
STM32_VIDEO_SURVEILLANCE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002e4bc  08000190  08000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002780  0802e650  0802e650  0002f650  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08030dd0  08030dd0  00032088  2**0
                  CONTENTS
  4 .ARM          00000008  08030dd0  08030dd0  00031dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08030dd8  08030dd8  00032088  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08030dd8  08030dd8  00031dd8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08030ddc  08030ddc  00031ddc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000088  20000000  08030de0  00032000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00032088  2**0
                  CONTENTS
 10 .bss          000031a0  20000088  20000088  00032088  2**3
                  ALLOC
 11 ._user_heap_stack 00000600  20003228  20003228  00032088  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00032088  2**0
                  CONTENTS, READONLY
 13 .debug_info   000665a8  00000000  00000000  000320b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00009b3b  00000000  00000000  00098660  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001d40  00000000  00000000  000a21a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000160c  00000000  00000000  000a3ee0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000297a1  00000000  00000000  000a54ec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00048a91  00000000  00000000  000cec8d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00088640  00000000  00000000  0011771e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  0019fd5e  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00007cf8  00000000  00000000  0019fda4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000075  00000000  00000000  001a7a9c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	@ (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	@ (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000088 	.word	0x20000088
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0802e634 	.word	0x0802e634

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	@ (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	@ (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	@ (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	2000008c 	.word	0x2000008c
 80001cc:	0802e634 	.word	0x0802e634

080001d0 <memchr>:
 80001d0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80001d4:	2a10      	cmp	r2, #16
 80001d6:	db2b      	blt.n	8000230 <memchr+0x60>
 80001d8:	f010 0f07 	tst.w	r0, #7
 80001dc:	d008      	beq.n	80001f0 <memchr+0x20>
 80001de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001e2:	3a01      	subs	r2, #1
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d02d      	beq.n	8000244 <memchr+0x74>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	b342      	cbz	r2, 8000240 <memchr+0x70>
 80001ee:	d1f6      	bne.n	80001de <memchr+0xe>
 80001f0:	b4f0      	push	{r4, r5, r6, r7}
 80001f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001fa:	f022 0407 	bic.w	r4, r2, #7
 80001fe:	f07f 0700 	mvns.w	r7, #0
 8000202:	2300      	movs	r3, #0
 8000204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000208:	3c08      	subs	r4, #8
 800020a:	ea85 0501 	eor.w	r5, r5, r1
 800020e:	ea86 0601 	eor.w	r6, r6, r1
 8000212:	fa85 f547 	uadd8	r5, r5, r7
 8000216:	faa3 f587 	sel	r5, r3, r7
 800021a:	fa86 f647 	uadd8	r6, r6, r7
 800021e:	faa5 f687 	sel	r6, r5, r7
 8000222:	b98e      	cbnz	r6, 8000248 <memchr+0x78>
 8000224:	d1ee      	bne.n	8000204 <memchr+0x34>
 8000226:	bcf0      	pop	{r4, r5, r6, r7}
 8000228:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800022c:	f002 0207 	and.w	r2, r2, #7
 8000230:	b132      	cbz	r2, 8000240 <memchr+0x70>
 8000232:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000236:	3a01      	subs	r2, #1
 8000238:	ea83 0301 	eor.w	r3, r3, r1
 800023c:	b113      	cbz	r3, 8000244 <memchr+0x74>
 800023e:	d1f8      	bne.n	8000232 <memchr+0x62>
 8000240:	2000      	movs	r0, #0
 8000242:	4770      	bx	lr
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr
 8000248:	2d00      	cmp	r5, #0
 800024a:	bf06      	itte	eq
 800024c:	4635      	moveq	r5, r6
 800024e:	3803      	subeq	r0, #3
 8000250:	3807      	subne	r0, #7
 8000252:	f015 0f01 	tst.w	r5, #1
 8000256:	d107      	bne.n	8000268 <memchr+0x98>
 8000258:	3001      	adds	r0, #1
 800025a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800025e:	bf02      	ittt	eq
 8000260:	3001      	addeq	r0, #1
 8000262:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000266:	3001      	addeq	r0, #1
 8000268:	bcf0      	pop	{r4, r5, r6, r7}
 800026a:	3801      	subs	r0, #1
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop

08000270 <__aeabi_drsub>:
 8000270:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000274:	e002      	b.n	800027c <__adddf3>
 8000276:	bf00      	nop

08000278 <__aeabi_dsub>:
 8000278:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800027c <__adddf3>:
 800027c:	b530      	push	{r4, r5, lr}
 800027e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000282:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000286:	ea94 0f05 	teq	r4, r5
 800028a:	bf08      	it	eq
 800028c:	ea90 0f02 	teqeq	r0, r2
 8000290:	bf1f      	itttt	ne
 8000292:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000296:	ea55 0c02 	orrsne.w	ip, r5, r2
 800029a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800029e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002a2:	f000 80e2 	beq.w	800046a <__adddf3+0x1ee>
 80002a6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002aa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ae:	bfb8      	it	lt
 80002b0:	426d      	neglt	r5, r5
 80002b2:	dd0c      	ble.n	80002ce <__adddf3+0x52>
 80002b4:	442c      	add	r4, r5
 80002b6:	ea80 0202 	eor.w	r2, r0, r2
 80002ba:	ea81 0303 	eor.w	r3, r1, r3
 80002be:	ea82 0000 	eor.w	r0, r2, r0
 80002c2:	ea83 0101 	eor.w	r1, r3, r1
 80002c6:	ea80 0202 	eor.w	r2, r0, r2
 80002ca:	ea81 0303 	eor.w	r3, r1, r3
 80002ce:	2d36      	cmp	r5, #54	@ 0x36
 80002d0:	bf88      	it	hi
 80002d2:	bd30      	pophi	{r4, r5, pc}
 80002d4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80002d8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002dc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80002e0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002e4:	d002      	beq.n	80002ec <__adddf3+0x70>
 80002e6:	4240      	negs	r0, r0
 80002e8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002ec:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80002f0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002f4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002f8:	d002      	beq.n	8000300 <__adddf3+0x84>
 80002fa:	4252      	negs	r2, r2
 80002fc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000300:	ea94 0f05 	teq	r4, r5
 8000304:	f000 80a7 	beq.w	8000456 <__adddf3+0x1da>
 8000308:	f1a4 0401 	sub.w	r4, r4, #1
 800030c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000310:	db0d      	blt.n	800032e <__adddf3+0xb2>
 8000312:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000316:	fa22 f205 	lsr.w	r2, r2, r5
 800031a:	1880      	adds	r0, r0, r2
 800031c:	f141 0100 	adc.w	r1, r1, #0
 8000320:	fa03 f20e 	lsl.w	r2, r3, lr
 8000324:	1880      	adds	r0, r0, r2
 8000326:	fa43 f305 	asr.w	r3, r3, r5
 800032a:	4159      	adcs	r1, r3
 800032c:	e00e      	b.n	800034c <__adddf3+0xd0>
 800032e:	f1a5 0520 	sub.w	r5, r5, #32
 8000332:	f10e 0e20 	add.w	lr, lr, #32
 8000336:	2a01      	cmp	r2, #1
 8000338:	fa03 fc0e 	lsl.w	ip, r3, lr
 800033c:	bf28      	it	cs
 800033e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000342:	fa43 f305 	asr.w	r3, r3, r5
 8000346:	18c0      	adds	r0, r0, r3
 8000348:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800034c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000350:	d507      	bpl.n	8000362 <__adddf3+0xe6>
 8000352:	f04f 0e00 	mov.w	lr, #0
 8000356:	f1dc 0c00 	rsbs	ip, ip, #0
 800035a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800035e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000362:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000366:	d31b      	bcc.n	80003a0 <__adddf3+0x124>
 8000368:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800036c:	d30c      	bcc.n	8000388 <__adddf3+0x10c>
 800036e:	0849      	lsrs	r1, r1, #1
 8000370:	ea5f 0030 	movs.w	r0, r0, rrx
 8000374:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000378:	f104 0401 	add.w	r4, r4, #1
 800037c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000380:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8000384:	f080 809a 	bcs.w	80004bc <__adddf3+0x240>
 8000388:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800038c:	bf08      	it	eq
 800038e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000392:	f150 0000 	adcs.w	r0, r0, #0
 8000396:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800039a:	ea41 0105 	orr.w	r1, r1, r5
 800039e:	bd30      	pop	{r4, r5, pc}
 80003a0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003a4:	4140      	adcs	r0, r0
 80003a6:	eb41 0101 	adc.w	r1, r1, r1
 80003aa:	3c01      	subs	r4, #1
 80003ac:	bf28      	it	cs
 80003ae:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80003b2:	d2e9      	bcs.n	8000388 <__adddf3+0x10c>
 80003b4:	f091 0f00 	teq	r1, #0
 80003b8:	bf04      	itt	eq
 80003ba:	4601      	moveq	r1, r0
 80003bc:	2000      	moveq	r0, #0
 80003be:	fab1 f381 	clz	r3, r1
 80003c2:	bf08      	it	eq
 80003c4:	3320      	addeq	r3, #32
 80003c6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ca:	f1b3 0220 	subs.w	r2, r3, #32
 80003ce:	da0c      	bge.n	80003ea <__adddf3+0x16e>
 80003d0:	320c      	adds	r2, #12
 80003d2:	dd08      	ble.n	80003e6 <__adddf3+0x16a>
 80003d4:	f102 0c14 	add.w	ip, r2, #20
 80003d8:	f1c2 020c 	rsb	r2, r2, #12
 80003dc:	fa01 f00c 	lsl.w	r0, r1, ip
 80003e0:	fa21 f102 	lsr.w	r1, r1, r2
 80003e4:	e00c      	b.n	8000400 <__adddf3+0x184>
 80003e6:	f102 0214 	add.w	r2, r2, #20
 80003ea:	bfd8      	it	le
 80003ec:	f1c2 0c20 	rsble	ip, r2, #32
 80003f0:	fa01 f102 	lsl.w	r1, r1, r2
 80003f4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003f8:	bfdc      	itt	le
 80003fa:	ea41 010c 	orrle.w	r1, r1, ip
 80003fe:	4090      	lslle	r0, r2
 8000400:	1ae4      	subs	r4, r4, r3
 8000402:	bfa2      	ittt	ge
 8000404:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000408:	4329      	orrge	r1, r5
 800040a:	bd30      	popge	{r4, r5, pc}
 800040c:	ea6f 0404 	mvn.w	r4, r4
 8000410:	3c1f      	subs	r4, #31
 8000412:	da1c      	bge.n	800044e <__adddf3+0x1d2>
 8000414:	340c      	adds	r4, #12
 8000416:	dc0e      	bgt.n	8000436 <__adddf3+0x1ba>
 8000418:	f104 0414 	add.w	r4, r4, #20
 800041c:	f1c4 0220 	rsb	r2, r4, #32
 8000420:	fa20 f004 	lsr.w	r0, r0, r4
 8000424:	fa01 f302 	lsl.w	r3, r1, r2
 8000428:	ea40 0003 	orr.w	r0, r0, r3
 800042c:	fa21 f304 	lsr.w	r3, r1, r4
 8000430:	ea45 0103 	orr.w	r1, r5, r3
 8000434:	bd30      	pop	{r4, r5, pc}
 8000436:	f1c4 040c 	rsb	r4, r4, #12
 800043a:	f1c4 0220 	rsb	r2, r4, #32
 800043e:	fa20 f002 	lsr.w	r0, r0, r2
 8000442:	fa01 f304 	lsl.w	r3, r1, r4
 8000446:	ea40 0003 	orr.w	r0, r0, r3
 800044a:	4629      	mov	r1, r5
 800044c:	bd30      	pop	{r4, r5, pc}
 800044e:	fa21 f004 	lsr.w	r0, r1, r4
 8000452:	4629      	mov	r1, r5
 8000454:	bd30      	pop	{r4, r5, pc}
 8000456:	f094 0f00 	teq	r4, #0
 800045a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800045e:	bf06      	itte	eq
 8000460:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000464:	3401      	addeq	r4, #1
 8000466:	3d01      	subne	r5, #1
 8000468:	e74e      	b.n	8000308 <__adddf3+0x8c>
 800046a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800046e:	bf18      	it	ne
 8000470:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000474:	d029      	beq.n	80004ca <__adddf3+0x24e>
 8000476:	ea94 0f05 	teq	r4, r5
 800047a:	bf08      	it	eq
 800047c:	ea90 0f02 	teqeq	r0, r2
 8000480:	d005      	beq.n	800048e <__adddf3+0x212>
 8000482:	ea54 0c00 	orrs.w	ip, r4, r0
 8000486:	bf04      	itt	eq
 8000488:	4619      	moveq	r1, r3
 800048a:	4610      	moveq	r0, r2
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	ea91 0f03 	teq	r1, r3
 8000492:	bf1e      	ittt	ne
 8000494:	2100      	movne	r1, #0
 8000496:	2000      	movne	r0, #0
 8000498:	bd30      	popne	{r4, r5, pc}
 800049a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800049e:	d105      	bne.n	80004ac <__adddf3+0x230>
 80004a0:	0040      	lsls	r0, r0, #1
 80004a2:	4149      	adcs	r1, r1
 80004a4:	bf28      	it	cs
 80004a6:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80004aa:	bd30      	pop	{r4, r5, pc}
 80004ac:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80004b0:	bf3c      	itt	cc
 80004b2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80004b6:	bd30      	popcc	{r4, r5, pc}
 80004b8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004bc:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80004c0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80004c4:	f04f 0000 	mov.w	r0, #0
 80004c8:	bd30      	pop	{r4, r5, pc}
 80004ca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ce:	bf1a      	itte	ne
 80004d0:	4619      	movne	r1, r3
 80004d2:	4610      	movne	r0, r2
 80004d4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004d8:	bf1c      	itt	ne
 80004da:	460b      	movne	r3, r1
 80004dc:	4602      	movne	r2, r0
 80004de:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004e2:	bf06      	itte	eq
 80004e4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004e8:	ea91 0f03 	teqeq	r1, r3
 80004ec:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80004f0:	bd30      	pop	{r4, r5, pc}
 80004f2:	bf00      	nop

080004f4 <__aeabi_ui2d>:
 80004f4:	f090 0f00 	teq	r0, #0
 80004f8:	bf04      	itt	eq
 80004fa:	2100      	moveq	r1, #0
 80004fc:	4770      	bxeq	lr
 80004fe:	b530      	push	{r4, r5, lr}
 8000500:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000504:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000508:	f04f 0500 	mov.w	r5, #0
 800050c:	f04f 0100 	mov.w	r1, #0
 8000510:	e750      	b.n	80003b4 <__adddf3+0x138>
 8000512:	bf00      	nop

08000514 <__aeabi_i2d>:
 8000514:	f090 0f00 	teq	r0, #0
 8000518:	bf04      	itt	eq
 800051a:	2100      	moveq	r1, #0
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000524:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000528:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 800052c:	bf48      	it	mi
 800052e:	4240      	negmi	r0, r0
 8000530:	f04f 0100 	mov.w	r1, #0
 8000534:	e73e      	b.n	80003b4 <__adddf3+0x138>
 8000536:	bf00      	nop

08000538 <__aeabi_f2d>:
 8000538:	0042      	lsls	r2, r0, #1
 800053a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800053e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000542:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000546:	bf1f      	itttt	ne
 8000548:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 800054c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000550:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000554:	4770      	bxne	lr
 8000556:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800055a:	bf08      	it	eq
 800055c:	4770      	bxeq	lr
 800055e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000562:	bf04      	itt	eq
 8000564:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000568:	4770      	bxeq	lr
 800056a:	b530      	push	{r4, r5, lr}
 800056c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000570:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000574:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000578:	e71c      	b.n	80003b4 <__adddf3+0x138>
 800057a:	bf00      	nop

0800057c <__aeabi_ul2d>:
 800057c:	ea50 0201 	orrs.w	r2, r0, r1
 8000580:	bf08      	it	eq
 8000582:	4770      	bxeq	lr
 8000584:	b530      	push	{r4, r5, lr}
 8000586:	f04f 0500 	mov.w	r5, #0
 800058a:	e00a      	b.n	80005a2 <__aeabi_l2d+0x16>

0800058c <__aeabi_l2d>:
 800058c:	ea50 0201 	orrs.w	r2, r0, r1
 8000590:	bf08      	it	eq
 8000592:	4770      	bxeq	lr
 8000594:	b530      	push	{r4, r5, lr}
 8000596:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 800059a:	d502      	bpl.n	80005a2 <__aeabi_l2d+0x16>
 800059c:	4240      	negs	r0, r0
 800059e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005a2:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005a6:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005aa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ae:	f43f aed8 	beq.w	8000362 <__adddf3+0xe6>
 80005b2:	f04f 0203 	mov.w	r2, #3
 80005b6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ba:	bf18      	it	ne
 80005bc:	3203      	addne	r2, #3
 80005be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005c2:	bf18      	it	ne
 80005c4:	3203      	addne	r2, #3
 80005c6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005ca:	f1c2 0320 	rsb	r3, r2, #32
 80005ce:	fa00 fc03 	lsl.w	ip, r0, r3
 80005d2:	fa20 f002 	lsr.w	r0, r0, r2
 80005d6:	fa01 fe03 	lsl.w	lr, r1, r3
 80005da:	ea40 000e 	orr.w	r0, r0, lr
 80005de:	fa21 f102 	lsr.w	r1, r1, r2
 80005e2:	4414      	add	r4, r2
 80005e4:	e6bd      	b.n	8000362 <__adddf3+0xe6>
 80005e6:	bf00      	nop

080005e8 <__aeabi_dmul>:
 80005e8:	b570      	push	{r4, r5, r6, lr}
 80005ea:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80005ee:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80005f2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005f6:	bf1d      	ittte	ne
 80005f8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005fc:	ea94 0f0c 	teqne	r4, ip
 8000600:	ea95 0f0c 	teqne	r5, ip
 8000604:	f000 f8de 	bleq	80007c4 <__aeabi_dmul+0x1dc>
 8000608:	442c      	add	r4, r5
 800060a:	ea81 0603 	eor.w	r6, r1, r3
 800060e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000612:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000616:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800061a:	bf18      	it	ne
 800061c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000620:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000624:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000628:	d038      	beq.n	800069c <__aeabi_dmul+0xb4>
 800062a:	fba0 ce02 	umull	ip, lr, r0, r2
 800062e:	f04f 0500 	mov.w	r5, #0
 8000632:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000636:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 800063a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800063e:	f04f 0600 	mov.w	r6, #0
 8000642:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000646:	f09c 0f00 	teq	ip, #0
 800064a:	bf18      	it	ne
 800064c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000650:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000654:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000658:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 800065c:	d204      	bcs.n	8000668 <__aeabi_dmul+0x80>
 800065e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000662:	416d      	adcs	r5, r5
 8000664:	eb46 0606 	adc.w	r6, r6, r6
 8000668:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800066c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000670:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000674:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000678:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800067c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8000680:	bf88      	it	hi
 8000682:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000686:	d81e      	bhi.n	80006c6 <__aeabi_dmul+0xde>
 8000688:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 800068c:	bf08      	it	eq
 800068e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000692:	f150 0000 	adcs.w	r0, r0, #0
 8000696:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800069a:	bd70      	pop	{r4, r5, r6, pc}
 800069c:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 80006a0:	ea46 0101 	orr.w	r1, r6, r1
 80006a4:	ea40 0002 	orr.w	r0, r0, r2
 80006a8:	ea81 0103 	eor.w	r1, r1, r3
 80006ac:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006b0:	bfc2      	ittt	gt
 80006b2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006b6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006ba:	bd70      	popgt	{r4, r5, r6, pc}
 80006bc:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80006c0:	f04f 0e00 	mov.w	lr, #0
 80006c4:	3c01      	subs	r4, #1
 80006c6:	f300 80ab 	bgt.w	8000820 <__aeabi_dmul+0x238>
 80006ca:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80006ce:	bfde      	ittt	le
 80006d0:	2000      	movle	r0, #0
 80006d2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80006d6:	bd70      	pople	{r4, r5, r6, pc}
 80006d8:	f1c4 0400 	rsb	r4, r4, #0
 80006dc:	3c20      	subs	r4, #32
 80006de:	da35      	bge.n	800074c <__aeabi_dmul+0x164>
 80006e0:	340c      	adds	r4, #12
 80006e2:	dc1b      	bgt.n	800071c <__aeabi_dmul+0x134>
 80006e4:	f104 0414 	add.w	r4, r4, #20
 80006e8:	f1c4 0520 	rsb	r5, r4, #32
 80006ec:	fa00 f305 	lsl.w	r3, r0, r5
 80006f0:	fa20 f004 	lsr.w	r0, r0, r4
 80006f4:	fa01 f205 	lsl.w	r2, r1, r5
 80006f8:	ea40 0002 	orr.w	r0, r0, r2
 80006fc:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000700:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000704:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000708:	fa21 f604 	lsr.w	r6, r1, r4
 800070c:	eb42 0106 	adc.w	r1, r2, r6
 8000710:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000714:	bf08      	it	eq
 8000716:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800071a:	bd70      	pop	{r4, r5, r6, pc}
 800071c:	f1c4 040c 	rsb	r4, r4, #12
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f304 	lsl.w	r3, r0, r4
 8000728:	fa20 f005 	lsr.w	r0, r0, r5
 800072c:	fa01 f204 	lsl.w	r2, r1, r4
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000738:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800073c:	f141 0100 	adc.w	r1, r1, #0
 8000740:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000744:	bf08      	it	eq
 8000746:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800074a:	bd70      	pop	{r4, r5, r6, pc}
 800074c:	f1c4 0520 	rsb	r5, r4, #32
 8000750:	fa00 f205 	lsl.w	r2, r0, r5
 8000754:	ea4e 0e02 	orr.w	lr, lr, r2
 8000758:	fa20 f304 	lsr.w	r3, r0, r4
 800075c:	fa01 f205 	lsl.w	r2, r1, r5
 8000760:	ea43 0302 	orr.w	r3, r3, r2
 8000764:	fa21 f004 	lsr.w	r0, r1, r4
 8000768:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800076c:	fa21 f204 	lsr.w	r2, r1, r4
 8000770:	ea20 0002 	bic.w	r0, r0, r2
 8000774:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f094 0f00 	teq	r4, #0
 8000788:	d10f      	bne.n	80007aa <__aeabi_dmul+0x1c2>
 800078a:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 800078e:	0040      	lsls	r0, r0, #1
 8000790:	eb41 0101 	adc.w	r1, r1, r1
 8000794:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000798:	bf08      	it	eq
 800079a:	3c01      	subeq	r4, #1
 800079c:	d0f7      	beq.n	800078e <__aeabi_dmul+0x1a6>
 800079e:	ea41 0106 	orr.w	r1, r1, r6
 80007a2:	f095 0f00 	teq	r5, #0
 80007a6:	bf18      	it	ne
 80007a8:	4770      	bxne	lr
 80007aa:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 80007ae:	0052      	lsls	r2, r2, #1
 80007b0:	eb43 0303 	adc.w	r3, r3, r3
 80007b4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80007b8:	bf08      	it	eq
 80007ba:	3d01      	subeq	r5, #1
 80007bc:	d0f7      	beq.n	80007ae <__aeabi_dmul+0x1c6>
 80007be:	ea43 0306 	orr.w	r3, r3, r6
 80007c2:	4770      	bx	lr
 80007c4:	ea94 0f0c 	teq	r4, ip
 80007c8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007cc:	bf18      	it	ne
 80007ce:	ea95 0f0c 	teqne	r5, ip
 80007d2:	d00c      	beq.n	80007ee <__aeabi_dmul+0x206>
 80007d4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007d8:	bf18      	it	ne
 80007da:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007de:	d1d1      	bne.n	8000784 <__aeabi_dmul+0x19c>
 80007e0:	ea81 0103 	eor.w	r1, r1, r3
 80007e4:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80007e8:	f04f 0000 	mov.w	r0, #0
 80007ec:	bd70      	pop	{r4, r5, r6, pc}
 80007ee:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007f2:	bf06      	itte	eq
 80007f4:	4610      	moveq	r0, r2
 80007f6:	4619      	moveq	r1, r3
 80007f8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007fc:	d019      	beq.n	8000832 <__aeabi_dmul+0x24a>
 80007fe:	ea94 0f0c 	teq	r4, ip
 8000802:	d102      	bne.n	800080a <__aeabi_dmul+0x222>
 8000804:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000808:	d113      	bne.n	8000832 <__aeabi_dmul+0x24a>
 800080a:	ea95 0f0c 	teq	r5, ip
 800080e:	d105      	bne.n	800081c <__aeabi_dmul+0x234>
 8000810:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000814:	bf1c      	itt	ne
 8000816:	4610      	movne	r0, r2
 8000818:	4619      	movne	r1, r3
 800081a:	d10a      	bne.n	8000832 <__aeabi_dmul+0x24a>
 800081c:	ea81 0103 	eor.w	r1, r1, r3
 8000820:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000824:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000828:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800082c:	f04f 0000 	mov.w	r0, #0
 8000830:	bd70      	pop	{r4, r5, r6, pc}
 8000832:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000836:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 800083a:	bd70      	pop	{r4, r5, r6, pc}

0800083c <__aeabi_ddiv>:
 800083c:	b570      	push	{r4, r5, r6, lr}
 800083e:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000842:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000846:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800084a:	bf1d      	ittte	ne
 800084c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000850:	ea94 0f0c 	teqne	r4, ip
 8000854:	ea95 0f0c 	teqne	r5, ip
 8000858:	f000 f8a7 	bleq	80009aa <__aeabi_ddiv+0x16e>
 800085c:	eba4 0405 	sub.w	r4, r4, r5
 8000860:	ea81 0e03 	eor.w	lr, r1, r3
 8000864:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000868:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800086c:	f000 8088 	beq.w	8000980 <__aeabi_ddiv+0x144>
 8000870:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000874:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8000878:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800087c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000880:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000884:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000888:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800088c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000890:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 8000894:	429d      	cmp	r5, r3
 8000896:	bf08      	it	eq
 8000898:	4296      	cmpeq	r6, r2
 800089a:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 800089e:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 80008a2:	d202      	bcs.n	80008aa <__aeabi_ddiv+0x6e>
 80008a4:	085b      	lsrs	r3, r3, #1
 80008a6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008aa:	1ab6      	subs	r6, r6, r2
 80008ac:	eb65 0503 	sbc.w	r5, r5, r3
 80008b0:	085b      	lsrs	r3, r3, #1
 80008b2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008b6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80008ba:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80008be:	ebb6 0e02 	subs.w	lr, r6, r2
 80008c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008c6:	bf22      	ittt	cs
 80008c8:	1ab6      	subcs	r6, r6, r2
 80008ca:	4675      	movcs	r5, lr
 80008cc:	ea40 000c 	orrcs.w	r0, r0, ip
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008de:	bf22      	ittt	cs
 80008e0:	1ab6      	subcs	r6, r6, r2
 80008e2:	4675      	movcs	r5, lr
 80008e4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f6:	bf22      	ittt	cs
 80008f8:	1ab6      	subcs	r6, r6, r2
 80008fa:	4675      	movcs	r5, lr
 80008fc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	ebb6 0e02 	subs.w	lr, r6, r2
 800090a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800090e:	bf22      	ittt	cs
 8000910:	1ab6      	subcs	r6, r6, r2
 8000912:	4675      	movcs	r5, lr
 8000914:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000918:	ea55 0e06 	orrs.w	lr, r5, r6
 800091c:	d018      	beq.n	8000950 <__aeabi_ddiv+0x114>
 800091e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000922:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000926:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800092a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800092e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000932:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000936:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800093a:	d1c0      	bne.n	80008be <__aeabi_ddiv+0x82>
 800093c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000940:	d10b      	bne.n	800095a <__aeabi_ddiv+0x11e>
 8000942:	ea41 0100 	orr.w	r1, r1, r0
 8000946:	f04f 0000 	mov.w	r0, #0
 800094a:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 800094e:	e7b6      	b.n	80008be <__aeabi_ddiv+0x82>
 8000950:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000954:	bf04      	itt	eq
 8000956:	4301      	orreq	r1, r0
 8000958:	2000      	moveq	r0, #0
 800095a:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 800095e:	bf88      	it	hi
 8000960:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000964:	f63f aeaf 	bhi.w	80006c6 <__aeabi_dmul+0xde>
 8000968:	ebb5 0c03 	subs.w	ip, r5, r3
 800096c:	bf04      	itt	eq
 800096e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000972:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000976:	f150 0000 	adcs.w	r0, r0, #0
 800097a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800097e:	bd70      	pop	{r4, r5, r6, pc}
 8000980:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 8000984:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000988:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800098c:	bfc2      	ittt	gt
 800098e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000992:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000996:	bd70      	popgt	{r4, r5, r6, pc}
 8000998:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 800099c:	f04f 0e00 	mov.w	lr, #0
 80009a0:	3c01      	subs	r4, #1
 80009a2:	e690      	b.n	80006c6 <__aeabi_dmul+0xde>
 80009a4:	ea45 0e06 	orr.w	lr, r5, r6
 80009a8:	e68d      	b.n	80006c6 <__aeabi_dmul+0xde>
 80009aa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009ae:	ea94 0f0c 	teq	r4, ip
 80009b2:	bf08      	it	eq
 80009b4:	ea95 0f0c 	teqeq	r5, ip
 80009b8:	f43f af3b 	beq.w	8000832 <__aeabi_dmul+0x24a>
 80009bc:	ea94 0f0c 	teq	r4, ip
 80009c0:	d10a      	bne.n	80009d8 <__aeabi_ddiv+0x19c>
 80009c2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009c6:	f47f af34 	bne.w	8000832 <__aeabi_dmul+0x24a>
 80009ca:	ea95 0f0c 	teq	r5, ip
 80009ce:	f47f af25 	bne.w	800081c <__aeabi_dmul+0x234>
 80009d2:	4610      	mov	r0, r2
 80009d4:	4619      	mov	r1, r3
 80009d6:	e72c      	b.n	8000832 <__aeabi_dmul+0x24a>
 80009d8:	ea95 0f0c 	teq	r5, ip
 80009dc:	d106      	bne.n	80009ec <__aeabi_ddiv+0x1b0>
 80009de:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009e2:	f43f aefd 	beq.w	80007e0 <__aeabi_dmul+0x1f8>
 80009e6:	4610      	mov	r0, r2
 80009e8:	4619      	mov	r1, r3
 80009ea:	e722      	b.n	8000832 <__aeabi_dmul+0x24a>
 80009ec:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009f0:	bf18      	it	ne
 80009f2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009f6:	f47f aec5 	bne.w	8000784 <__aeabi_dmul+0x19c>
 80009fa:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009fe:	f47f af0d 	bne.w	800081c <__aeabi_dmul+0x234>
 8000a02:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a06:	f47f aeeb 	bne.w	80007e0 <__aeabi_dmul+0x1f8>
 8000a0a:	e712      	b.n	8000832 <__aeabi_dmul+0x24a>

08000a0c <__aeabi_d2f>:
 8000a0c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a10:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000a14:	bf24      	itt	cs
 8000a16:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000a1a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000a1e:	d90d      	bls.n	8000a3c <__aeabi_d2f+0x30>
 8000a20:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000a24:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a28:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a2c:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000a30:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a34:	bf08      	it	eq
 8000a36:	f020 0001 	biceq.w	r0, r0, #1
 8000a3a:	4770      	bx	lr
 8000a3c:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000a40:	d121      	bne.n	8000a86 <__aeabi_d2f+0x7a>
 8000a42:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000a46:	bfbc      	itt	lt
 8000a48:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000a4c:	4770      	bxlt	lr
 8000a4e:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000a52:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a56:	f1c2 0218 	rsb	r2, r2, #24
 8000a5a:	f1c2 0c20 	rsb	ip, r2, #32
 8000a5e:	fa10 f30c 	lsls.w	r3, r0, ip
 8000a62:	fa20 f002 	lsr.w	r0, r0, r2
 8000a66:	bf18      	it	ne
 8000a68:	f040 0001 	orrne.w	r0, r0, #1
 8000a6c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a70:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000a74:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000a78:	ea40 000c 	orr.w	r0, r0, ip
 8000a7c:	fa23 f302 	lsr.w	r3, r3, r2
 8000a80:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000a84:	e7cc      	b.n	8000a20 <__aeabi_d2f+0x14>
 8000a86:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000a8a:	d107      	bne.n	8000a9c <__aeabi_d2f+0x90>
 8000a8c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000a90:	bf1e      	ittt	ne
 8000a92:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000a96:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000a9a:	4770      	bxne	lr
 8000a9c:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000aa0:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000aa4:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000aa8:	4770      	bx	lr
 8000aaa:	bf00      	nop

08000aac <__aeabi_uldivmod>:
 8000aac:	b953      	cbnz	r3, 8000ac4 <__aeabi_uldivmod+0x18>
 8000aae:	b94a      	cbnz	r2, 8000ac4 <__aeabi_uldivmod+0x18>
 8000ab0:	2900      	cmp	r1, #0
 8000ab2:	bf08      	it	eq
 8000ab4:	2800      	cmpeq	r0, #0
 8000ab6:	bf1c      	itt	ne
 8000ab8:	f04f 31ff 	movne.w	r1, #4294967295
 8000abc:	f04f 30ff 	movne.w	r0, #4294967295
 8000ac0:	f000 b96a 	b.w	8000d98 <__aeabi_idiv0>
 8000ac4:	f1ad 0c08 	sub.w	ip, sp, #8
 8000ac8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000acc:	f000 f806 	bl	8000adc <__udivmoddi4>
 8000ad0:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000ad4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ad8:	b004      	add	sp, #16
 8000ada:	4770      	bx	lr

08000adc <__udivmoddi4>:
 8000adc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000ae0:	9d08      	ldr	r5, [sp, #32]
 8000ae2:	460c      	mov	r4, r1
 8000ae4:	2b00      	cmp	r3, #0
 8000ae6:	d14e      	bne.n	8000b86 <__udivmoddi4+0xaa>
 8000ae8:	4694      	mov	ip, r2
 8000aea:	458c      	cmp	ip, r1
 8000aec:	4686      	mov	lr, r0
 8000aee:	fab2 f282 	clz	r2, r2
 8000af2:	d962      	bls.n	8000bba <__udivmoddi4+0xde>
 8000af4:	b14a      	cbz	r2, 8000b0a <__udivmoddi4+0x2e>
 8000af6:	f1c2 0320 	rsb	r3, r2, #32
 8000afa:	4091      	lsls	r1, r2
 8000afc:	fa20 f303 	lsr.w	r3, r0, r3
 8000b00:	fa0c fc02 	lsl.w	ip, ip, r2
 8000b04:	4319      	orrs	r1, r3
 8000b06:	fa00 fe02 	lsl.w	lr, r0, r2
 8000b0a:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000b0e:	fa1f f68c 	uxth.w	r6, ip
 8000b12:	fbb1 f4f7 	udiv	r4, r1, r7
 8000b16:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000b1a:	fb07 1114 	mls	r1, r7, r4, r1
 8000b1e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b22:	fb04 f106 	mul.w	r1, r4, r6
 8000b26:	4299      	cmp	r1, r3
 8000b28:	d90a      	bls.n	8000b40 <__udivmoddi4+0x64>
 8000b2a:	eb1c 0303 	adds.w	r3, ip, r3
 8000b2e:	f104 30ff 	add.w	r0, r4, #4294967295
 8000b32:	f080 8112 	bcs.w	8000d5a <__udivmoddi4+0x27e>
 8000b36:	4299      	cmp	r1, r3
 8000b38:	f240 810f 	bls.w	8000d5a <__udivmoddi4+0x27e>
 8000b3c:	3c02      	subs	r4, #2
 8000b3e:	4463      	add	r3, ip
 8000b40:	1a59      	subs	r1, r3, r1
 8000b42:	fa1f f38e 	uxth.w	r3, lr
 8000b46:	fbb1 f0f7 	udiv	r0, r1, r7
 8000b4a:	fb07 1110 	mls	r1, r7, r0, r1
 8000b4e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b52:	fb00 f606 	mul.w	r6, r0, r6
 8000b56:	429e      	cmp	r6, r3
 8000b58:	d90a      	bls.n	8000b70 <__udivmoddi4+0x94>
 8000b5a:	eb1c 0303 	adds.w	r3, ip, r3
 8000b5e:	f100 31ff 	add.w	r1, r0, #4294967295
 8000b62:	f080 80fc 	bcs.w	8000d5e <__udivmoddi4+0x282>
 8000b66:	429e      	cmp	r6, r3
 8000b68:	f240 80f9 	bls.w	8000d5e <__udivmoddi4+0x282>
 8000b6c:	4463      	add	r3, ip
 8000b6e:	3802      	subs	r0, #2
 8000b70:	1b9b      	subs	r3, r3, r6
 8000b72:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000b76:	2100      	movs	r1, #0
 8000b78:	b11d      	cbz	r5, 8000b82 <__udivmoddi4+0xa6>
 8000b7a:	40d3      	lsrs	r3, r2
 8000b7c:	2200      	movs	r2, #0
 8000b7e:	e9c5 3200 	strd	r3, r2, [r5]
 8000b82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b86:	428b      	cmp	r3, r1
 8000b88:	d905      	bls.n	8000b96 <__udivmoddi4+0xba>
 8000b8a:	b10d      	cbz	r5, 8000b90 <__udivmoddi4+0xb4>
 8000b8c:	e9c5 0100 	strd	r0, r1, [r5]
 8000b90:	2100      	movs	r1, #0
 8000b92:	4608      	mov	r0, r1
 8000b94:	e7f5      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000b96:	fab3 f183 	clz	r1, r3
 8000b9a:	2900      	cmp	r1, #0
 8000b9c:	d146      	bne.n	8000c2c <__udivmoddi4+0x150>
 8000b9e:	42a3      	cmp	r3, r4
 8000ba0:	d302      	bcc.n	8000ba8 <__udivmoddi4+0xcc>
 8000ba2:	4290      	cmp	r0, r2
 8000ba4:	f0c0 80f0 	bcc.w	8000d88 <__udivmoddi4+0x2ac>
 8000ba8:	1a86      	subs	r6, r0, r2
 8000baa:	eb64 0303 	sbc.w	r3, r4, r3
 8000bae:	2001      	movs	r0, #1
 8000bb0:	2d00      	cmp	r5, #0
 8000bb2:	d0e6      	beq.n	8000b82 <__udivmoddi4+0xa6>
 8000bb4:	e9c5 6300 	strd	r6, r3, [r5]
 8000bb8:	e7e3      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000bba:	2a00      	cmp	r2, #0
 8000bbc:	f040 8090 	bne.w	8000ce0 <__udivmoddi4+0x204>
 8000bc0:	eba1 040c 	sub.w	r4, r1, ip
 8000bc4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000bc8:	fa1f f78c 	uxth.w	r7, ip
 8000bcc:	2101      	movs	r1, #1
 8000bce:	fbb4 f6f8 	udiv	r6, r4, r8
 8000bd2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000bd6:	fb08 4416 	mls	r4, r8, r6, r4
 8000bda:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000bde:	fb07 f006 	mul.w	r0, r7, r6
 8000be2:	4298      	cmp	r0, r3
 8000be4:	d908      	bls.n	8000bf8 <__udivmoddi4+0x11c>
 8000be6:	eb1c 0303 	adds.w	r3, ip, r3
 8000bea:	f106 34ff 	add.w	r4, r6, #4294967295
 8000bee:	d202      	bcs.n	8000bf6 <__udivmoddi4+0x11a>
 8000bf0:	4298      	cmp	r0, r3
 8000bf2:	f200 80cd 	bhi.w	8000d90 <__udivmoddi4+0x2b4>
 8000bf6:	4626      	mov	r6, r4
 8000bf8:	1a1c      	subs	r4, r3, r0
 8000bfa:	fa1f f38e 	uxth.w	r3, lr
 8000bfe:	fbb4 f0f8 	udiv	r0, r4, r8
 8000c02:	fb08 4410 	mls	r4, r8, r0, r4
 8000c06:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000c0a:	fb00 f707 	mul.w	r7, r0, r7
 8000c0e:	429f      	cmp	r7, r3
 8000c10:	d908      	bls.n	8000c24 <__udivmoddi4+0x148>
 8000c12:	eb1c 0303 	adds.w	r3, ip, r3
 8000c16:	f100 34ff 	add.w	r4, r0, #4294967295
 8000c1a:	d202      	bcs.n	8000c22 <__udivmoddi4+0x146>
 8000c1c:	429f      	cmp	r7, r3
 8000c1e:	f200 80b0 	bhi.w	8000d82 <__udivmoddi4+0x2a6>
 8000c22:	4620      	mov	r0, r4
 8000c24:	1bdb      	subs	r3, r3, r7
 8000c26:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000c2a:	e7a5      	b.n	8000b78 <__udivmoddi4+0x9c>
 8000c2c:	f1c1 0620 	rsb	r6, r1, #32
 8000c30:	408b      	lsls	r3, r1
 8000c32:	fa22 f706 	lsr.w	r7, r2, r6
 8000c36:	431f      	orrs	r7, r3
 8000c38:	fa20 fc06 	lsr.w	ip, r0, r6
 8000c3c:	fa04 f301 	lsl.w	r3, r4, r1
 8000c40:	ea43 030c 	orr.w	r3, r3, ip
 8000c44:	40f4      	lsrs	r4, r6
 8000c46:	fa00 f801 	lsl.w	r8, r0, r1
 8000c4a:	0c38      	lsrs	r0, r7, #16
 8000c4c:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000c50:	fbb4 fef0 	udiv	lr, r4, r0
 8000c54:	fa1f fc87 	uxth.w	ip, r7
 8000c58:	fb00 441e 	mls	r4, r0, lr, r4
 8000c5c:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000c60:	fb0e f90c 	mul.w	r9, lr, ip
 8000c64:	45a1      	cmp	r9, r4
 8000c66:	fa02 f201 	lsl.w	r2, r2, r1
 8000c6a:	d90a      	bls.n	8000c82 <__udivmoddi4+0x1a6>
 8000c6c:	193c      	adds	r4, r7, r4
 8000c6e:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000c72:	f080 8084 	bcs.w	8000d7e <__udivmoddi4+0x2a2>
 8000c76:	45a1      	cmp	r9, r4
 8000c78:	f240 8081 	bls.w	8000d7e <__udivmoddi4+0x2a2>
 8000c7c:	f1ae 0e02 	sub.w	lr, lr, #2
 8000c80:	443c      	add	r4, r7
 8000c82:	eba4 0409 	sub.w	r4, r4, r9
 8000c86:	fa1f f983 	uxth.w	r9, r3
 8000c8a:	fbb4 f3f0 	udiv	r3, r4, r0
 8000c8e:	fb00 4413 	mls	r4, r0, r3, r4
 8000c92:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000c96:	fb03 fc0c 	mul.w	ip, r3, ip
 8000c9a:	45a4      	cmp	ip, r4
 8000c9c:	d907      	bls.n	8000cae <__udivmoddi4+0x1d2>
 8000c9e:	193c      	adds	r4, r7, r4
 8000ca0:	f103 30ff 	add.w	r0, r3, #4294967295
 8000ca4:	d267      	bcs.n	8000d76 <__udivmoddi4+0x29a>
 8000ca6:	45a4      	cmp	ip, r4
 8000ca8:	d965      	bls.n	8000d76 <__udivmoddi4+0x29a>
 8000caa:	3b02      	subs	r3, #2
 8000cac:	443c      	add	r4, r7
 8000cae:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000cb2:	fba0 9302 	umull	r9, r3, r0, r2
 8000cb6:	eba4 040c 	sub.w	r4, r4, ip
 8000cba:	429c      	cmp	r4, r3
 8000cbc:	46ce      	mov	lr, r9
 8000cbe:	469c      	mov	ip, r3
 8000cc0:	d351      	bcc.n	8000d66 <__udivmoddi4+0x28a>
 8000cc2:	d04e      	beq.n	8000d62 <__udivmoddi4+0x286>
 8000cc4:	b155      	cbz	r5, 8000cdc <__udivmoddi4+0x200>
 8000cc6:	ebb8 030e 	subs.w	r3, r8, lr
 8000cca:	eb64 040c 	sbc.w	r4, r4, ip
 8000cce:	fa04 f606 	lsl.w	r6, r4, r6
 8000cd2:	40cb      	lsrs	r3, r1
 8000cd4:	431e      	orrs	r6, r3
 8000cd6:	40cc      	lsrs	r4, r1
 8000cd8:	e9c5 6400 	strd	r6, r4, [r5]
 8000cdc:	2100      	movs	r1, #0
 8000cde:	e750      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000ce0:	f1c2 0320 	rsb	r3, r2, #32
 8000ce4:	fa20 f103 	lsr.w	r1, r0, r3
 8000ce8:	fa0c fc02 	lsl.w	ip, ip, r2
 8000cec:	fa24 f303 	lsr.w	r3, r4, r3
 8000cf0:	4094      	lsls	r4, r2
 8000cf2:	430c      	orrs	r4, r1
 8000cf4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000cf8:	fa00 fe02 	lsl.w	lr, r0, r2
 8000cfc:	fa1f f78c 	uxth.w	r7, ip
 8000d00:	fbb3 f0f8 	udiv	r0, r3, r8
 8000d04:	fb08 3110 	mls	r1, r8, r0, r3
 8000d08:	0c23      	lsrs	r3, r4, #16
 8000d0a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000d0e:	fb00 f107 	mul.w	r1, r0, r7
 8000d12:	4299      	cmp	r1, r3
 8000d14:	d908      	bls.n	8000d28 <__udivmoddi4+0x24c>
 8000d16:	eb1c 0303 	adds.w	r3, ip, r3
 8000d1a:	f100 36ff 	add.w	r6, r0, #4294967295
 8000d1e:	d22c      	bcs.n	8000d7a <__udivmoddi4+0x29e>
 8000d20:	4299      	cmp	r1, r3
 8000d22:	d92a      	bls.n	8000d7a <__udivmoddi4+0x29e>
 8000d24:	3802      	subs	r0, #2
 8000d26:	4463      	add	r3, ip
 8000d28:	1a5b      	subs	r3, r3, r1
 8000d2a:	b2a4      	uxth	r4, r4
 8000d2c:	fbb3 f1f8 	udiv	r1, r3, r8
 8000d30:	fb08 3311 	mls	r3, r8, r1, r3
 8000d34:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000d38:	fb01 f307 	mul.w	r3, r1, r7
 8000d3c:	42a3      	cmp	r3, r4
 8000d3e:	d908      	bls.n	8000d52 <__udivmoddi4+0x276>
 8000d40:	eb1c 0404 	adds.w	r4, ip, r4
 8000d44:	f101 36ff 	add.w	r6, r1, #4294967295
 8000d48:	d213      	bcs.n	8000d72 <__udivmoddi4+0x296>
 8000d4a:	42a3      	cmp	r3, r4
 8000d4c:	d911      	bls.n	8000d72 <__udivmoddi4+0x296>
 8000d4e:	3902      	subs	r1, #2
 8000d50:	4464      	add	r4, ip
 8000d52:	1ae4      	subs	r4, r4, r3
 8000d54:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000d58:	e739      	b.n	8000bce <__udivmoddi4+0xf2>
 8000d5a:	4604      	mov	r4, r0
 8000d5c:	e6f0      	b.n	8000b40 <__udivmoddi4+0x64>
 8000d5e:	4608      	mov	r0, r1
 8000d60:	e706      	b.n	8000b70 <__udivmoddi4+0x94>
 8000d62:	45c8      	cmp	r8, r9
 8000d64:	d2ae      	bcs.n	8000cc4 <__udivmoddi4+0x1e8>
 8000d66:	ebb9 0e02 	subs.w	lr, r9, r2
 8000d6a:	eb63 0c07 	sbc.w	ip, r3, r7
 8000d6e:	3801      	subs	r0, #1
 8000d70:	e7a8      	b.n	8000cc4 <__udivmoddi4+0x1e8>
 8000d72:	4631      	mov	r1, r6
 8000d74:	e7ed      	b.n	8000d52 <__udivmoddi4+0x276>
 8000d76:	4603      	mov	r3, r0
 8000d78:	e799      	b.n	8000cae <__udivmoddi4+0x1d2>
 8000d7a:	4630      	mov	r0, r6
 8000d7c:	e7d4      	b.n	8000d28 <__udivmoddi4+0x24c>
 8000d7e:	46d6      	mov	lr, sl
 8000d80:	e77f      	b.n	8000c82 <__udivmoddi4+0x1a6>
 8000d82:	4463      	add	r3, ip
 8000d84:	3802      	subs	r0, #2
 8000d86:	e74d      	b.n	8000c24 <__udivmoddi4+0x148>
 8000d88:	4606      	mov	r6, r0
 8000d8a:	4623      	mov	r3, r4
 8000d8c:	4608      	mov	r0, r1
 8000d8e:	e70f      	b.n	8000bb0 <__udivmoddi4+0xd4>
 8000d90:	3e02      	subs	r6, #2
 8000d92:	4463      	add	r3, ip
 8000d94:	e730      	b.n	8000bf8 <__udivmoddi4+0x11c>
 8000d96:	bf00      	nop

08000d98 <__aeabi_idiv0>:
 8000d98:	4770      	bx	lr
 8000d9a:	bf00      	nop

08000d9c <compare_timestamp>:
static void RTC_Config(void);


int compare_timestamp(const Current_Date_t* ts1_date, const Current_Time_t* ts1_time,
                      const Current_Date_t* ts2_date, const Current_Time_t* ts2_time)
{
 8000d9c:	b480      	push	{r7}
 8000d9e:	b085      	sub	sp, #20
 8000da0:	af00      	add	r7, sp, #0
 8000da2:	60f8      	str	r0, [r7, #12]
 8000da4:	60b9      	str	r1, [r7, #8]
 8000da6:	607a      	str	r2, [r7, #4]
 8000da8:	603b      	str	r3, [r7, #0]
    if (ts1_date->year != ts2_date->year)
 8000daa:	68fb      	ldr	r3, [r7, #12]
 8000dac:	881a      	ldrh	r2, [r3, #0]
 8000dae:	687b      	ldr	r3, [r7, #4]
 8000db0:	881b      	ldrh	r3, [r3, #0]
 8000db2:	429a      	cmp	r2, r3
 8000db4:	d006      	beq.n	8000dc4 <compare_timestamp+0x28>
    {
        return ts1_date->year - ts2_date->year;
 8000db6:	68fb      	ldr	r3, [r7, #12]
 8000db8:	881b      	ldrh	r3, [r3, #0]
 8000dba:	461a      	mov	r2, r3
 8000dbc:	687b      	ldr	r3, [r7, #4]
 8000dbe:	881b      	ldrh	r3, [r3, #0]
 8000dc0:	1ad3      	subs	r3, r2, r3
 8000dc2:	e039      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_date->month != ts2_date->month)
 8000dc4:	68fb      	ldr	r3, [r7, #12]
 8000dc6:	789a      	ldrb	r2, [r3, #2]
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	789b      	ldrb	r3, [r3, #2]
 8000dcc:	429a      	cmp	r2, r3
 8000dce:	d006      	beq.n	8000dde <compare_timestamp+0x42>
    {
        return ts1_date->month - ts2_date->month;
 8000dd0:	68fb      	ldr	r3, [r7, #12]
 8000dd2:	789b      	ldrb	r3, [r3, #2]
 8000dd4:	461a      	mov	r2, r3
 8000dd6:	687b      	ldr	r3, [r7, #4]
 8000dd8:	789b      	ldrb	r3, [r3, #2]
 8000dda:	1ad3      	subs	r3, r2, r3
 8000ddc:	e02c      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_date->date != ts2_date->date)
 8000dde:	68fb      	ldr	r3, [r7, #12]
 8000de0:	78da      	ldrb	r2, [r3, #3]
 8000de2:	687b      	ldr	r3, [r7, #4]
 8000de4:	78db      	ldrb	r3, [r3, #3]
 8000de6:	429a      	cmp	r2, r3
 8000de8:	d006      	beq.n	8000df8 <compare_timestamp+0x5c>
    {
        return ts1_date->date - ts2_date->date;
 8000dea:	68fb      	ldr	r3, [r7, #12]
 8000dec:	78db      	ldrb	r3, [r3, #3]
 8000dee:	461a      	mov	r2, r3
 8000df0:	687b      	ldr	r3, [r7, #4]
 8000df2:	78db      	ldrb	r3, [r3, #3]
 8000df4:	1ad3      	subs	r3, r2, r3
 8000df6:	e01f      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_time->hour != ts2_time->hour)
 8000df8:	68bb      	ldr	r3, [r7, #8]
 8000dfa:	781a      	ldrb	r2, [r3, #0]
 8000dfc:	683b      	ldr	r3, [r7, #0]
 8000dfe:	781b      	ldrb	r3, [r3, #0]
 8000e00:	429a      	cmp	r2, r3
 8000e02:	d006      	beq.n	8000e12 <compare_timestamp+0x76>
    {
        return ts1_time->hour - ts2_time->hour;
 8000e04:	68bb      	ldr	r3, [r7, #8]
 8000e06:	781b      	ldrb	r3, [r3, #0]
 8000e08:	461a      	mov	r2, r3
 8000e0a:	683b      	ldr	r3, [r7, #0]
 8000e0c:	781b      	ldrb	r3, [r3, #0]
 8000e0e:	1ad3      	subs	r3, r2, r3
 8000e10:	e012      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_time->minute != ts2_time->minute)
 8000e12:	68bb      	ldr	r3, [r7, #8]
 8000e14:	785a      	ldrb	r2, [r3, #1]
 8000e16:	683b      	ldr	r3, [r7, #0]
 8000e18:	785b      	ldrb	r3, [r3, #1]
 8000e1a:	429a      	cmp	r2, r3
 8000e1c:	d006      	beq.n	8000e2c <compare_timestamp+0x90>
    {
        return ts1_time->minute - ts2_time->minute;
 8000e1e:	68bb      	ldr	r3, [r7, #8]
 8000e20:	785b      	ldrb	r3, [r3, #1]
 8000e22:	461a      	mov	r2, r3
 8000e24:	683b      	ldr	r3, [r7, #0]
 8000e26:	785b      	ldrb	r3, [r3, #1]
 8000e28:	1ad3      	subs	r3, r2, r3
 8000e2a:	e005      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    return ts1_time->second - ts2_time->second;
 8000e2c:	68bb      	ldr	r3, [r7, #8]
 8000e2e:	789b      	ldrb	r3, [r3, #2]
 8000e30:	461a      	mov	r2, r3
 8000e32:	683b      	ldr	r3, [r7, #0]
 8000e34:	789b      	ldrb	r3, [r3, #2]
 8000e36:	1ad3      	subs	r3, r2, r3
}
 8000e38:	4618      	mov	r0, r3
 8000e3a:	3714      	adds	r7, #20
 8000e3c:	46bd      	mov	sp, r7
 8000e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e42:	4770      	bx	lr

08000e44 <add_video_timestamp>:

void add_video_timestamp(const Current_Date_t* date, const Current_Time_t* time)
{
 8000e44:	b580      	push	{r7, lr}
 8000e46:	b082      	sub	sp, #8
 8000e48:	af00      	add	r7, sp, #0
 8000e4a:	6078      	str	r0, [r7, #4]
 8000e4c:	6039      	str	r1, [r7, #0]
    if (video_count < MAX_VIDEOS)
 8000e4e:	4b11      	ldr	r3, [pc, #68]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e50:	681b      	ldr	r3, [r3, #0]
 8000e52:	2b09      	cmp	r3, #9
 8000e54:	dc19      	bgt.n	8000e8a <add_video_timestamp+0x46>
    {
        memcpy(&video_dates[video_count], date, sizeof(Current_Date_t));
 8000e56:	4b0f      	ldr	r3, [pc, #60]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e58:	681a      	ldr	r2, [r3, #0]
 8000e5a:	4613      	mov	r3, r2
 8000e5c:	005b      	lsls	r3, r3, #1
 8000e5e:	4413      	add	r3, r2
 8000e60:	005b      	lsls	r3, r3, #1
 8000e62:	4a0d      	ldr	r2, [pc, #52]	@ (8000e98 <add_video_timestamp+0x54>)
 8000e64:	4413      	add	r3, r2
 8000e66:	2206      	movs	r2, #6
 8000e68:	6879      	ldr	r1, [r7, #4]
 8000e6a:	4618      	mov	r0, r3
 8000e6c:	f02c fd4d 	bl	802d90a <memcpy>
        memcpy(&video_times[video_count], time, sizeof(Current_Time_t));
 8000e70:	4b08      	ldr	r3, [pc, #32]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e72:	681b      	ldr	r3, [r3, #0]
 8000e74:	009b      	lsls	r3, r3, #2
 8000e76:	4a09      	ldr	r2, [pc, #36]	@ (8000e9c <add_video_timestamp+0x58>)
 8000e78:	4413      	add	r3, r2
 8000e7a:	683a      	ldr	r2, [r7, #0]
 8000e7c:	6812      	ldr	r2, [r2, #0]
 8000e7e:	601a      	str	r2, [r3, #0]
        video_count++;
 8000e80:	4b04      	ldr	r3, [pc, #16]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e82:	681b      	ldr	r3, [r3, #0]
 8000e84:	3301      	adds	r3, #1
 8000e86:	4a03      	ldr	r2, [pc, #12]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e88:	6013      	str	r3, [r2, #0]
    }
}
 8000e8a:	bf00      	nop
 8000e8c:	3708      	adds	r7, #8
 8000e8e:	46bd      	mov	sp, r7
 8000e90:	bd80      	pop	{r7, pc}
 8000e92:	bf00      	nop
 8000e94:	2000224c 	.word	0x2000224c
 8000e98:	200021e8 	.word	0x200021e8
 8000e9c:	20002224 	.word	0x20002224

08000ea0 <delete_oldest_video>:

void delete_oldest_video(void)
{
 8000ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ea2:	b0b9      	sub	sp, #228	@ 0xe4
 8000ea4:	af04      	add	r7, sp, #16
    if (video_count > 0)
 8000ea6:	4b67      	ldr	r3, [pc, #412]	@ (8001044 <delete_oldest_video+0x1a4>)
 8000ea8:	681b      	ldr	r3, [r3, #0]
 8000eaa:	2b00      	cmp	r3, #0
 8000eac:	f340 80c6 	ble.w	800103c <delete_oldest_video+0x19c>
    {
        int oldest_index = 0;
 8000eb0:	2300      	movs	r3, #0
 8000eb2:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        for (int i = 1; i < video_count; ++i)
 8000eb6:	2301      	movs	r3, #1
 8000eb8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8000ebc:	e027      	b.n	8000f0e <delete_oldest_video+0x6e>
        {
            if (compare_timestamp(&video_dates[i], &video_times[i],
 8000ebe:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8000ec2:	4613      	mov	r3, r2
 8000ec4:	005b      	lsls	r3, r3, #1
 8000ec6:	4413      	add	r3, r2
 8000ec8:	005b      	lsls	r3, r3, #1
 8000eca:	4a5f      	ldr	r2, [pc, #380]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000ecc:	1898      	adds	r0, r3, r2
 8000ece:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000ed2:	009b      	lsls	r3, r3, #2
 8000ed4:	4a5d      	ldr	r2, [pc, #372]	@ (800104c <delete_oldest_video+0x1ac>)
 8000ed6:	1899      	adds	r1, r3, r2
                                  &video_dates[oldest_index], &video_times[oldest_index]) < 0)
 8000ed8:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8000edc:	4613      	mov	r3, r2
 8000ede:	005b      	lsls	r3, r3, #1
 8000ee0:	4413      	add	r3, r2
 8000ee2:	005b      	lsls	r3, r3, #1
 8000ee4:	4a58      	ldr	r2, [pc, #352]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000ee6:	441a      	add	r2, r3
 8000ee8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000eec:	009b      	lsls	r3, r3, #2
 8000eee:	4c57      	ldr	r4, [pc, #348]	@ (800104c <delete_oldest_video+0x1ac>)
 8000ef0:	4423      	add	r3, r4
            if (compare_timestamp(&video_dates[i], &video_times[i],
 8000ef2:	f7ff ff53 	bl	8000d9c <compare_timestamp>
 8000ef6:	4603      	mov	r3, r0
 8000ef8:	2b00      	cmp	r3, #0
 8000efa:	da03      	bge.n	8000f04 <delete_oldest_video+0x64>
            {
                oldest_index = i;
 8000efc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000f00:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        for (int i = 1; i < video_count; ++i)
 8000f04:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000f08:	3301      	adds	r3, #1
 8000f0a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8000f0e:	4b4d      	ldr	r3, [pc, #308]	@ (8001044 <delete_oldest_video+0x1a4>)
 8000f10:	681b      	ldr	r3, [r3, #0]
 8000f12:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8000f16:	429a      	cmp	r2, r3
 8000f18:	dbd1      	blt.n	8000ebe <delete_oldest_video+0x1e>
        }

        // Delete the oldest video file
        char filename[64];
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f1a:	494b      	ldr	r1, [pc, #300]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000f1c:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8000f20:	4613      	mov	r3, r2
 8000f22:	005b      	lsls	r3, r3, #1
 8000f24:	4413      	add	r3, r2
 8000f26:	005b      	lsls	r3, r3, #1
 8000f28:	440b      	add	r3, r1
 8000f2a:	881b      	ldrh	r3, [r3, #0]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f2c:	461e      	mov	r6, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f2e:	4946      	ldr	r1, [pc, #280]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000f30:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8000f34:	4613      	mov	r3, r2
 8000f36:	005b      	lsls	r3, r3, #1
 8000f38:	4413      	add	r3, r2
 8000f3a:	005b      	lsls	r3, r3, #1
 8000f3c:	440b      	add	r3, r1
 8000f3e:	3302      	adds	r3, #2
 8000f40:	781b      	ldrb	r3, [r3, #0]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f42:	469c      	mov	ip, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f44:	4940      	ldr	r1, [pc, #256]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000f46:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8000f4a:	4613      	mov	r3, r2
 8000f4c:	005b      	lsls	r3, r3, #1
 8000f4e:	4413      	add	r3, r2
 8000f50:	005b      	lsls	r3, r3, #1
 8000f52:	440b      	add	r3, r1
 8000f54:	3303      	adds	r3, #3
 8000f56:	781b      	ldrb	r3, [r3, #0]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f58:	4619      	mov	r1, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f5a:	4a3c      	ldr	r2, [pc, #240]	@ (800104c <delete_oldest_video+0x1ac>)
 8000f5c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f60:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f64:	461c      	mov	r4, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f66:	4a39      	ldr	r2, [pc, #228]	@ (800104c <delete_oldest_video+0x1ac>)
 8000f68:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f6c:	009b      	lsls	r3, r3, #2
 8000f6e:	4413      	add	r3, r2
 8000f70:	785b      	ldrb	r3, [r3, #1]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f72:	461d      	mov	r5, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f74:	4a35      	ldr	r2, [pc, #212]	@ (800104c <delete_oldest_video+0x1ac>)
 8000f76:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f7a:	009b      	lsls	r3, r3, #2
 8000f7c:	4413      	add	r3, r2
 8000f7e:	789b      	ldrb	r3, [r3, #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f80:	4638      	mov	r0, r7
 8000f82:	9303      	str	r3, [sp, #12]
 8000f84:	9502      	str	r5, [sp, #8]
 8000f86:	9401      	str	r4, [sp, #4]
 8000f88:	9100      	str	r1, [sp, #0]
 8000f8a:	4663      	mov	r3, ip
 8000f8c:	4632      	mov	r2, r6
 8000f8e:	4930      	ldr	r1, [pc, #192]	@ (8001050 <delete_oldest_video+0x1b0>)
 8000f90:	f02c fbcc 	bl	802d72c <siprintf>
        char filepath[128];
        sprintf(filepath, "/Video/%s", filename);
 8000f94:	463a      	mov	r2, r7
 8000f96:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 8000f9a:	492e      	ldr	r1, [pc, #184]	@ (8001054 <delete_oldest_video+0x1b4>)
 8000f9c:	4618      	mov	r0, r3
 8000f9e:	f02c fbc5 	bl	802d72c <siprintf>
        FRESULT fr = f_unlink(filepath);
 8000fa2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 8000fa6:	4618      	mov	r0, r3
 8000fa8:	f00f fb6b 	bl	8010682 <f_unlink>
 8000fac:	4603      	mov	r3, r0
 8000fae:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3
        if (fr == FR_OK) {
 8000fb2:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 8000fb6:	2b00      	cmp	r3, #0
 8000fb8:	d105      	bne.n	8000fc6 <delete_oldest_video+0x126>
            printf("Deleted oldest video: %s\n", filename);
 8000fba:	463b      	mov	r3, r7
 8000fbc:	4619      	mov	r1, r3
 8000fbe:	4826      	ldr	r0, [pc, #152]	@ (8001058 <delete_oldest_video+0x1b8>)
 8000fc0:	f02c fba2 	bl	802d708 <iprintf>
 8000fc4:	e004      	b.n	8000fd0 <delete_oldest_video+0x130>
        } else {
            printf("Failed to delete oldest video: %s\n", filename);
 8000fc6:	463b      	mov	r3, r7
 8000fc8:	4619      	mov	r1, r3
 8000fca:	4824      	ldr	r0, [pc, #144]	@ (800105c <delete_oldest_video+0x1bc>)
 8000fcc:	f02c fb9c 	bl	802d708 <iprintf>
        }

        // Remove the oldest timestamp from the list
        for (int i = oldest_index; i < video_count - 1; ++i) {
 8000fd0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000fd4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8000fd8:	e024      	b.n	8001024 <delete_oldest_video+0x184>
            memcpy(&video_dates[i], &video_dates[i + 1], sizeof(Current_Time_t));
 8000fda:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8000fde:	4613      	mov	r3, r2
 8000fe0:	005b      	lsls	r3, r3, #1
 8000fe2:	4413      	add	r3, r2
 8000fe4:	005b      	lsls	r3, r3, #1
 8000fe6:	4a18      	ldr	r2, [pc, #96]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000fe8:	1899      	adds	r1, r3, r2
 8000fea:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8000fee:	1c5a      	adds	r2, r3, #1
 8000ff0:	4613      	mov	r3, r2
 8000ff2:	005b      	lsls	r3, r3, #1
 8000ff4:	4413      	add	r3, r2
 8000ff6:	005b      	lsls	r3, r3, #1
 8000ff8:	4a13      	ldr	r2, [pc, #76]	@ (8001048 <delete_oldest_video+0x1a8>)
 8000ffa:	4413      	add	r3, r2
 8000ffc:	681b      	ldr	r3, [r3, #0]
 8000ffe:	600b      	str	r3, [r1, #0]
            memcpy(&video_times[i], &video_times[i + 1], sizeof(Current_Time_t));
 8001000:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8001004:	009b      	lsls	r3, r3, #2
 8001006:	4a11      	ldr	r2, [pc, #68]	@ (800104c <delete_oldest_video+0x1ac>)
 8001008:	4413      	add	r3, r2
 800100a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 800100e:	3201      	adds	r2, #1
 8001010:	0092      	lsls	r2, r2, #2
 8001012:	490e      	ldr	r1, [pc, #56]	@ (800104c <delete_oldest_video+0x1ac>)
 8001014:	440a      	add	r2, r1
 8001016:	6812      	ldr	r2, [r2, #0]
 8001018:	601a      	str	r2, [r3, #0]
        for (int i = oldest_index; i < video_count - 1; ++i) {
 800101a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800101e:	3301      	adds	r3, #1
 8001020:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8001024:	4b07      	ldr	r3, [pc, #28]	@ (8001044 <delete_oldest_video+0x1a4>)
 8001026:	681b      	ldr	r3, [r3, #0]
 8001028:	3b01      	subs	r3, #1
 800102a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 800102e:	429a      	cmp	r2, r3
 8001030:	dbd3      	blt.n	8000fda <delete_oldest_video+0x13a>
        }
        video_count--;
 8001032:	4b04      	ldr	r3, [pc, #16]	@ (8001044 <delete_oldest_video+0x1a4>)
 8001034:	681b      	ldr	r3, [r3, #0]
 8001036:	3b01      	subs	r3, #1
 8001038:	4a02      	ldr	r2, [pc, #8]	@ (8001044 <delete_oldest_video+0x1a4>)
 800103a:	6013      	str	r3, [r2, #0]
    }
}
 800103c:	bf00      	nop
 800103e:	37d4      	adds	r7, #212	@ 0xd4
 8001040:	46bd      	mov	sp, r7
 8001042:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001044:	2000224c 	.word	0x2000224c
 8001048:	200021e8 	.word	0x200021e8
 800104c:	20002224 	.word	0x20002224
 8001050:	0802e650 	.word	0x0802e650
 8001054:	0802e678 	.word	0x0802e678
 8001058:	0802e684 	.word	0x0802e684
 800105c:	0802e6a0 	.word	0x0802e6a0

08001060 <check_delete_oldest_video>:

void check_delete_oldest_video(void)
{
 8001060:	b580      	push	{r7, lr}
 8001062:	af00      	add	r7, sp, #0
    if (video_count >= MAX_VIDEOS)
 8001064:	4b03      	ldr	r3, [pc, #12]	@ (8001074 <check_delete_oldest_video+0x14>)
 8001066:	681b      	ldr	r3, [r3, #0]
 8001068:	2b09      	cmp	r3, #9
 800106a:	dd01      	ble.n	8001070 <check_delete_oldest_video+0x10>
    {
        delete_oldest_video();
 800106c:	f7ff ff18 	bl	8000ea0 <delete_oldest_video>
    }
}
 8001070:	bf00      	nop
 8001072:	bd80      	pop	{r7, pc}
 8001074:	2000224c 	.word	0x2000224c

08001078 <rec_begin>:

void rec_begin(void)
{
 8001078:	b5f0      	push	{r4, r5, r6, r7, lr}
 800107a:	b099      	sub	sp, #100	@ 0x64
 800107c:	af04      	add	r7, sp, #16

	Current_Date_Handle_t sCurrent;
    RTC_GetTime(&hrtc, &sCurrent);
 800107e:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8001082:	4619      	mov	r1, r3
 8001084:	4825      	ldr	r0, [pc, #148]	@ (800111c <rec_begin+0xa4>)
 8001086:	f009 f887 	bl	800a198 <RTC_GetTime>
    RTC_GetDate(&hrtc, &sCurrent);
 800108a:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800108e:	4619      	mov	r1, r3
 8001090:	4822      	ldr	r0, [pc, #136]	@ (800111c <rec_begin+0xa4>)
 8001092:	f009 f8d7 	bl	800a244 <RTC_GetDate>

    // Add the timestamp to the list
    add_video_timestamp(&sCurrent.Date, &sCurrent.Time);
 8001096:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 800109a:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800109e:	3304      	adds	r3, #4
 80010a0:	4611      	mov	r1, r2
 80010a2:	4618      	mov	r0, r3
 80010a4:	f7ff fece 	bl	8000e44 <add_video_timestamp>

    // Delete the oldest video if there are already 10 videos recorded
    check_delete_oldest_video();
 80010a8:	f7ff ffda 	bl	8001060 <check_delete_oldest_video>

	char fn[64];
	memset(fn, 0, 64);
 80010ac:	1d3b      	adds	r3, r7, #4
 80010ae:	2240      	movs	r2, #64	@ 0x40
 80010b0:	2100      	movs	r1, #0
 80010b2:	4618      	mov	r0, r3
 80010b4:	f02c fb9d 	bl	802d7f2 <memset>

	sprintf(fn, "0:/Video/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 80010b8:	f8b7 3048 	ldrh.w	r3, [r7, #72]	@ 0x48
	sprintf(fn, "0:/Video/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 80010bc:	461d      	mov	r5, r3
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 80010be:	f897 304a 	ldrb.w	r3, [r7, #74]	@ 0x4a
	sprintf(fn, "0:/Video/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 80010c2:	461e      	mov	r6, r3
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 80010c4:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 80010c8:	f897 2044 	ldrb.w	r2, [r7, #68]	@ 0x44
 80010cc:	f897 1045 	ldrb.w	r1, [r7, #69]	@ 0x45
 80010d0:	f897 0046 	ldrb.w	r0, [r7, #70]	@ 0x46
	sprintf(fn, "0:/Video/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 80010d4:	4604      	mov	r4, r0
 80010d6:	1d38      	adds	r0, r7, #4
 80010d8:	9403      	str	r4, [sp, #12]
 80010da:	9102      	str	r1, [sp, #8]
 80010dc:	9201      	str	r2, [sp, #4]
 80010de:	9300      	str	r3, [sp, #0]
 80010e0:	4633      	mov	r3, r6
 80010e2:	462a      	mov	r2, r5
 80010e4:	490e      	ldr	r1, [pc, #56]	@ (8001120 <rec_begin+0xa8>)
 80010e6:	f02c fb21 	bl	802d72c <siprintf>
	res = f_open(&file, fn, FA_CREATE_ALWAYS|FA_WRITE);
 80010ea:	1d3b      	adds	r3, r7, #4
 80010ec:	220a      	movs	r2, #10
 80010ee:	4619      	mov	r1, r3
 80010f0:	480c      	ldr	r0, [pc, #48]	@ (8001124 <rec_begin+0xac>)
 80010f2:	f00e fb3f 	bl	800f774 <f_open>
 80010f6:	4603      	mov	r3, r0
 80010f8:	461a      	mov	r2, r3
 80010fa:	4b0b      	ldr	r3, [pc, #44]	@ (8001128 <rec_begin+0xb0>)
 80010fc:	701a      	strb	r2, [r3, #0]
	if (res==FR_OK)
 80010fe:	4b0a      	ldr	r3, [pc, #40]	@ (8001128 <rec_begin+0xb0>)
 8001100:	781b      	ldrb	r3, [r3, #0]
 8001102:	2b00      	cmp	r3, #0
 8001104:	d105      	bne.n	8001112 <rec_begin+0x9a>
	{
	  start_output_mjpeg_avi(&file, &hdcmi, (uint8_t)3, (uint8_t)1);
 8001106:	2301      	movs	r3, #1
 8001108:	2203      	movs	r2, #3
 800110a:	4908      	ldr	r1, [pc, #32]	@ (800112c <rec_begin+0xb4>)
 800110c:	4805      	ldr	r0, [pc, #20]	@ (8001124 <rec_begin+0xac>)
 800110e:	f007 fb3f 	bl	8008790 <start_output_mjpeg_avi>
	}
}
 8001112:	bf00      	nop
 8001114:	3754      	adds	r7, #84	@ 0x54
 8001116:	46bd      	mov	sp, r7
 8001118:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800111a:	bf00      	nop
 800111c:	2000016c 	.word	0x2000016c
 8001120:	0802e6c4 	.word	0x0802e6c4
 8001124:	200011b4 	.word	0x200011b4
 8001128:	200011b0 	.word	0x200011b0
 800112c:	200000a4 	.word	0x200000a4

08001130 <main>:


int main(void)
{
 8001130:	b580      	push	{r7, lr}
 8001132:	af00      	add	r7, sp, #0

	HAL_Init();
 8001134:	f000 fce4 	bl	8001b00 <HAL_Init>

	// configure the system clock
	SystemClock_Config();
 8001138:	f000 f836 	bl	80011a8 <SystemClock_Config>

	// configure the peripherals common clocks */
	PeriphCommonClock_Config();
 800113c:	f000 f892 	bl	8001264 <PeriphCommonClock_Config>

	// peripheral initialization
	TIM1_Config();
 8001140:	f009 fa56 	bl	800a5f0 <TIM1_Config>
	GPIO_Config();
 8001144:	f000 f8e6 	bl	8001314 <GPIO_Config>
	DMA_Config();
 8001148:	f000 f8d0 	bl	80012ec <DMA_Config>
	MX_FATFS_Init();
 800114c:	f009 faa8 	bl	800a6a0 <MX_FATFS_Init>
	DCMI_Config();
 8001150:	f000 f8a4 	bl	800129c <DCMI_Config>
	I2C_Config();
 8001154:	f000 f962 	bl	800141c <I2C_Config>
	MX_LIBJPEG_Init();
 8001158:	f009 fbcc 	bl	800a8f4 <MX_LIBJPEG_Init>
	MX_USB_HOST_Init();
 800115c:	f02b fe0e 	bl	802cd7c <MX_USB_HOST_Init>
	RTC_Config();
 8001160:	f000 f9a2 	bl	80014a8 <RTC_Config>



	// turn on USB powering
	MX_DriverVbusFS(0);
 8001164:	2000      	movs	r0, #0
 8001166:	f02c f933 	bl	802d3d0 <MX_DriverVbusFS>

	while (1)
	{
		if((begin_rec != 0) && (read_avi_output_status() == AVI_READY))
 800116a:	4b0d      	ldr	r3, [pc, #52]	@ (80011a0 <main+0x70>)
 800116c:	781b      	ldrb	r3, [r3, #0]
 800116e:	b2db      	uxtb	r3, r3
 8001170:	2b00      	cmp	r3, #0
 8001172:	d009      	beq.n	8001188 <main+0x58>
 8001174:	f006 ff36 	bl	8007fe4 <read_avi_output_status>
 8001178:	4603      	mov	r3, r0
 800117a:	2b00      	cmp	r3, #0
 800117c:	d104      	bne.n	8001188 <main+0x58>
		{
			HAL_DCMI_Stop(&hdcmi);
 800117e:	4809      	ldr	r0, [pc, #36]	@ (80011a4 <main+0x74>)
 8001180:	f000 ff06 	bl	8001f90 <HAL_DCMI_Stop>
			rec_begin();
 8001184:	f7ff ff78 	bl	8001078 <rec_begin>
		}
		if (read_avi_output_status() == AVI_CLOSED_OUT) //output finished
 8001188:	f006 ff2c 	bl	8007fe4 <read_avi_output_status>
 800118c:	4603      	mov	r3, r0
 800118e:	2b03      	cmp	r3, #3
 8001190:	d102      	bne.n	8001198 <main+0x68>
		{
		  set_avi_output_status(AVI_READY);
 8001192:	2000      	movs	r0, #0
 8001194:	f006 ff16 	bl	8007fc4 <set_avi_output_status>
		}
		MX_USB_HOST_Process();
 8001198:	f02b fe16 	bl	802cdc8 <MX_USB_HOST_Process>
		if((begin_rec != 0) && (read_avi_output_status() == AVI_READY))
 800119c:	e7e5      	b.n	800116a <main+0x3a>
 800119e:	bf00      	nop
 80011a0:	200021e4 	.word	0x200021e4
 80011a4:	200000a4 	.word	0x200000a4

080011a8 <SystemClock_Config>:

}


void SystemClock_Config(void)
{
 80011a8:	b580      	push	{r7, lr}
 80011aa:	b092      	sub	sp, #72	@ 0x48
 80011ac:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80011ae:	f107 0318 	add.w	r3, r7, #24
 80011b2:	2230      	movs	r2, #48	@ 0x30
 80011b4:	2100      	movs	r1, #0
 80011b6:	4618      	mov	r0, r3
 80011b8:	f02c fb1b 	bl	802d7f2 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80011bc:	1d3b      	adds	r3, r7, #4
 80011be:	2200      	movs	r2, #0
 80011c0:	601a      	str	r2, [r3, #0]
 80011c2:	605a      	str	r2, [r3, #4]
 80011c4:	609a      	str	r2, [r3, #8]
 80011c6:	60da      	str	r2, [r3, #12]
 80011c8:	611a      	str	r2, [r3, #16]

	/** Configure the main internal regulator output voltage
	*/
	RCC->APB1ENR.bit.pwren = SET;
 80011ca:	4a24      	ldr	r2, [pc, #144]	@ (800125c <SystemClock_Config+0xb4>)
 80011cc:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 80011ce:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80011d2:	6413      	str	r3, [r2, #64]	@ 0x40
	PWR->CR.bit.vos = 1;
 80011d4:	4a22      	ldr	r2, [pc, #136]	@ (8001260 <SystemClock_Config+0xb8>)
 80011d6:	6813      	ldr	r3, [r2, #0]
 80011d8:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80011dc:	6013      	str	r3, [r2, #0]

	/** Initializes the RCC Oscillators according to the specified parameters
	* in the RCC_OscInitTypeDef structure.
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 80011de:	2309      	movs	r3, #9
 80011e0:	61bb      	str	r3, [r7, #24]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80011e2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 80011e6:	61fb      	str	r3, [r7, #28]
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 80011e8:	2301      	movs	r3, #1
 80011ea:	62fb      	str	r3, [r7, #44]	@ 0x2c
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80011ec:	2302      	movs	r3, #2
 80011ee:	633b      	str	r3, [r7, #48]	@ 0x30
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80011f0:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 80011f4:	637b      	str	r3, [r7, #52]	@ 0x34
	RCC_OscInitStruct.PLL.PLLM = 4;
 80011f6:	2304      	movs	r3, #4
 80011f8:	63bb      	str	r3, [r7, #56]	@ 0x38
	RCC_OscInitStruct.PLL.PLLN = 168;
 80011fa:	23a8      	movs	r3, #168	@ 0xa8
 80011fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80011fe:	2302      	movs	r3, #2
 8001200:	643b      	str	r3, [r7, #64]	@ 0x40
	RCC_OscInitStruct.PLL.PLLQ = 7;
 8001202:	2307      	movs	r3, #7
 8001204:	647b      	str	r3, [r7, #68]	@ 0x44
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001206:	f107 0318 	add.w	r3, r7, #24
 800120a:	4618      	mov	r0, r3
 800120c:	f004 ff80 	bl	8006110 <HAL_RCC_OscConfig>
 8001210:	4603      	mov	r3, r0
 8001212:	2b00      	cmp	r3, #0
 8001214:	d001      	beq.n	800121a <SystemClock_Config+0x72>
	{
		Error_Handler();
 8001216:	f000 f9ad 	bl	8001574 <Error_Handler>
	}

	/** Initializes the CPU, AHB and APB buses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800121a:	230f      	movs	r3, #15
 800121c:	607b      	str	r3, [r7, #4]
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800121e:	2302      	movs	r3, #2
 8001220:	60bb      	str	r3, [r7, #8]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001222:	2300      	movs	r3, #0
 8001224:	60fb      	str	r3, [r7, #12]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001226:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 800122a:	613b      	str	r3, [r7, #16]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800122c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001230:	617b      	str	r3, [r7, #20]

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8001232:	1d3b      	adds	r3, r7, #4
 8001234:	2105      	movs	r1, #5
 8001236:	4618      	mov	r0, r3
 8001238:	f005 f9ca 	bl	80065d0 <HAL_RCC_ClockConfig>
 800123c:	4603      	mov	r3, r0
 800123e:	2b00      	cmp	r3, #0
 8001240:	d001      	beq.n	8001246 <SystemClock_Config+0x9e>
	{
		Error_Handler();
 8001242:	f000 f997 	bl	8001574 <Error_Handler>
	}
	HAL_RCC_MCOConfig(RCC_MCO2, RCC_MCO2SOURCE_PLLI2SCLK, RCC_MCODIV_4);
 8001246:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
 800124a:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 800124e:	2001      	movs	r0, #1
 8001250:	f005 faa4 	bl	800679c <HAL_RCC_MCOConfig>
}
 8001254:	bf00      	nop
 8001256:	3748      	adds	r7, #72	@ 0x48
 8001258:	46bd      	mov	sp, r7
 800125a:	bd80      	pop	{r7, pc}
 800125c:	40023800 	.word	0x40023800
 8001260:	40007000 	.word	0x40007000

08001264 <PeriphCommonClock_Config>:

void PeriphCommonClock_Config(void)
{
 8001264:	b580      	push	{r7, lr}
 8001266:	b084      	sub	sp, #16
 8001268:	af00      	add	r7, sp, #0
	RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800126a:	463b      	mov	r3, r7
 800126c:	2200      	movs	r2, #0
 800126e:	601a      	str	r2, [r3, #0]
 8001270:	605a      	str	r2, [r3, #4]
 8001272:	609a      	str	r2, [r3, #8]
 8001274:	60da      	str	r2, [r3, #12]

	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_PLLI2S;
 8001276:	2304      	movs	r3, #4
 8001278:	603b      	str	r3, [r7, #0]
	PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 800127a:	23c0      	movs	r3, #192	@ 0xc0
 800127c:	607b      	str	r3, [r7, #4]
	PeriphClkInitStruct.PLLI2S.PLLI2SR = 4;
 800127e:	2304      	movs	r3, #4
 8001280:	60bb      	str	r3, [r7, #8]
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001282:	463b      	mov	r3, r7
 8001284:	4618      	mov	r0, r3
 8001286:	f005 fc25 	bl	8006ad4 <HAL_RCCEx_PeriphCLKConfig>
 800128a:	4603      	mov	r3, r0
 800128c:	2b00      	cmp	r3, #0
 800128e:	d001      	beq.n	8001294 <PeriphCommonClock_Config+0x30>
	{
		Error_Handler();
 8001290:	f000 f970 	bl	8001574 <Error_Handler>
	}
}
 8001294:	bf00      	nop
 8001296:	3710      	adds	r7, #16
 8001298:	46bd      	mov	sp, r7
 800129a:	bd80      	pop	{r7, pc}

0800129c <DCMI_Config>:

static void DCMI_Config(void)
{
 800129c:	b580      	push	{r7, lr}
 800129e:	af00      	add	r7, sp, #0
	hdcmi.Instance = DCMI;
 80012a0:	4b10      	ldr	r3, [pc, #64]	@ (80012e4 <DCMI_Config+0x48>)
 80012a2:	4a11      	ldr	r2, [pc, #68]	@ (80012e8 <DCMI_Config+0x4c>)
 80012a4:	601a      	str	r2, [r3, #0]
	hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
 80012a6:	4b0f      	ldr	r3, [pc, #60]	@ (80012e4 <DCMI_Config+0x48>)
 80012a8:	2200      	movs	r2, #0
 80012aa:	605a      	str	r2, [r3, #4]
	hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
 80012ac:	4b0d      	ldr	r3, [pc, #52]	@ (80012e4 <DCMI_Config+0x48>)
 80012ae:	2220      	movs	r2, #32
 80012b0:	609a      	str	r2, [r3, #8]
	hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
 80012b2:	4b0c      	ldr	r3, [pc, #48]	@ (80012e4 <DCMI_Config+0x48>)
 80012b4:	2200      	movs	r2, #0
 80012b6:	60da      	str	r2, [r3, #12]
	hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
 80012b8:	4b0a      	ldr	r3, [pc, #40]	@ (80012e4 <DCMI_Config+0x48>)
 80012ba:	2200      	movs	r2, #0
 80012bc:	611a      	str	r2, [r3, #16]
	hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
 80012be:	4b09      	ldr	r3, [pc, #36]	@ (80012e4 <DCMI_Config+0x48>)
 80012c0:	2200      	movs	r2, #0
 80012c2:	615a      	str	r2, [r3, #20]
	hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
 80012c4:	4b07      	ldr	r3, [pc, #28]	@ (80012e4 <DCMI_Config+0x48>)
 80012c6:	2200      	movs	r2, #0
 80012c8:	619a      	str	r2, [r3, #24]
	hdcmi.Init.JPEGMode = DCMI_JPEG_ENABLE;
 80012ca:	4b06      	ldr	r3, [pc, #24]	@ (80012e4 <DCMI_Config+0x48>)
 80012cc:	2208      	movs	r2, #8
 80012ce:	621a      	str	r2, [r3, #32]
	if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
 80012d0:	4804      	ldr	r0, [pc, #16]	@ (80012e4 <DCMI_Config+0x48>)
 80012d2:	f001 f80b 	bl	80022ec <HAL_DCMI_Init>
 80012d6:	4603      	mov	r3, r0
 80012d8:	2b00      	cmp	r3, #0
 80012da:	d001      	beq.n	80012e0 <DCMI_Config+0x44>
	{
	Error_Handler();
 80012dc:	f000 f94a 	bl	8001574 <Error_Handler>
	}
}
 80012e0:	bf00      	nop
 80012e2:	bd80      	pop	{r7, pc}
 80012e4:	200000a4 	.word	0x200000a4
 80012e8:	50050000 	.word	0x50050000

080012ec <DMA_Config>:

static void DMA_Config(void)
{
 80012ec:	b580      	push	{r7, lr}
 80012ee:	af00      	add	r7, sp, #0
	// enable DMA2 clock
	RCC->AHB1ENR.bit.dma2en = SET;
 80012f0:	4a07      	ldr	r2, [pc, #28]	@ (8001310 <DMA_Config+0x24>)
 80012f2:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80012f4:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 80012f8:	6313      	str	r3, [r2, #48]	@ 0x30

	// initialize DMA2_Stream1 interrupt which is used for DCMI
	HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0);
 80012fa:	2200      	movs	r2, #0
 80012fc:	2100      	movs	r1, #0
 80012fe:	2039      	movs	r0, #57	@ 0x39
 8001300:	f000 fd6f 	bl	8001de2 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 8001304:	2039      	movs	r0, #57	@ 0x39
 8001306:	f000 fd88 	bl	8001e1a <HAL_NVIC_EnableIRQ>
}
 800130a:	bf00      	nop
 800130c:	bd80      	pop	{r7, pc}
 800130e:	bf00      	nop
 8001310:	40023800 	.word	0x40023800

08001314 <GPIO_Config>:


static void GPIO_Config(void)
{
 8001314:	b580      	push	{r7, lr}
 8001316:	b086      	sub	sp, #24
 8001318:	af00      	add	r7, sp, #0
	GPIO_Handle_t GPIO_InitStruct = {0};
 800131a:	f107 0308 	add.w	r3, r7, #8
 800131e:	2200      	movs	r2, #0
 8001320:	601a      	str	r2, [r3, #0]
 8001322:	605a      	str	r2, [r3, #4]
 8001324:	609a      	str	r2, [r3, #8]
 8001326:	60da      	str	r2, [r3, #12]

	// enable all necessary GPIO clocks
	RCC_AHB1ENR_Reg_t AHB1ENR_temp;
	AHB1ENR_temp.reg = RCC->AHB1ENR.reg;
 8001328:	4b38      	ldr	r3, [pc, #224]	@ (800140c <GPIO_Config+0xf8>)
 800132a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800132c:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioeen = SET;
 800132e:	687b      	ldr	r3, [r7, #4]
 8001330:	f043 0310 	orr.w	r3, r3, #16
 8001334:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpiohen = SET;
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800133c:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpiocen = SET;
 800133e:	687b      	ldr	r3, [r7, #4]
 8001340:	f043 0304 	orr.w	r3, r3, #4
 8001344:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioaen = SET;
 8001346:	687b      	ldr	r3, [r7, #4]
 8001348:	f043 0301 	orr.w	r3, r3, #1
 800134c:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioden = SET;
 800134e:	687b      	ldr	r3, [r7, #4]
 8001350:	f043 0308 	orr.w	r3, r3, #8
 8001354:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioben = SET;
 8001356:	687b      	ldr	r3, [r7, #4]
 8001358:	f043 0302 	orr.w	r3, r3, #2
 800135c:	607b      	str	r3, [r7, #4]
	RCC->AHB1ENR.reg = AHB1ENR_temp.reg;
 800135e:	4a2b      	ldr	r2, [pc, #172]	@ (800140c <GPIO_Config+0xf8>)
 8001360:	687b      	ldr	r3, [r7, #4]
 8001362:	6313      	str	r3, [r2, #48]	@ 0x30

	// make sure PC0 is low; this pin is used for Drive_VBUS_FS
	GPIO_WritePin(GPIOC, GPIO_PIN_0, RESET);
 8001364:	2200      	movs	r2, #0
 8001366:	2100      	movs	r1, #0
 8001368:	4829      	ldr	r0, [pc, #164]	@ (8001410 <GPIO_Config+0xfc>)
 800136a:	f008 fa8f 	bl	800988c <GPIO_WritePin>

	// set camera RESET pin to disable reset
	GPIO_WritePin(GPIOD, GPIO_PIN_0, SET);
 800136e:	2201      	movs	r2, #1
 8001370:	2100      	movs	r1, #0
 8001372:	4828      	ldr	r0, [pc, #160]	@ (8001414 <GPIO_Config+0x100>)
 8001374:	f008 fa8a 	bl	800988c <GPIO_WritePin>

	// default PWDN pin state when camera is working; you may connect camera's PWDN pin to GND as well
	GPIO_WritePin(GPIOC, CAMERA_PWDN_Pin, RESET);
 8001378:	2200      	movs	r2, #0
 800137a:	210c      	movs	r1, #12
 800137c:	4824      	ldr	r0, [pc, #144]	@ (8001410 <GPIO_Config+0xfc>)
 800137e:	f008 fa85 	bl	800988c <GPIO_WritePin>

	// Drive_VBUS_FS pin configuration
	GPIO_InitStruct.pGPIOx = GPIOC;
 8001382:	4b23      	ldr	r3, [pc, #140]	@ (8001410 <GPIO_Config+0xfc>)
 8001384:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_0;
 8001386:	2300      	movs	r3, #0
 8001388:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_OUTPUT;
 800138a:	2301      	movs	r3, #1
 800138c:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800138e:	2300      	movs	r3, #0
 8001390:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8001392:	2300      	movs	r3, #0
 8001394:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001396:	2300      	movs	r3, #0
 8001398:	747b      	strb	r3, [r7, #17]
	GPIO_Init(&GPIO_InitStruct);
 800139a:	f107 0308 	add.w	r3, r7, #8
 800139e:	4618      	mov	r0, r3
 80013a0:	f008 f84c 	bl	800943c <GPIO_Init>

	// PWDN pin configuration
	GPIO_InitStruct.GPIO_Config.PinNumber = CAMERA_PWDN_Pin;
 80013a4:	230c      	movs	r3, #12
 80013a6:	60fb      	str	r3, [r7, #12]
	GPIO_Init(&GPIO_InitStruct);
 80013a8:	f107 0308 	add.w	r3, r7, #8
 80013ac:	4618      	mov	r0, r3
 80013ae:	f008 f845 	bl	800943c <GPIO_Init>

	// configure USER_Btn to be used as EXTI; or use any other EXTI you want
	GPIO_InitStruct.pGPIOx = USER_Btn_GPIO_Port;
 80013b2:	4b19      	ldr	r3, [pc, #100]	@ (8001418 <GPIO_Config+0x104>)
 80013b4:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = USER_Btn_Pin;
 80013b6:	2300      	movs	r3, #0
 80013b8:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_IT_RT;
 80013ba:	2305      	movs	r3, #5
 80013bc:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_PULL_DOWN;
 80013be:	2302      	movs	r3, #2
 80013c0:	74bb      	strb	r3, [r7, #18]
	GPIO_Init(&GPIO_InitStruct);
 80013c2:	f107 0308 	add.w	r3, r7, #8
 80013c6:	4618      	mov	r0, r3
 80013c8:	f008 f838 	bl	800943c <GPIO_Init>


	// configure DCMI_XCLX_Pin
	GPIO_InitStruct.pGPIOx = DCMI_XCLX_GPIO_Port;
 80013cc:	4b10      	ldr	r3, [pc, #64]	@ (8001410 <GPIO_Config+0xfc>)
 80013ce:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = DCMI_XCLX_Pin;
 80013d0:	2309      	movs	r3, #9
 80013d2:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 80013d4:	2302      	movs	r3, #2
 80013d6:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 80013d8:	2300      	movs	r3, #0
 80013da:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 80013dc:	2300      	movs	r3, #0
 80013de:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 80013e0:	2300      	movs	r3, #0
 80013e2:	747b      	strb	r3, [r7, #17]
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 80013e4:	2300      	movs	r3, #0
 80013e6:	753b      	strb	r3, [r7, #20]
	GPIO_Init(&GPIO_InitStruct);
 80013e8:	f107 0308 	add.w	r3, r7, #8
 80013ec:	4618      	mov	r0, r3
 80013ee:	f008 f825 	bl	800943c <GPIO_Init>

	HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
 80013f2:	2200      	movs	r2, #0
 80013f4:	2101      	movs	r1, #1
 80013f6:	2006      	movs	r0, #6
 80013f8:	f000 fcf3 	bl	8001de2 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 80013fc:	2006      	movs	r0, #6
 80013fe:	f000 fd0c 	bl	8001e1a <HAL_NVIC_EnableIRQ>
}
 8001402:	bf00      	nop
 8001404:	3718      	adds	r7, #24
 8001406:	46bd      	mov	sp, r7
 8001408:	bd80      	pop	{r7, pc}
 800140a:	bf00      	nop
 800140c:	40023800 	.word	0x40023800
 8001410:	40020800 	.word	0x40020800
 8001414:	40020c00 	.word	0x40020c00
 8001418:	40020000 	.word	0x40020000

0800141c <I2C_Config>:

static void I2C_Config(void)
{
 800141c:	b580      	push	{r7, lr}
 800141e:	b084      	sub	sp, #16
 8001420:	af00      	add	r7, sp, #0
	GPIO_Handle_t sI2C_GPIO = {0};
 8001422:	463b      	mov	r3, r7
 8001424:	2200      	movs	r2, #0
 8001426:	601a      	str	r2, [r3, #0]
 8001428:	605a      	str	r2, [r3, #4]
 800142a:	609a      	str	r2, [r3, #8]
 800142c:	60da      	str	r2, [r3, #12]

	hi2c1.pI2Cx = I2C1;
 800142e:	4b19      	ldr	r3, [pc, #100]	@ (8001494 <I2C_Config+0x78>)
 8001430:	4a19      	ldr	r2, [pc, #100]	@ (8001498 <I2C_Config+0x7c>)
 8001432:	601a      	str	r2, [r3, #0]
	hi2c1.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_STANDARD;
 8001434:	4b17      	ldr	r3, [pc, #92]	@ (8001494 <I2C_Config+0x78>)
 8001436:	4a19      	ldr	r2, [pc, #100]	@ (800149c <I2C_Config+0x80>)
 8001438:	605a      	str	r2, [r3, #4]
	hi2c1.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
 800143a:	4b16      	ldr	r3, [pc, #88]	@ (8001494 <I2C_Config+0x78>)
 800143c:	2200      	movs	r2, #0
 800143e:	729a      	strb	r2, [r3, #10]
	hi2c1.I2C_Config.I2C_DeviceAddress = 0;
 8001440:	4b14      	ldr	r3, [pc, #80]	@ (8001494 <I2C_Config+0x78>)
 8001442:	2200      	movs	r2, #0
 8001444:	721a      	strb	r2, [r3, #8]
	hi2c1.I2C_Config.I2C_AckControl = I2C_ACK_DISABLE;
 8001446:	4b13      	ldr	r3, [pc, #76]	@ (8001494 <I2C_Config+0x78>)
 8001448:	2200      	movs	r2, #0
 800144a:	725a      	strb	r2, [r3, #9]
	I2C_Init(&hi2c1);
 800144c:	4811      	ldr	r0, [pc, #68]	@ (8001494 <I2C_Config+0x78>)
 800144e:	f008 fb05 	bl	8009a5c <I2C_Init>

	/*I2C1 GPIO Configuration
	PB8     ------> I2C1_SCL
	PB9     ------> I2C1_SDA */

	sI2C_GPIO.pGPIOx = GPIOB;
 8001452:	4b13      	ldr	r3, [pc, #76]	@ (80014a0 <I2C_Config+0x84>)
 8001454:	603b      	str	r3, [r7, #0]
	sI2C_GPIO.GPIO_Config.PinNumber = GPIO_PIN_8;
 8001456:	2308      	movs	r3, #8
 8001458:	607b      	str	r3, [r7, #4]
	sI2C_GPIO.GPIO_Config.PinMode = GPIO_MODE_AF;
 800145a:	2302      	movs	r3, #2
 800145c:	723b      	strb	r3, [r7, #8]
	sI2C_GPIO.GPIO_Config.PinOPType = GPIO_OUTPUT_OD;
 800145e:	2301      	movs	r3, #1
 8001460:	72fb      	strb	r3, [r7, #11]
	sI2C_GPIO.GPIO_Config.PinPuPdControl = GPIO_PIN_PULL_UP;
 8001462:	2301      	movs	r3, #1
 8001464:	72bb      	strb	r3, [r7, #10]
	sI2C_GPIO.GPIO_Config.PinSpeed = GPIO_SPEED_HIGH;
 8001466:	2303      	movs	r3, #3
 8001468:	727b      	strb	r3, [r7, #9]
	sI2C_GPIO.GPIO_Config.PinAltFuncMode = 4;
 800146a:	2304      	movs	r3, #4
 800146c:	733b      	strb	r3, [r7, #12]
	GPIO_Init(&sI2C_GPIO);
 800146e:	463b      	mov	r3, r7
 8001470:	4618      	mov	r0, r3
 8001472:	f007 ffe3 	bl	800943c <GPIO_Init>

	sI2C_GPIO.GPIO_Config.PinNumber = GPIO_PIN_9;
 8001476:	2309      	movs	r3, #9
 8001478:	607b      	str	r3, [r7, #4]
	GPIO_Init(&sI2C_GPIO);
 800147a:	463b      	mov	r3, r7
 800147c:	4618      	mov	r0, r3
 800147e:	f007 ffdd 	bl	800943c <GPIO_Init>

	RCC->APB1ENR.bit.i2c1en = SET;
 8001482:	4a08      	ldr	r2, [pc, #32]	@ (80014a4 <I2C_Config+0x88>)
 8001484:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8001486:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800148a:	6413      	str	r3, [r2, #64]	@ 0x40

}
 800148c:	bf00      	nop
 800148e:	3710      	adds	r7, #16
 8001490:	46bd      	mov	sp, r7
 8001492:	bd80      	pop	{r7, pc}
 8001494:	20000144 	.word	0x20000144
 8001498:	40005400 	.word	0x40005400
 800149c:	000186a0 	.word	0x000186a0
 80014a0:	40020400 	.word	0x40020400
 80014a4:	40023800 	.word	0x40023800

080014a8 <RTC_Config>:

static void RTC_Config(void)
{
 80014a8:	b580      	push	{r7, lr}
 80014aa:	b082      	sub	sp, #8
 80014ac:	af00      	add	r7, sp, #0
	RTC_Alarm_t sAlarm = {0};
 80014ae:	463b      	mov	r3, r7
 80014b0:	2200      	movs	r2, #0
 80014b2:	601a      	str	r2, [r3, #0]
 80014b4:	f8c3 2003 	str.w	r2, [r3, #3]

	// initialize RTC working mode
	hrtc.RTC_Config.RTC_HourFormat = RTC_HOURFORMAT_24;
 80014b8:	4b2b      	ldr	r3, [pc, #172]	@ (8001568 <RTC_Config+0xc0>)
 80014ba:	2200      	movs	r2, #0
 80014bc:	701a      	strb	r2, [r3, #0]
	hrtc.RTC_Config.RTC_AsynchPrediv = 128;
 80014be:	4b2a      	ldr	r3, [pc, #168]	@ (8001568 <RTC_Config+0xc0>)
 80014c0:	2280      	movs	r2, #128	@ 0x80
 80014c2:	705a      	strb	r2, [r3, #1]
	hrtc.RTC_Config.RTC_SynchPrediv = 256;
 80014c4:	4b28      	ldr	r3, [pc, #160]	@ (8001568 <RTC_Config+0xc0>)
 80014c6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80014ca:	805a      	strh	r2, [r3, #2]
	RTC_Init(&hrtc);
 80014cc:	4826      	ldr	r0, [pc, #152]	@ (8001568 <RTC_Config+0xc0>)
 80014ce:	f008 fcf7 	bl	8009ec0 <RTC_Init>

	// set RTC time
	hrtc.Time.hour = 11;
 80014d2:	4b25      	ldr	r3, [pc, #148]	@ (8001568 <RTC_Config+0xc0>)
 80014d4:	220b      	movs	r2, #11
 80014d6:	711a      	strb	r2, [r3, #4]
	hrtc.Time.minute = 00;
 80014d8:	4b23      	ldr	r3, [pc, #140]	@ (8001568 <RTC_Config+0xc0>)
 80014da:	2200      	movs	r2, #0
 80014dc:	715a      	strb	r2, [r3, #5]
	hrtc.Time.second = 23;
 80014de:	4b22      	ldr	r3, [pc, #136]	@ (8001568 <RTC_Config+0xc0>)
 80014e0:	2217      	movs	r2, #23
 80014e2:	719a      	strb	r2, [r3, #6]
	RTC_SetTime(&hrtc);
 80014e4:	4820      	ldr	r0, [pc, #128]	@ (8001568 <RTC_Config+0xc0>)
 80014e6:	f008 fd51 	bl	8009f8c <RTC_SetTime>

	// set RTC date
	hrtc.Date.weekDay = MONDAY;
 80014ea:	4b1f      	ldr	r3, [pc, #124]	@ (8001568 <RTC_Config+0xc0>)
 80014ec:	2201      	movs	r2, #1
 80014ee:	731a      	strb	r2, [r3, #12]
	hrtc.Date.month = APRIL;
 80014f0:	4b1d      	ldr	r3, [pc, #116]	@ (8001568 <RTC_Config+0xc0>)
 80014f2:	2204      	movs	r2, #4
 80014f4:	729a      	strb	r2, [r3, #10]
	hrtc.Date.date = 27;
 80014f6:	4b1c      	ldr	r3, [pc, #112]	@ (8001568 <RTC_Config+0xc0>)
 80014f8:	221b      	movs	r2, #27
 80014fa:	72da      	strb	r2, [r3, #11]
	hrtc.Date.year = 24;
 80014fc:	4b1a      	ldr	r3, [pc, #104]	@ (8001568 <RTC_Config+0xc0>)
 80014fe:	2218      	movs	r2, #24
 8001500:	811a      	strh	r2, [r3, #8]
	RTC_SetDate(&hrtc);
 8001502:	4819      	ldr	r0, [pc, #100]	@ (8001568 <RTC_Config+0xc0>)
 8001504:	f008 fde2 	bl	800a0cc <RTC_SetDate>

	// alarm A configuration
	sAlarm.hour = 00;
 8001508:	2300      	movs	r3, #0
 800150a:	703b      	strb	r3, [r7, #0]
	sAlarm.minute = 00;
 800150c:	2300      	movs	r3, #0
 800150e:	707b      	strb	r3, [r7, #1]
	sAlarm.second = 00;
 8001510:	2300      	movs	r3, #0
 8001512:	70bb      	strb	r3, [r7, #2]
	sAlarm.sec_msk = RTC_ALARM_MASK_UNMASKED;
 8001514:	2300      	movs	r3, #0
 8001516:	70fb      	strb	r3, [r7, #3]
	sAlarm.min_msk = RTC_ALARM_MASK_MINUTES;
 8001518:	2301      	movs	r3, #1
 800151a:	713b      	strb	r3, [r7, #4]
	sAlarm.hour_msk = RTC_ALARM_MASK_HOURS;
 800151c:	2301      	movs	r3, #1
 800151e:	717b      	strb	r3, [r7, #5]
	sAlarm.dateweek_msk = RTC_ALARM_MASK_DATEWEEKDAY;
 8001520:	2301      	movs	r3, #1
 8001522:	71bb      	strb	r3, [r7, #6]
	RTC_SetAlarm_IT(&hrtc, RTC_ALARM_A, &sAlarm);
 8001524:	463b      	mov	r3, r7
 8001526:	461a      	mov	r2, r3
 8001528:	2100      	movs	r1, #0
 800152a:	480f      	ldr	r0, [pc, #60]	@ (8001568 <RTC_Config+0xc0>)
 800152c:	f008 fee2 	bl	800a2f4 <RTC_SetAlarm_IT>

	EXTI->IMR.bit.mr17 = SET;
 8001530:	4a0e      	ldr	r2, [pc, #56]	@ (800156c <RTC_Config+0xc4>)
 8001532:	6813      	ldr	r3, [r2, #0]
 8001534:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001538:	6013      	str	r3, [r2, #0]
	EXTI->RTSR.bit.tr17 = SET;
 800153a:	4a0c      	ldr	r2, [pc, #48]	@ (800156c <RTC_Config+0xc4>)
 800153c:	6893      	ldr	r3, [r2, #8]
 800153e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001542:	6093      	str	r3, [r2, #8]

	RTC->WPR.bit.key = 0xFFU;
 8001544:	4a0a      	ldr	r2, [pc, #40]	@ (8001570 <RTC_Config+0xc8>)
 8001546:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8001548:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 800154c:	6253      	str	r3, [r2, #36]	@ 0x24

	HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 800154e:	2200      	movs	r2, #0
 8001550:	2100      	movs	r1, #0
 8001552:	2029      	movs	r0, #41	@ 0x29
 8001554:	f000 fc45 	bl	8001de2 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 8001558:	2029      	movs	r0, #41	@ 0x29
 800155a:	f000 fc5e 	bl	8001e1a <HAL_NVIC_EnableIRQ>

}
 800155e:	bf00      	nop
 8001560:	3708      	adds	r7, #8
 8001562:	46bd      	mov	sp, r7
 8001564:	bd80      	pop	{r7, pc}
 8001566:	bf00      	nop
 8001568:	2000016c 	.word	0x2000016c
 800156c:	40013c00 	.word	0x40013c00
 8001570:	40002800 	.word	0x40002800

08001574 <Error_Handler>:

void Error_Handler(void)
{
 8001574:	b480      	push	{r7}
 8001576:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001578:	b672      	cpsid	i
}
 800157a:	bf00      	nop
	__disable_irq();
	while (1)
 800157c:	bf00      	nop
 800157e:	e7fd      	b.n	800157c <Error_Handler+0x8>

08001580 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001580:	b480      	push	{r7}
 8001582:	af00      	add	r7, sp, #0

  RCC->APB2ENR.bit.syscfgen = SET;
 8001584:	4a07      	ldr	r2, [pc, #28]	@ (80015a4 <HAL_MspInit+0x24>)
 8001586:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 8001588:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800158c:	6453      	str	r3, [r2, #68]	@ 0x44
  RCC->APB1ENR.bit.pwren = SET;
 800158e:	4a05      	ldr	r2, [pc, #20]	@ (80015a4 <HAL_MspInit+0x24>)
 8001590:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8001592:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8001596:	6413      	str	r3, [r2, #64]	@ 0x40

}
 8001598:	bf00      	nop
 800159a:	46bd      	mov	sp, r7
 800159c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015a0:	4770      	bx	lr
 80015a2:	bf00      	nop
 80015a4:	40023800 	.word	0x40023800

080015a8 <HAL_DCMI_MspInit>:
* This function configures the hardware resources used in this example
* @param hdcmi: DCMI handle pointer
* @retval None
*/
void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi)
{
 80015a8:	b580      	push	{r7, lr}
 80015aa:	b086      	sub	sp, #24
 80015ac:	af00      	add	r7, sp, #0
 80015ae:	6078      	str	r0, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct = {0};
 80015b0:	f107 0308 	add.w	r3, r7, #8
 80015b4:	2200      	movs	r2, #0
 80015b6:	601a      	str	r2, [r3, #0]
 80015b8:	605a      	str	r2, [r3, #4]
 80015ba:	609a      	str	r2, [r3, #8]
 80015bc:	60da      	str	r2, [r3, #12]
  if(hdcmi->Instance==DCMI)
 80015be:	687b      	ldr	r3, [r7, #4]
 80015c0:	681b      	ldr	r3, [r3, #0]
 80015c2:	4a70      	ldr	r2, [pc, #448]	@ (8001784 <HAL_DCMI_MspInit+0x1dc>)
 80015c4:	4293      	cmp	r3, r2
 80015c6:	f040 80d9 	bne.w	800177c <HAL_DCMI_MspInit+0x1d4>
  {

    /* Peripheral clock enable */
	  RCC->AHB2ENR.bit.dcmien = SET;
 80015ca:	4a6f      	ldr	r2, [pc, #444]	@ (8001788 <HAL_DCMI_MspInit+0x1e0>)
 80015cc:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 80015ce:	f043 0301 	orr.w	r3, r3, #1
 80015d2:	6353      	str	r3, [r2, #52]	@ 0x34

	  RCC->AHB1ENR.bit.gpioeen = SET;
 80015d4:	4a6c      	ldr	r2, [pc, #432]	@ (8001788 <HAL_DCMI_MspInit+0x1e0>)
 80015d6:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80015d8:	f043 0310 	orr.w	r3, r3, #16
 80015dc:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpioaen = SET;
 80015de:	4a6a      	ldr	r2, [pc, #424]	@ (8001788 <HAL_DCMI_MspInit+0x1e0>)
 80015e0:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80015e2:	f043 0301 	orr.w	r3, r3, #1
 80015e6:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpiocen = SET;
 80015e8:	4a67      	ldr	r2, [pc, #412]	@ (8001788 <HAL_DCMI_MspInit+0x1e0>)
 80015ea:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80015ec:	f043 0304 	orr.w	r3, r3, #4
 80015f0:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpioben = SET;
 80015f2:	4a65      	ldr	r2, [pc, #404]	@ (8001788 <HAL_DCMI_MspInit+0x1e0>)
 80015f4:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80015f6:	f043 0302 	orr.w	r3, r3, #2
 80015fa:	6313      	str	r3, [r2, #48]	@ 0x30
    PC8     ------> DCMI_D2
    PB6     ------> DCMI_D5
    PB7     ------> DCMI_VSYNC
    PE1     ------> DCMI_D3
    */
	  GPIO_InitStruct.pGPIOx = GPIOE;
 80015fc:	4b63      	ldr	r3, [pc, #396]	@ (800178c <HAL_DCMI_MspInit+0x1e4>)
 80015fe:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_4;
 8001600:	2304      	movs	r3, #4
 8001602:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8001604:	2302      	movs	r3, #2
 8001606:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 8001608:	2300      	movs	r3, #0
 800160a:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 800160c:	2300      	movs	r3, #0
 800160e:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001610:	2300      	movs	r3, #0
 8001612:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 8001614:	230d      	movs	r3, #13
 8001616:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 8001618:	f107 0308 	add.w	r3, r7, #8
 800161c:	4618      	mov	r0, r3
 800161e:	f007 ff0d 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_5;
 8001622:	2305      	movs	r3, #5
 8001624:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001626:	f107 0308 	add.w	r3, r7, #8
 800162a:	4618      	mov	r0, r3
 800162c:	f007 ff06 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 8001630:	2306      	movs	r3, #6
 8001632:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001634:	f107 0308 	add.w	r3, r7, #8
 8001638:	4618      	mov	r0, r3
 800163a:	f007 feff 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_1;
 800163e:	2301      	movs	r3, #1
 8001640:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001642:	f107 0308 	add.w	r3, r7, #8
 8001646:	4618      	mov	r0, r3
 8001648:	f007 fef8 	bl	800943c <GPIO_Init>


	  GPIO_InitStruct.pGPIOx = GPIOA;
 800164c:	4b50      	ldr	r3, [pc, #320]	@ (8001790 <HAL_DCMI_MspInit+0x1e8>)
 800164e:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_4;
 8001650:	2304      	movs	r3, #4
 8001652:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8001654:	2302      	movs	r3, #2
 8001656:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 8001658:	2300      	movs	r3, #0
 800165a:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 800165c:	2300      	movs	r3, #0
 800165e:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001660:	2300      	movs	r3, #0
 8001662:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 8001664:	230d      	movs	r3, #13
 8001666:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 8001668:	f107 0308 	add.w	r3, r7, #8
 800166c:	4618      	mov	r0, r3
 800166e:	f007 fee5 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 8001672:	2306      	movs	r3, #6
 8001674:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001676:	f107 0308 	add.w	r3, r7, #8
 800167a:	4618      	mov	r0, r3
 800167c:	f007 fede 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.pGPIOx = GPIOC;
 8001680:	4b44      	ldr	r3, [pc, #272]	@ (8001794 <HAL_DCMI_MspInit+0x1ec>)
 8001682:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 8001684:	2306      	movs	r3, #6
 8001686:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8001688:	2302      	movs	r3, #2
 800168a:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800168c:	2300      	movs	r3, #0
 800168e:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8001690:	2300      	movs	r3, #0
 8001692:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001694:	2300      	movs	r3, #0
 8001696:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 8001698:	230d      	movs	r3, #13
 800169a:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 800169c:	f107 0308 	add.w	r3, r7, #8
 80016a0:	4618      	mov	r0, r3
 80016a2:	f007 fecb 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_7;
 80016a6:	2307      	movs	r3, #7
 80016a8:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80016aa:	f107 0308 	add.w	r3, r7, #8
 80016ae:	4618      	mov	r0, r3
 80016b0:	f007 fec4 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_8;
 80016b4:	2308      	movs	r3, #8
 80016b6:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80016b8:	f107 0308 	add.w	r3, r7, #8
 80016bc:	4618      	mov	r0, r3
 80016be:	f007 febd 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.pGPIOx = GPIOB;
 80016c2:	4b35      	ldr	r3, [pc, #212]	@ (8001798 <HAL_DCMI_MspInit+0x1f0>)
 80016c4:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 80016c6:	2306      	movs	r3, #6
 80016c8:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 80016ca:	2302      	movs	r3, #2
 80016cc:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 80016ce:	2300      	movs	r3, #0
 80016d0:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 80016d2:	2300      	movs	r3, #0
 80016d4:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 80016d6:	2300      	movs	r3, #0
 80016d8:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 80016da:	230d      	movs	r3, #13
 80016dc:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 80016de:	f107 0308 	add.w	r3, r7, #8
 80016e2:	4618      	mov	r0, r3
 80016e4:	f007 feaa 	bl	800943c <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_7;
 80016e8:	2307      	movs	r3, #7
 80016ea:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80016ec:	f107 0308 	add.w	r3, r7, #8
 80016f0:	4618      	mov	r0, r3
 80016f2:	f007 fea3 	bl	800943c <GPIO_Init>


    /* DCMI DMA Init */
    /* DCMI Init */
    hdma_dcmi.Instance = DMA2_Stream1;
 80016f6:	4b29      	ldr	r3, [pc, #164]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 80016f8:	4a29      	ldr	r2, [pc, #164]	@ (80017a0 <HAL_DCMI_MspInit+0x1f8>)
 80016fa:	601a      	str	r2, [r3, #0]
    hdma_dcmi.Init.Channel = DMA_CHANNEL_1;
 80016fc:	4b27      	ldr	r3, [pc, #156]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 80016fe:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 8001702:	605a      	str	r2, [r3, #4]
    hdma_dcmi.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001704:	4b25      	ldr	r3, [pc, #148]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001706:	2200      	movs	r2, #0
 8001708:	609a      	str	r2, [r3, #8]
    hdma_dcmi.Init.PeriphInc = DMA_PINC_DISABLE;
 800170a:	4b24      	ldr	r3, [pc, #144]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 800170c:	2200      	movs	r2, #0
 800170e:	60da      	str	r2, [r3, #12]
    hdma_dcmi.Init.MemInc = DMA_MINC_ENABLE;
 8001710:	4b22      	ldr	r3, [pc, #136]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001712:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8001716:	611a      	str	r2, [r3, #16]
    hdma_dcmi.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8001718:	4b20      	ldr	r3, [pc, #128]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 800171a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 800171e:	615a      	str	r2, [r3, #20]
    hdma_dcmi.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8001720:	4b1e      	ldr	r3, [pc, #120]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001722:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8001726:	619a      	str	r2, [r3, #24]
    hdma_dcmi.Init.Mode = DMA_CIRCULAR;
 8001728:	4b1c      	ldr	r3, [pc, #112]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 800172a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800172e:	61da      	str	r2, [r3, #28]
    hdma_dcmi.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8001730:	4b1a      	ldr	r3, [pc, #104]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001732:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 8001736:	621a      	str	r2, [r3, #32]
    hdma_dcmi.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8001738:	4b18      	ldr	r3, [pc, #96]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 800173a:	2204      	movs	r2, #4
 800173c:	625a      	str	r2, [r3, #36]	@ 0x24
    hdma_dcmi.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 800173e:	4b17      	ldr	r3, [pc, #92]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001740:	2203      	movs	r2, #3
 8001742:	629a      	str	r2, [r3, #40]	@ 0x28
    hdma_dcmi.Init.MemBurst = DMA_MBURST_SINGLE;
 8001744:	4b15      	ldr	r3, [pc, #84]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001746:	2200      	movs	r2, #0
 8001748:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdma_dcmi.Init.PeriphBurst = DMA_PBURST_SINGLE;
 800174a:	4b14      	ldr	r3, [pc, #80]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 800174c:	2200      	movs	r2, #0
 800174e:	631a      	str	r2, [r3, #48]	@ 0x30
    if (HAL_DMA_Init(&hdma_dcmi) != HAL_OK)
 8001750:	4812      	ldr	r0, [pc, #72]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001752:	f000 fe39 	bl	80023c8 <HAL_DMA_Init>
 8001756:	4603      	mov	r3, r0
 8001758:	2b00      	cmp	r3, #0
 800175a:	d001      	beq.n	8001760 <HAL_DCMI_MspInit+0x1b8>
    {
      Error_Handler();
 800175c:	f7ff ff0a 	bl	8001574 <Error_Handler>
    }

    __HAL_LINKDMA(hdcmi,DMA_Handle,hdma_dcmi);
 8001760:	687b      	ldr	r3, [r7, #4]
 8001762:	4a0e      	ldr	r2, [pc, #56]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001764:	639a      	str	r2, [r3, #56]	@ 0x38
 8001766:	4a0d      	ldr	r2, [pc, #52]	@ (800179c <HAL_DCMI_MspInit+0x1f4>)
 8001768:	687b      	ldr	r3, [r7, #4]
 800176a:	6393      	str	r3, [r2, #56]	@ 0x38

    /* DCMI interrupt Init */
    HAL_NVIC_SetPriority(DCMI_IRQn, 0, 0);
 800176c:	2200      	movs	r2, #0
 800176e:	2100      	movs	r1, #0
 8001770:	204e      	movs	r0, #78	@ 0x4e
 8001772:	f000 fb36 	bl	8001de2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMI_IRQn);
 8001776:	204e      	movs	r0, #78	@ 0x4e
 8001778:	f000 fb4f 	bl	8001e1a <HAL_NVIC_EnableIRQ>

  }

}
 800177c:	bf00      	nop
 800177e:	3718      	adds	r7, #24
 8001780:	46bd      	mov	sp, r7
 8001782:	bd80      	pop	{r7, pc}
 8001784:	50050000 	.word	0x50050000
 8001788:	40023800 	.word	0x40023800
 800178c:	40021000 	.word	0x40021000
 8001790:	40020000 	.word	0x40020000
 8001794:	40020800 	.word	0x40020800
 8001798:	40020400 	.word	0x40020400
 800179c:	200000e4 	.word	0x200000e4
 80017a0:	40026428 	.word	0x40026428

080017a4 <EXTI0_IRQHandler>:
extern DMA_HandleTypeDef hdma_dcmi;
extern DCMI_HandleTypeDef hdcmi;


void EXTI0_IRQHandler(void)
{
 80017a4:	b580      	push	{r7, lr}
 80017a6:	b082      	sub	sp, #8
 80017a8:	af00      	add	r7, sp, #0
	static uint32_t last_time = 0;
	uint32_t current_time = HAL_GetTick();
 80017aa:	f000 fa0f 	bl	8001bcc <HAL_GetTick>
 80017ae:	6078      	str	r0, [r7, #4]
	 if((current_time - last_time) > 300)	//debouncing
 80017b0:	4b0e      	ldr	r3, [pc, #56]	@ (80017ec <EXTI0_IRQHandler+0x48>)
 80017b2:	681b      	ldr	r3, [r3, #0]
 80017b4:	687a      	ldr	r2, [r7, #4]
 80017b6:	1ad3      	subs	r3, r2, r3
 80017b8:	f5b3 7f96 	cmp.w	r3, #300	@ 0x12c
 80017bc:	d90d      	bls.n	80017da <EXTI0_IRQHandler+0x36>
	 {
		 begin_rec = 1;
 80017be:	4b0c      	ldr	r3, [pc, #48]	@ (80017f0 <EXTI0_IRQHandler+0x4c>)
 80017c0:	2201      	movs	r2, #1
 80017c2:	701a      	strb	r2, [r3, #0]
		 if (read_avi_output_status() == AVI_START)
 80017c4:	f006 fc0e 	bl	8007fe4 <read_avi_output_status>
 80017c8:	4603      	mov	r3, r0
 80017ca:	2b01      	cmp	r3, #1
 80017cc:	d102      	bne.n	80017d4 <EXTI0_IRQHandler+0x30>
		 {
			 set_avi_output_status(AVI_PENDING); // stop recording
 80017ce:	2002      	movs	r0, #2
 80017d0:	f006 fbf8 	bl	8007fc4 <set_avi_output_status>
		 }
		 last_time = current_time; // Update the last_time
 80017d4:	4a05      	ldr	r2, [pc, #20]	@ (80017ec <EXTI0_IRQHandler+0x48>)
 80017d6:	687b      	ldr	r3, [r7, #4]
 80017d8:	6013      	str	r3, [r2, #0]
	 }
	 EXTI->PR.bit.pr0 = SET;	 // clear interrupt pending bit for EXTI Line 0
 80017da:	4a06      	ldr	r2, [pc, #24]	@ (80017f4 <EXTI0_IRQHandler+0x50>)
 80017dc:	6953      	ldr	r3, [r2, #20]
 80017de:	f043 0301 	orr.w	r3, r3, #1
 80017e2:	6153      	str	r3, [r2, #20]
}
 80017e4:	bf00      	nop
 80017e6:	3708      	adds	r7, #8
 80017e8:	46bd      	mov	sp, r7
 80017ea:	bd80      	pop	{r7, pc}
 80017ec:	20002250 	.word	0x20002250
 80017f0:	200021e4 	.word	0x200021e4
 80017f4:	40013c00 	.word	0x40013c00

080017f8 <RTC_Alarm_IRQHandler>:

void RTC_Alarm_IRQHandler(void)
{
 80017f8:	b580      	push	{r7, lr}
 80017fa:	af00      	add	r7, sp, #0
	EXTI->PR.bit.pr17 = SET;
 80017fc:	4a12      	ldr	r2, [pc, #72]	@ (8001848 <RTC_Alarm_IRQHandler+0x50>)
 80017fe:	6953      	ldr	r3, [r2, #20]
 8001800:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001804:	6153      	str	r3, [r2, #20]

	if(SET == RTC->CR.bit.alraie)
 8001806:	4b11      	ldr	r3, [pc, #68]	@ (800184c <RTC_Alarm_IRQHandler+0x54>)
 8001808:	689b      	ldr	r3, [r3, #8]
 800180a:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800180e:	b2db      	uxtb	r3, r3
 8001810:	2b01      	cmp	r3, #1
 8001812:	d116      	bne.n	8001842 <RTC_Alarm_IRQHandler+0x4a>
	{
		if(SET == RTC->ISR.bit.alraf)
 8001814:	4b0d      	ldr	r3, [pc, #52]	@ (800184c <RTC_Alarm_IRQHandler+0x54>)
 8001816:	68db      	ldr	r3, [r3, #12]
 8001818:	f3c3 2300 	ubfx	r3, r3, #8, #1
 800181c:	b2db      	uxtb	r3, r3
 800181e:	2b01      	cmp	r3, #1
 8001820:	d10f      	bne.n	8001842 <RTC_Alarm_IRQHandler+0x4a>
		{
			RTC->ISR.bit.alraf = RESET;
 8001822:	4a0a      	ldr	r2, [pc, #40]	@ (800184c <RTC_Alarm_IRQHandler+0x54>)
 8001824:	68d3      	ldr	r3, [r2, #12]
 8001826:	f36f 2308 	bfc	r3, #8, #1
 800182a:	60d3      	str	r3, [r2, #12]
			begin_rec = 1;
 800182c:	4b08      	ldr	r3, [pc, #32]	@ (8001850 <RTC_Alarm_IRQHandler+0x58>)
 800182e:	2201      	movs	r2, #1
 8001830:	701a      	strb	r2, [r3, #0]
			if (read_avi_output_status() == AVI_START)
 8001832:	f006 fbd7 	bl	8007fe4 <read_avi_output_status>
 8001836:	4603      	mov	r3, r0
 8001838:	2b01      	cmp	r3, #1
 800183a:	d102      	bne.n	8001842 <RTC_Alarm_IRQHandler+0x4a>
			{
				set_avi_output_status(AVI_PENDING); // stop recording
 800183c:	2002      	movs	r0, #2
 800183e:	f006 fbc1 	bl	8007fc4 <set_avi_output_status>
			}
		}
	}
}
 8001842:	bf00      	nop
 8001844:	bd80      	pop	{r7, pc}
 8001846:	bf00      	nop
 8001848:	40013c00 	.word	0x40013c00
 800184c:	40002800 	.word	0x40002800
 8001850:	200021e4 	.word	0x200021e4

08001854 <NMI_Handler>:

void NMI_Handler(void)
{
 8001854:	b480      	push	{r7}
 8001856:	af00      	add	r7, sp, #0
   while (1)
 8001858:	bf00      	nop
 800185a:	e7fd      	b.n	8001858 <NMI_Handler+0x4>

0800185c <HardFault_Handler>:
  }

}

void HardFault_Handler(void)
{
 800185c:	b480      	push	{r7}
 800185e:	af00      	add	r7, sp, #0

  while (1)
 8001860:	bf00      	nop
 8001862:	e7fd      	b.n	8001860 <HardFault_Handler+0x4>

08001864 <MemManage_Handler>:

  }
}

void MemManage_Handler(void)
{
 8001864:	b480      	push	{r7}
 8001866:	af00      	add	r7, sp, #0

  while (1)
 8001868:	bf00      	nop
 800186a:	e7fd      	b.n	8001868 <MemManage_Handler+0x4>

0800186c <BusFault_Handler>:

  }
}

void BusFault_Handler(void)
{
 800186c:	b480      	push	{r7}
 800186e:	af00      	add	r7, sp, #0

  while (1)
 8001870:	bf00      	nop
 8001872:	e7fd      	b.n	8001870 <BusFault_Handler+0x4>

08001874 <UsageFault_Handler>:
  }
}


void UsageFault_Handler(void)
{
 8001874:	b480      	push	{r7}
 8001876:	af00      	add	r7, sp, #0

  while (1)
 8001878:	bf00      	nop
 800187a:	e7fd      	b.n	8001878 <UsageFault_Handler+0x4>

0800187c <SVC_Handler>:

  }
}

void SVC_Handler(void)
{
 800187c:	b480      	push	{r7}
 800187e:	af00      	add	r7, sp, #0

}
 8001880:	bf00      	nop
 8001882:	46bd      	mov	sp, r7
 8001884:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001888:	4770      	bx	lr

0800188a <DebugMon_Handler>:

void DebugMon_Handler(void)
{
 800188a:	b480      	push	{r7}
 800188c:	af00      	add	r7, sp, #0

}
 800188e:	bf00      	nop
 8001890:	46bd      	mov	sp, r7
 8001892:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001896:	4770      	bx	lr

08001898 <PendSV_Handler>:

void PendSV_Handler(void)
{
 8001898:	b480      	push	{r7}
 800189a:	af00      	add	r7, sp, #0

}
 800189c:	bf00      	nop
 800189e:	46bd      	mov	sp, r7
 80018a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018a4:	4770      	bx	lr

080018a6 <SysTick_Handler>:


void SysTick_Handler(void)
{
 80018a6:	b580      	push	{r7, lr}
 80018a8:	af00      	add	r7, sp, #0
	HAL_IncTick();
 80018aa:	f000 f97b 	bl	8001ba4 <HAL_IncTick>
}
 80018ae:	bf00      	nop
 80018b0:	bd80      	pop	{r7, pc}
	...

080018b4 <DMA2_Stream1_IRQHandler>:


void DMA2_Stream1_IRQHandler(void)
{
 80018b4:	b580      	push	{r7, lr}
 80018b6:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_dcmi);
 80018b8:	4802      	ldr	r0, [pc, #8]	@ (80018c4 <DMA2_Stream1_IRQHandler+0x10>)
 80018ba:	f000 ff1d 	bl	80026f8 <HAL_DMA_IRQHandler>
}
 80018be:	bf00      	nop
 80018c0:	bd80      	pop	{r7, pc}
 80018c2:	bf00      	nop
 80018c4:	200000e4 	.word	0x200000e4

080018c8 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 80018c8:	b580      	push	{r7, lr}
 80018ca:	af00      	add	r7, sp, #0

  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 80018cc:	4802      	ldr	r0, [pc, #8]	@ (80018d8 <OTG_FS_IRQHandler+0x10>)
 80018ce:	f002 fde5 	bl	800449c <HAL_HCD_IRQHandler>
}
 80018d2:	bf00      	nop
 80018d4:	bd80      	pop	{r7, pc}
 80018d6:	bf00      	nop
 80018d8:	20002cfc 	.word	0x20002cfc

080018dc <DCMI_IRQHandler>:


void DCMI_IRQHandler(void)
{
 80018dc:	b580      	push	{r7, lr}
 80018de:	af00      	add	r7, sp, #0

  HAL_DCMI_IRQHandler(&hdcmi);
 80018e0:	4802      	ldr	r0, [pc, #8]	@ (80018ec <DCMI_IRQHandler+0x10>)
 80018e2:	f000 fbb1 	bl	8002048 <HAL_DCMI_IRQHandler>

}
 80018e6:	bf00      	nop
 80018e8:	bd80      	pop	{r7, pc}
 80018ea:	bf00      	nop
 80018ec:	200000a4 	.word	0x200000a4

080018f0 <ITM_SendChar>:
/* ITM register addresses */
#define ITM_STIMULUS_PORT0   	*((volatile uint32_t*) 0xE0000000 )
#define ITM_TRACE_EN          	*((volatile uint32_t*) 0xE0000E00 )

void ITM_SendChar(uint8_t ch)
{
 80018f0:	b480      	push	{r7}
 80018f2:	b083      	sub	sp, #12
 80018f4:	af00      	add	r7, sp, #0
 80018f6:	4603      	mov	r3, r0
 80018f8:	71fb      	strb	r3, [r7, #7]

	//Enable TRCENA
	DEMCR |= ( 1 << 24);
 80018fa:	4b0f      	ldr	r3, [pc, #60]	@ (8001938 <ITM_SendChar+0x48>)
 80018fc:	681b      	ldr	r3, [r3, #0]
 80018fe:	4a0e      	ldr	r2, [pc, #56]	@ (8001938 <ITM_SendChar+0x48>)
 8001900:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001904:	6013      	str	r3, [r2, #0]

	//enable stimulus port 0
	ITM_TRACE_EN |= ( 1 << 0);
 8001906:	4b0d      	ldr	r3, [pc, #52]	@ (800193c <ITM_SendChar+0x4c>)
 8001908:	681b      	ldr	r3, [r3, #0]
 800190a:	4a0c      	ldr	r2, [pc, #48]	@ (800193c <ITM_SendChar+0x4c>)
 800190c:	f043 0301 	orr.w	r3, r3, #1
 8001910:	6013      	str	r3, [r2, #0]

	// read FIFO status in bit [0]:
	while(!(ITM_STIMULUS_PORT0 & 1));
 8001912:	bf00      	nop
 8001914:	f04f 4360 	mov.w	r3, #3758096384	@ 0xe0000000
 8001918:	681b      	ldr	r3, [r3, #0]
 800191a:	f003 0301 	and.w	r3, r3, #1
 800191e:	2b00      	cmp	r3, #0
 8001920:	d0f8      	beq.n	8001914 <ITM_SendChar+0x24>

	//Write to ITM stimulus port0
	ITM_STIMULUS_PORT0 = ch;
 8001922:	f04f 4260 	mov.w	r2, #3758096384	@ 0xe0000000
 8001926:	79fb      	ldrb	r3, [r7, #7]
 8001928:	6013      	str	r3, [r2, #0]
}
 800192a:	bf00      	nop
 800192c:	370c      	adds	r7, #12
 800192e:	46bd      	mov	sp, r7
 8001930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001934:	4770      	bx	lr
 8001936:	bf00      	nop
 8001938:	e000edfc 	.word	0xe000edfc
 800193c:	e0000e00 	.word	0xe0000e00

08001940 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001940:	b580      	push	{r7, lr}
 8001942:	b086      	sub	sp, #24
 8001944:	af00      	add	r7, sp, #0
 8001946:	60f8      	str	r0, [r7, #12]
 8001948:	60b9      	str	r1, [r7, #8]
 800194a:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800194c:	2300      	movs	r3, #0
 800194e:	617b      	str	r3, [r7, #20]
 8001950:	e00a      	b.n	8001968 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8001952:	f3af 8000 	nop.w
 8001956:	4601      	mov	r1, r0
 8001958:	68bb      	ldr	r3, [r7, #8]
 800195a:	1c5a      	adds	r2, r3, #1
 800195c:	60ba      	str	r2, [r7, #8]
 800195e:	b2ca      	uxtb	r2, r1
 8001960:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001962:	697b      	ldr	r3, [r7, #20]
 8001964:	3301      	adds	r3, #1
 8001966:	617b      	str	r3, [r7, #20]
 8001968:	697a      	ldr	r2, [r7, #20]
 800196a:	687b      	ldr	r3, [r7, #4]
 800196c:	429a      	cmp	r2, r3
 800196e:	dbf0      	blt.n	8001952 <_read+0x12>
  }

  return len;
 8001970:	687b      	ldr	r3, [r7, #4]
}
 8001972:	4618      	mov	r0, r3
 8001974:	3718      	adds	r7, #24
 8001976:	46bd      	mov	sp, r7
 8001978:	bd80      	pop	{r7, pc}

0800197a <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800197a:	b580      	push	{r7, lr}
 800197c:	b086      	sub	sp, #24
 800197e:	af00      	add	r7, sp, #0
 8001980:	60f8      	str	r0, [r7, #12]
 8001982:	60b9      	str	r1, [r7, #8]
 8001984:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001986:	2300      	movs	r3, #0
 8001988:	617b      	str	r3, [r7, #20]
 800198a:	e009      	b.n	80019a0 <_write+0x26>
  {
//    __io_putchar(*ptr++);
	  ITM_SendChar(*ptr++);
 800198c:	68bb      	ldr	r3, [r7, #8]
 800198e:	1c5a      	adds	r2, r3, #1
 8001990:	60ba      	str	r2, [r7, #8]
 8001992:	781b      	ldrb	r3, [r3, #0]
 8001994:	4618      	mov	r0, r3
 8001996:	f7ff ffab 	bl	80018f0 <ITM_SendChar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800199a:	697b      	ldr	r3, [r7, #20]
 800199c:	3301      	adds	r3, #1
 800199e:	617b      	str	r3, [r7, #20]
 80019a0:	697a      	ldr	r2, [r7, #20]
 80019a2:	687b      	ldr	r3, [r7, #4]
 80019a4:	429a      	cmp	r2, r3
 80019a6:	dbf1      	blt.n	800198c <_write+0x12>
  }
  return len;
 80019a8:	687b      	ldr	r3, [r7, #4]
}
 80019aa:	4618      	mov	r0, r3
 80019ac:	3718      	adds	r7, #24
 80019ae:	46bd      	mov	sp, r7
 80019b0:	bd80      	pop	{r7, pc}

080019b2 <_close>:

int _close(int file)
{
 80019b2:	b480      	push	{r7}
 80019b4:	b083      	sub	sp, #12
 80019b6:	af00      	add	r7, sp, #0
 80019b8:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 80019ba:	f04f 33ff 	mov.w	r3, #4294967295
}
 80019be:	4618      	mov	r0, r3
 80019c0:	370c      	adds	r7, #12
 80019c2:	46bd      	mov	sp, r7
 80019c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019c8:	4770      	bx	lr

080019ca <_fstat>:


int _fstat(int file, struct stat *st)
{
 80019ca:	b480      	push	{r7}
 80019cc:	b083      	sub	sp, #12
 80019ce:	af00      	add	r7, sp, #0
 80019d0:	6078      	str	r0, [r7, #4]
 80019d2:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 80019d4:	683b      	ldr	r3, [r7, #0]
 80019d6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 80019da:	605a      	str	r2, [r3, #4]
  return 0;
 80019dc:	2300      	movs	r3, #0
}
 80019de:	4618      	mov	r0, r3
 80019e0:	370c      	adds	r7, #12
 80019e2:	46bd      	mov	sp, r7
 80019e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019e8:	4770      	bx	lr

080019ea <_isatty>:

int _isatty(int file)
{
 80019ea:	b480      	push	{r7}
 80019ec:	b083      	sub	sp, #12
 80019ee:	af00      	add	r7, sp, #0
 80019f0:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 80019f2:	2301      	movs	r3, #1
}
 80019f4:	4618      	mov	r0, r3
 80019f6:	370c      	adds	r7, #12
 80019f8:	46bd      	mov	sp, r7
 80019fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019fe:	4770      	bx	lr

08001a00 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8001a00:	b480      	push	{r7}
 8001a02:	b085      	sub	sp, #20
 8001a04:	af00      	add	r7, sp, #0
 8001a06:	60f8      	str	r0, [r7, #12]
 8001a08:	60b9      	str	r1, [r7, #8]
 8001a0a:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 8001a0c:	2300      	movs	r3, #0
}
 8001a0e:	4618      	mov	r0, r3
 8001a10:	3714      	adds	r7, #20
 8001a12:	46bd      	mov	sp, r7
 8001a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a18:	4770      	bx	lr
	...

08001a1c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001a1c:	b580      	push	{r7, lr}
 8001a1e:	b086      	sub	sp, #24
 8001a20:	af00      	add	r7, sp, #0
 8001a22:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001a24:	4a14      	ldr	r2, [pc, #80]	@ (8001a78 <_sbrk+0x5c>)
 8001a26:	4b15      	ldr	r3, [pc, #84]	@ (8001a7c <_sbrk+0x60>)
 8001a28:	1ad3      	subs	r3, r2, r3
 8001a2a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001a2c:	697b      	ldr	r3, [r7, #20]
 8001a2e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001a30:	4b13      	ldr	r3, [pc, #76]	@ (8001a80 <_sbrk+0x64>)
 8001a32:	681b      	ldr	r3, [r3, #0]
 8001a34:	2b00      	cmp	r3, #0
 8001a36:	d102      	bne.n	8001a3e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001a38:	4b11      	ldr	r3, [pc, #68]	@ (8001a80 <_sbrk+0x64>)
 8001a3a:	4a12      	ldr	r2, [pc, #72]	@ (8001a84 <_sbrk+0x68>)
 8001a3c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001a3e:	4b10      	ldr	r3, [pc, #64]	@ (8001a80 <_sbrk+0x64>)
 8001a40:	681a      	ldr	r2, [r3, #0]
 8001a42:	687b      	ldr	r3, [r7, #4]
 8001a44:	4413      	add	r3, r2
 8001a46:	693a      	ldr	r2, [r7, #16]
 8001a48:	429a      	cmp	r2, r3
 8001a4a:	d207      	bcs.n	8001a5c <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001a4c:	f02b ff30 	bl	802d8b0 <__errno>
 8001a50:	4603      	mov	r3, r0
 8001a52:	220c      	movs	r2, #12
 8001a54:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8001a56:	f04f 33ff 	mov.w	r3, #4294967295
 8001a5a:	e009      	b.n	8001a70 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8001a5c:	4b08      	ldr	r3, [pc, #32]	@ (8001a80 <_sbrk+0x64>)
 8001a5e:	681b      	ldr	r3, [r3, #0]
 8001a60:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001a62:	4b07      	ldr	r3, [pc, #28]	@ (8001a80 <_sbrk+0x64>)
 8001a64:	681a      	ldr	r2, [r3, #0]
 8001a66:	687b      	ldr	r3, [r7, #4]
 8001a68:	4413      	add	r3, r2
 8001a6a:	4a05      	ldr	r2, [pc, #20]	@ (8001a80 <_sbrk+0x64>)
 8001a6c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001a6e:	68fb      	ldr	r3, [r7, #12]
}
 8001a70:	4618      	mov	r0, r3
 8001a72:	3718      	adds	r7, #24
 8001a74:	46bd      	mov	sp, r7
 8001a76:	bd80      	pop	{r7, pc}
 8001a78:	20020000 	.word	0x20020000
 8001a7c:	00000400 	.word	0x00000400
 8001a80:	20002254 	.word	0x20002254
 8001a84:	20003228 	.word	0x20003228

08001a88 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001a88:	b480      	push	{r7}
 8001a8a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001a8c:	4b06      	ldr	r3, [pc, #24]	@ (8001aa8 <SystemInit+0x20>)
 8001a8e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8001a92:	4a05      	ldr	r2, [pc, #20]	@ (8001aa8 <SystemInit+0x20>)
 8001a94:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001a98:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001a9c:	bf00      	nop
 8001a9e:	46bd      	mov	sp, r7
 8001aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001aa4:	4770      	bx	lr
 8001aa6:	bf00      	nop
 8001aa8:	e000ed00 	.word	0xe000ed00

08001aac <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8001aac:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001ae4 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 8001ab0:	f7ff ffea 	bl	8001a88 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001ab4:	480c      	ldr	r0, [pc, #48]	@ (8001ae8 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001ab6:	490d      	ldr	r1, [pc, #52]	@ (8001aec <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001ab8:	4a0d      	ldr	r2, [pc, #52]	@ (8001af0 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001aba:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001abc:	e002      	b.n	8001ac4 <LoopCopyDataInit>

08001abe <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001abe:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001ac0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001ac2:	3304      	adds	r3, #4

08001ac4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001ac4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001ac6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001ac8:	d3f9      	bcc.n	8001abe <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001aca:	4a0a      	ldr	r2, [pc, #40]	@ (8001af4 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001acc:	4c0a      	ldr	r4, [pc, #40]	@ (8001af8 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001ace:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001ad0:	e001      	b.n	8001ad6 <LoopFillZerobss>

08001ad2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001ad2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001ad4:	3204      	adds	r2, #4

08001ad6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001ad6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001ad8:	d3fb      	bcc.n	8001ad2 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001ada:	f02b feef 	bl	802d8bc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001ade:	f7ff fb27 	bl	8001130 <main>
  bx  lr    
 8001ae2:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8001ae4:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001ae8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001aec:	20000088 	.word	0x20000088
  ldr r2, =_sidata
 8001af0:	08030de0 	.word	0x08030de0
  ldr r2, =_sbss
 8001af4:	20000088 	.word	0x20000088
  ldr r4, =_ebss
 8001af8:	20003228 	.word	0x20003228

08001afc <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001afc:	e7fe      	b.n	8001afc <ADC_IRQHandler>
	...

08001b00 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001b00:	b580      	push	{r7, lr}
 8001b02:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001b04:	4b0e      	ldr	r3, [pc, #56]	@ (8001b40 <HAL_Init+0x40>)
 8001b06:	681b      	ldr	r3, [r3, #0]
 8001b08:	4a0d      	ldr	r2, [pc, #52]	@ (8001b40 <HAL_Init+0x40>)
 8001b0a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001b0e:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001b10:	4b0b      	ldr	r3, [pc, #44]	@ (8001b40 <HAL_Init+0x40>)
 8001b12:	681b      	ldr	r3, [r3, #0]
 8001b14:	4a0a      	ldr	r2, [pc, #40]	@ (8001b40 <HAL_Init+0x40>)
 8001b16:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001b1a:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001b1c:	4b08      	ldr	r3, [pc, #32]	@ (8001b40 <HAL_Init+0x40>)
 8001b1e:	681b      	ldr	r3, [r3, #0]
 8001b20:	4a07      	ldr	r2, [pc, #28]	@ (8001b40 <HAL_Init+0x40>)
 8001b22:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001b26:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001b28:	2003      	movs	r0, #3
 8001b2a:	f000 f94f 	bl	8001dcc <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001b2e:	200f      	movs	r0, #15
 8001b30:	f000 f808 	bl	8001b44 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001b34:	f7ff fd24 	bl	8001580 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001b38:	2300      	movs	r3, #0
}
 8001b3a:	4618      	mov	r0, r3
 8001b3c:	bd80      	pop	{r7, pc}
 8001b3e:	bf00      	nop
 8001b40:	40023c00 	.word	0x40023c00

08001b44 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001b44:	b580      	push	{r7, lr}
 8001b46:	b082      	sub	sp, #8
 8001b48:	af00      	add	r7, sp, #0
 8001b4a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001b4c:	4b12      	ldr	r3, [pc, #72]	@ (8001b98 <HAL_InitTick+0x54>)
 8001b4e:	681a      	ldr	r2, [r3, #0]
 8001b50:	4b12      	ldr	r3, [pc, #72]	@ (8001b9c <HAL_InitTick+0x58>)
 8001b52:	781b      	ldrb	r3, [r3, #0]
 8001b54:	4619      	mov	r1, r3
 8001b56:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8001b5a:	fbb3 f3f1 	udiv	r3, r3, r1
 8001b5e:	fbb2 f3f3 	udiv	r3, r2, r3
 8001b62:	4618      	mov	r0, r3
 8001b64:	f000 f967 	bl	8001e36 <HAL_SYSTICK_Config>
 8001b68:	4603      	mov	r3, r0
 8001b6a:	2b00      	cmp	r3, #0
 8001b6c:	d001      	beq.n	8001b72 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001b6e:	2301      	movs	r3, #1
 8001b70:	e00e      	b.n	8001b90 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001b72:	687b      	ldr	r3, [r7, #4]
 8001b74:	2b0f      	cmp	r3, #15
 8001b76:	d80a      	bhi.n	8001b8e <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001b78:	2200      	movs	r2, #0
 8001b7a:	6879      	ldr	r1, [r7, #4]
 8001b7c:	f04f 30ff 	mov.w	r0, #4294967295
 8001b80:	f000 f92f 	bl	8001de2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001b84:	4a06      	ldr	r2, [pc, #24]	@ (8001ba0 <HAL_InitTick+0x5c>)
 8001b86:	687b      	ldr	r3, [r7, #4]
 8001b88:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001b8a:	2300      	movs	r3, #0
 8001b8c:	e000      	b.n	8001b90 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001b8e:	2301      	movs	r3, #1
}
 8001b90:	4618      	mov	r0, r3
 8001b92:	3708      	adds	r7, #8
 8001b94:	46bd      	mov	sp, r7
 8001b96:	bd80      	pop	{r7, pc}
 8001b98:	20000000 	.word	0x20000000
 8001b9c:	20000008 	.word	0x20000008
 8001ba0:	20000004 	.word	0x20000004

08001ba4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001ba4:	b480      	push	{r7}
 8001ba6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001ba8:	4b06      	ldr	r3, [pc, #24]	@ (8001bc4 <HAL_IncTick+0x20>)
 8001baa:	781b      	ldrb	r3, [r3, #0]
 8001bac:	461a      	mov	r2, r3
 8001bae:	4b06      	ldr	r3, [pc, #24]	@ (8001bc8 <HAL_IncTick+0x24>)
 8001bb0:	681b      	ldr	r3, [r3, #0]
 8001bb2:	4413      	add	r3, r2
 8001bb4:	4a04      	ldr	r2, [pc, #16]	@ (8001bc8 <HAL_IncTick+0x24>)
 8001bb6:	6013      	str	r3, [r2, #0]
}
 8001bb8:	bf00      	nop
 8001bba:	46bd      	mov	sp, r7
 8001bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bc0:	4770      	bx	lr
 8001bc2:	bf00      	nop
 8001bc4:	20000008 	.word	0x20000008
 8001bc8:	20002258 	.word	0x20002258

08001bcc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001bcc:	b480      	push	{r7}
 8001bce:	af00      	add	r7, sp, #0
  return uwTick;
 8001bd0:	4b03      	ldr	r3, [pc, #12]	@ (8001be0 <HAL_GetTick+0x14>)
 8001bd2:	681b      	ldr	r3, [r3, #0]
}
 8001bd4:	4618      	mov	r0, r3
 8001bd6:	46bd      	mov	sp, r7
 8001bd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bdc:	4770      	bx	lr
 8001bde:	bf00      	nop
 8001be0:	20002258 	.word	0x20002258

08001be4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001be4:	b580      	push	{r7, lr}
 8001be6:	b084      	sub	sp, #16
 8001be8:	af00      	add	r7, sp, #0
 8001bea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001bec:	f7ff ffee 	bl	8001bcc <HAL_GetTick>
 8001bf0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001bf6:	68fb      	ldr	r3, [r7, #12]
 8001bf8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001bfc:	d005      	beq.n	8001c0a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001bfe:	4b0a      	ldr	r3, [pc, #40]	@ (8001c28 <HAL_Delay+0x44>)
 8001c00:	781b      	ldrb	r3, [r3, #0]
 8001c02:	461a      	mov	r2, r3
 8001c04:	68fb      	ldr	r3, [r7, #12]
 8001c06:	4413      	add	r3, r2
 8001c08:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001c0a:	bf00      	nop
 8001c0c:	f7ff ffde 	bl	8001bcc <HAL_GetTick>
 8001c10:	4602      	mov	r2, r0
 8001c12:	68bb      	ldr	r3, [r7, #8]
 8001c14:	1ad3      	subs	r3, r2, r3
 8001c16:	68fa      	ldr	r2, [r7, #12]
 8001c18:	429a      	cmp	r2, r3
 8001c1a:	d8f7      	bhi.n	8001c0c <HAL_Delay+0x28>
  {
  }
}
 8001c1c:	bf00      	nop
 8001c1e:	bf00      	nop
 8001c20:	3710      	adds	r7, #16
 8001c22:	46bd      	mov	sp, r7
 8001c24:	bd80      	pop	{r7, pc}
 8001c26:	bf00      	nop
 8001c28:	20000008 	.word	0x20000008

08001c2c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
static inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001c2c:	b480      	push	{r7}
 8001c2e:	b085      	sub	sp, #20
 8001c30:	af00      	add	r7, sp, #0
 8001c32:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001c34:	687b      	ldr	r3, [r7, #4]
 8001c36:	f003 0307 	and.w	r3, r3, #7
 8001c3a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001c3c:	4b0c      	ldr	r3, [pc, #48]	@ (8001c70 <__NVIC_SetPriorityGrouping+0x44>)
 8001c3e:	68db      	ldr	r3, [r3, #12]
 8001c40:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001c42:	68ba      	ldr	r2, [r7, #8]
 8001c44:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8001c48:	4013      	ands	r3, r2
 8001c4a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001c4c:	68fb      	ldr	r3, [r7, #12]
 8001c4e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001c50:	68bb      	ldr	r3, [r7, #8]
 8001c52:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001c54:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001c58:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001c5c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001c5e:	4a04      	ldr	r2, [pc, #16]	@ (8001c70 <__NVIC_SetPriorityGrouping+0x44>)
 8001c60:	68bb      	ldr	r3, [r7, #8]
 8001c62:	60d3      	str	r3, [r2, #12]
}
 8001c64:	bf00      	nop
 8001c66:	3714      	adds	r7, #20
 8001c68:	46bd      	mov	sp, r7
 8001c6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c6e:	4770      	bx	lr
 8001c70:	e000ed00 	.word	0xe000ed00

08001c74 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
static inline uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001c74:	b480      	push	{r7}
 8001c76:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001c78:	4b04      	ldr	r3, [pc, #16]	@ (8001c8c <__NVIC_GetPriorityGrouping+0x18>)
 8001c7a:	68db      	ldr	r3, [r3, #12]
 8001c7c:	0a1b      	lsrs	r3, r3, #8
 8001c7e:	f003 0307 	and.w	r3, r3, #7
}
 8001c82:	4618      	mov	r0, r3
 8001c84:	46bd      	mov	sp, r7
 8001c86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c8a:	4770      	bx	lr
 8001c8c:	e000ed00 	.word	0xe000ed00

08001c90 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001c90:	b480      	push	{r7}
 8001c92:	b083      	sub	sp, #12
 8001c94:	af00      	add	r7, sp, #0
 8001c96:	4603      	mov	r3, r0
 8001c98:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001c9a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c9e:	2b00      	cmp	r3, #0
 8001ca0:	db0b      	blt.n	8001cba <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001ca2:	79fb      	ldrb	r3, [r7, #7]
 8001ca4:	f003 021f 	and.w	r2, r3, #31
 8001ca8:	4907      	ldr	r1, [pc, #28]	@ (8001cc8 <__NVIC_EnableIRQ+0x38>)
 8001caa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001cae:	095b      	lsrs	r3, r3, #5
 8001cb0:	2001      	movs	r0, #1
 8001cb2:	fa00 f202 	lsl.w	r2, r0, r2
 8001cb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001cba:	bf00      	nop
 8001cbc:	370c      	adds	r7, #12
 8001cbe:	46bd      	mov	sp, r7
 8001cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cc4:	4770      	bx	lr
 8001cc6:	bf00      	nop
 8001cc8:	e000e100 	.word	0xe000e100

08001ccc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
static inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001ccc:	b480      	push	{r7}
 8001cce:	b083      	sub	sp, #12
 8001cd0:	af00      	add	r7, sp, #0
 8001cd2:	4603      	mov	r3, r0
 8001cd4:	6039      	str	r1, [r7, #0]
 8001cd6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001cd8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	db0a      	blt.n	8001cf6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ce0:	683b      	ldr	r3, [r7, #0]
 8001ce2:	b2da      	uxtb	r2, r3
 8001ce4:	490c      	ldr	r1, [pc, #48]	@ (8001d18 <__NVIC_SetPriority+0x4c>)
 8001ce6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001cea:	0112      	lsls	r2, r2, #4
 8001cec:	b2d2      	uxtb	r2, r2
 8001cee:	440b      	add	r3, r1
 8001cf0:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001cf4:	e00a      	b.n	8001d0c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001cf6:	683b      	ldr	r3, [r7, #0]
 8001cf8:	b2da      	uxtb	r2, r3
 8001cfa:	4908      	ldr	r1, [pc, #32]	@ (8001d1c <__NVIC_SetPriority+0x50>)
 8001cfc:	79fb      	ldrb	r3, [r7, #7]
 8001cfe:	f003 030f 	and.w	r3, r3, #15
 8001d02:	3b04      	subs	r3, #4
 8001d04:	0112      	lsls	r2, r2, #4
 8001d06:	b2d2      	uxtb	r2, r2
 8001d08:	440b      	add	r3, r1
 8001d0a:	761a      	strb	r2, [r3, #24]
}
 8001d0c:	bf00      	nop
 8001d0e:	370c      	adds	r7, #12
 8001d10:	46bd      	mov	sp, r7
 8001d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d16:	4770      	bx	lr
 8001d18:	e000e100 	.word	0xe000e100
 8001d1c:	e000ed00 	.word	0xe000ed00

08001d20 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
static inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001d20:	b480      	push	{r7}
 8001d22:	b089      	sub	sp, #36	@ 0x24
 8001d24:	af00      	add	r7, sp, #0
 8001d26:	60f8      	str	r0, [r7, #12]
 8001d28:	60b9      	str	r1, [r7, #8]
 8001d2a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001d2c:	68fb      	ldr	r3, [r7, #12]
 8001d2e:	f003 0307 	and.w	r3, r3, #7
 8001d32:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001d34:	69fb      	ldr	r3, [r7, #28]
 8001d36:	f1c3 0307 	rsb	r3, r3, #7
 8001d3a:	2b04      	cmp	r3, #4
 8001d3c:	bf28      	it	cs
 8001d3e:	2304      	movcs	r3, #4
 8001d40:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001d42:	69fb      	ldr	r3, [r7, #28]
 8001d44:	3304      	adds	r3, #4
 8001d46:	2b06      	cmp	r3, #6
 8001d48:	d902      	bls.n	8001d50 <NVIC_EncodePriority+0x30>
 8001d4a:	69fb      	ldr	r3, [r7, #28]
 8001d4c:	3b03      	subs	r3, #3
 8001d4e:	e000      	b.n	8001d52 <NVIC_EncodePriority+0x32>
 8001d50:	2300      	movs	r3, #0
 8001d52:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001d54:	f04f 32ff 	mov.w	r2, #4294967295
 8001d58:	69bb      	ldr	r3, [r7, #24]
 8001d5a:	fa02 f303 	lsl.w	r3, r2, r3
 8001d5e:	43da      	mvns	r2, r3
 8001d60:	68bb      	ldr	r3, [r7, #8]
 8001d62:	401a      	ands	r2, r3
 8001d64:	697b      	ldr	r3, [r7, #20]
 8001d66:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001d68:	f04f 31ff 	mov.w	r1, #4294967295
 8001d6c:	697b      	ldr	r3, [r7, #20]
 8001d6e:	fa01 f303 	lsl.w	r3, r1, r3
 8001d72:	43d9      	mvns	r1, r3
 8001d74:	687b      	ldr	r3, [r7, #4]
 8001d76:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001d78:	4313      	orrs	r3, r2
         );
}
 8001d7a:	4618      	mov	r0, r3
 8001d7c:	3724      	adds	r7, #36	@ 0x24
 8001d7e:	46bd      	mov	sp, r7
 8001d80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d84:	4770      	bx	lr
	...

08001d88 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
static inline uint32_t SysTick_Config(uint32_t ticks)
{
 8001d88:	b580      	push	{r7, lr}
 8001d8a:	b082      	sub	sp, #8
 8001d8c:	af00      	add	r7, sp, #0
 8001d8e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001d90:	687b      	ldr	r3, [r7, #4]
 8001d92:	3b01      	subs	r3, #1
 8001d94:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8001d98:	d301      	bcc.n	8001d9e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001d9a:	2301      	movs	r3, #1
 8001d9c:	e00f      	b.n	8001dbe <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001d9e:	4a0a      	ldr	r2, [pc, #40]	@ (8001dc8 <SysTick_Config+0x40>)
 8001da0:	687b      	ldr	r3, [r7, #4]
 8001da2:	3b01      	subs	r3, #1
 8001da4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001da6:	210f      	movs	r1, #15
 8001da8:	f04f 30ff 	mov.w	r0, #4294967295
 8001dac:	f7ff ff8e 	bl	8001ccc <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001db0:	4b05      	ldr	r3, [pc, #20]	@ (8001dc8 <SysTick_Config+0x40>)
 8001db2:	2200      	movs	r2, #0
 8001db4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001db6:	4b04      	ldr	r3, [pc, #16]	@ (8001dc8 <SysTick_Config+0x40>)
 8001db8:	2207      	movs	r2, #7
 8001dba:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001dbc:	2300      	movs	r3, #0
}
 8001dbe:	4618      	mov	r0, r3
 8001dc0:	3708      	adds	r7, #8
 8001dc2:	46bd      	mov	sp, r7
 8001dc4:	bd80      	pop	{r7, pc}
 8001dc6:	bf00      	nop
 8001dc8:	e000e010 	.word	0xe000e010

08001dcc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001dcc:	b580      	push	{r7, lr}
 8001dce:	b082      	sub	sp, #8
 8001dd0:	af00      	add	r7, sp, #0
 8001dd2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001dd4:	6878      	ldr	r0, [r7, #4]
 8001dd6:	f7ff ff29 	bl	8001c2c <__NVIC_SetPriorityGrouping>
}
 8001dda:	bf00      	nop
 8001ddc:	3708      	adds	r7, #8
 8001dde:	46bd      	mov	sp, r7
 8001de0:	bd80      	pop	{r7, pc}

08001de2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001de2:	b580      	push	{r7, lr}
 8001de4:	b086      	sub	sp, #24
 8001de6:	af00      	add	r7, sp, #0
 8001de8:	4603      	mov	r3, r0
 8001dea:	60b9      	str	r1, [r7, #8]
 8001dec:	607a      	str	r2, [r7, #4]
 8001dee:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001df0:	2300      	movs	r3, #0
 8001df2:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8001df4:	f7ff ff3e 	bl	8001c74 <__NVIC_GetPriorityGrouping>
 8001df8:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001dfa:	687a      	ldr	r2, [r7, #4]
 8001dfc:	68b9      	ldr	r1, [r7, #8]
 8001dfe:	6978      	ldr	r0, [r7, #20]
 8001e00:	f7ff ff8e 	bl	8001d20 <NVIC_EncodePriority>
 8001e04:	4602      	mov	r2, r0
 8001e06:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001e0a:	4611      	mov	r1, r2
 8001e0c:	4618      	mov	r0, r3
 8001e0e:	f7ff ff5d 	bl	8001ccc <__NVIC_SetPriority>
}
 8001e12:	bf00      	nop
 8001e14:	3718      	adds	r7, #24
 8001e16:	46bd      	mov	sp, r7
 8001e18:	bd80      	pop	{r7, pc}

08001e1a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001e1a:	b580      	push	{r7, lr}
 8001e1c:	b082      	sub	sp, #8
 8001e1e:	af00      	add	r7, sp, #0
 8001e20:	4603      	mov	r3, r0
 8001e22:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001e24:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001e28:	4618      	mov	r0, r3
 8001e2a:	f7ff ff31 	bl	8001c90 <__NVIC_EnableIRQ>
}
 8001e2e:	bf00      	nop
 8001e30:	3708      	adds	r7, #8
 8001e32:	46bd      	mov	sp, r7
 8001e34:	bd80      	pop	{r7, pc}

08001e36 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8001e36:	b580      	push	{r7, lr}
 8001e38:	b082      	sub	sp, #8
 8001e3a:	af00      	add	r7, sp, #0
 8001e3c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8001e3e:	6878      	ldr	r0, [r7, #4]
 8001e40:	f7ff ffa2 	bl	8001d88 <SysTick_Config>
 8001e44:	4603      	mov	r3, r0
}
 8001e46:	4618      	mov	r0, r3
 8001e48:	3708      	adds	r7, #8
 8001e4a:	46bd      	mov	sp, r7
 8001e4c:	bd80      	pop	{r7, pc}
	...

08001e50 <HAL_DCMI_Start_DMA>:
  * @param  pData     The destination memory Buffer address (LCD Frame buffer).
  * @param  Length    The length of capture to be transferred.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Start_DMA(DCMI_HandleTypeDef* hdcmi, uint32_t DCMI_Mode, uint32_t pData, uint32_t Length)
{
 8001e50:	b580      	push	{r7, lr}
 8001e52:	b088      	sub	sp, #32
 8001e54:	af02      	add	r7, sp, #8
 8001e56:	60f8      	str	r0, [r7, #12]
 8001e58:	60b9      	str	r1, [r7, #8]
 8001e5a:	607a      	str	r2, [r7, #4]
 8001e5c:	603b      	str	r3, [r7, #0]
  /* Initialize the second memory address */
  uint32_t SecondMemAddress = 0U;
 8001e5e:	2300      	movs	r3, #0
 8001e60:	617b      	str	r3, [r7, #20]

  /* Check function parameters */
  assert_param(IS_DCMI_CAPTURE_MODE(DCMI_Mode));

  /* Process Locked */
  __HAL_LOCK(hdcmi);
 8001e62:	68fb      	ldr	r3, [r7, #12]
 8001e64:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8001e68:	2b01      	cmp	r3, #1
 8001e6a:	d101      	bne.n	8001e70 <HAL_DCMI_Start_DMA+0x20>
 8001e6c:	2302      	movs	r3, #2
 8001e6e:	e086      	b.n	8001f7e <HAL_DCMI_Start_DMA+0x12e>
 8001e70:	68fb      	ldr	r3, [r7, #12]
 8001e72:	2201      	movs	r2, #1
 8001e74:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Lock the DCMI peripheral state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8001e78:	68fb      	ldr	r3, [r7, #12]
 8001e7a:	2202      	movs	r2, #2
 8001e7c:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  
  /* Enable DCMI by setting DCMIEN bit */
  __HAL_DCMI_ENABLE(hdcmi);
 8001e80:	68fb      	ldr	r3, [r7, #12]
 8001e82:	681b      	ldr	r3, [r3, #0]
 8001e84:	681a      	ldr	r2, [r3, #0]
 8001e86:	68fb      	ldr	r3, [r7, #12]
 8001e88:	681b      	ldr	r3, [r3, #0]
 8001e8a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8001e8e:	601a      	str	r2, [r3, #0]

  /* Configure the DCMI Mode */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_CM);
 8001e90:	68fb      	ldr	r3, [r7, #12]
 8001e92:	681b      	ldr	r3, [r3, #0]
 8001e94:	681a      	ldr	r2, [r3, #0]
 8001e96:	68fb      	ldr	r3, [r7, #12]
 8001e98:	681b      	ldr	r3, [r3, #0]
 8001e9a:	f022 0202 	bic.w	r2, r2, #2
 8001e9e:	601a      	str	r2, [r3, #0]
  hdcmi->Instance->CR.reg |=  (uint32_t)(DCMI_Mode);
 8001ea0:	68fb      	ldr	r3, [r7, #12]
 8001ea2:	681b      	ldr	r3, [r3, #0]
 8001ea4:	6819      	ldr	r1, [r3, #0]
 8001ea6:	68fb      	ldr	r3, [r7, #12]
 8001ea8:	681b      	ldr	r3, [r3, #0]
 8001eaa:	68ba      	ldr	r2, [r7, #8]
 8001eac:	430a      	orrs	r2, r1
 8001eae:	601a      	str	r2, [r3, #0]

  /* Set the DMA memory0 conversion complete callback */
  hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
 8001eb0:	68fb      	ldr	r3, [r7, #12]
 8001eb2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001eb4:	4a34      	ldr	r2, [pc, #208]	@ (8001f88 <HAL_DCMI_Start_DMA+0x138>)
 8001eb6:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Set the DMA error callback */
  hdcmi->DMA_Handle->XferErrorCallback = DCMI_DMAError;
 8001eb8:	68fb      	ldr	r3, [r7, #12]
 8001eba:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ebc:	4a33      	ldr	r2, [pc, #204]	@ (8001f8c <HAL_DCMI_Start_DMA+0x13c>)
 8001ebe:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Set the dma abort callback */
  hdcmi->DMA_Handle->XferAbortCallback = NULL;
 8001ec0:	68fb      	ldr	r3, [r7, #12]
 8001ec2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ec4:	2200      	movs	r2, #0
 8001ec6:	651a      	str	r2, [r3, #80]	@ 0x50
  
  /* Reset transfer counters value */ 
  hdcmi->XferCount = 0U;
 8001ec8:	68fb      	ldr	r3, [r7, #12]
 8001eca:	2200      	movs	r2, #0
 8001ecc:	629a      	str	r2, [r3, #40]	@ 0x28
  hdcmi->XferTransferNumber = 0U;
 8001ece:	68fb      	ldr	r3, [r7, #12]
 8001ed0:	2200      	movs	r2, #0
 8001ed2:	631a      	str	r2, [r3, #48]	@ 0x30

  if(Length <= 0xFFFFU)
 8001ed4:	683b      	ldr	r3, [r7, #0]
 8001ed6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001eda:	d20a      	bcs.n	8001ef2 <HAL_DCMI_Start_DMA+0xa2>
  {
    /* Enable the DMA Stream */
    HAL_DMA_Start_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, Length);
 8001edc:	68fb      	ldr	r3, [r7, #12]
 8001ede:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001ee0:	68fb      	ldr	r3, [r7, #12]
 8001ee2:	681b      	ldr	r3, [r3, #0]
 8001ee4:	3328      	adds	r3, #40	@ 0x28
 8001ee6:	4619      	mov	r1, r3
 8001ee8:	683b      	ldr	r3, [r7, #0]
 8001eea:	687a      	ldr	r2, [r7, #4]
 8001eec:	f000 fb1a 	bl	8002524 <HAL_DMA_Start_IT>
 8001ef0:	e038      	b.n	8001f64 <HAL_DCMI_Start_DMA+0x114>
  }
  else /* DCMI_DOUBLE_BUFFER Mode */
  {
    /* Set the DMA memory1 conversion complete callback */
    hdcmi->DMA_Handle->XferM1CpltCallback = DCMI_DMAXferCplt;
 8001ef2:	68fb      	ldr	r3, [r7, #12]
 8001ef4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ef6:	4a24      	ldr	r2, [pc, #144]	@ (8001f88 <HAL_DCMI_Start_DMA+0x138>)
 8001ef8:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Initialize transfer parameters */
    hdcmi->XferCount = 1U;
 8001efa:	68fb      	ldr	r3, [r7, #12]
 8001efc:	2201      	movs	r2, #1
 8001efe:	629a      	str	r2, [r3, #40]	@ 0x28
    hdcmi->XferSize = Length;
 8001f00:	68fb      	ldr	r3, [r7, #12]
 8001f02:	683a      	ldr	r2, [r7, #0]
 8001f04:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdcmi->pBuffPtr = pData;
 8001f06:	68fb      	ldr	r3, [r7, #12]
 8001f08:	687a      	ldr	r2, [r7, #4]
 8001f0a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Get the number of buffer */
    while(hdcmi->XferSize > 0xFFFFU)
 8001f0c:	e009      	b.n	8001f22 <HAL_DCMI_Start_DMA+0xd2>
    {
      hdcmi->XferSize = (hdcmi->XferSize/2U);
 8001f0e:	68fb      	ldr	r3, [r7, #12]
 8001f10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001f12:	085a      	lsrs	r2, r3, #1
 8001f14:	68fb      	ldr	r3, [r7, #12]
 8001f16:	62da      	str	r2, [r3, #44]	@ 0x2c
      hdcmi->XferCount = hdcmi->XferCount*2U;
 8001f18:	68fb      	ldr	r3, [r7, #12]
 8001f1a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f1c:	005a      	lsls	r2, r3, #1
 8001f1e:	68fb      	ldr	r3, [r7, #12]
 8001f20:	629a      	str	r2, [r3, #40]	@ 0x28
    while(hdcmi->XferSize > 0xFFFFU)
 8001f22:	68fb      	ldr	r3, [r7, #12]
 8001f24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001f26:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001f2a:	d2f0      	bcs.n	8001f0e <HAL_DCMI_Start_DMA+0xbe>
    }

    /* Update DCMI counter  and transfer number*/
    hdcmi->XferCount = (hdcmi->XferCount - 2U);
 8001f2c:	68fb      	ldr	r3, [r7, #12]
 8001f2e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001f30:	1e9a      	subs	r2, r3, #2
 8001f32:	68fb      	ldr	r3, [r7, #12]
 8001f34:	629a      	str	r2, [r3, #40]	@ 0x28
    hdcmi->XferTransferNumber = hdcmi->XferCount;
 8001f36:	68fb      	ldr	r3, [r7, #12]
 8001f38:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001f3a:	68fb      	ldr	r3, [r7, #12]
 8001f3c:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Update second memory address */
    SecondMemAddress = (uint32_t)(pData + (4U*hdcmi->XferSize));
 8001f3e:	68fb      	ldr	r3, [r7, #12]
 8001f40:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001f42:	009b      	lsls	r3, r3, #2
 8001f44:	687a      	ldr	r2, [r7, #4]
 8001f46:	4413      	add	r3, r2
 8001f48:	617b      	str	r3, [r7, #20]

    /* Start DMA multi buffer transfer */
    HAL_DMAEx_MultiBufferStart_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, SecondMemAddress, hdcmi->XferSize);
 8001f4a:	68fb      	ldr	r3, [r7, #12]
 8001f4c:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001f4e:	68fb      	ldr	r3, [r7, #12]
 8001f50:	681b      	ldr	r3, [r3, #0]
 8001f52:	3328      	adds	r3, #40	@ 0x28
 8001f54:	4619      	mov	r1, r3
 8001f56:	68fb      	ldr	r3, [r7, #12]
 8001f58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001f5a:	9300      	str	r3, [sp, #0]
 8001f5c:	697b      	ldr	r3, [r7, #20]
 8001f5e:	687a      	ldr	r2, [r7, #4]
 8001f60:	f000 fe34 	bl	8002bcc <HAL_DMAEx_MultiBufferStart_IT>
  }

  /* Enable Capture */
  hdcmi->Instance->CR.reg |= DCMI_CR_CAPTURE;
 8001f64:	68fb      	ldr	r3, [r7, #12]
 8001f66:	681b      	ldr	r3, [r3, #0]
 8001f68:	681a      	ldr	r2, [r3, #0]
 8001f6a:	68fb      	ldr	r3, [r7, #12]
 8001f6c:	681b      	ldr	r3, [r3, #0]
 8001f6e:	f042 0201 	orr.w	r2, r2, #1
 8001f72:	601a      	str	r2, [r3, #0]

  /* Release Lock */
  __HAL_UNLOCK(hdcmi);
 8001f74:	68fb      	ldr	r3, [r7, #12]
 8001f76:	2200      	movs	r2, #0
 8001f78:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Return function status */
  return HAL_OK;
 8001f7c:	2300      	movs	r3, #0
}
 8001f7e:	4618      	mov	r0, r3
 8001f80:	3718      	adds	r7, #24
 8001f82:	46bd      	mov	sp, r7
 8001f84:	bd80      	pop	{r7, pc}
 8001f86:	bf00      	nop
 8001f88:	08002195 	.word	0x08002195
 8001f8c:	080022bf 	.word	0x080022bf

08001f90 <HAL_DCMI_Stop>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Stop(DCMI_HandleTypeDef* hdcmi)
{
 8001f90:	b580      	push	{r7, lr}
 8001f92:	b084      	sub	sp, #16
 8001f94:	af00      	add	r7, sp, #0
 8001f96:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = SystemCoreClock / HAL_TIMEOUT_DCMI_STOP;
 8001f98:	4b29      	ldr	r3, [pc, #164]	@ (8002040 <HAL_DCMI_Stop+0xb0>)
 8001f9a:	681b      	ldr	r3, [r3, #0]
 8001f9c:	085b      	lsrs	r3, r3, #1
 8001f9e:	4a29      	ldr	r2, [pc, #164]	@ (8002044 <HAL_DCMI_Stop+0xb4>)
 8001fa0:	fba2 2303 	umull	r2, r3, r2, r3
 8001fa4:	089b      	lsrs	r3, r3, #2
 8001fa6:	60bb      	str	r3, [r7, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8001fa8:	2300      	movs	r3, #0
 8001faa:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hdcmi);
 8001fac:	687b      	ldr	r3, [r7, #4]
 8001fae:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8001fb2:	2b01      	cmp	r3, #1
 8001fb4:	d101      	bne.n	8001fba <HAL_DCMI_Stop+0x2a>
 8001fb6:	2302      	movs	r3, #2
 8001fb8:	e03e      	b.n	8002038 <HAL_DCMI_Stop+0xa8>
 8001fba:	687b      	ldr	r3, [r7, #4]
 8001fbc:	2201      	movs	r2, #1
 8001fbe:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  
  /* Lock the DCMI peripheral state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8001fc2:	687b      	ldr	r3, [r7, #4]
 8001fc4:	2202      	movs	r2, #2
 8001fc6:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  /* Disable Capture */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_CAPTURE);
 8001fca:	687b      	ldr	r3, [r7, #4]
 8001fcc:	681b      	ldr	r3, [r3, #0]
 8001fce:	681a      	ldr	r2, [r3, #0]
 8001fd0:	687b      	ldr	r3, [r7, #4]
 8001fd2:	681b      	ldr	r3, [r3, #0]
 8001fd4:	f022 0201 	bic.w	r2, r2, #1
 8001fd8:	601a      	str	r2, [r3, #0]

  /* Check if the DCMI capture effectively disabled */
  do
  {
    if (count-- == 0U)
 8001fda:	68bb      	ldr	r3, [r7, #8]
 8001fdc:	1e5a      	subs	r2, r3, #1
 8001fde:	60ba      	str	r2, [r7, #8]
 8001fe0:	2b00      	cmp	r3, #0
 8001fe2:	d108      	bne.n	8001ff6 <HAL_DCMI_Stop+0x66>
    {
      /* Update error code */
      hdcmi->ErrorCode |= HAL_DCMI_ERROR_TIMEOUT;
 8001fe4:	687b      	ldr	r3, [r7, #4]
 8001fe6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001fe8:	f043 0220 	orr.w	r2, r3, #32
 8001fec:	687b      	ldr	r3, [r7, #4]
 8001fee:	63da      	str	r2, [r3, #60]	@ 0x3c

      status = HAL_TIMEOUT;
 8001ff0:	2303      	movs	r3, #3
 8001ff2:	73fb      	strb	r3, [r7, #15]
      break;
 8001ff4:	e006      	b.n	8002004 <HAL_DCMI_Stop+0x74>
    }
  }
  while((hdcmi->Instance->CR.reg & DCMI_CR_CAPTURE) != 0U);
 8001ff6:	687b      	ldr	r3, [r7, #4]
 8001ff8:	681b      	ldr	r3, [r3, #0]
 8001ffa:	681b      	ldr	r3, [r3, #0]
 8001ffc:	f003 0301 	and.w	r3, r3, #1
 8002000:	2b00      	cmp	r3, #0
 8002002:	d1ea      	bne.n	8001fda <HAL_DCMI_Stop+0x4a>

  /* Disable the DCMI */
  __HAL_DCMI_DISABLE(hdcmi);
 8002004:	687b      	ldr	r3, [r7, #4]
 8002006:	681b      	ldr	r3, [r3, #0]
 8002008:	681a      	ldr	r2, [r3, #0]
 800200a:	687b      	ldr	r3, [r7, #4]
 800200c:	681b      	ldr	r3, [r3, #0]
 800200e:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8002012:	601a      	str	r2, [r3, #0]

  /* Disable the DMA */
  HAL_DMA_Abort(hdcmi->DMA_Handle);
 8002014:	687b      	ldr	r3, [r7, #4]
 8002016:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002018:	4618      	mov	r0, r3
 800201a:	f000 fadb 	bl	80025d4 <HAL_DMA_Abort>

  /* Update error code */
  hdcmi->ErrorCode |= HAL_DCMI_ERROR_NONE;
 800201e:	687b      	ldr	r3, [r7, #4]
 8002020:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8002022:	687b      	ldr	r3, [r7, #4]
 8002024:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Change DCMI state */
  hdcmi->State = HAL_DCMI_STATE_READY;
 8002026:	687b      	ldr	r3, [r7, #4]
 8002028:	2201      	movs	r2, #1
 800202a:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  /* Process Unlocked */
  __HAL_UNLOCK(hdcmi);
 800202e:	687b      	ldr	r3, [r7, #4]
 8002030:	2200      	movs	r2, #0
 8002032:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Return function status */
  return status;
 8002036:	7bfb      	ldrb	r3, [r7, #15]
}
 8002038:	4618      	mov	r0, r3
 800203a:	3710      	adds	r7, #16
 800203c:	46bd      	mov	sp, r7
 800203e:	bd80      	pop	{r7, pc}
 8002040:	20000000 	.word	0x20000000
 8002044:	92492493 	.word	0x92492493

08002048 <HAL_DCMI_IRQHandler>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for the DCMI.
  * @retval None
  */
void HAL_DCMI_IRQHandler(DCMI_HandleTypeDef *hdcmi)
{
 8002048:	b580      	push	{r7, lr}
 800204a:	b084      	sub	sp, #16
 800204c:	af00      	add	r7, sp, #0
 800204e:	6078      	str	r0, [r7, #4]
  uint32_t isr_value = READ_REG(hdcmi->Instance->MIS.reg);
 8002050:	687b      	ldr	r3, [r7, #4]
 8002052:	681b      	ldr	r3, [r3, #0]
 8002054:	691b      	ldr	r3, [r3, #16]
 8002056:	60fb      	str	r3, [r7, #12]

  /* Synchronization error interrupt management *******************************/
  if((isr_value & DCMI_FLAG_ERRRI) == DCMI_FLAG_ERRRI)
 8002058:	68fb      	ldr	r3, [r7, #12]
 800205a:	f003 0304 	and.w	r3, r3, #4
 800205e:	2b00      	cmp	r3, #0
 8002060:	d016      	beq.n	8002090 <HAL_DCMI_IRQHandler+0x48>
  {
    /* Clear the Synchronization error flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_ERRRI);
 8002062:	687b      	ldr	r3, [r7, #4]
 8002064:	681b      	ldr	r3, [r3, #0]
 8002066:	2204      	movs	r2, #4
 8002068:	615a      	str	r2, [r3, #20]

    /* Update error code */
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_SYNC;
 800206a:	687b      	ldr	r3, [r7, #4]
 800206c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800206e:	f043 0202 	orr.w	r2, r3, #2
 8002072:	687b      	ldr	r3, [r7, #4]
 8002074:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Change DCMI state */
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 8002076:	687b      	ldr	r3, [r7, #4]
 8002078:	2204      	movs	r2, #4
 800207a:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    
    /* Set the synchronization error callback */
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 800207e:	687b      	ldr	r3, [r7, #4]
 8002080:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002082:	4a2f      	ldr	r2, [pc, #188]	@ (8002140 <HAL_DCMI_IRQHandler+0xf8>)
 8002084:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Abort the DMA Transfer */
    HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
 8002086:	687b      	ldr	r3, [r7, #4]
 8002088:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800208a:	4618      	mov	r0, r3
 800208c:	f000 fb12 	bl	80026b4 <HAL_DMA_Abort_IT>
  }
  /* Overflow interrupt management ********************************************/
  if((isr_value & DCMI_FLAG_OVRRI) == DCMI_FLAG_OVRRI)
 8002090:	68fb      	ldr	r3, [r7, #12]
 8002092:	f003 0302 	and.w	r3, r3, #2
 8002096:	2b00      	cmp	r3, #0
 8002098:	d016      	beq.n	80020c8 <HAL_DCMI_IRQHandler+0x80>
  {
    /* Clear the Overflow flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_OVRRI);
 800209a:	687b      	ldr	r3, [r7, #4]
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	2202      	movs	r2, #2
 80020a0:	615a      	str	r2, [r3, #20]

    /* Update error code */
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_OVR;
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80020a6:	f043 0201 	orr.w	r2, r3, #1
 80020aa:	687b      	ldr	r3, [r7, #4]
 80020ac:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Change DCMI state */
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 80020ae:	687b      	ldr	r3, [r7, #4]
 80020b0:	2204      	movs	r2, #4
 80020b2:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    
    /* Set the overflow callback */
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 80020b6:	687b      	ldr	r3, [r7, #4]
 80020b8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80020ba:	4a21      	ldr	r2, [pc, #132]	@ (8002140 <HAL_DCMI_IRQHandler+0xf8>)
 80020bc:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Abort the DMA Transfer */
    HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
 80020be:	687b      	ldr	r3, [r7, #4]
 80020c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80020c2:	4618      	mov	r0, r3
 80020c4:	f000 faf6 	bl	80026b4 <HAL_DMA_Abort_IT>
  }
  /* Line Interrupt management ************************************************/
  if((isr_value & DCMI_FLAG_LINERI) == DCMI_FLAG_LINERI)
 80020c8:	68fb      	ldr	r3, [r7, #12]
 80020ca:	f003 0310 	and.w	r3, r3, #16
 80020ce:	2b00      	cmp	r3, #0
 80020d0:	d006      	beq.n	80020e0 <HAL_DCMI_IRQHandler+0x98>
  {
    /* Clear the Line interrupt flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_LINERI);
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	681b      	ldr	r3, [r3, #0]
 80020d6:	2210      	movs	r2, #16
 80020d8:	615a      	str	r2, [r3, #20]
    /* Line interrupt Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI line event callback*/
    hdcmi->LineEventCallback(hdcmi);
#else  
    HAL_DCMI_LineEventCallback(hdcmi);
 80020da:	6878      	ldr	r0, [r7, #4]
 80020dc:	f000 f83c 	bl	8002158 <HAL_DCMI_LineEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */     
  }
  /* VSYNC interrupt management ***********************************************/
  if((isr_value & DCMI_FLAG_VSYNCRI) == DCMI_FLAG_VSYNCRI)
 80020e0:	68fb      	ldr	r3, [r7, #12]
 80020e2:	f003 0308 	and.w	r3, r3, #8
 80020e6:	2b00      	cmp	r3, #0
 80020e8:	d006      	beq.n	80020f8 <HAL_DCMI_IRQHandler+0xb0>
  {
    /* Clear the VSYNC flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_VSYNCRI);
 80020ea:	687b      	ldr	r3, [r7, #4]
 80020ec:	681b      	ldr	r3, [r3, #0]
 80020ee:	2208      	movs	r2, #8
 80020f0:	615a      	str	r2, [r3, #20]
    /* VSYNC Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI vsync event callback*/
    hdcmi->VsyncEventCallback(hdcmi);
#else  
    HAL_DCMI_VsyncEventCallback(hdcmi);
 80020f2:	6878      	ldr	r0, [r7, #4]
 80020f4:	f000 f83a 	bl	800216c <HAL_DCMI_VsyncEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */ 
  }
  /* FRAME interrupt management ***********************************************/
  if((isr_value & DCMI_FLAG_FRAMERI) == DCMI_FLAG_FRAMERI)
 80020f8:	68fb      	ldr	r3, [r7, #12]
 80020fa:	f003 0301 	and.w	r3, r3, #1
 80020fe:	2b00      	cmp	r3, #0
 8002100:	d019      	beq.n	8002136 <HAL_DCMI_IRQHandler+0xee>
  {
    /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
    if((hdcmi->Instance->CR.reg & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 8002102:	687b      	ldr	r3, [r7, #4]
 8002104:	681b      	ldr	r3, [r3, #0]
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	f003 0302 	and.w	r3, r3, #2
 800210c:	2b00      	cmp	r3, #0
 800210e:	d007      	beq.n	8002120 <HAL_DCMI_IRQHandler+0xd8>
    { 
      /* Disable the Line, Vsync, Error and Overrun interrupts */
      __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8002110:	687b      	ldr	r3, [r7, #4]
 8002112:	681b      	ldr	r3, [r3, #0]
 8002114:	68da      	ldr	r2, [r3, #12]
 8002116:	687b      	ldr	r3, [r7, #4]
 8002118:	681b      	ldr	r3, [r3, #0]
 800211a:	f022 021e 	bic.w	r2, r2, #30
 800211e:	60da      	str	r2, [r3, #12]
    }

    /* Disable the Frame interrupt */
    __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_FRAME);
 8002120:	687b      	ldr	r3, [r7, #4]
 8002122:	681b      	ldr	r3, [r3, #0]
 8002124:	68da      	ldr	r2, [r3, #12]
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	681b      	ldr	r3, [r3, #0]
 800212a:	f022 0201 	bic.w	r2, r2, #1
 800212e:	60da      	str	r2, [r3, #12]
    /* Frame Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI frame event callback*/
    hdcmi->FrameEventCallback(hdcmi);
#else  
    HAL_DCMI_FrameEventCallback(hdcmi);
 8002130:	6878      	ldr	r0, [r7, #4]
 8002132:	f000 f825 	bl	8002180 <HAL_DCMI_FrameEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */      
  }
}
 8002136:	bf00      	nop
 8002138:	3710      	adds	r7, #16
 800213a:	46bd      	mov	sp, r7
 800213c:	bd80      	pop	{r7, pc}
 800213e:	bf00      	nop
 8002140:	080022bf 	.word	0x080022bf

08002144 <HAL_DCMI_ErrorCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi)
{
 8002144:	b480      	push	{r7}
 8002146:	b083      	sub	sp, #12
 8002148:	af00      	add	r7, sp, #0
 800214a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_ErrorCallback could be implemented in the user file
   */
}
 800214c:	bf00      	nop
 800214e:	370c      	adds	r7, #12
 8002150:	46bd      	mov	sp, r7
 8002152:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002156:	4770      	bx	lr

08002158 <HAL_DCMI_LineEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 8002158:	b480      	push	{r7}
 800215a:	b083      	sub	sp, #12
 800215c:	af00      	add	r7, sp, #0
 800215e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_LineEventCallback could be implemented in the user file
   */
}
 8002160:	bf00      	nop
 8002162:	370c      	adds	r7, #12
 8002164:	46bd      	mov	sp, r7
 8002166:	f85d 7b04 	ldr.w	r7, [sp], #4
 800216a:	4770      	bx	lr

0800216c <HAL_DCMI_VsyncEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 800216c:	b480      	push	{r7}
 800216e:	b083      	sub	sp, #12
 8002170:	af00      	add	r7, sp, #0
 8002172:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_VsyncEventCallback could be implemented in the user file
   */
}
 8002174:	bf00      	nop
 8002176:	370c      	adds	r7, #12
 8002178:	46bd      	mov	sp, r7
 800217a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800217e:	4770      	bx	lr

08002180 <HAL_DCMI_FrameEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 8002180:	b480      	push	{r7}
 8002182:	b083      	sub	sp, #12
 8002184:	af00      	add	r7, sp, #0
 8002186:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_FrameEventCallback could be implemented in the user file
   */
}
 8002188:	bf00      	nop
 800218a:	370c      	adds	r7, #12
 800218c:	46bd      	mov	sp, r7
 800218e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002192:	4770      	bx	lr

08002194 <DCMI_DMAXferCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAXferCplt(DMA_HandleTypeDef *hdma)
{
 8002194:	b580      	push	{r7, lr}
 8002196:	b084      	sub	sp, #16
 8002198:	af00      	add	r7, sp, #0
 800219a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 800219c:	2300      	movs	r3, #0
 800219e:	60fb      	str	r3, [r7, #12]
 
  DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80021a0:	687b      	ldr	r3, [r7, #4]
 80021a2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80021a4:	60bb      	str	r3, [r7, #8]
  
  if(hdcmi->XferCount != 0U)
 80021a6:	68bb      	ldr	r3, [r7, #8]
 80021a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021aa:	2b00      	cmp	r3, #0
 80021ac:	d043      	beq.n	8002236 <DCMI_DMAXferCplt+0xa2>
  {
    /* Update memory 0 address location */
    tmp = ((hdcmi->DMA_Handle->Instance->CR.reg) & DMA_SxCR_CT);
 80021ae:	68bb      	ldr	r3, [r7, #8]
 80021b0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80021b2:	681b      	ldr	r3, [r3, #0]
 80021b4:	681b      	ldr	r3, [r3, #0]
 80021b6:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80021ba:	60fb      	str	r3, [r7, #12]
    if(((hdcmi->XferCount % 2U) == 0U) && (tmp != 0U))
 80021bc:	68bb      	ldr	r3, [r7, #8]
 80021be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021c0:	f003 0301 	and.w	r3, r3, #1
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d118      	bne.n	80021fa <DCMI_DMAXferCplt+0x66>
 80021c8:	68fb      	ldr	r3, [r7, #12]
 80021ca:	2b00      	cmp	r3, #0
 80021cc:	d015      	beq.n	80021fa <DCMI_DMAXferCplt+0x66>
    {
      tmp = hdcmi->DMA_Handle->Instance->M0AR;
 80021ce:	68bb      	ldr	r3, [r7, #8]
 80021d0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80021d2:	681b      	ldr	r3, [r3, #0]
 80021d4:	68db      	ldr	r3, [r3, #12]
 80021d6:	60fb      	str	r3, [r7, #12]
      HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY0);
 80021d8:	68bb      	ldr	r3, [r7, #8]
 80021da:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 80021dc:	68bb      	ldr	r3, [r7, #8]
 80021de:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80021e0:	00da      	lsls	r2, r3, #3
 80021e2:	68fb      	ldr	r3, [r7, #12]
 80021e4:	4413      	add	r3, r2
 80021e6:	2200      	movs	r2, #0
 80021e8:	4619      	mov	r1, r3
 80021ea:	f001 fe37 	bl	8003e5c <HAL_DMAEx_ChangeMemory>
      hdcmi->XferCount--;
 80021ee:	68bb      	ldr	r3, [r7, #8]
 80021f0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80021f2:	1e5a      	subs	r2, r3, #1
 80021f4:	68bb      	ldr	r3, [r7, #8]
 80021f6:	629a      	str	r2, [r3, #40]	@ 0x28
 80021f8:	e044      	b.n	8002284 <DCMI_DMAXferCplt+0xf0>
    }
    /* Update memory 1 address location */
    else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) == 0U)
 80021fa:	68bb      	ldr	r3, [r7, #8]
 80021fc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80021fe:	681b      	ldr	r3, [r3, #0]
 8002200:	681b      	ldr	r3, [r3, #0]
 8002202:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002206:	2b00      	cmp	r3, #0
 8002208:	d13c      	bne.n	8002284 <DCMI_DMAXferCplt+0xf0>
    {
      tmp = hdcmi->DMA_Handle->Instance->M1AR;
 800220a:	68bb      	ldr	r3, [r7, #8]
 800220c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800220e:	681b      	ldr	r3, [r3, #0]
 8002210:	691b      	ldr	r3, [r3, #16]
 8002212:	60fb      	str	r3, [r7, #12]
      HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY1);
 8002214:	68bb      	ldr	r3, [r7, #8]
 8002216:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8002218:	68bb      	ldr	r3, [r7, #8]
 800221a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800221c:	00da      	lsls	r2, r3, #3
 800221e:	68fb      	ldr	r3, [r7, #12]
 8002220:	4413      	add	r3, r2
 8002222:	2201      	movs	r2, #1
 8002224:	4619      	mov	r1, r3
 8002226:	f001 fe19 	bl	8003e5c <HAL_DMAEx_ChangeMemory>
      hdcmi->XferCount--;
 800222a:	68bb      	ldr	r3, [r7, #8]
 800222c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800222e:	1e5a      	subs	r2, r3, #1
 8002230:	68bb      	ldr	r3, [r7, #8]
 8002232:	629a      	str	r2, [r3, #40]	@ 0x28
 8002234:	e026      	b.n	8002284 <DCMI_DMAXferCplt+0xf0>
    }
  }
  /* Update memory 0 address location */
  else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) != 0U)
 8002236:	68bb      	ldr	r3, [r7, #8]
 8002238:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800223a:	681b      	ldr	r3, [r3, #0]
 800223c:	681b      	ldr	r3, [r3, #0]
 800223e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002242:	2b00      	cmp	r3, #0
 8002244:	d006      	beq.n	8002254 <DCMI_DMAXferCplt+0xc0>
  {
    hdcmi->DMA_Handle->Instance->M0AR = hdcmi->pBuffPtr;
 8002246:	68bb      	ldr	r3, [r7, #8]
 8002248:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800224a:	681b      	ldr	r3, [r3, #0]
 800224c:	68ba      	ldr	r2, [r7, #8]
 800224e:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 8002250:	60da      	str	r2, [r3, #12]
 8002252:	e017      	b.n	8002284 <DCMI_DMAXferCplt+0xf0>
  }
  /* Update memory 1 address location */
  else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) == 0U)
 8002254:	68bb      	ldr	r3, [r7, #8]
 8002256:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	681b      	ldr	r3, [r3, #0]
 800225c:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002260:	2b00      	cmp	r3, #0
 8002262:	d10f      	bne.n	8002284 <DCMI_DMAXferCplt+0xf0>
  {
    tmp = hdcmi->pBuffPtr;
 8002264:	68bb      	ldr	r3, [r7, #8]
 8002266:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002268:	60fb      	str	r3, [r7, #12]
    hdcmi->DMA_Handle->Instance->M1AR = (tmp + (4U*hdcmi->XferSize));
 800226a:	68bb      	ldr	r3, [r7, #8]
 800226c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800226e:	0099      	lsls	r1, r3, #2
 8002270:	68bb      	ldr	r3, [r7, #8]
 8002272:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002274:	681b      	ldr	r3, [r3, #0]
 8002276:	68fa      	ldr	r2, [r7, #12]
 8002278:	440a      	add	r2, r1
 800227a:	611a      	str	r2, [r3, #16]
    hdcmi->XferCount = hdcmi->XferTransferNumber;
 800227c:	68bb      	ldr	r3, [r7, #8]
 800227e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8002280:	68bb      	ldr	r3, [r7, #8]
 8002282:	629a      	str	r2, [r3, #40]	@ 0x28
  }
  
  /* Check if the frame is transferred */
  if(hdcmi->XferCount == hdcmi->XferTransferNumber)
 8002284:	68bb      	ldr	r3, [r7, #8]
 8002286:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8002288:	68bb      	ldr	r3, [r7, #8]
 800228a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800228c:	429a      	cmp	r2, r3
 800228e:	d112      	bne.n	80022b6 <DCMI_DMAXferCplt+0x122>
  {
    /* Enable the Frame interrupt */
    __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_FRAME);
 8002290:	68bb      	ldr	r3, [r7, #8]
 8002292:	681b      	ldr	r3, [r3, #0]
 8002294:	68da      	ldr	r2, [r3, #12]
 8002296:	68bb      	ldr	r3, [r7, #8]
 8002298:	681b      	ldr	r3, [r3, #0]
 800229a:	f042 0201 	orr.w	r2, r2, #1
 800229e:	60da      	str	r2, [r3, #12]
    
    /* When snapshot mode, set dcmi state to ready */
    if((hdcmi->Instance->CR.reg & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 80022a0:	68bb      	ldr	r3, [r7, #8]
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	681b      	ldr	r3, [r3, #0]
 80022a6:	f003 0302 	and.w	r3, r3, #2
 80022aa:	2b00      	cmp	r3, #0
 80022ac:	d003      	beq.n	80022b6 <DCMI_DMAXferCplt+0x122>
    {  
      hdcmi->State= HAL_DCMI_STATE_READY;
 80022ae:	68bb      	ldr	r3, [r7, #8]
 80022b0:	2201      	movs	r2, #1
 80022b2:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    }
  }
}
 80022b6:	bf00      	nop
 80022b8:	3710      	adds	r7, #16
 80022ba:	46bd      	mov	sp, r7
 80022bc:	bd80      	pop	{r7, pc}

080022be <DCMI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAError(DMA_HandleTypeDef *hdma)
{
 80022be:	b580      	push	{r7, lr}
 80022c0:	b084      	sub	sp, #16
 80022c2:	af00      	add	r7, sp, #0
 80022c4:	6078      	str	r0, [r7, #4]
  DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80022c6:	687b      	ldr	r3, [r7, #4]
 80022c8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022ca:	60fb      	str	r3, [r7, #12]
  
  if(hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
 80022cc:	68fb      	ldr	r3, [r7, #12]
 80022ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80022d0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80022d2:	2b02      	cmp	r3, #2
 80022d4:	d003      	beq.n	80022de <DCMI_DMAError+0x20>
  {
    /* Initialize the DCMI state*/
    hdcmi->State = HAL_DCMI_STATE_READY;
 80022d6:	68fb      	ldr	r3, [r7, #12]
 80022d8:	2201      	movs	r2, #1
 80022da:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  /* DCMI error Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI error callback*/
    hdcmi->ErrorCallback(hdcmi);
#else  
  HAL_DCMI_ErrorCallback(hdcmi);
 80022de:	68f8      	ldr	r0, [r7, #12]
 80022e0:	f7ff ff30 	bl	8002144 <HAL_DCMI_ErrorCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */   

}
 80022e4:	bf00      	nop
 80022e6:	3710      	adds	r7, #16
 80022e8:	46bd      	mov	sp, r7
 80022ea:	bd80      	pop	{r7, pc}

080022ec <HAL_DCMI_Init>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Init(DCMI_HandleTypeDef *hdcmi)
{
 80022ec:	b580      	push	{r7, lr}
 80022ee:	b082      	sub	sp, #8
 80022f0:	af00      	add	r7, sp, #0
 80022f2:	6078      	str	r0, [r7, #4]
  /* Check the DCMI peripheral state */
  if(hdcmi == NULL)
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d101      	bne.n	80022fe <HAL_DCMI_Init+0x12>
  {
     return HAL_ERROR;
 80022fa:	2301      	movs	r3, #1
 80022fc:	e05f      	b.n	80023be <HAL_DCMI_Init+0xd2>
  assert_param(IS_DCMI_BYTE_SELECT_MODE(hdcmi->Init.ByteSelectMode));
  assert_param(IS_DCMI_BYTE_SELECT_START(hdcmi->Init.ByteSelectStart));
  assert_param(IS_DCMI_LINE_SELECT_MODE(hdcmi->Init.LineSelectMode));
  assert_param(IS_DCMI_LINE_SELECT_START(hdcmi->Init.LineSelectStart));
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
  if(hdcmi->State == HAL_DCMI_STATE_RESET)
 80022fe:	687b      	ldr	r3, [r7, #4]
 8002300:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8002304:	b2db      	uxtb	r3, r3
 8002306:	2b00      	cmp	r3, #0
 8002308:	d109      	bne.n	800231e <HAL_DCMI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hdcmi->Lock = HAL_UNLOCKED;
 800230a:	687b      	ldr	r3, [r7, #4]
 800230c:	2200      	movs	r2, #0
 800230e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    }
    /* Initialize the low level hardware (MSP) */
    hdcmi->MspInitCallback(hdcmi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMI_MspInit(hdcmi);
 8002312:	6878      	ldr	r0, [r7, #4]
 8002314:	f7ff f948 	bl	80015a8 <HAL_DCMI_MspInit>
#endif /* (USE_HAL_DCMI_REGISTER_CALLBACKS) */
    HAL_DCMI_MspInit(hdcmi);
 8002318:	6878      	ldr	r0, [r7, #4]
 800231a:	f7ff f945 	bl	80015a8 <HAL_DCMI_MspInit>
  }

  /* Change the DCMI state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 800231e:	687b      	ldr	r3, [r7, #4]
 8002320:	2202      	movs	r2, #2
 8002322:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
                          /* Configures the HS, VS, DE and PC polarity */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 |\
 8002326:	687b      	ldr	r3, [r7, #4]
 8002328:	681b      	ldr	r3, [r3, #0]
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	687a      	ldr	r2, [r7, #4]
 800232e:	6812      	ldr	r2, [r2, #0]
 8002330:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 8002334:	f023 0308 	bic.w	r3, r3, #8
 8002338:	6013      	str	r3, [r2, #0]
#if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
                           | DCMI_CR_BSM_0 | DCMI_CR_BSM_1 | DCMI_CR_OEBS |\
                           DCMI_CR_LSM | DCMI_CR_OELS
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
                           );
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 800233a:	687b      	ldr	r3, [r7, #4]
 800233c:	681b      	ldr	r3, [r3, #0]
 800233e:	6819      	ldr	r1, [r3, #0]
 8002340:	687b      	ldr	r3, [r7, #4]
 8002342:	685a      	ldr	r2, [r3, #4]
 8002344:	687b      	ldr	r3, [r7, #4]
 8002346:	695b      	ldr	r3, [r3, #20]
 8002348:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 800234a:	687b      	ldr	r3, [r7, #4]
 800234c:	68db      	ldr	r3, [r3, #12]
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 800234e:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 8002350:	687b      	ldr	r3, [r7, #4]
 8002352:	691b      	ldr	r3, [r3, #16]
 8002354:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 8002356:	687b      	ldr	r3, [r7, #4]
 8002358:	689b      	ldr	r3, [r3, #8]
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 800235a:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 800235c:	687b      	ldr	r3, [r7, #4]
 800235e:	699b      	ldr	r3, [r3, #24]
 8002360:	431a      	orrs	r2, r3
                                     hdcmi->Init.JPEGMode
 8002362:	687b      	ldr	r3, [r7, #4]
 8002364:	6a1b      	ldr	r3, [r3, #32]
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 8002366:	431a      	orrs	r2, r3
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 8002368:	687b      	ldr	r3, [r7, #4]
 800236a:	681b      	ldr	r3, [r3, #0]
 800236c:	430a      	orrs	r2, r1
 800236e:	601a      	str	r2, [r3, #0]
                                     | hdcmi->Init.ByteSelectMode |\
                                     hdcmi->Init.ByteSelectStart | hdcmi->Init.LineSelectMode |\
                                     hdcmi->Init.LineSelectStart
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
                                     );
  if(hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
 8002370:	687b      	ldr	r3, [r7, #4]
 8002372:	685b      	ldr	r3, [r3, #4]
 8002374:	2b10      	cmp	r3, #16
 8002376:	d112      	bne.n	800239e <HAL_DCMI_Init+0xb2>
  {
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 8002378:	687b      	ldr	r3, [r7, #4]
 800237a:	7f1b      	ldrb	r3, [r3, #28]
 800237c:	461a      	mov	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_POSITION_ESCR_LSC)|
 800237e:	687b      	ldr	r3, [r7, #4]
 8002380:	7f5b      	ldrb	r3, [r3, #29]
 8002382:	021b      	lsls	r3, r3, #8
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 8002384:	431a      	orrs	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_POSITION_ESCR_LEC) |
 8002386:	687b      	ldr	r3, [r7, #4]
 8002388:	7f9b      	ldrb	r3, [r3, #30]
 800238a:	041b      	lsls	r3, r3, #16
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_POSITION_ESCR_LSC)|
 800238c:	ea42 0103 	orr.w	r1, r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.FrameEndCode << DCMI_POSITION_ESCR_FEC));
 8002390:	687b      	ldr	r3, [r7, #4]
 8002392:	7fdb      	ldrb	r3, [r3, #31]
 8002394:	061a      	lsls	r2, r3, #24
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 8002396:	687b      	ldr	r3, [r7, #4]
 8002398:	681b      	ldr	r3, [r3, #0]
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_POSITION_ESCR_LEC) |
 800239a:	430a      	orrs	r2, r1
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 800239c:	619a      	str	r2, [r3, #24]

  }

  /* Enable the Line, Vsync, Error and Overrun interrupts */
  __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 800239e:	687b      	ldr	r3, [r7, #4]
 80023a0:	681b      	ldr	r3, [r3, #0]
 80023a2:	68da      	ldr	r2, [r3, #12]
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	681b      	ldr	r3, [r3, #0]
 80023a8:	f042 021e 	orr.w	r2, r2, #30
 80023ac:	60da      	str	r2, [r3, #12]

  /* Update error code */
  hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
 80023ae:	687b      	ldr	r3, [r7, #4]
 80023b0:	2200      	movs	r2, #0
 80023b2:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Initialize the DCMI state*/
  hdcmi->State  = HAL_DCMI_STATE_READY;
 80023b4:	687b      	ldr	r3, [r7, #4]
 80023b6:	2201      	movs	r2, #1
 80023b8:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  return HAL_OK;
 80023bc:	2300      	movs	r3, #0
}
 80023be:	4618      	mov	r0, r3
 80023c0:	3708      	adds	r7, #8
 80023c2:	46bd      	mov	sp, r7
 80023c4:	bd80      	pop	{r7, pc}
	...

080023c8 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80023c8:	b580      	push	{r7, lr}
 80023ca:	b086      	sub	sp, #24
 80023cc:	af00      	add	r7, sp, #0
 80023ce:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 80023d0:	2300      	movs	r3, #0
 80023d2:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 80023d4:	f7ff fbfa 	bl	8001bcc <HAL_GetTick>
 80023d8:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80023da:	687b      	ldr	r3, [r7, #4]
 80023dc:	2b00      	cmp	r3, #0
 80023de:	d101      	bne.n	80023e4 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 80023e0:	2301      	movs	r3, #1
 80023e2:	e099      	b.n	8002518 <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80023e4:	687b      	ldr	r3, [r7, #4]
 80023e6:	2202      	movs	r2, #2
 80023e8:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 80023ec:	687b      	ldr	r3, [r7, #4]
 80023ee:	2200      	movs	r2, #0
 80023f0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80023f4:	687b      	ldr	r3, [r7, #4]
 80023f6:	681b      	ldr	r3, [r3, #0]
 80023f8:	681a      	ldr	r2, [r3, #0]
 80023fa:	687b      	ldr	r3, [r7, #4]
 80023fc:	681b      	ldr	r3, [r3, #0]
 80023fe:	f022 0201 	bic.w	r2, r2, #1
 8002402:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 8002404:	e00f      	b.n	8002426 <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8002406:	f7ff fbe1 	bl	8001bcc <HAL_GetTick>
 800240a:	4602      	mov	r2, r0
 800240c:	693b      	ldr	r3, [r7, #16]
 800240e:	1ad3      	subs	r3, r2, r3
 8002410:	2b05      	cmp	r3, #5
 8002412:	d908      	bls.n	8002426 <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8002414:	687b      	ldr	r3, [r7, #4]
 8002416:	2220      	movs	r2, #32
 8002418:	655a      	str	r2, [r3, #84]	@ 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800241a:	687b      	ldr	r3, [r7, #4]
 800241c:	2203      	movs	r2, #3
 800241e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
      
      return HAL_TIMEOUT;
 8002422:	2303      	movs	r3, #3
 8002424:	e078      	b.n	8002518 <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 8002426:	687b      	ldr	r3, [r7, #4]
 8002428:	681b      	ldr	r3, [r3, #0]
 800242a:	681b      	ldr	r3, [r3, #0]
 800242c:	f003 0301 	and.w	r3, r3, #1
 8002430:	2b00      	cmp	r3, #0
 8002432:	d1e8      	bne.n	8002406 <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR.reg;
 8002434:	687b      	ldr	r3, [r7, #4]
 8002436:	681b      	ldr	r3, [r3, #0]
 8002438:	681b      	ldr	r3, [r3, #0]
 800243a:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800243c:	697a      	ldr	r2, [r7, #20]
 800243e:	4b38      	ldr	r3, [pc, #224]	@ (8002520 <HAL_DMA_Init+0x158>)
 8002440:	4013      	ands	r3, r2
 8002442:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002444:	687b      	ldr	r3, [r7, #4]
 8002446:	685a      	ldr	r2, [r3, #4]
 8002448:	687b      	ldr	r3, [r7, #4]
 800244a:	689b      	ldr	r3, [r3, #8]
 800244c:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800244e:	687b      	ldr	r3, [r7, #4]
 8002450:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002452:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002454:	687b      	ldr	r3, [r7, #4]
 8002456:	691b      	ldr	r3, [r3, #16]
 8002458:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800245a:	687b      	ldr	r3, [r7, #4]
 800245c:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800245e:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002460:	687b      	ldr	r3, [r7, #4]
 8002462:	699b      	ldr	r3, [r3, #24]
 8002464:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8002466:	687b      	ldr	r3, [r7, #4]
 8002468:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800246a:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800246c:	687b      	ldr	r3, [r7, #4]
 800246e:	6a1b      	ldr	r3, [r3, #32]
 8002470:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002472:	697a      	ldr	r2, [r7, #20]
 8002474:	4313      	orrs	r3, r2
 8002476:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002478:	687b      	ldr	r3, [r7, #4]
 800247a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800247c:	2b04      	cmp	r3, #4
 800247e:	d107      	bne.n	8002490 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8002480:	687b      	ldr	r3, [r7, #4]
 8002482:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002488:	4313      	orrs	r3, r2
 800248a:	697a      	ldr	r2, [r7, #20]
 800248c:	4313      	orrs	r3, r2
 800248e:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR.reg = tmp;
 8002490:	687b      	ldr	r3, [r7, #4]
 8002492:	681b      	ldr	r3, [r3, #0]
 8002494:	697a      	ldr	r2, [r7, #20]
 8002496:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR.reg;
 8002498:	687b      	ldr	r3, [r7, #4]
 800249a:	681b      	ldr	r3, [r3, #0]
 800249c:	695b      	ldr	r3, [r3, #20]
 800249e:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80024a0:	697b      	ldr	r3, [r7, #20]
 80024a2:	f023 0307 	bic.w	r3, r3, #7
 80024a6:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 80024a8:	687b      	ldr	r3, [r7, #4]
 80024aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80024ac:	697a      	ldr	r2, [r7, #20]
 80024ae:	4313      	orrs	r3, r2
 80024b0:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80024b2:	687b      	ldr	r3, [r7, #4]
 80024b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80024b6:	2b04      	cmp	r3, #4
 80024b8:	d117      	bne.n	80024ea <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 80024ba:	687b      	ldr	r3, [r7, #4]
 80024bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024be:	697a      	ldr	r2, [r7, #20]
 80024c0:	4313      	orrs	r3, r2
 80024c2:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80024c4:	687b      	ldr	r3, [r7, #4]
 80024c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80024c8:	2b00      	cmp	r3, #0
 80024ca:	d00e      	beq.n	80024ea <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 80024cc:	6878      	ldr	r0, [r7, #4]
 80024ce:	f000 fb01 	bl	8002ad4 <DMA_CheckFifoParam>
 80024d2:	4603      	mov	r3, r0
 80024d4:	2b00      	cmp	r3, #0
 80024d6:	d008      	beq.n	80024ea <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80024d8:	687b      	ldr	r3, [r7, #4]
 80024da:	2240      	movs	r2, #64	@ 0x40
 80024dc:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80024de:	687b      	ldr	r3, [r7, #4]
 80024e0:	2201      	movs	r2, #1
 80024e2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        return HAL_ERROR; 
 80024e6:	2301      	movs	r3, #1
 80024e8:	e016      	b.n	8002518 <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR.reg = tmp;
 80024ea:	687b      	ldr	r3, [r7, #4]
 80024ec:	681b      	ldr	r3, [r3, #0]
 80024ee:	697a      	ldr	r2, [r7, #20]
 80024f0:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80024f2:	6878      	ldr	r0, [r7, #4]
 80024f4:	f000 fab8 	bl	8002a68 <DMA_CalcBaseAndBitshift>
 80024f8:	4603      	mov	r3, r0
 80024fa:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80024fc:	687b      	ldr	r3, [r7, #4]
 80024fe:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002500:	223f      	movs	r2, #63	@ 0x3f
 8002502:	409a      	lsls	r2, r3
 8002504:	68fb      	ldr	r3, [r7, #12]
 8002506:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	2200      	movs	r2, #0
 800250c:	655a      	str	r2, [r3, #84]	@ 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	2201      	movs	r2, #1
 8002512:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  return HAL_OK;
 8002516:	2300      	movs	r3, #0
}
 8002518:	4618      	mov	r0, r3
 800251a:	3718      	adds	r7, #24
 800251c:	46bd      	mov	sp, r7
 800251e:	bd80      	pop	{r7, pc}
 8002520:	f010803f 	.word	0xf010803f

08002524 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8002524:	b580      	push	{r7, lr}
 8002526:	b086      	sub	sp, #24
 8002528:	af00      	add	r7, sp, #0
 800252a:	60f8      	str	r0, [r7, #12]
 800252c:	60b9      	str	r1, [r7, #8]
 800252e:	607a      	str	r2, [r7, #4]
 8002530:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002532:	2300      	movs	r3, #0
 8002534:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002536:	68fb      	ldr	r3, [r7, #12]
 8002538:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800253a:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 800253c:	68fb      	ldr	r3, [r7, #12]
 800253e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8002542:	2b01      	cmp	r3, #1
 8002544:	d101      	bne.n	800254a <HAL_DMA_Start_IT+0x26>
 8002546:	2302      	movs	r3, #2
 8002548:	e040      	b.n	80025cc <HAL_DMA_Start_IT+0xa8>
 800254a:	68fb      	ldr	r3, [r7, #12]
 800254c:	2201      	movs	r2, #1
 800254e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8002552:	68fb      	ldr	r3, [r7, #12]
 8002554:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8002558:	b2db      	uxtb	r3, r3
 800255a:	2b01      	cmp	r3, #1
 800255c:	d12f      	bne.n	80025be <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 800255e:	68fb      	ldr	r3, [r7, #12]
 8002560:	2202      	movs	r2, #2
 8002562:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002566:	68fb      	ldr	r3, [r7, #12]
 8002568:	2200      	movs	r2, #0
 800256a:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 800256c:	683b      	ldr	r3, [r7, #0]
 800256e:	687a      	ldr	r2, [r7, #4]
 8002570:	68b9      	ldr	r1, [r7, #8]
 8002572:	68f8      	ldr	r0, [r7, #12]
 8002574:	f000 fa4a 	bl	8002a0c <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002578:	68fb      	ldr	r3, [r7, #12]
 800257a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800257c:	223f      	movs	r2, #63	@ 0x3f
 800257e:	409a      	lsls	r2, r3
 8002580:	693b      	ldr	r3, [r7, #16]
 8002582:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR.reg  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8002584:	68fb      	ldr	r3, [r7, #12]
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	681a      	ldr	r2, [r3, #0]
 800258a:	68fb      	ldr	r3, [r7, #12]
 800258c:	681b      	ldr	r3, [r3, #0]
 800258e:	f042 0216 	orr.w	r2, r2, #22
 8002592:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 8002594:	68fb      	ldr	r3, [r7, #12]
 8002596:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002598:	2b00      	cmp	r3, #0
 800259a:	d007      	beq.n	80025ac <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR.reg  |= DMA_IT_HT;
 800259c:	68fb      	ldr	r3, [r7, #12]
 800259e:	681b      	ldr	r3, [r3, #0]
 80025a0:	681a      	ldr	r2, [r3, #0]
 80025a2:	68fb      	ldr	r3, [r7, #12]
 80025a4:	681b      	ldr	r3, [r3, #0]
 80025a6:	f042 0208 	orr.w	r2, r2, #8
 80025aa:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 80025ac:	68fb      	ldr	r3, [r7, #12]
 80025ae:	681b      	ldr	r3, [r3, #0]
 80025b0:	681a      	ldr	r2, [r3, #0]
 80025b2:	68fb      	ldr	r3, [r7, #12]
 80025b4:	681b      	ldr	r3, [r3, #0]
 80025b6:	f042 0201 	orr.w	r2, r2, #1
 80025ba:	601a      	str	r2, [r3, #0]
 80025bc:	e005      	b.n	80025ca <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 80025be:	68fb      	ldr	r3, [r7, #12]
 80025c0:	2200      	movs	r2, #0
 80025c2:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 80025c6:	2302      	movs	r3, #2
 80025c8:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 80025ca:	7dfb      	ldrb	r3, [r7, #23]
}
 80025cc:	4618      	mov	r0, r3
 80025ce:	3718      	adds	r7, #24
 80025d0:	46bd      	mov	sp, r7
 80025d2:	bd80      	pop	{r7, pc}

080025d4 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80025d4:	b580      	push	{r7, lr}
 80025d6:	b084      	sub	sp, #16
 80025d8:	af00      	add	r7, sp, #0
 80025da:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80025e0:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
 80025e2:	f7ff faf3 	bl	8001bcc <HAL_GetTick>
 80025e6:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80025e8:	687b      	ldr	r3, [r7, #4]
 80025ea:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80025ee:	b2db      	uxtb	r3, r3
 80025f0:	2b02      	cmp	r3, #2
 80025f2:	d008      	beq.n	8002606 <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80025f4:	687b      	ldr	r3, [r7, #4]
 80025f6:	2280      	movs	r2, #128	@ 0x80
 80025f8:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	2200      	movs	r2, #0
 80025fe:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    return HAL_ERROR;
 8002602:	2301      	movs	r3, #1
 8002604:	e052      	b.n	80026ac <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR.reg  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8002606:	687b      	ldr	r3, [r7, #4]
 8002608:	681b      	ldr	r3, [r3, #0]
 800260a:	681a      	ldr	r2, [r3, #0]
 800260c:	687b      	ldr	r3, [r7, #4]
 800260e:	681b      	ldr	r3, [r3, #0]
 8002610:	f022 0216 	bic.w	r2, r2, #22
 8002614:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR.reg &= ~(DMA_IT_FE);
 8002616:	687b      	ldr	r3, [r7, #4]
 8002618:	681b      	ldr	r3, [r3, #0]
 800261a:	695a      	ldr	r2, [r3, #20]
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	681b      	ldr	r3, [r3, #0]
 8002620:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8002624:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800262a:	2b00      	cmp	r3, #0
 800262c:	d103      	bne.n	8002636 <HAL_DMA_Abort+0x62>
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002632:	2b00      	cmp	r3, #0
 8002634:	d007      	beq.n	8002646 <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	681b      	ldr	r3, [r3, #0]
 800263a:	681a      	ldr	r2, [r3, #0]
 800263c:	687b      	ldr	r3, [r7, #4]
 800263e:	681b      	ldr	r3, [r3, #0]
 8002640:	f022 0208 	bic.w	r2, r2, #8
 8002644:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8002646:	687b      	ldr	r3, [r7, #4]
 8002648:	681b      	ldr	r3, [r3, #0]
 800264a:	681a      	ldr	r2, [r3, #0]
 800264c:	687b      	ldr	r3, [r7, #4]
 800264e:	681b      	ldr	r3, [r3, #0]
 8002650:	f022 0201 	bic.w	r2, r2, #1
 8002654:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 8002656:	e013      	b.n	8002680 <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8002658:	f7ff fab8 	bl	8001bcc <HAL_GetTick>
 800265c:	4602      	mov	r2, r0
 800265e:	68bb      	ldr	r3, [r7, #8]
 8002660:	1ad3      	subs	r3, r2, r3
 8002662:	2b05      	cmp	r3, #5
 8002664:	d90c      	bls.n	8002680 <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8002666:	687b      	ldr	r3, [r7, #4]
 8002668:	2220      	movs	r2, #32
 800266a:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 800266c:	687b      	ldr	r3, [r7, #4]
 800266e:	2203      	movs	r2, #3
 8002670:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8002674:	687b      	ldr	r3, [r7, #4]
 8002676:	2200      	movs	r2, #0
 8002678:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        
        return HAL_TIMEOUT;
 800267c:	2303      	movs	r3, #3
 800267e:	e015      	b.n	80026ac <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 8002680:	687b      	ldr	r3, [r7, #4]
 8002682:	681b      	ldr	r3, [r3, #0]
 8002684:	681b      	ldr	r3, [r3, #0]
 8002686:	f003 0301 	and.w	r3, r3, #1
 800268a:	2b00      	cmp	r3, #0
 800268c:	d1e4      	bne.n	8002658 <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800268e:	687b      	ldr	r3, [r7, #4]
 8002690:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002692:	223f      	movs	r2, #63	@ 0x3f
 8002694:	409a      	lsls	r2, r3
 8002696:	68fb      	ldr	r3, [r7, #12]
 8002698:	609a      	str	r2, [r3, #8]
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
 800269a:	687b      	ldr	r3, [r7, #4]
 800269c:	2201      	movs	r2, #1
 800269e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	2200      	movs	r2, #0
 80026a6:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  }
  return HAL_OK;
 80026aa:	2300      	movs	r3, #0
}
 80026ac:	4618      	mov	r0, r3
 80026ae:	3710      	adds	r7, #16
 80026b0:	46bd      	mov	sp, r7
 80026b2:	bd80      	pop	{r7, pc}

080026b4 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80026b4:	b480      	push	{r7}
 80026b6:	b083      	sub	sp, #12
 80026b8:	af00      	add	r7, sp, #0
 80026ba:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80026bc:	687b      	ldr	r3, [r7, #4]
 80026be:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80026c2:	b2db      	uxtb	r3, r3
 80026c4:	2b02      	cmp	r3, #2
 80026c6:	d004      	beq.n	80026d2 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80026c8:	687b      	ldr	r3, [r7, #4]
 80026ca:	2280      	movs	r2, #128	@ 0x80
 80026cc:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 80026ce:	2301      	movs	r3, #1
 80026d0:	e00c      	b.n	80026ec <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 80026d2:	687b      	ldr	r3, [r7, #4]
 80026d4:	2205      	movs	r2, #5
 80026d6:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	681b      	ldr	r3, [r3, #0]
 80026de:	681a      	ldr	r2, [r3, #0]
 80026e0:	687b      	ldr	r3, [r7, #4]
 80026e2:	681b      	ldr	r3, [r3, #0]
 80026e4:	f022 0201 	bic.w	r2, r2, #1
 80026e8:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 80026ea:	2300      	movs	r3, #0
}
 80026ec:	4618      	mov	r0, r3
 80026ee:	370c      	adds	r7, #12
 80026f0:	46bd      	mov	sp, r7
 80026f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026f6:	4770      	bx	lr

080026f8 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80026f8:	b580      	push	{r7, lr}
 80026fa:	b086      	sub	sp, #24
 80026fc:	af00      	add	r7, sp, #0
 80026fe:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  volatile uint32_t count = 0U;
 8002700:	2300      	movs	r3, #0
 8002702:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 8002704:	4b8e      	ldr	r3, [pc, #568]	@ (8002940 <HAL_DMA_IRQHandler+0x248>)
 8002706:	681b      	ldr	r3, [r3, #0]
 8002708:	4a8e      	ldr	r2, [pc, #568]	@ (8002944 <HAL_DMA_IRQHandler+0x24c>)
 800270a:	fba2 2303 	umull	r2, r3, r2, r3
 800270e:	0a9b      	lsrs	r3, r3, #10
 8002710:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002712:	687b      	ldr	r3, [r7, #4]
 8002714:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002716:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 8002718:	693b      	ldr	r3, [r7, #16]
 800271a:	681b      	ldr	r3, [r3, #0]
 800271c:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002722:	2208      	movs	r2, #8
 8002724:	409a      	lsls	r2, r3
 8002726:	68fb      	ldr	r3, [r7, #12]
 8002728:	4013      	ands	r3, r2
 800272a:	2b00      	cmp	r3, #0
 800272c:	d01a      	beq.n	8002764 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800272e:	687b      	ldr	r3, [r7, #4]
 8002730:	681b      	ldr	r3, [r3, #0]
 8002732:	681b      	ldr	r3, [r3, #0]
 8002734:	f003 0304 	and.w	r3, r3, #4
 8002738:	2b00      	cmp	r3, #0
 800273a:	d013      	beq.n	8002764 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR.reg  &= ~(DMA_IT_TE);
 800273c:	687b      	ldr	r3, [r7, #4]
 800273e:	681b      	ldr	r3, [r3, #0]
 8002740:	681a      	ldr	r2, [r3, #0]
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	681b      	ldr	r3, [r3, #0]
 8002746:	f022 0204 	bic.w	r2, r2, #4
 800274a:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 800274c:	687b      	ldr	r3, [r7, #4]
 800274e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002750:	2208      	movs	r2, #8
 8002752:	409a      	lsls	r2, r3
 8002754:	693b      	ldr	r3, [r7, #16]
 8002756:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8002758:	687b      	ldr	r3, [r7, #4]
 800275a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800275c:	f043 0201 	orr.w	r2, r3, #1
 8002760:	687b      	ldr	r3, [r7, #4]
 8002762:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8002764:	687b      	ldr	r3, [r7, #4]
 8002766:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002768:	2201      	movs	r2, #1
 800276a:	409a      	lsls	r2, r3
 800276c:	68fb      	ldr	r3, [r7, #12]
 800276e:	4013      	ands	r3, r2
 8002770:	2b00      	cmp	r3, #0
 8002772:	d012      	beq.n	800279a <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8002774:	687b      	ldr	r3, [r7, #4]
 8002776:	681b      	ldr	r3, [r3, #0]
 8002778:	695b      	ldr	r3, [r3, #20]
 800277a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800277e:	2b00      	cmp	r3, #0
 8002780:	d00b      	beq.n	800279a <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8002782:	687b      	ldr	r3, [r7, #4]
 8002784:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002786:	2201      	movs	r2, #1
 8002788:	409a      	lsls	r2, r3
 800278a:	693b      	ldr	r3, [r7, #16]
 800278c:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800278e:	687b      	ldr	r3, [r7, #4]
 8002790:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002792:	f043 0202 	orr.w	r2, r3, #2
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 800279a:	687b      	ldr	r3, [r7, #4]
 800279c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800279e:	2204      	movs	r2, #4
 80027a0:	409a      	lsls	r2, r3
 80027a2:	68fb      	ldr	r3, [r7, #12]
 80027a4:	4013      	ands	r3, r2
 80027a6:	2b00      	cmp	r3, #0
 80027a8:	d012      	beq.n	80027d0 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80027aa:	687b      	ldr	r3, [r7, #4]
 80027ac:	681b      	ldr	r3, [r3, #0]
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	f003 0302 	and.w	r3, r3, #2
 80027b4:	2b00      	cmp	r3, #0
 80027b6:	d00b      	beq.n	80027d0 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80027bc:	2204      	movs	r2, #4
 80027be:	409a      	lsls	r2, r3
 80027c0:	693b      	ldr	r3, [r7, #16]
 80027c2:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80027c4:	687b      	ldr	r3, [r7, #4]
 80027c6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80027c8:	f043 0204 	orr.w	r2, r3, #4
 80027cc:	687b      	ldr	r3, [r7, #4]
 80027ce:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 80027d0:	687b      	ldr	r3, [r7, #4]
 80027d2:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80027d4:	2210      	movs	r2, #16
 80027d6:	409a      	lsls	r2, r3
 80027d8:	68fb      	ldr	r3, [r7, #12]
 80027da:	4013      	ands	r3, r2
 80027dc:	2b00      	cmp	r3, #0
 80027de:	d043      	beq.n	8002868 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80027e0:	687b      	ldr	r3, [r7, #4]
 80027e2:	681b      	ldr	r3, [r3, #0]
 80027e4:	681b      	ldr	r3, [r3, #0]
 80027e6:	f003 0308 	and.w	r3, r3, #8
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d03c      	beq.n	8002868 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80027ee:	687b      	ldr	r3, [r7, #4]
 80027f0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80027f2:	2210      	movs	r2, #16
 80027f4:	409a      	lsls	r2, r3
 80027f6:	693b      	ldr	r3, [r7, #16]
 80027f8:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR.reg) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80027fa:	687b      	ldr	r3, [r7, #4]
 80027fc:	681b      	ldr	r3, [r3, #0]
 80027fe:	681b      	ldr	r3, [r3, #0]
 8002800:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8002804:	2b00      	cmp	r3, #0
 8002806:	d018      	beq.n	800283a <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR.reg & DMA_SxCR_CT) == RESET)
 8002808:	687b      	ldr	r3, [r7, #4]
 800280a:	681b      	ldr	r3, [r3, #0]
 800280c:	681b      	ldr	r3, [r3, #0]
 800280e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002812:	2b00      	cmp	r3, #0
 8002814:	d108      	bne.n	8002828 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 8002816:	687b      	ldr	r3, [r7, #4]
 8002818:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800281a:	2b00      	cmp	r3, #0
 800281c:	d024      	beq.n	8002868 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 800281e:	687b      	ldr	r3, [r7, #4]
 8002820:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002822:	6878      	ldr	r0, [r7, #4]
 8002824:	4798      	blx	r3
 8002826:	e01f      	b.n	8002868 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 8002828:	687b      	ldr	r3, [r7, #4]
 800282a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800282c:	2b00      	cmp	r3, #0
 800282e:	d01b      	beq.n	8002868 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 8002830:	687b      	ldr	r3, [r7, #4]
 8002832:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002834:	6878      	ldr	r0, [r7, #4]
 8002836:	4798      	blx	r3
 8002838:	e016      	b.n	8002868 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR.reg & DMA_SxCR_CIRC) == RESET)
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	681b      	ldr	r3, [r3, #0]
 800283e:	681b      	ldr	r3, [r3, #0]
 8002840:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002844:	2b00      	cmp	r3, #0
 8002846:	d107      	bne.n	8002858 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 8002848:	687b      	ldr	r3, [r7, #4]
 800284a:	681b      	ldr	r3, [r3, #0]
 800284c:	681a      	ldr	r2, [r3, #0]
 800284e:	687b      	ldr	r3, [r7, #4]
 8002850:	681b      	ldr	r3, [r3, #0]
 8002852:	f022 0208 	bic.w	r2, r2, #8
 8002856:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 8002858:	687b      	ldr	r3, [r7, #4]
 800285a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800285c:	2b00      	cmp	r3, #0
 800285e:	d003      	beq.n	8002868 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 8002860:	687b      	ldr	r3, [r7, #4]
 8002862:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002864:	6878      	ldr	r0, [r7, #4]
 8002866:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8002868:	687b      	ldr	r3, [r7, #4]
 800286a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800286c:	2220      	movs	r2, #32
 800286e:	409a      	lsls	r2, r3
 8002870:	68fb      	ldr	r3, [r7, #12]
 8002872:	4013      	ands	r3, r2
 8002874:	2b00      	cmp	r3, #0
 8002876:	f000 808f 	beq.w	8002998 <HAL_DMA_IRQHandler+0x2a0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800287a:	687b      	ldr	r3, [r7, #4]
 800287c:	681b      	ldr	r3, [r3, #0]
 800287e:	681b      	ldr	r3, [r3, #0]
 8002880:	f003 0310 	and.w	r3, r3, #16
 8002884:	2b00      	cmp	r3, #0
 8002886:	f000 8087 	beq.w	8002998 <HAL_DMA_IRQHandler+0x2a0>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 800288a:	687b      	ldr	r3, [r7, #4]
 800288c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800288e:	2220      	movs	r2, #32
 8002890:	409a      	lsls	r2, r3
 8002892:	693b      	ldr	r3, [r7, #16]
 8002894:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8002896:	687b      	ldr	r3, [r7, #4]
 8002898:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800289c:	b2db      	uxtb	r3, r3
 800289e:	2b05      	cmp	r3, #5
 80028a0:	d136      	bne.n	8002910 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR.reg  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80028a2:	687b      	ldr	r3, [r7, #4]
 80028a4:	681b      	ldr	r3, [r3, #0]
 80028a6:	681a      	ldr	r2, [r3, #0]
 80028a8:	687b      	ldr	r3, [r7, #4]
 80028aa:	681b      	ldr	r3, [r3, #0]
 80028ac:	f022 0216 	bic.w	r2, r2, #22
 80028b0:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR.reg &= ~(DMA_IT_FE);
 80028b2:	687b      	ldr	r3, [r7, #4]
 80028b4:	681b      	ldr	r3, [r3, #0]
 80028b6:	695a      	ldr	r2, [r3, #20]
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	681b      	ldr	r3, [r3, #0]
 80028bc:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80028c0:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80028c2:	687b      	ldr	r3, [r7, #4]
 80028c4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80028c6:	2b00      	cmp	r3, #0
 80028c8:	d103      	bne.n	80028d2 <HAL_DMA_IRQHandler+0x1da>
 80028ca:	687b      	ldr	r3, [r7, #4]
 80028cc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d007      	beq.n	80028e2 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 80028d2:	687b      	ldr	r3, [r7, #4]
 80028d4:	681b      	ldr	r3, [r3, #0]
 80028d6:	681a      	ldr	r2, [r3, #0]
 80028d8:	687b      	ldr	r3, [r7, #4]
 80028da:	681b      	ldr	r3, [r3, #0]
 80028dc:	f022 0208 	bic.w	r2, r2, #8
 80028e0:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80028e6:	223f      	movs	r2, #63	@ 0x3f
 80028e8:	409a      	lsls	r2, r3
 80028ea:	693b      	ldr	r3, [r7, #16]
 80028ec:	609a      	str	r2, [r3, #8]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	2201      	movs	r2, #1
 80028f2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80028f6:	687b      	ldr	r3, [r7, #4]
 80028f8:	2200      	movs	r2, #0
 80028fa:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

        if(hdma->XferAbortCallback != NULL)
 80028fe:	687b      	ldr	r3, [r7, #4]
 8002900:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8002902:	2b00      	cmp	r3, #0
 8002904:	d07e      	beq.n	8002a04 <HAL_DMA_IRQHandler+0x30c>
        {
          hdma->XferAbortCallback(hdma);
 8002906:	687b      	ldr	r3, [r7, #4]
 8002908:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800290a:	6878      	ldr	r0, [r7, #4]
 800290c:	4798      	blx	r3
        }
        return;
 800290e:	e079      	b.n	8002a04 <HAL_DMA_IRQHandler+0x30c>
      }

      if(((hdma->Instance->CR.reg) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	681b      	ldr	r3, [r3, #0]
 8002914:	681b      	ldr	r3, [r3, #0]
 8002916:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800291a:	2b00      	cmp	r3, #0
 800291c:	d01d      	beq.n	800295a <HAL_DMA_IRQHandler+0x262>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR.reg & DMA_SxCR_CT) == RESET)
 800291e:	687b      	ldr	r3, [r7, #4]
 8002920:	681b      	ldr	r3, [r3, #0]
 8002922:	681b      	ldr	r3, [r3, #0]
 8002924:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002928:	2b00      	cmp	r3, #0
 800292a:	d10d      	bne.n	8002948 <HAL_DMA_IRQHandler+0x250>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002930:	2b00      	cmp	r3, #0
 8002932:	d031      	beq.n	8002998 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8002934:	687b      	ldr	r3, [r7, #4]
 8002936:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002938:	6878      	ldr	r0, [r7, #4]
 800293a:	4798      	blx	r3
 800293c:	e02c      	b.n	8002998 <HAL_DMA_IRQHandler+0x2a0>
 800293e:	bf00      	nop
 8002940:	20000000 	.word	0x20000000
 8002944:	1b4e81b5 	.word	0x1b4e81b5
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800294c:	2b00      	cmp	r3, #0
 800294e:	d023      	beq.n	8002998 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8002950:	687b      	ldr	r3, [r7, #4]
 8002952:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002954:	6878      	ldr	r0, [r7, #4]
 8002956:	4798      	blx	r3
 8002958:	e01e      	b.n	8002998 <HAL_DMA_IRQHandler+0x2a0>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR.reg & DMA_SxCR_CIRC) == RESET)
 800295a:	687b      	ldr	r3, [r7, #4]
 800295c:	681b      	ldr	r3, [r3, #0]
 800295e:	681b      	ldr	r3, [r3, #0]
 8002960:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002964:	2b00      	cmp	r3, #0
 8002966:	d10f      	bne.n	8002988 <HAL_DMA_IRQHandler+0x290>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR.reg  &= ~(DMA_IT_TC);
 8002968:	687b      	ldr	r3, [r7, #4]
 800296a:	681b      	ldr	r3, [r3, #0]
 800296c:	681a      	ldr	r2, [r3, #0]
 800296e:	687b      	ldr	r3, [r7, #4]
 8002970:	681b      	ldr	r3, [r3, #0]
 8002972:	f022 0210 	bic.w	r2, r2, #16
 8002976:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8002978:	687b      	ldr	r3, [r7, #4]
 800297a:	2201      	movs	r2, #1
 800297c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8002980:	687b      	ldr	r3, [r7, #4]
 8002982:	2200      	movs	r2, #0
 8002984:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 8002988:	687b      	ldr	r3, [r7, #4]
 800298a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800298c:	2b00      	cmp	r3, #0
 800298e:	d003      	beq.n	8002998 <HAL_DMA_IRQHandler+0x2a0>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8002990:	687b      	ldr	r3, [r7, #4]
 8002992:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002994:	6878      	ldr	r0, [r7, #4]
 8002996:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8002998:	687b      	ldr	r3, [r7, #4]
 800299a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800299c:	2b00      	cmp	r3, #0
 800299e:	d032      	beq.n	8002a06 <HAL_DMA_IRQHandler+0x30e>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 80029a0:	687b      	ldr	r3, [r7, #4]
 80029a2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80029a4:	f003 0301 	and.w	r3, r3, #1
 80029a8:	2b00      	cmp	r3, #0
 80029aa:	d022      	beq.n	80029f2 <HAL_DMA_IRQHandler+0x2fa>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 80029ac:	687b      	ldr	r3, [r7, #4]
 80029ae:	2205      	movs	r2, #5
 80029b0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 80029b4:	687b      	ldr	r3, [r7, #4]
 80029b6:	681b      	ldr	r3, [r3, #0]
 80029b8:	681a      	ldr	r2, [r3, #0]
 80029ba:	687b      	ldr	r3, [r7, #4]
 80029bc:	681b      	ldr	r3, [r3, #0]
 80029be:	f022 0201 	bic.w	r2, r2, #1
 80029c2:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 80029c4:	68bb      	ldr	r3, [r7, #8]
 80029c6:	3301      	adds	r3, #1
 80029c8:	60bb      	str	r3, [r7, #8]
 80029ca:	697a      	ldr	r2, [r7, #20]
 80029cc:	429a      	cmp	r2, r3
 80029ce:	d307      	bcc.n	80029e0 <HAL_DMA_IRQHandler+0x2e8>
        {
          break;
        }
      }
      while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET);
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	681b      	ldr	r3, [r3, #0]
 80029d4:	681b      	ldr	r3, [r3, #0]
 80029d6:	f003 0301 	and.w	r3, r3, #1
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d1f2      	bne.n	80029c4 <HAL_DMA_IRQHandler+0x2cc>
 80029de:	e000      	b.n	80029e2 <HAL_DMA_IRQHandler+0x2ea>
          break;
 80029e0:	bf00      	nop

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80029e2:	687b      	ldr	r3, [r7, #4]
 80029e4:	2201      	movs	r2, #1
 80029e6:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80029ea:	687b      	ldr	r3, [r7, #4]
 80029ec:	2200      	movs	r2, #0
 80029ee:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    }

    if(hdma->XferErrorCallback != NULL)
 80029f2:	687b      	ldr	r3, [r7, #4]
 80029f4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80029f6:	2b00      	cmp	r3, #0
 80029f8:	d005      	beq.n	8002a06 <HAL_DMA_IRQHandler+0x30e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80029fa:	687b      	ldr	r3, [r7, #4]
 80029fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80029fe:	6878      	ldr	r0, [r7, #4]
 8002a00:	4798      	blx	r3
 8002a02:	e000      	b.n	8002a06 <HAL_DMA_IRQHandler+0x30e>
        return;
 8002a04:	bf00      	nop
    }
  }
}
 8002a06:	3718      	adds	r7, #24
 8002a08:	46bd      	mov	sp, r7
 8002a0a:	bd80      	pop	{r7, pc}

08002a0c <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8002a0c:	b480      	push	{r7}
 8002a0e:	b085      	sub	sp, #20
 8002a10:	af00      	add	r7, sp, #0
 8002a12:	60f8      	str	r0, [r7, #12]
 8002a14:	60b9      	str	r1, [r7, #8]
 8002a16:	607a      	str	r2, [r7, #4]
 8002a18:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR.reg &= (uint32_t)(~DMA_SxCR_DBM);
 8002a1a:	68fb      	ldr	r3, [r7, #12]
 8002a1c:	681b      	ldr	r3, [r3, #0]
 8002a1e:	681a      	ldr	r2, [r3, #0]
 8002a20:	68fb      	ldr	r3, [r7, #12]
 8002a22:	681b      	ldr	r3, [r3, #0]
 8002a24:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8002a28:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR.reg = DataLength;
 8002a2a:	68fb      	ldr	r3, [r7, #12]
 8002a2c:	681b      	ldr	r3, [r3, #0]
 8002a2e:	683a      	ldr	r2, [r7, #0]
 8002a30:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8002a32:	68fb      	ldr	r3, [r7, #12]
 8002a34:	689b      	ldr	r3, [r3, #8]
 8002a36:	2b40      	cmp	r3, #64	@ 0x40
 8002a38:	d108      	bne.n	8002a4c <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8002a3a:	68fb      	ldr	r3, [r7, #12]
 8002a3c:	681b      	ldr	r3, [r3, #0]
 8002a3e:	687a      	ldr	r2, [r7, #4]
 8002a40:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8002a42:	68fb      	ldr	r3, [r7, #12]
 8002a44:	681b      	ldr	r3, [r3, #0]
 8002a46:	68ba      	ldr	r2, [r7, #8]
 8002a48:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 8002a4a:	e007      	b.n	8002a5c <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 8002a4c:	68fb      	ldr	r3, [r7, #12]
 8002a4e:	681b      	ldr	r3, [r3, #0]
 8002a50:	68ba      	ldr	r2, [r7, #8]
 8002a52:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 8002a54:	68fb      	ldr	r3, [r7, #12]
 8002a56:	681b      	ldr	r3, [r3, #0]
 8002a58:	687a      	ldr	r2, [r7, #4]
 8002a5a:	60da      	str	r2, [r3, #12]
}
 8002a5c:	bf00      	nop
 8002a5e:	3714      	adds	r7, #20
 8002a60:	46bd      	mov	sp, r7
 8002a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a66:	4770      	bx	lr

08002a68 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 8002a68:	b480      	push	{r7}
 8002a6a:	b085      	sub	sp, #20
 8002a6c:	af00      	add	r7, sp, #0
 8002a6e:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002a70:	687b      	ldr	r3, [r7, #4]
 8002a72:	681b      	ldr	r3, [r3, #0]
 8002a74:	b2db      	uxtb	r3, r3
 8002a76:	3b10      	subs	r3, #16
 8002a78:	4a14      	ldr	r2, [pc, #80]	@ (8002acc <DMA_CalcBaseAndBitshift+0x64>)
 8002a7a:	fba2 2303 	umull	r2, r3, r2, r3
 8002a7e:	091b      	lsrs	r3, r3, #4
 8002a80:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002a82:	4a13      	ldr	r2, [pc, #76]	@ (8002ad0 <DMA_CalcBaseAndBitshift+0x68>)
 8002a84:	68fb      	ldr	r3, [r7, #12]
 8002a86:	4413      	add	r3, r2
 8002a88:	781b      	ldrb	r3, [r3, #0]
 8002a8a:	461a      	mov	r2, r3
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	65da      	str	r2, [r3, #92]	@ 0x5c
  
  if (stream_number > 3U)
 8002a90:	68fb      	ldr	r3, [r7, #12]
 8002a92:	2b03      	cmp	r3, #3
 8002a94:	d909      	bls.n	8002aaa <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002a96:	687b      	ldr	r3, [r7, #4]
 8002a98:	681b      	ldr	r3, [r3, #0]
 8002a9a:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 8002a9e:	f023 0303 	bic.w	r3, r3, #3
 8002aa2:	1d1a      	adds	r2, r3, #4
 8002aa4:	687b      	ldr	r3, [r7, #4]
 8002aa6:	659a      	str	r2, [r3, #88]	@ 0x58
 8002aa8:	e007      	b.n	8002aba <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8002aaa:	687b      	ldr	r3, [r7, #4]
 8002aac:	681b      	ldr	r3, [r3, #0]
 8002aae:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 8002ab2:	f023 0303 	bic.w	r3, r3, #3
 8002ab6:	687a      	ldr	r2, [r7, #4]
 8002ab8:	6593      	str	r3, [r2, #88]	@ 0x58
  }
  
  return hdma->StreamBaseAddress;
 8002aba:	687b      	ldr	r3, [r7, #4]
 8002abc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
 8002abe:	4618      	mov	r0, r3
 8002ac0:	3714      	adds	r7, #20
 8002ac2:	46bd      	mov	sp, r7
 8002ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ac8:	4770      	bx	lr
 8002aca:	bf00      	nop
 8002acc:	aaaaaaab 	.word	0xaaaaaaab
 8002ad0:	0802faf8 	.word	0x0802faf8

08002ad4 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 8002ad4:	b480      	push	{r7}
 8002ad6:	b085      	sub	sp, #20
 8002ad8:	af00      	add	r7, sp, #0
 8002ada:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002adc:	2300      	movs	r3, #0
 8002ade:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 8002ae0:	687b      	ldr	r3, [r7, #4]
 8002ae2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002ae4:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8002ae6:	687b      	ldr	r3, [r7, #4]
 8002ae8:	699b      	ldr	r3, [r3, #24]
 8002aea:	2b00      	cmp	r3, #0
 8002aec:	d11f      	bne.n	8002b2e <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 8002aee:	68bb      	ldr	r3, [r7, #8]
 8002af0:	2b03      	cmp	r3, #3
 8002af2:	d856      	bhi.n	8002ba2 <DMA_CheckFifoParam+0xce>
 8002af4:	a201      	add	r2, pc, #4	@ (adr r2, 8002afc <DMA_CheckFifoParam+0x28>)
 8002af6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002afa:	bf00      	nop
 8002afc:	08002b0d 	.word	0x08002b0d
 8002b00:	08002b1f 	.word	0x08002b1f
 8002b04:	08002b0d 	.word	0x08002b0d
 8002b08:	08002ba3 	.word	0x08002ba3
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8002b0c:	687b      	ldr	r3, [r7, #4]
 8002b0e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b10:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8002b14:	2b00      	cmp	r3, #0
 8002b16:	d046      	beq.n	8002ba6 <DMA_CheckFifoParam+0xd2>
      {
        status = HAL_ERROR;
 8002b18:	2301      	movs	r3, #1
 8002b1a:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8002b1c:	e043      	b.n	8002ba6 <DMA_CheckFifoParam+0xd2>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8002b1e:	687b      	ldr	r3, [r7, #4]
 8002b20:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b22:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 8002b26:	d140      	bne.n	8002baa <DMA_CheckFifoParam+0xd6>
      {
        status = HAL_ERROR;
 8002b28:	2301      	movs	r3, #1
 8002b2a:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8002b2c:	e03d      	b.n	8002baa <DMA_CheckFifoParam+0xd6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8002b2e:	687b      	ldr	r3, [r7, #4]
 8002b30:	699b      	ldr	r3, [r3, #24]
 8002b32:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8002b36:	d121      	bne.n	8002b7c <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 8002b38:	68bb      	ldr	r3, [r7, #8]
 8002b3a:	2b03      	cmp	r3, #3
 8002b3c:	d837      	bhi.n	8002bae <DMA_CheckFifoParam+0xda>
 8002b3e:	a201      	add	r2, pc, #4	@ (adr r2, 8002b44 <DMA_CheckFifoParam+0x70>)
 8002b40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002b44:	08002b55 	.word	0x08002b55
 8002b48:	08002b5b 	.word	0x08002b5b
 8002b4c:	08002b55 	.word	0x08002b55
 8002b50:	08002b6d 	.word	0x08002b6d
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 8002b54:	2301      	movs	r3, #1
 8002b56:	73fb      	strb	r3, [r7, #15]
      break;
 8002b58:	e030      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8002b5a:	687b      	ldr	r3, [r7, #4]
 8002b5c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b5e:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8002b62:	2b00      	cmp	r3, #0
 8002b64:	d025      	beq.n	8002bb2 <DMA_CheckFifoParam+0xde>
      {
        status = HAL_ERROR;
 8002b66:	2301      	movs	r3, #1
 8002b68:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8002b6a:	e022      	b.n	8002bb2 <DMA_CheckFifoParam+0xde>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8002b6c:	687b      	ldr	r3, [r7, #4]
 8002b6e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b70:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 8002b74:	d11f      	bne.n	8002bb6 <DMA_CheckFifoParam+0xe2>
      {
        status = HAL_ERROR;
 8002b76:	2301      	movs	r3, #1
 8002b78:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 8002b7a:	e01c      	b.n	8002bb6 <DMA_CheckFifoParam+0xe2>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8002b7c:	68bb      	ldr	r3, [r7, #8]
 8002b7e:	2b02      	cmp	r3, #2
 8002b80:	d903      	bls.n	8002b8a <DMA_CheckFifoParam+0xb6>
 8002b82:	68bb      	ldr	r3, [r7, #8]
 8002b84:	2b03      	cmp	r3, #3
 8002b86:	d003      	beq.n	8002b90 <DMA_CheckFifoParam+0xbc>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 8002b88:	e018      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      status = HAL_ERROR;
 8002b8a:	2301      	movs	r3, #1
 8002b8c:	73fb      	strb	r3, [r7, #15]
      break;
 8002b8e:	e015      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8002b90:	687b      	ldr	r3, [r7, #4]
 8002b92:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b94:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8002b98:	2b00      	cmp	r3, #0
 8002b9a:	d00e      	beq.n	8002bba <DMA_CheckFifoParam+0xe6>
        status = HAL_ERROR;
 8002b9c:	2301      	movs	r3, #1
 8002b9e:	73fb      	strb	r3, [r7, #15]
      break;
 8002ba0:	e00b      	b.n	8002bba <DMA_CheckFifoParam+0xe6>
      break;
 8002ba2:	bf00      	nop
 8002ba4:	e00a      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;
 8002ba6:	bf00      	nop
 8002ba8:	e008      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;
 8002baa:	bf00      	nop
 8002bac:	e006      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;
 8002bae:	bf00      	nop
 8002bb0:	e004      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;
 8002bb2:	bf00      	nop
 8002bb4:	e002      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;   
 8002bb6:	bf00      	nop
 8002bb8:	e000      	b.n	8002bbc <DMA_CheckFifoParam+0xe8>
      break;
 8002bba:	bf00      	nop
    }
  } 
  
  return status; 
 8002bbc:	7bfb      	ldrb	r3, [r7, #15]
}
 8002bbe:	4618      	mov	r0, r3
 8002bc0:	3714      	adds	r7, #20
 8002bc2:	46bd      	mov	sp, r7
 8002bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bc8:	4770      	bx	lr
 8002bca:	bf00      	nop

08002bcc <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
 8002bcc:	b580      	push	{r7, lr}
 8002bce:	b086      	sub	sp, #24
 8002bd0:	af00      	add	r7, sp, #0
 8002bd2:	60f8      	str	r0, [r7, #12]
 8002bd4:	60b9      	str	r1, [r7, #8]
 8002bd6:	607a      	str	r2, [r7, #4]
 8002bd8:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002bda:	2300      	movs	r3, #0
 8002bdc:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8002bde:	68fb      	ldr	r3, [r7, #12]
 8002be0:	689b      	ldr	r3, [r3, #8]
 8002be2:	2b80      	cmp	r3, #128	@ 0x80
 8002be4:	d106      	bne.n	8002bf4 <HAL_DMAEx_MultiBufferStart_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 8002be6:	68fb      	ldr	r3, [r7, #12]
 8002be8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8002bec:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 8002bee:	2301      	movs	r3, #1
 8002bf0:	f001 b911 	b.w	8003e16 <HAL_DMAEx_MultiBufferStart_IT+0x124a>
  }
  
  /* Check callback functions */
  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))
 8002bf4:	68fb      	ldr	r3, [r7, #12]
 8002bf6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002bf8:	2b00      	cmp	r3, #0
 8002bfa:	d007      	beq.n	8002c0c <HAL_DMAEx_MultiBufferStart_IT+0x40>
 8002bfc:	68fb      	ldr	r3, [r7, #12]
 8002bfe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c00:	2b00      	cmp	r3, #0
 8002c02:	d003      	beq.n	8002c0c <HAL_DMAEx_MultiBufferStart_IT+0x40>
 8002c04:	68fb      	ldr	r3, [r7, #12]
 8002c06:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002c08:	2b00      	cmp	r3, #0
 8002c0a:	d105      	bne.n	8002c18 <HAL_DMAEx_MultiBufferStart_IT+0x4c>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002c0c:	68fb      	ldr	r3, [r7, #12]
 8002c0e:	2240      	movs	r2, #64	@ 0x40
 8002c10:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 8002c12:	2301      	movs	r3, #1
 8002c14:	f001 b8ff 	b.w	8003e16 <HAL_DMAEx_MultiBufferStart_IT+0x124a>
  }
  
  /* Process locked */
  __HAL_LOCK(hdma);
 8002c18:	68fb      	ldr	r3, [r7, #12]
 8002c1a:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8002c1e:	2b01      	cmp	r3, #1
 8002c20:	d102      	bne.n	8002c28 <HAL_DMAEx_MultiBufferStart_IT+0x5c>
 8002c22:	2302      	movs	r3, #2
 8002c24:	f001 b8f7 	b.w	8003e16 <HAL_DMAEx_MultiBufferStart_IT+0x124a>
 8002c28:	68fb      	ldr	r3, [r7, #12]
 8002c2a:	2201      	movs	r2, #1
 8002c2c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8002c30:	68fb      	ldr	r3, [r7, #12]
 8002c32:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8002c36:	b2db      	uxtb	r3, r3
 8002c38:	2b01      	cmp	r3, #1
 8002c3a:	f041 80e5 	bne.w	8003e08 <HAL_DMAEx_MultiBufferStart_IT+0x123c>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8002c3e:	68fb      	ldr	r3, [r7, #12]
 8002c40:	2202      	movs	r2, #2
 8002c42:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002c46:	68fb      	ldr	r3, [r7, #12]
 8002c48:	2200      	movs	r2, #0
 8002c4a:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Enable the Double buffer mode */
    hdma->Instance->CR.reg |= (uint32_t)DMA_SxCR_DBM;
 8002c4c:	68fb      	ldr	r3, [r7, #12]
 8002c4e:	681b      	ldr	r3, [r3, #0]
 8002c50:	681a      	ldr	r2, [r3, #0]
 8002c52:	68fb      	ldr	r3, [r7, #12]
 8002c54:	681b      	ldr	r3, [r3, #0]
 8002c56:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8002c5a:	601a      	str	r2, [r3, #0]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M1AR = SecondMemAddress;
 8002c5c:	68fb      	ldr	r3, [r7, #12]
 8002c5e:	681b      	ldr	r3, [r3, #0]
 8002c60:	683a      	ldr	r2, [r7, #0]
 8002c62:	611a      	str	r2, [r3, #16]
    
    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
 8002c64:	6a3b      	ldr	r3, [r7, #32]
 8002c66:	687a      	ldr	r2, [r7, #4]
 8002c68:	68b9      	ldr	r1, [r7, #8]
 8002c6a:	68f8      	ldr	r0, [r7, #12]
 8002c6c:	f001 f910 	bl	8003e90 <DMA_MultiBufferSetConfig>
    
    /* Clear all flags */
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8002c70:	68fb      	ldr	r3, [r7, #12]
 8002c72:	681b      	ldr	r3, [r3, #0]
 8002c74:	461a      	mov	r2, r3
 8002c76:	4b8d      	ldr	r3, [pc, #564]	@ (8002eac <HAL_DMAEx_MultiBufferStart_IT+0x2e0>)
 8002c78:	429a      	cmp	r2, r3
 8002c7a:	d960      	bls.n	8002d3e <HAL_DMAEx_MultiBufferStart_IT+0x172>
 8002c7c:	68fb      	ldr	r3, [r7, #12]
 8002c7e:	681b      	ldr	r3, [r3, #0]
 8002c80:	4a8b      	ldr	r2, [pc, #556]	@ (8002eb0 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002c82:	4293      	cmp	r3, r2
 8002c84:	d057      	beq.n	8002d36 <HAL_DMAEx_MultiBufferStart_IT+0x16a>
 8002c86:	68fb      	ldr	r3, [r7, #12]
 8002c88:	681b      	ldr	r3, [r3, #0]
 8002c8a:	4a8a      	ldr	r2, [pc, #552]	@ (8002eb4 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002c8c:	4293      	cmp	r3, r2
 8002c8e:	d050      	beq.n	8002d32 <HAL_DMAEx_MultiBufferStart_IT+0x166>
 8002c90:	68fb      	ldr	r3, [r7, #12]
 8002c92:	681b      	ldr	r3, [r3, #0]
 8002c94:	4a88      	ldr	r2, [pc, #544]	@ (8002eb8 <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002c96:	4293      	cmp	r3, r2
 8002c98:	d049      	beq.n	8002d2e <HAL_DMAEx_MultiBufferStart_IT+0x162>
 8002c9a:	68fb      	ldr	r3, [r7, #12]
 8002c9c:	681b      	ldr	r3, [r3, #0]
 8002c9e:	4a87      	ldr	r2, [pc, #540]	@ (8002ebc <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002ca0:	4293      	cmp	r3, r2
 8002ca2:	d042      	beq.n	8002d2a <HAL_DMAEx_MultiBufferStart_IT+0x15e>
 8002ca4:	68fb      	ldr	r3, [r7, #12]
 8002ca6:	681b      	ldr	r3, [r3, #0]
 8002ca8:	4a85      	ldr	r2, [pc, #532]	@ (8002ec0 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002caa:	4293      	cmp	r3, r2
 8002cac:	d03a      	beq.n	8002d24 <HAL_DMAEx_MultiBufferStart_IT+0x158>
 8002cae:	68fb      	ldr	r3, [r7, #12]
 8002cb0:	681b      	ldr	r3, [r3, #0]
 8002cb2:	4a84      	ldr	r2, [pc, #528]	@ (8002ec4 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002cb4:	4293      	cmp	r3, r2
 8002cb6:	d032      	beq.n	8002d1e <HAL_DMAEx_MultiBufferStart_IT+0x152>
 8002cb8:	68fb      	ldr	r3, [r7, #12]
 8002cba:	681b      	ldr	r3, [r3, #0]
 8002cbc:	4a82      	ldr	r2, [pc, #520]	@ (8002ec8 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002cbe:	4293      	cmp	r3, r2
 8002cc0:	d02a      	beq.n	8002d18 <HAL_DMAEx_MultiBufferStart_IT+0x14c>
 8002cc2:	68fb      	ldr	r3, [r7, #12]
 8002cc4:	681b      	ldr	r3, [r3, #0]
 8002cc6:	4a81      	ldr	r2, [pc, #516]	@ (8002ecc <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002cc8:	4293      	cmp	r3, r2
 8002cca:	d022      	beq.n	8002d12 <HAL_DMAEx_MultiBufferStart_IT+0x146>
 8002ccc:	68fb      	ldr	r3, [r7, #12]
 8002cce:	681b      	ldr	r3, [r3, #0]
 8002cd0:	4a7f      	ldr	r2, [pc, #508]	@ (8002ed0 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002cd2:	4293      	cmp	r3, r2
 8002cd4:	d01a      	beq.n	8002d0c <HAL_DMAEx_MultiBufferStart_IT+0x140>
 8002cd6:	68fb      	ldr	r3, [r7, #12]
 8002cd8:	681b      	ldr	r3, [r3, #0]
 8002cda:	4a7e      	ldr	r2, [pc, #504]	@ (8002ed4 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002cdc:	4293      	cmp	r3, r2
 8002cde:	d012      	beq.n	8002d06 <HAL_DMAEx_MultiBufferStart_IT+0x13a>
 8002ce0:	68fb      	ldr	r3, [r7, #12]
 8002ce2:	681b      	ldr	r3, [r3, #0]
 8002ce4:	4a7c      	ldr	r2, [pc, #496]	@ (8002ed8 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002ce6:	4293      	cmp	r3, r2
 8002ce8:	d00a      	beq.n	8002d00 <HAL_DMAEx_MultiBufferStart_IT+0x134>
 8002cea:	68fb      	ldr	r3, [r7, #12]
 8002cec:	681b      	ldr	r3, [r3, #0]
 8002cee:	4a7b      	ldr	r2, [pc, #492]	@ (8002edc <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002cf0:	4293      	cmp	r3, r2
 8002cf2:	d102      	bne.n	8002cfa <HAL_DMAEx_MultiBufferStart_IT+0x12e>
 8002cf4:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002cf8:	e01e      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002cfa:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002cfe:	e01b      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d00:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002d04:	e018      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d06:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002d0a:	e015      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d0c:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002d10:	e012      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d12:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d16:	e00f      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d18:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d1c:	e00c      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d1e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d22:	e009      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d24:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d28:	e006      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d2a:	2320      	movs	r3, #32
 8002d2c:	e004      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d2e:	2320      	movs	r3, #32
 8002d30:	e002      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d32:	2320      	movs	r3, #32
 8002d34:	e000      	b.n	8002d38 <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002d36:	2320      	movs	r3, #32
 8002d38:	4a69      	ldr	r2, [pc, #420]	@ (8002ee0 <HAL_DMAEx_MultiBufferStart_IT+0x314>)
 8002d3a:	60d3      	str	r3, [r2, #12]
 8002d3c:	e14f      	b.n	8002fde <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002d3e:	68fb      	ldr	r3, [r7, #12]
 8002d40:	681b      	ldr	r3, [r3, #0]
 8002d42:	461a      	mov	r2, r3
 8002d44:	4b67      	ldr	r3, [pc, #412]	@ (8002ee4 <HAL_DMAEx_MultiBufferStart_IT+0x318>)
 8002d46:	429a      	cmp	r2, r3
 8002d48:	d960      	bls.n	8002e0c <HAL_DMAEx_MultiBufferStart_IT+0x240>
 8002d4a:	68fb      	ldr	r3, [r7, #12]
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	4a58      	ldr	r2, [pc, #352]	@ (8002eb0 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002d50:	4293      	cmp	r3, r2
 8002d52:	d057      	beq.n	8002e04 <HAL_DMAEx_MultiBufferStart_IT+0x238>
 8002d54:	68fb      	ldr	r3, [r7, #12]
 8002d56:	681b      	ldr	r3, [r3, #0]
 8002d58:	4a56      	ldr	r2, [pc, #344]	@ (8002eb4 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002d5a:	4293      	cmp	r3, r2
 8002d5c:	d050      	beq.n	8002e00 <HAL_DMAEx_MultiBufferStart_IT+0x234>
 8002d5e:	68fb      	ldr	r3, [r7, #12]
 8002d60:	681b      	ldr	r3, [r3, #0]
 8002d62:	4a55      	ldr	r2, [pc, #340]	@ (8002eb8 <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002d64:	4293      	cmp	r3, r2
 8002d66:	d049      	beq.n	8002dfc <HAL_DMAEx_MultiBufferStart_IT+0x230>
 8002d68:	68fb      	ldr	r3, [r7, #12]
 8002d6a:	681b      	ldr	r3, [r3, #0]
 8002d6c:	4a53      	ldr	r2, [pc, #332]	@ (8002ebc <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002d6e:	4293      	cmp	r3, r2
 8002d70:	d042      	beq.n	8002df8 <HAL_DMAEx_MultiBufferStart_IT+0x22c>
 8002d72:	68fb      	ldr	r3, [r7, #12]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	4a52      	ldr	r2, [pc, #328]	@ (8002ec0 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002d78:	4293      	cmp	r3, r2
 8002d7a:	d03a      	beq.n	8002df2 <HAL_DMAEx_MultiBufferStart_IT+0x226>
 8002d7c:	68fb      	ldr	r3, [r7, #12]
 8002d7e:	681b      	ldr	r3, [r3, #0]
 8002d80:	4a50      	ldr	r2, [pc, #320]	@ (8002ec4 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002d82:	4293      	cmp	r3, r2
 8002d84:	d032      	beq.n	8002dec <HAL_DMAEx_MultiBufferStart_IT+0x220>
 8002d86:	68fb      	ldr	r3, [r7, #12]
 8002d88:	681b      	ldr	r3, [r3, #0]
 8002d8a:	4a4f      	ldr	r2, [pc, #316]	@ (8002ec8 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002d8c:	4293      	cmp	r3, r2
 8002d8e:	d02a      	beq.n	8002de6 <HAL_DMAEx_MultiBufferStart_IT+0x21a>
 8002d90:	68fb      	ldr	r3, [r7, #12]
 8002d92:	681b      	ldr	r3, [r3, #0]
 8002d94:	4a4d      	ldr	r2, [pc, #308]	@ (8002ecc <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002d96:	4293      	cmp	r3, r2
 8002d98:	d022      	beq.n	8002de0 <HAL_DMAEx_MultiBufferStart_IT+0x214>
 8002d9a:	68fb      	ldr	r3, [r7, #12]
 8002d9c:	681b      	ldr	r3, [r3, #0]
 8002d9e:	4a4c      	ldr	r2, [pc, #304]	@ (8002ed0 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002da0:	4293      	cmp	r3, r2
 8002da2:	d01a      	beq.n	8002dda <HAL_DMAEx_MultiBufferStart_IT+0x20e>
 8002da4:	68fb      	ldr	r3, [r7, #12]
 8002da6:	681b      	ldr	r3, [r3, #0]
 8002da8:	4a4a      	ldr	r2, [pc, #296]	@ (8002ed4 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002daa:	4293      	cmp	r3, r2
 8002dac:	d012      	beq.n	8002dd4 <HAL_DMAEx_MultiBufferStart_IT+0x208>
 8002dae:	68fb      	ldr	r3, [r7, #12]
 8002db0:	681b      	ldr	r3, [r3, #0]
 8002db2:	4a49      	ldr	r2, [pc, #292]	@ (8002ed8 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002db4:	4293      	cmp	r3, r2
 8002db6:	d00a      	beq.n	8002dce <HAL_DMAEx_MultiBufferStart_IT+0x202>
 8002db8:	68fb      	ldr	r3, [r7, #12]
 8002dba:	681b      	ldr	r3, [r3, #0]
 8002dbc:	4a47      	ldr	r2, [pc, #284]	@ (8002edc <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002dbe:	4293      	cmp	r3, r2
 8002dc0:	d102      	bne.n	8002dc8 <HAL_DMAEx_MultiBufferStart_IT+0x1fc>
 8002dc2:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dc6:	e01e      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dc8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002dcc:	e01b      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dce:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dd2:	e018      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dd4:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dd8:	e015      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dda:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dde:	e012      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002de0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002de4:	e00f      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002de6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002dea:	e00c      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dec:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002df0:	e009      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002df2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002df6:	e006      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002df8:	2320      	movs	r3, #32
 8002dfa:	e004      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002dfc:	2320      	movs	r3, #32
 8002dfe:	e002      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002e00:	2320      	movs	r3, #32
 8002e02:	e000      	b.n	8002e06 <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002e04:	2320      	movs	r3, #32
 8002e06:	4a36      	ldr	r2, [pc, #216]	@ (8002ee0 <HAL_DMAEx_MultiBufferStart_IT+0x314>)
 8002e08:	6093      	str	r3, [r2, #8]
 8002e0a:	e0e8      	b.n	8002fde <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002e0c:	68fb      	ldr	r3, [r7, #12]
 8002e0e:	681b      	ldr	r3, [r3, #0]
 8002e10:	461a      	mov	r2, r3
 8002e12:	4b35      	ldr	r3, [pc, #212]	@ (8002ee8 <HAL_DMAEx_MultiBufferStart_IT+0x31c>)
 8002e14:	429a      	cmp	r2, r3
 8002e16:	f240 8082 	bls.w	8002f1e <HAL_DMAEx_MultiBufferStart_IT+0x352>
 8002e1a:	68fb      	ldr	r3, [r7, #12]
 8002e1c:	681b      	ldr	r3, [r3, #0]
 8002e1e:	4a24      	ldr	r2, [pc, #144]	@ (8002eb0 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002e20:	4293      	cmp	r3, r2
 8002e22:	d078      	beq.n	8002f16 <HAL_DMAEx_MultiBufferStart_IT+0x34a>
 8002e24:	68fb      	ldr	r3, [r7, #12]
 8002e26:	681b      	ldr	r3, [r3, #0]
 8002e28:	4a22      	ldr	r2, [pc, #136]	@ (8002eb4 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002e2a:	4293      	cmp	r3, r2
 8002e2c:	d071      	beq.n	8002f12 <HAL_DMAEx_MultiBufferStart_IT+0x346>
 8002e2e:	68fb      	ldr	r3, [r7, #12]
 8002e30:	681b      	ldr	r3, [r3, #0]
 8002e32:	4a21      	ldr	r2, [pc, #132]	@ (8002eb8 <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002e34:	4293      	cmp	r3, r2
 8002e36:	d06a      	beq.n	8002f0e <HAL_DMAEx_MultiBufferStart_IT+0x342>
 8002e38:	68fb      	ldr	r3, [r7, #12]
 8002e3a:	681b      	ldr	r3, [r3, #0]
 8002e3c:	4a1f      	ldr	r2, [pc, #124]	@ (8002ebc <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002e3e:	4293      	cmp	r3, r2
 8002e40:	d063      	beq.n	8002f0a <HAL_DMAEx_MultiBufferStart_IT+0x33e>
 8002e42:	68fb      	ldr	r3, [r7, #12]
 8002e44:	681b      	ldr	r3, [r3, #0]
 8002e46:	4a1e      	ldr	r2, [pc, #120]	@ (8002ec0 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002e48:	4293      	cmp	r3, r2
 8002e4a:	d05b      	beq.n	8002f04 <HAL_DMAEx_MultiBufferStart_IT+0x338>
 8002e4c:	68fb      	ldr	r3, [r7, #12]
 8002e4e:	681b      	ldr	r3, [r3, #0]
 8002e50:	4a1c      	ldr	r2, [pc, #112]	@ (8002ec4 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002e52:	4293      	cmp	r3, r2
 8002e54:	d053      	beq.n	8002efe <HAL_DMAEx_MultiBufferStart_IT+0x332>
 8002e56:	68fb      	ldr	r3, [r7, #12]
 8002e58:	681b      	ldr	r3, [r3, #0]
 8002e5a:	4a1b      	ldr	r2, [pc, #108]	@ (8002ec8 <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002e5c:	4293      	cmp	r3, r2
 8002e5e:	d04b      	beq.n	8002ef8 <HAL_DMAEx_MultiBufferStart_IT+0x32c>
 8002e60:	68fb      	ldr	r3, [r7, #12]
 8002e62:	681b      	ldr	r3, [r3, #0]
 8002e64:	4a19      	ldr	r2, [pc, #100]	@ (8002ecc <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002e66:	4293      	cmp	r3, r2
 8002e68:	d043      	beq.n	8002ef2 <HAL_DMAEx_MultiBufferStart_IT+0x326>
 8002e6a:	68fb      	ldr	r3, [r7, #12]
 8002e6c:	681b      	ldr	r3, [r3, #0]
 8002e6e:	4a18      	ldr	r2, [pc, #96]	@ (8002ed0 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002e70:	4293      	cmp	r3, r2
 8002e72:	d03b      	beq.n	8002eec <HAL_DMAEx_MultiBufferStart_IT+0x320>
 8002e74:	68fb      	ldr	r3, [r7, #12]
 8002e76:	681b      	ldr	r3, [r3, #0]
 8002e78:	4a16      	ldr	r2, [pc, #88]	@ (8002ed4 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002e7a:	4293      	cmp	r3, r2
 8002e7c:	d012      	beq.n	8002ea4 <HAL_DMAEx_MultiBufferStart_IT+0x2d8>
 8002e7e:	68fb      	ldr	r3, [r7, #12]
 8002e80:	681b      	ldr	r3, [r3, #0]
 8002e82:	4a15      	ldr	r2, [pc, #84]	@ (8002ed8 <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002e84:	4293      	cmp	r3, r2
 8002e86:	d00a      	beq.n	8002e9e <HAL_DMAEx_MultiBufferStart_IT+0x2d2>
 8002e88:	68fb      	ldr	r3, [r7, #12]
 8002e8a:	681b      	ldr	r3, [r3, #0]
 8002e8c:	4a13      	ldr	r2, [pc, #76]	@ (8002edc <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002e8e:	4293      	cmp	r3, r2
 8002e90:	d102      	bne.n	8002e98 <HAL_DMAEx_MultiBufferStart_IT+0x2cc>
 8002e92:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002e96:	e03f      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002e98:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002e9c:	e03c      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002e9e:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002ea2:	e039      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002ea4:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002ea8:	e036      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002eaa:	bf00      	nop
 8002eac:	40026458 	.word	0x40026458
 8002eb0:	40026010 	.word	0x40026010
 8002eb4:	40026410 	.word	0x40026410
 8002eb8:	40026070 	.word	0x40026070
 8002ebc:	40026470 	.word	0x40026470
 8002ec0:	40026028 	.word	0x40026028
 8002ec4:	40026428 	.word	0x40026428
 8002ec8:	40026088 	.word	0x40026088
 8002ecc:	40026488 	.word	0x40026488
 8002ed0:	40026040 	.word	0x40026040
 8002ed4:	40026440 	.word	0x40026440
 8002ed8:	400260a0 	.word	0x400260a0
 8002edc:	400264a0 	.word	0x400264a0
 8002ee0:	40026400 	.word	0x40026400
 8002ee4:	400260b8 	.word	0x400260b8
 8002ee8:	40026058 	.word	0x40026058
 8002eec:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002ef0:	e012      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002ef2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002ef6:	e00f      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002ef8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002efc:	e00c      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002efe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002f02:	e009      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002f04:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002f08:	e006      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002f0a:	2320      	movs	r3, #32
 8002f0c:	e004      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002f0e:	2320      	movs	r3, #32
 8002f10:	e002      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002f12:	2320      	movs	r3, #32
 8002f14:	e000      	b.n	8002f18 <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002f16:	2320      	movs	r3, #32
 8002f18:	4a8c      	ldr	r2, [pc, #560]	@ (800314c <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8002f1a:	60d3      	str	r3, [r2, #12]
 8002f1c:	e05f      	b.n	8002fde <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002f1e:	68fb      	ldr	r3, [r7, #12]
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	4a8b      	ldr	r2, [pc, #556]	@ (8003150 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8002f24:	4293      	cmp	r3, r2
 8002f26:	d057      	beq.n	8002fd8 <HAL_DMAEx_MultiBufferStart_IT+0x40c>
 8002f28:	68fb      	ldr	r3, [r7, #12]
 8002f2a:	681b      	ldr	r3, [r3, #0]
 8002f2c:	4a89      	ldr	r2, [pc, #548]	@ (8003154 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8002f2e:	4293      	cmp	r3, r2
 8002f30:	d050      	beq.n	8002fd4 <HAL_DMAEx_MultiBufferStart_IT+0x408>
 8002f32:	68fb      	ldr	r3, [r7, #12]
 8002f34:	681b      	ldr	r3, [r3, #0]
 8002f36:	4a88      	ldr	r2, [pc, #544]	@ (8003158 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8002f38:	4293      	cmp	r3, r2
 8002f3a:	d049      	beq.n	8002fd0 <HAL_DMAEx_MultiBufferStart_IT+0x404>
 8002f3c:	68fb      	ldr	r3, [r7, #12]
 8002f3e:	681b      	ldr	r3, [r3, #0]
 8002f40:	4a86      	ldr	r2, [pc, #536]	@ (800315c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 8002f42:	4293      	cmp	r3, r2
 8002f44:	d042      	beq.n	8002fcc <HAL_DMAEx_MultiBufferStart_IT+0x400>
 8002f46:	68fb      	ldr	r3, [r7, #12]
 8002f48:	681b      	ldr	r3, [r3, #0]
 8002f4a:	4a85      	ldr	r2, [pc, #532]	@ (8003160 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8002f4c:	4293      	cmp	r3, r2
 8002f4e:	d03a      	beq.n	8002fc6 <HAL_DMAEx_MultiBufferStart_IT+0x3fa>
 8002f50:	68fb      	ldr	r3, [r7, #12]
 8002f52:	681b      	ldr	r3, [r3, #0]
 8002f54:	4a83      	ldr	r2, [pc, #524]	@ (8003164 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8002f56:	4293      	cmp	r3, r2
 8002f58:	d032      	beq.n	8002fc0 <HAL_DMAEx_MultiBufferStart_IT+0x3f4>
 8002f5a:	68fb      	ldr	r3, [r7, #12]
 8002f5c:	681b      	ldr	r3, [r3, #0]
 8002f5e:	4a82      	ldr	r2, [pc, #520]	@ (8003168 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8002f60:	4293      	cmp	r3, r2
 8002f62:	d02a      	beq.n	8002fba <HAL_DMAEx_MultiBufferStart_IT+0x3ee>
 8002f64:	68fb      	ldr	r3, [r7, #12]
 8002f66:	681b      	ldr	r3, [r3, #0]
 8002f68:	4a80      	ldr	r2, [pc, #512]	@ (800316c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8002f6a:	4293      	cmp	r3, r2
 8002f6c:	d022      	beq.n	8002fb4 <HAL_DMAEx_MultiBufferStart_IT+0x3e8>
 8002f6e:	68fb      	ldr	r3, [r7, #12]
 8002f70:	681b      	ldr	r3, [r3, #0]
 8002f72:	4a7f      	ldr	r2, [pc, #508]	@ (8003170 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8002f74:	4293      	cmp	r3, r2
 8002f76:	d01a      	beq.n	8002fae <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
 8002f78:	68fb      	ldr	r3, [r7, #12]
 8002f7a:	681b      	ldr	r3, [r3, #0]
 8002f7c:	4a7d      	ldr	r2, [pc, #500]	@ (8003174 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 8002f7e:	4293      	cmp	r3, r2
 8002f80:	d012      	beq.n	8002fa8 <HAL_DMAEx_MultiBufferStart_IT+0x3dc>
 8002f82:	68fb      	ldr	r3, [r7, #12]
 8002f84:	681b      	ldr	r3, [r3, #0]
 8002f86:	4a7c      	ldr	r2, [pc, #496]	@ (8003178 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8002f88:	4293      	cmp	r3, r2
 8002f8a:	d00a      	beq.n	8002fa2 <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
 8002f8c:	68fb      	ldr	r3, [r7, #12]
 8002f8e:	681b      	ldr	r3, [r3, #0]
 8002f90:	4a7a      	ldr	r2, [pc, #488]	@ (800317c <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 8002f92:	4293      	cmp	r3, r2
 8002f94:	d102      	bne.n	8002f9c <HAL_DMAEx_MultiBufferStart_IT+0x3d0>
 8002f96:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002f9a:	e01e      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002f9c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002fa0:	e01b      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fa2:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002fa6:	e018      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fa8:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002fac:	e015      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fae:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002fb2:	e012      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fb4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002fb8:	e00f      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fba:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002fbe:	e00c      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fc0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002fc4:	e009      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fc6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002fca:	e006      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fcc:	2320      	movs	r3, #32
 8002fce:	e004      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fd0:	2320      	movs	r3, #32
 8002fd2:	e002      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fd4:	2320      	movs	r3, #32
 8002fd6:	e000      	b.n	8002fda <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002fd8:	2320      	movs	r3, #32
 8002fda:	4a5c      	ldr	r2, [pc, #368]	@ (800314c <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8002fdc:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8002fde:	68fb      	ldr	r3, [r7, #12]
 8002fe0:	681b      	ldr	r3, [r3, #0]
 8002fe2:	461a      	mov	r2, r3
 8002fe4:	4b66      	ldr	r3, [pc, #408]	@ (8003180 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 8002fe6:	429a      	cmp	r2, r3
 8002fe8:	d960      	bls.n	80030ac <HAL_DMAEx_MultiBufferStart_IT+0x4e0>
 8002fea:	68fb      	ldr	r3, [r7, #12]
 8002fec:	681b      	ldr	r3, [r3, #0]
 8002fee:	4a58      	ldr	r2, [pc, #352]	@ (8003150 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8002ff0:	4293      	cmp	r3, r2
 8002ff2:	d057      	beq.n	80030a4 <HAL_DMAEx_MultiBufferStart_IT+0x4d8>
 8002ff4:	68fb      	ldr	r3, [r7, #12]
 8002ff6:	681b      	ldr	r3, [r3, #0]
 8002ff8:	4a56      	ldr	r2, [pc, #344]	@ (8003154 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8002ffa:	4293      	cmp	r3, r2
 8002ffc:	d050      	beq.n	80030a0 <HAL_DMAEx_MultiBufferStart_IT+0x4d4>
 8002ffe:	68fb      	ldr	r3, [r7, #12]
 8003000:	681b      	ldr	r3, [r3, #0]
 8003002:	4a55      	ldr	r2, [pc, #340]	@ (8003158 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8003004:	4293      	cmp	r3, r2
 8003006:	d049      	beq.n	800309c <HAL_DMAEx_MultiBufferStart_IT+0x4d0>
 8003008:	68fb      	ldr	r3, [r7, #12]
 800300a:	681b      	ldr	r3, [r3, #0]
 800300c:	4a53      	ldr	r2, [pc, #332]	@ (800315c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 800300e:	4293      	cmp	r3, r2
 8003010:	d042      	beq.n	8003098 <HAL_DMAEx_MultiBufferStart_IT+0x4cc>
 8003012:	68fb      	ldr	r3, [r7, #12]
 8003014:	681b      	ldr	r3, [r3, #0]
 8003016:	4a52      	ldr	r2, [pc, #328]	@ (8003160 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8003018:	4293      	cmp	r3, r2
 800301a:	d03a      	beq.n	8003092 <HAL_DMAEx_MultiBufferStart_IT+0x4c6>
 800301c:	68fb      	ldr	r3, [r7, #12]
 800301e:	681b      	ldr	r3, [r3, #0]
 8003020:	4a50      	ldr	r2, [pc, #320]	@ (8003164 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8003022:	4293      	cmp	r3, r2
 8003024:	d032      	beq.n	800308c <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 8003026:	68fb      	ldr	r3, [r7, #12]
 8003028:	681b      	ldr	r3, [r3, #0]
 800302a:	4a4f      	ldr	r2, [pc, #316]	@ (8003168 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 800302c:	4293      	cmp	r3, r2
 800302e:	d02a      	beq.n	8003086 <HAL_DMAEx_MultiBufferStart_IT+0x4ba>
 8003030:	68fb      	ldr	r3, [r7, #12]
 8003032:	681b      	ldr	r3, [r3, #0]
 8003034:	4a4d      	ldr	r2, [pc, #308]	@ (800316c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8003036:	4293      	cmp	r3, r2
 8003038:	d022      	beq.n	8003080 <HAL_DMAEx_MultiBufferStart_IT+0x4b4>
 800303a:	68fb      	ldr	r3, [r7, #12]
 800303c:	681b      	ldr	r3, [r3, #0]
 800303e:	4a4c      	ldr	r2, [pc, #304]	@ (8003170 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8003040:	4293      	cmp	r3, r2
 8003042:	d01a      	beq.n	800307a <HAL_DMAEx_MultiBufferStart_IT+0x4ae>
 8003044:	68fb      	ldr	r3, [r7, #12]
 8003046:	681b      	ldr	r3, [r3, #0]
 8003048:	4a4a      	ldr	r2, [pc, #296]	@ (8003174 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 800304a:	4293      	cmp	r3, r2
 800304c:	d012      	beq.n	8003074 <HAL_DMAEx_MultiBufferStart_IT+0x4a8>
 800304e:	68fb      	ldr	r3, [r7, #12]
 8003050:	681b      	ldr	r3, [r3, #0]
 8003052:	4a49      	ldr	r2, [pc, #292]	@ (8003178 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8003054:	4293      	cmp	r3, r2
 8003056:	d00a      	beq.n	800306e <HAL_DMAEx_MultiBufferStart_IT+0x4a2>
 8003058:	68fb      	ldr	r3, [r7, #12]
 800305a:	681b      	ldr	r3, [r3, #0]
 800305c:	4a47      	ldr	r2, [pc, #284]	@ (800317c <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 800305e:	4293      	cmp	r3, r2
 8003060:	d102      	bne.n	8003068 <HAL_DMAEx_MultiBufferStart_IT+0x49c>
 8003062:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003066:	e01e      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003068:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800306c:	e01b      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 800306e:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003072:	e018      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003074:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003078:	e015      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 800307a:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800307e:	e012      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003080:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003084:	e00f      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003086:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800308a:	e00c      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 800308c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003090:	e009      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003092:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003096:	e006      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8003098:	2310      	movs	r3, #16
 800309a:	e004      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 800309c:	2310      	movs	r3, #16
 800309e:	e002      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 80030a0:	2310      	movs	r3, #16
 80030a2:	e000      	b.n	80030a6 <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 80030a4:	2310      	movs	r3, #16
 80030a6:	4a37      	ldr	r2, [pc, #220]	@ (8003184 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>)
 80030a8:	60d3      	str	r3, [r2, #12]
 80030aa:	e14f      	b.n	800334c <HAL_DMAEx_MultiBufferStart_IT+0x780>
 80030ac:	68fb      	ldr	r3, [r7, #12]
 80030ae:	681b      	ldr	r3, [r3, #0]
 80030b0:	461a      	mov	r2, r3
 80030b2:	4b35      	ldr	r3, [pc, #212]	@ (8003188 <HAL_DMAEx_MultiBufferStart_IT+0x5bc>)
 80030b4:	429a      	cmp	r2, r3
 80030b6:	f240 8082 	bls.w	80031be <HAL_DMAEx_MultiBufferStart_IT+0x5f2>
 80030ba:	68fb      	ldr	r3, [r7, #12]
 80030bc:	681b      	ldr	r3, [r3, #0]
 80030be:	4a24      	ldr	r2, [pc, #144]	@ (8003150 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 80030c0:	4293      	cmp	r3, r2
 80030c2:	d078      	beq.n	80031b6 <HAL_DMAEx_MultiBufferStart_IT+0x5ea>
 80030c4:	68fb      	ldr	r3, [r7, #12]
 80030c6:	681b      	ldr	r3, [r3, #0]
 80030c8:	4a22      	ldr	r2, [pc, #136]	@ (8003154 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 80030ca:	4293      	cmp	r3, r2
 80030cc:	d071      	beq.n	80031b2 <HAL_DMAEx_MultiBufferStart_IT+0x5e6>
 80030ce:	68fb      	ldr	r3, [r7, #12]
 80030d0:	681b      	ldr	r3, [r3, #0]
 80030d2:	4a21      	ldr	r2, [pc, #132]	@ (8003158 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 80030d4:	4293      	cmp	r3, r2
 80030d6:	d06a      	beq.n	80031ae <HAL_DMAEx_MultiBufferStart_IT+0x5e2>
 80030d8:	68fb      	ldr	r3, [r7, #12]
 80030da:	681b      	ldr	r3, [r3, #0]
 80030dc:	4a1f      	ldr	r2, [pc, #124]	@ (800315c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 80030de:	4293      	cmp	r3, r2
 80030e0:	d063      	beq.n	80031aa <HAL_DMAEx_MultiBufferStart_IT+0x5de>
 80030e2:	68fb      	ldr	r3, [r7, #12]
 80030e4:	681b      	ldr	r3, [r3, #0]
 80030e6:	4a1e      	ldr	r2, [pc, #120]	@ (8003160 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 80030e8:	4293      	cmp	r3, r2
 80030ea:	d05b      	beq.n	80031a4 <HAL_DMAEx_MultiBufferStart_IT+0x5d8>
 80030ec:	68fb      	ldr	r3, [r7, #12]
 80030ee:	681b      	ldr	r3, [r3, #0]
 80030f0:	4a1c      	ldr	r2, [pc, #112]	@ (8003164 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 80030f2:	4293      	cmp	r3, r2
 80030f4:	d053      	beq.n	800319e <HAL_DMAEx_MultiBufferStart_IT+0x5d2>
 80030f6:	68fb      	ldr	r3, [r7, #12]
 80030f8:	681b      	ldr	r3, [r3, #0]
 80030fa:	4a1b      	ldr	r2, [pc, #108]	@ (8003168 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 80030fc:	4293      	cmp	r3, r2
 80030fe:	d04b      	beq.n	8003198 <HAL_DMAEx_MultiBufferStart_IT+0x5cc>
 8003100:	68fb      	ldr	r3, [r7, #12]
 8003102:	681b      	ldr	r3, [r3, #0]
 8003104:	4a19      	ldr	r2, [pc, #100]	@ (800316c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8003106:	4293      	cmp	r3, r2
 8003108:	d043      	beq.n	8003192 <HAL_DMAEx_MultiBufferStart_IT+0x5c6>
 800310a:	68fb      	ldr	r3, [r7, #12]
 800310c:	681b      	ldr	r3, [r3, #0]
 800310e:	4a18      	ldr	r2, [pc, #96]	@ (8003170 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8003110:	4293      	cmp	r3, r2
 8003112:	d03b      	beq.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x5c0>
 8003114:	68fb      	ldr	r3, [r7, #12]
 8003116:	681b      	ldr	r3, [r3, #0]
 8003118:	4a16      	ldr	r2, [pc, #88]	@ (8003174 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 800311a:	4293      	cmp	r3, r2
 800311c:	d012      	beq.n	8003144 <HAL_DMAEx_MultiBufferStart_IT+0x578>
 800311e:	68fb      	ldr	r3, [r7, #12]
 8003120:	681b      	ldr	r3, [r3, #0]
 8003122:	4a15      	ldr	r2, [pc, #84]	@ (8003178 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8003124:	4293      	cmp	r3, r2
 8003126:	d00a      	beq.n	800313e <HAL_DMAEx_MultiBufferStart_IT+0x572>
 8003128:	68fb      	ldr	r3, [r7, #12]
 800312a:	681b      	ldr	r3, [r3, #0]
 800312c:	4a13      	ldr	r2, [pc, #76]	@ (800317c <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 800312e:	4293      	cmp	r3, r2
 8003130:	d102      	bne.n	8003138 <HAL_DMAEx_MultiBufferStart_IT+0x56c>
 8003132:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003136:	e03f      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8003138:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800313c:	e03c      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 800313e:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003142:	e039      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8003144:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003148:	e036      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 800314a:	bf00      	nop
 800314c:	40026000 	.word	0x40026000
 8003150:	40026010 	.word	0x40026010
 8003154:	40026410 	.word	0x40026410
 8003158:	40026070 	.word	0x40026070
 800315c:	40026470 	.word	0x40026470
 8003160:	40026028 	.word	0x40026028
 8003164:	40026428 	.word	0x40026428
 8003168:	40026088 	.word	0x40026088
 800316c:	40026488 	.word	0x40026488
 8003170:	40026040 	.word	0x40026040
 8003174:	40026440 	.word	0x40026440
 8003178:	400260a0 	.word	0x400260a0
 800317c:	400264a0 	.word	0x400264a0
 8003180:	40026458 	.word	0x40026458
 8003184:	40026400 	.word	0x40026400
 8003188:	400260b8 	.word	0x400260b8
 800318c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003190:	e012      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8003192:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003196:	e00f      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8003198:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800319c:	e00c      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 800319e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80031a2:	e009      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 80031a4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80031a8:	e006      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 80031aa:	2310      	movs	r3, #16
 80031ac:	e004      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 80031ae:	2310      	movs	r3, #16
 80031b0:	e002      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 80031b2:	2310      	movs	r3, #16
 80031b4:	e000      	b.n	80031b8 <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 80031b6:	2310      	movs	r3, #16
 80031b8:	4a8c      	ldr	r2, [pc, #560]	@ (80033ec <HAL_DMAEx_MultiBufferStart_IT+0x820>)
 80031ba:	6093      	str	r3, [r2, #8]
 80031bc:	e0c6      	b.n	800334c <HAL_DMAEx_MultiBufferStart_IT+0x780>
 80031be:	68fb      	ldr	r3, [r7, #12]
 80031c0:	681b      	ldr	r3, [r3, #0]
 80031c2:	461a      	mov	r2, r3
 80031c4:	4b8a      	ldr	r3, [pc, #552]	@ (80033f0 <HAL_DMAEx_MultiBufferStart_IT+0x824>)
 80031c6:	429a      	cmp	r2, r3
 80031c8:	d960      	bls.n	800328c <HAL_DMAEx_MultiBufferStart_IT+0x6c0>
 80031ca:	68fb      	ldr	r3, [r7, #12]
 80031cc:	681b      	ldr	r3, [r3, #0]
 80031ce:	4a89      	ldr	r2, [pc, #548]	@ (80033f4 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 80031d0:	4293      	cmp	r3, r2
 80031d2:	d057      	beq.n	8003284 <HAL_DMAEx_MultiBufferStart_IT+0x6b8>
 80031d4:	68fb      	ldr	r3, [r7, #12]
 80031d6:	681b      	ldr	r3, [r3, #0]
 80031d8:	4a87      	ldr	r2, [pc, #540]	@ (80033f8 <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 80031da:	4293      	cmp	r3, r2
 80031dc:	d050      	beq.n	8003280 <HAL_DMAEx_MultiBufferStart_IT+0x6b4>
 80031de:	68fb      	ldr	r3, [r7, #12]
 80031e0:	681b      	ldr	r3, [r3, #0]
 80031e2:	4a86      	ldr	r2, [pc, #536]	@ (80033fc <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 80031e4:	4293      	cmp	r3, r2
 80031e6:	d049      	beq.n	800327c <HAL_DMAEx_MultiBufferStart_IT+0x6b0>
 80031e8:	68fb      	ldr	r3, [r7, #12]
 80031ea:	681b      	ldr	r3, [r3, #0]
 80031ec:	4a84      	ldr	r2, [pc, #528]	@ (8003400 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 80031ee:	4293      	cmp	r3, r2
 80031f0:	d042      	beq.n	8003278 <HAL_DMAEx_MultiBufferStart_IT+0x6ac>
 80031f2:	68fb      	ldr	r3, [r7, #12]
 80031f4:	681b      	ldr	r3, [r3, #0]
 80031f6:	4a83      	ldr	r2, [pc, #524]	@ (8003404 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 80031f8:	4293      	cmp	r3, r2
 80031fa:	d03a      	beq.n	8003272 <HAL_DMAEx_MultiBufferStart_IT+0x6a6>
 80031fc:	68fb      	ldr	r3, [r7, #12]
 80031fe:	681b      	ldr	r3, [r3, #0]
 8003200:	4a81      	ldr	r2, [pc, #516]	@ (8003408 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 8003202:	4293      	cmp	r3, r2
 8003204:	d032      	beq.n	800326c <HAL_DMAEx_MultiBufferStart_IT+0x6a0>
 8003206:	68fb      	ldr	r3, [r7, #12]
 8003208:	681b      	ldr	r3, [r3, #0]
 800320a:	4a80      	ldr	r2, [pc, #512]	@ (800340c <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 800320c:	4293      	cmp	r3, r2
 800320e:	d02a      	beq.n	8003266 <HAL_DMAEx_MultiBufferStart_IT+0x69a>
 8003210:	68fb      	ldr	r3, [r7, #12]
 8003212:	681b      	ldr	r3, [r3, #0]
 8003214:	4a7e      	ldr	r2, [pc, #504]	@ (8003410 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 8003216:	4293      	cmp	r3, r2
 8003218:	d022      	beq.n	8003260 <HAL_DMAEx_MultiBufferStart_IT+0x694>
 800321a:	68fb      	ldr	r3, [r7, #12]
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	4a7d      	ldr	r2, [pc, #500]	@ (8003414 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 8003220:	4293      	cmp	r3, r2
 8003222:	d01a      	beq.n	800325a <HAL_DMAEx_MultiBufferStart_IT+0x68e>
 8003224:	68fb      	ldr	r3, [r7, #12]
 8003226:	681b      	ldr	r3, [r3, #0]
 8003228:	4a7b      	ldr	r2, [pc, #492]	@ (8003418 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 800322a:	4293      	cmp	r3, r2
 800322c:	d012      	beq.n	8003254 <HAL_DMAEx_MultiBufferStart_IT+0x688>
 800322e:	68fb      	ldr	r3, [r7, #12]
 8003230:	681b      	ldr	r3, [r3, #0]
 8003232:	4a7a      	ldr	r2, [pc, #488]	@ (800341c <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 8003234:	4293      	cmp	r3, r2
 8003236:	d00a      	beq.n	800324e <HAL_DMAEx_MultiBufferStart_IT+0x682>
 8003238:	68fb      	ldr	r3, [r7, #12]
 800323a:	681b      	ldr	r3, [r3, #0]
 800323c:	4a78      	ldr	r2, [pc, #480]	@ (8003420 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 800323e:	4293      	cmp	r3, r2
 8003240:	d102      	bne.n	8003248 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
 8003242:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003246:	e01e      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003248:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800324c:	e01b      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800324e:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003252:	e018      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003254:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003258:	e015      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800325a:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800325e:	e012      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003260:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003264:	e00f      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003266:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800326a:	e00c      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800326c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003270:	e009      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003272:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003276:	e006      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003278:	2310      	movs	r3, #16
 800327a:	e004      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800327c:	2310      	movs	r3, #16
 800327e:	e002      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003280:	2310      	movs	r3, #16
 8003282:	e000      	b.n	8003286 <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003284:	2310      	movs	r3, #16
 8003286:	4a67      	ldr	r2, [pc, #412]	@ (8003424 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
 8003288:	60d3      	str	r3, [r2, #12]
 800328a:	e05f      	b.n	800334c <HAL_DMAEx_MultiBufferStart_IT+0x780>
 800328c:	68fb      	ldr	r3, [r7, #12]
 800328e:	681b      	ldr	r3, [r3, #0]
 8003290:	4a58      	ldr	r2, [pc, #352]	@ (80033f4 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 8003292:	4293      	cmp	r3, r2
 8003294:	d057      	beq.n	8003346 <HAL_DMAEx_MultiBufferStart_IT+0x77a>
 8003296:	68fb      	ldr	r3, [r7, #12]
 8003298:	681b      	ldr	r3, [r3, #0]
 800329a:	4a57      	ldr	r2, [pc, #348]	@ (80033f8 <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 800329c:	4293      	cmp	r3, r2
 800329e:	d050      	beq.n	8003342 <HAL_DMAEx_MultiBufferStart_IT+0x776>
 80032a0:	68fb      	ldr	r3, [r7, #12]
 80032a2:	681b      	ldr	r3, [r3, #0]
 80032a4:	4a55      	ldr	r2, [pc, #340]	@ (80033fc <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 80032a6:	4293      	cmp	r3, r2
 80032a8:	d049      	beq.n	800333e <HAL_DMAEx_MultiBufferStart_IT+0x772>
 80032aa:	68fb      	ldr	r3, [r7, #12]
 80032ac:	681b      	ldr	r3, [r3, #0]
 80032ae:	4a54      	ldr	r2, [pc, #336]	@ (8003400 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 80032b0:	4293      	cmp	r3, r2
 80032b2:	d042      	beq.n	800333a <HAL_DMAEx_MultiBufferStart_IT+0x76e>
 80032b4:	68fb      	ldr	r3, [r7, #12]
 80032b6:	681b      	ldr	r3, [r3, #0]
 80032b8:	4a52      	ldr	r2, [pc, #328]	@ (8003404 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 80032ba:	4293      	cmp	r3, r2
 80032bc:	d03a      	beq.n	8003334 <HAL_DMAEx_MultiBufferStart_IT+0x768>
 80032be:	68fb      	ldr	r3, [r7, #12]
 80032c0:	681b      	ldr	r3, [r3, #0]
 80032c2:	4a51      	ldr	r2, [pc, #324]	@ (8003408 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 80032c4:	4293      	cmp	r3, r2
 80032c6:	d032      	beq.n	800332e <HAL_DMAEx_MultiBufferStart_IT+0x762>
 80032c8:	68fb      	ldr	r3, [r7, #12]
 80032ca:	681b      	ldr	r3, [r3, #0]
 80032cc:	4a4f      	ldr	r2, [pc, #316]	@ (800340c <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 80032ce:	4293      	cmp	r3, r2
 80032d0:	d02a      	beq.n	8003328 <HAL_DMAEx_MultiBufferStart_IT+0x75c>
 80032d2:	68fb      	ldr	r3, [r7, #12]
 80032d4:	681b      	ldr	r3, [r3, #0]
 80032d6:	4a4e      	ldr	r2, [pc, #312]	@ (8003410 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 80032d8:	4293      	cmp	r3, r2
 80032da:	d022      	beq.n	8003322 <HAL_DMAEx_MultiBufferStart_IT+0x756>
 80032dc:	68fb      	ldr	r3, [r7, #12]
 80032de:	681b      	ldr	r3, [r3, #0]
 80032e0:	4a4c      	ldr	r2, [pc, #304]	@ (8003414 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 80032e2:	4293      	cmp	r3, r2
 80032e4:	d01a      	beq.n	800331c <HAL_DMAEx_MultiBufferStart_IT+0x750>
 80032e6:	68fb      	ldr	r3, [r7, #12]
 80032e8:	681b      	ldr	r3, [r3, #0]
 80032ea:	4a4b      	ldr	r2, [pc, #300]	@ (8003418 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 80032ec:	4293      	cmp	r3, r2
 80032ee:	d012      	beq.n	8003316 <HAL_DMAEx_MultiBufferStart_IT+0x74a>
 80032f0:	68fb      	ldr	r3, [r7, #12]
 80032f2:	681b      	ldr	r3, [r3, #0]
 80032f4:	4a49      	ldr	r2, [pc, #292]	@ (800341c <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 80032f6:	4293      	cmp	r3, r2
 80032f8:	d00a      	beq.n	8003310 <HAL_DMAEx_MultiBufferStart_IT+0x744>
 80032fa:	68fb      	ldr	r3, [r7, #12]
 80032fc:	681b      	ldr	r3, [r3, #0]
 80032fe:	4a48      	ldr	r2, [pc, #288]	@ (8003420 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 8003300:	4293      	cmp	r3, r2
 8003302:	d102      	bne.n	800330a <HAL_DMAEx_MultiBufferStart_IT+0x73e>
 8003304:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003308:	e01e      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800330a:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800330e:	e01b      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003310:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003314:	e018      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003316:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800331a:	e015      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800331c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003320:	e012      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003322:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003326:	e00f      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003328:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800332c:	e00c      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800332e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003332:	e009      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003334:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003338:	e006      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800333a:	2310      	movs	r3, #16
 800333c:	e004      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800333e:	2310      	movs	r3, #16
 8003340:	e002      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003342:	2310      	movs	r3, #16
 8003344:	e000      	b.n	8003348 <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003346:	2310      	movs	r3, #16
 8003348:	4a36      	ldr	r2, [pc, #216]	@ (8003424 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
 800334a:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800334c:	68fb      	ldr	r3, [r7, #12]
 800334e:	681b      	ldr	r3, [r3, #0]
 8003350:	461a      	mov	r2, r3
 8003352:	4b35      	ldr	r3, [pc, #212]	@ (8003428 <HAL_DMAEx_MultiBufferStart_IT+0x85c>)
 8003354:	429a      	cmp	r2, r3
 8003356:	f240 8082 	bls.w	800345e <HAL_DMAEx_MultiBufferStart_IT+0x892>
 800335a:	68fb      	ldr	r3, [r7, #12]
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	4a25      	ldr	r2, [pc, #148]	@ (80033f4 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 8003360:	4293      	cmp	r3, r2
 8003362:	d078      	beq.n	8003456 <HAL_DMAEx_MultiBufferStart_IT+0x88a>
 8003364:	68fb      	ldr	r3, [r7, #12]
 8003366:	681b      	ldr	r3, [r3, #0]
 8003368:	4a23      	ldr	r2, [pc, #140]	@ (80033f8 <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 800336a:	4293      	cmp	r3, r2
 800336c:	d071      	beq.n	8003452 <HAL_DMAEx_MultiBufferStart_IT+0x886>
 800336e:	68fb      	ldr	r3, [r7, #12]
 8003370:	681b      	ldr	r3, [r3, #0]
 8003372:	4a22      	ldr	r2, [pc, #136]	@ (80033fc <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 8003374:	4293      	cmp	r3, r2
 8003376:	d06a      	beq.n	800344e <HAL_DMAEx_MultiBufferStart_IT+0x882>
 8003378:	68fb      	ldr	r3, [r7, #12]
 800337a:	681b      	ldr	r3, [r3, #0]
 800337c:	4a20      	ldr	r2, [pc, #128]	@ (8003400 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 800337e:	4293      	cmp	r3, r2
 8003380:	d063      	beq.n	800344a <HAL_DMAEx_MultiBufferStart_IT+0x87e>
 8003382:	68fb      	ldr	r3, [r7, #12]
 8003384:	681b      	ldr	r3, [r3, #0]
 8003386:	4a1f      	ldr	r2, [pc, #124]	@ (8003404 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 8003388:	4293      	cmp	r3, r2
 800338a:	d05b      	beq.n	8003444 <HAL_DMAEx_MultiBufferStart_IT+0x878>
 800338c:	68fb      	ldr	r3, [r7, #12]
 800338e:	681b      	ldr	r3, [r3, #0]
 8003390:	4a1d      	ldr	r2, [pc, #116]	@ (8003408 <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 8003392:	4293      	cmp	r3, r2
 8003394:	d053      	beq.n	800343e <HAL_DMAEx_MultiBufferStart_IT+0x872>
 8003396:	68fb      	ldr	r3, [r7, #12]
 8003398:	681b      	ldr	r3, [r3, #0]
 800339a:	4a1c      	ldr	r2, [pc, #112]	@ (800340c <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 800339c:	4293      	cmp	r3, r2
 800339e:	d04b      	beq.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0x86c>
 80033a0:	68fb      	ldr	r3, [r7, #12]
 80033a2:	681b      	ldr	r3, [r3, #0]
 80033a4:	4a1a      	ldr	r2, [pc, #104]	@ (8003410 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 80033a6:	4293      	cmp	r3, r2
 80033a8:	d043      	beq.n	8003432 <HAL_DMAEx_MultiBufferStart_IT+0x866>
 80033aa:	68fb      	ldr	r3, [r7, #12]
 80033ac:	681b      	ldr	r3, [r3, #0]
 80033ae:	4a19      	ldr	r2, [pc, #100]	@ (8003414 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 80033b0:	4293      	cmp	r3, r2
 80033b2:	d03b      	beq.n	800342c <HAL_DMAEx_MultiBufferStart_IT+0x860>
 80033b4:	68fb      	ldr	r3, [r7, #12]
 80033b6:	681b      	ldr	r3, [r3, #0]
 80033b8:	4a17      	ldr	r2, [pc, #92]	@ (8003418 <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 80033ba:	4293      	cmp	r3, r2
 80033bc:	d012      	beq.n	80033e4 <HAL_DMAEx_MultiBufferStart_IT+0x818>
 80033be:	68fb      	ldr	r3, [r7, #12]
 80033c0:	681b      	ldr	r3, [r3, #0]
 80033c2:	4a16      	ldr	r2, [pc, #88]	@ (800341c <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 80033c4:	4293      	cmp	r3, r2
 80033c6:	d00a      	beq.n	80033de <HAL_DMAEx_MultiBufferStart_IT+0x812>
 80033c8:	68fb      	ldr	r3, [r7, #12]
 80033ca:	681b      	ldr	r3, [r3, #0]
 80033cc:	4a14      	ldr	r2, [pc, #80]	@ (8003420 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 80033ce:	4293      	cmp	r3, r2
 80033d0:	d102      	bne.n	80033d8 <HAL_DMAEx_MultiBufferStart_IT+0x80c>
 80033d2:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80033d6:	e03f      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 80033d8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80033dc:	e03c      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 80033de:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80033e2:	e039      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 80033e4:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80033e8:	e036      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 80033ea:	bf00      	nop
 80033ec:	40026400 	.word	0x40026400
 80033f0:	40026058 	.word	0x40026058
 80033f4:	40026010 	.word	0x40026010
 80033f8:	40026410 	.word	0x40026410
 80033fc:	40026070 	.word	0x40026070
 8003400:	40026470 	.word	0x40026470
 8003404:	40026028 	.word	0x40026028
 8003408:	40026428 	.word	0x40026428
 800340c:	40026088 	.word	0x40026088
 8003410:	40026488 	.word	0x40026488
 8003414:	40026040 	.word	0x40026040
 8003418:	40026440 	.word	0x40026440
 800341c:	400260a0 	.word	0x400260a0
 8003420:	400264a0 	.word	0x400264a0
 8003424:	40026000 	.word	0x40026000
 8003428:	40026458 	.word	0x40026458
 800342c:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003430:	e012      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003432:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003436:	e00f      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003438:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800343c:	e00c      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800343e:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003442:	e009      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003444:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003448:	e006      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800344a:	2308      	movs	r3, #8
 800344c:	e004      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800344e:	2308      	movs	r3, #8
 8003450:	e002      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003452:	2308      	movs	r3, #8
 8003454:	e000      	b.n	8003458 <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003456:	2308      	movs	r3, #8
 8003458:	4a8c      	ldr	r2, [pc, #560]	@ (800368c <HAL_DMAEx_MultiBufferStart_IT+0xac0>)
 800345a:	60d3      	str	r3, [r2, #12]
 800345c:	e14e      	b.n	80036fc <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 800345e:	68fb      	ldr	r3, [r7, #12]
 8003460:	681b      	ldr	r3, [r3, #0]
 8003462:	461a      	mov	r2, r3
 8003464:	4b8a      	ldr	r3, [pc, #552]	@ (8003690 <HAL_DMAEx_MultiBufferStart_IT+0xac4>)
 8003466:	429a      	cmp	r2, r3
 8003468:	d960      	bls.n	800352c <HAL_DMAEx_MultiBufferStart_IT+0x960>
 800346a:	68fb      	ldr	r3, [r7, #12]
 800346c:	681b      	ldr	r3, [r3, #0]
 800346e:	4a89      	ldr	r2, [pc, #548]	@ (8003694 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 8003470:	4293      	cmp	r3, r2
 8003472:	d057      	beq.n	8003524 <HAL_DMAEx_MultiBufferStart_IT+0x958>
 8003474:	68fb      	ldr	r3, [r7, #12]
 8003476:	681b      	ldr	r3, [r3, #0]
 8003478:	4a87      	ldr	r2, [pc, #540]	@ (8003698 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 800347a:	4293      	cmp	r3, r2
 800347c:	d050      	beq.n	8003520 <HAL_DMAEx_MultiBufferStart_IT+0x954>
 800347e:	68fb      	ldr	r3, [r7, #12]
 8003480:	681b      	ldr	r3, [r3, #0]
 8003482:	4a86      	ldr	r2, [pc, #536]	@ (800369c <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 8003484:	4293      	cmp	r3, r2
 8003486:	d049      	beq.n	800351c <HAL_DMAEx_MultiBufferStart_IT+0x950>
 8003488:	68fb      	ldr	r3, [r7, #12]
 800348a:	681b      	ldr	r3, [r3, #0]
 800348c:	4a84      	ldr	r2, [pc, #528]	@ (80036a0 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 800348e:	4293      	cmp	r3, r2
 8003490:	d042      	beq.n	8003518 <HAL_DMAEx_MultiBufferStart_IT+0x94c>
 8003492:	68fb      	ldr	r3, [r7, #12]
 8003494:	681b      	ldr	r3, [r3, #0]
 8003496:	4a83      	ldr	r2, [pc, #524]	@ (80036a4 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 8003498:	4293      	cmp	r3, r2
 800349a:	d03a      	beq.n	8003512 <HAL_DMAEx_MultiBufferStart_IT+0x946>
 800349c:	68fb      	ldr	r3, [r7, #12]
 800349e:	681b      	ldr	r3, [r3, #0]
 80034a0:	4a81      	ldr	r2, [pc, #516]	@ (80036a8 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 80034a2:	4293      	cmp	r3, r2
 80034a4:	d032      	beq.n	800350c <HAL_DMAEx_MultiBufferStart_IT+0x940>
 80034a6:	68fb      	ldr	r3, [r7, #12]
 80034a8:	681b      	ldr	r3, [r3, #0]
 80034aa:	4a80      	ldr	r2, [pc, #512]	@ (80036ac <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 80034ac:	4293      	cmp	r3, r2
 80034ae:	d02a      	beq.n	8003506 <HAL_DMAEx_MultiBufferStart_IT+0x93a>
 80034b0:	68fb      	ldr	r3, [r7, #12]
 80034b2:	681b      	ldr	r3, [r3, #0]
 80034b4:	4a7e      	ldr	r2, [pc, #504]	@ (80036b0 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 80034b6:	4293      	cmp	r3, r2
 80034b8:	d022      	beq.n	8003500 <HAL_DMAEx_MultiBufferStart_IT+0x934>
 80034ba:	68fb      	ldr	r3, [r7, #12]
 80034bc:	681b      	ldr	r3, [r3, #0]
 80034be:	4a7d      	ldr	r2, [pc, #500]	@ (80036b4 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 80034c0:	4293      	cmp	r3, r2
 80034c2:	d01a      	beq.n	80034fa <HAL_DMAEx_MultiBufferStart_IT+0x92e>
 80034c4:	68fb      	ldr	r3, [r7, #12]
 80034c6:	681b      	ldr	r3, [r3, #0]
 80034c8:	4a7b      	ldr	r2, [pc, #492]	@ (80036b8 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 80034ca:	4293      	cmp	r3, r2
 80034cc:	d012      	beq.n	80034f4 <HAL_DMAEx_MultiBufferStart_IT+0x928>
 80034ce:	68fb      	ldr	r3, [r7, #12]
 80034d0:	681b      	ldr	r3, [r3, #0]
 80034d2:	4a7a      	ldr	r2, [pc, #488]	@ (80036bc <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 80034d4:	4293      	cmp	r3, r2
 80034d6:	d00a      	beq.n	80034ee <HAL_DMAEx_MultiBufferStart_IT+0x922>
 80034d8:	68fb      	ldr	r3, [r7, #12]
 80034da:	681b      	ldr	r3, [r3, #0]
 80034dc:	4a78      	ldr	r2, [pc, #480]	@ (80036c0 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 80034de:	4293      	cmp	r3, r2
 80034e0:	d102      	bne.n	80034e8 <HAL_DMAEx_MultiBufferStart_IT+0x91c>
 80034e2:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034e6:	e01e      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 80034e8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80034ec:	e01b      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 80034ee:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034f2:	e018      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 80034f4:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034f8:	e015      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 80034fa:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034fe:	e012      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003500:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003504:	e00f      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003506:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800350a:	e00c      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800350c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003510:	e009      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003512:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003516:	e006      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003518:	2308      	movs	r3, #8
 800351a:	e004      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800351c:	2308      	movs	r3, #8
 800351e:	e002      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003520:	2308      	movs	r3, #8
 8003522:	e000      	b.n	8003526 <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003524:	2308      	movs	r3, #8
 8003526:	4a59      	ldr	r2, [pc, #356]	@ (800368c <HAL_DMAEx_MultiBufferStart_IT+0xac0>)
 8003528:	6093      	str	r3, [r2, #8]
 800352a:	e0e7      	b.n	80036fc <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 800352c:	68fb      	ldr	r3, [r7, #12]
 800352e:	681b      	ldr	r3, [r3, #0]
 8003530:	461a      	mov	r2, r3
 8003532:	4b64      	ldr	r3, [pc, #400]	@ (80036c4 <HAL_DMAEx_MultiBufferStart_IT+0xaf8>)
 8003534:	429a      	cmp	r2, r3
 8003536:	d960      	bls.n	80035fa <HAL_DMAEx_MultiBufferStart_IT+0xa2e>
 8003538:	68fb      	ldr	r3, [r7, #12]
 800353a:	681b      	ldr	r3, [r3, #0]
 800353c:	4a55      	ldr	r2, [pc, #340]	@ (8003694 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 800353e:	4293      	cmp	r3, r2
 8003540:	d057      	beq.n	80035f2 <HAL_DMAEx_MultiBufferStart_IT+0xa26>
 8003542:	68fb      	ldr	r3, [r7, #12]
 8003544:	681b      	ldr	r3, [r3, #0]
 8003546:	4a54      	ldr	r2, [pc, #336]	@ (8003698 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 8003548:	4293      	cmp	r3, r2
 800354a:	d050      	beq.n	80035ee <HAL_DMAEx_MultiBufferStart_IT+0xa22>
 800354c:	68fb      	ldr	r3, [r7, #12]
 800354e:	681b      	ldr	r3, [r3, #0]
 8003550:	4a52      	ldr	r2, [pc, #328]	@ (800369c <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 8003552:	4293      	cmp	r3, r2
 8003554:	d049      	beq.n	80035ea <HAL_DMAEx_MultiBufferStart_IT+0xa1e>
 8003556:	68fb      	ldr	r3, [r7, #12]
 8003558:	681b      	ldr	r3, [r3, #0]
 800355a:	4a51      	ldr	r2, [pc, #324]	@ (80036a0 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 800355c:	4293      	cmp	r3, r2
 800355e:	d042      	beq.n	80035e6 <HAL_DMAEx_MultiBufferStart_IT+0xa1a>
 8003560:	68fb      	ldr	r3, [r7, #12]
 8003562:	681b      	ldr	r3, [r3, #0]
 8003564:	4a4f      	ldr	r2, [pc, #316]	@ (80036a4 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 8003566:	4293      	cmp	r3, r2
 8003568:	d03a      	beq.n	80035e0 <HAL_DMAEx_MultiBufferStart_IT+0xa14>
 800356a:	68fb      	ldr	r3, [r7, #12]
 800356c:	681b      	ldr	r3, [r3, #0]
 800356e:	4a4e      	ldr	r2, [pc, #312]	@ (80036a8 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 8003570:	4293      	cmp	r3, r2
 8003572:	d032      	beq.n	80035da <HAL_DMAEx_MultiBufferStart_IT+0xa0e>
 8003574:	68fb      	ldr	r3, [r7, #12]
 8003576:	681b      	ldr	r3, [r3, #0]
 8003578:	4a4c      	ldr	r2, [pc, #304]	@ (80036ac <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 800357a:	4293      	cmp	r3, r2
 800357c:	d02a      	beq.n	80035d4 <HAL_DMAEx_MultiBufferStart_IT+0xa08>
 800357e:	68fb      	ldr	r3, [r7, #12]
 8003580:	681b      	ldr	r3, [r3, #0]
 8003582:	4a4b      	ldr	r2, [pc, #300]	@ (80036b0 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 8003584:	4293      	cmp	r3, r2
 8003586:	d022      	beq.n	80035ce <HAL_DMAEx_MultiBufferStart_IT+0xa02>
 8003588:	68fb      	ldr	r3, [r7, #12]
 800358a:	681b      	ldr	r3, [r3, #0]
 800358c:	4a49      	ldr	r2, [pc, #292]	@ (80036b4 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 800358e:	4293      	cmp	r3, r2
 8003590:	d01a      	beq.n	80035c8 <HAL_DMAEx_MultiBufferStart_IT+0x9fc>
 8003592:	68fb      	ldr	r3, [r7, #12]
 8003594:	681b      	ldr	r3, [r3, #0]
 8003596:	4a48      	ldr	r2, [pc, #288]	@ (80036b8 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 8003598:	4293      	cmp	r3, r2
 800359a:	d012      	beq.n	80035c2 <HAL_DMAEx_MultiBufferStart_IT+0x9f6>
 800359c:	68fb      	ldr	r3, [r7, #12]
 800359e:	681b      	ldr	r3, [r3, #0]
 80035a0:	4a46      	ldr	r2, [pc, #280]	@ (80036bc <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 80035a2:	4293      	cmp	r3, r2
 80035a4:	d00a      	beq.n	80035bc <HAL_DMAEx_MultiBufferStart_IT+0x9f0>
 80035a6:	68fb      	ldr	r3, [r7, #12]
 80035a8:	681b      	ldr	r3, [r3, #0]
 80035aa:	4a45      	ldr	r2, [pc, #276]	@ (80036c0 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 80035ac:	4293      	cmp	r3, r2
 80035ae:	d102      	bne.n	80035b6 <HAL_DMAEx_MultiBufferStart_IT+0x9ea>
 80035b0:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80035b4:	e01e      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035b6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80035ba:	e01b      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035bc:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80035c0:	e018      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035c2:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80035c6:	e015      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035c8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80035cc:	e012      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035ce:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80035d2:	e00f      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035d4:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80035d8:	e00c      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035da:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80035de:	e009      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035e0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80035e4:	e006      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035e6:	2308      	movs	r3, #8
 80035e8:	e004      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035ea:	2308      	movs	r3, #8
 80035ec:	e002      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035ee:	2308      	movs	r3, #8
 80035f0:	e000      	b.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80035f2:	2308      	movs	r3, #8
 80035f4:	4a34      	ldr	r2, [pc, #208]	@ (80036c8 <HAL_DMAEx_MultiBufferStart_IT+0xafc>)
 80035f6:	60d3      	str	r3, [r2, #12]
 80035f8:	e080      	b.n	80036fc <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 80035fa:	68fb      	ldr	r3, [r7, #12]
 80035fc:	681b      	ldr	r3, [r3, #0]
 80035fe:	4a25      	ldr	r2, [pc, #148]	@ (8003694 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 8003600:	4293      	cmp	r3, r2
 8003602:	d078      	beq.n	80036f6 <HAL_DMAEx_MultiBufferStart_IT+0xb2a>
 8003604:	68fb      	ldr	r3, [r7, #12]
 8003606:	681b      	ldr	r3, [r3, #0]
 8003608:	4a23      	ldr	r2, [pc, #140]	@ (8003698 <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 800360a:	4293      	cmp	r3, r2
 800360c:	d071      	beq.n	80036f2 <HAL_DMAEx_MultiBufferStart_IT+0xb26>
 800360e:	68fb      	ldr	r3, [r7, #12]
 8003610:	681b      	ldr	r3, [r3, #0]
 8003612:	4a22      	ldr	r2, [pc, #136]	@ (800369c <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 8003614:	4293      	cmp	r3, r2
 8003616:	d06a      	beq.n	80036ee <HAL_DMAEx_MultiBufferStart_IT+0xb22>
 8003618:	68fb      	ldr	r3, [r7, #12]
 800361a:	681b      	ldr	r3, [r3, #0]
 800361c:	4a20      	ldr	r2, [pc, #128]	@ (80036a0 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 800361e:	4293      	cmp	r3, r2
 8003620:	d063      	beq.n	80036ea <HAL_DMAEx_MultiBufferStart_IT+0xb1e>
 8003622:	68fb      	ldr	r3, [r7, #12]
 8003624:	681b      	ldr	r3, [r3, #0]
 8003626:	4a1f      	ldr	r2, [pc, #124]	@ (80036a4 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 8003628:	4293      	cmp	r3, r2
 800362a:	d05b      	beq.n	80036e4 <HAL_DMAEx_MultiBufferStart_IT+0xb18>
 800362c:	68fb      	ldr	r3, [r7, #12]
 800362e:	681b      	ldr	r3, [r3, #0]
 8003630:	4a1d      	ldr	r2, [pc, #116]	@ (80036a8 <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 8003632:	4293      	cmp	r3, r2
 8003634:	d053      	beq.n	80036de <HAL_DMAEx_MultiBufferStart_IT+0xb12>
 8003636:	68fb      	ldr	r3, [r7, #12]
 8003638:	681b      	ldr	r3, [r3, #0]
 800363a:	4a1c      	ldr	r2, [pc, #112]	@ (80036ac <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 800363c:	4293      	cmp	r3, r2
 800363e:	d04b      	beq.n	80036d8 <HAL_DMAEx_MultiBufferStart_IT+0xb0c>
 8003640:	68fb      	ldr	r3, [r7, #12]
 8003642:	681b      	ldr	r3, [r3, #0]
 8003644:	4a1a      	ldr	r2, [pc, #104]	@ (80036b0 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 8003646:	4293      	cmp	r3, r2
 8003648:	d043      	beq.n	80036d2 <HAL_DMAEx_MultiBufferStart_IT+0xb06>
 800364a:	68fb      	ldr	r3, [r7, #12]
 800364c:	681b      	ldr	r3, [r3, #0]
 800364e:	4a19      	ldr	r2, [pc, #100]	@ (80036b4 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 8003650:	4293      	cmp	r3, r2
 8003652:	d03b      	beq.n	80036cc <HAL_DMAEx_MultiBufferStart_IT+0xb00>
 8003654:	68fb      	ldr	r3, [r7, #12]
 8003656:	681b      	ldr	r3, [r3, #0]
 8003658:	4a17      	ldr	r2, [pc, #92]	@ (80036b8 <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 800365a:	4293      	cmp	r3, r2
 800365c:	d012      	beq.n	8003684 <HAL_DMAEx_MultiBufferStart_IT+0xab8>
 800365e:	68fb      	ldr	r3, [r7, #12]
 8003660:	681b      	ldr	r3, [r3, #0]
 8003662:	4a16      	ldr	r2, [pc, #88]	@ (80036bc <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 8003664:	4293      	cmp	r3, r2
 8003666:	d00a      	beq.n	800367e <HAL_DMAEx_MultiBufferStart_IT+0xab2>
 8003668:	68fb      	ldr	r3, [r7, #12]
 800366a:	681b      	ldr	r3, [r3, #0]
 800366c:	4a14      	ldr	r2, [pc, #80]	@ (80036c0 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 800366e:	4293      	cmp	r3, r2
 8003670:	d102      	bne.n	8003678 <HAL_DMAEx_MultiBufferStart_IT+0xaac>
 8003672:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003676:	e03f      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003678:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 800367c:	e03c      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 800367e:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003682:	e039      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003684:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003688:	e036      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 800368a:	bf00      	nop
 800368c:	40026400 	.word	0x40026400
 8003690:	400260b8 	.word	0x400260b8
 8003694:	40026010 	.word	0x40026010
 8003698:	40026410 	.word	0x40026410
 800369c:	40026070 	.word	0x40026070
 80036a0:	40026470 	.word	0x40026470
 80036a4:	40026028 	.word	0x40026028
 80036a8:	40026428 	.word	0x40026428
 80036ac:	40026088 	.word	0x40026088
 80036b0:	40026488 	.word	0x40026488
 80036b4:	40026040 	.word	0x40026040
 80036b8:	40026440 	.word	0x40026440
 80036bc:	400260a0 	.word	0x400260a0
 80036c0:	400264a0 	.word	0x400264a0
 80036c4:	40026058 	.word	0x40026058
 80036c8:	40026000 	.word	0x40026000
 80036cc:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80036d0:	e012      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036d2:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80036d6:	e00f      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036d8:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80036dc:	e00c      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036de:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80036e2:	e009      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036e4:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80036e8:	e006      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036ea:	2308      	movs	r3, #8
 80036ec:	e004      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036ee:	2308      	movs	r3, #8
 80036f0:	e002      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036f2:	2308      	movs	r3, #8
 80036f4:	e000      	b.n	80036f8 <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80036f6:	2308      	movs	r3, #8
 80036f8:	4a8a      	ldr	r2, [pc, #552]	@ (8003924 <HAL_DMAEx_MultiBufferStart_IT+0xd58>)
 80036fa:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80036fc:	68fb      	ldr	r3, [r7, #12]
 80036fe:	681b      	ldr	r3, [r3, #0]
 8003700:	461a      	mov	r2, r3
 8003702:	4b89      	ldr	r3, [pc, #548]	@ (8003928 <HAL_DMAEx_MultiBufferStart_IT+0xd5c>)
 8003704:	429a      	cmp	r2, r3
 8003706:	d960      	bls.n	80037ca <HAL_DMAEx_MultiBufferStart_IT+0xbfe>
 8003708:	68fb      	ldr	r3, [r7, #12]
 800370a:	681b      	ldr	r3, [r3, #0]
 800370c:	4a87      	ldr	r2, [pc, #540]	@ (800392c <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 800370e:	4293      	cmp	r3, r2
 8003710:	d057      	beq.n	80037c2 <HAL_DMAEx_MultiBufferStart_IT+0xbf6>
 8003712:	68fb      	ldr	r3, [r7, #12]
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	4a86      	ldr	r2, [pc, #536]	@ (8003930 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 8003718:	4293      	cmp	r3, r2
 800371a:	d050      	beq.n	80037be <HAL_DMAEx_MultiBufferStart_IT+0xbf2>
 800371c:	68fb      	ldr	r3, [r7, #12]
 800371e:	681b      	ldr	r3, [r3, #0]
 8003720:	4a84      	ldr	r2, [pc, #528]	@ (8003934 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 8003722:	4293      	cmp	r3, r2
 8003724:	d049      	beq.n	80037ba <HAL_DMAEx_MultiBufferStart_IT+0xbee>
 8003726:	68fb      	ldr	r3, [r7, #12]
 8003728:	681b      	ldr	r3, [r3, #0]
 800372a:	4a83      	ldr	r2, [pc, #524]	@ (8003938 <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 800372c:	4293      	cmp	r3, r2
 800372e:	d042      	beq.n	80037b6 <HAL_DMAEx_MultiBufferStart_IT+0xbea>
 8003730:	68fb      	ldr	r3, [r7, #12]
 8003732:	681b      	ldr	r3, [r3, #0]
 8003734:	4a81      	ldr	r2, [pc, #516]	@ (800393c <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 8003736:	4293      	cmp	r3, r2
 8003738:	d03a      	beq.n	80037b0 <HAL_DMAEx_MultiBufferStart_IT+0xbe4>
 800373a:	68fb      	ldr	r3, [r7, #12]
 800373c:	681b      	ldr	r3, [r3, #0]
 800373e:	4a80      	ldr	r2, [pc, #512]	@ (8003940 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8003740:	4293      	cmp	r3, r2
 8003742:	d032      	beq.n	80037aa <HAL_DMAEx_MultiBufferStart_IT+0xbde>
 8003744:	68fb      	ldr	r3, [r7, #12]
 8003746:	681b      	ldr	r3, [r3, #0]
 8003748:	4a7e      	ldr	r2, [pc, #504]	@ (8003944 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 800374a:	4293      	cmp	r3, r2
 800374c:	d02a      	beq.n	80037a4 <HAL_DMAEx_MultiBufferStart_IT+0xbd8>
 800374e:	68fb      	ldr	r3, [r7, #12]
 8003750:	681b      	ldr	r3, [r3, #0]
 8003752:	4a7d      	ldr	r2, [pc, #500]	@ (8003948 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8003754:	4293      	cmp	r3, r2
 8003756:	d022      	beq.n	800379e <HAL_DMAEx_MultiBufferStart_IT+0xbd2>
 8003758:	68fb      	ldr	r3, [r7, #12]
 800375a:	681b      	ldr	r3, [r3, #0]
 800375c:	4a7b      	ldr	r2, [pc, #492]	@ (800394c <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 800375e:	4293      	cmp	r3, r2
 8003760:	d01a      	beq.n	8003798 <HAL_DMAEx_MultiBufferStart_IT+0xbcc>
 8003762:	68fb      	ldr	r3, [r7, #12]
 8003764:	681b      	ldr	r3, [r3, #0]
 8003766:	4a7a      	ldr	r2, [pc, #488]	@ (8003950 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 8003768:	4293      	cmp	r3, r2
 800376a:	d012      	beq.n	8003792 <HAL_DMAEx_MultiBufferStart_IT+0xbc6>
 800376c:	68fb      	ldr	r3, [r7, #12]
 800376e:	681b      	ldr	r3, [r3, #0]
 8003770:	4a78      	ldr	r2, [pc, #480]	@ (8003954 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8003772:	4293      	cmp	r3, r2
 8003774:	d00a      	beq.n	800378c <HAL_DMAEx_MultiBufferStart_IT+0xbc0>
 8003776:	68fb      	ldr	r3, [r7, #12]
 8003778:	681b      	ldr	r3, [r3, #0]
 800377a:	4a77      	ldr	r2, [pc, #476]	@ (8003958 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 800377c:	4293      	cmp	r3, r2
 800377e:	d102      	bne.n	8003786 <HAL_DMAEx_MultiBufferStart_IT+0xbba>
 8003780:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003784:	e01e      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 8003786:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 800378a:	e01b      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 800378c:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003790:	e018      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 8003792:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003796:	e015      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 8003798:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800379c:	e012      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 800379e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037a2:	e00f      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037a4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037a8:	e00c      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037aa:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037ae:	e009      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037b0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037b4:	e006      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037b6:	2304      	movs	r3, #4
 80037b8:	e004      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037ba:	2304      	movs	r3, #4
 80037bc:	e002      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037be:	2304      	movs	r3, #4
 80037c0:	e000      	b.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80037c2:	2304      	movs	r3, #4
 80037c4:	4a65      	ldr	r2, [pc, #404]	@ (800395c <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
 80037c6:	60d3      	str	r3, [r2, #12]
 80037c8:	e150      	b.n	8003a6c <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 80037ca:	68fb      	ldr	r3, [r7, #12]
 80037cc:	681b      	ldr	r3, [r3, #0]
 80037ce:	461a      	mov	r2, r3
 80037d0:	4b63      	ldr	r3, [pc, #396]	@ (8003960 <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
 80037d2:	429a      	cmp	r2, r3
 80037d4:	d960      	bls.n	8003898 <HAL_DMAEx_MultiBufferStart_IT+0xccc>
 80037d6:	68fb      	ldr	r3, [r7, #12]
 80037d8:	681b      	ldr	r3, [r3, #0]
 80037da:	4a54      	ldr	r2, [pc, #336]	@ (800392c <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 80037dc:	4293      	cmp	r3, r2
 80037de:	d057      	beq.n	8003890 <HAL_DMAEx_MultiBufferStart_IT+0xcc4>
 80037e0:	68fb      	ldr	r3, [r7, #12]
 80037e2:	681b      	ldr	r3, [r3, #0]
 80037e4:	4a52      	ldr	r2, [pc, #328]	@ (8003930 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 80037e6:	4293      	cmp	r3, r2
 80037e8:	d050      	beq.n	800388c <HAL_DMAEx_MultiBufferStart_IT+0xcc0>
 80037ea:	68fb      	ldr	r3, [r7, #12]
 80037ec:	681b      	ldr	r3, [r3, #0]
 80037ee:	4a51      	ldr	r2, [pc, #324]	@ (8003934 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 80037f0:	4293      	cmp	r3, r2
 80037f2:	d049      	beq.n	8003888 <HAL_DMAEx_MultiBufferStart_IT+0xcbc>
 80037f4:	68fb      	ldr	r3, [r7, #12]
 80037f6:	681b      	ldr	r3, [r3, #0]
 80037f8:	4a4f      	ldr	r2, [pc, #316]	@ (8003938 <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 80037fa:	4293      	cmp	r3, r2
 80037fc:	d042      	beq.n	8003884 <HAL_DMAEx_MultiBufferStart_IT+0xcb8>
 80037fe:	68fb      	ldr	r3, [r7, #12]
 8003800:	681b      	ldr	r3, [r3, #0]
 8003802:	4a4e      	ldr	r2, [pc, #312]	@ (800393c <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 8003804:	4293      	cmp	r3, r2
 8003806:	d03a      	beq.n	800387e <HAL_DMAEx_MultiBufferStart_IT+0xcb2>
 8003808:	68fb      	ldr	r3, [r7, #12]
 800380a:	681b      	ldr	r3, [r3, #0]
 800380c:	4a4c      	ldr	r2, [pc, #304]	@ (8003940 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 800380e:	4293      	cmp	r3, r2
 8003810:	d032      	beq.n	8003878 <HAL_DMAEx_MultiBufferStart_IT+0xcac>
 8003812:	68fb      	ldr	r3, [r7, #12]
 8003814:	681b      	ldr	r3, [r3, #0]
 8003816:	4a4b      	ldr	r2, [pc, #300]	@ (8003944 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 8003818:	4293      	cmp	r3, r2
 800381a:	d02a      	beq.n	8003872 <HAL_DMAEx_MultiBufferStart_IT+0xca6>
 800381c:	68fb      	ldr	r3, [r7, #12]
 800381e:	681b      	ldr	r3, [r3, #0]
 8003820:	4a49      	ldr	r2, [pc, #292]	@ (8003948 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8003822:	4293      	cmp	r3, r2
 8003824:	d022      	beq.n	800386c <HAL_DMAEx_MultiBufferStart_IT+0xca0>
 8003826:	68fb      	ldr	r3, [r7, #12]
 8003828:	681b      	ldr	r3, [r3, #0]
 800382a:	4a48      	ldr	r2, [pc, #288]	@ (800394c <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 800382c:	4293      	cmp	r3, r2
 800382e:	d01a      	beq.n	8003866 <HAL_DMAEx_MultiBufferStart_IT+0xc9a>
 8003830:	68fb      	ldr	r3, [r7, #12]
 8003832:	681b      	ldr	r3, [r3, #0]
 8003834:	4a46      	ldr	r2, [pc, #280]	@ (8003950 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 8003836:	4293      	cmp	r3, r2
 8003838:	d012      	beq.n	8003860 <HAL_DMAEx_MultiBufferStart_IT+0xc94>
 800383a:	68fb      	ldr	r3, [r7, #12]
 800383c:	681b      	ldr	r3, [r3, #0]
 800383e:	4a45      	ldr	r2, [pc, #276]	@ (8003954 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8003840:	4293      	cmp	r3, r2
 8003842:	d00a      	beq.n	800385a <HAL_DMAEx_MultiBufferStart_IT+0xc8e>
 8003844:	68fb      	ldr	r3, [r7, #12]
 8003846:	681b      	ldr	r3, [r3, #0]
 8003848:	4a43      	ldr	r2, [pc, #268]	@ (8003958 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 800384a:	4293      	cmp	r3, r2
 800384c:	d102      	bne.n	8003854 <HAL_DMAEx_MultiBufferStart_IT+0xc88>
 800384e:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003852:	e01e      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003854:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8003858:	e01b      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 800385a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800385e:	e018      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003860:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003864:	e015      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003866:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800386a:	e012      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 800386c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003870:	e00f      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003872:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003876:	e00c      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003878:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800387c:	e009      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 800387e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003882:	e006      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003884:	2304      	movs	r3, #4
 8003886:	e004      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003888:	2304      	movs	r3, #4
 800388a:	e002      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 800388c:	2304      	movs	r3, #4
 800388e:	e000      	b.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003890:	2304      	movs	r3, #4
 8003892:	4a32      	ldr	r2, [pc, #200]	@ (800395c <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
 8003894:	6093      	str	r3, [r2, #8]
 8003896:	e0e9      	b.n	8003a6c <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 8003898:	68fb      	ldr	r3, [r7, #12]
 800389a:	681b      	ldr	r3, [r3, #0]
 800389c:	461a      	mov	r2, r3
 800389e:	4b31      	ldr	r3, [pc, #196]	@ (8003964 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
 80038a0:	429a      	cmp	r2, r3
 80038a2:	f240 8083 	bls.w	80039ac <HAL_DMAEx_MultiBufferStart_IT+0xde0>
 80038a6:	68fb      	ldr	r3, [r7, #12]
 80038a8:	681b      	ldr	r3, [r3, #0]
 80038aa:	4a20      	ldr	r2, [pc, #128]	@ (800392c <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 80038ac:	4293      	cmp	r3, r2
 80038ae:	d079      	beq.n	80039a4 <HAL_DMAEx_MultiBufferStart_IT+0xdd8>
 80038b0:	68fb      	ldr	r3, [r7, #12]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	4a1e      	ldr	r2, [pc, #120]	@ (8003930 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 80038b6:	4293      	cmp	r3, r2
 80038b8:	d072      	beq.n	80039a0 <HAL_DMAEx_MultiBufferStart_IT+0xdd4>
 80038ba:	68fb      	ldr	r3, [r7, #12]
 80038bc:	681b      	ldr	r3, [r3, #0]
 80038be:	4a1d      	ldr	r2, [pc, #116]	@ (8003934 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 80038c0:	4293      	cmp	r3, r2
 80038c2:	d06b      	beq.n	800399c <HAL_DMAEx_MultiBufferStart_IT+0xdd0>
 80038c4:	68fb      	ldr	r3, [r7, #12]
 80038c6:	681b      	ldr	r3, [r3, #0]
 80038c8:	4a1b      	ldr	r2, [pc, #108]	@ (8003938 <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 80038ca:	4293      	cmp	r3, r2
 80038cc:	d064      	beq.n	8003998 <HAL_DMAEx_MultiBufferStart_IT+0xdcc>
 80038ce:	68fb      	ldr	r3, [r7, #12]
 80038d0:	681b      	ldr	r3, [r3, #0]
 80038d2:	4a1a      	ldr	r2, [pc, #104]	@ (800393c <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 80038d4:	4293      	cmp	r3, r2
 80038d6:	d05c      	beq.n	8003992 <HAL_DMAEx_MultiBufferStart_IT+0xdc6>
 80038d8:	68fb      	ldr	r3, [r7, #12]
 80038da:	681b      	ldr	r3, [r3, #0]
 80038dc:	4a18      	ldr	r2, [pc, #96]	@ (8003940 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80038de:	4293      	cmp	r3, r2
 80038e0:	d054      	beq.n	800398c <HAL_DMAEx_MultiBufferStart_IT+0xdc0>
 80038e2:	68fb      	ldr	r3, [r7, #12]
 80038e4:	681b      	ldr	r3, [r3, #0]
 80038e6:	4a17      	ldr	r2, [pc, #92]	@ (8003944 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 80038e8:	4293      	cmp	r3, r2
 80038ea:	d04c      	beq.n	8003986 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
 80038ec:	68fb      	ldr	r3, [r7, #12]
 80038ee:	681b      	ldr	r3, [r3, #0]
 80038f0:	4a15      	ldr	r2, [pc, #84]	@ (8003948 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 80038f2:	4293      	cmp	r3, r2
 80038f4:	d044      	beq.n	8003980 <HAL_DMAEx_MultiBufferStart_IT+0xdb4>
 80038f6:	68fb      	ldr	r3, [r7, #12]
 80038f8:	681b      	ldr	r3, [r3, #0]
 80038fa:	4a14      	ldr	r2, [pc, #80]	@ (800394c <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 80038fc:	4293      	cmp	r3, r2
 80038fe:	d03c      	beq.n	800397a <HAL_DMAEx_MultiBufferStart_IT+0xdae>
 8003900:	68fb      	ldr	r3, [r7, #12]
 8003902:	681b      	ldr	r3, [r3, #0]
 8003904:	4a12      	ldr	r2, [pc, #72]	@ (8003950 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 8003906:	4293      	cmp	r3, r2
 8003908:	d034      	beq.n	8003974 <HAL_DMAEx_MultiBufferStart_IT+0xda8>
 800390a:	68fb      	ldr	r3, [r7, #12]
 800390c:	681b      	ldr	r3, [r3, #0]
 800390e:	4a11      	ldr	r2, [pc, #68]	@ (8003954 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8003910:	4293      	cmp	r3, r2
 8003912:	d02c      	beq.n	800396e <HAL_DMAEx_MultiBufferStart_IT+0xda2>
 8003914:	68fb      	ldr	r3, [r7, #12]
 8003916:	681b      	ldr	r3, [r3, #0]
 8003918:	4a0f      	ldr	r2, [pc, #60]	@ (8003958 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 800391a:	4293      	cmp	r3, r2
 800391c:	d124      	bne.n	8003968 <HAL_DMAEx_MultiBufferStart_IT+0xd9c>
 800391e:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003922:	e040      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003924:	40026000 	.word	0x40026000
 8003928:	40026458 	.word	0x40026458
 800392c:	40026010 	.word	0x40026010
 8003930:	40026410 	.word	0x40026410
 8003934:	40026070 	.word	0x40026070
 8003938:	40026470 	.word	0x40026470
 800393c:	40026028 	.word	0x40026028
 8003940:	40026428 	.word	0x40026428
 8003944:	40026088 	.word	0x40026088
 8003948:	40026488 	.word	0x40026488
 800394c:	40026040 	.word	0x40026040
 8003950:	40026440 	.word	0x40026440
 8003954:	400260a0 	.word	0x400260a0
 8003958:	400264a0 	.word	0x400264a0
 800395c:	40026400 	.word	0x40026400
 8003960:	400260b8 	.word	0x400260b8
 8003964:	40026058 	.word	0x40026058
 8003968:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 800396c:	e01b      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 800396e:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003972:	e018      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003974:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003978:	e015      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 800397a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800397e:	e012      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003980:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003984:	e00f      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003986:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800398a:	e00c      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 800398c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003990:	e009      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003992:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003996:	e006      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003998:	2304      	movs	r3, #4
 800399a:	e004      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 800399c:	2304      	movs	r3, #4
 800399e:	e002      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80039a0:	2304      	movs	r3, #4
 80039a2:	e000      	b.n	80039a6 <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80039a4:	2304      	movs	r3, #4
 80039a6:	4a8b      	ldr	r2, [pc, #556]	@ (8003bd4 <HAL_DMAEx_MultiBufferStart_IT+0x1008>)
 80039a8:	60d3      	str	r3, [r2, #12]
 80039aa:	e05f      	b.n	8003a6c <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 80039ac:	68fb      	ldr	r3, [r7, #12]
 80039ae:	681b      	ldr	r3, [r3, #0]
 80039b0:	4a89      	ldr	r2, [pc, #548]	@ (8003bd8 <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 80039b2:	4293      	cmp	r3, r2
 80039b4:	d057      	beq.n	8003a66 <HAL_DMAEx_MultiBufferStart_IT+0xe9a>
 80039b6:	68fb      	ldr	r3, [r7, #12]
 80039b8:	681b      	ldr	r3, [r3, #0]
 80039ba:	4a88      	ldr	r2, [pc, #544]	@ (8003bdc <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 80039bc:	4293      	cmp	r3, r2
 80039be:	d050      	beq.n	8003a62 <HAL_DMAEx_MultiBufferStart_IT+0xe96>
 80039c0:	68fb      	ldr	r3, [r7, #12]
 80039c2:	681b      	ldr	r3, [r3, #0]
 80039c4:	4a86      	ldr	r2, [pc, #536]	@ (8003be0 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 80039c6:	4293      	cmp	r3, r2
 80039c8:	d049      	beq.n	8003a5e <HAL_DMAEx_MultiBufferStart_IT+0xe92>
 80039ca:	68fb      	ldr	r3, [r7, #12]
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	4a85      	ldr	r2, [pc, #532]	@ (8003be4 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 80039d0:	4293      	cmp	r3, r2
 80039d2:	d042      	beq.n	8003a5a <HAL_DMAEx_MultiBufferStart_IT+0xe8e>
 80039d4:	68fb      	ldr	r3, [r7, #12]
 80039d6:	681b      	ldr	r3, [r3, #0]
 80039d8:	4a83      	ldr	r2, [pc, #524]	@ (8003be8 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 80039da:	4293      	cmp	r3, r2
 80039dc:	d03a      	beq.n	8003a54 <HAL_DMAEx_MultiBufferStart_IT+0xe88>
 80039de:	68fb      	ldr	r3, [r7, #12]
 80039e0:	681b      	ldr	r3, [r3, #0]
 80039e2:	4a82      	ldr	r2, [pc, #520]	@ (8003bec <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 80039e4:	4293      	cmp	r3, r2
 80039e6:	d032      	beq.n	8003a4e <HAL_DMAEx_MultiBufferStart_IT+0xe82>
 80039e8:	68fb      	ldr	r3, [r7, #12]
 80039ea:	681b      	ldr	r3, [r3, #0]
 80039ec:	4a80      	ldr	r2, [pc, #512]	@ (8003bf0 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 80039ee:	4293      	cmp	r3, r2
 80039f0:	d02a      	beq.n	8003a48 <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
 80039f2:	68fb      	ldr	r3, [r7, #12]
 80039f4:	681b      	ldr	r3, [r3, #0]
 80039f6:	4a7f      	ldr	r2, [pc, #508]	@ (8003bf4 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 80039f8:	4293      	cmp	r3, r2
 80039fa:	d022      	beq.n	8003a42 <HAL_DMAEx_MultiBufferStart_IT+0xe76>
 80039fc:	68fb      	ldr	r3, [r7, #12]
 80039fe:	681b      	ldr	r3, [r3, #0]
 8003a00:	4a7d      	ldr	r2, [pc, #500]	@ (8003bf8 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 8003a02:	4293      	cmp	r3, r2
 8003a04:	d01a      	beq.n	8003a3c <HAL_DMAEx_MultiBufferStart_IT+0xe70>
 8003a06:	68fb      	ldr	r3, [r7, #12]
 8003a08:	681b      	ldr	r3, [r3, #0]
 8003a0a:	4a7c      	ldr	r2, [pc, #496]	@ (8003bfc <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 8003a0c:	4293      	cmp	r3, r2
 8003a0e:	d012      	beq.n	8003a36 <HAL_DMAEx_MultiBufferStart_IT+0xe6a>
 8003a10:	68fb      	ldr	r3, [r7, #12]
 8003a12:	681b      	ldr	r3, [r3, #0]
 8003a14:	4a7a      	ldr	r2, [pc, #488]	@ (8003c00 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 8003a16:	4293      	cmp	r3, r2
 8003a18:	d00a      	beq.n	8003a30 <HAL_DMAEx_MultiBufferStart_IT+0xe64>
 8003a1a:	68fb      	ldr	r3, [r7, #12]
 8003a1c:	681b      	ldr	r3, [r3, #0]
 8003a1e:	4a79      	ldr	r2, [pc, #484]	@ (8003c04 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 8003a20:	4293      	cmp	r3, r2
 8003a22:	d102      	bne.n	8003a2a <HAL_DMAEx_MultiBufferStart_IT+0xe5e>
 8003a24:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003a28:	e01e      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a2a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8003a2e:	e01b      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a30:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003a34:	e018      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a36:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003a3a:	e015      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a3c:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003a40:	e012      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a42:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003a46:	e00f      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a48:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003a4c:	e00c      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a4e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003a52:	e009      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a54:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003a58:	e006      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a5a:	2304      	movs	r3, #4
 8003a5c:	e004      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a5e:	2304      	movs	r3, #4
 8003a60:	e002      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a62:	2304      	movs	r3, #4
 8003a64:	e000      	b.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003a66:	2304      	movs	r3, #4
 8003a68:	4a5a      	ldr	r2, [pc, #360]	@ (8003bd4 <HAL_DMAEx_MultiBufferStart_IT+0x1008>)
 8003a6a:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8003a6c:	68fb      	ldr	r3, [r7, #12]
 8003a6e:	681b      	ldr	r3, [r3, #0]
 8003a70:	461a      	mov	r2, r3
 8003a72:	4b65      	ldr	r3, [pc, #404]	@ (8003c08 <HAL_DMAEx_MultiBufferStart_IT+0x103c>)
 8003a74:	429a      	cmp	r2, r3
 8003a76:	d95c      	bls.n	8003b32 <HAL_DMAEx_MultiBufferStart_IT+0xf66>
 8003a78:	68fb      	ldr	r3, [r7, #12]
 8003a7a:	681b      	ldr	r3, [r3, #0]
 8003a7c:	4a56      	ldr	r2, [pc, #344]	@ (8003bd8 <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 8003a7e:	4293      	cmp	r3, r2
 8003a80:	d053      	beq.n	8003b2a <HAL_DMAEx_MultiBufferStart_IT+0xf5e>
 8003a82:	68fb      	ldr	r3, [r7, #12]
 8003a84:	681b      	ldr	r3, [r3, #0]
 8003a86:	4a55      	ldr	r2, [pc, #340]	@ (8003bdc <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 8003a88:	4293      	cmp	r3, r2
 8003a8a:	d04c      	beq.n	8003b26 <HAL_DMAEx_MultiBufferStart_IT+0xf5a>
 8003a8c:	68fb      	ldr	r3, [r7, #12]
 8003a8e:	681b      	ldr	r3, [r3, #0]
 8003a90:	4a53      	ldr	r2, [pc, #332]	@ (8003be0 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 8003a92:	4293      	cmp	r3, r2
 8003a94:	d045      	beq.n	8003b22 <HAL_DMAEx_MultiBufferStart_IT+0xf56>
 8003a96:	68fb      	ldr	r3, [r7, #12]
 8003a98:	681b      	ldr	r3, [r3, #0]
 8003a9a:	4a52      	ldr	r2, [pc, #328]	@ (8003be4 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 8003a9c:	4293      	cmp	r3, r2
 8003a9e:	d03e      	beq.n	8003b1e <HAL_DMAEx_MultiBufferStart_IT+0xf52>
 8003aa0:	68fb      	ldr	r3, [r7, #12]
 8003aa2:	681b      	ldr	r3, [r3, #0]
 8003aa4:	4a50      	ldr	r2, [pc, #320]	@ (8003be8 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 8003aa6:	4293      	cmp	r3, r2
 8003aa8:	d037      	beq.n	8003b1a <HAL_DMAEx_MultiBufferStart_IT+0xf4e>
 8003aaa:	68fb      	ldr	r3, [r7, #12]
 8003aac:	681b      	ldr	r3, [r3, #0]
 8003aae:	4a4f      	ldr	r2, [pc, #316]	@ (8003bec <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 8003ab0:	4293      	cmp	r3, r2
 8003ab2:	d030      	beq.n	8003b16 <HAL_DMAEx_MultiBufferStart_IT+0xf4a>
 8003ab4:	68fb      	ldr	r3, [r7, #12]
 8003ab6:	681b      	ldr	r3, [r3, #0]
 8003ab8:	4a4d      	ldr	r2, [pc, #308]	@ (8003bf0 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 8003aba:	4293      	cmp	r3, r2
 8003abc:	d029      	beq.n	8003b12 <HAL_DMAEx_MultiBufferStart_IT+0xf46>
 8003abe:	68fb      	ldr	r3, [r7, #12]
 8003ac0:	681b      	ldr	r3, [r3, #0]
 8003ac2:	4a4c      	ldr	r2, [pc, #304]	@ (8003bf4 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 8003ac4:	4293      	cmp	r3, r2
 8003ac6:	d022      	beq.n	8003b0e <HAL_DMAEx_MultiBufferStart_IT+0xf42>
 8003ac8:	68fb      	ldr	r3, [r7, #12]
 8003aca:	681b      	ldr	r3, [r3, #0]
 8003acc:	4a4a      	ldr	r2, [pc, #296]	@ (8003bf8 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 8003ace:	4293      	cmp	r3, r2
 8003ad0:	d01a      	beq.n	8003b08 <HAL_DMAEx_MultiBufferStart_IT+0xf3c>
 8003ad2:	68fb      	ldr	r3, [r7, #12]
 8003ad4:	681b      	ldr	r3, [r3, #0]
 8003ad6:	4a49      	ldr	r2, [pc, #292]	@ (8003bfc <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 8003ad8:	4293      	cmp	r3, r2
 8003ada:	d012      	beq.n	8003b02 <HAL_DMAEx_MultiBufferStart_IT+0xf36>
 8003adc:	68fb      	ldr	r3, [r7, #12]
 8003ade:	681b      	ldr	r3, [r3, #0]
 8003ae0:	4a47      	ldr	r2, [pc, #284]	@ (8003c00 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 8003ae2:	4293      	cmp	r3, r2
 8003ae4:	d00a      	beq.n	8003afc <HAL_DMAEx_MultiBufferStart_IT+0xf30>
 8003ae6:	68fb      	ldr	r3, [r7, #12]
 8003ae8:	681b      	ldr	r3, [r3, #0]
 8003aea:	4a46      	ldr	r2, [pc, #280]	@ (8003c04 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 8003aec:	4293      	cmp	r3, r2
 8003aee:	d102      	bne.n	8003af6 <HAL_DMAEx_MultiBufferStart_IT+0xf2a>
 8003af0:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003af4:	e01a      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003af6:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003afa:	e017      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003afc:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b00:	e014      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b02:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b06:	e011      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b08:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b0c:	e00e      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b0e:	2340      	movs	r3, #64	@ 0x40
 8003b10:	e00c      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b12:	2340      	movs	r3, #64	@ 0x40
 8003b14:	e00a      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b16:	2340      	movs	r3, #64	@ 0x40
 8003b18:	e008      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b1a:	2340      	movs	r3, #64	@ 0x40
 8003b1c:	e006      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b1e:	2301      	movs	r3, #1
 8003b20:	e004      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b22:	2301      	movs	r3, #1
 8003b24:	e002      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b26:	2301      	movs	r3, #1
 8003b28:	e000      	b.n	8003b2c <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003b2a:	2301      	movs	r3, #1
 8003b2c:	4a37      	ldr	r2, [pc, #220]	@ (8003c0c <HAL_DMAEx_MultiBufferStart_IT+0x1040>)
 8003b2e:	60d3      	str	r3, [r2, #12]
 8003b30:	e141      	b.n	8003db6 <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003b32:	68fb      	ldr	r3, [r7, #12]
 8003b34:	681b      	ldr	r3, [r3, #0]
 8003b36:	461a      	mov	r2, r3
 8003b38:	4b35      	ldr	r3, [pc, #212]	@ (8003c10 <HAL_DMAEx_MultiBufferStart_IT+0x1044>)
 8003b3a:	429a      	cmp	r2, r3
 8003b3c:	d97c      	bls.n	8003c38 <HAL_DMAEx_MultiBufferStart_IT+0x106c>
 8003b3e:	68fb      	ldr	r3, [r7, #12]
 8003b40:	681b      	ldr	r3, [r3, #0]
 8003b42:	4a25      	ldr	r2, [pc, #148]	@ (8003bd8 <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 8003b44:	4293      	cmp	r3, r2
 8003b46:	d073      	beq.n	8003c30 <HAL_DMAEx_MultiBufferStart_IT+0x1064>
 8003b48:	68fb      	ldr	r3, [r7, #12]
 8003b4a:	681b      	ldr	r3, [r3, #0]
 8003b4c:	4a23      	ldr	r2, [pc, #140]	@ (8003bdc <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 8003b4e:	4293      	cmp	r3, r2
 8003b50:	d06c      	beq.n	8003c2c <HAL_DMAEx_MultiBufferStart_IT+0x1060>
 8003b52:	68fb      	ldr	r3, [r7, #12]
 8003b54:	681b      	ldr	r3, [r3, #0]
 8003b56:	4a22      	ldr	r2, [pc, #136]	@ (8003be0 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 8003b58:	4293      	cmp	r3, r2
 8003b5a:	d065      	beq.n	8003c28 <HAL_DMAEx_MultiBufferStart_IT+0x105c>
 8003b5c:	68fb      	ldr	r3, [r7, #12]
 8003b5e:	681b      	ldr	r3, [r3, #0]
 8003b60:	4a20      	ldr	r2, [pc, #128]	@ (8003be4 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 8003b62:	4293      	cmp	r3, r2
 8003b64:	d05e      	beq.n	8003c24 <HAL_DMAEx_MultiBufferStart_IT+0x1058>
 8003b66:	68fb      	ldr	r3, [r7, #12]
 8003b68:	681b      	ldr	r3, [r3, #0]
 8003b6a:	4a1f      	ldr	r2, [pc, #124]	@ (8003be8 <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 8003b6c:	4293      	cmp	r3, r2
 8003b6e:	d057      	beq.n	8003c20 <HAL_DMAEx_MultiBufferStart_IT+0x1054>
 8003b70:	68fb      	ldr	r3, [r7, #12]
 8003b72:	681b      	ldr	r3, [r3, #0]
 8003b74:	4a1d      	ldr	r2, [pc, #116]	@ (8003bec <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 8003b76:	4293      	cmp	r3, r2
 8003b78:	d050      	beq.n	8003c1c <HAL_DMAEx_MultiBufferStart_IT+0x1050>
 8003b7a:	68fb      	ldr	r3, [r7, #12]
 8003b7c:	681b      	ldr	r3, [r3, #0]
 8003b7e:	4a1c      	ldr	r2, [pc, #112]	@ (8003bf0 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 8003b80:	4293      	cmp	r3, r2
 8003b82:	d049      	beq.n	8003c18 <HAL_DMAEx_MultiBufferStart_IT+0x104c>
 8003b84:	68fb      	ldr	r3, [r7, #12]
 8003b86:	681b      	ldr	r3, [r3, #0]
 8003b88:	4a1a      	ldr	r2, [pc, #104]	@ (8003bf4 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 8003b8a:	4293      	cmp	r3, r2
 8003b8c:	d042      	beq.n	8003c14 <HAL_DMAEx_MultiBufferStart_IT+0x1048>
 8003b8e:	68fb      	ldr	r3, [r7, #12]
 8003b90:	681b      	ldr	r3, [r3, #0]
 8003b92:	4a19      	ldr	r2, [pc, #100]	@ (8003bf8 <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 8003b94:	4293      	cmp	r3, r2
 8003b96:	d01a      	beq.n	8003bce <HAL_DMAEx_MultiBufferStart_IT+0x1002>
 8003b98:	68fb      	ldr	r3, [r7, #12]
 8003b9a:	681b      	ldr	r3, [r3, #0]
 8003b9c:	4a17      	ldr	r2, [pc, #92]	@ (8003bfc <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 8003b9e:	4293      	cmp	r3, r2
 8003ba0:	d012      	beq.n	8003bc8 <HAL_DMAEx_MultiBufferStart_IT+0xffc>
 8003ba2:	68fb      	ldr	r3, [r7, #12]
 8003ba4:	681b      	ldr	r3, [r3, #0]
 8003ba6:	4a16      	ldr	r2, [pc, #88]	@ (8003c00 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 8003ba8:	4293      	cmp	r3, r2
 8003baa:	d00a      	beq.n	8003bc2 <HAL_DMAEx_MultiBufferStart_IT+0xff6>
 8003bac:	68fb      	ldr	r3, [r7, #12]
 8003bae:	681b      	ldr	r3, [r3, #0]
 8003bb0:	4a14      	ldr	r2, [pc, #80]	@ (8003c04 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 8003bb2:	4293      	cmp	r3, r2
 8003bb4:	d102      	bne.n	8003bbc <HAL_DMAEx_MultiBufferStart_IT+0xff0>
 8003bb6:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bba:	e03a      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003bbc:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003bc0:	e037      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003bc2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bc6:	e034      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003bc8:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bcc:	e031      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003bce:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bd2:	e02e      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003bd4:	40026000 	.word	0x40026000
 8003bd8:	40026010 	.word	0x40026010
 8003bdc:	40026410 	.word	0x40026410
 8003be0:	40026070 	.word	0x40026070
 8003be4:	40026470 	.word	0x40026470
 8003be8:	40026028 	.word	0x40026028
 8003bec:	40026428 	.word	0x40026428
 8003bf0:	40026088 	.word	0x40026088
 8003bf4:	40026488 	.word	0x40026488
 8003bf8:	40026040 	.word	0x40026040
 8003bfc:	40026440 	.word	0x40026440
 8003c00:	400260a0 	.word	0x400260a0
 8003c04:	400264a0 	.word	0x400264a0
 8003c08:	40026458 	.word	0x40026458
 8003c0c:	40026400 	.word	0x40026400
 8003c10:	400260b8 	.word	0x400260b8
 8003c14:	2340      	movs	r3, #64	@ 0x40
 8003c16:	e00c      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c18:	2340      	movs	r3, #64	@ 0x40
 8003c1a:	e00a      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c1c:	2340      	movs	r3, #64	@ 0x40
 8003c1e:	e008      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c20:	2340      	movs	r3, #64	@ 0x40
 8003c22:	e006      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c24:	2301      	movs	r3, #1
 8003c26:	e004      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c28:	2301      	movs	r3, #1
 8003c2a:	e002      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c2c:	2301      	movs	r3, #1
 8003c2e:	e000      	b.n	8003c32 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003c30:	2301      	movs	r3, #1
 8003c32:	4a7b      	ldr	r2, [pc, #492]	@ (8003e20 <HAL_DMAEx_MultiBufferStart_IT+0x1254>)
 8003c34:	6093      	str	r3, [r2, #8]
 8003c36:	e0be      	b.n	8003db6 <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003c38:	68fb      	ldr	r3, [r7, #12]
 8003c3a:	681b      	ldr	r3, [r3, #0]
 8003c3c:	461a      	mov	r2, r3
 8003c3e:	4b79      	ldr	r3, [pc, #484]	@ (8003e24 <HAL_DMAEx_MultiBufferStart_IT+0x1258>)
 8003c40:	429a      	cmp	r2, r3
 8003c42:	d95c      	bls.n	8003cfe <HAL_DMAEx_MultiBufferStart_IT+0x1132>
 8003c44:	68fb      	ldr	r3, [r7, #12]
 8003c46:	681b      	ldr	r3, [r3, #0]
 8003c48:	4a77      	ldr	r2, [pc, #476]	@ (8003e28 <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
 8003c4a:	4293      	cmp	r3, r2
 8003c4c:	d053      	beq.n	8003cf6 <HAL_DMAEx_MultiBufferStart_IT+0x112a>
 8003c4e:	68fb      	ldr	r3, [r7, #12]
 8003c50:	681b      	ldr	r3, [r3, #0]
 8003c52:	4a76      	ldr	r2, [pc, #472]	@ (8003e2c <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
 8003c54:	4293      	cmp	r3, r2
 8003c56:	d04c      	beq.n	8003cf2 <HAL_DMAEx_MultiBufferStart_IT+0x1126>
 8003c58:	68fb      	ldr	r3, [r7, #12]
 8003c5a:	681b      	ldr	r3, [r3, #0]
 8003c5c:	4a74      	ldr	r2, [pc, #464]	@ (8003e30 <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
 8003c5e:	4293      	cmp	r3, r2
 8003c60:	d045      	beq.n	8003cee <HAL_DMAEx_MultiBufferStart_IT+0x1122>
 8003c62:	68fb      	ldr	r3, [r7, #12]
 8003c64:	681b      	ldr	r3, [r3, #0]
 8003c66:	4a73      	ldr	r2, [pc, #460]	@ (8003e34 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
 8003c68:	4293      	cmp	r3, r2
 8003c6a:	d03e      	beq.n	8003cea <HAL_DMAEx_MultiBufferStart_IT+0x111e>
 8003c6c:	68fb      	ldr	r3, [r7, #12]
 8003c6e:	681b      	ldr	r3, [r3, #0]
 8003c70:	4a71      	ldr	r2, [pc, #452]	@ (8003e38 <HAL_DMAEx_MultiBufferStart_IT+0x126c>)
 8003c72:	4293      	cmp	r3, r2
 8003c74:	d037      	beq.n	8003ce6 <HAL_DMAEx_MultiBufferStart_IT+0x111a>
 8003c76:	68fb      	ldr	r3, [r7, #12]
 8003c78:	681b      	ldr	r3, [r3, #0]
 8003c7a:	4a70      	ldr	r2, [pc, #448]	@ (8003e3c <HAL_DMAEx_MultiBufferStart_IT+0x1270>)
 8003c7c:	4293      	cmp	r3, r2
 8003c7e:	d030      	beq.n	8003ce2 <HAL_DMAEx_MultiBufferStart_IT+0x1116>
 8003c80:	68fb      	ldr	r3, [r7, #12]
 8003c82:	681b      	ldr	r3, [r3, #0]
 8003c84:	4a6e      	ldr	r2, [pc, #440]	@ (8003e40 <HAL_DMAEx_MultiBufferStart_IT+0x1274>)
 8003c86:	4293      	cmp	r3, r2
 8003c88:	d029      	beq.n	8003cde <HAL_DMAEx_MultiBufferStart_IT+0x1112>
 8003c8a:	68fb      	ldr	r3, [r7, #12]
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	4a6d      	ldr	r2, [pc, #436]	@ (8003e44 <HAL_DMAEx_MultiBufferStart_IT+0x1278>)
 8003c90:	4293      	cmp	r3, r2
 8003c92:	d022      	beq.n	8003cda <HAL_DMAEx_MultiBufferStart_IT+0x110e>
 8003c94:	68fb      	ldr	r3, [r7, #12]
 8003c96:	681b      	ldr	r3, [r3, #0]
 8003c98:	4a6b      	ldr	r2, [pc, #428]	@ (8003e48 <HAL_DMAEx_MultiBufferStart_IT+0x127c>)
 8003c9a:	4293      	cmp	r3, r2
 8003c9c:	d01a      	beq.n	8003cd4 <HAL_DMAEx_MultiBufferStart_IT+0x1108>
 8003c9e:	68fb      	ldr	r3, [r7, #12]
 8003ca0:	681b      	ldr	r3, [r3, #0]
 8003ca2:	4a6a      	ldr	r2, [pc, #424]	@ (8003e4c <HAL_DMAEx_MultiBufferStart_IT+0x1280>)
 8003ca4:	4293      	cmp	r3, r2
 8003ca6:	d012      	beq.n	8003cce <HAL_DMAEx_MultiBufferStart_IT+0x1102>
 8003ca8:	68fb      	ldr	r3, [r7, #12]
 8003caa:	681b      	ldr	r3, [r3, #0]
 8003cac:	4a68      	ldr	r2, [pc, #416]	@ (8003e50 <HAL_DMAEx_MultiBufferStart_IT+0x1284>)
 8003cae:	4293      	cmp	r3, r2
 8003cb0:	d00a      	beq.n	8003cc8 <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 8003cb2:	68fb      	ldr	r3, [r7, #12]
 8003cb4:	681b      	ldr	r3, [r3, #0]
 8003cb6:	4a67      	ldr	r2, [pc, #412]	@ (8003e54 <HAL_DMAEx_MultiBufferStart_IT+0x1288>)
 8003cb8:	4293      	cmp	r3, r2
 8003cba:	d102      	bne.n	8003cc2 <HAL_DMAEx_MultiBufferStart_IT+0x10f6>
 8003cbc:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003cc0:	e01a      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cc2:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003cc6:	e017      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cc8:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003ccc:	e014      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cce:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003cd2:	e011      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cd4:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003cd8:	e00e      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cda:	2340      	movs	r3, #64	@ 0x40
 8003cdc:	e00c      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cde:	2340      	movs	r3, #64	@ 0x40
 8003ce0:	e00a      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003ce2:	2340      	movs	r3, #64	@ 0x40
 8003ce4:	e008      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003ce6:	2340      	movs	r3, #64	@ 0x40
 8003ce8:	e006      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cea:	2301      	movs	r3, #1
 8003cec:	e004      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cee:	2301      	movs	r3, #1
 8003cf0:	e002      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cf2:	2301      	movs	r3, #1
 8003cf4:	e000      	b.n	8003cf8 <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003cf6:	2301      	movs	r3, #1
 8003cf8:	4a57      	ldr	r2, [pc, #348]	@ (8003e58 <HAL_DMAEx_MultiBufferStart_IT+0x128c>)
 8003cfa:	60d3      	str	r3, [r2, #12]
 8003cfc:	e05b      	b.n	8003db6 <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003cfe:	68fb      	ldr	r3, [r7, #12]
 8003d00:	681b      	ldr	r3, [r3, #0]
 8003d02:	4a49      	ldr	r2, [pc, #292]	@ (8003e28 <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
 8003d04:	4293      	cmp	r3, r2
 8003d06:	d053      	beq.n	8003db0 <HAL_DMAEx_MultiBufferStart_IT+0x11e4>
 8003d08:	68fb      	ldr	r3, [r7, #12]
 8003d0a:	681b      	ldr	r3, [r3, #0]
 8003d0c:	4a47      	ldr	r2, [pc, #284]	@ (8003e2c <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
 8003d0e:	4293      	cmp	r3, r2
 8003d10:	d04c      	beq.n	8003dac <HAL_DMAEx_MultiBufferStart_IT+0x11e0>
 8003d12:	68fb      	ldr	r3, [r7, #12]
 8003d14:	681b      	ldr	r3, [r3, #0]
 8003d16:	4a46      	ldr	r2, [pc, #280]	@ (8003e30 <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
 8003d18:	4293      	cmp	r3, r2
 8003d1a:	d045      	beq.n	8003da8 <HAL_DMAEx_MultiBufferStart_IT+0x11dc>
 8003d1c:	68fb      	ldr	r3, [r7, #12]
 8003d1e:	681b      	ldr	r3, [r3, #0]
 8003d20:	4a44      	ldr	r2, [pc, #272]	@ (8003e34 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
 8003d22:	4293      	cmp	r3, r2
 8003d24:	d03e      	beq.n	8003da4 <HAL_DMAEx_MultiBufferStart_IT+0x11d8>
 8003d26:	68fb      	ldr	r3, [r7, #12]
 8003d28:	681b      	ldr	r3, [r3, #0]
 8003d2a:	4a43      	ldr	r2, [pc, #268]	@ (8003e38 <HAL_DMAEx_MultiBufferStart_IT+0x126c>)
 8003d2c:	4293      	cmp	r3, r2
 8003d2e:	d037      	beq.n	8003da0 <HAL_DMAEx_MultiBufferStart_IT+0x11d4>
 8003d30:	68fb      	ldr	r3, [r7, #12]
 8003d32:	681b      	ldr	r3, [r3, #0]
 8003d34:	4a41      	ldr	r2, [pc, #260]	@ (8003e3c <HAL_DMAEx_MultiBufferStart_IT+0x1270>)
 8003d36:	4293      	cmp	r3, r2
 8003d38:	d030      	beq.n	8003d9c <HAL_DMAEx_MultiBufferStart_IT+0x11d0>
 8003d3a:	68fb      	ldr	r3, [r7, #12]
 8003d3c:	681b      	ldr	r3, [r3, #0]
 8003d3e:	4a40      	ldr	r2, [pc, #256]	@ (8003e40 <HAL_DMAEx_MultiBufferStart_IT+0x1274>)
 8003d40:	4293      	cmp	r3, r2
 8003d42:	d029      	beq.n	8003d98 <HAL_DMAEx_MultiBufferStart_IT+0x11cc>
 8003d44:	68fb      	ldr	r3, [r7, #12]
 8003d46:	681b      	ldr	r3, [r3, #0]
 8003d48:	4a3e      	ldr	r2, [pc, #248]	@ (8003e44 <HAL_DMAEx_MultiBufferStart_IT+0x1278>)
 8003d4a:	4293      	cmp	r3, r2
 8003d4c:	d022      	beq.n	8003d94 <HAL_DMAEx_MultiBufferStart_IT+0x11c8>
 8003d4e:	68fb      	ldr	r3, [r7, #12]
 8003d50:	681b      	ldr	r3, [r3, #0]
 8003d52:	4a3d      	ldr	r2, [pc, #244]	@ (8003e48 <HAL_DMAEx_MultiBufferStart_IT+0x127c>)
 8003d54:	4293      	cmp	r3, r2
 8003d56:	d01a      	beq.n	8003d8e <HAL_DMAEx_MultiBufferStart_IT+0x11c2>
 8003d58:	68fb      	ldr	r3, [r7, #12]
 8003d5a:	681b      	ldr	r3, [r3, #0]
 8003d5c:	4a3b      	ldr	r2, [pc, #236]	@ (8003e4c <HAL_DMAEx_MultiBufferStart_IT+0x1280>)
 8003d5e:	4293      	cmp	r3, r2
 8003d60:	d012      	beq.n	8003d88 <HAL_DMAEx_MultiBufferStart_IT+0x11bc>
 8003d62:	68fb      	ldr	r3, [r7, #12]
 8003d64:	681b      	ldr	r3, [r3, #0]
 8003d66:	4a3a      	ldr	r2, [pc, #232]	@ (8003e50 <HAL_DMAEx_MultiBufferStart_IT+0x1284>)
 8003d68:	4293      	cmp	r3, r2
 8003d6a:	d00a      	beq.n	8003d82 <HAL_DMAEx_MultiBufferStart_IT+0x11b6>
 8003d6c:	68fb      	ldr	r3, [r7, #12]
 8003d6e:	681b      	ldr	r3, [r3, #0]
 8003d70:	4a38      	ldr	r2, [pc, #224]	@ (8003e54 <HAL_DMAEx_MultiBufferStart_IT+0x1288>)
 8003d72:	4293      	cmp	r3, r2
 8003d74:	d102      	bne.n	8003d7c <HAL_DMAEx_MultiBufferStart_IT+0x11b0>
 8003d76:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003d7a:	e01a      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d7c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003d80:	e017      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d82:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003d86:	e014      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d88:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003d8c:	e011      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d8e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003d92:	e00e      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d94:	2340      	movs	r3, #64	@ 0x40
 8003d96:	e00c      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d98:	2340      	movs	r3, #64	@ 0x40
 8003d9a:	e00a      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003d9c:	2340      	movs	r3, #64	@ 0x40
 8003d9e:	e008      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003da0:	2340      	movs	r3, #64	@ 0x40
 8003da2:	e006      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003da4:	2301      	movs	r3, #1
 8003da6:	e004      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003da8:	2301      	movs	r3, #1
 8003daa:	e002      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003dac:	2301      	movs	r3, #1
 8003dae:	e000      	b.n	8003db2 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003db0:	2301      	movs	r3, #1
 8003db2:	4a29      	ldr	r2, [pc, #164]	@ (8003e58 <HAL_DMAEx_MultiBufferStart_IT+0x128c>)
 8003db4:	6093      	str	r3, [r2, #8]

    /* Enable Common interrupts*/
    hdma->Instance->CR.reg  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8003db6:	68fb      	ldr	r3, [r7, #12]
 8003db8:	681b      	ldr	r3, [r3, #0]
 8003dba:	681a      	ldr	r2, [r3, #0]
 8003dbc:	68fb      	ldr	r3, [r7, #12]
 8003dbe:	681b      	ldr	r3, [r3, #0]
 8003dc0:	f042 0216 	orr.w	r2, r2, #22
 8003dc4:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR.reg |= DMA_IT_FE;
 8003dc6:	68fb      	ldr	r3, [r7, #12]
 8003dc8:	681b      	ldr	r3, [r3, #0]
 8003dca:	695a      	ldr	r2, [r3, #20]
 8003dcc:	68fb      	ldr	r3, [r7, #12]
 8003dce:	681b      	ldr	r3, [r3, #0]
 8003dd0:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8003dd4:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8003dd6:	68fb      	ldr	r3, [r7, #12]
 8003dd8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8003dda:	2b00      	cmp	r3, #0
 8003ddc:	d103      	bne.n	8003de6 <HAL_DMAEx_MultiBufferStart_IT+0x121a>
 8003dde:	68fb      	ldr	r3, [r7, #12]
 8003de0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003de2:	2b00      	cmp	r3, #0
 8003de4:	d007      	beq.n	8003df6 <HAL_DMAEx_MultiBufferStart_IT+0x122a>
    {
      hdma->Instance->CR.reg  |= DMA_IT_HT;
 8003de6:	68fb      	ldr	r3, [r7, #12]
 8003de8:	681b      	ldr	r3, [r3, #0]
 8003dea:	681a      	ldr	r2, [r3, #0]
 8003dec:	68fb      	ldr	r3, [r7, #12]
 8003dee:	681b      	ldr	r3, [r3, #0]
 8003df0:	f042 0208 	orr.w	r2, r2, #8
 8003df4:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma); 
 8003df6:	68fb      	ldr	r3, [r7, #12]
 8003df8:	681b      	ldr	r3, [r3, #0]
 8003dfa:	681a      	ldr	r2, [r3, #0]
 8003dfc:	68fb      	ldr	r3, [r7, #12]
 8003dfe:	681b      	ldr	r3, [r3, #0]
 8003e00:	f042 0201 	orr.w	r2, r2, #1
 8003e04:	601a      	str	r2, [r3, #0]
 8003e06:	e005      	b.n	8003e14 <HAL_DMAEx_MultiBufferStart_IT+0x1248>
  }
  else
  {     
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8003e08:	68fb      	ldr	r3, [r7, #12]
 8003e0a:	2200      	movs	r2, #0
 8003e0c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 8003e10:	2302      	movs	r3, #2
 8003e12:	75fb      	strb	r3, [r7, #23]
  }  
  return status; 
 8003e14:	7dfb      	ldrb	r3, [r7, #23]
}
 8003e16:	4618      	mov	r0, r3
 8003e18:	3718      	adds	r7, #24
 8003e1a:	46bd      	mov	sp, r7
 8003e1c:	bd80      	pop	{r7, pc}
 8003e1e:	bf00      	nop
 8003e20:	40026400 	.word	0x40026400
 8003e24:	40026058 	.word	0x40026058
 8003e28:	40026010 	.word	0x40026010
 8003e2c:	40026410 	.word	0x40026410
 8003e30:	40026070 	.word	0x40026070
 8003e34:	40026470 	.word	0x40026470
 8003e38:	40026028 	.word	0x40026028
 8003e3c:	40026428 	.word	0x40026428
 8003e40:	40026088 	.word	0x40026088
 8003e44:	40026488 	.word	0x40026488
 8003e48:	40026040 	.word	0x40026040
 8003e4c:	40026440 	.word	0x40026440
 8003e50:	400260a0 	.word	0x400260a0
 8003e54:	400264a0 	.word	0x400264a0
 8003e58:	40026000 	.word	0x40026000

08003e5c <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current 
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
 8003e5c:	b480      	push	{r7}
 8003e5e:	b085      	sub	sp, #20
 8003e60:	af00      	add	r7, sp, #0
 8003e62:	60f8      	str	r0, [r7, #12]
 8003e64:	60b9      	str	r1, [r7, #8]
 8003e66:	4613      	mov	r3, r2
 8003e68:	71fb      	strb	r3, [r7, #7]
  if(memory == MEMORY0)
 8003e6a:	79fb      	ldrb	r3, [r7, #7]
 8003e6c:	2b00      	cmp	r3, #0
 8003e6e:	d104      	bne.n	8003e7a <HAL_DMAEx_ChangeMemory+0x1e>
  {
    /* change the memory0 address */
    hdma->Instance->M0AR = Address;
 8003e70:	68fb      	ldr	r3, [r7, #12]
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	68ba      	ldr	r2, [r7, #8]
 8003e76:	60da      	str	r2, [r3, #12]
 8003e78:	e003      	b.n	8003e82 <HAL_DMAEx_ChangeMemory+0x26>
  }
  else
  {
    /* change the memory1 address */
    hdma->Instance->M1AR = Address;
 8003e7a:	68fb      	ldr	r3, [r7, #12]
 8003e7c:	681b      	ldr	r3, [r3, #0]
 8003e7e:	68ba      	ldr	r2, [r7, #8]
 8003e80:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
 8003e82:	2300      	movs	r3, #0
}
 8003e84:	4618      	mov	r0, r3
 8003e86:	3714      	adds	r7, #20
 8003e88:	46bd      	mov	sp, r7
 8003e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e8e:	4770      	bx	lr

08003e90 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{  
 8003e90:	b480      	push	{r7}
 8003e92:	b085      	sub	sp, #20
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	60f8      	str	r0, [r7, #12]
 8003e98:	60b9      	str	r1, [r7, #8]
 8003e9a:	607a      	str	r2, [r7, #4]
 8003e9c:	603b      	str	r3, [r7, #0]
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR.reg = DataLength;
 8003e9e:	68fb      	ldr	r3, [r7, #12]
 8003ea0:	681b      	ldr	r3, [r3, #0]
 8003ea2:	683a      	ldr	r2, [r7, #0]
 8003ea4:	605a      	str	r2, [r3, #4]
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003ea6:	68fb      	ldr	r3, [r7, #12]
 8003ea8:	689b      	ldr	r3, [r3, #8]
 8003eaa:	2b40      	cmp	r3, #64	@ 0x40
 8003eac:	d108      	bne.n	8003ec0 <DMA_MultiBufferSetConfig+0x30>
  {   
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8003eae:	68fb      	ldr	r3, [r7, #12]
 8003eb0:	681b      	ldr	r3, [r3, #0]
 8003eb2:	687a      	ldr	r2, [r7, #4]
 8003eb4:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8003eb6:	68fb      	ldr	r3, [r7, #12]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	68ba      	ldr	r2, [r7, #8]
 8003ebc:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 8003ebe:	e007      	b.n	8003ed0 <DMA_MultiBufferSetConfig+0x40>
    hdma->Instance->PAR = SrcAddress;
 8003ec0:	68fb      	ldr	r3, [r7, #12]
 8003ec2:	681b      	ldr	r3, [r3, #0]
 8003ec4:	68ba      	ldr	r2, [r7, #8]
 8003ec6:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 8003ec8:	68fb      	ldr	r3, [r7, #12]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	687a      	ldr	r2, [r7, #4]
 8003ece:	60da      	str	r2, [r3, #12]
}
 8003ed0:	bf00      	nop
 8003ed2:	3714      	adds	r7, #20
 8003ed4:	46bd      	mov	sp, r7
 8003ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003eda:	4770      	bx	lr

08003edc <HAL_HCD_Init>:
  * @brief  Initialize the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
{
 8003edc:	b580      	push	{r7, lr}
 8003ede:	b086      	sub	sp, #24
 8003ee0:	af02      	add	r7, sp, #8
 8003ee2:	6078      	str	r0, [r7, #4]
#if defined (USB_OTG_FS)
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */

  /* Check the HCD handle allocation */
  if (hhcd == NULL)
 8003ee4:	687b      	ldr	r3, [r7, #4]
 8003ee6:	2b00      	cmp	r3, #0
 8003ee8:	d101      	bne.n	8003eee <HAL_HCD_Init+0x12>
  {
    return HAL_ERROR;
 8003eea:	2301      	movs	r3, #1
 8003eec:	e059      	b.n	8003fa2 <HAL_HCD_Init+0xc6>

  /* Check the parameters */
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hhcd->Instance;
 8003eee:	687b      	ldr	r3, [r7, #4]
 8003ef0:	681b      	ldr	r3, [r3, #0]
 8003ef2:	60fb      	str	r3, [r7, #12]
#endif /* defined (USB_OTG_FS) */

  if (hhcd->State == HAL_HCD_STATE_RESET)
 8003ef4:	687b      	ldr	r3, [r7, #4]
 8003ef6:	f893 33d5 	ldrb.w	r3, [r3, #981]	@ 0x3d5
 8003efa:	b2db      	uxtb	r3, r3
 8003efc:	2b00      	cmp	r3, #0
 8003efe:	d106      	bne.n	8003f0e <HAL_HCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hhcd->Lock = HAL_UNLOCKED;
 8003f00:	687b      	ldr	r3, [r7, #4]
 8003f02:	2200      	movs	r2, #0
 8003f04:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

    /* Init the low level hardware */
    hhcd->MspInitCallback(hhcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_HCD_MspInit(hhcd);
 8003f08:	6878      	ldr	r0, [r7, #4]
 8003f0a:	f028 ffab 	bl	802ce64 <HAL_HCD_MspInit>
#endif /* (USE_HAL_HCD_REGISTER_CALLBACKS) */
  }

  hhcd->State = HAL_HCD_STATE_BUSY;
 8003f0e:	687b      	ldr	r3, [r7, #4]
 8003f10:	2203      	movs	r2, #3
 8003f12:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 8003f16:	68fb      	ldr	r3, [r7, #12]
 8003f18:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003f1c:	d102      	bne.n	8003f24 <HAL_HCD_Init+0x48>
  {
    hhcd->Init.dma_enable = 0U;
 8003f1e:	687b      	ldr	r3, [r7, #4]
 8003f20:	2200      	movs	r2, #0
 8003f22:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_HCD_DISABLE(hhcd);
 8003f24:	687b      	ldr	r3, [r7, #4]
 8003f26:	681b      	ldr	r3, [r3, #0]
 8003f28:	4618      	mov	r0, r3
 8003f2a:	f002 ff2a 	bl	8006d82 <USB_DisableGlobalInt>

  /* Init the Core (common init.) */
  if (USB_CoreInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 8003f2e:	687b      	ldr	r3, [r7, #4]
 8003f30:	6818      	ldr	r0, [r3, #0]
 8003f32:	687b      	ldr	r3, [r7, #4]
 8003f34:	7c1a      	ldrb	r2, [r3, #16]
 8003f36:	f88d 2000 	strb.w	r2, [sp]
 8003f3a:	3304      	adds	r3, #4
 8003f3c:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003f3e:	f002 feab 	bl	8006c98 <USB_CoreInit>
 8003f42:	4603      	mov	r3, r0
 8003f44:	2b00      	cmp	r3, #0
 8003f46:	d005      	beq.n	8003f54 <HAL_HCD_Init+0x78>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003f48:	687b      	ldr	r3, [r7, #4]
 8003f4a:	2202      	movs	r2, #2
 8003f4c:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003f50:	2301      	movs	r3, #1
 8003f52:	e026      	b.n	8003fa2 <HAL_HCD_Init+0xc6>
  }

  /* Force Host Mode */
  if (USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE) != HAL_OK)
 8003f54:	687b      	ldr	r3, [r7, #4]
 8003f56:	681b      	ldr	r3, [r3, #0]
 8003f58:	2101      	movs	r1, #1
 8003f5a:	4618      	mov	r0, r3
 8003f5c:	f002 ff22 	bl	8006da4 <USB_SetCurrentMode>
 8003f60:	4603      	mov	r3, r0
 8003f62:	2b00      	cmp	r3, #0
 8003f64:	d005      	beq.n	8003f72 <HAL_HCD_Init+0x96>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003f66:	687b      	ldr	r3, [r7, #4]
 8003f68:	2202      	movs	r2, #2
 8003f6a:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003f6e:	2301      	movs	r3, #1
 8003f70:	e017      	b.n	8003fa2 <HAL_HCD_Init+0xc6>
  }

  /* Init Host */
  if (USB_HostInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 8003f72:	687b      	ldr	r3, [r7, #4]
 8003f74:	6818      	ldr	r0, [r3, #0]
 8003f76:	687b      	ldr	r3, [r7, #4]
 8003f78:	7c1a      	ldrb	r2, [r3, #16]
 8003f7a:	f88d 2000 	strb.w	r2, [sp]
 8003f7e:	3304      	adds	r3, #4
 8003f80:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003f82:	f003 f8c5 	bl	8007110 <USB_HostInit>
 8003f86:	4603      	mov	r3, r0
 8003f88:	2b00      	cmp	r3, #0
 8003f8a:	d005      	beq.n	8003f98 <HAL_HCD_Init+0xbc>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003f8c:	687b      	ldr	r3, [r7, #4]
 8003f8e:	2202      	movs	r2, #2
 8003f90:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003f94:	2301      	movs	r3, #1
 8003f96:	e004      	b.n	8003fa2 <HAL_HCD_Init+0xc6>
  }

  hhcd->State = HAL_HCD_STATE_READY;
 8003f98:	687b      	ldr	r3, [r7, #4]
 8003f9a:	2201      	movs	r2, #1
 8003f9c:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5

  return HAL_OK;
 8003fa0:	2300      	movs	r3, #0
}
 8003fa2:	4618      	mov	r0, r3
 8003fa4:	3710      	adds	r7, #16
 8003fa6:	46bd      	mov	sp, r7
 8003fa8:	bd80      	pop	{r7, pc}

08003faa <HAL_HCD_HC_Init>:
  *          This parameter can be a value from 0 to32K
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd, uint8_t ch_num, uint8_t epnum,
                                  uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8003faa:	b590      	push	{r4, r7, lr}
 8003fac:	b08b      	sub	sp, #44	@ 0x2c
 8003fae:	af04      	add	r7, sp, #16
 8003fb0:	6078      	str	r0, [r7, #4]
 8003fb2:	4608      	mov	r0, r1
 8003fb4:	4611      	mov	r1, r2
 8003fb6:	461a      	mov	r2, r3
 8003fb8:	4603      	mov	r3, r0
 8003fba:	70fb      	strb	r3, [r7, #3]
 8003fbc:	460b      	mov	r3, r1
 8003fbe:	70bb      	strb	r3, [r7, #2]
 8003fc0:	4613      	mov	r3, r2
 8003fc2:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef status;
  uint32_t HostCoreSpeed;
  uint32_t HCcharMps = mps;
 8003fc4:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
 8003fc6:	617b      	str	r3, [r7, #20]

  __HAL_LOCK(hhcd);
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8003fce:	2b01      	cmp	r3, #1
 8003fd0:	d101      	bne.n	8003fd6 <HAL_HCD_HC_Init+0x2c>
 8003fd2:	2302      	movs	r3, #2
 8003fd4:	e09d      	b.n	8004112 <HAL_HCD_HC_Init+0x168>
 8003fd6:	687b      	ldr	r3, [r7, #4]
 8003fd8:	2201      	movs	r2, #1
 8003fda:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  hhcd->hc[ch_num].do_ping = 0U;
 8003fde:	78fa      	ldrb	r2, [r7, #3]
 8003fe0:	6879      	ldr	r1, [r7, #4]
 8003fe2:	4613      	mov	r3, r2
 8003fe4:	011b      	lsls	r3, r3, #4
 8003fe6:	1a9b      	subs	r3, r3, r2
 8003fe8:	009b      	lsls	r3, r3, #2
 8003fea:	440b      	add	r3, r1
 8003fec:	3319      	adds	r3, #25
 8003fee:	2200      	movs	r2, #0
 8003ff0:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].dev_addr = dev_address;
 8003ff2:	78fa      	ldrb	r2, [r7, #3]
 8003ff4:	6879      	ldr	r1, [r7, #4]
 8003ff6:	4613      	mov	r3, r2
 8003ff8:	011b      	lsls	r3, r3, #4
 8003ffa:	1a9b      	subs	r3, r3, r2
 8003ffc:	009b      	lsls	r3, r3, #2
 8003ffe:	440b      	add	r3, r1
 8004000:	3314      	adds	r3, #20
 8004002:	787a      	ldrb	r2, [r7, #1]
 8004004:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 8004006:	78fa      	ldrb	r2, [r7, #3]
 8004008:	6879      	ldr	r1, [r7, #4]
 800400a:	4613      	mov	r3, r2
 800400c:	011b      	lsls	r3, r3, #4
 800400e:	1a9b      	subs	r3, r3, r2
 8004010:	009b      	lsls	r3, r3, #2
 8004012:	440b      	add	r3, r1
 8004014:	3315      	adds	r3, #21
 8004016:	78fa      	ldrb	r2, [r7, #3]
 8004018:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type = ep_type;
 800401a:	78fa      	ldrb	r2, [r7, #3]
 800401c:	6879      	ldr	r1, [r7, #4]
 800401e:	4613      	mov	r3, r2
 8004020:	011b      	lsls	r3, r3, #4
 8004022:	1a9b      	subs	r3, r3, r2
 8004024:	009b      	lsls	r3, r3, #2
 8004026:	440b      	add	r3, r1
 8004028:	3326      	adds	r3, #38	@ 0x26
 800402a:	f897 202c 	ldrb.w	r2, [r7, #44]	@ 0x2c
 800402e:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 8004030:	78fa      	ldrb	r2, [r7, #3]
 8004032:	78bb      	ldrb	r3, [r7, #2]
 8004034:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004038:	b2d8      	uxtb	r0, r3
 800403a:	6879      	ldr	r1, [r7, #4]
 800403c:	4613      	mov	r3, r2
 800403e:	011b      	lsls	r3, r3, #4
 8004040:	1a9b      	subs	r3, r3, r2
 8004042:	009b      	lsls	r3, r3, #2
 8004044:	440b      	add	r3, r1
 8004046:	3316      	adds	r3, #22
 8004048:	4602      	mov	r2, r0
 800404a:	701a      	strb	r2, [r3, #0]

  (void)HAL_HCD_HC_ClearHubInfo(hhcd, ch_num);
 800404c:	78fb      	ldrb	r3, [r7, #3]
 800404e:	4619      	mov	r1, r3
 8004050:	6878      	ldr	r0, [r7, #4]
 8004052:	f000 fbc7 	bl	80047e4 <HAL_HCD_HC_ClearHubInfo>

  if ((epnum & 0x80U) == 0x80U)
 8004056:	f997 3002 	ldrsb.w	r3, [r7, #2]
 800405a:	2b00      	cmp	r3, #0
 800405c:	da0a      	bge.n	8004074 <HAL_HCD_HC_Init+0xca>
  {
    hhcd->hc[ch_num].ep_is_in = 1U;
 800405e:	78fa      	ldrb	r2, [r7, #3]
 8004060:	6879      	ldr	r1, [r7, #4]
 8004062:	4613      	mov	r3, r2
 8004064:	011b      	lsls	r3, r3, #4
 8004066:	1a9b      	subs	r3, r3, r2
 8004068:	009b      	lsls	r3, r3, #2
 800406a:	440b      	add	r3, r1
 800406c:	3317      	adds	r3, #23
 800406e:	2201      	movs	r2, #1
 8004070:	701a      	strb	r2, [r3, #0]
 8004072:	e009      	b.n	8004088 <HAL_HCD_HC_Init+0xde>
  }
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
 8004074:	78fa      	ldrb	r2, [r7, #3]
 8004076:	6879      	ldr	r1, [r7, #4]
 8004078:	4613      	mov	r3, r2
 800407a:	011b      	lsls	r3, r3, #4
 800407c:	1a9b      	subs	r3, r3, r2
 800407e:	009b      	lsls	r3, r3, #2
 8004080:	440b      	add	r3, r1
 8004082:	3317      	adds	r3, #23
 8004084:	2200      	movs	r2, #0
 8004086:	701a      	strb	r2, [r3, #0]
  }

  HostCoreSpeed = USB_GetHostSpeed(hhcd->Instance);
 8004088:	687b      	ldr	r3, [r7, #4]
 800408a:	681b      	ldr	r3, [r3, #0]
 800408c:	4618      	mov	r0, r3
 800408e:	f003 f9a3 	bl	80073d8 <USB_GetHostSpeed>
 8004092:	6138      	str	r0, [r7, #16]

  if (ep_type == EP_TYPE_ISOC)
 8004094:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8004098:	2b01      	cmp	r3, #1
 800409a:	d10b      	bne.n	80040b4 <HAL_HCD_HC_Init+0x10a>
  {
    /* FS device plugged to HS HUB */
    if ((speed == HCD_DEVICE_SPEED_FULL) && (HostCoreSpeed == HPRT0_PRTSPD_HIGH_SPEED))
 800409c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80040a0:	2b01      	cmp	r3, #1
 80040a2:	d107      	bne.n	80040b4 <HAL_HCD_HC_Init+0x10a>
 80040a4:	693b      	ldr	r3, [r7, #16]
 80040a6:	2b00      	cmp	r3, #0
 80040a8:	d104      	bne.n	80040b4 <HAL_HCD_HC_Init+0x10a>
    {
      if (HCcharMps > ISO_SPLT_MPS)
 80040aa:	697b      	ldr	r3, [r7, #20]
 80040ac:	2bbc      	cmp	r3, #188	@ 0xbc
 80040ae:	d901      	bls.n	80040b4 <HAL_HCD_HC_Init+0x10a>
      {
        /* ISO Max Packet Size for Split mode */
        HCcharMps = ISO_SPLT_MPS;
 80040b0:	23bc      	movs	r3, #188	@ 0xbc
 80040b2:	617b      	str	r3, [r7, #20]
      }
    }
  }

  hhcd->hc[ch_num].speed = speed;
 80040b4:	78fa      	ldrb	r2, [r7, #3]
 80040b6:	6879      	ldr	r1, [r7, #4]
 80040b8:	4613      	mov	r3, r2
 80040ba:	011b      	lsls	r3, r3, #4
 80040bc:	1a9b      	subs	r3, r3, r2
 80040be:	009b      	lsls	r3, r3, #2
 80040c0:	440b      	add	r3, r1
 80040c2:	3318      	adds	r3, #24
 80040c4:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
 80040c8:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 80040ca:	78fa      	ldrb	r2, [r7, #3]
 80040cc:	697b      	ldr	r3, [r7, #20]
 80040ce:	b298      	uxth	r0, r3
 80040d0:	6879      	ldr	r1, [r7, #4]
 80040d2:	4613      	mov	r3, r2
 80040d4:	011b      	lsls	r3, r3, #4
 80040d6:	1a9b      	subs	r3, r3, r2
 80040d8:	009b      	lsls	r3, r3, #2
 80040da:	440b      	add	r3, r1
 80040dc:	3328      	adds	r3, #40	@ 0x28
 80040de:	4602      	mov	r2, r0
 80040e0:	801a      	strh	r2, [r3, #0]

  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 80040e2:	687b      	ldr	r3, [r7, #4]
 80040e4:	6818      	ldr	r0, [r3, #0]
 80040e6:	697b      	ldr	r3, [r7, #20]
 80040e8:	b29b      	uxth	r3, r3
 80040ea:	787c      	ldrb	r4, [r7, #1]
 80040ec:	78ba      	ldrb	r2, [r7, #2]
 80040ee:	78f9      	ldrb	r1, [r7, #3]
 80040f0:	9302      	str	r3, [sp, #8]
 80040f2:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 80040f6:	9301      	str	r3, [sp, #4]
 80040f8:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80040fc:	9300      	str	r3, [sp, #0]
 80040fe:	4623      	mov	r3, r4
 8004100:	f003 f992 	bl	8007428 <USB_HC_Init>
 8004104:	4603      	mov	r3, r0
 8004106:	73fb      	strb	r3, [r7, #15]
                        dev_address, speed, ep_type, (uint16_t)HCcharMps);

  __HAL_UNLOCK(hhcd);
 8004108:	687b      	ldr	r3, [r7, #4]
 800410a:	2200      	movs	r2, #0
 800410c:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return status;
 8004110:	7bfb      	ldrb	r3, [r7, #15]
}
 8004112:	4618      	mov	r0, r3
 8004114:	371c      	adds	r7, #28
 8004116:	46bd      	mov	sp, r7
 8004118:	bd90      	pop	{r4, r7, pc}

0800411a <HAL_HCD_HC_Halt>:
  * @param  ch_num Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
 800411a:	b580      	push	{r7, lr}
 800411c:	b084      	sub	sp, #16
 800411e:	af00      	add	r7, sp, #0
 8004120:	6078      	str	r0, [r7, #4]
 8004122:	460b      	mov	r3, r1
 8004124:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
 8004126:	2300      	movs	r3, #0
 8004128:	73fb      	strb	r3, [r7, #15]

  __HAL_LOCK(hhcd);
 800412a:	687b      	ldr	r3, [r7, #4]
 800412c:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8004130:	2b01      	cmp	r3, #1
 8004132:	d101      	bne.n	8004138 <HAL_HCD_HC_Halt+0x1e>
 8004134:	2302      	movs	r3, #2
 8004136:	e00f      	b.n	8004158 <HAL_HCD_HC_Halt+0x3e>
 8004138:	687b      	ldr	r3, [r7, #4]
 800413a:	2201      	movs	r2, #1
 800413c:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  (void)USB_HC_Halt(hhcd->Instance, ch_num);
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	681b      	ldr	r3, [r3, #0]
 8004144:	78fa      	ldrb	r2, [r7, #3]
 8004146:	4611      	mov	r1, r2
 8004148:	4618      	mov	r0, r3
 800414a:	f003 fd24 	bl	8007b96 <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 800414e:	687b      	ldr	r3, [r7, #4]
 8004150:	2200      	movs	r2, #0
 8004152:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return status;
 8004156:	7bfb      	ldrb	r3, [r7, #15]
}
 8004158:	4618      	mov	r0, r3
 800415a:	3710      	adds	r7, #16
 800415c:	46bd      	mov	sp, r7
 800415e:	bd80      	pop	{r7, pc}

08004160 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 8004160:	b580      	push	{r7, lr}
 8004162:	b082      	sub	sp, #8
 8004164:	af00      	add	r7, sp, #0
 8004166:	6078      	str	r0, [r7, #4]
 8004168:	4608      	mov	r0, r1
 800416a:	4611      	mov	r1, r2
 800416c:	461a      	mov	r2, r3
 800416e:	4603      	mov	r3, r0
 8004170:	70fb      	strb	r3, [r7, #3]
 8004172:	460b      	mov	r3, r1
 8004174:	70bb      	strb	r3, [r7, #2]
 8004176:	4613      	mov	r3, r2
 8004178:	707b      	strb	r3, [r7, #1]
  hhcd->hc[ch_num].ep_is_in = direction;
 800417a:	78fa      	ldrb	r2, [r7, #3]
 800417c:	6879      	ldr	r1, [r7, #4]
 800417e:	4613      	mov	r3, r2
 8004180:	011b      	lsls	r3, r3, #4
 8004182:	1a9b      	subs	r3, r3, r2
 8004184:	009b      	lsls	r3, r3, #2
 8004186:	440b      	add	r3, r1
 8004188:	3317      	adds	r3, #23
 800418a:	78ba      	ldrb	r2, [r7, #2]
 800418c:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type  = ep_type;
 800418e:	78fa      	ldrb	r2, [r7, #3]
 8004190:	6879      	ldr	r1, [r7, #4]
 8004192:	4613      	mov	r3, r2
 8004194:	011b      	lsls	r3, r3, #4
 8004196:	1a9b      	subs	r3, r3, r2
 8004198:	009b      	lsls	r3, r3, #2
 800419a:	440b      	add	r3, r1
 800419c:	3326      	adds	r3, #38	@ 0x26
 800419e:	787a      	ldrb	r2, [r7, #1]
 80041a0:	701a      	strb	r2, [r3, #0]

  if (token == 0U)
 80041a2:	7c3b      	ldrb	r3, [r7, #16]
 80041a4:	2b00      	cmp	r3, #0
 80041a6:	d114      	bne.n	80041d2 <HAL_HCD_HC_SubmitRequest+0x72>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 80041a8:	78fa      	ldrb	r2, [r7, #3]
 80041aa:	6879      	ldr	r1, [r7, #4]
 80041ac:	4613      	mov	r3, r2
 80041ae:	011b      	lsls	r3, r3, #4
 80041b0:	1a9b      	subs	r3, r3, r2
 80041b2:	009b      	lsls	r3, r3, #2
 80041b4:	440b      	add	r3, r1
 80041b6:	332a      	adds	r3, #42	@ 0x2a
 80041b8:	2203      	movs	r2, #3
 80041ba:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].do_ping = do_ping;
 80041bc:	78fa      	ldrb	r2, [r7, #3]
 80041be:	6879      	ldr	r1, [r7, #4]
 80041c0:	4613      	mov	r3, r2
 80041c2:	011b      	lsls	r3, r3, #4
 80041c4:	1a9b      	subs	r3, r3, r2
 80041c6:	009b      	lsls	r3, r3, #2
 80041c8:	440b      	add	r3, r1
 80041ca:	3319      	adds	r3, #25
 80041cc:	7f3a      	ldrb	r2, [r7, #28]
 80041ce:	701a      	strb	r2, [r3, #0]
 80041d0:	e009      	b.n	80041e6 <HAL_HCD_HC_SubmitRequest+0x86>
  }
  else
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80041d2:	78fa      	ldrb	r2, [r7, #3]
 80041d4:	6879      	ldr	r1, [r7, #4]
 80041d6:	4613      	mov	r3, r2
 80041d8:	011b      	lsls	r3, r3, #4
 80041da:	1a9b      	subs	r3, r3, r2
 80041dc:	009b      	lsls	r3, r3, #2
 80041de:	440b      	add	r3, r1
 80041e0:	332a      	adds	r3, #42	@ 0x2a
 80041e2:	2202      	movs	r2, #2
 80041e4:	701a      	strb	r2, [r3, #0]
  }

  /* Manage Data Toggle */
  switch (ep_type)
 80041e6:	787b      	ldrb	r3, [r7, #1]
 80041e8:	2b03      	cmp	r3, #3
 80041ea:	f200 8102 	bhi.w	80043f2 <HAL_HCD_HC_SubmitRequest+0x292>
 80041ee:	a201      	add	r2, pc, #4	@ (adr r2, 80041f4 <HAL_HCD_HC_SubmitRequest+0x94>)
 80041f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80041f4:	08004205 	.word	0x08004205
 80041f8:	080043dd 	.word	0x080043dd
 80041fc:	080042c9 	.word	0x080042c9
 8004200:	08004353 	.word	0x08004353
  {
    case EP_TYPE_CTRL:
      if (token == 1U) /* send data */
 8004204:	7c3b      	ldrb	r3, [r7, #16]
 8004206:	2b01      	cmp	r3, #1
 8004208:	f040 80f5 	bne.w	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>
      {
        if (direction == 0U)
 800420c:	78bb      	ldrb	r3, [r7, #2]
 800420e:	2b00      	cmp	r3, #0
 8004210:	d12d      	bne.n	800426e <HAL_HCD_HC_SubmitRequest+0x10e>
        {
          if (length == 0U)
 8004212:	8b3b      	ldrh	r3, [r7, #24]
 8004214:	2b00      	cmp	r3, #0
 8004216:	d109      	bne.n	800422c <HAL_HCD_HC_SubmitRequest+0xcc>
          {
            /* For Status OUT stage, Length == 0U, Status Out PID = 1 */
            hhcd->hc[ch_num].toggle_out = 1U;
 8004218:	78fa      	ldrb	r2, [r7, #3]
 800421a:	6879      	ldr	r1, [r7, #4]
 800421c:	4613      	mov	r3, r2
 800421e:	011b      	lsls	r3, r3, #4
 8004220:	1a9b      	subs	r3, r3, r2
 8004222:	009b      	lsls	r3, r3, #2
 8004224:	440b      	add	r3, r1
 8004226:	333d      	adds	r3, #61	@ 0x3d
 8004228:	2201      	movs	r2, #1
 800422a:	701a      	strb	r2, [r3, #0]
          }

          /* Set the Data Toggle bit as per the Flag */
          if (hhcd->hc[ch_num].toggle_out == 0U)
 800422c:	78fa      	ldrb	r2, [r7, #3]
 800422e:	6879      	ldr	r1, [r7, #4]
 8004230:	4613      	mov	r3, r2
 8004232:	011b      	lsls	r3, r3, #4
 8004234:	1a9b      	subs	r3, r3, r2
 8004236:	009b      	lsls	r3, r3, #2
 8004238:	440b      	add	r3, r1
 800423a:	333d      	adds	r3, #61	@ 0x3d
 800423c:	781b      	ldrb	r3, [r3, #0]
 800423e:	2b00      	cmp	r3, #0
 8004240:	d10a      	bne.n	8004258 <HAL_HCD_HC_SubmitRequest+0xf8>
          {
            /* Put the PID 0 */
            hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8004242:	78fa      	ldrb	r2, [r7, #3]
 8004244:	6879      	ldr	r1, [r7, #4]
 8004246:	4613      	mov	r3, r2
 8004248:	011b      	lsls	r3, r3, #4
 800424a:	1a9b      	subs	r3, r3, r2
 800424c:	009b      	lsls	r3, r3, #2
 800424e:	440b      	add	r3, r1
 8004250:	332a      	adds	r3, #42	@ 0x2a
 8004252:	2200      	movs	r2, #0
 8004254:	701a      	strb	r2, [r3, #0]
              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
            }
          }
        }
      }
      break;
 8004256:	e0ce      	b.n	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>
            hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8004258:	78fa      	ldrb	r2, [r7, #3]
 800425a:	6879      	ldr	r1, [r7, #4]
 800425c:	4613      	mov	r3, r2
 800425e:	011b      	lsls	r3, r3, #4
 8004260:	1a9b      	subs	r3, r3, r2
 8004262:	009b      	lsls	r3, r3, #2
 8004264:	440b      	add	r3, r1
 8004266:	332a      	adds	r3, #42	@ 0x2a
 8004268:	2202      	movs	r2, #2
 800426a:	701a      	strb	r2, [r3, #0]
      break;
 800426c:	e0c3      	b.n	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>
          if (hhcd->hc[ch_num].do_ssplit == 1U)
 800426e:	78fa      	ldrb	r2, [r7, #3]
 8004270:	6879      	ldr	r1, [r7, #4]
 8004272:	4613      	mov	r3, r2
 8004274:	011b      	lsls	r3, r3, #4
 8004276:	1a9b      	subs	r3, r3, r2
 8004278:	009b      	lsls	r3, r3, #2
 800427a:	440b      	add	r3, r1
 800427c:	331a      	adds	r3, #26
 800427e:	781b      	ldrb	r3, [r3, #0]
 8004280:	2b01      	cmp	r3, #1
 8004282:	f040 80b8 	bne.w	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>
            if (hhcd->hc[ch_num].toggle_in == 0U)
 8004286:	78fa      	ldrb	r2, [r7, #3]
 8004288:	6879      	ldr	r1, [r7, #4]
 800428a:	4613      	mov	r3, r2
 800428c:	011b      	lsls	r3, r3, #4
 800428e:	1a9b      	subs	r3, r3, r2
 8004290:	009b      	lsls	r3, r3, #2
 8004292:	440b      	add	r3, r1
 8004294:	333c      	adds	r3, #60	@ 0x3c
 8004296:	781b      	ldrb	r3, [r3, #0]
 8004298:	2b00      	cmp	r3, #0
 800429a:	d10a      	bne.n	80042b2 <HAL_HCD_HC_SubmitRequest+0x152>
              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 800429c:	78fa      	ldrb	r2, [r7, #3]
 800429e:	6879      	ldr	r1, [r7, #4]
 80042a0:	4613      	mov	r3, r2
 80042a2:	011b      	lsls	r3, r3, #4
 80042a4:	1a9b      	subs	r3, r3, r2
 80042a6:	009b      	lsls	r3, r3, #2
 80042a8:	440b      	add	r3, r1
 80042aa:	332a      	adds	r3, #42	@ 0x2a
 80042ac:	2200      	movs	r2, #0
 80042ae:	701a      	strb	r2, [r3, #0]
      break;
 80042b0:	e0a1      	b.n	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>
              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80042b2:	78fa      	ldrb	r2, [r7, #3]
 80042b4:	6879      	ldr	r1, [r7, #4]
 80042b6:	4613      	mov	r3, r2
 80042b8:	011b      	lsls	r3, r3, #4
 80042ba:	1a9b      	subs	r3, r3, r2
 80042bc:	009b      	lsls	r3, r3, #2
 80042be:	440b      	add	r3, r1
 80042c0:	332a      	adds	r3, #42	@ 0x2a
 80042c2:	2202      	movs	r2, #2
 80042c4:	701a      	strb	r2, [r3, #0]
      break;
 80042c6:	e096      	b.n	80043f6 <HAL_HCD_HC_SubmitRequest+0x296>

    case EP_TYPE_BULK:
      if (direction == 0U)
 80042c8:	78bb      	ldrb	r3, [r7, #2]
 80042ca:	2b00      	cmp	r3, #0
 80042cc:	d120      	bne.n	8004310 <HAL_HCD_HC_SubmitRequest+0x1b0>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80042ce:	78fa      	ldrb	r2, [r7, #3]
 80042d0:	6879      	ldr	r1, [r7, #4]
 80042d2:	4613      	mov	r3, r2
 80042d4:	011b      	lsls	r3, r3, #4
 80042d6:	1a9b      	subs	r3, r3, r2
 80042d8:	009b      	lsls	r3, r3, #2
 80042da:	440b      	add	r3, r1
 80042dc:	333d      	adds	r3, #61	@ 0x3d
 80042de:	781b      	ldrb	r3, [r3, #0]
 80042e0:	2b00      	cmp	r3, #0
 80042e2:	d10a      	bne.n	80042fa <HAL_HCD_HC_SubmitRequest+0x19a>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80042e4:	78fa      	ldrb	r2, [r7, #3]
 80042e6:	6879      	ldr	r1, [r7, #4]
 80042e8:	4613      	mov	r3, r2
 80042ea:	011b      	lsls	r3, r3, #4
 80042ec:	1a9b      	subs	r3, r3, r2
 80042ee:	009b      	lsls	r3, r3, #2
 80042f0:	440b      	add	r3, r1
 80042f2:	332a      	adds	r3, #42	@ 0x2a
 80042f4:	2200      	movs	r2, #0
 80042f6:	701a      	strb	r2, [r3, #0]
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }

      break;
 80042f8:	e07e      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80042fa:	78fa      	ldrb	r2, [r7, #3]
 80042fc:	6879      	ldr	r1, [r7, #4]
 80042fe:	4613      	mov	r3, r2
 8004300:	011b      	lsls	r3, r3, #4
 8004302:	1a9b      	subs	r3, r3, r2
 8004304:	009b      	lsls	r3, r3, #2
 8004306:	440b      	add	r3, r1
 8004308:	332a      	adds	r3, #42	@ 0x2a
 800430a:	2202      	movs	r2, #2
 800430c:	701a      	strb	r2, [r3, #0]
      break;
 800430e:	e073      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 8004310:	78fa      	ldrb	r2, [r7, #3]
 8004312:	6879      	ldr	r1, [r7, #4]
 8004314:	4613      	mov	r3, r2
 8004316:	011b      	lsls	r3, r3, #4
 8004318:	1a9b      	subs	r3, r3, r2
 800431a:	009b      	lsls	r3, r3, #2
 800431c:	440b      	add	r3, r1
 800431e:	333c      	adds	r3, #60	@ 0x3c
 8004320:	781b      	ldrb	r3, [r3, #0]
 8004322:	2b00      	cmp	r3, #0
 8004324:	d10a      	bne.n	800433c <HAL_HCD_HC_SubmitRequest+0x1dc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8004326:	78fa      	ldrb	r2, [r7, #3]
 8004328:	6879      	ldr	r1, [r7, #4]
 800432a:	4613      	mov	r3, r2
 800432c:	011b      	lsls	r3, r3, #4
 800432e:	1a9b      	subs	r3, r3, r2
 8004330:	009b      	lsls	r3, r3, #2
 8004332:	440b      	add	r3, r1
 8004334:	332a      	adds	r3, #42	@ 0x2a
 8004336:	2200      	movs	r2, #0
 8004338:	701a      	strb	r2, [r3, #0]
      break;
 800433a:	e05d      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800433c:	78fa      	ldrb	r2, [r7, #3]
 800433e:	6879      	ldr	r1, [r7, #4]
 8004340:	4613      	mov	r3, r2
 8004342:	011b      	lsls	r3, r3, #4
 8004344:	1a9b      	subs	r3, r3, r2
 8004346:	009b      	lsls	r3, r3, #2
 8004348:	440b      	add	r3, r1
 800434a:	332a      	adds	r3, #42	@ 0x2a
 800434c:	2202      	movs	r2, #2
 800434e:	701a      	strb	r2, [r3, #0]
      break;
 8004350:	e052      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
    case EP_TYPE_INTR:
      if (direction == 0U)
 8004352:	78bb      	ldrb	r3, [r7, #2]
 8004354:	2b00      	cmp	r3, #0
 8004356:	d120      	bne.n	800439a <HAL_HCD_HC_SubmitRequest+0x23a>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8004358:	78fa      	ldrb	r2, [r7, #3]
 800435a:	6879      	ldr	r1, [r7, #4]
 800435c:	4613      	mov	r3, r2
 800435e:	011b      	lsls	r3, r3, #4
 8004360:	1a9b      	subs	r3, r3, r2
 8004362:	009b      	lsls	r3, r3, #2
 8004364:	440b      	add	r3, r1
 8004366:	333d      	adds	r3, #61	@ 0x3d
 8004368:	781b      	ldrb	r3, [r3, #0]
 800436a:	2b00      	cmp	r3, #0
 800436c:	d10a      	bne.n	8004384 <HAL_HCD_HC_SubmitRequest+0x224>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 800436e:	78fa      	ldrb	r2, [r7, #3]
 8004370:	6879      	ldr	r1, [r7, #4]
 8004372:	4613      	mov	r3, r2
 8004374:	011b      	lsls	r3, r3, #4
 8004376:	1a9b      	subs	r3, r3, r2
 8004378:	009b      	lsls	r3, r3, #2
 800437a:	440b      	add	r3, r1
 800437c:	332a      	adds	r3, #42	@ 0x2a
 800437e:	2200      	movs	r2, #0
 8004380:	701a      	strb	r2, [r3, #0]
        else
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }
      break;
 8004382:	e039      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8004384:	78fa      	ldrb	r2, [r7, #3]
 8004386:	6879      	ldr	r1, [r7, #4]
 8004388:	4613      	mov	r3, r2
 800438a:	011b      	lsls	r3, r3, #4
 800438c:	1a9b      	subs	r3, r3, r2
 800438e:	009b      	lsls	r3, r3, #2
 8004390:	440b      	add	r3, r1
 8004392:	332a      	adds	r3, #42	@ 0x2a
 8004394:	2202      	movs	r2, #2
 8004396:	701a      	strb	r2, [r3, #0]
      break;
 8004398:	e02e      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 800439a:	78fa      	ldrb	r2, [r7, #3]
 800439c:	6879      	ldr	r1, [r7, #4]
 800439e:	4613      	mov	r3, r2
 80043a0:	011b      	lsls	r3, r3, #4
 80043a2:	1a9b      	subs	r3, r3, r2
 80043a4:	009b      	lsls	r3, r3, #2
 80043a6:	440b      	add	r3, r1
 80043a8:	333c      	adds	r3, #60	@ 0x3c
 80043aa:	781b      	ldrb	r3, [r3, #0]
 80043ac:	2b00      	cmp	r3, #0
 80043ae:	d10a      	bne.n	80043c6 <HAL_HCD_HC_SubmitRequest+0x266>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80043b0:	78fa      	ldrb	r2, [r7, #3]
 80043b2:	6879      	ldr	r1, [r7, #4]
 80043b4:	4613      	mov	r3, r2
 80043b6:	011b      	lsls	r3, r3, #4
 80043b8:	1a9b      	subs	r3, r3, r2
 80043ba:	009b      	lsls	r3, r3, #2
 80043bc:	440b      	add	r3, r1
 80043be:	332a      	adds	r3, #42	@ 0x2a
 80043c0:	2200      	movs	r2, #0
 80043c2:	701a      	strb	r2, [r3, #0]
      break;
 80043c4:	e018      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80043c6:	78fa      	ldrb	r2, [r7, #3]
 80043c8:	6879      	ldr	r1, [r7, #4]
 80043ca:	4613      	mov	r3, r2
 80043cc:	011b      	lsls	r3, r3, #4
 80043ce:	1a9b      	subs	r3, r3, r2
 80043d0:	009b      	lsls	r3, r3, #2
 80043d2:	440b      	add	r3, r1
 80043d4:	332a      	adds	r3, #42	@ 0x2a
 80043d6:	2202      	movs	r2, #2
 80043d8:	701a      	strb	r2, [r3, #0]
      break;
 80043da:	e00d      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>

    case EP_TYPE_ISOC:
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80043dc:	78fa      	ldrb	r2, [r7, #3]
 80043de:	6879      	ldr	r1, [r7, #4]
 80043e0:	4613      	mov	r3, r2
 80043e2:	011b      	lsls	r3, r3, #4
 80043e4:	1a9b      	subs	r3, r3, r2
 80043e6:	009b      	lsls	r3, r3, #2
 80043e8:	440b      	add	r3, r1
 80043ea:	332a      	adds	r3, #42	@ 0x2a
 80043ec:	2200      	movs	r2, #0
 80043ee:	701a      	strb	r2, [r3, #0]
      break;
 80043f0:	e002      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>

    default:
      break;
 80043f2:	bf00      	nop
 80043f4:	e000      	b.n	80043f8 <HAL_HCD_HC_SubmitRequest+0x298>
      break;
 80043f6:	bf00      	nop
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 80043f8:	78fa      	ldrb	r2, [r7, #3]
 80043fa:	6879      	ldr	r1, [r7, #4]
 80043fc:	4613      	mov	r3, r2
 80043fe:	011b      	lsls	r3, r3, #4
 8004400:	1a9b      	subs	r3, r3, r2
 8004402:	009b      	lsls	r3, r3, #2
 8004404:	440b      	add	r3, r1
 8004406:	332c      	adds	r3, #44	@ 0x2c
 8004408:	697a      	ldr	r2, [r7, #20]
 800440a:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_len  = length;
 800440c:	78fa      	ldrb	r2, [r7, #3]
 800440e:	8b39      	ldrh	r1, [r7, #24]
 8004410:	6878      	ldr	r0, [r7, #4]
 8004412:	4613      	mov	r3, r2
 8004414:	011b      	lsls	r3, r3, #4
 8004416:	1a9b      	subs	r3, r3, r2
 8004418:	009b      	lsls	r3, r3, #2
 800441a:	4403      	add	r3, r0
 800441c:	3334      	adds	r3, #52	@ 0x34
 800441e:	6019      	str	r1, [r3, #0]
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8004420:	78fa      	ldrb	r2, [r7, #3]
 8004422:	6879      	ldr	r1, [r7, #4]
 8004424:	4613      	mov	r3, r2
 8004426:	011b      	lsls	r3, r3, #4
 8004428:	1a9b      	subs	r3, r3, r2
 800442a:	009b      	lsls	r3, r3, #2
 800442c:	440b      	add	r3, r1
 800442e:	334c      	adds	r3, #76	@ 0x4c
 8004430:	2200      	movs	r2, #0
 8004432:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_count = 0U;
 8004434:	78fa      	ldrb	r2, [r7, #3]
 8004436:	6879      	ldr	r1, [r7, #4]
 8004438:	4613      	mov	r3, r2
 800443a:	011b      	lsls	r3, r3, #4
 800443c:	1a9b      	subs	r3, r3, r2
 800443e:	009b      	lsls	r3, r3, #2
 8004440:	440b      	add	r3, r1
 8004442:	3338      	adds	r3, #56	@ 0x38
 8004444:	2200      	movs	r2, #0
 8004446:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 8004448:	78fa      	ldrb	r2, [r7, #3]
 800444a:	6879      	ldr	r1, [r7, #4]
 800444c:	4613      	mov	r3, r2
 800444e:	011b      	lsls	r3, r3, #4
 8004450:	1a9b      	subs	r3, r3, r2
 8004452:	009b      	lsls	r3, r3, #2
 8004454:	440b      	add	r3, r1
 8004456:	3315      	adds	r3, #21
 8004458:	78fa      	ldrb	r2, [r7, #3]
 800445a:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].state = HC_IDLE;
 800445c:	78fa      	ldrb	r2, [r7, #3]
 800445e:	6879      	ldr	r1, [r7, #4]
 8004460:	4613      	mov	r3, r2
 8004462:	011b      	lsls	r3, r3, #4
 8004464:	1a9b      	subs	r3, r3, r2
 8004466:	009b      	lsls	r3, r3, #2
 8004468:	440b      	add	r3, r1
 800446a:	334d      	adds	r3, #77	@ 0x4d
 800446c:	2200      	movs	r2, #0
 800446e:	701a      	strb	r2, [r3, #0]

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8004470:	687b      	ldr	r3, [r7, #4]
 8004472:	6818      	ldr	r0, [r3, #0]
 8004474:	78fa      	ldrb	r2, [r7, #3]
 8004476:	4613      	mov	r3, r2
 8004478:	011b      	lsls	r3, r3, #4
 800447a:	1a9b      	subs	r3, r3, r2
 800447c:	009b      	lsls	r3, r3, #2
 800447e:	3310      	adds	r3, #16
 8004480:	687a      	ldr	r2, [r7, #4]
 8004482:	4413      	add	r3, r2
 8004484:	1d19      	adds	r1, r3, #4
 8004486:	687b      	ldr	r3, [r7, #4]
 8004488:	799b      	ldrb	r3, [r3, #6]
 800448a:	461a      	mov	r2, r3
 800448c:	f003 f8f8 	bl	8007680 <USB_HC_StartXfer>
 8004490:	4603      	mov	r3, r0
}
 8004492:	4618      	mov	r0, r3
 8004494:	3708      	adds	r7, #8
 8004496:	46bd      	mov	sp, r7
 8004498:	bd80      	pop	{r7, pc}
 800449a:	bf00      	nop

0800449c <HAL_HCD_IRQHandler>:
  * @brief  Handle HCD interrupt request.
  * @param  hhcd HCD handle
  * @retval None
  */
void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 800449c:	b580      	push	{r7, lr}
 800449e:	b086      	sub	sp, #24
 80044a0:	af00      	add	r7, sp, #0
 80044a2:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	681b      	ldr	r3, [r3, #0]
 80044a8:	613b      	str	r3, [r7, #16]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80044aa:	693b      	ldr	r3, [r7, #16]
 80044ac:	60fb      	str	r3, [r7, #12]
  uint32_t i;
  uint32_t interrupt;

  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 80044ae:	687b      	ldr	r3, [r7, #4]
 80044b0:	681b      	ldr	r3, [r3, #0]
 80044b2:	4618      	mov	r0, r3
 80044b4:	f002 fdec 	bl	8007090 <USB_GetMode>
 80044b8:	4603      	mov	r3, r0
 80044ba:	2b01      	cmp	r3, #1
 80044bc:	f040 80fb 	bne.w	80046b6 <HAL_HCD_IRQHandler+0x21a>
  {
    /* Avoid spurious interrupt */
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 80044c0:	687b      	ldr	r3, [r7, #4]
 80044c2:	681b      	ldr	r3, [r3, #0]
 80044c4:	4618      	mov	r0, r3
 80044c6:	f002 fdaf 	bl	8007028 <USB_ReadInterrupts>
 80044ca:	4603      	mov	r3, r0
 80044cc:	2b00      	cmp	r3, #0
 80044ce:	f000 80f1 	beq.w	80046b4 <HAL_HCD_IRQHandler+0x218>
    {
      return;
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80044d2:	687b      	ldr	r3, [r7, #4]
 80044d4:	681b      	ldr	r3, [r3, #0]
 80044d6:	4618      	mov	r0, r3
 80044d8:	f002 fda6 	bl	8007028 <USB_ReadInterrupts>
 80044dc:	4603      	mov	r3, r0
 80044de:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80044e2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80044e6:	d104      	bne.n	80044f2 <HAL_HCD_IRQHandler+0x56>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80044e8:	687b      	ldr	r3, [r7, #4]
 80044ea:	681b      	ldr	r3, [r3, #0]
 80044ec:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 80044f0:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 80044f2:	687b      	ldr	r3, [r7, #4]
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	4618      	mov	r0, r3
 80044f8:	f002 fd96 	bl	8007028 <USB_ReadInterrupts>
 80044fc:	4603      	mov	r3, r0
 80044fe:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8004502:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8004506:	d104      	bne.n	8004512 <HAL_HCD_IRQHandler+0x76>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8004508:	687b      	ldr	r3, [r7, #4]
 800450a:	681b      	ldr	r3, [r3, #0]
 800450c:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8004510:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 8004512:	687b      	ldr	r3, [r7, #4]
 8004514:	681b      	ldr	r3, [r3, #0]
 8004516:	4618      	mov	r0, r3
 8004518:	f002 fd86 	bl	8007028 <USB_ReadInterrupts>
 800451c:	4603      	mov	r3, r0
 800451e:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8004522:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8004526:	d104      	bne.n	8004532 <HAL_HCD_IRQHandler+0x96>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8004528:	687b      	ldr	r3, [r7, #4]
 800452a:	681b      	ldr	r3, [r3, #0]
 800452c:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 8004530:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	681b      	ldr	r3, [r3, #0]
 8004536:	4618      	mov	r0, r3
 8004538:	f002 fd76 	bl	8007028 <USB_ReadInterrupts>
 800453c:	4603      	mov	r3, r0
 800453e:	f003 0302 	and.w	r3, r3, #2
 8004542:	2b02      	cmp	r3, #2
 8004544:	d103      	bne.n	800454e <HAL_HCD_IRQHandler+0xb2>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8004546:	687b      	ldr	r3, [r7, #4]
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	2202      	movs	r2, #2
 800454c:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host Disconnect Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	681b      	ldr	r3, [r3, #0]
 8004552:	4618      	mov	r0, r3
 8004554:	f002 fd68 	bl	8007028 <USB_ReadInterrupts>
 8004558:	4603      	mov	r3, r0
 800455a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800455e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8004562:	d120      	bne.n	80045a6 <HAL_HCD_IRQHandler+0x10a>
    {
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 8004564:	687b      	ldr	r3, [r7, #4]
 8004566:	681b      	ldr	r3, [r3, #0]
 8004568:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 800456c:	615a      	str	r2, [r3, #20]

      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 800456e:	68fb      	ldr	r3, [r7, #12]
 8004570:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8004574:	681b      	ldr	r3, [r3, #0]
 8004576:	f003 0301 	and.w	r3, r3, #1
 800457a:	2b00      	cmp	r3, #0
 800457c:	d113      	bne.n	80045a6 <HAL_HCD_IRQHandler+0x10a>
      {
        /* Flush USB Fifo */
        (void)USB_FlushTxFifo(USBx, 0x10U);
 800457e:	2110      	movs	r1, #16
 8004580:	6938      	ldr	r0, [r7, #16]
 8004582:	f002 fc5b 	bl	8006e3c <USB_FlushTxFifo>
        (void)USB_FlushRxFifo(USBx);
 8004586:	6938      	ldr	r0, [r7, #16]
 8004588:	f002 fc8a 	bl	8006ea0 <USB_FlushRxFifo>

        if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 800458c:	687b      	ldr	r3, [r7, #4]
 800458e:	7a5b      	ldrb	r3, [r3, #9]
 8004590:	2b02      	cmp	r3, #2
 8004592:	d105      	bne.n	80045a0 <HAL_HCD_IRQHandler+0x104>
        {
          /* Restore FS Clock */
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8004594:	687b      	ldr	r3, [r7, #4]
 8004596:	681b      	ldr	r3, [r3, #0]
 8004598:	2101      	movs	r1, #1
 800459a:	4618      	mov	r0, r3
 800459c:	f002 fe7c 	bl	8007298 <USB_InitFSLSPClkSel>

        /* Handle Host Port Disconnect Interrupt */
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
        hhcd->DisconnectCallback(hhcd);
#else
        HAL_HCD_Disconnect_Callback(hhcd);
 80045a0:	6878      	ldr	r0, [r7, #4]
 80045a2:	f028 fccf 	bl	802cf44 <HAL_HCD_Disconnect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Host Port Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 80045a6:	687b      	ldr	r3, [r7, #4]
 80045a8:	681b      	ldr	r3, [r3, #0]
 80045aa:	4618      	mov	r0, r3
 80045ac:	f002 fd3c 	bl	8007028 <USB_ReadInterrupts>
 80045b0:	4603      	mov	r3, r0
 80045b2:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80045b6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80045ba:	d102      	bne.n	80045c2 <HAL_HCD_IRQHandler+0x126>
    {
      HCD_Port_IRQHandler(hhcd);
 80045bc:	6878      	ldr	r0, [r7, #4]
 80045be:	f001 fd33 	bl	8006028 <HCD_Port_IRQHandler>
    }

    /* Handle Host SOF Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 80045c2:	687b      	ldr	r3, [r7, #4]
 80045c4:	681b      	ldr	r3, [r3, #0]
 80045c6:	4618      	mov	r0, r3
 80045c8:	f002 fd2e 	bl	8007028 <USB_ReadInterrupts>
 80045cc:	4603      	mov	r3, r0
 80045ce:	f003 0308 	and.w	r3, r3, #8
 80045d2:	2b08      	cmp	r3, #8
 80045d4:	d106      	bne.n	80045e4 <HAL_HCD_IRQHandler+0x148>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->SOFCallback(hhcd);
#else
      HAL_HCD_SOF_Callback(hhcd);
 80045d6:	6878      	ldr	r0, [r7, #4]
 80045d8:	f028 fc98 	bl	802cf0c <HAL_HCD_SOF_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 80045dc:	687b      	ldr	r3, [r7, #4]
 80045de:	681b      	ldr	r3, [r3, #0]
 80045e0:	2208      	movs	r2, #8
 80045e2:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host channel Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 80045e4:	687b      	ldr	r3, [r7, #4]
 80045e6:	681b      	ldr	r3, [r3, #0]
 80045e8:	4618      	mov	r0, r3
 80045ea:	f002 fd1d 	bl	8007028 <USB_ReadInterrupts>
 80045ee:	4603      	mov	r3, r0
 80045f0:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80045f4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80045f8:	d139      	bne.n	800466e <HAL_HCD_IRQHandler+0x1d2>
    {
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 80045fa:	687b      	ldr	r3, [r7, #4]
 80045fc:	681b      	ldr	r3, [r3, #0]
 80045fe:	4618      	mov	r0, r3
 8004600:	f003 fab8 	bl	8007b74 <USB_HC_ReadInterrupt>
 8004604:	60b8      	str	r0, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8004606:	2300      	movs	r3, #0
 8004608:	617b      	str	r3, [r7, #20]
 800460a:	e025      	b.n	8004658 <HAL_HCD_IRQHandler+0x1bc>
      {
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 800460c:	697b      	ldr	r3, [r7, #20]
 800460e:	f003 030f 	and.w	r3, r3, #15
 8004612:	68ba      	ldr	r2, [r7, #8]
 8004614:	fa22 f303 	lsr.w	r3, r2, r3
 8004618:	f003 0301 	and.w	r3, r3, #1
 800461c:	2b00      	cmp	r3, #0
 800461e:	d018      	beq.n	8004652 <HAL_HCD_IRQHandler+0x1b6>
        {
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8004620:	697b      	ldr	r3, [r7, #20]
 8004622:	015a      	lsls	r2, r3, #5
 8004624:	68fb      	ldr	r3, [r7, #12]
 8004626:	4413      	add	r3, r2
 8004628:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800462c:	681b      	ldr	r3, [r3, #0]
 800462e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8004632:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8004636:	d106      	bne.n	8004646 <HAL_HCD_IRQHandler+0x1aa>
          {
            HCD_HC_IN_IRQHandler(hhcd, (uint8_t)i);
 8004638:	697b      	ldr	r3, [r7, #20]
 800463a:	b2db      	uxtb	r3, r3
 800463c:	4619      	mov	r1, r3
 800463e:	6878      	ldr	r0, [r7, #4]
 8004640:	f000 f905 	bl	800484e <HCD_HC_IN_IRQHandler>
 8004644:	e005      	b.n	8004652 <HAL_HCD_IRQHandler+0x1b6>
          }
          else
          {
            HCD_HC_OUT_IRQHandler(hhcd, (uint8_t)i);
 8004646:	697b      	ldr	r3, [r7, #20]
 8004648:	b2db      	uxtb	r3, r3
 800464a:	4619      	mov	r1, r3
 800464c:	6878      	ldr	r0, [r7, #4]
 800464e:	f000 ff67 	bl	8005520 <HCD_HC_OUT_IRQHandler>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8004652:	697b      	ldr	r3, [r7, #20]
 8004654:	3301      	adds	r3, #1
 8004656:	617b      	str	r3, [r7, #20]
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	795b      	ldrb	r3, [r3, #5]
 800465c:	461a      	mov	r2, r3
 800465e:	697b      	ldr	r3, [r7, #20]
 8004660:	4293      	cmp	r3, r2
 8004662:	d3d3      	bcc.n	800460c <HAL_HCD_IRQHandler+0x170>
          }
        }
      }
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 8004664:	687b      	ldr	r3, [r7, #4]
 8004666:	681b      	ldr	r3, [r3, #0]
 8004668:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800466c:	615a      	str	r2, [r3, #20]
    }

    /* Handle Rx Queue Level Interrupts */
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 800466e:	687b      	ldr	r3, [r7, #4]
 8004670:	681b      	ldr	r3, [r3, #0]
 8004672:	4618      	mov	r0, r3
 8004674:	f002 fcd8 	bl	8007028 <USB_ReadInterrupts>
 8004678:	4603      	mov	r3, r0
 800467a:	f003 0310 	and.w	r3, r3, #16
 800467e:	2b10      	cmp	r3, #16
 8004680:	d101      	bne.n	8004686 <HAL_HCD_IRQHandler+0x1ea>
 8004682:	2301      	movs	r3, #1
 8004684:	e000      	b.n	8004688 <HAL_HCD_IRQHandler+0x1ec>
 8004686:	2300      	movs	r3, #0
 8004688:	2b00      	cmp	r3, #0
 800468a:	d014      	beq.n	80046b6 <HAL_HCD_IRQHandler+0x21a>
    {
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800468c:	687b      	ldr	r3, [r7, #4]
 800468e:	681b      	ldr	r3, [r3, #0]
 8004690:	699a      	ldr	r2, [r3, #24]
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	681b      	ldr	r3, [r3, #0]
 8004696:	f022 0210 	bic.w	r2, r2, #16
 800469a:	619a      	str	r2, [r3, #24]

      HCD_RXQLVL_IRQHandler(hhcd);
 800469c:	6878      	ldr	r0, [r7, #4]
 800469e:	f001 fbe4 	bl	8005e6a <HCD_RXQLVL_IRQHandler>

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80046a2:	687b      	ldr	r3, [r7, #4]
 80046a4:	681b      	ldr	r3, [r3, #0]
 80046a6:	699a      	ldr	r2, [r3, #24]
 80046a8:	687b      	ldr	r3, [r7, #4]
 80046aa:	681b      	ldr	r3, [r3, #0]
 80046ac:	f042 0210 	orr.w	r2, r2, #16
 80046b0:	619a      	str	r2, [r3, #24]
 80046b2:	e000      	b.n	80046b6 <HAL_HCD_IRQHandler+0x21a>
      return;
 80046b4:	bf00      	nop
    }
  }
}
 80046b6:	3718      	adds	r7, #24
 80046b8:	46bd      	mov	sp, r7
 80046ba:	bd80      	pop	{r7, pc}

080046bc <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
 80046bc:	b580      	push	{r7, lr}
 80046be:	b082      	sub	sp, #8
 80046c0:	af00      	add	r7, sp, #0
 80046c2:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 80046c4:	687b      	ldr	r3, [r7, #4]
 80046c6:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 80046ca:	2b01      	cmp	r3, #1
 80046cc:	d101      	bne.n	80046d2 <HAL_HCD_Start+0x16>
 80046ce:	2302      	movs	r3, #2
 80046d0:	e013      	b.n	80046fa <HAL_HCD_Start+0x3e>
 80046d2:	687b      	ldr	r3, [r7, #4]
 80046d4:	2201      	movs	r2, #1
 80046d6:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  /* Enable port power */
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 80046da:	687b      	ldr	r3, [r7, #4]
 80046dc:	681b      	ldr	r3, [r3, #0]
 80046de:	2101      	movs	r1, #1
 80046e0:	4618      	mov	r0, r3
 80046e2:	f002 fe40 	bl	8007366 <USB_DriveVbus>

  /* Enable global interrupt */
  __HAL_HCD_ENABLE(hhcd);
 80046e6:	687b      	ldr	r3, [r7, #4]
 80046e8:	681b      	ldr	r3, [r3, #0]
 80046ea:	4618      	mov	r0, r3
 80046ec:	f002 fb38 	bl	8006d60 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hhcd);
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	2200      	movs	r2, #0
 80046f4:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return HAL_OK;
 80046f8:	2300      	movs	r3, #0
}
 80046fa:	4618      	mov	r0, r3
 80046fc:	3708      	adds	r7, #8
 80046fe:	46bd      	mov	sp, r7
 8004700:	bd80      	pop	{r7, pc}

08004702 <HAL_HCD_Stop>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
 8004702:	b580      	push	{r7, lr}
 8004704:	b082      	sub	sp, #8
 8004706:	af00      	add	r7, sp, #0
 8004708:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 800470a:	687b      	ldr	r3, [r7, #4]
 800470c:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8004710:	2b01      	cmp	r3, #1
 8004712:	d101      	bne.n	8004718 <HAL_HCD_Stop+0x16>
 8004714:	2302      	movs	r3, #2
 8004716:	e00d      	b.n	8004734 <HAL_HCD_Stop+0x32>
 8004718:	687b      	ldr	r3, [r7, #4]
 800471a:	2201      	movs	r2, #1
 800471c:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  (void)USB_StopHost(hhcd->Instance);
 8004720:	687b      	ldr	r3, [r7, #4]
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	4618      	mov	r0, r3
 8004726:	f003 fb93 	bl	8007e50 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800472a:	687b      	ldr	r3, [r7, #4]
 800472c:	2200      	movs	r2, #0
 800472e:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return HAL_OK;
 8004732:	2300      	movs	r3, #0
}
 8004734:	4618      	mov	r0, r3
 8004736:	3708      	adds	r7, #8
 8004738:	46bd      	mov	sp, r7
 800473a:	bd80      	pop	{r7, pc}

0800473c <HAL_HCD_ResetPort>:
  * @brief  Reset the host port.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
 800473c:	b580      	push	{r7, lr}
 800473e:	b082      	sub	sp, #8
 8004740:	af00      	add	r7, sp, #0
 8004742:	6078      	str	r0, [r7, #4]
  return (USB_ResetPort(hhcd->Instance));
 8004744:	687b      	ldr	r3, [r7, #4]
 8004746:	681b      	ldr	r3, [r3, #0]
 8004748:	4618      	mov	r0, r3
 800474a:	f002 fde2 	bl	8007312 <USB_ResetPort>
 800474e:	4603      	mov	r3, r0
}
 8004750:	4618      	mov	r0, r3
 8004752:	3708      	adds	r7, #8
 8004754:	46bd      	mov	sp, r7
 8004756:	bd80      	pop	{r7, pc}

08004758 <HAL_HCD_HC_GetURBState>:
  *            URB_NYET/
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef const *hhcd, uint8_t chnum)
{
 8004758:	b480      	push	{r7}
 800475a:	b083      	sub	sp, #12
 800475c:	af00      	add	r7, sp, #0
 800475e:	6078      	str	r0, [r7, #4]
 8004760:	460b      	mov	r3, r1
 8004762:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].urb_state;
 8004764:	78fa      	ldrb	r2, [r7, #3]
 8004766:	6879      	ldr	r1, [r7, #4]
 8004768:	4613      	mov	r3, r2
 800476a:	011b      	lsls	r3, r3, #4
 800476c:	1a9b      	subs	r3, r3, r2
 800476e:	009b      	lsls	r3, r3, #2
 8004770:	440b      	add	r3, r1
 8004772:	334c      	adds	r3, #76	@ 0x4c
 8004774:	781b      	ldrb	r3, [r3, #0]
}
 8004776:	4618      	mov	r0, r3
 8004778:	370c      	adds	r7, #12
 800477a:	46bd      	mov	sp, r7
 800477c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004780:	4770      	bx	lr

08004782 <HAL_HCD_HC_GetXferCount>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef const *hhcd, uint8_t chnum)
{
 8004782:	b480      	push	{r7}
 8004784:	b083      	sub	sp, #12
 8004786:	af00      	add	r7, sp, #0
 8004788:	6078      	str	r0, [r7, #4]
 800478a:	460b      	mov	r3, r1
 800478c:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].xfer_count;
 800478e:	78fa      	ldrb	r2, [r7, #3]
 8004790:	6879      	ldr	r1, [r7, #4]
 8004792:	4613      	mov	r3, r2
 8004794:	011b      	lsls	r3, r3, #4
 8004796:	1a9b      	subs	r3, r3, r2
 8004798:	009b      	lsls	r3, r3, #2
 800479a:	440b      	add	r3, r1
 800479c:	3338      	adds	r3, #56	@ 0x38
 800479e:	681b      	ldr	r3, [r3, #0]
}
 80047a0:	4618      	mov	r0, r3
 80047a2:	370c      	adds	r7, #12
 80047a4:	46bd      	mov	sp, r7
 80047a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80047aa:	4770      	bx	lr

080047ac <HAL_HCD_GetCurrentFrame>:
  * @brief  Return the current Host frame number.
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
 80047ac:	b580      	push	{r7, lr}
 80047ae:	b082      	sub	sp, #8
 80047b0:	af00      	add	r7, sp, #0
 80047b2:	6078      	str	r0, [r7, #4]
  return (USB_GetCurrentFrame(hhcd->Instance));
 80047b4:	687b      	ldr	r3, [r7, #4]
 80047b6:	681b      	ldr	r3, [r3, #0]
 80047b8:	4618      	mov	r0, r3
 80047ba:	f002 fe24 	bl	8007406 <USB_GetCurrentFrame>
 80047be:	4603      	mov	r3, r0
}
 80047c0:	4618      	mov	r0, r3
 80047c2:	3708      	adds	r7, #8
 80047c4:	46bd      	mov	sp, r7
 80047c6:	bd80      	pop	{r7, pc}

080047c8 <HAL_HCD_GetCurrentSpeed>:
  * @brief  Return the Host enumeration speed.
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
 80047c8:	b580      	push	{r7, lr}
 80047ca:	b082      	sub	sp, #8
 80047cc:	af00      	add	r7, sp, #0
 80047ce:	6078      	str	r0, [r7, #4]
  return (USB_GetHostSpeed(hhcd->Instance));
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	4618      	mov	r0, r3
 80047d6:	f002 fdff 	bl	80073d8 <USB_GetHostSpeed>
 80047da:	4603      	mov	r3, r0
}
 80047dc:	4618      	mov	r0, r3
 80047de:	3708      	adds	r7, #8
 80047e0:	46bd      	mov	sp, r7
 80047e2:	bd80      	pop	{r7, pc}

080047e4 <HAL_HCD_HC_ClearHubInfo>:
  * @param  ch_num Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_ClearHubInfo(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
 80047e4:	b480      	push	{r7}
 80047e6:	b083      	sub	sp, #12
 80047e8:	af00      	add	r7, sp, #0
 80047ea:	6078      	str	r0, [r7, #4]
 80047ec:	460b      	mov	r3, r1
 80047ee:	70fb      	strb	r3, [r7, #3]
  hhcd->hc[ch_num].do_ssplit = 0U;
 80047f0:	78fa      	ldrb	r2, [r7, #3]
 80047f2:	6879      	ldr	r1, [r7, #4]
 80047f4:	4613      	mov	r3, r2
 80047f6:	011b      	lsls	r3, r3, #4
 80047f8:	1a9b      	subs	r3, r3, r2
 80047fa:	009b      	lsls	r3, r3, #2
 80047fc:	440b      	add	r3, r1
 80047fe:	331a      	adds	r3, #26
 8004800:	2200      	movs	r2, #0
 8004802:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].do_csplit = 0U;
 8004804:	78fa      	ldrb	r2, [r7, #3]
 8004806:	6879      	ldr	r1, [r7, #4]
 8004808:	4613      	mov	r3, r2
 800480a:	011b      	lsls	r3, r3, #4
 800480c:	1a9b      	subs	r3, r3, r2
 800480e:	009b      	lsls	r3, r3, #2
 8004810:	440b      	add	r3, r1
 8004812:	331b      	adds	r3, #27
 8004814:	2200      	movs	r2, #0
 8004816:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].hub_addr = 0U;
 8004818:	78fa      	ldrb	r2, [r7, #3]
 800481a:	6879      	ldr	r1, [r7, #4]
 800481c:	4613      	mov	r3, r2
 800481e:	011b      	lsls	r3, r3, #4
 8004820:	1a9b      	subs	r3, r3, r2
 8004822:	009b      	lsls	r3, r3, #2
 8004824:	440b      	add	r3, r1
 8004826:	3325      	adds	r3, #37	@ 0x25
 8004828:	2200      	movs	r2, #0
 800482a:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 800482c:	78fa      	ldrb	r2, [r7, #3]
 800482e:	6879      	ldr	r1, [r7, #4]
 8004830:	4613      	mov	r3, r2
 8004832:	011b      	lsls	r3, r3, #4
 8004834:	1a9b      	subs	r3, r3, r2
 8004836:	009b      	lsls	r3, r3, #2
 8004838:	440b      	add	r3, r1
 800483a:	3324      	adds	r3, #36	@ 0x24
 800483c:	2200      	movs	r2, #0
 800483e:	701a      	strb	r2, [r3, #0]

  return HAL_OK;
 8004840:	2300      	movs	r3, #0
}
 8004842:	4618      	mov	r0, r3
 8004844:	370c      	adds	r7, #12
 8004846:	46bd      	mov	sp, r7
 8004848:	f85d 7b04 	ldr.w	r7, [sp], #4
 800484c:	4770      	bx	lr

0800484e <HCD_HC_IN_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 800484e:	b580      	push	{r7, lr}
 8004850:	b086      	sub	sp, #24
 8004852:	af00      	add	r7, sp, #0
 8004854:	6078      	str	r0, [r7, #4]
 8004856:	460b      	mov	r3, r1
 8004858:	70fb      	strb	r3, [r7, #3]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800485a:	687b      	ldr	r3, [r7, #4]
 800485c:	681b      	ldr	r3, [r3, #0]
 800485e:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004860:	697b      	ldr	r3, [r7, #20]
 8004862:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg;

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 8004864:	687b      	ldr	r3, [r7, #4]
 8004866:	681b      	ldr	r3, [r3, #0]
 8004868:	78fa      	ldrb	r2, [r7, #3]
 800486a:	4611      	mov	r1, r2
 800486c:	4618      	mov	r0, r3
 800486e:	f002 fbee 	bl	800704e <USB_ReadChInterrupts>
 8004872:	4603      	mov	r3, r0
 8004874:	f003 0304 	and.w	r3, r3, #4
 8004878:	2b04      	cmp	r3, #4
 800487a:	d11a      	bne.n	80048b2 <HCD_HC_IN_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 800487c:	78fb      	ldrb	r3, [r7, #3]
 800487e:	015a      	lsls	r2, r3, #5
 8004880:	693b      	ldr	r3, [r7, #16]
 8004882:	4413      	add	r3, r2
 8004884:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004888:	461a      	mov	r2, r3
 800488a:	2304      	movs	r3, #4
 800488c:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 800488e:	78fa      	ldrb	r2, [r7, #3]
 8004890:	6879      	ldr	r1, [r7, #4]
 8004892:	4613      	mov	r3, r2
 8004894:	011b      	lsls	r3, r3, #4
 8004896:	1a9b      	subs	r3, r3, r2
 8004898:	009b      	lsls	r3, r3, #2
 800489a:	440b      	add	r3, r1
 800489c:	334d      	adds	r3, #77	@ 0x4d
 800489e:	2207      	movs	r2, #7
 80048a0:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80048a2:	687b      	ldr	r3, [r7, #4]
 80048a4:	681b      	ldr	r3, [r3, #0]
 80048a6:	78fa      	ldrb	r2, [r7, #3]
 80048a8:	4611      	mov	r1, r2
 80048aa:	4618      	mov	r0, r3
 80048ac:	f003 f973 	bl	8007b96 <USB_HC_Halt>
 80048b0:	e09e      	b.n	80049f0 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_BBERR))
 80048b2:	687b      	ldr	r3, [r7, #4]
 80048b4:	681b      	ldr	r3, [r3, #0]
 80048b6:	78fa      	ldrb	r2, [r7, #3]
 80048b8:	4611      	mov	r1, r2
 80048ba:	4618      	mov	r0, r3
 80048bc:	f002 fbc7 	bl	800704e <USB_ReadChInterrupts>
 80048c0:	4603      	mov	r3, r0
 80048c2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80048c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80048ca:	d11b      	bne.n	8004904 <HCD_HC_IN_IRQHandler+0xb6>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_BBERR);
 80048cc:	78fb      	ldrb	r3, [r7, #3]
 80048ce:	015a      	lsls	r2, r3, #5
 80048d0:	693b      	ldr	r3, [r7, #16]
 80048d2:	4413      	add	r3, r2
 80048d4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80048d8:	461a      	mov	r2, r3
 80048da:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80048de:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_BBLERR;
 80048e0:	78fa      	ldrb	r2, [r7, #3]
 80048e2:	6879      	ldr	r1, [r7, #4]
 80048e4:	4613      	mov	r3, r2
 80048e6:	011b      	lsls	r3, r3, #4
 80048e8:	1a9b      	subs	r3, r3, r2
 80048ea:	009b      	lsls	r3, r3, #2
 80048ec:	440b      	add	r3, r1
 80048ee:	334d      	adds	r3, #77	@ 0x4d
 80048f0:	2208      	movs	r2, #8
 80048f2:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80048f4:	687b      	ldr	r3, [r7, #4]
 80048f6:	681b      	ldr	r3, [r3, #0]
 80048f8:	78fa      	ldrb	r2, [r7, #3]
 80048fa:	4611      	mov	r1, r2
 80048fc:	4618      	mov	r0, r3
 80048fe:	f003 f94a 	bl	8007b96 <USB_HC_Halt>
 8004902:	e075      	b.n	80049f0 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 8004904:	687b      	ldr	r3, [r7, #4]
 8004906:	681b      	ldr	r3, [r3, #0]
 8004908:	78fa      	ldrb	r2, [r7, #3]
 800490a:	4611      	mov	r1, r2
 800490c:	4618      	mov	r0, r3
 800490e:	f002 fb9e 	bl	800704e <USB_ReadChInterrupts>
 8004912:	4603      	mov	r3, r0
 8004914:	f003 0308 	and.w	r3, r3, #8
 8004918:	2b08      	cmp	r3, #8
 800491a:	d11a      	bne.n	8004952 <HCD_HC_IN_IRQHandler+0x104>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 800491c:	78fb      	ldrb	r3, [r7, #3]
 800491e:	015a      	lsls	r2, r3, #5
 8004920:	693b      	ldr	r3, [r7, #16]
 8004922:	4413      	add	r3, r2
 8004924:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004928:	461a      	mov	r2, r3
 800492a:	2308      	movs	r3, #8
 800492c:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_STALL;
 800492e:	78fa      	ldrb	r2, [r7, #3]
 8004930:	6879      	ldr	r1, [r7, #4]
 8004932:	4613      	mov	r3, r2
 8004934:	011b      	lsls	r3, r3, #4
 8004936:	1a9b      	subs	r3, r3, r2
 8004938:	009b      	lsls	r3, r3, #2
 800493a:	440b      	add	r3, r1
 800493c:	334d      	adds	r3, #77	@ 0x4d
 800493e:	2206      	movs	r2, #6
 8004940:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004942:	687b      	ldr	r3, [r7, #4]
 8004944:	681b      	ldr	r3, [r3, #0]
 8004946:	78fa      	ldrb	r2, [r7, #3]
 8004948:	4611      	mov	r1, r2
 800494a:	4618      	mov	r0, r3
 800494c:	f003 f923 	bl	8007b96 <USB_HC_Halt>
 8004950:	e04e      	b.n	80049f0 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8004952:	687b      	ldr	r3, [r7, #4]
 8004954:	681b      	ldr	r3, [r3, #0]
 8004956:	78fa      	ldrb	r2, [r7, #3]
 8004958:	4611      	mov	r1, r2
 800495a:	4618      	mov	r0, r3
 800495c:	f002 fb77 	bl	800704e <USB_ReadChInterrupts>
 8004960:	4603      	mov	r3, r0
 8004962:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004966:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800496a:	d11b      	bne.n	80049a4 <HCD_HC_IN_IRQHandler+0x156>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 800496c:	78fb      	ldrb	r3, [r7, #3]
 800496e:	015a      	lsls	r2, r3, #5
 8004970:	693b      	ldr	r3, [r7, #16]
 8004972:	4413      	add	r3, r2
 8004974:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004978:	461a      	mov	r2, r3
 800497a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800497e:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_DATATGLERR;
 8004980:	78fa      	ldrb	r2, [r7, #3]
 8004982:	6879      	ldr	r1, [r7, #4]
 8004984:	4613      	mov	r3, r2
 8004986:	011b      	lsls	r3, r3, #4
 8004988:	1a9b      	subs	r3, r3, r2
 800498a:	009b      	lsls	r3, r3, #2
 800498c:	440b      	add	r3, r1
 800498e:	334d      	adds	r3, #77	@ 0x4d
 8004990:	2209      	movs	r2, #9
 8004992:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004994:	687b      	ldr	r3, [r7, #4]
 8004996:	681b      	ldr	r3, [r3, #0]
 8004998:	78fa      	ldrb	r2, [r7, #3]
 800499a:	4611      	mov	r1, r2
 800499c:	4618      	mov	r0, r3
 800499e:	f003 f8fa 	bl	8007b96 <USB_HC_Halt>
 80049a2:	e025      	b.n	80049f0 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 80049a4:	687b      	ldr	r3, [r7, #4]
 80049a6:	681b      	ldr	r3, [r3, #0]
 80049a8:	78fa      	ldrb	r2, [r7, #3]
 80049aa:	4611      	mov	r1, r2
 80049ac:	4618      	mov	r0, r3
 80049ae:	f002 fb4e 	bl	800704e <USB_ReadChInterrupts>
 80049b2:	4603      	mov	r3, r0
 80049b4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80049b8:	2b80      	cmp	r3, #128	@ 0x80
 80049ba:	d119      	bne.n	80049f0 <HCD_HC_IN_IRQHandler+0x1a2>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 80049bc:	78fb      	ldrb	r3, [r7, #3]
 80049be:	015a      	lsls	r2, r3, #5
 80049c0:	693b      	ldr	r3, [r7, #16]
 80049c2:	4413      	add	r3, r2
 80049c4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80049c8:	461a      	mov	r2, r3
 80049ca:	2380      	movs	r3, #128	@ 0x80
 80049cc:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 80049ce:	78fa      	ldrb	r2, [r7, #3]
 80049d0:	6879      	ldr	r1, [r7, #4]
 80049d2:	4613      	mov	r3, r2
 80049d4:	011b      	lsls	r3, r3, #4
 80049d6:	1a9b      	subs	r3, r3, r2
 80049d8:	009b      	lsls	r3, r3, #2
 80049da:	440b      	add	r3, r1
 80049dc:	334d      	adds	r3, #77	@ 0x4d
 80049de:	2207      	movs	r2, #7
 80049e0:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80049e2:	687b      	ldr	r3, [r7, #4]
 80049e4:	681b      	ldr	r3, [r3, #0]
 80049e6:	78fa      	ldrb	r2, [r7, #3]
 80049e8:	4611      	mov	r1, r2
 80049ea:	4618      	mov	r0, r3
 80049ec:	f003 f8d3 	bl	8007b96 <USB_HC_Halt>
  else
  {
    /* ... */
  }

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 80049f0:	687b      	ldr	r3, [r7, #4]
 80049f2:	681b      	ldr	r3, [r3, #0]
 80049f4:	78fa      	ldrb	r2, [r7, #3]
 80049f6:	4611      	mov	r1, r2
 80049f8:	4618      	mov	r0, r3
 80049fa:	f002 fb28 	bl	800704e <USB_ReadChInterrupts>
 80049fe:	4603      	mov	r3, r0
 8004a00:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8004a04:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004a08:	d112      	bne.n	8004a30 <HCD_HC_IN_IRQHandler+0x1e2>
  {
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004a0a:	687b      	ldr	r3, [r7, #4]
 8004a0c:	681b      	ldr	r3, [r3, #0]
 8004a0e:	78fa      	ldrb	r2, [r7, #3]
 8004a10:	4611      	mov	r1, r2
 8004a12:	4618      	mov	r0, r3
 8004a14:	f003 f8bf 	bl	8007b96 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 8004a18:	78fb      	ldrb	r3, [r7, #3]
 8004a1a:	015a      	lsls	r2, r3, #5
 8004a1c:	693b      	ldr	r3, [r7, #16]
 8004a1e:	4413      	add	r3, r2
 8004a20:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004a24:	461a      	mov	r2, r3
 8004a26:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8004a2a:	6093      	str	r3, [r2, #8]
 8004a2c:	f000 bd75 	b.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 8004a30:	687b      	ldr	r3, [r7, #4]
 8004a32:	681b      	ldr	r3, [r3, #0]
 8004a34:	78fa      	ldrb	r2, [r7, #3]
 8004a36:	4611      	mov	r1, r2
 8004a38:	4618      	mov	r0, r3
 8004a3a:	f002 fb08 	bl	800704e <USB_ReadChInterrupts>
 8004a3e:	4603      	mov	r3, r0
 8004a40:	f003 0301 	and.w	r3, r3, #1
 8004a44:	2b01      	cmp	r3, #1
 8004a46:	f040 8128 	bne.w	8004c9a <HCD_HC_IN_IRQHandler+0x44c>
  {
    /* Clear any pending ACK IT */
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 8004a4a:	78fb      	ldrb	r3, [r7, #3]
 8004a4c:	015a      	lsls	r2, r3, #5
 8004a4e:	693b      	ldr	r3, [r7, #16]
 8004a50:	4413      	add	r3, r2
 8004a52:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004a56:	461a      	mov	r2, r3
 8004a58:	2320      	movs	r3, #32
 8004a5a:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_csplit == 1U)
 8004a5c:	78fa      	ldrb	r2, [r7, #3]
 8004a5e:	6879      	ldr	r1, [r7, #4]
 8004a60:	4613      	mov	r3, r2
 8004a62:	011b      	lsls	r3, r3, #4
 8004a64:	1a9b      	subs	r3, r3, r2
 8004a66:	009b      	lsls	r3, r3, #2
 8004a68:	440b      	add	r3, r1
 8004a6a:	331b      	adds	r3, #27
 8004a6c:	781b      	ldrb	r3, [r3, #0]
 8004a6e:	2b01      	cmp	r3, #1
 8004a70:	d119      	bne.n	8004aa6 <HCD_HC_IN_IRQHandler+0x258>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 8004a72:	78fa      	ldrb	r2, [r7, #3]
 8004a74:	6879      	ldr	r1, [r7, #4]
 8004a76:	4613      	mov	r3, r2
 8004a78:	011b      	lsls	r3, r3, #4
 8004a7a:	1a9b      	subs	r3, r3, r2
 8004a7c:	009b      	lsls	r3, r3, #2
 8004a7e:	440b      	add	r3, r1
 8004a80:	331b      	adds	r3, #27
 8004a82:	2200      	movs	r2, #0
 8004a84:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8004a86:	78fb      	ldrb	r3, [r7, #3]
 8004a88:	015a      	lsls	r2, r3, #5
 8004a8a:	693b      	ldr	r3, [r7, #16]
 8004a8c:	4413      	add	r3, r2
 8004a8e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004a92:	685b      	ldr	r3, [r3, #4]
 8004a94:	78fa      	ldrb	r2, [r7, #3]
 8004a96:	0151      	lsls	r1, r2, #5
 8004a98:	693a      	ldr	r2, [r7, #16]
 8004a9a:	440a      	add	r2, r1
 8004a9c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004aa0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004aa4:	6053      	str	r3, [r2, #4]
    }

    if (hhcd->Init.dma_enable != 0U)
 8004aa6:	687b      	ldr	r3, [r7, #4]
 8004aa8:	799b      	ldrb	r3, [r3, #6]
 8004aaa:	2b00      	cmp	r3, #0
 8004aac:	d01b      	beq.n	8004ae6 <HCD_HC_IN_IRQHandler+0x298>
    {
      hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].XferSize - (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8004aae:	78fa      	ldrb	r2, [r7, #3]
 8004ab0:	6879      	ldr	r1, [r7, #4]
 8004ab2:	4613      	mov	r3, r2
 8004ab4:	011b      	lsls	r3, r3, #4
 8004ab6:	1a9b      	subs	r3, r3, r2
 8004ab8:	009b      	lsls	r3, r3, #2
 8004aba:	440b      	add	r3, r1
 8004abc:	3330      	adds	r3, #48	@ 0x30
 8004abe:	6819      	ldr	r1, [r3, #0]
 8004ac0:	78fb      	ldrb	r3, [r7, #3]
 8004ac2:	015a      	lsls	r2, r3, #5
 8004ac4:	693b      	ldr	r3, [r7, #16]
 8004ac6:	4413      	add	r3, r2
 8004ac8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004acc:	691b      	ldr	r3, [r3, #16]
 8004ace:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8004ad2:	78fa      	ldrb	r2, [r7, #3]
 8004ad4:	1ac9      	subs	r1, r1, r3
 8004ad6:	6878      	ldr	r0, [r7, #4]
 8004ad8:	4613      	mov	r3, r2
 8004ada:	011b      	lsls	r3, r3, #4
 8004adc:	1a9b      	subs	r3, r3, r2
 8004ade:	009b      	lsls	r3, r3, #2
 8004ae0:	4403      	add	r3, r0
 8004ae2:	3338      	adds	r3, #56	@ 0x38
 8004ae4:	6019      	str	r1, [r3, #0]
    }

    hhcd->hc[chnum].state = HC_XFRC;
 8004ae6:	78fa      	ldrb	r2, [r7, #3]
 8004ae8:	6879      	ldr	r1, [r7, #4]
 8004aea:	4613      	mov	r3, r2
 8004aec:	011b      	lsls	r3, r3, #4
 8004aee:	1a9b      	subs	r3, r3, r2
 8004af0:	009b      	lsls	r3, r3, #2
 8004af2:	440b      	add	r3, r1
 8004af4:	334d      	adds	r3, #77	@ 0x4d
 8004af6:	2201      	movs	r2, #1
 8004af8:	701a      	strb	r2, [r3, #0]
    hhcd->hc[chnum].ErrCnt = 0U;
 8004afa:	78fa      	ldrb	r2, [r7, #3]
 8004afc:	6879      	ldr	r1, [r7, #4]
 8004afe:	4613      	mov	r3, r2
 8004b00:	011b      	lsls	r3, r3, #4
 8004b02:	1a9b      	subs	r3, r3, r2
 8004b04:	009b      	lsls	r3, r3, #2
 8004b06:	440b      	add	r3, r1
 8004b08:	3344      	adds	r3, #68	@ 0x44
 8004b0a:	2200      	movs	r2, #0
 8004b0c:	601a      	str	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8004b0e:	78fb      	ldrb	r3, [r7, #3]
 8004b10:	015a      	lsls	r2, r3, #5
 8004b12:	693b      	ldr	r3, [r7, #16]
 8004b14:	4413      	add	r3, r2
 8004b16:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004b1a:	461a      	mov	r2, r3
 8004b1c:	2301      	movs	r3, #1
 8004b1e:	6093      	str	r3, [r2, #8]

    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004b20:	78fa      	ldrb	r2, [r7, #3]
 8004b22:	6879      	ldr	r1, [r7, #4]
 8004b24:	4613      	mov	r3, r2
 8004b26:	011b      	lsls	r3, r3, #4
 8004b28:	1a9b      	subs	r3, r3, r2
 8004b2a:	009b      	lsls	r3, r3, #2
 8004b2c:	440b      	add	r3, r1
 8004b2e:	3326      	adds	r3, #38	@ 0x26
 8004b30:	781b      	ldrb	r3, [r3, #0]
 8004b32:	2b00      	cmp	r3, #0
 8004b34:	d00a      	beq.n	8004b4c <HCD_HC_IN_IRQHandler+0x2fe>
        (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8004b36:	78fa      	ldrb	r2, [r7, #3]
 8004b38:	6879      	ldr	r1, [r7, #4]
 8004b3a:	4613      	mov	r3, r2
 8004b3c:	011b      	lsls	r3, r3, #4
 8004b3e:	1a9b      	subs	r3, r3, r2
 8004b40:	009b      	lsls	r3, r3, #2
 8004b42:	440b      	add	r3, r1
 8004b44:	3326      	adds	r3, #38	@ 0x26
 8004b46:	781b      	ldrb	r3, [r3, #0]
    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004b48:	2b02      	cmp	r3, #2
 8004b4a:	d110      	bne.n	8004b6e <HCD_HC_IN_IRQHandler+0x320>
    {
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004b4c:	687b      	ldr	r3, [r7, #4]
 8004b4e:	681b      	ldr	r3, [r3, #0]
 8004b50:	78fa      	ldrb	r2, [r7, #3]
 8004b52:	4611      	mov	r1, r2
 8004b54:	4618      	mov	r0, r3
 8004b56:	f003 f81e 	bl	8007b96 <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8004b5a:	78fb      	ldrb	r3, [r7, #3]
 8004b5c:	015a      	lsls	r2, r3, #5
 8004b5e:	693b      	ldr	r3, [r7, #16]
 8004b60:	4413      	add	r3, r2
 8004b62:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004b66:	461a      	mov	r2, r3
 8004b68:	2310      	movs	r3, #16
 8004b6a:	6093      	str	r3, [r2, #8]
 8004b6c:	e03d      	b.n	8004bea <HCD_HC_IN_IRQHandler+0x39c>
    }
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_INTR) ||
 8004b6e:	78fa      	ldrb	r2, [r7, #3]
 8004b70:	6879      	ldr	r1, [r7, #4]
 8004b72:	4613      	mov	r3, r2
 8004b74:	011b      	lsls	r3, r3, #4
 8004b76:	1a9b      	subs	r3, r3, r2
 8004b78:	009b      	lsls	r3, r3, #2
 8004b7a:	440b      	add	r3, r1
 8004b7c:	3326      	adds	r3, #38	@ 0x26
 8004b7e:	781b      	ldrb	r3, [r3, #0]
 8004b80:	2b03      	cmp	r3, #3
 8004b82:	d00a      	beq.n	8004b9a <HCD_HC_IN_IRQHandler+0x34c>
             (hhcd->hc[chnum].ep_type == EP_TYPE_ISOC))
 8004b84:	78fa      	ldrb	r2, [r7, #3]
 8004b86:	6879      	ldr	r1, [r7, #4]
 8004b88:	4613      	mov	r3, r2
 8004b8a:	011b      	lsls	r3, r3, #4
 8004b8c:	1a9b      	subs	r3, r3, r2
 8004b8e:	009b      	lsls	r3, r3, #2
 8004b90:	440b      	add	r3, r1
 8004b92:	3326      	adds	r3, #38	@ 0x26
 8004b94:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_INTR) ||
 8004b96:	2b01      	cmp	r3, #1
 8004b98:	d127      	bne.n	8004bea <HCD_HC_IN_IRQHandler+0x39c>
    {
      USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8004b9a:	78fb      	ldrb	r3, [r7, #3]
 8004b9c:	015a      	lsls	r2, r3, #5
 8004b9e:	693b      	ldr	r3, [r7, #16]
 8004ba0:	4413      	add	r3, r2
 8004ba2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004ba6:	681b      	ldr	r3, [r3, #0]
 8004ba8:	78fa      	ldrb	r2, [r7, #3]
 8004baa:	0151      	lsls	r1, r2, #5
 8004bac:	693a      	ldr	r2, [r7, #16]
 8004bae:	440a      	add	r2, r1
 8004bb0:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004bb4:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8004bb8:	6013      	str	r3, [r2, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 8004bba:	78fa      	ldrb	r2, [r7, #3]
 8004bbc:	6879      	ldr	r1, [r7, #4]
 8004bbe:	4613      	mov	r3, r2
 8004bc0:	011b      	lsls	r3, r3, #4
 8004bc2:	1a9b      	subs	r3, r3, r2
 8004bc4:	009b      	lsls	r3, r3, #2
 8004bc6:	440b      	add	r3, r1
 8004bc8:	334c      	adds	r3, #76	@ 0x4c
 8004bca:	2201      	movs	r2, #1
 8004bcc:	701a      	strb	r2, [r3, #0]

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8004bce:	78fa      	ldrb	r2, [r7, #3]
 8004bd0:	6879      	ldr	r1, [r7, #4]
 8004bd2:	4613      	mov	r3, r2
 8004bd4:	011b      	lsls	r3, r3, #4
 8004bd6:	1a9b      	subs	r3, r3, r2
 8004bd8:	009b      	lsls	r3, r3, #2
 8004bda:	440b      	add	r3, r1
 8004bdc:	334c      	adds	r3, #76	@ 0x4c
 8004bde:	781a      	ldrb	r2, [r3, #0]
 8004be0:	78fb      	ldrb	r3, [r7, #3]
 8004be2:	4619      	mov	r1, r3
 8004be4:	6878      	ldr	r0, [r7, #4]
 8004be6:	f028 f9bb 	bl	802cf60 <HAL_HCD_HC_NotifyURBChange_Callback>
    else
    {
      /* ... */
    }

    if (hhcd->Init.dma_enable == 1U)
 8004bea:	687b      	ldr	r3, [r7, #4]
 8004bec:	799b      	ldrb	r3, [r3, #6]
 8004bee:	2b01      	cmp	r3, #1
 8004bf0:	d13b      	bne.n	8004c6a <HCD_HC_IN_IRQHandler+0x41c>
    {
      if ((((hhcd->hc[chnum].xfer_count + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet) & 1U) != 0U)
 8004bf2:	78fa      	ldrb	r2, [r7, #3]
 8004bf4:	6879      	ldr	r1, [r7, #4]
 8004bf6:	4613      	mov	r3, r2
 8004bf8:	011b      	lsls	r3, r3, #4
 8004bfa:	1a9b      	subs	r3, r3, r2
 8004bfc:	009b      	lsls	r3, r3, #2
 8004bfe:	440b      	add	r3, r1
 8004c00:	3338      	adds	r3, #56	@ 0x38
 8004c02:	6819      	ldr	r1, [r3, #0]
 8004c04:	78fa      	ldrb	r2, [r7, #3]
 8004c06:	6878      	ldr	r0, [r7, #4]
 8004c08:	4613      	mov	r3, r2
 8004c0a:	011b      	lsls	r3, r3, #4
 8004c0c:	1a9b      	subs	r3, r3, r2
 8004c0e:	009b      	lsls	r3, r3, #2
 8004c10:	4403      	add	r3, r0
 8004c12:	3328      	adds	r3, #40	@ 0x28
 8004c14:	881b      	ldrh	r3, [r3, #0]
 8004c16:	440b      	add	r3, r1
 8004c18:	1e59      	subs	r1, r3, #1
 8004c1a:	78fa      	ldrb	r2, [r7, #3]
 8004c1c:	6878      	ldr	r0, [r7, #4]
 8004c1e:	4613      	mov	r3, r2
 8004c20:	011b      	lsls	r3, r3, #4
 8004c22:	1a9b      	subs	r3, r3, r2
 8004c24:	009b      	lsls	r3, r3, #2
 8004c26:	4403      	add	r3, r0
 8004c28:	3328      	adds	r3, #40	@ 0x28
 8004c2a:	881b      	ldrh	r3, [r3, #0]
 8004c2c:	fbb1 f3f3 	udiv	r3, r1, r3
 8004c30:	f003 0301 	and.w	r3, r3, #1
 8004c34:	2b00      	cmp	r3, #0
 8004c36:	f000 8470 	beq.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
      {
        hhcd->hc[chnum].toggle_in ^= 1U;
 8004c3a:	78fa      	ldrb	r2, [r7, #3]
 8004c3c:	6879      	ldr	r1, [r7, #4]
 8004c3e:	4613      	mov	r3, r2
 8004c40:	011b      	lsls	r3, r3, #4
 8004c42:	1a9b      	subs	r3, r3, r2
 8004c44:	009b      	lsls	r3, r3, #2
 8004c46:	440b      	add	r3, r1
 8004c48:	333c      	adds	r3, #60	@ 0x3c
 8004c4a:	781b      	ldrb	r3, [r3, #0]
 8004c4c:	78fa      	ldrb	r2, [r7, #3]
 8004c4e:	f083 0301 	eor.w	r3, r3, #1
 8004c52:	b2d8      	uxtb	r0, r3
 8004c54:	6879      	ldr	r1, [r7, #4]
 8004c56:	4613      	mov	r3, r2
 8004c58:	011b      	lsls	r3, r3, #4
 8004c5a:	1a9b      	subs	r3, r3, r2
 8004c5c:	009b      	lsls	r3, r3, #2
 8004c5e:	440b      	add	r3, r1
 8004c60:	333c      	adds	r3, #60	@ 0x3c
 8004c62:	4602      	mov	r2, r0
 8004c64:	701a      	strb	r2, [r3, #0]
 8004c66:	f000 bc58 	b.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
      }
    }
    else
    {
      hhcd->hc[chnum].toggle_in ^= 1U;
 8004c6a:	78fa      	ldrb	r2, [r7, #3]
 8004c6c:	6879      	ldr	r1, [r7, #4]
 8004c6e:	4613      	mov	r3, r2
 8004c70:	011b      	lsls	r3, r3, #4
 8004c72:	1a9b      	subs	r3, r3, r2
 8004c74:	009b      	lsls	r3, r3, #2
 8004c76:	440b      	add	r3, r1
 8004c78:	333c      	adds	r3, #60	@ 0x3c
 8004c7a:	781b      	ldrb	r3, [r3, #0]
 8004c7c:	78fa      	ldrb	r2, [r7, #3]
 8004c7e:	f083 0301 	eor.w	r3, r3, #1
 8004c82:	b2d8      	uxtb	r0, r3
 8004c84:	6879      	ldr	r1, [r7, #4]
 8004c86:	4613      	mov	r3, r2
 8004c88:	011b      	lsls	r3, r3, #4
 8004c8a:	1a9b      	subs	r3, r3, r2
 8004c8c:	009b      	lsls	r3, r3, #2
 8004c8e:	440b      	add	r3, r1
 8004c90:	333c      	adds	r3, #60	@ 0x3c
 8004c92:	4602      	mov	r2, r0
 8004c94:	701a      	strb	r2, [r3, #0]
 8004c96:	f000 bc40 	b.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 8004c9a:	687b      	ldr	r3, [r7, #4]
 8004c9c:	681b      	ldr	r3, [r3, #0]
 8004c9e:	78fa      	ldrb	r2, [r7, #3]
 8004ca0:	4611      	mov	r1, r2
 8004ca2:	4618      	mov	r0, r3
 8004ca4:	f002 f9d3 	bl	800704e <USB_ReadChInterrupts>
 8004ca8:	4603      	mov	r3, r0
 8004caa:	f003 0320 	and.w	r3, r3, #32
 8004cae:	2b20      	cmp	r3, #32
 8004cb0:	d131      	bne.n	8004d16 <HCD_HC_IN_IRQHandler+0x4c8>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 8004cb2:	78fb      	ldrb	r3, [r7, #3]
 8004cb4:	015a      	lsls	r2, r3, #5
 8004cb6:	693b      	ldr	r3, [r7, #16]
 8004cb8:	4413      	add	r3, r2
 8004cba:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004cbe:	461a      	mov	r2, r3
 8004cc0:	2320      	movs	r3, #32
 8004cc2:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_ssplit == 1U)
 8004cc4:	78fa      	ldrb	r2, [r7, #3]
 8004cc6:	6879      	ldr	r1, [r7, #4]
 8004cc8:	4613      	mov	r3, r2
 8004cca:	011b      	lsls	r3, r3, #4
 8004ccc:	1a9b      	subs	r3, r3, r2
 8004cce:	009b      	lsls	r3, r3, #2
 8004cd0:	440b      	add	r3, r1
 8004cd2:	331a      	adds	r3, #26
 8004cd4:	781b      	ldrb	r3, [r3, #0]
 8004cd6:	2b01      	cmp	r3, #1
 8004cd8:	f040 841f 	bne.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
    {
      hhcd->hc[chnum].do_csplit = 1U;
 8004cdc:	78fa      	ldrb	r2, [r7, #3]
 8004cde:	6879      	ldr	r1, [r7, #4]
 8004ce0:	4613      	mov	r3, r2
 8004ce2:	011b      	lsls	r3, r3, #4
 8004ce4:	1a9b      	subs	r3, r3, r2
 8004ce6:	009b      	lsls	r3, r3, #2
 8004ce8:	440b      	add	r3, r1
 8004cea:	331b      	adds	r3, #27
 8004cec:	2201      	movs	r2, #1
 8004cee:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_ACK;
 8004cf0:	78fa      	ldrb	r2, [r7, #3]
 8004cf2:	6879      	ldr	r1, [r7, #4]
 8004cf4:	4613      	mov	r3, r2
 8004cf6:	011b      	lsls	r3, r3, #4
 8004cf8:	1a9b      	subs	r3, r3, r2
 8004cfa:	009b      	lsls	r3, r3, #2
 8004cfc:	440b      	add	r3, r1
 8004cfe:	334d      	adds	r3, #77	@ 0x4d
 8004d00:	2203      	movs	r2, #3
 8004d02:	701a      	strb	r2, [r3, #0]

      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004d04:	687b      	ldr	r3, [r7, #4]
 8004d06:	681b      	ldr	r3, [r3, #0]
 8004d08:	78fa      	ldrb	r2, [r7, #3]
 8004d0a:	4611      	mov	r1, r2
 8004d0c:	4618      	mov	r0, r3
 8004d0e:	f002 ff42 	bl	8007b96 <USB_HC_Halt>
 8004d12:	f000 bc02 	b.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 8004d16:	687b      	ldr	r3, [r7, #4]
 8004d18:	681b      	ldr	r3, [r3, #0]
 8004d1a:	78fa      	ldrb	r2, [r7, #3]
 8004d1c:	4611      	mov	r1, r2
 8004d1e:	4618      	mov	r0, r3
 8004d20:	f002 f995 	bl	800704e <USB_ReadChInterrupts>
 8004d24:	4603      	mov	r3, r0
 8004d26:	f003 0302 	and.w	r3, r3, #2
 8004d2a:	2b02      	cmp	r3, #2
 8004d2c:	f040 8305 	bne.w	800533a <HCD_HC_IN_IRQHandler+0xaec>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 8004d30:	78fb      	ldrb	r3, [r7, #3]
 8004d32:	015a      	lsls	r2, r3, #5
 8004d34:	693b      	ldr	r3, [r7, #16]
 8004d36:	4413      	add	r3, r2
 8004d38:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004d3c:	461a      	mov	r2, r3
 8004d3e:	2302      	movs	r3, #2
 8004d40:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].state == HC_XFRC)
 8004d42:	78fa      	ldrb	r2, [r7, #3]
 8004d44:	6879      	ldr	r1, [r7, #4]
 8004d46:	4613      	mov	r3, r2
 8004d48:	011b      	lsls	r3, r3, #4
 8004d4a:	1a9b      	subs	r3, r3, r2
 8004d4c:	009b      	lsls	r3, r3, #2
 8004d4e:	440b      	add	r3, r1
 8004d50:	334d      	adds	r3, #77	@ 0x4d
 8004d52:	781b      	ldrb	r3, [r3, #0]
 8004d54:	2b01      	cmp	r3, #1
 8004d56:	d114      	bne.n	8004d82 <HCD_HC_IN_IRQHandler+0x534>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004d58:	78fa      	ldrb	r2, [r7, #3]
 8004d5a:	6879      	ldr	r1, [r7, #4]
 8004d5c:	4613      	mov	r3, r2
 8004d5e:	011b      	lsls	r3, r3, #4
 8004d60:	1a9b      	subs	r3, r3, r2
 8004d62:	009b      	lsls	r3, r3, #2
 8004d64:	440b      	add	r3, r1
 8004d66:	334d      	adds	r3, #77	@ 0x4d
 8004d68:	2202      	movs	r2, #2
 8004d6a:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 8004d6c:	78fa      	ldrb	r2, [r7, #3]
 8004d6e:	6879      	ldr	r1, [r7, #4]
 8004d70:	4613      	mov	r3, r2
 8004d72:	011b      	lsls	r3, r3, #4
 8004d74:	1a9b      	subs	r3, r3, r2
 8004d76:	009b      	lsls	r3, r3, #2
 8004d78:	440b      	add	r3, r1
 8004d7a:	334c      	adds	r3, #76	@ 0x4c
 8004d7c:	2201      	movs	r2, #1
 8004d7e:	701a      	strb	r2, [r3, #0]
 8004d80:	e2cc      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
    }
    else if (hhcd->hc[chnum].state == HC_STALL)
 8004d82:	78fa      	ldrb	r2, [r7, #3]
 8004d84:	6879      	ldr	r1, [r7, #4]
 8004d86:	4613      	mov	r3, r2
 8004d88:	011b      	lsls	r3, r3, #4
 8004d8a:	1a9b      	subs	r3, r3, r2
 8004d8c:	009b      	lsls	r3, r3, #2
 8004d8e:	440b      	add	r3, r1
 8004d90:	334d      	adds	r3, #77	@ 0x4d
 8004d92:	781b      	ldrb	r3, [r3, #0]
 8004d94:	2b06      	cmp	r3, #6
 8004d96:	d114      	bne.n	8004dc2 <HCD_HC_IN_IRQHandler+0x574>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004d98:	78fa      	ldrb	r2, [r7, #3]
 8004d9a:	6879      	ldr	r1, [r7, #4]
 8004d9c:	4613      	mov	r3, r2
 8004d9e:	011b      	lsls	r3, r3, #4
 8004da0:	1a9b      	subs	r3, r3, r2
 8004da2:	009b      	lsls	r3, r3, #2
 8004da4:	440b      	add	r3, r1
 8004da6:	334d      	adds	r3, #77	@ 0x4d
 8004da8:	2202      	movs	r2, #2
 8004daa:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_STALL;
 8004dac:	78fa      	ldrb	r2, [r7, #3]
 8004dae:	6879      	ldr	r1, [r7, #4]
 8004db0:	4613      	mov	r3, r2
 8004db2:	011b      	lsls	r3, r3, #4
 8004db4:	1a9b      	subs	r3, r3, r2
 8004db6:	009b      	lsls	r3, r3, #2
 8004db8:	440b      	add	r3, r1
 8004dba:	334c      	adds	r3, #76	@ 0x4c
 8004dbc:	2205      	movs	r2, #5
 8004dbe:	701a      	strb	r2, [r3, #0]
 8004dc0:	e2ac      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
    }
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8004dc2:	78fa      	ldrb	r2, [r7, #3]
 8004dc4:	6879      	ldr	r1, [r7, #4]
 8004dc6:	4613      	mov	r3, r2
 8004dc8:	011b      	lsls	r3, r3, #4
 8004dca:	1a9b      	subs	r3, r3, r2
 8004dcc:	009b      	lsls	r3, r3, #2
 8004dce:	440b      	add	r3, r1
 8004dd0:	334d      	adds	r3, #77	@ 0x4d
 8004dd2:	781b      	ldrb	r3, [r3, #0]
 8004dd4:	2b07      	cmp	r3, #7
 8004dd6:	d00b      	beq.n	8004df0 <HCD_HC_IN_IRQHandler+0x5a2>
             (hhcd->hc[chnum].state == HC_DATATGLERR))
 8004dd8:	78fa      	ldrb	r2, [r7, #3]
 8004dda:	6879      	ldr	r1, [r7, #4]
 8004ddc:	4613      	mov	r3, r2
 8004dde:	011b      	lsls	r3, r3, #4
 8004de0:	1a9b      	subs	r3, r3, r2
 8004de2:	009b      	lsls	r3, r3, #2
 8004de4:	440b      	add	r3, r1
 8004de6:	334d      	adds	r3, #77	@ 0x4d
 8004de8:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8004dea:	2b09      	cmp	r3, #9
 8004dec:	f040 80a6 	bne.w	8004f3c <HCD_HC_IN_IRQHandler+0x6ee>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004df0:	78fa      	ldrb	r2, [r7, #3]
 8004df2:	6879      	ldr	r1, [r7, #4]
 8004df4:	4613      	mov	r3, r2
 8004df6:	011b      	lsls	r3, r3, #4
 8004df8:	1a9b      	subs	r3, r3, r2
 8004dfa:	009b      	lsls	r3, r3, #2
 8004dfc:	440b      	add	r3, r1
 8004dfe:	334d      	adds	r3, #77	@ 0x4d
 8004e00:	2202      	movs	r2, #2
 8004e02:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 8004e04:	78fa      	ldrb	r2, [r7, #3]
 8004e06:	6879      	ldr	r1, [r7, #4]
 8004e08:	4613      	mov	r3, r2
 8004e0a:	011b      	lsls	r3, r3, #4
 8004e0c:	1a9b      	subs	r3, r3, r2
 8004e0e:	009b      	lsls	r3, r3, #2
 8004e10:	440b      	add	r3, r1
 8004e12:	3344      	adds	r3, #68	@ 0x44
 8004e14:	681b      	ldr	r3, [r3, #0]
 8004e16:	1c59      	adds	r1, r3, #1
 8004e18:	6878      	ldr	r0, [r7, #4]
 8004e1a:	4613      	mov	r3, r2
 8004e1c:	011b      	lsls	r3, r3, #4
 8004e1e:	1a9b      	subs	r3, r3, r2
 8004e20:	009b      	lsls	r3, r3, #2
 8004e22:	4403      	add	r3, r0
 8004e24:	3344      	adds	r3, #68	@ 0x44
 8004e26:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004e28:	78fa      	ldrb	r2, [r7, #3]
 8004e2a:	6879      	ldr	r1, [r7, #4]
 8004e2c:	4613      	mov	r3, r2
 8004e2e:	011b      	lsls	r3, r3, #4
 8004e30:	1a9b      	subs	r3, r3, r2
 8004e32:	009b      	lsls	r3, r3, #2
 8004e34:	440b      	add	r3, r1
 8004e36:	3344      	adds	r3, #68	@ 0x44
 8004e38:	681b      	ldr	r3, [r3, #0]
 8004e3a:	2b02      	cmp	r3, #2
 8004e3c:	d943      	bls.n	8004ec6 <HCD_HC_IN_IRQHandler+0x678>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 8004e3e:	78fa      	ldrb	r2, [r7, #3]
 8004e40:	6879      	ldr	r1, [r7, #4]
 8004e42:	4613      	mov	r3, r2
 8004e44:	011b      	lsls	r3, r3, #4
 8004e46:	1a9b      	subs	r3, r3, r2
 8004e48:	009b      	lsls	r3, r3, #2
 8004e4a:	440b      	add	r3, r1
 8004e4c:	3344      	adds	r3, #68	@ 0x44
 8004e4e:	2200      	movs	r2, #0
 8004e50:	601a      	str	r2, [r3, #0]

        if (hhcd->hc[chnum].do_ssplit == 1U)
 8004e52:	78fa      	ldrb	r2, [r7, #3]
 8004e54:	6879      	ldr	r1, [r7, #4]
 8004e56:	4613      	mov	r3, r2
 8004e58:	011b      	lsls	r3, r3, #4
 8004e5a:	1a9b      	subs	r3, r3, r2
 8004e5c:	009b      	lsls	r3, r3, #2
 8004e5e:	440b      	add	r3, r1
 8004e60:	331a      	adds	r3, #26
 8004e62:	781b      	ldrb	r3, [r3, #0]
 8004e64:	2b01      	cmp	r3, #1
 8004e66:	d123      	bne.n	8004eb0 <HCD_HC_IN_IRQHandler+0x662>
        {
          hhcd->hc[chnum].do_csplit = 0U;
 8004e68:	78fa      	ldrb	r2, [r7, #3]
 8004e6a:	6879      	ldr	r1, [r7, #4]
 8004e6c:	4613      	mov	r3, r2
 8004e6e:	011b      	lsls	r3, r3, #4
 8004e70:	1a9b      	subs	r3, r3, r2
 8004e72:	009b      	lsls	r3, r3, #2
 8004e74:	440b      	add	r3, r1
 8004e76:	331b      	adds	r3, #27
 8004e78:	2200      	movs	r2, #0
 8004e7a:	701a      	strb	r2, [r3, #0]
          hhcd->hc[chnum].ep_ss_schedule = 0U;
 8004e7c:	78fa      	ldrb	r2, [r7, #3]
 8004e7e:	6879      	ldr	r1, [r7, #4]
 8004e80:	4613      	mov	r3, r2
 8004e82:	011b      	lsls	r3, r3, #4
 8004e84:	1a9b      	subs	r3, r3, r2
 8004e86:	009b      	lsls	r3, r3, #2
 8004e88:	440b      	add	r3, r1
 8004e8a:	331c      	adds	r3, #28
 8004e8c:	2200      	movs	r2, #0
 8004e8e:	701a      	strb	r2, [r3, #0]
          __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8004e90:	78fb      	ldrb	r3, [r7, #3]
 8004e92:	015a      	lsls	r2, r3, #5
 8004e94:	693b      	ldr	r3, [r7, #16]
 8004e96:	4413      	add	r3, r2
 8004e98:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004e9c:	685b      	ldr	r3, [r3, #4]
 8004e9e:	78fa      	ldrb	r2, [r7, #3]
 8004ea0:	0151      	lsls	r1, r2, #5
 8004ea2:	693a      	ldr	r2, [r7, #16]
 8004ea4:	440a      	add	r2, r1
 8004ea6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004eaa:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004eae:	6053      	str	r3, [r2, #4]
        }

        hhcd->hc[chnum].urb_state = URB_ERROR;
 8004eb0:	78fa      	ldrb	r2, [r7, #3]
 8004eb2:	6879      	ldr	r1, [r7, #4]
 8004eb4:	4613      	mov	r3, r2
 8004eb6:	011b      	lsls	r3, r3, #4
 8004eb8:	1a9b      	subs	r3, r3, r2
 8004eba:	009b      	lsls	r3, r3, #2
 8004ebc:	440b      	add	r3, r1
 8004ebe:	334c      	adds	r3, #76	@ 0x4c
 8004ec0:	2204      	movs	r2, #4
 8004ec2:	701a      	strb	r2, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004ec4:	e229      	b.n	800531a <HCD_HC_IN_IRQHandler+0xacc>
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8004ec6:	78fa      	ldrb	r2, [r7, #3]
 8004ec8:	6879      	ldr	r1, [r7, #4]
 8004eca:	4613      	mov	r3, r2
 8004ecc:	011b      	lsls	r3, r3, #4
 8004ece:	1a9b      	subs	r3, r3, r2
 8004ed0:	009b      	lsls	r3, r3, #2
 8004ed2:	440b      	add	r3, r1
 8004ed4:	334c      	adds	r3, #76	@ 0x4c
 8004ed6:	2202      	movs	r2, #2
 8004ed8:	701a      	strb	r2, [r3, #0]

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004eda:	78fa      	ldrb	r2, [r7, #3]
 8004edc:	6879      	ldr	r1, [r7, #4]
 8004ede:	4613      	mov	r3, r2
 8004ee0:	011b      	lsls	r3, r3, #4
 8004ee2:	1a9b      	subs	r3, r3, r2
 8004ee4:	009b      	lsls	r3, r3, #2
 8004ee6:	440b      	add	r3, r1
 8004ee8:	3326      	adds	r3, #38	@ 0x26
 8004eea:	781b      	ldrb	r3, [r3, #0]
 8004eec:	2b00      	cmp	r3, #0
 8004eee:	d00b      	beq.n	8004f08 <HCD_HC_IN_IRQHandler+0x6ba>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8004ef0:	78fa      	ldrb	r2, [r7, #3]
 8004ef2:	6879      	ldr	r1, [r7, #4]
 8004ef4:	4613      	mov	r3, r2
 8004ef6:	011b      	lsls	r3, r3, #4
 8004ef8:	1a9b      	subs	r3, r3, r2
 8004efa:	009b      	lsls	r3, r3, #2
 8004efc:	440b      	add	r3, r1
 8004efe:	3326      	adds	r3, #38	@ 0x26
 8004f00:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004f02:	2b02      	cmp	r3, #2
 8004f04:	f040 8209 	bne.w	800531a <HCD_HC_IN_IRQHandler+0xacc>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 8004f08:	78fb      	ldrb	r3, [r7, #3]
 8004f0a:	015a      	lsls	r2, r3, #5
 8004f0c:	693b      	ldr	r3, [r7, #16]
 8004f0e:	4413      	add	r3, r2
 8004f10:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004f14:	681b      	ldr	r3, [r3, #0]
 8004f16:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8004f18:	68fb      	ldr	r3, [r7, #12]
 8004f1a:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8004f1e:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8004f20:	68fb      	ldr	r3, [r7, #12]
 8004f22:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8004f26:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 8004f28:	78fb      	ldrb	r3, [r7, #3]
 8004f2a:	015a      	lsls	r2, r3, #5
 8004f2c:	693b      	ldr	r3, [r7, #16]
 8004f2e:	4413      	add	r3, r2
 8004f30:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004f34:	461a      	mov	r2, r3
 8004f36:	68fb      	ldr	r3, [r7, #12]
 8004f38:	6013      	str	r3, [r2, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004f3a:	e1ee      	b.n	800531a <HCD_HC_IN_IRQHandler+0xacc>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_NYET)
 8004f3c:	78fa      	ldrb	r2, [r7, #3]
 8004f3e:	6879      	ldr	r1, [r7, #4]
 8004f40:	4613      	mov	r3, r2
 8004f42:	011b      	lsls	r3, r3, #4
 8004f44:	1a9b      	subs	r3, r3, r2
 8004f46:	009b      	lsls	r3, r3, #2
 8004f48:	440b      	add	r3, r1
 8004f4a:	334d      	adds	r3, #77	@ 0x4d
 8004f4c:	781b      	ldrb	r3, [r3, #0]
 8004f4e:	2b05      	cmp	r3, #5
 8004f50:	f040 80c8 	bne.w	80050e4 <HCD_HC_IN_IRQHandler+0x896>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004f54:	78fa      	ldrb	r2, [r7, #3]
 8004f56:	6879      	ldr	r1, [r7, #4]
 8004f58:	4613      	mov	r3, r2
 8004f5a:	011b      	lsls	r3, r3, #4
 8004f5c:	1a9b      	subs	r3, r3, r2
 8004f5e:	009b      	lsls	r3, r3, #2
 8004f60:	440b      	add	r3, r1
 8004f62:	334d      	adds	r3, #77	@ 0x4d
 8004f64:	2202      	movs	r2, #2
 8004f66:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8004f68:	78fa      	ldrb	r2, [r7, #3]
 8004f6a:	6879      	ldr	r1, [r7, #4]
 8004f6c:	4613      	mov	r3, r2
 8004f6e:	011b      	lsls	r3, r3, #4
 8004f70:	1a9b      	subs	r3, r3, r2
 8004f72:	009b      	lsls	r3, r3, #2
 8004f74:	440b      	add	r3, r1
 8004f76:	331b      	adds	r3, #27
 8004f78:	781b      	ldrb	r3, [r3, #0]
 8004f7a:	2b01      	cmp	r3, #1
 8004f7c:	f040 81ce 	bne.w	800531c <HCD_HC_IN_IRQHandler+0xace>
      {
        if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 8004f80:	78fa      	ldrb	r2, [r7, #3]
 8004f82:	6879      	ldr	r1, [r7, #4]
 8004f84:	4613      	mov	r3, r2
 8004f86:	011b      	lsls	r3, r3, #4
 8004f88:	1a9b      	subs	r3, r3, r2
 8004f8a:	009b      	lsls	r3, r3, #2
 8004f8c:	440b      	add	r3, r1
 8004f8e:	3326      	adds	r3, #38	@ 0x26
 8004f90:	781b      	ldrb	r3, [r3, #0]
 8004f92:	2b03      	cmp	r3, #3
 8004f94:	d16b      	bne.n	800506e <HCD_HC_IN_IRQHandler+0x820>
        {
          hhcd->hc[chnum].NyetErrCnt++;
 8004f96:	78fa      	ldrb	r2, [r7, #3]
 8004f98:	6879      	ldr	r1, [r7, #4]
 8004f9a:	4613      	mov	r3, r2
 8004f9c:	011b      	lsls	r3, r3, #4
 8004f9e:	1a9b      	subs	r3, r3, r2
 8004fa0:	009b      	lsls	r3, r3, #2
 8004fa2:	440b      	add	r3, r1
 8004fa4:	3348      	adds	r3, #72	@ 0x48
 8004fa6:	681b      	ldr	r3, [r3, #0]
 8004fa8:	1c59      	adds	r1, r3, #1
 8004faa:	6878      	ldr	r0, [r7, #4]
 8004fac:	4613      	mov	r3, r2
 8004fae:	011b      	lsls	r3, r3, #4
 8004fb0:	1a9b      	subs	r3, r3, r2
 8004fb2:	009b      	lsls	r3, r3, #2
 8004fb4:	4403      	add	r3, r0
 8004fb6:	3348      	adds	r3, #72	@ 0x48
 8004fb8:	6019      	str	r1, [r3, #0]
          if (hhcd->hc[chnum].NyetErrCnt > 2U)
 8004fba:	78fa      	ldrb	r2, [r7, #3]
 8004fbc:	6879      	ldr	r1, [r7, #4]
 8004fbe:	4613      	mov	r3, r2
 8004fc0:	011b      	lsls	r3, r3, #4
 8004fc2:	1a9b      	subs	r3, r3, r2
 8004fc4:	009b      	lsls	r3, r3, #2
 8004fc6:	440b      	add	r3, r1
 8004fc8:	3348      	adds	r3, #72	@ 0x48
 8004fca:	681b      	ldr	r3, [r3, #0]
 8004fcc:	2b02      	cmp	r3, #2
 8004fce:	d943      	bls.n	8005058 <HCD_HC_IN_IRQHandler+0x80a>
          {
            hhcd->hc[chnum].NyetErrCnt = 0U;
 8004fd0:	78fa      	ldrb	r2, [r7, #3]
 8004fd2:	6879      	ldr	r1, [r7, #4]
 8004fd4:	4613      	mov	r3, r2
 8004fd6:	011b      	lsls	r3, r3, #4
 8004fd8:	1a9b      	subs	r3, r3, r2
 8004fda:	009b      	lsls	r3, r3, #2
 8004fdc:	440b      	add	r3, r1
 8004fde:	3348      	adds	r3, #72	@ 0x48
 8004fe0:	2200      	movs	r2, #0
 8004fe2:	601a      	str	r2, [r3, #0]
            hhcd->hc[chnum].do_csplit = 0U;
 8004fe4:	78fa      	ldrb	r2, [r7, #3]
 8004fe6:	6879      	ldr	r1, [r7, #4]
 8004fe8:	4613      	mov	r3, r2
 8004fea:	011b      	lsls	r3, r3, #4
 8004fec:	1a9b      	subs	r3, r3, r2
 8004fee:	009b      	lsls	r3, r3, #2
 8004ff0:	440b      	add	r3, r1
 8004ff2:	331b      	adds	r3, #27
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	701a      	strb	r2, [r3, #0]

            if (hhcd->hc[chnum].ErrCnt < 3U)
 8004ff8:	78fa      	ldrb	r2, [r7, #3]
 8004ffa:	6879      	ldr	r1, [r7, #4]
 8004ffc:	4613      	mov	r3, r2
 8004ffe:	011b      	lsls	r3, r3, #4
 8005000:	1a9b      	subs	r3, r3, r2
 8005002:	009b      	lsls	r3, r3, #2
 8005004:	440b      	add	r3, r1
 8005006:	3344      	adds	r3, #68	@ 0x44
 8005008:	681b      	ldr	r3, [r3, #0]
 800500a:	2b02      	cmp	r3, #2
 800500c:	d809      	bhi.n	8005022 <HCD_HC_IN_IRQHandler+0x7d4>
            {
              hhcd->hc[chnum].ep_ss_schedule = 1U;
 800500e:	78fa      	ldrb	r2, [r7, #3]
 8005010:	6879      	ldr	r1, [r7, #4]
 8005012:	4613      	mov	r3, r2
 8005014:	011b      	lsls	r3, r3, #4
 8005016:	1a9b      	subs	r3, r3, r2
 8005018:	009b      	lsls	r3, r3, #2
 800501a:	440b      	add	r3, r1
 800501c:	331c      	adds	r3, #28
 800501e:	2201      	movs	r2, #1
 8005020:	701a      	strb	r2, [r3, #0]
            }
            __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8005022:	78fb      	ldrb	r3, [r7, #3]
 8005024:	015a      	lsls	r2, r3, #5
 8005026:	693b      	ldr	r3, [r7, #16]
 8005028:	4413      	add	r3, r2
 800502a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800502e:	685b      	ldr	r3, [r3, #4]
 8005030:	78fa      	ldrb	r2, [r7, #3]
 8005032:	0151      	lsls	r1, r2, #5
 8005034:	693a      	ldr	r2, [r7, #16]
 8005036:	440a      	add	r2, r1
 8005038:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800503c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005040:	6053      	str	r3, [r2, #4]
            hhcd->hc[chnum].urb_state = URB_ERROR;
 8005042:	78fa      	ldrb	r2, [r7, #3]
 8005044:	6879      	ldr	r1, [r7, #4]
 8005046:	4613      	mov	r3, r2
 8005048:	011b      	lsls	r3, r3, #4
 800504a:	1a9b      	subs	r3, r3, r2
 800504c:	009b      	lsls	r3, r3, #2
 800504e:	440b      	add	r3, r1
 8005050:	334c      	adds	r3, #76	@ 0x4c
 8005052:	2204      	movs	r2, #4
 8005054:	701a      	strb	r2, [r3, #0]
 8005056:	e014      	b.n	8005082 <HCD_HC_IN_IRQHandler+0x834>
          }
          else
          {
            hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005058:	78fa      	ldrb	r2, [r7, #3]
 800505a:	6879      	ldr	r1, [r7, #4]
 800505c:	4613      	mov	r3, r2
 800505e:	011b      	lsls	r3, r3, #4
 8005060:	1a9b      	subs	r3, r3, r2
 8005062:	009b      	lsls	r3, r3, #2
 8005064:	440b      	add	r3, r1
 8005066:	334c      	adds	r3, #76	@ 0x4c
 8005068:	2202      	movs	r2, #2
 800506a:	701a      	strb	r2, [r3, #0]
 800506c:	e009      	b.n	8005082 <HCD_HC_IN_IRQHandler+0x834>
          }
        }
        else
        {
          hhcd->hc[chnum].urb_state = URB_NOTREADY;
 800506e:	78fa      	ldrb	r2, [r7, #3]
 8005070:	6879      	ldr	r1, [r7, #4]
 8005072:	4613      	mov	r3, r2
 8005074:	011b      	lsls	r3, r3, #4
 8005076:	1a9b      	subs	r3, r3, r2
 8005078:	009b      	lsls	r3, r3, #2
 800507a:	440b      	add	r3, r1
 800507c:	334c      	adds	r3, #76	@ 0x4c
 800507e:	2202      	movs	r2, #2
 8005080:	701a      	strb	r2, [r3, #0]
        }

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005082:	78fa      	ldrb	r2, [r7, #3]
 8005084:	6879      	ldr	r1, [r7, #4]
 8005086:	4613      	mov	r3, r2
 8005088:	011b      	lsls	r3, r3, #4
 800508a:	1a9b      	subs	r3, r3, r2
 800508c:	009b      	lsls	r3, r3, #2
 800508e:	440b      	add	r3, r1
 8005090:	3326      	adds	r3, #38	@ 0x26
 8005092:	781b      	ldrb	r3, [r3, #0]
 8005094:	2b00      	cmp	r3, #0
 8005096:	d00b      	beq.n	80050b0 <HCD_HC_IN_IRQHandler+0x862>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8005098:	78fa      	ldrb	r2, [r7, #3]
 800509a:	6879      	ldr	r1, [r7, #4]
 800509c:	4613      	mov	r3, r2
 800509e:	011b      	lsls	r3, r3, #4
 80050a0:	1a9b      	subs	r3, r3, r2
 80050a2:	009b      	lsls	r3, r3, #2
 80050a4:	440b      	add	r3, r1
 80050a6:	3326      	adds	r3, #38	@ 0x26
 80050a8:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 80050aa:	2b02      	cmp	r3, #2
 80050ac:	f040 8136 	bne.w	800531c <HCD_HC_IN_IRQHandler+0xace>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 80050b0:	78fb      	ldrb	r3, [r7, #3]
 80050b2:	015a      	lsls	r2, r3, #5
 80050b4:	693b      	ldr	r3, [r7, #16]
 80050b6:	4413      	add	r3, r2
 80050b8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80050bc:	681b      	ldr	r3, [r3, #0]
 80050be:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80050c0:	68fb      	ldr	r3, [r7, #12]
 80050c2:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80050c6:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 80050c8:	68fb      	ldr	r3, [r7, #12]
 80050ca:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80050ce:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 80050d0:	78fb      	ldrb	r3, [r7, #3]
 80050d2:	015a      	lsls	r2, r3, #5
 80050d4:	693b      	ldr	r3, [r7, #16]
 80050d6:	4413      	add	r3, r2
 80050d8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80050dc:	461a      	mov	r2, r3
 80050de:	68fb      	ldr	r3, [r7, #12]
 80050e0:	6013      	str	r3, [r2, #0]
 80050e2:	e11b      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_ACK)
 80050e4:	78fa      	ldrb	r2, [r7, #3]
 80050e6:	6879      	ldr	r1, [r7, #4]
 80050e8:	4613      	mov	r3, r2
 80050ea:	011b      	lsls	r3, r3, #4
 80050ec:	1a9b      	subs	r3, r3, r2
 80050ee:	009b      	lsls	r3, r3, #2
 80050f0:	440b      	add	r3, r1
 80050f2:	334d      	adds	r3, #77	@ 0x4d
 80050f4:	781b      	ldrb	r3, [r3, #0]
 80050f6:	2b03      	cmp	r3, #3
 80050f8:	f040 8081 	bne.w	80051fe <HCD_HC_IN_IRQHandler+0x9b0>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 80050fc:	78fa      	ldrb	r2, [r7, #3]
 80050fe:	6879      	ldr	r1, [r7, #4]
 8005100:	4613      	mov	r3, r2
 8005102:	011b      	lsls	r3, r3, #4
 8005104:	1a9b      	subs	r3, r3, r2
 8005106:	009b      	lsls	r3, r3, #2
 8005108:	440b      	add	r3, r1
 800510a:	334d      	adds	r3, #77	@ 0x4d
 800510c:	2202      	movs	r2, #2
 800510e:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8005110:	78fa      	ldrb	r2, [r7, #3]
 8005112:	6879      	ldr	r1, [r7, #4]
 8005114:	4613      	mov	r3, r2
 8005116:	011b      	lsls	r3, r3, #4
 8005118:	1a9b      	subs	r3, r3, r2
 800511a:	009b      	lsls	r3, r3, #2
 800511c:	440b      	add	r3, r1
 800511e:	331b      	adds	r3, #27
 8005120:	781b      	ldrb	r3, [r3, #0]
 8005122:	2b01      	cmp	r3, #1
 8005124:	f040 80fa 	bne.w	800531c <HCD_HC_IN_IRQHandler+0xace>
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005128:	78fa      	ldrb	r2, [r7, #3]
 800512a:	6879      	ldr	r1, [r7, #4]
 800512c:	4613      	mov	r3, r2
 800512e:	011b      	lsls	r3, r3, #4
 8005130:	1a9b      	subs	r3, r3, r2
 8005132:	009b      	lsls	r3, r3, #2
 8005134:	440b      	add	r3, r1
 8005136:	334c      	adds	r3, #76	@ 0x4c
 8005138:	2202      	movs	r2, #2
 800513a:	701a      	strb	r2, [r3, #0]

        /* Set Complete split and re-activate the channel */
        USBx_HC(chnum)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 800513c:	78fb      	ldrb	r3, [r7, #3]
 800513e:	015a      	lsls	r2, r3, #5
 8005140:	693b      	ldr	r3, [r7, #16]
 8005142:	4413      	add	r3, r2
 8005144:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005148:	685b      	ldr	r3, [r3, #4]
 800514a:	78fa      	ldrb	r2, [r7, #3]
 800514c:	0151      	lsls	r1, r2, #5
 800514e:	693a      	ldr	r2, [r7, #16]
 8005150:	440a      	add	r2, r1
 8005152:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005156:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800515a:	6053      	str	r3, [r2, #4]
        USBx_HC(chnum)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 800515c:	78fb      	ldrb	r3, [r7, #3]
 800515e:	015a      	lsls	r2, r3, #5
 8005160:	693b      	ldr	r3, [r7, #16]
 8005162:	4413      	add	r3, r2
 8005164:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005168:	68db      	ldr	r3, [r3, #12]
 800516a:	78fa      	ldrb	r2, [r7, #3]
 800516c:	0151      	lsls	r1, r2, #5
 800516e:	693a      	ldr	r2, [r7, #16]
 8005170:	440a      	add	r2, r1
 8005172:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005176:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800517a:	60d3      	str	r3, [r2, #12]
        USBx_HC(chnum)->HCINTMSK &= ~USB_OTG_HCINT_ACK;
 800517c:	78fb      	ldrb	r3, [r7, #3]
 800517e:	015a      	lsls	r2, r3, #5
 8005180:	693b      	ldr	r3, [r7, #16]
 8005182:	4413      	add	r3, r2
 8005184:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005188:	68db      	ldr	r3, [r3, #12]
 800518a:	78fa      	ldrb	r2, [r7, #3]
 800518c:	0151      	lsls	r1, r2, #5
 800518e:	693a      	ldr	r2, [r7, #16]
 8005190:	440a      	add	r2, r1
 8005192:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005196:	f023 0320 	bic.w	r3, r3, #32
 800519a:	60d3      	str	r3, [r2, #12]

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800519c:	78fa      	ldrb	r2, [r7, #3]
 800519e:	6879      	ldr	r1, [r7, #4]
 80051a0:	4613      	mov	r3, r2
 80051a2:	011b      	lsls	r3, r3, #4
 80051a4:	1a9b      	subs	r3, r3, r2
 80051a6:	009b      	lsls	r3, r3, #2
 80051a8:	440b      	add	r3, r1
 80051aa:	3326      	adds	r3, #38	@ 0x26
 80051ac:	781b      	ldrb	r3, [r3, #0]
 80051ae:	2b00      	cmp	r3, #0
 80051b0:	d00b      	beq.n	80051ca <HCD_HC_IN_IRQHandler+0x97c>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 80051b2:	78fa      	ldrb	r2, [r7, #3]
 80051b4:	6879      	ldr	r1, [r7, #4]
 80051b6:	4613      	mov	r3, r2
 80051b8:	011b      	lsls	r3, r3, #4
 80051ba:	1a9b      	subs	r3, r3, r2
 80051bc:	009b      	lsls	r3, r3, #2
 80051be:	440b      	add	r3, r1
 80051c0:	3326      	adds	r3, #38	@ 0x26
 80051c2:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 80051c4:	2b02      	cmp	r3, #2
 80051c6:	f040 80a9 	bne.w	800531c <HCD_HC_IN_IRQHandler+0xace>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 80051ca:	78fb      	ldrb	r3, [r7, #3]
 80051cc:	015a      	lsls	r2, r3, #5
 80051ce:	693b      	ldr	r3, [r7, #16]
 80051d0:	4413      	add	r3, r2
 80051d2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80051d6:	681b      	ldr	r3, [r3, #0]
 80051d8:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80051da:	68fb      	ldr	r3, [r7, #12]
 80051dc:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80051e0:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 80051e2:	68fb      	ldr	r3, [r7, #12]
 80051e4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80051e8:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 80051ea:	78fb      	ldrb	r3, [r7, #3]
 80051ec:	015a      	lsls	r2, r3, #5
 80051ee:	693b      	ldr	r3, [r7, #16]
 80051f0:	4413      	add	r3, r2
 80051f2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80051f6:	461a      	mov	r2, r3
 80051f8:	68fb      	ldr	r3, [r7, #12]
 80051fa:	6013      	str	r3, [r2, #0]
 80051fc:	e08e      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_NAK)
 80051fe:	78fa      	ldrb	r2, [r7, #3]
 8005200:	6879      	ldr	r1, [r7, #4]
 8005202:	4613      	mov	r3, r2
 8005204:	011b      	lsls	r3, r3, #4
 8005206:	1a9b      	subs	r3, r3, r2
 8005208:	009b      	lsls	r3, r3, #2
 800520a:	440b      	add	r3, r1
 800520c:	334d      	adds	r3, #77	@ 0x4d
 800520e:	781b      	ldrb	r3, [r3, #0]
 8005210:	2b04      	cmp	r3, #4
 8005212:	d143      	bne.n	800529c <HCD_HC_IN_IRQHandler+0xa4e>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005214:	78fa      	ldrb	r2, [r7, #3]
 8005216:	6879      	ldr	r1, [r7, #4]
 8005218:	4613      	mov	r3, r2
 800521a:	011b      	lsls	r3, r3, #4
 800521c:	1a9b      	subs	r3, r3, r2
 800521e:	009b      	lsls	r3, r3, #2
 8005220:	440b      	add	r3, r1
 8005222:	334d      	adds	r3, #77	@ 0x4d
 8005224:	2202      	movs	r2, #2
 8005226:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005228:	78fa      	ldrb	r2, [r7, #3]
 800522a:	6879      	ldr	r1, [r7, #4]
 800522c:	4613      	mov	r3, r2
 800522e:	011b      	lsls	r3, r3, #4
 8005230:	1a9b      	subs	r3, r3, r2
 8005232:	009b      	lsls	r3, r3, #2
 8005234:	440b      	add	r3, r1
 8005236:	334c      	adds	r3, #76	@ 0x4c
 8005238:	2202      	movs	r2, #2
 800523a:	701a      	strb	r2, [r3, #0]

      if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800523c:	78fa      	ldrb	r2, [r7, #3]
 800523e:	6879      	ldr	r1, [r7, #4]
 8005240:	4613      	mov	r3, r2
 8005242:	011b      	lsls	r3, r3, #4
 8005244:	1a9b      	subs	r3, r3, r2
 8005246:	009b      	lsls	r3, r3, #2
 8005248:	440b      	add	r3, r1
 800524a:	3326      	adds	r3, #38	@ 0x26
 800524c:	781b      	ldrb	r3, [r3, #0]
 800524e:	2b00      	cmp	r3, #0
 8005250:	d00a      	beq.n	8005268 <HCD_HC_IN_IRQHandler+0xa1a>
          (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8005252:	78fa      	ldrb	r2, [r7, #3]
 8005254:	6879      	ldr	r1, [r7, #4]
 8005256:	4613      	mov	r3, r2
 8005258:	011b      	lsls	r3, r3, #4
 800525a:	1a9b      	subs	r3, r3, r2
 800525c:	009b      	lsls	r3, r3, #2
 800525e:	440b      	add	r3, r1
 8005260:	3326      	adds	r3, #38	@ 0x26
 8005262:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005264:	2b02      	cmp	r3, #2
 8005266:	d159      	bne.n	800531c <HCD_HC_IN_IRQHandler+0xace>
      {
        /* re-activate the channel */
        tmpreg = USBx_HC(chnum)->HCCHAR;
 8005268:	78fb      	ldrb	r3, [r7, #3]
 800526a:	015a      	lsls	r2, r3, #5
 800526c:	693b      	ldr	r3, [r7, #16]
 800526e:	4413      	add	r3, r2
 8005270:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005274:	681b      	ldr	r3, [r3, #0]
 8005276:	60fb      	str	r3, [r7, #12]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005278:	68fb      	ldr	r3, [r7, #12]
 800527a:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 800527e:	60fb      	str	r3, [r7, #12]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005280:	68fb      	ldr	r3, [r7, #12]
 8005282:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8005286:	60fb      	str	r3, [r7, #12]
        USBx_HC(chnum)->HCCHAR = tmpreg;
 8005288:	78fb      	ldrb	r3, [r7, #3]
 800528a:	015a      	lsls	r2, r3, #5
 800528c:	693b      	ldr	r3, [r7, #16]
 800528e:	4413      	add	r3, r2
 8005290:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005294:	461a      	mov	r2, r3
 8005296:	68fb      	ldr	r3, [r7, #12]
 8005298:	6013      	str	r3, [r2, #0]
 800529a:	e03f      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
      }
    }
    else if (hhcd->hc[chnum].state == HC_BBLERR)
 800529c:	78fa      	ldrb	r2, [r7, #3]
 800529e:	6879      	ldr	r1, [r7, #4]
 80052a0:	4613      	mov	r3, r2
 80052a2:	011b      	lsls	r3, r3, #4
 80052a4:	1a9b      	subs	r3, r3, r2
 80052a6:	009b      	lsls	r3, r3, #2
 80052a8:	440b      	add	r3, r1
 80052aa:	334d      	adds	r3, #77	@ 0x4d
 80052ac:	781b      	ldrb	r3, [r3, #0]
 80052ae:	2b08      	cmp	r3, #8
 80052b0:	d126      	bne.n	8005300 <HCD_HC_IN_IRQHandler+0xab2>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 80052b2:	78fa      	ldrb	r2, [r7, #3]
 80052b4:	6879      	ldr	r1, [r7, #4]
 80052b6:	4613      	mov	r3, r2
 80052b8:	011b      	lsls	r3, r3, #4
 80052ba:	1a9b      	subs	r3, r3, r2
 80052bc:	009b      	lsls	r3, r3, #2
 80052be:	440b      	add	r3, r1
 80052c0:	334d      	adds	r3, #77	@ 0x4d
 80052c2:	2202      	movs	r2, #2
 80052c4:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 80052c6:	78fa      	ldrb	r2, [r7, #3]
 80052c8:	6879      	ldr	r1, [r7, #4]
 80052ca:	4613      	mov	r3, r2
 80052cc:	011b      	lsls	r3, r3, #4
 80052ce:	1a9b      	subs	r3, r3, r2
 80052d0:	009b      	lsls	r3, r3, #2
 80052d2:	440b      	add	r3, r1
 80052d4:	3344      	adds	r3, #68	@ 0x44
 80052d6:	681b      	ldr	r3, [r3, #0]
 80052d8:	1c59      	adds	r1, r3, #1
 80052da:	6878      	ldr	r0, [r7, #4]
 80052dc:	4613      	mov	r3, r2
 80052de:	011b      	lsls	r3, r3, #4
 80052e0:	1a9b      	subs	r3, r3, r2
 80052e2:	009b      	lsls	r3, r3, #2
 80052e4:	4403      	add	r3, r0
 80052e6:	3344      	adds	r3, #68	@ 0x44
 80052e8:	6019      	str	r1, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_ERROR;
 80052ea:	78fa      	ldrb	r2, [r7, #3]
 80052ec:	6879      	ldr	r1, [r7, #4]
 80052ee:	4613      	mov	r3, r2
 80052f0:	011b      	lsls	r3, r3, #4
 80052f2:	1a9b      	subs	r3, r3, r2
 80052f4:	009b      	lsls	r3, r3, #2
 80052f6:	440b      	add	r3, r1
 80052f8:	334c      	adds	r3, #76	@ 0x4c
 80052fa:	2204      	movs	r2, #4
 80052fc:	701a      	strb	r2, [r3, #0]
 80052fe:	e00d      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
    }
    else
    {
      if (hhcd->hc[chnum].state == HC_HALTED)
 8005300:	78fa      	ldrb	r2, [r7, #3]
 8005302:	6879      	ldr	r1, [r7, #4]
 8005304:	4613      	mov	r3, r2
 8005306:	011b      	lsls	r3, r3, #4
 8005308:	1a9b      	subs	r3, r3, r2
 800530a:	009b      	lsls	r3, r3, #2
 800530c:	440b      	add	r3, r1
 800530e:	334d      	adds	r3, #77	@ 0x4d
 8005310:	781b      	ldrb	r3, [r3, #0]
 8005312:	2b02      	cmp	r3, #2
 8005314:	f000 8100 	beq.w	8005518 <HCD_HC_IN_IRQHandler+0xcca>
 8005318:	e000      	b.n	800531c <HCD_HC_IN_IRQHandler+0xace>
      if (hhcd->hc[chnum].ErrCnt > 2U)
 800531a:	bf00      	nop
    }

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
    hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 800531c:	78fa      	ldrb	r2, [r7, #3]
 800531e:	6879      	ldr	r1, [r7, #4]
 8005320:	4613      	mov	r3, r2
 8005322:	011b      	lsls	r3, r3, #4
 8005324:	1a9b      	subs	r3, r3, r2
 8005326:	009b      	lsls	r3, r3, #2
 8005328:	440b      	add	r3, r1
 800532a:	334c      	adds	r3, #76	@ 0x4c
 800532c:	781a      	ldrb	r2, [r3, #0]
 800532e:	78fb      	ldrb	r3, [r7, #3]
 8005330:	4619      	mov	r1, r3
 8005332:	6878      	ldr	r0, [r7, #4]
 8005334:	f027 fe14 	bl	802cf60 <HAL_HCD_HC_NotifyURBChange_Callback>
 8005338:	e0ef      	b.n	800551a <HCD_HC_IN_IRQHandler+0xccc>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	681b      	ldr	r3, [r3, #0]
 800533e:	78fa      	ldrb	r2, [r7, #3]
 8005340:	4611      	mov	r1, r2
 8005342:	4618      	mov	r0, r3
 8005344:	f001 fe83 	bl	800704e <USB_ReadChInterrupts>
 8005348:	4603      	mov	r3, r0
 800534a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800534e:	2b40      	cmp	r3, #64	@ 0x40
 8005350:	d12f      	bne.n	80053b2 <HCD_HC_IN_IRQHandler+0xb64>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8005352:	78fb      	ldrb	r3, [r7, #3]
 8005354:	015a      	lsls	r2, r3, #5
 8005356:	693b      	ldr	r3, [r7, #16]
 8005358:	4413      	add	r3, r2
 800535a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800535e:	461a      	mov	r2, r3
 8005360:	2340      	movs	r3, #64	@ 0x40
 8005362:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_NYET;
 8005364:	78fa      	ldrb	r2, [r7, #3]
 8005366:	6879      	ldr	r1, [r7, #4]
 8005368:	4613      	mov	r3, r2
 800536a:	011b      	lsls	r3, r3, #4
 800536c:	1a9b      	subs	r3, r3, r2
 800536e:	009b      	lsls	r3, r3, #2
 8005370:	440b      	add	r3, r1
 8005372:	334d      	adds	r3, #77	@ 0x4d
 8005374:	2205      	movs	r2, #5
 8005376:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ssplit == 0U)
 8005378:	78fa      	ldrb	r2, [r7, #3]
 800537a:	6879      	ldr	r1, [r7, #4]
 800537c:	4613      	mov	r3, r2
 800537e:	011b      	lsls	r3, r3, #4
 8005380:	1a9b      	subs	r3, r3, r2
 8005382:	009b      	lsls	r3, r3, #2
 8005384:	440b      	add	r3, r1
 8005386:	331a      	adds	r3, #26
 8005388:	781b      	ldrb	r3, [r3, #0]
 800538a:	2b00      	cmp	r3, #0
 800538c:	d109      	bne.n	80053a2 <HCD_HC_IN_IRQHandler+0xb54>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 800538e:	78fa      	ldrb	r2, [r7, #3]
 8005390:	6879      	ldr	r1, [r7, #4]
 8005392:	4613      	mov	r3, r2
 8005394:	011b      	lsls	r3, r3, #4
 8005396:	1a9b      	subs	r3, r3, r2
 8005398:	009b      	lsls	r3, r3, #2
 800539a:	440b      	add	r3, r1
 800539c:	3344      	adds	r3, #68	@ 0x44
 800539e:	2200      	movs	r2, #0
 80053a0:	601a      	str	r2, [r3, #0]
    }

    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80053a2:	687b      	ldr	r3, [r7, #4]
 80053a4:	681b      	ldr	r3, [r3, #0]
 80053a6:	78fa      	ldrb	r2, [r7, #3]
 80053a8:	4611      	mov	r1, r2
 80053aa:	4618      	mov	r0, r3
 80053ac:	f002 fbf3 	bl	8007b96 <USB_HC_Halt>
 80053b0:	e0b3      	b.n	800551a <HCD_HC_IN_IRQHandler+0xccc>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 80053b2:	687b      	ldr	r3, [r7, #4]
 80053b4:	681b      	ldr	r3, [r3, #0]
 80053b6:	78fa      	ldrb	r2, [r7, #3]
 80053b8:	4611      	mov	r1, r2
 80053ba:	4618      	mov	r0, r3
 80053bc:	f001 fe47 	bl	800704e <USB_ReadChInterrupts>
 80053c0:	4603      	mov	r3, r0
 80053c2:	f003 0310 	and.w	r3, r3, #16
 80053c6:	2b10      	cmp	r3, #16
 80053c8:	f040 80a7 	bne.w	800551a <HCD_HC_IN_IRQHandler+0xccc>
  {
    if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 80053cc:	78fa      	ldrb	r2, [r7, #3]
 80053ce:	6879      	ldr	r1, [r7, #4]
 80053d0:	4613      	mov	r3, r2
 80053d2:	011b      	lsls	r3, r3, #4
 80053d4:	1a9b      	subs	r3, r3, r2
 80053d6:	009b      	lsls	r3, r3, #2
 80053d8:	440b      	add	r3, r1
 80053da:	3326      	adds	r3, #38	@ 0x26
 80053dc:	781b      	ldrb	r3, [r3, #0]
 80053de:	2b03      	cmp	r3, #3
 80053e0:	d11b      	bne.n	800541a <HCD_HC_IN_IRQHandler+0xbcc>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 80053e2:	78fa      	ldrb	r2, [r7, #3]
 80053e4:	6879      	ldr	r1, [r7, #4]
 80053e6:	4613      	mov	r3, r2
 80053e8:	011b      	lsls	r3, r3, #4
 80053ea:	1a9b      	subs	r3, r3, r2
 80053ec:	009b      	lsls	r3, r3, #2
 80053ee:	440b      	add	r3, r1
 80053f0:	3344      	adds	r3, #68	@ 0x44
 80053f2:	2200      	movs	r2, #0
 80053f4:	601a      	str	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_NAK;
 80053f6:	78fa      	ldrb	r2, [r7, #3]
 80053f8:	6879      	ldr	r1, [r7, #4]
 80053fa:	4613      	mov	r3, r2
 80053fc:	011b      	lsls	r3, r3, #4
 80053fe:	1a9b      	subs	r3, r3, r2
 8005400:	009b      	lsls	r3, r3, #2
 8005402:	440b      	add	r3, r1
 8005404:	334d      	adds	r3, #77	@ 0x4d
 8005406:	2204      	movs	r2, #4
 8005408:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 800540a:	687b      	ldr	r3, [r7, #4]
 800540c:	681b      	ldr	r3, [r3, #0]
 800540e:	78fa      	ldrb	r2, [r7, #3]
 8005410:	4611      	mov	r1, r2
 8005412:	4618      	mov	r0, r3
 8005414:	f002 fbbf 	bl	8007b96 <USB_HC_Halt>
 8005418:	e03f      	b.n	800549a <HCD_HC_IN_IRQHandler+0xc4c>
    }
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800541a:	78fa      	ldrb	r2, [r7, #3]
 800541c:	6879      	ldr	r1, [r7, #4]
 800541e:	4613      	mov	r3, r2
 8005420:	011b      	lsls	r3, r3, #4
 8005422:	1a9b      	subs	r3, r3, r2
 8005424:	009b      	lsls	r3, r3, #2
 8005426:	440b      	add	r3, r1
 8005428:	3326      	adds	r3, #38	@ 0x26
 800542a:	781b      	ldrb	r3, [r3, #0]
 800542c:	2b00      	cmp	r3, #0
 800542e:	d00a      	beq.n	8005446 <HCD_HC_IN_IRQHandler+0xbf8>
             (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8005430:	78fa      	ldrb	r2, [r7, #3]
 8005432:	6879      	ldr	r1, [r7, #4]
 8005434:	4613      	mov	r3, r2
 8005436:	011b      	lsls	r3, r3, #4
 8005438:	1a9b      	subs	r3, r3, r2
 800543a:	009b      	lsls	r3, r3, #2
 800543c:	440b      	add	r3, r1
 800543e:	3326      	adds	r3, #38	@ 0x26
 8005440:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005442:	2b02      	cmp	r3, #2
 8005444:	d129      	bne.n	800549a <HCD_HC_IN_IRQHandler+0xc4c>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 8005446:	78fa      	ldrb	r2, [r7, #3]
 8005448:	6879      	ldr	r1, [r7, #4]
 800544a:	4613      	mov	r3, r2
 800544c:	011b      	lsls	r3, r3, #4
 800544e:	1a9b      	subs	r3, r3, r2
 8005450:	009b      	lsls	r3, r3, #2
 8005452:	440b      	add	r3, r1
 8005454:	3344      	adds	r3, #68	@ 0x44
 8005456:	2200      	movs	r2, #0
 8005458:	601a      	str	r2, [r3, #0]

      if ((hhcd->Init.dma_enable == 0U) || (hhcd->hc[chnum].do_csplit == 1U))
 800545a:	687b      	ldr	r3, [r7, #4]
 800545c:	799b      	ldrb	r3, [r3, #6]
 800545e:	2b00      	cmp	r3, #0
 8005460:	d00a      	beq.n	8005478 <HCD_HC_IN_IRQHandler+0xc2a>
 8005462:	78fa      	ldrb	r2, [r7, #3]
 8005464:	6879      	ldr	r1, [r7, #4]
 8005466:	4613      	mov	r3, r2
 8005468:	011b      	lsls	r3, r3, #4
 800546a:	1a9b      	subs	r3, r3, r2
 800546c:	009b      	lsls	r3, r3, #2
 800546e:	440b      	add	r3, r1
 8005470:	331b      	adds	r3, #27
 8005472:	781b      	ldrb	r3, [r3, #0]
 8005474:	2b01      	cmp	r3, #1
 8005476:	d110      	bne.n	800549a <HCD_HC_IN_IRQHandler+0xc4c>
      {
        hhcd->hc[chnum].state = HC_NAK;
 8005478:	78fa      	ldrb	r2, [r7, #3]
 800547a:	6879      	ldr	r1, [r7, #4]
 800547c:	4613      	mov	r3, r2
 800547e:	011b      	lsls	r3, r3, #4
 8005480:	1a9b      	subs	r3, r3, r2
 8005482:	009b      	lsls	r3, r3, #2
 8005484:	440b      	add	r3, r1
 8005486:	334d      	adds	r3, #77	@ 0x4d
 8005488:	2204      	movs	r2, #4
 800548a:	701a      	strb	r2, [r3, #0]
        (void)USB_HC_Halt(hhcd->Instance, chnum);
 800548c:	687b      	ldr	r3, [r7, #4]
 800548e:	681b      	ldr	r3, [r3, #0]
 8005490:	78fa      	ldrb	r2, [r7, #3]
 8005492:	4611      	mov	r1, r2
 8005494:	4618      	mov	r0, r3
 8005496:	f002 fb7e 	bl	8007b96 <USB_HC_Halt>
    else
    {
      /* ... */
    }

    if (hhcd->hc[chnum].do_csplit == 1U)
 800549a:	78fa      	ldrb	r2, [r7, #3]
 800549c:	6879      	ldr	r1, [r7, #4]
 800549e:	4613      	mov	r3, r2
 80054a0:	011b      	lsls	r3, r3, #4
 80054a2:	1a9b      	subs	r3, r3, r2
 80054a4:	009b      	lsls	r3, r3, #2
 80054a6:	440b      	add	r3, r1
 80054a8:	331b      	adds	r3, #27
 80054aa:	781b      	ldrb	r3, [r3, #0]
 80054ac:	2b01      	cmp	r3, #1
 80054ae:	d129      	bne.n	8005504 <HCD_HC_IN_IRQHandler+0xcb6>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 80054b0:	78fa      	ldrb	r2, [r7, #3]
 80054b2:	6879      	ldr	r1, [r7, #4]
 80054b4:	4613      	mov	r3, r2
 80054b6:	011b      	lsls	r3, r3, #4
 80054b8:	1a9b      	subs	r3, r3, r2
 80054ba:	009b      	lsls	r3, r3, #2
 80054bc:	440b      	add	r3, r1
 80054be:	331b      	adds	r3, #27
 80054c0:	2200      	movs	r2, #0
 80054c2:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 80054c4:	78fb      	ldrb	r3, [r7, #3]
 80054c6:	015a      	lsls	r2, r3, #5
 80054c8:	693b      	ldr	r3, [r7, #16]
 80054ca:	4413      	add	r3, r2
 80054cc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80054d0:	685b      	ldr	r3, [r3, #4]
 80054d2:	78fa      	ldrb	r2, [r7, #3]
 80054d4:	0151      	lsls	r1, r2, #5
 80054d6:	693a      	ldr	r2, [r7, #16]
 80054d8:	440a      	add	r2, r1
 80054da:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80054de:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80054e2:	6053      	str	r3, [r2, #4]
      __HAL_HCD_UNMASK_ACK_HC_INT(chnum);
 80054e4:	78fb      	ldrb	r3, [r7, #3]
 80054e6:	015a      	lsls	r2, r3, #5
 80054e8:	693b      	ldr	r3, [r7, #16]
 80054ea:	4413      	add	r3, r2
 80054ec:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80054f0:	68db      	ldr	r3, [r3, #12]
 80054f2:	78fa      	ldrb	r2, [r7, #3]
 80054f4:	0151      	lsls	r1, r2, #5
 80054f6:	693a      	ldr	r2, [r7, #16]
 80054f8:	440a      	add	r2, r1
 80054fa:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80054fe:	f043 0320 	orr.w	r3, r3, #32
 8005502:	60d3      	str	r3, [r2, #12]
    }

    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8005504:	78fb      	ldrb	r3, [r7, #3]
 8005506:	015a      	lsls	r2, r3, #5
 8005508:	693b      	ldr	r3, [r7, #16]
 800550a:	4413      	add	r3, r2
 800550c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005510:	461a      	mov	r2, r3
 8005512:	2310      	movs	r3, #16
 8005514:	6093      	str	r3, [r2, #8]
 8005516:	e000      	b.n	800551a <HCD_HC_IN_IRQHandler+0xccc>
        return;
 8005518:	bf00      	nop
  }
  else
  {
    /* ... */
  }
}
 800551a:	3718      	adds	r7, #24
 800551c:	46bd      	mov	sp, r7
 800551e:	bd80      	pop	{r7, pc}

08005520 <HCD_HC_OUT_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8005520:	b580      	push	{r7, lr}
 8005522:	b086      	sub	sp, #24
 8005524:	af00      	add	r7, sp, #0
 8005526:	6078      	str	r0, [r7, #4]
 8005528:	460b      	mov	r3, r1
 800552a:	70fb      	strb	r3, [r7, #3]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	681b      	ldr	r3, [r3, #0]
 8005530:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005532:	697b      	ldr	r3, [r7, #20]
 8005534:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg;
  uint32_t num_packets;

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 8005536:	687b      	ldr	r3, [r7, #4]
 8005538:	681b      	ldr	r3, [r3, #0]
 800553a:	78fa      	ldrb	r2, [r7, #3]
 800553c:	4611      	mov	r1, r2
 800553e:	4618      	mov	r0, r3
 8005540:	f001 fd85 	bl	800704e <USB_ReadChInterrupts>
 8005544:	4603      	mov	r3, r0
 8005546:	f003 0304 	and.w	r3, r3, #4
 800554a:	2b04      	cmp	r3, #4
 800554c:	d11b      	bne.n	8005586 <HCD_HC_OUT_IRQHandler+0x66>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 800554e:	78fb      	ldrb	r3, [r7, #3]
 8005550:	015a      	lsls	r2, r3, #5
 8005552:	693b      	ldr	r3, [r7, #16]
 8005554:	4413      	add	r3, r2
 8005556:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800555a:	461a      	mov	r2, r3
 800555c:	2304      	movs	r3, #4
 800555e:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 8005560:	78fa      	ldrb	r2, [r7, #3]
 8005562:	6879      	ldr	r1, [r7, #4]
 8005564:	4613      	mov	r3, r2
 8005566:	011b      	lsls	r3, r3, #4
 8005568:	1a9b      	subs	r3, r3, r2
 800556a:	009b      	lsls	r3, r3, #2
 800556c:	440b      	add	r3, r1
 800556e:	334d      	adds	r3, #77	@ 0x4d
 8005570:	2207      	movs	r2, #7
 8005572:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005574:	687b      	ldr	r3, [r7, #4]
 8005576:	681b      	ldr	r3, [r3, #0]
 8005578:	78fa      	ldrb	r2, [r7, #3]
 800557a:	4611      	mov	r1, r2
 800557c:	4618      	mov	r0, r3
 800557e:	f002 fb0a 	bl	8007b96 <USB_HC_Halt>
 8005582:	f000 bc6f 	b.w	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 8005586:	687b      	ldr	r3, [r7, #4]
 8005588:	681b      	ldr	r3, [r3, #0]
 800558a:	78fa      	ldrb	r2, [r7, #3]
 800558c:	4611      	mov	r1, r2
 800558e:	4618      	mov	r0, r3
 8005590:	f001 fd5d 	bl	800704e <USB_ReadChInterrupts>
 8005594:	4603      	mov	r3, r0
 8005596:	f003 0320 	and.w	r3, r3, #32
 800559a:	2b20      	cmp	r3, #32
 800559c:	f040 8082 	bne.w	80056a4 <HCD_HC_OUT_IRQHandler+0x184>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80055a0:	78fb      	ldrb	r3, [r7, #3]
 80055a2:	015a      	lsls	r2, r3, #5
 80055a4:	693b      	ldr	r3, [r7, #16]
 80055a6:	4413      	add	r3, r2
 80055a8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80055ac:	461a      	mov	r2, r3
 80055ae:	2320      	movs	r3, #32
 80055b0:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_ping == 1U)
 80055b2:	78fa      	ldrb	r2, [r7, #3]
 80055b4:	6879      	ldr	r1, [r7, #4]
 80055b6:	4613      	mov	r3, r2
 80055b8:	011b      	lsls	r3, r3, #4
 80055ba:	1a9b      	subs	r3, r3, r2
 80055bc:	009b      	lsls	r3, r3, #2
 80055be:	440b      	add	r3, r1
 80055c0:	3319      	adds	r3, #25
 80055c2:	781b      	ldrb	r3, [r3, #0]
 80055c4:	2b01      	cmp	r3, #1
 80055c6:	d124      	bne.n	8005612 <HCD_HC_OUT_IRQHandler+0xf2>
    {
      hhcd->hc[chnum].do_ping = 0U;
 80055c8:	78fa      	ldrb	r2, [r7, #3]
 80055ca:	6879      	ldr	r1, [r7, #4]
 80055cc:	4613      	mov	r3, r2
 80055ce:	011b      	lsls	r3, r3, #4
 80055d0:	1a9b      	subs	r3, r3, r2
 80055d2:	009b      	lsls	r3, r3, #2
 80055d4:	440b      	add	r3, r1
 80055d6:	3319      	adds	r3, #25
 80055d8:	2200      	movs	r2, #0
 80055da:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 80055dc:	78fa      	ldrb	r2, [r7, #3]
 80055de:	6879      	ldr	r1, [r7, #4]
 80055e0:	4613      	mov	r3, r2
 80055e2:	011b      	lsls	r3, r3, #4
 80055e4:	1a9b      	subs	r3, r3, r2
 80055e6:	009b      	lsls	r3, r3, #2
 80055e8:	440b      	add	r3, r1
 80055ea:	334c      	adds	r3, #76	@ 0x4c
 80055ec:	2202      	movs	r2, #2
 80055ee:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_ACK;
 80055f0:	78fa      	ldrb	r2, [r7, #3]
 80055f2:	6879      	ldr	r1, [r7, #4]
 80055f4:	4613      	mov	r3, r2
 80055f6:	011b      	lsls	r3, r3, #4
 80055f8:	1a9b      	subs	r3, r3, r2
 80055fa:	009b      	lsls	r3, r3, #2
 80055fc:	440b      	add	r3, r1
 80055fe:	334d      	adds	r3, #77	@ 0x4d
 8005600:	2203      	movs	r2, #3
 8005602:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005604:	687b      	ldr	r3, [r7, #4]
 8005606:	681b      	ldr	r3, [r3, #0]
 8005608:	78fa      	ldrb	r2, [r7, #3]
 800560a:	4611      	mov	r1, r2
 800560c:	4618      	mov	r0, r3
 800560e:	f002 fac2 	bl	8007b96 <USB_HC_Halt>
    }

    if ((hhcd->hc[chnum].do_ssplit == 1U) && (hhcd->hc[chnum].do_csplit == 0U))
 8005612:	78fa      	ldrb	r2, [r7, #3]
 8005614:	6879      	ldr	r1, [r7, #4]
 8005616:	4613      	mov	r3, r2
 8005618:	011b      	lsls	r3, r3, #4
 800561a:	1a9b      	subs	r3, r3, r2
 800561c:	009b      	lsls	r3, r3, #2
 800561e:	440b      	add	r3, r1
 8005620:	331a      	adds	r3, #26
 8005622:	781b      	ldrb	r3, [r3, #0]
 8005624:	2b01      	cmp	r3, #1
 8005626:	f040 841d 	bne.w	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
 800562a:	78fa      	ldrb	r2, [r7, #3]
 800562c:	6879      	ldr	r1, [r7, #4]
 800562e:	4613      	mov	r3, r2
 8005630:	011b      	lsls	r3, r3, #4
 8005632:	1a9b      	subs	r3, r3, r2
 8005634:	009b      	lsls	r3, r3, #2
 8005636:	440b      	add	r3, r1
 8005638:	331b      	adds	r3, #27
 800563a:	781b      	ldrb	r3, [r3, #0]
 800563c:	2b00      	cmp	r3, #0
 800563e:	f040 8411 	bne.w	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
    {
      if (hhcd->hc[chnum].ep_type != EP_TYPE_ISOC)
 8005642:	78fa      	ldrb	r2, [r7, #3]
 8005644:	6879      	ldr	r1, [r7, #4]
 8005646:	4613      	mov	r3, r2
 8005648:	011b      	lsls	r3, r3, #4
 800564a:	1a9b      	subs	r3, r3, r2
 800564c:	009b      	lsls	r3, r3, #2
 800564e:	440b      	add	r3, r1
 8005650:	3326      	adds	r3, #38	@ 0x26
 8005652:	781b      	ldrb	r3, [r3, #0]
 8005654:	2b01      	cmp	r3, #1
 8005656:	d009      	beq.n	800566c <HCD_HC_OUT_IRQHandler+0x14c>
      {
        hhcd->hc[chnum].do_csplit = 1U;
 8005658:	78fa      	ldrb	r2, [r7, #3]
 800565a:	6879      	ldr	r1, [r7, #4]
 800565c:	4613      	mov	r3, r2
 800565e:	011b      	lsls	r3, r3, #4
 8005660:	1a9b      	subs	r3, r3, r2
 8005662:	009b      	lsls	r3, r3, #2
 8005664:	440b      	add	r3, r1
 8005666:	331b      	adds	r3, #27
 8005668:	2201      	movs	r2, #1
 800566a:	701a      	strb	r2, [r3, #0]
      }

      hhcd->hc[chnum].state = HC_ACK;
 800566c:	78fa      	ldrb	r2, [r7, #3]
 800566e:	6879      	ldr	r1, [r7, #4]
 8005670:	4613      	mov	r3, r2
 8005672:	011b      	lsls	r3, r3, #4
 8005674:	1a9b      	subs	r3, r3, r2
 8005676:	009b      	lsls	r3, r3, #2
 8005678:	440b      	add	r3, r1
 800567a:	334d      	adds	r3, #77	@ 0x4d
 800567c:	2203      	movs	r2, #3
 800567e:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005680:	687b      	ldr	r3, [r7, #4]
 8005682:	681b      	ldr	r3, [r3, #0]
 8005684:	78fa      	ldrb	r2, [r7, #3]
 8005686:	4611      	mov	r1, r2
 8005688:	4618      	mov	r0, r3
 800568a:	f002 fa84 	bl	8007b96 <USB_HC_Halt>

      /* reset error_count */
      hhcd->hc[chnum].ErrCnt = 0U;
 800568e:	78fa      	ldrb	r2, [r7, #3]
 8005690:	6879      	ldr	r1, [r7, #4]
 8005692:	4613      	mov	r3, r2
 8005694:	011b      	lsls	r3, r3, #4
 8005696:	1a9b      	subs	r3, r3, r2
 8005698:	009b      	lsls	r3, r3, #2
 800569a:	440b      	add	r3, r1
 800569c:	3344      	adds	r3, #68	@ 0x44
 800569e:	2200      	movs	r2, #0
 80056a0:	601a      	str	r2, [r3, #0]
 80056a2:	e3df      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 80056a4:	687b      	ldr	r3, [r7, #4]
 80056a6:	681b      	ldr	r3, [r3, #0]
 80056a8:	78fa      	ldrb	r2, [r7, #3]
 80056aa:	4611      	mov	r1, r2
 80056ac:	4618      	mov	r0, r3
 80056ae:	f001 fcce 	bl	800704e <USB_ReadChInterrupts>
 80056b2:	4603      	mov	r3, r0
 80056b4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80056b8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80056bc:	d111      	bne.n	80056e2 <HCD_HC_OUT_IRQHandler+0x1c2>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 80056be:	78fb      	ldrb	r3, [r7, #3]
 80056c0:	015a      	lsls	r2, r3, #5
 80056c2:	693b      	ldr	r3, [r7, #16]
 80056c4:	4413      	add	r3, r2
 80056c6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80056ca:	461a      	mov	r2, r3
 80056cc:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80056d0:	6093      	str	r3, [r2, #8]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80056d2:	687b      	ldr	r3, [r7, #4]
 80056d4:	681b      	ldr	r3, [r3, #0]
 80056d6:	78fa      	ldrb	r2, [r7, #3]
 80056d8:	4611      	mov	r1, r2
 80056da:	4618      	mov	r0, r3
 80056dc:	f002 fa5b 	bl	8007b96 <USB_HC_Halt>
 80056e0:	e3c0      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 80056e2:	687b      	ldr	r3, [r7, #4]
 80056e4:	681b      	ldr	r3, [r3, #0]
 80056e6:	78fa      	ldrb	r2, [r7, #3]
 80056e8:	4611      	mov	r1, r2
 80056ea:	4618      	mov	r0, r3
 80056ec:	f001 fcaf 	bl	800704e <USB_ReadChInterrupts>
 80056f0:	4603      	mov	r3, r0
 80056f2:	f003 0301 	and.w	r3, r3, #1
 80056f6:	2b01      	cmp	r3, #1
 80056f8:	d168      	bne.n	80057cc <HCD_HC_OUT_IRQHandler+0x2ac>
  {
    hhcd->hc[chnum].ErrCnt = 0U;
 80056fa:	78fa      	ldrb	r2, [r7, #3]
 80056fc:	6879      	ldr	r1, [r7, #4]
 80056fe:	4613      	mov	r3, r2
 8005700:	011b      	lsls	r3, r3, #4
 8005702:	1a9b      	subs	r3, r3, r2
 8005704:	009b      	lsls	r3, r3, #2
 8005706:	440b      	add	r3, r1
 8005708:	3344      	adds	r3, #68	@ 0x44
 800570a:	2200      	movs	r2, #0
 800570c:	601a      	str	r2, [r3, #0]

    /* transaction completed with NYET state, update do ping state */
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 800570e:	687b      	ldr	r3, [r7, #4]
 8005710:	681b      	ldr	r3, [r3, #0]
 8005712:	78fa      	ldrb	r2, [r7, #3]
 8005714:	4611      	mov	r1, r2
 8005716:	4618      	mov	r0, r3
 8005718:	f001 fc99 	bl	800704e <USB_ReadChInterrupts>
 800571c:	4603      	mov	r3, r0
 800571e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8005722:	2b40      	cmp	r3, #64	@ 0x40
 8005724:	d112      	bne.n	800574c <HCD_HC_OUT_IRQHandler+0x22c>
    {
      hhcd->hc[chnum].do_ping = 1U;
 8005726:	78fa      	ldrb	r2, [r7, #3]
 8005728:	6879      	ldr	r1, [r7, #4]
 800572a:	4613      	mov	r3, r2
 800572c:	011b      	lsls	r3, r3, #4
 800572e:	1a9b      	subs	r3, r3, r2
 8005730:	009b      	lsls	r3, r3, #2
 8005732:	440b      	add	r3, r1
 8005734:	3319      	adds	r3, #25
 8005736:	2201      	movs	r2, #1
 8005738:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 800573a:	78fb      	ldrb	r3, [r7, #3]
 800573c:	015a      	lsls	r2, r3, #5
 800573e:	693b      	ldr	r3, [r7, #16]
 8005740:	4413      	add	r3, r2
 8005742:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005746:	461a      	mov	r2, r3
 8005748:	2340      	movs	r3, #64	@ 0x40
 800574a:	6093      	str	r3, [r2, #8]
    }

    if (hhcd->hc[chnum].do_csplit != 0U)
 800574c:	78fa      	ldrb	r2, [r7, #3]
 800574e:	6879      	ldr	r1, [r7, #4]
 8005750:	4613      	mov	r3, r2
 8005752:	011b      	lsls	r3, r3, #4
 8005754:	1a9b      	subs	r3, r3, r2
 8005756:	009b      	lsls	r3, r3, #2
 8005758:	440b      	add	r3, r1
 800575a:	331b      	adds	r3, #27
 800575c:	781b      	ldrb	r3, [r3, #0]
 800575e:	2b00      	cmp	r3, #0
 8005760:	d019      	beq.n	8005796 <HCD_HC_OUT_IRQHandler+0x276>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 8005762:	78fa      	ldrb	r2, [r7, #3]
 8005764:	6879      	ldr	r1, [r7, #4]
 8005766:	4613      	mov	r3, r2
 8005768:	011b      	lsls	r3, r3, #4
 800576a:	1a9b      	subs	r3, r3, r2
 800576c:	009b      	lsls	r3, r3, #2
 800576e:	440b      	add	r3, r1
 8005770:	331b      	adds	r3, #27
 8005772:	2200      	movs	r2, #0
 8005774:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8005776:	78fb      	ldrb	r3, [r7, #3]
 8005778:	015a      	lsls	r2, r3, #5
 800577a:	693b      	ldr	r3, [r7, #16]
 800577c:	4413      	add	r3, r2
 800577e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005782:	685b      	ldr	r3, [r3, #4]
 8005784:	78fa      	ldrb	r2, [r7, #3]
 8005786:	0151      	lsls	r1, r2, #5
 8005788:	693a      	ldr	r2, [r7, #16]
 800578a:	440a      	add	r2, r1
 800578c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005790:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005794:	6053      	str	r3, [r2, #4]
    }

    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8005796:	78fb      	ldrb	r3, [r7, #3]
 8005798:	015a      	lsls	r2, r3, #5
 800579a:	693b      	ldr	r3, [r7, #16]
 800579c:	4413      	add	r3, r2
 800579e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80057a2:	461a      	mov	r2, r3
 80057a4:	2301      	movs	r3, #1
 80057a6:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XFRC;
 80057a8:	78fa      	ldrb	r2, [r7, #3]
 80057aa:	6879      	ldr	r1, [r7, #4]
 80057ac:	4613      	mov	r3, r2
 80057ae:	011b      	lsls	r3, r3, #4
 80057b0:	1a9b      	subs	r3, r3, r2
 80057b2:	009b      	lsls	r3, r3, #2
 80057b4:	440b      	add	r3, r1
 80057b6:	334d      	adds	r3, #77	@ 0x4d
 80057b8:	2201      	movs	r2, #1
 80057ba:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80057bc:	687b      	ldr	r3, [r7, #4]
 80057be:	681b      	ldr	r3, [r3, #0]
 80057c0:	78fa      	ldrb	r2, [r7, #3]
 80057c2:	4611      	mov	r1, r2
 80057c4:	4618      	mov	r0, r3
 80057c6:	f002 f9e6 	bl	8007b96 <USB_HC_Halt>
 80057ca:	e34b      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 80057cc:	687b      	ldr	r3, [r7, #4]
 80057ce:	681b      	ldr	r3, [r3, #0]
 80057d0:	78fa      	ldrb	r2, [r7, #3]
 80057d2:	4611      	mov	r1, r2
 80057d4:	4618      	mov	r0, r3
 80057d6:	f001 fc3a 	bl	800704e <USB_ReadChInterrupts>
 80057da:	4603      	mov	r3, r0
 80057dc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80057e0:	2b40      	cmp	r3, #64	@ 0x40
 80057e2:	d139      	bne.n	8005858 <HCD_HC_OUT_IRQHandler+0x338>
  {
    hhcd->hc[chnum].state = HC_NYET;
 80057e4:	78fa      	ldrb	r2, [r7, #3]
 80057e6:	6879      	ldr	r1, [r7, #4]
 80057e8:	4613      	mov	r3, r2
 80057ea:	011b      	lsls	r3, r3, #4
 80057ec:	1a9b      	subs	r3, r3, r2
 80057ee:	009b      	lsls	r3, r3, #2
 80057f0:	440b      	add	r3, r1
 80057f2:	334d      	adds	r3, #77	@ 0x4d
 80057f4:	2205      	movs	r2, #5
 80057f6:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ssplit == 0U)
 80057f8:	78fa      	ldrb	r2, [r7, #3]
 80057fa:	6879      	ldr	r1, [r7, #4]
 80057fc:	4613      	mov	r3, r2
 80057fe:	011b      	lsls	r3, r3, #4
 8005800:	1a9b      	subs	r3, r3, r2
 8005802:	009b      	lsls	r3, r3, #2
 8005804:	440b      	add	r3, r1
 8005806:	331a      	adds	r3, #26
 8005808:	781b      	ldrb	r3, [r3, #0]
 800580a:	2b00      	cmp	r3, #0
 800580c:	d109      	bne.n	8005822 <HCD_HC_OUT_IRQHandler+0x302>
    {
      hhcd->hc[chnum].do_ping = 1U;
 800580e:	78fa      	ldrb	r2, [r7, #3]
 8005810:	6879      	ldr	r1, [r7, #4]
 8005812:	4613      	mov	r3, r2
 8005814:	011b      	lsls	r3, r3, #4
 8005816:	1a9b      	subs	r3, r3, r2
 8005818:	009b      	lsls	r3, r3, #2
 800581a:	440b      	add	r3, r1
 800581c:	3319      	adds	r3, #25
 800581e:	2201      	movs	r2, #1
 8005820:	701a      	strb	r2, [r3, #0]
    }

    hhcd->hc[chnum].ErrCnt = 0U;
 8005822:	78fa      	ldrb	r2, [r7, #3]
 8005824:	6879      	ldr	r1, [r7, #4]
 8005826:	4613      	mov	r3, r2
 8005828:	011b      	lsls	r3, r3, #4
 800582a:	1a9b      	subs	r3, r3, r2
 800582c:	009b      	lsls	r3, r3, #2
 800582e:	440b      	add	r3, r1
 8005830:	3344      	adds	r3, #68	@ 0x44
 8005832:	2200      	movs	r2, #0
 8005834:	601a      	str	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005836:	687b      	ldr	r3, [r7, #4]
 8005838:	681b      	ldr	r3, [r3, #0]
 800583a:	78fa      	ldrb	r2, [r7, #3]
 800583c:	4611      	mov	r1, r2
 800583e:	4618      	mov	r0, r3
 8005840:	f002 f9a9 	bl	8007b96 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8005844:	78fb      	ldrb	r3, [r7, #3]
 8005846:	015a      	lsls	r2, r3, #5
 8005848:	693b      	ldr	r3, [r7, #16]
 800584a:	4413      	add	r3, r2
 800584c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005850:	461a      	mov	r2, r3
 8005852:	2340      	movs	r3, #64	@ 0x40
 8005854:	6093      	str	r3, [r2, #8]
 8005856:	e305      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 8005858:	687b      	ldr	r3, [r7, #4]
 800585a:	681b      	ldr	r3, [r3, #0]
 800585c:	78fa      	ldrb	r2, [r7, #3]
 800585e:	4611      	mov	r1, r2
 8005860:	4618      	mov	r0, r3
 8005862:	f001 fbf4 	bl	800704e <USB_ReadChInterrupts>
 8005866:	4603      	mov	r3, r0
 8005868:	f003 0308 	and.w	r3, r3, #8
 800586c:	2b08      	cmp	r3, #8
 800586e:	d11a      	bne.n	80058a6 <HCD_HC_OUT_IRQHandler+0x386>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8005870:	78fb      	ldrb	r3, [r7, #3]
 8005872:	015a      	lsls	r2, r3, #5
 8005874:	693b      	ldr	r3, [r7, #16]
 8005876:	4413      	add	r3, r2
 8005878:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800587c:	461a      	mov	r2, r3
 800587e:	2308      	movs	r3, #8
 8005880:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_STALL;
 8005882:	78fa      	ldrb	r2, [r7, #3]
 8005884:	6879      	ldr	r1, [r7, #4]
 8005886:	4613      	mov	r3, r2
 8005888:	011b      	lsls	r3, r3, #4
 800588a:	1a9b      	subs	r3, r3, r2
 800588c:	009b      	lsls	r3, r3, #2
 800588e:	440b      	add	r3, r1
 8005890:	334d      	adds	r3, #77	@ 0x4d
 8005892:	2206      	movs	r2, #6
 8005894:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005896:	687b      	ldr	r3, [r7, #4]
 8005898:	681b      	ldr	r3, [r3, #0]
 800589a:	78fa      	ldrb	r2, [r7, #3]
 800589c:	4611      	mov	r1, r2
 800589e:	4618      	mov	r0, r3
 80058a0:	f002 f979 	bl	8007b96 <USB_HC_Halt>
 80058a4:	e2de      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 80058a6:	687b      	ldr	r3, [r7, #4]
 80058a8:	681b      	ldr	r3, [r3, #0]
 80058aa:	78fa      	ldrb	r2, [r7, #3]
 80058ac:	4611      	mov	r1, r2
 80058ae:	4618      	mov	r0, r3
 80058b0:	f001 fbcd 	bl	800704e <USB_ReadChInterrupts>
 80058b4:	4603      	mov	r3, r0
 80058b6:	f003 0310 	and.w	r3, r3, #16
 80058ba:	2b10      	cmp	r3, #16
 80058bc:	d144      	bne.n	8005948 <HCD_HC_OUT_IRQHandler+0x428>
  {
    hhcd->hc[chnum].ErrCnt = 0U;
 80058be:	78fa      	ldrb	r2, [r7, #3]
 80058c0:	6879      	ldr	r1, [r7, #4]
 80058c2:	4613      	mov	r3, r2
 80058c4:	011b      	lsls	r3, r3, #4
 80058c6:	1a9b      	subs	r3, r3, r2
 80058c8:	009b      	lsls	r3, r3, #2
 80058ca:	440b      	add	r3, r1
 80058cc:	3344      	adds	r3, #68	@ 0x44
 80058ce:	2200      	movs	r2, #0
 80058d0:	601a      	str	r2, [r3, #0]
    hhcd->hc[chnum].state = HC_NAK;
 80058d2:	78fa      	ldrb	r2, [r7, #3]
 80058d4:	6879      	ldr	r1, [r7, #4]
 80058d6:	4613      	mov	r3, r2
 80058d8:	011b      	lsls	r3, r3, #4
 80058da:	1a9b      	subs	r3, r3, r2
 80058dc:	009b      	lsls	r3, r3, #2
 80058de:	440b      	add	r3, r1
 80058e0:	334d      	adds	r3, #77	@ 0x4d
 80058e2:	2204      	movs	r2, #4
 80058e4:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ping == 0U)
 80058e6:	78fa      	ldrb	r2, [r7, #3]
 80058e8:	6879      	ldr	r1, [r7, #4]
 80058ea:	4613      	mov	r3, r2
 80058ec:	011b      	lsls	r3, r3, #4
 80058ee:	1a9b      	subs	r3, r3, r2
 80058f0:	009b      	lsls	r3, r3, #2
 80058f2:	440b      	add	r3, r1
 80058f4:	3319      	adds	r3, #25
 80058f6:	781b      	ldrb	r3, [r3, #0]
 80058f8:	2b00      	cmp	r3, #0
 80058fa:	d114      	bne.n	8005926 <HCD_HC_OUT_IRQHandler+0x406>
    {
      if (hhcd->hc[chnum].speed == HCD_DEVICE_SPEED_HIGH)
 80058fc:	78fa      	ldrb	r2, [r7, #3]
 80058fe:	6879      	ldr	r1, [r7, #4]
 8005900:	4613      	mov	r3, r2
 8005902:	011b      	lsls	r3, r3, #4
 8005904:	1a9b      	subs	r3, r3, r2
 8005906:	009b      	lsls	r3, r3, #2
 8005908:	440b      	add	r3, r1
 800590a:	3318      	adds	r3, #24
 800590c:	781b      	ldrb	r3, [r3, #0]
 800590e:	2b00      	cmp	r3, #0
 8005910:	d109      	bne.n	8005926 <HCD_HC_OUT_IRQHandler+0x406>
      {
        hhcd->hc[chnum].do_ping = 1U;
 8005912:	78fa      	ldrb	r2, [r7, #3]
 8005914:	6879      	ldr	r1, [r7, #4]
 8005916:	4613      	mov	r3, r2
 8005918:	011b      	lsls	r3, r3, #4
 800591a:	1a9b      	subs	r3, r3, r2
 800591c:	009b      	lsls	r3, r3, #2
 800591e:	440b      	add	r3, r1
 8005920:	3319      	adds	r3, #25
 8005922:	2201      	movs	r2, #1
 8005924:	701a      	strb	r2, [r3, #0]
      }
    }

    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005926:	687b      	ldr	r3, [r7, #4]
 8005928:	681b      	ldr	r3, [r3, #0]
 800592a:	78fa      	ldrb	r2, [r7, #3]
 800592c:	4611      	mov	r1, r2
 800592e:	4618      	mov	r0, r3
 8005930:	f002 f931 	bl	8007b96 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8005934:	78fb      	ldrb	r3, [r7, #3]
 8005936:	015a      	lsls	r2, r3, #5
 8005938:	693b      	ldr	r3, [r7, #16]
 800593a:	4413      	add	r3, r2
 800593c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005940:	461a      	mov	r2, r3
 8005942:	2310      	movs	r3, #16
 8005944:	6093      	str	r3, [r2, #8]
 8005946:	e28d      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 8005948:	687b      	ldr	r3, [r7, #4]
 800594a:	681b      	ldr	r3, [r3, #0]
 800594c:	78fa      	ldrb	r2, [r7, #3]
 800594e:	4611      	mov	r1, r2
 8005950:	4618      	mov	r0, r3
 8005952:	f001 fb7c 	bl	800704e <USB_ReadChInterrupts>
 8005956:	4603      	mov	r3, r0
 8005958:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800595c:	2b80      	cmp	r3, #128	@ 0x80
 800595e:	d169      	bne.n	8005a34 <HCD_HC_OUT_IRQHandler+0x514>
  {
    if (hhcd->Init.dma_enable == 0U)
 8005960:	687b      	ldr	r3, [r7, #4]
 8005962:	799b      	ldrb	r3, [r3, #6]
 8005964:	2b00      	cmp	r3, #0
 8005966:	d111      	bne.n	800598c <HCD_HC_OUT_IRQHandler+0x46c>
    {
      hhcd->hc[chnum].state = HC_XACTERR;
 8005968:	78fa      	ldrb	r2, [r7, #3]
 800596a:	6879      	ldr	r1, [r7, #4]
 800596c:	4613      	mov	r3, r2
 800596e:	011b      	lsls	r3, r3, #4
 8005970:	1a9b      	subs	r3, r3, r2
 8005972:	009b      	lsls	r3, r3, #2
 8005974:	440b      	add	r3, r1
 8005976:	334d      	adds	r3, #77	@ 0x4d
 8005978:	2207      	movs	r2, #7
 800597a:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 800597c:	687b      	ldr	r3, [r7, #4]
 800597e:	681b      	ldr	r3, [r3, #0]
 8005980:	78fa      	ldrb	r2, [r7, #3]
 8005982:	4611      	mov	r1, r2
 8005984:	4618      	mov	r0, r3
 8005986:	f002 f906 	bl	8007b96 <USB_HC_Halt>
 800598a:	e049      	b.n	8005a20 <HCD_HC_OUT_IRQHandler+0x500>
    }
    else
    {
      hhcd->hc[chnum].ErrCnt++;
 800598c:	78fa      	ldrb	r2, [r7, #3]
 800598e:	6879      	ldr	r1, [r7, #4]
 8005990:	4613      	mov	r3, r2
 8005992:	011b      	lsls	r3, r3, #4
 8005994:	1a9b      	subs	r3, r3, r2
 8005996:	009b      	lsls	r3, r3, #2
 8005998:	440b      	add	r3, r1
 800599a:	3344      	adds	r3, #68	@ 0x44
 800599c:	681b      	ldr	r3, [r3, #0]
 800599e:	1c59      	adds	r1, r3, #1
 80059a0:	6878      	ldr	r0, [r7, #4]
 80059a2:	4613      	mov	r3, r2
 80059a4:	011b      	lsls	r3, r3, #4
 80059a6:	1a9b      	subs	r3, r3, r2
 80059a8:	009b      	lsls	r3, r3, #2
 80059aa:	4403      	add	r3, r0
 80059ac:	3344      	adds	r3, #68	@ 0x44
 80059ae:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 80059b0:	78fa      	ldrb	r2, [r7, #3]
 80059b2:	6879      	ldr	r1, [r7, #4]
 80059b4:	4613      	mov	r3, r2
 80059b6:	011b      	lsls	r3, r3, #4
 80059b8:	1a9b      	subs	r3, r3, r2
 80059ba:	009b      	lsls	r3, r3, #2
 80059bc:	440b      	add	r3, r1
 80059be:	3344      	adds	r3, #68	@ 0x44
 80059c0:	681b      	ldr	r3, [r3, #0]
 80059c2:	2b02      	cmp	r3, #2
 80059c4:	d922      	bls.n	8005a0c <HCD_HC_OUT_IRQHandler+0x4ec>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 80059c6:	78fa      	ldrb	r2, [r7, #3]
 80059c8:	6879      	ldr	r1, [r7, #4]
 80059ca:	4613      	mov	r3, r2
 80059cc:	011b      	lsls	r3, r3, #4
 80059ce:	1a9b      	subs	r3, r3, r2
 80059d0:	009b      	lsls	r3, r3, #2
 80059d2:	440b      	add	r3, r1
 80059d4:	3344      	adds	r3, #68	@ 0x44
 80059d6:	2200      	movs	r2, #0
 80059d8:	601a      	str	r2, [r3, #0]
        hhcd->hc[chnum].urb_state = URB_ERROR;
 80059da:	78fa      	ldrb	r2, [r7, #3]
 80059dc:	6879      	ldr	r1, [r7, #4]
 80059de:	4613      	mov	r3, r2
 80059e0:	011b      	lsls	r3, r3, #4
 80059e2:	1a9b      	subs	r3, r3, r2
 80059e4:	009b      	lsls	r3, r3, #2
 80059e6:	440b      	add	r3, r1
 80059e8:	334c      	adds	r3, #76	@ 0x4c
 80059ea:	2204      	movs	r2, #4
 80059ec:	701a      	strb	r2, [r3, #0]

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
        hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 80059ee:	78fa      	ldrb	r2, [r7, #3]
 80059f0:	6879      	ldr	r1, [r7, #4]
 80059f2:	4613      	mov	r3, r2
 80059f4:	011b      	lsls	r3, r3, #4
 80059f6:	1a9b      	subs	r3, r3, r2
 80059f8:	009b      	lsls	r3, r3, #2
 80059fa:	440b      	add	r3, r1
 80059fc:	334c      	adds	r3, #76	@ 0x4c
 80059fe:	781a      	ldrb	r2, [r3, #0]
 8005a00:	78fb      	ldrb	r3, [r7, #3]
 8005a02:	4619      	mov	r1, r3
 8005a04:	6878      	ldr	r0, [r7, #4]
 8005a06:	f027 faab 	bl	802cf60 <HAL_HCD_HC_NotifyURBChange_Callback>
 8005a0a:	e009      	b.n	8005a20 <HCD_HC_OUT_IRQHandler+0x500>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005a0c:	78fa      	ldrb	r2, [r7, #3]
 8005a0e:	6879      	ldr	r1, [r7, #4]
 8005a10:	4613      	mov	r3, r2
 8005a12:	011b      	lsls	r3, r3, #4
 8005a14:	1a9b      	subs	r3, r3, r2
 8005a16:	009b      	lsls	r3, r3, #2
 8005a18:	440b      	add	r3, r1
 8005a1a:	334c      	adds	r3, #76	@ 0x4c
 8005a1c:	2202      	movs	r2, #2
 8005a1e:	701a      	strb	r2, [r3, #0]
      }
    }
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8005a20:	78fb      	ldrb	r3, [r7, #3]
 8005a22:	015a      	lsls	r2, r3, #5
 8005a24:	693b      	ldr	r3, [r7, #16]
 8005a26:	4413      	add	r3, r2
 8005a28:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005a2c:	461a      	mov	r2, r3
 8005a2e:	2380      	movs	r3, #128	@ 0x80
 8005a30:	6093      	str	r3, [r2, #8]
 8005a32:	e217      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8005a34:	687b      	ldr	r3, [r7, #4]
 8005a36:	681b      	ldr	r3, [r3, #0]
 8005a38:	78fa      	ldrb	r2, [r7, #3]
 8005a3a:	4611      	mov	r1, r2
 8005a3c:	4618      	mov	r0, r3
 8005a3e:	f001 fb06 	bl	800704e <USB_ReadChInterrupts>
 8005a42:	4603      	mov	r3, r0
 8005a44:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8005a48:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8005a4c:	d11b      	bne.n	8005a86 <HCD_HC_OUT_IRQHandler+0x566>
  {
    hhcd->hc[chnum].state = HC_DATATGLERR;
 8005a4e:	78fa      	ldrb	r2, [r7, #3]
 8005a50:	6879      	ldr	r1, [r7, #4]
 8005a52:	4613      	mov	r3, r2
 8005a54:	011b      	lsls	r3, r3, #4
 8005a56:	1a9b      	subs	r3, r3, r2
 8005a58:	009b      	lsls	r3, r3, #2
 8005a5a:	440b      	add	r3, r1
 8005a5c:	334d      	adds	r3, #77	@ 0x4d
 8005a5e:	2209      	movs	r2, #9
 8005a60:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005a62:	687b      	ldr	r3, [r7, #4]
 8005a64:	681b      	ldr	r3, [r3, #0]
 8005a66:	78fa      	ldrb	r2, [r7, #3]
 8005a68:	4611      	mov	r1, r2
 8005a6a:	4618      	mov	r0, r3
 8005a6c:	f002 f893 	bl	8007b96 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 8005a70:	78fb      	ldrb	r3, [r7, #3]
 8005a72:	015a      	lsls	r2, r3, #5
 8005a74:	693b      	ldr	r3, [r7, #16]
 8005a76:	4413      	add	r3, r2
 8005a78:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005a7c:	461a      	mov	r2, r3
 8005a7e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8005a82:	6093      	str	r3, [r2, #8]
 8005a84:	e1ee      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 8005a86:	687b      	ldr	r3, [r7, #4]
 8005a88:	681b      	ldr	r3, [r3, #0]
 8005a8a:	78fa      	ldrb	r2, [r7, #3]
 8005a8c:	4611      	mov	r1, r2
 8005a8e:	4618      	mov	r0, r3
 8005a90:	f001 fadd 	bl	800704e <USB_ReadChInterrupts>
 8005a94:	4603      	mov	r3, r0
 8005a96:	f003 0302 	and.w	r3, r3, #2
 8005a9a:	2b02      	cmp	r3, #2
 8005a9c:	f040 81df 	bne.w	8005e5e <HCD_HC_OUT_IRQHandler+0x93e>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 8005aa0:	78fb      	ldrb	r3, [r7, #3]
 8005aa2:	015a      	lsls	r2, r3, #5
 8005aa4:	693b      	ldr	r3, [r7, #16]
 8005aa6:	4413      	add	r3, r2
 8005aa8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005aac:	461a      	mov	r2, r3
 8005aae:	2302      	movs	r3, #2
 8005ab0:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].state == HC_XFRC)
 8005ab2:	78fa      	ldrb	r2, [r7, #3]
 8005ab4:	6879      	ldr	r1, [r7, #4]
 8005ab6:	4613      	mov	r3, r2
 8005ab8:	011b      	lsls	r3, r3, #4
 8005aba:	1a9b      	subs	r3, r3, r2
 8005abc:	009b      	lsls	r3, r3, #2
 8005abe:	440b      	add	r3, r1
 8005ac0:	334d      	adds	r3, #77	@ 0x4d
 8005ac2:	781b      	ldrb	r3, [r3, #0]
 8005ac4:	2b01      	cmp	r3, #1
 8005ac6:	f040 8093 	bne.w	8005bf0 <HCD_HC_OUT_IRQHandler+0x6d0>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005aca:	78fa      	ldrb	r2, [r7, #3]
 8005acc:	6879      	ldr	r1, [r7, #4]
 8005ace:	4613      	mov	r3, r2
 8005ad0:	011b      	lsls	r3, r3, #4
 8005ad2:	1a9b      	subs	r3, r3, r2
 8005ad4:	009b      	lsls	r3, r3, #2
 8005ad6:	440b      	add	r3, r1
 8005ad8:	334d      	adds	r3, #77	@ 0x4d
 8005ada:	2202      	movs	r2, #2
 8005adc:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 8005ade:	78fa      	ldrb	r2, [r7, #3]
 8005ae0:	6879      	ldr	r1, [r7, #4]
 8005ae2:	4613      	mov	r3, r2
 8005ae4:	011b      	lsls	r3, r3, #4
 8005ae6:	1a9b      	subs	r3, r3, r2
 8005ae8:	009b      	lsls	r3, r3, #2
 8005aea:	440b      	add	r3, r1
 8005aec:	334c      	adds	r3, #76	@ 0x4c
 8005aee:	2201      	movs	r2, #1
 8005af0:	701a      	strb	r2, [r3, #0]

      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 8005af2:	78fa      	ldrb	r2, [r7, #3]
 8005af4:	6879      	ldr	r1, [r7, #4]
 8005af6:	4613      	mov	r3, r2
 8005af8:	011b      	lsls	r3, r3, #4
 8005afa:	1a9b      	subs	r3, r3, r2
 8005afc:	009b      	lsls	r3, r3, #2
 8005afe:	440b      	add	r3, r1
 8005b00:	3326      	adds	r3, #38	@ 0x26
 8005b02:	781b      	ldrb	r3, [r3, #0]
 8005b04:	2b02      	cmp	r3, #2
 8005b06:	d00b      	beq.n	8005b20 <HCD_HC_OUT_IRQHandler+0x600>
          (hhcd->hc[chnum].ep_type == EP_TYPE_INTR))
 8005b08:	78fa      	ldrb	r2, [r7, #3]
 8005b0a:	6879      	ldr	r1, [r7, #4]
 8005b0c:	4613      	mov	r3, r2
 8005b0e:	011b      	lsls	r3, r3, #4
 8005b10:	1a9b      	subs	r3, r3, r2
 8005b12:	009b      	lsls	r3, r3, #2
 8005b14:	440b      	add	r3, r1
 8005b16:	3326      	adds	r3, #38	@ 0x26
 8005b18:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 8005b1a:	2b03      	cmp	r3, #3
 8005b1c:	f040 8190 	bne.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
      {
        if (hhcd->Init.dma_enable == 0U)
 8005b20:	687b      	ldr	r3, [r7, #4]
 8005b22:	799b      	ldrb	r3, [r3, #6]
 8005b24:	2b00      	cmp	r3, #0
 8005b26:	d115      	bne.n	8005b54 <HCD_HC_OUT_IRQHandler+0x634>
        {
          hhcd->hc[chnum].toggle_out ^= 1U;
 8005b28:	78fa      	ldrb	r2, [r7, #3]
 8005b2a:	6879      	ldr	r1, [r7, #4]
 8005b2c:	4613      	mov	r3, r2
 8005b2e:	011b      	lsls	r3, r3, #4
 8005b30:	1a9b      	subs	r3, r3, r2
 8005b32:	009b      	lsls	r3, r3, #2
 8005b34:	440b      	add	r3, r1
 8005b36:	333d      	adds	r3, #61	@ 0x3d
 8005b38:	781b      	ldrb	r3, [r3, #0]
 8005b3a:	78fa      	ldrb	r2, [r7, #3]
 8005b3c:	f083 0301 	eor.w	r3, r3, #1
 8005b40:	b2d8      	uxtb	r0, r3
 8005b42:	6879      	ldr	r1, [r7, #4]
 8005b44:	4613      	mov	r3, r2
 8005b46:	011b      	lsls	r3, r3, #4
 8005b48:	1a9b      	subs	r3, r3, r2
 8005b4a:	009b      	lsls	r3, r3, #2
 8005b4c:	440b      	add	r3, r1
 8005b4e:	333d      	adds	r3, #61	@ 0x3d
 8005b50:	4602      	mov	r2, r0
 8005b52:	701a      	strb	r2, [r3, #0]
        }

        if ((hhcd->Init.dma_enable == 1U) && (hhcd->hc[chnum].xfer_len > 0U))
 8005b54:	687b      	ldr	r3, [r7, #4]
 8005b56:	799b      	ldrb	r3, [r3, #6]
 8005b58:	2b01      	cmp	r3, #1
 8005b5a:	f040 8171 	bne.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
 8005b5e:	78fa      	ldrb	r2, [r7, #3]
 8005b60:	6879      	ldr	r1, [r7, #4]
 8005b62:	4613      	mov	r3, r2
 8005b64:	011b      	lsls	r3, r3, #4
 8005b66:	1a9b      	subs	r3, r3, r2
 8005b68:	009b      	lsls	r3, r3, #2
 8005b6a:	440b      	add	r3, r1
 8005b6c:	3334      	adds	r3, #52	@ 0x34
 8005b6e:	681b      	ldr	r3, [r3, #0]
 8005b70:	2b00      	cmp	r3, #0
 8005b72:	f000 8165 	beq.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
        {
          num_packets = (hhcd->hc[chnum].xfer_len + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet;
 8005b76:	78fa      	ldrb	r2, [r7, #3]
 8005b78:	6879      	ldr	r1, [r7, #4]
 8005b7a:	4613      	mov	r3, r2
 8005b7c:	011b      	lsls	r3, r3, #4
 8005b7e:	1a9b      	subs	r3, r3, r2
 8005b80:	009b      	lsls	r3, r3, #2
 8005b82:	440b      	add	r3, r1
 8005b84:	3334      	adds	r3, #52	@ 0x34
 8005b86:	6819      	ldr	r1, [r3, #0]
 8005b88:	78fa      	ldrb	r2, [r7, #3]
 8005b8a:	6878      	ldr	r0, [r7, #4]
 8005b8c:	4613      	mov	r3, r2
 8005b8e:	011b      	lsls	r3, r3, #4
 8005b90:	1a9b      	subs	r3, r3, r2
 8005b92:	009b      	lsls	r3, r3, #2
 8005b94:	4403      	add	r3, r0
 8005b96:	3328      	adds	r3, #40	@ 0x28
 8005b98:	881b      	ldrh	r3, [r3, #0]
 8005b9a:	440b      	add	r3, r1
 8005b9c:	1e59      	subs	r1, r3, #1
 8005b9e:	78fa      	ldrb	r2, [r7, #3]
 8005ba0:	6878      	ldr	r0, [r7, #4]
 8005ba2:	4613      	mov	r3, r2
 8005ba4:	011b      	lsls	r3, r3, #4
 8005ba6:	1a9b      	subs	r3, r3, r2
 8005ba8:	009b      	lsls	r3, r3, #2
 8005baa:	4403      	add	r3, r0
 8005bac:	3328      	adds	r3, #40	@ 0x28
 8005bae:	881b      	ldrh	r3, [r3, #0]
 8005bb0:	fbb1 f3f3 	udiv	r3, r1, r3
 8005bb4:	60bb      	str	r3, [r7, #8]

          if ((num_packets & 1U) != 0U)
 8005bb6:	68bb      	ldr	r3, [r7, #8]
 8005bb8:	f003 0301 	and.w	r3, r3, #1
 8005bbc:	2b00      	cmp	r3, #0
 8005bbe:	f000 813f 	beq.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
          {
            hhcd->hc[chnum].toggle_out ^= 1U;
 8005bc2:	78fa      	ldrb	r2, [r7, #3]
 8005bc4:	6879      	ldr	r1, [r7, #4]
 8005bc6:	4613      	mov	r3, r2
 8005bc8:	011b      	lsls	r3, r3, #4
 8005bca:	1a9b      	subs	r3, r3, r2
 8005bcc:	009b      	lsls	r3, r3, #2
 8005bce:	440b      	add	r3, r1
 8005bd0:	333d      	adds	r3, #61	@ 0x3d
 8005bd2:	781b      	ldrb	r3, [r3, #0]
 8005bd4:	78fa      	ldrb	r2, [r7, #3]
 8005bd6:	f083 0301 	eor.w	r3, r3, #1
 8005bda:	b2d8      	uxtb	r0, r3
 8005bdc:	6879      	ldr	r1, [r7, #4]
 8005bde:	4613      	mov	r3, r2
 8005be0:	011b      	lsls	r3, r3, #4
 8005be2:	1a9b      	subs	r3, r3, r2
 8005be4:	009b      	lsls	r3, r3, #2
 8005be6:	440b      	add	r3, r1
 8005be8:	333d      	adds	r3, #61	@ 0x3d
 8005bea:	4602      	mov	r2, r0
 8005bec:	701a      	strb	r2, [r3, #0]
 8005bee:	e127      	b.n	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
          }
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_ACK)
 8005bf0:	78fa      	ldrb	r2, [r7, #3]
 8005bf2:	6879      	ldr	r1, [r7, #4]
 8005bf4:	4613      	mov	r3, r2
 8005bf6:	011b      	lsls	r3, r3, #4
 8005bf8:	1a9b      	subs	r3, r3, r2
 8005bfa:	009b      	lsls	r3, r3, #2
 8005bfc:	440b      	add	r3, r1
 8005bfe:	334d      	adds	r3, #77	@ 0x4d
 8005c00:	781b      	ldrb	r3, [r3, #0]
 8005c02:	2b03      	cmp	r3, #3
 8005c04:	d120      	bne.n	8005c48 <HCD_HC_OUT_IRQHandler+0x728>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005c06:	78fa      	ldrb	r2, [r7, #3]
 8005c08:	6879      	ldr	r1, [r7, #4]
 8005c0a:	4613      	mov	r3, r2
 8005c0c:	011b      	lsls	r3, r3, #4
 8005c0e:	1a9b      	subs	r3, r3, r2
 8005c10:	009b      	lsls	r3, r3, #2
 8005c12:	440b      	add	r3, r1
 8005c14:	334d      	adds	r3, #77	@ 0x4d
 8005c16:	2202      	movs	r2, #2
 8005c18:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8005c1a:	78fa      	ldrb	r2, [r7, #3]
 8005c1c:	6879      	ldr	r1, [r7, #4]
 8005c1e:	4613      	mov	r3, r2
 8005c20:	011b      	lsls	r3, r3, #4
 8005c22:	1a9b      	subs	r3, r3, r2
 8005c24:	009b      	lsls	r3, r3, #2
 8005c26:	440b      	add	r3, r1
 8005c28:	331b      	adds	r3, #27
 8005c2a:	781b      	ldrb	r3, [r3, #0]
 8005c2c:	2b01      	cmp	r3, #1
 8005c2e:	f040 8107 	bne.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005c32:	78fa      	ldrb	r2, [r7, #3]
 8005c34:	6879      	ldr	r1, [r7, #4]
 8005c36:	4613      	mov	r3, r2
 8005c38:	011b      	lsls	r3, r3, #4
 8005c3a:	1a9b      	subs	r3, r3, r2
 8005c3c:	009b      	lsls	r3, r3, #2
 8005c3e:	440b      	add	r3, r1
 8005c40:	334c      	adds	r3, #76	@ 0x4c
 8005c42:	2202      	movs	r2, #2
 8005c44:	701a      	strb	r2, [r3, #0]
 8005c46:	e0fb      	b.n	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
      }
    }
    else if (hhcd->hc[chnum].state == HC_NAK)
 8005c48:	78fa      	ldrb	r2, [r7, #3]
 8005c4a:	6879      	ldr	r1, [r7, #4]
 8005c4c:	4613      	mov	r3, r2
 8005c4e:	011b      	lsls	r3, r3, #4
 8005c50:	1a9b      	subs	r3, r3, r2
 8005c52:	009b      	lsls	r3, r3, #2
 8005c54:	440b      	add	r3, r1
 8005c56:	334d      	adds	r3, #77	@ 0x4d
 8005c58:	781b      	ldrb	r3, [r3, #0]
 8005c5a:	2b04      	cmp	r3, #4
 8005c5c:	d13a      	bne.n	8005cd4 <HCD_HC_OUT_IRQHandler+0x7b4>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005c5e:	78fa      	ldrb	r2, [r7, #3]
 8005c60:	6879      	ldr	r1, [r7, #4]
 8005c62:	4613      	mov	r3, r2
 8005c64:	011b      	lsls	r3, r3, #4
 8005c66:	1a9b      	subs	r3, r3, r2
 8005c68:	009b      	lsls	r3, r3, #2
 8005c6a:	440b      	add	r3, r1
 8005c6c:	334d      	adds	r3, #77	@ 0x4d
 8005c6e:	2202      	movs	r2, #2
 8005c70:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005c72:	78fa      	ldrb	r2, [r7, #3]
 8005c74:	6879      	ldr	r1, [r7, #4]
 8005c76:	4613      	mov	r3, r2
 8005c78:	011b      	lsls	r3, r3, #4
 8005c7a:	1a9b      	subs	r3, r3, r2
 8005c7c:	009b      	lsls	r3, r3, #2
 8005c7e:	440b      	add	r3, r1
 8005c80:	334c      	adds	r3, #76	@ 0x4c
 8005c82:	2202      	movs	r2, #2
 8005c84:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8005c86:	78fa      	ldrb	r2, [r7, #3]
 8005c88:	6879      	ldr	r1, [r7, #4]
 8005c8a:	4613      	mov	r3, r2
 8005c8c:	011b      	lsls	r3, r3, #4
 8005c8e:	1a9b      	subs	r3, r3, r2
 8005c90:	009b      	lsls	r3, r3, #2
 8005c92:	440b      	add	r3, r1
 8005c94:	331b      	adds	r3, #27
 8005c96:	781b      	ldrb	r3, [r3, #0]
 8005c98:	2b01      	cmp	r3, #1
 8005c9a:	f040 80d1 	bne.w	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
      {
        hhcd->hc[chnum].do_csplit = 0U;
 8005c9e:	78fa      	ldrb	r2, [r7, #3]
 8005ca0:	6879      	ldr	r1, [r7, #4]
 8005ca2:	4613      	mov	r3, r2
 8005ca4:	011b      	lsls	r3, r3, #4
 8005ca6:	1a9b      	subs	r3, r3, r2
 8005ca8:	009b      	lsls	r3, r3, #2
 8005caa:	440b      	add	r3, r1
 8005cac:	331b      	adds	r3, #27
 8005cae:	2200      	movs	r2, #0
 8005cb0:	701a      	strb	r2, [r3, #0]
        __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8005cb2:	78fb      	ldrb	r3, [r7, #3]
 8005cb4:	015a      	lsls	r2, r3, #5
 8005cb6:	693b      	ldr	r3, [r7, #16]
 8005cb8:	4413      	add	r3, r2
 8005cba:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005cbe:	685b      	ldr	r3, [r3, #4]
 8005cc0:	78fa      	ldrb	r2, [r7, #3]
 8005cc2:	0151      	lsls	r1, r2, #5
 8005cc4:	693a      	ldr	r2, [r7, #16]
 8005cc6:	440a      	add	r2, r1
 8005cc8:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005ccc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005cd0:	6053      	str	r3, [r2, #4]
 8005cd2:	e0b5      	b.n	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
      }
    }
    else if (hhcd->hc[chnum].state == HC_NYET)
 8005cd4:	78fa      	ldrb	r2, [r7, #3]
 8005cd6:	6879      	ldr	r1, [r7, #4]
 8005cd8:	4613      	mov	r3, r2
 8005cda:	011b      	lsls	r3, r3, #4
 8005cdc:	1a9b      	subs	r3, r3, r2
 8005cde:	009b      	lsls	r3, r3, #2
 8005ce0:	440b      	add	r3, r1
 8005ce2:	334d      	adds	r3, #77	@ 0x4d
 8005ce4:	781b      	ldrb	r3, [r3, #0]
 8005ce6:	2b05      	cmp	r3, #5
 8005ce8:	d114      	bne.n	8005d14 <HCD_HC_OUT_IRQHandler+0x7f4>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005cea:	78fa      	ldrb	r2, [r7, #3]
 8005cec:	6879      	ldr	r1, [r7, #4]
 8005cee:	4613      	mov	r3, r2
 8005cf0:	011b      	lsls	r3, r3, #4
 8005cf2:	1a9b      	subs	r3, r3, r2
 8005cf4:	009b      	lsls	r3, r3, #2
 8005cf6:	440b      	add	r3, r1
 8005cf8:	334d      	adds	r3, #77	@ 0x4d
 8005cfa:	2202      	movs	r2, #2
 8005cfc:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state  = URB_NOTREADY;
 8005cfe:	78fa      	ldrb	r2, [r7, #3]
 8005d00:	6879      	ldr	r1, [r7, #4]
 8005d02:	4613      	mov	r3, r2
 8005d04:	011b      	lsls	r3, r3, #4
 8005d06:	1a9b      	subs	r3, r3, r2
 8005d08:	009b      	lsls	r3, r3, #2
 8005d0a:	440b      	add	r3, r1
 8005d0c:	334c      	adds	r3, #76	@ 0x4c
 8005d0e:	2202      	movs	r2, #2
 8005d10:	701a      	strb	r2, [r3, #0]
 8005d12:	e095      	b.n	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
    }
    else if (hhcd->hc[chnum].state == HC_STALL)
 8005d14:	78fa      	ldrb	r2, [r7, #3]
 8005d16:	6879      	ldr	r1, [r7, #4]
 8005d18:	4613      	mov	r3, r2
 8005d1a:	011b      	lsls	r3, r3, #4
 8005d1c:	1a9b      	subs	r3, r3, r2
 8005d1e:	009b      	lsls	r3, r3, #2
 8005d20:	440b      	add	r3, r1
 8005d22:	334d      	adds	r3, #77	@ 0x4d
 8005d24:	781b      	ldrb	r3, [r3, #0]
 8005d26:	2b06      	cmp	r3, #6
 8005d28:	d114      	bne.n	8005d54 <HCD_HC_OUT_IRQHandler+0x834>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005d2a:	78fa      	ldrb	r2, [r7, #3]
 8005d2c:	6879      	ldr	r1, [r7, #4]
 8005d2e:	4613      	mov	r3, r2
 8005d30:	011b      	lsls	r3, r3, #4
 8005d32:	1a9b      	subs	r3, r3, r2
 8005d34:	009b      	lsls	r3, r3, #2
 8005d36:	440b      	add	r3, r1
 8005d38:	334d      	adds	r3, #77	@ 0x4d
 8005d3a:	2202      	movs	r2, #2
 8005d3c:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state  = URB_STALL;
 8005d3e:	78fa      	ldrb	r2, [r7, #3]
 8005d40:	6879      	ldr	r1, [r7, #4]
 8005d42:	4613      	mov	r3, r2
 8005d44:	011b      	lsls	r3, r3, #4
 8005d46:	1a9b      	subs	r3, r3, r2
 8005d48:	009b      	lsls	r3, r3, #2
 8005d4a:	440b      	add	r3, r1
 8005d4c:	334c      	adds	r3, #76	@ 0x4c
 8005d4e:	2205      	movs	r2, #5
 8005d50:	701a      	strb	r2, [r3, #0]
 8005d52:	e075      	b.n	8005e40 <HCD_HC_OUT_IRQHandler+0x920>
    }
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8005d54:	78fa      	ldrb	r2, [r7, #3]
 8005d56:	6879      	ldr	r1, [r7, #4]
 8005d58:	4613      	mov	r3, r2
 8005d5a:	011b      	lsls	r3, r3, #4
 8005d5c:	1a9b      	subs	r3, r3, r2
 8005d5e:	009b      	lsls	r3, r3, #2
 8005d60:	440b      	add	r3, r1
 8005d62:	334d      	adds	r3, #77	@ 0x4d
 8005d64:	781b      	ldrb	r3, [r3, #0]
 8005d66:	2b07      	cmp	r3, #7
 8005d68:	d00a      	beq.n	8005d80 <HCD_HC_OUT_IRQHandler+0x860>
             (hhcd->hc[chnum].state == HC_DATATGLERR))
 8005d6a:	78fa      	ldrb	r2, [r7, #3]
 8005d6c:	6879      	ldr	r1, [r7, #4]
 8005d6e:	4613      	mov	r3, r2
 8005d70:	011b      	lsls	r3, r3, #4
 8005d72:	1a9b      	subs	r3, r3, r2
 8005d74:	009b      	lsls	r3, r3, #2
 8005d76:	440b      	add	r3, r1
 8005d78:	334d      	adds	r3, #77	@ 0x4d
 8005d7a:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8005d7c:	2b09      	cmp	r3, #9
 8005d7e:	d170      	bne.n	8005e62 <HCD_HC_OUT_IRQHandler+0x942>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005d80:	78fa      	ldrb	r2, [r7, #3]
 8005d82:	6879      	ldr	r1, [r7, #4]
 8005d84:	4613      	mov	r3, r2
 8005d86:	011b      	lsls	r3, r3, #4
 8005d88:	1a9b      	subs	r3, r3, r2
 8005d8a:	009b      	lsls	r3, r3, #2
 8005d8c:	440b      	add	r3, r1
 8005d8e:	334d      	adds	r3, #77	@ 0x4d
 8005d90:	2202      	movs	r2, #2
 8005d92:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 8005d94:	78fa      	ldrb	r2, [r7, #3]
 8005d96:	6879      	ldr	r1, [r7, #4]
 8005d98:	4613      	mov	r3, r2
 8005d9a:	011b      	lsls	r3, r3, #4
 8005d9c:	1a9b      	subs	r3, r3, r2
 8005d9e:	009b      	lsls	r3, r3, #2
 8005da0:	440b      	add	r3, r1
 8005da2:	3344      	adds	r3, #68	@ 0x44
 8005da4:	681b      	ldr	r3, [r3, #0]
 8005da6:	1c59      	adds	r1, r3, #1
 8005da8:	6878      	ldr	r0, [r7, #4]
 8005daa:	4613      	mov	r3, r2
 8005dac:	011b      	lsls	r3, r3, #4
 8005dae:	1a9b      	subs	r3, r3, r2
 8005db0:	009b      	lsls	r3, r3, #2
 8005db2:	4403      	add	r3, r0
 8005db4:	3344      	adds	r3, #68	@ 0x44
 8005db6:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005db8:	78fa      	ldrb	r2, [r7, #3]
 8005dba:	6879      	ldr	r1, [r7, #4]
 8005dbc:	4613      	mov	r3, r2
 8005dbe:	011b      	lsls	r3, r3, #4
 8005dc0:	1a9b      	subs	r3, r3, r2
 8005dc2:	009b      	lsls	r3, r3, #2
 8005dc4:	440b      	add	r3, r1
 8005dc6:	3344      	adds	r3, #68	@ 0x44
 8005dc8:	681b      	ldr	r3, [r3, #0]
 8005dca:	2b02      	cmp	r3, #2
 8005dcc:	d914      	bls.n	8005df8 <HCD_HC_OUT_IRQHandler+0x8d8>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 8005dce:	78fa      	ldrb	r2, [r7, #3]
 8005dd0:	6879      	ldr	r1, [r7, #4]
 8005dd2:	4613      	mov	r3, r2
 8005dd4:	011b      	lsls	r3, r3, #4
 8005dd6:	1a9b      	subs	r3, r3, r2
 8005dd8:	009b      	lsls	r3, r3, #2
 8005dda:	440b      	add	r3, r1
 8005ddc:	3344      	adds	r3, #68	@ 0x44
 8005dde:	2200      	movs	r2, #0
 8005de0:	601a      	str	r2, [r3, #0]
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8005de2:	78fa      	ldrb	r2, [r7, #3]
 8005de4:	6879      	ldr	r1, [r7, #4]
 8005de6:	4613      	mov	r3, r2
 8005de8:	011b      	lsls	r3, r3, #4
 8005dea:	1a9b      	subs	r3, r3, r2
 8005dec:	009b      	lsls	r3, r3, #2
 8005dee:	440b      	add	r3, r1
 8005df0:	334c      	adds	r3, #76	@ 0x4c
 8005df2:	2204      	movs	r2, #4
 8005df4:	701a      	strb	r2, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005df6:	e022      	b.n	8005e3e <HCD_HC_OUT_IRQHandler+0x91e>
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005df8:	78fa      	ldrb	r2, [r7, #3]
 8005dfa:	6879      	ldr	r1, [r7, #4]
 8005dfc:	4613      	mov	r3, r2
 8005dfe:	011b      	lsls	r3, r3, #4
 8005e00:	1a9b      	subs	r3, r3, r2
 8005e02:	009b      	lsls	r3, r3, #2
 8005e04:	440b      	add	r3, r1
 8005e06:	334c      	adds	r3, #76	@ 0x4c
 8005e08:	2202      	movs	r2, #2
 8005e0a:	701a      	strb	r2, [r3, #0]

        /* re-activate the channel  */
        tmpreg = USBx_HC(chnum)->HCCHAR;
 8005e0c:	78fb      	ldrb	r3, [r7, #3]
 8005e0e:	015a      	lsls	r2, r3, #5
 8005e10:	693b      	ldr	r3, [r7, #16]
 8005e12:	4413      	add	r3, r2
 8005e14:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005e18:	681b      	ldr	r3, [r3, #0]
 8005e1a:	60fb      	str	r3, [r7, #12]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005e1c:	68fb      	ldr	r3, [r7, #12]
 8005e1e:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005e22:	60fb      	str	r3, [r7, #12]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005e24:	68fb      	ldr	r3, [r7, #12]
 8005e26:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8005e2a:	60fb      	str	r3, [r7, #12]
        USBx_HC(chnum)->HCCHAR = tmpreg;
 8005e2c:	78fb      	ldrb	r3, [r7, #3]
 8005e2e:	015a      	lsls	r2, r3, #5
 8005e30:	693b      	ldr	r3, [r7, #16]
 8005e32:	4413      	add	r3, r2
 8005e34:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005e38:	461a      	mov	r2, r3
 8005e3a:	68fb      	ldr	r3, [r7, #12]
 8005e3c:	6013      	str	r3, [r2, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005e3e:	bf00      	nop
    }

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
    hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8005e40:	78fa      	ldrb	r2, [r7, #3]
 8005e42:	6879      	ldr	r1, [r7, #4]
 8005e44:	4613      	mov	r3, r2
 8005e46:	011b      	lsls	r3, r3, #4
 8005e48:	1a9b      	subs	r3, r3, r2
 8005e4a:	009b      	lsls	r3, r3, #2
 8005e4c:	440b      	add	r3, r1
 8005e4e:	334c      	adds	r3, #76	@ 0x4c
 8005e50:	781a      	ldrb	r2, [r3, #0]
 8005e52:	78fb      	ldrb	r3, [r7, #3]
 8005e54:	4619      	mov	r1, r3
 8005e56:	6878      	ldr	r0, [r7, #4]
 8005e58:	f027 f882 	bl	802cf60 <HAL_HCD_HC_NotifyURBChange_Callback>
 8005e5c:	e002      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
  }
  else
  {
    return;
 8005e5e:	bf00      	nop
 8005e60:	e000      	b.n	8005e64 <HCD_HC_OUT_IRQHandler+0x944>
      return;
 8005e62:	bf00      	nop
  }
}
 8005e64:	3718      	adds	r7, #24
 8005e66:	46bd      	mov	sp, r7
 8005e68:	bd80      	pop	{r7, pc}

08005e6a <HCD_RXQLVL_IRQHandler>:
  * @brief  Handle Rx Queue Level interrupt requests.
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8005e6a:	b580      	push	{r7, lr}
 8005e6c:	b08a      	sub	sp, #40	@ 0x28
 8005e6e:	af00      	add	r7, sp, #0
 8005e70:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005e72:	687b      	ldr	r3, [r7, #4]
 8005e74:	681b      	ldr	r3, [r3, #0]
 8005e76:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005e78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005e7a:	623b      	str	r3, [r7, #32]
  uint32_t GrxstspReg;
  uint32_t xferSizePktCnt;
  uint32_t tmpreg;
  uint32_t chnum;

  GrxstspReg = hhcd->Instance->GRXSTSP;
 8005e7c:	687b      	ldr	r3, [r7, #4]
 8005e7e:	681b      	ldr	r3, [r3, #0]
 8005e80:	6a1b      	ldr	r3, [r3, #32]
 8005e82:	61fb      	str	r3, [r7, #28]
  chnum = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
 8005e84:	69fb      	ldr	r3, [r7, #28]
 8005e86:	f003 030f 	and.w	r3, r3, #15
 8005e8a:	61bb      	str	r3, [r7, #24]
  pktsts = (GrxstspReg & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 8005e8c:	69fb      	ldr	r3, [r7, #28]
 8005e8e:	0c5b      	lsrs	r3, r3, #17
 8005e90:	f003 030f 	and.w	r3, r3, #15
 8005e94:	617b      	str	r3, [r7, #20]
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;
 8005e96:	69fb      	ldr	r3, [r7, #28]
 8005e98:	091b      	lsrs	r3, r3, #4
 8005e9a:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8005e9e:	613b      	str	r3, [r7, #16]

  switch (pktsts)
 8005ea0:	697b      	ldr	r3, [r7, #20]
 8005ea2:	2b02      	cmp	r3, #2
 8005ea4:	d004      	beq.n	8005eb0 <HCD_RXQLVL_IRQHandler+0x46>
 8005ea6:	697b      	ldr	r3, [r7, #20]
 8005ea8:	2b05      	cmp	r3, #5
 8005eaa:	f000 80b6 	beq.w	800601a <HCD_RXQLVL_IRQHandler+0x1b0>
      break;

    case GRXSTS_PKTSTS_IN_XFER_COMP:
    case GRXSTS_PKTSTS_CH_HALTED:
    default:
      break;
 8005eae:	e0b7      	b.n	8006020 <HCD_RXQLVL_IRQHandler+0x1b6>
      if ((pktcnt > 0U) && (hhcd->hc[chnum].xfer_buff != (void *)0))
 8005eb0:	693b      	ldr	r3, [r7, #16]
 8005eb2:	2b00      	cmp	r3, #0
 8005eb4:	f000 80b3 	beq.w	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
 8005eb8:	6879      	ldr	r1, [r7, #4]
 8005eba:	69ba      	ldr	r2, [r7, #24]
 8005ebc:	4613      	mov	r3, r2
 8005ebe:	011b      	lsls	r3, r3, #4
 8005ec0:	1a9b      	subs	r3, r3, r2
 8005ec2:	009b      	lsls	r3, r3, #2
 8005ec4:	440b      	add	r3, r1
 8005ec6:	332c      	adds	r3, #44	@ 0x2c
 8005ec8:	681b      	ldr	r3, [r3, #0]
 8005eca:	2b00      	cmp	r3, #0
 8005ecc:	f000 80a7 	beq.w	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
        if ((hhcd->hc[chnum].xfer_count + pktcnt) <= hhcd->hc[chnum].xfer_len)
 8005ed0:	6879      	ldr	r1, [r7, #4]
 8005ed2:	69ba      	ldr	r2, [r7, #24]
 8005ed4:	4613      	mov	r3, r2
 8005ed6:	011b      	lsls	r3, r3, #4
 8005ed8:	1a9b      	subs	r3, r3, r2
 8005eda:	009b      	lsls	r3, r3, #2
 8005edc:	440b      	add	r3, r1
 8005ede:	3338      	adds	r3, #56	@ 0x38
 8005ee0:	681a      	ldr	r2, [r3, #0]
 8005ee2:	693b      	ldr	r3, [r7, #16]
 8005ee4:	18d1      	adds	r1, r2, r3
 8005ee6:	6878      	ldr	r0, [r7, #4]
 8005ee8:	69ba      	ldr	r2, [r7, #24]
 8005eea:	4613      	mov	r3, r2
 8005eec:	011b      	lsls	r3, r3, #4
 8005eee:	1a9b      	subs	r3, r3, r2
 8005ef0:	009b      	lsls	r3, r3, #2
 8005ef2:	4403      	add	r3, r0
 8005ef4:	3334      	adds	r3, #52	@ 0x34
 8005ef6:	681b      	ldr	r3, [r3, #0]
 8005ef8:	4299      	cmp	r1, r3
 8005efa:	f200 8083 	bhi.w	8006004 <HCD_RXQLVL_IRQHandler+0x19a>
          (void)USB_ReadPacket(hhcd->Instance,
 8005efe:	687b      	ldr	r3, [r7, #4]
 8005f00:	6818      	ldr	r0, [r3, #0]
 8005f02:	6879      	ldr	r1, [r7, #4]
 8005f04:	69ba      	ldr	r2, [r7, #24]
 8005f06:	4613      	mov	r3, r2
 8005f08:	011b      	lsls	r3, r3, #4
 8005f0a:	1a9b      	subs	r3, r3, r2
 8005f0c:	009b      	lsls	r3, r3, #2
 8005f0e:	440b      	add	r3, r1
 8005f10:	332c      	adds	r3, #44	@ 0x2c
 8005f12:	681b      	ldr	r3, [r3, #0]
 8005f14:	693a      	ldr	r2, [r7, #16]
 8005f16:	b292      	uxth	r2, r2
 8005f18:	4619      	mov	r1, r3
 8005f1a:	f001 f82d 	bl	8006f78 <USB_ReadPacket>
          hhcd->hc[chnum].xfer_buff += pktcnt;
 8005f1e:	6879      	ldr	r1, [r7, #4]
 8005f20:	69ba      	ldr	r2, [r7, #24]
 8005f22:	4613      	mov	r3, r2
 8005f24:	011b      	lsls	r3, r3, #4
 8005f26:	1a9b      	subs	r3, r3, r2
 8005f28:	009b      	lsls	r3, r3, #2
 8005f2a:	440b      	add	r3, r1
 8005f2c:	332c      	adds	r3, #44	@ 0x2c
 8005f2e:	681a      	ldr	r2, [r3, #0]
 8005f30:	693b      	ldr	r3, [r7, #16]
 8005f32:	18d1      	adds	r1, r2, r3
 8005f34:	6878      	ldr	r0, [r7, #4]
 8005f36:	69ba      	ldr	r2, [r7, #24]
 8005f38:	4613      	mov	r3, r2
 8005f3a:	011b      	lsls	r3, r3, #4
 8005f3c:	1a9b      	subs	r3, r3, r2
 8005f3e:	009b      	lsls	r3, r3, #2
 8005f40:	4403      	add	r3, r0
 8005f42:	332c      	adds	r3, #44	@ 0x2c
 8005f44:	6019      	str	r1, [r3, #0]
          hhcd->hc[chnum].xfer_count += pktcnt;
 8005f46:	6879      	ldr	r1, [r7, #4]
 8005f48:	69ba      	ldr	r2, [r7, #24]
 8005f4a:	4613      	mov	r3, r2
 8005f4c:	011b      	lsls	r3, r3, #4
 8005f4e:	1a9b      	subs	r3, r3, r2
 8005f50:	009b      	lsls	r3, r3, #2
 8005f52:	440b      	add	r3, r1
 8005f54:	3338      	adds	r3, #56	@ 0x38
 8005f56:	681a      	ldr	r2, [r3, #0]
 8005f58:	693b      	ldr	r3, [r7, #16]
 8005f5a:	18d1      	adds	r1, r2, r3
 8005f5c:	6878      	ldr	r0, [r7, #4]
 8005f5e:	69ba      	ldr	r2, [r7, #24]
 8005f60:	4613      	mov	r3, r2
 8005f62:	011b      	lsls	r3, r3, #4
 8005f64:	1a9b      	subs	r3, r3, r2
 8005f66:	009b      	lsls	r3, r3, #2
 8005f68:	4403      	add	r3, r0
 8005f6a:	3338      	adds	r3, #56	@ 0x38
 8005f6c:	6019      	str	r1, [r3, #0]
          xferSizePktCnt = (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8005f6e:	69bb      	ldr	r3, [r7, #24]
 8005f70:	015a      	lsls	r2, r3, #5
 8005f72:	6a3b      	ldr	r3, [r7, #32]
 8005f74:	4413      	add	r3, r2
 8005f76:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005f7a:	691b      	ldr	r3, [r3, #16]
 8005f7c:	0cdb      	lsrs	r3, r3, #19
 8005f7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8005f82:	60fb      	str	r3, [r7, #12]
          if ((hhcd->hc[chnum].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 8005f84:	6879      	ldr	r1, [r7, #4]
 8005f86:	69ba      	ldr	r2, [r7, #24]
 8005f88:	4613      	mov	r3, r2
 8005f8a:	011b      	lsls	r3, r3, #4
 8005f8c:	1a9b      	subs	r3, r3, r2
 8005f8e:	009b      	lsls	r3, r3, #2
 8005f90:	440b      	add	r3, r1
 8005f92:	3328      	adds	r3, #40	@ 0x28
 8005f94:	881b      	ldrh	r3, [r3, #0]
 8005f96:	461a      	mov	r2, r3
 8005f98:	693b      	ldr	r3, [r7, #16]
 8005f9a:	4293      	cmp	r3, r2
 8005f9c:	d13f      	bne.n	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
 8005f9e:	68fb      	ldr	r3, [r7, #12]
 8005fa0:	2b00      	cmp	r3, #0
 8005fa2:	d03c      	beq.n	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
            tmpreg = USBx_HC(chnum)->HCCHAR;
 8005fa4:	69bb      	ldr	r3, [r7, #24]
 8005fa6:	015a      	lsls	r2, r3, #5
 8005fa8:	6a3b      	ldr	r3, [r7, #32]
 8005faa:	4413      	add	r3, r2
 8005fac:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005fb0:	681b      	ldr	r3, [r3, #0]
 8005fb2:	60bb      	str	r3, [r7, #8]
            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005fb4:	68bb      	ldr	r3, [r7, #8]
 8005fb6:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005fba:	60bb      	str	r3, [r7, #8]
            tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005fbc:	68bb      	ldr	r3, [r7, #8]
 8005fbe:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8005fc2:	60bb      	str	r3, [r7, #8]
            USBx_HC(chnum)->HCCHAR = tmpreg;
 8005fc4:	69bb      	ldr	r3, [r7, #24]
 8005fc6:	015a      	lsls	r2, r3, #5
 8005fc8:	6a3b      	ldr	r3, [r7, #32]
 8005fca:	4413      	add	r3, r2
 8005fcc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005fd0:	461a      	mov	r2, r3
 8005fd2:	68bb      	ldr	r3, [r7, #8]
 8005fd4:	6013      	str	r3, [r2, #0]
            hhcd->hc[chnum].toggle_in ^= 1U;
 8005fd6:	6879      	ldr	r1, [r7, #4]
 8005fd8:	69ba      	ldr	r2, [r7, #24]
 8005fda:	4613      	mov	r3, r2
 8005fdc:	011b      	lsls	r3, r3, #4
 8005fde:	1a9b      	subs	r3, r3, r2
 8005fe0:	009b      	lsls	r3, r3, #2
 8005fe2:	440b      	add	r3, r1
 8005fe4:	333c      	adds	r3, #60	@ 0x3c
 8005fe6:	781b      	ldrb	r3, [r3, #0]
 8005fe8:	f083 0301 	eor.w	r3, r3, #1
 8005fec:	b2d8      	uxtb	r0, r3
 8005fee:	6879      	ldr	r1, [r7, #4]
 8005ff0:	69ba      	ldr	r2, [r7, #24]
 8005ff2:	4613      	mov	r3, r2
 8005ff4:	011b      	lsls	r3, r3, #4
 8005ff6:	1a9b      	subs	r3, r3, r2
 8005ff8:	009b      	lsls	r3, r3, #2
 8005ffa:	440b      	add	r3, r1
 8005ffc:	333c      	adds	r3, #60	@ 0x3c
 8005ffe:	4602      	mov	r2, r0
 8006000:	701a      	strb	r2, [r3, #0]
      break;
 8006002:	e00c      	b.n	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
          hhcd->hc[chnum].urb_state = URB_ERROR;
 8006004:	6879      	ldr	r1, [r7, #4]
 8006006:	69ba      	ldr	r2, [r7, #24]
 8006008:	4613      	mov	r3, r2
 800600a:	011b      	lsls	r3, r3, #4
 800600c:	1a9b      	subs	r3, r3, r2
 800600e:	009b      	lsls	r3, r3, #2
 8006010:	440b      	add	r3, r1
 8006012:	334c      	adds	r3, #76	@ 0x4c
 8006014:	2204      	movs	r2, #4
 8006016:	701a      	strb	r2, [r3, #0]
      break;
 8006018:	e001      	b.n	800601e <HCD_RXQLVL_IRQHandler+0x1b4>
      break;
 800601a:	bf00      	nop
 800601c:	e000      	b.n	8006020 <HCD_RXQLVL_IRQHandler+0x1b6>
      break;
 800601e:	bf00      	nop
  }
}
 8006020:	bf00      	nop
 8006022:	3728      	adds	r7, #40	@ 0x28
 8006024:	46bd      	mov	sp, r7
 8006026:	bd80      	pop	{r7, pc}

08006028 <HCD_Port_IRQHandler>:
  * @brief  Handle Host Port interrupt requests.
  * @param  hhcd HCD handle
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8006028:	b580      	push	{r7, lr}
 800602a:	b086      	sub	sp, #24
 800602c:	af00      	add	r7, sp, #0
 800602e:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8006030:	687b      	ldr	r3, [r7, #4]
 8006032:	681b      	ldr	r3, [r3, #0]
 8006034:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006036:	697b      	ldr	r3, [r7, #20]
 8006038:	613b      	str	r3, [r7, #16]
  volatile uint32_t hprt0;
  volatile uint32_t hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 800603a:	693b      	ldr	r3, [r7, #16]
 800603c:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8006040:	681b      	ldr	r3, [r3, #0]
 8006042:	60fb      	str	r3, [r7, #12]
  hprt0_dup = USBx_HPRT0;
 8006044:	693b      	ldr	r3, [r7, #16]
 8006046:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 800604a:	681b      	ldr	r3, [r3, #0]
 800604c:	60bb      	str	r3, [r7, #8]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 800604e:	68bb      	ldr	r3, [r7, #8]
 8006050:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8006054:	60bb      	str	r3, [r7, #8]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8006056:	68fb      	ldr	r3, [r7, #12]
 8006058:	f003 0302 	and.w	r3, r3, #2
 800605c:	2b02      	cmp	r3, #2
 800605e:	d10b      	bne.n	8006078 <HCD_Port_IRQHandler+0x50>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8006060:	68fb      	ldr	r3, [r7, #12]
 8006062:	f003 0301 	and.w	r3, r3, #1
 8006066:	2b01      	cmp	r3, #1
 8006068:	d102      	bne.n	8006070 <HCD_Port_IRQHandler+0x48>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
 800606a:	6878      	ldr	r0, [r7, #4]
 800606c:	f026 ff5c 	bl	802cf28 <HAL_HCD_Connect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup |= USB_OTG_HPRT_PCDET;
 8006070:	68bb      	ldr	r3, [r7, #8]
 8006072:	f043 0302 	orr.w	r3, r3, #2
 8006076:	60bb      	str	r3, [r7, #8]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8006078:	68fb      	ldr	r3, [r7, #12]
 800607a:	f003 0308 	and.w	r3, r3, #8
 800607e:	2b08      	cmp	r3, #8
 8006080:	d132      	bne.n	80060e8 <HCD_Port_IRQHandler+0xc0>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8006082:	68bb      	ldr	r3, [r7, #8]
 8006084:	f043 0308 	orr.w	r3, r3, #8
 8006088:	60bb      	str	r3, [r7, #8]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 800608a:	68fb      	ldr	r3, [r7, #12]
 800608c:	f003 0304 	and.w	r3, r3, #4
 8006090:	2b04      	cmp	r3, #4
 8006092:	d126      	bne.n	80060e2 <HCD_Port_IRQHandler+0xba>
    {
      if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 8006094:	687b      	ldr	r3, [r7, #4]
 8006096:	7a5b      	ldrb	r3, [r3, #9]
 8006098:	2b02      	cmp	r3, #2
 800609a:	d113      	bne.n	80060c4 <HCD_Port_IRQHandler+0x9c>
      {
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 800609c:	68fb      	ldr	r3, [r7, #12]
 800609e:	f403 23c0 	and.w	r3, r3, #393216	@ 0x60000
 80060a2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 80060a6:	d106      	bne.n	80060b6 <HCD_Port_IRQHandler+0x8e>
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
 80060a8:	687b      	ldr	r3, [r7, #4]
 80060aa:	681b      	ldr	r3, [r3, #0]
 80060ac:	2102      	movs	r1, #2
 80060ae:	4618      	mov	r0, r3
 80060b0:	f001 f8f2 	bl	8007298 <USB_InitFSLSPClkSel>
 80060b4:	e011      	b.n	80060da <HCD_Port_IRQHandler+0xb2>
        }
        else
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80060b6:	687b      	ldr	r3, [r7, #4]
 80060b8:	681b      	ldr	r3, [r3, #0]
 80060ba:	2101      	movs	r1, #1
 80060bc:	4618      	mov	r0, r3
 80060be:	f001 f8eb 	bl	8007298 <USB_InitFSLSPClkSel>
 80060c2:	e00a      	b.n	80060da <HCD_Port_IRQHandler+0xb2>
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 80060c4:	687b      	ldr	r3, [r7, #4]
 80060c6:	79db      	ldrb	r3, [r3, #7]
 80060c8:	2b01      	cmp	r3, #1
 80060ca:	d106      	bne.n	80060da <HCD_Port_IRQHandler+0xb2>
        {
          USBx_HOST->HFIR = HFIR_60_MHZ;
 80060cc:	693b      	ldr	r3, [r7, #16]
 80060ce:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80060d2:	461a      	mov	r2, r3
 80060d4:	f64e 2360 	movw	r3, #60000	@ 0xea60
 80060d8:	6053      	str	r3, [r2, #4]
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 80060da:	6878      	ldr	r0, [r7, #4]
 80060dc:	f026 ff4e 	bl	802cf7c <HAL_HCD_PortEnabled_Callback>
 80060e0:	e002      	b.n	80060e8 <HCD_Port_IRQHandler+0xc0>
    else
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortDisabledCallback(hhcd);
#else
      HAL_HCD_PortDisabled_Callback(hhcd);
 80060e2:	6878      	ldr	r0, [r7, #4]
 80060e4:	f026 ff58 	bl	802cf98 <HAL_HCD_PortDisabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 80060e8:	68fb      	ldr	r3, [r7, #12]
 80060ea:	f003 0320 	and.w	r3, r3, #32
 80060ee:	2b20      	cmp	r3, #32
 80060f0:	d103      	bne.n	80060fa <HCD_Port_IRQHandler+0xd2>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 80060f2:	68bb      	ldr	r3, [r7, #8]
 80060f4:	f043 0320 	orr.w	r3, r3, #32
 80060f8:	60bb      	str	r3, [r7, #8]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 80060fa:	693b      	ldr	r3, [r7, #16]
 80060fc:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8006100:	461a      	mov	r2, r3
 8006102:	68bb      	ldr	r3, [r7, #8]
 8006104:	6013      	str	r3, [r2, #0]
}
 8006106:	bf00      	nop
 8006108:	3718      	adds	r7, #24
 800610a:	46bd      	mov	sp, r7
 800610c:	bd80      	pop	{r7, pc}
	...

08006110 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8006110:	b580      	push	{r7, lr}
 8006112:	b086      	sub	sp, #24
 8006114:	af00      	add	r7, sp, #0
 8006116:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8006118:	687b      	ldr	r3, [r7, #4]
 800611a:	2b00      	cmp	r3, #0
 800611c:	d101      	bne.n	8006122 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800611e:	2301      	movs	r3, #1
 8006120:	e24b      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8006122:	687b      	ldr	r3, [r7, #4]
 8006124:	681b      	ldr	r3, [r3, #0]
 8006126:	f003 0301 	and.w	r3, r3, #1
 800612a:	2b00      	cmp	r3, #0
 800612c:	d05c      	beq.n	80061e8 <HAL_RCC_OscConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((RCC->CFGR.bit.sws == RCC_CFGR_SWS_HSE) ||\
 800612e:	4b9b      	ldr	r3, [pc, #620]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006130:	689b      	ldr	r3, [r3, #8]
 8006132:	f3c3 0381 	ubfx	r3, r3, #2, #2
      ((RCC->CFGR.bit.sws == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == (0x1UL << 22U))))
 8006136:	4b99      	ldr	r3, [pc, #612]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006138:	689b      	ldr	r3, [r3, #8]
 800613a:	f3c3 0381 	ubfx	r3, r3, #2, #2
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800613e:	687b      	ldr	r3, [r7, #4]
 8006140:	685b      	ldr	r3, [r3, #4]
 8006142:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8006146:	d106      	bne.n	8006156 <HAL_RCC_OscConfig+0x46>
 8006148:	4b94      	ldr	r3, [pc, #592]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800614a:	681b      	ldr	r3, [r3, #0]
 800614c:	4a93      	ldr	r2, [pc, #588]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800614e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8006152:	6013      	str	r3, [r2, #0]
 8006154:	e01d      	b.n	8006192 <HAL_RCC_OscConfig+0x82>
 8006156:	687b      	ldr	r3, [r7, #4]
 8006158:	685b      	ldr	r3, [r3, #4]
 800615a:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800615e:	d10c      	bne.n	800617a <HAL_RCC_OscConfig+0x6a>
 8006160:	4b8e      	ldr	r3, [pc, #568]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006162:	681b      	ldr	r3, [r3, #0]
 8006164:	4a8d      	ldr	r2, [pc, #564]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006166:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800616a:	6013      	str	r3, [r2, #0]
 800616c:	4b8b      	ldr	r3, [pc, #556]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800616e:	681b      	ldr	r3, [r3, #0]
 8006170:	4a8a      	ldr	r2, [pc, #552]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006172:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8006176:	6013      	str	r3, [r2, #0]
 8006178:	e00b      	b.n	8006192 <HAL_RCC_OscConfig+0x82>
 800617a:	4b88      	ldr	r3, [pc, #544]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800617c:	681b      	ldr	r3, [r3, #0]
 800617e:	4a87      	ldr	r2, [pc, #540]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006180:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8006184:	6013      	str	r3, [r2, #0]
 8006186:	4b85      	ldr	r3, [pc, #532]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006188:	681b      	ldr	r3, [r3, #0]
 800618a:	4a84      	ldr	r2, [pc, #528]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800618c:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8006190:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8006192:	687b      	ldr	r3, [r7, #4]
 8006194:	685b      	ldr	r3, [r3, #4]
 8006196:	2b00      	cmp	r3, #0
 8006198:	d013      	beq.n	80061c2 <HAL_RCC_OscConfig+0xb2>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800619a:	f7fb fd17 	bl	8001bcc <HAL_GetTick>
 800619e:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80061a0:	e008      	b.n	80061b4 <HAL_RCC_OscConfig+0xa4>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80061a2:	f7fb fd13 	bl	8001bcc <HAL_GetTick>
 80061a6:	4602      	mov	r2, r0
 80061a8:	693b      	ldr	r3, [r7, #16]
 80061aa:	1ad3      	subs	r3, r2, r3
 80061ac:	2b64      	cmp	r3, #100	@ 0x64
 80061ae:	d901      	bls.n	80061b4 <HAL_RCC_OscConfig+0xa4>
          {
            return HAL_TIMEOUT;
 80061b0:	2303      	movs	r3, #3
 80061b2:	e202      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80061b4:	4b79      	ldr	r3, [pc, #484]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80061bc:	2b00      	cmp	r3, #0
 80061be:	d0f0      	beq.n	80061a2 <HAL_RCC_OscConfig+0x92>
 80061c0:	e012      	b.n	80061e8 <HAL_RCC_OscConfig+0xd8>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80061c2:	f7fb fd03 	bl	8001bcc <HAL_GetTick>
 80061c6:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80061c8:	e008      	b.n	80061dc <HAL_RCC_OscConfig+0xcc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80061ca:	f7fb fcff 	bl	8001bcc <HAL_GetTick>
 80061ce:	4602      	mov	r2, r0
 80061d0:	693b      	ldr	r3, [r7, #16]
 80061d2:	1ad3      	subs	r3, r2, r3
 80061d4:	2b64      	cmp	r3, #100	@ 0x64
 80061d6:	d901      	bls.n	80061dc <HAL_RCC_OscConfig+0xcc>
          {
            return HAL_TIMEOUT;
 80061d8:	2303      	movs	r3, #3
 80061da:	e1ee      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80061dc:	4b6f      	ldr	r3, [pc, #444]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 80061de:	681b      	ldr	r3, [r3, #0]
 80061e0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80061e4:	2b00      	cmp	r3, #0
 80061e6:	d1f0      	bne.n	80061ca <HAL_RCC_OscConfig+0xba>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80061e8:	687b      	ldr	r3, [r7, #4]
 80061ea:	681b      	ldr	r3, [r3, #0]
 80061ec:	f003 0302 	and.w	r3, r3, #2
 80061f0:	2b00      	cmp	r3, #0
 80061f2:	d063      	beq.n	80062bc <HAL_RCC_OscConfig+0x1ac>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80061f4:	4b69      	ldr	r3, [pc, #420]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 80061f6:	689b      	ldr	r3, [r3, #8]
 80061f8:	f003 030c 	and.w	r3, r3, #12
 80061fc:	2b00      	cmp	r3, #0
 80061fe:	d00b      	beq.n	8006218 <HAL_RCC_OscConfig+0x108>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8006200:	4b66      	ldr	r3, [pc, #408]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006202:	689b      	ldr	r3, [r3, #8]
 8006204:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8006208:	2b08      	cmp	r3, #8
 800620a:	d11c      	bne.n	8006246 <HAL_RCC_OscConfig+0x136>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800620c:	4b63      	ldr	r3, [pc, #396]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800620e:	685b      	ldr	r3, [r3, #4]
 8006210:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8006214:	2b00      	cmp	r3, #0
 8006216:	d116      	bne.n	8006246 <HAL_RCC_OscConfig+0x136>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8006218:	4b60      	ldr	r3, [pc, #384]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800621a:	681b      	ldr	r3, [r3, #0]
 800621c:	f003 0302 	and.w	r3, r3, #2
 8006220:	2b00      	cmp	r3, #0
 8006222:	d005      	beq.n	8006230 <HAL_RCC_OscConfig+0x120>
 8006224:	687b      	ldr	r3, [r7, #4]
 8006226:	68db      	ldr	r3, [r3, #12]
 8006228:	2b01      	cmp	r3, #1
 800622a:	d001      	beq.n	8006230 <HAL_RCC_OscConfig+0x120>
      {
        return HAL_ERROR;
 800622c:	2301      	movs	r3, #1
 800622e:	e1c4      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006230:	4b5a      	ldr	r3, [pc, #360]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006232:	681b      	ldr	r3, [r3, #0]
 8006234:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 8006238:	687b      	ldr	r3, [r7, #4]
 800623a:	691b      	ldr	r3, [r3, #16]
 800623c:	00db      	lsls	r3, r3, #3
 800623e:	4957      	ldr	r1, [pc, #348]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006240:	4313      	orrs	r3, r2
 8006242:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8006244:	e03a      	b.n	80062bc <HAL_RCC_OscConfig+0x1ac>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8006246:	687b      	ldr	r3, [r7, #4]
 8006248:	68db      	ldr	r3, [r3, #12]
 800624a:	2b00      	cmp	r3, #0
 800624c:	d020      	beq.n	8006290 <HAL_RCC_OscConfig+0x180>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800624e:	4b54      	ldr	r3, [pc, #336]	@ (80063a0 <HAL_RCC_OscConfig+0x290>)
 8006250:	2201      	movs	r2, #1
 8006252:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006254:	f7fb fcba 	bl	8001bcc <HAL_GetTick>
 8006258:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800625a:	e008      	b.n	800626e <HAL_RCC_OscConfig+0x15e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800625c:	f7fb fcb6 	bl	8001bcc <HAL_GetTick>
 8006260:	4602      	mov	r2, r0
 8006262:	693b      	ldr	r3, [r7, #16]
 8006264:	1ad3      	subs	r3, r2, r3
 8006266:	2b02      	cmp	r3, #2
 8006268:	d901      	bls.n	800626e <HAL_RCC_OscConfig+0x15e>
          {
            return HAL_TIMEOUT;
 800626a:	2303      	movs	r3, #3
 800626c:	e1a5      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800626e:	4b4b      	ldr	r3, [pc, #300]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006270:	681b      	ldr	r3, [r3, #0]
 8006272:	f003 0302 	and.w	r3, r3, #2
 8006276:	2b00      	cmp	r3, #0
 8006278:	d0f0      	beq.n	800625c <HAL_RCC_OscConfig+0x14c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800627a:	4b48      	ldr	r3, [pc, #288]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800627c:	681b      	ldr	r3, [r3, #0]
 800627e:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	691b      	ldr	r3, [r3, #16]
 8006286:	00db      	lsls	r3, r3, #3
 8006288:	4944      	ldr	r1, [pc, #272]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800628a:	4313      	orrs	r3, r2
 800628c:	600b      	str	r3, [r1, #0]
 800628e:	e015      	b.n	80062bc <HAL_RCC_OscConfig+0x1ac>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8006290:	4b43      	ldr	r3, [pc, #268]	@ (80063a0 <HAL_RCC_OscConfig+0x290>)
 8006292:	2200      	movs	r2, #0
 8006294:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006296:	f7fb fc99 	bl	8001bcc <HAL_GetTick>
 800629a:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800629c:	e008      	b.n	80062b0 <HAL_RCC_OscConfig+0x1a0>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800629e:	f7fb fc95 	bl	8001bcc <HAL_GetTick>
 80062a2:	4602      	mov	r2, r0
 80062a4:	693b      	ldr	r3, [r7, #16]
 80062a6:	1ad3      	subs	r3, r2, r3
 80062a8:	2b02      	cmp	r3, #2
 80062aa:	d901      	bls.n	80062b0 <HAL_RCC_OscConfig+0x1a0>
          {
            return HAL_TIMEOUT;
 80062ac:	2303      	movs	r3, #3
 80062ae:	e184      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80062b0:	4b3a      	ldr	r3, [pc, #232]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 80062b2:	681b      	ldr	r3, [r3, #0]
 80062b4:	f003 0302 	and.w	r3, r3, #2
 80062b8:	2b00      	cmp	r3, #0
 80062ba:	d1f0      	bne.n	800629e <HAL_RCC_OscConfig+0x18e>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80062bc:	687b      	ldr	r3, [r7, #4]
 80062be:	681b      	ldr	r3, [r3, #0]
 80062c0:	f003 0308 	and.w	r3, r3, #8
 80062c4:	2b00      	cmp	r3, #0
 80062c6:	d030      	beq.n	800632a <HAL_RCC_OscConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80062c8:	687b      	ldr	r3, [r7, #4]
 80062ca:	695b      	ldr	r3, [r3, #20]
 80062cc:	2b00      	cmp	r3, #0
 80062ce:	d016      	beq.n	80062fe <HAL_RCC_OscConfig+0x1ee>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80062d0:	4b34      	ldr	r3, [pc, #208]	@ (80063a4 <HAL_RCC_OscConfig+0x294>)
 80062d2:	2201      	movs	r2, #1
 80062d4:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80062d6:	f7fb fc79 	bl	8001bcc <HAL_GetTick>
 80062da:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80062dc:	e008      	b.n	80062f0 <HAL_RCC_OscConfig+0x1e0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80062de:	f7fb fc75 	bl	8001bcc <HAL_GetTick>
 80062e2:	4602      	mov	r2, r0
 80062e4:	693b      	ldr	r3, [r7, #16]
 80062e6:	1ad3      	subs	r3, r2, r3
 80062e8:	2b02      	cmp	r3, #2
 80062ea:	d901      	bls.n	80062f0 <HAL_RCC_OscConfig+0x1e0>
        {
          return HAL_TIMEOUT;
 80062ec:	2303      	movs	r3, #3
 80062ee:	e164      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80062f0:	4b2a      	ldr	r3, [pc, #168]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 80062f2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80062f4:	f003 0302 	and.w	r3, r3, #2
 80062f8:	2b00      	cmp	r3, #0
 80062fa:	d0f0      	beq.n	80062de <HAL_RCC_OscConfig+0x1ce>
 80062fc:	e015      	b.n	800632a <HAL_RCC_OscConfig+0x21a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80062fe:	4b29      	ldr	r3, [pc, #164]	@ (80063a4 <HAL_RCC_OscConfig+0x294>)
 8006300:	2200      	movs	r2, #0
 8006302:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8006304:	f7fb fc62 	bl	8001bcc <HAL_GetTick>
 8006308:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800630a:	e008      	b.n	800631e <HAL_RCC_OscConfig+0x20e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800630c:	f7fb fc5e 	bl	8001bcc <HAL_GetTick>
 8006310:	4602      	mov	r2, r0
 8006312:	693b      	ldr	r3, [r7, #16]
 8006314:	1ad3      	subs	r3, r2, r3
 8006316:	2b02      	cmp	r3, #2
 8006318:	d901      	bls.n	800631e <HAL_RCC_OscConfig+0x20e>
        {
          return HAL_TIMEOUT;
 800631a:	2303      	movs	r3, #3
 800631c:	e14d      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800631e:	4b1f      	ldr	r3, [pc, #124]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006320:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8006322:	f003 0302 	and.w	r3, r3, #2
 8006326:	2b00      	cmp	r3, #0
 8006328:	d1f0      	bne.n	800630c <HAL_RCC_OscConfig+0x1fc>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800632a:	687b      	ldr	r3, [r7, #4]
 800632c:	681b      	ldr	r3, [r3, #0]
 800632e:	f003 0304 	and.w	r3, r3, #4
 8006332:	2b00      	cmp	r3, #0
 8006334:	f000 80a0 	beq.w	8006478 <HAL_RCC_OscConfig+0x368>
  {
    FlagStatus       pwrclkchanged = RESET;
 8006338:	2300      	movs	r3, #0
 800633a:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800633c:	4b17      	ldr	r3, [pc, #92]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800633e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006340:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8006344:	2b00      	cmp	r3, #0
 8006346:	d10f      	bne.n	8006368 <HAL_RCC_OscConfig+0x258>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8006348:	2300      	movs	r3, #0
 800634a:	60bb      	str	r3, [r7, #8]
 800634c:	4b13      	ldr	r3, [pc, #76]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800634e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006350:	4a12      	ldr	r2, [pc, #72]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 8006352:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006356:	6413      	str	r3, [r2, #64]	@ 0x40
 8006358:	4b10      	ldr	r3, [pc, #64]	@ (800639c <HAL_RCC_OscConfig+0x28c>)
 800635a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800635c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8006360:	60bb      	str	r3, [r7, #8]
 8006362:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8006364:	2301      	movs	r3, #1
 8006366:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 8006368:	4b0f      	ldr	r3, [pc, #60]	@ (80063a8 <HAL_RCC_OscConfig+0x298>)
 800636a:	681b      	ldr	r3, [r3, #0]
 800636c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006370:	2b00      	cmp	r3, #0
 8006372:	d121      	bne.n	80063b8 <HAL_RCC_OscConfig+0x2a8>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR.reg, PWR_CR_DBP);
 8006374:	4b0c      	ldr	r3, [pc, #48]	@ (80063a8 <HAL_RCC_OscConfig+0x298>)
 8006376:	681b      	ldr	r3, [r3, #0]
 8006378:	4a0b      	ldr	r2, [pc, #44]	@ (80063a8 <HAL_RCC_OscConfig+0x298>)
 800637a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800637e:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8006380:	f7fb fc24 	bl	8001bcc <HAL_GetTick>
 8006384:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 8006386:	e011      	b.n	80063ac <HAL_RCC_OscConfig+0x29c>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8006388:	f7fb fc20 	bl	8001bcc <HAL_GetTick>
 800638c:	4602      	mov	r2, r0
 800638e:	693b      	ldr	r3, [r7, #16]
 8006390:	1ad3      	subs	r3, r2, r3
 8006392:	2b02      	cmp	r3, #2
 8006394:	d90a      	bls.n	80063ac <HAL_RCC_OscConfig+0x29c>
        {
          return HAL_TIMEOUT;
 8006396:	2303      	movs	r3, #3
 8006398:	e10f      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
 800639a:	bf00      	nop
 800639c:	40023800 	.word	0x40023800
 80063a0:	42470000 	.word	0x42470000
 80063a4:	42470e80 	.word	0x42470e80
 80063a8:	40007000 	.word	0x40007000
      while(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 80063ac:	4b85      	ldr	r3, [pc, #532]	@ (80065c4 <HAL_RCC_OscConfig+0x4b4>)
 80063ae:	681b      	ldr	r3, [r3, #0]
 80063b0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80063b4:	2b00      	cmp	r3, #0
 80063b6:	d0e7      	beq.n	8006388 <HAL_RCC_OscConfig+0x278>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80063b8:	687b      	ldr	r3, [r7, #4]
 80063ba:	689b      	ldr	r3, [r3, #8]
 80063bc:	2b01      	cmp	r3, #1
 80063be:	d106      	bne.n	80063ce <HAL_RCC_OscConfig+0x2be>
 80063c0:	4b81      	ldr	r3, [pc, #516]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063c2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80063c4:	4a80      	ldr	r2, [pc, #512]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063c6:	f043 0301 	orr.w	r3, r3, #1
 80063ca:	6713      	str	r3, [r2, #112]	@ 0x70
 80063cc:	e01c      	b.n	8006408 <HAL_RCC_OscConfig+0x2f8>
 80063ce:	687b      	ldr	r3, [r7, #4]
 80063d0:	689b      	ldr	r3, [r3, #8]
 80063d2:	2b05      	cmp	r3, #5
 80063d4:	d10c      	bne.n	80063f0 <HAL_RCC_OscConfig+0x2e0>
 80063d6:	4b7c      	ldr	r3, [pc, #496]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80063da:	4a7b      	ldr	r2, [pc, #492]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063dc:	f043 0304 	orr.w	r3, r3, #4
 80063e0:	6713      	str	r3, [r2, #112]	@ 0x70
 80063e2:	4b79      	ldr	r3, [pc, #484]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063e4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80063e6:	4a78      	ldr	r2, [pc, #480]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063e8:	f043 0301 	orr.w	r3, r3, #1
 80063ec:	6713      	str	r3, [r2, #112]	@ 0x70
 80063ee:	e00b      	b.n	8006408 <HAL_RCC_OscConfig+0x2f8>
 80063f0:	4b75      	ldr	r3, [pc, #468]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063f2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80063f4:	4a74      	ldr	r2, [pc, #464]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063f6:	f023 0301 	bic.w	r3, r3, #1
 80063fa:	6713      	str	r3, [r2, #112]	@ 0x70
 80063fc:	4b72      	ldr	r3, [pc, #456]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80063fe:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006400:	4a71      	ldr	r2, [pc, #452]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 8006402:	f023 0304 	bic.w	r3, r3, #4
 8006406:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8006408:	687b      	ldr	r3, [r7, #4]
 800640a:	689b      	ldr	r3, [r3, #8]
 800640c:	2b00      	cmp	r3, #0
 800640e:	d015      	beq.n	800643c <HAL_RCC_OscConfig+0x32c>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006410:	f7fb fbdc 	bl	8001bcc <HAL_GetTick>
 8006414:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006416:	e00a      	b.n	800642e <HAL_RCC_OscConfig+0x31e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8006418:	f7fb fbd8 	bl	8001bcc <HAL_GetTick>
 800641c:	4602      	mov	r2, r0
 800641e:	693b      	ldr	r3, [r7, #16]
 8006420:	1ad3      	subs	r3, r2, r3
 8006422:	f241 3288 	movw	r2, #5000	@ 0x1388
 8006426:	4293      	cmp	r3, r2
 8006428:	d901      	bls.n	800642e <HAL_RCC_OscConfig+0x31e>
        {
          return HAL_TIMEOUT;
 800642a:	2303      	movs	r3, #3
 800642c:	e0c5      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800642e:	4b66      	ldr	r3, [pc, #408]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 8006430:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006432:	f003 0302 	and.w	r3, r3, #2
 8006436:	2b00      	cmp	r3, #0
 8006438:	d0ee      	beq.n	8006418 <HAL_RCC_OscConfig+0x308>
 800643a:	e014      	b.n	8006466 <HAL_RCC_OscConfig+0x356>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800643c:	f7fb fbc6 	bl	8001bcc <HAL_GetTick>
 8006440:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8006442:	e00a      	b.n	800645a <HAL_RCC_OscConfig+0x34a>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8006444:	f7fb fbc2 	bl	8001bcc <HAL_GetTick>
 8006448:	4602      	mov	r2, r0
 800644a:	693b      	ldr	r3, [r7, #16]
 800644c:	1ad3      	subs	r3, r2, r3
 800644e:	f241 3288 	movw	r2, #5000	@ 0x1388
 8006452:	4293      	cmp	r3, r2
 8006454:	d901      	bls.n	800645a <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 8006456:	2303      	movs	r3, #3
 8006458:	e0af      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800645a:	4b5b      	ldr	r3, [pc, #364]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 800645c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800645e:	f003 0302 	and.w	r3, r3, #2
 8006462:	2b00      	cmp	r3, #0
 8006464:	d1ee      	bne.n	8006444 <HAL_RCC_OscConfig+0x334>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8006466:	7dfb      	ldrb	r3, [r7, #23]
 8006468:	2b01      	cmp	r3, #1
 800646a:	d105      	bne.n	8006478 <HAL_RCC_OscConfig+0x368>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800646c:	4b56      	ldr	r3, [pc, #344]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 800646e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006470:	4a55      	ldr	r2, [pc, #340]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 8006472:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8006476:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	699b      	ldr	r3, [r3, #24]
 800647c:	2b00      	cmp	r3, #0
 800647e:	f000 809b 	beq.w	80065b8 <HAL_RCC_OscConfig+0x4a8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006482:	4b51      	ldr	r3, [pc, #324]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 8006484:	689b      	ldr	r3, [r3, #8]
 8006486:	f003 030c 	and.w	r3, r3, #12
 800648a:	2b08      	cmp	r3, #8
 800648c:	d05c      	beq.n	8006548 <HAL_RCC_OscConfig+0x438>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800648e:	687b      	ldr	r3, [r7, #4]
 8006490:	699b      	ldr	r3, [r3, #24]
 8006492:	2b02      	cmp	r3, #2
 8006494:	d141      	bne.n	800651a <HAL_RCC_OscConfig+0x40a>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8006496:	4b4d      	ldr	r3, [pc, #308]	@ (80065cc <HAL_RCC_OscConfig+0x4bc>)
 8006498:	2200      	movs	r2, #0
 800649a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800649c:	f7fb fb96 	bl	8001bcc <HAL_GetTick>
 80064a0:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80064a2:	e008      	b.n	80064b6 <HAL_RCC_OscConfig+0x3a6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80064a4:	f7fb fb92 	bl	8001bcc <HAL_GetTick>
 80064a8:	4602      	mov	r2, r0
 80064aa:	693b      	ldr	r3, [r7, #16]
 80064ac:	1ad3      	subs	r3, r2, r3
 80064ae:	2b02      	cmp	r3, #2
 80064b0:	d901      	bls.n	80064b6 <HAL_RCC_OscConfig+0x3a6>
          {
            return HAL_TIMEOUT;
 80064b2:	2303      	movs	r3, #3
 80064b4:	e081      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80064b6:	4b44      	ldr	r3, [pc, #272]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80064b8:	681b      	ldr	r3, [r3, #0]
 80064ba:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80064be:	2b00      	cmp	r3, #0
 80064c0:	d1f0      	bne.n	80064a4 <HAL_RCC_OscConfig+0x394>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR.reg, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80064c2:	687b      	ldr	r3, [r7, #4]
 80064c4:	69da      	ldr	r2, [r3, #28]
 80064c6:	687b      	ldr	r3, [r7, #4]
 80064c8:	6a1b      	ldr	r3, [r3, #32]
 80064ca:	431a      	orrs	r2, r3
 80064cc:	687b      	ldr	r3, [r7, #4]
 80064ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80064d0:	019b      	lsls	r3, r3, #6
 80064d2:	431a      	orrs	r2, r3
 80064d4:	687b      	ldr	r3, [r7, #4]
 80064d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80064d8:	085b      	lsrs	r3, r3, #1
 80064da:	3b01      	subs	r3, #1
 80064dc:	041b      	lsls	r3, r3, #16
 80064de:	431a      	orrs	r2, r3
 80064e0:	687b      	ldr	r3, [r7, #4]
 80064e2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80064e4:	061b      	lsls	r3, r3, #24
 80064e6:	4938      	ldr	r1, [pc, #224]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 80064e8:	4313      	orrs	r3, r2
 80064ea:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80064ec:	4b37      	ldr	r3, [pc, #220]	@ (80065cc <HAL_RCC_OscConfig+0x4bc>)
 80064ee:	2201      	movs	r2, #1
 80064f0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80064f2:	f7fb fb6b 	bl	8001bcc <HAL_GetTick>
 80064f6:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80064f8:	e008      	b.n	800650c <HAL_RCC_OscConfig+0x3fc>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80064fa:	f7fb fb67 	bl	8001bcc <HAL_GetTick>
 80064fe:	4602      	mov	r2, r0
 8006500:	693b      	ldr	r3, [r7, #16]
 8006502:	1ad3      	subs	r3, r2, r3
 8006504:	2b02      	cmp	r3, #2
 8006506:	d901      	bls.n	800650c <HAL_RCC_OscConfig+0x3fc>
          {
            return HAL_TIMEOUT;
 8006508:	2303      	movs	r3, #3
 800650a:	e056      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800650c:	4b2e      	ldr	r3, [pc, #184]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 800650e:	681b      	ldr	r3, [r3, #0]
 8006510:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006514:	2b00      	cmp	r3, #0
 8006516:	d0f0      	beq.n	80064fa <HAL_RCC_OscConfig+0x3ea>
 8006518:	e04e      	b.n	80065b8 <HAL_RCC_OscConfig+0x4a8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800651a:	4b2c      	ldr	r3, [pc, #176]	@ (80065cc <HAL_RCC_OscConfig+0x4bc>)
 800651c:	2200      	movs	r2, #0
 800651e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8006520:	f7fb fb54 	bl	8001bcc <HAL_GetTick>
 8006524:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8006526:	e008      	b.n	800653a <HAL_RCC_OscConfig+0x42a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8006528:	f7fb fb50 	bl	8001bcc <HAL_GetTick>
 800652c:	4602      	mov	r2, r0
 800652e:	693b      	ldr	r3, [r7, #16]
 8006530:	1ad3      	subs	r3, r2, r3
 8006532:	2b02      	cmp	r3, #2
 8006534:	d901      	bls.n	800653a <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
 8006536:	2303      	movs	r3, #3
 8006538:	e03f      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800653a:	4b23      	ldr	r3, [pc, #140]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 800653c:	681b      	ldr	r3, [r3, #0]
 800653e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006542:	2b00      	cmp	r3, #0
 8006544:	d1f0      	bne.n	8006528 <HAL_RCC_OscConfig+0x418>
 8006546:	e037      	b.n	80065b8 <HAL_RCC_OscConfig+0x4a8>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8006548:	687b      	ldr	r3, [r7, #4]
 800654a:	699b      	ldr	r3, [r3, #24]
 800654c:	2b01      	cmp	r3, #1
 800654e:	d101      	bne.n	8006554 <HAL_RCC_OscConfig+0x444>
      {
        return HAL_ERROR;
 8006550:	2301      	movs	r3, #1
 8006552:	e032      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR.reg;
 8006554:	4b1c      	ldr	r3, [pc, #112]	@ (80065c8 <HAL_RCC_OscConfig+0x4b8>)
 8006556:	685b      	ldr	r3, [r3, #4]
 8006558:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800655a:	687b      	ldr	r3, [r7, #4]
 800655c:	699b      	ldr	r3, [r3, #24]
 800655e:	2b01      	cmp	r3, #1
 8006560:	d028      	beq.n	80065b4 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8006562:	68fb      	ldr	r3, [r7, #12]
 8006564:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 8006568:	687b      	ldr	r3, [r7, #4]
 800656a:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800656c:	429a      	cmp	r2, r3
 800656e:	d121      	bne.n	80065b4 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8006570:	68fb      	ldr	r3, [r7, #12]
 8006572:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8006576:	687b      	ldr	r3, [r7, #4]
 8006578:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800657a:	429a      	cmp	r2, r3
 800657c:	d11a      	bne.n	80065b4 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800657e:	68fa      	ldr	r2, [r7, #12]
 8006580:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8006584:	4013      	ands	r3, r2
 8006586:	687a      	ldr	r2, [r7, #4]
 8006588:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 800658a:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800658c:	4293      	cmp	r3, r2
 800658e:	d111      	bne.n	80065b4 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8006590:	68fb      	ldr	r3, [r7, #12]
 8006592:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800659a:	085b      	lsrs	r3, r3, #1
 800659c:	3b01      	subs	r3, #1
 800659e:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80065a0:	429a      	cmp	r2, r3
 80065a2:	d107      	bne.n	80065b4 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80065a4:	68fb      	ldr	r3, [r7, #12]
 80065a6:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 80065aa:	687b      	ldr	r3, [r7, #4]
 80065ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80065ae:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80065b0:	429a      	cmp	r2, r3
 80065b2:	d001      	beq.n	80065b8 <HAL_RCC_OscConfig+0x4a8>
#endif
        {
          return HAL_ERROR;
 80065b4:	2301      	movs	r3, #1
 80065b6:	e000      	b.n	80065ba <HAL_RCC_OscConfig+0x4aa>
        }
      }
    }
  }
  return HAL_OK;
 80065b8:	2300      	movs	r3, #0
}
 80065ba:	4618      	mov	r0, r3
 80065bc:	3718      	adds	r7, #24
 80065be:	46bd      	mov	sp, r7
 80065c0:	bd80      	pop	{r7, pc}
 80065c2:	bf00      	nop
 80065c4:	40007000 	.word	0x40007000
 80065c8:	40023800 	.word	0x40023800
 80065cc:	42470060 	.word	0x42470060

080065d0 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80065d0:	b580      	push	{r7, lr}
 80065d2:	b084      	sub	sp, #16
 80065d4:	af00      	add	r7, sp, #0
 80065d6:	6078      	str	r0, [r7, #4]
 80065d8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80065da:	687b      	ldr	r3, [r7, #4]
 80065dc:	2b00      	cmp	r3, #0
 80065de:	d101      	bne.n	80065e4 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 80065e0:	2301      	movs	r3, #1
 80065e2:	e0cc      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80065e4:	4b68      	ldr	r3, [pc, #416]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 80065e6:	681b      	ldr	r3, [r3, #0]
 80065e8:	f003 0307 	and.w	r3, r3, #7
 80065ec:	683a      	ldr	r2, [r7, #0]
 80065ee:	429a      	cmp	r2, r3
 80065f0:	d90c      	bls.n	800660c <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80065f2:	4b65      	ldr	r3, [pc, #404]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 80065f4:	683a      	ldr	r2, [r7, #0]
 80065f6:	b2d2      	uxtb	r2, r2
 80065f8:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80065fa:	4b63      	ldr	r3, [pc, #396]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 80065fc:	681b      	ldr	r3, [r3, #0]
 80065fe:	f003 0307 	and.w	r3, r3, #7
 8006602:	683a      	ldr	r2, [r7, #0]
 8006604:	429a      	cmp	r2, r3
 8006606:	d001      	beq.n	800660c <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 8006608:	2301      	movs	r3, #1
 800660a:	e0b8      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800660c:	687b      	ldr	r3, [r7, #4]
 800660e:	681b      	ldr	r3, [r3, #0]
 8006610:	f003 0302 	and.w	r3, r3, #2
 8006614:	2b00      	cmp	r3, #0
 8006616:	d020      	beq.n	800665a <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006618:	687b      	ldr	r3, [r7, #4]
 800661a:	681b      	ldr	r3, [r3, #0]
 800661c:	f003 0304 	and.w	r3, r3, #4
 8006620:	2b00      	cmp	r3, #0
 8006622:	d005      	beq.n	8006630 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8006624:	4b59      	ldr	r3, [pc, #356]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006626:	689b      	ldr	r3, [r3, #8]
 8006628:	4a58      	ldr	r2, [pc, #352]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 800662a:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 800662e:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006630:	687b      	ldr	r3, [r7, #4]
 8006632:	681b      	ldr	r3, [r3, #0]
 8006634:	f003 0308 	and.w	r3, r3, #8
 8006638:	2b00      	cmp	r3, #0
 800663a:	d005      	beq.n	8006648 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800663c:	4b53      	ldr	r3, [pc, #332]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 800663e:	689b      	ldr	r3, [r3, #8]
 8006640:	4a52      	ldr	r2, [pc, #328]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006642:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 8006646:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006648:	4b50      	ldr	r3, [pc, #320]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 800664a:	689b      	ldr	r3, [r3, #8]
 800664c:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 8006650:	687b      	ldr	r3, [r7, #4]
 8006652:	689b      	ldr	r3, [r3, #8]
 8006654:	494d      	ldr	r1, [pc, #308]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006656:	4313      	orrs	r3, r2
 8006658:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800665a:	687b      	ldr	r3, [r7, #4]
 800665c:	681b      	ldr	r3, [r3, #0]
 800665e:	f003 0301 	and.w	r3, r3, #1
 8006662:	2b00      	cmp	r3, #0
 8006664:	d044      	beq.n	80066f0 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006666:	687b      	ldr	r3, [r7, #4]
 8006668:	685b      	ldr	r3, [r3, #4]
 800666a:	2b01      	cmp	r3, #1
 800666c:	d107      	bne.n	800667e <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800666e:	4b47      	ldr	r3, [pc, #284]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006670:	681b      	ldr	r3, [r3, #0]
 8006672:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8006676:	2b00      	cmp	r3, #0
 8006678:	d119      	bne.n	80066ae <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800667a:	2301      	movs	r3, #1
 800667c:	e07f      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800667e:	687b      	ldr	r3, [r7, #4]
 8006680:	685b      	ldr	r3, [r3, #4]
 8006682:	2b02      	cmp	r3, #2
 8006684:	d003      	beq.n	800668e <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8006686:	687b      	ldr	r3, [r7, #4]
 8006688:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800668a:	2b03      	cmp	r3, #3
 800668c:	d107      	bne.n	800669e <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800668e:	4b3f      	ldr	r3, [pc, #252]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006690:	681b      	ldr	r3, [r3, #0]
 8006692:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006696:	2b00      	cmp	r3, #0
 8006698:	d109      	bne.n	80066ae <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800669a:	2301      	movs	r3, #1
 800669c:	e06f      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800669e:	4b3b      	ldr	r3, [pc, #236]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 80066a0:	681b      	ldr	r3, [r3, #0]
 80066a2:	f003 0302 	and.w	r3, r3, #2
 80066a6:	2b00      	cmp	r3, #0
 80066a8:	d101      	bne.n	80066ae <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80066aa:	2301      	movs	r3, #1
 80066ac:	e067      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80066ae:	4b37      	ldr	r3, [pc, #220]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 80066b0:	689b      	ldr	r3, [r3, #8]
 80066b2:	f023 0203 	bic.w	r2, r3, #3
 80066b6:	687b      	ldr	r3, [r7, #4]
 80066b8:	685b      	ldr	r3, [r3, #4]
 80066ba:	4934      	ldr	r1, [pc, #208]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 80066bc:	4313      	orrs	r3, r2
 80066be:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 80066c0:	f7fb fa84 	bl	8001bcc <HAL_GetTick>
 80066c4:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80066c6:	e00a      	b.n	80066de <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80066c8:	f7fb fa80 	bl	8001bcc <HAL_GetTick>
 80066cc:	4602      	mov	r2, r0
 80066ce:	68fb      	ldr	r3, [r7, #12]
 80066d0:	1ad3      	subs	r3, r2, r3
 80066d2:	f241 3288 	movw	r2, #5000	@ 0x1388
 80066d6:	4293      	cmp	r3, r2
 80066d8:	d901      	bls.n	80066de <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 80066da:	2303      	movs	r3, #3
 80066dc:	e04f      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80066de:	4b2b      	ldr	r3, [pc, #172]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 80066e0:	689b      	ldr	r3, [r3, #8]
 80066e2:	f003 020c 	and.w	r2, r3, #12
 80066e6:	687b      	ldr	r3, [r7, #4]
 80066e8:	685b      	ldr	r3, [r3, #4]
 80066ea:	009b      	lsls	r3, r3, #2
 80066ec:	429a      	cmp	r2, r3
 80066ee:	d1eb      	bne.n	80066c8 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80066f0:	4b25      	ldr	r3, [pc, #148]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 80066f2:	681b      	ldr	r3, [r3, #0]
 80066f4:	f003 0307 	and.w	r3, r3, #7
 80066f8:	683a      	ldr	r2, [r7, #0]
 80066fa:	429a      	cmp	r2, r3
 80066fc:	d20c      	bcs.n	8006718 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80066fe:	4b22      	ldr	r3, [pc, #136]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 8006700:	683a      	ldr	r2, [r7, #0]
 8006702:	b2d2      	uxtb	r2, r2
 8006704:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8006706:	4b20      	ldr	r3, [pc, #128]	@ (8006788 <HAL_RCC_ClockConfig+0x1b8>)
 8006708:	681b      	ldr	r3, [r3, #0]
 800670a:	f003 0307 	and.w	r3, r3, #7
 800670e:	683a      	ldr	r2, [r7, #0]
 8006710:	429a      	cmp	r2, r3
 8006712:	d001      	beq.n	8006718 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8006714:	2301      	movs	r3, #1
 8006716:	e032      	b.n	800677e <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006718:	687b      	ldr	r3, [r7, #4]
 800671a:	681b      	ldr	r3, [r3, #0]
 800671c:	f003 0304 	and.w	r3, r3, #4
 8006720:	2b00      	cmp	r3, #0
 8006722:	d008      	beq.n	8006736 <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8006724:	4b19      	ldr	r3, [pc, #100]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006726:	689b      	ldr	r3, [r3, #8]
 8006728:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 800672c:	687b      	ldr	r3, [r7, #4]
 800672e:	68db      	ldr	r3, [r3, #12]
 8006730:	4916      	ldr	r1, [pc, #88]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006732:	4313      	orrs	r3, r2
 8006734:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006736:	687b      	ldr	r3, [r7, #4]
 8006738:	681b      	ldr	r3, [r3, #0]
 800673a:	f003 0308 	and.w	r3, r3, #8
 800673e:	2b00      	cmp	r3, #0
 8006740:	d009      	beq.n	8006756 <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8006742:	4b12      	ldr	r3, [pc, #72]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006744:	689b      	ldr	r3, [r3, #8]
 8006746:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 800674a:	687b      	ldr	r3, [r7, #4]
 800674c:	691b      	ldr	r3, [r3, #16]
 800674e:	00db      	lsls	r3, r3, #3
 8006750:	490e      	ldr	r1, [pc, #56]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 8006752:	4313      	orrs	r3, r2
 8006754:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR.reg & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8006756:	f000 f897 	bl	8006888 <HAL_RCC_GetSysClockFreq>
 800675a:	4602      	mov	r2, r0
 800675c:	4b0b      	ldr	r3, [pc, #44]	@ (800678c <HAL_RCC_ClockConfig+0x1bc>)
 800675e:	689b      	ldr	r3, [r3, #8]
 8006760:	091b      	lsrs	r3, r3, #4
 8006762:	f003 030f 	and.w	r3, r3, #15
 8006766:	490a      	ldr	r1, [pc, #40]	@ (8006790 <HAL_RCC_ClockConfig+0x1c0>)
 8006768:	5ccb      	ldrb	r3, [r1, r3]
 800676a:	fa22 f303 	lsr.w	r3, r2, r3
 800676e:	4a09      	ldr	r2, [pc, #36]	@ (8006794 <HAL_RCC_ClockConfig+0x1c4>)
 8006770:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 8006772:	4b09      	ldr	r3, [pc, #36]	@ (8006798 <HAL_RCC_ClockConfig+0x1c8>)
 8006774:	681b      	ldr	r3, [r3, #0]
 8006776:	4618      	mov	r0, r3
 8006778:	f7fb f9e4 	bl	8001b44 <HAL_InitTick>

  return HAL_OK;
 800677c:	2300      	movs	r3, #0
}
 800677e:	4618      	mov	r0, r3
 8006780:	3710      	adds	r7, #16
 8006782:	46bd      	mov	sp, r7
 8006784:	bd80      	pop	{r7, pc}
 8006786:	bf00      	nop
 8006788:	40023c00 	.word	0x40023c00
 800678c:	40023800 	.word	0x40023800
 8006790:	0802fae0 	.word	0x0802fae0
 8006794:	20000000 	.word	0x20000000
 8006798:	20000004 	.word	0x20000004

0800679c <HAL_RCC_MCOConfig>:
  * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have
  *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 800679c:	b580      	push	{r7, lr}
 800679e:	b08a      	sub	sp, #40	@ 0x28
 80067a0:	af00      	add	r7, sp, #0
 80067a2:	60f8      	str	r0, [r7, #12]
 80067a4:	60b9      	str	r1, [r7, #8]
 80067a6:	607a      	str	r2, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 80067a8:	68fb      	ldr	r3, [r7, #12]
 80067aa:	2b00      	cmp	r3, #0
 80067ac:	d130      	bne.n	8006810 <HAL_RCC_MCOConfig+0x74>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    __MCO1_CLK_ENABLE();
 80067ae:	2300      	movs	r3, #0
 80067b0:	617b      	str	r3, [r7, #20]
 80067b2:	4b32      	ldr	r3, [pc, #200]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 80067b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80067b6:	4a31      	ldr	r2, [pc, #196]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 80067b8:	f043 0301 	orr.w	r3, r3, #1
 80067bc:	6313      	str	r3, [r2, #48]	@ 0x30
 80067be:	4b2f      	ldr	r3, [pc, #188]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 80067c0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80067c2:	f003 0301 	and.w	r3, r3, #1
 80067c6:	617b      	str	r3, [r7, #20]
 80067c8:	697b      	ldr	r3, [r7, #20]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.pGPIOx = MCO1_GPIO_PORT;
 80067ca:	4b2d      	ldr	r3, [pc, #180]	@ (8006880 <HAL_RCC_MCOConfig+0xe4>)
 80067cc:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.GPIO_Config.PinNumber = MCO1_PIN;
 80067ce:	2308      	movs	r3, #8
 80067d0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 80067d2:	2302      	movs	r3, #2
 80067d4:	f887 3020 	strb.w	r3, [r7, #32]
    GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 80067d8:	2300      	movs	r3, #0
 80067da:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    GPIO_InitStruct.GPIO_Config.PinSpeed = 3;
 80067de:	2303      	movs	r3, #3
 80067e0:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
    GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 80067e4:	2300      	movs	r3, #0
 80067e6:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
    GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 80067ea:	2300      	movs	r3, #0
 80067ec:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
    GPIO_Init(&GPIO_InitStruct);
 80067f0:	f107 0318 	add.w	r3, r7, #24
 80067f4:	4618      	mov	r0, r3
 80067f6:	f002 fe21 	bl	800943c <GPIO_Init>

    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    MODIFY_REG(RCC->CFGR.reg, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 80067fa:	4b20      	ldr	r3, [pc, #128]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 80067fc:	689b      	ldr	r3, [r3, #8]
 80067fe:	f023 62ec 	bic.w	r2, r3, #123731968	@ 0x7600000
 8006802:	68b9      	ldr	r1, [r7, #8]
 8006804:	687b      	ldr	r3, [r7, #4]
 8006806:	430b      	orrs	r3, r1
 8006808:	491c      	ldr	r1, [pc, #112]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 800680a:	4313      	orrs	r3, r2
 800680c:	608b      	str	r3, [r1, #8]
#if defined(RCC_CFGR_MCO2EN)
    __HAL_RCC_MCO2_ENABLE();
#endif /* RCC_CFGR_MCO2EN */
  }
#endif /* RCC_CFGR_MCO2 */
}
 800680e:	e030      	b.n	8006872 <HAL_RCC_MCOConfig+0xd6>
    __MCO2_CLK_ENABLE();
 8006810:	2300      	movs	r3, #0
 8006812:	613b      	str	r3, [r7, #16]
 8006814:	4b19      	ldr	r3, [pc, #100]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 8006816:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006818:	4a18      	ldr	r2, [pc, #96]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 800681a:	f043 0304 	orr.w	r3, r3, #4
 800681e:	6313      	str	r3, [r2, #48]	@ 0x30
 8006820:	4b16      	ldr	r3, [pc, #88]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 8006822:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006824:	f003 0304 	and.w	r3, r3, #4
 8006828:	613b      	str	r3, [r7, #16]
 800682a:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.pGPIOx = MCO2_GPIO_PORT;
 800682c:	4b15      	ldr	r3, [pc, #84]	@ (8006884 <HAL_RCC_MCOConfig+0xe8>)
 800682e:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.GPIO_Config.PinNumber = MCO2_PIN;
 8006830:	2309      	movs	r3, #9
 8006832:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8006834:	2302      	movs	r3, #2
 8006836:	f887 3020 	strb.w	r3, [r7, #32]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800683a:	2300      	movs	r3, #0
 800683c:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
	GPIO_InitStruct.GPIO_Config.PinSpeed = 3;
 8006840:	2303      	movs	r3, #3
 8006842:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8006846:	2300      	movs	r3, #0
 8006848:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 800684c:	2300      	movs	r3, #0
 800684e:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
	GPIO_Init(&GPIO_InitStruct);
 8006852:	f107 0318 	add.w	r3, r7, #24
 8006856:	4618      	mov	r0, r3
 8006858:	f002 fdf0 	bl	800943c <GPIO_Init>
    MODIFY_REG(RCC->CFGR.reg, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3U)));
 800685c:	4b07      	ldr	r3, [pc, #28]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 800685e:	689b      	ldr	r3, [r3, #8]
 8006860:	f023 4278 	bic.w	r2, r3, #4160749568	@ 0xf8000000
 8006864:	687b      	ldr	r3, [r7, #4]
 8006866:	00d9      	lsls	r1, r3, #3
 8006868:	68bb      	ldr	r3, [r7, #8]
 800686a:	430b      	orrs	r3, r1
 800686c:	4903      	ldr	r1, [pc, #12]	@ (800687c <HAL_RCC_MCOConfig+0xe0>)
 800686e:	4313      	orrs	r3, r2
 8006870:	608b      	str	r3, [r1, #8]
}
 8006872:	bf00      	nop
 8006874:	3728      	adds	r7, #40	@ 0x28
 8006876:	46bd      	mov	sp, r7
 8006878:	bd80      	pop	{r7, pc}
 800687a:	bf00      	nop
 800687c:	40023800 	.word	0x40023800
 8006880:	40020000 	.word	0x40020000
 8006884:	40020800 	.word	0x40020800

08006888 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8006888:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800688c:	b094      	sub	sp, #80	@ 0x50
 800688e:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 8006890:	2300      	movs	r3, #0
 8006892:	647b      	str	r3, [r7, #68]	@ 0x44
 8006894:	2300      	movs	r3, #0
 8006896:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8006898:	2300      	movs	r3, #0
 800689a:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 800689c:	2300      	movs	r3, #0
 800689e:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR.reg & RCC_CFGR_SWS)
 80068a0:	4b79      	ldr	r3, [pc, #484]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 80068a2:	689b      	ldr	r3, [r3, #8]
 80068a4:	f003 030c 	and.w	r3, r3, #12
 80068a8:	2b08      	cmp	r3, #8
 80068aa:	d00d      	beq.n	80068c8 <HAL_RCC_GetSysClockFreq+0x40>
 80068ac:	2b08      	cmp	r3, #8
 80068ae:	f200 80e1 	bhi.w	8006a74 <HAL_RCC_GetSysClockFreq+0x1ec>
 80068b2:	2b00      	cmp	r3, #0
 80068b4:	d002      	beq.n	80068bc <HAL_RCC_GetSysClockFreq+0x34>
 80068b6:	2b04      	cmp	r3, #4
 80068b8:	d003      	beq.n	80068c2 <HAL_RCC_GetSysClockFreq+0x3a>
 80068ba:	e0db      	b.n	8006a74 <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80068bc:	4b73      	ldr	r3, [pc, #460]	@ (8006a8c <HAL_RCC_GetSysClockFreq+0x204>)
 80068be:	64bb      	str	r3, [r7, #72]	@ 0x48
       break;
 80068c0:	e0db      	b.n	8006a7a <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 80068c2:	4b73      	ldr	r3, [pc, #460]	@ (8006a90 <HAL_RCC_GetSysClockFreq+0x208>)
 80068c4:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 80068c6:	e0d8      	b.n	8006a7a <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLM;
 80068c8:	4b6f      	ldr	r3, [pc, #444]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 80068ca:	685b      	ldr	r3, [r3, #4]
 80068cc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80068d0:	647b      	str	r3, [r7, #68]	@ 0x44
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80068d2:	4b6d      	ldr	r3, [pc, #436]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 80068d4:	685b      	ldr	r3, [r3, #4]
 80068d6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80068da:	2b00      	cmp	r3, #0
 80068dc:	d063      	beq.n	80069a6 <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80068de:	4b6a      	ldr	r3, [pc, #424]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 80068e0:	685b      	ldr	r3, [r3, #4]
 80068e2:	099b      	lsrs	r3, r3, #6
 80068e4:	2200      	movs	r2, #0
 80068e6:	63bb      	str	r3, [r7, #56]	@ 0x38
 80068e8:	63fa      	str	r2, [r7, #60]	@ 0x3c
 80068ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80068ec:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80068f0:	633b      	str	r3, [r7, #48]	@ 0x30
 80068f2:	2300      	movs	r3, #0
 80068f4:	637b      	str	r3, [r7, #52]	@ 0x34
 80068f6:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 80068fa:	4622      	mov	r2, r4
 80068fc:	462b      	mov	r3, r5
 80068fe:	f04f 0000 	mov.w	r0, #0
 8006902:	f04f 0100 	mov.w	r1, #0
 8006906:	0159      	lsls	r1, r3, #5
 8006908:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800690c:	0150      	lsls	r0, r2, #5
 800690e:	4602      	mov	r2, r0
 8006910:	460b      	mov	r3, r1
 8006912:	4621      	mov	r1, r4
 8006914:	1a51      	subs	r1, r2, r1
 8006916:	6139      	str	r1, [r7, #16]
 8006918:	4629      	mov	r1, r5
 800691a:	eb63 0301 	sbc.w	r3, r3, r1
 800691e:	617b      	str	r3, [r7, #20]
 8006920:	f04f 0200 	mov.w	r2, #0
 8006924:	f04f 0300 	mov.w	r3, #0
 8006928:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 800692c:	4659      	mov	r1, fp
 800692e:	018b      	lsls	r3, r1, #6
 8006930:	4651      	mov	r1, sl
 8006932:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 8006936:	4651      	mov	r1, sl
 8006938:	018a      	lsls	r2, r1, #6
 800693a:	4651      	mov	r1, sl
 800693c:	ebb2 0801 	subs.w	r8, r2, r1
 8006940:	4659      	mov	r1, fp
 8006942:	eb63 0901 	sbc.w	r9, r3, r1
 8006946:	f04f 0200 	mov.w	r2, #0
 800694a:	f04f 0300 	mov.w	r3, #0
 800694e:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8006952:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8006956:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 800695a:	4690      	mov	r8, r2
 800695c:	4699      	mov	r9, r3
 800695e:	4623      	mov	r3, r4
 8006960:	eb18 0303 	adds.w	r3, r8, r3
 8006964:	60bb      	str	r3, [r7, #8]
 8006966:	462b      	mov	r3, r5
 8006968:	eb49 0303 	adc.w	r3, r9, r3
 800696c:	60fb      	str	r3, [r7, #12]
 800696e:	f04f 0200 	mov.w	r2, #0
 8006972:	f04f 0300 	mov.w	r3, #0
 8006976:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 800697a:	4629      	mov	r1, r5
 800697c:	024b      	lsls	r3, r1, #9
 800697e:	4621      	mov	r1, r4
 8006980:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 8006984:	4621      	mov	r1, r4
 8006986:	024a      	lsls	r2, r1, #9
 8006988:	4610      	mov	r0, r2
 800698a:	4619      	mov	r1, r3
 800698c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800698e:	2200      	movs	r2, #0
 8006990:	62bb      	str	r3, [r7, #40]	@ 0x28
 8006992:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8006994:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8006998:	f7fa f888 	bl	8000aac <__aeabi_uldivmod>
 800699c:	4602      	mov	r2, r0
 800699e:	460b      	mov	r3, r1
 80069a0:	4613      	mov	r3, r2
 80069a2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80069a4:	e058      	b.n	8006a58 <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80069a6:	4b38      	ldr	r3, [pc, #224]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 80069a8:	685b      	ldr	r3, [r3, #4]
 80069aa:	099b      	lsrs	r3, r3, #6
 80069ac:	2200      	movs	r2, #0
 80069ae:	4618      	mov	r0, r3
 80069b0:	4611      	mov	r1, r2
 80069b2:	f3c0 0308 	ubfx	r3, r0, #0, #9
 80069b6:	623b      	str	r3, [r7, #32]
 80069b8:	2300      	movs	r3, #0
 80069ba:	627b      	str	r3, [r7, #36]	@ 0x24
 80069bc:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 80069c0:	4642      	mov	r2, r8
 80069c2:	464b      	mov	r3, r9
 80069c4:	f04f 0000 	mov.w	r0, #0
 80069c8:	f04f 0100 	mov.w	r1, #0
 80069cc:	0159      	lsls	r1, r3, #5
 80069ce:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 80069d2:	0150      	lsls	r0, r2, #5
 80069d4:	4602      	mov	r2, r0
 80069d6:	460b      	mov	r3, r1
 80069d8:	4641      	mov	r1, r8
 80069da:	ebb2 0a01 	subs.w	sl, r2, r1
 80069de:	4649      	mov	r1, r9
 80069e0:	eb63 0b01 	sbc.w	fp, r3, r1
 80069e4:	f04f 0200 	mov.w	r2, #0
 80069e8:	f04f 0300 	mov.w	r3, #0
 80069ec:	ea4f 138b 	mov.w	r3, fp, lsl #6
 80069f0:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 80069f4:	ea4f 128a 	mov.w	r2, sl, lsl #6
 80069f8:	ebb2 040a 	subs.w	r4, r2, sl
 80069fc:	eb63 050b 	sbc.w	r5, r3, fp
 8006a00:	f04f 0200 	mov.w	r2, #0
 8006a04:	f04f 0300 	mov.w	r3, #0
 8006a08:	00eb      	lsls	r3, r5, #3
 8006a0a:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8006a0e:	00e2      	lsls	r2, r4, #3
 8006a10:	4614      	mov	r4, r2
 8006a12:	461d      	mov	r5, r3
 8006a14:	4643      	mov	r3, r8
 8006a16:	18e3      	adds	r3, r4, r3
 8006a18:	603b      	str	r3, [r7, #0]
 8006a1a:	464b      	mov	r3, r9
 8006a1c:	eb45 0303 	adc.w	r3, r5, r3
 8006a20:	607b      	str	r3, [r7, #4]
 8006a22:	f04f 0200 	mov.w	r2, #0
 8006a26:	f04f 0300 	mov.w	r3, #0
 8006a2a:	e9d7 4500 	ldrd	r4, r5, [r7]
 8006a2e:	4629      	mov	r1, r5
 8006a30:	028b      	lsls	r3, r1, #10
 8006a32:	4621      	mov	r1, r4
 8006a34:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8006a38:	4621      	mov	r1, r4
 8006a3a:	028a      	lsls	r2, r1, #10
 8006a3c:	4610      	mov	r0, r2
 8006a3e:	4619      	mov	r1, r3
 8006a40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8006a42:	2200      	movs	r2, #0
 8006a44:	61bb      	str	r3, [r7, #24]
 8006a46:	61fa      	str	r2, [r7, #28]
 8006a48:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8006a4c:	f7fa f82e 	bl	8000aac <__aeabi_uldivmod>
 8006a50:	4602      	mov	r2, r0
 8006a52:	460b      	mov	r3, r1
 8006a54:	4613      	mov	r3, r2
 8006a56:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8006a58:	4b0b      	ldr	r3, [pc, #44]	@ (8006a88 <HAL_RCC_GetSysClockFreq+0x200>)
 8006a5a:	685b      	ldr	r3, [r3, #4]
 8006a5c:	0c1b      	lsrs	r3, r3, #16
 8006a5e:	f003 0303 	and.w	r3, r3, #3
 8006a62:	3301      	adds	r3, #1
 8006a64:	005b      	lsls	r3, r3, #1
 8006a66:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco/pllp;
 8006a68:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8006a6a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006a6c:	fbb2 f3f3 	udiv	r3, r2, r3
 8006a70:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8006a72:	e002      	b.n	8006a7a <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8006a74:	4b05      	ldr	r3, [pc, #20]	@ (8006a8c <HAL_RCC_GetSysClockFreq+0x204>)
 8006a76:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8006a78:	bf00      	nop
    }
  }
  return sysclockfreq;
 8006a7a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 8006a7c:	4618      	mov	r0, r3
 8006a7e:	3750      	adds	r7, #80	@ 0x50
 8006a80:	46bd      	mov	sp, r7
 8006a82:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006a86:	bf00      	nop
 8006a88:	40023800 	.word	0x40023800
 8006a8c:	00f42400 	.word	0x00f42400
 8006a90:	007a1200 	.word	0x007a1200

08006a94 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8006a94:	b480      	push	{r7}
 8006a96:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8006a98:	4b03      	ldr	r3, [pc, #12]	@ (8006aa8 <HAL_RCC_GetHCLKFreq+0x14>)
 8006a9a:	681b      	ldr	r3, [r3, #0]
}
 8006a9c:	4618      	mov	r0, r3
 8006a9e:	46bd      	mov	sp, r7
 8006aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006aa4:	4770      	bx	lr
 8006aa6:	bf00      	nop
 8006aa8:	20000000 	.word	0x20000000

08006aac <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8006aac:	b580      	push	{r7, lr}
 8006aae:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR.reg & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8006ab0:	f7ff fff0 	bl	8006a94 <HAL_RCC_GetHCLKFreq>
 8006ab4:	4602      	mov	r2, r0
 8006ab6:	4b05      	ldr	r3, [pc, #20]	@ (8006acc <HAL_RCC_GetPCLK1Freq+0x20>)
 8006ab8:	689b      	ldr	r3, [r3, #8]
 8006aba:	0a9b      	lsrs	r3, r3, #10
 8006abc:	f003 0307 	and.w	r3, r3, #7
 8006ac0:	4903      	ldr	r1, [pc, #12]	@ (8006ad0 <HAL_RCC_GetPCLK1Freq+0x24>)
 8006ac2:	5ccb      	ldrb	r3, [r1, r3]
 8006ac4:	fa22 f303 	lsr.w	r3, r2, r3
}
 8006ac8:	4618      	mov	r0, r3
 8006aca:	bd80      	pop	{r7, pc}
 8006acc:	40023800 	.word	0x40023800
 8006ad0:	0802faf0 	.word	0x0802faf0

08006ad4 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8006ad4:	b580      	push	{r7, lr}
 8006ad6:	b086      	sub	sp, #24
 8006ad8:	af00      	add	r7, sp, #0
 8006ada:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8006adc:	2300      	movs	r3, #0
 8006ade:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8006ae0:	2300      	movs	r3, #0
 8006ae2:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8006ae4:	687b      	ldr	r3, [r7, #4]
 8006ae6:	681b      	ldr	r3, [r3, #0]
 8006ae8:	f003 0301 	and.w	r3, r3, #1
 8006aec:	2b00      	cmp	r3, #0
 8006aee:	d105      	bne.n	8006afc <HAL_RCCEx_PeriphCLKConfig+0x28>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8006af0:	687b      	ldr	r3, [r7, #4]
 8006af2:	681b      	ldr	r3, [r3, #0]
 8006af4:	f003 0304 	and.w	r3, r3, #4
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8006af8:	2b00      	cmp	r3, #0
 8006afa:	d035      	beq.n	8006b68 <HAL_RCCEx_PeriphCLKConfig+0x94>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8006afc:	4b62      	ldr	r3, [pc, #392]	@ (8006c88 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8006afe:	2200      	movs	r2, #0
 8006b00:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8006b02:	f7fb f863 	bl	8001bcc <HAL_GetTick>
 8006b06:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8006b08:	e008      	b.n	8006b1c <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8006b0a:	f7fb f85f 	bl	8001bcc <HAL_GetTick>
 8006b0e:	4602      	mov	r2, r0
 8006b10:	697b      	ldr	r3, [r7, #20]
 8006b12:	1ad3      	subs	r3, r2, r3
 8006b14:	2b02      	cmp	r3, #2
 8006b16:	d901      	bls.n	8006b1c <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8006b18:	2303      	movs	r3, #3
 8006b1a:	e0b0      	b.n	8006c7e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8006b1c:	4b5b      	ldr	r3, [pc, #364]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b1e:	681b      	ldr	r3, [r3, #0]
 8006b20:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8006b24:	2b00      	cmp	r3, #0
 8006b26:	d1f0      	bne.n	8006b0a <HAL_RCCEx_PeriphCLKConfig+0x36>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8006b28:	687b      	ldr	r3, [r7, #4]
 8006b2a:	685b      	ldr	r3, [r3, #4]
 8006b2c:	019a      	lsls	r2, r3, #6
 8006b2e:	687b      	ldr	r3, [r7, #4]
 8006b30:	689b      	ldr	r3, [r3, #8]
 8006b32:	071b      	lsls	r3, r3, #28
 8006b34:	4955      	ldr	r1, [pc, #340]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b36:	4313      	orrs	r3, r2
 8006b38:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8006b3c:	4b52      	ldr	r3, [pc, #328]	@ (8006c88 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8006b3e:	2201      	movs	r2, #1
 8006b40:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8006b42:	f7fb f843 	bl	8001bcc <HAL_GetTick>
 8006b46:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8006b48:	e008      	b.n	8006b5c <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8006b4a:	f7fb f83f 	bl	8001bcc <HAL_GetTick>
 8006b4e:	4602      	mov	r2, r0
 8006b50:	697b      	ldr	r3, [r7, #20]
 8006b52:	1ad3      	subs	r3, r2, r3
 8006b54:	2b02      	cmp	r3, #2
 8006b56:	d901      	bls.n	8006b5c <HAL_RCCEx_PeriphCLKConfig+0x88>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8006b58:	2303      	movs	r3, #3
 8006b5a:	e090      	b.n	8006c7e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8006b5c:	4b4b      	ldr	r3, [pc, #300]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b5e:	681b      	ldr	r3, [r3, #0]
 8006b60:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8006b64:	2b00      	cmp	r3, #0
 8006b66:	d0f0      	beq.n	8006b4a <HAL_RCCEx_PeriphCLKConfig+0x76>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8006b68:	687b      	ldr	r3, [r7, #4]
 8006b6a:	681b      	ldr	r3, [r3, #0]
 8006b6c:	f003 0302 	and.w	r3, r3, #2
 8006b70:	2b00      	cmp	r3, #0
 8006b72:	f000 8083 	beq.w	8006c7c <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8006b76:	2300      	movs	r3, #0
 8006b78:	60fb      	str	r3, [r7, #12]
 8006b7a:	4b44      	ldr	r3, [pc, #272]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b7c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006b7e:	4a43      	ldr	r2, [pc, #268]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b80:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006b84:	6413      	str	r3, [r2, #64]	@ 0x40
 8006b86:	4b41      	ldr	r3, [pc, #260]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006b88:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006b8a:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8006b8e:	60fb      	str	r3, [r7, #12]
 8006b90:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR.reg |= PWR_CR_DBP;
 8006b92:	4b3f      	ldr	r3, [pc, #252]	@ (8006c90 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8006b94:	681b      	ldr	r3, [r3, #0]
 8006b96:	4a3e      	ldr	r2, [pc, #248]	@ (8006c90 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8006b98:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8006b9c:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8006b9e:	f7fb f815 	bl	8001bcc <HAL_GetTick>
 8006ba2:	6178      	str	r0, [r7, #20]

    while((PWR->CR.reg & PWR_CR_DBP) == RESET)
 8006ba4:	e008      	b.n	8006bb8 <HAL_RCCEx_PeriphCLKConfig+0xe4>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8006ba6:	f7fb f811 	bl	8001bcc <HAL_GetTick>
 8006baa:	4602      	mov	r2, r0
 8006bac:	697b      	ldr	r3, [r7, #20]
 8006bae:	1ad3      	subs	r3, r2, r3
 8006bb0:	2b02      	cmp	r3, #2
 8006bb2:	d901      	bls.n	8006bb8 <HAL_RCCEx_PeriphCLKConfig+0xe4>
      {
        return HAL_TIMEOUT;
 8006bb4:	2303      	movs	r3, #3
 8006bb6:	e062      	b.n	8006c7e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while((PWR->CR.reg & PWR_CR_DBP) == RESET)
 8006bb8:	4b35      	ldr	r3, [pc, #212]	@ (8006c90 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8006bba:	681b      	ldr	r3, [r3, #0]
 8006bbc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006bc0:	2b00      	cmp	r3, #0
 8006bc2:	d0f0      	beq.n	8006ba6 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR.reg & RCC_BDCR_RTCSEL);
 8006bc4:	4b31      	ldr	r3, [pc, #196]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006bc6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006bc8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006bcc:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8006bce:	693b      	ldr	r3, [r7, #16]
 8006bd0:	2b00      	cmp	r3, #0
 8006bd2:	d02f      	beq.n	8006c34 <HAL_RCCEx_PeriphCLKConfig+0x160>
 8006bd4:	687b      	ldr	r3, [r7, #4]
 8006bd6:	68db      	ldr	r3, [r3, #12]
 8006bd8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006bdc:	693a      	ldr	r2, [r7, #16]
 8006bde:	429a      	cmp	r2, r3
 8006be0:	d028      	beq.n	8006c34 <HAL_RCCEx_PeriphCLKConfig+0x160>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR.reg & ~(RCC_BDCR_RTCSEL));
 8006be2:	4b2a      	ldr	r3, [pc, #168]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006be4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006be6:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8006bea:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8006bec:	4b29      	ldr	r3, [pc, #164]	@ (8006c94 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8006bee:	2201      	movs	r2, #1
 8006bf0:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8006bf2:	4b28      	ldr	r3, [pc, #160]	@ (8006c94 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8006bf4:	2200      	movs	r2, #0
 8006bf6:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR.reg = tmpreg1;
 8006bf8:	4a24      	ldr	r2, [pc, #144]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006bfa:	693b      	ldr	r3, [r7, #16]
 8006bfc:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR.reg, RCC_BDCR_LSEON))
 8006bfe:	4b23      	ldr	r3, [pc, #140]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c00:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006c02:	f003 0301 	and.w	r3, r3, #1
 8006c06:	2b00      	cmp	r3, #0
 8006c08:	d014      	beq.n	8006c34 <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8006c0a:	f7fa ffdf 	bl	8001bcc <HAL_GetTick>
 8006c0e:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006c10:	e00a      	b.n	8006c28 <HAL_RCCEx_PeriphCLKConfig+0x154>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8006c12:	f7fa ffdb 	bl	8001bcc <HAL_GetTick>
 8006c16:	4602      	mov	r2, r0
 8006c18:	697b      	ldr	r3, [r7, #20]
 8006c1a:	1ad3      	subs	r3, r2, r3
 8006c1c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8006c20:	4293      	cmp	r3, r2
 8006c22:	d901      	bls.n	8006c28 <HAL_RCCEx_PeriphCLKConfig+0x154>
          {
            return HAL_TIMEOUT;
 8006c24:	2303      	movs	r3, #3
 8006c26:	e02a      	b.n	8006c7e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006c28:	4b18      	ldr	r3, [pc, #96]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c2a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006c2c:	f003 0302 	and.w	r3, r3, #2
 8006c30:	2b00      	cmp	r3, #0
 8006c32:	d0ee      	beq.n	8006c12 <HAL_RCCEx_PeriphCLKConfig+0x13e>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8006c34:	687b      	ldr	r3, [r7, #4]
 8006c36:	68db      	ldr	r3, [r3, #12]
 8006c38:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006c3c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8006c40:	d10d      	bne.n	8006c5e <HAL_RCCEx_PeriphCLKConfig+0x18a>
 8006c42:	4b12      	ldr	r3, [pc, #72]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c44:	689b      	ldr	r3, [r3, #8]
 8006c46:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8006c4a:	687b      	ldr	r3, [r7, #4]
 8006c4c:	68db      	ldr	r3, [r3, #12]
 8006c4e:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8006c52:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8006c56:	490d      	ldr	r1, [pc, #52]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c58:	4313      	orrs	r3, r2
 8006c5a:	608b      	str	r3, [r1, #8]
 8006c5c:	e005      	b.n	8006c6a <HAL_RCCEx_PeriphCLKConfig+0x196>
 8006c5e:	4b0b      	ldr	r3, [pc, #44]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c60:	689b      	ldr	r3, [r3, #8]
 8006c62:	4a0a      	ldr	r2, [pc, #40]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c64:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8006c68:	6093      	str	r3, [r2, #8]
 8006c6a:	4b08      	ldr	r3, [pc, #32]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c6c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8006c6e:	687b      	ldr	r3, [r7, #4]
 8006c70:	68db      	ldr	r3, [r3, #12]
 8006c72:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8006c76:	4905      	ldr	r1, [pc, #20]	@ (8006c8c <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006c78:	4313      	orrs	r3, r2
 8006c7a:	670b      	str	r3, [r1, #112]	@ 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8006c7c:	2300      	movs	r3, #0
}
 8006c7e:	4618      	mov	r0, r3
 8006c80:	3718      	adds	r7, #24
 8006c82:	46bd      	mov	sp, r7
 8006c84:	bd80      	pop	{r7, pc}
 8006c86:	bf00      	nop
 8006c88:	42470068 	.word	0x42470068
 8006c8c:	40023800 	.word	0x40023800
 8006c90:	40007000 	.word	0x40007000
 8006c94:	42470e40 	.word	0x42470e40

08006c98 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8006c98:	b084      	sub	sp, #16
 8006c9a:	b580      	push	{r7, lr}
 8006c9c:	b084      	sub	sp, #16
 8006c9e:	af00      	add	r7, sp, #0
 8006ca0:	6078      	str	r0, [r7, #4]
 8006ca2:	f107 001c 	add.w	r0, r7, #28
 8006ca6:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8006caa:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 8006cae:	2b01      	cmp	r3, #1
 8006cb0:	d123      	bne.n	8006cfa <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8006cb2:	687b      	ldr	r3, [r7, #4]
 8006cb4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006cb6:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8006cba:	687b      	ldr	r3, [r7, #4]
 8006cbc:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8006cbe:	687b      	ldr	r3, [r7, #4]
 8006cc0:	68db      	ldr	r3, [r3, #12]
 8006cc2:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 8006cc6:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8006cca:	687a      	ldr	r2, [r7, #4]
 8006ccc:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8006cce:	687b      	ldr	r3, [r7, #4]
 8006cd0:	68db      	ldr	r3, [r3, #12]
 8006cd2:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8006cda:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8006cde:	2b01      	cmp	r3, #1
 8006ce0:	d105      	bne.n	8006cee <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	68db      	ldr	r3, [r3, #12]
 8006ce6:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 8006cea:	687b      	ldr	r3, [r7, #4]
 8006cec:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8006cee:	6878      	ldr	r0, [r7, #4]
 8006cf0:	f000 f9dc 	bl	80070ac <USB_CoreReset>
 8006cf4:	4603      	mov	r3, r0
 8006cf6:	73fb      	strb	r3, [r7, #15]
 8006cf8:	e01b      	b.n	8006d32 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8006cfa:	687b      	ldr	r3, [r7, #4]
 8006cfc:	68db      	ldr	r3, [r3, #12]
 8006cfe:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8006d02:	687b      	ldr	r3, [r7, #4]
 8006d04:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8006d06:	6878      	ldr	r0, [r7, #4]
 8006d08:	f000 f9d0 	bl	80070ac <USB_CoreReset>
 8006d0c:	4603      	mov	r3, r0
 8006d0e:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8006d10:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8006d14:	2b00      	cmp	r3, #0
 8006d16:	d106      	bne.n	8006d26 <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8006d18:	687b      	ldr	r3, [r7, #4]
 8006d1a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006d1c:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8006d20:	687b      	ldr	r3, [r7, #4]
 8006d22:	639a      	str	r2, [r3, #56]	@ 0x38
 8006d24:	e005      	b.n	8006d32 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8006d26:	687b      	ldr	r3, [r7, #4]
 8006d28:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006d2a:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8006d2e:	687b      	ldr	r3, [r7, #4]
 8006d30:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8006d32:	7fbb      	ldrb	r3, [r7, #30]
 8006d34:	2b01      	cmp	r3, #1
 8006d36:	d10b      	bne.n	8006d50 <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8006d38:	687b      	ldr	r3, [r7, #4]
 8006d3a:	689b      	ldr	r3, [r3, #8]
 8006d3c:	f043 0206 	orr.w	r2, r3, #6
 8006d40:	687b      	ldr	r3, [r7, #4]
 8006d42:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8006d44:	687b      	ldr	r3, [r7, #4]
 8006d46:	689b      	ldr	r3, [r3, #8]
 8006d48:	f043 0220 	orr.w	r2, r3, #32
 8006d4c:	687b      	ldr	r3, [r7, #4]
 8006d4e:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8006d50:	7bfb      	ldrb	r3, [r7, #15]
}
 8006d52:	4618      	mov	r0, r3
 8006d54:	3710      	adds	r7, #16
 8006d56:	46bd      	mov	sp, r7
 8006d58:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8006d5c:	b004      	add	sp, #16
 8006d5e:	4770      	bx	lr

08006d60 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8006d60:	b480      	push	{r7}
 8006d62:	b083      	sub	sp, #12
 8006d64:	af00      	add	r7, sp, #0
 8006d66:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8006d68:	687b      	ldr	r3, [r7, #4]
 8006d6a:	689b      	ldr	r3, [r3, #8]
 8006d6c:	f043 0201 	orr.w	r2, r3, #1
 8006d70:	687b      	ldr	r3, [r7, #4]
 8006d72:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8006d74:	2300      	movs	r3, #0
}
 8006d76:	4618      	mov	r0, r3
 8006d78:	370c      	adds	r7, #12
 8006d7a:	46bd      	mov	sp, r7
 8006d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d80:	4770      	bx	lr

08006d82 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8006d82:	b480      	push	{r7}
 8006d84:	b083      	sub	sp, #12
 8006d86:	af00      	add	r7, sp, #0
 8006d88:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8006d8a:	687b      	ldr	r3, [r7, #4]
 8006d8c:	689b      	ldr	r3, [r3, #8]
 8006d8e:	f023 0201 	bic.w	r2, r3, #1
 8006d92:	687b      	ldr	r3, [r7, #4]
 8006d94:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8006d96:	2300      	movs	r3, #0
}
 8006d98:	4618      	mov	r0, r3
 8006d9a:	370c      	adds	r7, #12
 8006d9c:	46bd      	mov	sp, r7
 8006d9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006da2:	4770      	bx	lr

08006da4 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8006da4:	b580      	push	{r7, lr}
 8006da6:	b084      	sub	sp, #16
 8006da8:	af00      	add	r7, sp, #0
 8006daa:	6078      	str	r0, [r7, #4]
 8006dac:	460b      	mov	r3, r1
 8006dae:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8006db0:	2300      	movs	r3, #0
 8006db2:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8006db4:	687b      	ldr	r3, [r7, #4]
 8006db6:	68db      	ldr	r3, [r3, #12]
 8006db8:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 8006dbc:	687b      	ldr	r3, [r7, #4]
 8006dbe:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8006dc0:	78fb      	ldrb	r3, [r7, #3]
 8006dc2:	2b01      	cmp	r3, #1
 8006dc4:	d115      	bne.n	8006df2 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8006dc6:	687b      	ldr	r3, [r7, #4]
 8006dc8:	68db      	ldr	r3, [r3, #12]
 8006dca:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 8006dce:	687b      	ldr	r3, [r7, #4]
 8006dd0:	60da      	str	r2, [r3, #12]

    do
    {
      delay_ms(10U);
 8006dd2:	200a      	movs	r0, #10
 8006dd4:	f003 fc4c 	bl	800a670 <delay_ms>
      ms += 10U;
 8006dd8:	68fb      	ldr	r3, [r7, #12]
 8006dda:	330a      	adds	r3, #10
 8006ddc:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8006dde:	6878      	ldr	r0, [r7, #4]
 8006de0:	f000 f956 	bl	8007090 <USB_GetMode>
 8006de4:	4603      	mov	r3, r0
 8006de6:	2b01      	cmp	r3, #1
 8006de8:	d01e      	beq.n	8006e28 <USB_SetCurrentMode+0x84>
 8006dea:	68fb      	ldr	r3, [r7, #12]
 8006dec:	2bc7      	cmp	r3, #199	@ 0xc7
 8006dee:	d9f0      	bls.n	8006dd2 <USB_SetCurrentMode+0x2e>
 8006df0:	e01a      	b.n	8006e28 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8006df2:	78fb      	ldrb	r3, [r7, #3]
 8006df4:	2b00      	cmp	r3, #0
 8006df6:	d115      	bne.n	8006e24 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8006df8:	687b      	ldr	r3, [r7, #4]
 8006dfa:	68db      	ldr	r3, [r3, #12]
 8006dfc:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8006e00:	687b      	ldr	r3, [r7, #4]
 8006e02:	60da      	str	r2, [r3, #12]

    do
    {
    	delay_ms(10U);
 8006e04:	200a      	movs	r0, #10
 8006e06:	f003 fc33 	bl	800a670 <delay_ms>
      ms += 10U;
 8006e0a:	68fb      	ldr	r3, [r7, #12]
 8006e0c:	330a      	adds	r3, #10
 8006e0e:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8006e10:	6878      	ldr	r0, [r7, #4]
 8006e12:	f000 f93d 	bl	8007090 <USB_GetMode>
 8006e16:	4603      	mov	r3, r0
 8006e18:	2b00      	cmp	r3, #0
 8006e1a:	d005      	beq.n	8006e28 <USB_SetCurrentMode+0x84>
 8006e1c:	68fb      	ldr	r3, [r7, #12]
 8006e1e:	2bc7      	cmp	r3, #199	@ 0xc7
 8006e20:	d9f0      	bls.n	8006e04 <USB_SetCurrentMode+0x60>
 8006e22:	e001      	b.n	8006e28 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8006e24:	2301      	movs	r3, #1
 8006e26:	e005      	b.n	8006e34 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 8006e28:	68fb      	ldr	r3, [r7, #12]
 8006e2a:	2bc8      	cmp	r3, #200	@ 0xc8
 8006e2c:	d101      	bne.n	8006e32 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8006e2e:	2301      	movs	r3, #1
 8006e30:	e000      	b.n	8006e34 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8006e32:	2300      	movs	r3, #0
}
 8006e34:	4618      	mov	r0, r3
 8006e36:	3710      	adds	r7, #16
 8006e38:	46bd      	mov	sp, r7
 8006e3a:	bd80      	pop	{r7, pc}

08006e3c <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8006e3c:	b480      	push	{r7}
 8006e3e:	b085      	sub	sp, #20
 8006e40:	af00      	add	r7, sp, #0
 8006e42:	6078      	str	r0, [r7, #4]
 8006e44:	6039      	str	r1, [r7, #0]
  volatile uint32_t count = 0U;
 8006e46:	2300      	movs	r3, #0
 8006e48:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006e4a:	68fb      	ldr	r3, [r7, #12]
 8006e4c:	3301      	adds	r3, #1
 8006e4e:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006e50:	68fb      	ldr	r3, [r7, #12]
 8006e52:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006e56:	d901      	bls.n	8006e5c <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8006e58:	2303      	movs	r3, #3
 8006e5a:	e01b      	b.n	8006e94 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006e5c:	687b      	ldr	r3, [r7, #4]
 8006e5e:	691b      	ldr	r3, [r3, #16]
 8006e60:	2b00      	cmp	r3, #0
 8006e62:	daf2      	bge.n	8006e4a <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8006e64:	2300      	movs	r3, #0
 8006e66:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8006e68:	683b      	ldr	r3, [r7, #0]
 8006e6a:	019b      	lsls	r3, r3, #6
 8006e6c:	f043 0220 	orr.w	r2, r3, #32
 8006e70:	687b      	ldr	r3, [r7, #4]
 8006e72:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006e74:	68fb      	ldr	r3, [r7, #12]
 8006e76:	3301      	adds	r3, #1
 8006e78:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006e7a:	68fb      	ldr	r3, [r7, #12]
 8006e7c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006e80:	d901      	bls.n	8006e86 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 8006e82:	2303      	movs	r3, #3
 8006e84:	e006      	b.n	8006e94 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	691b      	ldr	r3, [r3, #16]
 8006e8a:	f003 0320 	and.w	r3, r3, #32
 8006e8e:	2b20      	cmp	r3, #32
 8006e90:	d0f0      	beq.n	8006e74 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 8006e92:	2300      	movs	r3, #0
}
 8006e94:	4618      	mov	r0, r3
 8006e96:	3714      	adds	r7, #20
 8006e98:	46bd      	mov	sp, r7
 8006e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e9e:	4770      	bx	lr

08006ea0 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8006ea0:	b480      	push	{r7}
 8006ea2:	b085      	sub	sp, #20
 8006ea4:	af00      	add	r7, sp, #0
 8006ea6:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = 0U;
 8006ea8:	2300      	movs	r3, #0
 8006eaa:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006eac:	68fb      	ldr	r3, [r7, #12]
 8006eae:	3301      	adds	r3, #1
 8006eb0:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006eb2:	68fb      	ldr	r3, [r7, #12]
 8006eb4:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006eb8:	d901      	bls.n	8006ebe <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 8006eba:	2303      	movs	r3, #3
 8006ebc:	e018      	b.n	8006ef0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006ebe:	687b      	ldr	r3, [r7, #4]
 8006ec0:	691b      	ldr	r3, [r3, #16]
 8006ec2:	2b00      	cmp	r3, #0
 8006ec4:	daf2      	bge.n	8006eac <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8006ec6:	2300      	movs	r3, #0
 8006ec8:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8006eca:	687b      	ldr	r3, [r7, #4]
 8006ecc:	2210      	movs	r2, #16
 8006ece:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006ed0:	68fb      	ldr	r3, [r7, #12]
 8006ed2:	3301      	adds	r3, #1
 8006ed4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006ed6:	68fb      	ldr	r3, [r7, #12]
 8006ed8:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006edc:	d901      	bls.n	8006ee2 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 8006ede:	2303      	movs	r3, #3
 8006ee0:	e006      	b.n	8006ef0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8006ee2:	687b      	ldr	r3, [r7, #4]
 8006ee4:	691b      	ldr	r3, [r3, #16]
 8006ee6:	f003 0310 	and.w	r3, r3, #16
 8006eea:	2b10      	cmp	r3, #16
 8006eec:	d0f0      	beq.n	8006ed0 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 8006eee:	2300      	movs	r3, #0
}
 8006ef0:	4618      	mov	r0, r3
 8006ef2:	3714      	adds	r7, #20
 8006ef4:	46bd      	mov	sp, r7
 8006ef6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006efa:	4770      	bx	lr

08006efc <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8006efc:	b480      	push	{r7}
 8006efe:	b089      	sub	sp, #36	@ 0x24
 8006f00:	af00      	add	r7, sp, #0
 8006f02:	60f8      	str	r0, [r7, #12]
 8006f04:	60b9      	str	r1, [r7, #8]
 8006f06:	4611      	mov	r1, r2
 8006f08:	461a      	mov	r2, r3
 8006f0a:	460b      	mov	r3, r1
 8006f0c:	71fb      	strb	r3, [r7, #7]
 8006f0e:	4613      	mov	r3, r2
 8006f10:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006f12:	68fb      	ldr	r3, [r7, #12]
 8006f14:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 8006f16:	68bb      	ldr	r3, [r7, #8]
 8006f18:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8006f1a:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8006f1e:	2b00      	cmp	r3, #0
 8006f20:	d123      	bne.n	8006f6a <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8006f22:	88bb      	ldrh	r3, [r7, #4]
 8006f24:	3303      	adds	r3, #3
 8006f26:	089b      	lsrs	r3, r3, #2
 8006f28:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8006f2a:	2300      	movs	r3, #0
 8006f2c:	61bb      	str	r3, [r7, #24]
 8006f2e:	e018      	b.n	8006f62 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8006f30:	79fb      	ldrb	r3, [r7, #7]
 8006f32:	031a      	lsls	r2, r3, #12
 8006f34:	697b      	ldr	r3, [r7, #20]
 8006f36:	4413      	add	r3, r2
 8006f38:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006f3c:	461a      	mov	r2, r3
 8006f3e:	69fb      	ldr	r3, [r7, #28]
 8006f40:	681b      	ldr	r3, [r3, #0]
 8006f42:	6013      	str	r3, [r2, #0]
      pSrc++;
 8006f44:	69fb      	ldr	r3, [r7, #28]
 8006f46:	3301      	adds	r3, #1
 8006f48:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006f4a:	69fb      	ldr	r3, [r7, #28]
 8006f4c:	3301      	adds	r3, #1
 8006f4e:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006f50:	69fb      	ldr	r3, [r7, #28]
 8006f52:	3301      	adds	r3, #1
 8006f54:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006f56:	69fb      	ldr	r3, [r7, #28]
 8006f58:	3301      	adds	r3, #1
 8006f5a:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8006f5c:	69bb      	ldr	r3, [r7, #24]
 8006f5e:	3301      	adds	r3, #1
 8006f60:	61bb      	str	r3, [r7, #24]
 8006f62:	69ba      	ldr	r2, [r7, #24]
 8006f64:	693b      	ldr	r3, [r7, #16]
 8006f66:	429a      	cmp	r2, r3
 8006f68:	d3e2      	bcc.n	8006f30 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 8006f6a:	2300      	movs	r3, #0
}
 8006f6c:	4618      	mov	r0, r3
 8006f6e:	3724      	adds	r7, #36	@ 0x24
 8006f70:	46bd      	mov	sp, r7
 8006f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f76:	4770      	bx	lr

08006f78 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8006f78:	b480      	push	{r7}
 8006f7a:	b08b      	sub	sp, #44	@ 0x2c
 8006f7c:	af00      	add	r7, sp, #0
 8006f7e:	60f8      	str	r0, [r7, #12]
 8006f80:	60b9      	str	r1, [r7, #8]
 8006f82:	4613      	mov	r3, r2
 8006f84:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006f86:	68fb      	ldr	r3, [r7, #12]
 8006f88:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 8006f8a:	68bb      	ldr	r3, [r7, #8]
 8006f8c:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 8006f8e:	88fb      	ldrh	r3, [r7, #6]
 8006f90:	089b      	lsrs	r3, r3, #2
 8006f92:	b29b      	uxth	r3, r3
 8006f94:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 8006f96:	88fb      	ldrh	r3, [r7, #6]
 8006f98:	f003 0303 	and.w	r3, r3, #3
 8006f9c:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 8006f9e:	2300      	movs	r3, #0
 8006fa0:	623b      	str	r3, [r7, #32]
 8006fa2:	e014      	b.n	8006fce <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8006fa4:	69bb      	ldr	r3, [r7, #24]
 8006fa6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006faa:	681a      	ldr	r2, [r3, #0]
 8006fac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006fae:	601a      	str	r2, [r3, #0]
    pDest++;
 8006fb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006fb2:	3301      	adds	r3, #1
 8006fb4:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006fb6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006fb8:	3301      	adds	r3, #1
 8006fba:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006fbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006fbe:	3301      	adds	r3, #1
 8006fc0:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006fc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006fc4:	3301      	adds	r3, #1
 8006fc6:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 8006fc8:	6a3b      	ldr	r3, [r7, #32]
 8006fca:	3301      	adds	r3, #1
 8006fcc:	623b      	str	r3, [r7, #32]
 8006fce:	6a3a      	ldr	r2, [r7, #32]
 8006fd0:	697b      	ldr	r3, [r7, #20]
 8006fd2:	429a      	cmp	r2, r3
 8006fd4:	d3e6      	bcc.n	8006fa4 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8006fd6:	8bfb      	ldrh	r3, [r7, #30]
 8006fd8:	2b00      	cmp	r3, #0
 8006fda:	d01e      	beq.n	800701a <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8006fdc:	2300      	movs	r3, #0
 8006fde:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8006fe0:	69bb      	ldr	r3, [r7, #24]
 8006fe2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006fe6:	461a      	mov	r2, r3
 8006fe8:	f107 0310 	add.w	r3, r7, #16
 8006fec:	6812      	ldr	r2, [r2, #0]
 8006fee:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8006ff0:	693a      	ldr	r2, [r7, #16]
 8006ff2:	6a3b      	ldr	r3, [r7, #32]
 8006ff4:	b2db      	uxtb	r3, r3
 8006ff6:	00db      	lsls	r3, r3, #3
 8006ff8:	fa22 f303 	lsr.w	r3, r2, r3
 8006ffc:	b2da      	uxtb	r2, r3
 8006ffe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007000:	701a      	strb	r2, [r3, #0]
      i++;
 8007002:	6a3b      	ldr	r3, [r7, #32]
 8007004:	3301      	adds	r3, #1
 8007006:	623b      	str	r3, [r7, #32]
      pDest++;
 8007008:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800700a:	3301      	adds	r3, #1
 800700c:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 800700e:	8bfb      	ldrh	r3, [r7, #30]
 8007010:	3b01      	subs	r3, #1
 8007012:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8007014:	8bfb      	ldrh	r3, [r7, #30]
 8007016:	2b00      	cmp	r3, #0
 8007018:	d1ea      	bne.n	8006ff0 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 800701a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800701c:	4618      	mov	r0, r3
 800701e:	372c      	adds	r7, #44	@ 0x2c
 8007020:	46bd      	mov	sp, r7
 8007022:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007026:	4770      	bx	lr

08007028 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 8007028:	b480      	push	{r7}
 800702a:	b085      	sub	sp, #20
 800702c:	af00      	add	r7, sp, #0
 800702e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8007030:	687b      	ldr	r3, [r7, #4]
 8007032:	695b      	ldr	r3, [r3, #20]
 8007034:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8007036:	687b      	ldr	r3, [r7, #4]
 8007038:	699b      	ldr	r3, [r3, #24]
 800703a:	68fa      	ldr	r2, [r7, #12]
 800703c:	4013      	ands	r3, r2
 800703e:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8007040:	68fb      	ldr	r3, [r7, #12]
}
 8007042:	4618      	mov	r0, r3
 8007044:	3714      	adds	r7, #20
 8007046:	46bd      	mov	sp, r7
 8007048:	f85d 7b04 	ldr.w	r7, [sp], #4
 800704c:	4770      	bx	lr

0800704e <USB_ReadChInterrupts>:
  * @param  USBx  Selected device
  * @param  chnum Channel number
  * @retval USB Channel Interrupt status
  */
uint32_t USB_ReadChInterrupts(const USB_OTG_GlobalTypeDef *USBx, uint8_t chnum)
{
 800704e:	b480      	push	{r7}
 8007050:	b085      	sub	sp, #20
 8007052:	af00      	add	r7, sp, #0
 8007054:	6078      	str	r0, [r7, #4]
 8007056:	460b      	mov	r3, r1
 8007058:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800705a:	687b      	ldr	r3, [r7, #4]
 800705c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg = USBx_HC(chnum)->HCINT;
 800705e:	78fb      	ldrb	r3, [r7, #3]
 8007060:	015a      	lsls	r2, r3, #5
 8007062:	68fb      	ldr	r3, [r7, #12]
 8007064:	4413      	add	r3, r2
 8007066:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800706a:	689b      	ldr	r3, [r3, #8]
 800706c:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_HC(chnum)->HCINTMSK;
 800706e:	78fb      	ldrb	r3, [r7, #3]
 8007070:	015a      	lsls	r2, r3, #5
 8007072:	68fb      	ldr	r3, [r7, #12]
 8007074:	4413      	add	r3, r2
 8007076:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800707a:	68db      	ldr	r3, [r3, #12]
 800707c:	68ba      	ldr	r2, [r7, #8]
 800707e:	4013      	ands	r3, r2
 8007080:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8007082:	68bb      	ldr	r3, [r7, #8]
}
 8007084:	4618      	mov	r0, r3
 8007086:	3714      	adds	r7, #20
 8007088:	46bd      	mov	sp, r7
 800708a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800708e:	4770      	bx	lr

08007090 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 8007090:	b480      	push	{r7}
 8007092:	b083      	sub	sp, #12
 8007094:	af00      	add	r7, sp, #0
 8007096:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8007098:	687b      	ldr	r3, [r7, #4]
 800709a:	695b      	ldr	r3, [r3, #20]
 800709c:	f003 0301 	and.w	r3, r3, #1
}
 80070a0:	4618      	mov	r0, r3
 80070a2:	370c      	adds	r7, #12
 80070a4:	46bd      	mov	sp, r7
 80070a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070aa:	4770      	bx	lr

080070ac <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80070ac:	b480      	push	{r7}
 80070ae:	b085      	sub	sp, #20
 80070b0:	af00      	add	r7, sp, #0
 80070b2:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = 0U;
 80070b4:	2300      	movs	r3, #0
 80070b6:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 80070b8:	68fb      	ldr	r3, [r7, #12]
 80070ba:	3301      	adds	r3, #1
 80070bc:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80070be:	68fb      	ldr	r3, [r7, #12]
 80070c0:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80070c4:	d901      	bls.n	80070ca <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 80070c6:	2303      	movs	r3, #3
 80070c8:	e01b      	b.n	8007102 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80070ca:	687b      	ldr	r3, [r7, #4]
 80070cc:	691b      	ldr	r3, [r3, #16]
 80070ce:	2b00      	cmp	r3, #0
 80070d0:	daf2      	bge.n	80070b8 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 80070d2:	2300      	movs	r3, #0
 80070d4:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80070d6:	687b      	ldr	r3, [r7, #4]
 80070d8:	691b      	ldr	r3, [r3, #16]
 80070da:	f043 0201 	orr.w	r2, r3, #1
 80070de:	687b      	ldr	r3, [r7, #4]
 80070e0:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80070e2:	68fb      	ldr	r3, [r7, #12]
 80070e4:	3301      	adds	r3, #1
 80070e6:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80070e8:	68fb      	ldr	r3, [r7, #12]
 80070ea:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80070ee:	d901      	bls.n	80070f4 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 80070f0:	2303      	movs	r3, #3
 80070f2:	e006      	b.n	8007102 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80070f4:	687b      	ldr	r3, [r7, #4]
 80070f6:	691b      	ldr	r3, [r3, #16]
 80070f8:	f003 0301 	and.w	r3, r3, #1
 80070fc:	2b01      	cmp	r3, #1
 80070fe:	d0f0      	beq.n	80070e2 <USB_CoreReset+0x36>

  return HAL_OK;
 8007100:	2300      	movs	r3, #0
}
 8007102:	4618      	mov	r0, r3
 8007104:	3714      	adds	r7, #20
 8007106:	46bd      	mov	sp, r7
 8007108:	f85d 7b04 	ldr.w	r7, [sp], #4
 800710c:	4770      	bx	lr
	...

08007110 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8007110:	b084      	sub	sp, #16
 8007112:	b580      	push	{r7, lr}
 8007114:	b086      	sub	sp, #24
 8007116:	af00      	add	r7, sp, #0
 8007118:	6078      	str	r0, [r7, #4]
 800711a:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 800711e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8007122:	2300      	movs	r3, #0
 8007124:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007126:	687b      	ldr	r3, [r7, #4]
 8007128:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800712a:	68fb      	ldr	r3, [r7, #12]
 800712c:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8007130:	461a      	mov	r2, r3
 8007132:	2300      	movs	r3, #0
 8007134:	6013      	str	r3, [r2, #0]
#else
  /*
  * Disable HW VBUS sensing. VBUS is internally considered to be always
  * at VBUS-Valid level (5V).
  */
  USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8007136:	687b      	ldr	r3, [r7, #4]
 8007138:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800713a:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 800713e:	687b      	ldr	r3, [r7, #4]
 8007140:	639a      	str	r2, [r3, #56]	@ 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8007142:	687b      	ldr	r3, [r7, #4]
 8007144:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8007146:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 800714a:	687b      	ldr	r3, [r7, #4]
 800714c:	639a      	str	r2, [r3, #56]	@ 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 800714e:	687b      	ldr	r3, [r7, #4]
 8007150:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8007152:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 8007156:	687b      	ldr	r3, [r7, #4]
 8007158:	639a      	str	r2, [r3, #56]	@ 0x38
  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
#endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||
          defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */

  if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) == 0U)
 800715a:	687b      	ldr	r3, [r7, #4]
 800715c:	68db      	ldr	r3, [r3, #12]
 800715e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8007162:	2b00      	cmp	r3, #0
 8007164:	d119      	bne.n	800719a <USB_HostInit+0x8a>
  {
    if (cfg.speed == USBH_FSLS_SPEED)
 8007166:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800716a:	2b01      	cmp	r3, #1
 800716c:	d10a      	bne.n	8007184 <USB_HostInit+0x74>
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800716e:	68fb      	ldr	r3, [r7, #12]
 8007170:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007174:	681b      	ldr	r3, [r3, #0]
 8007176:	68fa      	ldr	r2, [r7, #12]
 8007178:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800717c:	f043 0304 	orr.w	r3, r3, #4
 8007180:	6013      	str	r3, [r2, #0]
 8007182:	e014      	b.n	80071ae <USB_HostInit+0x9e>
    }
    else
    {
      /* Set default Max speed support */
      USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8007184:	68fb      	ldr	r3, [r7, #12]
 8007186:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800718a:	681b      	ldr	r3, [r3, #0]
 800718c:	68fa      	ldr	r2, [r7, #12]
 800718e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8007192:	f023 0304 	bic.w	r3, r3, #4
 8007196:	6013      	str	r3, [r2, #0]
 8007198:	e009      	b.n	80071ae <USB_HostInit+0x9e>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800719a:	68fb      	ldr	r3, [r7, #12]
 800719c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80071a0:	681b      	ldr	r3, [r3, #0]
 80071a2:	68fa      	ldr	r2, [r7, #12]
 80071a4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80071a8:	f023 0304 	bic.w	r3, r3, #4
 80071ac:	6013      	str	r3, [r2, #0]
  }

  /* Make sure the FIFOs are flushed. */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 80071ae:	2110      	movs	r1, #16
 80071b0:	6878      	ldr	r0, [r7, #4]
 80071b2:	f7ff fe43 	bl	8006e3c <USB_FlushTxFifo>
 80071b6:	4603      	mov	r3, r0
 80071b8:	2b00      	cmp	r3, #0
 80071ba:	d001      	beq.n	80071c0 <USB_HostInit+0xb0>
  {
    ret = HAL_ERROR;
 80071bc:	2301      	movs	r3, #1
 80071be:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 80071c0:	6878      	ldr	r0, [r7, #4]
 80071c2:	f7ff fe6d 	bl	8006ea0 <USB_FlushRxFifo>
 80071c6:	4603      	mov	r3, r0
 80071c8:	2b00      	cmp	r3, #0
 80071ca:	d001      	beq.n	80071d0 <USB_HostInit+0xc0>
  {
    ret = HAL_ERROR;
 80071cc:	2301      	movs	r3, #1
 80071ce:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 80071d0:	2300      	movs	r3, #0
 80071d2:	613b      	str	r3, [r7, #16]
 80071d4:	e015      	b.n	8007202 <USB_HostInit+0xf2>
  {
    USBx_HC(i)->HCINT = CLEAR_INTERRUPT_MASK;
 80071d6:	693b      	ldr	r3, [r7, #16]
 80071d8:	015a      	lsls	r2, r3, #5
 80071da:	68fb      	ldr	r3, [r7, #12]
 80071dc:	4413      	add	r3, r2
 80071de:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80071e2:	461a      	mov	r2, r3
 80071e4:	f04f 33ff 	mov.w	r3, #4294967295
 80071e8:	6093      	str	r3, [r2, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 80071ea:	693b      	ldr	r3, [r7, #16]
 80071ec:	015a      	lsls	r2, r3, #5
 80071ee:	68fb      	ldr	r3, [r7, #12]
 80071f0:	4413      	add	r3, r2
 80071f2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80071f6:	461a      	mov	r2, r3
 80071f8:	2300      	movs	r3, #0
 80071fa:	60d3      	str	r3, [r2, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 80071fc:	693b      	ldr	r3, [r7, #16]
 80071fe:	3301      	adds	r3, #1
 8007200:	613b      	str	r3, [r7, #16]
 8007202:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8007206:	461a      	mov	r2, r3
 8007208:	693b      	ldr	r3, [r7, #16]
 800720a:	4293      	cmp	r3, r2
 800720c:	d3e3      	bcc.n	80071d6 <USB_HostInit+0xc6>
  }

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 800720e:	687b      	ldr	r3, [r7, #4]
 8007210:	2200      	movs	r2, #0
 8007212:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 8007214:	687b      	ldr	r3, [r7, #4]
 8007216:	f04f 32ff 	mov.w	r2, #4294967295
 800721a:	615a      	str	r2, [r3, #20]
#if defined (USB_OTG_HS)
  if (USBx == USB_OTG_HS)
 800721c:	687b      	ldr	r3, [r7, #4]
 800721e:	4a18      	ldr	r2, [pc, #96]	@ (8007280 <USB_HostInit+0x170>)
 8007220:	4293      	cmp	r3, r2
 8007222:	d10b      	bne.n	800723c <USB_HostInit+0x12c>
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x200U;
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800722a:	625a      	str	r2, [r3, #36]	@ 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 800722c:	687b      	ldr	r3, [r7, #4]
 800722e:	4a15      	ldr	r2, [pc, #84]	@ (8007284 <USB_HostInit+0x174>)
 8007230:	629a      	str	r2, [r3, #40]	@ 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 8007232:	687b      	ldr	r3, [r7, #4]
 8007234:	4a14      	ldr	r2, [pc, #80]	@ (8007288 <USB_HostInit+0x178>)
 8007236:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
 800723a:	e009      	b.n	8007250 <USB_HostInit+0x140>
  }
  else
#endif /* defined (USB_OTG_HS) */
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x80U;
 800723c:	687b      	ldr	r3, [r7, #4]
 800723e:	2280      	movs	r2, #128	@ 0x80
 8007240:	625a      	str	r2, [r3, #36]	@ 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 8007242:	687b      	ldr	r3, [r7, #4]
 8007244:	4a11      	ldr	r2, [pc, #68]	@ (800728c <USB_HostInit+0x17c>)
 8007246:	629a      	str	r2, [r3, #40]	@ 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 8007248:	687b      	ldr	r3, [r7, #4]
 800724a:	4a11      	ldr	r2, [pc, #68]	@ (8007290 <USB_HostInit+0x180>)
 800724c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  }

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8007250:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8007254:	2b00      	cmp	r3, #0
 8007256:	d105      	bne.n	8007264 <USB_HostInit+0x154>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8007258:	687b      	ldr	r3, [r7, #4]
 800725a:	699b      	ldr	r3, [r3, #24]
 800725c:	f043 0210 	orr.w	r2, r3, #16
 8007260:	687b      	ldr	r3, [r7, #4]
 8007262:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 8007264:	687b      	ldr	r3, [r7, #4]
 8007266:	699a      	ldr	r2, [r3, #24]
 8007268:	4b0a      	ldr	r3, [pc, #40]	@ (8007294 <USB_HostInit+0x184>)
 800726a:	4313      	orrs	r3, r2
 800726c:	687a      	ldr	r2, [r7, #4]
 800726e:	6193      	str	r3, [r2, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return ret;
 8007270:	7dfb      	ldrb	r3, [r7, #23]
}
 8007272:	4618      	mov	r0, r3
 8007274:	3718      	adds	r7, #24
 8007276:	46bd      	mov	sp, r7
 8007278:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800727c:	b004      	add	sp, #16
 800727e:	4770      	bx	lr
 8007280:	40040000 	.word	0x40040000
 8007284:	01000200 	.word	0x01000200
 8007288:	00e00300 	.word	0x00e00300
 800728c:	00600080 	.word	0x00600080
 8007290:	004000e0 	.word	0x004000e0
 8007294:	a3200008 	.word	0xa3200008

08007298 <USB_InitFSLSPClkSel>:
  *           HCFG_48_MHZ : Full Speed 48 MHz Clock
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(const USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
 8007298:	b480      	push	{r7}
 800729a:	b085      	sub	sp, #20
 800729c:	af00      	add	r7, sp, #0
 800729e:	6078      	str	r0, [r7, #4]
 80072a0:	460b      	mov	r3, r1
 80072a2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80072a4:	687b      	ldr	r3, [r7, #4]
 80072a6:	60fb      	str	r3, [r7, #12]

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 80072a8:	68fb      	ldr	r3, [r7, #12]
 80072aa:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80072ae:	681b      	ldr	r3, [r3, #0]
 80072b0:	68fa      	ldr	r2, [r7, #12]
 80072b2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80072b6:	f023 0303 	bic.w	r3, r3, #3
 80072ba:	6013      	str	r3, [r2, #0]
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 80072bc:	68fb      	ldr	r3, [r7, #12]
 80072be:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80072c2:	681a      	ldr	r2, [r3, #0]
 80072c4:	78fb      	ldrb	r3, [r7, #3]
 80072c6:	f003 0303 	and.w	r3, r3, #3
 80072ca:	68f9      	ldr	r1, [r7, #12]
 80072cc:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80072d0:	4313      	orrs	r3, r2
 80072d2:	600b      	str	r3, [r1, #0]

  if (freq == HCFG_48_MHZ)
 80072d4:	78fb      	ldrb	r3, [r7, #3]
 80072d6:	2b01      	cmp	r3, #1
 80072d8:	d107      	bne.n	80072ea <USB_InitFSLSPClkSel+0x52>
  {
    USBx_HOST->HFIR = HFIR_48_MHZ;
 80072da:	68fb      	ldr	r3, [r7, #12]
 80072dc:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80072e0:	461a      	mov	r2, r3
 80072e2:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 80072e6:	6053      	str	r3, [r2, #4]
 80072e8:	e00c      	b.n	8007304 <USB_InitFSLSPClkSel+0x6c>
  }
  else if (freq == HCFG_6_MHZ)
 80072ea:	78fb      	ldrb	r3, [r7, #3]
 80072ec:	2b02      	cmp	r3, #2
 80072ee:	d107      	bne.n	8007300 <USB_InitFSLSPClkSel+0x68>
  {
    USBx_HOST->HFIR = HFIR_6_MHZ;
 80072f0:	68fb      	ldr	r3, [r7, #12]
 80072f2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80072f6:	461a      	mov	r2, r3
 80072f8:	f241 7370 	movw	r3, #6000	@ 0x1770
 80072fc:	6053      	str	r3, [r2, #4]
 80072fe:	e001      	b.n	8007304 <USB_InitFSLSPClkSel+0x6c>
  }
  else
  {
    return HAL_ERROR;
 8007300:	2301      	movs	r3, #1
 8007302:	e000      	b.n	8007306 <USB_InitFSLSPClkSel+0x6e>
  }

  return HAL_OK;
 8007304:	2300      	movs	r3, #0
}
 8007306:	4618      	mov	r0, r3
 8007308:	3714      	adds	r7, #20
 800730a:	46bd      	mov	sp, r7
 800730c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007310:	4770      	bx	lr

08007312 <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(const USB_OTG_GlobalTypeDef *USBx)
{
 8007312:	b580      	push	{r7, lr}
 8007314:	b084      	sub	sp, #16
 8007316:	af00      	add	r7, sp, #0
 8007318:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800731a:	687b      	ldr	r3, [r7, #4]
 800731c:	60fb      	str	r3, [r7, #12]

  volatile uint32_t hprt0 = 0U;
 800731e:	2300      	movs	r3, #0
 8007320:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 8007322:	68fb      	ldr	r3, [r7, #12]
 8007324:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8007328:	681b      	ldr	r3, [r3, #0]
 800732a:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800732c:	68bb      	ldr	r3, [r7, #8]
 800732e:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8007332:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 8007334:	68bb      	ldr	r3, [r7, #8]
 8007336:	68fa      	ldr	r2, [r7, #12]
 8007338:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 800733c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8007340:	6013      	str	r3, [r2, #0]
  HAL_Delay(100U);                                 /* See Note #1 */
 8007342:	2064      	movs	r0, #100	@ 0x64
 8007344:	f7fa fc4e 	bl	8001be4 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8007348:	68bb      	ldr	r3, [r7, #8]
 800734a:	68fa      	ldr	r2, [r7, #12]
 800734c:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 8007350:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8007354:	6013      	str	r3, [r2, #0]
  HAL_Delay(10U);
 8007356:	200a      	movs	r0, #10
 8007358:	f7fa fc44 	bl	8001be4 <HAL_Delay>

  return HAL_OK;
 800735c:	2300      	movs	r3, #0
}
 800735e:	4618      	mov	r0, r3
 8007360:	3710      	adds	r7, #16
 8007362:	46bd      	mov	sp, r7
 8007364:	bd80      	pop	{r7, pc}

08007366 <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(const USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 8007366:	b480      	push	{r7}
 8007368:	b085      	sub	sp, #20
 800736a:	af00      	add	r7, sp, #0
 800736c:	6078      	str	r0, [r7, #4]
 800736e:	460b      	mov	r3, r1
 8007370:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007372:	687b      	ldr	r3, [r7, #4]
 8007374:	60fb      	str	r3, [r7, #12]
  volatile uint32_t hprt0 = 0U;
 8007376:	2300      	movs	r3, #0
 8007378:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 800737a:	68fb      	ldr	r3, [r7, #12]
 800737c:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8007380:	681b      	ldr	r3, [r3, #0]
 8007382:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8007384:	68bb      	ldr	r3, [r7, #8]
 8007386:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 800738a:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800738c:	68bb      	ldr	r3, [r7, #8]
 800738e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8007392:	2b00      	cmp	r3, #0
 8007394:	d109      	bne.n	80073aa <USB_DriveVbus+0x44>
 8007396:	78fb      	ldrb	r3, [r7, #3]
 8007398:	2b01      	cmp	r3, #1
 800739a:	d106      	bne.n	80073aa <USB_DriveVbus+0x44>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800739c:	68bb      	ldr	r3, [r7, #8]
 800739e:	68fa      	ldr	r2, [r7, #12]
 80073a0:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 80073a4:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80073a8:	6013      	str	r3, [r2, #0]
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 80073aa:	68bb      	ldr	r3, [r7, #8]
 80073ac:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80073b0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80073b4:	d109      	bne.n	80073ca <USB_DriveVbus+0x64>
 80073b6:	78fb      	ldrb	r3, [r7, #3]
 80073b8:	2b00      	cmp	r3, #0
 80073ba:	d106      	bne.n	80073ca <USB_DriveVbus+0x64>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 80073bc:	68bb      	ldr	r3, [r7, #8]
 80073be:	68fa      	ldr	r2, [r7, #12]
 80073c0:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 80073c4:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80073c8:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 80073ca:	2300      	movs	r3, #0
}
 80073cc:	4618      	mov	r0, r3
 80073ce:	3714      	adds	r7, #20
 80073d0:	46bd      	mov	sp, r7
 80073d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80073d6:	4770      	bx	lr

080073d8 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef const *USBx)
{
 80073d8:	b480      	push	{r7}
 80073da:	b085      	sub	sp, #20
 80073dc:	af00      	add	r7, sp, #0
 80073de:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80073e0:	687b      	ldr	r3, [r7, #4]
 80073e2:	60fb      	str	r3, [r7, #12]
  volatile uint32_t hprt0 = 0U;
 80073e4:	2300      	movs	r3, #0
 80073e6:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 80073e8:	68fb      	ldr	r3, [r7, #12]
 80073ea:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 80073ee:	681b      	ldr	r3, [r3, #0]
 80073f0:	60bb      	str	r3, [r7, #8]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 80073f2:	68bb      	ldr	r3, [r7, #8]
 80073f4:	0c5b      	lsrs	r3, r3, #17
 80073f6:	f003 0303 	and.w	r3, r3, #3
}
 80073fa:	4618      	mov	r0, r3
 80073fc:	3714      	adds	r7, #20
 80073fe:	46bd      	mov	sp, r7
 8007400:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007404:	4770      	bx	lr

08007406 <USB_GetCurrentFrame>:
  * @brief  Return Host Current Frame number
  * @param  USBx  Selected device
  * @retval current frame number
  */
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef const *USBx)
{
 8007406:	b480      	push	{r7}
 8007408:	b085      	sub	sp, #20
 800740a:	af00      	add	r7, sp, #0
 800740c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800740e:	687b      	ldr	r3, [r7, #4]
 8007410:	60fb      	str	r3, [r7, #12]

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 8007412:	68fb      	ldr	r3, [r7, #12]
 8007414:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007418:	689b      	ldr	r3, [r3, #8]
 800741a:	b29b      	uxth	r3, r3
}
 800741c:	4618      	mov	r0, r3
 800741e:	3714      	adds	r7, #20
 8007420:	46bd      	mov	sp, r7
 8007422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007426:	4770      	bx	lr

08007428 <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 8007428:	b580      	push	{r7, lr}
 800742a:	b088      	sub	sp, #32
 800742c:	af00      	add	r7, sp, #0
 800742e:	6078      	str	r0, [r7, #4]
 8007430:	4608      	mov	r0, r1
 8007432:	4611      	mov	r1, r2
 8007434:	461a      	mov	r2, r3
 8007436:	4603      	mov	r3, r0
 8007438:	70fb      	strb	r3, [r7, #3]
 800743a:	460b      	mov	r3, r1
 800743c:	70bb      	strb	r3, [r7, #2]
 800743e:	4613      	mov	r3, r2
 8007440:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef ret = HAL_OK;
 8007442:	2300      	movs	r3, #0
 8007444:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007446:	687b      	ldr	r3, [r7, #4]
 8007448:	613b      	str	r3, [r7, #16]
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800744a:	78fb      	ldrb	r3, [r7, #3]
 800744c:	015a      	lsls	r2, r3, #5
 800744e:	693b      	ldr	r3, [r7, #16]
 8007450:	4413      	add	r3, r2
 8007452:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007456:	461a      	mov	r2, r3
 8007458:	f04f 33ff 	mov.w	r3, #4294967295
 800745c:	6093      	str	r3, [r2, #8]

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 800745e:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8007462:	2b03      	cmp	r3, #3
 8007464:	d87c      	bhi.n	8007560 <USB_HC_Init+0x138>
 8007466:	a201      	add	r2, pc, #4	@ (adr r2, 800746c <USB_HC_Init+0x44>)
 8007468:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800746c:	0800747d 	.word	0x0800747d
 8007470:	08007523 	.word	0x08007523
 8007474:	0800747d 	.word	0x0800747d
 8007478:	080074e5 	.word	0x080074e5
  {
    case EP_TYPE_CTRL:
    case EP_TYPE_BULK:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800747c:	78fb      	ldrb	r3, [r7, #3]
 800747e:	015a      	lsls	r2, r3, #5
 8007480:	693b      	ldr	r3, [r7, #16]
 8007482:	4413      	add	r3, r2
 8007484:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007488:	461a      	mov	r2, r3
 800748a:	f240 439d 	movw	r3, #1181	@ 0x49d
 800748e:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 8007490:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8007494:	2b00      	cmp	r3, #0
 8007496:	da10      	bge.n	80074ba <USB_HC_Init+0x92>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8007498:	78fb      	ldrb	r3, [r7, #3]
 800749a:	015a      	lsls	r2, r3, #5
 800749c:	693b      	ldr	r3, [r7, #16]
 800749e:	4413      	add	r3, r2
 80074a0:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80074a4:	68db      	ldr	r3, [r3, #12]
 80074a6:	78fa      	ldrb	r2, [r7, #3]
 80074a8:	0151      	lsls	r1, r2, #5
 80074aa:	693a      	ldr	r2, [r7, #16]
 80074ac:	440a      	add	r2, r1
 80074ae:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80074b2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80074b6:	60d3      	str	r3, [r2, #12]
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
                                                 USB_OTG_HCINTMSK_ACKM;
        }
#endif /* defined (USB_OTG_HS) */
      }
      break;
 80074b8:	e055      	b.n	8007566 <USB_HC_Init+0x13e>
        if (USBx == USB_OTG_HS)
 80074ba:	687b      	ldr	r3, [r7, #4]
 80074bc:	4a6f      	ldr	r2, [pc, #444]	@ (800767c <USB_HC_Init+0x254>)
 80074be:	4293      	cmp	r3, r2
 80074c0:	d151      	bne.n	8007566 <USB_HC_Init+0x13e>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 80074c2:	78fb      	ldrb	r3, [r7, #3]
 80074c4:	015a      	lsls	r2, r3, #5
 80074c6:	693b      	ldr	r3, [r7, #16]
 80074c8:	4413      	add	r3, r2
 80074ca:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80074ce:	68db      	ldr	r3, [r3, #12]
 80074d0:	78fa      	ldrb	r2, [r7, #3]
 80074d2:	0151      	lsls	r1, r2, #5
 80074d4:	693a      	ldr	r2, [r7, #16]
 80074d6:	440a      	add	r2, r1
 80074d8:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80074dc:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 80074e0:	60d3      	str	r3, [r2, #12]
      break;
 80074e2:	e040      	b.n	8007566 <USB_HC_Init+0x13e>

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80074e4:	78fb      	ldrb	r3, [r7, #3]
 80074e6:	015a      	lsls	r2, r3, #5
 80074e8:	693b      	ldr	r3, [r7, #16]
 80074ea:	4413      	add	r3, r2
 80074ec:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80074f0:	461a      	mov	r2, r3
 80074f2:	f240 639d 	movw	r3, #1693	@ 0x69d
 80074f6:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 80074f8:	f997 3002 	ldrsb.w	r3, [r7, #2]
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	da34      	bge.n	800756a <USB_HC_Init+0x142>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8007500:	78fb      	ldrb	r3, [r7, #3]
 8007502:	015a      	lsls	r2, r3, #5
 8007504:	693b      	ldr	r3, [r7, #16]
 8007506:	4413      	add	r3, r2
 8007508:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800750c:	68db      	ldr	r3, [r3, #12]
 800750e:	78fa      	ldrb	r2, [r7, #3]
 8007510:	0151      	lsls	r1, r2, #5
 8007512:	693a      	ldr	r2, [r7, #16]
 8007514:	440a      	add	r2, r1
 8007516:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800751a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800751e:	60d3      	str	r3, [r2, #12]
      }

      break;
 8007520:	e023      	b.n	800756a <USB_HC_Init+0x142>

    case EP_TYPE_ISOC:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007522:	78fb      	ldrb	r3, [r7, #3]
 8007524:	015a      	lsls	r2, r3, #5
 8007526:	693b      	ldr	r3, [r7, #16]
 8007528:	4413      	add	r3, r2
 800752a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800752e:	461a      	mov	r2, r3
 8007530:	f240 2325 	movw	r3, #549	@ 0x225
 8007534:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_ACKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 8007536:	f997 3002 	ldrsb.w	r3, [r7, #2]
 800753a:	2b00      	cmp	r3, #0
 800753c:	da17      	bge.n	800756e <USB_HC_Init+0x146>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 800753e:	78fb      	ldrb	r3, [r7, #3]
 8007540:	015a      	lsls	r2, r3, #5
 8007542:	693b      	ldr	r3, [r7, #16]
 8007544:	4413      	add	r3, r2
 8007546:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800754a:	68db      	ldr	r3, [r3, #12]
 800754c:	78fa      	ldrb	r2, [r7, #3]
 800754e:	0151      	lsls	r1, r2, #5
 8007550:	693a      	ldr	r2, [r7, #16]
 8007552:	440a      	add	r2, r1
 8007554:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007558:	f443 73c0 	orr.w	r3, r3, #384	@ 0x180
 800755c:	60d3      	str	r3, [r2, #12]
      }
      break;
 800755e:	e006      	b.n	800756e <USB_HC_Init+0x146>

    default:
      ret = HAL_ERROR;
 8007560:	2301      	movs	r3, #1
 8007562:	77fb      	strb	r3, [r7, #31]
      break;
 8007564:	e004      	b.n	8007570 <USB_HC_Init+0x148>
      break;
 8007566:	bf00      	nop
 8007568:	e002      	b.n	8007570 <USB_HC_Init+0x148>
      break;
 800756a:	bf00      	nop
 800756c:	e000      	b.n	8007570 <USB_HC_Init+0x148>
      break;
 800756e:	bf00      	nop
  }

  /* Clear Hub Start Split transaction */
  USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 8007570:	78fb      	ldrb	r3, [r7, #3]
 8007572:	015a      	lsls	r2, r3, #5
 8007574:	693b      	ldr	r3, [r7, #16]
 8007576:	4413      	add	r3, r2
 8007578:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800757c:	461a      	mov	r2, r3
 800757e:	2300      	movs	r3, #0
 8007580:	6053      	str	r3, [r2, #4]

  /* Enable host channel Halt interrupt */
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8007582:	78fb      	ldrb	r3, [r7, #3]
 8007584:	015a      	lsls	r2, r3, #5
 8007586:	693b      	ldr	r3, [r7, #16]
 8007588:	4413      	add	r3, r2
 800758a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800758e:	68db      	ldr	r3, [r3, #12]
 8007590:	78fa      	ldrb	r2, [r7, #3]
 8007592:	0151      	lsls	r1, r2, #5
 8007594:	693a      	ldr	r2, [r7, #16]
 8007596:	440a      	add	r2, r1
 8007598:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800759c:	f043 0302 	orr.w	r3, r3, #2
 80075a0:	60d3      	str	r3, [r2, #12]

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 80075a2:	693b      	ldr	r3, [r7, #16]
 80075a4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80075a8:	699a      	ldr	r2, [r3, #24]
 80075aa:	78fb      	ldrb	r3, [r7, #3]
 80075ac:	f003 030f 	and.w	r3, r3, #15
 80075b0:	2101      	movs	r1, #1
 80075b2:	fa01 f303 	lsl.w	r3, r1, r3
 80075b6:	6939      	ldr	r1, [r7, #16]
 80075b8:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80075bc:	4313      	orrs	r3, r2
 80075be:	618b      	str	r3, [r1, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 80075c0:	687b      	ldr	r3, [r7, #4]
 80075c2:	699b      	ldr	r3, [r3, #24]
 80075c4:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 80075c8:	687b      	ldr	r3, [r7, #4]
 80075ca:	619a      	str	r2, [r3, #24]

  /* Program the HCCHAR register */
  if ((epnum & 0x80U) == 0x80U)
 80075cc:	f997 3002 	ldrsb.w	r3, [r7, #2]
 80075d0:	2b00      	cmp	r3, #0
 80075d2:	da03      	bge.n	80075dc <USB_HC_Init+0x1b4>
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 80075d4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80075d8:	61bb      	str	r3, [r7, #24]
 80075da:	e001      	b.n	80075e0 <USB_HC_Init+0x1b8>
  }
  else
  {
    HCcharEpDir = 0U;
 80075dc:	2300      	movs	r3, #0
 80075de:	61bb      	str	r3, [r7, #24]
  }

  HostCoreSpeed = USB_GetHostSpeed(USBx);
 80075e0:	6878      	ldr	r0, [r7, #4]
 80075e2:	f7ff fef9 	bl	80073d8 <USB_GetHostSpeed>
 80075e6:	60f8      	str	r0, [r7, #12]

  /* LS device plugged to HUB */
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 80075e8:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80075ec:	2b02      	cmp	r3, #2
 80075ee:	d106      	bne.n	80075fe <USB_HC_Init+0x1d6>
 80075f0:	68fb      	ldr	r3, [r7, #12]
 80075f2:	2b02      	cmp	r3, #2
 80075f4:	d003      	beq.n	80075fe <USB_HC_Init+0x1d6>
  {
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 80075f6:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 80075fa:	617b      	str	r3, [r7, #20]
 80075fc:	e001      	b.n	8007602 <USB_HC_Init+0x1da>
  }
  else
  {
    HCcharLowSpeed = 0U;
 80075fe:	2300      	movs	r3, #0
 8007600:	617b      	str	r3, [r7, #20]
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007602:	787b      	ldrb	r3, [r7, #1]
 8007604:	059b      	lsls	r3, r3, #22
 8007606:	f003 52fe 	and.w	r2, r3, #532676608	@ 0x1fc00000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800760a:	78bb      	ldrb	r3, [r7, #2]
 800760c:	02db      	lsls	r3, r3, #11
 800760e:	f403 43f0 	and.w	r3, r3, #30720	@ 0x7800
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007612:	431a      	orrs	r2, r3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007614:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8007618:	049b      	lsls	r3, r3, #18
 800761a:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800761e:	431a      	orrs	r2, r3
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) |
 8007620:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
 8007622:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007626:	431a      	orrs	r2, r3
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 8007628:	69bb      	ldr	r3, [r7, #24]
 800762a:	431a      	orrs	r2, r3
 800762c:	697b      	ldr	r3, [r7, #20]
 800762e:	4313      	orrs	r3, r2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007630:	78fa      	ldrb	r2, [r7, #3]
 8007632:	0151      	lsls	r1, r2, #5
 8007634:	693a      	ldr	r2, [r7, #16]
 8007636:	440a      	add	r2, r1
 8007638:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800763c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007640:	6013      	str	r3, [r2, #0]

  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8007642:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8007646:	2b03      	cmp	r3, #3
 8007648:	d003      	beq.n	8007652 <USB_HC_Init+0x22a>
 800764a:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 800764e:	2b01      	cmp	r3, #1
 8007650:	d10f      	bne.n	8007672 <USB_HC_Init+0x24a>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8007652:	78fb      	ldrb	r3, [r7, #3]
 8007654:	015a      	lsls	r2, r3, #5
 8007656:	693b      	ldr	r3, [r7, #16]
 8007658:	4413      	add	r3, r2
 800765a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800765e:	681b      	ldr	r3, [r3, #0]
 8007660:	78fa      	ldrb	r2, [r7, #3]
 8007662:	0151      	lsls	r1, r2, #5
 8007664:	693a      	ldr	r2, [r7, #16]
 8007666:	440a      	add	r2, r1
 8007668:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800766c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8007670:	6013      	str	r3, [r2, #0]
  }

  return ret;
 8007672:	7ffb      	ldrb	r3, [r7, #31]
}
 8007674:	4618      	mov	r0, r3
 8007676:	3720      	adds	r7, #32
 8007678:	46bd      	mov	sp, r7
 800767a:	bd80      	pop	{r7, pc}
 800767c:	40040000 	.word	0x40040000

08007680 <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 8007680:	b580      	push	{r7, lr}
 8007682:	b08c      	sub	sp, #48	@ 0x30
 8007684:	af02      	add	r7, sp, #8
 8007686:	60f8      	str	r0, [r7, #12]
 8007688:	60b9      	str	r1, [r7, #8]
 800768a:	4613      	mov	r3, r2
 800768c:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800768e:	68fb      	ldr	r3, [r7, #12]
 8007690:	623b      	str	r3, [r7, #32]
  uint32_t ch_num = (uint32_t)hc->ch_num;
 8007692:	68bb      	ldr	r3, [r7, #8]
 8007694:	785b      	ldrb	r3, [r3, #1]
 8007696:	61fb      	str	r3, [r7, #28]
  volatile uint32_t tmpreg;
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = HC_MAX_PKT_CNT;
 8007698:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800769c:	837b      	strh	r3, [r7, #26]

#if defined (USB_OTG_HS)
  if (USBx == USB_OTG_HS)
 800769e:	68fb      	ldr	r3, [r7, #12]
 80076a0:	4a5d      	ldr	r2, [pc, #372]	@ (8007818 <USB_HC_StartXfer+0x198>)
 80076a2:	4293      	cmp	r3, r2
 80076a4:	d12f      	bne.n	8007706 <USB_HC_StartXfer+0x86>
  {
    /* in DMA mode host Core automatically issues ping in case of NYET/NAK */
    if (dma == 1U)
 80076a6:	79fb      	ldrb	r3, [r7, #7]
 80076a8:	2b01      	cmp	r3, #1
 80076aa:	d11c      	bne.n	80076e6 <USB_HC_StartXfer+0x66>
    {
      if (((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)) && (hc->do_ssplit == 0U))
 80076ac:	68bb      	ldr	r3, [r7, #8]
 80076ae:	7c9b      	ldrb	r3, [r3, #18]
 80076b0:	2b00      	cmp	r3, #0
 80076b2:	d003      	beq.n	80076bc <USB_HC_StartXfer+0x3c>
 80076b4:	68bb      	ldr	r3, [r7, #8]
 80076b6:	7c9b      	ldrb	r3, [r3, #18]
 80076b8:	2b02      	cmp	r3, #2
 80076ba:	d124      	bne.n	8007706 <USB_HC_StartXfer+0x86>
 80076bc:	68bb      	ldr	r3, [r7, #8]
 80076be:	799b      	ldrb	r3, [r3, #6]
 80076c0:	2b00      	cmp	r3, #0
 80076c2:	d120      	bne.n	8007706 <USB_HC_StartXfer+0x86>
      {

        USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 80076c4:	69fb      	ldr	r3, [r7, #28]
 80076c6:	015a      	lsls	r2, r3, #5
 80076c8:	6a3b      	ldr	r3, [r7, #32]
 80076ca:	4413      	add	r3, r2
 80076cc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80076d0:	68db      	ldr	r3, [r3, #12]
 80076d2:	69fa      	ldr	r2, [r7, #28]
 80076d4:	0151      	lsls	r1, r2, #5
 80076d6:	6a3a      	ldr	r2, [r7, #32]
 80076d8:	440a      	add	r2, r1
 80076da:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80076de:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80076e2:	60d3      	str	r3, [r2, #12]
 80076e4:	e00f      	b.n	8007706 <USB_HC_StartXfer+0x86>
                                                 USB_OTG_HCINTMSK_NAKM);
      }
    }
    else
    {
      if ((hc->speed == USBH_HS_SPEED) && (hc->do_ping == 1U))
 80076e6:	68bb      	ldr	r3, [r7, #8]
 80076e8:	791b      	ldrb	r3, [r3, #4]
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d10b      	bne.n	8007706 <USB_HC_StartXfer+0x86>
 80076ee:	68bb      	ldr	r3, [r7, #8]
 80076f0:	795b      	ldrb	r3, [r3, #5]
 80076f2:	2b01      	cmp	r3, #1
 80076f4:	d107      	bne.n	8007706 <USB_HC_StartXfer+0x86>
      {
        (void)USB_DoPing(USBx, hc->ch_num);
 80076f6:	68bb      	ldr	r3, [r7, #8]
 80076f8:	785b      	ldrb	r3, [r3, #1]
 80076fa:	4619      	mov	r1, r3
 80076fc:	68f8      	ldr	r0, [r7, #12]
 80076fe:	f000 fb6b 	bl	8007dd8 <USB_DoPing>
        return HAL_OK;
 8007702:	2300      	movs	r3, #0
 8007704:	e232      	b.n	8007b6c <USB_HC_StartXfer+0x4ec>
      }
    }
  }
#endif /* defined (USB_OTG_HS) */

  if (hc->do_ssplit == 1U)
 8007706:	68bb      	ldr	r3, [r7, #8]
 8007708:	799b      	ldrb	r3, [r3, #6]
 800770a:	2b01      	cmp	r3, #1
 800770c:	d158      	bne.n	80077c0 <USB_HC_StartXfer+0x140>
  {
    /* Set number of packet to 1 for Split transaction */
    num_packets = 1U;
 800770e:	2301      	movs	r3, #1
 8007710:	84fb      	strh	r3, [r7, #38]	@ 0x26

    if (hc->ep_is_in != 0U)
 8007712:	68bb      	ldr	r3, [r7, #8]
 8007714:	78db      	ldrb	r3, [r3, #3]
 8007716:	2b00      	cmp	r3, #0
 8007718:	d007      	beq.n	800772a <USB_HC_StartXfer+0xaa>
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800771a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800771c:	68ba      	ldr	r2, [r7, #8]
 800771e:	8a92      	ldrh	r2, [r2, #20]
 8007720:	fb03 f202 	mul.w	r2, r3, r2
 8007724:	68bb      	ldr	r3, [r7, #8]
 8007726:	61da      	str	r2, [r3, #28]
 8007728:	e07c      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
    }
    else
    {
      if (hc->ep_type == EP_TYPE_ISOC)
 800772a:	68bb      	ldr	r3, [r7, #8]
 800772c:	7c9b      	ldrb	r3, [r3, #18]
 800772e:	2b01      	cmp	r3, #1
 8007730:	d130      	bne.n	8007794 <USB_HC_StartXfer+0x114>
      {
        if (hc->xfer_len > ISO_SPLT_MPS)
 8007732:	68bb      	ldr	r3, [r7, #8]
 8007734:	6a1b      	ldr	r3, [r3, #32]
 8007736:	2bbc      	cmp	r3, #188	@ 0xbc
 8007738:	d918      	bls.n	800776c <USB_HC_StartXfer+0xec>
        {
          /* Isochrone Max Packet Size for Split mode */
          hc->XferSize = hc->max_packet;
 800773a:	68bb      	ldr	r3, [r7, #8]
 800773c:	8a9b      	ldrh	r3, [r3, #20]
 800773e:	461a      	mov	r2, r3
 8007740:	68bb      	ldr	r3, [r7, #8]
 8007742:	61da      	str	r2, [r3, #28]
          hc->xfer_len = hc->XferSize;
 8007744:	68bb      	ldr	r3, [r7, #8]
 8007746:	69da      	ldr	r2, [r3, #28]
 8007748:	68bb      	ldr	r3, [r7, #8]
 800774a:	621a      	str	r2, [r3, #32]

          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 800774c:	68bb      	ldr	r3, [r7, #8]
 800774e:	68db      	ldr	r3, [r3, #12]
 8007750:	2b01      	cmp	r3, #1
 8007752:	d003      	beq.n	800775c <USB_HC_StartXfer+0xdc>
 8007754:	68bb      	ldr	r3, [r7, #8]
 8007756:	68db      	ldr	r3, [r3, #12]
 8007758:	2b02      	cmp	r3, #2
 800775a:	d103      	bne.n	8007764 <USB_HC_StartXfer+0xe4>
          {
            hc->iso_splt_xactPos = HCSPLT_MIDDLE;
 800775c:	68bb      	ldr	r3, [r7, #8]
 800775e:	2202      	movs	r2, #2
 8007760:	60da      	str	r2, [r3, #12]
 8007762:	e05f      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
          }
          else
          {
            hc->iso_splt_xactPos = HCSPLT_BEGIN;
 8007764:	68bb      	ldr	r3, [r7, #8]
 8007766:	2201      	movs	r2, #1
 8007768:	60da      	str	r2, [r3, #12]
 800776a:	e05b      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
          }
        }
        else
        {
          hc->XferSize = hc->xfer_len;
 800776c:	68bb      	ldr	r3, [r7, #8]
 800776e:	6a1a      	ldr	r2, [r3, #32]
 8007770:	68bb      	ldr	r3, [r7, #8]
 8007772:	61da      	str	r2, [r3, #28]

          if ((hc->iso_splt_xactPos != HCSPLT_BEGIN) && (hc->iso_splt_xactPos != HCSPLT_MIDDLE))
 8007774:	68bb      	ldr	r3, [r7, #8]
 8007776:	68db      	ldr	r3, [r3, #12]
 8007778:	2b01      	cmp	r3, #1
 800777a:	d007      	beq.n	800778c <USB_HC_StartXfer+0x10c>
 800777c:	68bb      	ldr	r3, [r7, #8]
 800777e:	68db      	ldr	r3, [r3, #12]
 8007780:	2b02      	cmp	r3, #2
 8007782:	d003      	beq.n	800778c <USB_HC_StartXfer+0x10c>
          {
            hc->iso_splt_xactPos = HCSPLT_FULL;
 8007784:	68bb      	ldr	r3, [r7, #8]
 8007786:	2204      	movs	r2, #4
 8007788:	60da      	str	r2, [r3, #12]
 800778a:	e04b      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
          }
          else
          {
            hc->iso_splt_xactPos = HCSPLT_END;
 800778c:	68bb      	ldr	r3, [r7, #8]
 800778e:	2203      	movs	r2, #3
 8007790:	60da      	str	r2, [r3, #12]
 8007792:	e047      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
          }
        }
      }
      else
      {
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 8007794:	79fb      	ldrb	r3, [r7, #7]
 8007796:	2b01      	cmp	r3, #1
 8007798:	d10d      	bne.n	80077b6 <USB_HC_StartXfer+0x136>
 800779a:	68bb      	ldr	r3, [r7, #8]
 800779c:	6a1b      	ldr	r3, [r3, #32]
 800779e:	68ba      	ldr	r2, [r7, #8]
 80077a0:	8a92      	ldrh	r2, [r2, #20]
 80077a2:	4293      	cmp	r3, r2
 80077a4:	d907      	bls.n	80077b6 <USB_HC_StartXfer+0x136>
        {
          hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80077a6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80077a8:	68ba      	ldr	r2, [r7, #8]
 80077aa:	8a92      	ldrh	r2, [r2, #20]
 80077ac:	fb03 f202 	mul.w	r2, r3, r2
 80077b0:	68bb      	ldr	r3, [r7, #8]
 80077b2:	61da      	str	r2, [r3, #28]
 80077b4:	e036      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
        }
        else
        {
          hc->XferSize = hc->xfer_len;
 80077b6:	68bb      	ldr	r3, [r7, #8]
 80077b8:	6a1a      	ldr	r2, [r3, #32]
 80077ba:	68bb      	ldr	r3, [r7, #8]
 80077bc:	61da      	str	r2, [r3, #28]
 80077be:	e031      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
    }
  }
  else
  {
    /* Compute the expected number of packets associated to the transfer */
    if (hc->xfer_len > 0U)
 80077c0:	68bb      	ldr	r3, [r7, #8]
 80077c2:	6a1b      	ldr	r3, [r3, #32]
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	d018      	beq.n	80077fa <USB_HC_StartXfer+0x17a>
    {
      num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 80077c8:	68bb      	ldr	r3, [r7, #8]
 80077ca:	6a1b      	ldr	r3, [r3, #32]
 80077cc:	68ba      	ldr	r2, [r7, #8]
 80077ce:	8a92      	ldrh	r2, [r2, #20]
 80077d0:	4413      	add	r3, r2
 80077d2:	3b01      	subs	r3, #1
 80077d4:	68ba      	ldr	r2, [r7, #8]
 80077d6:	8a92      	ldrh	r2, [r2, #20]
 80077d8:	fbb3 f3f2 	udiv	r3, r3, r2
 80077dc:	84fb      	strh	r3, [r7, #38]	@ 0x26

      if (num_packets > max_hc_pkt_count)
 80077de:	8cfa      	ldrh	r2, [r7, #38]	@ 0x26
 80077e0:	8b7b      	ldrh	r3, [r7, #26]
 80077e2:	429a      	cmp	r2, r3
 80077e4:	d90b      	bls.n	80077fe <USB_HC_StartXfer+0x17e>
      {
        num_packets = max_hc_pkt_count;
 80077e6:	8b7b      	ldrh	r3, [r7, #26]
 80077e8:	84fb      	strh	r3, [r7, #38]	@ 0x26
        hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80077ea:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80077ec:	68ba      	ldr	r2, [r7, #8]
 80077ee:	8a92      	ldrh	r2, [r2, #20]
 80077f0:	fb03 f202 	mul.w	r2, r3, r2
 80077f4:	68bb      	ldr	r3, [r7, #8]
 80077f6:	61da      	str	r2, [r3, #28]
 80077f8:	e001      	b.n	80077fe <USB_HC_StartXfer+0x17e>
      }
    }
    else
    {
      num_packets = 1U;
 80077fa:	2301      	movs	r3, #1
 80077fc:	84fb      	strh	r3, [r7, #38]	@ 0x26

    /*
    * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
    * max_packet size.
    */
    if (hc->ep_is_in != 0U)
 80077fe:	68bb      	ldr	r3, [r7, #8]
 8007800:	78db      	ldrb	r3, [r3, #3]
 8007802:	2b00      	cmp	r3, #0
 8007804:	d00a      	beq.n	800781c <USB_HC_StartXfer+0x19c>
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 8007806:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8007808:	68ba      	ldr	r2, [r7, #8]
 800780a:	8a92      	ldrh	r2, [r2, #20]
 800780c:	fb03 f202 	mul.w	r2, r3, r2
 8007810:	68bb      	ldr	r3, [r7, #8]
 8007812:	61da      	str	r2, [r3, #28]
 8007814:	e006      	b.n	8007824 <USB_HC_StartXfer+0x1a4>
 8007816:	bf00      	nop
 8007818:	40040000 	.word	0x40040000
    }
    else
    {
      hc->XferSize = hc->xfer_len;
 800781c:	68bb      	ldr	r3, [r7, #8]
 800781e:	6a1a      	ldr	r2, [r3, #32]
 8007820:	68bb      	ldr	r3, [r7, #8]
 8007822:	61da      	str	r2, [r3, #28]
    }
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007824:	68bb      	ldr	r3, [r7, #8]
 8007826:	69db      	ldr	r3, [r3, #28]
 8007828:	f3c3 0212 	ubfx	r2, r3, #0, #19
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800782c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800782e:	04d9      	lsls	r1, r3, #19
 8007830:	4ba3      	ldr	r3, [pc, #652]	@ (8007ac0 <USB_HC_StartXfer+0x440>)
 8007832:	400b      	ands	r3, r1
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007834:	431a      	orrs	r2, r3
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 8007836:	68bb      	ldr	r3, [r7, #8]
 8007838:	7d9b      	ldrb	r3, [r3, #22]
 800783a:	075b      	lsls	r3, r3, #29
 800783c:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007840:	69f9      	ldr	r1, [r7, #28]
 8007842:	0148      	lsls	r0, r1, #5
 8007844:	6a39      	ldr	r1, [r7, #32]
 8007846:	4401      	add	r1, r0
 8007848:	f501 61a0 	add.w	r1, r1, #1280	@ 0x500
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800784c:	4313      	orrs	r3, r2
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 800784e:	610b      	str	r3, [r1, #16]

  if (dma != 0U)
 8007850:	79fb      	ldrb	r3, [r7, #7]
 8007852:	2b00      	cmp	r3, #0
 8007854:	d009      	beq.n	800786a <USB_HC_StartXfer+0x1ea>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 8007856:	68bb      	ldr	r3, [r7, #8]
 8007858:	6999      	ldr	r1, [r3, #24]
 800785a:	69fb      	ldr	r3, [r7, #28]
 800785c:	015a      	lsls	r2, r3, #5
 800785e:	6a3b      	ldr	r3, [r7, #32]
 8007860:	4413      	add	r3, r2
 8007862:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007866:	460a      	mov	r2, r1
 8007868:	615a      	str	r2, [r3, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800786a:	6a3b      	ldr	r3, [r7, #32]
 800786c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007870:	689b      	ldr	r3, [r3, #8]
 8007872:	f003 0301 	and.w	r3, r3, #1
 8007876:	2b00      	cmp	r3, #0
 8007878:	bf0c      	ite	eq
 800787a:	2301      	moveq	r3, #1
 800787c:	2300      	movne	r3, #0
 800787e:	b2db      	uxtb	r3, r3
 8007880:	767b      	strb	r3, [r7, #25]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8007882:	69fb      	ldr	r3, [r7, #28]
 8007884:	015a      	lsls	r2, r3, #5
 8007886:	6a3b      	ldr	r3, [r7, #32]
 8007888:	4413      	add	r3, r2
 800788a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800788e:	681b      	ldr	r3, [r3, #0]
 8007890:	69fa      	ldr	r2, [r7, #28]
 8007892:	0151      	lsls	r1, r2, #5
 8007894:	6a3a      	ldr	r2, [r7, #32]
 8007896:	440a      	add	r2, r1
 8007898:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800789c:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 80078a0:	6013      	str	r3, [r2, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80078a2:	69fb      	ldr	r3, [r7, #28]
 80078a4:	015a      	lsls	r2, r3, #5
 80078a6:	6a3b      	ldr	r3, [r7, #32]
 80078a8:	4413      	add	r3, r2
 80078aa:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80078ae:	681a      	ldr	r2, [r3, #0]
 80078b0:	7e7b      	ldrb	r3, [r7, #25]
 80078b2:	075b      	lsls	r3, r3, #29
 80078b4:	69f9      	ldr	r1, [r7, #28]
 80078b6:	0148      	lsls	r0, r1, #5
 80078b8:	6a39      	ldr	r1, [r7, #32]
 80078ba:	4401      	add	r1, r0
 80078bc:	f501 61a0 	add.w	r1, r1, #1280	@ 0x500
 80078c0:	4313      	orrs	r3, r2
 80078c2:	600b      	str	r3, [r1, #0]

  if (hc->do_ssplit == 1U)
 80078c4:	68bb      	ldr	r3, [r7, #8]
 80078c6:	799b      	ldrb	r3, [r3, #6]
 80078c8:	2b01      	cmp	r3, #1
 80078ca:	f040 80c3 	bne.w	8007a54 <USB_HC_StartXfer+0x3d4>
  {
    /* Set Hub start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 80078ce:	68bb      	ldr	r3, [r7, #8]
 80078d0:	7c5b      	ldrb	r3, [r3, #17]
 80078d2:	01db      	lsls	r3, r3, #7
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 80078d4:	68ba      	ldr	r2, [r7, #8]
 80078d6:	7c12      	ldrb	r2, [r2, #16]
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 80078d8:	4313      	orrs	r3, r2
 80078da:	69fa      	ldr	r2, [r7, #28]
 80078dc:	0151      	lsls	r1, r2, #5
 80078de:	6a3a      	ldr	r2, [r7, #32]
 80078e0:	440a      	add	r2, r1
 80078e2:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 80078e6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 80078ea:	6053      	str	r3, [r2, #4]

    /* unmask ack & nyet for IN/OUT transactions */
    USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_ACKM |
 80078ec:	69fb      	ldr	r3, [r7, #28]
 80078ee:	015a      	lsls	r2, r3, #5
 80078f0:	6a3b      	ldr	r3, [r7, #32]
 80078f2:	4413      	add	r3, r2
 80078f4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80078f8:	68db      	ldr	r3, [r3, #12]
 80078fa:	69fa      	ldr	r2, [r7, #28]
 80078fc:	0151      	lsls	r1, r2, #5
 80078fe:	6a3a      	ldr	r2, [r7, #32]
 8007900:	440a      	add	r2, r1
 8007902:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007906:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800790a:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_NYET);

    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 800790c:	68bb      	ldr	r3, [r7, #8]
 800790e:	79db      	ldrb	r3, [r3, #7]
 8007910:	2b01      	cmp	r3, #1
 8007912:	d123      	bne.n	800795c <USB_HC_StartXfer+0x2dc>
 8007914:	68bb      	ldr	r3, [r7, #8]
 8007916:	78db      	ldrb	r3, [r3, #3]
 8007918:	2b00      	cmp	r3, #0
 800791a:	d11f      	bne.n	800795c <USB_HC_StartXfer+0x2dc>
    {
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 800791c:	69fb      	ldr	r3, [r7, #28]
 800791e:	015a      	lsls	r2, r3, #5
 8007920:	6a3b      	ldr	r3, [r7, #32]
 8007922:	4413      	add	r3, r2
 8007924:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007928:	685b      	ldr	r3, [r3, #4]
 800792a:	69fa      	ldr	r2, [r7, #28]
 800792c:	0151      	lsls	r1, r2, #5
 800792e:	6a3a      	ldr	r2, [r7, #32]
 8007930:	440a      	add	r2, r1
 8007932:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007936:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800793a:	6053      	str	r3, [r2, #4]
      USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 800793c:	69fb      	ldr	r3, [r7, #28]
 800793e:	015a      	lsls	r2, r3, #5
 8007940:	6a3b      	ldr	r3, [r7, #32]
 8007942:	4413      	add	r3, r2
 8007944:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007948:	68db      	ldr	r3, [r3, #12]
 800794a:	69fa      	ldr	r2, [r7, #28]
 800794c:	0151      	lsls	r1, r2, #5
 800794e:	6a3a      	ldr	r2, [r7, #32]
 8007950:	440a      	add	r2, r1
 8007952:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007956:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800795a:	60d3      	str	r3, [r2, #12]
    }

    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 800795c:	68bb      	ldr	r3, [r7, #8]
 800795e:	7c9b      	ldrb	r3, [r3, #18]
 8007960:	2b01      	cmp	r3, #1
 8007962:	d003      	beq.n	800796c <USB_HC_StartXfer+0x2ec>
 8007964:	68bb      	ldr	r3, [r7, #8]
 8007966:	7c9b      	ldrb	r3, [r3, #18]
 8007968:	2b03      	cmp	r3, #3
 800796a:	d117      	bne.n	800799c <USB_HC_StartXfer+0x31c>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 800796c:	68bb      	ldr	r3, [r7, #8]
 800796e:	79db      	ldrb	r3, [r3, #7]
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 8007970:	2b01      	cmp	r3, #1
 8007972:	d113      	bne.n	800799c <USB_HC_StartXfer+0x31c>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 8007974:	68bb      	ldr	r3, [r7, #8]
 8007976:	78db      	ldrb	r3, [r3, #3]
 8007978:	2b01      	cmp	r3, #1
 800797a:	d10f      	bne.n	800799c <USB_HC_StartXfer+0x31c>
    {
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 800797c:	69fb      	ldr	r3, [r7, #28]
 800797e:	015a      	lsls	r2, r3, #5
 8007980:	6a3b      	ldr	r3, [r7, #32]
 8007982:	4413      	add	r3, r2
 8007984:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007988:	685b      	ldr	r3, [r3, #4]
 800798a:	69fa      	ldr	r2, [r7, #28]
 800798c:	0151      	lsls	r1, r2, #5
 800798e:	6a3a      	ldr	r2, [r7, #32]
 8007990:	440a      	add	r2, r1
 8007992:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007996:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800799a:	6053      	str	r3, [r2, #4]
    }

    /* Position management for iso out transaction on split mode */
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 800799c:	68bb      	ldr	r3, [r7, #8]
 800799e:	7c9b      	ldrb	r3, [r3, #18]
 80079a0:	2b01      	cmp	r3, #1
 80079a2:	d162      	bne.n	8007a6a <USB_HC_StartXfer+0x3ea>
 80079a4:	68bb      	ldr	r3, [r7, #8]
 80079a6:	78db      	ldrb	r3, [r3, #3]
 80079a8:	2b00      	cmp	r3, #0
 80079aa:	d15e      	bne.n	8007a6a <USB_HC_StartXfer+0x3ea>
    {
      /* Set data payload position */
      switch (hc->iso_splt_xactPos)
 80079ac:	68bb      	ldr	r3, [r7, #8]
 80079ae:	68db      	ldr	r3, [r3, #12]
 80079b0:	3b01      	subs	r3, #1
 80079b2:	2b03      	cmp	r3, #3
 80079b4:	d858      	bhi.n	8007a68 <USB_HC_StartXfer+0x3e8>
 80079b6:	a201      	add	r2, pc, #4	@ (adr r2, 80079bc <USB_HC_StartXfer+0x33c>)
 80079b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80079bc:	080079cd 	.word	0x080079cd
 80079c0:	080079ef 	.word	0x080079ef
 80079c4:	08007a11 	.word	0x08007a11
 80079c8:	08007a33 	.word	0x08007a33
      {
        case HCSPLT_BEGIN:
          /* First data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_1;
 80079cc:	69fb      	ldr	r3, [r7, #28]
 80079ce:	015a      	lsls	r2, r3, #5
 80079d0:	6a3b      	ldr	r3, [r7, #32]
 80079d2:	4413      	add	r3, r2
 80079d4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80079d8:	685b      	ldr	r3, [r3, #4]
 80079da:	69fa      	ldr	r2, [r7, #28]
 80079dc:	0151      	lsls	r1, r2, #5
 80079de:	6a3a      	ldr	r2, [r7, #32]
 80079e0:	440a      	add	r2, r1
 80079e2:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80079e6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80079ea:	6053      	str	r3, [r2, #4]
          break;
 80079ec:	e03d      	b.n	8007a6a <USB_HC_StartXfer+0x3ea>

        case HCSPLT_MIDDLE:
          /* Middle data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_Pos;
 80079ee:	69fb      	ldr	r3, [r7, #28]
 80079f0:	015a      	lsls	r2, r3, #5
 80079f2:	6a3b      	ldr	r3, [r7, #32]
 80079f4:	4413      	add	r3, r2
 80079f6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80079fa:	685b      	ldr	r3, [r3, #4]
 80079fc:	69fa      	ldr	r2, [r7, #28]
 80079fe:	0151      	lsls	r1, r2, #5
 8007a00:	6a3a      	ldr	r2, [r7, #32]
 8007a02:	440a      	add	r2, r1
 8007a04:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007a08:	f043 030e 	orr.w	r3, r3, #14
 8007a0c:	6053      	str	r3, [r2, #4]
          break;
 8007a0e:	e02c      	b.n	8007a6a <USB_HC_StartXfer+0x3ea>

        case HCSPLT_END:
          /* End data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_0;
 8007a10:	69fb      	ldr	r3, [r7, #28]
 8007a12:	015a      	lsls	r2, r3, #5
 8007a14:	6a3b      	ldr	r3, [r7, #32]
 8007a16:	4413      	add	r3, r2
 8007a18:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a1c:	685b      	ldr	r3, [r3, #4]
 8007a1e:	69fa      	ldr	r2, [r7, #28]
 8007a20:	0151      	lsls	r1, r2, #5
 8007a22:	6a3a      	ldr	r2, [r7, #32]
 8007a24:	440a      	add	r2, r1
 8007a26:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007a2a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8007a2e:	6053      	str	r3, [r2, #4]
          break;
 8007a30:	e01b      	b.n	8007a6a <USB_HC_StartXfer+0x3ea>

        case HCSPLT_FULL:
          /* Entire data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS;
 8007a32:	69fb      	ldr	r3, [r7, #28]
 8007a34:	015a      	lsls	r2, r3, #5
 8007a36:	6a3b      	ldr	r3, [r7, #32]
 8007a38:	4413      	add	r3, r2
 8007a3a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a3e:	685b      	ldr	r3, [r3, #4]
 8007a40:	69fa      	ldr	r2, [r7, #28]
 8007a42:	0151      	lsls	r1, r2, #5
 8007a44:	6a3a      	ldr	r2, [r7, #32]
 8007a46:	440a      	add	r2, r1
 8007a48:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007a4c:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 8007a50:	6053      	str	r3, [r2, #4]
          break;
 8007a52:	e00a      	b.n	8007a6a <USB_HC_StartXfer+0x3ea>
    }
  }
  else
  {
    /* Clear Hub Start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 8007a54:	69fb      	ldr	r3, [r7, #28]
 8007a56:	015a      	lsls	r2, r3, #5
 8007a58:	6a3b      	ldr	r3, [r7, #32]
 8007a5a:	4413      	add	r3, r2
 8007a5c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a60:	461a      	mov	r2, r3
 8007a62:	2300      	movs	r3, #0
 8007a64:	6053      	str	r3, [r2, #4]
 8007a66:	e000      	b.n	8007a6a <USB_HC_StartXfer+0x3ea>
          break;
 8007a68:	bf00      	nop
  }

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 8007a6a:	69fb      	ldr	r3, [r7, #28]
 8007a6c:	015a      	lsls	r2, r3, #5
 8007a6e:	6a3b      	ldr	r3, [r7, #32]
 8007a70:	4413      	add	r3, r2
 8007a72:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a76:	681b      	ldr	r3, [r3, #0]
 8007a78:	613b      	str	r3, [r7, #16]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8007a7a:	693b      	ldr	r3, [r7, #16]
 8007a7c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8007a80:	613b      	str	r3, [r7, #16]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 8007a82:	68bb      	ldr	r3, [r7, #8]
 8007a84:	78db      	ldrb	r3, [r3, #3]
 8007a86:	2b00      	cmp	r3, #0
 8007a88:	d004      	beq.n	8007a94 <USB_HC_StartXfer+0x414>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 8007a8a:	693b      	ldr	r3, [r7, #16]
 8007a8c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8007a90:	613b      	str	r3, [r7, #16]
 8007a92:	e003      	b.n	8007a9c <USB_HC_StartXfer+0x41c>
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 8007a94:	693b      	ldr	r3, [r7, #16]
 8007a96:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007a9a:	613b      	str	r3, [r7, #16]
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007a9c:	693b      	ldr	r3, [r7, #16]
 8007a9e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007aa2:	613b      	str	r3, [r7, #16]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 8007aa4:	69fb      	ldr	r3, [r7, #28]
 8007aa6:	015a      	lsls	r2, r3, #5
 8007aa8:	6a3b      	ldr	r3, [r7, #32]
 8007aaa:	4413      	add	r3, r2
 8007aac:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007ab0:	461a      	mov	r2, r3
 8007ab2:	693b      	ldr	r3, [r7, #16]
 8007ab4:	6013      	str	r3, [r2, #0]

  if (dma != 0U) /* dma mode */
 8007ab6:	79fb      	ldrb	r3, [r7, #7]
 8007ab8:	2b00      	cmp	r3, #0
 8007aba:	d003      	beq.n	8007ac4 <USB_HC_StartXfer+0x444>
  {
    return HAL_OK;
 8007abc:	2300      	movs	r3, #0
 8007abe:	e055      	b.n	8007b6c <USB_HC_StartXfer+0x4ec>
 8007ac0:	1ff80000 	.word	0x1ff80000
  }

  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U) && (hc->do_csplit == 0U))
 8007ac4:	68bb      	ldr	r3, [r7, #8]
 8007ac6:	78db      	ldrb	r3, [r3, #3]
 8007ac8:	2b00      	cmp	r3, #0
 8007aca:	d14e      	bne.n	8007b6a <USB_HC_StartXfer+0x4ea>
 8007acc:	68bb      	ldr	r3, [r7, #8]
 8007ace:	6a1b      	ldr	r3, [r3, #32]
 8007ad0:	2b00      	cmp	r3, #0
 8007ad2:	d04a      	beq.n	8007b6a <USB_HC_StartXfer+0x4ea>
 8007ad4:	68bb      	ldr	r3, [r7, #8]
 8007ad6:	79db      	ldrb	r3, [r3, #7]
 8007ad8:	2b00      	cmp	r3, #0
 8007ada:	d146      	bne.n	8007b6a <USB_HC_StartXfer+0x4ea>
  {
    switch (hc->ep_type)
 8007adc:	68bb      	ldr	r3, [r7, #8]
 8007ade:	7c9b      	ldrb	r3, [r3, #18]
 8007ae0:	2b03      	cmp	r3, #3
 8007ae2:	d831      	bhi.n	8007b48 <USB_HC_StartXfer+0x4c8>
 8007ae4:	a201      	add	r2, pc, #4	@ (adr r2, 8007aec <USB_HC_StartXfer+0x46c>)
 8007ae6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007aea:	bf00      	nop
 8007aec:	08007afd 	.word	0x08007afd
 8007af0:	08007b21 	.word	0x08007b21
 8007af4:	08007afd 	.word	0x08007afd
 8007af8:	08007b21 	.word	0x08007b21
    {
      /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:

        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007afc:	68bb      	ldr	r3, [r7, #8]
 8007afe:	6a1b      	ldr	r3, [r3, #32]
 8007b00:	3303      	adds	r3, #3
 8007b02:	089b      	lsrs	r3, r3, #2
 8007b04:	82fb      	strh	r3, [r7, #22]

        /* check if there is enough space in FIFO space */
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8007b06:	8afa      	ldrh	r2, [r7, #22]
 8007b08:	68fb      	ldr	r3, [r7, #12]
 8007b0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007b0c:	b29b      	uxth	r3, r3
 8007b0e:	429a      	cmp	r2, r3
 8007b10:	d91c      	bls.n	8007b4c <USB_HC_StartXfer+0x4cc>
        {
          /* need to process data in nptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8007b12:	68fb      	ldr	r3, [r7, #12]
 8007b14:	699b      	ldr	r3, [r3, #24]
 8007b16:	f043 0220 	orr.w	r2, r3, #32
 8007b1a:	68fb      	ldr	r3, [r7, #12]
 8007b1c:	619a      	str	r2, [r3, #24]
        }
        break;
 8007b1e:	e015      	b.n	8007b4c <USB_HC_StartXfer+0x4cc>

      /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007b20:	68bb      	ldr	r3, [r7, #8]
 8007b22:	6a1b      	ldr	r3, [r3, #32]
 8007b24:	3303      	adds	r3, #3
 8007b26:	089b      	lsrs	r3, r3, #2
 8007b28:	82fb      	strh	r3, [r7, #22]
        /* check if there is enough space in FIFO space */
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8007b2a:	8afa      	ldrh	r2, [r7, #22]
 8007b2c:	6a3b      	ldr	r3, [r7, #32]
 8007b2e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007b32:	691b      	ldr	r3, [r3, #16]
 8007b34:	b29b      	uxth	r3, r3
 8007b36:	429a      	cmp	r2, r3
 8007b38:	d90a      	bls.n	8007b50 <USB_HC_StartXfer+0x4d0>
        {
          /* need to process data in ptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 8007b3a:	68fb      	ldr	r3, [r7, #12]
 8007b3c:	699b      	ldr	r3, [r3, #24]
 8007b3e:	f043 6280 	orr.w	r2, r3, #67108864	@ 0x4000000
 8007b42:	68fb      	ldr	r3, [r7, #12]
 8007b44:	619a      	str	r2, [r3, #24]
        }
        break;
 8007b46:	e003      	b.n	8007b50 <USB_HC_StartXfer+0x4d0>

      default:
        break;
 8007b48:	bf00      	nop
 8007b4a:	e002      	b.n	8007b52 <USB_HC_StartXfer+0x4d2>
        break;
 8007b4c:	bf00      	nop
 8007b4e:	e000      	b.n	8007b52 <USB_HC_StartXfer+0x4d2>
        break;
 8007b50:	bf00      	nop
    }

    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 8007b52:	68bb      	ldr	r3, [r7, #8]
 8007b54:	6999      	ldr	r1, [r3, #24]
 8007b56:	68bb      	ldr	r3, [r7, #8]
 8007b58:	785a      	ldrb	r2, [r3, #1]
 8007b5a:	68bb      	ldr	r3, [r7, #8]
 8007b5c:	6a1b      	ldr	r3, [r3, #32]
 8007b5e:	b29b      	uxth	r3, r3
 8007b60:	2000      	movs	r0, #0
 8007b62:	9000      	str	r0, [sp, #0]
 8007b64:	68f8      	ldr	r0, [r7, #12]
 8007b66:	f7ff f9c9 	bl	8006efc <USB_WritePacket>
  }

  return HAL_OK;
 8007b6a:	2300      	movs	r3, #0
}
 8007b6c:	4618      	mov	r0, r3
 8007b6e:	3728      	adds	r7, #40	@ 0x28
 8007b70:	46bd      	mov	sp, r7
 8007b72:	bd80      	pop	{r7, pc}

08007b74 <USB_HC_ReadInterrupt>:
  * @brief Read all host channel interrupts status
  * @param  USBx  Selected device
  * @retval HAL state
  */
uint32_t USB_HC_ReadInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 8007b74:	b480      	push	{r7}
 8007b76:	b085      	sub	sp, #20
 8007b78:	af00      	add	r7, sp, #0
 8007b7a:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007b7c:	687b      	ldr	r3, [r7, #4]
 8007b7e:	60fb      	str	r3, [r7, #12]

  return ((USBx_HOST->HAINT) & 0xFFFFU);
 8007b80:	68fb      	ldr	r3, [r7, #12]
 8007b82:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007b86:	695b      	ldr	r3, [r3, #20]
 8007b88:	b29b      	uxth	r3, r3
}
 8007b8a:	4618      	mov	r0, r3
 8007b8c:	3714      	adds	r7, #20
 8007b8e:	46bd      	mov	sp, r7
 8007b90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b94:	4770      	bx	lr

08007b96 <USB_HC_Halt>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Halt(const USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
{
 8007b96:	b480      	push	{r7}
 8007b98:	b089      	sub	sp, #36	@ 0x24
 8007b9a:	af00      	add	r7, sp, #0
 8007b9c:	6078      	str	r0, [r7, #4]
 8007b9e:	460b      	mov	r3, r1
 8007ba0:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007ba2:	687b      	ldr	r3, [r7, #4]
 8007ba4:	61fb      	str	r3, [r7, #28]
  uint32_t hcnum = (uint32_t)hc_num;
 8007ba6:	78fb      	ldrb	r3, [r7, #3]
 8007ba8:	61bb      	str	r3, [r7, #24]
  volatile uint32_t count = 0U;
 8007baa:	2300      	movs	r3, #0
 8007bac:	60bb      	str	r3, [r7, #8]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8007bae:	69bb      	ldr	r3, [r7, #24]
 8007bb0:	015a      	lsls	r2, r3, #5
 8007bb2:	69fb      	ldr	r3, [r7, #28]
 8007bb4:	4413      	add	r3, r2
 8007bb6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007bba:	681b      	ldr	r3, [r3, #0]
 8007bbc:	0c9b      	lsrs	r3, r3, #18
 8007bbe:	f003 0303 	and.w	r3, r3, #3
 8007bc2:	617b      	str	r3, [r7, #20]
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 8007bc4:	69bb      	ldr	r3, [r7, #24]
 8007bc6:	015a      	lsls	r2, r3, #5
 8007bc8:	69fb      	ldr	r3, [r7, #28]
 8007bca:	4413      	add	r3, r2
 8007bcc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007bd0:	681b      	ldr	r3, [r3, #0]
 8007bd2:	0fdb      	lsrs	r3, r3, #31
 8007bd4:	f003 0301 	and.w	r3, r3, #1
 8007bd8:	613b      	str	r3, [r7, #16]
  uint32_t SplitEna = (USBx_HC(hcnum)->HCSPLT & USB_OTG_HCSPLT_SPLITEN) >> 31;
 8007bda:	69bb      	ldr	r3, [r7, #24]
 8007bdc:	015a      	lsls	r2, r3, #5
 8007bde:	69fb      	ldr	r3, [r7, #28]
 8007be0:	4413      	add	r3, r2
 8007be2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007be6:	685b      	ldr	r3, [r3, #4]
 8007be8:	0fdb      	lsrs	r3, r3, #31
 8007bea:	f003 0301 	and.w	r3, r3, #1
 8007bee:	60fb      	str	r3, [r7, #12]

  /* In buffer DMA, Channel disable must not be programmed for non-split periodic channels.
     At the end of the next uframe/frame (in the worst case), the core generates a channel halted
     and disables the channel automatically. */

  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 8007bf0:	687b      	ldr	r3, [r7, #4]
 8007bf2:	689b      	ldr	r3, [r3, #8]
 8007bf4:	f003 0320 	and.w	r3, r3, #32
 8007bf8:	2b20      	cmp	r3, #32
 8007bfa:	d10d      	bne.n	8007c18 <USB_HC_Halt+0x82>
 8007bfc:	68fb      	ldr	r3, [r7, #12]
 8007bfe:	2b00      	cmp	r3, #0
 8007c00:	d10a      	bne.n	8007c18 <USB_HC_Halt+0x82>
 8007c02:	693b      	ldr	r3, [r7, #16]
 8007c04:	2b00      	cmp	r3, #0
 8007c06:	d005      	beq.n	8007c14 <USB_HC_Halt+0x7e>
      ((ChannelEna == 0U) || (((HcEpType == HCCHAR_ISOC) || (HcEpType == HCCHAR_INTR)))))
 8007c08:	697b      	ldr	r3, [r7, #20]
 8007c0a:	2b01      	cmp	r3, #1
 8007c0c:	d002      	beq.n	8007c14 <USB_HC_Halt+0x7e>
 8007c0e:	697b      	ldr	r3, [r7, #20]
 8007c10:	2b03      	cmp	r3, #3
 8007c12:	d101      	bne.n	8007c18 <USB_HC_Halt+0x82>
  {
    return HAL_OK;
 8007c14:	2300      	movs	r3, #0
 8007c16:	e0d8      	b.n	8007dca <USB_HC_Halt+0x234>
  }

  /* Check for space in the request queue to issue the halt. */
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8007c18:	697b      	ldr	r3, [r7, #20]
 8007c1a:	2b00      	cmp	r3, #0
 8007c1c:	d002      	beq.n	8007c24 <USB_HC_Halt+0x8e>
 8007c1e:	697b      	ldr	r3, [r7, #20]
 8007c20:	2b02      	cmp	r3, #2
 8007c22:	d173      	bne.n	8007d0c <USB_HC_Halt+0x176>
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8007c24:	69bb      	ldr	r3, [r7, #24]
 8007c26:	015a      	lsls	r2, r3, #5
 8007c28:	69fb      	ldr	r3, [r7, #28]
 8007c2a:	4413      	add	r3, r2
 8007c2c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007c30:	681b      	ldr	r3, [r3, #0]
 8007c32:	69ba      	ldr	r2, [r7, #24]
 8007c34:	0151      	lsls	r1, r2, #5
 8007c36:	69fa      	ldr	r2, [r7, #28]
 8007c38:	440a      	add	r2, r1
 8007c3a:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007c3e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007c42:	6013      	str	r3, [r2, #0]

    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007c44:	687b      	ldr	r3, [r7, #4]
 8007c46:	689b      	ldr	r3, [r3, #8]
 8007c48:	f003 0320 	and.w	r3, r3, #32
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	d14a      	bne.n	8007ce6 <USB_HC_Halt+0x150>
    {
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8007c50:	687b      	ldr	r3, [r7, #4]
 8007c52:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007c54:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8007c58:	2b00      	cmp	r3, #0
 8007c5a:	d133      	bne.n	8007cc4 <USB_HC_Halt+0x12e>
      {
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007c5c:	69bb      	ldr	r3, [r7, #24]
 8007c5e:	015a      	lsls	r2, r3, #5
 8007c60:	69fb      	ldr	r3, [r7, #28]
 8007c62:	4413      	add	r3, r2
 8007c64:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007c68:	681b      	ldr	r3, [r3, #0]
 8007c6a:	69ba      	ldr	r2, [r7, #24]
 8007c6c:	0151      	lsls	r1, r2, #5
 8007c6e:	69fa      	ldr	r2, [r7, #28]
 8007c70:	440a      	add	r2, r1
 8007c72:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007c76:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007c7a:	6013      	str	r3, [r2, #0]
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007c7c:	69bb      	ldr	r3, [r7, #24]
 8007c7e:	015a      	lsls	r2, r3, #5
 8007c80:	69fb      	ldr	r3, [r7, #28]
 8007c82:	4413      	add	r3, r2
 8007c84:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007c88:	681b      	ldr	r3, [r3, #0]
 8007c8a:	69ba      	ldr	r2, [r7, #24]
 8007c8c:	0151      	lsls	r1, r2, #5
 8007c8e:	69fa      	ldr	r2, [r7, #28]
 8007c90:	440a      	add	r2, r1
 8007c92:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007c96:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007c9a:	6013      	str	r3, [r2, #0]
        do
        {
          count++;
 8007c9c:	68bb      	ldr	r3, [r7, #8]
 8007c9e:	3301      	adds	r3, #1
 8007ca0:	60bb      	str	r3, [r7, #8]

          if (count > 1000U)
 8007ca2:	68bb      	ldr	r3, [r7, #8]
 8007ca4:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007ca8:	d82e      	bhi.n	8007d08 <USB_HC_Halt+0x172>
          {
            break;
          }
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007caa:	69bb      	ldr	r3, [r7, #24]
 8007cac:	015a      	lsls	r2, r3, #5
 8007cae:	69fb      	ldr	r3, [r7, #28]
 8007cb0:	4413      	add	r3, r2
 8007cb2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007cb6:	681b      	ldr	r3, [r3, #0]
 8007cb8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007cbc:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007cc0:	d0ec      	beq.n	8007c9c <USB_HC_Halt+0x106>
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007cc2:	e081      	b.n	8007dc8 <USB_HC_Halt+0x232>
      }
      else
      {
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007cc4:	69bb      	ldr	r3, [r7, #24]
 8007cc6:	015a      	lsls	r2, r3, #5
 8007cc8:	69fb      	ldr	r3, [r7, #28]
 8007cca:	4413      	add	r3, r2
 8007ccc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007cd0:	681b      	ldr	r3, [r3, #0]
 8007cd2:	69ba      	ldr	r2, [r7, #24]
 8007cd4:	0151      	lsls	r1, r2, #5
 8007cd6:	69fa      	ldr	r2, [r7, #28]
 8007cd8:	440a      	add	r2, r1
 8007cda:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007cde:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007ce2:	6013      	str	r3, [r2, #0]
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007ce4:	e070      	b.n	8007dc8 <USB_HC_Halt+0x232>
      }
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007ce6:	69bb      	ldr	r3, [r7, #24]
 8007ce8:	015a      	lsls	r2, r3, #5
 8007cea:	69fb      	ldr	r3, [r7, #28]
 8007cec:	4413      	add	r3, r2
 8007cee:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007cf2:	681b      	ldr	r3, [r3, #0]
 8007cf4:	69ba      	ldr	r2, [r7, #24]
 8007cf6:	0151      	lsls	r1, r2, #5
 8007cf8:	69fa      	ldr	r2, [r7, #28]
 8007cfa:	440a      	add	r2, r1
 8007cfc:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007d00:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007d04:	6013      	str	r3, [r2, #0]
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007d06:	e05f      	b.n	8007dc8 <USB_HC_Halt+0x232>
            break;
 8007d08:	bf00      	nop
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007d0a:	e05d      	b.n	8007dc8 <USB_HC_Halt+0x232>
    }
  }
  else
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8007d0c:	69bb      	ldr	r3, [r7, #24]
 8007d0e:	015a      	lsls	r2, r3, #5
 8007d10:	69fb      	ldr	r3, [r7, #28]
 8007d12:	4413      	add	r3, r2
 8007d14:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d18:	681b      	ldr	r3, [r3, #0]
 8007d1a:	69ba      	ldr	r2, [r7, #24]
 8007d1c:	0151      	lsls	r1, r2, #5
 8007d1e:	69fa      	ldr	r2, [r7, #28]
 8007d20:	440a      	add	r2, r1
 8007d22:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007d26:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007d2a:	6013      	str	r3, [r2, #0]

    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8007d2c:	69fb      	ldr	r3, [r7, #28]
 8007d2e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007d32:	691b      	ldr	r3, [r3, #16]
 8007d34:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8007d38:	2b00      	cmp	r3, #0
 8007d3a:	d133      	bne.n	8007da4 <USB_HC_Halt+0x20e>
    {
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007d3c:	69bb      	ldr	r3, [r7, #24]
 8007d3e:	015a      	lsls	r2, r3, #5
 8007d40:	69fb      	ldr	r3, [r7, #28]
 8007d42:	4413      	add	r3, r2
 8007d44:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d48:	681b      	ldr	r3, [r3, #0]
 8007d4a:	69ba      	ldr	r2, [r7, #24]
 8007d4c:	0151      	lsls	r1, r2, #5
 8007d4e:	69fa      	ldr	r2, [r7, #28]
 8007d50:	440a      	add	r2, r1
 8007d52:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007d56:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007d5a:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007d5c:	69bb      	ldr	r3, [r7, #24]
 8007d5e:	015a      	lsls	r2, r3, #5
 8007d60:	69fb      	ldr	r3, [r7, #28]
 8007d62:	4413      	add	r3, r2
 8007d64:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d68:	681b      	ldr	r3, [r3, #0]
 8007d6a:	69ba      	ldr	r2, [r7, #24]
 8007d6c:	0151      	lsls	r1, r2, #5
 8007d6e:	69fa      	ldr	r2, [r7, #28]
 8007d70:	440a      	add	r2, r1
 8007d72:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007d76:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007d7a:	6013      	str	r3, [r2, #0]
      do
      {
        count++;
 8007d7c:	68bb      	ldr	r3, [r7, #8]
 8007d7e:	3301      	adds	r3, #1
 8007d80:	60bb      	str	r3, [r7, #8]

        if (count > 1000U)
 8007d82:	68bb      	ldr	r3, [r7, #8]
 8007d84:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007d88:	d81d      	bhi.n	8007dc6 <USB_HC_Halt+0x230>
        {
          break;
        }
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007d8a:	69bb      	ldr	r3, [r7, #24]
 8007d8c:	015a      	lsls	r2, r3, #5
 8007d8e:	69fb      	ldr	r3, [r7, #28]
 8007d90:	4413      	add	r3, r2
 8007d92:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d96:	681b      	ldr	r3, [r3, #0]
 8007d98:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007d9c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007da0:	d0ec      	beq.n	8007d7c <USB_HC_Halt+0x1e6>
 8007da2:	e011      	b.n	8007dc8 <USB_HC_Halt+0x232>
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007da4:	69bb      	ldr	r3, [r7, #24]
 8007da6:	015a      	lsls	r2, r3, #5
 8007da8:	69fb      	ldr	r3, [r7, #28]
 8007daa:	4413      	add	r3, r2
 8007dac:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007db0:	681b      	ldr	r3, [r3, #0]
 8007db2:	69ba      	ldr	r2, [r7, #24]
 8007db4:	0151      	lsls	r1, r2, #5
 8007db6:	69fa      	ldr	r2, [r7, #28]
 8007db8:	440a      	add	r2, r1
 8007dba:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007dbe:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007dc2:	6013      	str	r3, [r2, #0]
 8007dc4:	e000      	b.n	8007dc8 <USB_HC_Halt+0x232>
          break;
 8007dc6:	bf00      	nop
    }
  }

  return HAL_OK;
 8007dc8:	2300      	movs	r3, #0
}
 8007dca:	4618      	mov	r0, r3
 8007dcc:	3724      	adds	r7, #36	@ 0x24
 8007dce:	46bd      	mov	sp, r7
 8007dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007dd4:	4770      	bx	lr
	...

08007dd8 <USB_DoPing>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_DoPing(const USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
{
 8007dd8:	b480      	push	{r7}
 8007dda:	b087      	sub	sp, #28
 8007ddc:	af00      	add	r7, sp, #0
 8007dde:	6078      	str	r0, [r7, #4]
 8007de0:	460b      	mov	r3, r1
 8007de2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007de4:	687b      	ldr	r3, [r7, #4]
 8007de6:	617b      	str	r3, [r7, #20]
  uint32_t chnum = (uint32_t)ch_num;
 8007de8:	78fb      	ldrb	r3, [r7, #3]
 8007dea:	613b      	str	r3, [r7, #16]
  uint32_t num_packets = 1U;
 8007dec:	2301      	movs	r3, #1
 8007dee:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007df0:	68fb      	ldr	r3, [r7, #12]
 8007df2:	04da      	lsls	r2, r3, #19
 8007df4:	4b15      	ldr	r3, [pc, #84]	@ (8007e4c <USB_DoPing+0x74>)
 8007df6:	4013      	ands	r3, r2
 8007df8:	693a      	ldr	r2, [r7, #16]
 8007dfa:	0151      	lsls	r1, r2, #5
 8007dfc:	697a      	ldr	r2, [r7, #20]
 8007dfe:	440a      	add	r2, r1
 8007e00:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007e04:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007e08:	6113      	str	r3, [r2, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 8007e0a:	693b      	ldr	r3, [r7, #16]
 8007e0c:	015a      	lsls	r2, r3, #5
 8007e0e:	697b      	ldr	r3, [r7, #20]
 8007e10:	4413      	add	r3, r2
 8007e12:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007e16:	681b      	ldr	r3, [r3, #0]
 8007e18:	60bb      	str	r3, [r7, #8]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8007e1a:	68bb      	ldr	r3, [r7, #8]
 8007e1c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8007e20:	60bb      	str	r3, [r7, #8]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007e22:	68bb      	ldr	r3, [r7, #8]
 8007e24:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007e28:	60bb      	str	r3, [r7, #8]
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8007e2a:	693b      	ldr	r3, [r7, #16]
 8007e2c:	015a      	lsls	r2, r3, #5
 8007e2e:	697b      	ldr	r3, [r7, #20]
 8007e30:	4413      	add	r3, r2
 8007e32:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007e36:	461a      	mov	r2, r3
 8007e38:	68bb      	ldr	r3, [r7, #8]
 8007e3a:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8007e3c:	2300      	movs	r3, #0
}
 8007e3e:	4618      	mov	r0, r3
 8007e40:	371c      	adds	r7, #28
 8007e42:	46bd      	mov	sp, r7
 8007e44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e48:	4770      	bx	lr
 8007e4a:	bf00      	nop
 8007e4c:	1ff80000 	.word	0x1ff80000

08007e50 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 8007e50:	b580      	push	{r7, lr}
 8007e52:	b088      	sub	sp, #32
 8007e54:	af00      	add	r7, sp, #0
 8007e56:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8007e58:	2300      	movs	r3, #0
 8007e5a:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007e5c:	687b      	ldr	r3, [r7, #4]
 8007e5e:	617b      	str	r3, [r7, #20]
  volatile uint32_t count = 0U;
 8007e60:	2300      	movs	r3, #0
 8007e62:	60fb      	str	r3, [r7, #12]
  uint32_t value;
  uint32_t i;

  (void)USB_DisableGlobalInt(USBx);
 8007e64:	6878      	ldr	r0, [r7, #4]
 8007e66:	f7fe ff8c 	bl	8006d82 <USB_DisableGlobalInt>

  /* Flush USB FIFO */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8007e6a:	2110      	movs	r1, #16
 8007e6c:	6878      	ldr	r0, [r7, #4]
 8007e6e:	f7fe ffe5 	bl	8006e3c <USB_FlushTxFifo>
 8007e72:	4603      	mov	r3, r0
 8007e74:	2b00      	cmp	r3, #0
 8007e76:	d001      	beq.n	8007e7c <USB_StopHost+0x2c>
  {
    ret = HAL_ERROR;
 8007e78:	2301      	movs	r3, #1
 8007e7a:	77fb      	strb	r3, [r7, #31]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8007e7c:	6878      	ldr	r0, [r7, #4]
 8007e7e:	f7ff f80f 	bl	8006ea0 <USB_FlushRxFifo>
 8007e82:	4603      	mov	r3, r0
 8007e84:	2b00      	cmp	r3, #0
 8007e86:	d001      	beq.n	8007e8c <USB_StopHost+0x3c>
  {
    ret = HAL_ERROR;
 8007e88:	2301      	movs	r3, #1
 8007e8a:	77fb      	strb	r3, [r7, #31]
  }

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
 8007e8c:	2300      	movs	r3, #0
 8007e8e:	61bb      	str	r3, [r7, #24]
 8007e90:	e01f      	b.n	8007ed2 <USB_StopHost+0x82>
  {
    value = USBx_HC(i)->HCCHAR;
 8007e92:	69bb      	ldr	r3, [r7, #24]
 8007e94:	015a      	lsls	r2, r3, #5
 8007e96:	697b      	ldr	r3, [r7, #20]
 8007e98:	4413      	add	r3, r2
 8007e9a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007e9e:	681b      	ldr	r3, [r3, #0]
 8007ea0:	613b      	str	r3, [r7, #16]
    value |=  USB_OTG_HCCHAR_CHDIS;
 8007ea2:	693b      	ldr	r3, [r7, #16]
 8007ea4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007ea8:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_CHENA;
 8007eaa:	693b      	ldr	r3, [r7, #16]
 8007eac:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007eb0:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007eb2:	693b      	ldr	r3, [r7, #16]
 8007eb4:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007eb8:	613b      	str	r3, [r7, #16]
    USBx_HC(i)->HCCHAR = value;
 8007eba:	69bb      	ldr	r3, [r7, #24]
 8007ebc:	015a      	lsls	r2, r3, #5
 8007ebe:	697b      	ldr	r3, [r7, #20]
 8007ec0:	4413      	add	r3, r2
 8007ec2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007ec6:	461a      	mov	r2, r3
 8007ec8:	693b      	ldr	r3, [r7, #16]
 8007eca:	6013      	str	r3, [r2, #0]
  for (i = 0U; i <= 15U; i++)
 8007ecc:	69bb      	ldr	r3, [r7, #24]
 8007ece:	3301      	adds	r3, #1
 8007ed0:	61bb      	str	r3, [r7, #24]
 8007ed2:	69bb      	ldr	r3, [r7, #24]
 8007ed4:	2b0f      	cmp	r3, #15
 8007ed6:	d9dc      	bls.n	8007e92 <USB_StopHost+0x42>
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
 8007ed8:	2300      	movs	r3, #0
 8007eda:	61bb      	str	r3, [r7, #24]
 8007edc:	e034      	b.n	8007f48 <USB_StopHost+0xf8>
  {
    value = USBx_HC(i)->HCCHAR;
 8007ede:	69bb      	ldr	r3, [r7, #24]
 8007ee0:	015a      	lsls	r2, r3, #5
 8007ee2:	697b      	ldr	r3, [r7, #20]
 8007ee4:	4413      	add	r3, r2
 8007ee6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007eea:	681b      	ldr	r3, [r3, #0]
 8007eec:	613b      	str	r3, [r7, #16]
    value |= USB_OTG_HCCHAR_CHDIS;
 8007eee:	693b      	ldr	r3, [r7, #16]
 8007ef0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007ef4:	613b      	str	r3, [r7, #16]
    value |= USB_OTG_HCCHAR_CHENA;
 8007ef6:	693b      	ldr	r3, [r7, #16]
 8007ef8:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007efc:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007efe:	693b      	ldr	r3, [r7, #16]
 8007f00:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007f04:	613b      	str	r3, [r7, #16]
    USBx_HC(i)->HCCHAR = value;
 8007f06:	69bb      	ldr	r3, [r7, #24]
 8007f08:	015a      	lsls	r2, r3, #5
 8007f0a:	697b      	ldr	r3, [r7, #20]
 8007f0c:	4413      	add	r3, r2
 8007f0e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007f12:	461a      	mov	r2, r3
 8007f14:	693b      	ldr	r3, [r7, #16]
 8007f16:	6013      	str	r3, [r2, #0]

    do
    {
      count++;
 8007f18:	68fb      	ldr	r3, [r7, #12]
 8007f1a:	3301      	adds	r3, #1
 8007f1c:	60fb      	str	r3, [r7, #12]

      if (count > 1000U)
 8007f1e:	68fb      	ldr	r3, [r7, #12]
 8007f20:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007f24:	d80c      	bhi.n	8007f40 <USB_StopHost+0xf0>
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007f26:	69bb      	ldr	r3, [r7, #24]
 8007f28:	015a      	lsls	r2, r3, #5
 8007f2a:	697b      	ldr	r3, [r7, #20]
 8007f2c:	4413      	add	r3, r2
 8007f2e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007f32:	681b      	ldr	r3, [r3, #0]
 8007f34:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007f38:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007f3c:	d0ec      	beq.n	8007f18 <USB_StopHost+0xc8>
 8007f3e:	e000      	b.n	8007f42 <USB_StopHost+0xf2>
        break;
 8007f40:	bf00      	nop
  for (i = 0U; i <= 15U; i++)
 8007f42:	69bb      	ldr	r3, [r7, #24]
 8007f44:	3301      	adds	r3, #1
 8007f46:	61bb      	str	r3, [r7, #24]
 8007f48:	69bb      	ldr	r3, [r7, #24]
 8007f4a:	2b0f      	cmp	r3, #15
 8007f4c:	d9c7      	bls.n	8007ede <USB_StopHost+0x8e>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = CLEAR_INTERRUPT_MASK;
 8007f4e:	697b      	ldr	r3, [r7, #20]
 8007f50:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007f54:	461a      	mov	r2, r3
 8007f56:	f04f 33ff 	mov.w	r3, #4294967295
 8007f5a:	6153      	str	r3, [r2, #20]
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 8007f5c:	687b      	ldr	r3, [r7, #4]
 8007f5e:	f04f 32ff 	mov.w	r2, #4294967295
 8007f62:	615a      	str	r2, [r3, #20]

  (void)USB_EnableGlobalInt(USBx);
 8007f64:	6878      	ldr	r0, [r7, #4]
 8007f66:	f7fe fefb 	bl	8006d60 <USB_EnableGlobalInt>

  return ret;
 8007f6a:	7ffb      	ldrb	r3, [r7, #31]
}
 8007f6c:	4618      	mov	r0, r3
 8007f6e:	3720      	adds	r7, #32
 8007f70:	46bd      	mov	sp, r7
 8007f72:	bd80      	pop	{r7, pc}

08007f74 <fwrite_DWORD>:
DWORD LSBtoDWORD(char* lsb)
{
	return lsb[0] | lsb[1]<<8 | lsb[2]<<16 | lsb[3] << 24;
}
FRESULT fwrite_DWORD(FIL * file, DWORD word)
{
 8007f74:	b580      	push	{r7, lr}
 8007f76:	b084      	sub	sp, #16
 8007f78:	af00      	add	r7, sp, #0
 8007f7a:	6078      	str	r0, [r7, #4]
 8007f7c:	6039      	str	r1, [r7, #0]
	unsigned char * p;
	UINT bw;

	p = (unsigned char *)&word;
 8007f7e:	463b      	mov	r3, r7
 8007f80:	60fb      	str	r3, [r7, #12]

	return (f_write(file, p, 4, &bw));
 8007f82:	f107 0308 	add.w	r3, r7, #8
 8007f86:	2204      	movs	r2, #4
 8007f88:	68f9      	ldr	r1, [r7, #12]
 8007f8a:	6878      	ldr	r0, [r7, #4]
 8007f8c:	f007 ff19 	bl	800fdc2 <f_write>
 8007f90:	4603      	mov	r3, r0

}
 8007f92:	4618      	mov	r0, r3
 8007f94:	3710      	adds	r7, #16
 8007f96:	46bd      	mov	sp, r7
 8007f98:	bd80      	pop	{r7, pc}

08007f9a <fwrite_WORD>:

FRESULT fwrite_WORD(FIL * file, WORD word)
{
 8007f9a:	b580      	push	{r7, lr}
 8007f9c:	b084      	sub	sp, #16
 8007f9e:	af00      	add	r7, sp, #0
 8007fa0:	6078      	str	r0, [r7, #4]
 8007fa2:	460b      	mov	r3, r1
 8007fa4:	807b      	strh	r3, [r7, #2]
	unsigned char * p;
	UINT bw;

	p = (unsigned char*)&word;
 8007fa6:	1cbb      	adds	r3, r7, #2
 8007fa8:	60fb      	str	r3, [r7, #12]
	return (f_write(file, p, 2, &bw));
 8007faa:	f107 0308 	add.w	r3, r7, #8
 8007fae:	2202      	movs	r2, #2
 8007fb0:	68f9      	ldr	r1, [r7, #12]
 8007fb2:	6878      	ldr	r0, [r7, #4]
 8007fb4:	f007 ff05 	bl	800fdc2 <f_write>
 8007fb8:	4603      	mov	r3, r0

}
 8007fba:	4618      	mov	r0, r3
 8007fbc:	3710      	adds	r7, #16
 8007fbe:	46bd      	mov	sp, r7
 8007fc0:	bd80      	pop	{r7, pc}
	...

08007fc4 <set_avi_output_status>:
void set_avi_output_status(uint8_t stat)
{
 8007fc4:	b480      	push	{r7}
 8007fc6:	b083      	sub	sp, #12
 8007fc8:	af00      	add	r7, sp, #0
 8007fca:	4603      	mov	r3, r0
 8007fcc:	71fb      	strb	r3, [r7, #7]
	bAviStartRecording = stat;
 8007fce:	4a04      	ldr	r2, [pc, #16]	@ (8007fe0 <set_avi_output_status+0x1c>)
 8007fd0:	79fb      	ldrb	r3, [r7, #7]
 8007fd2:	7013      	strb	r3, [r2, #0]
}
 8007fd4:	bf00      	nop
 8007fd6:	370c      	adds	r7, #12
 8007fd8:	46bd      	mov	sp, r7
 8007fda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fde:	4770      	bx	lr
 8007fe0:	200028da 	.word	0x200028da

08007fe4 <read_avi_output_status>:
uint8_t read_avi_output_status()
{
 8007fe4:	b480      	push	{r7}
 8007fe6:	af00      	add	r7, sp, #0
	return bAviStartRecording;
 8007fe8:	4b03      	ldr	r3, [pc, #12]	@ (8007ff8 <read_avi_output_status+0x14>)
 8007fea:	781b      	ldrb	r3, [r3, #0]
}
 8007fec:	4618      	mov	r0, r3
 8007fee:	46bd      	mov	sp, r7
 8007ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ff4:	4770      	bx	lr
 8007ff6:	bf00      	nop
 8007ff8:	200028da 	.word	0x200028da

08007ffc <decode_jpeg_to_tft>:

void decode_jpeg_to_tft(uint8_t *buff, uint32_t len)
{
 8007ffc:	b580      	push	{r7, lr}
 8007ffe:	b084      	sub	sp, #16
 8008000:	af00      	add	r7, sp, #0
 8008002:	6078      	str	r0, [r7, #4]
 8008004:	6039      	str	r1, [r7, #0]
	uint32_t line_counter = 0;
 8008006:	2300      	movs	r3, #0
 8008008:	60fb      	str	r3, [r7, #12]
	uint32_t i = 0;
 800800a:	2300      	movs	r3, #0
 800800c:	60bb      	str	r3, [r7, #8]

	buffer[0] = rowBuff;
 800800e:	4b49      	ldr	r3, [pc, #292]	@ (8008134 <decode_jpeg_to_tft+0x138>)
 8008010:	4a49      	ldr	r2, [pc, #292]	@ (8008138 <decode_jpeg_to_tft+0x13c>)
 8008012:	601a      	str	r2, [r3, #0]

	//jpeg must begin 0xFFD8 end 0xFFD9
	if (!(buff[0] == 0xFF && buff[1] == 0xD8 && buff[len-2]==0xFF && buff[len-1] == 0xD9))
 8008014:	687b      	ldr	r3, [r7, #4]
 8008016:	781b      	ldrb	r3, [r3, #0]
 8008018:	2bff      	cmp	r3, #255	@ 0xff
 800801a:	f040 8087 	bne.w	800812c <decode_jpeg_to_tft+0x130>
 800801e:	687b      	ldr	r3, [r7, #4]
 8008020:	3301      	adds	r3, #1
 8008022:	781b      	ldrb	r3, [r3, #0]
 8008024:	2bd8      	cmp	r3, #216	@ 0xd8
 8008026:	f040 8081 	bne.w	800812c <decode_jpeg_to_tft+0x130>
 800802a:	683b      	ldr	r3, [r7, #0]
 800802c:	3b02      	subs	r3, #2
 800802e:	687a      	ldr	r2, [r7, #4]
 8008030:	4413      	add	r3, r2
 8008032:	781b      	ldrb	r3, [r3, #0]
 8008034:	2bff      	cmp	r3, #255	@ 0xff
 8008036:	d179      	bne.n	800812c <decode_jpeg_to_tft+0x130>
 8008038:	683b      	ldr	r3, [r7, #0]
 800803a:	3b01      	subs	r3, #1
 800803c:	687a      	ldr	r2, [r7, #4]
 800803e:	4413      	add	r3, r2
 8008040:	781b      	ldrb	r3, [r3, #0]
 8008042:	2bd9      	cmp	r3, #217	@ 0xd9
 8008044:	d172      	bne.n	800812c <decode_jpeg_to_tft+0x130>
		return;
	cinfo.err = jpeg_std_error(&jerr);
 8008046:	483d      	ldr	r0, [pc, #244]	@ (800813c <decode_jpeg_to_tft+0x140>)
 8008048:	f014 f97e 	bl	801c348 <jpeg_std_error>
 800804c:	4603      	mov	r3, r0
 800804e:	4a3c      	ldr	r2, [pc, #240]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008050:	6013      	str	r3, [r2, #0]

	jpeg_create_decompress(&cinfo);
 8008052:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8008056:	2150      	movs	r1, #80	@ 0x50
 8008058:	4839      	ldr	r0, [pc, #228]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 800805a:	f008 fd93 	bl	8010b84 <jpeg_CreateDecompress>

	jpeg_mem_src(&cinfo, buff, len);
 800805e:	683a      	ldr	r2, [r7, #0]
 8008060:	6879      	ldr	r1, [r7, #4]
 8008062:	4837      	ldr	r0, [pc, #220]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008064:	f00a fac4 	bl	80125f0 <jpeg_mem_src>
	jpeg_read_header(&cinfo, TRUE);
 8008068:	2101      	movs	r1, #1
 800806a:	4835      	ldr	r0, [pc, #212]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 800806c:	f008 ff40 	bl	8010ef0 <jpeg_read_header>
	//cinfo.scale_num=1;
	//cinfo.scale_denom=2;
	cinfo.dct_method = JDCT_IFAST;
 8008070:	4b33      	ldr	r3, [pc, #204]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008072:	2201      	movs	r2, #1
 8008074:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

	jpeg_start_decompress(&cinfo);
 8008078:	4831      	ldr	r0, [pc, #196]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 800807a:	f009 f846 	bl	801110a <jpeg_start_decompress>
	//while (cinfo.output_scanline < cinfo.output_height && line_counter < 240)

	while (cinfo.output_scanline < cinfo.output_height && line_counter < 228) //240-12 (12 for menu)
 800807e:	e044      	b.n	800810a <decode_jpeg_to_tft+0x10e>
	{
		(void)jpeg_read_scanlines(&cinfo, buffer, 1);
 8008080:	2201      	movs	r2, #1
 8008082:	492c      	ldr	r1, [pc, #176]	@ (8008134 <decode_jpeg_to_tft+0x138>)
 8008084:	482e      	ldr	r0, [pc, #184]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008086:	f009 f928 	bl	80112da <jpeg_read_scanlines>

		RGB_matrix=(RGB_typedef*)buffer[0];
 800808a:	4b2a      	ldr	r3, [pc, #168]	@ (8008134 <decode_jpeg_to_tft+0x138>)
 800808c:	681b      	ldr	r3, [r3, #0]
 800808e:	4a2d      	ldr	r2, [pc, #180]	@ (8008144 <decode_jpeg_to_tft+0x148>)
 8008090:	6013      	str	r3, [r2, #0]
		for(i = 0; i < cinfo.output_width ; i++)
 8008092:	2300      	movs	r3, #0
 8008094:	60bb      	str	r3, [r7, #8]
 8008096:	e030      	b.n	80080fa <decode_jpeg_to_tft+0xfe>
		{
			RGB16PixelColor = (uint16_t)
			(
				((RGB_matrix[i].R & 0x00F8) >> 3)|
 8008098:	4b2a      	ldr	r3, [pc, #168]	@ (8008144 <decode_jpeg_to_tft+0x148>)
 800809a:	6819      	ldr	r1, [r3, #0]
 800809c:	68ba      	ldr	r2, [r7, #8]
 800809e:	4613      	mov	r3, r2
 80080a0:	005b      	lsls	r3, r3, #1
 80080a2:	4413      	add	r3, r2
 80080a4:	440b      	add	r3, r1
 80080a6:	789b      	ldrb	r3, [r3, #2]
 80080a8:	08db      	lsrs	r3, r3, #3
 80080aa:	b2db      	uxtb	r3, r3
 80080ac:	b219      	sxth	r1, r3
				((RGB_matrix[i].G & 0x00FC) << 3)|
 80080ae:	4b25      	ldr	r3, [pc, #148]	@ (8008144 <decode_jpeg_to_tft+0x148>)
 80080b0:	6818      	ldr	r0, [r3, #0]
 80080b2:	68ba      	ldr	r2, [r7, #8]
 80080b4:	4613      	mov	r3, r2
 80080b6:	005b      	lsls	r3, r3, #1
 80080b8:	4413      	add	r3, r2
 80080ba:	4403      	add	r3, r0
 80080bc:	785b      	ldrb	r3, [r3, #1]
 80080be:	00db      	lsls	r3, r3, #3
				((RGB_matrix[i].R & 0x00F8) >> 3)|
 80080c0:	b21b      	sxth	r3, r3
 80080c2:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 80080c6:	b21b      	sxth	r3, r3
 80080c8:	430b      	orrs	r3, r1
 80080ca:	b219      	sxth	r1, r3
				((RGB_matrix[i].B & 0x00F8) << 8)
 80080cc:	4b1d      	ldr	r3, [pc, #116]	@ (8008144 <decode_jpeg_to_tft+0x148>)
 80080ce:	6818      	ldr	r0, [r3, #0]
 80080d0:	68ba      	ldr	r2, [r7, #8]
 80080d2:	4613      	mov	r3, r2
 80080d4:	005b      	lsls	r3, r3, #1
 80080d6:	4413      	add	r3, r2
 80080d8:	4403      	add	r3, r0
 80080da:	781b      	ldrb	r3, [r3, #0]
 80080dc:	021b      	lsls	r3, r3, #8
				((RGB_matrix[i].G & 0x00FC) << 3)|
 80080de:	b21b      	sxth	r3, r3
 80080e0:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 80080e4:	f023 0307 	bic.w	r3, r3, #7
 80080e8:	b21b      	sxth	r3, r3
 80080ea:	430b      	orrs	r3, r1
 80080ec:	b21b      	sxth	r3, r3
			RGB16PixelColor = (uint16_t)
 80080ee:	b29a      	uxth	r2, r3
 80080f0:	4b15      	ldr	r3, [pc, #84]	@ (8008148 <decode_jpeg_to_tft+0x14c>)
 80080f2:	801a      	strh	r2, [r3, #0]
		for(i = 0; i < cinfo.output_width ; i++)
 80080f4:	68bb      	ldr	r3, [r7, #8]
 80080f6:	3301      	adds	r3, #1
 80080f8:	60bb      	str	r3, [r7, #8]
 80080fa:	4b11      	ldr	r3, [pc, #68]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 80080fc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80080fe:	68ba      	ldr	r2, [r7, #8]
 8008100:	429a      	cmp	r2, r3
 8008102:	d3c9      	bcc.n	8008098 <decode_jpeg_to_tft+0x9c>
			);

		}

	  	line_counter++;
 8008104:	68fb      	ldr	r3, [r7, #12]
 8008106:	3301      	adds	r3, #1
 8008108:	60fb      	str	r3, [r7, #12]
	while (cinfo.output_scanline < cinfo.output_height && line_counter < 228) //240-12 (12 for menu)
 800810a:	4b0d      	ldr	r3, [pc, #52]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 800810c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8008110:	4b0b      	ldr	r3, [pc, #44]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008112:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8008114:	429a      	cmp	r2, r3
 8008116:	d202      	bcs.n	800811e <decode_jpeg_to_tft+0x122>
 8008118:	68fb      	ldr	r3, [r7, #12]
 800811a:	2be3      	cmp	r3, #227	@ 0xe3
 800811c:	d9b0      	bls.n	8008080 <decode_jpeg_to_tft+0x84>

	}

	jpeg_finish_decompress(&cinfo);
 800811e:	4808      	ldr	r0, [pc, #32]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008120:	f008 ff90 	bl	8011044 <jpeg_finish_decompress>

	jpeg_destroy_decompress(&cinfo);
 8008124:	4806      	ldr	r0, [pc, #24]	@ (8008140 <decode_jpeg_to_tft+0x144>)
 8008126:	f008 fdb6 	bl	8010c96 <jpeg_destroy_decompress>
 800812a:	e000      	b.n	800812e <decode_jpeg_to_tft+0x132>
		return;
 800812c:	bf00      	nop
}
 800812e:	3710      	adds	r7, #16
 8008130:	46bd      	mov	sp, r7
 8008132:	bd80      	pop	{r7, pc}
 8008134:	20002448 	.word	0x20002448
 8008138:	20002450 	.word	0x20002450
 800813c:	20002850 	.word	0x20002850
 8008140:	20002260 	.word	0x20002260
 8008144:	200028d4 	.word	0x200028d4
 8008148:	200028d8 	.word	0x200028d8

0800814c <output_avi_header>:

FRESULT output_avi_header(FIL *file, uint8_t fps, uint16_t width, uint16_t height)
{
 800814c:	b580      	push	{r7, lr}
 800814e:	b0c0      	sub	sp, #256	@ 0x100
 8008150:	af00      	add	r7, sp, #0
 8008152:	60f8      	str	r0, [r7, #12]
 8008154:	4608      	mov	r0, r1
 8008156:	4611      	mov	r1, r2
 8008158:	461a      	mov	r2, r3
 800815a:	4603      	mov	r3, r0
 800815c:	72fb      	strb	r3, [r7, #11]
 800815e:	460b      	mov	r3, r1
 8008160:	813b      	strh	r3, [r7, #8]
 8008162:	4613      	mov	r3, r2
 8008164:	80fb      	strh	r3, [r7, #6]
	FRESULT res=FR_OK;
 8008166:	2300      	movs	r3, #0
 8008168:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	UINT bw;
	RIFF RIFF_LIST;


	RIFF_LIST.dwRIFF = 'RIFF';
 800816c:	4bd8      	ldr	r3, [pc, #864]	@ (80084d0 <output_avi_header+0x384>)
 800816e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
	res = f_write(file, "RIFF", 4, &bw); //offset=0
 8008172:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008176:	2204      	movs	r2, #4
 8008178:	49d6      	ldr	r1, [pc, #856]	@ (80084d4 <output_avi_header+0x388>)
 800817a:	68f8      	ldr	r0, [r7, #12]
 800817c:	f007 fe21 	bl	800fdc2 <f_write>
 8008180:	4603      	mov	r3, r0
 8008182:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	//RIFF_LIST.dwSize =  150 + 12 + len + 8*frames + 8 + 4*4*frames;
	RIFF_LIST.dwSize =  0;
 8008186:	2300      	movs	r3, #0
 8008188:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
	// must rewrite when stop_output at file offset  4;
	res = fwrite_DWORD(file, RIFF_LIST.dwSize); //offset+4=4
 800818c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8008190:	4619      	mov	r1, r3
 8008192:	68f8      	ldr	r0, [r7, #12]
 8008194:	f7ff feee 	bl	8007f74 <fwrite_DWORD>
 8008198:	4603      	mov	r3, r0
 800819a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	RIFF_LIST.dwFourCC = 'AVI ';
 800819e:	4bce      	ldr	r3, [pc, #824]	@ (80084d8 <output_avi_header+0x38c>)
 80081a0:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
	res = f_write(file, "AVI ", 4, &bw); //offset+4=8
 80081a4:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80081a8:	2204      	movs	r2, #4
 80081aa:	49cc      	ldr	r1, [pc, #816]	@ (80084dc <output_avi_header+0x390>)
 80081ac:	68f8      	ldr	r0, [r7, #12]
 80081ae:	f007 fe08 	bl	800fdc2 <f_write>
 80081b2:	4603      	mov	r3, r0
 80081b4:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	// 	RIFF_LIST.data = WAIT WITH THIS

	LIST hdrl;
	hdrl.dwList = 'LIST';
 80081b8:	4bc9      	ldr	r3, [pc, #804]	@ (80084e0 <output_avi_header+0x394>)
 80081ba:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
	res = f_write(file, "LIST", 4, &bw); //offset+4=12
 80081be:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80081c2:	2204      	movs	r2, #4
 80081c4:	49c7      	ldr	r1, [pc, #796]	@ (80084e4 <output_avi_header+0x398>)
 80081c6:	68f8      	ldr	r0, [r7, #12]
 80081c8:	f007 fdfb 	bl	800fdc2 <f_write>
 80081cc:	4603      	mov	r3, r0
 80081ce:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	hdrl.dwSize = 208;
 80081d2:	23d0      	movs	r3, #208	@ 0xd0
 80081d4:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
	res = fwrite_DWORD(file, hdrl.dwSize);//offset+4=16
 80081d8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80081dc:	4619      	mov	r1, r3
 80081de:	68f8      	ldr	r0, [r7, #12]
 80081e0:	f7ff fec8 	bl	8007f74 <fwrite_DWORD>
 80081e4:	4603      	mov	r3, r0
 80081e6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	hdrl.dwFourCC = 'hdrl';
 80081ea:	4bbf      	ldr	r3, [pc, #764]	@ (80084e8 <output_avi_header+0x39c>)
 80081ec:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
	res = f_write(file, "hdrl", 4, &bw);//offset+4=20
 80081f0:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80081f4:	2204      	movs	r2, #4
 80081f6:	49bd      	ldr	r1, [pc, #756]	@ (80084ec <output_avi_header+0x3a0>)
 80081f8:	68f8      	ldr	r0, [r7, #12]
 80081fa:	f007 fde2 	bl	800fdc2 <f_write>
 80081fe:	4603      	mov	r3, r0
 8008200:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	MainAVIHeader avih;

	avih.dwFourCC = 'avih';
 8008204:	4bba      	ldr	r3, [pc, #744]	@ (80084f0 <output_avi_header+0x3a4>)
 8008206:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
	res = f_write(file, "avih", 4, &bw); //offset+4=24
 800820a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800820e:	2204      	movs	r2, #4
 8008210:	49b8      	ldr	r1, [pc, #736]	@ (80084f4 <output_avi_header+0x3a8>)
 8008212:	68f8      	ldr	r0, [r7, #12]
 8008214:	f007 fdd5 	bl	800fdc2 <f_write>
 8008218:	4603      	mov	r3, r0
 800821a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwSize = 56;
 800821e:	2338      	movs	r3, #56	@ 0x38
 8008220:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
	res = fwrite_DWORD(file, avih.dwSize);//offset+4=28
 8008224:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8008228:	4619      	mov	r1, r3
 800822a:	68f8      	ldr	r0, [r7, #12]
 800822c:	f7ff fea2 	bl	8007f74 <fwrite_DWORD>
 8008230:	4603      	mov	r3, r0
 8008232:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwMicroSecPerFrame = 1000000/fps;
 8008236:	7afb      	ldrb	r3, [r7, #11]
 8008238:	4aaf      	ldr	r2, [pc, #700]	@ (80084f8 <output_avi_header+0x3ac>)
 800823a:	fb92 f3f3 	sdiv	r3, r2, r3
 800823e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
	res = fwrite_DWORD(file, avih.dwMicroSecPerFrame);//offset+4=32
 8008242:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8008246:	4619      	mov	r1, r3
 8008248:	68f8      	ldr	r0, [r7, #12]
 800824a:	f7ff fe93 	bl	8007f74 <fwrite_DWORD>
 800824e:	4603      	mov	r3, r0
 8008250:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwMaxBytesPerSec = 7000;
 8008254:	f641 3358 	movw	r3, #7000	@ 0x1b58
 8008258:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
	res = fwrite_DWORD(file, avih.dwMaxBytesPerSec);//offset+4=36
 800825c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8008260:	4619      	mov	r1, r3
 8008262:	68f8      	ldr	r0, [r7, #12]
 8008264:	f7ff fe86 	bl	8007f74 <fwrite_DWORD>
 8008268:	4603      	mov	r3, r0
 800826a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwPaddingGranularity = 0;
 800826e:	2300      	movs	r3, #0
 8008270:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
	res = fwrite_DWORD(file, avih.dwPaddingGranularity);//offset+4=40
 8008274:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8008278:	4619      	mov	r1, r3
 800827a:	68f8      	ldr	r0, [r7, #12]
 800827c:	f7ff fe7a 	bl	8007f74 <fwrite_DWORD>
 8008280:	4603      	mov	r3, r0
 8008282:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	// dwFlags set to 16, do not know why!
	avih.dwFlags = 16;
 8008286:	2310      	movs	r3, #16
 8008288:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
	res = fwrite_DWORD(file, avih.dwFlags);//offset+4=44
 800828c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8008290:	4619      	mov	r1, r3
 8008292:	68f8      	ldr	r0, [r7, #12]
 8008294:	f7ff fe6e 	bl	8007f74 <fwrite_DWORD>
 8008298:	4603      	mov	r3, r0
 800829a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
///////////////////////////////
	avih.dwTotalFrames = 0;  // frames, offset ?, must rewrite
 800829e:	2300      	movs	r3, #0
 80082a0:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

	res = fwrite_DWORD(file, avih.dwTotalFrames);//offset+4=48
 80082a4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80082a8:	4619      	mov	r1, r3
 80082aa:	68f8      	ldr	r0, [r7, #12]
 80082ac:	f7ff fe62 	bl	8007f74 <fwrite_DWORD>
 80082b0:	4603      	mov	r3, r0
 80082b2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwInitialFrames = 0;
 80082b6:	2300      	movs	r3, #0
 80082b8:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
	res = fwrite_DWORD(file, avih.dwInitialFrames);//offset+4=52
 80082bc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 80082c0:	4619      	mov	r1, r3
 80082c2:	68f8      	ldr	r0, [r7, #12]
 80082c4:	f7ff fe56 	bl	8007f74 <fwrite_DWORD>
 80082c8:	4603      	mov	r3, r0
 80082ca:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwStreams = 1;
 80082ce:	2301      	movs	r3, #1
 80082d0:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
	res = fwrite_DWORD(file, avih.dwStreams);//offset+4=56
 80082d4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80082d8:	4619      	mov	r1, r3
 80082da:	68f8      	ldr	r0, [r7, #12]
 80082dc:	f7ff fe4a 	bl	8007f74 <fwrite_DWORD>
 80082e0:	4603      	mov	r3, r0
 80082e2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwSuggestedBufferSize = 0;
 80082e6:	2300      	movs	r3, #0
 80082e8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
	res = fwrite_DWORD(file, avih.dwSuggestedBufferSize);//offset+4=60
 80082ec:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80082f0:	4619      	mov	r1, r3
 80082f2:	68f8      	ldr	r0, [r7, #12]
 80082f4:	f7ff fe3e 	bl	8007f74 <fwrite_DWORD>
 80082f8:	4603      	mov	r3, r0
 80082fa:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwWidth = width;
 80082fe:	893b      	ldrh	r3, [r7, #8]
 8008300:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
	res = fwrite_DWORD(file, avih.dwWidth);//offset+4=64
 8008304:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8008308:	4619      	mov	r1, r3
 800830a:	68f8      	ldr	r0, [r7, #12]
 800830c:	f7ff fe32 	bl	8007f74 <fwrite_DWORD>
 8008310:	4603      	mov	r3, r0
 8008312:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwHeight = height;
 8008316:	88fb      	ldrh	r3, [r7, #6]
 8008318:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
	res = fwrite_DWORD(file, avih.dwHeight);//offset+4=68
 800831c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8008320:	4619      	mov	r1, r3
 8008322:	68f8      	ldr	r0, [r7, #12]
 8008324:	f7ff fe26 	bl	8007f74 <fwrite_DWORD>
 8008328:	4603      	mov	r3, r0
 800832a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwReserved[0] = 0;
 800832e:	2300      	movs	r3, #0
 8008330:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
	res = fwrite_DWORD(file, avih.dwReserved[0]);//offset+4=72
 8008334:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8008338:	4619      	mov	r1, r3
 800833a:	68f8      	ldr	r0, [r7, #12]
 800833c:	f7ff fe1a 	bl	8007f74 <fwrite_DWORD>
 8008340:	4603      	mov	r3, r0
 8008342:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[1] = 0;
 8008346:	2300      	movs	r3, #0
 8008348:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	res = fwrite_DWORD(file, avih.dwReserved[1]);//offset+4=76
 800834c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8008350:	4619      	mov	r1, r3
 8008352:	68f8      	ldr	r0, [r7, #12]
 8008354:	f7ff fe0e 	bl	8007f74 <fwrite_DWORD>
 8008358:	4603      	mov	r3, r0
 800835a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[2] = 0;
 800835e:	2300      	movs	r3, #0
 8008360:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
	res = fwrite_DWORD(file, avih.dwReserved[2]);//offset+4=80
 8008364:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8008368:	4619      	mov	r1, r3
 800836a:	68f8      	ldr	r0, [r7, #12]
 800836c:	f7ff fe02 	bl	8007f74 <fwrite_DWORD>
 8008370:	4603      	mov	r3, r0
 8008372:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[3] = 0;
 8008376:	2300      	movs	r3, #0
 8008378:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
	res = fwrite_DWORD(file, avih.dwReserved[3]);//offset+4=84
 800837c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8008380:	4619      	mov	r1, r3
 8008382:	68f8      	ldr	r0, [r7, #12]
 8008384:	f7ff fdf6 	bl	8007f74 <fwrite_DWORD>
 8008388:	4603      	mov	r3, r0
 800838a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	LIST strl;
	strl.dwList = 'LIST';
 800838e:	4b54      	ldr	r3, [pc, #336]	@ (80084e0 <output_avi_header+0x394>)
 8008390:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
	res = f_write(file, "LIST", 4, &bw);//offset+4=88
 8008394:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008398:	2204      	movs	r2, #4
 800839a:	4952      	ldr	r1, [pc, #328]	@ (80084e4 <output_avi_header+0x398>)
 800839c:	68f8      	ldr	r0, [r7, #12]
 800839e:	f007 fd10 	bl	800fdc2 <f_write>
 80083a2:	4603      	mov	r3, r0
 80083a4:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strl.dwSize = 132;
 80083a8:	2384      	movs	r3, #132	@ 0x84
 80083aa:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	res = fwrite_DWORD(file, strl.dwSize);//offset+4=92
 80083ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80083b2:	4619      	mov	r1, r3
 80083b4:	68f8      	ldr	r0, [r7, #12]
 80083b6:	f7ff fddd 	bl	8007f74 <fwrite_DWORD>
 80083ba:	4603      	mov	r3, r0
 80083bc:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strl.dwFourCC = 'strl';
 80083c0:	4b4e      	ldr	r3, [pc, #312]	@ (80084fc <output_avi_header+0x3b0>)
 80083c2:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
	res = f_write(file, "strl", 4, &bw);//offset+4=96
 80083c6:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80083ca:	2204      	movs	r2, #4
 80083cc:	494c      	ldr	r1, [pc, #304]	@ (8008500 <output_avi_header+0x3b4>)
 80083ce:	68f8      	ldr	r0, [r7, #12]
 80083d0:	f007 fcf7 	bl	800fdc2 <f_write>
 80083d4:	4603      	mov	r3, r0
 80083d6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	AVIStreamHeader strh;
	strh.dwFourCC = 'strh';
 80083da:	4b4a      	ldr	r3, [pc, #296]	@ (8008504 <output_avi_header+0x3b8>)
 80083dc:	653b      	str	r3, [r7, #80]	@ 0x50
	res = f_write(file, "strh", 4, &bw);//offset+4=100
 80083de:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80083e2:	2204      	movs	r2, #4
 80083e4:	4948      	ldr	r1, [pc, #288]	@ (8008508 <output_avi_header+0x3bc>)
 80083e6:	68f8      	ldr	r0, [r7, #12]
 80083e8:	f007 fceb 	bl	800fdc2 <f_write>
 80083ec:	4603      	mov	r3, r0
 80083ee:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwSize = 48;
 80083f2:	2330      	movs	r3, #48	@ 0x30
 80083f4:	657b      	str	r3, [r7, #84]	@ 0x54
	res = fwrite_DWORD(file, strh.dwSize);//offset+4=104
 80083f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80083f8:	4619      	mov	r1, r3
 80083fa:	68f8      	ldr	r0, [r7, #12]
 80083fc:	f7ff fdba 	bl	8007f74 <fwrite_DWORD>
 8008400:	4603      	mov	r3, r0
 8008402:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.fccType = 'vids';
 8008406:	4b41      	ldr	r3, [pc, #260]	@ (800850c <output_avi_header+0x3c0>)
 8008408:	65bb      	str	r3, [r7, #88]	@ 0x58
	res = f_write(file, "vids", 4, &bw);//offset+4=108
 800840a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800840e:	2204      	movs	r2, #4
 8008410:	493f      	ldr	r1, [pc, #252]	@ (8008510 <output_avi_header+0x3c4>)
 8008412:	68f8      	ldr	r0, [r7, #12]
 8008414:	f007 fcd5 	bl	800fdc2 <f_write>
 8008418:	4603      	mov	r3, r0
 800841a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.fccHandler = 'MJPG';
 800841e:	4b3d      	ldr	r3, [pc, #244]	@ (8008514 <output_avi_header+0x3c8>)
 8008420:	65fb      	str	r3, [r7, #92]	@ 0x5c
	res = f_write(file, "MJPG", 4,&bw);//offset+4=112
 8008422:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008426:	2204      	movs	r2, #4
 8008428:	493b      	ldr	r1, [pc, #236]	@ (8008518 <output_avi_header+0x3cc>)
 800842a:	68f8      	ldr	r0, [r7, #12]
 800842c:	f007 fcc9 	bl	800fdc2 <f_write>
 8008430:	4603      	mov	r3, r0
 8008432:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwFlags = 0;
 8008436:	2300      	movs	r3, #0
 8008438:	663b      	str	r3, [r7, #96]	@ 0x60
	res = fwrite_DWORD(file, strh.dwFlags);//offset+4=116
 800843a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800843c:	4619      	mov	r1, r3
 800843e:	68f8      	ldr	r0, [r7, #12]
 8008440:	f7ff fd98 	bl	8007f74 <fwrite_DWORD>
 8008444:	4603      	mov	r3, r0
 8008446:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.wPriority = 0; // +2 = 14
 800844a:	2300      	movs	r3, #0
 800844c:	f8a7 3064 	strh.w	r3, [r7, #100]	@ 0x64
	res = fwrite_WORD(file, strh.wPriority);//offset+4=120
 8008450:	f8b7 3064 	ldrh.w	r3, [r7, #100]	@ 0x64
 8008454:	4619      	mov	r1, r3
 8008456:	68f8      	ldr	r0, [r7, #12]
 8008458:	f7ff fd9f 	bl	8007f9a <fwrite_WORD>
 800845c:	4603      	mov	r3, r0
 800845e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.wLanguage = 0; // +2 = 16
 8008462:	2300      	movs	r3, #0
 8008464:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
	res = fwrite_WORD(file, strh.wLanguage);//offset+2=122
 8008468:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 800846c:	4619      	mov	r1, r3
 800846e:	68f8      	ldr	r0, [r7, #12]
 8008470:	f7ff fd93 	bl	8007f9a <fwrite_WORD>
 8008474:	4603      	mov	r3, r0
 8008476:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwInitialFrames = 0; // +4 = 20
 800847a:	2300      	movs	r3, #0
 800847c:	66bb      	str	r3, [r7, #104]	@ 0x68
	res = fwrite_DWORD(file, strh.dwInitialFrames);//offset+2=124
 800847e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8008480:	4619      	mov	r1, r3
 8008482:	68f8      	ldr	r0, [r7, #12]
 8008484:	f7ff fd76 	bl	8007f74 <fwrite_DWORD>
 8008488:	4603      	mov	r3, r0
 800848a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwScale = 1; // +4 = 24
 800848e:	2301      	movs	r3, #1
 8008490:	66fb      	str	r3, [r7, #108]	@ 0x6c
	res = fwrite_DWORD(file, strh.dwScale);//offset+4=128
 8008492:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008494:	4619      	mov	r1, r3
 8008496:	68f8      	ldr	r0, [r7, #12]
 8008498:	f7ff fd6c 	bl	8007f74 <fwrite_DWORD>
 800849c:	4603      	mov	r3, r0
 800849e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	// insert FPS
	strh.dwRate = fps; // +4 = 28
 80084a2:	7afb      	ldrb	r3, [r7, #11]
 80084a4:	673b      	str	r3, [r7, #112]	@ 0x70
	res = fwrite_DWORD(file, strh.dwRate);//offset+4=132
 80084a6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80084a8:	4619      	mov	r1, r3
 80084aa:	68f8      	ldr	r0, [r7, #12]
 80084ac:	f7ff fd62 	bl	8007f74 <fwrite_DWORD>
 80084b0:	4603      	mov	r3, r0
 80084b2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwStart = 0; // +4 = 32
 80084b6:	2300      	movs	r3, #0
 80084b8:	677b      	str	r3, [r7, #116]	@ 0x74
	res = fwrite_DWORD(file, strh.dwStart);//offset+4=136
 80084ba:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80084bc:	4619      	mov	r1, r3
 80084be:	68f8      	ldr	r0, [r7, #12]
 80084c0:	f7ff fd58 	bl	8007f74 <fwrite_DWORD>
 80084c4:	4603      	mov	r3, r0
 80084c6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	//////////////////////
	// insert nbr of jpegs, must rewrite, offset ?
	strh.dwLength = 0; //nbr_of_jpgs;  +4 = 36
 80084ca:	2300      	movs	r3, #0
 80084cc:	e026      	b.n	800851c <output_avi_header+0x3d0>
 80084ce:	bf00      	nop
 80084d0:	52494646 	.word	0x52494646
 80084d4:	0802e6f4 	.word	0x0802e6f4
 80084d8:	41564920 	.word	0x41564920
 80084dc:	0802e6fc 	.word	0x0802e6fc
 80084e0:	4c495354 	.word	0x4c495354
 80084e4:	0802e704 	.word	0x0802e704
 80084e8:	6864726c 	.word	0x6864726c
 80084ec:	0802e70c 	.word	0x0802e70c
 80084f0:	61766968 	.word	0x61766968
 80084f4:	0802e714 	.word	0x0802e714
 80084f8:	000f4240 	.word	0x000f4240
 80084fc:	7374726c 	.word	0x7374726c
 8008500:	0802e71c 	.word	0x0802e71c
 8008504:	73747268 	.word	0x73747268
 8008508:	0802e724 	.word	0x0802e724
 800850c:	76696473 	.word	0x76696473
 8008510:	0802e72c 	.word	0x0802e72c
 8008514:	4d4a5047 	.word	0x4d4a5047
 8008518:	0802e734 	.word	0x0802e734
 800851c:	67bb      	str	r3, [r7, #120]	@ 0x78
	res = fwrite_DWORD(file, strh.dwLength);//offset+4=140
 800851e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8008520:	4619      	mov	r1, r3
 8008522:	68f8      	ldr	r0, [r7, #12]
 8008524:	f7ff fd26 	bl	8007f74 <fwrite_DWORD>
 8008528:	4603      	mov	r3, r0
 800852a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwSuggestedBufferSize = 0; // +4 = 40
 800852e:	2300      	movs	r3, #0
 8008530:	67fb      	str	r3, [r7, #124]	@ 0x7c
	res = fwrite_DWORD(file, strh.dwSuggestedBufferSize);//offset+4=144
 8008532:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8008534:	4619      	mov	r1, r3
 8008536:	68f8      	ldr	r0, [r7, #12]
 8008538:	f7ff fd1c 	bl	8007f74 <fwrite_DWORD>
 800853c:	4603      	mov	r3, r0
 800853e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwQuality = 0; // +4 = 44
 8008542:	2300      	movs	r3, #0
 8008544:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
	res = fwrite_DWORD(file, strh.dwQuality);//offset+4=148
 8008548:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800854c:	4619      	mov	r1, r3
 800854e:	68f8      	ldr	r0, [r7, #12]
 8008550:	f7ff fd10 	bl	8007f74 <fwrite_DWORD>
 8008554:	4603      	mov	r3, r0
 8008556:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	// can be grouped into a single chunk within the file.
	// If it is zero, each sample of data (such as a video frame) must be in a separate chunk.
	// For video streams, this number is typically zero, although
	// it can be nonzero if all video frames are the same size.
	//
	strh.dwSampleSize = 0; // +4 = 48
 800855a:	2300      	movs	r3, #0
 800855c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
	res = fwrite_DWORD(file, strh.dwSampleSize);//offset+4=152
 8008560:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8008564:	4619      	mov	r1, r3
 8008566:	68f8      	ldr	r0, [r7, #12]
 8008568:	f7ff fd04 	bl	8007f74 <fwrite_DWORD>
 800856c:	4603      	mov	r3, r0
 800856e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	EXBMINFOHEADER strf;

	strf.dwFourCC = 'strf';
 8008572:	4b7d      	ldr	r3, [pc, #500]	@ (8008768 <output_avi_header+0x61c>)
 8008574:	623b      	str	r3, [r7, #32]
	res = f_write(file, "strf", 4, &bw);//offset+4=156
 8008576:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800857a:	2204      	movs	r2, #4
 800857c:	497b      	ldr	r1, [pc, #492]	@ (800876c <output_avi_header+0x620>)
 800857e:	68f8      	ldr	r0, [r7, #12]
 8008580:	f007 fc1f 	bl	800fdc2 <f_write>
 8008584:	4603      	mov	r3, r0
 8008586:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.dwSize = 40;
 800858a:	2328      	movs	r3, #40	@ 0x28
 800858c:	627b      	str	r3, [r7, #36]	@ 0x24
	res = fwrite_DWORD(file, strf.dwSize);//offset+4=160
 800858e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008590:	4619      	mov	r1, r3
 8008592:	68f8      	ldr	r0, [r7, #12]
 8008594:	f7ff fcee 	bl	8007f74 <fwrite_DWORD>
 8008598:	4603      	mov	r3, r0
 800859a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biSize = 40;
 800859e:	2328      	movs	r3, #40	@ 0x28
 80085a0:	62bb      	str	r3, [r7, #40]	@ 0x28
	res = fwrite_DWORD(file, strf.biSize);//offset+4=164
 80085a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80085a4:	4619      	mov	r1, r3
 80085a6:	68f8      	ldr	r0, [r7, #12]
 80085a8:	f7ff fce4 	bl	8007f74 <fwrite_DWORD>
 80085ac:	4603      	mov	r3, r0
 80085ae:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biWidth = width;
 80085b2:	893b      	ldrh	r3, [r7, #8]
 80085b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
	res = fwrite_DWORD(file, strf.biWidth);//offset+4=168
 80085b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80085b8:	4619      	mov	r1, r3
 80085ba:	68f8      	ldr	r0, [r7, #12]
 80085bc:	f7ff fcda 	bl	8007f74 <fwrite_DWORD>
 80085c0:	4603      	mov	r3, r0
 80085c2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biHeight = height;
 80085c6:	88fb      	ldrh	r3, [r7, #6]
 80085c8:	633b      	str	r3, [r7, #48]	@ 0x30
	res = fwrite_DWORD(file, strf.biHeight);//offset+4=172
 80085ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80085cc:	4619      	mov	r1, r3
 80085ce:	68f8      	ldr	r0, [r7, #12]
 80085d0:	f7ff fcd0 	bl	8007f74 <fwrite_DWORD>
 80085d4:	4603      	mov	r3, r0
 80085d6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biPlanes = 1;
 80085da:	2301      	movs	r3, #1
 80085dc:	86bb      	strh	r3, [r7, #52]	@ 0x34
	res = fwrite_WORD(file, strf.biPlanes);//offset+4=176
 80085de:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 80085e0:	4619      	mov	r1, r3
 80085e2:	68f8      	ldr	r0, [r7, #12]
 80085e4:	f7ff fcd9 	bl	8007f9a <fwrite_WORD>
 80085e8:	4603      	mov	r3, r0
 80085ea:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biBitCount = 24;
 80085ee:	2318      	movs	r3, #24
 80085f0:	86fb      	strh	r3, [r7, #54]	@ 0x36
	res = fwrite_WORD(file, strf.biBitCount);//offset+2=178
 80085f2:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 80085f4:	4619      	mov	r1, r3
 80085f6:	68f8      	ldr	r0, [r7, #12]
 80085f8:	f7ff fccf 	bl	8007f9a <fwrite_WORD>
 80085fc:	4603      	mov	r3, r0
 80085fe:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biCompression = 'MJPG';
 8008602:	4b5b      	ldr	r3, [pc, #364]	@ (8008770 <output_avi_header+0x624>)
 8008604:	63bb      	str	r3, [r7, #56]	@ 0x38
	res = f_write(file, "MJPG", 4, &bw);//offset+2=180
 8008606:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800860a:	2204      	movs	r2, #4
 800860c:	4959      	ldr	r1, [pc, #356]	@ (8008774 <output_avi_header+0x628>)
 800860e:	68f8      	ldr	r0, [r7, #12]
 8008610:	f007 fbd7 	bl	800fdc2 <f_write>
 8008614:	4603      	mov	r3, r0
 8008616:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biSizeImage = ((strf.biWidth*strf.biBitCount/8 + 3)&0xFFFFFFFC)*strf.biHeight;
 800861a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800861c:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 800861e:	fb02 f303 	mul.w	r3, r2, r3
 8008622:	2b00      	cmp	r3, #0
 8008624:	da00      	bge.n	8008628 <output_avi_header+0x4dc>
 8008626:	3307      	adds	r3, #7
 8008628:	10db      	asrs	r3, r3, #3
 800862a:	3303      	adds	r3, #3
 800862c:	f023 0303 	bic.w	r3, r3, #3
 8008630:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8008632:	fb02 f303 	mul.w	r3, r2, r3
 8008636:	63fb      	str	r3, [r7, #60]	@ 0x3c
	res = fwrite_DWORD(file, strf.biSizeImage);//offset+4=184
 8008638:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800863a:	4619      	mov	r1, r3
 800863c:	68f8      	ldr	r0, [r7, #12]
 800863e:	f7ff fc99 	bl	8007f74 <fwrite_DWORD>
 8008642:	4603      	mov	r3, r0
 8008644:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biXPelsPerMeter = 0;
 8008648:	2300      	movs	r3, #0
 800864a:	643b      	str	r3, [r7, #64]	@ 0x40
	res = fwrite_DWORD(file, strf.biXPelsPerMeter);//offset+4=188
 800864c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800864e:	4619      	mov	r1, r3
 8008650:	68f8      	ldr	r0, [r7, #12]
 8008652:	f7ff fc8f 	bl	8007f74 <fwrite_DWORD>
 8008656:	4603      	mov	r3, r0
 8008658:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biYPelsPerMeter = 0;
 800865c:	2300      	movs	r3, #0
 800865e:	647b      	str	r3, [r7, #68]	@ 0x44
	res = fwrite_DWORD(file, strf.biYPelsPerMeter);//offset+4=192
 8008660:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008662:	4619      	mov	r1, r3
 8008664:	68f8      	ldr	r0, [r7, #12]
 8008666:	f7ff fc85 	bl	8007f74 <fwrite_DWORD>
 800866a:	4603      	mov	r3, r0
 800866c:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biClrUsed = 0;
 8008670:	2300      	movs	r3, #0
 8008672:	64bb      	str	r3, [r7, #72]	@ 0x48
	res = fwrite_DWORD(file, strf.biClrUsed);//offset+4=196
 8008674:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008676:	4619      	mov	r1, r3
 8008678:	68f8      	ldr	r0, [r7, #12]
 800867a:	f7ff fc7b 	bl	8007f74 <fwrite_DWORD>
 800867e:	4603      	mov	r3, r0
 8008680:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biClrImportant = 0;
 8008684:	2300      	movs	r3, #0
 8008686:	64fb      	str	r3, [r7, #76]	@ 0x4c
	res = fwrite_DWORD(file, strf.biClrImportant);//offset+4=200
 8008688:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800868a:	4619      	mov	r1, r3
 800868c:	68f8      	ldr	r0, [r7, #12]
 800868e:	f7ff fc71 	bl	8007f74 <fwrite_DWORD>
 8008692:	4603      	mov	r3, r0
 8008694:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	res = f_write(file, "LIST", 4, &bw);//offset+4=204
 8008698:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800869c:	2204      	movs	r2, #4
 800869e:	4936      	ldr	r1, [pc, #216]	@ (8008778 <output_avi_header+0x62c>)
 80086a0:	68f8      	ldr	r0, [r7, #12]
 80086a2:	f007 fb8e 	bl	800fdc2 <f_write>
 80086a6:	4603      	mov	r3, r0
 80086a8:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	DWORD ddww = 16;
 80086ac:	2310      	movs	r3, #16
 80086ae:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
	res = fwrite_DWORD(file, ddww);//offset+4=208
 80086b2:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80086b6:	68f8      	ldr	r0, [r7, #12]
 80086b8:	f7ff fc5c 	bl	8007f74 <fwrite_DWORD>
 80086bc:	4603      	mov	r3, r0
 80086be:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	res = f_write(file, "odml", 4, &bw);//offset+4=212
 80086c2:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80086c6:	2204      	movs	r2, #4
 80086c8:	492c      	ldr	r1, [pc, #176]	@ (800877c <output_avi_header+0x630>)
 80086ca:	68f8      	ldr	r0, [r7, #12]
 80086cc:	f007 fb79 	bl	800fdc2 <f_write>
 80086d0:	4603      	mov	r3, r0
 80086d2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	res = f_write(file, "dmlh", 4, &bw);//offset+4=216
 80086d6:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80086da:	2204      	movs	r2, #4
 80086dc:	4928      	ldr	r1, [pc, #160]	@ (8008780 <output_avi_header+0x634>)
 80086de:	68f8      	ldr	r0, [r7, #12]
 80086e0:	f007 fb6f 	bl	800fdc2 <f_write>
 80086e4:	4603      	mov	r3, r0
 80086e6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	DWORD szs = 4;
 80086ea:	2304      	movs	r3, #4
 80086ec:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
	res = fwrite_DWORD(file, szs);//offset+4=220
 80086f0:	f8d7 10f4 	ldr.w	r1, [r7, #244]	@ 0xf4
 80086f4:	68f8      	ldr	r0, [r7, #12]
 80086f6:	f7ff fc3d 	bl	8007f74 <fwrite_DWORD>
 80086fa:	4603      	mov	r3, r0
 80086fc:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
////////////////////////////////////////
	// nbr of jpgs
	DWORD totalframes = 0; //nbr_of_jpgs; must rewrite, offset ?;
 8008700:	2300      	movs	r3, #0
 8008702:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
	res = fwrite_DWORD(file, totalframes);//offset+4=224
 8008706:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 800870a:	68f8      	ldr	r0, [r7, #12]
 800870c:	f7ff fc32 	bl	8007f74 <fwrite_DWORD>
 8008710:	4603      	mov	r3, r0
 8008712:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	LIST movi;
	movi.dwList = 'LIST';
 8008716:	4b1b      	ldr	r3, [pc, #108]	@ (8008784 <output_avi_header+0x638>)
 8008718:	617b      	str	r3, [r7, #20]
	res = f_write(file, "LIST", 4, &bw);//offset+4=228
 800871a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800871e:	2204      	movs	r2, #4
 8008720:	4915      	ldr	r1, [pc, #84]	@ (8008778 <output_avi_header+0x62c>)
 8008722:	68f8      	ldr	r0, [r7, #12]
 8008724:	f007 fb4d 	bl	800fdc2 <f_write>
 8008728:	4603      	mov	r3, r0
 800872a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	//////////////////////////////
	//movi.dwSize = len + 4 + 8*nbr_of_jpgs;   must rewrite, offset?, len, nbr_of_jpgs;
	movi.dwSize = 0;
 800872e:	2300      	movs	r3, #0
 8008730:	61bb      	str	r3, [r7, #24]
	res = fwrite_DWORD(file, movi.dwSize);//offset+4=232
 8008732:	69bb      	ldr	r3, [r7, #24]
 8008734:	4619      	mov	r1, r3
 8008736:	68f8      	ldr	r0, [r7, #12]
 8008738:	f7ff fc1c 	bl	8007f74 <fwrite_DWORD>
 800873c:	4603      	mov	r3, r0
 800873e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	movi.dwFourCC = 'movi';
 8008742:	4b11      	ldr	r3, [pc, #68]	@ (8008788 <output_avi_header+0x63c>)
 8008744:	61fb      	str	r3, [r7, #28]
	res = f_write(file, "movi", 4, &bw);//offset+4=236
 8008746:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800874a:	2204      	movs	r2, #4
 800874c:	490f      	ldr	r1, [pc, #60]	@ (800878c <output_avi_header+0x640>)
 800874e:	68f8      	ldr	r0, [r7, #12]
 8008750:	f007 fb37 	bl	800fdc2 <f_write>
 8008754:	4603      	mov	r3, r0
 8008756:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	return res;
 800875a:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
}
 800875e:	4618      	mov	r0, r3
 8008760:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 8008764:	46bd      	mov	sp, r7
 8008766:	bd80      	pop	{r7, pc}
 8008768:	73747266 	.word	0x73747266
 800876c:	0802e73c 	.word	0x0802e73c
 8008770:	4d4a5047 	.word	0x4d4a5047
 8008774:	0802e734 	.word	0x0802e734
 8008778:	0802e704 	.word	0x0802e704
 800877c:	0802e744 	.word	0x0802e744
 8008780:	0802e74c 	.word	0x0802e74c
 8008784:	4c495354 	.word	0x4c495354
 8008788:	6d6f7669 	.word	0x6d6f7669
 800878c:	0802e754 	.word	0x0802e754

08008790 <start_output_mjpeg_avi>:

FRESULT start_output_mjpeg_avi(FIL *file, DCMI_HandleTypeDef *hdcmi, uint8_t fps, uint8_t resolution)
{
 8008790:	b590      	push	{r4, r7, lr}
 8008792:	f5ad 4dc1 	sub.w	sp, sp, #24704	@ 0x6080
 8008796:	b085      	sub	sp, #20
 8008798:	af00      	add	r7, sp, #0
 800879a:	f107 0490 	add.w	r4, r7, #144	@ 0x90
 800879e:	f844 0c84 	str.w	r0, [r4, #-132]
 80087a2:	f107 0090 	add.w	r0, r7, #144	@ 0x90
 80087a6:	f840 1c88 	str.w	r1, [r0, #-136]
 80087aa:	4619      	mov	r1, r3
 80087ac:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 80087b0:	f803 2c89 	strb.w	r2, [r3, #-137]
 80087b4:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 80087b8:	460a      	mov	r2, r1
 80087ba:	f803 2c8a 	strb.w	r2, [r3, #-138]
	FRESULT res = FR_OK;
 80087be:	2300      	movs	r3, #0
 80087c0:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80087c4:	f102 020f 	add.w	r2, r2, #15
 80087c8:	7013      	strb	r3, [r2, #0]
	FIL temp_idx1;
	uint32_t next_idx1_offset;
	uint8_t dmabuff[MAX_AVI_BUFF];
	uint16_t width, height;
	uint16_t f_begin = 0;
 80087ca:	2300      	movs	r3, #0
 80087cc:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80087d0:	f102 0206 	add.w	r2, r2, #6
 80087d4:	8013      	strh	r3, [r2, #0]
	uint32_t f_end = 0;
 80087d6:	2300      	movs	r3, #0
 80087d8:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80087dc:	f102 0260 	add.w	r2, r2, #96	@ 0x60
 80087e0:	6013      	str	r3, [r2, #0]
	uint32_t idx = 0;
 80087e2:	2300      	movs	r3, #0
 80087e4:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80087e8:	6013      	str	r3, [r2, #0]

	uint32_t sublen=0;
 80087ea:	2300      	movs	r3, #0
 80087ec:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80087f0:	f102 027c 	add.w	r2, r2, #124	@ 0x7c
 80087f4:	6013      	str	r3, [r2, #0]
	uint8_t headerFinder=0;
 80087f6:	2300      	movs	r3, #0
 80087f8:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80087fc:	f102 027b 	add.w	r2, r2, #123	@ 0x7b
 8008800:	7013      	strb	r3, [r2, #0]
	UINT bw;
	uint16_t f,r;
	CHUNK data;
	uint8_t *buff;
	uint8_t frame_ok=0;
 8008802:	2300      	movs	r3, #0
 8008804:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008808:	f102 0273 	add.w	r2, r2, #115	@ 0x73
 800880c:	7013      	strb	r3, [r2, #0]

	uint32_t lastSuccessTick;
	uint16_t timeout=0;
 800880e:	2300      	movs	r3, #0
 8008810:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008814:	f102 026a 	add.w	r2, r2, #106	@ 0x6a
 8008818:	8013      	strh	r3, [r2, #0]
	uint8_t adjTime=0;
 800881a:	2300      	movs	r3, #0
 800881c:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008820:	f102 0269 	add.w	r2, r2, #105	@ 0x69
 8008824:	7013      	strb	r3, [r2, #0]

	unsigned long beginTick;
	long time_diff=0;
 8008826:	2300      	movs	r3, #0
 8008828:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 800882c:	f102 025c 	add.w	r2, r2, #92	@ 0x5c
 8008830:	6013      	str	r3, [r2, #0]


	bAviStartRecording = AVI_START;
 8008832:	4b7b      	ldr	r3, [pc, #492]	@ (8008a20 <start_output_mjpeg_avi+0x290>)
 8008834:	2201      	movs	r2, #1
 8008836:	701a      	strb	r2, [r3, #0]
	HAL_DCMI_Stop(hdcmi);
 8008838:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 800883c:	f853 0c88 	ldr.w	r0, [r3, #-136]
 8008840:	f7f9 fba6 	bl	8001f90 <HAL_DCMI_Stop>
	ov2640_Init(0x60, CAMERA_Movie);
 8008844:	2102      	movs	r1, #2
 8008846:	2060      	movs	r0, #96	@ 0x60
 8008848:	f000 fc1a 	bl	8009080 <ov2640_Init>

	width = 320;
 800884c:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 8008850:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008854:	f102 025a 	add.w	r2, r2, #90	@ 0x5a
 8008858:	8013      	strh	r3, [r2, #0]
	height = 240;
 800885a:	23f0      	movs	r3, #240	@ 0xf0
 800885c:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008860:	f102 0258 	add.w	r2, r2, #88	@ 0x58
 8008864:	8013      	strh	r3, [r2, #0]

	 res = f_open(&temp_idx1, "0:/temp_idx1", FA_CREATE_ALWAYS|FA_WRITE|FA_READ);
 8008866:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 800886a:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 800886e:	3b10      	subs	r3, #16
 8008870:	220b      	movs	r2, #11
 8008872:	496c      	ldr	r1, [pc, #432]	@ (8008a24 <start_output_mjpeg_avi+0x294>)
 8008874:	4618      	mov	r0, r3
 8008876:	f006 ff7d 	bl	800f774 <f_open>
 800887a:	4603      	mov	r3, r0
 800887c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008880:	f102 020f 	add.w	r2, r2, #15
 8008884:	7013      	strb	r3, [r2, #0]
	 if (res != FR_OK) return res;
 8008886:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800888a:	f103 030f 	add.w	r3, r3, #15
 800888e:	781b      	ldrb	r3, [r3, #0]
 8008890:	2b00      	cmp	r3, #0
 8008892:	d005      	beq.n	80088a0 <start_output_mjpeg_avi+0x110>
 8008894:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008898:	f103 030f 	add.w	r3, r3, #15
 800889c:	781b      	ldrb	r3, [r3, #0]
 800889e:	e2c5      	b.n	8008e2c <start_output_mjpeg_avi+0x69c>

	 if (output_avi_header(file, fps, width, height) != FR_OK)  //default fps = 15
 80088a0:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80088a4:	f103 0358 	add.w	r3, r3, #88	@ 0x58
 80088a8:	881b      	ldrh	r3, [r3, #0]
 80088aa:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80088ae:	f102 025a 	add.w	r2, r2, #90	@ 0x5a
 80088b2:	8812      	ldrh	r2, [r2, #0]
 80088b4:	f107 0190 	add.w	r1, r7, #144	@ 0x90
 80088b8:	f811 1c89 	ldrb.w	r1, [r1, #-137]
 80088bc:	f107 0090 	add.w	r0, r7, #144	@ 0x90
 80088c0:	f850 0c84 	ldr.w	r0, [r0, #-132]
 80088c4:	f7ff fc42 	bl	800814c <output_avi_header>
 80088c8:	4603      	mov	r3, r0
 80088ca:	2b00      	cmp	r3, #0
 80088cc:	d005      	beq.n	80088da <start_output_mjpeg_avi+0x14a>
		return res;
 80088ce:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80088d2:	f103 030f 	add.w	r3, r3, #15
 80088d6:	781b      	ldrb	r3, [r3, #0]
 80088d8:	e2a8      	b.n	8008e2c <start_output_mjpeg_avi+0x69c>

	totalLen=0;
 80088da:	4b53      	ldr	r3, [pc, #332]	@ (8008a28 <start_output_mjpeg_avi+0x298>)
 80088dc:	2200      	movs	r2, #0
 80088de:	601a      	str	r2, [r3, #0]
	frames=0;
 80088e0:	4b52      	ldr	r3, [pc, #328]	@ (8008a2c <start_output_mjpeg_avi+0x29c>)
 80088e2:	2200      	movs	r2, #0
 80088e4:	601a      	str	r2, [r3, #0]

	next_idx1_offset=4;
 80088e6:	2304      	movs	r3, #4
 80088e8:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80088ec:	f102 0208 	add.w	r2, r2, #8
 80088f0:	6013      	str	r3, [r2, #0]
	lastSuccessTick = HAL_GetTick();
 80088f2:	f7f9 f96b 	bl	8001bcc <HAL_GetTick>
 80088f6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80088fa:	f103 036c 	add.w	r3, r3, #108	@ 0x6c
 80088fe:	6018      	str	r0, [r3, #0]
	while(bAviStartRecording == AVI_START)
 8008900:	e27a      	b.n	8008df8 <start_output_mjpeg_avi+0x668>
	{
		memset(dmabuff,0, MAX_AVI_BUFF);
 8008902:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008906:	3b70      	subs	r3, #112	@ 0x70
 8008908:	f44f 42a0 	mov.w	r2, #20480	@ 0x5000
 800890c:	2100      	movs	r1, #0
 800890e:	4618      	mov	r0, r3
 8008910:	f024 ff6f 	bl	802d7f2 <memset>
		headerFinder=0;
 8008914:	2300      	movs	r3, #0
 8008916:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 800891a:	f102 027b 	add.w	r2, r2, #123	@ 0x7b
 800891e:	7013      	strb	r3, [r2, #0]
		//if (frame_ok 0)
		if (frame_ok && adjTime  == 0)
 8008920:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008924:	f103 0373 	add.w	r3, r3, #115	@ 0x73
 8008928:	781b      	ldrb	r3, [r3, #0]
 800892a:	2b00      	cmp	r3, #0
 800892c:	d026      	beq.n	800897c <start_output_mjpeg_avi+0x1ec>
 800892e:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008932:	f103 0369 	add.w	r3, r3, #105	@ 0x69
 8008936:	781b      	ldrb	r3, [r3, #0]
 8008938:	2b00      	cmp	r3, #0
 800893a:	d11f      	bne.n	800897c <start_output_mjpeg_avi+0x1ec>
		{
			time_diff = HAL_GetTick()-lastSuccessTick;
 800893c:	f7f9 f946 	bl	8001bcc <HAL_GetTick>
 8008940:	4602      	mov	r2, r0
 8008942:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008946:	f103 036c 	add.w	r3, r3, #108	@ 0x6c
 800894a:	681b      	ldr	r3, [r3, #0]
 800894c:	1ad3      	subs	r3, r2, r3
 800894e:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008952:	f102 025c 	add.w	r2, r2, #92	@ 0x5c
 8008956:	6013      	str	r3, [r2, #0]

			//if (1000/fps > time_diff && time_diff > 0)
			if (1000 > time_diff)
 8008958:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 800895c:	f103 035c 	add.w	r3, r3, #92	@ 0x5c
 8008960:	681b      	ldr	r3, [r3, #0]
 8008962:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8008966:	da09      	bge.n	800897c <start_output_mjpeg_avi+0x1ec>
				HAL_Delay(1000 - time_diff);
 8008968:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 800896c:	f103 035c 	add.w	r3, r3, #92	@ 0x5c
 8008970:	681b      	ldr	r3, [r3, #0]
 8008972:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8008976:	4618      	mov	r0, r3
 8008978:	f7f9 f934 	bl	8001be4 <HAL_Delay>
		}

		beginTick = HAL_GetTick();
 800897c:	f7f9 f926 	bl	8001bcc <HAL_GetTick>
 8008980:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008984:	f103 0354 	add.w	r3, r3, #84	@ 0x54
 8008988:	6018      	str	r0, [r3, #0]

		HAL_DCMI_Start_DMA(hdcmi, DCMI_MODE_SNAPSHOT, ((uint32_t)dmabuff), MAX_AVI_BUFF/4);
 800898a:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 800898e:	3a70      	subs	r2, #112	@ 0x70
 8008990:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008994:	4618      	mov	r0, r3
 8008996:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 800899a:	2102      	movs	r1, #2
 800899c:	f850 0c88 	ldr.w	r0, [r0, #-136]
 80089a0:	f7f9 fa56 	bl	8001e50 <HAL_DCMI_Start_DMA>

		timeout=0;
 80089a4:	2300      	movs	r3, #0
 80089a6:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80089aa:	f102 026a 	add.w	r2, r2, #106	@ 0x6a
 80089ae:	8013      	strh	r3, [r2, #0]
		while((hdcmi->Instance->CR.reg & 0x03) == 3)
 80089b0:	e015      	b.n	80089de <start_output_mjpeg_avi+0x24e>
		{
			if (timeout > 1000)
 80089b2:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80089b6:	f103 036a 	add.w	r3, r3, #106	@ 0x6a
 80089ba:	881b      	ldrh	r3, [r3, #0]
 80089bc:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80089c0:	d818      	bhi.n	80089f4 <start_output_mjpeg_avi+0x264>
			{
				break; //max timeout: 1 seconds
			}
			HAL_Delay(1);
 80089c2:	2001      	movs	r0, #1
 80089c4:	f7f9 f90e 	bl	8001be4 <HAL_Delay>
			timeout++;
 80089c8:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80089cc:	f103 036a 	add.w	r3, r3, #106	@ 0x6a
 80089d0:	881b      	ldrh	r3, [r3, #0]
 80089d2:	3301      	adds	r3, #1
 80089d4:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 80089d8:	f102 026a 	add.w	r2, r2, #106	@ 0x6a
 80089dc:	8013      	strh	r3, [r2, #0]
		while((hdcmi->Instance->CR.reg & 0x03) == 3)
 80089de:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 80089e2:	f853 3c88 	ldr.w	r3, [r3, #-136]
 80089e6:	681b      	ldr	r3, [r3, #0]
 80089e8:	681b      	ldr	r3, [r3, #0]
 80089ea:	f003 0303 	and.w	r3, r3, #3
 80089ee:	2b03      	cmp	r3, #3
 80089f0:	d0df      	beq.n	80089b2 <start_output_mjpeg_avi+0x222>
 80089f2:	e000      	b.n	80089f6 <start_output_mjpeg_avi+0x266>
				break; //max timeout: 1 seconds
 80089f4:	bf00      	nop
		}
		if(timeout <= 1000)
 80089f6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80089fa:	f103 036a 	add.w	r3, r3, #106	@ 0x6a
 80089fe:	881b      	ldrh	r3, [r3, #0]
 8008a00:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8008a04:	f200 81f8 	bhi.w	8008df8 <start_output_mjpeg_avi+0x668>
		{
			frame_ok=0;
 8008a08:	2300      	movs	r3, #0
 8008a0a:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008a0e:	f102 0273 	add.w	r2, r2, #115	@ 0x73
 8008a12:	7013      	strb	r3, [r2, #0]
			for (idx = 0; idx<MAX_AVI_BUFF-4;idx++)
 8008a14:	2300      	movs	r3, #0
 8008a16:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008a1a:	6013      	str	r3, [r2, #0]
 8008a1c:	e1e4      	b.n	8008de8 <start_output_mjpeg_avi+0x658>
 8008a1e:	bf00      	nop
 8008a20:	200028da 	.word	0x200028da
 8008a24:	0802e75c 	.word	0x0802e75c
 8008a28:	200028dc 	.word	0x200028dc
 8008a2c:	200028e0 	.word	0x200028e0
			{
				if (headerFinder == 0 && dmabuff[idx] == 0xff && dmabuff[idx+1]==0xD8)
 8008a30:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008a34:	f103 037b 	add.w	r3, r3, #123	@ 0x7b
 8008a38:	781b      	ldrb	r3, [r3, #0]
 8008a3a:	2b00      	cmp	r3, #0
 8008a3c:	d123      	bne.n	8008a86 <start_output_mjpeg_avi+0x2f6>
 8008a3e:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008a42:	461a      	mov	r2, r3
 8008a44:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a48:	681b      	ldr	r3, [r3, #0]
 8008a4a:	4413      	add	r3, r2
 8008a4c:	3b70      	subs	r3, #112	@ 0x70
 8008a4e:	781b      	ldrb	r3, [r3, #0]
 8008a50:	2bff      	cmp	r3, #255	@ 0xff
 8008a52:	d118      	bne.n	8008a86 <start_output_mjpeg_avi+0x2f6>
 8008a54:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a58:	681b      	ldr	r3, [r3, #0]
 8008a5a:	3301      	adds	r3, #1
 8008a5c:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008a60:	4413      	add	r3, r2
 8008a62:	f813 3c70 	ldrb.w	r3, [r3, #-112]
 8008a66:	2bd8      	cmp	r3, #216	@ 0xd8
 8008a68:	d10d      	bne.n	8008a86 <start_output_mjpeg_avi+0x2f6>
				{
					headerFinder=1;
 8008a6a:	2301      	movs	r3, #1
 8008a6c:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008a70:	f102 027b 	add.w	r2, r2, #123	@ 0x7b
 8008a74:	7013      	strb	r3, [r2, #0]
					f_begin=idx;
 8008a76:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a7a:	681b      	ldr	r3, [r3, #0]
 8008a7c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008a80:	f102 0206 	add.w	r2, r2, #6
 8008a84:	8013      	strh	r3, [r2, #0]
				}
				if (headerFinder==1 && dmabuff[idx]== 0xFF && dmabuff[idx+1] == 0xD9 )
 8008a86:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008a8a:	f103 037b 	add.w	r3, r3, #123	@ 0x7b
 8008a8e:	781b      	ldrb	r3, [r3, #0]
 8008a90:	2b01      	cmp	r3, #1
 8008a92:	f040 81a2 	bne.w	8008dda <start_output_mjpeg_avi+0x64a>
 8008a96:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008a9a:	461a      	mov	r2, r3
 8008a9c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008aa0:	681b      	ldr	r3, [r3, #0]
 8008aa2:	4413      	add	r3, r2
 8008aa4:	3b70      	subs	r3, #112	@ 0x70
 8008aa6:	781b      	ldrb	r3, [r3, #0]
 8008aa8:	2bff      	cmp	r3, #255	@ 0xff
 8008aaa:	f040 8196 	bne.w	8008dda <start_output_mjpeg_avi+0x64a>
 8008aae:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008ab2:	681b      	ldr	r3, [r3, #0]
 8008ab4:	3301      	adds	r3, #1
 8008ab6:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008aba:	4413      	add	r3, r2
 8008abc:	f813 3c70 	ldrb.w	r3, [r3, #-112]
 8008ac0:	2bd9      	cmp	r3, #217	@ 0xd9
 8008ac2:	f040 818a 	bne.w	8008dda <start_output_mjpeg_avi+0x64a>
				{
					if (adjTime == 0) // 1 sec
 8008ac6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008aca:	f103 0369 	add.w	r3, r3, #105	@ 0x69
 8008ace:	781b      	ldrb	r3, [r3, #0]
 8008ad0:	2b00      	cmp	r3, #0
 8008ad2:	d109      	bne.n	8008ae8 <start_output_mjpeg_avi+0x358>
						lastSuccessTick=beginTick;
 8008ad4:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ad8:	f103 0354 	add.w	r3, r3, #84	@ 0x54
 8008adc:	681b      	ldr	r3, [r3, #0]
 8008ade:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008ae2:	f102 026c 	add.w	r2, r2, #108	@ 0x6c
 8008ae6:	6013      	str	r3, [r2, #0]

					adjTime = (adjTime+1)%fps; // 1 sec
 8008ae8:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008aec:	f103 0369 	add.w	r3, r3, #105	@ 0x69
 8008af0:	781b      	ldrb	r3, [r3, #0]
 8008af2:	3301      	adds	r3, #1
 8008af4:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008af8:	f812 2c89 	ldrb.w	r2, [r2, #-137]
 8008afc:	fb93 f1f2 	sdiv	r1, r3, r2
 8008b00:	fb01 f202 	mul.w	r2, r1, r2
 8008b04:	1a9b      	subs	r3, r3, r2
 8008b06:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b0a:	f102 0269 	add.w	r2, r2, #105	@ 0x69
 8008b0e:	7013      	strb	r3, [r2, #0]

					frame_ok=1;
 8008b10:	2301      	movs	r3, #1
 8008b12:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b16:	f102 0273 	add.w	r2, r2, #115	@ 0x73
 8008b1a:	7013      	strb	r3, [r2, #0]
					headerFinder=0;
 8008b1c:	2300      	movs	r3, #0
 8008b1e:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b22:	f102 027b 	add.w	r2, r2, #123	@ 0x7b
 8008b26:	7013      	strb	r3, [r2, #0]
					f_end = idx+1;
 8008b28:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b2c:	681b      	ldr	r3, [r3, #0]
 8008b2e:	3301      	adds	r3, #1
 8008b30:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b34:	f102 0260 	add.w	r2, r2, #96	@ 0x60
 8008b38:	6013      	str	r3, [r2, #0]

					buff = dmabuff + f_begin;
 8008b3a:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b3e:	f103 0306 	add.w	r3, r3, #6
 8008b42:	881a      	ldrh	r2, [r3, #0]
 8008b44:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008b48:	3b70      	subs	r3, #112	@ 0x70
 8008b4a:	4413      	add	r3, r2
 8008b4c:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b50:	f102 0274 	add.w	r2, r2, #116	@ 0x74
 8008b54:	6013      	str	r3, [r2, #0]

					data.dwFourCC = '00db';
 8008b56:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008b5a:	461a      	mov	r2, r3
 8008b5c:	4bb6      	ldr	r3, [pc, #728]	@ (8008e38 <start_output_mjpeg_avi+0x6a8>)
 8008b5e:	f842 3c7c 	str.w	r3, [r2, #-124]
					f_write(file, "00db", 4, &bw);
 8008b62:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008b66:	3b74      	subs	r3, #116	@ 0x74
 8008b68:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008b6c:	4610      	mov	r0, r2
 8008b6e:	2204      	movs	r2, #4
 8008b70:	49b2      	ldr	r1, [pc, #712]	@ (8008e3c <start_output_mjpeg_avi+0x6ac>)
 8008b72:	f850 0c84 	ldr.w	r0, [r0, #-132]
 8008b76:	f007 f924 	bl	800fdc2 <f_write>
					sublen = f_end-f_begin+1;
 8008b7a:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b7e:	f103 0306 	add.w	r3, r3, #6
 8008b82:	881b      	ldrh	r3, [r3, #0]
 8008b84:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b88:	f102 0260 	add.w	r2, r2, #96	@ 0x60
 8008b8c:	6812      	ldr	r2, [r2, #0]
 8008b8e:	1ad3      	subs	r3, r2, r3
 8008b90:	3301      	adds	r3, #1
 8008b92:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008b96:	f102 027c 	add.w	r2, r2, #124	@ 0x7c
 8008b9a:	6013      	str	r3, [r2, #0]

					data.dwSize = sublen;
 8008b9c:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008ba0:	461a      	mov	r2, r3
 8008ba2:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ba6:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008baa:	681b      	ldr	r3, [r3, #0]
 8008bac:	f842 3c78 	str.w	r3, [r2, #-120]
					fwrite_DWORD(file, data.dwSize);
 8008bb0:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008bb4:	f853 3c78 	ldr.w	r3, [r3, #-120]
 8008bb8:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008bbc:	4619      	mov	r1, r3
 8008bbe:	f852 0c84 	ldr.w	r0, [r2, #-132]
 8008bc2:	f7ff f9d7 	bl	8007f74 <fwrite_DWORD>
					f = sublen / 512;
 8008bc6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008bca:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008bce:	681b      	ldr	r3, [r3, #0]
 8008bd0:	0a5b      	lsrs	r3, r3, #9
 8008bd2:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008bd6:	f102 0252 	add.w	r2, r2, #82	@ 0x52
 8008bda:	8013      	strh	r3, [r2, #0]
					r = sublen % 512;
 8008bdc:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008be0:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008be4:	681b      	ldr	r3, [r3, #0]
 8008be6:	b29b      	uxth	r3, r3
 8008be8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008bec:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008bf0:	f102 0250 	add.w	r2, r2, #80	@ 0x50
 8008bf4:	8013      	strh	r3, [r2, #0]
					for (int i = 0; i < f; i++)
 8008bf6:	2300      	movs	r3, #0
 8008bf8:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008bfc:	f102 0264 	add.w	r2, r2, #100	@ 0x64
 8008c00:	6013      	str	r3, [r2, #0]
 8008c02:	e02d      	b.n	8008c60 <start_output_mjpeg_avi+0x4d0>
					{
						res=f_write(file, buff, 512, &bw);
 8008c04:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008c08:	3b74      	subs	r3, #116	@ 0x74
 8008c0a:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008c0e:	4610      	mov	r0, r2
 8008c10:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008c14:	f507 41c0 	add.w	r1, r7, #24576	@ 0x6000
 8008c18:	f101 0174 	add.w	r1, r1, #116	@ 0x74
 8008c1c:	6809      	ldr	r1, [r1, #0]
 8008c1e:	f850 0c84 	ldr.w	r0, [r0, #-132]
 8008c22:	f007 f8ce 	bl	800fdc2 <f_write>
 8008c26:	4603      	mov	r3, r0
 8008c28:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008c2c:	f102 020f 	add.w	r2, r2, #15
 8008c30:	7013      	strb	r3, [r2, #0]
						buff += 512;
 8008c32:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008c36:	f103 0374 	add.w	r3, r3, #116	@ 0x74
 8008c3a:	681b      	ldr	r3, [r3, #0]
 8008c3c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8008c40:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008c44:	f102 0274 	add.w	r2, r2, #116	@ 0x74
 8008c48:	6013      	str	r3, [r2, #0]
					for (int i = 0; i < f; i++)
 8008c4a:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008c4e:	f103 0364 	add.w	r3, r3, #100	@ 0x64
 8008c52:	681b      	ldr	r3, [r3, #0]
 8008c54:	3301      	adds	r3, #1
 8008c56:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008c5a:	f102 0264 	add.w	r2, r2, #100	@ 0x64
 8008c5e:	6013      	str	r3, [r2, #0]
 8008c60:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008c64:	f103 0352 	add.w	r3, r3, #82	@ 0x52
 8008c68:	881b      	ldrh	r3, [r3, #0]
 8008c6a:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008c6e:	f102 0264 	add.w	r2, r2, #100	@ 0x64
 8008c72:	6812      	ldr	r2, [r2, #0]
 8008c74:	429a      	cmp	r2, r3
 8008c76:	dbc5      	blt.n	8008c04 <start_output_mjpeg_avi+0x474>
					}

					if (r > 0)
 8008c78:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008c7c:	f103 0350 	add.w	r3, r3, #80	@ 0x50
 8008c80:	881b      	ldrh	r3, [r3, #0]
 8008c82:	2b00      	cmp	r3, #0
 8008c84:	d019      	beq.n	8008cba <start_output_mjpeg_avi+0x52a>
					{
						res=f_write(file, buff, r, &bw);
 8008c86:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008c8a:	f103 0350 	add.w	r3, r3, #80	@ 0x50
 8008c8e:	881a      	ldrh	r2, [r3, #0]
 8008c90:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008c94:	3b74      	subs	r3, #116	@ 0x74
 8008c96:	f107 0190 	add.w	r1, r7, #144	@ 0x90
 8008c9a:	4608      	mov	r0, r1
 8008c9c:	f507 41c0 	add.w	r1, r7, #24576	@ 0x6000
 8008ca0:	f101 0174 	add.w	r1, r1, #116	@ 0x74
 8008ca4:	6809      	ldr	r1, [r1, #0]
 8008ca6:	f850 0c84 	ldr.w	r0, [r0, #-132]
 8008caa:	f007 f88a 	bl	800fdc2 <f_write>
 8008cae:	4603      	mov	r3, r0
 8008cb0:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008cb4:	f102 020f 	add.w	r2, r2, #15
 8008cb8:	7013      	strb	r3, [r2, #0]

					}

					buff = dmabuff + f_begin;
 8008cba:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008cbe:	f103 0306 	add.w	r3, r3, #6
 8008cc2:	881a      	ldrh	r2, [r3, #0]
 8008cc4:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008cc8:	3b70      	subs	r3, #112	@ 0x70
 8008cca:	4413      	add	r3, r2
 8008ccc:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008cd0:	f102 0274 	add.w	r2, r2, #116	@ 0x74
 8008cd4:	6013      	str	r3, [r2, #0]

					decode_jpeg_to_tft(buff, sublen);
 8008cd6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008cda:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008cde:	6819      	ldr	r1, [r3, #0]
 8008ce0:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ce4:	f103 0374 	add.w	r3, r3, #116	@ 0x74
 8008ce8:	6818      	ldr	r0, [r3, #0]
 8008cea:	f7ff f987 	bl	8007ffc <decode_jpeg_to_tft>

					if (sublen%2)
 8008cee:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008cf2:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008cf6:	681b      	ldr	r3, [r3, #0]
 8008cf8:	f003 0301 	and.w	r3, r3, #1
 8008cfc:	2b00      	cmp	r3, #0
 8008cfe:	d01c      	beq.n	8008d3a <start_output_mjpeg_avi+0x5aa>
					{
						sublen++;
 8008d00:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008d04:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008d08:	681b      	ldr	r3, [r3, #0]
 8008d0a:	3301      	adds	r3, #1
 8008d0c:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008d10:	f102 027c 	add.w	r2, r2, #124	@ 0x7c
 8008d14:	6013      	str	r3, [r2, #0]
						res=f_write(file, '\0', 1, &bw);
 8008d16:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008d1a:	3b74      	subs	r3, #116	@ 0x74
 8008d1c:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008d20:	4610      	mov	r0, r2
 8008d22:	2201      	movs	r2, #1
 8008d24:	2100      	movs	r1, #0
 8008d26:	f850 0c84 	ldr.w	r0, [r0, #-132]
 8008d2a:	f007 f84a 	bl	800fdc2 <f_write>
 8008d2e:	4603      	mov	r3, r0
 8008d30:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008d34:	f102 020f 	add.w	r2, r2, #15
 8008d38:	7013      	strb	r3, [r2, #0]
					}
					frames++;
 8008d3a:	4b41      	ldr	r3, [pc, #260]	@ (8008e40 <start_output_mjpeg_avi+0x6b0>)
 8008d3c:	681b      	ldr	r3, [r3, #0]
 8008d3e:	3301      	adds	r3, #1
 8008d40:	4a3f      	ldr	r2, [pc, #252]	@ (8008e40 <start_output_mjpeg_avi+0x6b0>)
 8008d42:	6013      	str	r3, [r2, #0]
					totalLen += (sublen);
 8008d44:	4b3f      	ldr	r3, [pc, #252]	@ (8008e44 <start_output_mjpeg_avi+0x6b4>)
 8008d46:	681a      	ldr	r2, [r3, #0]
 8008d48:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008d4c:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008d50:	681b      	ldr	r3, [r3, #0]
 8008d52:	4413      	add	r3, r2
 8008d54:	4a3b      	ldr	r2, [pc, #236]	@ (8008e44 <start_output_mjpeg_avi+0x6b4>)
 8008d56:	6013      	str	r3, [r2, #0]
					f_write(&temp_idx1, "00db", 4, &bw);
 8008d58:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8008d5c:	3b74      	subs	r3, #116	@ 0x74
 8008d5e:	f507 40a0 	add.w	r0, r7, #20480	@ 0x5000
 8008d62:	f100 0030 	add.w	r0, r0, #48	@ 0x30
 8008d66:	3810      	subs	r0, #16
 8008d68:	2204      	movs	r2, #4
 8008d6a:	4934      	ldr	r1, [pc, #208]	@ (8008e3c <start_output_mjpeg_avi+0x6ac>)
 8008d6c:	f007 f829 	bl	800fdc2 <f_write>
					fwrite_DWORD(&temp_idx1, 16);//AVI_KEYFRAME=16
 8008d70:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008d74:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8008d78:	3b10      	subs	r3, #16
 8008d7a:	2110      	movs	r1, #16
 8008d7c:	4618      	mov	r0, r3
 8008d7e:	f7ff f8f9 	bl	8007f74 <fwrite_DWORD>
					fwrite_DWORD(&temp_idx1, next_idx1_offset);
 8008d82:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008d86:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8008d8a:	3b10      	subs	r3, #16
 8008d8c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008d90:	f102 0208 	add.w	r2, r2, #8
 8008d94:	6811      	ldr	r1, [r2, #0]
 8008d96:	4618      	mov	r0, r3
 8008d98:	f7ff f8ec 	bl	8007f74 <fwrite_DWORD>
					fwrite_DWORD(&temp_idx1, sublen);
 8008d9c:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008da0:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8008da4:	3b10      	subs	r3, #16
 8008da6:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008daa:	f102 027c 	add.w	r2, r2, #124	@ 0x7c
 8008dae:	6811      	ldr	r1, [r2, #0]
 8008db0:	4618      	mov	r0, r3
 8008db2:	f7ff f8df 	bl	8007f74 <fwrite_DWORD>
					next_idx1_offset += (8+sublen);
 8008db6:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008dba:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008dbe:	681a      	ldr	r2, [r3, #0]
 8008dc0:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008dc4:	f103 0308 	add.w	r3, r3, #8
 8008dc8:	681b      	ldr	r3, [r3, #0]
 8008dca:	4413      	add	r3, r2
 8008dcc:	3308      	adds	r3, #8
 8008dce:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008dd2:	f102 0208 	add.w	r2, r2, #8
 8008dd6:	6013      	str	r3, [r2, #0]

					break;
 8008dd8:	e00e      	b.n	8008df8 <start_output_mjpeg_avi+0x668>
			for (idx = 0; idx<MAX_AVI_BUFF-4;idx++)
 8008dda:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008dde:	681b      	ldr	r3, [r3, #0]
 8008de0:	3301      	adds	r3, #1
 8008de2:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008de6:	6013      	str	r3, [r2, #0]
 8008de8:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008dec:	681b      	ldr	r3, [r3, #0]
 8008dee:	f644 72fb 	movw	r2, #20475	@ 0x4ffb
 8008df2:	4293      	cmp	r3, r2
 8008df4:	f67f ae1c 	bls.w	8008a30 <start_output_mjpeg_avi+0x2a0>
	while(bAviStartRecording == AVI_START)
 8008df8:	4b13      	ldr	r3, [pc, #76]	@ (8008e48 <start_output_mjpeg_avi+0x6b8>)
 8008dfa:	781b      	ldrb	r3, [r3, #0]
 8008dfc:	2b01      	cmp	r3, #1
 8008dfe:	f43f ad80 	beq.w	8008902 <start_output_mjpeg_avi+0x172>

			}

		}
	}
	if (bAviStartRecording == AVI_PENDING)
 8008e02:	4b11      	ldr	r3, [pc, #68]	@ (8008e48 <start_output_mjpeg_avi+0x6b8>)
 8008e04:	781b      	ldrb	r3, [r3, #0]
 8008e06:	2b02      	cmp	r3, #2
 8008e08:	d10b      	bne.n	8008e22 <start_output_mjpeg_avi+0x692>
	{
		stop_output_mjpeg_avi(file, &temp_idx1);
 8008e0a:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008e0e:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8008e12:	3b10      	subs	r3, #16
 8008e14:	f107 0290 	add.w	r2, r7, #144	@ 0x90
 8008e18:	4619      	mov	r1, r3
 8008e1a:	f852 0c84 	ldr.w	r0, [r2, #-132]
 8008e1e:	f000 f815 	bl	8008e4c <stop_output_mjpeg_avi>
	}
	//bAviStartRecording = AVI_PENDING; //wait for rewriting some parameters and to close file;

	return res;
 8008e22:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008e26:	f103 030f 	add.w	r3, r3, #15
 8008e2a:	781b      	ldrb	r3, [r3, #0]
}
 8008e2c:	4618      	mov	r0, r3
 8008e2e:	f507 47c1 	add.w	r7, r7, #24704	@ 0x6080
 8008e32:	3714      	adds	r7, #20
 8008e34:	46bd      	mov	sp, r7
 8008e36:	bd90      	pop	{r4, r7, pc}
 8008e38:	30306462 	.word	0x30306462
 8008e3c:	0802e76c 	.word	0x0802e76c
 8008e40:	200028e0 	.word	0x200028e0
 8008e44:	200028dc 	.word	0x200028dc
 8008e48:	200028da 	.word	0x200028da

08008e4c <stop_output_mjpeg_avi>:
void stop_output_mjpeg_avi(FIL *file, FIL* temp_idx1)
{
 8008e4c:	b580      	push	{r7, lr}
 8008e4e:	f5ad 7d06 	sub.w	sp, sp, #536	@ 0x218
 8008e52:	af00      	add	r7, sp, #0
 8008e54:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e58:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e5c:	6018      	str	r0, [r3, #0]
 8008e5e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e62:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008e66:	6019      	str	r1, [r3, #0]
	UINT br;
	UINT bw;
	unsigned char buf[512];
	if (bAviStartRecording != AVI_PENDING) return;
 8008e68:	4b6c      	ldr	r3, [pc, #432]	@ (800901c <stop_output_mjpeg_avi+0x1d0>)
 8008e6a:	781b      	ldrb	r3, [r3, #0]
 8008e6c:	2b02      	cmp	r3, #2
 8008e6e:	f040 80d0 	bne.w	8009012 <stop_output_mjpeg_avi+0x1c6>

	f_write(file, "idx1", 4, &br);
 8008e72:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8008e76:	f507 7206 	add.w	r2, r7, #536	@ 0x218
 8008e7a:	f5a2 7005 	sub.w	r0, r2, #532	@ 0x214
 8008e7e:	2204      	movs	r2, #4
 8008e80:	4967      	ldr	r1, [pc, #412]	@ (8009020 <stop_output_mjpeg_avi+0x1d4>)
 8008e82:	6800      	ldr	r0, [r0, #0]
 8008e84:	f006 ff9d 	bl	800fdc2 <f_write>
	fwrite_DWORD(file, 4*4*frames);
 8008e88:	4b66      	ldr	r3, [pc, #408]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008e8a:	681b      	ldr	r3, [r3, #0]
 8008e8c:	011a      	lsls	r2, r3, #4
 8008e8e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e92:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e96:	4611      	mov	r1, r2
 8008e98:	6818      	ldr	r0, [r3, #0]
 8008e9a:	f7ff f86b 	bl	8007f74 <fwrite_DWORD>
	f_lseek(temp_idx1, 0);
 8008e9e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008ea2:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008ea6:	2100      	movs	r1, #0
 8008ea8:	6818      	ldr	r0, [r3, #0]
 8008eaa:	f007 f9c6 	bl	801023a <f_lseek>
	do {
		f_read(temp_idx1, buf, 512, &br);
 8008eae:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8008eb2:	f107 010c 	add.w	r1, r7, #12
 8008eb6:	f507 7206 	add.w	r2, r7, #536	@ 0x218
 8008eba:	f5a2 7006 	sub.w	r0, r2, #536	@ 0x218
 8008ebe:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008ec2:	6800      	ldr	r0, [r0, #0]
 8008ec4:	f006 fe1e 	bl	800fb04 <f_read>
		f_write(file, buf, br, &bw);
 8008ec8:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8008ecc:	f507 7303 	add.w	r3, r7, #524	@ 0x20c
 8008ed0:	f107 010c 	add.w	r1, r7, #12
 8008ed4:	f507 7006 	add.w	r0, r7, #536	@ 0x218
 8008ed8:	f5a0 7005 	sub.w	r0, r0, #532	@ 0x214
 8008edc:	6800      	ldr	r0, [r0, #0]
 8008ede:	f006 ff70 	bl	800fdc2 <f_write>
	} while (br == 512);
 8008ee2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8008ee6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8008eea:	d0e0      	beq.n	8008eae <stop_output_mjpeg_avi+0x62>
	f_close(temp_idx1);
 8008eec:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008ef0:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008ef4:	6818      	ldr	r0, [r3, #0]
 8008ef6:	f007 f976 	bl	80101e6 <f_close>
	f_unlink("0:/temp_idx1");
 8008efa:	484b      	ldr	r0, [pc, #300]	@ (8009028 <stop_output_mjpeg_avi+0x1dc>)
 8008efc:	f007 fbc1 	bl	8010682 <f_unlink>
	DWORD size;

	//RIFF_LIST.dwSize =  150 + 12 + len + 8*frames + 8 + 4*4*frames;

	//size = 150 + 12 + totalLen + 8*frames + 8 + 4*4*frames(idx1);
	size = 150 + 12 + totalLen + 8*frames + 8 + 4*4*frames;
 8008f00:	4b48      	ldr	r3, [pc, #288]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008f02:	681b      	ldr	r3, [r3, #0]
 8008f04:	00da      	lsls	r2, r3, #3
 8008f06:	4b49      	ldr	r3, [pc, #292]	@ (800902c <stop_output_mjpeg_avi+0x1e0>)
 8008f08:	681b      	ldr	r3, [r3, #0]
 8008f0a:	441a      	add	r2, r3
 8008f0c:	4b45      	ldr	r3, [pc, #276]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008f0e:	681b      	ldr	r3, [r3, #0]
 8008f10:	011b      	lsls	r3, r3, #4
 8008f12:	4413      	add	r3, r2
 8008f14:	33aa      	adds	r3, #170	@ 0xaa
 8008f16:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 4);
 8008f1a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f1e:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f22:	2104      	movs	r1, #4
 8008f24:	6818      	ldr	r0, [r3, #0]
 8008f26:	f007 f988 	bl	801023a <f_lseek>
	fwrite_DWORD(file, size);
 8008f2a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f2e:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f32:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008f36:	6818      	ldr	r0, [r3, #0]
 8008f38:	f7ff f81c 	bl	8007f74 <fwrite_DWORD>

	//DWORD avih  totalframes = 0; nbr_of_jpgs;;
	size = frames;
 8008f3c:	4b39      	ldr	r3, [pc, #228]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008f3e:	681b      	ldr	r3, [r3, #0]
 8008f40:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 48);
 8008f44:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f48:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f4c:	2130      	movs	r1, #48	@ 0x30
 8008f4e:	6818      	ldr	r0, [r3, #0]
 8008f50:	f007 f973 	bl	801023a <f_lseek>
	fwrite_DWORD(file, size);//offset+4=48
 8008f54:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f58:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f5c:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008f60:	6818      	ldr	r0, [r3, #0]
 8008f62:	f7ff f807 	bl	8007f74 <fwrite_DWORD>

	//strh.dwLength = nbr_of_jpgs;  +4 = 36
	size=frames;
 8008f66:	4b2f      	ldr	r3, [pc, #188]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008f68:	681b      	ldr	r3, [r3, #0]
 8008f6a:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 140); //140
 8008f6e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f72:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f76:	218c      	movs	r1, #140	@ 0x8c
 8008f78:	6818      	ldr	r0, [r3, #0]
 8008f7a:	f007 f95e 	bl	801023a <f_lseek>
	fwrite_DWORD(file, size);
 8008f7e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f82:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008f86:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008f8a:	6818      	ldr	r0, [r3, #0]
 8008f8c:	f7fe fff2 	bl	8007f74 <fwrite_DWORD>


	//totalFrames(dmlh)
	size=frames;
 8008f90:	4b24      	ldr	r3, [pc, #144]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008f92:	681b      	ldr	r3, [r3, #0]
 8008f94:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 224); //140
 8008f98:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008f9c:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008fa0:	21e0      	movs	r1, #224	@ 0xe0
 8008fa2:	6818      	ldr	r0, [r3, #0]
 8008fa4:	f007 f949 	bl	801023a <f_lseek>
	fwrite_DWORD(file, size);
 8008fa8:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008fac:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008fb0:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008fb4:	6818      	ldr	r0, [r3, #0]
 8008fb6:	f7fe ffdd 	bl	8007f74 <fwrite_DWORD>


	//movi.dwSize = len + 4 + 8*nbr_of_jpgs;
	size = totalLen + 4 + 8*frames;
 8008fba:	4b1a      	ldr	r3, [pc, #104]	@ (8009024 <stop_output_mjpeg_avi+0x1d8>)
 8008fbc:	681b      	ldr	r3, [r3, #0]
 8008fbe:	00da      	lsls	r2, r3, #3
 8008fc0:	4b1a      	ldr	r3, [pc, #104]	@ (800902c <stop_output_mjpeg_avi+0x1e0>)
 8008fc2:	681b      	ldr	r3, [r3, #0]
 8008fc4:	4413      	add	r3, r2
 8008fc6:	3304      	adds	r3, #4
 8008fc8:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 232);
 8008fcc:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008fd0:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008fd4:	21e8      	movs	r1, #232	@ 0xe8
 8008fd6:	6818      	ldr	r0, [r3, #0]
 8008fd8:	f007 f92f 	bl	801023a <f_lseek>
	fwrite_DWORD(file, size);//offset+4=232
 8008fdc:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008fe0:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008fe4:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008fe8:	6818      	ldr	r0, [r3, #0]
 8008fea:	f7fe ffc3 	bl	8007f74 <fwrite_DWORD>
	f_close(temp_idx1);
 8008fee:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008ff2:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008ff6:	6818      	ldr	r0, [r3, #0]
 8008ff8:	f007 f8f5 	bl	80101e6 <f_close>
	f_close(file);
 8008ffc:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8009000:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8009004:	6818      	ldr	r0, [r3, #0]
 8009006:	f007 f8ee 	bl	80101e6 <f_close>
	bAviStartRecording = AVI_CLOSED_OUT;
 800900a:	4b04      	ldr	r3, [pc, #16]	@ (800901c <stop_output_mjpeg_avi+0x1d0>)
 800900c:	2203      	movs	r2, #3
 800900e:	701a      	strb	r2, [r3, #0]
 8009010:	e000      	b.n	8009014 <stop_output_mjpeg_avi+0x1c8>
	if (bAviStartRecording != AVI_PENDING) return;
 8009012:	bf00      	nop
}
 8009014:	f507 7706 	add.w	r7, r7, #536	@ 0x218
 8009018:	46bd      	mov	sp, r7
 800901a:	bd80      	pop	{r7, pc}
 800901c:	200028da 	.word	0x200028da
 8009020:	0802e774 	.word	0x0802e774
 8009024:	200028e0 	.word	0x200028e0
 8009028:	0802e75c 	.word	0x0802e75c
 800902c:	200028dc 	.word	0x200028dc

08009030 <CAMERA_IO_Write>:
				0x90 }, { 0x52, 0x2c }, { 0x53, 0x00 }, { 0x54, 0x00 }, { 0x55,
				0x88 }, { 0x57, 0x00 }, { 0x5a, 0x40 }, { 0x5b, 0xf0 }, { 0x5c,
				0x01 }, { 0xd3, 0x02 }, { 0xe0, 0x00 }, { 0xff, 0xff } };

void CAMERA_IO_Write(uint8_t deviceAddr, uint8_t reg, uint8_t value)
{
 8009030:	b580      	push	{r7, lr}
 8009032:	b084      	sub	sp, #16
 8009034:	af02      	add	r7, sp, #8
 8009036:	4603      	mov	r3, r0
 8009038:	71fb      	strb	r3, [r7, #7]
 800903a:	460b      	mov	r3, r1
 800903c:	71bb      	strb	r3, [r7, #6]
 800903e:	4613      	mov	r3, r2
 8009040:	717b      	strb	r3, [r7, #5]
	I2C_Mem_Write(&hi2c1, deviceAddr, reg, I2C_MEMADD_SIZE_8BIT, &value, 1);
 8009042:	79fb      	ldrb	r3, [r7, #7]
 8009044:	b299      	uxth	r1, r3
 8009046:	79bb      	ldrb	r3, [r7, #6]
 8009048:	b29a      	uxth	r2, r3
 800904a:	2301      	movs	r3, #1
 800904c:	9301      	str	r3, [sp, #4]
 800904e:	1d7b      	adds	r3, r7, #5
 8009050:	9300      	str	r3, [sp, #0]
 8009052:	2301      	movs	r3, #1
 8009054:	4803      	ldr	r0, [pc, #12]	@ (8009064 <CAMERA_IO_Write+0x34>)
 8009056:	f000 fe55 	bl	8009d04 <I2C_Mem_Write>
}
 800905a:	bf00      	nop
 800905c:	3708      	adds	r7, #8
 800905e:	46bd      	mov	sp, r7
 8009060:	bd80      	pop	{r7, pc}
 8009062:	bf00      	nop
 8009064:	20000144 	.word	0x20000144

08009068 <CAMERA_Delay>:
void CAMERA_Delay(uint32_t Delay)
{
 8009068:	b580      	push	{r7, lr}
 800906a:	b082      	sub	sp, #8
 800906c:	af00      	add	r7, sp, #0
 800906e:	6078      	str	r0, [r7, #4]
	HAL_Delay(Delay);
 8009070:	6878      	ldr	r0, [r7, #4]
 8009072:	f7f8 fdb7 	bl	8001be4 <HAL_Delay>
}
 8009076:	bf00      	nop
 8009078:	3708      	adds	r7, #8
 800907a:	46bd      	mov	sp, r7
 800907c:	bd80      	pop	{r7, pc}
	...

08009080 <ov2640_Init>:

void ov2640_Init(uint16_t DeviceAddr, uint8_t action)
{
 8009080:	b580      	push	{r7, lr}
 8009082:	b084      	sub	sp, #16
 8009084:	af00      	add	r7, sp, #0
 8009086:	4603      	mov	r3, r0
 8009088:	460a      	mov	r2, r1
 800908a:	80fb      	strh	r3, [r7, #6]
 800908c:	4613      	mov	r3, r2
 800908e:	717b      	strb	r3, [r7, #5]
  uint32_t index;

//hardware and software init
  GPIO_WritePin(CAMERA_PWDN_GPIO_Port, CAMERA_PWDN_Pin, RESET); //power on
 8009090:	2200      	movs	r2, #0
 8009092:	210c      	movs	r1, #12
 8009094:	4892      	ldr	r0, [pc, #584]	@ (80092e0 <ov2640_Init+0x260>)
 8009096:	f000 fbf9 	bl	800988c <GPIO_WritePin>
  delay_ms(1);
 800909a:	2001      	movs	r0, #1
 800909c:	f001 fae8 	bl	800a670 <delay_ms>
  GPIO_WritePin(CAMERA_RESET_GPIO_Port, CAMERA_RESET_Pin, RESET);  //hardware reset
 80090a0:	2200      	movs	r2, #0
 80090a2:	2100      	movs	r1, #0
 80090a4:	488f      	ldr	r0, [pc, #572]	@ (80092e4 <ov2640_Init+0x264>)
 80090a6:	f000 fbf1 	bl	800988c <GPIO_WritePin>
  delay_ms(1);
 80090aa:	2001      	movs	r0, #1
 80090ac:	f001 fae0 	bl	800a670 <delay_ms>
  GPIO_WritePin(CAMERA_RESET_GPIO_Port, CAMERA_RESET_Pin, SET);
 80090b0:	2201      	movs	r2, #1
 80090b2:	2100      	movs	r1, #0
 80090b4:	488b      	ldr	r0, [pc, #556]	@ (80092e4 <ov2640_Init+0x264>)
 80090b6:	f000 fbe9 	bl	800988c <GPIO_WritePin>
  delay_ms(1);
 80090ba:	2001      	movs	r0, #1
 80090bc:	f001 fad8 	bl	800a670 <delay_ms>

  /* Prepare the camera to be configured */
  CAMERA_IO_Write(DeviceAddr, 0xff, 0x01);
 80090c0:	88fb      	ldrh	r3, [r7, #6]
 80090c2:	b2db      	uxtb	r3, r3
 80090c4:	2201      	movs	r2, #1
 80090c6:	21ff      	movs	r1, #255	@ 0xff
 80090c8:	4618      	mov	r0, r3
 80090ca:	f7ff ffb1 	bl	8009030 <CAMERA_IO_Write>
  CAMERA_IO_Write(DeviceAddr, 0x12, 0x80);
 80090ce:	88fb      	ldrh	r3, [r7, #6]
 80090d0:	b2db      	uxtb	r3, r3
 80090d2:	2280      	movs	r2, #128	@ 0x80
 80090d4:	2112      	movs	r1, #18
 80090d6:	4618      	mov	r0, r3
 80090d8:	f7ff ffaa 	bl	8009030 <CAMERA_IO_Write>
  CAMERA_Delay(20);
 80090dc:	2014      	movs	r0, #20
 80090de:	f7ff ffc3 	bl	8009068 <CAMERA_Delay>

  /* Initialize OV2640 */
  switch (action)
 80090e2:	797b      	ldrb	r3, [r7, #5]
 80090e4:	2b03      	cmp	r3, #3
 80090e6:	f000 808c 	beq.w	8009202 <ov2640_Init+0x182>
 80090ea:	2b03      	cmp	r3, #3
 80090ec:	f300 80f2 	bgt.w	80092d4 <ov2640_Init+0x254>
 80090f0:	2b01      	cmp	r3, #1
 80090f2:	d06b      	beq.n	80091cc <ov2640_Init+0x14c>
 80090f4:	2b02      	cmp	r3, #2
 80090f6:	f040 80ed 	bne.w	80092d4 <ov2640_Init+0x254>
  {
  case CAMERA_Movie:
	  for(index=0; index<(sizeof(OV2640_JPEG_INIT)/2); index++)
 80090fa:	2300      	movs	r3, #0
 80090fc:	60fb      	str	r3, [r7, #12]
 80090fe:	e013      	b.n	8009128 <ov2640_Init+0xa8>
	  {
		  CAMERA_IO_Write(DeviceAddr, OV2640_JPEG_INIT[index][0], OV2640_JPEG_INIT[index][1]);
 8009100:	88fb      	ldrh	r3, [r7, #6]
 8009102:	b2d8      	uxtb	r0, r3
 8009104:	4a78      	ldr	r2, [pc, #480]	@ (80092e8 <ov2640_Init+0x268>)
 8009106:	68fb      	ldr	r3, [r7, #12]
 8009108:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 800910c:	4a76      	ldr	r2, [pc, #472]	@ (80092e8 <ov2640_Init+0x268>)
 800910e:	68fb      	ldr	r3, [r7, #12]
 8009110:	005b      	lsls	r3, r3, #1
 8009112:	4413      	add	r3, r2
 8009114:	785b      	ldrb	r3, [r3, #1]
 8009116:	461a      	mov	r2, r3
 8009118:	f7ff ff8a 	bl	8009030 <CAMERA_IO_Write>
		  CAMERA_Delay(1);
 800911c:	2001      	movs	r0, #1
 800911e:	f7ff ffa3 	bl	8009068 <CAMERA_Delay>
	  for(index=0; index<(sizeof(OV2640_JPEG_INIT)/2); index++)
 8009122:	68fb      	ldr	r3, [r7, #12]
 8009124:	3301      	adds	r3, #1
 8009126:	60fb      	str	r3, [r7, #12]
 8009128:	68fb      	ldr	r3, [r7, #12]
 800912a:	2bbe      	cmp	r3, #190	@ 0xbe
 800912c:	d9e8      	bls.n	8009100 <ov2640_Init+0x80>
	  }

	for(index=0; index<(sizeof(OV2640_YUV422)/2); index++)
 800912e:	2300      	movs	r3, #0
 8009130:	60fb      	str	r3, [r7, #12]
 8009132:	e013      	b.n	800915c <ov2640_Init+0xdc>
	{
		CAMERA_IO_Write(DeviceAddr, OV2640_YUV422[index][0], OV2640_YUV422[index][1]);
 8009134:	88fb      	ldrh	r3, [r7, #6]
 8009136:	b2d8      	uxtb	r0, r3
 8009138:	4a6c      	ldr	r2, [pc, #432]	@ (80092ec <ov2640_Init+0x26c>)
 800913a:	68fb      	ldr	r3, [r7, #12]
 800913c:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009140:	4a6a      	ldr	r2, [pc, #424]	@ (80092ec <ov2640_Init+0x26c>)
 8009142:	68fb      	ldr	r3, [r7, #12]
 8009144:	005b      	lsls	r3, r3, #1
 8009146:	4413      	add	r3, r2
 8009148:	785b      	ldrb	r3, [r3, #1]
 800914a:	461a      	mov	r2, r3
 800914c:	f7ff ff70 	bl	8009030 <CAMERA_IO_Write>
	  	CAMERA_Delay(1);
 8009150:	2001      	movs	r0, #1
 8009152:	f7ff ff89 	bl	8009068 <CAMERA_Delay>
	for(index=0; index<(sizeof(OV2640_YUV422)/2); index++)
 8009156:	68fb      	ldr	r3, [r7, #12]
 8009158:	3301      	adds	r3, #1
 800915a:	60fb      	str	r3, [r7, #12]
 800915c:	68fb      	ldr	r3, [r7, #12]
 800915e:	2b09      	cmp	r3, #9
 8009160:	d9e8      	bls.n	8009134 <ov2640_Init+0xb4>
	}

	for(index=0; index<(sizeof(OV2640_JPEG)/2); index++)
 8009162:	2300      	movs	r3, #0
 8009164:	60fb      	str	r3, [r7, #12]
 8009166:	e013      	b.n	8009190 <ov2640_Init+0x110>
	{
		CAMERA_IO_Write(DeviceAddr, OV2640_JPEG[index][0], OV2640_JPEG[index][1]);
 8009168:	88fb      	ldrh	r3, [r7, #6]
 800916a:	b2d8      	uxtb	r0, r3
 800916c:	4a60      	ldr	r2, [pc, #384]	@ (80092f0 <ov2640_Init+0x270>)
 800916e:	68fb      	ldr	r3, [r7, #12]
 8009170:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009174:	4a5e      	ldr	r2, [pc, #376]	@ (80092f0 <ov2640_Init+0x270>)
 8009176:	68fb      	ldr	r3, [r7, #12]
 8009178:	005b      	lsls	r3, r3, #1
 800917a:	4413      	add	r3, r2
 800917c:	785b      	ldrb	r3, [r3, #1]
 800917e:	461a      	mov	r2, r3
 8009180:	f7ff ff56 	bl	8009030 <CAMERA_IO_Write>
		CAMERA_Delay(1);
 8009184:	2001      	movs	r0, #1
 8009186:	f7ff ff6f 	bl	8009068 <CAMERA_Delay>
	for(index=0; index<(sizeof(OV2640_JPEG)/2); index++)
 800918a:	68fb      	ldr	r3, [r7, #12]
 800918c:	3301      	adds	r3, #1
 800918e:	60fb      	str	r3, [r7, #12]
 8009190:	68fb      	ldr	r3, [r7, #12]
 8009192:	2b08      	cmp	r3, #8
 8009194:	d9e8      	bls.n	8009168 <ov2640_Init+0xe8>
	}

	for(index=0; index<(sizeof(OV2640_320x240_JPEG)/2); index++)
 8009196:	2300      	movs	r3, #0
 8009198:	60fb      	str	r3, [r7, #12]
 800919a:	e013      	b.n	80091c4 <ov2640_Init+0x144>
	{
		CAMERA_IO_Write(DeviceAddr, OV2640_320x240_JPEG[index][0], OV2640_320x240_JPEG[index][1]);
 800919c:	88fb      	ldrh	r3, [r7, #6]
 800919e:	b2d8      	uxtb	r0, r3
 80091a0:	4a54      	ldr	r2, [pc, #336]	@ (80092f4 <ov2640_Init+0x274>)
 80091a2:	68fb      	ldr	r3, [r7, #12]
 80091a4:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 80091a8:	4a52      	ldr	r2, [pc, #328]	@ (80092f4 <ov2640_Init+0x274>)
 80091aa:	68fb      	ldr	r3, [r7, #12]
 80091ac:	005b      	lsls	r3, r3, #1
 80091ae:	4413      	add	r3, r2
 80091b0:	785b      	ldrb	r3, [r3, #1]
 80091b2:	461a      	mov	r2, r3
 80091b4:	f7ff ff3c 	bl	8009030 <CAMERA_IO_Write>
		CAMERA_Delay(1);
 80091b8:	2001      	movs	r0, #1
 80091ba:	f7ff ff55 	bl	8009068 <CAMERA_Delay>
	for(index=0; index<(sizeof(OV2640_320x240_JPEG)/2); index++)
 80091be:	68fb      	ldr	r3, [r7, #12]
 80091c0:	3301      	adds	r3, #1
 80091c2:	60fb      	str	r3, [r7, #12]
 80091c4:	68fb      	ldr	r3, [r7, #12]
 80091c6:	2b27      	cmp	r3, #39	@ 0x27
 80091c8:	d9e8      	bls.n	800919c <ov2640_Init+0x11c>
	}
	break;
 80091ca:	e084      	b.n	80092d6 <ov2640_Init+0x256>
  case CAMERA_Monitor:
    {
      for(index=0; index<(sizeof(OV2640_QVGA)/2); index++)
 80091cc:	2300      	movs	r3, #0
 80091ce:	60fb      	str	r3, [r7, #12]
 80091d0:	e013      	b.n	80091fa <ov2640_Init+0x17a>
      {
        CAMERA_IO_Write(DeviceAddr, OV2640_QVGA[index][0], OV2640_QVGA[index][1]);
 80091d2:	88fb      	ldrh	r3, [r7, #6]
 80091d4:	b2d8      	uxtb	r0, r3
 80091d6:	4a48      	ldr	r2, [pc, #288]	@ (80092f8 <ov2640_Init+0x278>)
 80091d8:	68fb      	ldr	r3, [r7, #12]
 80091da:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 80091de:	4a46      	ldr	r2, [pc, #280]	@ (80092f8 <ov2640_Init+0x278>)
 80091e0:	68fb      	ldr	r3, [r7, #12]
 80091e2:	005b      	lsls	r3, r3, #1
 80091e4:	4413      	add	r3, r2
 80091e6:	785b      	ldrb	r3, [r3, #1]
 80091e8:	461a      	mov	r2, r3
 80091ea:	f7ff ff21 	bl	8009030 <CAMERA_IO_Write>
        CAMERA_Delay(1);
 80091ee:	2001      	movs	r0, #1
 80091f0:	f7ff ff3a 	bl	8009068 <CAMERA_Delay>
      for(index=0; index<(sizeof(OV2640_QVGA)/2); index++)
 80091f4:	68fb      	ldr	r3, [r7, #12]
 80091f6:	3301      	adds	r3, #1
 80091f8:	60fb      	str	r3, [r7, #12]
 80091fa:	68fb      	ldr	r3, [r7, #12]
 80091fc:	2bda      	cmp	r3, #218	@ 0xda
 80091fe:	d9e8      	bls.n	80091d2 <ov2640_Init+0x152>
      }
      break;
 8009200:	e069      	b.n	80092d6 <ov2640_Init+0x256>
    }
  case CAMERA_Picture:
  	  for(index=0; index<(sizeof(OV2640_JPEG_INIT)/2); index++)
 8009202:	2300      	movs	r3, #0
 8009204:	60fb      	str	r3, [r7, #12]
 8009206:	e013      	b.n	8009230 <ov2640_Init+0x1b0>
  	  {
  		  CAMERA_IO_Write(DeviceAddr, OV2640_JPEG_INIT[index][0], OV2640_JPEG_INIT[index][1]);
 8009208:	88fb      	ldrh	r3, [r7, #6]
 800920a:	b2d8      	uxtb	r0, r3
 800920c:	4a36      	ldr	r2, [pc, #216]	@ (80092e8 <ov2640_Init+0x268>)
 800920e:	68fb      	ldr	r3, [r7, #12]
 8009210:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009214:	4a34      	ldr	r2, [pc, #208]	@ (80092e8 <ov2640_Init+0x268>)
 8009216:	68fb      	ldr	r3, [r7, #12]
 8009218:	005b      	lsls	r3, r3, #1
 800921a:	4413      	add	r3, r2
 800921c:	785b      	ldrb	r3, [r3, #1]
 800921e:	461a      	mov	r2, r3
 8009220:	f7ff ff06 	bl	8009030 <CAMERA_IO_Write>
  		  CAMERA_Delay(1);
 8009224:	2001      	movs	r0, #1
 8009226:	f7ff ff1f 	bl	8009068 <CAMERA_Delay>
  	  for(index=0; index<(sizeof(OV2640_JPEG_INIT)/2); index++)
 800922a:	68fb      	ldr	r3, [r7, #12]
 800922c:	3301      	adds	r3, #1
 800922e:	60fb      	str	r3, [r7, #12]
 8009230:	68fb      	ldr	r3, [r7, #12]
 8009232:	2bbe      	cmp	r3, #190	@ 0xbe
 8009234:	d9e8      	bls.n	8009208 <ov2640_Init+0x188>
  	  }

  	for(index=0; index<(sizeof(OV2640_YUV422)/2); index++)
 8009236:	2300      	movs	r3, #0
 8009238:	60fb      	str	r3, [r7, #12]
 800923a:	e013      	b.n	8009264 <ov2640_Init+0x1e4>
  	{
  		CAMERA_IO_Write(DeviceAddr, OV2640_YUV422[index][0], OV2640_YUV422[index][1]);
 800923c:	88fb      	ldrh	r3, [r7, #6]
 800923e:	b2d8      	uxtb	r0, r3
 8009240:	4a2a      	ldr	r2, [pc, #168]	@ (80092ec <ov2640_Init+0x26c>)
 8009242:	68fb      	ldr	r3, [r7, #12]
 8009244:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009248:	4a28      	ldr	r2, [pc, #160]	@ (80092ec <ov2640_Init+0x26c>)
 800924a:	68fb      	ldr	r3, [r7, #12]
 800924c:	005b      	lsls	r3, r3, #1
 800924e:	4413      	add	r3, r2
 8009250:	785b      	ldrb	r3, [r3, #1]
 8009252:	461a      	mov	r2, r3
 8009254:	f7ff feec 	bl	8009030 <CAMERA_IO_Write>
  	  	CAMERA_Delay(1);
 8009258:	2001      	movs	r0, #1
 800925a:	f7ff ff05 	bl	8009068 <CAMERA_Delay>
  	for(index=0; index<(sizeof(OV2640_YUV422)/2); index++)
 800925e:	68fb      	ldr	r3, [r7, #12]
 8009260:	3301      	adds	r3, #1
 8009262:	60fb      	str	r3, [r7, #12]
 8009264:	68fb      	ldr	r3, [r7, #12]
 8009266:	2b09      	cmp	r3, #9
 8009268:	d9e8      	bls.n	800923c <ov2640_Init+0x1bc>
  	}

  	for(index=0; index<(sizeof(OV2640_JPEG)/2); index++)
 800926a:	2300      	movs	r3, #0
 800926c:	60fb      	str	r3, [r7, #12]
 800926e:	e013      	b.n	8009298 <ov2640_Init+0x218>
  	{
  		CAMERA_IO_Write(DeviceAddr, OV2640_JPEG[index][0], OV2640_JPEG[index][1]);
 8009270:	88fb      	ldrh	r3, [r7, #6]
 8009272:	b2d8      	uxtb	r0, r3
 8009274:	4a1e      	ldr	r2, [pc, #120]	@ (80092f0 <ov2640_Init+0x270>)
 8009276:	68fb      	ldr	r3, [r7, #12]
 8009278:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 800927c:	4a1c      	ldr	r2, [pc, #112]	@ (80092f0 <ov2640_Init+0x270>)
 800927e:	68fb      	ldr	r3, [r7, #12]
 8009280:	005b      	lsls	r3, r3, #1
 8009282:	4413      	add	r3, r2
 8009284:	785b      	ldrb	r3, [r3, #1]
 8009286:	461a      	mov	r2, r3
 8009288:	f7ff fed2 	bl	8009030 <CAMERA_IO_Write>
  		CAMERA_Delay(1);
 800928c:	2001      	movs	r0, #1
 800928e:	f7ff feeb 	bl	8009068 <CAMERA_Delay>
  	for(index=0; index<(sizeof(OV2640_JPEG)/2); index++)
 8009292:	68fb      	ldr	r3, [r7, #12]
 8009294:	3301      	adds	r3, #1
 8009296:	60fb      	str	r3, [r7, #12]
 8009298:	68fb      	ldr	r3, [r7, #12]
 800929a:	2b08      	cmp	r3, #8
 800929c:	d9e8      	bls.n	8009270 <ov2640_Init+0x1f0>
  	}

  	for(index=0; index<(sizeof(OV2640_1280x960_JPEG)/2); index++)
 800929e:	2300      	movs	r3, #0
 80092a0:	60fb      	str	r3, [r7, #12]
 80092a2:	e013      	b.n	80092cc <ov2640_Init+0x24c>
  	{
  		CAMERA_IO_Write(DeviceAddr, OV2640_1280x960_JPEG[index][0], OV2640_1280x960_JPEG[index][1]);
 80092a4:	88fb      	ldrh	r3, [r7, #6]
 80092a6:	b2d8      	uxtb	r0, r3
 80092a8:	4a14      	ldr	r2, [pc, #80]	@ (80092fc <ov2640_Init+0x27c>)
 80092aa:	68fb      	ldr	r3, [r7, #12]
 80092ac:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 80092b0:	4a12      	ldr	r2, [pc, #72]	@ (80092fc <ov2640_Init+0x27c>)
 80092b2:	68fb      	ldr	r3, [r7, #12]
 80092b4:	005b      	lsls	r3, r3, #1
 80092b6:	4413      	add	r3, r2
 80092b8:	785b      	ldrb	r3, [r3, #1]
 80092ba:	461a      	mov	r2, r3
 80092bc:	f7ff feb8 	bl	8009030 <CAMERA_IO_Write>
  		CAMERA_Delay(1);
 80092c0:	2001      	movs	r0, #1
 80092c2:	f7ff fed1 	bl	8009068 <CAMERA_Delay>
  	for(index=0; index<(sizeof(OV2640_1280x960_JPEG)/2); index++)
 80092c6:	68fb      	ldr	r3, [r7, #12]
 80092c8:	3301      	adds	r3, #1
 80092ca:	60fb      	str	r3, [r7, #12]
 80092cc:	68fb      	ldr	r3, [r7, #12]
 80092ce:	2b28      	cmp	r3, #40	@ 0x28
 80092d0:	d9e8      	bls.n	80092a4 <ov2640_Init+0x224>
  	}
	  break;
 80092d2:	e000      	b.n	80092d6 <ov2640_Init+0x256>
  default:
    {
      break;
 80092d4:	bf00      	nop
    }
  }
}
 80092d6:	bf00      	nop
 80092d8:	3710      	adds	r7, #16
 80092da:	46bd      	mov	sp, r7
 80092dc:	bd80      	pop	{r7, pc}
 80092de:	bf00      	nop
 80092e0:	40020800 	.word	0x40020800
 80092e4:	40020c00 	.word	0x40020c00
 80092e8:	0802fcb8 	.word	0x0802fcb8
 80092ec:	0802fe38 	.word	0x0802fe38
 80092f0:	0802fe4c 	.word	0x0802fe4c
 80092f4:	0802fe60 	.word	0x0802fe60
 80092f8:	0802fb00 	.word	0x0802fb00
 80092fc:	0802feb0 	.word	0x0802feb0

08009300 <GPIO_PeriphClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void GPIO_PeriphClockControl(GPIO_RegDef_t *pGPIOx, uint8_t state)
{
 8009300:	b480      	push	{r7}
 8009302:	b083      	sub	sp, #12
 8009304:	af00      	add	r7, sp, #0
 8009306:	6078      	str	r0, [r7, #4]
 8009308:	460b      	mov	r3, r1
 800930a:	70fb      	strb	r3, [r7, #3]
		if(pGPIOx == GPIOA)
 800930c:	687b      	ldr	r3, [r7, #4]
 800930e:	4a41      	ldr	r2, [pc, #260]	@ (8009414 <GPIO_PeriphClockControl+0x114>)
 8009310:	4293      	cmp	r3, r2
 8009312:	d109      	bne.n	8009328 <GPIO_PeriphClockControl+0x28>
		{
			RCC->AHB1ENR.bit.gpioaen = state;
 8009314:	4a40      	ldr	r2, [pc, #256]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 8009316:	78fb      	ldrb	r3, [r7, #3]
 8009318:	f003 0301 	and.w	r3, r3, #1
 800931c:	b2d9      	uxtb	r1, r3
 800931e:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009320:	f361 0300 	bfi	r3, r1, #0, #1
 8009324:	6313      	str	r3, [r2, #48]	@ 0x30
			RCC->AHB1ENR.bit.gpiohen = state;
		}else if(pGPIOx == GPIOI)
		{
			RCC->AHB1ENR.bit.gpioien = state;
		}
}
 8009326:	e06e      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOB)
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	4a3c      	ldr	r2, [pc, #240]	@ (800941c <GPIO_PeriphClockControl+0x11c>)
 800932c:	4293      	cmp	r3, r2
 800932e:	d109      	bne.n	8009344 <GPIO_PeriphClockControl+0x44>
			RCC->AHB1ENR.bit.gpioben = state;
 8009330:	4a39      	ldr	r2, [pc, #228]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 8009332:	78fb      	ldrb	r3, [r7, #3]
 8009334:	f003 0301 	and.w	r3, r3, #1
 8009338:	b2d9      	uxtb	r1, r3
 800933a:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 800933c:	f361 0341 	bfi	r3, r1, #1, #1
 8009340:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009342:	e060      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOC)
 8009344:	687b      	ldr	r3, [r7, #4]
 8009346:	4a36      	ldr	r2, [pc, #216]	@ (8009420 <GPIO_PeriphClockControl+0x120>)
 8009348:	4293      	cmp	r3, r2
 800934a:	d109      	bne.n	8009360 <GPIO_PeriphClockControl+0x60>
			RCC->AHB1ENR.bit.gpiocen = state;
 800934c:	4a32      	ldr	r2, [pc, #200]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 800934e:	78fb      	ldrb	r3, [r7, #3]
 8009350:	f003 0301 	and.w	r3, r3, #1
 8009354:	b2d9      	uxtb	r1, r3
 8009356:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009358:	f361 0382 	bfi	r3, r1, #2, #1
 800935c:	6313      	str	r3, [r2, #48]	@ 0x30
}
 800935e:	e052      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOD)
 8009360:	687b      	ldr	r3, [r7, #4]
 8009362:	4a30      	ldr	r2, [pc, #192]	@ (8009424 <GPIO_PeriphClockControl+0x124>)
 8009364:	4293      	cmp	r3, r2
 8009366:	d109      	bne.n	800937c <GPIO_PeriphClockControl+0x7c>
			RCC->AHB1ENR.bit.gpioden = state;
 8009368:	4a2b      	ldr	r2, [pc, #172]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 800936a:	78fb      	ldrb	r3, [r7, #3]
 800936c:	f003 0301 	and.w	r3, r3, #1
 8009370:	b2d9      	uxtb	r1, r3
 8009372:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009374:	f361 03c3 	bfi	r3, r1, #3, #1
 8009378:	6313      	str	r3, [r2, #48]	@ 0x30
}
 800937a:	e044      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOE)
 800937c:	687b      	ldr	r3, [r7, #4]
 800937e:	4a2a      	ldr	r2, [pc, #168]	@ (8009428 <GPIO_PeriphClockControl+0x128>)
 8009380:	4293      	cmp	r3, r2
 8009382:	d109      	bne.n	8009398 <GPIO_PeriphClockControl+0x98>
			RCC->AHB1ENR.bit.gpioeen = state;
 8009384:	4a24      	ldr	r2, [pc, #144]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 8009386:	78fb      	ldrb	r3, [r7, #3]
 8009388:	f003 0301 	and.w	r3, r3, #1
 800938c:	b2d9      	uxtb	r1, r3
 800938e:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009390:	f361 1304 	bfi	r3, r1, #4, #1
 8009394:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009396:	e036      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOF)
 8009398:	687b      	ldr	r3, [r7, #4]
 800939a:	4a24      	ldr	r2, [pc, #144]	@ (800942c <GPIO_PeriphClockControl+0x12c>)
 800939c:	4293      	cmp	r3, r2
 800939e:	d109      	bne.n	80093b4 <GPIO_PeriphClockControl+0xb4>
			RCC->AHB1ENR.bit.gpiofen = state;
 80093a0:	4a1d      	ldr	r2, [pc, #116]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 80093a2:	78fb      	ldrb	r3, [r7, #3]
 80093a4:	f003 0301 	and.w	r3, r3, #1
 80093a8:	b2d9      	uxtb	r1, r3
 80093aa:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80093ac:	f361 1345 	bfi	r3, r1, #5, #1
 80093b0:	6313      	str	r3, [r2, #48]	@ 0x30
}
 80093b2:	e028      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOG)
 80093b4:	687b      	ldr	r3, [r7, #4]
 80093b6:	4a1e      	ldr	r2, [pc, #120]	@ (8009430 <GPIO_PeriphClockControl+0x130>)
 80093b8:	4293      	cmp	r3, r2
 80093ba:	d109      	bne.n	80093d0 <GPIO_PeriphClockControl+0xd0>
			RCC->AHB1ENR.bit.gpiogen = state;
 80093bc:	4a16      	ldr	r2, [pc, #88]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 80093be:	78fb      	ldrb	r3, [r7, #3]
 80093c0:	f003 0301 	and.w	r3, r3, #1
 80093c4:	b2d9      	uxtb	r1, r3
 80093c6:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80093c8:	f361 1386 	bfi	r3, r1, #6, #1
 80093cc:	6313      	str	r3, [r2, #48]	@ 0x30
}
 80093ce:	e01a      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOH)
 80093d0:	687b      	ldr	r3, [r7, #4]
 80093d2:	4a18      	ldr	r2, [pc, #96]	@ (8009434 <GPIO_PeriphClockControl+0x134>)
 80093d4:	4293      	cmp	r3, r2
 80093d6:	d109      	bne.n	80093ec <GPIO_PeriphClockControl+0xec>
			RCC->AHB1ENR.bit.gpiohen = state;
 80093d8:	4a0f      	ldr	r2, [pc, #60]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 80093da:	78fb      	ldrb	r3, [r7, #3]
 80093dc:	f003 0301 	and.w	r3, r3, #1
 80093e0:	b2d9      	uxtb	r1, r3
 80093e2:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80093e4:	f361 13c7 	bfi	r3, r1, #7, #1
 80093e8:	6313      	str	r3, [r2, #48]	@ 0x30
}
 80093ea:	e00c      	b.n	8009406 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOI)
 80093ec:	687b      	ldr	r3, [r7, #4]
 80093ee:	4a12      	ldr	r2, [pc, #72]	@ (8009438 <GPIO_PeriphClockControl+0x138>)
 80093f0:	4293      	cmp	r3, r2
 80093f2:	d108      	bne.n	8009406 <GPIO_PeriphClockControl+0x106>
			RCC->AHB1ENR.bit.gpioien = state;
 80093f4:	4a08      	ldr	r2, [pc, #32]	@ (8009418 <GPIO_PeriphClockControl+0x118>)
 80093f6:	78fb      	ldrb	r3, [r7, #3]
 80093f8:	f003 0301 	and.w	r3, r3, #1
 80093fc:	b2d9      	uxtb	r1, r3
 80093fe:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009400:	f361 2308 	bfi	r3, r1, #8, #1
 8009404:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009406:	bf00      	nop
 8009408:	370c      	adds	r7, #12
 800940a:	46bd      	mov	sp, r7
 800940c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009410:	4770      	bx	lr
 8009412:	bf00      	nop
 8009414:	40020000 	.word	0x40020000
 8009418:	40023800 	.word	0x40023800
 800941c:	40020400 	.word	0x40020400
 8009420:	40020800 	.word	0x40020800
 8009424:	40020c00 	.word	0x40020c00
 8009428:	40021000 	.word	0x40021000
 800942c:	40021400 	.word	0x40021400
 8009430:	40021800 	.word	0x40021800
 8009434:	40021c00 	.word	0x40021c00
 8009438:	40022000 	.word	0x40022000

0800943c <GPIO_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
 800943c:	b580      	push	{r7, lr}
 800943e:	b086      	sub	sp, #24
 8009440:	af00      	add	r7, sp, #0
 8009442:	6078      	str	r0, [r7, #4]
	uint32_t temp = 0;		//temporary register var
 8009444:	2300      	movs	r3, #0
 8009446:	617b      	str	r3, [r7, #20]

	//enable peripheral clock
	GPIO_PeriphClockControl(pGPIOHandle->pGPIOx, ENABLE);
 8009448:	687b      	ldr	r3, [r7, #4]
 800944a:	681b      	ldr	r3, [r3, #0]
 800944c:	2101      	movs	r1, #1
 800944e:	4618      	mov	r0, r3
 8009450:	f7ff ff56 	bl	8009300 <GPIO_PeriphClockControl>

	if(pGPIOHandle->GPIO_Config.PinMode <= GPIO_MODE_ANALOG)
 8009454:	687b      	ldr	r3, [r7, #4]
 8009456:	7a1b      	ldrb	r3, [r3, #8]
 8009458:	2b03      	cmp	r3, #3
 800945a:	d81f      	bhi.n	800949c <GPIO_Init+0x60>
	{
		temp = pGPIOHandle->GPIO_Config.PinMode << (2 * pGPIOHandle->GPIO_Config.PinNumber); /*< shift to left by 2 bits because
 800945c:	687b      	ldr	r3, [r7, #4]
 800945e:	7a1b      	ldrb	r3, [r3, #8]
 8009460:	461a      	mov	r2, r3
 8009462:	687b      	ldr	r3, [r7, #4]
 8009464:	685b      	ldr	r3, [r3, #4]
 8009466:	005b      	lsls	r3, r3, #1
 8009468:	fa02 f303 	lsl.w	r3, r2, r3
 800946c:	617b      	str	r3, [r7, #20]
																							 each pin in MODER is two bits >*/
		pGPIOHandle->pGPIOx->MODER.reg &= ~(0x3 << pGPIOHandle->GPIO_Config.PinNumber);
 800946e:	687b      	ldr	r3, [r7, #4]
 8009470:	681b      	ldr	r3, [r3, #0]
 8009472:	681a      	ldr	r2, [r3, #0]
 8009474:	687b      	ldr	r3, [r7, #4]
 8009476:	685b      	ldr	r3, [r3, #4]
 8009478:	2103      	movs	r1, #3
 800947a:	fa01 f303 	lsl.w	r3, r1, r3
 800947e:	43db      	mvns	r3, r3
 8009480:	4619      	mov	r1, r3
 8009482:	687b      	ldr	r3, [r7, #4]
 8009484:	681b      	ldr	r3, [r3, #0]
 8009486:	400a      	ands	r2, r1
 8009488:	601a      	str	r2, [r3, #0]
		pGPIOHandle->pGPIOx->MODER.reg |= temp;
 800948a:	687b      	ldr	r3, [r7, #4]
 800948c:	681b      	ldr	r3, [r3, #0]
 800948e:	6819      	ldr	r1, [r3, #0]
 8009490:	687b      	ldr	r3, [r7, #4]
 8009492:	681b      	ldr	r3, [r3, #0]
 8009494:	697a      	ldr	r2, [r7, #20]
 8009496:	430a      	orrs	r2, r1
 8009498:	601a      	str	r2, [r3, #0]
 800949a:	e113      	b.n	80096c4 <GPIO_Init+0x288>
	}else
	{
		//interrupt mode
		if(GPIO_MODE_IT_FT == pGPIOHandle->GPIO_Config.PinMode)
 800949c:	687b      	ldr	r3, [r7, #4]
 800949e:	7a1b      	ldrb	r3, [r3, #8]
 80094a0:	2b06      	cmp	r3, #6
 80094a2:	d117      	bne.n	80094d4 <GPIO_Init+0x98>
		{
			//configure FTSR
			EXTI->FTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in FTSR
 80094a4:	4b6c      	ldr	r3, [pc, #432]	@ (8009658 <GPIO_Init+0x21c>)
 80094a6:	68db      	ldr	r3, [r3, #12]
 80094a8:	687a      	ldr	r2, [r7, #4]
 80094aa:	6852      	ldr	r2, [r2, #4]
 80094ac:	2101      	movs	r1, #1
 80094ae:	fa01 f202 	lsl.w	r2, r1, r2
 80094b2:	4611      	mov	r1, r2
 80094b4:	4a68      	ldr	r2, [pc, #416]	@ (8009658 <GPIO_Init+0x21c>)
 80094b6:	430b      	orrs	r3, r1
 80094b8:	60d3      	str	r3, [r2, #12]
			EXTI->RTSR.reg &= ~(1 << pGPIOHandle->GPIO_Config.PinNumber); 	//clear bit in RTSR just in case it is not reset
 80094ba:	4b67      	ldr	r3, [pc, #412]	@ (8009658 <GPIO_Init+0x21c>)
 80094bc:	689b      	ldr	r3, [r3, #8]
 80094be:	687a      	ldr	r2, [r7, #4]
 80094c0:	6852      	ldr	r2, [r2, #4]
 80094c2:	2101      	movs	r1, #1
 80094c4:	fa01 f202 	lsl.w	r2, r1, r2
 80094c8:	43d2      	mvns	r2, r2
 80094ca:	4611      	mov	r1, r2
 80094cc:	4a62      	ldr	r2, [pc, #392]	@ (8009658 <GPIO_Init+0x21c>)
 80094ce:	400b      	ands	r3, r1
 80094d0:	6093      	str	r3, [r2, #8]
 80094d2:	e035      	b.n	8009540 <GPIO_Init+0x104>
		}else if(GPIO_MODE_IT_RT == pGPIOHandle->GPIO_Config.PinMode)
 80094d4:	687b      	ldr	r3, [r7, #4]
 80094d6:	7a1b      	ldrb	r3, [r3, #8]
 80094d8:	2b05      	cmp	r3, #5
 80094da:	d117      	bne.n	800950c <GPIO_Init+0xd0>
		{
			//configure RTSR
			EXTI->RTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in RTSR
 80094dc:	4b5e      	ldr	r3, [pc, #376]	@ (8009658 <GPIO_Init+0x21c>)
 80094de:	689b      	ldr	r3, [r3, #8]
 80094e0:	687a      	ldr	r2, [r7, #4]
 80094e2:	6852      	ldr	r2, [r2, #4]
 80094e4:	2101      	movs	r1, #1
 80094e6:	fa01 f202 	lsl.w	r2, r1, r2
 80094ea:	4611      	mov	r1, r2
 80094ec:	4a5a      	ldr	r2, [pc, #360]	@ (8009658 <GPIO_Init+0x21c>)
 80094ee:	430b      	orrs	r3, r1
 80094f0:	6093      	str	r3, [r2, #8]
			EXTI->FTSR.reg &= ~(1 << pGPIOHandle->GPIO_Config.PinNumber); 	//clear bit in FTSR just in case it is not reset
 80094f2:	4b59      	ldr	r3, [pc, #356]	@ (8009658 <GPIO_Init+0x21c>)
 80094f4:	68db      	ldr	r3, [r3, #12]
 80094f6:	687a      	ldr	r2, [r7, #4]
 80094f8:	6852      	ldr	r2, [r2, #4]
 80094fa:	2101      	movs	r1, #1
 80094fc:	fa01 f202 	lsl.w	r2, r1, r2
 8009500:	43d2      	mvns	r2, r2
 8009502:	4611      	mov	r1, r2
 8009504:	4a54      	ldr	r2, [pc, #336]	@ (8009658 <GPIO_Init+0x21c>)
 8009506:	400b      	ands	r3, r1
 8009508:	60d3      	str	r3, [r2, #12]
 800950a:	e019      	b.n	8009540 <GPIO_Init+0x104>
		}else if (GPIO_MODE_IT_RFT == pGPIOHandle->GPIO_Config.PinMode)
 800950c:	687b      	ldr	r3, [r7, #4]
 800950e:	7a1b      	ldrb	r3, [r3, #8]
 8009510:	2b07      	cmp	r3, #7
 8009512:	d115      	bne.n	8009540 <GPIO_Init+0x104>
		{
			//configure both FTSR and RTSR registers
			EXTI->RTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in RTSR
 8009514:	4b50      	ldr	r3, [pc, #320]	@ (8009658 <GPIO_Init+0x21c>)
 8009516:	689b      	ldr	r3, [r3, #8]
 8009518:	687a      	ldr	r2, [r7, #4]
 800951a:	6852      	ldr	r2, [r2, #4]
 800951c:	2101      	movs	r1, #1
 800951e:	fa01 f202 	lsl.w	r2, r1, r2
 8009522:	4611      	mov	r1, r2
 8009524:	4a4c      	ldr	r2, [pc, #304]	@ (8009658 <GPIO_Init+0x21c>)
 8009526:	430b      	orrs	r3, r1
 8009528:	6093      	str	r3, [r2, #8]
			EXTI->FTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber); 	//set bit in FTSR
 800952a:	4b4b      	ldr	r3, [pc, #300]	@ (8009658 <GPIO_Init+0x21c>)
 800952c:	68db      	ldr	r3, [r3, #12]
 800952e:	687a      	ldr	r2, [r7, #4]
 8009530:	6852      	ldr	r2, [r2, #4]
 8009532:	2101      	movs	r1, #1
 8009534:	fa01 f202 	lsl.w	r2, r1, r2
 8009538:	4611      	mov	r1, r2
 800953a:	4a47      	ldr	r2, [pc, #284]	@ (8009658 <GPIO_Init+0x21c>)
 800953c:	430b      	orrs	r3, r1
 800953e:	60d3      	str	r3, [r2, #12]
		}

		uint8_t temp1 = pGPIOHandle->GPIO_Config.PinNumber / 4;
 8009540:	687b      	ldr	r3, [r7, #4]
 8009542:	685b      	ldr	r3, [r3, #4]
 8009544:	089b      	lsrs	r3, r3, #2
 8009546:	74fb      	strb	r3, [r7, #19]
		uint8_t temp2 = pGPIOHandle->GPIO_Config.PinNumber % 4;
 8009548:	687b      	ldr	r3, [r7, #4]
 800954a:	685b      	ldr	r3, [r3, #4]
 800954c:	b2db      	uxtb	r3, r3
 800954e:	f003 0303 	and.w	r3, r3, #3
 8009552:	74bb      	strb	r3, [r7, #18]

		uint8_t portcode = GPIO_BASEADDR_TO_CODE(pGPIOHandle->pGPIOx);
 8009554:	687b      	ldr	r3, [r7, #4]
 8009556:	681b      	ldr	r3, [r3, #0]
 8009558:	4a40      	ldr	r2, [pc, #256]	@ (800965c <GPIO_Init+0x220>)
 800955a:	4293      	cmp	r3, r2
 800955c:	d02b      	beq.n	80095b6 <GPIO_Init+0x17a>
 800955e:	687b      	ldr	r3, [r7, #4]
 8009560:	681b      	ldr	r3, [r3, #0]
 8009562:	4a3f      	ldr	r2, [pc, #252]	@ (8009660 <GPIO_Init+0x224>)
 8009564:	4293      	cmp	r3, r2
 8009566:	d024      	beq.n	80095b2 <GPIO_Init+0x176>
 8009568:	687b      	ldr	r3, [r7, #4]
 800956a:	681b      	ldr	r3, [r3, #0]
 800956c:	4a3d      	ldr	r2, [pc, #244]	@ (8009664 <GPIO_Init+0x228>)
 800956e:	4293      	cmp	r3, r2
 8009570:	d01d      	beq.n	80095ae <GPIO_Init+0x172>
 8009572:	687b      	ldr	r3, [r7, #4]
 8009574:	681b      	ldr	r3, [r3, #0]
 8009576:	4a3c      	ldr	r2, [pc, #240]	@ (8009668 <GPIO_Init+0x22c>)
 8009578:	4293      	cmp	r3, r2
 800957a:	d016      	beq.n	80095aa <GPIO_Init+0x16e>
 800957c:	687b      	ldr	r3, [r7, #4]
 800957e:	681b      	ldr	r3, [r3, #0]
 8009580:	4a3a      	ldr	r2, [pc, #232]	@ (800966c <GPIO_Init+0x230>)
 8009582:	4293      	cmp	r3, r2
 8009584:	d00f      	beq.n	80095a6 <GPIO_Init+0x16a>
 8009586:	687b      	ldr	r3, [r7, #4]
 8009588:	681b      	ldr	r3, [r3, #0]
 800958a:	4a39      	ldr	r2, [pc, #228]	@ (8009670 <GPIO_Init+0x234>)
 800958c:	4293      	cmp	r3, r2
 800958e:	d008      	beq.n	80095a2 <GPIO_Init+0x166>
 8009590:	687b      	ldr	r3, [r7, #4]
 8009592:	681b      	ldr	r3, [r3, #0]
 8009594:	4a37      	ldr	r2, [pc, #220]	@ (8009674 <GPIO_Init+0x238>)
 8009596:	4293      	cmp	r3, r2
 8009598:	d101      	bne.n	800959e <GPIO_Init+0x162>
 800959a:	2308      	movs	r3, #8
 800959c:	e00c      	b.n	80095b8 <GPIO_Init+0x17c>
 800959e:	2300      	movs	r3, #0
 80095a0:	e00a      	b.n	80095b8 <GPIO_Init+0x17c>
 80095a2:	2307      	movs	r3, #7
 80095a4:	e008      	b.n	80095b8 <GPIO_Init+0x17c>
 80095a6:	2304      	movs	r3, #4
 80095a8:	e006      	b.n	80095b8 <GPIO_Init+0x17c>
 80095aa:	2303      	movs	r3, #3
 80095ac:	e004      	b.n	80095b8 <GPIO_Init+0x17c>
 80095ae:	2302      	movs	r3, #2
 80095b0:	e002      	b.n	80095b8 <GPIO_Init+0x17c>
 80095b2:	2301      	movs	r3, #1
 80095b4:	e000      	b.n	80095b8 <GPIO_Init+0x17c>
 80095b6:	2300      	movs	r3, #0
 80095b8:	747b      	strb	r3, [r7, #17]
		RCC->APB2ENR.reg |= RCC_APB2ENR_SYSCFGEN; 											// enable SYSCFG peripheral clock
 80095ba:	4b2f      	ldr	r3, [pc, #188]	@ (8009678 <GPIO_Init+0x23c>)
 80095bc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80095be:	4a2e      	ldr	r2, [pc, #184]	@ (8009678 <GPIO_Init+0x23c>)
 80095c0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80095c4:	6453      	str	r3, [r2, #68]	@ 0x44
		if((0 == temp1) || (1/4 == temp1) || (2/4 == temp1) || (3/4 == temp1))
 80095c6:	7cfb      	ldrb	r3, [r7, #19]
 80095c8:	2b00      	cmp	r3, #0
 80095ca:	d008      	beq.n	80095de <GPIO_Init+0x1a2>
 80095cc:	7cfb      	ldrb	r3, [r7, #19]
 80095ce:	2b00      	cmp	r3, #0
 80095d0:	d005      	beq.n	80095de <GPIO_Init+0x1a2>
 80095d2:	7cfb      	ldrb	r3, [r7, #19]
 80095d4:	2b00      	cmp	r3, #0
 80095d6:	d002      	beq.n	80095de <GPIO_Init+0x1a2>
 80095d8:	7cfb      	ldrb	r3, [r7, #19]
 80095da:	2b00      	cmp	r3, #0
 80095dc:	d10b      	bne.n	80095f6 <GPIO_Init+0x1ba>
		{
			SYSCFG->EXTICR[0] |= portcode << (temp2 * 4);
 80095de:	4b27      	ldr	r3, [pc, #156]	@ (800967c <GPIO_Init+0x240>)
 80095e0:	689b      	ldr	r3, [r3, #8]
 80095e2:	7c79      	ldrb	r1, [r7, #17]
 80095e4:	7cba      	ldrb	r2, [r7, #18]
 80095e6:	0092      	lsls	r2, r2, #2
 80095e8:	fa01 f202 	lsl.w	r2, r1, r2
 80095ec:	4611      	mov	r1, r2
 80095ee:	4a23      	ldr	r2, [pc, #140]	@ (800967c <GPIO_Init+0x240>)
 80095f0:	430b      	orrs	r3, r1
 80095f2:	6093      	str	r3, [r2, #8]
 80095f4:	e05b      	b.n	80096ae <GPIO_Init+0x272>
		}
		else if((1 == temp1) || (5/4 == temp1) || (6/4 == temp1) || (7/4 == temp1))
 80095f6:	7cfb      	ldrb	r3, [r7, #19]
 80095f8:	2b01      	cmp	r3, #1
 80095fa:	d008      	beq.n	800960e <GPIO_Init+0x1d2>
 80095fc:	7cfb      	ldrb	r3, [r7, #19]
 80095fe:	2b01      	cmp	r3, #1
 8009600:	d005      	beq.n	800960e <GPIO_Init+0x1d2>
 8009602:	7cfb      	ldrb	r3, [r7, #19]
 8009604:	2b01      	cmp	r3, #1
 8009606:	d002      	beq.n	800960e <GPIO_Init+0x1d2>
 8009608:	7cfb      	ldrb	r3, [r7, #19]
 800960a:	2b01      	cmp	r3, #1
 800960c:	d10b      	bne.n	8009626 <GPIO_Init+0x1ea>
		{
			SYSCFG->EXTICR[1] |= portcode << (temp2 * 4);
 800960e:	4b1b      	ldr	r3, [pc, #108]	@ (800967c <GPIO_Init+0x240>)
 8009610:	68db      	ldr	r3, [r3, #12]
 8009612:	7c79      	ldrb	r1, [r7, #17]
 8009614:	7cba      	ldrb	r2, [r7, #18]
 8009616:	0092      	lsls	r2, r2, #2
 8009618:	fa01 f202 	lsl.w	r2, r1, r2
 800961c:	4611      	mov	r1, r2
 800961e:	4a17      	ldr	r2, [pc, #92]	@ (800967c <GPIO_Init+0x240>)
 8009620:	430b      	orrs	r3, r1
 8009622:	60d3      	str	r3, [r2, #12]
 8009624:	e043      	b.n	80096ae <GPIO_Init+0x272>
		}
		else if((2 == temp1) || (9/4 == temp1) || (10/4 == temp1) || (11/4 == temp1))
 8009626:	7cfb      	ldrb	r3, [r7, #19]
 8009628:	2b02      	cmp	r3, #2
 800962a:	d008      	beq.n	800963e <GPIO_Init+0x202>
 800962c:	7cfb      	ldrb	r3, [r7, #19]
 800962e:	2b02      	cmp	r3, #2
 8009630:	d005      	beq.n	800963e <GPIO_Init+0x202>
 8009632:	7cfb      	ldrb	r3, [r7, #19]
 8009634:	2b02      	cmp	r3, #2
 8009636:	d002      	beq.n	800963e <GPIO_Init+0x202>
 8009638:	7cfb      	ldrb	r3, [r7, #19]
 800963a:	2b02      	cmp	r3, #2
 800963c:	d120      	bne.n	8009680 <GPIO_Init+0x244>
		{
			SYSCFG->EXTICR[2] |= portcode << (temp2 * 4);
 800963e:	4b0f      	ldr	r3, [pc, #60]	@ (800967c <GPIO_Init+0x240>)
 8009640:	691b      	ldr	r3, [r3, #16]
 8009642:	7c79      	ldrb	r1, [r7, #17]
 8009644:	7cba      	ldrb	r2, [r7, #18]
 8009646:	0092      	lsls	r2, r2, #2
 8009648:	fa01 f202 	lsl.w	r2, r1, r2
 800964c:	4611      	mov	r1, r2
 800964e:	4a0b      	ldr	r2, [pc, #44]	@ (800967c <GPIO_Init+0x240>)
 8009650:	430b      	orrs	r3, r1
 8009652:	6113      	str	r3, [r2, #16]
 8009654:	e02b      	b.n	80096ae <GPIO_Init+0x272>
 8009656:	bf00      	nop
 8009658:	40013c00 	.word	0x40013c00
 800965c:	40020000 	.word	0x40020000
 8009660:	40020400 	.word	0x40020400
 8009664:	40020800 	.word	0x40020800
 8009668:	40020c00 	.word	0x40020c00
 800966c:	40021000 	.word	0x40021000
 8009670:	40021c00 	.word	0x40021c00
 8009674:	40022000 	.word	0x40022000
 8009678:	40023800 	.word	0x40023800
 800967c:	40013800 	.word	0x40013800
		}
		else if((3 == temp1) || (13/4 == temp1) || (14/4 == temp1) || (15/4 == temp1))
 8009680:	7cfb      	ldrb	r3, [r7, #19]
 8009682:	2b03      	cmp	r3, #3
 8009684:	d008      	beq.n	8009698 <GPIO_Init+0x25c>
 8009686:	7cfb      	ldrb	r3, [r7, #19]
 8009688:	2b03      	cmp	r3, #3
 800968a:	d005      	beq.n	8009698 <GPIO_Init+0x25c>
 800968c:	7cfb      	ldrb	r3, [r7, #19]
 800968e:	2b03      	cmp	r3, #3
 8009690:	d002      	beq.n	8009698 <GPIO_Init+0x25c>
 8009692:	7cfb      	ldrb	r3, [r7, #19]
 8009694:	2b03      	cmp	r3, #3
 8009696:	d10a      	bne.n	80096ae <GPIO_Init+0x272>
		{
			SYSCFG->EXTICR[3] |= portcode << (temp2 * 4);
 8009698:	4b7a      	ldr	r3, [pc, #488]	@ (8009884 <GPIO_Init+0x448>)
 800969a:	695b      	ldr	r3, [r3, #20]
 800969c:	7c79      	ldrb	r1, [r7, #17]
 800969e:	7cba      	ldrb	r2, [r7, #18]
 80096a0:	0092      	lsls	r2, r2, #2
 80096a2:	fa01 f202 	lsl.w	r2, r1, r2
 80096a6:	4611      	mov	r1, r2
 80096a8:	4a76      	ldr	r2, [pc, #472]	@ (8009884 <GPIO_Init+0x448>)
 80096aa:	430b      	orrs	r3, r1
 80096ac:	6153      	str	r3, [r2, #20]
		}

		EXTI->IMR.reg |= 1 << pGPIOHandle->GPIO_Config.PinNumber;			//enable the EXTI interrupt delivery using IMR
 80096ae:	4b76      	ldr	r3, [pc, #472]	@ (8009888 <GPIO_Init+0x44c>)
 80096b0:	681b      	ldr	r3, [r3, #0]
 80096b2:	687a      	ldr	r2, [r7, #4]
 80096b4:	6852      	ldr	r2, [r2, #4]
 80096b6:	2101      	movs	r1, #1
 80096b8:	fa01 f202 	lsl.w	r2, r1, r2
 80096bc:	4611      	mov	r1, r2
 80096be:	4a72      	ldr	r2, [pc, #456]	@ (8009888 <GPIO_Init+0x44c>)
 80096c0:	430b      	orrs	r3, r1
 80096c2:	6013      	str	r3, [r2, #0]
	}

	temp = pGPIOHandle->GPIO_Config.PinSpeed << (2 * pGPIOHandle->GPIO_Config.PinNumber);//shift to left by 2 bits
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	7a5b      	ldrb	r3, [r3, #9]
 80096c8:	461a      	mov	r2, r3
 80096ca:	687b      	ldr	r3, [r7, #4]
 80096cc:	685b      	ldr	r3, [r3, #4]
 80096ce:	005b      	lsls	r3, r3, #1
 80096d0:	fa02 f303 	lsl.w	r3, r2, r3
 80096d4:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OSPEEDR.reg &= ~(0x3 <<(2 * pGPIOHandle->GPIO_Config.PinNumber));
 80096d6:	687b      	ldr	r3, [r7, #4]
 80096d8:	681b      	ldr	r3, [r3, #0]
 80096da:	689a      	ldr	r2, [r3, #8]
 80096dc:	687b      	ldr	r3, [r7, #4]
 80096de:	685b      	ldr	r3, [r3, #4]
 80096e0:	005b      	lsls	r3, r3, #1
 80096e2:	2103      	movs	r1, #3
 80096e4:	fa01 f303 	lsl.w	r3, r1, r3
 80096e8:	43db      	mvns	r3, r3
 80096ea:	4619      	mov	r1, r3
 80096ec:	687b      	ldr	r3, [r7, #4]
 80096ee:	681b      	ldr	r3, [r3, #0]
 80096f0:	400a      	ands	r2, r1
 80096f2:	609a      	str	r2, [r3, #8]
	pGPIOHandle->pGPIOx->OSPEEDR.reg |= temp;
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	681b      	ldr	r3, [r3, #0]
 80096f8:	6899      	ldr	r1, [r3, #8]
 80096fa:	687b      	ldr	r3, [r7, #4]
 80096fc:	681b      	ldr	r3, [r3, #0]
 80096fe:	697a      	ldr	r2, [r7, #20]
 8009700:	430a      	orrs	r2, r1
 8009702:	609a      	str	r2, [r3, #8]

	temp = pGPIOHandle->GPIO_Config.PinPuPdControl << (2 * pGPIOHandle->GPIO_Config.PinNumber);//shift to left by 2 bits because
 8009704:	687b      	ldr	r3, [r7, #4]
 8009706:	7a9b      	ldrb	r3, [r3, #10]
 8009708:	461a      	mov	r2, r3
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	685b      	ldr	r3, [r3, #4]
 800970e:	005b      	lsls	r3, r3, #1
 8009710:	fa02 f303 	lsl.w	r3, r2, r3
 8009714:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->PUPDR.reg &= ~(0x3 <<( 2 * pGPIOHandle->GPIO_Config.PinNumber));
 8009716:	687b      	ldr	r3, [r7, #4]
 8009718:	681b      	ldr	r3, [r3, #0]
 800971a:	68da      	ldr	r2, [r3, #12]
 800971c:	687b      	ldr	r3, [r7, #4]
 800971e:	685b      	ldr	r3, [r3, #4]
 8009720:	005b      	lsls	r3, r3, #1
 8009722:	2103      	movs	r1, #3
 8009724:	fa01 f303 	lsl.w	r3, r1, r3
 8009728:	43db      	mvns	r3, r3
 800972a:	4619      	mov	r1, r3
 800972c:	687b      	ldr	r3, [r7, #4]
 800972e:	681b      	ldr	r3, [r3, #0]
 8009730:	400a      	ands	r2, r1
 8009732:	60da      	str	r2, [r3, #12]
	pGPIOHandle->pGPIOx->PUPDR.reg |= temp;
 8009734:	687b      	ldr	r3, [r7, #4]
 8009736:	681b      	ldr	r3, [r3, #0]
 8009738:	68d9      	ldr	r1, [r3, #12]
 800973a:	687b      	ldr	r3, [r7, #4]
 800973c:	681b      	ldr	r3, [r3, #0]
 800973e:	697a      	ldr	r2, [r7, #20]
 8009740:	430a      	orrs	r2, r1
 8009742:	60da      	str	r2, [r3, #12]

	temp = pGPIOHandle->GPIO_Config.PinOPType << pGPIOHandle->GPIO_Config.PinNumber;//shift to left by 2 bits
 8009744:	687b      	ldr	r3, [r7, #4]
 8009746:	7adb      	ldrb	r3, [r3, #11]
 8009748:	461a      	mov	r2, r3
 800974a:	687b      	ldr	r3, [r7, #4]
 800974c:	685b      	ldr	r3, [r3, #4]
 800974e:	fa02 f303 	lsl.w	r3, r2, r3
 8009752:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OTYPER.reg &= ~(0x1 << pGPIOHandle->GPIO_Config.PinNumber);
 8009754:	687b      	ldr	r3, [r7, #4]
 8009756:	681b      	ldr	r3, [r3, #0]
 8009758:	685a      	ldr	r2, [r3, #4]
 800975a:	687b      	ldr	r3, [r7, #4]
 800975c:	685b      	ldr	r3, [r3, #4]
 800975e:	2101      	movs	r1, #1
 8009760:	fa01 f303 	lsl.w	r3, r1, r3
 8009764:	43db      	mvns	r3, r3
 8009766:	4619      	mov	r1, r3
 8009768:	687b      	ldr	r3, [r7, #4]
 800976a:	681b      	ldr	r3, [r3, #0]
 800976c:	400a      	ands	r2, r1
 800976e:	605a      	str	r2, [r3, #4]
	pGPIOHandle->pGPIOx->OTYPER.reg |= temp;
 8009770:	687b      	ldr	r3, [r7, #4]
 8009772:	681b      	ldr	r3, [r3, #0]
 8009774:	6859      	ldr	r1, [r3, #4]
 8009776:	687b      	ldr	r3, [r7, #4]
 8009778:	681b      	ldr	r3, [r3, #0]
 800977a:	697a      	ldr	r2, [r7, #20]
 800977c:	430a      	orrs	r2, r1
 800977e:	605a      	str	r2, [r3, #4]

	if(GPIO_MODE_AF == pGPIOHandle->GPIO_Config.PinMode)
 8009780:	687b      	ldr	r3, [r7, #4]
 8009782:	7a1b      	ldrb	r3, [r3, #8]
 8009784:	2b02      	cmp	r3, #2
 8009786:	d178      	bne.n	800987a <GPIO_Init+0x43e>
	{
		uint8_t temp1 = 0, temp2 = 0;
 8009788:	2300      	movs	r3, #0
 800978a:	743b      	strb	r3, [r7, #16]
 800978c:	2300      	movs	r3, #0
 800978e:	73fb      	strb	r3, [r7, #15]

		temp1 = pGPIOHandle->GPIO_Config.PinNumber/8;	//AFRL = AFR[0]. Any integer smaller than 8 will be 0 after division
 8009790:	687b      	ldr	r3, [r7, #4]
 8009792:	685b      	ldr	r3, [r3, #4]
 8009794:	08db      	lsrs	r3, r3, #3
 8009796:	743b      	strb	r3, [r7, #16]
		temp2 = pGPIOHandle->GPIO_Config.PinNumber%8;
 8009798:	687b      	ldr	r3, [r7, #4]
 800979a:	685b      	ldr	r3, [r3, #4]
 800979c:	b2db      	uxtb	r3, r3
 800979e:	f003 0307 	and.w	r3, r3, #7
 80097a2:	73fb      	strb	r3, [r7, #15]
		if((0 == temp1) || (1/8 == temp1) || (2/8 == temp1) || (3/8 == temp1) ||
 80097a4:	7c3b      	ldrb	r3, [r7, #16]
 80097a6:	2b00      	cmp	r3, #0
 80097a8:	d014      	beq.n	80097d4 <GPIO_Init+0x398>
 80097aa:	7c3b      	ldrb	r3, [r7, #16]
 80097ac:	2b00      	cmp	r3, #0
 80097ae:	d011      	beq.n	80097d4 <GPIO_Init+0x398>
 80097b0:	7c3b      	ldrb	r3, [r7, #16]
 80097b2:	2b00      	cmp	r3, #0
 80097b4:	d00e      	beq.n	80097d4 <GPIO_Init+0x398>
 80097b6:	7c3b      	ldrb	r3, [r7, #16]
 80097b8:	2b00      	cmp	r3, #0
 80097ba:	d00b      	beq.n	80097d4 <GPIO_Init+0x398>
 80097bc:	7c3b      	ldrb	r3, [r7, #16]
 80097be:	2b00      	cmp	r3, #0
 80097c0:	d008      	beq.n	80097d4 <GPIO_Init+0x398>
			(4/8 == temp1 ) || (5/8 == temp1) || (6/8 == temp1) || (7/8 == temp1))
 80097c2:	7c3b      	ldrb	r3, [r7, #16]
 80097c4:	2b00      	cmp	r3, #0
 80097c6:	d005      	beq.n	80097d4 <GPIO_Init+0x398>
 80097c8:	7c3b      	ldrb	r3, [r7, #16]
 80097ca:	2b00      	cmp	r3, #0
 80097cc:	d002      	beq.n	80097d4 <GPIO_Init+0x398>
 80097ce:	7c3b      	ldrb	r3, [r7, #16]
 80097d0:	2b00      	cmp	r3, #0
 80097d2:	d11d      	bne.n	8009810 <GPIO_Init+0x3d4>
		{
			pGPIOHandle->pGPIOx->AFRL.reg &= ~(0xF << (4* temp2));
 80097d4:	687b      	ldr	r3, [r7, #4]
 80097d6:	681b      	ldr	r3, [r3, #0]
 80097d8:	6a1a      	ldr	r2, [r3, #32]
 80097da:	7bfb      	ldrb	r3, [r7, #15]
 80097dc:	009b      	lsls	r3, r3, #2
 80097de:	210f      	movs	r1, #15
 80097e0:	fa01 f303 	lsl.w	r3, r1, r3
 80097e4:	43db      	mvns	r3, r3
 80097e6:	4619      	mov	r1, r3
 80097e8:	687b      	ldr	r3, [r7, #4]
 80097ea:	681b      	ldr	r3, [r3, #0]
 80097ec:	400a      	ands	r2, r1
 80097ee:	621a      	str	r2, [r3, #32]
			pGPIOHandle->pGPIOx->AFRL.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
 80097f0:	687b      	ldr	r3, [r7, #4]
 80097f2:	681b      	ldr	r3, [r3, #0]
 80097f4:	6a1a      	ldr	r2, [r3, #32]
 80097f6:	687b      	ldr	r3, [r7, #4]
 80097f8:	7b1b      	ldrb	r3, [r3, #12]
 80097fa:	4619      	mov	r1, r3
 80097fc:	7bfb      	ldrb	r3, [r7, #15]
 80097fe:	009b      	lsls	r3, r3, #2
 8009800:	fa01 f303 	lsl.w	r3, r1, r3
 8009804:	4619      	mov	r1, r3
 8009806:	687b      	ldr	r3, [r7, #4]
 8009808:	681b      	ldr	r3, [r3, #0]
 800980a:	430a      	orrs	r2, r1
 800980c:	621a      	str	r2, [r3, #32]
		{
			pGPIOHandle->pGPIOx->AFRH.reg &= ~(0xF << (4* temp2));
			pGPIOHandle->pGPIOx->AFRH.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
		}
	}
}
 800980e:	e034      	b.n	800987a <GPIO_Init+0x43e>
		else if((1 == temp1) || (9/8 == temp1) || (10/8 == temp1) || (11/8 == temp1) ||
 8009810:	7c3b      	ldrb	r3, [r7, #16]
 8009812:	2b01      	cmp	r3, #1
 8009814:	d014      	beq.n	8009840 <GPIO_Init+0x404>
 8009816:	7c3b      	ldrb	r3, [r7, #16]
 8009818:	2b01      	cmp	r3, #1
 800981a:	d011      	beq.n	8009840 <GPIO_Init+0x404>
 800981c:	7c3b      	ldrb	r3, [r7, #16]
 800981e:	2b01      	cmp	r3, #1
 8009820:	d00e      	beq.n	8009840 <GPIO_Init+0x404>
 8009822:	7c3b      	ldrb	r3, [r7, #16]
 8009824:	2b01      	cmp	r3, #1
 8009826:	d00b      	beq.n	8009840 <GPIO_Init+0x404>
 8009828:	7c3b      	ldrb	r3, [r7, #16]
 800982a:	2b01      	cmp	r3, #1
 800982c:	d008      	beq.n	8009840 <GPIO_Init+0x404>
				(12/8 == temp1 ) || (13/8 == temp1) || (14/8 == temp1) || (15/8 == temp1))
 800982e:	7c3b      	ldrb	r3, [r7, #16]
 8009830:	2b01      	cmp	r3, #1
 8009832:	d005      	beq.n	8009840 <GPIO_Init+0x404>
 8009834:	7c3b      	ldrb	r3, [r7, #16]
 8009836:	2b01      	cmp	r3, #1
 8009838:	d002      	beq.n	8009840 <GPIO_Init+0x404>
 800983a:	7c3b      	ldrb	r3, [r7, #16]
 800983c:	2b01      	cmp	r3, #1
 800983e:	d11c      	bne.n	800987a <GPIO_Init+0x43e>
			pGPIOHandle->pGPIOx->AFRH.reg &= ~(0xF << (4* temp2));
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	681b      	ldr	r3, [r3, #0]
 8009844:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8009846:	7bfb      	ldrb	r3, [r7, #15]
 8009848:	009b      	lsls	r3, r3, #2
 800984a:	210f      	movs	r1, #15
 800984c:	fa01 f303 	lsl.w	r3, r1, r3
 8009850:	43db      	mvns	r3, r3
 8009852:	4619      	mov	r1, r3
 8009854:	687b      	ldr	r3, [r7, #4]
 8009856:	681b      	ldr	r3, [r3, #0]
 8009858:	400a      	ands	r2, r1
 800985a:	625a      	str	r2, [r3, #36]	@ 0x24
			pGPIOHandle->pGPIOx->AFRH.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
 800985c:	687b      	ldr	r3, [r7, #4]
 800985e:	681b      	ldr	r3, [r3, #0]
 8009860:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8009862:	687b      	ldr	r3, [r7, #4]
 8009864:	7b1b      	ldrb	r3, [r3, #12]
 8009866:	4619      	mov	r1, r3
 8009868:	7bfb      	ldrb	r3, [r7, #15]
 800986a:	009b      	lsls	r3, r3, #2
 800986c:	fa01 f303 	lsl.w	r3, r1, r3
 8009870:	4619      	mov	r1, r3
 8009872:	687b      	ldr	r3, [r7, #4]
 8009874:	681b      	ldr	r3, [r3, #0]
 8009876:	430a      	orrs	r2, r1
 8009878:	625a      	str	r2, [r3, #36]	@ 0x24
}
 800987a:	bf00      	nop
 800987c:	3718      	adds	r7, #24
 800987e:	46bd      	mov	sp, r7
 8009880:	bd80      	pop	{r7, pc}
 8009882:	bf00      	nop
 8009884:	40013800 	.word	0x40013800
 8009888:	40013c00 	.word	0x40013c00

0800988c <GPIO_WritePin>:
/* @return				-	none																		*/
/*																										*/
/* @Note				-	none																		*/
/********************************************************************************************************/
void GPIO_WritePin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t val)
{
 800988c:	b480      	push	{r7}
 800988e:	b083      	sub	sp, #12
 8009890:	af00      	add	r7, sp, #0
 8009892:	6078      	str	r0, [r7, #4]
 8009894:	460b      	mov	r3, r1
 8009896:	70fb      	strb	r3, [r7, #3]
 8009898:	4613      	mov	r3, r2
 800989a:	70bb      	strb	r3, [r7, #2]
	if(SET == val)
 800989c:	78bb      	ldrb	r3, [r7, #2]
 800989e:	2b01      	cmp	r3, #1
 80098a0:	d109      	bne.n	80098b6 <GPIO_WritePin+0x2a>
	{
		pGPIOx->ODR.reg |= (1 << PinNumber);
 80098a2:	687b      	ldr	r3, [r7, #4]
 80098a4:	695b      	ldr	r3, [r3, #20]
 80098a6:	78fa      	ldrb	r2, [r7, #3]
 80098a8:	2101      	movs	r1, #1
 80098aa:	fa01 f202 	lsl.w	r2, r1, r2
 80098ae:	431a      	orrs	r2, r3
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	615a      	str	r2, [r3, #20]
	}else
	{
		pGPIOx->ODR.reg &= ~(1 << PinNumber);
	}
}
 80098b4:	e009      	b.n	80098ca <GPIO_WritePin+0x3e>
		pGPIOx->ODR.reg &= ~(1 << PinNumber);
 80098b6:	687b      	ldr	r3, [r7, #4]
 80098b8:	695b      	ldr	r3, [r3, #20]
 80098ba:	78fa      	ldrb	r2, [r7, #3]
 80098bc:	2101      	movs	r1, #1
 80098be:	fa01 f202 	lsl.w	r2, r1, r2
 80098c2:	43d2      	mvns	r2, r2
 80098c4:	401a      	ands	r2, r3
 80098c6:	687b      	ldr	r3, [r7, #4]
 80098c8:	615a      	str	r2, [r3, #20]
}
 80098ca:	bf00      	nop
 80098cc:	370c      	adds	r7, #12
 80098ce:	46bd      	mov	sp, r7
 80098d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098d4:	4770      	bx	lr

080098d6 <I2C_GenerateStartCondition>:
static void I2C_MasterHandleRXNEInterrupt(I2C_Handle_t *pI2CHandle );
static void I2C_MasterHandleTXEInterrupt(I2C_Handle_t *pI2CHandle );


static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
 80098d6:	b480      	push	{r7}
 80098d8:	b083      	sub	sp, #12
 80098da:	af00      	add	r7, sp, #0
 80098dc:	6078      	str	r0, [r7, #4]
	pI2Cx->CR1.bit.start = SET;
 80098de:	687a      	ldr	r2, [r7, #4]
 80098e0:	8813      	ldrh	r3, [r2, #0]
 80098e2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80098e6:	8013      	strh	r3, [r2, #0]
}
 80098e8:	bf00      	nop
 80098ea:	370c      	adds	r7, #12
 80098ec:	46bd      	mov	sp, r7
 80098ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098f2:	4770      	bx	lr

080098f4 <I2C_ExecuteAddressPhaseWrite>:

static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
{
 80098f4:	b480      	push	{r7}
 80098f6:	b083      	sub	sp, #12
 80098f8:	af00      	add	r7, sp, #0
 80098fa:	6078      	str	r0, [r7, #4]
 80098fc:	460b      	mov	r3, r1
 80098fe:	70fb      	strb	r3, [r7, #3]
	SlaveAddr = SlaveAddr << 1;
 8009900:	78fb      	ldrb	r3, [r7, #3]
 8009902:	005b      	lsls	r3, r3, #1
 8009904:	70fb      	strb	r3, [r7, #3]
	//clear 0th bit because 0th bit is 'read/write' bit and '0' stands for 'write'
	SlaveAddr &= ~(1);
 8009906:	78fb      	ldrb	r3, [r7, #3]
 8009908:	f023 0301 	bic.w	r3, r3, #1
 800990c:	70fb      	strb	r3, [r7, #3]
	pI2Cx->DR.bit.dr = SlaveAddr;
 800990e:	687a      	ldr	r2, [r7, #4]
 8009910:	78f9      	ldrb	r1, [r7, #3]
 8009912:	8a13      	ldrh	r3, [r2, #16]
 8009914:	f361 0307 	bfi	r3, r1, #0, #8
 8009918:	8213      	strh	r3, [r2, #16]
}
 800991a:	bf00      	nop
 800991c:	370c      	adds	r7, #12
 800991e:	46bd      	mov	sp, r7
 8009920:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009924:	4770      	bx	lr

08009926 <I2C_ClearADDRFlag>:
	pI2Cx->DR.bit.dr = SlaveAddr;
}


static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle )
{
 8009926:	b580      	push	{r7, lr}
 8009928:	b084      	sub	sp, #16
 800992a:	af00      	add	r7, sp, #0
 800992c:	6078      	str	r0, [r7, #4]
	uint32_t read_statusreg_dummy;

	//check for device mode
	if(ENABLE == pI2CHandle->pI2Cx->SR2.bit.msl)
 800992e:	687b      	ldr	r3, [r7, #4]
 8009930:	681b      	ldr	r3, [r3, #0]
 8009932:	699b      	ldr	r3, [r3, #24]
 8009934:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009938:	b2db      	uxtb	r3, r3
 800993a:	2b01      	cmp	r3, #1
 800993c:	d11f      	bne.n	800997e <I2C_ClearADDRFlag+0x58>
	{
		//device is in master mode
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
 800993e:	687b      	ldr	r3, [r7, #4]
 8009940:	7f1b      	ldrb	r3, [r3, #28]
 8009942:	2b01      	cmp	r3, #1
 8009944:	d112      	bne.n	800996c <I2C_ClearADDRFlag+0x46>
		{
			if(pI2CHandle->RxSize  == 1)
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	6a1b      	ldr	r3, [r3, #32]
 800994a:	2b01      	cmp	r3, #1
 800994c:	d11f      	bne.n	800998e <I2C_ClearADDRFlag+0x68>
			{
				//first disable the ack
				I2C_ManageAcking(pI2CHandle->pI2Cx,I2C_ACK_DISABLE);
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	681b      	ldr	r3, [r3, #0]
 8009952:	2100      	movs	r1, #0
 8009954:	4618      	mov	r0, r3
 8009956:	f000 fa71 	bl	8009e3c <I2C_ManageAcking>

				//clear the ADDR flag ( read SR1 , read SR2)
				read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 800995a:	687b      	ldr	r3, [r7, #4]
 800995c:	681b      	ldr	r3, [r3, #0]
 800995e:	695b      	ldr	r3, [r3, #20]
 8009960:	60fb      	str	r3, [r7, #12]
				read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 8009962:	687b      	ldr	r3, [r7, #4]
 8009964:	681b      	ldr	r3, [r3, #0]
 8009966:	699b      	ldr	r3, [r3, #24]
 8009968:	60fb      	str	r3, [r7, #12]
		//clear the ADDR flag ( read SR1 , read SR2)
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
		(void)read_statusreg_dummy;
	}
}
 800996a:	e010      	b.n	800998e <I2C_ClearADDRFlag+0x68>
			read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 800996c:	687b      	ldr	r3, [r7, #4]
 800996e:	681b      	ldr	r3, [r3, #0]
 8009970:	695b      	ldr	r3, [r3, #20]
 8009972:	60fb      	str	r3, [r7, #12]
			read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 8009974:	687b      	ldr	r3, [r7, #4]
 8009976:	681b      	ldr	r3, [r3, #0]
 8009978:	699b      	ldr	r3, [r3, #24]
 800997a:	60fb      	str	r3, [r7, #12]
}
 800997c:	e007      	b.n	800998e <I2C_ClearADDRFlag+0x68>
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 800997e:	687b      	ldr	r3, [r7, #4]
 8009980:	681b      	ldr	r3, [r3, #0]
 8009982:	695b      	ldr	r3, [r3, #20]
 8009984:	60fb      	str	r3, [r7, #12]
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 8009986:	687b      	ldr	r3, [r7, #4]
 8009988:	681b      	ldr	r3, [r3, #0]
 800998a:	699b      	ldr	r3, [r3, #24]
 800998c:	60fb      	str	r3, [r7, #12]
}
 800998e:	bf00      	nop
 8009990:	3710      	adds	r7, #16
 8009992:	46bd      	mov	sp, r7
 8009994:	bd80      	pop	{r7, pc}

08009996 <I2C_GenerateStopCondition>:


void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
 8009996:	b480      	push	{r7}
 8009998:	b083      	sub	sp, #12
 800999a:	af00      	add	r7, sp, #0
 800999c:	6078      	str	r0, [r7, #4]
	pI2Cx->CR1.bit.stop = SET;
 800999e:	687a      	ldr	r2, [r7, #4]
 80099a0:	8813      	ldrh	r3, [r2, #0]
 80099a2:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80099a6:	8013      	strh	r3, [r2, #0]
}
 80099a8:	bf00      	nop
 80099aa:	370c      	adds	r7, #12
 80099ac:	46bd      	mov	sp, r7
 80099ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099b2:	4770      	bx	lr

080099b4 <I2C_PeripheralControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 80099b4:	b480      	push	{r7}
 80099b6:	b083      	sub	sp, #12
 80099b8:	af00      	add	r7, sp, #0
 80099ba:	6078      	str	r0, [r7, #4]
 80099bc:	460b      	mov	r3, r1
 80099be:	70fb      	strb	r3, [r7, #3]
	pI2Cx->CR1.bit.pe = state;
 80099c0:	78fb      	ldrb	r3, [r7, #3]
 80099c2:	f003 0301 	and.w	r3, r3, #1
 80099c6:	b2d9      	uxtb	r1, r3
 80099c8:	687a      	ldr	r2, [r7, #4]
 80099ca:	8813      	ldrh	r3, [r2, #0]
 80099cc:	f361 0300 	bfi	r3, r1, #0, #1
 80099d0:	8013      	strh	r3, [r2, #0]
}
 80099d2:	bf00      	nop
 80099d4:	370c      	adds	r7, #12
 80099d6:	46bd      	mov	sp, r7
 80099d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099dc:	4770      	bx	lr
	...

080099e0 <I2C_PeriphClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_PeriphClockControl(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 80099e0:	b480      	push	{r7}
 80099e2:	b083      	sub	sp, #12
 80099e4:	af00      	add	r7, sp, #0
 80099e6:	6078      	str	r0, [r7, #4]
 80099e8:	460b      	mov	r3, r1
 80099ea:	70fb      	strb	r3, [r7, #3]
		if(pI2Cx == I2C1)
 80099ec:	687b      	ldr	r3, [r7, #4]
 80099ee:	4a17      	ldr	r2, [pc, #92]	@ (8009a4c <I2C_PeriphClockControl+0x6c>)
 80099f0:	4293      	cmp	r3, r2
 80099f2:	d109      	bne.n	8009a08 <I2C_PeriphClockControl+0x28>
		{
			RCC->APB1ENR.bit.i2c1en = state;
 80099f4:	4a16      	ldr	r2, [pc, #88]	@ (8009a50 <I2C_PeriphClockControl+0x70>)
 80099f6:	78fb      	ldrb	r3, [r7, #3]
 80099f8:	f003 0301 	and.w	r3, r3, #1
 80099fc:	b2d9      	uxtb	r1, r3
 80099fe:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009a00:	f361 5355 	bfi	r3, r1, #21, #1
 8009a04:	6413      	str	r3, [r2, #64]	@ 0x40
		else if (pI2Cx == I2C3)
		{
			RCC->APB1ENR.bit.i2c3en = state;
		}

}
 8009a06:	e01a      	b.n	8009a3e <I2C_PeriphClockControl+0x5e>
		else if (pI2Cx == I2C2)
 8009a08:	687b      	ldr	r3, [r7, #4]
 8009a0a:	4a12      	ldr	r2, [pc, #72]	@ (8009a54 <I2C_PeriphClockControl+0x74>)
 8009a0c:	4293      	cmp	r3, r2
 8009a0e:	d109      	bne.n	8009a24 <I2C_PeriphClockControl+0x44>
			RCC->APB1ENR.bit.i2c2en = state;
 8009a10:	4a0f      	ldr	r2, [pc, #60]	@ (8009a50 <I2C_PeriphClockControl+0x70>)
 8009a12:	78fb      	ldrb	r3, [r7, #3]
 8009a14:	f003 0301 	and.w	r3, r3, #1
 8009a18:	b2d9      	uxtb	r1, r3
 8009a1a:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009a1c:	f361 5396 	bfi	r3, r1, #22, #1
 8009a20:	6413      	str	r3, [r2, #64]	@ 0x40
}
 8009a22:	e00c      	b.n	8009a3e <I2C_PeriphClockControl+0x5e>
		else if (pI2Cx == I2C3)
 8009a24:	687b      	ldr	r3, [r7, #4]
 8009a26:	4a0c      	ldr	r2, [pc, #48]	@ (8009a58 <I2C_PeriphClockControl+0x78>)
 8009a28:	4293      	cmp	r3, r2
 8009a2a:	d108      	bne.n	8009a3e <I2C_PeriphClockControl+0x5e>
			RCC->APB1ENR.bit.i2c3en = state;
 8009a2c:	4a08      	ldr	r2, [pc, #32]	@ (8009a50 <I2C_PeriphClockControl+0x70>)
 8009a2e:	78fb      	ldrb	r3, [r7, #3]
 8009a30:	f003 0301 	and.w	r3, r3, #1
 8009a34:	b2d9      	uxtb	r1, r3
 8009a36:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009a38:	f361 53d7 	bfi	r3, r1, #23, #1
 8009a3c:	6413      	str	r3, [r2, #64]	@ 0x40
}
 8009a3e:	bf00      	nop
 8009a40:	370c      	adds	r7, #12
 8009a42:	46bd      	mov	sp, r7
 8009a44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a48:	4770      	bx	lr
 8009a4a:	bf00      	nop
 8009a4c:	40005400 	.word	0x40005400
 8009a50:	40023800 	.word	0x40023800
 8009a54:	40005800 	.word	0x40005800
 8009a58:	40005c00 	.word	0x40005c00

08009a5c <I2C_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
 8009a5c:	b580      	push	{r7, lr}
 8009a5e:	b086      	sub	sp, #24
 8009a60:	af00      	add	r7, sp, #0
 8009a62:	6078      	str	r0, [r7, #4]
	uint32_t temp = 0;
 8009a64:	2300      	movs	r3, #0
 8009a66:	613b      	str	r3, [r7, #16]
	uint8_t trise;

	//enable the clock for the I2Cx peripheral
	I2C_PeriphClockControl(pI2CHandle->pI2Cx,ENABLE);
 8009a68:	687b      	ldr	r3, [r7, #4]
 8009a6a:	681b      	ldr	r3, [r3, #0]
 8009a6c:	2101      	movs	r1, #1
 8009a6e:	4618      	mov	r0, r3
 8009a70:	f7ff ffb6 	bl	80099e0 <I2C_PeriphClockControl>

	//configure the FREQ field of CR2
	temp = 0;
 8009a74:	2300      	movs	r3, #0
 8009a76:	613b      	str	r3, [r7, #16]
//	temp |= RCC_GetPCLK1Freq() /1000000U;
	temp |= HAL_RCC_GetPCLK1Freq() / 1000000U;
 8009a78:	f7fd f818 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009a7c:	4603      	mov	r3, r0
 8009a7e:	4a56      	ldr	r2, [pc, #344]	@ (8009bd8 <I2C_Init+0x17c>)
 8009a80:	fba2 2303 	umull	r2, r3, r2, r3
 8009a84:	0c9b      	lsrs	r3, r3, #18
 8009a86:	693a      	ldr	r2, [r7, #16]
 8009a88:	4313      	orrs	r3, r2
 8009a8a:	613b      	str	r3, [r7, #16]
	pI2CHandle->pI2Cx->CR2.bit.freq = temp;
 8009a8c:	687b      	ldr	r3, [r7, #4]
 8009a8e:	681a      	ldr	r2, [r3, #0]
 8009a90:	693b      	ldr	r3, [r7, #16]
 8009a92:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8009a96:	b2d9      	uxtb	r1, r3
 8009a98:	8893      	ldrh	r3, [r2, #4]
 8009a9a:	f361 0305 	bfi	r3, r1, #0, #6
 8009a9e:	8093      	strh	r3, [r2, #4]

   //program the device own address
	temp = 0;
 8009aa0:	2300      	movs	r3, #0
 8009aa2:	613b      	str	r3, [r7, #16]
	temp |= pI2CHandle->I2C_Config.I2C_DeviceAddress << 1;
 8009aa4:	687b      	ldr	r3, [r7, #4]
 8009aa6:	7a1b      	ldrb	r3, [r3, #8]
 8009aa8:	005b      	lsls	r3, r3, #1
 8009aaa:	693a      	ldr	r2, [r7, #16]
 8009aac:	4313      	orrs	r3, r2
 8009aae:	613b      	str	r3, [r7, #16]
	//reference manual states that it should always be kept equal to 1 by software
	temp |= ( 1 << 14);
 8009ab0:	693b      	ldr	r3, [r7, #16]
 8009ab2:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8009ab6:	613b      	str	r3, [r7, #16]
//	temp |= (1 << 15);	//uncomment if you are using 10-bit slave address
	pI2CHandle->pI2Cx->OAR1.reg = temp;
 8009ab8:	687b      	ldr	r3, [r7, #4]
 8009aba:	681b      	ldr	r3, [r3, #0]
 8009abc:	693a      	ldr	r2, [r7, #16]
 8009abe:	609a      	str	r2, [r3, #8]

	//CCR calculations
	I2C_CCR_Reg_t CCR_temp = {0};
 8009ac0:	2300      	movs	r3, #0
 8009ac2:	60fb      	str	r3, [r7, #12]
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_STANDARD)
 8009ac4:	687b      	ldr	r3, [r7, #4]
 8009ac6:	685b      	ldr	r3, [r3, #4]
 8009ac8:	4a44      	ldr	r2, [pc, #272]	@ (8009bdc <I2C_Init+0x180>)
 8009aca:	4293      	cmp	r3, r2
 8009acc:	d80f      	bhi.n	8009aee <I2C_Init+0x92>
	{
		//mode is standard mode
		//CCR = Tscl/(2*Tpclk1) => CCR = f(pclk1)/[2*f(scl)]
//		CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
		CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 8009ace:	f7fc ffed 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009ad2:	4602      	mov	r2, r0
 8009ad4:	687b      	ldr	r3, [r7, #4]
 8009ad6:	685b      	ldr	r3, [r3, #4]
 8009ad8:	005b      	lsls	r3, r3, #1
 8009ada:	fbb2 f3f3 	udiv	r3, r2, r3
 8009ade:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8009ae2:	b29a      	uxth	r2, r3
 8009ae4:	89bb      	ldrh	r3, [r7, #12]
 8009ae6:	f362 030b 	bfi	r3, r2, #0, #12
 8009aea:	81bb      	strh	r3, [r7, #12]
 8009aec:	e035      	b.n	8009b5a <I2C_Init+0xfe>
	}
	else
	{
		//mode is fast mode
		CCR_temp.bit.fs =  ENABLE;
 8009aee:	89bb      	ldrh	r3, [r7, #12]
 8009af0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8009af4:	81bb      	strh	r3, [r7, #12]
		CCR_temp.bit.duty = pI2CHandle->I2C_Config.I2C_FMDutyCycle;
 8009af6:	687b      	ldr	r3, [r7, #4]
 8009af8:	7a9b      	ldrb	r3, [r3, #10]
 8009afa:	f003 0301 	and.w	r3, r3, #1
 8009afe:	b2da      	uxtb	r2, r3
 8009b00:	89bb      	ldrh	r3, [r7, #12]
 8009b02:	f362 338e 	bfi	r3, r2, #14, #1
 8009b06:	81bb      	strh	r3, [r7, #12]
		if(I2C_FM_DUTY_2 == pI2CHandle->I2C_Config.I2C_FMDutyCycle)
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	7a9b      	ldrb	r3, [r3, #10]
 8009b0c:	2b00      	cmp	r3, #0
 8009b0e:	d111      	bne.n	8009b34 <I2C_Init+0xd8>
		{
//			CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
			CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 8009b10:	f7fc ffcc 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009b14:	4601      	mov	r1, r0
 8009b16:	687b      	ldr	r3, [r7, #4]
 8009b18:	685a      	ldr	r2, [r3, #4]
 8009b1a:	4613      	mov	r3, r2
 8009b1c:	005b      	lsls	r3, r3, #1
 8009b1e:	4413      	add	r3, r2
 8009b20:	fbb1 f3f3 	udiv	r3, r1, r3
 8009b24:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8009b28:	b29a      	uxth	r2, r3
 8009b2a:	89bb      	ldrh	r3, [r7, #12]
 8009b2c:	f362 030b 	bfi	r3, r2, #0, #12
 8009b30:	81bb      	strh	r3, [r7, #12]
 8009b32:	e012      	b.n	8009b5a <I2C_Init+0xfe>
		}
		else
		{
//			CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
			CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 8009b34:	f7fc ffba 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009b38:	4601      	mov	r1, r0
 8009b3a:	687b      	ldr	r3, [r7, #4]
 8009b3c:	685a      	ldr	r2, [r3, #4]
 8009b3e:	4613      	mov	r3, r2
 8009b40:	009b      	lsls	r3, r3, #2
 8009b42:	4413      	add	r3, r2
 8009b44:	009a      	lsls	r2, r3, #2
 8009b46:	4413      	add	r3, r2
 8009b48:	fbb1 f3f3 	udiv	r3, r1, r3
 8009b4c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8009b50:	b29a      	uxth	r2, r3
 8009b52:	89bb      	ldrh	r3, [r7, #12]
 8009b54:	f362 030b 	bfi	r3, r2, #0, #12
 8009b58:	81bb      	strh	r3, [r7, #12]
		}
	}
	pI2CHandle->pI2Cx->CCR.reg = CCR_temp.reg;
 8009b5a:	687b      	ldr	r3, [r7, #4]
 8009b5c:	681b      	ldr	r3, [r3, #0]
 8009b5e:	68fa      	ldr	r2, [r7, #12]
 8009b60:	61da      	str	r2, [r3, #28]

	//TRISE Configuration
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_STANDARD)
 8009b62:	687b      	ldr	r3, [r7, #4]
 8009b64:	685b      	ldr	r3, [r3, #4]
 8009b66:	4a1d      	ldr	r2, [pc, #116]	@ (8009bdc <I2C_Init+0x180>)
 8009b68:	4293      	cmp	r3, r2
 8009b6a:	d80a      	bhi.n	8009b82 <I2C_Init+0x126>
	{
		//mode is standard mode
//		trise = (RCC_GetPCLK1Freq() /1000000U) + 1 ;
		trise = (HAL_RCC_GetPCLK1Freq() /1000000U) + 1 ;
 8009b6c:	f7fc ff9e 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009b70:	4603      	mov	r3, r0
 8009b72:	4a19      	ldr	r2, [pc, #100]	@ (8009bd8 <I2C_Init+0x17c>)
 8009b74:	fba2 2303 	umull	r2, r3, r2, r3
 8009b78:	0c9b      	lsrs	r3, r3, #18
 8009b7a:	b2db      	uxtb	r3, r3
 8009b7c:	3301      	adds	r3, #1
 8009b7e:	75fb      	strb	r3, [r7, #23]
 8009b80:	e00e      	b.n	8009ba0 <I2C_Init+0x144>
	}
	else
	{
		//mode is fast mode
//		trise = ( (RCC_GetPCLK1Freq() * 300) / 1000000000U ) + 1;
		trise = ( (HAL_RCC_GetPCLK1Freq() * 300) / 1000000000U ) + 1;
 8009b82:	f7fc ff93 	bl	8006aac <HAL_RCC_GetPCLK1Freq>
 8009b86:	4603      	mov	r3, r0
 8009b88:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 8009b8c:	fb02 f303 	mul.w	r3, r2, r3
 8009b90:	0a5b      	lsrs	r3, r3, #9
 8009b92:	4a13      	ldr	r2, [pc, #76]	@ (8009be0 <I2C_Init+0x184>)
 8009b94:	fba2 2303 	umull	r2, r3, r2, r3
 8009b98:	09db      	lsrs	r3, r3, #7
 8009b9a:	b2db      	uxtb	r3, r3
 8009b9c:	3301      	adds	r3, #1
 8009b9e:	75fb      	strb	r3, [r7, #23]

	}

	pI2CHandle->pI2Cx->TRISE.bit.trise = trise;
 8009ba0:	687b      	ldr	r3, [r7, #4]
 8009ba2:	681a      	ldr	r2, [r3, #0]
 8009ba4:	7dfb      	ldrb	r3, [r7, #23]
 8009ba6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8009baa:	b2d9      	uxtb	r1, r3
 8009bac:	8c13      	ldrh	r3, [r2, #32]
 8009bae:	f361 0305 	bfi	r3, r1, #0, #6
 8009bb2:	8413      	strh	r3, [r2, #32]

	//I2C peripheral enabled
	I2C_PeripheralControl(pI2CHandle->pI2Cx, ENABLE);
 8009bb4:	687b      	ldr	r3, [r7, #4]
 8009bb6:	681b      	ldr	r3, [r3, #0]
 8009bb8:	2101      	movs	r1, #1
 8009bba:	4618      	mov	r0, r3
 8009bbc:	f7ff fefa 	bl	80099b4 <I2C_PeripheralControl>

	//ACK control bit set
	I2C_ManageAcking(pI2CHandle->pI2Cx, pI2CHandle->I2C_Config.I2C_AckControl);
 8009bc0:	687b      	ldr	r3, [r7, #4]
 8009bc2:	681a      	ldr	r2, [r3, #0]
 8009bc4:	687b      	ldr	r3, [r7, #4]
 8009bc6:	7a5b      	ldrb	r3, [r3, #9]
 8009bc8:	4619      	mov	r1, r3
 8009bca:	4610      	mov	r0, r2
 8009bcc:	f000 f936 	bl	8009e3c <I2C_ManageAcking>
}
 8009bd0:	bf00      	nop
 8009bd2:	3718      	adds	r7, #24
 8009bd4:	46bd      	mov	sp, r7
 8009bd6:	bd80      	pop	{r7, pc}
 8009bd8:	431bde83 	.word	0x431bde83
 8009bdc:	000186a0 	.word	0x000186a0
 8009be0:	00044b83 	.word	0x00044b83

08009be4 <I2C_GetFlagStatus>:
/* @return				- flag state																	*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx , uint32_t FlagName)
{
 8009be4:	b480      	push	{r7}
 8009be6:	b083      	sub	sp, #12
 8009be8:	af00      	add	r7, sp, #0
 8009bea:	6078      	str	r0, [r7, #4]
 8009bec:	6039      	str	r1, [r7, #0]
	switch(FlagName)
 8009bee:	683b      	ldr	r3, [r7, #0]
 8009bf0:	2b13      	cmp	r3, #19
 8009bf2:	d87f      	bhi.n	8009cf4 <I2C_GetFlagStatus+0x110>
 8009bf4:	a201      	add	r2, pc, #4	@ (adr r2, 8009bfc <I2C_GetFlagStatus+0x18>)
 8009bf6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009bfa:	bf00      	nop
 8009bfc:	08009c4d 	.word	0x08009c4d
 8009c00:	08009c59 	.word	0x08009c59
 8009c04:	08009c65 	.word	0x08009c65
 8009c08:	08009c71 	.word	0x08009c71
 8009c0c:	08009c7d 	.word	0x08009c7d
 8009c10:	08009c89 	.word	0x08009c89
 8009c14:	08009c95 	.word	0x08009c95
 8009c18:	08009ca1 	.word	0x08009ca1
 8009c1c:	08009cad 	.word	0x08009cad
 8009c20:	08009cb9 	.word	0x08009cb9
 8009c24:	08009cf5 	.word	0x08009cf5
 8009c28:	08009cf5 	.word	0x08009cf5
 8009c2c:	08009cf5 	.word	0x08009cf5
 8009c30:	08009cf5 	.word	0x08009cf5
 8009c34:	08009cf5 	.word	0x08009cf5
 8009c38:	08009cf5 	.word	0x08009cf5
 8009c3c:	08009cc5 	.word	0x08009cc5
 8009c40:	08009cd1 	.word	0x08009cd1
 8009c44:	08009cdd 	.word	0x08009cdd
 8009c48:	08009ce9 	.word	0x08009ce9
	{
		case I2C_SR1_SB:
		{
			return pI2Cx->SR1.bit.sb;
 8009c4c:	687b      	ldr	r3, [r7, #4]
 8009c4e:	695b      	ldr	r3, [r3, #20]
 8009c50:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009c54:	b2db      	uxtb	r3, r3
 8009c56:	e04e      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ADDR:
		{
			return pI2Cx->SR1.bit.addr;
 8009c58:	687b      	ldr	r3, [r7, #4]
 8009c5a:	695b      	ldr	r3, [r3, #20]
 8009c5c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8009c60:	b2db      	uxtb	r3, r3
 8009c62:	e048      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_BTF:
		{
			return pI2Cx->SR1.bit.btf;
 8009c64:	687b      	ldr	r3, [r7, #4]
 8009c66:	695b      	ldr	r3, [r3, #20]
 8009c68:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8009c6c:	b2db      	uxtb	r3, r3
 8009c6e:	e042      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ADD10:
		{
			return pI2Cx->SR1.bit.add10;
 8009c70:	687b      	ldr	r3, [r7, #4]
 8009c72:	695b      	ldr	r3, [r3, #20]
 8009c74:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8009c78:	b2db      	uxtb	r3, r3
 8009c7a:	e03c      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_STOPF:
		{
			return pI2Cx->SR1.bit.stopf;
 8009c7c:	687b      	ldr	r3, [r7, #4]
 8009c7e:	695b      	ldr	r3, [r3, #20]
 8009c80:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8009c84:	b2db      	uxtb	r3, r3
 8009c86:	e036      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_RxNE:
		{
			return pI2Cx->SR1.bit.rxne;
 8009c88:	687b      	ldr	r3, [r7, #4]
 8009c8a:	695b      	ldr	r3, [r3, #20]
 8009c8c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009c90:	b2db      	uxtb	r3, r3
 8009c92:	e030      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_TxE:
		{
			return pI2Cx->SR1.bit.txe;
 8009c94:	687b      	ldr	r3, [r7, #4]
 8009c96:	695b      	ldr	r3, [r3, #20]
 8009c98:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8009c9c:	b2db      	uxtb	r3, r3
 8009c9e:	e02a      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_BERR:
		{
			return pI2Cx->SR1.bit.berr;
 8009ca0:	687b      	ldr	r3, [r7, #4]
 8009ca2:	695b      	ldr	r3, [r3, #20]
 8009ca4:	f3c3 2300 	ubfx	r3, r3, #8, #1
 8009ca8:	b2db      	uxtb	r3, r3
 8009caa:	e024      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ARLO:
		{
			return pI2Cx->SR1.bit.arlo;
 8009cac:	687b      	ldr	r3, [r7, #4]
 8009cae:	695b      	ldr	r3, [r3, #20]
 8009cb0:	f3c3 2340 	ubfx	r3, r3, #9, #1
 8009cb4:	b2db      	uxtb	r3, r3
 8009cb6:	e01e      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_AF:
		{
			return pI2Cx->SR1.bit.af;
 8009cb8:	687b      	ldr	r3, [r7, #4]
 8009cba:	695b      	ldr	r3, [r3, #20]
 8009cbc:	f3c3 2380 	ubfx	r3, r3, #10, #1
 8009cc0:	b2db      	uxtb	r3, r3
 8009cc2:	e018      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_OVR:
		{
			return pI2Cx->SR1.bit.ovr;
 8009cc4:	687b      	ldr	r3, [r7, #4]
 8009cc6:	695b      	ldr	r3, [r3, #20]
 8009cc8:	f3c3 23c0 	ubfx	r3, r3, #11, #1
 8009ccc:	b2db      	uxtb	r3, r3
 8009cce:	e012      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_PECERR:
		{
			return pI2Cx->SR1.bit.pecerr;
 8009cd0:	687b      	ldr	r3, [r7, #4]
 8009cd2:	695b      	ldr	r3, [r3, #20]
 8009cd4:	f3c3 3300 	ubfx	r3, r3, #12, #1
 8009cd8:	b2db      	uxtb	r3, r3
 8009cda:	e00c      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_TIMEOUT:
		{
			return pI2Cx->SR1.bit.timeout;
 8009cdc:	687b      	ldr	r3, [r7, #4]
 8009cde:	695b      	ldr	r3, [r3, #20]
 8009ce0:	f3c3 3380 	ubfx	r3, r3, #14, #1
 8009ce4:	b2db      	uxtb	r3, r3
 8009ce6:	e006      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_SMBALERT:
		{
			return pI2Cx->SR1.bit.smbalert;
 8009ce8:	687b      	ldr	r3, [r7, #4]
 8009cea:	695b      	ldr	r3, [r3, #20]
 8009cec:	f3c3 33c0 	ubfx	r3, r3, #15, #1
 8009cf0:	b2db      	uxtb	r3, r3
 8009cf2:	e000      	b.n	8009cf6 <I2C_GetFlagStatus+0x112>
			break;
		}
		default:
			return RESET;
 8009cf4:	2300      	movs	r3, #0
	}
}
 8009cf6:	4618      	mov	r0, r3
 8009cf8:	370c      	adds	r7, #12
 8009cfa:	46bd      	mov	sp, r7
 8009cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d00:	4770      	bx	lr
 8009d02:	bf00      	nop

08009d04 <I2C_Mem_Write>:
/* @return				- none																			*/
/*																										*/
/* @Note					- blocking function																*/
/********************************************************************************************************/
void I2C_Mem_Write(I2C_Handle_t *pI2CHandle, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8009d04:	b580      	push	{r7, lr}
 8009d06:	b084      	sub	sp, #16
 8009d08:	af00      	add	r7, sp, #0
 8009d0a:	60f8      	str	r0, [r7, #12]
 8009d0c:	4608      	mov	r0, r1
 8009d0e:	4611      	mov	r1, r2
 8009d10:	461a      	mov	r2, r3
 8009d12:	4603      	mov	r3, r0
 8009d14:	817b      	strh	r3, [r7, #10]
 8009d16:	460b      	mov	r3, r1
 8009d18:	813b      	strh	r3, [r7, #8]
 8009d1a:	4613      	mov	r3, r2
 8009d1c:	80fb      	strh	r3, [r7, #6]
    // Generate the Start Condition
    I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
 8009d1e:	68fb      	ldr	r3, [r7, #12]
 8009d20:	681b      	ldr	r3, [r3, #0]
 8009d22:	4618      	mov	r0, r3
 8009d24:	f7ff fdd7 	bl	80098d6 <I2C_GenerateStartCondition>

    // Wait until SB flag is set
    while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_SB));
 8009d28:	bf00      	nop
 8009d2a:	68fb      	ldr	r3, [r7, #12]
 8009d2c:	681b      	ldr	r3, [r3, #0]
 8009d2e:	2100      	movs	r1, #0
 8009d30:	4618      	mov	r0, r3
 8009d32:	f7ff ff57 	bl	8009be4 <I2C_GetFlagStatus>
 8009d36:	4603      	mov	r3, r0
 8009d38:	2b00      	cmp	r3, #0
 8009d3a:	d0f6      	beq.n	8009d2a <I2C_Mem_Write+0x26>

    // Send the device address with write option
    I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, DevAddress);
 8009d3c:	68fb      	ldr	r3, [r7, #12]
 8009d3e:	681b      	ldr	r3, [r3, #0]
 8009d40:	897a      	ldrh	r2, [r7, #10]
 8009d42:	b2d2      	uxtb	r2, r2
 8009d44:	4611      	mov	r1, r2
 8009d46:	4618      	mov	r0, r3
 8009d48:	f7ff fdd4 	bl	80098f4 <I2C_ExecuteAddressPhaseWrite>

    // Wait until ADDR flag is set
    while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_ADDR))
 8009d4c:	bf00      	nop
 8009d4e:	68fb      	ldr	r3, [r7, #12]
 8009d50:	681b      	ldr	r3, [r3, #0]
 8009d52:	2101      	movs	r1, #1
 8009d54:	4618      	mov	r0, r3
 8009d56:	f7ff ff45 	bl	8009be4 <I2C_GetFlagStatus>
 8009d5a:	4603      	mov	r3, r0
 8009d5c:	2b00      	cmp	r3, #0
 8009d5e:	d0f6      	beq.n	8009d4e <I2C_Mem_Write+0x4a>
    {

    }

    // Clear the ADDR flag
    I2C_ClearADDRFlag(pI2CHandle);
 8009d60:	68f8      	ldr	r0, [r7, #12]
 8009d62:	f7ff fde0 	bl	8009926 <I2C_ClearADDRFlag>

    // Wait until TXE flag is set
    while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_TxE))
 8009d66:	bf00      	nop
 8009d68:	68fb      	ldr	r3, [r7, #12]
 8009d6a:	681b      	ldr	r3, [r3, #0]
 8009d6c:	2106      	movs	r1, #6
 8009d6e:	4618      	mov	r0, r3
 8009d70:	f7ff ff38 	bl	8009be4 <I2C_GetFlagStatus>
 8009d74:	4603      	mov	r3, r0
 8009d76:	2b00      	cmp	r3, #0
 8009d78:	d0f6      	beq.n	8009d68 <I2C_Mem_Write+0x64>
    {

    }

    // If memory address size is 16 bits
    if (MemAddSize == I2C_MEMADD_SIZE_16BIT)
 8009d7a:	88fb      	ldrh	r3, [r7, #6]
 8009d7c:	2b00      	cmp	r3, #0
 8009d7e:	d11c      	bne.n	8009dba <I2C_Mem_Write+0xb6>
    {
        // Send the high byte of the memory address
        pI2CHandle->pI2Cx->DR.bit.dr = (uint8_t)((MemAddress & 0xFF00) >> 8);
 8009d80:	893b      	ldrh	r3, [r7, #8]
 8009d82:	0a1b      	lsrs	r3, r3, #8
 8009d84:	b299      	uxth	r1, r3
 8009d86:	68fb      	ldr	r3, [r7, #12]
 8009d88:	681a      	ldr	r2, [r3, #0]
 8009d8a:	b2c9      	uxtb	r1, r1
 8009d8c:	8a13      	ldrh	r3, [r2, #16]
 8009d8e:	f361 0307 	bfi	r3, r1, #0, #8
 8009d92:	8213      	strh	r3, [r2, #16]

        // Wait until TXE flag is set
        while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_TxE))
 8009d94:	bf00      	nop
 8009d96:	68fb      	ldr	r3, [r7, #12]
 8009d98:	681b      	ldr	r3, [r3, #0]
 8009d9a:	2106      	movs	r1, #6
 8009d9c:	4618      	mov	r0, r3
 8009d9e:	f7ff ff21 	bl	8009be4 <I2C_GetFlagStatus>
 8009da2:	4603      	mov	r3, r0
 8009da4:	2b00      	cmp	r3, #0
 8009da6:	d0f6      	beq.n	8009d96 <I2C_Mem_Write+0x92>
        {

        }

        // Send the low byte of the memory address
        pI2CHandle->pI2Cx->DR.bit.dr = (uint8_t)(MemAddress & 0x00FF);
 8009da8:	68fb      	ldr	r3, [r7, #12]
 8009daa:	681a      	ldr	r2, [r3, #0]
 8009dac:	893b      	ldrh	r3, [r7, #8]
 8009dae:	b2d9      	uxtb	r1, r3
 8009db0:	8a13      	ldrh	r3, [r2, #16]
 8009db2:	f361 0307 	bfi	r3, r1, #0, #8
 8009db6:	8213      	strh	r3, [r2, #16]
 8009db8:	e007      	b.n	8009dca <I2C_Mem_Write+0xc6>
    }
    else
    {
        // Memory address size is 8 bits, send the memory address
        pI2CHandle->pI2Cx->DR.bit.dr = (uint8_t)MemAddress;
 8009dba:	68fb      	ldr	r3, [r7, #12]
 8009dbc:	681a      	ldr	r2, [r3, #0]
 8009dbe:	893b      	ldrh	r3, [r7, #8]
 8009dc0:	b2d9      	uxtb	r1, r3
 8009dc2:	8a13      	ldrh	r3, [r2, #16]
 8009dc4:	f361 0307 	bfi	r3, r1, #0, #8
 8009dc8:	8213      	strh	r3, [r2, #16]
    }

    // Wait until TXE flag is set
    while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_TxE))
 8009dca:	bf00      	nop
 8009dcc:	68fb      	ldr	r3, [r7, #12]
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	2106      	movs	r1, #6
 8009dd2:	4618      	mov	r0, r3
 8009dd4:	f7ff ff06 	bl	8009be4 <I2C_GetFlagStatus>
 8009dd8:	4603      	mov	r3, r0
 8009dda:	2b00      	cmp	r3, #0
 8009ddc:	d0f6      	beq.n	8009dcc <I2C_Mem_Write+0xc8>
    {

    }

    // Write the data to the memory
    while (Size > 0)
 8009dde:	e017      	b.n	8009e10 <I2C_Mem_Write+0x10c>
    {
        pI2CHandle->pI2Cx->DR.bit.dr = *pData;
 8009de0:	68fb      	ldr	r3, [r7, #12]
 8009de2:	681a      	ldr	r2, [r3, #0]
 8009de4:	69bb      	ldr	r3, [r7, #24]
 8009de6:	7819      	ldrb	r1, [r3, #0]
 8009de8:	8a13      	ldrh	r3, [r2, #16]
 8009dea:	f361 0307 	bfi	r3, r1, #0, #8
 8009dee:	8213      	strh	r3, [r2, #16]
        pData++;
 8009df0:	69bb      	ldr	r3, [r7, #24]
 8009df2:	3301      	adds	r3, #1
 8009df4:	61bb      	str	r3, [r7, #24]
        Size--;
 8009df6:	8bbb      	ldrh	r3, [r7, #28]
 8009df8:	3b01      	subs	r3, #1
 8009dfa:	83bb      	strh	r3, [r7, #28]

        // Wait until TXE flag is set
        while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_TxE))
 8009dfc:	bf00      	nop
 8009dfe:	68fb      	ldr	r3, [r7, #12]
 8009e00:	681b      	ldr	r3, [r3, #0]
 8009e02:	2106      	movs	r1, #6
 8009e04:	4618      	mov	r0, r3
 8009e06:	f7ff feed 	bl	8009be4 <I2C_GetFlagStatus>
 8009e0a:	4603      	mov	r3, r0
 8009e0c:	2b00      	cmp	r3, #0
 8009e0e:	d0f6      	beq.n	8009dfe <I2C_Mem_Write+0xfa>
    while (Size > 0)
 8009e10:	8bbb      	ldrh	r3, [r7, #28]
 8009e12:	2b00      	cmp	r3, #0
 8009e14:	d1e4      	bne.n	8009de0 <I2C_Mem_Write+0xdc>

        }
    }

    // Wait until BTF flag is set
    while (!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SR1_BTF))
 8009e16:	bf00      	nop
 8009e18:	68fb      	ldr	r3, [r7, #12]
 8009e1a:	681b      	ldr	r3, [r3, #0]
 8009e1c:	2102      	movs	r1, #2
 8009e1e:	4618      	mov	r0, r3
 8009e20:	f7ff fee0 	bl	8009be4 <I2C_GetFlagStatus>
 8009e24:	4603      	mov	r3, r0
 8009e26:	2b00      	cmp	r3, #0
 8009e28:	d0f6      	beq.n	8009e18 <I2C_Mem_Write+0x114>
    {

    }

    // Generate the Stop Condition
    I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
 8009e2a:	68fb      	ldr	r3, [r7, #12]
 8009e2c:	681b      	ldr	r3, [r3, #0]
 8009e2e:	4618      	mov	r0, r3
 8009e30:	f7ff fdb1 	bl	8009996 <I2C_GenerateStopCondition>
}
 8009e34:	bf00      	nop
 8009e36:	3710      	adds	r7, #16
 8009e38:	46bd      	mov	sp, r7
 8009e3a:	bd80      	pop	{r7, pc}

08009e3c <I2C_ManageAcking>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 8009e3c:	b480      	push	{r7}
 8009e3e:	b083      	sub	sp, #12
 8009e40:	af00      	add	r7, sp, #0
 8009e42:	6078      	str	r0, [r7, #4]
 8009e44:	460b      	mov	r3, r1
 8009e46:	70fb      	strb	r3, [r7, #3]
	pI2Cx->CR1.bit.ack = state;
 8009e48:	78fb      	ldrb	r3, [r7, #3]
 8009e4a:	f003 0301 	and.w	r3, r3, #1
 8009e4e:	b2d9      	uxtb	r1, r3
 8009e50:	687a      	ldr	r2, [r7, #4]
 8009e52:	8813      	ldrh	r3, [r2, #0]
 8009e54:	f361 238a 	bfi	r3, r1, #10, #1
 8009e58:	8013      	strh	r3, [r2, #0]
}
 8009e5a:	bf00      	nop
 8009e5c:	370c      	adds	r7, #12
 8009e5e:	46bd      	mov	sp, r7
 8009e60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e64:	4770      	bx	lr
	...

08009e68 <RTC_ClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_ClockControl(RTC_Clock_State_t state)
{
 8009e68:	b480      	push	{r7}
 8009e6a:	b083      	sub	sp, #12
 8009e6c:	af00      	add	r7, sp, #0
 8009e6e:	4603      	mov	r3, r0
 8009e70:	71fb      	strb	r3, [r7, #7]
	if (state == RTC_ENABLE)
 8009e72:	79fb      	ldrb	r3, [r7, #7]
 8009e74:	2b01      	cmp	r3, #1
 8009e76:	d105      	bne.n	8009e84 <RTC_ClockControl+0x1c>
	{
		//enable RTC clock
		RCC->BDCR.bit.rtcen = SET;
 8009e78:	4a10      	ldr	r2, [pc, #64]	@ (8009ebc <RTC_ClockControl+0x54>)
 8009e7a:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009e7c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8009e80:	6713      	str	r3, [r2, #112]	@ 0x70
	{
		//backup domain software reset
		RCC->BDCR.bit.bdrst = SET;
		RCC->BDCR.bit.bdrst = RESET;
	}
}
 8009e82:	e015      	b.n	8009eb0 <RTC_ClockControl+0x48>
	else if (state == RTC_DISABLE)
 8009e84:	79fb      	ldrb	r3, [r7, #7]
 8009e86:	2b00      	cmp	r3, #0
 8009e88:	d105      	bne.n	8009e96 <RTC_ClockControl+0x2e>
		RCC->BDCR.bit.rtcen = RESET;
 8009e8a:	4a0c      	ldr	r2, [pc, #48]	@ (8009ebc <RTC_ClockControl+0x54>)
 8009e8c:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009e8e:	f36f 33cf 	bfc	r3, #15, #1
 8009e92:	6713      	str	r3, [r2, #112]	@ 0x70
}
 8009e94:	e00c      	b.n	8009eb0 <RTC_ClockControl+0x48>
	else if(state == RTC_RESET)
 8009e96:	79fb      	ldrb	r3, [r7, #7]
 8009e98:	2b02      	cmp	r3, #2
 8009e9a:	d109      	bne.n	8009eb0 <RTC_ClockControl+0x48>
		RCC->BDCR.bit.bdrst = SET;
 8009e9c:	4a07      	ldr	r2, [pc, #28]	@ (8009ebc <RTC_ClockControl+0x54>)
 8009e9e:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009ea0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009ea4:	6713      	str	r3, [r2, #112]	@ 0x70
		RCC->BDCR.bit.bdrst = RESET;
 8009ea6:	4a05      	ldr	r2, [pc, #20]	@ (8009ebc <RTC_ClockControl+0x54>)
 8009ea8:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009eaa:	f36f 4310 	bfc	r3, #16, #1
 8009eae:	6713      	str	r3, [r2, #112]	@ 0x70
}
 8009eb0:	bf00      	nop
 8009eb2:	370c      	adds	r7, #12
 8009eb4:	46bd      	mov	sp, r7
 8009eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009eba:	4770      	bx	lr
 8009ebc:	40023800 	.word	0x40023800

08009ec0 <RTC_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_Init(RTC_Handle_t *pRTCHandle)
{
 8009ec0:	b580      	push	{r7, lr}
 8009ec2:	b082      	sub	sp, #8
 8009ec4:	af00      	add	r7, sp, #0
 8009ec6:	6078      	str	r0, [r7, #4]
	PWR->CR.bit.dbp = SET;
 8009ec8:	4a2d      	ldr	r2, [pc, #180]	@ (8009f80 <RTC_Init+0xc0>)
 8009eca:	6813      	ldr	r3, [r2, #0]
 8009ecc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8009ed0:	6013      	str	r3, [r2, #0]

	//enable RTC clock
	RTC_ClockControl(RTC_ENABLE);
 8009ed2:	2001      	movs	r0, #1
 8009ed4:	f7ff ffc8 	bl	8009e68 <RTC_ClockControl>

	RCC->BDCR.bit.rtcsel = 2; //LSI
 8009ed8:	4a2a      	ldr	r2, [pc, #168]	@ (8009f84 <RTC_Init+0xc4>)
 8009eda:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009edc:	2102      	movs	r1, #2
 8009ede:	f361 2309 	bfi	r3, r1, #8, #2
 8009ee2:	6713      	str	r3, [r2, #112]	@ 0x70

	//Disable RTC registers write protection
	RTC->WPR.bit.key = 0xCA;
 8009ee4:	4a28      	ldr	r2, [pc, #160]	@ (8009f88 <RTC_Init+0xc8>)
 8009ee6:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009ee8:	21ca      	movs	r1, #202	@ 0xca
 8009eea:	f361 0307 	bfi	r3, r1, #0, #8
 8009eee:	6253      	str	r3, [r2, #36]	@ 0x24
	RTC->WPR.bit.key = 0x53;
 8009ef0:	4a25      	ldr	r2, [pc, #148]	@ (8009f88 <RTC_Init+0xc8>)
 8009ef2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009ef4:	2153      	movs	r1, #83	@ 0x53
 8009ef6:	f361 0307 	bfi	r3, r1, #0, #8
 8009efa:	6253      	str	r3, [r2, #36]	@ 0x24

	//Enable initialization mode
	RTC->ISR.bit.init = SET;
 8009efc:	4a22      	ldr	r2, [pc, #136]	@ (8009f88 <RTC_Init+0xc8>)
 8009efe:	68d3      	ldr	r3, [r2, #12]
 8009f00:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009f04:	60d3      	str	r3, [r2, #12]

	while(!(SET == RTC->ISR.bit.initf))
 8009f06:	bf00      	nop
 8009f08:	4b1f      	ldr	r3, [pc, #124]	@ (8009f88 <RTC_Init+0xc8>)
 8009f0a:	68db      	ldr	r3, [r3, #12]
 8009f0c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009f10:	b2db      	uxtb	r3, r3
 8009f12:	2b01      	cmp	r3, #1
 8009f14:	d1f8      	bne.n	8009f08 <RTC_Init+0x48>
	{
		//Wait till initialization mode is set
	}

	//Set RTC configuration
	RTC->CR.bit.fmt = pRTCHandle->RTC_Config.RTC_HourFormat;
 8009f16:	687b      	ldr	r3, [r7, #4]
 8009f18:	781b      	ldrb	r3, [r3, #0]
 8009f1a:	4a1b      	ldr	r2, [pc, #108]	@ (8009f88 <RTC_Init+0xc8>)
 8009f1c:	f003 0301 	and.w	r3, r3, #1
 8009f20:	b2d9      	uxtb	r1, r3
 8009f22:	6893      	ldr	r3, [r2, #8]
 8009f24:	f361 1386 	bfi	r3, r1, #6, #1
 8009f28:	6093      	str	r3, [r2, #8]

	RTC->PRER.bit.prediv_a = pRTCHandle->RTC_Config.RTC_AsynchPrediv - 1;
 8009f2a:	687b      	ldr	r3, [r7, #4]
 8009f2c:	785b      	ldrb	r3, [r3, #1]
 8009f2e:	3b01      	subs	r3, #1
 8009f30:	b2db      	uxtb	r3, r3
 8009f32:	4a15      	ldr	r2, [pc, #84]	@ (8009f88 <RTC_Init+0xc8>)
 8009f34:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8009f38:	b2d9      	uxtb	r1, r3
 8009f3a:	6913      	ldr	r3, [r2, #16]
 8009f3c:	f361 4316 	bfi	r3, r1, #16, #7
 8009f40:	6113      	str	r3, [r2, #16]
	RTC->PRER.bit.prediv_s = pRTCHandle->RTC_Config.RTC_SynchPrediv - 1;
 8009f42:	687b      	ldr	r3, [r7, #4]
 8009f44:	885b      	ldrh	r3, [r3, #2]
 8009f46:	3b01      	subs	r3, #1
 8009f48:	b29b      	uxth	r3, r3
 8009f4a:	4a0f      	ldr	r2, [pc, #60]	@ (8009f88 <RTC_Init+0xc8>)
 8009f4c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8009f50:	b299      	uxth	r1, r3
 8009f52:	6913      	ldr	r3, [r2, #16]
 8009f54:	f361 030e 	bfi	r3, r1, #0, #15
 8009f58:	6113      	str	r3, [r2, #16]

	//Set time
	RTC_SetTime(pRTCHandle);
 8009f5a:	6878      	ldr	r0, [r7, #4]
 8009f5c:	f000 f816 	bl	8009f8c <RTC_SetTime>

	//Set date
	RTC_SetDate(pRTCHandle);
 8009f60:	6878      	ldr	r0, [r7, #4]
 8009f62:	f000 f8b3 	bl	800a0cc <RTC_SetDate>

	//Disable initialization mode
	RTC->ISR.bit.init = RESET;
 8009f66:	4a08      	ldr	r2, [pc, #32]	@ (8009f88 <RTC_Init+0xc8>)
 8009f68:	68d3      	ldr	r3, [r2, #12]
 8009f6a:	f36f 13c7 	bfc	r3, #7, #1
 8009f6e:	60d3      	str	r3, [r2, #12]

	//Enable RTC registers write protection
	RTC->WPR.reg = 0xFF;
 8009f70:	4b05      	ldr	r3, [pc, #20]	@ (8009f88 <RTC_Init+0xc8>)
 8009f72:	22ff      	movs	r2, #255	@ 0xff
 8009f74:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8009f76:	bf00      	nop
 8009f78:	3708      	adds	r7, #8
 8009f7a:	46bd      	mov	sp, r7
 8009f7c:	bd80      	pop	{r7, pc}
 8009f7e:	bf00      	nop
 8009f80:	40007000 	.word	0x40007000
 8009f84:	40023800 	.word	0x40023800
 8009f88:	40002800 	.word	0x40002800

08009f8c <RTC_SetTime>:
/* @return				- none																			*/
/*																										*/
/* @Note					- 23 hours, 59 minutes, 59 seconds												*/
/********************************************************************************************************/
void RTC_SetTime(RTC_Handle_t *pRTCHandle)
{
 8009f8c:	b480      	push	{r7}
 8009f8e:	b085      	sub	sp, #20
 8009f90:	af00      	add	r7, sp, #0
 8009f92:	6078      	str	r0, [r7, #4]
	//Disable RTC registers write protection
	RTC->WPR.bit.key = 0xCA;
 8009f94:	4a4b      	ldr	r2, [pc, #300]	@ (800a0c4 <RTC_SetTime+0x138>)
 8009f96:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009f98:	21ca      	movs	r1, #202	@ 0xca
 8009f9a:	f361 0307 	bfi	r3, r1, #0, #8
 8009f9e:	6253      	str	r3, [r2, #36]	@ 0x24
	RTC->WPR.bit.key = 0x53;
 8009fa0:	4a48      	ldr	r2, [pc, #288]	@ (800a0c4 <RTC_SetTime+0x138>)
 8009fa2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009fa4:	2153      	movs	r1, #83	@ 0x53
 8009fa6:	f361 0307 	bfi	r3, r1, #0, #8
 8009faa:	6253      	str	r3, [r2, #36]	@ 0x24

	//Enable initialization mode
	RTC->ISR.bit.init = SET;
 8009fac:	4a45      	ldr	r2, [pc, #276]	@ (800a0c4 <RTC_SetTime+0x138>)
 8009fae:	68d3      	ldr	r3, [r2, #12]
 8009fb0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009fb4:	60d3      	str	r3, [r2, #12]

	while (!(SET == RTC->ISR.bit.initf))
 8009fb6:	bf00      	nop
 8009fb8:	4b42      	ldr	r3, [pc, #264]	@ (800a0c4 <RTC_SetTime+0x138>)
 8009fba:	68db      	ldr	r3, [r3, #12]
 8009fbc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009fc0:	b2db      	uxtb	r3, r3
 8009fc2:	2b01      	cmp	r3, #1
 8009fc4:	d1f8      	bne.n	8009fb8 <RTC_SetTime+0x2c>
	{
		//Wait till initialization mode is set
	}

	RTC_TR_Reg_t TR_temp = {0};
 8009fc6:	2300      	movs	r3, #0
 8009fc8:	60fb      	str	r3, [r7, #12]

	//Set RTC time
	TR_temp.bit.pm  = pRTCHandle->Time.AM_PM;
 8009fca:	687b      	ldr	r3, [r7, #4]
 8009fcc:	79db      	ldrb	r3, [r3, #7]
 8009fce:	f003 0301 	and.w	r3, r3, #1
 8009fd2:	b2da      	uxtb	r2, r3
 8009fd4:	68fb      	ldr	r3, [r7, #12]
 8009fd6:	f362 5396 	bfi	r3, r2, #22, #1
 8009fda:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.ht  = pRTCHandle->Time.hour   / 10;
 8009fdc:	687b      	ldr	r3, [r7, #4]
 8009fde:	791b      	ldrb	r3, [r3, #4]
 8009fe0:	4a39      	ldr	r2, [pc, #228]	@ (800a0c8 <RTC_SetTime+0x13c>)
 8009fe2:	fba2 2303 	umull	r2, r3, r2, r3
 8009fe6:	08db      	lsrs	r3, r3, #3
 8009fe8:	b2db      	uxtb	r3, r3
 8009fea:	f003 0303 	and.w	r3, r3, #3
 8009fee:	b2da      	uxtb	r2, r3
 8009ff0:	68fb      	ldr	r3, [r7, #12]
 8009ff2:	f362 5315 	bfi	r3, r2, #20, #2
 8009ff6:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.hu  = pRTCHandle->Time.hour   % 10;
 8009ff8:	687b      	ldr	r3, [r7, #4]
 8009ffa:	791a      	ldrb	r2, [r3, #4]
 8009ffc:	4b32      	ldr	r3, [pc, #200]	@ (800a0c8 <RTC_SetTime+0x13c>)
 8009ffe:	fba3 1302 	umull	r1, r3, r3, r2
 800a002:	08d9      	lsrs	r1, r3, #3
 800a004:	460b      	mov	r3, r1
 800a006:	009b      	lsls	r3, r3, #2
 800a008:	440b      	add	r3, r1
 800a00a:	005b      	lsls	r3, r3, #1
 800a00c:	1ad3      	subs	r3, r2, r3
 800a00e:	b2db      	uxtb	r3, r3
 800a010:	f003 030f 	and.w	r3, r3, #15
 800a014:	b2da      	uxtb	r2, r3
 800a016:	68fb      	ldr	r3, [r7, #12]
 800a018:	f362 4313 	bfi	r3, r2, #16, #4
 800a01c:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.mnt = pRTCHandle->Time.minute / 10;
 800a01e:	687b      	ldr	r3, [r7, #4]
 800a020:	795b      	ldrb	r3, [r3, #5]
 800a022:	4a29      	ldr	r2, [pc, #164]	@ (800a0c8 <RTC_SetTime+0x13c>)
 800a024:	fba2 2303 	umull	r2, r3, r2, r3
 800a028:	08db      	lsrs	r3, r3, #3
 800a02a:	b2db      	uxtb	r3, r3
 800a02c:	f003 0307 	and.w	r3, r3, #7
 800a030:	b2da      	uxtb	r2, r3
 800a032:	68fb      	ldr	r3, [r7, #12]
 800a034:	f362 330e 	bfi	r3, r2, #12, #3
 800a038:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.mnu = pRTCHandle->Time.minute % 10;
 800a03a:	687b      	ldr	r3, [r7, #4]
 800a03c:	795a      	ldrb	r2, [r3, #5]
 800a03e:	4b22      	ldr	r3, [pc, #136]	@ (800a0c8 <RTC_SetTime+0x13c>)
 800a040:	fba3 1302 	umull	r1, r3, r3, r2
 800a044:	08d9      	lsrs	r1, r3, #3
 800a046:	460b      	mov	r3, r1
 800a048:	009b      	lsls	r3, r3, #2
 800a04a:	440b      	add	r3, r1
 800a04c:	005b      	lsls	r3, r3, #1
 800a04e:	1ad3      	subs	r3, r2, r3
 800a050:	b2db      	uxtb	r3, r3
 800a052:	f003 030f 	and.w	r3, r3, #15
 800a056:	b2da      	uxtb	r2, r3
 800a058:	68fb      	ldr	r3, [r7, #12]
 800a05a:	f362 230b 	bfi	r3, r2, #8, #4
 800a05e:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.st  = pRTCHandle->Time.second / 10;
 800a060:	687b      	ldr	r3, [r7, #4]
 800a062:	799b      	ldrb	r3, [r3, #6]
 800a064:	4a18      	ldr	r2, [pc, #96]	@ (800a0c8 <RTC_SetTime+0x13c>)
 800a066:	fba2 2303 	umull	r2, r3, r2, r3
 800a06a:	08db      	lsrs	r3, r3, #3
 800a06c:	b2db      	uxtb	r3, r3
 800a06e:	f003 0307 	and.w	r3, r3, #7
 800a072:	b2da      	uxtb	r2, r3
 800a074:	68fb      	ldr	r3, [r7, #12]
 800a076:	f362 1306 	bfi	r3, r2, #4, #3
 800a07a:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.su  = pRTCHandle->Time.second % 10;
 800a07c:	687b      	ldr	r3, [r7, #4]
 800a07e:	799a      	ldrb	r2, [r3, #6]
 800a080:	4b11      	ldr	r3, [pc, #68]	@ (800a0c8 <RTC_SetTime+0x13c>)
 800a082:	fba3 1302 	umull	r1, r3, r3, r2
 800a086:	08d9      	lsrs	r1, r3, #3
 800a088:	460b      	mov	r3, r1
 800a08a:	009b      	lsls	r3, r3, #2
 800a08c:	440b      	add	r3, r1
 800a08e:	005b      	lsls	r3, r3, #1
 800a090:	1ad3      	subs	r3, r2, r3
 800a092:	b2db      	uxtb	r3, r3
 800a094:	f003 030f 	and.w	r3, r3, #15
 800a098:	b2da      	uxtb	r2, r3
 800a09a:	68fb      	ldr	r3, [r7, #12]
 800a09c:	f362 0303 	bfi	r3, r2, #0, #4
 800a0a0:	60fb      	str	r3, [r7, #12]
	RTC->TR.reg = TR_temp.reg;
 800a0a2:	4a08      	ldr	r2, [pc, #32]	@ (800a0c4 <RTC_SetTime+0x138>)
 800a0a4:	68fb      	ldr	r3, [r7, #12]
 800a0a6:	6013      	str	r3, [r2, #0]

	//Disable initialization mode
	RTC->ISR.bit.init = RESET;
 800a0a8:	4a06      	ldr	r2, [pc, #24]	@ (800a0c4 <RTC_SetTime+0x138>)
 800a0aa:	68d3      	ldr	r3, [r2, #12]
 800a0ac:	f36f 13c7 	bfc	r3, #7, #1
 800a0b0:	60d3      	str	r3, [r2, #12]

	//Enable RTC registers write protection
	RTC->WPR.reg = 0xFF;
 800a0b2:	4b04      	ldr	r3, [pc, #16]	@ (800a0c4 <RTC_SetTime+0x138>)
 800a0b4:	22ff      	movs	r2, #255	@ 0xff
 800a0b6:	625a      	str	r2, [r3, #36]	@ 0x24
}
 800a0b8:	bf00      	nop
 800a0ba:	3714      	adds	r7, #20
 800a0bc:	46bd      	mov	sp, r7
 800a0be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0c2:	4770      	bx	lr
 800a0c4:	40002800 	.word	0x40002800
 800a0c8:	cccccccd 	.word	0xcccccccd

0800a0cc <RTC_SetDate>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_SetDate(RTC_Handle_t * pRTCHandle)
{
 800a0cc:	b580      	push	{r7, lr}
 800a0ce:	b084      	sub	sp, #16
 800a0d0:	af00      	add	r7, sp, #0
 800a0d2:	6078      	str	r0, [r7, #4]
	RTC_DR_Reg_t DR_Temp = {0};
 800a0d4:	2300      	movs	r3, #0
 800a0d6:	60fb      	str	r3, [r7, #12]

	//Disable RTC registers write protection
	RTC->WPR.bit.key = 0xCA;
 800a0d8:	4a2e      	ldr	r2, [pc, #184]	@ (800a194 <RTC_SetDate+0xc8>)
 800a0da:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a0dc:	21ca      	movs	r1, #202	@ 0xca
 800a0de:	f361 0307 	bfi	r3, r1, #0, #8
 800a0e2:	6253      	str	r3, [r2, #36]	@ 0x24
	RTC->WPR.bit.key = 0x53;
 800a0e4:	4a2b      	ldr	r2, [pc, #172]	@ (800a194 <RTC_SetDate+0xc8>)
 800a0e6:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a0e8:	2153      	movs	r1, #83	@ 0x53
 800a0ea:	f361 0307 	bfi	r3, r1, #0, #8
 800a0ee:	6253      	str	r3, [r2, #36]	@ 0x24

	//Set RTC date
	DR_Temp.bit.yu  = RTC_ConvertYear(pRTCHandle->Date.year);
 800a0f0:	687b      	ldr	r3, [r7, #4]
 800a0f2:	891b      	ldrh	r3, [r3, #8]
 800a0f4:	4618      	mov	r0, r3
 800a0f6:	f000 f9e7 	bl	800a4c8 <RTC_ConvertYear>
 800a0fa:	4603      	mov	r3, r0
 800a0fc:	f003 030f 	and.w	r3, r3, #15
 800a100:	b2da      	uxtb	r2, r3
 800a102:	68fb      	ldr	r3, [r7, #12]
 800a104:	f362 4313 	bfi	r3, r2, #16, #4
 800a108:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.mu  = RTC_ConvertMonth(pRTCHandle->Date.month);
 800a10a:	687b      	ldr	r3, [r7, #4]
 800a10c:	7a9b      	ldrb	r3, [r3, #10]
 800a10e:	4618      	mov	r0, r3
 800a110:	f000 fa12 	bl	800a538 <RTC_ConvertMonth>
 800a114:	4603      	mov	r3, r0
 800a116:	f003 030f 	and.w	r3, r3, #15
 800a11a:	b2da      	uxtb	r2, r3
 800a11c:	68fb      	ldr	r3, [r7, #12]
 800a11e:	f362 230b 	bfi	r3, r2, #8, #4
 800a122:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.du  = RTC_ConvertDate(pRTCHandle->Date.date);
 800a124:	687b      	ldr	r3, [r7, #4]
 800a126:	7adb      	ldrb	r3, [r3, #11]
 800a128:	4618      	mov	r0, r3
 800a12a:	f000 fa33 	bl	800a594 <RTC_ConvertDate>
 800a12e:	4603      	mov	r3, r0
 800a130:	f003 030f 	and.w	r3, r3, #15
 800a134:	b2da      	uxtb	r2, r3
 800a136:	68fb      	ldr	r3, [r7, #12]
 800a138:	f362 0303 	bfi	r3, r2, #0, #4
 800a13c:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.wdu = pRTCHandle->Date.weekDay;
 800a13e:	687b      	ldr	r3, [r7, #4]
 800a140:	7b1b      	ldrb	r3, [r3, #12]
 800a142:	f003 0307 	and.w	r3, r3, #7
 800a146:	b2da      	uxtb	r2, r3
 800a148:	68fb      	ldr	r3, [r7, #12]
 800a14a:	f362 334f 	bfi	r3, r2, #13, #3
 800a14e:	60fb      	str	r3, [r7, #12]

	RTC->ISR.bit.rsf = RESET;
 800a150:	4a10      	ldr	r2, [pc, #64]	@ (800a194 <RTC_SetDate+0xc8>)
 800a152:	68d3      	ldr	r3, [r2, #12]
 800a154:	f36f 1345 	bfc	r3, #5, #1
 800a158:	60d3      	str	r3, [r2, #12]

	RTC->DR.reg = DR_Temp.reg;
 800a15a:	4a0e      	ldr	r2, [pc, #56]	@ (800a194 <RTC_SetDate+0xc8>)
 800a15c:	68fb      	ldr	r3, [r7, #12]
 800a15e:	6053      	str	r3, [r2, #4]

	//Enable initialization mode
	RTC->ISR.bit.init = SET;
 800a160:	4a0c      	ldr	r2, [pc, #48]	@ (800a194 <RTC_SetDate+0xc8>)
 800a162:	68d3      	ldr	r3, [r2, #12]
 800a164:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800a168:	60d3      	str	r3, [r2, #12]

	while (!(SET == RTC->ISR.bit.initf))
 800a16a:	bf00      	nop
 800a16c:	4b09      	ldr	r3, [pc, #36]	@ (800a194 <RTC_SetDate+0xc8>)
 800a16e:	68db      	ldr	r3, [r3, #12]
 800a170:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a174:	b2db      	uxtb	r3, r3
 800a176:	2b01      	cmp	r3, #1
 800a178:	d1f8      	bne.n	800a16c <RTC_SetDate+0xa0>
	{
		//Wait till initialization mode is set
	}

	//Disable initialization mode
	RTC->ISR.bit.init = RESET;
 800a17a:	4a06      	ldr	r2, [pc, #24]	@ (800a194 <RTC_SetDate+0xc8>)
 800a17c:	68d3      	ldr	r3, [r2, #12]
 800a17e:	f36f 13c7 	bfc	r3, #7, #1
 800a182:	60d3      	str	r3, [r2, #12]

	//Enable RTC registers write protection
	RTC->WPR.reg = 0xFF;
 800a184:	4b03      	ldr	r3, [pc, #12]	@ (800a194 <RTC_SetDate+0xc8>)
 800a186:	22ff      	movs	r2, #255	@ 0xff
 800a188:	625a      	str	r2, [r3, #36]	@ 0x24
}
 800a18a:	bf00      	nop
 800a18c:	3710      	adds	r7, #16
 800a18e:	46bd      	mov	sp, r7
 800a190:	bd80      	pop	{r7, pc}
 800a192:	bf00      	nop
 800a194:	40002800 	.word	0x40002800

0800a198 <RTC_GetTime>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_GetTime(RTC_Handle_t * pRTCHandle, Current_Date_Handle_t* pCurrentDateHandle)
{
 800a198:	b480      	push	{r7}
 800a19a:	b085      	sub	sp, #20
 800a19c:	af00      	add	r7, sp, #0
 800a19e:	6078      	str	r0, [r7, #4]
 800a1a0:	6039      	str	r1, [r7, #0]
	RTC_TR_Reg_t TR_temp = {0};
 800a1a2:	2300      	movs	r3, #0
 800a1a4:	60fb      	str	r3, [r7, #12]

	//Read the time values
	TR_temp.reg = RTC->TR.reg;
 800a1a6:	4b26      	ldr	r3, [pc, #152]	@ (800a240 <RTC_GetTime+0xa8>)
 800a1a8:	681b      	ldr	r3, [r3, #0]
 800a1aa:	60fb      	str	r3, [r7, #12]

	while (!(SET == RTC->ISR.bit.rsf))
 800a1ac:	bf00      	nop
 800a1ae:	4b24      	ldr	r3, [pc, #144]	@ (800a240 <RTC_GetTime+0xa8>)
 800a1b0:	68db      	ldr	r3, [r3, #12]
 800a1b2:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a1b6:	b2db      	uxtb	r3, r3
 800a1b8:	2b01      	cmp	r3, #1
 800a1ba:	d1f8      	bne.n	800a1ae <RTC_GetTime+0x16>
	{
		//wait till the RTC time is updated
	}

	//read the time
	pCurrentDateHandle->Time.hour        = TR_temp.bit.ht  * 10 + TR_temp.bit.hu;
 800a1bc:	68fb      	ldr	r3, [r7, #12]
 800a1be:	f3c3 5301 	ubfx	r3, r3, #20, #2
 800a1c2:	b2db      	uxtb	r3, r3
 800a1c4:	461a      	mov	r2, r3
 800a1c6:	0092      	lsls	r2, r2, #2
 800a1c8:	4413      	add	r3, r2
 800a1ca:	005b      	lsls	r3, r3, #1
 800a1cc:	b2db      	uxtb	r3, r3
 800a1ce:	68fa      	ldr	r2, [r7, #12]
 800a1d0:	f3c2 4203 	ubfx	r2, r2, #16, #4
 800a1d4:	b2d2      	uxtb	r2, r2
 800a1d6:	4413      	add	r3, r2
 800a1d8:	b2da      	uxtb	r2, r3
 800a1da:	683b      	ldr	r3, [r7, #0]
 800a1dc:	701a      	strb	r2, [r3, #0]
	pCurrentDateHandle->Time.minute      = TR_temp.bit.mnt * 10 + TR_temp.bit.mnu;
 800a1de:	68fb      	ldr	r3, [r7, #12]
 800a1e0:	f3c3 3302 	ubfx	r3, r3, #12, #3
 800a1e4:	b2db      	uxtb	r3, r3
 800a1e6:	461a      	mov	r2, r3
 800a1e8:	0092      	lsls	r2, r2, #2
 800a1ea:	4413      	add	r3, r2
 800a1ec:	005b      	lsls	r3, r3, #1
 800a1ee:	b2db      	uxtb	r3, r3
 800a1f0:	68fa      	ldr	r2, [r7, #12]
 800a1f2:	f3c2 2203 	ubfx	r2, r2, #8, #4
 800a1f6:	b2d2      	uxtb	r2, r2
 800a1f8:	4413      	add	r3, r2
 800a1fa:	b2da      	uxtb	r2, r3
 800a1fc:	683b      	ldr	r3, [r7, #0]
 800a1fe:	705a      	strb	r2, [r3, #1]
	pCurrentDateHandle->Time.second      = TR_temp.bit.st  * 10 + TR_temp.bit.su;
 800a200:	68fb      	ldr	r3, [r7, #12]
 800a202:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800a206:	b2db      	uxtb	r3, r3
 800a208:	461a      	mov	r2, r3
 800a20a:	0092      	lsls	r2, r2, #2
 800a20c:	4413      	add	r3, r2
 800a20e:	005b      	lsls	r3, r3, #1
 800a210:	b2db      	uxtb	r3, r3
 800a212:	68fa      	ldr	r2, [r7, #12]
 800a214:	f3c2 0203 	ubfx	r2, r2, #0, #4
 800a218:	b2d2      	uxtb	r2, r2
 800a21a:	4413      	add	r3, r2
 800a21c:	b2da      	uxtb	r2, r3
 800a21e:	683b      	ldr	r3, [r7, #0]
 800a220:	709a      	strb	r2, [r3, #2]
	pCurrentDateHandle->Time.hour_format = RTC->CR.bit.fmt;
 800a222:	4b07      	ldr	r3, [pc, #28]	@ (800a240 <RTC_GetTime+0xa8>)
 800a224:	689b      	ldr	r3, [r3, #8]
 800a226:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a22a:	b2db      	uxtb	r3, r3
 800a22c:	461a      	mov	r2, r3
 800a22e:	683b      	ldr	r3, [r7, #0]
 800a230:	70da      	strb	r2, [r3, #3]
}
 800a232:	bf00      	nop
 800a234:	3714      	adds	r7, #20
 800a236:	46bd      	mov	sp, r7
 800a238:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a23c:	4770      	bx	lr
 800a23e:	bf00      	nop
 800a240:	40002800 	.word	0x40002800

0800a244 <RTC_GetDate>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_GetDate(RTC_Handle_t* pRTCHandle, Current_Date_Handle_t* pCurrentDateHandle)
{
 800a244:	b480      	push	{r7}
 800a246:	b085      	sub	sp, #20
 800a248:	af00      	add	r7, sp, #0
 800a24a:	6078      	str	r0, [r7, #4]
 800a24c:	6039      	str	r1, [r7, #0]
	RTC_DR_Reg_t DR_temp = {0};
 800a24e:	2300      	movs	r3, #0
 800a250:	60fb      	str	r3, [r7, #12]

	//Read the date values
	DR_temp.reg = RTC->DR.reg;
 800a252:	4b27      	ldr	r3, [pc, #156]	@ (800a2f0 <RTC_GetDate+0xac>)
 800a254:	685b      	ldr	r3, [r3, #4]
 800a256:	60fb      	str	r3, [r7, #12]

	pCurrentDateHandle->Date.year = DR_temp.bit.yt * 10;
 800a258:	68fb      	ldr	r3, [r7, #12]
 800a25a:	f3c3 5303 	ubfx	r3, r3, #20, #4
 800a25e:	b2db      	uxtb	r3, r3
 800a260:	461a      	mov	r2, r3
 800a262:	0092      	lsls	r2, r2, #2
 800a264:	4413      	add	r3, r2
 800a266:	005b      	lsls	r3, r3, #1
 800a268:	b29a      	uxth	r2, r3
 800a26a:	683b      	ldr	r3, [r7, #0]
 800a26c:	809a      	strh	r2, [r3, #4]
	pCurrentDateHandle->Date.year += DR_temp.bit.yu;
 800a26e:	68fb      	ldr	r3, [r7, #12]
 800a270:	f3c3 4303 	ubfx	r3, r3, #16, #4
 800a274:	b2da      	uxtb	r2, r3
 800a276:	683b      	ldr	r3, [r7, #0]
 800a278:	889b      	ldrh	r3, [r3, #4]
 800a27a:	4413      	add	r3, r2
 800a27c:	b29a      	uxth	r2, r3
 800a27e:	683b      	ldr	r3, [r7, #0]
 800a280:	809a      	strh	r2, [r3, #4]

	pCurrentDateHandle->Date.month = DR_temp.bit.mt * 10;
 800a282:	68fb      	ldr	r3, [r7, #12]
 800a284:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800a288:	b2db      	uxtb	r3, r3
 800a28a:	461a      	mov	r2, r3
 800a28c:	0092      	lsls	r2, r2, #2
 800a28e:	4413      	add	r3, r2
 800a290:	005b      	lsls	r3, r3, #1
 800a292:	b2da      	uxtb	r2, r3
 800a294:	683b      	ldr	r3, [r7, #0]
 800a296:	719a      	strb	r2, [r3, #6]
	pCurrentDateHandle->Date.month += DR_temp.bit.mu;
 800a298:	68fb      	ldr	r3, [r7, #12]
 800a29a:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800a29e:	b2da      	uxtb	r2, r3
 800a2a0:	683b      	ldr	r3, [r7, #0]
 800a2a2:	799b      	ldrb	r3, [r3, #6]
 800a2a4:	4413      	add	r3, r2
 800a2a6:	b2da      	uxtb	r2, r3
 800a2a8:	683b      	ldr	r3, [r7, #0]
 800a2aa:	719a      	strb	r2, [r3, #6]

	pCurrentDateHandle->Date.date = DR_temp.bit.dt * 10;
 800a2ac:	68fb      	ldr	r3, [r7, #12]
 800a2ae:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800a2b2:	b2db      	uxtb	r3, r3
 800a2b4:	461a      	mov	r2, r3
 800a2b6:	0092      	lsls	r2, r2, #2
 800a2b8:	4413      	add	r3, r2
 800a2ba:	005b      	lsls	r3, r3, #1
 800a2bc:	b2da      	uxtb	r2, r3
 800a2be:	683b      	ldr	r3, [r7, #0]
 800a2c0:	71da      	strb	r2, [r3, #7]
	pCurrentDateHandle->Date.date += DR_temp.bit.du;
 800a2c2:	68fb      	ldr	r3, [r7, #12]
 800a2c4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800a2c8:	b2da      	uxtb	r2, r3
 800a2ca:	683b      	ldr	r3, [r7, #0]
 800a2cc:	79db      	ldrb	r3, [r3, #7]
 800a2ce:	4413      	add	r3, r2
 800a2d0:	b2da      	uxtb	r2, r3
 800a2d2:	683b      	ldr	r3, [r7, #0]
 800a2d4:	71da      	strb	r2, [r3, #7]

	pCurrentDateHandle->Date.weekDay = DR_temp.bit.wdu;
 800a2d6:	68fb      	ldr	r3, [r7, #12]
 800a2d8:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800a2dc:	b2db      	uxtb	r3, r3
 800a2de:	461a      	mov	r2, r3
 800a2e0:	683b      	ldr	r3, [r7, #0]
 800a2e2:	721a      	strb	r2, [r3, #8]
}
 800a2e4:	bf00      	nop
 800a2e6:	3714      	adds	r7, #20
 800a2e8:	46bd      	mov	sp, r7
 800a2ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a2ee:	4770      	bx	lr
 800a2f0:	40002800 	.word	0x40002800

0800a2f4 <RTC_SetAlarm_IT>:
/*																										*/
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_SetAlarm_IT(RTC_Handle_t *pRTCHandle, RTC_AlarmType_t alarmType, RTC_Alarm_t *pAlarm) {
 800a2f4:	b480      	push	{r7}
 800a2f6:	b087      	sub	sp, #28
 800a2f8:	af00      	add	r7, sp, #0
 800a2fa:	60f8      	str	r0, [r7, #12]
 800a2fc:	460b      	mov	r3, r1
 800a2fe:	607a      	str	r2, [r7, #4]
 800a300:	72fb      	strb	r3, [r7, #11]
    // Disable RTC registers write protection
    RTC->WPR.bit.key = 0xCA;
 800a302:	4a6d      	ldr	r2, [pc, #436]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a304:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a306:	21ca      	movs	r1, #202	@ 0xca
 800a308:	f361 0307 	bfi	r3, r1, #0, #8
 800a30c:	6253      	str	r3, [r2, #36]	@ 0x24
    RTC->WPR.bit.key = 0x53;
 800a30e:	4a6a      	ldr	r2, [pc, #424]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a310:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a312:	2153      	movs	r1, #83	@ 0x53
 800a314:	f361 0307 	bfi	r3, r1, #0, #8
 800a318:	6253      	str	r3, [r2, #36]	@ 0x24

    // Enable initialization mode
    RTC->ISR.bit.init = SET;
 800a31a:	4a67      	ldr	r2, [pc, #412]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a31c:	68d3      	ldr	r3, [r2, #12]
 800a31e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800a322:	60d3      	str	r3, [r2, #12]

    while (!(SET == RTC->ISR.bit.initf))
 800a324:	bf00      	nop
 800a326:	4b64      	ldr	r3, [pc, #400]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a328:	68db      	ldr	r3, [r3, #12]
 800a32a:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a32e:	b2db      	uxtb	r3, r3
 800a330:	2b01      	cmp	r3, #1
 800a332:	d1f8      	bne.n	800a326 <RTC_SetAlarm_IT+0x32>
    {
        // Wait till initialization mode is set
    }

    // Set RTC alarm configuration
    RTC_ALRMx_Reg_t *pALRM = (alarmType == RTC_ALARM_A) ? &RTC->ALRMAR : &RTC->ALRMBR;
 800a334:	7afb      	ldrb	r3, [r7, #11]
 800a336:	2b00      	cmp	r3, #0
 800a338:	d101      	bne.n	800a33e <RTC_SetAlarm_IT+0x4a>
 800a33a:	4b60      	ldr	r3, [pc, #384]	@ (800a4bc <RTC_SetAlarm_IT+0x1c8>)
 800a33c:	e000      	b.n	800a340 <RTC_SetAlarm_IT+0x4c>
 800a33e:	4b60      	ldr	r3, [pc, #384]	@ (800a4c0 <RTC_SetAlarm_IT+0x1cc>)
 800a340:	617b      	str	r3, [r7, #20]

    pALRM->bit.hu = pAlarm->hour / 10;
 800a342:	687b      	ldr	r3, [r7, #4]
 800a344:	781b      	ldrb	r3, [r3, #0]
 800a346:	4a5f      	ldr	r2, [pc, #380]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a348:	fba2 2303 	umull	r2, r3, r2, r3
 800a34c:	08db      	lsrs	r3, r3, #3
 800a34e:	b2db      	uxtb	r3, r3
 800a350:	f003 030f 	and.w	r3, r3, #15
 800a354:	b2d9      	uxtb	r1, r3
 800a356:	697a      	ldr	r2, [r7, #20]
 800a358:	6813      	ldr	r3, [r2, #0]
 800a35a:	f361 4313 	bfi	r3, r1, #16, #4
 800a35e:	6013      	str	r3, [r2, #0]
    pALRM->bit.ht = pAlarm->hour % 10;
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	781a      	ldrb	r2, [r3, #0]
 800a364:	4b57      	ldr	r3, [pc, #348]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a366:	fba3 1302 	umull	r1, r3, r3, r2
 800a36a:	08d9      	lsrs	r1, r3, #3
 800a36c:	460b      	mov	r3, r1
 800a36e:	009b      	lsls	r3, r3, #2
 800a370:	440b      	add	r3, r1
 800a372:	005b      	lsls	r3, r3, #1
 800a374:	1ad3      	subs	r3, r2, r3
 800a376:	b2db      	uxtb	r3, r3
 800a378:	f003 0303 	and.w	r3, r3, #3
 800a37c:	b2d9      	uxtb	r1, r3
 800a37e:	697a      	ldr	r2, [r7, #20]
 800a380:	6813      	ldr	r3, [r2, #0]
 800a382:	f361 5315 	bfi	r3, r1, #20, #2
 800a386:	6013      	str	r3, [r2, #0]
    pALRM->bit.mnu = pAlarm->minute / 10;
 800a388:	687b      	ldr	r3, [r7, #4]
 800a38a:	785b      	ldrb	r3, [r3, #1]
 800a38c:	4a4d      	ldr	r2, [pc, #308]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a38e:	fba2 2303 	umull	r2, r3, r2, r3
 800a392:	08db      	lsrs	r3, r3, #3
 800a394:	b2db      	uxtb	r3, r3
 800a396:	f003 030f 	and.w	r3, r3, #15
 800a39a:	b2d9      	uxtb	r1, r3
 800a39c:	697a      	ldr	r2, [r7, #20]
 800a39e:	6813      	ldr	r3, [r2, #0]
 800a3a0:	f361 230b 	bfi	r3, r1, #8, #4
 800a3a4:	6013      	str	r3, [r2, #0]
    pALRM->bit.mnt = pAlarm->minute % 10;
 800a3a6:	687b      	ldr	r3, [r7, #4]
 800a3a8:	785a      	ldrb	r2, [r3, #1]
 800a3aa:	4b46      	ldr	r3, [pc, #280]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a3ac:	fba3 1302 	umull	r1, r3, r3, r2
 800a3b0:	08d9      	lsrs	r1, r3, #3
 800a3b2:	460b      	mov	r3, r1
 800a3b4:	009b      	lsls	r3, r3, #2
 800a3b6:	440b      	add	r3, r1
 800a3b8:	005b      	lsls	r3, r3, #1
 800a3ba:	1ad3      	subs	r3, r2, r3
 800a3bc:	b2db      	uxtb	r3, r3
 800a3be:	f003 0307 	and.w	r3, r3, #7
 800a3c2:	b2d9      	uxtb	r1, r3
 800a3c4:	697a      	ldr	r2, [r7, #20]
 800a3c6:	6813      	ldr	r3, [r2, #0]
 800a3c8:	f361 330e 	bfi	r3, r1, #12, #3
 800a3cc:	6013      	str	r3, [r2, #0]
    pALRM->bit.su = pAlarm->second / 10;
 800a3ce:	687b      	ldr	r3, [r7, #4]
 800a3d0:	789b      	ldrb	r3, [r3, #2]
 800a3d2:	4a3c      	ldr	r2, [pc, #240]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a3d4:	fba2 2303 	umull	r2, r3, r2, r3
 800a3d8:	08db      	lsrs	r3, r3, #3
 800a3da:	b2db      	uxtb	r3, r3
 800a3dc:	f003 030f 	and.w	r3, r3, #15
 800a3e0:	b2d9      	uxtb	r1, r3
 800a3e2:	697a      	ldr	r2, [r7, #20]
 800a3e4:	6813      	ldr	r3, [r2, #0]
 800a3e6:	f361 0303 	bfi	r3, r1, #0, #4
 800a3ea:	6013      	str	r3, [r2, #0]
    pALRM->bit.st = pAlarm->second % 10;
 800a3ec:	687b      	ldr	r3, [r7, #4]
 800a3ee:	789a      	ldrb	r2, [r3, #2]
 800a3f0:	4b34      	ldr	r3, [pc, #208]	@ (800a4c4 <RTC_SetAlarm_IT+0x1d0>)
 800a3f2:	fba3 1302 	umull	r1, r3, r3, r2
 800a3f6:	08d9      	lsrs	r1, r3, #3
 800a3f8:	460b      	mov	r3, r1
 800a3fa:	009b      	lsls	r3, r3, #2
 800a3fc:	440b      	add	r3, r1
 800a3fe:	005b      	lsls	r3, r3, #1
 800a400:	1ad3      	subs	r3, r2, r3
 800a402:	b2db      	uxtb	r3, r3
 800a404:	f003 0307 	and.w	r3, r3, #7
 800a408:	b2d9      	uxtb	r1, r3
 800a40a:	697a      	ldr	r2, [r7, #20]
 800a40c:	6813      	ldr	r3, [r2, #0]
 800a40e:	f361 1306 	bfi	r3, r1, #4, #3
 800a412:	6013      	str	r3, [r2, #0]

    // masking options configuration
    pALRM->bit.msk1 = pAlarm->sec_msk;
 800a414:	687b      	ldr	r3, [r7, #4]
 800a416:	78db      	ldrb	r3, [r3, #3]
 800a418:	f003 0301 	and.w	r3, r3, #1
 800a41c:	b2d9      	uxtb	r1, r3
 800a41e:	697a      	ldr	r2, [r7, #20]
 800a420:	6813      	ldr	r3, [r2, #0]
 800a422:	f361 13c7 	bfi	r3, r1, #7, #1
 800a426:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk2 = pAlarm->min_msk;
 800a428:	687b      	ldr	r3, [r7, #4]
 800a42a:	791b      	ldrb	r3, [r3, #4]
 800a42c:	f003 0301 	and.w	r3, r3, #1
 800a430:	b2d9      	uxtb	r1, r3
 800a432:	697a      	ldr	r2, [r7, #20]
 800a434:	6813      	ldr	r3, [r2, #0]
 800a436:	f361 33cf 	bfi	r3, r1, #15, #1
 800a43a:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk3 = pAlarm->hour_msk;
 800a43c:	687b      	ldr	r3, [r7, #4]
 800a43e:	795b      	ldrb	r3, [r3, #5]
 800a440:	f003 0301 	and.w	r3, r3, #1
 800a444:	b2d9      	uxtb	r1, r3
 800a446:	697a      	ldr	r2, [r7, #20]
 800a448:	6813      	ldr	r3, [r2, #0]
 800a44a:	f361 53d7 	bfi	r3, r1, #23, #1
 800a44e:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk4 = pAlarm->dateweek_msk;
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	799b      	ldrb	r3, [r3, #6]
 800a454:	f003 0301 	and.w	r3, r3, #1
 800a458:	b2d9      	uxtb	r1, r3
 800a45a:	697a      	ldr	r2, [r7, #20]
 800a45c:	6813      	ldr	r3, [r2, #0]
 800a45e:	f361 73df 	bfi	r3, r1, #31, #1
 800a462:	6013      	str	r3, [r2, #0]

    // Clear the Alarm flag
    if (alarmType == RTC_ALARM_A)
 800a464:	7afb      	ldrb	r3, [r7, #11]
 800a466:	2b00      	cmp	r3, #0
 800a468:	d105      	bne.n	800a476 <RTC_SetAlarm_IT+0x182>
    {
        RTC->ISR.bit.alraf = RESET;
 800a46a:	4a13      	ldr	r2, [pc, #76]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a46c:	68d3      	ldr	r3, [r2, #12]
 800a46e:	f36f 2308 	bfc	r3, #8, #1
 800a472:	60d3      	str	r3, [r2, #12]
 800a474:	e004      	b.n	800a480 <RTC_SetAlarm_IT+0x18c>
    }
    else
    {
        RTC->ISR.bit.alrbf = RESET;
 800a476:	4a10      	ldr	r2, [pc, #64]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a478:	68d3      	ldr	r3, [r2, #12]
 800a47a:	f36f 2349 	bfc	r3, #9, #1
 800a47e:	60d3      	str	r3, [r2, #12]
    }

    // Enable the Alarm interrupt
    if(alarmType == RTC_ALARM_A)
 800a480:	7afb      	ldrb	r3, [r7, #11]
 800a482:	2b00      	cmp	r3, #0
 800a484:	d105      	bne.n	800a492 <RTC_SetAlarm_IT+0x19e>
    {
        RTC->CR.bit.alraie = SET;
 800a486:	4a0c      	ldr	r2, [pc, #48]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a488:	6893      	ldr	r3, [r2, #8]
 800a48a:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800a48e:	6093      	str	r3, [r2, #8]
 800a490:	e004      	b.n	800a49c <RTC_SetAlarm_IT+0x1a8>
    }
    else
    {
        RTC->CR.bit.alrbie = SET;
 800a492:	4a09      	ldr	r2, [pc, #36]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a494:	6893      	ldr	r3, [r2, #8]
 800a496:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800a49a:	6093      	str	r3, [r2, #8]
    }

    // Disable initialization mode
    RTC->ISR.bit.init = RESET;
 800a49c:	4a06      	ldr	r2, [pc, #24]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a49e:	68d3      	ldr	r3, [r2, #12]
 800a4a0:	f36f 13c7 	bfc	r3, #7, #1
 800a4a4:	60d3      	str	r3, [r2, #12]

    // Enable RTC registers write protection
    RTC->WPR.reg = 0xFF;
 800a4a6:	4b04      	ldr	r3, [pc, #16]	@ (800a4b8 <RTC_SetAlarm_IT+0x1c4>)
 800a4a8:	22ff      	movs	r2, #255	@ 0xff
 800a4aa:	625a      	str	r2, [r3, #36]	@ 0x24
}
 800a4ac:	bf00      	nop
 800a4ae:	371c      	adds	r7, #28
 800a4b0:	46bd      	mov	sp, r7
 800a4b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4b6:	4770      	bx	lr
 800a4b8:	40002800 	.word	0x40002800
 800a4bc:	4000281c 	.word	0x4000281c
 800a4c0:	40002820 	.word	0x40002820
 800a4c4:	cccccccd 	.word	0xcccccccd

0800a4c8 <RTC_ConvertYear>:
/*
 * Helper functions
 */
// Convert a 4-digit year value to BCD format
static uint8_t RTC_ConvertYear(uint16_t year)
{
 800a4c8:	b480      	push	{r7}
 800a4ca:	b085      	sub	sp, #20
 800a4cc:	af00      	add	r7, sp, #0
 800a4ce:	4603      	mov	r3, r0
 800a4d0:	80fb      	strh	r3, [r7, #6]
    uint8_t bcd_year = 0;
 800a4d2:	2300      	movs	r3, #0
 800a4d4:	73fb      	strb	r3, [r7, #15]
    bcd_year |= ((year % 100 /10) <<4);
 800a4d6:	88fb      	ldrh	r3, [r7, #6]
 800a4d8:	4a15      	ldr	r2, [pc, #84]	@ (800a530 <RTC_ConvertYear+0x68>)
 800a4da:	fba2 1203 	umull	r1, r2, r2, r3
 800a4de:	0952      	lsrs	r2, r2, #5
 800a4e0:	2164      	movs	r1, #100	@ 0x64
 800a4e2:	fb01 f202 	mul.w	r2, r1, r2
 800a4e6:	1a9b      	subs	r3, r3, r2
 800a4e8:	b29b      	uxth	r3, r3
 800a4ea:	4a12      	ldr	r2, [pc, #72]	@ (800a534 <RTC_ConvertYear+0x6c>)
 800a4ec:	fba2 2303 	umull	r2, r3, r2, r3
 800a4f0:	08db      	lsrs	r3, r3, #3
 800a4f2:	b29b      	uxth	r3, r3
 800a4f4:	011b      	lsls	r3, r3, #4
 800a4f6:	b25a      	sxtb	r2, r3
 800a4f8:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800a4fc:	4313      	orrs	r3, r2
 800a4fe:	b25b      	sxtb	r3, r3
 800a500:	73fb      	strb	r3, [r7, #15]
    bcd_year |= (year % 10 <<0);
 800a502:	88fa      	ldrh	r2, [r7, #6]
 800a504:	4b0b      	ldr	r3, [pc, #44]	@ (800a534 <RTC_ConvertYear+0x6c>)
 800a506:	fba3 1302 	umull	r1, r3, r3, r2
 800a50a:	08d9      	lsrs	r1, r3, #3
 800a50c:	460b      	mov	r3, r1
 800a50e:	009b      	lsls	r3, r3, #2
 800a510:	440b      	add	r3, r1
 800a512:	005b      	lsls	r3, r3, #1
 800a514:	1ad3      	subs	r3, r2, r3
 800a516:	b29b      	uxth	r3, r3
 800a518:	b2da      	uxtb	r2, r3
 800a51a:	7bfb      	ldrb	r3, [r7, #15]
 800a51c:	4313      	orrs	r3, r2
 800a51e:	73fb      	strb	r3, [r7, #15]
    return bcd_year;
 800a520:	7bfb      	ldrb	r3, [r7, #15]
}
 800a522:	4618      	mov	r0, r3
 800a524:	3714      	adds	r7, #20
 800a526:	46bd      	mov	sp, r7
 800a528:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a52c:	4770      	bx	lr
 800a52e:	bf00      	nop
 800a530:	51eb851f 	.word	0x51eb851f
 800a534:	cccccccd 	.word	0xcccccccd

0800a538 <RTC_ConvertMonth>:

// Function to convert a decimal month to BCD format
static uint8_t RTC_ConvertMonth(uint8_t month)
{
 800a538:	b480      	push	{r7}
 800a53a:	b085      	sub	sp, #20
 800a53c:	af00      	add	r7, sp, #0
 800a53e:	4603      	mov	r3, r0
 800a540:	71fb      	strb	r3, [r7, #7]
	uint8_t bcd_month = 0;
 800a542:	2300      	movs	r3, #0
 800a544:	73fb      	strb	r3, [r7, #15]
    if(month > 9)
 800a546:	79fb      	ldrb	r3, [r7, #7]
 800a548:	2b09      	cmp	r3, #9
 800a54a:	d90c      	bls.n	800a566 <RTC_ConvertMonth+0x2e>
    {
    	bcd_month |= month/10 << 4;
 800a54c:	79fb      	ldrb	r3, [r7, #7]
 800a54e:	4a10      	ldr	r2, [pc, #64]	@ (800a590 <RTC_ConvertMonth+0x58>)
 800a550:	fba2 2303 	umull	r2, r3, r2, r3
 800a554:	08db      	lsrs	r3, r3, #3
 800a556:	b2db      	uxtb	r3, r3
 800a558:	011b      	lsls	r3, r3, #4
 800a55a:	b25a      	sxtb	r2, r3
 800a55c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800a560:	4313      	orrs	r3, r2
 800a562:	b25b      	sxtb	r3, r3
 800a564:	73fb      	strb	r3, [r7, #15]
    }
    bcd_month |= month%10 << 0;
 800a566:	79fa      	ldrb	r2, [r7, #7]
 800a568:	4b09      	ldr	r3, [pc, #36]	@ (800a590 <RTC_ConvertMonth+0x58>)
 800a56a:	fba3 1302 	umull	r1, r3, r3, r2
 800a56e:	08d9      	lsrs	r1, r3, #3
 800a570:	460b      	mov	r3, r1
 800a572:	009b      	lsls	r3, r3, #2
 800a574:	440b      	add	r3, r1
 800a576:	005b      	lsls	r3, r3, #1
 800a578:	1ad3      	subs	r3, r2, r3
 800a57a:	b2da      	uxtb	r2, r3
 800a57c:	7bfb      	ldrb	r3, [r7, #15]
 800a57e:	4313      	orrs	r3, r2
 800a580:	73fb      	strb	r3, [r7, #15]
    return bcd_month;
 800a582:	7bfb      	ldrb	r3, [r7, #15]
}
 800a584:	4618      	mov	r0, r3
 800a586:	3714      	adds	r7, #20
 800a588:	46bd      	mov	sp, r7
 800a58a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a58e:	4770      	bx	lr
 800a590:	cccccccd 	.word	0xcccccccd

0800a594 <RTC_ConvertDate>:

// Function to convert a decimal date to BCD format
static uint8_t RTC_ConvertDate(uint8_t date)
{
 800a594:	b480      	push	{r7}
 800a596:	b085      	sub	sp, #20
 800a598:	af00      	add	r7, sp, #0
 800a59a:	4603      	mov	r3, r0
 800a59c:	71fb      	strb	r3, [r7, #7]
    uint8_t bcd_date = 0;
 800a59e:	2300      	movs	r3, #0
 800a5a0:	73fb      	strb	r3, [r7, #15]
    if(date > 9)
 800a5a2:	79fb      	ldrb	r3, [r7, #7]
 800a5a4:	2b09      	cmp	r3, #9
 800a5a6:	d90c      	bls.n	800a5c2 <RTC_ConvertDate+0x2e>
	{
    	bcd_date |= date/10 << 4;
 800a5a8:	79fb      	ldrb	r3, [r7, #7]
 800a5aa:	4a10      	ldr	r2, [pc, #64]	@ (800a5ec <RTC_ConvertDate+0x58>)
 800a5ac:	fba2 2303 	umull	r2, r3, r2, r3
 800a5b0:	08db      	lsrs	r3, r3, #3
 800a5b2:	b2db      	uxtb	r3, r3
 800a5b4:	011b      	lsls	r3, r3, #4
 800a5b6:	b25a      	sxtb	r2, r3
 800a5b8:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800a5bc:	4313      	orrs	r3, r2
 800a5be:	b25b      	sxtb	r3, r3
 800a5c0:	73fb      	strb	r3, [r7, #15]
	}
	bcd_date |= date%10 << 0;
 800a5c2:	79fa      	ldrb	r2, [r7, #7]
 800a5c4:	4b09      	ldr	r3, [pc, #36]	@ (800a5ec <RTC_ConvertDate+0x58>)
 800a5c6:	fba3 1302 	umull	r1, r3, r3, r2
 800a5ca:	08d9      	lsrs	r1, r3, #3
 800a5cc:	460b      	mov	r3, r1
 800a5ce:	009b      	lsls	r3, r3, #2
 800a5d0:	440b      	add	r3, r1
 800a5d2:	005b      	lsls	r3, r3, #1
 800a5d4:	1ad3      	subs	r3, r2, r3
 800a5d6:	b2da      	uxtb	r2, r3
 800a5d8:	7bfb      	ldrb	r3, [r7, #15]
 800a5da:	4313      	orrs	r3, r2
 800a5dc:	73fb      	strb	r3, [r7, #15]
	return bcd_date;
 800a5de:	7bfb      	ldrb	r3, [r7, #15]
}
 800a5e0:	4618      	mov	r0, r3
 800a5e2:	3714      	adds	r7, #20
 800a5e4:	46bd      	mov	sp, r7
 800a5e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5ea:	4770      	bx	lr
 800a5ec:	cccccccd 	.word	0xcccccccd

0800a5f0 <TIM1_Config>:
#include <simple_delay.h>
#include <stm32f407xx.h>
#include <stm32f4xx.h>

void TIM1_Config(void)
{
 800a5f0:	b480      	push	{r7}
 800a5f2:	af00      	add	r7, sp, #0
	RCC->APB2ENR.bit.tim1en = ENABLE;  	//TIM1 EN
 800a5f4:	4a11      	ldr	r2, [pc, #68]	@ (800a63c <TIM1_Config+0x4c>)
 800a5f6:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800a5f8:	f043 0301 	orr.w	r3, r3, #1
 800a5fc:	6453      	str	r3, [r2, #68]	@ 0x44
	TIM1->PSC = 167; 					// ~1 uS delay
 800a5fe:	4b10      	ldr	r3, [pc, #64]	@ (800a640 <TIM1_Config+0x50>)
 800a600:	22a7      	movs	r2, #167	@ 0xa7
 800a602:	629a      	str	r2, [r3, #40]	@ 0x28
	TIM1->ARR |= 0xFFFF; 				//all bits set to 1
 800a604:	4b0e      	ldr	r3, [pc, #56]	@ (800a640 <TIM1_Config+0x50>)
 800a606:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a608:	4a0d      	ldr	r2, [pc, #52]	@ (800a640 <TIM1_Config+0x50>)
 800a60a:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 800a60e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 800a612:	62d3      	str	r3, [r2, #44]	@ 0x2c
	TIM1->CR1.bit.cen = ENABLE; 		//timer counter EN
 800a614:	4a0a      	ldr	r2, [pc, #40]	@ (800a640 <TIM1_Config+0x50>)
 800a616:	8813      	ldrh	r3, [r2, #0]
 800a618:	f043 0301 	orr.w	r3, r3, #1
 800a61c:	8013      	strh	r3, [r2, #0]

	while(SET != TIM1->SR.bit.uif)
 800a61e:	bf00      	nop
 800a620:	4b07      	ldr	r3, [pc, #28]	@ (800a640 <TIM1_Config+0x50>)
 800a622:	691b      	ldr	r3, [r3, #16]
 800a624:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800a628:	b2db      	uxtb	r3, r3
 800a62a:	2b01      	cmp	r3, #1
 800a62c:	d1f8      	bne.n	800a620 <TIM1_Config+0x30>
	{
		//Update interrupt pending. This bit is set by hardware when the registers are updated
	}
}
 800a62e:	bf00      	nop
 800a630:	bf00      	nop
 800a632:	46bd      	mov	sp, r7
 800a634:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a638:	4770      	bx	lr
 800a63a:	bf00      	nop
 800a63c:	40023800 	.word	0x40023800
 800a640:	40010000 	.word	0x40010000

0800a644 <delay_us>:

void delay_us(int micro)
{
 800a644:	b480      	push	{r7}
 800a646:	b083      	sub	sp, #12
 800a648:	af00      	add	r7, sp, #0
 800a64a:	6078      	str	r0, [r7, #4]
	TIM1->CNT = 0x0000;  				//reset counter register
 800a64c:	4b07      	ldr	r3, [pc, #28]	@ (800a66c <delay_us+0x28>)
 800a64e:	2200      	movs	r2, #0
 800a650:	625a      	str	r2, [r3, #36]	@ 0x24
	while(TIM1->CNT < micro);
 800a652:	bf00      	nop
 800a654:	4b05      	ldr	r3, [pc, #20]	@ (800a66c <delay_us+0x28>)
 800a656:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800a658:	687b      	ldr	r3, [r7, #4]
 800a65a:	429a      	cmp	r2, r3
 800a65c:	d3fa      	bcc.n	800a654 <delay_us+0x10>
}
 800a65e:	bf00      	nop
 800a660:	bf00      	nop
 800a662:	370c      	adds	r7, #12
 800a664:	46bd      	mov	sp, r7
 800a666:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a66a:	4770      	bx	lr
 800a66c:	40010000 	.word	0x40010000

0800a670 <delay_ms>:

void delay_ms(int ms)
{
 800a670:	b580      	push	{r7, lr}
 800a672:	b084      	sub	sp, #16
 800a674:	af00      	add	r7, sp, #0
 800a676:	6078      	str	r0, [r7, #4]
	int i;
	for (i = 0; i < ms; i++)
 800a678:	2300      	movs	r3, #0
 800a67a:	60fb      	str	r3, [r7, #12]
 800a67c:	e006      	b.n	800a68c <delay_ms+0x1c>
	{
		delay_us(1000); 			//1 ms delay
 800a67e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800a682:	f7ff ffdf 	bl	800a644 <delay_us>
	for (i = 0; i < ms; i++)
 800a686:	68fb      	ldr	r3, [r7, #12]
 800a688:	3301      	adds	r3, #1
 800a68a:	60fb      	str	r3, [r7, #12]
 800a68c:	68fa      	ldr	r2, [r7, #12]
 800a68e:	687b      	ldr	r3, [r7, #4]
 800a690:	429a      	cmp	r2, r3
 800a692:	dbf4      	blt.n	800a67e <delay_ms+0xe>
	}
}
 800a694:	bf00      	nop
 800a696:	bf00      	nop
 800a698:	3710      	adds	r7, #16
 800a69a:	46bd      	mov	sp, r7
 800a69c:	bd80      	pop	{r7, pc}
	...

0800a6a0 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 800a6a0:	b580      	push	{r7, lr}
 800a6a2:	af00      	add	r7, sp, #0
  /*## FatFS: Link the USBH driver ###########################*/
  retUSBH = FATFS_LinkDriver(&USBH_Driver, USBHPath);
 800a6a4:	4904      	ldr	r1, [pc, #16]	@ (800a6b8 <MX_FATFS_Init+0x18>)
 800a6a6:	4805      	ldr	r0, [pc, #20]	@ (800a6bc <MX_FATFS_Init+0x1c>)
 800a6a8:	f006 f9f0 	bl	8010a8c <FATFS_LinkDriver>
 800a6ac:	4603      	mov	r3, r0
 800a6ae:	461a      	mov	r2, r3
 800a6b0:	4b03      	ldr	r3, [pc, #12]	@ (800a6c0 <MX_FATFS_Init+0x20>)
 800a6b2:	701a      	strb	r2, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
 800a6b4:	bf00      	nop
 800a6b6:	bd80      	pop	{r7, pc}
 800a6b8:	200028e8 	.word	0x200028e8
 800a6bc:	0802ff04 	.word	0x0802ff04
 800a6c0:	200028e4 	.word	0x200028e4

0800a6c4 <get_fattime>:
  * @brief  Gets Time from RTC
  * @param  None
  * @retval Time in DWORD
  */
DWORD get_fattime(void)
{
 800a6c4:	b480      	push	{r7}
 800a6c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN get_fattime */
  return 0;
 800a6c8:	2300      	movs	r3, #0
  /* USER CODE END get_fattime */
}
 800a6ca:	4618      	mov	r0, r3
 800a6cc:	46bd      	mov	sp, r7
 800a6ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6d2:	4770      	bx	lr

0800a6d4 <USBH_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_initialize(BYTE lun)
{
 800a6d4:	b480      	push	{r7}
 800a6d6:	b083      	sub	sp, #12
 800a6d8:	af00      	add	r7, sp, #0
 800a6da:	4603      	mov	r3, r0
 800a6dc:	71fb      	strb	r3, [r7, #7]
  /* CAUTION : USB Host library has to be initialized in the application */

  return RES_OK;
 800a6de:	2300      	movs	r3, #0
}
 800a6e0:	4618      	mov	r0, r3
 800a6e2:	370c      	adds	r7, #12
 800a6e4:	46bd      	mov	sp, r7
 800a6e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6ea:	4770      	bx	lr

0800a6ec <USBH_status>:
  * @brief  Gets Disk Status
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_status(BYTE lun)
{
 800a6ec:	b580      	push	{r7, lr}
 800a6ee:	b084      	sub	sp, #16
 800a6f0:	af00      	add	r7, sp, #0
 800a6f2:	4603      	mov	r3, r0
 800a6f4:	71fb      	strb	r3, [r7, #7]
  DRESULT res = RES_ERROR;
 800a6f6:	2301      	movs	r3, #1
 800a6f8:	73fb      	strb	r3, [r7, #15]

  if(USBH_MSC_UnitIsReady(&hUSB_Host, lun))
 800a6fa:	79fb      	ldrb	r3, [r7, #7]
 800a6fc:	4619      	mov	r1, r3
 800a6fe:	4808      	ldr	r0, [pc, #32]	@ (800a720 <USBH_status+0x34>)
 800a700:	f000 fe36 	bl	800b370 <USBH_MSC_UnitIsReady>
 800a704:	4603      	mov	r3, r0
 800a706:	2b00      	cmp	r3, #0
 800a708:	d002      	beq.n	800a710 <USBH_status+0x24>
  {
    res = RES_OK;
 800a70a:	2300      	movs	r3, #0
 800a70c:	73fb      	strb	r3, [r7, #15]
 800a70e:	e001      	b.n	800a714 <USBH_status+0x28>
  }
  else
  {
    res = RES_ERROR;
 800a710:	2301      	movs	r3, #1
 800a712:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 800a714:	7bfb      	ldrb	r3, [r7, #15]
}
 800a716:	4618      	mov	r0, r3
 800a718:	3710      	adds	r7, #16
 800a71a:	46bd      	mov	sp, r7
 800a71c:	bd80      	pop	{r7, pc}
 800a71e:	bf00      	nop
 800a720:	20002920 	.word	0x20002920

0800a724 <USBH_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT USBH_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 800a724:	b580      	push	{r7, lr}
 800a726:	b094      	sub	sp, #80	@ 0x50
 800a728:	af02      	add	r7, sp, #8
 800a72a:	60b9      	str	r1, [r7, #8]
 800a72c:	607a      	str	r2, [r7, #4]
 800a72e:	603b      	str	r3, [r7, #0]
 800a730:	4603      	mov	r3, r0
 800a732:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 800a734:	2301      	movs	r3, #1
 800a736:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Read(&hUSB_Host, lun, sector, buff, count) == USBH_OK)
 800a73a:	7bf9      	ldrb	r1, [r7, #15]
 800a73c:	683b      	ldr	r3, [r7, #0]
 800a73e:	9300      	str	r3, [sp, #0]
 800a740:	68bb      	ldr	r3, [r7, #8]
 800a742:	687a      	ldr	r2, [r7, #4]
 800a744:	4813      	ldr	r0, [pc, #76]	@ (800a794 <USBH_read+0x70>)
 800a746:	f000 fe5d 	bl	800b404 <USBH_MSC_Read>
 800a74a:	4603      	mov	r3, r0
 800a74c:	2b00      	cmp	r3, #0
 800a74e:	d103      	bne.n	800a758 <USBH_read+0x34>
  {
    res = RES_OK;
 800a750:	2300      	movs	r3, #0
 800a752:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 800a756:	e017      	b.n	800a788 <USBH_read+0x64>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 800a758:	f107 0210 	add.w	r2, r7, #16
 800a75c:	7bfb      	ldrb	r3, [r7, #15]
 800a75e:	4619      	mov	r1, r3
 800a760:	480c      	ldr	r0, [pc, #48]	@ (800a794 <USBH_read+0x70>)
 800a762:	f000 fe2b 	bl	800b3bc <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 800a766:	7f7b      	ldrb	r3, [r7, #29]
 800a768:	2b3a      	cmp	r3, #58	@ 0x3a
 800a76a:	d005      	beq.n	800a778 <USBH_read+0x54>
 800a76c:	2b3a      	cmp	r3, #58	@ 0x3a
 800a76e:	dc07      	bgt.n	800a780 <USBH_read+0x5c>
 800a770:	2b04      	cmp	r3, #4
 800a772:	d001      	beq.n	800a778 <USBH_read+0x54>
 800a774:	2b28      	cmp	r3, #40	@ 0x28
 800a776:	d103      	bne.n	800a780 <USBH_read+0x5c>
    {
    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog ("USB Disk is not ready!");
      res = RES_NOTRDY;
 800a778:	2303      	movs	r3, #3
 800a77a:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a77e:	e003      	b.n	800a788 <USBH_read+0x64>

    default:
      res = RES_ERROR;
 800a780:	2301      	movs	r3, #1
 800a782:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a786:	bf00      	nop
    }
  }

  return res;
 800a788:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 800a78c:	4618      	mov	r0, r3
 800a78e:	3748      	adds	r7, #72	@ 0x48
 800a790:	46bd      	mov	sp, r7
 800a792:	bd80      	pop	{r7, pc}
 800a794:	20002920 	.word	0x20002920

0800a798 <USBH_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT USBH_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 800a798:	b580      	push	{r7, lr}
 800a79a:	b094      	sub	sp, #80	@ 0x50
 800a79c:	af02      	add	r7, sp, #8
 800a79e:	60b9      	str	r1, [r7, #8]
 800a7a0:	607a      	str	r2, [r7, #4]
 800a7a2:	603b      	str	r3, [r7, #0]
 800a7a4:	4603      	mov	r3, r0
 800a7a6:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 800a7a8:	2301      	movs	r3, #1
 800a7aa:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Write(&hUSB_Host, lun, sector, (BYTE *)buff, count) == USBH_OK)
 800a7ae:	7bf9      	ldrb	r1, [r7, #15]
 800a7b0:	683b      	ldr	r3, [r7, #0]
 800a7b2:	9300      	str	r3, [sp, #0]
 800a7b4:	68bb      	ldr	r3, [r7, #8]
 800a7b6:	687a      	ldr	r2, [r7, #4]
 800a7b8:	4817      	ldr	r0, [pc, #92]	@ (800a818 <USBH_write+0x80>)
 800a7ba:	f000 fe8c 	bl	800b4d6 <USBH_MSC_Write>
 800a7be:	4603      	mov	r3, r0
 800a7c0:	2b00      	cmp	r3, #0
 800a7c2:	d103      	bne.n	800a7cc <USBH_write+0x34>
  {
    res = RES_OK;
 800a7c4:	2300      	movs	r3, #0
 800a7c6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 800a7ca:	e01f      	b.n	800a80c <USBH_write+0x74>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 800a7cc:	f107 0210 	add.w	r2, r7, #16
 800a7d0:	7bfb      	ldrb	r3, [r7, #15]
 800a7d2:	4619      	mov	r1, r3
 800a7d4:	4810      	ldr	r0, [pc, #64]	@ (800a818 <USBH_write+0x80>)
 800a7d6:	f000 fdf1 	bl	800b3bc <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 800a7da:	7f7b      	ldrb	r3, [r7, #29]
 800a7dc:	2b3a      	cmp	r3, #58	@ 0x3a
 800a7de:	d00d      	beq.n	800a7fc <USBH_write+0x64>
 800a7e0:	2b3a      	cmp	r3, #58	@ 0x3a
 800a7e2:	dc0f      	bgt.n	800a804 <USBH_write+0x6c>
 800a7e4:	2b28      	cmp	r3, #40	@ 0x28
 800a7e6:	d009      	beq.n	800a7fc <USBH_write+0x64>
 800a7e8:	2b28      	cmp	r3, #40	@ 0x28
 800a7ea:	dc0b      	bgt.n	800a804 <USBH_write+0x6c>
 800a7ec:	2b04      	cmp	r3, #4
 800a7ee:	d005      	beq.n	800a7fc <USBH_write+0x64>
 800a7f0:	2b27      	cmp	r3, #39	@ 0x27
 800a7f2:	d107      	bne.n	800a804 <USBH_write+0x6c>
    {
    case SCSI_ASC_WRITE_PROTECTED:
      USBH_ErrLog("USB Disk is Write protected!");
      res = RES_WRPRT;
 800a7f4:	2302      	movs	r3, #2
 800a7f6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a7fa:	e007      	b.n	800a80c <USBH_write+0x74>

    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog("USB Disk is not ready!");
      res = RES_NOTRDY;
 800a7fc:	2303      	movs	r3, #3
 800a7fe:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a802:	e003      	b.n	800a80c <USBH_write+0x74>

    default:
      res = RES_ERROR;
 800a804:	2301      	movs	r3, #1
 800a806:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a80a:	bf00      	nop
    }
  }

  return res;
 800a80c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 800a810:	4618      	mov	r0, r3
 800a812:	3748      	adds	r7, #72	@ 0x48
 800a814:	46bd      	mov	sp, r7
 800a816:	bd80      	pop	{r7, pc}
 800a818:	20002920 	.word	0x20002920

0800a81c <USBH_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USBH_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 800a81c:	b580      	push	{r7, lr}
 800a81e:	b090      	sub	sp, #64	@ 0x40
 800a820:	af00      	add	r7, sp, #0
 800a822:	4603      	mov	r3, r0
 800a824:	603a      	str	r2, [r7, #0]
 800a826:	71fb      	strb	r3, [r7, #7]
 800a828:	460b      	mov	r3, r1
 800a82a:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_ERROR;
 800a82c:	2301      	movs	r3, #1
 800a82e:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  MSC_LUNTypeDef info;

  switch (cmd)
 800a832:	79bb      	ldrb	r3, [r7, #6]
 800a834:	2b03      	cmp	r3, #3
 800a836:	d852      	bhi.n	800a8de <USBH_ioctl+0xc2>
 800a838:	a201      	add	r2, pc, #4	@ (adr r2, 800a840 <USBH_ioctl+0x24>)
 800a83a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a83e:	bf00      	nop
 800a840:	0800a851 	.word	0x0800a851
 800a844:	0800a859 	.word	0x0800a859
 800a848:	0800a883 	.word	0x0800a883
 800a84c:	0800a8af 	.word	0x0800a8af
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC:
    res = RES_OK;
 800a850:	2300      	movs	r3, #0
 800a852:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a856:	e045      	b.n	800a8e4 <USBH_ioctl+0xc8>

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a858:	f107 0208 	add.w	r2, r7, #8
 800a85c:	79fb      	ldrb	r3, [r7, #7]
 800a85e:	4619      	mov	r1, r3
 800a860:	4823      	ldr	r0, [pc, #140]	@ (800a8f0 <USBH_ioctl+0xd4>)
 800a862:	f000 fdab 	bl	800b3bc <USBH_MSC_GetLUNInfo>
 800a866:	4603      	mov	r3, r0
 800a868:	2b00      	cmp	r3, #0
 800a86a:	d106      	bne.n	800a87a <USBH_ioctl+0x5e>
    {
      *(DWORD*)buff = info.capacity.block_nbr;
 800a86c:	68fa      	ldr	r2, [r7, #12]
 800a86e:	683b      	ldr	r3, [r7, #0]
 800a870:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a872:	2300      	movs	r3, #0
 800a874:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a878:	e034      	b.n	800a8e4 <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a87a:	2301      	movs	r3, #1
 800a87c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a880:	e030      	b.n	800a8e4 <USBH_ioctl+0xc8>

  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a882:	f107 0208 	add.w	r2, r7, #8
 800a886:	79fb      	ldrb	r3, [r7, #7]
 800a888:	4619      	mov	r1, r3
 800a88a:	4819      	ldr	r0, [pc, #100]	@ (800a8f0 <USBH_ioctl+0xd4>)
 800a88c:	f000 fd96 	bl	800b3bc <USBH_MSC_GetLUNInfo>
 800a890:	4603      	mov	r3, r0
 800a892:	2b00      	cmp	r3, #0
 800a894:	d107      	bne.n	800a8a6 <USBH_ioctl+0x8a>
    {
      *(DWORD*)buff = info.capacity.block_size;
 800a896:	8a3b      	ldrh	r3, [r7, #16]
 800a898:	461a      	mov	r2, r3
 800a89a:	683b      	ldr	r3, [r7, #0]
 800a89c:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a89e:	2300      	movs	r3, #0
 800a8a0:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a8a4:	e01e      	b.n	800a8e4 <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a8a6:	2301      	movs	r3, #1
 800a8a8:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a8ac:	e01a      	b.n	800a8e4 <USBH_ioctl+0xc8>

    /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :

    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a8ae:	f107 0208 	add.w	r2, r7, #8
 800a8b2:	79fb      	ldrb	r3, [r7, #7]
 800a8b4:	4619      	mov	r1, r3
 800a8b6:	480e      	ldr	r0, [pc, #56]	@ (800a8f0 <USBH_ioctl+0xd4>)
 800a8b8:	f000 fd80 	bl	800b3bc <USBH_MSC_GetLUNInfo>
 800a8bc:	4603      	mov	r3, r0
 800a8be:	2b00      	cmp	r3, #0
 800a8c0:	d109      	bne.n	800a8d6 <USBH_ioctl+0xba>
    {
      *(DWORD*)buff = info.capacity.block_size / USB_DEFAULT_BLOCK_SIZE;
 800a8c2:	8a3b      	ldrh	r3, [r7, #16]
 800a8c4:	0a5b      	lsrs	r3, r3, #9
 800a8c6:	b29b      	uxth	r3, r3
 800a8c8:	461a      	mov	r2, r3
 800a8ca:	683b      	ldr	r3, [r7, #0]
 800a8cc:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a8ce:	2300      	movs	r3, #0
 800a8d0:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a8d4:	e006      	b.n	800a8e4 <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a8d6:	2301      	movs	r3, #1
 800a8d8:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a8dc:	e002      	b.n	800a8e4 <USBH_ioctl+0xc8>

  default:
    res = RES_PARERR;
 800a8de:	2304      	movs	r3, #4
 800a8e0:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  }

  return res;
 800a8e4:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
}
 800a8e8:	4618      	mov	r0, r3
 800a8ea:	3740      	adds	r7, #64	@ 0x40
 800a8ec:	46bd      	mov	sp, r7
 800a8ee:	bd80      	pop	{r7, pc}
 800a8f0:	20002920 	.word	0x20002920

0800a8f4 <MX_LIBJPEG_Init>:
/* USER CODE BEGIN 2 */
/* USER CODE END 2 */

/* LIBJPEG init function */
void MX_LIBJPEG_Init(void)
{
 800a8f4:	b480      	push	{r7}
 800a8f6:	af00      	add	r7, sp, #0
  */

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

}
 800a8f8:	bf00      	nop
 800a8fa:	46bd      	mov	sp, r7
 800a8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a900:	4770      	bx	lr

0800a902 <USBH_MSC_InterfaceInit>:
  *         The function init the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceInit(USBH_HandleTypeDef *phost)
{
 800a902:	b590      	push	{r4, r7, lr}
 800a904:	b089      	sub	sp, #36	@ 0x24
 800a906:	af04      	add	r7, sp, #16
 800a908:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef status;
  uint8_t interface;
  MSC_HandleTypeDef *MSC_Handle;

  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 800a90a:	687b      	ldr	r3, [r7, #4]
 800a90c:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a910:	7919      	ldrb	r1, [r3, #4]
 800a912:	2350      	movs	r3, #80	@ 0x50
 800a914:	2206      	movs	r2, #6
 800a916:	6878      	ldr	r0, [r7, #4]
 800a918:	f001 fc86 	bl	800c228 <USBH_FindInterface>
 800a91c:	4603      	mov	r3, r0
 800a91e:	73fb      	strb	r3, [r7, #15]

  if ((interface == 0xFFU) || (interface >= USBH_MAX_NUM_INTERFACES)) /* Not Valid Interface */
 800a920:	7bfb      	ldrb	r3, [r7, #15]
 800a922:	2bff      	cmp	r3, #255	@ 0xff
 800a924:	d002      	beq.n	800a92c <USBH_MSC_InterfaceInit+0x2a>
 800a926:	7bfb      	ldrb	r3, [r7, #15]
 800a928:	2b01      	cmp	r3, #1
 800a92a:	d901      	bls.n	800a930 <USBH_MSC_InterfaceInit+0x2e>
  {
    USBH_DbgLog("Cannot Find the interface for %s class.", phost->pActiveClass->Name);
    return USBH_FAIL;
 800a92c:	2302      	movs	r3, #2
 800a92e:	e106      	b.n	800ab3e <USBH_MSC_InterfaceInit+0x23c>
  }

  status = USBH_SelectInterface(phost, interface);
 800a930:	7bfb      	ldrb	r3, [r7, #15]
 800a932:	4619      	mov	r1, r3
 800a934:	6878      	ldr	r0, [r7, #4]
 800a936:	f001 fc5b 	bl	800c1f0 <USBH_SelectInterface>
 800a93a:	4603      	mov	r3, r0
 800a93c:	73bb      	strb	r3, [r7, #14]

  if (status != USBH_OK)
 800a93e:	7bbb      	ldrb	r3, [r7, #14]
 800a940:	2b00      	cmp	r3, #0
 800a942:	d001      	beq.n	800a948 <USBH_MSC_InterfaceInit+0x46>
  {
    return USBH_FAIL;
 800a944:	2302      	movs	r3, #2
 800a946:	e0fa      	b.n	800ab3e <USBH_MSC_InterfaceInit+0x23c>
  }

  phost->pActiveClass->pData = (MSC_HandleTypeDef *)USBH_malloc(sizeof(MSC_HandleTypeDef));
 800a948:	687b      	ldr	r3, [r7, #4]
 800a94a:	f8d3 437c 	ldr.w	r4, [r3, #892]	@ 0x37c
 800a94e:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800a952:	f022 fd59 	bl	802d408 <malloc>
 800a956:	4603      	mov	r3, r0
 800a958:	61e3      	str	r3, [r4, #28]
  MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800a95a:	687b      	ldr	r3, [r7, #4]
 800a95c:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a960:	69db      	ldr	r3, [r3, #28]
 800a962:	60bb      	str	r3, [r7, #8]

  if (MSC_Handle == NULL)
 800a964:	68bb      	ldr	r3, [r7, #8]
 800a966:	2b00      	cmp	r3, #0
 800a968:	d101      	bne.n	800a96e <USBH_MSC_InterfaceInit+0x6c>
  {
    USBH_DbgLog("Cannot allocate memory for MSC Handle");
    return USBH_FAIL;
 800a96a:	2302      	movs	r3, #2
 800a96c:	e0e7      	b.n	800ab3e <USBH_MSC_InterfaceInit+0x23c>
  }

  /* Initialize msc handler */
  (void)USBH_memset(MSC_Handle, 0, sizeof(MSC_HandleTypeDef));
 800a96e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800a972:	2100      	movs	r1, #0
 800a974:	68b8      	ldr	r0, [r7, #8]
 800a976:	f022 ff3c 	bl	802d7f2 <memset>

  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress & 0x80U) != 0U)
 800a97a:	7bfb      	ldrb	r3, [r7, #15]
 800a97c:	687a      	ldr	r2, [r7, #4]
 800a97e:	211a      	movs	r1, #26
 800a980:	fb01 f303 	mul.w	r3, r1, r3
 800a984:	4413      	add	r3, r2
 800a986:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a98a:	781b      	ldrb	r3, [r3, #0]
 800a98c:	b25b      	sxtb	r3, r3
 800a98e:	2b00      	cmp	r3, #0
 800a990:	da16      	bge.n	800a9c0 <USBH_MSC_InterfaceInit+0xbe>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 800a992:	7bfb      	ldrb	r3, [r7, #15]
 800a994:	687a      	ldr	r2, [r7, #4]
 800a996:	211a      	movs	r1, #26
 800a998:	fb01 f303 	mul.w	r3, r1, r3
 800a99c:	4413      	add	r3, r2
 800a99e:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a9a2:	781a      	ldrb	r2, [r3, #0]
 800a9a4:	68bb      	ldr	r3, [r7, #8]
 800a9a6:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 800a9a8:	7bfb      	ldrb	r3, [r7, #15]
 800a9aa:	687a      	ldr	r2, [r7, #4]
 800a9ac:	211a      	movs	r1, #26
 800a9ae:	fb01 f303 	mul.w	r3, r1, r3
 800a9b2:	4413      	add	r3, r2
 800a9b4:	f503 7354 	add.w	r3, r3, #848	@ 0x350
 800a9b8:	881a      	ldrh	r2, [r3, #0]
 800a9ba:	68bb      	ldr	r3, [r7, #8]
 800a9bc:	815a      	strh	r2, [r3, #10]
 800a9be:	e015      	b.n	800a9ec <USBH_MSC_InterfaceInit+0xea>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 800a9c0:	7bfb      	ldrb	r3, [r7, #15]
 800a9c2:	687a      	ldr	r2, [r7, #4]
 800a9c4:	211a      	movs	r1, #26
 800a9c6:	fb01 f303 	mul.w	r3, r1, r3
 800a9ca:	4413      	add	r3, r2
 800a9cc:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a9d0:	781a      	ldrb	r2, [r3, #0]
 800a9d2:	68bb      	ldr	r3, [r7, #8]
 800a9d4:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 800a9d6:	7bfb      	ldrb	r3, [r7, #15]
 800a9d8:	687a      	ldr	r2, [r7, #4]
 800a9da:	211a      	movs	r1, #26
 800a9dc:	fb01 f303 	mul.w	r3, r1, r3
 800a9e0:	4413      	add	r3, r2
 800a9e2:	f503 7354 	add.w	r3, r3, #848	@ 0x350
 800a9e6:	881a      	ldrh	r2, [r3, #0]
 800a9e8:	68bb      	ldr	r3, [r7, #8]
 800a9ea:	811a      	strh	r2, [r3, #8]
  }

  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress & 0x80U) != 0U)
 800a9ec:	7bfb      	ldrb	r3, [r7, #15]
 800a9ee:	687a      	ldr	r2, [r7, #4]
 800a9f0:	211a      	movs	r1, #26
 800a9f2:	fb01 f303 	mul.w	r3, r1, r3
 800a9f6:	4413      	add	r3, r2
 800a9f8:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800a9fc:	781b      	ldrb	r3, [r3, #0]
 800a9fe:	b25b      	sxtb	r3, r3
 800aa00:	2b00      	cmp	r3, #0
 800aa02:	da16      	bge.n	800aa32 <USBH_MSC_InterfaceInit+0x130>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 800aa04:	7bfb      	ldrb	r3, [r7, #15]
 800aa06:	687a      	ldr	r2, [r7, #4]
 800aa08:	211a      	movs	r1, #26
 800aa0a:	fb01 f303 	mul.w	r3, r1, r3
 800aa0e:	4413      	add	r3, r2
 800aa10:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800aa14:	781a      	ldrb	r2, [r3, #0]
 800aa16:	68bb      	ldr	r3, [r7, #8]
 800aa18:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 800aa1a:	7bfb      	ldrb	r3, [r7, #15]
 800aa1c:	687a      	ldr	r2, [r7, #4]
 800aa1e:	211a      	movs	r1, #26
 800aa20:	fb01 f303 	mul.w	r3, r1, r3
 800aa24:	4413      	add	r3, r2
 800aa26:	f503 7356 	add.w	r3, r3, #856	@ 0x358
 800aa2a:	881a      	ldrh	r2, [r3, #0]
 800aa2c:	68bb      	ldr	r3, [r7, #8]
 800aa2e:	815a      	strh	r2, [r3, #10]
 800aa30:	e015      	b.n	800aa5e <USBH_MSC_InterfaceInit+0x15c>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 800aa32:	7bfb      	ldrb	r3, [r7, #15]
 800aa34:	687a      	ldr	r2, [r7, #4]
 800aa36:	211a      	movs	r1, #26
 800aa38:	fb01 f303 	mul.w	r3, r1, r3
 800aa3c:	4413      	add	r3, r2
 800aa3e:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800aa42:	781a      	ldrb	r2, [r3, #0]
 800aa44:	68bb      	ldr	r3, [r7, #8]
 800aa46:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 800aa48:	7bfb      	ldrb	r3, [r7, #15]
 800aa4a:	687a      	ldr	r2, [r7, #4]
 800aa4c:	211a      	movs	r1, #26
 800aa4e:	fb01 f303 	mul.w	r3, r1, r3
 800aa52:	4413      	add	r3, r2
 800aa54:	f503 7356 	add.w	r3, r3, #856	@ 0x358
 800aa58:	881a      	ldrh	r2, [r3, #0]
 800aa5a:	68bb      	ldr	r3, [r7, #8]
 800aa5c:	811a      	strh	r2, [r3, #8]
  }

  MSC_Handle->state = MSC_INIT;
 800aa5e:	68bb      	ldr	r3, [r7, #8]
 800aa60:	2200      	movs	r2, #0
 800aa62:	731a      	strb	r2, [r3, #12]
  MSC_Handle->error = MSC_OK;
 800aa64:	68bb      	ldr	r3, [r7, #8]
 800aa66:	2200      	movs	r2, #0
 800aa68:	735a      	strb	r2, [r3, #13]
  MSC_Handle->req_state = MSC_REQ_IDLE;
 800aa6a:	68bb      	ldr	r3, [r7, #8]
 800aa6c:	2200      	movs	r2, #0
 800aa6e:	739a      	strb	r2, [r3, #14]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 800aa70:	68bb      	ldr	r3, [r7, #8]
 800aa72:	799b      	ldrb	r3, [r3, #6]
 800aa74:	4619      	mov	r1, r3
 800aa76:	6878      	ldr	r0, [r7, #4]
 800aa78:	f002 ff63 	bl	800d942 <USBH_AllocPipe>
 800aa7c:	4603      	mov	r3, r0
 800aa7e:	461a      	mov	r2, r3
 800aa80:	68bb      	ldr	r3, [r7, #8]
 800aa82:	715a      	strb	r2, [r3, #5]
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 800aa84:	68bb      	ldr	r3, [r7, #8]
 800aa86:	79db      	ldrb	r3, [r3, #7]
 800aa88:	4619      	mov	r1, r3
 800aa8a:	6878      	ldr	r0, [r7, #4]
 800aa8c:	f002 ff59 	bl	800d942 <USBH_AllocPipe>
 800aa90:	4603      	mov	r3, r0
 800aa92:	461a      	mov	r2, r3
 800aa94:	68bb      	ldr	r3, [r7, #8]
 800aa96:	711a      	strb	r2, [r3, #4]

  (void)USBH_MSC_BOT_Init(phost);
 800aa98:	6878      	ldr	r0, [r7, #4]
 800aa9a:	f000 fdc1 	bl	800b620 <USBH_MSC_BOT_Init>

  /* Open the new channels */
  if ((MSC_Handle->OutEp != 0U) && (MSC_Handle->OutEpSize != 0U))
 800aa9e:	68bb      	ldr	r3, [r7, #8]
 800aaa0:	799b      	ldrb	r3, [r3, #6]
 800aaa2:	2b00      	cmp	r3, #0
 800aaa4:	d01e      	beq.n	800aae4 <USBH_MSC_InterfaceInit+0x1e2>
 800aaa6:	68bb      	ldr	r3, [r7, #8]
 800aaa8:	891b      	ldrh	r3, [r3, #8]
 800aaaa:	2b00      	cmp	r3, #0
 800aaac:	d01a      	beq.n	800aae4 <USBH_MSC_InterfaceInit+0x1e2>
  {
    (void)USBH_OpenPipe(phost, MSC_Handle->OutPipe, MSC_Handle->OutEp,
 800aaae:	68bb      	ldr	r3, [r7, #8]
 800aab0:	7959      	ldrb	r1, [r3, #5]
 800aab2:	68bb      	ldr	r3, [r7, #8]
 800aab4:	7998      	ldrb	r0, [r3, #6]
 800aab6:	687b      	ldr	r3, [r7, #4]
 800aab8:	f893 431c 	ldrb.w	r4, [r3, #796]	@ 0x31c
 800aabc:	687b      	ldr	r3, [r7, #4]
 800aabe:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800aac2:	68ba      	ldr	r2, [r7, #8]
 800aac4:	8912      	ldrh	r2, [r2, #8]
 800aac6:	9202      	str	r2, [sp, #8]
 800aac8:	2202      	movs	r2, #2
 800aaca:	9201      	str	r2, [sp, #4]
 800aacc:	9300      	str	r3, [sp, #0]
 800aace:	4623      	mov	r3, r4
 800aad0:	4602      	mov	r2, r0
 800aad2:	6878      	ldr	r0, [r7, #4]
 800aad4:	f002 ff06 	bl	800d8e4 <USBH_OpenPipe>
 800aad8:	bf00      	nop
  else
  {
    return USBH_NOT_SUPPORTED;
  }

  if ((MSC_Handle->InEp != 0U) && (MSC_Handle->InEpSize != 0U))
 800aada:	68bb      	ldr	r3, [r7, #8]
 800aadc:	79db      	ldrb	r3, [r3, #7]
 800aade:	2b00      	cmp	r3, #0
 800aae0:	d02c      	beq.n	800ab3c <USBH_MSC_InterfaceInit+0x23a>
 800aae2:	e001      	b.n	800aae8 <USBH_MSC_InterfaceInit+0x1e6>
    return USBH_NOT_SUPPORTED;
 800aae4:	2303      	movs	r3, #3
 800aae6:	e02a      	b.n	800ab3e <USBH_MSC_InterfaceInit+0x23c>
  if ((MSC_Handle->InEp != 0U) && (MSC_Handle->InEpSize != 0U))
 800aae8:	68bb      	ldr	r3, [r7, #8]
 800aaea:	895b      	ldrh	r3, [r3, #10]
 800aaec:	2b00      	cmp	r3, #0
 800aaee:	d025      	beq.n	800ab3c <USBH_MSC_InterfaceInit+0x23a>
  {
    (void)USBH_OpenPipe(phost, MSC_Handle->InPipe, MSC_Handle->InEp,
 800aaf0:	68bb      	ldr	r3, [r7, #8]
 800aaf2:	7919      	ldrb	r1, [r3, #4]
 800aaf4:	68bb      	ldr	r3, [r7, #8]
 800aaf6:	79d8      	ldrb	r0, [r3, #7]
 800aaf8:	687b      	ldr	r3, [r7, #4]
 800aafa:	f893 431c 	ldrb.w	r4, [r3, #796]	@ 0x31c
 800aafe:	687b      	ldr	r3, [r7, #4]
 800ab00:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800ab04:	68ba      	ldr	r2, [r7, #8]
 800ab06:	8952      	ldrh	r2, [r2, #10]
 800ab08:	9202      	str	r2, [sp, #8]
 800ab0a:	2202      	movs	r2, #2
 800ab0c:	9201      	str	r2, [sp, #4]
 800ab0e:	9300      	str	r3, [sp, #0]
 800ab10:	4623      	mov	r3, r4
 800ab12:	4602      	mov	r2, r0
 800ab14:	6878      	ldr	r0, [r7, #4]
 800ab16:	f002 fee5 	bl	800d8e4 <USBH_OpenPipe>
 800ab1a:	bf00      	nop
  else
  {
    return USBH_NOT_SUPPORTED;
  }

  (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 800ab1c:	68bb      	ldr	r3, [r7, #8]
 800ab1e:	791b      	ldrb	r3, [r3, #4]
 800ab20:	2200      	movs	r2, #0
 800ab22:	4619      	mov	r1, r3
 800ab24:	6878      	ldr	r0, [r7, #4]
 800ab26:	f022 fbb5 	bl	802d294 <USBH_LL_SetToggle>
  (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 0U);
 800ab2a:	68bb      	ldr	r3, [r7, #8]
 800ab2c:	795b      	ldrb	r3, [r3, #5]
 800ab2e:	2200      	movs	r2, #0
 800ab30:	4619      	mov	r1, r3
 800ab32:	6878      	ldr	r0, [r7, #4]
 800ab34:	f022 fbae 	bl	802d294 <USBH_LL_SetToggle>

  return USBH_OK;
 800ab38:	2300      	movs	r3, #0
 800ab3a:	e000      	b.n	800ab3e <USBH_MSC_InterfaceInit+0x23c>
    return USBH_NOT_SUPPORTED;
 800ab3c:	2303      	movs	r3, #3
}
 800ab3e:	4618      	mov	r0, r3
 800ab40:	3714      	adds	r7, #20
 800ab42:	46bd      	mov	sp, r7
 800ab44:	bd90      	pop	{r4, r7, pc}

0800ab46 <USBH_MSC_InterfaceDeInit>:
  *         The function DeInit the Pipes used for the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceDeInit(USBH_HandleTypeDef *phost)
{
 800ab46:	b580      	push	{r7, lr}
 800ab48:	b084      	sub	sp, #16
 800ab4a:	af00      	add	r7, sp, #0
 800ab4c:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800ab4e:	687b      	ldr	r3, [r7, #4]
 800ab50:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800ab54:	69db      	ldr	r3, [r3, #28]
 800ab56:	60fb      	str	r3, [r7, #12]

  if ((MSC_Handle->OutPipe) != 0U)
 800ab58:	68fb      	ldr	r3, [r7, #12]
 800ab5a:	795b      	ldrb	r3, [r3, #5]
 800ab5c:	2b00      	cmp	r3, #0
 800ab5e:	d00e      	beq.n	800ab7e <USBH_MSC_InterfaceDeInit+0x38>
  {
    (void)USBH_ClosePipe(phost, MSC_Handle->OutPipe);
 800ab60:	68fb      	ldr	r3, [r7, #12]
 800ab62:	795b      	ldrb	r3, [r3, #5]
 800ab64:	4619      	mov	r1, r3
 800ab66:	6878      	ldr	r0, [r7, #4]
 800ab68:	f002 fedb 	bl	800d922 <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->OutPipe);
 800ab6c:	68fb      	ldr	r3, [r7, #12]
 800ab6e:	795b      	ldrb	r3, [r3, #5]
 800ab70:	4619      	mov	r1, r3
 800ab72:	6878      	ldr	r0, [r7, #4]
 800ab74:	f002 ff06 	bl	800d984 <USBH_FreePipe>
    MSC_Handle->OutPipe = 0U;     /* Reset the Channel as Free */
 800ab78:	68fb      	ldr	r3, [r7, #12]
 800ab7a:	2200      	movs	r2, #0
 800ab7c:	715a      	strb	r2, [r3, #5]
  }

  if ((MSC_Handle->InPipe != 0U))
 800ab7e:	68fb      	ldr	r3, [r7, #12]
 800ab80:	791b      	ldrb	r3, [r3, #4]
 800ab82:	2b00      	cmp	r3, #0
 800ab84:	d00e      	beq.n	800aba4 <USBH_MSC_InterfaceDeInit+0x5e>
  {
    (void)USBH_ClosePipe(phost, MSC_Handle->InPipe);
 800ab86:	68fb      	ldr	r3, [r7, #12]
 800ab88:	791b      	ldrb	r3, [r3, #4]
 800ab8a:	4619      	mov	r1, r3
 800ab8c:	6878      	ldr	r0, [r7, #4]
 800ab8e:	f002 fec8 	bl	800d922 <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->InPipe);
 800ab92:	68fb      	ldr	r3, [r7, #12]
 800ab94:	791b      	ldrb	r3, [r3, #4]
 800ab96:	4619      	mov	r1, r3
 800ab98:	6878      	ldr	r0, [r7, #4]
 800ab9a:	f002 fef3 	bl	800d984 <USBH_FreePipe>
    MSC_Handle->InPipe = 0U;     /* Reset the Channel as Free */
 800ab9e:	68fb      	ldr	r3, [r7, #12]
 800aba0:	2200      	movs	r2, #0
 800aba2:	711a      	strb	r2, [r3, #4]
  }

  if ((phost->pActiveClass->pData) != NULL)
 800aba4:	687b      	ldr	r3, [r7, #4]
 800aba6:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800abaa:	69db      	ldr	r3, [r3, #28]
 800abac:	2b00      	cmp	r3, #0
 800abae:	d00b      	beq.n	800abc8 <USBH_MSC_InterfaceDeInit+0x82>
  {
    USBH_free(phost->pActiveClass->pData);
 800abb0:	687b      	ldr	r3, [r7, #4]
 800abb2:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800abb6:	69db      	ldr	r3, [r3, #28]
 800abb8:	4618      	mov	r0, r3
 800abba:	f022 fc2d 	bl	802d418 <free>
    phost->pActiveClass->pData = 0U;
 800abbe:	687b      	ldr	r3, [r7, #4]
 800abc0:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800abc4:	2200      	movs	r2, #0
 800abc6:	61da      	str	r2, [r3, #28]
  }

  return USBH_OK;
 800abc8:	2300      	movs	r3, #0
}
 800abca:	4618      	mov	r0, r3
 800abcc:	3710      	adds	r7, #16
 800abce:	46bd      	mov	sp, r7
 800abd0:	bd80      	pop	{r7, pc}

0800abd2 <USBH_MSC_ClassRequest>:
  *         for MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_ClassRequest(USBH_HandleTypeDef *phost)
{
 800abd2:	b580      	push	{r7, lr}
 800abd4:	b084      	sub	sp, #16
 800abd6:	af00      	add	r7, sp, #0
 800abd8:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800abe0:	69db      	ldr	r3, [r3, #28]
 800abe2:	60bb      	str	r3, [r7, #8]
  USBH_StatusTypeDef status = USBH_BUSY;
 800abe4:	2301      	movs	r3, #1
 800abe6:	73fb      	strb	r3, [r7, #15]
  uint8_t i;

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->req_state)
 800abe8:	68bb      	ldr	r3, [r7, #8]
 800abea:	7b9b      	ldrb	r3, [r3, #14]
 800abec:	2b03      	cmp	r3, #3
 800abee:	d041      	beq.n	800ac74 <USBH_MSC_ClassRequest+0xa2>
 800abf0:	2b03      	cmp	r3, #3
 800abf2:	dc4b      	bgt.n	800ac8c <USBH_MSC_ClassRequest+0xba>
 800abf4:	2b00      	cmp	r3, #0
 800abf6:	d001      	beq.n	800abfc <USBH_MSC_ClassRequest+0x2a>
 800abf8:	2b02      	cmp	r3, #2
 800abfa:	d147      	bne.n	800ac8c <USBH_MSC_ClassRequest+0xba>
  {
    case MSC_REQ_IDLE:
    case MSC_REQ_GET_MAX_LUN:
      /* Issue GetMaxLUN request */
      status = USBH_MSC_BOT_REQ_GetMaxLUN(phost, &MSC_Handle->max_lun);
 800abfc:	68bb      	ldr	r3, [r7, #8]
 800abfe:	4619      	mov	r1, r3
 800ac00:	6878      	ldr	r0, [r7, #4]
 800ac02:	f000 fcee 	bl	800b5e2 <USBH_MSC_BOT_REQ_GetMaxLUN>
 800ac06:	4603      	mov	r3, r0
 800ac08:	73fb      	strb	r3, [r7, #15]

      /* When devices do not support the GetMaxLun request, this should
         be considered as only one logical unit is supported */
      if (status == USBH_NOT_SUPPORTED)
 800ac0a:	7bfb      	ldrb	r3, [r7, #15]
 800ac0c:	2b03      	cmp	r3, #3
 800ac0e:	d104      	bne.n	800ac1a <USBH_MSC_ClassRequest+0x48>
      {
        MSC_Handle->max_lun = 0U;
 800ac10:	68bb      	ldr	r3, [r7, #8]
 800ac12:	2200      	movs	r2, #0
 800ac14:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 800ac16:	2300      	movs	r3, #0
 800ac18:	73fb      	strb	r3, [r7, #15]
      }

      if (status == USBH_OK)
 800ac1a:	7bfb      	ldrb	r3, [r7, #15]
 800ac1c:	2b00      	cmp	r3, #0
 800ac1e:	d137      	bne.n	800ac90 <USBH_MSC_ClassRequest+0xbe>
      {
        MSC_Handle->max_lun = (MSC_Handle->max_lun > MAX_SUPPORTED_LUN) ? MAX_SUPPORTED_LUN : (MSC_Handle->max_lun + 1U);
 800ac20:	68bb      	ldr	r3, [r7, #8]
 800ac22:	781b      	ldrb	r3, [r3, #0]
 800ac24:	2b02      	cmp	r3, #2
 800ac26:	d804      	bhi.n	800ac32 <USBH_MSC_ClassRequest+0x60>
 800ac28:	68bb      	ldr	r3, [r7, #8]
 800ac2a:	781b      	ldrb	r3, [r3, #0]
 800ac2c:	3301      	adds	r3, #1
 800ac2e:	b2da      	uxtb	r2, r3
 800ac30:	e000      	b.n	800ac34 <USBH_MSC_ClassRequest+0x62>
 800ac32:	2202      	movs	r2, #2
 800ac34:	68bb      	ldr	r3, [r7, #8]
 800ac36:	701a      	strb	r2, [r3, #0]
        USBH_UsrLog("Number of supported LUN: %d", MSC_Handle->max_lun);

        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800ac38:	2300      	movs	r3, #0
 800ac3a:	73bb      	strb	r3, [r7, #14]
 800ac3c:	e014      	b.n	800ac68 <USBH_MSC_ClassRequest+0x96>
        {
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 800ac3e:	7bbb      	ldrb	r3, [r7, #14]
 800ac40:	68ba      	ldr	r2, [r7, #8]
 800ac42:	2134      	movs	r1, #52	@ 0x34
 800ac44:	fb01 f303 	mul.w	r3, r1, r3
 800ac48:	4413      	add	r3, r2
 800ac4a:	3392      	adds	r3, #146	@ 0x92
 800ac4c:	2202      	movs	r2, #2
 800ac4e:	701a      	strb	r2, [r3, #0]
          MSC_Handle->unit[i].state_changed = 0U;
 800ac50:	7bbb      	ldrb	r3, [r7, #14]
 800ac52:	68ba      	ldr	r2, [r7, #8]
 800ac54:	2134      	movs	r1, #52	@ 0x34
 800ac56:	fb01 f303 	mul.w	r3, r1, r3
 800ac5a:	4413      	add	r3, r2
 800ac5c:	33c1      	adds	r3, #193	@ 0xc1
 800ac5e:	2200      	movs	r2, #0
 800ac60:	701a      	strb	r2, [r3, #0]
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800ac62:	7bbb      	ldrb	r3, [r7, #14]
 800ac64:	3301      	adds	r3, #1
 800ac66:	73bb      	strb	r3, [r7, #14]
 800ac68:	68bb      	ldr	r3, [r7, #8]
 800ac6a:	781b      	ldrb	r3, [r3, #0]
 800ac6c:	7bba      	ldrb	r2, [r7, #14]
 800ac6e:	429a      	cmp	r2, r3
 800ac70:	d3e5      	bcc.n	800ac3e <USBH_MSC_ClassRequest+0x6c>
        }
      }
      break;
 800ac72:	e00d      	b.n	800ac90 <USBH_MSC_ClassRequest+0xbe>

    case MSC_REQ_ERROR:
      /* a Clear Feature should be issued here */
      if (USBH_ClrFeature(phost, 0x00U) == USBH_OK)
 800ac74:	2100      	movs	r1, #0
 800ac76:	6878      	ldr	r0, [r7, #4]
 800ac78:	f002 f8ae 	bl	800cdd8 <USBH_ClrFeature>
 800ac7c:	4603      	mov	r3, r0
 800ac7e:	2b00      	cmp	r3, #0
 800ac80:	d108      	bne.n	800ac94 <USBH_MSC_ClassRequest+0xc2>
      {
        MSC_Handle->req_state = MSC_Handle->prev_req_state;
 800ac82:	68bb      	ldr	r3, [r7, #8]
 800ac84:	7bda      	ldrb	r2, [r3, #15]
 800ac86:	68bb      	ldr	r3, [r7, #8]
 800ac88:	739a      	strb	r2, [r3, #14]
      }
      break;
 800ac8a:	e003      	b.n	800ac94 <USBH_MSC_ClassRequest+0xc2>

    default:
      break;
 800ac8c:	bf00      	nop
 800ac8e:	e002      	b.n	800ac96 <USBH_MSC_ClassRequest+0xc4>
      break;
 800ac90:	bf00      	nop
 800ac92:	e000      	b.n	800ac96 <USBH_MSC_ClassRequest+0xc4>
      break;
 800ac94:	bf00      	nop
  }

  return status;
 800ac96:	7bfb      	ldrb	r3, [r7, #15]
}
 800ac98:	4618      	mov	r0, r3
 800ac9a:	3710      	adds	r7, #16
 800ac9c:	46bd      	mov	sp, r7
 800ac9e:	bd80      	pop	{r7, pc}

0800aca0 <USBH_MSC_Process>:
  *         The function is for managing state machine for MSC data transfers
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_Process(USBH_HandleTypeDef *phost)
{
 800aca0:	b580      	push	{r7, lr}
 800aca2:	b086      	sub	sp, #24
 800aca4:	af00      	add	r7, sp, #0
 800aca6:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800aca8:	687b      	ldr	r3, [r7, #4]
 800acaa:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800acae:	69db      	ldr	r3, [r3, #28]
 800acb0:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY;
 800acb2:	2301      	movs	r3, #1
 800acb4:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY;
 800acb6:	2301      	movs	r3, #1
 800acb8:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ready_status = USBH_BUSY;
 800acba:	2301      	movs	r3, #1
 800acbc:	73bb      	strb	r3, [r7, #14]

  switch (MSC_Handle->state)
 800acbe:	693b      	ldr	r3, [r7, #16]
 800acc0:	7b1b      	ldrb	r3, [r3, #12]
 800acc2:	2b00      	cmp	r3, #0
 800acc4:	d003      	beq.n	800acce <USBH_MSC_Process+0x2e>
 800acc6:	2b01      	cmp	r3, #1
 800acc8:	f000 826f 	beq.w	800b1aa <USBH_MSC_Process+0x50a>
    case MSC_IDLE:
      error = USBH_OK;
      break;

    default:
      break;
 800accc:	e270      	b.n	800b1b0 <USBH_MSC_Process+0x510>
      if (MSC_Handle->current_lun < MSC_Handle->max_lun)
 800acce:	693b      	ldr	r3, [r7, #16]
 800acd0:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800acd4:	693a      	ldr	r2, [r7, #16]
 800acd6:	7812      	ldrb	r2, [r2, #0]
 800acd8:	4293      	cmp	r3, r2
 800acda:	f080 824e 	bcs.w	800b17a <USBH_MSC_Process+0x4da>
        MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 800acde:	693b      	ldr	r3, [r7, #16]
 800ace0:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ace4:	4619      	mov	r1, r3
 800ace6:	693a      	ldr	r2, [r7, #16]
 800ace8:	2334      	movs	r3, #52	@ 0x34
 800acea:	fb01 f303 	mul.w	r3, r1, r3
 800acee:	4413      	add	r3, r2
 800acf0:	3391      	adds	r3, #145	@ 0x91
 800acf2:	2201      	movs	r2, #1
 800acf4:	701a      	strb	r2, [r3, #0]
        switch (MSC_Handle->unit[MSC_Handle->current_lun].state)
 800acf6:	693b      	ldr	r3, [r7, #16]
 800acf8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800acfc:	4619      	mov	r1, r3
 800acfe:	693a      	ldr	r2, [r7, #16]
 800ad00:	2334      	movs	r3, #52	@ 0x34
 800ad02:	fb01 f303 	mul.w	r3, r1, r3
 800ad06:	4413      	add	r3, r2
 800ad08:	3390      	adds	r3, #144	@ 0x90
 800ad0a:	781b      	ldrb	r3, [r3, #0]
 800ad0c:	2b08      	cmp	r3, #8
 800ad0e:	f200 8242 	bhi.w	800b196 <USBH_MSC_Process+0x4f6>
 800ad12:	a201      	add	r2, pc, #4	@ (adr r2, 800ad18 <USBH_MSC_Process+0x78>)
 800ad14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ad18:	0800ad3d 	.word	0x0800ad3d
 800ad1c:	0800b197 	.word	0x0800b197
 800ad20:	0800ae05 	.word	0x0800ae05
 800ad24:	0800af89 	.word	0x0800af89
 800ad28:	0800ad63 	.word	0x0800ad63
 800ad2c:	0800b055 	.word	0x0800b055
 800ad30:	0800b197 	.word	0x0800b197
 800ad34:	0800b197 	.word	0x0800b197
 800ad38:	0800b169 	.word	0x0800b169
            MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_INQUIRY;
 800ad3c:	693b      	ldr	r3, [r7, #16]
 800ad3e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad42:	4619      	mov	r1, r3
 800ad44:	693a      	ldr	r2, [r7, #16]
 800ad46:	2334      	movs	r3, #52	@ 0x34
 800ad48:	fb01 f303 	mul.w	r3, r1, r3
 800ad4c:	4413      	add	r3, r2
 800ad4e:	3390      	adds	r3, #144	@ 0x90
 800ad50:	2204      	movs	r2, #4
 800ad52:	701a      	strb	r2, [r3, #0]
            MSC_Handle->timer = phost->Timer;
 800ad54:	687b      	ldr	r3, [r7, #4]
 800ad56:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800ad5a:	693b      	ldr	r3, [r7, #16]
 800ad5c:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
            break;
 800ad60:	e222      	b.n	800b1a8 <USBH_MSC_Process+0x508>
            scsi_status = USBH_MSC_SCSI_Inquiry(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].inquiry);
 800ad62:	693b      	ldr	r3, [r7, #16]
 800ad64:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad68:	b2d9      	uxtb	r1, r3
 800ad6a:	693b      	ldr	r3, [r7, #16]
 800ad6c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad70:	461a      	mov	r2, r3
 800ad72:	2334      	movs	r3, #52	@ 0x34
 800ad74:	fb02 f303 	mul.w	r3, r2, r3
 800ad78:	3398      	adds	r3, #152	@ 0x98
 800ad7a:	693a      	ldr	r2, [r7, #16]
 800ad7c:	4413      	add	r3, r2
 800ad7e:	3307      	adds	r3, #7
 800ad80:	461a      	mov	r2, r3
 800ad82:	6878      	ldr	r0, [r7, #4]
 800ad84:	f000 ff69 	bl	800bc5a <USBH_MSC_SCSI_Inquiry>
 800ad88:	4603      	mov	r3, r0
 800ad8a:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800ad8c:	7bfb      	ldrb	r3, [r7, #15]
 800ad8e:	2b00      	cmp	r3, #0
 800ad90:	d10b      	bne.n	800adaa <USBH_MSC_Process+0x10a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 800ad92:	693b      	ldr	r3, [r7, #16]
 800ad94:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad98:	4619      	mov	r1, r3
 800ad9a:	693a      	ldr	r2, [r7, #16]
 800ad9c:	2334      	movs	r3, #52	@ 0x34
 800ad9e:	fb01 f303 	mul.w	r3, r1, r3
 800ada2:	4413      	add	r3, r2
 800ada4:	3390      	adds	r3, #144	@ 0x90
 800ada6:	2202      	movs	r2, #2
 800ada8:	701a      	strb	r2, [r3, #0]
            if (scsi_status == USBH_FAIL)
 800adaa:	7bfb      	ldrb	r3, [r7, #15]
 800adac:	2b02      	cmp	r3, #2
 800adae:	d10c      	bne.n	800adca <USBH_MSC_Process+0x12a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800adb0:	693b      	ldr	r3, [r7, #16]
 800adb2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800adb6:	4619      	mov	r1, r3
 800adb8:	693a      	ldr	r2, [r7, #16]
 800adba:	2334      	movs	r3, #52	@ 0x34
 800adbc:	fb01 f303 	mul.w	r3, r1, r3
 800adc0:	4413      	add	r3, r2
 800adc2:	3390      	adds	r3, #144	@ 0x90
 800adc4:	2205      	movs	r2, #5
 800adc6:	701a      	strb	r2, [r3, #0]
            break;
 800adc8:	e1e7      	b.n	800b19a <USBH_MSC_Process+0x4fa>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800adca:	7bfb      	ldrb	r3, [r7, #15]
 800adcc:	2b04      	cmp	r3, #4
 800adce:	f040 81e4 	bne.w	800b19a <USBH_MSC_Process+0x4fa>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800add2:	693b      	ldr	r3, [r7, #16]
 800add4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800add8:	4619      	mov	r1, r3
 800adda:	693a      	ldr	r2, [r7, #16]
 800addc:	2334      	movs	r3, #52	@ 0x34
 800adde:	fb01 f303 	mul.w	r3, r1, r3
 800ade2:	4413      	add	r3, r2
 800ade4:	3390      	adds	r3, #144	@ 0x90
 800ade6:	2201      	movs	r2, #1
 800ade8:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800adea:	693b      	ldr	r3, [r7, #16]
 800adec:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800adf0:	4619      	mov	r1, r3
 800adf2:	693a      	ldr	r2, [r7, #16]
 800adf4:	2334      	movs	r3, #52	@ 0x34
 800adf6:	fb01 f303 	mul.w	r3, r1, r3
 800adfa:	4413      	add	r3, r2
 800adfc:	3391      	adds	r3, #145	@ 0x91
 800adfe:	2202      	movs	r2, #2
 800ae00:	701a      	strb	r2, [r3, #0]
            break;
 800ae02:	e1ca      	b.n	800b19a <USBH_MSC_Process+0x4fa>
            ready_status = USBH_MSC_SCSI_TestUnitReady(phost, (uint8_t)MSC_Handle->current_lun);
 800ae04:	693b      	ldr	r3, [r7, #16]
 800ae06:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae0a:	b2db      	uxtb	r3, r3
 800ae0c:	4619      	mov	r1, r3
 800ae0e:	6878      	ldr	r0, [r7, #4]
 800ae10:	f000 fe66 	bl	800bae0 <USBH_MSC_SCSI_TestUnitReady>
 800ae14:	4603      	mov	r3, r0
 800ae16:	73bb      	strb	r3, [r7, #14]
            if (ready_status == USBH_OK)
 800ae18:	7bbb      	ldrb	r3, [r7, #14]
 800ae1a:	2b00      	cmp	r3, #0
 800ae1c:	d149      	bne.n	800aeb2 <USBH_MSC_Process+0x212>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_OK)
 800ae1e:	693b      	ldr	r3, [r7, #16]
 800ae20:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae24:	4619      	mov	r1, r3
 800ae26:	693a      	ldr	r2, [r7, #16]
 800ae28:	2334      	movs	r3, #52	@ 0x34
 800ae2a:	fb01 f303 	mul.w	r3, r1, r3
 800ae2e:	4413      	add	r3, r2
 800ae30:	3392      	adds	r3, #146	@ 0x92
 800ae32:	781b      	ldrb	r3, [r3, #0]
 800ae34:	2b00      	cmp	r3, #0
 800ae36:	d00c      	beq.n	800ae52 <USBH_MSC_Process+0x1b2>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800ae38:	693b      	ldr	r3, [r7, #16]
 800ae3a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae3e:	4619      	mov	r1, r3
 800ae40:	693a      	ldr	r2, [r7, #16]
 800ae42:	2334      	movs	r3, #52	@ 0x34
 800ae44:	fb01 f303 	mul.w	r3, r1, r3
 800ae48:	4413      	add	r3, r2
 800ae4a:	33c1      	adds	r3, #193	@ 0xc1
 800ae4c:	2201      	movs	r2, #1
 800ae4e:	701a      	strb	r2, [r3, #0]
 800ae50:	e00b      	b.n	800ae6a <USBH_MSC_Process+0x1ca>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 800ae52:	693b      	ldr	r3, [r7, #16]
 800ae54:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae58:	4619      	mov	r1, r3
 800ae5a:	693a      	ldr	r2, [r7, #16]
 800ae5c:	2334      	movs	r3, #52	@ 0x34
 800ae5e:	fb01 f303 	mul.w	r3, r1, r3
 800ae62:	4413      	add	r3, r2
 800ae64:	33c1      	adds	r3, #193	@ 0xc1
 800ae66:	2200      	movs	r2, #0
 800ae68:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_CAPACITY10;
 800ae6a:	693b      	ldr	r3, [r7, #16]
 800ae6c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae70:	4619      	mov	r1, r3
 800ae72:	693a      	ldr	r2, [r7, #16]
 800ae74:	2334      	movs	r3, #52	@ 0x34
 800ae76:	fb01 f303 	mul.w	r3, r1, r3
 800ae7a:	4413      	add	r3, r2
 800ae7c:	3390      	adds	r3, #144	@ 0x90
 800ae7e:	2203      	movs	r2, #3
 800ae80:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 800ae82:	693b      	ldr	r3, [r7, #16]
 800ae84:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae88:	4619      	mov	r1, r3
 800ae8a:	693a      	ldr	r2, [r7, #16]
 800ae8c:	2334      	movs	r3, #52	@ 0x34
 800ae8e:	fb01 f303 	mul.w	r3, r1, r3
 800ae92:	4413      	add	r3, r2
 800ae94:	3391      	adds	r3, #145	@ 0x91
 800ae96:	2200      	movs	r2, #0
 800ae98:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_OK;
 800ae9a:	693b      	ldr	r3, [r7, #16]
 800ae9c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aea0:	4619      	mov	r1, r3
 800aea2:	693a      	ldr	r2, [r7, #16]
 800aea4:	2334      	movs	r3, #52	@ 0x34
 800aea6:	fb01 f303 	mul.w	r3, r1, r3
 800aeaa:	4413      	add	r3, r2
 800aeac:	3392      	adds	r3, #146	@ 0x92
 800aeae:	2200      	movs	r2, #0
 800aeb0:	701a      	strb	r2, [r3, #0]
            if (ready_status == USBH_FAIL)
 800aeb2:	7bbb      	ldrb	r3, [r7, #14]
 800aeb4:	2b02      	cmp	r3, #2
 800aeb6:	d14a      	bne.n	800af4e <USBH_MSC_Process+0x2ae>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_FAIL)
 800aeb8:	693b      	ldr	r3, [r7, #16]
 800aeba:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aebe:	4619      	mov	r1, r3
 800aec0:	693a      	ldr	r2, [r7, #16]
 800aec2:	2334      	movs	r3, #52	@ 0x34
 800aec4:	fb01 f303 	mul.w	r3, r1, r3
 800aec8:	4413      	add	r3, r2
 800aeca:	3392      	adds	r3, #146	@ 0x92
 800aecc:	781b      	ldrb	r3, [r3, #0]
 800aece:	2b02      	cmp	r3, #2
 800aed0:	d00c      	beq.n	800aeec <USBH_MSC_Process+0x24c>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800aed2:	693b      	ldr	r3, [r7, #16]
 800aed4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aed8:	4619      	mov	r1, r3
 800aeda:	693a      	ldr	r2, [r7, #16]
 800aedc:	2334      	movs	r3, #52	@ 0x34
 800aede:	fb01 f303 	mul.w	r3, r1, r3
 800aee2:	4413      	add	r3, r2
 800aee4:	33c1      	adds	r3, #193	@ 0xc1
 800aee6:	2201      	movs	r2, #1
 800aee8:	701a      	strb	r2, [r3, #0]
 800aeea:	e00b      	b.n	800af04 <USBH_MSC_Process+0x264>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 800aeec:	693b      	ldr	r3, [r7, #16]
 800aeee:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aef2:	4619      	mov	r1, r3
 800aef4:	693a      	ldr	r2, [r7, #16]
 800aef6:	2334      	movs	r3, #52	@ 0x34
 800aef8:	fb01 f303 	mul.w	r3, r1, r3
 800aefc:	4413      	add	r3, r2
 800aefe:	33c1      	adds	r3, #193	@ 0xc1
 800af00:	2200      	movs	r2, #0
 800af02:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800af04:	693b      	ldr	r3, [r7, #16]
 800af06:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af0a:	4619      	mov	r1, r3
 800af0c:	693a      	ldr	r2, [r7, #16]
 800af0e:	2334      	movs	r3, #52	@ 0x34
 800af10:	fb01 f303 	mul.w	r3, r1, r3
 800af14:	4413      	add	r3, r2
 800af16:	3390      	adds	r3, #144	@ 0x90
 800af18:	2205      	movs	r2, #5
 800af1a:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 800af1c:	693b      	ldr	r3, [r7, #16]
 800af1e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af22:	4619      	mov	r1, r3
 800af24:	693a      	ldr	r2, [r7, #16]
 800af26:	2334      	movs	r3, #52	@ 0x34
 800af28:	fb01 f303 	mul.w	r3, r1, r3
 800af2c:	4413      	add	r3, r2
 800af2e:	3391      	adds	r3, #145	@ 0x91
 800af30:	2201      	movs	r2, #1
 800af32:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 800af34:	693b      	ldr	r3, [r7, #16]
 800af36:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af3a:	4619      	mov	r1, r3
 800af3c:	693a      	ldr	r2, [r7, #16]
 800af3e:	2334      	movs	r3, #52	@ 0x34
 800af40:	fb01 f303 	mul.w	r3, r1, r3
 800af44:	4413      	add	r3, r2
 800af46:	3392      	adds	r3, #146	@ 0x92
 800af48:	2202      	movs	r2, #2
 800af4a:	701a      	strb	r2, [r3, #0]
            break;
 800af4c:	e127      	b.n	800b19e <USBH_MSC_Process+0x4fe>
              if (ready_status == USBH_UNRECOVERED_ERROR)
 800af4e:	7bbb      	ldrb	r3, [r7, #14]
 800af50:	2b04      	cmp	r3, #4
 800af52:	f040 8124 	bne.w	800b19e <USBH_MSC_Process+0x4fe>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800af56:	693b      	ldr	r3, [r7, #16]
 800af58:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af5c:	4619      	mov	r1, r3
 800af5e:	693a      	ldr	r2, [r7, #16]
 800af60:	2334      	movs	r3, #52	@ 0x34
 800af62:	fb01 f303 	mul.w	r3, r1, r3
 800af66:	4413      	add	r3, r2
 800af68:	3390      	adds	r3, #144	@ 0x90
 800af6a:	2201      	movs	r2, #1
 800af6c:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800af6e:	693b      	ldr	r3, [r7, #16]
 800af70:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af74:	4619      	mov	r1, r3
 800af76:	693a      	ldr	r2, [r7, #16]
 800af78:	2334      	movs	r3, #52	@ 0x34
 800af7a:	fb01 f303 	mul.w	r3, r1, r3
 800af7e:	4413      	add	r3, r2
 800af80:	3391      	adds	r3, #145	@ 0x91
 800af82:	2202      	movs	r2, #2
 800af84:	701a      	strb	r2, [r3, #0]
            break;
 800af86:	e10a      	b.n	800b19e <USBH_MSC_Process+0x4fe>
            scsi_status = USBH_MSC_SCSI_ReadCapacity(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].capacity);
 800af88:	693b      	ldr	r3, [r7, #16]
 800af8a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af8e:	b2d9      	uxtb	r1, r3
 800af90:	693b      	ldr	r3, [r7, #16]
 800af92:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af96:	461a      	mov	r2, r3
 800af98:	2334      	movs	r3, #52	@ 0x34
 800af9a:	fb02 f303 	mul.w	r3, r2, r3
 800af9e:	3390      	adds	r3, #144	@ 0x90
 800afa0:	693a      	ldr	r2, [r7, #16]
 800afa2:	4413      	add	r3, r2
 800afa4:	3304      	adds	r3, #4
 800afa6:	461a      	mov	r2, r3
 800afa8:	6878      	ldr	r0, [r7, #4]
 800afaa:	f000 fddc 	bl	800bb66 <USBH_MSC_SCSI_ReadCapacity>
 800afae:	4603      	mov	r3, r0
 800afb0:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800afb2:	7bfb      	ldrb	r3, [r7, #15]
 800afb4:	2b00      	cmp	r3, #0
 800afb6:	d120      	bne.n	800affa <USBH_MSC_Process+0x35a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800afb8:	693b      	ldr	r3, [r7, #16]
 800afba:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800afbe:	4619      	mov	r1, r3
 800afc0:	693a      	ldr	r2, [r7, #16]
 800afc2:	2334      	movs	r3, #52	@ 0x34
 800afc4:	fb01 f303 	mul.w	r3, r1, r3
 800afc8:	4413      	add	r3, r2
 800afca:	3390      	adds	r3, #144	@ 0x90
 800afcc:	2201      	movs	r2, #1
 800afce:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 800afd0:	693b      	ldr	r3, [r7, #16]
 800afd2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800afd6:	4619      	mov	r1, r3
 800afd8:	693a      	ldr	r2, [r7, #16]
 800afda:	2334      	movs	r3, #52	@ 0x34
 800afdc:	fb01 f303 	mul.w	r3, r1, r3
 800afe0:	4413      	add	r3, r2
 800afe2:	3391      	adds	r3, #145	@ 0x91
 800afe4:	2200      	movs	r2, #0
 800afe6:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 800afe8:	693b      	ldr	r3, [r7, #16]
 800afea:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800afee:	3301      	adds	r3, #1
 800aff0:	b29a      	uxth	r2, r3
 800aff2:	693b      	ldr	r3, [r7, #16]
 800aff4:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            break;
 800aff8:	e0d3      	b.n	800b1a2 <USBH_MSC_Process+0x502>
            else if (scsi_status == USBH_FAIL)
 800affa:	7bfb      	ldrb	r3, [r7, #15]
 800affc:	2b02      	cmp	r3, #2
 800affe:	d10c      	bne.n	800b01a <USBH_MSC_Process+0x37a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800b000:	693b      	ldr	r3, [r7, #16]
 800b002:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b006:	4619      	mov	r1, r3
 800b008:	693a      	ldr	r2, [r7, #16]
 800b00a:	2334      	movs	r3, #52	@ 0x34
 800b00c:	fb01 f303 	mul.w	r3, r1, r3
 800b010:	4413      	add	r3, r2
 800b012:	3390      	adds	r3, #144	@ 0x90
 800b014:	2205      	movs	r2, #5
 800b016:	701a      	strb	r2, [r3, #0]
            break;
 800b018:	e0c3      	b.n	800b1a2 <USBH_MSC_Process+0x502>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b01a:	7bfb      	ldrb	r3, [r7, #15]
 800b01c:	2b04      	cmp	r3, #4
 800b01e:	f040 80c0 	bne.w	800b1a2 <USBH_MSC_Process+0x502>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800b022:	693b      	ldr	r3, [r7, #16]
 800b024:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b028:	4619      	mov	r1, r3
 800b02a:	693a      	ldr	r2, [r7, #16]
 800b02c:	2334      	movs	r3, #52	@ 0x34
 800b02e:	fb01 f303 	mul.w	r3, r1, r3
 800b032:	4413      	add	r3, r2
 800b034:	3390      	adds	r3, #144	@ 0x90
 800b036:	2201      	movs	r2, #1
 800b038:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800b03a:	693b      	ldr	r3, [r7, #16]
 800b03c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b040:	4619      	mov	r1, r3
 800b042:	693a      	ldr	r2, [r7, #16]
 800b044:	2334      	movs	r3, #52	@ 0x34
 800b046:	fb01 f303 	mul.w	r3, r1, r3
 800b04a:	4413      	add	r3, r2
 800b04c:	3391      	adds	r3, #145	@ 0x91
 800b04e:	2202      	movs	r2, #2
 800b050:	701a      	strb	r2, [r3, #0]
            break;
 800b052:	e0a6      	b.n	800b1a2 <USBH_MSC_Process+0x502>
            scsi_status = USBH_MSC_SCSI_RequestSense(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].sense);
 800b054:	693b      	ldr	r3, [r7, #16]
 800b056:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b05a:	b2d9      	uxtb	r1, r3
 800b05c:	693b      	ldr	r3, [r7, #16]
 800b05e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b062:	461a      	mov	r2, r3
 800b064:	2334      	movs	r3, #52	@ 0x34
 800b066:	fb02 f303 	mul.w	r3, r2, r3
 800b06a:	3398      	adds	r3, #152	@ 0x98
 800b06c:	693a      	ldr	r2, [r7, #16]
 800b06e:	4413      	add	r3, r2
 800b070:	3304      	adds	r3, #4
 800b072:	461a      	mov	r2, r3
 800b074:	6878      	ldr	r0, [r7, #4]
 800b076:	f000 fe95 	bl	800bda4 <USBH_MSC_SCSI_RequestSense>
 800b07a:	4603      	mov	r3, r0
 800b07c:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800b07e:	7bfb      	ldrb	r3, [r7, #15]
 800b080:	2b00      	cmp	r3, #0
 800b082:	d145      	bne.n	800b110 <USBH_MSC_Process+0x470>
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800b084:	693b      	ldr	r3, [r7, #16]
 800b086:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b08a:	4619      	mov	r1, r3
 800b08c:	693a      	ldr	r2, [r7, #16]
 800b08e:	2334      	movs	r3, #52	@ 0x34
 800b090:	fb01 f303 	mul.w	r3, r1, r3
 800b094:	4413      	add	r3, r2
 800b096:	339c      	adds	r3, #156	@ 0x9c
 800b098:	781b      	ldrb	r3, [r3, #0]
 800b09a:	2b06      	cmp	r3, #6
 800b09c:	d00c      	beq.n	800b0b8 <USBH_MSC_Process+0x418>
                  (MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_NOT_READY))
 800b09e:	693b      	ldr	r3, [r7, #16]
 800b0a0:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b0a4:	4619      	mov	r1, r3
 800b0a6:	693a      	ldr	r2, [r7, #16]
 800b0a8:	2334      	movs	r3, #52	@ 0x34
 800b0aa:	fb01 f303 	mul.w	r3, r1, r3
 800b0ae:	4413      	add	r3, r2
 800b0b0:	339c      	adds	r3, #156	@ 0x9c
 800b0b2:	781b      	ldrb	r3, [r3, #0]
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800b0b4:	2b02      	cmp	r3, #2
 800b0b6:	d117      	bne.n	800b0e8 <USBH_MSC_Process+0x448>
                if ((phost->Timer - MSC_Handle->timer) < 10000U)
 800b0b8:	687b      	ldr	r3, [r7, #4]
 800b0ba:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800b0be:	693b      	ldr	r3, [r7, #16]
 800b0c0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
 800b0c4:	1ad3      	subs	r3, r2, r3
 800b0c6:	f242 720f 	movw	r2, #9999	@ 0x270f
 800b0ca:	4293      	cmp	r3, r2
 800b0cc:	d80c      	bhi.n	800b0e8 <USBH_MSC_Process+0x448>
                  MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 800b0ce:	693b      	ldr	r3, [r7, #16]
 800b0d0:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b0d4:	4619      	mov	r1, r3
 800b0d6:	693a      	ldr	r2, [r7, #16]
 800b0d8:	2334      	movs	r3, #52	@ 0x34
 800b0da:	fb01 f303 	mul.w	r3, r1, r3
 800b0de:	4413      	add	r3, r2
 800b0e0:	3390      	adds	r3, #144	@ 0x90
 800b0e2:	2202      	movs	r2, #2
 800b0e4:	701a      	strb	r2, [r3, #0]
                  break;
 800b0e6:	e05f      	b.n	800b1a8 <USBH_MSC_Process+0x508>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800b0e8:	693b      	ldr	r3, [r7, #16]
 800b0ea:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b0ee:	4619      	mov	r1, r3
 800b0f0:	693a      	ldr	r2, [r7, #16]
 800b0f2:	2334      	movs	r3, #52	@ 0x34
 800b0f4:	fb01 f303 	mul.w	r3, r1, r3
 800b0f8:	4413      	add	r3, r2
 800b0fa:	3390      	adds	r3, #144	@ 0x90
 800b0fc:	2201      	movs	r2, #1
 800b0fe:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 800b100:	693b      	ldr	r3, [r7, #16]
 800b102:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b106:	3301      	adds	r3, #1
 800b108:	b29a      	uxth	r2, r3
 800b10a:	693b      	ldr	r3, [r7, #16]
 800b10c:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            if (scsi_status == USBH_FAIL)
 800b110:	7bfb      	ldrb	r3, [r7, #15]
 800b112:	2b02      	cmp	r3, #2
 800b114:	d10c      	bne.n	800b130 <USBH_MSC_Process+0x490>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_UNRECOVERED_ERROR;
 800b116:	693b      	ldr	r3, [r7, #16]
 800b118:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b11c:	4619      	mov	r1, r3
 800b11e:	693a      	ldr	r2, [r7, #16]
 800b120:	2334      	movs	r3, #52	@ 0x34
 800b122:	fb01 f303 	mul.w	r3, r1, r3
 800b126:	4413      	add	r3, r2
 800b128:	3390      	adds	r3, #144	@ 0x90
 800b12a:	2208      	movs	r2, #8
 800b12c:	701a      	strb	r2, [r3, #0]
            break;
 800b12e:	e03a      	b.n	800b1a6 <USBH_MSC_Process+0x506>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b130:	7bfb      	ldrb	r3, [r7, #15]
 800b132:	2b04      	cmp	r3, #4
 800b134:	d137      	bne.n	800b1a6 <USBH_MSC_Process+0x506>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800b136:	693b      	ldr	r3, [r7, #16]
 800b138:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b13c:	4619      	mov	r1, r3
 800b13e:	693a      	ldr	r2, [r7, #16]
 800b140:	2334      	movs	r3, #52	@ 0x34
 800b142:	fb01 f303 	mul.w	r3, r1, r3
 800b146:	4413      	add	r3, r2
 800b148:	3390      	adds	r3, #144	@ 0x90
 800b14a:	2201      	movs	r2, #1
 800b14c:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800b14e:	693b      	ldr	r3, [r7, #16]
 800b150:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b154:	4619      	mov	r1, r3
 800b156:	693a      	ldr	r2, [r7, #16]
 800b158:	2334      	movs	r3, #52	@ 0x34
 800b15a:	fb01 f303 	mul.w	r3, r1, r3
 800b15e:	4413      	add	r3, r2
 800b160:	3391      	adds	r3, #145	@ 0x91
 800b162:	2202      	movs	r2, #2
 800b164:	701a      	strb	r2, [r3, #0]
            break;
 800b166:	e01e      	b.n	800b1a6 <USBH_MSC_Process+0x506>
            MSC_Handle->current_lun++;
 800b168:	693b      	ldr	r3, [r7, #16]
 800b16a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800b16e:	3301      	adds	r3, #1
 800b170:	b29a      	uxth	r2, r3
 800b172:	693b      	ldr	r3, [r7, #16]
 800b174:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            break;
 800b178:	e016      	b.n	800b1a8 <USBH_MSC_Process+0x508>
        MSC_Handle->current_lun = 0U;
 800b17a:	693b      	ldr	r3, [r7, #16]
 800b17c:	2200      	movs	r2, #0
 800b17e:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
        MSC_Handle->state = MSC_IDLE;
 800b182:	693b      	ldr	r3, [r7, #16]
 800b184:	2201      	movs	r2, #1
 800b186:	731a      	strb	r2, [r3, #12]
        phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 800b188:	687b      	ldr	r3, [r7, #4]
 800b18a:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800b18e:	2102      	movs	r1, #2
 800b190:	6878      	ldr	r0, [r7, #4]
 800b192:	4798      	blx	r3
      break;
 800b194:	e00c      	b.n	800b1b0 <USBH_MSC_Process+0x510>
            break;
 800b196:	bf00      	nop
 800b198:	e00a      	b.n	800b1b0 <USBH_MSC_Process+0x510>
            break;
 800b19a:	bf00      	nop
 800b19c:	e008      	b.n	800b1b0 <USBH_MSC_Process+0x510>
            break;
 800b19e:	bf00      	nop
 800b1a0:	e006      	b.n	800b1b0 <USBH_MSC_Process+0x510>
            break;
 800b1a2:	bf00      	nop
 800b1a4:	e004      	b.n	800b1b0 <USBH_MSC_Process+0x510>
            break;
 800b1a6:	bf00      	nop
      break;
 800b1a8:	e002      	b.n	800b1b0 <USBH_MSC_Process+0x510>
      error = USBH_OK;
 800b1aa:	2300      	movs	r3, #0
 800b1ac:	75fb      	strb	r3, [r7, #23]
      break;
 800b1ae:	bf00      	nop
  }
  return error;
 800b1b0:	7dfb      	ldrb	r3, [r7, #23]
}
 800b1b2:	4618      	mov	r0, r3
 800b1b4:	3718      	adds	r7, #24
 800b1b6:	46bd      	mov	sp, r7
 800b1b8:	bd80      	pop	{r7, pc}
 800b1ba:	bf00      	nop

0800b1bc <USBH_MSC_SOFProcess>:
  *         The function is for SOF state
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_SOFProcess(USBH_HandleTypeDef *phost)
{
 800b1bc:	b480      	push	{r7}
 800b1be:	b083      	sub	sp, #12
 800b1c0:	af00      	add	r7, sp, #0
 800b1c2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phost);

  return USBH_OK;
 800b1c4:	2300      	movs	r3, #0
}
 800b1c6:	4618      	mov	r0, r3
 800b1c8:	370c      	adds	r7, #12
 800b1ca:	46bd      	mov	sp, r7
 800b1cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1d0:	4770      	bx	lr

0800b1d2 <USBH_MSC_RdWrProcess>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_RdWrProcess(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800b1d2:	b580      	push	{r7, lr}
 800b1d4:	b088      	sub	sp, #32
 800b1d6:	af02      	add	r7, sp, #8
 800b1d8:	6078      	str	r0, [r7, #4]
 800b1da:	460b      	mov	r3, r1
 800b1dc:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b1de:	687b      	ldr	r3, [r7, #4]
 800b1e0:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b1e4:	69db      	ldr	r3, [r3, #28]
 800b1e6:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY;
 800b1e8:	2301      	movs	r3, #1
 800b1ea:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY;
 800b1ec:	2301      	movs	r3, #1
 800b1ee:	73fb      	strb	r3, [r7, #15]

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->unit[lun].state)
 800b1f0:	78fb      	ldrb	r3, [r7, #3]
 800b1f2:	693a      	ldr	r2, [r7, #16]
 800b1f4:	2134      	movs	r1, #52	@ 0x34
 800b1f6:	fb01 f303 	mul.w	r3, r1, r3
 800b1fa:	4413      	add	r3, r2
 800b1fc:	3390      	adds	r3, #144	@ 0x90
 800b1fe:	781b      	ldrb	r3, [r3, #0]
 800b200:	2b07      	cmp	r3, #7
 800b202:	d03c      	beq.n	800b27e <USBH_MSC_RdWrProcess+0xac>
 800b204:	2b07      	cmp	r3, #7
 800b206:	f300 80a7 	bgt.w	800b358 <USBH_MSC_RdWrProcess+0x186>
 800b20a:	2b05      	cmp	r3, #5
 800b20c:	d06c      	beq.n	800b2e8 <USBH_MSC_RdWrProcess+0x116>
 800b20e:	2b06      	cmp	r3, #6
 800b210:	f040 80a2 	bne.w	800b358 <USBH_MSC_RdWrProcess+0x186>
  {

    case MSC_READ:
      scsi_status = USBH_MSC_SCSI_Read(phost, lun, 0U, NULL, 0U);
 800b214:	78f9      	ldrb	r1, [r7, #3]
 800b216:	2300      	movs	r3, #0
 800b218:	9300      	str	r3, [sp, #0]
 800b21a:	2300      	movs	r3, #0
 800b21c:	2200      	movs	r2, #0
 800b21e:	6878      	ldr	r0, [r7, #4]
 800b220:	f000 fea4 	bl	800bf6c <USBH_MSC_SCSI_Read>
 800b224:	4603      	mov	r3, r0
 800b226:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b228:	7bfb      	ldrb	r3, [r7, #15]
 800b22a:	2b00      	cmp	r3, #0
 800b22c:	d10b      	bne.n	800b246 <USBH_MSC_RdWrProcess+0x74>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b22e:	78fb      	ldrb	r3, [r7, #3]
 800b230:	693a      	ldr	r2, [r7, #16]
 800b232:	2134      	movs	r1, #52	@ 0x34
 800b234:	fb01 f303 	mul.w	r3, r1, r3
 800b238:	4413      	add	r3, r2
 800b23a:	3390      	adds	r3, #144	@ 0x90
 800b23c:	2201      	movs	r2, #1
 800b23e:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 800b240:	2300      	movs	r3, #0
 800b242:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b244:	e08a      	b.n	800b35c <USBH_MSC_RdWrProcess+0x18a>
      else if (scsi_status == USBH_FAIL)
 800b246:	7bfb      	ldrb	r3, [r7, #15]
 800b248:	2b02      	cmp	r3, #2
 800b24a:	d109      	bne.n	800b260 <USBH_MSC_RdWrProcess+0x8e>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800b24c:	78fb      	ldrb	r3, [r7, #3]
 800b24e:	693a      	ldr	r2, [r7, #16]
 800b250:	2134      	movs	r1, #52	@ 0x34
 800b252:	fb01 f303 	mul.w	r3, r1, r3
 800b256:	4413      	add	r3, r2
 800b258:	3390      	adds	r3, #144	@ 0x90
 800b25a:	2205      	movs	r2, #5
 800b25c:	701a      	strb	r2, [r3, #0]
      break;
 800b25e:	e07d      	b.n	800b35c <USBH_MSC_RdWrProcess+0x18a>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b260:	7bfb      	ldrb	r3, [r7, #15]
 800b262:	2b04      	cmp	r3, #4
 800b264:	d17a      	bne.n	800b35c <USBH_MSC_RdWrProcess+0x18a>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b266:	78fb      	ldrb	r3, [r7, #3]
 800b268:	693a      	ldr	r2, [r7, #16]
 800b26a:	2134      	movs	r1, #52	@ 0x34
 800b26c:	fb01 f303 	mul.w	r3, r1, r3
 800b270:	4413      	add	r3, r2
 800b272:	3390      	adds	r3, #144	@ 0x90
 800b274:	2208      	movs	r2, #8
 800b276:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b278:	2302      	movs	r3, #2
 800b27a:	75fb      	strb	r3, [r7, #23]
      break;
 800b27c:	e06e      	b.n	800b35c <USBH_MSC_RdWrProcess+0x18a>

    case MSC_WRITE:
      scsi_status = USBH_MSC_SCSI_Write(phost, lun, 0U, NULL, 0U);
 800b27e:	78f9      	ldrb	r1, [r7, #3]
 800b280:	2300      	movs	r3, #0
 800b282:	9300      	str	r3, [sp, #0]
 800b284:	2300      	movs	r3, #0
 800b286:	2200      	movs	r2, #0
 800b288:	6878      	ldr	r0, [r7, #4]
 800b28a:	f000 fe04 	bl	800be96 <USBH_MSC_SCSI_Write>
 800b28e:	4603      	mov	r3, r0
 800b290:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b292:	7bfb      	ldrb	r3, [r7, #15]
 800b294:	2b00      	cmp	r3, #0
 800b296:	d10b      	bne.n	800b2b0 <USBH_MSC_RdWrProcess+0xde>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b298:	78fb      	ldrb	r3, [r7, #3]
 800b29a:	693a      	ldr	r2, [r7, #16]
 800b29c:	2134      	movs	r1, #52	@ 0x34
 800b29e:	fb01 f303 	mul.w	r3, r1, r3
 800b2a2:	4413      	add	r3, r2
 800b2a4:	3390      	adds	r3, #144	@ 0x90
 800b2a6:	2201      	movs	r2, #1
 800b2a8:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 800b2aa:	2300      	movs	r3, #0
 800b2ac:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b2ae:	e057      	b.n	800b360 <USBH_MSC_RdWrProcess+0x18e>
      else if (scsi_status == USBH_FAIL)
 800b2b0:	7bfb      	ldrb	r3, [r7, #15]
 800b2b2:	2b02      	cmp	r3, #2
 800b2b4:	d109      	bne.n	800b2ca <USBH_MSC_RdWrProcess+0xf8>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800b2b6:	78fb      	ldrb	r3, [r7, #3]
 800b2b8:	693a      	ldr	r2, [r7, #16]
 800b2ba:	2134      	movs	r1, #52	@ 0x34
 800b2bc:	fb01 f303 	mul.w	r3, r1, r3
 800b2c0:	4413      	add	r3, r2
 800b2c2:	3390      	adds	r3, #144	@ 0x90
 800b2c4:	2205      	movs	r2, #5
 800b2c6:	701a      	strb	r2, [r3, #0]
      break;
 800b2c8:	e04a      	b.n	800b360 <USBH_MSC_RdWrProcess+0x18e>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b2ca:	7bfb      	ldrb	r3, [r7, #15]
 800b2cc:	2b04      	cmp	r3, #4
 800b2ce:	d147      	bne.n	800b360 <USBH_MSC_RdWrProcess+0x18e>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b2d0:	78fb      	ldrb	r3, [r7, #3]
 800b2d2:	693a      	ldr	r2, [r7, #16]
 800b2d4:	2134      	movs	r1, #52	@ 0x34
 800b2d6:	fb01 f303 	mul.w	r3, r1, r3
 800b2da:	4413      	add	r3, r2
 800b2dc:	3390      	adds	r3, #144	@ 0x90
 800b2de:	2208      	movs	r2, #8
 800b2e0:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b2e2:	2302      	movs	r3, #2
 800b2e4:	75fb      	strb	r3, [r7, #23]
      break;
 800b2e6:	e03b      	b.n	800b360 <USBH_MSC_RdWrProcess+0x18e>

    case MSC_REQUEST_SENSE:
      scsi_status = USBH_MSC_SCSI_RequestSense(phost, lun, &MSC_Handle->unit[lun].sense);
 800b2e8:	78fb      	ldrb	r3, [r7, #3]
 800b2ea:	2234      	movs	r2, #52	@ 0x34
 800b2ec:	fb02 f303 	mul.w	r3, r2, r3
 800b2f0:	3398      	adds	r3, #152	@ 0x98
 800b2f2:	693a      	ldr	r2, [r7, #16]
 800b2f4:	4413      	add	r3, r2
 800b2f6:	1d1a      	adds	r2, r3, #4
 800b2f8:	78fb      	ldrb	r3, [r7, #3]
 800b2fa:	4619      	mov	r1, r3
 800b2fc:	6878      	ldr	r0, [r7, #4]
 800b2fe:	f000 fd51 	bl	800bda4 <USBH_MSC_SCSI_RequestSense>
 800b302:	4603      	mov	r3, r0
 800b304:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b306:	7bfb      	ldrb	r3, [r7, #15]
 800b308:	2b00      	cmp	r3, #0
 800b30a:	d113      	bne.n	800b334 <USBH_MSC_RdWrProcess+0x162>
      {
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
        USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[lun].sense.asc);
        USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[lun].sense.ascq);
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b30c:	78fb      	ldrb	r3, [r7, #3]
 800b30e:	693a      	ldr	r2, [r7, #16]
 800b310:	2134      	movs	r1, #52	@ 0x34
 800b312:	fb01 f303 	mul.w	r3, r1, r3
 800b316:	4413      	add	r3, r2
 800b318:	3390      	adds	r3, #144	@ 0x90
 800b31a:	2201      	movs	r2, #1
 800b31c:	701a      	strb	r2, [r3, #0]
        MSC_Handle->unit[lun].error = MSC_ERROR;
 800b31e:	78fb      	ldrb	r3, [r7, #3]
 800b320:	693a      	ldr	r2, [r7, #16]
 800b322:	2134      	movs	r1, #52	@ 0x34
 800b324:	fb01 f303 	mul.w	r3, r1, r3
 800b328:	4413      	add	r3, r2
 800b32a:	3391      	adds	r3, #145	@ 0x91
 800b32c:	2202      	movs	r2, #2
 800b32e:	701a      	strb	r2, [r3, #0]

        error = USBH_FAIL;
 800b330:	2302      	movs	r3, #2
 800b332:	75fb      	strb	r3, [r7, #23]
      }
      if (scsi_status == USBH_FAIL)
 800b334:	7bfb      	ldrb	r3, [r7, #15]
 800b336:	2b02      	cmp	r3, #2
 800b338:	d014      	beq.n	800b364 <USBH_MSC_RdWrProcess+0x192>
      {
        USBH_UsrLog("MSC Device NOT ready");
      }
      else
      {
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b33a:	7bfb      	ldrb	r3, [r7, #15]
 800b33c:	2b04      	cmp	r3, #4
 800b33e:	d111      	bne.n	800b364 <USBH_MSC_RdWrProcess+0x192>
        {
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b340:	78fb      	ldrb	r3, [r7, #3]
 800b342:	693a      	ldr	r2, [r7, #16]
 800b344:	2134      	movs	r1, #52	@ 0x34
 800b346:	fb01 f303 	mul.w	r3, r1, r3
 800b34a:	4413      	add	r3, r2
 800b34c:	3390      	adds	r3, #144	@ 0x90
 800b34e:	2208      	movs	r2, #8
 800b350:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b352:	2302      	movs	r3, #2
 800b354:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b356:	e005      	b.n	800b364 <USBH_MSC_RdWrProcess+0x192>

    default:
      break;
 800b358:	bf00      	nop
 800b35a:	e004      	b.n	800b366 <USBH_MSC_RdWrProcess+0x194>
      break;
 800b35c:	bf00      	nop
 800b35e:	e002      	b.n	800b366 <USBH_MSC_RdWrProcess+0x194>
      break;
 800b360:	bf00      	nop
 800b362:	e000      	b.n	800b366 <USBH_MSC_RdWrProcess+0x194>
      break;
 800b364:	bf00      	nop

  }
  return error;
 800b366:	7dfb      	ldrb	r3, [r7, #23]
}
 800b368:	4618      	mov	r0, r3
 800b36a:	3718      	adds	r7, #24
 800b36c:	46bd      	mov	sp, r7
 800b36e:	bd80      	pop	{r7, pc}

0800b370 <USBH_MSC_UnitIsReady>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval Lun status (0: not ready / 1: ready)
  */
uint8_t USBH_MSC_UnitIsReady(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800b370:	b480      	push	{r7}
 800b372:	b085      	sub	sp, #20
 800b374:	af00      	add	r7, sp, #0
 800b376:	6078      	str	r0, [r7, #4]
 800b378:	460b      	mov	r3, r1
 800b37a:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b37c:	687b      	ldr	r3, [r7, #4]
 800b37e:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b382:	69db      	ldr	r3, [r3, #28]
 800b384:	60bb      	str	r3, [r7, #8]
  uint8_t res;

  if ((phost->gState == HOST_CLASS) && (MSC_Handle->unit[lun].error == MSC_OK))
 800b386:	687b      	ldr	r3, [r7, #4]
 800b388:	781b      	ldrb	r3, [r3, #0]
 800b38a:	b2db      	uxtb	r3, r3
 800b38c:	2b0b      	cmp	r3, #11
 800b38e:	d10c      	bne.n	800b3aa <USBH_MSC_UnitIsReady+0x3a>
 800b390:	78fb      	ldrb	r3, [r7, #3]
 800b392:	68ba      	ldr	r2, [r7, #8]
 800b394:	2134      	movs	r1, #52	@ 0x34
 800b396:	fb01 f303 	mul.w	r3, r1, r3
 800b39a:	4413      	add	r3, r2
 800b39c:	3391      	adds	r3, #145	@ 0x91
 800b39e:	781b      	ldrb	r3, [r3, #0]
 800b3a0:	2b00      	cmp	r3, #0
 800b3a2:	d102      	bne.n	800b3aa <USBH_MSC_UnitIsReady+0x3a>
  {
    res = 1U;
 800b3a4:	2301      	movs	r3, #1
 800b3a6:	73fb      	strb	r3, [r7, #15]
 800b3a8:	e001      	b.n	800b3ae <USBH_MSC_UnitIsReady+0x3e>
  }
  else
  {
    res = 0U;
 800b3aa:	2300      	movs	r3, #0
 800b3ac:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 800b3ae:	7bfb      	ldrb	r3, [r7, #15]
}
 800b3b0:	4618      	mov	r0, r3
 800b3b2:	3714      	adds	r7, #20
 800b3b4:	46bd      	mov	sp, r7
 800b3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3ba:	4770      	bx	lr

0800b3bc <USBH_MSC_GetLUNInfo>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_GetLUNInfo(USBH_HandleTypeDef *phost, uint8_t lun, MSC_LUNTypeDef *info)
{
 800b3bc:	b580      	push	{r7, lr}
 800b3be:	b086      	sub	sp, #24
 800b3c0:	af00      	add	r7, sp, #0
 800b3c2:	60f8      	str	r0, [r7, #12]
 800b3c4:	460b      	mov	r3, r1
 800b3c6:	607a      	str	r2, [r7, #4]
 800b3c8:	72fb      	strb	r3, [r7, #11]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b3ca:	68fb      	ldr	r3, [r7, #12]
 800b3cc:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b3d0:	69db      	ldr	r3, [r3, #28]
 800b3d2:	617b      	str	r3, [r7, #20]
  if (phost->gState == HOST_CLASS)
 800b3d4:	68fb      	ldr	r3, [r7, #12]
 800b3d6:	781b      	ldrb	r3, [r3, #0]
 800b3d8:	b2db      	uxtb	r3, r3
 800b3da:	2b0b      	cmp	r3, #11
 800b3dc:	d10d      	bne.n	800b3fa <USBH_MSC_GetLUNInfo+0x3e>
  {
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 800b3de:	7afb      	ldrb	r3, [r7, #11]
 800b3e0:	2234      	movs	r2, #52	@ 0x34
 800b3e2:	fb02 f303 	mul.w	r3, r2, r3
 800b3e6:	3390      	adds	r3, #144	@ 0x90
 800b3e8:	697a      	ldr	r2, [r7, #20]
 800b3ea:	4413      	add	r3, r2
 800b3ec:	2234      	movs	r2, #52	@ 0x34
 800b3ee:	4619      	mov	r1, r3
 800b3f0:	6878      	ldr	r0, [r7, #4]
 800b3f2:	f022 fa8a 	bl	802d90a <memcpy>
    return USBH_OK;
 800b3f6:	2300      	movs	r3, #0
 800b3f8:	e000      	b.n	800b3fc <USBH_MSC_GetLUNInfo+0x40>
  }
  else
  {
    return USBH_FAIL;
 800b3fa:	2302      	movs	r3, #2
  }
}
 800b3fc:	4618      	mov	r0, r3
 800b3fe:	3718      	adds	r7, #24
 800b400:	46bd      	mov	sp, r7
 800b402:	bd80      	pop	{r7, pc}

0800b404 <USBH_MSC_Read>:
USBH_StatusTypeDef USBH_MSC_Read(USBH_HandleTypeDef *phost,
                                 uint8_t lun,
                                 uint32_t address,
                                 uint8_t *pbuf,
                                 uint32_t length)
{
 800b404:	b580      	push	{r7, lr}
 800b406:	b088      	sub	sp, #32
 800b408:	af02      	add	r7, sp, #8
 800b40a:	60f8      	str	r0, [r7, #12]
 800b40c:	607a      	str	r2, [r7, #4]
 800b40e:	603b      	str	r3, [r7, #0]
 800b410:	460b      	mov	r3, r1
 800b412:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b414:	68fb      	ldr	r3, [r7, #12]
 800b416:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b41a:	69db      	ldr	r3, [r3, #28]
 800b41c:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 800b41e:	68fb      	ldr	r3, [r7, #12]
 800b420:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b424:	b2db      	uxtb	r3, r3
 800b426:	2b00      	cmp	r3, #0
 800b428:	d00e      	beq.n	800b448 <USBH_MSC_Read+0x44>
      (phost->gState != HOST_CLASS) ||
 800b42a:	68fb      	ldr	r3, [r7, #12]
 800b42c:	781b      	ldrb	r3, [r3, #0]
 800b42e:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 800b430:	2b0b      	cmp	r3, #11
 800b432:	d109      	bne.n	800b448 <USBH_MSC_Read+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800b434:	7afb      	ldrb	r3, [r7, #11]
 800b436:	697a      	ldr	r2, [r7, #20]
 800b438:	2134      	movs	r1, #52	@ 0x34
 800b43a:	fb01 f303 	mul.w	r3, r1, r3
 800b43e:	4413      	add	r3, r2
 800b440:	3390      	adds	r3, #144	@ 0x90
 800b442:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 800b444:	2b01      	cmp	r3, #1
 800b446:	d001      	beq.n	800b44c <USBH_MSC_Read+0x48>
  {
    return  USBH_FAIL;
 800b448:	2302      	movs	r3, #2
 800b44a:	e040      	b.n	800b4ce <USBH_MSC_Read+0xca>
  }

  MSC_Handle->state = MSC_READ;
 800b44c:	697b      	ldr	r3, [r7, #20]
 800b44e:	2206      	movs	r2, #6
 800b450:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_READ;
 800b452:	7afb      	ldrb	r3, [r7, #11]
 800b454:	697a      	ldr	r2, [r7, #20]
 800b456:	2134      	movs	r1, #52	@ 0x34
 800b458:	fb01 f303 	mul.w	r3, r1, r3
 800b45c:	4413      	add	r3, r2
 800b45e:	3390      	adds	r3, #144	@ 0x90
 800b460:	2206      	movs	r2, #6
 800b462:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 800b464:	7afb      	ldrb	r3, [r7, #11]
 800b466:	b29a      	uxth	r2, r3
 800b468:	697b      	ldr	r3, [r7, #20]
 800b46a:	f8a3 20fa 	strh.w	r2, [r3, #250]	@ 0xfa

  (void)USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 800b46e:	7af9      	ldrb	r1, [r7, #11]
 800b470:	6a3b      	ldr	r3, [r7, #32]
 800b472:	9300      	str	r3, [sp, #0]
 800b474:	683b      	ldr	r3, [r7, #0]
 800b476:	687a      	ldr	r2, [r7, #4]
 800b478:	68f8      	ldr	r0, [r7, #12]
 800b47a:	f000 fd77 	bl	800bf6c <USBH_MSC_SCSI_Read>

  timeout = phost->Timer;
 800b47e:	68fb      	ldr	r3, [r7, #12]
 800b480:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800b484:	613b      	str	r3, [r7, #16]

  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b486:	e016      	b.n	800b4b6 <USBH_MSC_Read+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800b488:	68fb      	ldr	r3, [r7, #12]
 800b48a:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800b48e:	693b      	ldr	r3, [r7, #16]
 800b490:	1ad2      	subs	r2, r2, r3
 800b492:	6a3b      	ldr	r3, [r7, #32]
 800b494:	f242 7110 	movw	r1, #10000	@ 0x2710
 800b498:	fb01 f303 	mul.w	r3, r1, r3
 800b49c:	429a      	cmp	r2, r3
 800b49e:	d805      	bhi.n	800b4ac <USBH_MSC_Read+0xa8>
 800b4a0:	68fb      	ldr	r3, [r7, #12]
 800b4a2:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b4a6:	b2db      	uxtb	r3, r3
 800b4a8:	2b00      	cmp	r3, #0
 800b4aa:	d104      	bne.n	800b4b6 <USBH_MSC_Read+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 800b4ac:	697b      	ldr	r3, [r7, #20]
 800b4ae:	2201      	movs	r2, #1
 800b4b0:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 800b4b2:	2302      	movs	r3, #2
 800b4b4:	e00b      	b.n	800b4ce <USBH_MSC_Read+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b4b6:	7afb      	ldrb	r3, [r7, #11]
 800b4b8:	4619      	mov	r1, r3
 800b4ba:	68f8      	ldr	r0, [r7, #12]
 800b4bc:	f7ff fe89 	bl	800b1d2 <USBH_MSC_RdWrProcess>
 800b4c0:	4603      	mov	r3, r0
 800b4c2:	2b01      	cmp	r3, #1
 800b4c4:	d0e0      	beq.n	800b488 <USBH_MSC_Read+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 800b4c6:	697b      	ldr	r3, [r7, #20]
 800b4c8:	2201      	movs	r2, #1
 800b4ca:	731a      	strb	r2, [r3, #12]

  return USBH_OK;
 800b4cc:	2300      	movs	r3, #0
}
 800b4ce:	4618      	mov	r0, r3
 800b4d0:	3718      	adds	r7, #24
 800b4d2:	46bd      	mov	sp, r7
 800b4d4:	bd80      	pop	{r7, pc}

0800b4d6 <USBH_MSC_Write>:
USBH_StatusTypeDef USBH_MSC_Write(USBH_HandleTypeDef *phost,
                                  uint8_t lun,
                                  uint32_t address,
                                  uint8_t *pbuf,
                                  uint32_t length)
{
 800b4d6:	b580      	push	{r7, lr}
 800b4d8:	b088      	sub	sp, #32
 800b4da:	af02      	add	r7, sp, #8
 800b4dc:	60f8      	str	r0, [r7, #12]
 800b4de:	607a      	str	r2, [r7, #4]
 800b4e0:	603b      	str	r3, [r7, #0]
 800b4e2:	460b      	mov	r3, r1
 800b4e4:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b4e6:	68fb      	ldr	r3, [r7, #12]
 800b4e8:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b4ec:	69db      	ldr	r3, [r3, #28]
 800b4ee:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 800b4f0:	68fb      	ldr	r3, [r7, #12]
 800b4f2:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b4f6:	b2db      	uxtb	r3, r3
 800b4f8:	2b00      	cmp	r3, #0
 800b4fa:	d00e      	beq.n	800b51a <USBH_MSC_Write+0x44>
      (phost->gState != HOST_CLASS) ||
 800b4fc:	68fb      	ldr	r3, [r7, #12]
 800b4fe:	781b      	ldrb	r3, [r3, #0]
 800b500:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 800b502:	2b0b      	cmp	r3, #11
 800b504:	d109      	bne.n	800b51a <USBH_MSC_Write+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800b506:	7afb      	ldrb	r3, [r7, #11]
 800b508:	697a      	ldr	r2, [r7, #20]
 800b50a:	2134      	movs	r1, #52	@ 0x34
 800b50c:	fb01 f303 	mul.w	r3, r1, r3
 800b510:	4413      	add	r3, r2
 800b512:	3390      	adds	r3, #144	@ 0x90
 800b514:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 800b516:	2b01      	cmp	r3, #1
 800b518:	d001      	beq.n	800b51e <USBH_MSC_Write+0x48>
  {
    return  USBH_FAIL;
 800b51a:	2302      	movs	r3, #2
 800b51c:	e040      	b.n	800b5a0 <USBH_MSC_Write+0xca>
  }

  MSC_Handle->state = MSC_WRITE;
 800b51e:	697b      	ldr	r3, [r7, #20]
 800b520:	2207      	movs	r2, #7
 800b522:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_WRITE;
 800b524:	7afb      	ldrb	r3, [r7, #11]
 800b526:	697a      	ldr	r2, [r7, #20]
 800b528:	2134      	movs	r1, #52	@ 0x34
 800b52a:	fb01 f303 	mul.w	r3, r1, r3
 800b52e:	4413      	add	r3, r2
 800b530:	3390      	adds	r3, #144	@ 0x90
 800b532:	2207      	movs	r2, #7
 800b534:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 800b536:	7afb      	ldrb	r3, [r7, #11]
 800b538:	b29a      	uxth	r2, r3
 800b53a:	697b      	ldr	r3, [r7, #20]
 800b53c:	f8a3 20fa 	strh.w	r2, [r3, #250]	@ 0xfa

  (void)USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 800b540:	7af9      	ldrb	r1, [r7, #11]
 800b542:	6a3b      	ldr	r3, [r7, #32]
 800b544:	9300      	str	r3, [sp, #0]
 800b546:	683b      	ldr	r3, [r7, #0]
 800b548:	687a      	ldr	r2, [r7, #4]
 800b54a:	68f8      	ldr	r0, [r7, #12]
 800b54c:	f000 fca3 	bl	800be96 <USBH_MSC_SCSI_Write>

  timeout = phost->Timer;
 800b550:	68fb      	ldr	r3, [r7, #12]
 800b552:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800b556:	613b      	str	r3, [r7, #16]
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b558:	e016      	b.n	800b588 <USBH_MSC_Write+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800b55a:	68fb      	ldr	r3, [r7, #12]
 800b55c:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800b560:	693b      	ldr	r3, [r7, #16]
 800b562:	1ad2      	subs	r2, r2, r3
 800b564:	6a3b      	ldr	r3, [r7, #32]
 800b566:	f242 7110 	movw	r1, #10000	@ 0x2710
 800b56a:	fb01 f303 	mul.w	r3, r1, r3
 800b56e:	429a      	cmp	r2, r3
 800b570:	d805      	bhi.n	800b57e <USBH_MSC_Write+0xa8>
 800b572:	68fb      	ldr	r3, [r7, #12]
 800b574:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b578:	b2db      	uxtb	r3, r3
 800b57a:	2b00      	cmp	r3, #0
 800b57c:	d104      	bne.n	800b588 <USBH_MSC_Write+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 800b57e:	697b      	ldr	r3, [r7, #20]
 800b580:	2201      	movs	r2, #1
 800b582:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 800b584:	2302      	movs	r3, #2
 800b586:	e00b      	b.n	800b5a0 <USBH_MSC_Write+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b588:	7afb      	ldrb	r3, [r7, #11]
 800b58a:	4619      	mov	r1, r3
 800b58c:	68f8      	ldr	r0, [r7, #12]
 800b58e:	f7ff fe20 	bl	800b1d2 <USBH_MSC_RdWrProcess>
 800b592:	4603      	mov	r3, r0
 800b594:	2b01      	cmp	r3, #1
 800b596:	d0e0      	beq.n	800b55a <USBH_MSC_Write+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 800b598:	697b      	ldr	r3, [r7, #20]
 800b59a:	2201      	movs	r2, #1
 800b59c:	731a      	strb	r2, [r3, #12]
  return USBH_OK;
 800b59e:	2300      	movs	r3, #0
}
 800b5a0:	4618      	mov	r0, r3
 800b5a2:	3718      	adds	r7, #24
 800b5a4:	46bd      	mov	sp, r7
 800b5a6:	bd80      	pop	{r7, pc}

0800b5a8 <USBH_MSC_BOT_REQ_Reset>:
  *         The function the MSC BOT Reset request.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
{
 800b5a8:	b580      	push	{r7, lr}
 800b5aa:	b082      	sub	sp, #8
 800b5ac:	af00      	add	r7, sp, #0
 800b5ae:	6078      	str	r0, [r7, #4]

  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS
 800b5b0:	687b      	ldr	r3, [r7, #4]
 800b5b2:	2221      	movs	r2, #33	@ 0x21
 800b5b4:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 800b5b6:	687b      	ldr	r3, [r7, #4]
 800b5b8:	22ff      	movs	r2, #255	@ 0xff
 800b5ba:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 800b5bc:	687b      	ldr	r3, [r7, #4]
 800b5be:	2200      	movs	r2, #0
 800b5c0:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 800b5c2:	687b      	ldr	r3, [r7, #4]
 800b5c4:	2200      	movs	r2, #0
 800b5c6:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 0U;
 800b5c8:	687b      	ldr	r3, [r7, #4]
 800b5ca:	2200      	movs	r2, #0
 800b5cc:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, NULL, 0U);
 800b5ce:	2200      	movs	r2, #0
 800b5d0:	2100      	movs	r1, #0
 800b5d2:	6878      	ldr	r0, [r7, #4]
 800b5d4:	f001 ff35 	bl	800d442 <USBH_CtlReq>
 800b5d8:	4603      	mov	r3, r0
}
 800b5da:	4618      	mov	r0, r3
 800b5dc:	3708      	adds	r7, #8
 800b5de:	46bd      	mov	sp, r7
 800b5e0:	bd80      	pop	{r7, pc}

0800b5e2 <USBH_MSC_BOT_REQ_GetMaxLUN>:
  * @param  phost: Host handle
  * @param  Maxlun: pointer to Maxlun variable
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
{
 800b5e2:	b580      	push	{r7, lr}
 800b5e4:	b082      	sub	sp, #8
 800b5e6:	af00      	add	r7, sp, #0
 800b5e8:	6078      	str	r0, [r7, #4]
 800b5ea:	6039      	str	r1, [r7, #0]
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS
 800b5ec:	687b      	ldr	r3, [r7, #4]
 800b5ee:	22a1      	movs	r2, #161	@ 0xa1
 800b5f0:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 800b5f2:	687b      	ldr	r3, [r7, #4]
 800b5f4:	22fe      	movs	r2, #254	@ 0xfe
 800b5f6:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 800b5f8:	687b      	ldr	r3, [r7, #4]
 800b5fa:	2200      	movs	r2, #0
 800b5fc:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 800b5fe:	687b      	ldr	r3, [r7, #4]
 800b600:	2200      	movs	r2, #0
 800b602:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 1U;
 800b604:	687b      	ldr	r3, [r7, #4]
 800b606:	2201      	movs	r2, #1
 800b608:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, Maxlun, 1U);
 800b60a:	2201      	movs	r2, #1
 800b60c:	6839      	ldr	r1, [r7, #0]
 800b60e:	6878      	ldr	r0, [r7, #4]
 800b610:	f001 ff17 	bl	800d442 <USBH_CtlReq>
 800b614:	4603      	mov	r3, r0
}
 800b616:	4618      	mov	r0, r3
 800b618:	3708      	adds	r7, #8
 800b61a:	46bd      	mov	sp, r7
 800b61c:	bd80      	pop	{r7, pc}
	...

0800b620 <USBH_MSC_BOT_Init>:
  *         The function Initializes the BOT protocol.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
{
 800b620:	b480      	push	{r7}
 800b622:	b085      	sub	sp, #20
 800b624:	af00      	add	r7, sp, #0
 800b626:	6078      	str	r0, [r7, #4]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b628:	687b      	ldr	r3, [r7, #4]
 800b62a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b62e:	69db      	ldr	r3, [r3, #28]
 800b630:	60fb      	str	r3, [r7, #12]

  MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
 800b632:	68fb      	ldr	r3, [r7, #12]
 800b634:	4a09      	ldr	r2, [pc, #36]	@ (800b65c <USBH_MSC_BOT_Init+0x3c>)
 800b636:	655a      	str	r2, [r3, #84]	@ 0x54
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
 800b638:	68fb      	ldr	r3, [r7, #12]
 800b63a:	4a09      	ldr	r2, [pc, #36]	@ (800b660 <USBH_MSC_BOT_Init+0x40>)
 800b63c:	659a      	str	r2, [r3, #88]	@ 0x58
  MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b63e:	68fb      	ldr	r3, [r7, #12]
 800b640:	2201      	movs	r2, #1
 800b642:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 800b646:	68fb      	ldr	r3, [r7, #12]
 800b648:	2201      	movs	r2, #1
 800b64a:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52

  return USBH_OK;
 800b64e:	2300      	movs	r3, #0
}
 800b650:	4618      	mov	r0, r3
 800b652:	3714      	adds	r7, #20
 800b654:	46bd      	mov	sp, r7
 800b656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b65a:	4770      	bx	lr
 800b65c:	43425355 	.word	0x43425355
 800b660:	20304050 	.word	0x20304050

0800b664 <USBH_MSC_BOT_Process>:
  * @param  phost: Host handle
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Process(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800b664:	b580      	push	{r7, lr}
 800b666:	b088      	sub	sp, #32
 800b668:	af02      	add	r7, sp, #8
 800b66a:	6078      	str	r0, [r7, #4]
 800b66c:	460b      	mov	r3, r1
 800b66e:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef   status = USBH_BUSY;
 800b670:	2301      	movs	r3, #1
 800b672:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef   error  = USBH_BUSY;
 800b674:	2301      	movs	r3, #1
 800b676:	75bb      	strb	r3, [r7, #22]
  BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
 800b678:	2301      	movs	r3, #1
 800b67a:	757b      	strb	r3, [r7, #21]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 800b67c:	2300      	movs	r3, #0
 800b67e:	753b      	strb	r3, [r7, #20]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b680:	687b      	ldr	r3, [r7, #4]
 800b682:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b686:	69db      	ldr	r3, [r3, #28]
 800b688:	613b      	str	r3, [r7, #16]
  uint8_t toggle = 0U;
 800b68a:	2300      	movs	r3, #0
 800b68c:	73fb      	strb	r3, [r7, #15]

  switch (MSC_Handle->hbot.state)
 800b68e:	693b      	ldr	r3, [r7, #16]
 800b690:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800b694:	3b01      	subs	r3, #1
 800b696:	2b0a      	cmp	r3, #10
 800b698:	f200 819e 	bhi.w	800b9d8 <USBH_MSC_BOT_Process+0x374>
 800b69c:	a201      	add	r2, pc, #4	@ (adr r2, 800b6a4 <USBH_MSC_BOT_Process+0x40>)
 800b69e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b6a2:	bf00      	nop
 800b6a4:	0800b6d1 	.word	0x0800b6d1
 800b6a8:	0800b6f9 	.word	0x0800b6f9
 800b6ac:	0800b763 	.word	0x0800b763
 800b6b0:	0800b781 	.word	0x0800b781
 800b6b4:	0800b805 	.word	0x0800b805
 800b6b8:	0800b827 	.word	0x0800b827
 800b6bc:	0800b8bf 	.word	0x0800b8bf
 800b6c0:	0800b8db 	.word	0x0800b8db
 800b6c4:	0800b92d 	.word	0x0800b92d
 800b6c8:	0800b95d 	.word	0x0800b95d
 800b6cc:	0800b9bf 	.word	0x0800b9bf
  {
    case BOT_SEND_CBW:
      MSC_Handle->hbot.cbw.field.LUN = lun;
 800b6d0:	693b      	ldr	r3, [r7, #16]
 800b6d2:	78fa      	ldrb	r2, [r7, #3]
 800b6d4:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61
      MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;
 800b6d8:	693b      	ldr	r3, [r7, #16]
 800b6da:	2202      	movs	r2, #2
 800b6dc:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.cbw.data,
 800b6e0:	693b      	ldr	r3, [r7, #16]
 800b6e2:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 800b6e6:	693b      	ldr	r3, [r7, #16]
 800b6e8:	795b      	ldrb	r3, [r3, #5]
 800b6ea:	2201      	movs	r2, #1
 800b6ec:	9200      	str	r2, [sp, #0]
 800b6ee:	221f      	movs	r2, #31
 800b6f0:	6878      	ldr	r0, [r7, #4]
 800b6f2:	f002 f8b4 	bl	800d85e <USBH_BulkSendData>
                              BOT_CBW_LENGTH, MSC_Handle->OutPipe, 1U);

      break;
 800b6f6:	e17e      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>

    case BOT_SEND_CBW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 800b6f8:	693b      	ldr	r3, [r7, #16]
 800b6fa:	795b      	ldrb	r3, [r3, #5]
 800b6fc:	4619      	mov	r1, r3
 800b6fe:	6878      	ldr	r0, [r7, #4]
 800b700:	f021 fd9e 	bl	802d240 <USBH_LL_GetURBState>
 800b704:	4603      	mov	r3, r0
 800b706:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b708:	7d3b      	ldrb	r3, [r7, #20]
 800b70a:	2b01      	cmp	r3, #1
 800b70c:	d118      	bne.n	800b740 <USBH_MSC_BOT_Process+0xdc>
      {
        if (MSC_Handle->hbot.cbw.field.DataTransferLength != 0U)
 800b70e:	693b      	ldr	r3, [r7, #16]
 800b710:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b712:	2b00      	cmp	r3, #0
 800b714:	d00f      	beq.n	800b736 <USBH_MSC_BOT_Process+0xd2>
        {
          /* If there is Data Transfer Stage */
          if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
 800b716:	693b      	ldr	r3, [r7, #16]
 800b718:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
 800b71c:	b25b      	sxtb	r3, r3
 800b71e:	2b00      	cmp	r3, #0
 800b720:	da04      	bge.n	800b72c <USBH_MSC_BOT_Process+0xc8>
          {
            /* Data Direction is IN */
            MSC_Handle->hbot.state = BOT_DATA_IN;
 800b722:	693b      	ldr	r3, [r7, #16]
 800b724:	2203      	movs	r2, #3
 800b726:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800b72a:	e157      	b.n	800b9dc <USBH_MSC_BOT_Process+0x378>
            MSC_Handle->hbot.state = BOT_DATA_OUT;
 800b72c:	693b      	ldr	r3, [r7, #16]
 800b72e:	2205      	movs	r2, #5
 800b730:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b734:	e152      	b.n	800b9dc <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 800b736:	693b      	ldr	r3, [r7, #16]
 800b738:	2207      	movs	r2, #7
 800b73a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b73e:	e14d      	b.n	800b9dc <USBH_MSC_BOT_Process+0x378>
      else if (URB_Status == USBH_URB_NOTREADY)
 800b740:	7d3b      	ldrb	r3, [r7, #20]
 800b742:	2b02      	cmp	r3, #2
 800b744:	d104      	bne.n	800b750 <USBH_MSC_BOT_Process+0xec>
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b746:	693b      	ldr	r3, [r7, #16]
 800b748:	2201      	movs	r2, #1
 800b74a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b74e:	e145      	b.n	800b9dc <USBH_MSC_BOT_Process+0x378>
        if (URB_Status == USBH_URB_STALL)
 800b750:	7d3b      	ldrb	r3, [r7, #20]
 800b752:	2b05      	cmp	r3, #5
 800b754:	f040 8142 	bne.w	800b9dc <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 800b758:	693b      	ldr	r3, [r7, #16]
 800b75a:	220a      	movs	r2, #10
 800b75c:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b760:	e13c      	b.n	800b9dc <USBH_MSC_BOT_Process+0x378>

    case BOT_DATA_IN:
      /* Send first packet */
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 800b762:	693b      	ldr	r3, [r7, #16]
 800b764:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b768:	693b      	ldr	r3, [r7, #16]
 800b76a:	895a      	ldrh	r2, [r3, #10]
 800b76c:	693b      	ldr	r3, [r7, #16]
 800b76e:	791b      	ldrb	r3, [r3, #4]
 800b770:	6878      	ldr	r0, [r7, #4]
 800b772:	f002 f899 	bl	800d8a8 <USBH_BulkReceiveData>
                                 MSC_Handle->InEpSize, MSC_Handle->InPipe);

      MSC_Handle->hbot.state = BOT_DATA_IN_WAIT;
 800b776:	693b      	ldr	r3, [r7, #16]
 800b778:	2204      	movs	r2, #4
 800b77a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

      break;
 800b77e:	e13a      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 800b780:	693b      	ldr	r3, [r7, #16]
 800b782:	791b      	ldrb	r3, [r3, #4]
 800b784:	4619      	mov	r1, r3
 800b786:	6878      	ldr	r0, [r7, #4]
 800b788:	f021 fd5a 	bl	802d240 <USBH_LL_GetURBState>
 800b78c:	4603      	mov	r3, r0
 800b78e:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b790:	7d3b      	ldrb	r3, [r7, #20]
 800b792:	2b01      	cmp	r3, #1
 800b794:	d12d      	bne.n	800b7f2 <USBH_MSC_BOT_Process+0x18e>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
 800b796:	693b      	ldr	r3, [r7, #16]
 800b798:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b79a:	693a      	ldr	r2, [r7, #16]
 800b79c:	8952      	ldrh	r2, [r2, #10]
 800b79e:	4293      	cmp	r3, r2
 800b7a0:	d910      	bls.n	800b7c4 <USBH_MSC_BOT_Process+0x160>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
 800b7a2:	693b      	ldr	r3, [r7, #16]
 800b7a4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b7a8:	693a      	ldr	r2, [r7, #16]
 800b7aa:	8952      	ldrh	r2, [r2, #10]
 800b7ac:	441a      	add	r2, r3
 800b7ae:	693b      	ldr	r3, [r7, #16]
 800b7b0:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;
 800b7b4:	693b      	ldr	r3, [r7, #16]
 800b7b6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b7b8:	693a      	ldr	r2, [r7, #16]
 800b7ba:	8952      	ldrh	r2, [r2, #10]
 800b7bc:	1a9a      	subs	r2, r3, r2
 800b7be:	693b      	ldr	r3, [r7, #16]
 800b7c0:	65da      	str	r2, [r3, #92]	@ 0x5c
 800b7c2:	e002      	b.n	800b7ca <USBH_MSC_BOT_Process+0x166>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 800b7c4:	693b      	ldr	r3, [r7, #16]
 800b7c6:	2200      	movs	r2, #0
 800b7c8:	65da      	str	r2, [r3, #92]	@ 0x5c
        }

        /* More Data To be Received */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 800b7ca:	693b      	ldr	r3, [r7, #16]
 800b7cc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b7ce:	2b00      	cmp	r3, #0
 800b7d0:	d00a      	beq.n	800b7e8 <USBH_MSC_BOT_Process+0x184>
        {
          /* Send next packet */
          (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 800b7d2:	693b      	ldr	r3, [r7, #16]
 800b7d4:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b7d8:	693b      	ldr	r3, [r7, #16]
 800b7da:	895a      	ldrh	r2, [r3, #10]
 800b7dc:	693b      	ldr	r3, [r7, #16]
 800b7de:	791b      	ldrb	r3, [r3, #4]
 800b7e0:	6878      	ldr	r0, [r7, #4]
 800b7e2:	f002 f861 	bl	800d8a8 <USBH_BulkReceiveData>
#endif
      }
      else
      {
      }
      break;
 800b7e6:	e0fb      	b.n	800b9e0 <USBH_MSC_BOT_Process+0x37c>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 800b7e8:	693b      	ldr	r3, [r7, #16]
 800b7ea:	2207      	movs	r2, #7
 800b7ec:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b7f0:	e0f6      	b.n	800b9e0 <USBH_MSC_BOT_Process+0x37c>
      else if (URB_Status == USBH_URB_STALL)
 800b7f2:	7d3b      	ldrb	r3, [r7, #20]
 800b7f4:	2b05      	cmp	r3, #5
 800b7f6:	f040 80f3 	bne.w	800b9e0 <USBH_MSC_BOT_Process+0x37c>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 800b7fa:	693b      	ldr	r3, [r7, #16]
 800b7fc:	2209      	movs	r2, #9
 800b7fe:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b802:	e0ed      	b.n	800b9e0 <USBH_MSC_BOT_Process+0x37c>

    case BOT_DATA_OUT:

      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 800b804:	693b      	ldr	r3, [r7, #16]
 800b806:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b80a:	693b      	ldr	r3, [r7, #16]
 800b80c:	891a      	ldrh	r2, [r3, #8]
 800b80e:	693b      	ldr	r3, [r7, #16]
 800b810:	795b      	ldrb	r3, [r3, #5]
 800b812:	2001      	movs	r0, #1
 800b814:	9000      	str	r0, [sp, #0]
 800b816:	6878      	ldr	r0, [r7, #4]
 800b818:	f002 f821 	bl	800d85e <USBH_BulkSendData>
                              MSC_Handle->OutEpSize, MSC_Handle->OutPipe, 1U);

      MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
 800b81c:	693b      	ldr	r3, [r7, #16]
 800b81e:	2206      	movs	r2, #6
 800b820:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b824:	e0e7      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 800b826:	693b      	ldr	r3, [r7, #16]
 800b828:	795b      	ldrb	r3, [r3, #5]
 800b82a:	4619      	mov	r1, r3
 800b82c:	6878      	ldr	r0, [r7, #4]
 800b82e:	f021 fd07 	bl	802d240 <USBH_LL_GetURBState>
 800b832:	4603      	mov	r3, r0
 800b834:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b836:	7d3b      	ldrb	r3, [r7, #20]
 800b838:	2b01      	cmp	r3, #1
 800b83a:	d12f      	bne.n	800b89c <USBH_MSC_BOT_Process+0x238>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
 800b83c:	693b      	ldr	r3, [r7, #16]
 800b83e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b840:	693a      	ldr	r2, [r7, #16]
 800b842:	8912      	ldrh	r2, [r2, #8]
 800b844:	4293      	cmp	r3, r2
 800b846:	d910      	bls.n	800b86a <USBH_MSC_BOT_Process+0x206>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
 800b848:	693b      	ldr	r3, [r7, #16]
 800b84a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b84e:	693a      	ldr	r2, [r7, #16]
 800b850:	8912      	ldrh	r2, [r2, #8]
 800b852:	441a      	add	r2, r3
 800b854:	693b      	ldr	r3, [r7, #16]
 800b856:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize;
 800b85a:	693b      	ldr	r3, [r7, #16]
 800b85c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b85e:	693a      	ldr	r2, [r7, #16]
 800b860:	8912      	ldrh	r2, [r2, #8]
 800b862:	1a9a      	subs	r2, r3, r2
 800b864:	693b      	ldr	r3, [r7, #16]
 800b866:	65da      	str	r2, [r3, #92]	@ 0x5c
 800b868:	e002      	b.n	800b870 <USBH_MSC_BOT_Process+0x20c>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 800b86a:	693b      	ldr	r3, [r7, #16]
 800b86c:	2200      	movs	r2, #0
 800b86e:	65da      	str	r2, [r3, #92]	@ 0x5c
        }

        /* More Data To be Sent */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 800b870:	693b      	ldr	r3, [r7, #16]
 800b872:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b874:	2b00      	cmp	r3, #0
 800b876:	d00c      	beq.n	800b892 <USBH_MSC_BOT_Process+0x22e>
        {
          (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 800b878:	693b      	ldr	r3, [r7, #16]
 800b87a:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b87e:	693b      	ldr	r3, [r7, #16]
 800b880:	891a      	ldrh	r2, [r3, #8]
 800b882:	693b      	ldr	r3, [r7, #16]
 800b884:	795b      	ldrb	r3, [r3, #5]
 800b886:	2001      	movs	r0, #1
 800b888:	9000      	str	r0, [sp, #0]
 800b88a:	6878      	ldr	r0, [r7, #4]
 800b88c:	f001 ffe7 	bl	800d85e <USBH_BulkSendData>
#endif
      }
      else
      {
      }
      break;
 800b890:	e0a8      	b.n	800b9e4 <USBH_MSC_BOT_Process+0x380>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 800b892:	693b      	ldr	r3, [r7, #16]
 800b894:	2207      	movs	r2, #7
 800b896:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b89a:	e0a3      	b.n	800b9e4 <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_NOTREADY)
 800b89c:	7d3b      	ldrb	r3, [r7, #20]
 800b89e:	2b02      	cmp	r3, #2
 800b8a0:	d104      	bne.n	800b8ac <USBH_MSC_BOT_Process+0x248>
        MSC_Handle->hbot.state  = BOT_DATA_OUT;
 800b8a2:	693b      	ldr	r3, [r7, #16]
 800b8a4:	2205      	movs	r2, #5
 800b8a6:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b8aa:	e09b      	b.n	800b9e4 <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_STALL)
 800b8ac:	7d3b      	ldrb	r3, [r7, #20]
 800b8ae:	2b05      	cmp	r3, #5
 800b8b0:	f040 8098 	bne.w	800b9e4 <USBH_MSC_BOT_Process+0x380>
        MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 800b8b4:	693b      	ldr	r3, [r7, #16]
 800b8b6:	220a      	movs	r2, #10
 800b8b8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b8bc:	e092      	b.n	800b9e4 <USBH_MSC_BOT_Process+0x380>

    case BOT_RECEIVE_CSW:

      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.csw.data,
 800b8be:	693b      	ldr	r3, [r7, #16]
 800b8c0:	f103 0178 	add.w	r1, r3, #120	@ 0x78
 800b8c4:	693b      	ldr	r3, [r7, #16]
 800b8c6:	791b      	ldrb	r3, [r3, #4]
 800b8c8:	220d      	movs	r2, #13
 800b8ca:	6878      	ldr	r0, [r7, #4]
 800b8cc:	f001 ffec 	bl	800d8a8 <USBH_BulkReceiveData>
                                 BOT_CSW_LENGTH, MSC_Handle->InPipe);

      MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
 800b8d0:	693b      	ldr	r3, [r7, #16]
 800b8d2:	2208      	movs	r2, #8
 800b8d4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b8d8:	e08d      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>

    case BOT_RECEIVE_CSW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 800b8da:	693b      	ldr	r3, [r7, #16]
 800b8dc:	791b      	ldrb	r3, [r3, #4]
 800b8de:	4619      	mov	r1, r3
 800b8e0:	6878      	ldr	r0, [r7, #4]
 800b8e2:	f021 fcad 	bl	802d240 <USBH_LL_GetURBState>
 800b8e6:	4603      	mov	r3, r0
 800b8e8:	753b      	strb	r3, [r7, #20]

      /* Decode CSW */
      if (URB_Status == USBH_URB_DONE)
 800b8ea:	7d3b      	ldrb	r3, [r7, #20]
 800b8ec:	2b01      	cmp	r3, #1
 800b8ee:	d115      	bne.n	800b91c <USBH_MSC_BOT_Process+0x2b8>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b8f0:	693b      	ldr	r3, [r7, #16]
 800b8f2:	2201      	movs	r2, #1
 800b8f4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 800b8f8:	693b      	ldr	r3, [r7, #16]
 800b8fa:	2201      	movs	r2, #1
 800b8fc:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
        CSW_Status = USBH_MSC_DecodeCSW(phost);
 800b900:	6878      	ldr	r0, [r7, #4]
 800b902:	f000 f8a9 	bl	800ba58 <USBH_MSC_DecodeCSW>
 800b906:	4603      	mov	r3, r0
 800b908:	757b      	strb	r3, [r7, #21]

        if (CSW_Status == BOT_CSW_CMD_PASSED)
 800b90a:	7d7b      	ldrb	r3, [r7, #21]
 800b90c:	2b00      	cmp	r3, #0
 800b90e:	d102      	bne.n	800b916 <USBH_MSC_BOT_Process+0x2b2>
        {
          status = USBH_OK;
 800b910:	2300      	movs	r3, #0
 800b912:	75fb      	strb	r3, [r7, #23]
#endif
      }
      else
      {
      }
      break;
 800b914:	e068      	b.n	800b9e8 <USBH_MSC_BOT_Process+0x384>
          status = USBH_FAIL;
 800b916:	2302      	movs	r3, #2
 800b918:	75fb      	strb	r3, [r7, #23]
      break;
 800b91a:	e065      	b.n	800b9e8 <USBH_MSC_BOT_Process+0x384>
      else if (URB_Status == USBH_URB_STALL)
 800b91c:	7d3b      	ldrb	r3, [r7, #20]
 800b91e:	2b05      	cmp	r3, #5
 800b920:	d162      	bne.n	800b9e8 <USBH_MSC_BOT_Process+0x384>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 800b922:	693b      	ldr	r3, [r7, #16]
 800b924:	2209      	movs	r2, #9
 800b926:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b92a:	e05d      	b.n	800b9e8 <USBH_MSC_BOT_Process+0x384>

    case BOT_ERROR_IN:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
 800b92c:	78fb      	ldrb	r3, [r7, #3]
 800b92e:	2200      	movs	r2, #0
 800b930:	4619      	mov	r1, r3
 800b932:	6878      	ldr	r0, [r7, #4]
 800b934:	f000 f864 	bl	800ba00 <USBH_MSC_BOT_Abort>
 800b938:	4603      	mov	r3, r0
 800b93a:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 800b93c:	7dbb      	ldrb	r3, [r7, #22]
 800b93e:	2b00      	cmp	r3, #0
 800b940:	d104      	bne.n	800b94c <USBH_MSC_BOT_Process+0x2e8>
      {
        MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 800b942:	693b      	ldr	r3, [r7, #16]
 800b944:	2207      	movs	r2, #7
 800b946:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
      }
      else
      {
      }
      break;
 800b94a:	e04f      	b.n	800b9ec <USBH_MSC_BOT_Process+0x388>
      else if (error == USBH_UNRECOVERED_ERROR)
 800b94c:	7dbb      	ldrb	r3, [r7, #22]
 800b94e:	2b04      	cmp	r3, #4
 800b950:	d14c      	bne.n	800b9ec <USBH_MSC_BOT_Process+0x388>
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 800b952:	693b      	ldr	r3, [r7, #16]
 800b954:	220b      	movs	r2, #11
 800b956:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b95a:	e047      	b.n	800b9ec <USBH_MSC_BOT_Process+0x388>

    case BOT_ERROR_OUT:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
 800b95c:	78fb      	ldrb	r3, [r7, #3]
 800b95e:	2201      	movs	r2, #1
 800b960:	4619      	mov	r1, r3
 800b962:	6878      	ldr	r0, [r7, #4]
 800b964:	f000 f84c 	bl	800ba00 <USBH_MSC_BOT_Abort>
 800b968:	4603      	mov	r3, r0
 800b96a:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 800b96c:	7dbb      	ldrb	r3, [r7, #22]
 800b96e:	2b00      	cmp	r3, #0
 800b970:	d11d      	bne.n	800b9ae <USBH_MSC_BOT_Process+0x34a>
      {

        toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe);
 800b972:	693b      	ldr	r3, [r7, #16]
 800b974:	795b      	ldrb	r3, [r3, #5]
 800b976:	4619      	mov	r1, r3
 800b978:	6878      	ldr	r0, [r7, #4]
 800b97a:	f021 fcbe 	bl	802d2fa <USBH_LL_GetToggle>
 800b97e:	4603      	mov	r3, r0
 800b980:	73fb      	strb	r3, [r7, #15]
        (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1U - toggle);
 800b982:	693b      	ldr	r3, [r7, #16]
 800b984:	7959      	ldrb	r1, [r3, #5]
 800b986:	7bfb      	ldrb	r3, [r7, #15]
 800b988:	f1c3 0301 	rsb	r3, r3, #1
 800b98c:	b2db      	uxtb	r3, r3
 800b98e:	461a      	mov	r2, r3
 800b990:	6878      	ldr	r0, [r7, #4]
 800b992:	f021 fc7f 	bl	802d294 <USBH_LL_SetToggle>
        (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 800b996:	693b      	ldr	r3, [r7, #16]
 800b998:	791b      	ldrb	r3, [r3, #4]
 800b99a:	2200      	movs	r2, #0
 800b99c:	4619      	mov	r1, r3
 800b99e:	6878      	ldr	r0, [r7, #4]
 800b9a0:	f021 fc78 	bl	802d294 <USBH_LL_SetToggle>
        MSC_Handle->hbot.state = BOT_ERROR_IN;
 800b9a4:	693b      	ldr	r3, [r7, #16]
 800b9a6:	2209      	movs	r2, #9
 800b9a8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        if (error == USBH_UNRECOVERED_ERROR)
        {
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
        }
      }
      break;
 800b9ac:	e020      	b.n	800b9f0 <USBH_MSC_BOT_Process+0x38c>
        if (error == USBH_UNRECOVERED_ERROR)
 800b9ae:	7dbb      	ldrb	r3, [r7, #22]
 800b9b0:	2b04      	cmp	r3, #4
 800b9b2:	d11d      	bne.n	800b9f0 <USBH_MSC_BOT_Process+0x38c>
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 800b9b4:	693b      	ldr	r3, [r7, #16]
 800b9b6:	220b      	movs	r2, #11
 800b9b8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b9bc:	e018      	b.n	800b9f0 <USBH_MSC_BOT_Process+0x38c>


    case BOT_UNRECOVERED_ERROR:
      status = USBH_MSC_BOT_REQ_Reset(phost);
 800b9be:	6878      	ldr	r0, [r7, #4]
 800b9c0:	f7ff fdf2 	bl	800b5a8 <USBH_MSC_BOT_REQ_Reset>
 800b9c4:	4603      	mov	r3, r0
 800b9c6:	75fb      	strb	r3, [r7, #23]
      if (status == USBH_OK)
 800b9c8:	7dfb      	ldrb	r3, [r7, #23]
 800b9ca:	2b00      	cmp	r3, #0
 800b9cc:	d112      	bne.n	800b9f4 <USBH_MSC_BOT_Process+0x390>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b9ce:	693b      	ldr	r3, [r7, #16]
 800b9d0:	2201      	movs	r2, #1
 800b9d2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      }
      break;
 800b9d6:	e00d      	b.n	800b9f4 <USBH_MSC_BOT_Process+0x390>

    default:
      break;
 800b9d8:	bf00      	nop
 800b9da:	e00c      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9dc:	bf00      	nop
 800b9de:	e00a      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9e0:	bf00      	nop
 800b9e2:	e008      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9e4:	bf00      	nop
 800b9e6:	e006      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9e8:	bf00      	nop
 800b9ea:	e004      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9ec:	bf00      	nop
 800b9ee:	e002      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9f0:	bf00      	nop
 800b9f2:	e000      	b.n	800b9f6 <USBH_MSC_BOT_Process+0x392>
      break;
 800b9f4:	bf00      	nop
  }
  return status;
 800b9f6:	7dfb      	ldrb	r3, [r7, #23]
}
 800b9f8:	4618      	mov	r0, r3
 800b9fa:	3718      	adds	r7, #24
 800b9fc:	46bd      	mov	sp, r7
 800b9fe:	bd80      	pop	{r7, pc}

0800ba00 <USBH_MSC_BOT_Abort>:
  * @param  lun: Logical Unit Number
  * @param  dir: direction (0: out / 1 : in)
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
{
 800ba00:	b580      	push	{r7, lr}
 800ba02:	b084      	sub	sp, #16
 800ba04:	af00      	add	r7, sp, #0
 800ba06:	6078      	str	r0, [r7, #4]
 800ba08:	460b      	mov	r3, r1
 800ba0a:	70fb      	strb	r3, [r7, #3]
 800ba0c:	4613      	mov	r3, r2
 800ba0e:	70bb      	strb	r3, [r7, #2]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(lun);

  USBH_StatusTypeDef status = USBH_FAIL;
 800ba10:	2302      	movs	r3, #2
 800ba12:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800ba14:	687b      	ldr	r3, [r7, #4]
 800ba16:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800ba1a:	69db      	ldr	r3, [r3, #28]
 800ba1c:	60bb      	str	r3, [r7, #8]

  switch (dir)
 800ba1e:	78bb      	ldrb	r3, [r7, #2]
 800ba20:	2b00      	cmp	r3, #0
 800ba22:	d002      	beq.n	800ba2a <USBH_MSC_BOT_Abort+0x2a>
 800ba24:	2b01      	cmp	r3, #1
 800ba26:	d009      	beq.n	800ba3c <USBH_MSC_BOT_Abort+0x3c>
      /*send ClrFeature on Bulk OUT endpoint */
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
      break;

    default:
      break;
 800ba28:	e011      	b.n	800ba4e <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->InEp);
 800ba2a:	68bb      	ldr	r3, [r7, #8]
 800ba2c:	79db      	ldrb	r3, [r3, #7]
 800ba2e:	4619      	mov	r1, r3
 800ba30:	6878      	ldr	r0, [r7, #4]
 800ba32:	f001 f9d1 	bl	800cdd8 <USBH_ClrFeature>
 800ba36:	4603      	mov	r3, r0
 800ba38:	73fb      	strb	r3, [r7, #15]
      break;
 800ba3a:	e008      	b.n	800ba4e <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
 800ba3c:	68bb      	ldr	r3, [r7, #8]
 800ba3e:	799b      	ldrb	r3, [r3, #6]
 800ba40:	4619      	mov	r1, r3
 800ba42:	6878      	ldr	r0, [r7, #4]
 800ba44:	f001 f9c8 	bl	800cdd8 <USBH_ClrFeature>
 800ba48:	4603      	mov	r3, r0
 800ba4a:	73fb      	strb	r3, [r7, #15]
      break;
 800ba4c:	bf00      	nop
  }
  return status;
 800ba4e:	7bfb      	ldrb	r3, [r7, #15]
}
 800ba50:	4618      	mov	r0, r3
 800ba52:	3710      	adds	r7, #16
 800ba54:	46bd      	mov	sp, r7
 800ba56:	bd80      	pop	{r7, pc}

0800ba58 <USBH_MSC_DecodeCSW>:
  *     2. the CSW is 13 (Dh) bytes in length,
  *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
  */

static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
{
 800ba58:	b580      	push	{r7, lr}
 800ba5a:	b084      	sub	sp, #16
 800ba5c:	af00      	add	r7, sp, #0
 800ba5e:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800ba60:	687b      	ldr	r3, [r7, #4]
 800ba62:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800ba66:	69db      	ldr	r3, [r3, #28]
 800ba68:	60bb      	str	r3, [r7, #8]
  BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
 800ba6a:	2301      	movs	r3, #1
 800ba6c:	73fb      	strb	r3, [r7, #15]

  /*Checking if the transfer length is different than 13*/
  if (USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
 800ba6e:	68bb      	ldr	r3, [r7, #8]
 800ba70:	791b      	ldrb	r3, [r3, #4]
 800ba72:	4619      	mov	r1, r3
 800ba74:	6878      	ldr	r0, [r7, #4]
 800ba76:	f021 fb51 	bl	802d11c <USBH_LL_GetLastXferSize>
 800ba7a:	4603      	mov	r3, r0
 800ba7c:	2b0d      	cmp	r3, #13
 800ba7e:	d002      	beq.n	800ba86 <USBH_MSC_DecodeCSW+0x2e>
    Device intends to transfer no data)
    (11) Ho > Do  (Host expects to send data to the device,
    Device intends to receive data from the host)*/


    status = BOT_CSW_PHASE_ERROR;
 800ba80:	2302      	movs	r3, #2
 800ba82:	73fb      	strb	r3, [r7, #15]
 800ba84:	e024      	b.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
  else
  {
    /* CSW length is Correct */

    /* Check validity of the CSW Signature and CSWStatus */
    if (MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
 800ba86:	68bb      	ldr	r3, [r7, #8]
 800ba88:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800ba8a:	4a14      	ldr	r2, [pc, #80]	@ (800badc <USBH_MSC_DecodeCSW+0x84>)
 800ba8c:	4293      	cmp	r3, r2
 800ba8e:	d11d      	bne.n	800bacc <USBH_MSC_DecodeCSW+0x74>
    {
      /* Check Condition 1. dCSWSignature is equal to 53425355h */

      if (MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
 800ba90:	68bb      	ldr	r3, [r7, #8]
 800ba92:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800ba94:	68bb      	ldr	r3, [r7, #8]
 800ba96:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800ba98:	429a      	cmp	r2, r3
 800ba9a:	d119      	bne.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
      {
        /* Check Condition 3. dCSWTag matches the dCBWTag from the
        corresponding CBW */

        if (MSC_Handle->hbot.csw.field.Status == 0U)
 800ba9c:	68bb      	ldr	r3, [r7, #8]
 800ba9e:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800baa2:	2b00      	cmp	r3, #0
 800baa4:	d102      	bne.n	800baac <USBH_MSC_DecodeCSW+0x54>
          (12) Ho = Do (Host expects to send data to the device,
          Device intends to receive data from the host)

          */

          status = BOT_CSW_CMD_PASSED;
 800baa6:	2300      	movs	r3, #0
 800baa8:	73fb      	strb	r3, [r7, #15]
 800baaa:	e011      	b.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
        }
        else if (MSC_Handle->hbot.csw.field.Status == 1U)
 800baac:	68bb      	ldr	r3, [r7, #8]
 800baae:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800bab2:	2b01      	cmp	r3, #1
 800bab4:	d102      	bne.n	800babc <USBH_MSC_DecodeCSW+0x64>
        {
          status = BOT_CSW_CMD_FAILED;
 800bab6:	2301      	movs	r3, #1
 800bab8:	73fb      	strb	r3, [r7, #15]
 800baba:	e009      	b.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
        }

        else if (MSC_Handle->hbot.csw.field.Status == 2U)
 800babc:	68bb      	ldr	r3, [r7, #8]
 800babe:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800bac2:	2b02      	cmp	r3, #2
 800bac4:	d104      	bne.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
          Di Device intends to send data to the host)
          (13) Ho < Do (Host expects to send data to the device,
          Device intends to receive data from the host)
          */

          status = BOT_CSW_PHASE_ERROR;
 800bac6:	2302      	movs	r3, #2
 800bac8:	73fb      	strb	r3, [r7, #15]
 800baca:	e001      	b.n	800bad0 <USBH_MSC_DecodeCSW+0x78>
    else
    {
      /* If the CSW Signature is not valid, We sall return the Phase Error to
      Upper Layers for Reset Recovery */

      status = BOT_CSW_PHASE_ERROR;
 800bacc:	2302      	movs	r3, #2
 800bace:	73fb      	strb	r3, [r7, #15]
    }
  } /* CSW Length Check*/

  return status;
 800bad0:	7bfb      	ldrb	r3, [r7, #15]
}
 800bad2:	4618      	mov	r0, r3
 800bad4:	3710      	adds	r7, #16
 800bad6:	46bd      	mov	sp, r7
 800bad8:	bd80      	pop	{r7, pc}
 800bada:	bf00      	nop
 800badc:	53425355 	.word	0x53425355

0800bae0 <USBH_MSC_SCSI_TestUnitReady>:
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady(USBH_HandleTypeDef *phost,
                                               uint8_t lun)
{
 800bae0:	b580      	push	{r7, lr}
 800bae2:	b084      	sub	sp, #16
 800bae4:	af00      	add	r7, sp, #0
 800bae6:	6078      	str	r0, [r7, #4]
 800bae8:	460b      	mov	r3, r1
 800baea:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800baec:	2302      	movs	r3, #2
 800baee:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800baf0:	687b      	ldr	r3, [r7, #4]
 800baf2:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800baf6:	69db      	ldr	r3, [r3, #28]
 800baf8:	60bb      	str	r3, [r7, #8]

  switch (MSC_Handle->hbot.cmd_state)
 800bafa:	68bb      	ldr	r3, [r7, #8]
 800bafc:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bb00:	2b01      	cmp	r3, #1
 800bb02:	d002      	beq.n	800bb0a <USBH_MSC_SCSI_TestUnitReady+0x2a>
 800bb04:	2b02      	cmp	r3, #2
 800bb06:	d021      	beq.n	800bb4c <USBH_MSC_SCSI_TestUnitReady+0x6c>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800bb08:	e028      	b.n	800bb5c <USBH_MSC_SCSI_TestUnitReady+0x7c>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;
 800bb0a:	68bb      	ldr	r3, [r7, #8]
 800bb0c:	2200      	movs	r2, #0
 800bb0e:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 800bb10:	68bb      	ldr	r3, [r7, #8]
 800bb12:	2200      	movs	r2, #0
 800bb14:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bb18:	68bb      	ldr	r3, [r7, #8]
 800bb1a:	220a      	movs	r2, #10
 800bb1c:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bb20:	68bb      	ldr	r3, [r7, #8]
 800bb22:	3363      	adds	r3, #99	@ 0x63
 800bb24:	2210      	movs	r2, #16
 800bb26:	2100      	movs	r1, #0
 800bb28:	4618      	mov	r0, r3
 800bb2a:	f021 fe62 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY;
 800bb2e:	68bb      	ldr	r3, [r7, #8]
 800bb30:	2200      	movs	r2, #0
 800bb32:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bb36:	68bb      	ldr	r3, [r7, #8]
 800bb38:	2201      	movs	r2, #1
 800bb3a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bb3e:	68bb      	ldr	r3, [r7, #8]
 800bb40:	2202      	movs	r2, #2
 800bb42:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      error = USBH_BUSY;
 800bb46:	2301      	movs	r3, #1
 800bb48:	73fb      	strb	r3, [r7, #15]
      break;
 800bb4a:	e007      	b.n	800bb5c <USBH_MSC_SCSI_TestUnitReady+0x7c>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bb4c:	78fb      	ldrb	r3, [r7, #3]
 800bb4e:	4619      	mov	r1, r3
 800bb50:	6878      	ldr	r0, [r7, #4]
 800bb52:	f7ff fd87 	bl	800b664 <USBH_MSC_BOT_Process>
 800bb56:	4603      	mov	r3, r0
 800bb58:	73fb      	strb	r3, [r7, #15]
      break;
 800bb5a:	bf00      	nop
  }

  return error;
 800bb5c:	7bfb      	ldrb	r3, [r7, #15]
}
 800bb5e:	4618      	mov	r0, r3
 800bb60:	3710      	adds	r7, #16
 800bb62:	46bd      	mov	sp, r7
 800bb64:	bd80      	pop	{r7, pc}

0800bb66 <USBH_MSC_SCSI_ReadCapacity>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_CapacityTypeDef *capacity)
{
 800bb66:	b580      	push	{r7, lr}
 800bb68:	b086      	sub	sp, #24
 800bb6a:	af00      	add	r7, sp, #0
 800bb6c:	60f8      	str	r0, [r7, #12]
 800bb6e:	460b      	mov	r3, r1
 800bb70:	607a      	str	r2, [r7, #4]
 800bb72:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_BUSY;
 800bb74:	2301      	movs	r3, #1
 800bb76:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bb78:	68fb      	ldr	r3, [r7, #12]
 800bb7a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bb7e:	69db      	ldr	r3, [r3, #28]
 800bb80:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bb82:	693b      	ldr	r3, [r7, #16]
 800bb84:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bb88:	2b01      	cmp	r3, #1
 800bb8a:	d002      	beq.n	800bb92 <USBH_MSC_SCSI_ReadCapacity+0x2c>
 800bb8c:	2b02      	cmp	r3, #2
 800bb8e:	d027      	beq.n	800bbe0 <USBH_MSC_SCSI_ReadCapacity+0x7a>
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
      }
      break;

    default:
      break;
 800bb90:	e05e      	b.n	800bc50 <USBH_MSC_SCSI_ReadCapacity+0xea>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
 800bb92:	693b      	ldr	r3, [r7, #16]
 800bb94:	2208      	movs	r2, #8
 800bb96:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bb98:	693b      	ldr	r3, [r7, #16]
 800bb9a:	2280      	movs	r2, #128	@ 0x80
 800bb9c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bba0:	693b      	ldr	r3, [r7, #16]
 800bba2:	220a      	movs	r2, #10
 800bba4:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bba8:	693b      	ldr	r3, [r7, #16]
 800bbaa:	3363      	adds	r3, #99	@ 0x63
 800bbac:	2210      	movs	r2, #16
 800bbae:	2100      	movs	r1, #0
 800bbb0:	4618      	mov	r0, r3
 800bbb2:	f021 fe1e 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10;
 800bbb6:	693b      	ldr	r3, [r7, #16]
 800bbb8:	2225      	movs	r2, #37	@ 0x25
 800bbba:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bbbe:	693b      	ldr	r3, [r7, #16]
 800bbc0:	2201      	movs	r2, #1
 800bbc2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bbc6:	693b      	ldr	r3, [r7, #16]
 800bbc8:	2202      	movs	r2, #2
 800bbca:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800bbce:	693b      	ldr	r3, [r7, #16]
 800bbd0:	f103 0210 	add.w	r2, r3, #16
 800bbd4:	693b      	ldr	r3, [r7, #16]
 800bbd6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bbda:	2301      	movs	r3, #1
 800bbdc:	75fb      	strb	r3, [r7, #23]
      break;
 800bbde:	e037      	b.n	800bc50 <USBH_MSC_SCSI_ReadCapacity+0xea>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bbe0:	7afb      	ldrb	r3, [r7, #11]
 800bbe2:	4619      	mov	r1, r3
 800bbe4:	68f8      	ldr	r0, [r7, #12]
 800bbe6:	f7ff fd3d 	bl	800b664 <USBH_MSC_BOT_Process>
 800bbea:	4603      	mov	r3, r0
 800bbec:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800bbee:	7dfb      	ldrb	r3, [r7, #23]
 800bbf0:	2b00      	cmp	r3, #0
 800bbf2:	d12c      	bne.n	800bc4e <USBH_MSC_SCSI_ReadCapacity+0xe8>
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800bbf4:	693b      	ldr	r3, [r7, #16]
 800bbf6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bbfa:	3303      	adds	r3, #3
 800bbfc:	781b      	ldrb	r3, [r3, #0]
 800bbfe:	461a      	mov	r2, r3
 800bc00:	693b      	ldr	r3, [r7, #16]
 800bc02:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc06:	3302      	adds	r3, #2
 800bc08:	781b      	ldrb	r3, [r3, #0]
 800bc0a:	021b      	lsls	r3, r3, #8
 800bc0c:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 800bc0e:	693b      	ldr	r3, [r7, #16]
 800bc10:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc14:	3301      	adds	r3, #1
 800bc16:	781b      	ldrb	r3, [r3, #0]
 800bc18:	041b      	lsls	r3, r3, #16
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800bc1a:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 800bc1c:	693b      	ldr	r3, [r7, #16]
 800bc1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc22:	781b      	ldrb	r3, [r3, #0]
 800bc24:	061b      	lsls	r3, r3, #24
 800bc26:	431a      	orrs	r2, r3
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800bc28:	687b      	ldr	r3, [r7, #4]
 800bc2a:	601a      	str	r2, [r3, #0]
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
 800bc2c:	693b      	ldr	r3, [r7, #16]
 800bc2e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc32:	3307      	adds	r3, #7
 800bc34:	781b      	ldrb	r3, [r3, #0]
 800bc36:	461a      	mov	r2, r3
 800bc38:	693b      	ldr	r3, [r7, #16]
 800bc3a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc3e:	3306      	adds	r3, #6
 800bc40:	781b      	ldrb	r3, [r3, #0]
 800bc42:	021b      	lsls	r3, r3, #8
 800bc44:	b29b      	uxth	r3, r3
 800bc46:	4313      	orrs	r3, r2
 800bc48:	b29a      	uxth	r2, r3
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	809a      	strh	r2, [r3, #4]
      break;
 800bc4e:	bf00      	nop
  }

  return error;
 800bc50:	7dfb      	ldrb	r3, [r7, #23]
}
 800bc52:	4618      	mov	r0, r3
 800bc54:	3718      	adds	r7, #24
 800bc56:	46bd      	mov	sp, r7
 800bc58:	bd80      	pop	{r7, pc}

0800bc5a <USBH_MSC_SCSI_Inquiry>:
  * @param  capacity: pointer to the inquiry structure
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry(USBH_HandleTypeDef *phost, uint8_t lun,
                                         SCSI_StdInquiryDataTypeDef *inquiry)
{
 800bc5a:	b580      	push	{r7, lr}
 800bc5c:	b086      	sub	sp, #24
 800bc5e:	af00      	add	r7, sp, #0
 800bc60:	60f8      	str	r0, [r7, #12]
 800bc62:	460b      	mov	r3, r1
 800bc64:	607a      	str	r2, [r7, #4]
 800bc66:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef error = USBH_FAIL;
 800bc68:	2302      	movs	r3, #2
 800bc6a:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bc6c:	68fb      	ldr	r3, [r7, #12]
 800bc6e:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bc72:	69db      	ldr	r3, [r3, #28]
 800bc74:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bc76:	693b      	ldr	r3, [r7, #16]
 800bc78:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bc7c:	2b01      	cmp	r3, #1
 800bc7e:	d002      	beq.n	800bc86 <USBH_MSC_SCSI_Inquiry+0x2c>
 800bc80:	2b02      	cmp	r3, #2
 800bc82:	d03d      	beq.n	800bd00 <USBH_MSC_SCSI_Inquiry+0xa6>
        (void)USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
      }
      break;

    default:
      break;
 800bc84:	e089      	b.n	800bd9a <USBH_MSC_SCSI_Inquiry+0x140>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
 800bc86:	693b      	ldr	r3, [r7, #16]
 800bc88:	2224      	movs	r2, #36	@ 0x24
 800bc8a:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bc8c:	693b      	ldr	r3, [r7, #16]
 800bc8e:	2280      	movs	r2, #128	@ 0x80
 800bc90:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bc94:	693b      	ldr	r3, [r7, #16]
 800bc96:	220a      	movs	r2, #10
 800bc98:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
 800bc9c:	693b      	ldr	r3, [r7, #16]
 800bc9e:	3363      	adds	r3, #99	@ 0x63
 800bca0:	220a      	movs	r2, #10
 800bca2:	2100      	movs	r1, #0
 800bca4:	4618      	mov	r0, r3
 800bca6:	f021 fda4 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY;
 800bcaa:	693b      	ldr	r3, [r7, #16]
 800bcac:	2212      	movs	r2, #18
 800bcae:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 800bcb2:	7afb      	ldrb	r3, [r7, #11]
 800bcb4:	015b      	lsls	r3, r3, #5
 800bcb6:	b2da      	uxtb	r2, r3
 800bcb8:	693b      	ldr	r3, [r7, #16]
 800bcba:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 800bcbe:	693b      	ldr	r3, [r7, #16]
 800bcc0:	2200      	movs	r2, #0
 800bcc2:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 800bcc6:	693b      	ldr	r3, [r7, #16]
 800bcc8:	2200      	movs	r2, #0
 800bcca:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = 0x24U;
 800bcce:	693b      	ldr	r3, [r7, #16]
 800bcd0:	2224      	movs	r2, #36	@ 0x24
 800bcd2:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 800bcd6:	693b      	ldr	r3, [r7, #16]
 800bcd8:	2200      	movs	r2, #0
 800bcda:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bcde:	693b      	ldr	r3, [r7, #16]
 800bce0:	2201      	movs	r2, #1
 800bce2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bce6:	693b      	ldr	r3, [r7, #16]
 800bce8:	2202      	movs	r2, #2
 800bcea:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800bcee:	693b      	ldr	r3, [r7, #16]
 800bcf0:	f103 0210 	add.w	r2, r3, #16
 800bcf4:	693b      	ldr	r3, [r7, #16]
 800bcf6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bcfa:	2301      	movs	r3, #1
 800bcfc:	75fb      	strb	r3, [r7, #23]
      break;
 800bcfe:	e04c      	b.n	800bd9a <USBH_MSC_SCSI_Inquiry+0x140>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bd00:	7afb      	ldrb	r3, [r7, #11]
 800bd02:	4619      	mov	r1, r3
 800bd04:	68f8      	ldr	r0, [r7, #12]
 800bd06:	f7ff fcad 	bl	800b664 <USBH_MSC_BOT_Process>
 800bd0a:	4603      	mov	r3, r0
 800bd0c:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800bd0e:	7dfb      	ldrb	r3, [r7, #23]
 800bd10:	2b00      	cmp	r3, #0
 800bd12:	d141      	bne.n	800bd98 <USBH_MSC_SCSI_Inquiry+0x13e>
        (void)USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
 800bd14:	2222      	movs	r2, #34	@ 0x22
 800bd16:	2100      	movs	r1, #0
 800bd18:	6878      	ldr	r0, [r7, #4]
 800bd1a:	f021 fd6a 	bl	802d7f2 <memset>
        inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1FU;
 800bd1e:	693b      	ldr	r3, [r7, #16]
 800bd20:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bd24:	781b      	ldrb	r3, [r3, #0]
 800bd26:	f003 031f 	and.w	r3, r3, #31
 800bd2a:	b2da      	uxtb	r2, r3
 800bd2c:	687b      	ldr	r3, [r7, #4]
 800bd2e:	705a      	strb	r2, [r3, #1]
        inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5U;
 800bd30:	693b      	ldr	r3, [r7, #16]
 800bd32:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bd36:	781b      	ldrb	r3, [r3, #0]
 800bd38:	095b      	lsrs	r3, r3, #5
 800bd3a:	b2da      	uxtb	r2, r3
 800bd3c:	687b      	ldr	r3, [r7, #4]
 800bd3e:	701a      	strb	r2, [r3, #0]
        if (((uint32_t)MSC_Handle->hbot.pbuf[1] & 0x80U) == 0x80U)
 800bd40:	693b      	ldr	r3, [r7, #16]
 800bd42:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bd46:	3301      	adds	r3, #1
 800bd48:	781b      	ldrb	r3, [r3, #0]
 800bd4a:	b25b      	sxtb	r3, r3
 800bd4c:	2b00      	cmp	r3, #0
 800bd4e:	da03      	bge.n	800bd58 <USBH_MSC_SCSI_Inquiry+0xfe>
          inquiry->RemovableMedia = 1U;
 800bd50:	687b      	ldr	r3, [r7, #4]
 800bd52:	2201      	movs	r2, #1
 800bd54:	709a      	strb	r2, [r3, #2]
 800bd56:	e002      	b.n	800bd5e <USBH_MSC_SCSI_Inquiry+0x104>
          inquiry->RemovableMedia = 0U;
 800bd58:	687b      	ldr	r3, [r7, #4]
 800bd5a:	2200      	movs	r2, #0
 800bd5c:	709a      	strb	r2, [r3, #2]
        (void)USBH_memcpy(inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8U);
 800bd5e:	687b      	ldr	r3, [r7, #4]
 800bd60:	1cd8      	adds	r0, r3, #3
 800bd62:	693b      	ldr	r3, [r7, #16]
 800bd64:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bd68:	3308      	adds	r3, #8
 800bd6a:	2208      	movs	r2, #8
 800bd6c:	4619      	mov	r1, r3
 800bd6e:	f021 fdcc 	bl	802d90a <memcpy>
        (void)USBH_memcpy(inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16U);
 800bd72:	687b      	ldr	r3, [r7, #4]
 800bd74:	f103 000c 	add.w	r0, r3, #12
 800bd78:	693b      	ldr	r3, [r7, #16]
 800bd7a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bd7e:	3310      	adds	r3, #16
 800bd80:	2210      	movs	r2, #16
 800bd82:	4619      	mov	r1, r3
 800bd84:	f021 fdc1 	bl	802d90a <memcpy>
        (void)USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
 800bd88:	687b      	ldr	r3, [r7, #4]
 800bd8a:	331d      	adds	r3, #29
 800bd8c:	693a      	ldr	r2, [r7, #16]
 800bd8e:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
 800bd92:	3220      	adds	r2, #32
 800bd94:	6812      	ldr	r2, [r2, #0]
 800bd96:	601a      	str	r2, [r3, #0]
      break;
 800bd98:	bf00      	nop
  }

  return error;
 800bd9a:	7dfb      	ldrb	r3, [r7, #23]
}
 800bd9c:	4618      	mov	r0, r3
 800bd9e:	3718      	adds	r7, #24
 800bda0:	46bd      	mov	sp, r7
 800bda2:	bd80      	pop	{r7, pc}

0800bda4 <USBH_MSC_SCSI_RequestSense>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_SenseTypeDef *sense_data)
{
 800bda4:	b580      	push	{r7, lr}
 800bda6:	b086      	sub	sp, #24
 800bda8:	af00      	add	r7, sp, #0
 800bdaa:	60f8      	str	r0, [r7, #12]
 800bdac:	460b      	mov	r3, r1
 800bdae:	607a      	str	r2, [r7, #4]
 800bdb0:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bdb2:	2302      	movs	r3, #2
 800bdb4:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bdb6:	68fb      	ldr	r3, [r7, #12]
 800bdb8:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bdbc:	69db      	ldr	r3, [r3, #28]
 800bdbe:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bdc0:	693b      	ldr	r3, [r7, #16]
 800bdc2:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bdc6:	2b01      	cmp	r3, #1
 800bdc8:	d002      	beq.n	800bdd0 <USBH_MSC_SCSI_RequestSense+0x2c>
 800bdca:	2b02      	cmp	r3, #2
 800bdcc:	d03d      	beq.n	800be4a <USBH_MSC_SCSI_RequestSense+0xa6>
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
      }
      break;

    default:
      break;
 800bdce:	e05d      	b.n	800be8c <USBH_MSC_SCSI_RequestSense+0xe8>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
 800bdd0:	693b      	ldr	r3, [r7, #16]
 800bdd2:	220e      	movs	r2, #14
 800bdd4:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bdd6:	693b      	ldr	r3, [r7, #16]
 800bdd8:	2280      	movs	r2, #128	@ 0x80
 800bdda:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bdde:	693b      	ldr	r3, [r7, #16]
 800bde0:	220a      	movs	r2, #10
 800bde2:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bde6:	693b      	ldr	r3, [r7, #16]
 800bde8:	3363      	adds	r3, #99	@ 0x63
 800bdea:	2210      	movs	r2, #16
 800bdec:	2100      	movs	r1, #0
 800bdee:	4618      	mov	r0, r3
 800bdf0:	f021 fcff 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE;
 800bdf4:	693b      	ldr	r3, [r7, #16]
 800bdf6:	2203      	movs	r2, #3
 800bdf8:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 800bdfc:	7afb      	ldrb	r3, [r7, #11]
 800bdfe:	015b      	lsls	r3, r3, #5
 800be00:	b2da      	uxtb	r2, r3
 800be02:	693b      	ldr	r3, [r7, #16]
 800be04:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 800be08:	693b      	ldr	r3, [r7, #16]
 800be0a:	2200      	movs	r2, #0
 800be0c:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 800be10:	693b      	ldr	r3, [r7, #16]
 800be12:	2200      	movs	r2, #0
 800be14:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
 800be18:	693b      	ldr	r3, [r7, #16]
 800be1a:	220e      	movs	r2, #14
 800be1c:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 800be20:	693b      	ldr	r3, [r7, #16]
 800be22:	2200      	movs	r2, #0
 800be24:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800be28:	693b      	ldr	r3, [r7, #16]
 800be2a:	2201      	movs	r2, #1
 800be2c:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800be30:	693b      	ldr	r3, [r7, #16]
 800be32:	2202      	movs	r2, #2
 800be34:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800be38:	693b      	ldr	r3, [r7, #16]
 800be3a:	f103 0210 	add.w	r2, r3, #16
 800be3e:	693b      	ldr	r3, [r7, #16]
 800be40:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800be44:	2301      	movs	r3, #1
 800be46:	75fb      	strb	r3, [r7, #23]
      break;
 800be48:	e020      	b.n	800be8c <USBH_MSC_SCSI_RequestSense+0xe8>
      error = USBH_MSC_BOT_Process(phost, lun);
 800be4a:	7afb      	ldrb	r3, [r7, #11]
 800be4c:	4619      	mov	r1, r3
 800be4e:	68f8      	ldr	r0, [r7, #12]
 800be50:	f7ff fc08 	bl	800b664 <USBH_MSC_BOT_Process>
 800be54:	4603      	mov	r3, r0
 800be56:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800be58:	7dfb      	ldrb	r3, [r7, #23]
 800be5a:	2b00      	cmp	r3, #0
 800be5c:	d115      	bne.n	800be8a <USBH_MSC_SCSI_RequestSense+0xe6>
        sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0FU;
 800be5e:	693b      	ldr	r3, [r7, #16]
 800be60:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800be64:	3302      	adds	r3, #2
 800be66:	781b      	ldrb	r3, [r3, #0]
 800be68:	f003 030f 	and.w	r3, r3, #15
 800be6c:	b2da      	uxtb	r2, r3
 800be6e:	687b      	ldr	r3, [r7, #4]
 800be70:	701a      	strb	r2, [r3, #0]
        sense_data->asc  = MSC_Handle->hbot.pbuf[12];
 800be72:	693b      	ldr	r3, [r7, #16]
 800be74:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800be78:	7b1a      	ldrb	r2, [r3, #12]
 800be7a:	687b      	ldr	r3, [r7, #4]
 800be7c:	705a      	strb	r2, [r3, #1]
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
 800be7e:	693b      	ldr	r3, [r7, #16]
 800be80:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800be84:	7b5a      	ldrb	r2, [r3, #13]
 800be86:	687b      	ldr	r3, [r7, #4]
 800be88:	709a      	strb	r2, [r3, #2]
      break;
 800be8a:	bf00      	nop
  }

  return error;
 800be8c:	7dfb      	ldrb	r3, [r7, #23]
}
 800be8e:	4618      	mov	r0, r3
 800be90:	3718      	adds	r7, #24
 800be92:	46bd      	mov	sp, r7
 800be94:	bd80      	pop	{r7, pc}

0800be96 <USBH_MSC_SCSI_Write>:
USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
                                       uint8_t lun,
                                       uint32_t address,
                                       uint8_t *pbuf,
                                       uint32_t length)
{
 800be96:	b580      	push	{r7, lr}
 800be98:	b086      	sub	sp, #24
 800be9a:	af00      	add	r7, sp, #0
 800be9c:	60f8      	str	r0, [r7, #12]
 800be9e:	607a      	str	r2, [r7, #4]
 800bea0:	603b      	str	r3, [r7, #0]
 800bea2:	460b      	mov	r3, r1
 800bea4:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bea6:	2302      	movs	r3, #2
 800bea8:	75fb      	strb	r3, [r7, #23]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800beaa:	68fb      	ldr	r3, [r7, #12]
 800beac:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800beb0:	69db      	ldr	r3, [r3, #28]
 800beb2:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800beb4:	693b      	ldr	r3, [r7, #16]
 800beb6:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800beba:	2b01      	cmp	r3, #1
 800bebc:	d002      	beq.n	800bec4 <USBH_MSC_SCSI_Write+0x2e>
 800bebe:	2b02      	cmp	r3, #2
 800bec0:	d047      	beq.n	800bf52 <USBH_MSC_SCSI_Write+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800bec2:	e04e      	b.n	800bf62 <USBH_MSC_SCSI_Write+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 800bec4:	693b      	ldr	r3, [r7, #16]
 800bec6:	f8b3 3098 	ldrh.w	r3, [r3, #152]	@ 0x98
 800beca:	461a      	mov	r2, r3
 800becc:	6a3b      	ldr	r3, [r7, #32]
 800bece:	fb03 f202 	mul.w	r2, r3, r2
 800bed2:	693b      	ldr	r3, [r7, #16]
 800bed4:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 800bed6:	693b      	ldr	r3, [r7, #16]
 800bed8:	2200      	movs	r2, #0
 800beda:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bede:	693b      	ldr	r3, [r7, #16]
 800bee0:	220a      	movs	r2, #10
 800bee2:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bee6:	693b      	ldr	r3, [r7, #16]
 800bee8:	3363      	adds	r3, #99	@ 0x63
 800beea:	2210      	movs	r2, #16
 800beec:	2100      	movs	r1, #0
 800beee:	4618      	mov	r0, r3
 800bef0:	f021 fc7f 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10;
 800bef4:	693b      	ldr	r3, [r7, #16]
 800bef6:	222a      	movs	r2, #42	@ 0x2a
 800bef8:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 800befc:	79fa      	ldrb	r2, [r7, #7]
 800befe:	693b      	ldr	r3, [r7, #16]
 800bf00:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 800bf04:	79ba      	ldrb	r2, [r7, #6]
 800bf06:	693b      	ldr	r3, [r7, #16]
 800bf08:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 800bf0c:	797a      	ldrb	r2, [r7, #5]
 800bf0e:	693b      	ldr	r3, [r7, #16]
 800bf10:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 800bf14:	1d3b      	adds	r3, r7, #4
 800bf16:	781a      	ldrb	r2, [r3, #0]
 800bf18:	693b      	ldr	r3, [r7, #16]
 800bf1a:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 800bf1e:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800bf22:	693b      	ldr	r3, [r7, #16]
 800bf24:	f883 206a 	strb.w	r2, [r3, #106]	@ 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]);
 800bf28:	f107 0320 	add.w	r3, r7, #32
 800bf2c:	781a      	ldrb	r2, [r3, #0]
 800bf2e:	693b      	ldr	r3, [r7, #16]
 800bf30:	f883 206b 	strb.w	r2, [r3, #107]	@ 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bf34:	693b      	ldr	r3, [r7, #16]
 800bf36:	2201      	movs	r2, #1
 800bf38:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bf3c:	693b      	ldr	r3, [r7, #16]
 800bf3e:	2202      	movs	r2, #2
 800bf40:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 800bf44:	693b      	ldr	r3, [r7, #16]
 800bf46:	683a      	ldr	r2, [r7, #0]
 800bf48:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bf4c:	2301      	movs	r3, #1
 800bf4e:	75fb      	strb	r3, [r7, #23]
      break;
 800bf50:	e007      	b.n	800bf62 <USBH_MSC_SCSI_Write+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bf52:	7afb      	ldrb	r3, [r7, #11]
 800bf54:	4619      	mov	r1, r3
 800bf56:	68f8      	ldr	r0, [r7, #12]
 800bf58:	f7ff fb84 	bl	800b664 <USBH_MSC_BOT_Process>
 800bf5c:	4603      	mov	r3, r0
 800bf5e:	75fb      	strb	r3, [r7, #23]
      break;
 800bf60:	bf00      	nop
  }

  return error;
 800bf62:	7dfb      	ldrb	r3, [r7, #23]
}
 800bf64:	4618      	mov	r0, r3
 800bf66:	3718      	adds	r7, #24
 800bf68:	46bd      	mov	sp, r7
 800bf6a:	bd80      	pop	{r7, pc}

0800bf6c <USBH_MSC_SCSI_Read>:
USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
                                      uint8_t lun,
                                      uint32_t address,
                                      uint8_t *pbuf,
                                      uint32_t length)
{
 800bf6c:	b580      	push	{r7, lr}
 800bf6e:	b086      	sub	sp, #24
 800bf70:	af00      	add	r7, sp, #0
 800bf72:	60f8      	str	r0, [r7, #12]
 800bf74:	607a      	str	r2, [r7, #4]
 800bf76:	603b      	str	r3, [r7, #0]
 800bf78:	460b      	mov	r3, r1
 800bf7a:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bf7c:	2302      	movs	r3, #2
 800bf7e:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bf80:	68fb      	ldr	r3, [r7, #12]
 800bf82:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bf86:	69db      	ldr	r3, [r3, #28]
 800bf88:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bf8a:	693b      	ldr	r3, [r7, #16]
 800bf8c:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bf90:	2b01      	cmp	r3, #1
 800bf92:	d002      	beq.n	800bf9a <USBH_MSC_SCSI_Read+0x2e>
 800bf94:	2b02      	cmp	r3, #2
 800bf96:	d047      	beq.n	800c028 <USBH_MSC_SCSI_Read+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800bf98:	e04e      	b.n	800c038 <USBH_MSC_SCSI_Read+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 800bf9a:	693b      	ldr	r3, [r7, #16]
 800bf9c:	f8b3 3098 	ldrh.w	r3, [r3, #152]	@ 0x98
 800bfa0:	461a      	mov	r2, r3
 800bfa2:	6a3b      	ldr	r3, [r7, #32]
 800bfa4:	fb03 f202 	mul.w	r2, r3, r2
 800bfa8:	693b      	ldr	r3, [r7, #16]
 800bfaa:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bfac:	693b      	ldr	r3, [r7, #16]
 800bfae:	2280      	movs	r2, #128	@ 0x80
 800bfb0:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bfb4:	693b      	ldr	r3, [r7, #16]
 800bfb6:	220a      	movs	r2, #10
 800bfb8:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bfbc:	693b      	ldr	r3, [r7, #16]
 800bfbe:	3363      	adds	r3, #99	@ 0x63
 800bfc0:	2210      	movs	r2, #16
 800bfc2:	2100      	movs	r1, #0
 800bfc4:	4618      	mov	r0, r3
 800bfc6:	f021 fc14 	bl	802d7f2 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10;
 800bfca:	693b      	ldr	r3, [r7, #16]
 800bfcc:	2228      	movs	r2, #40	@ 0x28
 800bfce:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 800bfd2:	79fa      	ldrb	r2, [r7, #7]
 800bfd4:	693b      	ldr	r3, [r7, #16]
 800bfd6:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 800bfda:	79ba      	ldrb	r2, [r7, #6]
 800bfdc:	693b      	ldr	r3, [r7, #16]
 800bfde:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 800bfe2:	797a      	ldrb	r2, [r7, #5]
 800bfe4:	693b      	ldr	r3, [r7, #16]
 800bfe6:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 800bfea:	1d3b      	adds	r3, r7, #4
 800bfec:	781a      	ldrb	r2, [r3, #0]
 800bfee:	693b      	ldr	r3, [r7, #16]
 800bff0:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 800bff4:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800bff8:	693b      	ldr	r3, [r7, #16]
 800bffa:	f883 206a 	strb.w	r2, [r3, #106]	@ 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]);
 800bffe:	f107 0320 	add.w	r3, r7, #32
 800c002:	781a      	ldrb	r2, [r3, #0]
 800c004:	693b      	ldr	r3, [r7, #16]
 800c006:	f883 206b 	strb.w	r2, [r3, #107]	@ 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800c00a:	693b      	ldr	r3, [r7, #16]
 800c00c:	2201      	movs	r2, #1
 800c00e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800c012:	693b      	ldr	r3, [r7, #16]
 800c014:	2202      	movs	r2, #2
 800c016:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 800c01a:	693b      	ldr	r3, [r7, #16]
 800c01c:	683a      	ldr	r2, [r7, #0]
 800c01e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800c022:	2301      	movs	r3, #1
 800c024:	75fb      	strb	r3, [r7, #23]
      break;
 800c026:	e007      	b.n	800c038 <USBH_MSC_SCSI_Read+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 800c028:	7afb      	ldrb	r3, [r7, #11]
 800c02a:	4619      	mov	r1, r3
 800c02c:	68f8      	ldr	r0, [r7, #12]
 800c02e:	f7ff fb19 	bl	800b664 <USBH_MSC_BOT_Process>
 800c032:	4603      	mov	r3, r0
 800c034:	75fb      	strb	r3, [r7, #23]
      break;
 800c036:	bf00      	nop
  }

  return error;
 800c038:	7dfb      	ldrb	r3, [r7, #23]
}
 800c03a:	4618      	mov	r0, r3
 800c03c:	3718      	adds	r7, #24
 800c03e:	46bd      	mov	sp, r7
 800c040:	bd80      	pop	{r7, pc}

0800c042 <USBH_Init>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Init(USBH_HandleTypeDef *phost,
                             void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                                              uint8_t id), uint8_t id)
{
 800c042:	b580      	push	{r7, lr}
 800c044:	b084      	sub	sp, #16
 800c046:	af00      	add	r7, sp, #0
 800c048:	60f8      	str	r0, [r7, #12]
 800c04a:	60b9      	str	r1, [r7, #8]
 800c04c:	4613      	mov	r3, r2
 800c04e:	71fb      	strb	r3, [r7, #7]
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 800c050:	68fb      	ldr	r3, [r7, #12]
 800c052:	2b00      	cmp	r3, #0
 800c054:	d101      	bne.n	800c05a <USBH_Init+0x18>
  {
    USBH_ErrLog("Invalid Host handle");
    return USBH_FAIL;
 800c056:	2302      	movs	r3, #2
 800c058:	e029      	b.n	800c0ae <USBH_Init+0x6c>
  }

  /* Set DRiver ID */
  phost->id = id;
 800c05a:	68fb      	ldr	r3, [r7, #12]
 800c05c:	79fa      	ldrb	r2, [r7, #7]
 800c05e:	f883 23cc 	strb.w	r2, [r3, #972]	@ 0x3cc

  /* Unlink class*/
  phost->pActiveClass = NULL;
 800c062:	68fb      	ldr	r3, [r7, #12]
 800c064:	2200      	movs	r2, #0
 800c066:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
  phost->ClassNumber = 0U;
 800c06a:	68fb      	ldr	r3, [r7, #12]
 800c06c:	2200      	movs	r2, #0
 800c06e:	f8c3 2380 	str.w	r2, [r3, #896]	@ 0x380

  /* Restore default states and prepare EP0 */
  (void)DeInitStateMachine(phost);
 800c072:	68f8      	ldr	r0, [r7, #12]
 800c074:	f000 f81f 	bl	800c0b6 <DeInitStateMachine>

  /* Restore default Device connection states */
  phost->device.PortEnabled = 0U;
 800c078:	68fb      	ldr	r3, [r7, #12]
 800c07a:	2200      	movs	r2, #0
 800c07c:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323
  phost->device.is_connected = 0U;
 800c080:	68fb      	ldr	r3, [r7, #12]
 800c082:	2200      	movs	r2, #0
 800c084:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.is_disconnected = 0U;
 800c088:	68fb      	ldr	r3, [r7, #12]
 800c08a:	2200      	movs	r2, #0
 800c08c:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_ReEnumerated = 0U;
 800c090:	68fb      	ldr	r3, [r7, #12]
 800c092:	2200      	movs	r2, #0
 800c094:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322

  /* Assign User process */
  if (pUsrFunc != NULL)
 800c098:	68bb      	ldr	r3, [r7, #8]
 800c09a:	2b00      	cmp	r3, #0
 800c09c:	d003      	beq.n	800c0a6 <USBH_Init+0x64>
  {
    phost->pUser = pUsrFunc;
 800c09e:	68fb      	ldr	r3, [r7, #12]
 800c0a0:	68ba      	ldr	r2, [r7, #8]
 800c0a2:	f8c3 23d4 	str.w	r2, [r3, #980]	@ 0x3d4

#endif /* (osCMSIS < 0x20000U) */
#endif /* (USBH_USE_OS == 1U) */

  /* Initialize low level driver */
  (void)USBH_LL_Init(phost);
 800c0a6:	68f8      	ldr	r0, [r7, #12]
 800c0a8:	f020 ff84 	bl	802cfb4 <USBH_LL_Init>

  return USBH_OK;
 800c0ac:	2300      	movs	r3, #0
}
 800c0ae:	4618      	mov	r0, r3
 800c0b0:	3710      	adds	r7, #16
 800c0b2:	46bd      	mov	sp, r7
 800c0b4:	bd80      	pop	{r7, pc}

0800c0b6 <DeInitStateMachine>:
  *         De-Initialize the Host state machine.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
{
 800c0b6:	b580      	push	{r7, lr}
 800c0b8:	b084      	sub	sp, #16
 800c0ba:	af00      	add	r7, sp, #0
 800c0bc:	6078      	str	r0, [r7, #4]
  uint32_t i = 0U;
 800c0be:	2300      	movs	r3, #0
 800c0c0:	60fb      	str	r3, [r7, #12]

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 800c0c2:	2300      	movs	r3, #0
 800c0c4:	60fb      	str	r3, [r7, #12]
 800c0c6:	e009      	b.n	800c0dc <DeInitStateMachine+0x26>
  {
    phost->Pipes[i] = 0U;
 800c0c8:	687a      	ldr	r2, [r7, #4]
 800c0ca:	68fb      	ldr	r3, [r7, #12]
 800c0cc:	33e0      	adds	r3, #224	@ 0xe0
 800c0ce:	009b      	lsls	r3, r3, #2
 800c0d0:	4413      	add	r3, r2
 800c0d2:	2200      	movs	r2, #0
 800c0d4:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 800c0d6:	68fb      	ldr	r3, [r7, #12]
 800c0d8:	3301      	adds	r3, #1
 800c0da:	60fb      	str	r3, [r7, #12]
 800c0dc:	68fb      	ldr	r3, [r7, #12]
 800c0de:	2b0f      	cmp	r3, #15
 800c0e0:	d9f2      	bls.n	800c0c8 <DeInitStateMachine+0x12>
  }

  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 800c0e2:	2300      	movs	r3, #0
 800c0e4:	60fb      	str	r3, [r7, #12]
 800c0e6:	e009      	b.n	800c0fc <DeInitStateMachine+0x46>
  {
    phost->device.Data[i] = 0U;
 800c0e8:	687a      	ldr	r2, [r7, #4]
 800c0ea:	68fb      	ldr	r3, [r7, #12]
 800c0ec:	4413      	add	r3, r2
 800c0ee:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800c0f2:	2200      	movs	r2, #0
 800c0f4:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 800c0f6:	68fb      	ldr	r3, [r7, #12]
 800c0f8:	3301      	adds	r3, #1
 800c0fa:	60fb      	str	r3, [r7, #12]
 800c0fc:	68fb      	ldr	r3, [r7, #12]
 800c0fe:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800c102:	d3f1      	bcc.n	800c0e8 <DeInitStateMachine+0x32>
  }

  phost->gState = HOST_IDLE;
 800c104:	687b      	ldr	r3, [r7, #4]
 800c106:	2200      	movs	r2, #0
 800c108:	701a      	strb	r2, [r3, #0]
  phost->EnumState = ENUM_IDLE;
 800c10a:	687b      	ldr	r3, [r7, #4]
 800c10c:	2200      	movs	r2, #0
 800c10e:	705a      	strb	r2, [r3, #1]
  phost->RequestState = CMD_SEND;
 800c110:	687b      	ldr	r3, [r7, #4]
 800c112:	2201      	movs	r2, #1
 800c114:	709a      	strb	r2, [r3, #2]
  phost->Timer = 0U;
 800c116:	687b      	ldr	r3, [r7, #4]
 800c118:	2200      	movs	r2, #0
 800c11a:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4

  phost->Control.state = CTRL_SETUP;
 800c11e:	687b      	ldr	r3, [r7, #4]
 800c120:	2201      	movs	r2, #1
 800c122:	761a      	strb	r2, [r3, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800c124:	687b      	ldr	r3, [r7, #4]
 800c126:	2240      	movs	r2, #64	@ 0x40
 800c128:	719a      	strb	r2, [r3, #6]
  phost->Control.errorcount = 0U;
 800c12a:	687b      	ldr	r3, [r7, #4]
 800c12c:	2200      	movs	r2, #0
 800c12e:	765a      	strb	r2, [r3, #25]

  phost->device.address = USBH_ADDRESS_DEFAULT;
 800c130:	687b      	ldr	r3, [r7, #4]
 800c132:	2200      	movs	r2, #0
 800c134:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c
  phost->device.speed = (uint8_t)USBH_SPEED_FULL;
 800c138:	687b      	ldr	r3, [r7, #4]
 800c13a:	2201      	movs	r2, #1
 800c13c:	f883 231d 	strb.w	r2, [r3, #797]	@ 0x31d
  phost->device.RstCnt = 0U;
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	2200      	movs	r2, #0
 800c144:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
  phost->device.EnumCnt = 0U;
 800c148:	687b      	ldr	r3, [r7, #4]
 800c14a:	2200      	movs	r2, #0
 800c14c:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e

  /* Reset the device struct */
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	331c      	adds	r3, #28
 800c154:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800c158:	2100      	movs	r1, #0
 800c15a:	4618      	mov	r0, r3
 800c15c:	f021 fb49 	bl	802d7f2 <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800c166:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800c16a:	2100      	movs	r1, #0
 800c16c:	4618      	mov	r0, r3
 800c16e:	f021 fb40 	bl	802d7f2 <memset>
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 800c172:	687b      	ldr	r3, [r7, #4]
 800c174:	f203 3326 	addw	r3, r3, #806	@ 0x326
 800c178:	2212      	movs	r2, #18
 800c17a:	2100      	movs	r1, #0
 800c17c:	4618      	mov	r0, r3
 800c17e:	f021 fb38 	bl	802d7f2 <memset>
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800c188:	223e      	movs	r2, #62	@ 0x3e
 800c18a:	2100      	movs	r1, #0
 800c18c:	4618      	mov	r0, r3
 800c18e:	f021 fb30 	bl	802d7f2 <memset>

  return USBH_OK;
 800c192:	2300      	movs	r3, #0
}
 800c194:	4618      	mov	r0, r3
 800c196:	3710      	adds	r7, #16
 800c198:	46bd      	mov	sp, r7
 800c19a:	bd80      	pop	{r7, pc}

0800c19c <USBH_RegisterClass>:
  * @param  phost : Host Handle
  * @param  pclass: Class handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
 800c19c:	b480      	push	{r7}
 800c19e:	b085      	sub	sp, #20
 800c1a0:	af00      	add	r7, sp, #0
 800c1a2:	6078      	str	r0, [r7, #4]
 800c1a4:	6039      	str	r1, [r7, #0]
  USBH_StatusTypeDef status = USBH_OK;
 800c1a6:	2300      	movs	r3, #0
 800c1a8:	73fb      	strb	r3, [r7, #15]

  if (pclass != NULL)
 800c1aa:	683b      	ldr	r3, [r7, #0]
 800c1ac:	2b00      	cmp	r3, #0
 800c1ae:	d016      	beq.n	800c1de <USBH_RegisterClass+0x42>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800c1b6:	2b00      	cmp	r3, #0
 800c1b8:	d10e      	bne.n	800c1d8 <USBH_RegisterClass+0x3c>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800c1c0:	1c59      	adds	r1, r3, #1
 800c1c2:	687a      	ldr	r2, [r7, #4]
 800c1c4:	f8c2 1380 	str.w	r1, [r2, #896]	@ 0x380
 800c1c8:	687a      	ldr	r2, [r7, #4]
 800c1ca:	33de      	adds	r3, #222	@ 0xde
 800c1cc:	6839      	ldr	r1, [r7, #0]
 800c1ce:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      status = USBH_OK;
 800c1d2:	2300      	movs	r3, #0
 800c1d4:	73fb      	strb	r3, [r7, #15]
 800c1d6:	e004      	b.n	800c1e2 <USBH_RegisterClass+0x46>
    }
    else
    {
      USBH_ErrLog("Max Class Number reached");
      status = USBH_FAIL;
 800c1d8:	2302      	movs	r3, #2
 800c1da:	73fb      	strb	r3, [r7, #15]
 800c1dc:	e001      	b.n	800c1e2 <USBH_RegisterClass+0x46>
    }
  }
  else
  {
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
 800c1de:	2302      	movs	r3, #2
 800c1e0:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800c1e2:	7bfb      	ldrb	r3, [r7, #15]
}
 800c1e4:	4618      	mov	r0, r3
 800c1e6:	3714      	adds	r7, #20
 800c1e8:	46bd      	mov	sp, r7
 800c1ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1ee:	4770      	bx	lr

0800c1f0 <USBH_SelectInterface>:
  * @param  phost: Host Handle
  * @param  interface: Interface number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
 800c1f0:	b480      	push	{r7}
 800c1f2:	b085      	sub	sp, #20
 800c1f4:	af00      	add	r7, sp, #0
 800c1f6:	6078      	str	r0, [r7, #4]
 800c1f8:	460b      	mov	r3, r1
 800c1fa:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef status = USBH_OK;
 800c1fc:	2300      	movs	r3, #0
 800c1fe:	73fb      	strb	r3, [r7, #15]

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	f893 333c 	ldrb.w	r3, [r3, #828]	@ 0x33c
 800c206:	78fa      	ldrb	r2, [r7, #3]
 800c208:	429a      	cmp	r2, r3
 800c20a:	d204      	bcs.n	800c216 <USBH_SelectInterface+0x26>
  {
    phost->device.current_interface = interface;
 800c20c:	687b      	ldr	r3, [r7, #4]
 800c20e:	78fa      	ldrb	r2, [r7, #3]
 800c210:	f883 2324 	strb.w	r2, [r3, #804]	@ 0x324
 800c214:	e001      	b.n	800c21a <USBH_SelectInterface+0x2a>
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
 800c216:	2302      	movs	r3, #2
 800c218:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800c21a:	7bfb      	ldrb	r3, [r7, #15]
}
 800c21c:	4618      	mov	r0, r3
 800c21e:	3714      	adds	r7, #20
 800c220:	46bd      	mov	sp, r7
 800c222:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c226:	4770      	bx	lr

0800c228 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 800c228:	b480      	push	{r7}
 800c22a:	b087      	sub	sp, #28
 800c22c:	af00      	add	r7, sp, #0
 800c22e:	6078      	str	r0, [r7, #4]
 800c230:	4608      	mov	r0, r1
 800c232:	4611      	mov	r1, r2
 800c234:	461a      	mov	r2, r3
 800c236:	4603      	mov	r3, r0
 800c238:	70fb      	strb	r3, [r7, #3]
 800c23a:	460b      	mov	r3, r1
 800c23c:	70bb      	strb	r3, [r7, #2]
 800c23e:	4613      	mov	r3, r2
 800c240:	707b      	strb	r3, [r7, #1]
  USBH_InterfaceDescTypeDef *pif;
  USBH_CfgDescTypeDef *pcfg;
  uint8_t if_ix = 0U;
 800c242:	2300      	movs	r3, #0
 800c244:	75fb      	strb	r3, [r7, #23]

  pif = (USBH_InterfaceDescTypeDef *)NULL;
 800c246:	2300      	movs	r3, #0
 800c248:	613b      	str	r3, [r7, #16]
  pcfg = &phost->device.CfgDesc;
 800c24a:	687b      	ldr	r3, [r7, #4]
 800c24c:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800c250:	60fb      	str	r3, [r7, #12]

  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c252:	e025      	b.n	800c2a0 <USBH_FindInterface+0x78>
  {
    pif = &pcfg->Itf_Desc[if_ix];
 800c254:	7dfb      	ldrb	r3, [r7, #23]
 800c256:	221a      	movs	r2, #26
 800c258:	fb02 f303 	mul.w	r3, r2, r3
 800c25c:	3308      	adds	r3, #8
 800c25e:	68fa      	ldr	r2, [r7, #12]
 800c260:	4413      	add	r3, r2
 800c262:	3302      	adds	r3, #2
 800c264:	613b      	str	r3, [r7, #16]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c266:	693b      	ldr	r3, [r7, #16]
 800c268:	795b      	ldrb	r3, [r3, #5]
 800c26a:	78fa      	ldrb	r2, [r7, #3]
 800c26c:	429a      	cmp	r2, r3
 800c26e:	d002      	beq.n	800c276 <USBH_FindInterface+0x4e>
 800c270:	78fb      	ldrb	r3, [r7, #3]
 800c272:	2bff      	cmp	r3, #255	@ 0xff
 800c274:	d111      	bne.n	800c29a <USBH_FindInterface+0x72>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c276:	693b      	ldr	r3, [r7, #16]
 800c278:	799b      	ldrb	r3, [r3, #6]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c27a:	78ba      	ldrb	r2, [r7, #2]
 800c27c:	429a      	cmp	r2, r3
 800c27e:	d002      	beq.n	800c286 <USBH_FindInterface+0x5e>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c280:	78bb      	ldrb	r3, [r7, #2]
 800c282:	2bff      	cmp	r3, #255	@ 0xff
 800c284:	d109      	bne.n	800c29a <USBH_FindInterface+0x72>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800c286:	693b      	ldr	r3, [r7, #16]
 800c288:	79db      	ldrb	r3, [r3, #7]
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c28a:	787a      	ldrb	r2, [r7, #1]
 800c28c:	429a      	cmp	r2, r3
 800c28e:	d002      	beq.n	800c296 <USBH_FindInterface+0x6e>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800c290:	787b      	ldrb	r3, [r7, #1]
 800c292:	2bff      	cmp	r3, #255	@ 0xff
 800c294:	d101      	bne.n	800c29a <USBH_FindInterface+0x72>
    {
      return  if_ix;
 800c296:	7dfb      	ldrb	r3, [r7, #23]
 800c298:	e006      	b.n	800c2a8 <USBH_FindInterface+0x80>
    }
    if_ix++;
 800c29a:	7dfb      	ldrb	r3, [r7, #23]
 800c29c:	3301      	adds	r3, #1
 800c29e:	75fb      	strb	r3, [r7, #23]
  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c2a0:	7dfb      	ldrb	r3, [r7, #23]
 800c2a2:	2b01      	cmp	r3, #1
 800c2a4:	d9d6      	bls.n	800c254 <USBH_FindInterface+0x2c>
  }
  return 0xFFU;
 800c2a6:	23ff      	movs	r3, #255	@ 0xff
}
 800c2a8:	4618      	mov	r0, r3
 800c2aa:	371c      	adds	r7, #28
 800c2ac:	46bd      	mov	sp, r7
 800c2ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2b2:	4770      	bx	lr

0800c2b4 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Start(USBH_HandleTypeDef *phost)
{
 800c2b4:	b580      	push	{r7, lr}
 800c2b6:	b082      	sub	sp, #8
 800c2b8:	af00      	add	r7, sp, #0
 800c2ba:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  (void)USBH_LL_Start(phost);
 800c2bc:	6878      	ldr	r0, [r7, #4]
 800c2be:	f020 feb5 	bl	802d02c <USBH_LL_Start>

  /* Activate VBUS on the port */
  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800c2c2:	2101      	movs	r1, #1
 800c2c4:	6878      	ldr	r0, [r7, #4]
 800c2c6:	f020 ffce 	bl	802d266 <USBH_LL_DriverVBUS>

  return USBH_OK;
 800c2ca:	2300      	movs	r3, #0
}
 800c2cc:	4618      	mov	r0, r3
 800c2ce:	3708      	adds	r7, #8
 800c2d0:	46bd      	mov	sp, r7
 800c2d2:	bd80      	pop	{r7, pc}

0800c2d4 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Process(USBH_HandleTypeDef *phost)
{
 800c2d4:	b580      	push	{r7, lr}
 800c2d6:	b088      	sub	sp, #32
 800c2d8:	af04      	add	r7, sp, #16
 800c2da:	6078      	str	r0, [r7, #4]
  volatile USBH_StatusTypeDef status = USBH_FAIL;
 800c2dc:	2302      	movs	r3, #2
 800c2de:	73bb      	strb	r3, [r7, #14]
  uint8_t idx = 0U;
 800c2e0:	2300      	movs	r3, #0
 800c2e2:	73fb      	strb	r3, [r7, #15]

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	f893 3321 	ldrb.w	r3, [r3, #801]	@ 0x321
 800c2ea:	b2db      	uxtb	r3, r3
 800c2ec:	2b01      	cmp	r3, #1
 800c2ee:	d102      	bne.n	800c2f6 <USBH_Process+0x22>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 800c2f0:	687b      	ldr	r3, [r7, #4]
 800c2f2:	2203      	movs	r2, #3
 800c2f4:	701a      	strb	r2, [r3, #0]
  }

  switch (phost->gState)
 800c2f6:	687b      	ldr	r3, [r7, #4]
 800c2f8:	781b      	ldrb	r3, [r3, #0]
 800c2fa:	b2db      	uxtb	r3, r3
 800c2fc:	2b0b      	cmp	r3, #11
 800c2fe:	f200 81bb 	bhi.w	800c678 <USBH_Process+0x3a4>
 800c302:	a201      	add	r2, pc, #4	@ (adr r2, 800c308 <USBH_Process+0x34>)
 800c304:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c308:	0800c339 	.word	0x0800c339
 800c30c:	0800c36b 	.word	0x0800c36b
 800c310:	0800c3d3 	.word	0x0800c3d3
 800c314:	0800c613 	.word	0x0800c613
 800c318:	0800c679 	.word	0x0800c679
 800c31c:	0800c473 	.word	0x0800c473
 800c320:	0800c5b9 	.word	0x0800c5b9
 800c324:	0800c4a9 	.word	0x0800c4a9
 800c328:	0800c4c9 	.word	0x0800c4c9
 800c32c:	0800c4e7 	.word	0x0800c4e7
 800c330:	0800c52b 	.word	0x0800c52b
 800c334:	0800c5fb 	.word	0x0800c5fb
  {
    case HOST_IDLE :

      if ((phost->device.is_connected) != 0U)
 800c338:	687b      	ldr	r3, [r7, #4]
 800c33a:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800c33e:	b2db      	uxtb	r3, r3
 800c340:	2b00      	cmp	r3, #0
 800c342:	f000 819b 	beq.w	800c67c <USBH_Process+0x3a8>
      {
        USBH_UsrLog("USB Device Connected");

        /* Wait for 200 ms after connection */
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800c346:	687b      	ldr	r3, [r7, #4]
 800c348:	2201      	movs	r2, #1
 800c34a:	701a      	strb	r2, [r3, #0]
        USBH_Delay(200U);
 800c34c:	20c8      	movs	r0, #200	@ 0xc8
 800c34e:	f021 f807 	bl	802d360 <USBH_Delay>
        (void)USBH_LL_ResetPort(phost);
 800c352:	6878      	ldr	r0, [r7, #4]
 800c354:	f020 fec7 	bl	802d0e6 <USBH_LL_ResetPort>

        /* Make sure to start with Default address */
        phost->device.address = USBH_ADDRESS_DEFAULT;
 800c358:	687b      	ldr	r3, [r7, #4]
 800c35a:	2200      	movs	r2, #0
 800c35c:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c
        phost->Timeout = 0U;
 800c360:	687b      	ldr	r3, [r7, #4]
 800c362:	2200      	movs	r2, #0
 800c364:	f8c3 23c8 	str.w	r2, [r3, #968]	@ 0x3c8
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c368:	e188      	b.n	800c67c <USBH_Process+0x3a8>

    case HOST_DEV_WAIT_FOR_ATTACHMENT: /* Wait for Port Enabled */

      if (phost->device.PortEnabled == 1U)
 800c36a:	687b      	ldr	r3, [r7, #4]
 800c36c:	f893 3323 	ldrb.w	r3, [r3, #803]	@ 0x323
 800c370:	2b01      	cmp	r3, #1
 800c372:	d107      	bne.n	800c384 <USBH_Process+0xb0>
      {
        USBH_UsrLog("USB Device Reset Completed");
        phost->device.RstCnt = 0U;
 800c374:	687b      	ldr	r3, [r7, #4]
 800c376:	2200      	movs	r2, #0
 800c378:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 800c37c:	687b      	ldr	r3, [r7, #4]
 800c37e:	2202      	movs	r2, #2
 800c380:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c382:	e18a      	b.n	800c69a <USBH_Process+0x3c6>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 800c384:	687b      	ldr	r3, [r7, #4]
 800c386:	f8d3 33c8 	ldr.w	r3, [r3, #968]	@ 0x3c8
 800c38a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800c38e:	d914      	bls.n	800c3ba <USBH_Process+0xe6>
          phost->device.RstCnt++;
 800c390:	687b      	ldr	r3, [r7, #4]
 800c392:	f893 331f 	ldrb.w	r3, [r3, #799]	@ 0x31f
 800c396:	3301      	adds	r3, #1
 800c398:	b2da      	uxtb	r2, r3
 800c39a:	687b      	ldr	r3, [r7, #4]
 800c39c:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
          if (phost->device.RstCnt > 3U)
 800c3a0:	687b      	ldr	r3, [r7, #4]
 800c3a2:	f893 331f 	ldrb.w	r3, [r3, #799]	@ 0x31f
 800c3a6:	2b03      	cmp	r3, #3
 800c3a8:	d903      	bls.n	800c3b2 <USBH_Process+0xde>
            phost->gState = HOST_ABORT_STATE;
 800c3aa:	687b      	ldr	r3, [r7, #4]
 800c3ac:	220d      	movs	r2, #13
 800c3ae:	701a      	strb	r2, [r3, #0]
      break;
 800c3b0:	e173      	b.n	800c69a <USBH_Process+0x3c6>
            phost->gState = HOST_IDLE;
 800c3b2:	687b      	ldr	r3, [r7, #4]
 800c3b4:	2200      	movs	r2, #0
 800c3b6:	701a      	strb	r2, [r3, #0]
      break;
 800c3b8:	e16f      	b.n	800c69a <USBH_Process+0x3c6>
          phost->Timeout += 10U;
 800c3ba:	687b      	ldr	r3, [r7, #4]
 800c3bc:	f8d3 33c8 	ldr.w	r3, [r3, #968]	@ 0x3c8
 800c3c0:	f103 020a 	add.w	r2, r3, #10
 800c3c4:	687b      	ldr	r3, [r7, #4]
 800c3c6:	f8c3 23c8 	str.w	r2, [r3, #968]	@ 0x3c8
          USBH_Delay(10U);
 800c3ca:	200a      	movs	r0, #10
 800c3cc:	f020 ffc8 	bl	802d360 <USBH_Delay>
      break;
 800c3d0:	e163      	b.n	800c69a <USBH_Process+0x3c6>

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 800c3d2:	687b      	ldr	r3, [r7, #4]
 800c3d4:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c3d8:	2b00      	cmp	r3, #0
 800c3da:	d005      	beq.n	800c3e8 <USBH_Process+0x114>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 800c3dc:	687b      	ldr	r3, [r7, #4]
 800c3de:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c3e2:	2104      	movs	r1, #4
 800c3e4:	6878      	ldr	r0, [r7, #4]
 800c3e6:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 800c3e8:	2064      	movs	r0, #100	@ 0x64
 800c3ea:	f020 ffb9 	bl	802d360 <USBH_Delay>

      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 800c3ee:	6878      	ldr	r0, [r7, #4]
 800c3f0:	f020 fe52 	bl	802d098 <USBH_LL_GetSpeed>
 800c3f4:	4603      	mov	r3, r0
 800c3f6:	461a      	mov	r2, r3
 800c3f8:	687b      	ldr	r3, [r7, #4]
 800c3fa:	f883 231d 	strb.w	r2, [r3, #797]	@ 0x31d

      phost->gState = HOST_ENUMERATION;
 800c3fe:	687b      	ldr	r3, [r7, #4]
 800c400:	2205      	movs	r2, #5
 800c402:	701a      	strb	r2, [r3, #0]

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800c404:	2100      	movs	r1, #0
 800c406:	6878      	ldr	r0, [r7, #4]
 800c408:	f001 fa9b 	bl	800d942 <USBH_AllocPipe>
 800c40c:	4603      	mov	r3, r0
 800c40e:	461a      	mov	r2, r3
 800c410:	687b      	ldr	r3, [r7, #4]
 800c412:	715a      	strb	r2, [r3, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c414:	2180      	movs	r1, #128	@ 0x80
 800c416:	6878      	ldr	r0, [r7, #4]
 800c418:	f001 fa93 	bl	800d942 <USBH_AllocPipe>
 800c41c:	4603      	mov	r3, r0
 800c41e:	461a      	mov	r2, r3
 800c420:	687b      	ldr	r3, [r7, #4]
 800c422:	711a      	strb	r2, [r3, #4]

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c424:	687b      	ldr	r3, [r7, #4]
 800c426:	7919      	ldrb	r1, [r3, #4]
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c42e:	687b      	ldr	r3, [r7, #4]
 800c430:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 800c434:	687a      	ldr	r2, [r7, #4]
 800c436:	7992      	ldrb	r2, [r2, #6]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c438:	9202      	str	r2, [sp, #8]
 800c43a:	2200      	movs	r2, #0
 800c43c:	9201      	str	r2, [sp, #4]
 800c43e:	9300      	str	r3, [sp, #0]
 800c440:	4603      	mov	r3, r0
 800c442:	2280      	movs	r2, #128	@ 0x80
 800c444:	6878      	ldr	r0, [r7, #4]
 800c446:	f001 fa4d 	bl	800d8e4 <USBH_OpenPipe>

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800c44a:	687b      	ldr	r3, [r7, #4]
 800c44c:	7959      	ldrb	r1, [r3, #5]
 800c44e:	687b      	ldr	r3, [r7, #4]
 800c450:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c454:	687b      	ldr	r3, [r7, #4]
 800c456:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 800c45a:	687a      	ldr	r2, [r7, #4]
 800c45c:	7992      	ldrb	r2, [r2, #6]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800c45e:	9202      	str	r2, [sp, #8]
 800c460:	2200      	movs	r2, #0
 800c462:	9201      	str	r2, [sp, #4]
 800c464:	9300      	str	r3, [sp, #0]
 800c466:	4603      	mov	r3, r0
 800c468:	2200      	movs	r2, #0
 800c46a:	6878      	ldr	r0, [r7, #4]
 800c46c:	f001 fa3a 	bl	800d8e4 <USBH_OpenPipe>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c470:	e113      	b.n	800c69a <USBH_Process+0x3c6>

    case HOST_ENUMERATION:
      /* Check for enumeration status */
      status = USBH_HandleEnum(phost);
 800c472:	6878      	ldr	r0, [r7, #4]
 800c474:	f000 f916 	bl	800c6a4 <USBH_HandleEnum>
 800c478:	4603      	mov	r3, r0
 800c47a:	73bb      	strb	r3, [r7, #14]
      if (status == USBH_OK)
 800c47c:	7bbb      	ldrb	r3, [r7, #14]
 800c47e:	b2db      	uxtb	r3, r3
 800c480:	2b00      	cmp	r3, #0
 800c482:	f040 80fd 	bne.w	800c680 <USBH_Process+0x3ac>
      {
        /* The function shall return USBH_OK when full enumeration is complete */
        USBH_UsrLog("Enumeration done.");

        phost->device.current_interface = 0U;
 800c486:	687b      	ldr	r3, [r7, #4]
 800c488:	2200      	movs	r2, #0
 800c48a:	f883 2324 	strb.w	r2, [r3, #804]	@ 0x324

        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800c48e:	687b      	ldr	r3, [r7, #4]
 800c490:	f893 3337 	ldrb.w	r3, [r3, #823]	@ 0x337
 800c494:	2b01      	cmp	r3, #1
 800c496:	d103      	bne.n	800c4a0 <USBH_Process+0x1cc>
        {
          USBH_UsrLog("This device has only 1 configuration.");
          phost->gState = HOST_SET_CONFIGURATION;
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	2208      	movs	r2, #8
 800c49c:	701a      	strb	r2, [r3, #0]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c49e:	e0ef      	b.n	800c680 <USBH_Process+0x3ac>
          phost->gState = HOST_INPUT;
 800c4a0:	687b      	ldr	r3, [r7, #4]
 800c4a2:	2207      	movs	r2, #7
 800c4a4:	701a      	strb	r2, [r3, #0]
      break;
 800c4a6:	e0eb      	b.n	800c680 <USBH_Process+0x3ac>

    case HOST_INPUT:
    {
      /* user callback for end of device basic enumeration */
      if (phost->pUser != NULL)
 800c4a8:	687b      	ldr	r3, [r7, #4]
 800c4aa:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c4ae:	2b00      	cmp	r3, #0
 800c4b0:	f000 80e8 	beq.w	800c684 <USBH_Process+0x3b0>
      {
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 800c4b4:	687b      	ldr	r3, [r7, #4]
 800c4b6:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c4ba:	2101      	movs	r1, #1
 800c4bc:	6878      	ldr	r0, [r7, #4]
 800c4be:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 800c4c0:	687b      	ldr	r3, [r7, #4]
 800c4c2:	2208      	movs	r2, #8
 800c4c4:	701a      	strb	r2, [r3, #0]
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
    }
    break;
 800c4c6:	e0dd      	b.n	800c684 <USBH_Process+0x3b0>

    case HOST_SET_CONFIGURATION:
      /* set configuration */
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 800c4c8:	687b      	ldr	r3, [r7, #4]
 800c4ca:	f893 333d 	ldrb.w	r3, [r3, #829]	@ 0x33d
 800c4ce:	4619      	mov	r1, r3
 800c4d0:	6878      	ldr	r0, [r7, #4]
 800c4d2:	f000 fc3a 	bl	800cd4a <USBH_SetCfg>
 800c4d6:	4603      	mov	r3, r0
 800c4d8:	2b00      	cmp	r3, #0
 800c4da:	f040 80d5 	bne.w	800c688 <USBH_Process+0x3b4>
      {
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 800c4de:	687b      	ldr	r3, [r7, #4]
 800c4e0:	2209      	movs	r2, #9
 800c4e2:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c4e4:	e0d0      	b.n	800c688 <USBH_Process+0x3b4>

    case  HOST_SET_WAKEUP_FEATURE:

      if (((phost->device.CfgDesc.bmAttributes) & (1U << 5)) != 0U)
 800c4e6:	687b      	ldr	r3, [r7, #4]
 800c4e8:	f893 333f 	ldrb.w	r3, [r3, #831]	@ 0x33f
 800c4ec:	f003 0320 	and.w	r3, r3, #32
 800c4f0:	2b00      	cmp	r3, #0
 800c4f2:	d016      	beq.n	800c522 <USBH_Process+0x24e>
      {
        status = USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP);
 800c4f4:	2101      	movs	r1, #1
 800c4f6:	6878      	ldr	r0, [r7, #4]
 800c4f8:	f000 fc4a 	bl	800cd90 <USBH_SetFeature>
 800c4fc:	4603      	mov	r3, r0
 800c4fe:	73bb      	strb	r3, [r7, #14]

        if (status == USBH_OK)
 800c500:	7bbb      	ldrb	r3, [r7, #14]
 800c502:	b2db      	uxtb	r3, r3
 800c504:	2b00      	cmp	r3, #0
 800c506:	d103      	bne.n	800c510 <USBH_Process+0x23c>
        {
          USBH_UsrLog("Device remote wakeup enabled");
          phost->gState = HOST_CHECK_CLASS;
 800c508:	687b      	ldr	r3, [r7, #4]
 800c50a:	220a      	movs	r2, #10
 800c50c:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c50e:	e0bd      	b.n	800c68c <USBH_Process+0x3b8>
        else if (status == USBH_NOT_SUPPORTED)
 800c510:	7bbb      	ldrb	r3, [r7, #14]
 800c512:	b2db      	uxtb	r3, r3
 800c514:	2b03      	cmp	r3, #3
 800c516:	f040 80b9 	bne.w	800c68c <USBH_Process+0x3b8>
          phost->gState = HOST_CHECK_CLASS;
 800c51a:	687b      	ldr	r3, [r7, #4]
 800c51c:	220a      	movs	r2, #10
 800c51e:	701a      	strb	r2, [r3, #0]
      break;
 800c520:	e0b4      	b.n	800c68c <USBH_Process+0x3b8>
        phost->gState = HOST_CHECK_CLASS;
 800c522:	687b      	ldr	r3, [r7, #4]
 800c524:	220a      	movs	r2, #10
 800c526:	701a      	strb	r2, [r3, #0]
      break;
 800c528:	e0b0      	b.n	800c68c <USBH_Process+0x3b8>

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
 800c52a:	687b      	ldr	r3, [r7, #4]
 800c52c:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800c530:	2b00      	cmp	r3, #0
 800c532:	f000 80ad 	beq.w	800c690 <USBH_Process+0x3bc>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
 800c536:	687b      	ldr	r3, [r7, #4]
 800c538:	2200      	movs	r2, #0
 800c53a:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 800c53e:	2300      	movs	r3, #0
 800c540:	73fb      	strb	r3, [r7, #15]
 800c542:	e016      	b.n	800c572 <USBH_Process+0x29e>
        {
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 800c544:	7bfa      	ldrb	r2, [r7, #15]
 800c546:	687b      	ldr	r3, [r7, #4]
 800c548:	32de      	adds	r2, #222	@ 0xde
 800c54a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c54e:	791a      	ldrb	r2, [r3, #4]
 800c550:	687b      	ldr	r3, [r7, #4]
 800c552:	f893 3347 	ldrb.w	r3, [r3, #839]	@ 0x347
 800c556:	429a      	cmp	r2, r3
 800c558:	d108      	bne.n	800c56c <USBH_Process+0x298>
          {
            phost->pActiveClass = phost->pClass[idx];
 800c55a:	7bfa      	ldrb	r2, [r7, #15]
 800c55c:	687b      	ldr	r3, [r7, #4]
 800c55e:	32de      	adds	r2, #222	@ 0xde
 800c560:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c564:	687b      	ldr	r3, [r7, #4]
 800c566:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
            break;
 800c56a:	e005      	b.n	800c578 <USBH_Process+0x2a4>
        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 800c56c:	7bfb      	ldrb	r3, [r7, #15]
 800c56e:	3301      	adds	r3, #1
 800c570:	73fb      	strb	r3, [r7, #15]
 800c572:	7bfb      	ldrb	r3, [r7, #15]
 800c574:	2b00      	cmp	r3, #0
 800c576:	d0e5      	beq.n	800c544 <USBH_Process+0x270>
          }
        }

        if (phost->pActiveClass != NULL)
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c57e:	2b00      	cmp	r3, #0
 800c580:	d016      	beq.n	800c5b0 <USBH_Process+0x2dc>
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c588:	689b      	ldr	r3, [r3, #8]
 800c58a:	6878      	ldr	r0, [r7, #4]
 800c58c:	4798      	blx	r3
 800c58e:	4603      	mov	r3, r0
 800c590:	2b00      	cmp	r3, #0
 800c592:	d109      	bne.n	800c5a8 <USBH_Process+0x2d4>
          {
            phost->gState = HOST_CLASS_REQUEST;
 800c594:	687b      	ldr	r3, [r7, #4]
 800c596:	2206      	movs	r2, #6
 800c598:	701a      	strb	r2, [r3, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 800c59a:	687b      	ldr	r3, [r7, #4]
 800c59c:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c5a0:	2103      	movs	r1, #3
 800c5a2:	6878      	ldr	r0, [r7, #4]
 800c5a4:	4798      	blx	r3
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c5a6:	e073      	b.n	800c690 <USBH_Process+0x3bc>
            phost->gState = HOST_ABORT_STATE;
 800c5a8:	687b      	ldr	r3, [r7, #4]
 800c5aa:	220d      	movs	r2, #13
 800c5ac:	701a      	strb	r2, [r3, #0]
      break;
 800c5ae:	e06f      	b.n	800c690 <USBH_Process+0x3bc>
          phost->gState = HOST_ABORT_STATE;
 800c5b0:	687b      	ldr	r3, [r7, #4]
 800c5b2:	220d      	movs	r2, #13
 800c5b4:	701a      	strb	r2, [r3, #0]
      break;
 800c5b6:	e06b      	b.n	800c690 <USBH_Process+0x3bc>

    case HOST_CLASS_REQUEST:
      /* process class standard control requests state machine */
      if (phost->pActiveClass != NULL)
 800c5b8:	687b      	ldr	r3, [r7, #4]
 800c5ba:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c5be:	2b00      	cmp	r3, #0
 800c5c0:	d017      	beq.n	800c5f2 <USBH_Process+0x31e>
      {
        status = phost->pActiveClass->Requests(phost);
 800c5c2:	687b      	ldr	r3, [r7, #4]
 800c5c4:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c5c8:	691b      	ldr	r3, [r3, #16]
 800c5ca:	6878      	ldr	r0, [r7, #4]
 800c5cc:	4798      	blx	r3
 800c5ce:	4603      	mov	r3, r0
 800c5d0:	73bb      	strb	r3, [r7, #14]

        if (status == USBH_OK)
 800c5d2:	7bbb      	ldrb	r3, [r7, #14]
 800c5d4:	b2db      	uxtb	r3, r3
 800c5d6:	2b00      	cmp	r3, #0
 800c5d8:	d103      	bne.n	800c5e2 <USBH_Process+0x30e>
        {
          phost->gState = HOST_CLASS;
 800c5da:	687b      	ldr	r3, [r7, #4]
 800c5dc:	220b      	movs	r2, #11
 800c5de:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c5e0:	e058      	b.n	800c694 <USBH_Process+0x3c0>
        else if (status == USBH_FAIL)
 800c5e2:	7bbb      	ldrb	r3, [r7, #14]
 800c5e4:	b2db      	uxtb	r3, r3
 800c5e6:	2b02      	cmp	r3, #2
 800c5e8:	d154      	bne.n	800c694 <USBH_Process+0x3c0>
          phost->gState = HOST_ABORT_STATE;
 800c5ea:	687b      	ldr	r3, [r7, #4]
 800c5ec:	220d      	movs	r2, #13
 800c5ee:	701a      	strb	r2, [r3, #0]
      break;
 800c5f0:	e050      	b.n	800c694 <USBH_Process+0x3c0>
        phost->gState = HOST_ABORT_STATE;
 800c5f2:	687b      	ldr	r3, [r7, #4]
 800c5f4:	220d      	movs	r2, #13
 800c5f6:	701a      	strb	r2, [r3, #0]
      break;
 800c5f8:	e04c      	b.n	800c694 <USBH_Process+0x3c0>

    case HOST_CLASS:
      /* process class state machine */
      if (phost->pActiveClass != NULL)
 800c5fa:	687b      	ldr	r3, [r7, #4]
 800c5fc:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c600:	2b00      	cmp	r3, #0
 800c602:	d049      	beq.n	800c698 <USBH_Process+0x3c4>
      {
        phost->pActiveClass->BgndProcess(phost);
 800c604:	687b      	ldr	r3, [r7, #4]
 800c606:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c60a:	695b      	ldr	r3, [r3, #20]
 800c60c:	6878      	ldr	r0, [r7, #4]
 800c60e:	4798      	blx	r3
      }
      break;
 800c610:	e042      	b.n	800c698 <USBH_Process+0x3c4>

    case HOST_DEV_DISCONNECTED :
      phost->device.is_disconnected = 0U;
 800c612:	687b      	ldr	r3, [r7, #4]
 800c614:	2200      	movs	r2, #0
 800c616:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321

      (void)DeInitStateMachine(phost);
 800c61a:	6878      	ldr	r0, [r7, #4]
 800c61c:	f7ff fd4b 	bl	800c0b6 <DeInitStateMachine>

      /* Re-Initilaize Host for new Enumeration */
      if (phost->pActiveClass != NULL)
 800c620:	687b      	ldr	r3, [r7, #4]
 800c622:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c626:	2b00      	cmp	r3, #0
 800c628:	d009      	beq.n	800c63e <USBH_Process+0x36a>
      {
        phost->pActiveClass->DeInit(phost);
 800c62a:	687b      	ldr	r3, [r7, #4]
 800c62c:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c630:	68db      	ldr	r3, [r3, #12]
 800c632:	6878      	ldr	r0, [r7, #4]
 800c634:	4798      	blx	r3
        phost->pActiveClass = NULL;
 800c636:	687b      	ldr	r3, [r7, #4]
 800c638:	2200      	movs	r2, #0
 800c63a:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
      }

      if (phost->pUser != NULL)
 800c63e:	687b      	ldr	r3, [r7, #4]
 800c640:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c644:	2b00      	cmp	r3, #0
 800c646:	d005      	beq.n	800c654 <USBH_Process+0x380>
      {
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 800c648:	687b      	ldr	r3, [r7, #4]
 800c64a:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c64e:	2105      	movs	r1, #5
 800c650:	6878      	ldr	r0, [r7, #4]
 800c652:	4798      	blx	r3
      }
      USBH_UsrLog("USB Device disconnected");

      if (phost->device.is_ReEnumerated == 1U)
 800c654:	687b      	ldr	r3, [r7, #4]
 800c656:	f893 3322 	ldrb.w	r3, [r3, #802]	@ 0x322
 800c65a:	b2db      	uxtb	r3, r3
 800c65c:	2b01      	cmp	r3, #1
 800c65e:	d107      	bne.n	800c670 <USBH_Process+0x39c>
      {
        phost->device.is_ReEnumerated = 0U;
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	2200      	movs	r2, #0
 800c664:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322

        /* Start the host and re-enable Vbus */
        (void)USBH_Start(phost);
 800c668:	6878      	ldr	r0, [r7, #4]
 800c66a:	f7ff fe23 	bl	800c2b4 <USBH_Start>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c66e:	e014      	b.n	800c69a <USBH_Process+0x3c6>
        (void)USBH_LL_Start(phost);
 800c670:	6878      	ldr	r0, [r7, #4]
 800c672:	f020 fcdb 	bl	802d02c <USBH_LL_Start>
      break;
 800c676:	e010      	b.n	800c69a <USBH_Process+0x3c6>

    case HOST_ABORT_STATE:
    default :
      break;
 800c678:	bf00      	nop
 800c67a:	e00e      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c67c:	bf00      	nop
 800c67e:	e00c      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c680:	bf00      	nop
 800c682:	e00a      	b.n	800c69a <USBH_Process+0x3c6>
    break;
 800c684:	bf00      	nop
 800c686:	e008      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c688:	bf00      	nop
 800c68a:	e006      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c68c:	bf00      	nop
 800c68e:	e004      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c690:	bf00      	nop
 800c692:	e002      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c694:	bf00      	nop
 800c696:	e000      	b.n	800c69a <USBH_Process+0x3c6>
      break;
 800c698:	bf00      	nop
  }
  return USBH_OK;
 800c69a:	2300      	movs	r3, #0
}
 800c69c:	4618      	mov	r0, r3
 800c69e:	3710      	adds	r7, #16
 800c6a0:	46bd      	mov	sp, r7
 800c6a2:	bd80      	pop	{r7, pc}

0800c6a4 <USBH_HandleEnum>:
  *         This function includes the complete enumeration process
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
 800c6a4:	b580      	push	{r7, lr}
 800c6a6:	b088      	sub	sp, #32
 800c6a8:	af04      	add	r7, sp, #16
 800c6aa:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c6ac:	2301      	movs	r3, #1
 800c6ae:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;
 800c6b0:	2301      	movs	r3, #1
 800c6b2:	73bb      	strb	r3, [r7, #14]

  switch (phost->EnumState)
 800c6b4:	687b      	ldr	r3, [r7, #4]
 800c6b6:	785b      	ldrb	r3, [r3, #1]
 800c6b8:	2b07      	cmp	r3, #7
 800c6ba:	f200 81bd 	bhi.w	800ca38 <USBH_HandleEnum+0x394>
 800c6be:	a201      	add	r2, pc, #4	@ (adr r2, 800c6c4 <USBH_HandleEnum+0x20>)
 800c6c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c6c4:	0800c6e5 	.word	0x0800c6e5
 800c6c8:	0800c79f 	.word	0x0800c79f
 800c6cc:	0800c809 	.word	0x0800c809
 800c6d0:	0800c893 	.word	0x0800c893
 800c6d4:	0800c8fd 	.word	0x0800c8fd
 800c6d8:	0800c96d 	.word	0x0800c96d
 800c6dc:	0800c9b3 	.word	0x0800c9b3
 800c6e0:	0800c9f9 	.word	0x0800c9f9
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 800c6e4:	2108      	movs	r1, #8
 800c6e6:	6878      	ldr	r0, [r7, #4]
 800c6e8:	f000 fa4c 	bl	800cb84 <USBH_Get_DevDesc>
 800c6ec:	4603      	mov	r3, r0
 800c6ee:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c6f0:	7bbb      	ldrb	r3, [r7, #14]
 800c6f2:	2b00      	cmp	r3, #0
 800c6f4:	d12e      	bne.n	800c754 <USBH_HandleEnum+0xb0>
      {
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	f893 232d 	ldrb.w	r2, [r3, #813]	@ 0x32d
 800c6fc:	687b      	ldr	r3, [r7, #4]
 800c6fe:	719a      	strb	r2, [r3, #6]

        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800c700:	687b      	ldr	r3, [r7, #4]
 800c702:	2201      	movs	r2, #1
 800c704:	705a      	strb	r2, [r3, #1]

        /* modify control channels configuration for MaxPacket size */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	7919      	ldrb	r1, [r3, #4]
 800c70a:	687b      	ldr	r3, [r7, #4]
 800c70c:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c710:	687b      	ldr	r3, [r7, #4]
 800c712:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c716:	687a      	ldr	r2, [r7, #4]
 800c718:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c71a:	9202      	str	r2, [sp, #8]
 800c71c:	2200      	movs	r2, #0
 800c71e:	9201      	str	r2, [sp, #4]
 800c720:	9300      	str	r3, [sp, #0]
 800c722:	4603      	mov	r3, r0
 800c724:	2280      	movs	r2, #128	@ 0x80
 800c726:	6878      	ldr	r0, [r7, #4]
 800c728:	f001 f8dc 	bl	800d8e4 <USBH_OpenPipe>

        /* Open Control pipes */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c72c:	687b      	ldr	r3, [r7, #4]
 800c72e:	7959      	ldrb	r1, [r3, #5]
 800c730:	687b      	ldr	r3, [r7, #4]
 800c732:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c73c:	687a      	ldr	r2, [r7, #4]
 800c73e:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c740:	9202      	str	r2, [sp, #8]
 800c742:	2200      	movs	r2, #0
 800c744:	9201      	str	r2, [sp, #4]
 800c746:	9300      	str	r3, [sp, #0]
 800c748:	4603      	mov	r3, r0
 800c74a:	2200      	movs	r2, #0
 800c74c:	6878      	ldr	r0, [r7, #4]
 800c74e:	f001 f8c9 	bl	800d8e4 <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 800c752:	e173      	b.n	800ca3c <USBH_HandleEnum+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c754:	7bbb      	ldrb	r3, [r7, #14]
 800c756:	2b03      	cmp	r3, #3
 800c758:	f040 8170 	bne.w	800ca3c <USBH_HandleEnum+0x398>
        phost->device.EnumCnt++;
 800c75c:	687b      	ldr	r3, [r7, #4]
 800c75e:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c762:	3301      	adds	r3, #1
 800c764:	b2da      	uxtb	r2, r3
 800c766:	687b      	ldr	r3, [r7, #4]
 800c768:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c76c:	687b      	ldr	r3, [r7, #4]
 800c76e:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c772:	2b03      	cmp	r3, #3
 800c774:	d903      	bls.n	800c77e <USBH_HandleEnum+0xda>
          phost->gState = HOST_ABORT_STATE;
 800c776:	687b      	ldr	r3, [r7, #4]
 800c778:	220d      	movs	r2, #13
 800c77a:	701a      	strb	r2, [r3, #0]
      break;
 800c77c:	e15e      	b.n	800ca3c <USBH_HandleEnum+0x398>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c77e:	687b      	ldr	r3, [r7, #4]
 800c780:	795b      	ldrb	r3, [r3, #5]
 800c782:	4619      	mov	r1, r3
 800c784:	6878      	ldr	r0, [r7, #4]
 800c786:	f001 f8fd 	bl	800d984 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c78a:	687b      	ldr	r3, [r7, #4]
 800c78c:	791b      	ldrb	r3, [r3, #4]
 800c78e:	4619      	mov	r1, r3
 800c790:	6878      	ldr	r0, [r7, #4]
 800c792:	f001 f8f7 	bl	800d984 <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 800c796:	687b      	ldr	r3, [r7, #4]
 800c798:	2200      	movs	r2, #0
 800c79a:	701a      	strb	r2, [r3, #0]
      break;
 800c79c:	e14e      	b.n	800ca3c <USBH_HandleEnum+0x398>

    case ENUM_GET_FULL_DEV_DESC:
      /* Get FULL Device Desc  */
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 800c79e:	2112      	movs	r1, #18
 800c7a0:	6878      	ldr	r0, [r7, #4]
 800c7a2:	f000 f9ef 	bl	800cb84 <USBH_Get_DevDesc>
 800c7a6:	4603      	mov	r3, r0
 800c7a8:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c7aa:	7bbb      	ldrb	r3, [r7, #14]
 800c7ac:	2b00      	cmp	r3, #0
 800c7ae:	d103      	bne.n	800c7b8 <USBH_HandleEnum+0x114>
      {
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);

        phost->EnumState = ENUM_SET_ADDR;
 800c7b0:	687b      	ldr	r3, [r7, #4]
 800c7b2:	2202      	movs	r2, #2
 800c7b4:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c7b6:	e143      	b.n	800ca40 <USBH_HandleEnum+0x39c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c7b8:	7bbb      	ldrb	r3, [r7, #14]
 800c7ba:	2b03      	cmp	r3, #3
 800c7bc:	f040 8140 	bne.w	800ca40 <USBH_HandleEnum+0x39c>
        phost->device.EnumCnt++;
 800c7c0:	687b      	ldr	r3, [r7, #4]
 800c7c2:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c7c6:	3301      	adds	r3, #1
 800c7c8:	b2da      	uxtb	r2, r3
 800c7ca:	687b      	ldr	r3, [r7, #4]
 800c7cc:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c7d0:	687b      	ldr	r3, [r7, #4]
 800c7d2:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c7d6:	2b03      	cmp	r3, #3
 800c7d8:	d903      	bls.n	800c7e2 <USBH_HandleEnum+0x13e>
          phost->gState = HOST_ABORT_STATE;
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	220d      	movs	r2, #13
 800c7de:	701a      	strb	r2, [r3, #0]
      break;
 800c7e0:	e12e      	b.n	800ca40 <USBH_HandleEnum+0x39c>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c7e2:	687b      	ldr	r3, [r7, #4]
 800c7e4:	795b      	ldrb	r3, [r3, #5]
 800c7e6:	4619      	mov	r1, r3
 800c7e8:	6878      	ldr	r0, [r7, #4]
 800c7ea:	f001 f8cb 	bl	800d984 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c7ee:	687b      	ldr	r3, [r7, #4]
 800c7f0:	791b      	ldrb	r3, [r3, #4]
 800c7f2:	4619      	mov	r1, r3
 800c7f4:	6878      	ldr	r0, [r7, #4]
 800c7f6:	f001 f8c5 	bl	800d984 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c7fa:	687b      	ldr	r3, [r7, #4]
 800c7fc:	2200      	movs	r2, #0
 800c7fe:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c800:	687b      	ldr	r3, [r7, #4]
 800c802:	2200      	movs	r2, #0
 800c804:	701a      	strb	r2, [r3, #0]
      break;
 800c806:	e11b      	b.n	800ca40 <USBH_HandleEnum+0x39c>

    case ENUM_SET_ADDR:
      /* set address */
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 800c808:	2101      	movs	r1, #1
 800c80a:	6878      	ldr	r0, [r7, #4]
 800c80c:	f000 fa79 	bl	800cd02 <USBH_SetAddress>
 800c810:	4603      	mov	r3, r0
 800c812:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c814:	7bbb      	ldrb	r3, [r7, #14]
 800c816:	2b00      	cmp	r3, #0
 800c818:	d130      	bne.n	800c87c <USBH_HandleEnum+0x1d8>
      {
        USBH_Delay(2U);
 800c81a:	2002      	movs	r0, #2
 800c81c:	f020 fda0 	bl	802d360 <USBH_Delay>
        phost->device.address = USBH_DEVICE_ADDRESS;
 800c820:	687b      	ldr	r3, [r7, #4]
 800c822:	2201      	movs	r2, #1
 800c824:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c

        /* user callback for device address assigned */
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
        phost->EnumState = ENUM_GET_CFG_DESC;
 800c828:	687b      	ldr	r3, [r7, #4]
 800c82a:	2203      	movs	r2, #3
 800c82c:	705a      	strb	r2, [r3, #1]

        /* modify control channels to update device address */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c82e:	687b      	ldr	r3, [r7, #4]
 800c830:	7919      	ldrb	r1, [r3, #4]
 800c832:	687b      	ldr	r3, [r7, #4]
 800c834:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c838:	687b      	ldr	r3, [r7, #4]
 800c83a:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c83e:	687a      	ldr	r2, [r7, #4]
 800c840:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c842:	9202      	str	r2, [sp, #8]
 800c844:	2200      	movs	r2, #0
 800c846:	9201      	str	r2, [sp, #4]
 800c848:	9300      	str	r3, [sp, #0]
 800c84a:	4603      	mov	r3, r0
 800c84c:	2280      	movs	r2, #128	@ 0x80
 800c84e:	6878      	ldr	r0, [r7, #4]
 800c850:	f001 f848 	bl	800d8e4 <USBH_OpenPipe>

        /* Open Control pipes */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c854:	687b      	ldr	r3, [r7, #4]
 800c856:	7959      	ldrb	r1, [r3, #5]
 800c858:	687b      	ldr	r3, [r7, #4]
 800c85a:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c85e:	687b      	ldr	r3, [r7, #4]
 800c860:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c864:	687a      	ldr	r2, [r7, #4]
 800c866:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c868:	9202      	str	r2, [sp, #8]
 800c86a:	2200      	movs	r2, #0
 800c86c:	9201      	str	r2, [sp, #4]
 800c86e:	9300      	str	r3, [sp, #0]
 800c870:	4603      	mov	r3, r0
 800c872:	2200      	movs	r2, #0
 800c874:	6878      	ldr	r0, [r7, #4]
 800c876:	f001 f835 	bl	800d8e4 <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 800c87a:	e0e3      	b.n	800ca44 <USBH_HandleEnum+0x3a0>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c87c:	7bbb      	ldrb	r3, [r7, #14]
 800c87e:	2b03      	cmp	r3, #3
 800c880:	f040 80e0 	bne.w	800ca44 <USBH_HandleEnum+0x3a0>
        phost->gState = HOST_ABORT_STATE;
 800c884:	687b      	ldr	r3, [r7, #4]
 800c886:	220d      	movs	r2, #13
 800c888:	701a      	strb	r2, [r3, #0]
        phost->EnumState = ENUM_IDLE;
 800c88a:	687b      	ldr	r3, [r7, #4]
 800c88c:	2200      	movs	r2, #0
 800c88e:	705a      	strb	r2, [r3, #1]
      break;
 800c890:	e0d8      	b.n	800ca44 <USBH_HandleEnum+0x3a0>

    case ENUM_GET_CFG_DESC:
      /* get standard configuration descriptor */
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 800c892:	2109      	movs	r1, #9
 800c894:	6878      	ldr	r0, [r7, #4]
 800c896:	f000 f9a1 	bl	800cbdc <USBH_Get_CfgDesc>
 800c89a:	4603      	mov	r3, r0
 800c89c:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c89e:	7bbb      	ldrb	r3, [r7, #14]
 800c8a0:	2b00      	cmp	r3, #0
 800c8a2:	d103      	bne.n	800c8ac <USBH_HandleEnum+0x208>
      {
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800c8a4:	687b      	ldr	r3, [r7, #4]
 800c8a6:	2204      	movs	r2, #4
 800c8a8:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c8aa:	e0cd      	b.n	800ca48 <USBH_HandleEnum+0x3a4>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c8ac:	7bbb      	ldrb	r3, [r7, #14]
 800c8ae:	2b03      	cmp	r3, #3
 800c8b0:	f040 80ca 	bne.w	800ca48 <USBH_HandleEnum+0x3a4>
        phost->device.EnumCnt++;
 800c8b4:	687b      	ldr	r3, [r7, #4]
 800c8b6:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c8ba:	3301      	adds	r3, #1
 800c8bc:	b2da      	uxtb	r2, r3
 800c8be:	687b      	ldr	r3, [r7, #4]
 800c8c0:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c8c4:	687b      	ldr	r3, [r7, #4]
 800c8c6:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c8ca:	2b03      	cmp	r3, #3
 800c8cc:	d903      	bls.n	800c8d6 <USBH_HandleEnum+0x232>
          phost->gState = HOST_ABORT_STATE;
 800c8ce:	687b      	ldr	r3, [r7, #4]
 800c8d0:	220d      	movs	r2, #13
 800c8d2:	701a      	strb	r2, [r3, #0]
      break;
 800c8d4:	e0b8      	b.n	800ca48 <USBH_HandleEnum+0x3a4>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c8d6:	687b      	ldr	r3, [r7, #4]
 800c8d8:	795b      	ldrb	r3, [r3, #5]
 800c8da:	4619      	mov	r1, r3
 800c8dc:	6878      	ldr	r0, [r7, #4]
 800c8de:	f001 f851 	bl	800d984 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c8e2:	687b      	ldr	r3, [r7, #4]
 800c8e4:	791b      	ldrb	r3, [r3, #4]
 800c8e6:	4619      	mov	r1, r3
 800c8e8:	6878      	ldr	r0, [r7, #4]
 800c8ea:	f001 f84b 	bl	800d984 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c8ee:	687b      	ldr	r3, [r7, #4]
 800c8f0:	2200      	movs	r2, #0
 800c8f2:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c8f4:	687b      	ldr	r3, [r7, #4]
 800c8f6:	2200      	movs	r2, #0
 800c8f8:	701a      	strb	r2, [r3, #0]
      break;
 800c8fa:	e0a5      	b.n	800ca48 <USBH_HandleEnum+0x3a4>

    case ENUM_GET_FULL_CFG_DESC:
      /* get FULL config descriptor (config, interface, endpoints) */
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800c8fc:	687b      	ldr	r3, [r7, #4]
 800c8fe:	f8b3 333a 	ldrh.w	r3, [r3, #826]	@ 0x33a
 800c902:	4619      	mov	r1, r3
 800c904:	6878      	ldr	r0, [r7, #4]
 800c906:	f000 f969 	bl	800cbdc <USBH_Get_CfgDesc>
 800c90a:	4603      	mov	r3, r0
 800c90c:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c90e:	7bbb      	ldrb	r3, [r7, #14]
 800c910:	2b00      	cmp	r3, #0
 800c912:	d103      	bne.n	800c91c <USBH_HandleEnum+0x278>
      {
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800c914:	687b      	ldr	r3, [r7, #4]
 800c916:	2205      	movs	r2, #5
 800c918:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c91a:	e097      	b.n	800ca4c <USBH_HandleEnum+0x3a8>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c91c:	7bbb      	ldrb	r3, [r7, #14]
 800c91e:	2b03      	cmp	r3, #3
 800c920:	f040 8094 	bne.w	800ca4c <USBH_HandleEnum+0x3a8>
        phost->device.EnumCnt++;
 800c924:	687b      	ldr	r3, [r7, #4]
 800c926:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c92a:	3301      	adds	r3, #1
 800c92c:	b2da      	uxtb	r2, r3
 800c92e:	687b      	ldr	r3, [r7, #4]
 800c930:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c934:	687b      	ldr	r3, [r7, #4]
 800c936:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c93a:	2b03      	cmp	r3, #3
 800c93c:	d903      	bls.n	800c946 <USBH_HandleEnum+0x2a2>
          phost->gState = HOST_ABORT_STATE;
 800c93e:	687b      	ldr	r3, [r7, #4]
 800c940:	220d      	movs	r2, #13
 800c942:	701a      	strb	r2, [r3, #0]
      break;
 800c944:	e082      	b.n	800ca4c <USBH_HandleEnum+0x3a8>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c946:	687b      	ldr	r3, [r7, #4]
 800c948:	795b      	ldrb	r3, [r3, #5]
 800c94a:	4619      	mov	r1, r3
 800c94c:	6878      	ldr	r0, [r7, #4]
 800c94e:	f001 f819 	bl	800d984 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c952:	687b      	ldr	r3, [r7, #4]
 800c954:	791b      	ldrb	r3, [r3, #4]
 800c956:	4619      	mov	r1, r3
 800c958:	6878      	ldr	r0, [r7, #4]
 800c95a:	f001 f813 	bl	800d984 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c95e:	687b      	ldr	r3, [r7, #4]
 800c960:	2200      	movs	r2, #0
 800c962:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c964:	687b      	ldr	r3, [r7, #4]
 800c966:	2200      	movs	r2, #0
 800c968:	701a      	strb	r2, [r3, #0]
      break;
 800c96a:	e06f      	b.n	800ca4c <USBH_HandleEnum+0x3a8>

    case ENUM_GET_MFC_STRING_DESC:
      if (phost->device.DevDesc.iManufacturer != 0U)
 800c96c:	687b      	ldr	r3, [r7, #4]
 800c96e:	f893 3334 	ldrb.w	r3, [r3, #820]	@ 0x334
 800c972:	2b00      	cmp	r3, #0
 800c974:	d019      	beq.n	800c9aa <USBH_HandleEnum+0x306>
      {
        /* Check that Manufacturer String is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800c976:	687b      	ldr	r3, [r7, #4]
 800c978:	f893 1334 	ldrb.w	r1, [r3, #820]	@ 0x334
                                        phost->device.Data, 0xFFU);
 800c97c:	687b      	ldr	r3, [r7, #4]
 800c97e:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800c982:	23ff      	movs	r3, #255	@ 0xff
 800c984:	6878      	ldr	r0, [r7, #4]
 800c986:	f000 f953 	bl	800cc30 <USBH_Get_StringDesc>
 800c98a:	4603      	mov	r3, r0
 800c98c:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800c98e:	7bbb      	ldrb	r3, [r7, #14]
 800c990:	2b00      	cmp	r3, #0
 800c992:	d103      	bne.n	800c99c <USBH_HandleEnum+0x2f8>
        {
          /* User callback for Manufacturing string */
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c994:	687b      	ldr	r3, [r7, #4]
 800c996:	2206      	movs	r2, #6
 800c998:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c99a:	e059      	b.n	800ca50 <USBH_HandleEnum+0x3ac>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c99c:	7bbb      	ldrb	r3, [r7, #14]
 800c99e:	2b03      	cmp	r3, #3
 800c9a0:	d156      	bne.n	800ca50 <USBH_HandleEnum+0x3ac>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c9a2:	687b      	ldr	r3, [r7, #4]
 800c9a4:	2206      	movs	r2, #6
 800c9a6:	705a      	strb	r2, [r3, #1]
      break;
 800c9a8:	e052      	b.n	800ca50 <USBH_HandleEnum+0x3ac>
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c9aa:	687b      	ldr	r3, [r7, #4]
 800c9ac:	2206      	movs	r2, #6
 800c9ae:	705a      	strb	r2, [r3, #1]
      break;
 800c9b0:	e04e      	b.n	800ca50 <USBH_HandleEnum+0x3ac>

    case ENUM_GET_PRODUCT_STRING_DESC:
      if (phost->device.DevDesc.iProduct != 0U)
 800c9b2:	687b      	ldr	r3, [r7, #4]
 800c9b4:	f893 3335 	ldrb.w	r3, [r3, #821]	@ 0x335
 800c9b8:	2b00      	cmp	r3, #0
 800c9ba:	d019      	beq.n	800c9f0 <USBH_HandleEnum+0x34c>
      {
        /* Check that Product string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800c9bc:	687b      	ldr	r3, [r7, #4]
 800c9be:	f893 1335 	ldrb.w	r1, [r3, #821]	@ 0x335
                                        phost->device.Data, 0xFFU);
 800c9c2:	687b      	ldr	r3, [r7, #4]
 800c9c4:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800c9c8:	23ff      	movs	r3, #255	@ 0xff
 800c9ca:	6878      	ldr	r0, [r7, #4]
 800c9cc:	f000 f930 	bl	800cc30 <USBH_Get_StringDesc>
 800c9d0:	4603      	mov	r3, r0
 800c9d2:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800c9d4:	7bbb      	ldrb	r3, [r7, #14]
 800c9d6:	2b00      	cmp	r3, #0
 800c9d8:	d103      	bne.n	800c9e2 <USBH_HandleEnum+0x33e>
        {
          /* User callback for Product string */
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c9da:	687b      	ldr	r3, [r7, #4]
 800c9dc:	2207      	movs	r2, #7
 800c9de:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c9e0:	e038      	b.n	800ca54 <USBH_HandleEnum+0x3b0>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c9e2:	7bbb      	ldrb	r3, [r7, #14]
 800c9e4:	2b03      	cmp	r3, #3
 800c9e6:	d135      	bne.n	800ca54 <USBH_HandleEnum+0x3b0>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c9e8:	687b      	ldr	r3, [r7, #4]
 800c9ea:	2207      	movs	r2, #7
 800c9ec:	705a      	strb	r2, [r3, #1]
      break;
 800c9ee:	e031      	b.n	800ca54 <USBH_HandleEnum+0x3b0>
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c9f0:	687b      	ldr	r3, [r7, #4]
 800c9f2:	2207      	movs	r2, #7
 800c9f4:	705a      	strb	r2, [r3, #1]
      break;
 800c9f6:	e02d      	b.n	800ca54 <USBH_HandleEnum+0x3b0>

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 800c9f8:	687b      	ldr	r3, [r7, #4]
 800c9fa:	f893 3336 	ldrb.w	r3, [r3, #822]	@ 0x336
 800c9fe:	2b00      	cmp	r3, #0
 800ca00:	d017      	beq.n	800ca32 <USBH_HandleEnum+0x38e>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800ca02:	687b      	ldr	r3, [r7, #4]
 800ca04:	f893 1336 	ldrb.w	r1, [r3, #822]	@ 0x336
                                        phost->device.Data, 0xFFU);
 800ca08:	687b      	ldr	r3, [r7, #4]
 800ca0a:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800ca0e:	23ff      	movs	r3, #255	@ 0xff
 800ca10:	6878      	ldr	r0, [r7, #4]
 800ca12:	f000 f90d 	bl	800cc30 <USBH_Get_StringDesc>
 800ca16:	4603      	mov	r3, r0
 800ca18:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800ca1a:	7bbb      	ldrb	r3, [r7, #14]
 800ca1c:	2b00      	cmp	r3, #0
 800ca1e:	d102      	bne.n	800ca26 <USBH_HandleEnum+0x382>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
 800ca20:	2300      	movs	r3, #0
 800ca22:	73fb      	strb	r3, [r7, #15]
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
      }
      break;
 800ca24:	e018      	b.n	800ca58 <USBH_HandleEnum+0x3b4>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800ca26:	7bbb      	ldrb	r3, [r7, #14]
 800ca28:	2b03      	cmp	r3, #3
 800ca2a:	d115      	bne.n	800ca58 <USBH_HandleEnum+0x3b4>
          Status = USBH_OK;
 800ca2c:	2300      	movs	r3, #0
 800ca2e:	73fb      	strb	r3, [r7, #15]
      break;
 800ca30:	e012      	b.n	800ca58 <USBH_HandleEnum+0x3b4>
        Status = USBH_OK;
 800ca32:	2300      	movs	r3, #0
 800ca34:	73fb      	strb	r3, [r7, #15]
      break;
 800ca36:	e00f      	b.n	800ca58 <USBH_HandleEnum+0x3b4>

    default:
      break;
 800ca38:	bf00      	nop
 800ca3a:	e00e      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca3c:	bf00      	nop
 800ca3e:	e00c      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca40:	bf00      	nop
 800ca42:	e00a      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca44:	bf00      	nop
 800ca46:	e008      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca48:	bf00      	nop
 800ca4a:	e006      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca4c:	bf00      	nop
 800ca4e:	e004      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca50:	bf00      	nop
 800ca52:	e002      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca54:	bf00      	nop
 800ca56:	e000      	b.n	800ca5a <USBH_HandleEnum+0x3b6>
      break;
 800ca58:	bf00      	nop
  }
  return Status;
 800ca5a:	7bfb      	ldrb	r3, [r7, #15]
}
 800ca5c:	4618      	mov	r0, r3
 800ca5e:	3710      	adds	r7, #16
 800ca60:	46bd      	mov	sp, r7
 800ca62:	bd80      	pop	{r7, pc}

0800ca64 <USBH_LL_SetTimer>:
  *         Set the initial Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
 800ca64:	b480      	push	{r7}
 800ca66:	b083      	sub	sp, #12
 800ca68:	af00      	add	r7, sp, #0
 800ca6a:	6078      	str	r0, [r7, #4]
 800ca6c:	6039      	str	r1, [r7, #0]
  phost->Timer = time;
 800ca6e:	687b      	ldr	r3, [r7, #4]
 800ca70:	683a      	ldr	r2, [r7, #0]
 800ca72:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4
}
 800ca76:	bf00      	nop
 800ca78:	370c      	adds	r7, #12
 800ca7a:	46bd      	mov	sp, r7
 800ca7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca80:	4770      	bx	lr

0800ca82 <USBH_LL_IncTimer>:
  *         Increment Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
 800ca82:	b580      	push	{r7, lr}
 800ca84:	b082      	sub	sp, #8
 800ca86:	af00      	add	r7, sp, #0
 800ca88:	6078      	str	r0, [r7, #4]
  phost->Timer++;
 800ca8a:	687b      	ldr	r3, [r7, #4]
 800ca8c:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800ca90:	1c5a      	adds	r2, r3, #1
 800ca92:	687b      	ldr	r3, [r7, #4]
 800ca94:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4
  USBH_HandleSof(phost);
 800ca98:	6878      	ldr	r0, [r7, #4]
 800ca9a:	f000 f804 	bl	800caa6 <USBH_HandleSof>
}
 800ca9e:	bf00      	nop
 800caa0:	3708      	adds	r7, #8
 800caa2:	46bd      	mov	sp, r7
 800caa4:	bd80      	pop	{r7, pc}

0800caa6 <USBH_HandleSof>:
  *         Call SOF process
  * @param  phost: Host Handle
  * @retval None
  */
static void USBH_HandleSof(USBH_HandleTypeDef *phost)
{
 800caa6:	b580      	push	{r7, lr}
 800caa8:	b082      	sub	sp, #8
 800caaa:	af00      	add	r7, sp, #0
 800caac:	6078      	str	r0, [r7, #4]
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800caae:	687b      	ldr	r3, [r7, #4]
 800cab0:	781b      	ldrb	r3, [r3, #0]
 800cab2:	b2db      	uxtb	r3, r3
 800cab4:	2b0b      	cmp	r3, #11
 800cab6:	d10a      	bne.n	800cace <USBH_HandleSof+0x28>
 800cab8:	687b      	ldr	r3, [r7, #4]
 800caba:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800cabe:	2b00      	cmp	r3, #0
 800cac0:	d005      	beq.n	800cace <USBH_HandleSof+0x28>
  {
    phost->pActiveClass->SOFProcess(phost);
 800cac2:	687b      	ldr	r3, [r7, #4]
 800cac4:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800cac8:	699b      	ldr	r3, [r3, #24]
 800caca:	6878      	ldr	r0, [r7, #4]
 800cacc:	4798      	blx	r3
  }
}
 800cace:	bf00      	nop
 800cad0:	3708      	adds	r7, #8
 800cad2:	46bd      	mov	sp, r7
 800cad4:	bd80      	pop	{r7, pc}

0800cad6 <USBH_LL_PortEnabled>:
  *         Port Enabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
 800cad6:	b480      	push	{r7}
 800cad8:	b083      	sub	sp, #12
 800cada:	af00      	add	r7, sp, #0
 800cadc:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 1U;
 800cade:	687b      	ldr	r3, [r7, #4]
 800cae0:	2201      	movs	r2, #1
 800cae2:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return;
 800cae6:	bf00      	nop
}
 800cae8:	370c      	adds	r7, #12
 800caea:	46bd      	mov	sp, r7
 800caec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800caf0:	4770      	bx	lr

0800caf2 <USBH_LL_PortDisabled>:
  *         Port Disabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
 800caf2:	b480      	push	{r7}
 800caf4:	b083      	sub	sp, #12
 800caf6:	af00      	add	r7, sp, #0
 800caf8:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 0U;
 800cafa:	687b      	ldr	r3, [r7, #4]
 800cafc:	2200      	movs	r2, #0
 800cafe:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323

  return;
 800cb02:	bf00      	nop
}
 800cb04:	370c      	adds	r7, #12
 800cb06:	46bd      	mov	sp, r7
 800cb08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb0c:	4770      	bx	lr

0800cb0e <USBH_LL_Connect>:
  *         Handle USB Host connection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 800cb0e:	b480      	push	{r7}
 800cb10:	b083      	sub	sp, #12
 800cb12:	af00      	add	r7, sp, #0
 800cb14:	6078      	str	r0, [r7, #4]
  phost->device.is_connected = 1U;
 800cb16:	687b      	ldr	r3, [r7, #4]
 800cb18:	2201      	movs	r2, #1
 800cb1a:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.is_disconnected = 0U;
 800cb1e:	687b      	ldr	r3, [r7, #4]
 800cb20:	2200      	movs	r2, #0
 800cb22:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_ReEnumerated = 0U;
 800cb26:	687b      	ldr	r3, [r7, #4]
 800cb28:	2200      	movs	r2, #0
 800cb2a:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
 800cb2e:	2300      	movs	r3, #0
}
 800cb30:	4618      	mov	r0, r3
 800cb32:	370c      	adds	r7, #12
 800cb34:	46bd      	mov	sp, r7
 800cb36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb3a:	4770      	bx	lr

0800cb3c <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 800cb3c:	b580      	push	{r7, lr}
 800cb3e:	b082      	sub	sp, #8
 800cb40:	af00      	add	r7, sp, #0
 800cb42:	6078      	str	r0, [r7, #4]
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 800cb44:	687b      	ldr	r3, [r7, #4]
 800cb46:	2201      	movs	r2, #1
 800cb48:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_connected = 0U;
 800cb4c:	687b      	ldr	r3, [r7, #4]
 800cb4e:	2200      	movs	r2, #0
 800cb50:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.PortEnabled = 0U;
 800cb54:	687b      	ldr	r3, [r7, #4]
 800cb56:	2200      	movs	r2, #0
 800cb58:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323

  /* Stop Host */
  (void)USBH_LL_Stop(phost);
 800cb5c:	6878      	ldr	r0, [r7, #4]
 800cb5e:	f020 fa80 	bl	802d062 <USBH_LL_Stop>

  /* FRee Control Pipes */
  (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800cb62:	687b      	ldr	r3, [r7, #4]
 800cb64:	791b      	ldrb	r3, [r3, #4]
 800cb66:	4619      	mov	r1, r3
 800cb68:	6878      	ldr	r0, [r7, #4]
 800cb6a:	f000 ff0b 	bl	800d984 <USBH_FreePipe>
  (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800cb6e:	687b      	ldr	r3, [r7, #4]
 800cb70:	795b      	ldrb	r3, [r3, #5]
 800cb72:	4619      	mov	r1, r3
 800cb74:	6878      	ldr	r0, [r7, #4]
 800cb76:	f000 ff05 	bl	800d984 <USBH_FreePipe>
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
 800cb7a:	2300      	movs	r3, #0
}
 800cb7c:	4618      	mov	r0, r3
 800cb7e:	3708      	adds	r7, #8
 800cb80:	46bd      	mov	sp, r7
 800cb82:	bd80      	pop	{r7, pc}

0800cb84 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint16_t length)
{
 800cb84:	b580      	push	{r7, lr}
 800cb86:	b086      	sub	sp, #24
 800cb88:	af02      	add	r7, sp, #8
 800cb8a:	6078      	str	r0, [r7, #4]
 800cb8c:	460b      	mov	r3, r1
 800cb8e:	807b      	strh	r3, [r7, #2]
  USBH_StatusTypeDef status;

  if (length > sizeof(phost->device.Data))
 800cb90:	887b      	ldrh	r3, [r7, #2]
 800cb92:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800cb96:	d901      	bls.n	800cb9c <USBH_Get_DevDesc+0x18>
  {
    USBH_ErrLog("Control error: Get Device Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800cb98:	2303      	movs	r3, #3
 800cb9a:	e01b      	b.n	800cbd4 <USBH_Get_DevDesc+0x50>
  }

  status = USBH_GetDescriptor(phost,
                              USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                              USB_DESC_DEVICE, phost->device.Data, length);
 800cb9c:	687b      	ldr	r3, [r7, #4]
 800cb9e:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
  status = USBH_GetDescriptor(phost,
 800cba2:	887b      	ldrh	r3, [r7, #2]
 800cba4:	9300      	str	r3, [sp, #0]
 800cba6:	4613      	mov	r3, r2
 800cba8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800cbac:	2100      	movs	r1, #0
 800cbae:	6878      	ldr	r0, [r7, #4]
 800cbb0:	f000 f872 	bl	800cc98 <USBH_GetDescriptor>
 800cbb4:	4603      	mov	r3, r0
 800cbb6:	73fb      	strb	r3, [r7, #15]

  if (status == USBH_OK)
 800cbb8:	7bfb      	ldrb	r3, [r7, #15]
 800cbba:	2b00      	cmp	r3, #0
 800cbbc:	d109      	bne.n	800cbd2 <USBH_Get_DevDesc+0x4e>
  {
    /* Commands successfully sent and Response Received */
    status = USBH_ParseDevDesc(phost, phost->device.Data, length);
 800cbbe:	687b      	ldr	r3, [r7, #4]
 800cbc0:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800cbc4:	887a      	ldrh	r2, [r7, #2]
 800cbc6:	4619      	mov	r1, r3
 800cbc8:	6878      	ldr	r0, [r7, #4]
 800cbca:	f000 f929 	bl	800ce20 <USBH_ParseDevDesc>
 800cbce:	4603      	mov	r3, r0
 800cbd0:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800cbd2:	7bfb      	ldrb	r3, [r7, #15]
}
 800cbd4:	4618      	mov	r0, r3
 800cbd6:	3710      	adds	r7, #16
 800cbd8:	46bd      	mov	sp, r7
 800cbda:	bd80      	pop	{r7, pc}

0800cbdc <USBH_Get_CfgDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_CfgDesc(USBH_HandleTypeDef *phost, uint16_t length)
{
 800cbdc:	b580      	push	{r7, lr}
 800cbde:	b086      	sub	sp, #24
 800cbe0:	af02      	add	r7, sp, #8
 800cbe2:	6078      	str	r0, [r7, #4]
 800cbe4:	460b      	mov	r3, r1
 800cbe6:	807b      	strh	r3, [r7, #2]
  USBH_StatusTypeDef status;
  uint8_t *pData = phost->device.CfgDesc_Raw;
 800cbe8:	687b      	ldr	r3, [r7, #4]
 800cbea:	331c      	adds	r3, #28
 800cbec:	60bb      	str	r3, [r7, #8]

  if (length > sizeof(phost->device.CfgDesc_Raw))
 800cbee:	887b      	ldrh	r3, [r7, #2]
 800cbf0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cbf4:	d901      	bls.n	800cbfa <USBH_Get_CfgDesc+0x1e>
  {
    USBH_ErrLog("Control error: Get configuration Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800cbf6:	2303      	movs	r3, #3
 800cbf8:	e016      	b.n	800cc28 <USBH_Get_CfgDesc+0x4c>
  }

  status = USBH_GetDescriptor(phost, (USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD),
 800cbfa:	887b      	ldrh	r3, [r7, #2]
 800cbfc:	9300      	str	r3, [sp, #0]
 800cbfe:	68bb      	ldr	r3, [r7, #8]
 800cc00:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800cc04:	2100      	movs	r1, #0
 800cc06:	6878      	ldr	r0, [r7, #4]
 800cc08:	f000 f846 	bl	800cc98 <USBH_GetDescriptor>
 800cc0c:	4603      	mov	r3, r0
 800cc0e:	73fb      	strb	r3, [r7, #15]
                              USB_DESC_CONFIGURATION, pData, length);

  if (status == USBH_OK)
 800cc10:	7bfb      	ldrb	r3, [r7, #15]
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d107      	bne.n	800cc26 <USBH_Get_CfgDesc+0x4a>
  {
    /* Commands successfully sent and Response Received  */
    status = USBH_ParseCfgDesc(phost, pData, length);
 800cc16:	887b      	ldrh	r3, [r7, #2]
 800cc18:	461a      	mov	r2, r3
 800cc1a:	68b9      	ldr	r1, [r7, #8]
 800cc1c:	6878      	ldr	r0, [r7, #4]
 800cc1e:	f000 f9af 	bl	800cf80 <USBH_ParseCfgDesc>
 800cc22:	4603      	mov	r3, r0
 800cc24:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800cc26:	7bfb      	ldrb	r3, [r7, #15]
}
 800cc28:	4618      	mov	r0, r3
 800cc2a:	3710      	adds	r7, #16
 800cc2c:	46bd      	mov	sp, r7
 800cc2e:	bd80      	pop	{r7, pc}

0800cc30 <USBH_Get_StringDesc>:
  * @param  buff: Buffer address for the descriptor
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_StringDesc(USBH_HandleTypeDef *phost, uint8_t string_index, uint8_t *buff, uint16_t length)
{
 800cc30:	b580      	push	{r7, lr}
 800cc32:	b088      	sub	sp, #32
 800cc34:	af02      	add	r7, sp, #8
 800cc36:	60f8      	str	r0, [r7, #12]
 800cc38:	607a      	str	r2, [r7, #4]
 800cc3a:	461a      	mov	r2, r3
 800cc3c:	460b      	mov	r3, r1
 800cc3e:	72fb      	strb	r3, [r7, #11]
 800cc40:	4613      	mov	r3, r2
 800cc42:	813b      	strh	r3, [r7, #8]
  USBH_StatusTypeDef status;

  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 800cc44:	893b      	ldrh	r3, [r7, #8]
 800cc46:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800cc4a:	d802      	bhi.n	800cc52 <USBH_Get_StringDesc+0x22>
 800cc4c:	687b      	ldr	r3, [r7, #4]
 800cc4e:	2b00      	cmp	r3, #0
 800cc50:	d101      	bne.n	800cc56 <USBH_Get_StringDesc+0x26>
  {
    USBH_ErrLog("Control error: Get String Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800cc52:	2303      	movs	r3, #3
 800cc54:	e01c      	b.n	800cc90 <USBH_Get_StringDesc+0x60>
  }

  status = USBH_GetDescriptor(phost,
 800cc56:	7afb      	ldrb	r3, [r7, #11]
 800cc58:	b29b      	uxth	r3, r3
 800cc5a:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
 800cc5e:	b29a      	uxth	r2, r3
                              USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                              USB_DESC_STRING | string_index,
                              phost->device.Data, length);
 800cc60:	68fb      	ldr	r3, [r7, #12]
 800cc62:	f503 718e 	add.w	r1, r3, #284	@ 0x11c
  status = USBH_GetDescriptor(phost,
 800cc66:	893b      	ldrh	r3, [r7, #8]
 800cc68:	9300      	str	r3, [sp, #0]
 800cc6a:	460b      	mov	r3, r1
 800cc6c:	2100      	movs	r1, #0
 800cc6e:	68f8      	ldr	r0, [r7, #12]
 800cc70:	f000 f812 	bl	800cc98 <USBH_GetDescriptor>
 800cc74:	4603      	mov	r3, r0
 800cc76:	75fb      	strb	r3, [r7, #23]

  if (status == USBH_OK)
 800cc78:	7dfb      	ldrb	r3, [r7, #23]
 800cc7a:	2b00      	cmp	r3, #0
 800cc7c:	d107      	bne.n	800cc8e <USBH_Get_StringDesc+0x5e>
  {
    /* Commands successfully sent and Response Received */
    USBH_ParseStringDesc(phost->device.Data, buff, length);
 800cc7e:	68fb      	ldr	r3, [r7, #12]
 800cc80:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800cc84:	893a      	ldrh	r2, [r7, #8]
 800cc86:	6879      	ldr	r1, [r7, #4]
 800cc88:	4618      	mov	r0, r3
 800cc8a:	f000 fb8d 	bl	800d3a8 <USBH_ParseStringDesc>
  }

  return status;
 800cc8e:	7dfb      	ldrb	r3, [r7, #23]
}
 800cc90:	4618      	mov	r0, r3
 800cc92:	3718      	adds	r7, #24
 800cc94:	46bd      	mov	sp, r7
 800cc96:	bd80      	pop	{r7, pc}

0800cc98 <USBH_GetDescriptor>:
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_GetDescriptor(USBH_HandleTypeDef *phost, uint8_t req_type, uint16_t value_idx,
                                      uint8_t *buff, uint16_t length)
{
 800cc98:	b580      	push	{r7, lr}
 800cc9a:	b084      	sub	sp, #16
 800cc9c:	af00      	add	r7, sp, #0
 800cc9e:	60f8      	str	r0, [r7, #12]
 800cca0:	607b      	str	r3, [r7, #4]
 800cca2:	460b      	mov	r3, r1
 800cca4:	72fb      	strb	r3, [r7, #11]
 800cca6:	4613      	mov	r3, r2
 800cca8:	813b      	strh	r3, [r7, #8]
  if (phost->RequestState == CMD_SEND)
 800ccaa:	68fb      	ldr	r3, [r7, #12]
 800ccac:	789b      	ldrb	r3, [r3, #2]
 800ccae:	2b01      	cmp	r3, #1
 800ccb0:	d11c      	bne.n	800ccec <USBH_GetDescriptor+0x54>
  {
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800ccb2:	7afb      	ldrb	r3, [r7, #11]
 800ccb4:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 800ccb8:	b2da      	uxtb	r2, r3
 800ccba:	68fb      	ldr	r3, [r7, #12]
 800ccbc:	741a      	strb	r2, [r3, #16]
    phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 800ccbe:	68fb      	ldr	r3, [r7, #12]
 800ccc0:	2206      	movs	r2, #6
 800ccc2:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = value_idx;
 800ccc4:	68fb      	ldr	r3, [r7, #12]
 800ccc6:	893a      	ldrh	r2, [r7, #8]
 800ccc8:	825a      	strh	r2, [r3, #18]

    if ((value_idx & 0xff00U) == USB_DESC_STRING)
 800ccca:	893b      	ldrh	r3, [r7, #8]
 800cccc:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
 800ccd0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800ccd4:	d104      	bne.n	800cce0 <USBH_GetDescriptor+0x48>
    {
      phost->Control.setup.b.wIndex.w = 0x0409U;
 800ccd6:	68fb      	ldr	r3, [r7, #12]
 800ccd8:	f240 4209 	movw	r2, #1033	@ 0x409
 800ccdc:	829a      	strh	r2, [r3, #20]
 800ccde:	e002      	b.n	800cce6 <USBH_GetDescriptor+0x4e>
    }
    else
    {
      phost->Control.setup.b.wIndex.w = 0U;
 800cce0:	68fb      	ldr	r3, [r7, #12]
 800cce2:	2200      	movs	r2, #0
 800cce4:	829a      	strh	r2, [r3, #20]
    }
    phost->Control.setup.b.wLength.w = length;
 800cce6:	68fb      	ldr	r3, [r7, #12]
 800cce8:	8b3a      	ldrh	r2, [r7, #24]
 800ccea:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, buff, length);
 800ccec:	8b3b      	ldrh	r3, [r7, #24]
 800ccee:	461a      	mov	r2, r3
 800ccf0:	6879      	ldr	r1, [r7, #4]
 800ccf2:	68f8      	ldr	r0, [r7, #12]
 800ccf4:	f000 fba5 	bl	800d442 <USBH_CtlReq>
 800ccf8:	4603      	mov	r3, r0
}
 800ccfa:	4618      	mov	r0, r3
 800ccfc:	3710      	adds	r7, #16
 800ccfe:	46bd      	mov	sp, r7
 800cd00:	bd80      	pop	{r7, pc}

0800cd02 <USBH_SetAddress>:
  * @param  DeviceAddress: Device address to assign
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetAddress(USBH_HandleTypeDef *phost,
                                   uint8_t DeviceAddress)
{
 800cd02:	b580      	push	{r7, lr}
 800cd04:	b082      	sub	sp, #8
 800cd06:	af00      	add	r7, sp, #0
 800cd08:	6078      	str	r0, [r7, #4]
 800cd0a:	460b      	mov	r3, r1
 800cd0c:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cd0e:	687b      	ldr	r3, [r7, #4]
 800cd10:	789b      	ldrb	r3, [r3, #2]
 800cd12:	2b01      	cmp	r3, #1
 800cd14:	d10f      	bne.n	800cd36 <USBH_SetAddress+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 800cd16:	687b      	ldr	r3, [r7, #4]
 800cd18:	2200      	movs	r2, #0
 800cd1a:	741a      	strb	r2, [r3, #16]
                                           USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 800cd1c:	687b      	ldr	r3, [r7, #4]
 800cd1e:	2205      	movs	r2, #5
 800cd20:	745a      	strb	r2, [r3, #17]

    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 800cd22:	78fb      	ldrb	r3, [r7, #3]
 800cd24:	b29a      	uxth	r2, r3
 800cd26:	687b      	ldr	r3, [r7, #4]
 800cd28:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cd2a:	687b      	ldr	r3, [r7, #4]
 800cd2c:	2200      	movs	r2, #0
 800cd2e:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cd30:	687b      	ldr	r3, [r7, #4]
 800cd32:	2200      	movs	r2, #0
 800cd34:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cd36:	2200      	movs	r2, #0
 800cd38:	2100      	movs	r1, #0
 800cd3a:	6878      	ldr	r0, [r7, #4]
 800cd3c:	f000 fb81 	bl	800d442 <USBH_CtlReq>
 800cd40:	4603      	mov	r3, r0
}
 800cd42:	4618      	mov	r0, r3
 800cd44:	3708      	adds	r7, #8
 800cd46:	46bd      	mov	sp, r7
 800cd48:	bd80      	pop	{r7, pc}

0800cd4a <USBH_SetCfg>:
  * @param  phost: Host Handle
  * @param  cfg_idx: Configuration value
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetCfg(USBH_HandleTypeDef *phost, uint16_t cfg_idx)
{
 800cd4a:	b580      	push	{r7, lr}
 800cd4c:	b082      	sub	sp, #8
 800cd4e:	af00      	add	r7, sp, #0
 800cd50:	6078      	str	r0, [r7, #4]
 800cd52:	460b      	mov	r3, r1
 800cd54:	807b      	strh	r3, [r7, #2]
  if (phost->RequestState == CMD_SEND)
 800cd56:	687b      	ldr	r3, [r7, #4]
 800cd58:	789b      	ldrb	r3, [r3, #2]
 800cd5a:	2b01      	cmp	r3, #1
 800cd5c:	d10e      	bne.n	800cd7c <USBH_SetCfg+0x32>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800cd5e:	687b      	ldr	r3, [r7, #4]
 800cd60:	2200      	movs	r2, #0
 800cd62:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 800cd64:	687b      	ldr	r3, [r7, #4]
 800cd66:	2209      	movs	r2, #9
 800cd68:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = cfg_idx;
 800cd6a:	687b      	ldr	r3, [r7, #4]
 800cd6c:	887a      	ldrh	r2, [r7, #2]
 800cd6e:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cd70:	687b      	ldr	r3, [r7, #4]
 800cd72:	2200      	movs	r2, #0
 800cd74:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cd76:	687b      	ldr	r3, [r7, #4]
 800cd78:	2200      	movs	r2, #0
 800cd7a:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cd7c:	2200      	movs	r2, #0
 800cd7e:	2100      	movs	r1, #0
 800cd80:	6878      	ldr	r0, [r7, #4]
 800cd82:	f000 fb5e 	bl	800d442 <USBH_CtlReq>
 800cd86:	4603      	mov	r3, r0
}
 800cd88:	4618      	mov	r0, r3
 800cd8a:	3708      	adds	r7, #8
 800cd8c:	46bd      	mov	sp, r7
 800cd8e:	bd80      	pop	{r7, pc}

0800cd90 <USBH_SetFeature>:
  * @param  pdev: Selected device
  * @param  itf_idx
  * @retval Status
  */
USBH_StatusTypeDef USBH_SetFeature(USBH_HandleTypeDef *phost, uint8_t wValue)
{
 800cd90:	b580      	push	{r7, lr}
 800cd92:	b082      	sub	sp, #8
 800cd94:	af00      	add	r7, sp, #0
 800cd96:	6078      	str	r0, [r7, #4]
 800cd98:	460b      	mov	r3, r1
 800cd9a:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cd9c:	687b      	ldr	r3, [r7, #4]
 800cd9e:	789b      	ldrb	r3, [r3, #2]
 800cda0:	2b01      	cmp	r3, #1
 800cda2:	d10f      	bne.n	800cdc4 <USBH_SetFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800cda4:	687b      	ldr	r3, [r7, #4]
 800cda6:	2200      	movs	r2, #0
 800cda8:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_FEATURE;
 800cdaa:	687b      	ldr	r3, [r7, #4]
 800cdac:	2203      	movs	r2, #3
 800cdae:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = wValue;
 800cdb0:	78fb      	ldrb	r3, [r7, #3]
 800cdb2:	b29a      	uxth	r2, r3
 800cdb4:	687b      	ldr	r3, [r7, #4]
 800cdb6:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cdb8:	687b      	ldr	r3, [r7, #4]
 800cdba:	2200      	movs	r2, #0
 800cdbc:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cdbe:	687b      	ldr	r3, [r7, #4]
 800cdc0:	2200      	movs	r2, #0
 800cdc2:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cdc4:	2200      	movs	r2, #0
 800cdc6:	2100      	movs	r1, #0
 800cdc8:	6878      	ldr	r0, [r7, #4]
 800cdca:	f000 fb3a 	bl	800d442 <USBH_CtlReq>
 800cdce:	4603      	mov	r3, r0
}
 800cdd0:	4618      	mov	r0, r3
 800cdd2:	3708      	adds	r7, #8
 800cdd4:	46bd      	mov	sp, r7
 800cdd6:	bd80      	pop	{r7, pc}

0800cdd8 <USBH_ClrFeature>:
  * @param  ep_num: endpoint number
  * @param  hc_num: Host channel number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClrFeature(USBH_HandleTypeDef *phost, uint8_t ep_num)
{
 800cdd8:	b580      	push	{r7, lr}
 800cdda:	b082      	sub	sp, #8
 800cddc:	af00      	add	r7, sp, #0
 800cdde:	6078      	str	r0, [r7, #4]
 800cde0:	460b      	mov	r3, r1
 800cde2:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cde4:	687b      	ldr	r3, [r7, #4]
 800cde6:	789b      	ldrb	r3, [r3, #2]
 800cde8:	2b01      	cmp	r3, #1
 800cdea:	d10f      	bne.n	800ce0c <USBH_ClrFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 800cdec:	687b      	ldr	r3, [r7, #4]
 800cdee:	2202      	movs	r2, #2
 800cdf0:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 800cdf2:	687b      	ldr	r3, [r7, #4]
 800cdf4:	2201      	movs	r2, #1
 800cdf6:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 800cdf8:	687b      	ldr	r3, [r7, #4]
 800cdfa:	2200      	movs	r2, #0
 800cdfc:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = ep_num;
 800cdfe:	78fb      	ldrb	r3, [r7, #3]
 800ce00:	b29a      	uxth	r2, r3
 800ce02:	687b      	ldr	r3, [r7, #4]
 800ce04:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800ce06:	687b      	ldr	r3, [r7, #4]
 800ce08:	2200      	movs	r2, #0
 800ce0a:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800ce0c:	2200      	movs	r2, #0
 800ce0e:	2100      	movs	r1, #0
 800ce10:	6878      	ldr	r0, [r7, #4]
 800ce12:	f000 fb16 	bl	800d442 <USBH_CtlReq>
 800ce16:	4603      	mov	r3, r0
}
 800ce18:	4618      	mov	r0, r3
 800ce1a:	3708      	adds	r7, #8
 800ce1c:	46bd      	mov	sp, r7
 800ce1e:	bd80      	pop	{r7, pc}

0800ce20 <USBH_ParseDevDesc>:
  * @param  buf: Buffer where the source descriptor is available
  * @param  length: Length of the descriptor
  * @retval USBH status
  */
static USBH_StatusTypeDef USBH_ParseDevDesc(USBH_HandleTypeDef *phost, uint8_t *buf, uint16_t length)
{
 800ce20:	b480      	push	{r7}
 800ce22:	b087      	sub	sp, #28
 800ce24:	af00      	add	r7, sp, #0
 800ce26:	60f8      	str	r0, [r7, #12]
 800ce28:	60b9      	str	r1, [r7, #8]
 800ce2a:	4613      	mov	r3, r2
 800ce2c:	80fb      	strh	r3, [r7, #6]
  USBH_DevDescTypeDef *dev_desc = &phost->device.DevDesc;
 800ce2e:	68fb      	ldr	r3, [r7, #12]
 800ce30:	f203 3326 	addw	r3, r3, #806	@ 0x326
 800ce34:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef status = USBH_OK;
 800ce36:	2300      	movs	r3, #0
 800ce38:	75fb      	strb	r3, [r7, #23]

  if (buf == NULL)
 800ce3a:	68bb      	ldr	r3, [r7, #8]
 800ce3c:	2b00      	cmp	r3, #0
 800ce3e:	d101      	bne.n	800ce44 <USBH_ParseDevDesc+0x24>
  {
    return USBH_FAIL;
 800ce40:	2302      	movs	r3, #2
 800ce42:	e094      	b.n	800cf6e <USBH_ParseDevDesc+0x14e>
  }

  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 800ce44:	68bb      	ldr	r3, [r7, #8]
 800ce46:	781a      	ldrb	r2, [r3, #0]
 800ce48:	693b      	ldr	r3, [r7, #16]
 800ce4a:	701a      	strb	r2, [r3, #0]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1U);
 800ce4c:	68bb      	ldr	r3, [r7, #8]
 800ce4e:	785a      	ldrb	r2, [r3, #1]
 800ce50:	693b      	ldr	r3, [r7, #16]
 800ce52:	705a      	strb	r2, [r3, #1]
  dev_desc->bcdUSB             = LE16(buf +  2U);
 800ce54:	68bb      	ldr	r3, [r7, #8]
 800ce56:	3302      	adds	r3, #2
 800ce58:	781b      	ldrb	r3, [r3, #0]
 800ce5a:	461a      	mov	r2, r3
 800ce5c:	68bb      	ldr	r3, [r7, #8]
 800ce5e:	3303      	adds	r3, #3
 800ce60:	781b      	ldrb	r3, [r3, #0]
 800ce62:	021b      	lsls	r3, r3, #8
 800ce64:	b29b      	uxth	r3, r3
 800ce66:	4313      	orrs	r3, r2
 800ce68:	b29a      	uxth	r2, r3
 800ce6a:	693b      	ldr	r3, [r7, #16]
 800ce6c:	805a      	strh	r2, [r3, #2]
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 800ce6e:	68bb      	ldr	r3, [r7, #8]
 800ce70:	791a      	ldrb	r2, [r3, #4]
 800ce72:	693b      	ldr	r3, [r7, #16]
 800ce74:	711a      	strb	r2, [r3, #4]
  dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5U);
 800ce76:	68bb      	ldr	r3, [r7, #8]
 800ce78:	795a      	ldrb	r2, [r3, #5]
 800ce7a:	693b      	ldr	r3, [r7, #16]
 800ce7c:	715a      	strb	r2, [r3, #5]
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6U);
 800ce7e:	68bb      	ldr	r3, [r7, #8]
 800ce80:	799a      	ldrb	r2, [r3, #6]
 800ce82:	693b      	ldr	r3, [r7, #16]
 800ce84:	719a      	strb	r2, [r3, #6]
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7U);
 800ce86:	68bb      	ldr	r3, [r7, #8]
 800ce88:	79da      	ldrb	r2, [r3, #7]
 800ce8a:	693b      	ldr	r3, [r7, #16]
 800ce8c:	71da      	strb	r2, [r3, #7]

  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800ce8e:	68fb      	ldr	r3, [r7, #12]
 800ce90:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800ce94:	2b00      	cmp	r3, #0
 800ce96:	d004      	beq.n	800cea2 <USBH_ParseDevDesc+0x82>
      (phost->device.speed == (uint8_t)USBH_SPEED_FULL))
 800ce98:	68fb      	ldr	r3, [r7, #12]
 800ce9a:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800ce9e:	2b01      	cmp	r3, #1
 800cea0:	d11b      	bne.n	800ceda <USBH_ParseDevDesc+0xba>
  {
    /* Make sure that the max packet size is either 8, 16, 32, 64 or force it to minimum allowed value */
    switch (dev_desc->bMaxPacketSize)
 800cea2:	693b      	ldr	r3, [r7, #16]
 800cea4:	79db      	ldrb	r3, [r3, #7]
 800cea6:	2b20      	cmp	r3, #32
 800cea8:	dc0f      	bgt.n	800ceca <USBH_ParseDevDesc+0xaa>
 800ceaa:	2b08      	cmp	r3, #8
 800ceac:	db0f      	blt.n	800cece <USBH_ParseDevDesc+0xae>
 800ceae:	3b08      	subs	r3, #8
 800ceb0:	4a32      	ldr	r2, [pc, #200]	@ (800cf7c <USBH_ParseDevDesc+0x15c>)
 800ceb2:	fa22 f303 	lsr.w	r3, r2, r3
 800ceb6:	f003 0301 	and.w	r3, r3, #1
 800ceba:	2b00      	cmp	r3, #0
 800cebc:	bf14      	ite	ne
 800cebe:	2301      	movne	r3, #1
 800cec0:	2300      	moveq	r3, #0
 800cec2:	b2db      	uxtb	r3, r3
 800cec4:	2b00      	cmp	r3, #0
 800cec6:	d106      	bne.n	800ced6 <USBH_ParseDevDesc+0xb6>
 800cec8:	e001      	b.n	800cece <USBH_ParseDevDesc+0xae>
 800ceca:	2b40      	cmp	r3, #64	@ 0x40
 800cecc:	d003      	beq.n	800ced6 <USBH_ParseDevDesc+0xb6>
      case 64:
        break;

      default:
        /* set the size to min allowed value in case the device has answered with incorrect size */
        dev_desc->bMaxPacketSize = 8U;
 800cece:	693b      	ldr	r3, [r7, #16]
 800ced0:	2208      	movs	r2, #8
 800ced2:	71da      	strb	r2, [r3, #7]
        break;
 800ced4:	e000      	b.n	800ced8 <USBH_ParseDevDesc+0xb8>
        break;
 800ced6:	bf00      	nop
    switch (dev_desc->bMaxPacketSize)
 800ced8:	e00e      	b.n	800cef8 <USBH_ParseDevDesc+0xd8>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800ceda:	68fb      	ldr	r3, [r7, #12]
 800cedc:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800cee0:	2b02      	cmp	r3, #2
 800cee2:	d107      	bne.n	800cef4 <USBH_ParseDevDesc+0xd4>
  {
    if (dev_desc->bMaxPacketSize != 8U)
 800cee4:	693b      	ldr	r3, [r7, #16]
 800cee6:	79db      	ldrb	r3, [r3, #7]
 800cee8:	2b08      	cmp	r3, #8
 800ceea:	d005      	beq.n	800cef8 <USBH_ParseDevDesc+0xd8>
    {
      /* set the size to 8 in case the device has answered with incorrect size */
      dev_desc->bMaxPacketSize = 8U;
 800ceec:	693b      	ldr	r3, [r7, #16]
 800ceee:	2208      	movs	r2, #8
 800cef0:	71da      	strb	r2, [r3, #7]
 800cef2:	e001      	b.n	800cef8 <USBH_ParseDevDesc+0xd8>
    }
  }
  else
  {
    status = USBH_NOT_SUPPORTED;
 800cef4:	2303      	movs	r3, #3
 800cef6:	75fb      	strb	r3, [r7, #23]
  }

  if (length > 8U)
 800cef8:	88fb      	ldrh	r3, [r7, #6]
 800cefa:	2b08      	cmp	r3, #8
 800cefc:	d936      	bls.n	800cf6c <USBH_ParseDevDesc+0x14c>
  {
    /* For 1st time after device connection, Host may issue only 8 bytes for
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16(buf +  8U);
 800cefe:	68bb      	ldr	r3, [r7, #8]
 800cf00:	3308      	adds	r3, #8
 800cf02:	781b      	ldrb	r3, [r3, #0]
 800cf04:	461a      	mov	r2, r3
 800cf06:	68bb      	ldr	r3, [r7, #8]
 800cf08:	3309      	adds	r3, #9
 800cf0a:	781b      	ldrb	r3, [r3, #0]
 800cf0c:	021b      	lsls	r3, r3, #8
 800cf0e:	b29b      	uxth	r3, r3
 800cf10:	4313      	orrs	r3, r2
 800cf12:	b29a      	uxth	r2, r3
 800cf14:	693b      	ldr	r3, [r7, #16]
 800cf16:	811a      	strh	r2, [r3, #8]
    dev_desc->idProduct          = LE16(buf + 10U);
 800cf18:	68bb      	ldr	r3, [r7, #8]
 800cf1a:	330a      	adds	r3, #10
 800cf1c:	781b      	ldrb	r3, [r3, #0]
 800cf1e:	461a      	mov	r2, r3
 800cf20:	68bb      	ldr	r3, [r7, #8]
 800cf22:	330b      	adds	r3, #11
 800cf24:	781b      	ldrb	r3, [r3, #0]
 800cf26:	021b      	lsls	r3, r3, #8
 800cf28:	b29b      	uxth	r3, r3
 800cf2a:	4313      	orrs	r3, r2
 800cf2c:	b29a      	uxth	r2, r3
 800cf2e:	693b      	ldr	r3, [r7, #16]
 800cf30:	815a      	strh	r2, [r3, #10]
    dev_desc->bcdDevice          = LE16(buf + 12U);
 800cf32:	68bb      	ldr	r3, [r7, #8]
 800cf34:	330c      	adds	r3, #12
 800cf36:	781b      	ldrb	r3, [r3, #0]
 800cf38:	461a      	mov	r2, r3
 800cf3a:	68bb      	ldr	r3, [r7, #8]
 800cf3c:	330d      	adds	r3, #13
 800cf3e:	781b      	ldrb	r3, [r3, #0]
 800cf40:	021b      	lsls	r3, r3, #8
 800cf42:	b29b      	uxth	r3, r3
 800cf44:	4313      	orrs	r3, r2
 800cf46:	b29a      	uxth	r2, r3
 800cf48:	693b      	ldr	r3, [r7, #16]
 800cf4a:	819a      	strh	r2, [r3, #12]
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 800cf4c:	68bb      	ldr	r3, [r7, #8]
 800cf4e:	7b9a      	ldrb	r2, [r3, #14]
 800cf50:	693b      	ldr	r3, [r7, #16]
 800cf52:	739a      	strb	r2, [r3, #14]
    dev_desc->iProduct           = *(uint8_t *)(buf + 15U);
 800cf54:	68bb      	ldr	r3, [r7, #8]
 800cf56:	7bda      	ldrb	r2, [r3, #15]
 800cf58:	693b      	ldr	r3, [r7, #16]
 800cf5a:	73da      	strb	r2, [r3, #15]
    dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16U);
 800cf5c:	68bb      	ldr	r3, [r7, #8]
 800cf5e:	7c1a      	ldrb	r2, [r3, #16]
 800cf60:	693b      	ldr	r3, [r7, #16]
 800cf62:	741a      	strb	r2, [r3, #16]
    dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17U);
 800cf64:	68bb      	ldr	r3, [r7, #8]
 800cf66:	7c5a      	ldrb	r2, [r3, #17]
 800cf68:	693b      	ldr	r3, [r7, #16]
 800cf6a:	745a      	strb	r2, [r3, #17]
  }

  return status;
 800cf6c:	7dfb      	ldrb	r3, [r7, #23]
}
 800cf6e:	4618      	mov	r0, r3
 800cf70:	371c      	adds	r7, #28
 800cf72:	46bd      	mov	sp, r7
 800cf74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf78:	4770      	bx	lr
 800cf7a:	bf00      	nop
 800cf7c:	01000101 	.word	0x01000101

0800cf80 <USBH_ParseCfgDesc>:
  * @param  buf: Buffer where the source descriptor is available
  * @param  length: Length of the descriptor
  * @retval USBH status
  */
static USBH_StatusTypeDef USBH_ParseCfgDesc(USBH_HandleTypeDef *phost, uint8_t *buf, uint16_t length)
{
 800cf80:	b580      	push	{r7, lr}
 800cf82:	b08c      	sub	sp, #48	@ 0x30
 800cf84:	af00      	add	r7, sp, #0
 800cf86:	60f8      	str	r0, [r7, #12]
 800cf88:	60b9      	str	r1, [r7, #8]
 800cf8a:	4613      	mov	r3, r2
 800cf8c:	80fb      	strh	r3, [r7, #6]
  USBH_CfgDescTypeDef *cfg_desc = &phost->device.CfgDesc;
 800cf8e:	68fb      	ldr	r3, [r7, #12]
 800cf90:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800cf94:	623b      	str	r3, [r7, #32]
  USBH_StatusTypeDef           status = USBH_OK;
 800cf96:	2300      	movs	r3, #0
 800cf98:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  USBH_InterfaceDescTypeDef    *pif;
  USBH_EpDescTypeDef           *pep;
  USBH_DescHeader_t            *pdesc;
  uint16_t                     ptr;
  uint8_t                      if_ix = 0U;
 800cf9c:	2300      	movs	r3, #0
 800cf9e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t                      ep_ix = 0U;
 800cfa2:	2300      	movs	r3, #0
 800cfa4:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26

  if (buf == NULL)
 800cfa8:	68bb      	ldr	r3, [r7, #8]
 800cfaa:	2b00      	cmp	r3, #0
 800cfac:	d101      	bne.n	800cfb2 <USBH_ParseCfgDesc+0x32>
  {
    return USBH_FAIL;
 800cfae:	2302      	movs	r3, #2
 800cfb0:	e0da      	b.n	800d168 <USBH_ParseCfgDesc+0x1e8>
  }

  pdesc = (USBH_DescHeader_t *)(void *)buf;
 800cfb2:	68bb      	ldr	r3, [r7, #8]
 800cfb4:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Parse configuration descriptor */
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 800cfb6:	68bb      	ldr	r3, [r7, #8]
 800cfb8:	781a      	ldrb	r2, [r3, #0]
 800cfba:	6a3b      	ldr	r3, [r7, #32]
 800cfbc:	701a      	strb	r2, [r3, #0]
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1U);
 800cfbe:	68bb      	ldr	r3, [r7, #8]
 800cfc0:	785a      	ldrb	r2, [r3, #1]
 800cfc2:	6a3b      	ldr	r3, [r7, #32]
 800cfc4:	705a      	strb	r2, [r3, #1]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cfc6:	68bb      	ldr	r3, [r7, #8]
 800cfc8:	3302      	adds	r3, #2
 800cfca:	781b      	ldrb	r3, [r3, #0]
 800cfcc:	461a      	mov	r2, r3
 800cfce:	68bb      	ldr	r3, [r7, #8]
 800cfd0:	3303      	adds	r3, #3
 800cfd2:	781b      	ldrb	r3, [r3, #0]
 800cfd4:	021b      	lsls	r3, r3, #8
 800cfd6:	b29b      	uxth	r3, r3
 800cfd8:	4313      	orrs	r3, r2
 800cfda:	b29b      	uxth	r3, r3
 800cfdc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cfe0:	bf28      	it	cs
 800cfe2:	f44f 7380 	movcs.w	r3, #256	@ 0x100
 800cfe6:	b29a      	uxth	r2, r3
 800cfe8:	6a3b      	ldr	r3, [r7, #32]
 800cfea:	805a      	strh	r2, [r3, #2]
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4U);
 800cfec:	68bb      	ldr	r3, [r7, #8]
 800cfee:	791a      	ldrb	r2, [r3, #4]
 800cff0:	6a3b      	ldr	r3, [r7, #32]
 800cff2:	711a      	strb	r2, [r3, #4]
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5U);
 800cff4:	68bb      	ldr	r3, [r7, #8]
 800cff6:	795a      	ldrb	r2, [r3, #5]
 800cff8:	6a3b      	ldr	r3, [r7, #32]
 800cffa:	715a      	strb	r2, [r3, #5]
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6U);
 800cffc:	68bb      	ldr	r3, [r7, #8]
 800cffe:	799a      	ldrb	r2, [r3, #6]
 800d000:	6a3b      	ldr	r3, [r7, #32]
 800d002:	719a      	strb	r2, [r3, #6]
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7U);
 800d004:	68bb      	ldr	r3, [r7, #8]
 800d006:	79da      	ldrb	r2, [r3, #7]
 800d008:	6a3b      	ldr	r3, [r7, #32]
 800d00a:	71da      	strb	r2, [r3, #7]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8U);
 800d00c:	68bb      	ldr	r3, [r7, #8]
 800d00e:	7a1a      	ldrb	r2, [r3, #8]
 800d010:	6a3b      	ldr	r3, [r7, #32]
 800d012:	721a      	strb	r2, [r3, #8]

  /* Make sure that the Configuration descriptor's bLength is equal to USB_CONFIGURATION_DESC_SIZE */
  if (cfg_desc->bLength != USB_CONFIGURATION_DESC_SIZE)
 800d014:	6a3b      	ldr	r3, [r7, #32]
 800d016:	781b      	ldrb	r3, [r3, #0]
 800d018:	2b09      	cmp	r3, #9
 800d01a:	d002      	beq.n	800d022 <USBH_ParseCfgDesc+0xa2>
  {
    cfg_desc->bLength = USB_CONFIGURATION_DESC_SIZE;
 800d01c:	6a3b      	ldr	r3, [r7, #32]
 800d01e:	2209      	movs	r2, #9
 800d020:	701a      	strb	r2, [r3, #0]
  }

  if (length > USB_CONFIGURATION_DESC_SIZE)
 800d022:	88fb      	ldrh	r3, [r7, #6]
 800d024:	2b09      	cmp	r3, #9
 800d026:	f240 809d 	bls.w	800d164 <USBH_ParseCfgDesc+0x1e4>
  {
    ptr = USB_LEN_CFG_DESC;
 800d02a:	2309      	movs	r3, #9
 800d02c:	82fb      	strh	r3, [r7, #22]
    pif = (USBH_InterfaceDescTypeDef *)NULL;
 800d02e:	2300      	movs	r3, #0
 800d030:	61fb      	str	r3, [r7, #28]

    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800d032:	e081      	b.n	800d138 <USBH_ParseCfgDesc+0x1b8>
    {
      pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 800d034:	f107 0316 	add.w	r3, r7, #22
 800d038:	4619      	mov	r1, r3
 800d03a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800d03c:	f000 f9e7 	bl	800d40e <USBH_GetNextDesc>
 800d040:	62b8      	str	r0, [r7, #40]	@ 0x28
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 800d042:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d044:	785b      	ldrb	r3, [r3, #1]
 800d046:	2b04      	cmp	r3, #4
 800d048:	d176      	bne.n	800d138 <USBH_ParseCfgDesc+0x1b8>
      {
        /* Make sure that the interface descriptor's bLength is equal to USB_INTERFACE_DESC_SIZE */
        if (pdesc->bLength != USB_INTERFACE_DESC_SIZE)
 800d04a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d04c:	781b      	ldrb	r3, [r3, #0]
 800d04e:	2b09      	cmp	r3, #9
 800d050:	d002      	beq.n	800d058 <USBH_ParseCfgDesc+0xd8>
        {
          pdesc->bLength = USB_INTERFACE_DESC_SIZE;
 800d052:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d054:	2209      	movs	r2, #9
 800d056:	701a      	strb	r2, [r3, #0]
        }

        pif = &cfg_desc->Itf_Desc[if_ix];
 800d058:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800d05c:	221a      	movs	r2, #26
 800d05e:	fb02 f303 	mul.w	r3, r2, r3
 800d062:	3308      	adds	r3, #8
 800d064:	6a3a      	ldr	r2, [r7, #32]
 800d066:	4413      	add	r3, r2
 800d068:	3302      	adds	r3, #2
 800d06a:	61fb      	str	r3, [r7, #28]
        USBH_ParseInterfaceDesc(pif, (uint8_t *)(void *)pdesc);
 800d06c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800d06e:	69f8      	ldr	r0, [r7, #28]
 800d070:	f000 f87e 	bl	800d170 <USBH_ParseInterfaceDesc>

        ep_ix = 0U;
 800d074:	2300      	movs	r3, #0
 800d076:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        pep = (USBH_EpDescTypeDef *)NULL;
 800d07a:	2300      	movs	r3, #0
 800d07c:	61bb      	str	r3, [r7, #24]

        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800d07e:	e043      	b.n	800d108 <USBH_ParseCfgDesc+0x188>
        {
          pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 800d080:	f107 0316 	add.w	r3, r7, #22
 800d084:	4619      	mov	r1, r3
 800d086:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800d088:	f000 f9c1 	bl	800d40e <USBH_GetNextDesc>
 800d08c:	62b8      	str	r0, [r7, #40]	@ 0x28

          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 800d08e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d090:	785b      	ldrb	r3, [r3, #1]
 800d092:	2b05      	cmp	r3, #5
 800d094:	d138      	bne.n	800d108 <USBH_ParseCfgDesc+0x188>
          {
            /* Check if the endpoint is appartening to an audio streaming interface */
            if ((pif->bInterfaceClass == 0x01U) &&
 800d096:	69fb      	ldr	r3, [r7, #28]
 800d098:	795b      	ldrb	r3, [r3, #5]
 800d09a:	2b01      	cmp	r3, #1
 800d09c:	d113      	bne.n	800d0c6 <USBH_ParseCfgDesc+0x146>
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 800d09e:	69fb      	ldr	r3, [r7, #28]
 800d0a0:	799b      	ldrb	r3, [r3, #6]
            if ((pif->bInterfaceClass == 0x01U) &&
 800d0a2:	2b02      	cmp	r3, #2
 800d0a4:	d003      	beq.n	800d0ae <USBH_ParseCfgDesc+0x12e>
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 800d0a6:	69fb      	ldr	r3, [r7, #28]
 800d0a8:	799b      	ldrb	r3, [r3, #6]
 800d0aa:	2b03      	cmp	r3, #3
 800d0ac:	d10b      	bne.n	800d0c6 <USBH_ParseCfgDesc+0x146>
            {
              /* Check if it is supporting the USB AUDIO 01 class specification */
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800d0ae:	69fb      	ldr	r3, [r7, #28]
 800d0b0:	79db      	ldrb	r3, [r3, #7]
 800d0b2:	2b00      	cmp	r3, #0
 800d0b4:	d10b      	bne.n	800d0ce <USBH_ParseCfgDesc+0x14e>
 800d0b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d0b8:	781b      	ldrb	r3, [r3, #0]
 800d0ba:	2b09      	cmp	r3, #9
 800d0bc:	d007      	beq.n	800d0ce <USBH_ParseCfgDesc+0x14e>
              {
                pdesc->bLength = 0x09U;
 800d0be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d0c0:	2209      	movs	r2, #9
 800d0c2:	701a      	strb	r2, [r3, #0]
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800d0c4:	e003      	b.n	800d0ce <USBH_ParseCfgDesc+0x14e>
            }
            /* Make sure that the endpoint descriptor's bLength is equal to
               USB_ENDPOINT_DESC_SIZE for all other endpoints types */
            else
            {
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 800d0c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d0c8:	2207      	movs	r2, #7
 800d0ca:	701a      	strb	r2, [r3, #0]
 800d0cc:	e000      	b.n	800d0d0 <USBH_ParseCfgDesc+0x150>
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800d0ce:	bf00      	nop
            }

            pep = &cfg_desc->Itf_Desc[if_ix].Ep_Desc[ep_ix];
 800d0d0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800d0d4:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800d0d8:	3201      	adds	r2, #1
 800d0da:	00d2      	lsls	r2, r2, #3
 800d0dc:	211a      	movs	r1, #26
 800d0de:	fb01 f303 	mul.w	r3, r1, r3
 800d0e2:	4413      	add	r3, r2
 800d0e4:	3308      	adds	r3, #8
 800d0e6:	6a3a      	ldr	r2, [r7, #32]
 800d0e8:	4413      	add	r3, r2
 800d0ea:	3304      	adds	r3, #4
 800d0ec:	61bb      	str	r3, [r7, #24]

            status = USBH_ParseEPDesc(phost, pep, (uint8_t *)(void *)pdesc);
 800d0ee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d0f0:	69b9      	ldr	r1, [r7, #24]
 800d0f2:	68f8      	ldr	r0, [r7, #12]
 800d0f4:	f000 f870 	bl	800d1d8 <USBH_ParseEPDesc>
 800d0f8:	4603      	mov	r3, r0
 800d0fa:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

            ep_ix++;
 800d0fe:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 800d102:	3301      	adds	r3, #1
 800d104:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800d108:	69fb      	ldr	r3, [r7, #28]
 800d10a:	791b      	ldrb	r3, [r3, #4]
 800d10c:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800d110:	429a      	cmp	r2, r3
 800d112:	d204      	bcs.n	800d11e <USBH_ParseCfgDesc+0x19e>
 800d114:	6a3b      	ldr	r3, [r7, #32]
 800d116:	885a      	ldrh	r2, [r3, #2]
 800d118:	8afb      	ldrh	r3, [r7, #22]
 800d11a:	429a      	cmp	r2, r3
 800d11c:	d8b0      	bhi.n	800d080 <USBH_ParseCfgDesc+0x100>
          }
        }

        /* Check if the required endpoint(s) data are parsed */
        if (ep_ix < pif->bNumEndpoints)
 800d11e:	69fb      	ldr	r3, [r7, #28]
 800d120:	791b      	ldrb	r3, [r3, #4]
 800d122:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800d126:	429a      	cmp	r2, r3
 800d128:	d201      	bcs.n	800d12e <USBH_ParseCfgDesc+0x1ae>
        {
          return USBH_NOT_SUPPORTED;
 800d12a:	2303      	movs	r3, #3
 800d12c:	e01c      	b.n	800d168 <USBH_ParseCfgDesc+0x1e8>
        }

        if_ix++;
 800d12e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800d132:	3301      	adds	r3, #1
 800d134:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800d138:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800d13c:	2b01      	cmp	r3, #1
 800d13e:	d805      	bhi.n	800d14c <USBH_ParseCfgDesc+0x1cc>
 800d140:	6a3b      	ldr	r3, [r7, #32]
 800d142:	885a      	ldrh	r2, [r3, #2]
 800d144:	8afb      	ldrh	r3, [r7, #22]
 800d146:	429a      	cmp	r2, r3
 800d148:	f63f af74 	bhi.w	800d034 <USBH_ParseCfgDesc+0xb4>
      }
    }

    /* Check if the required interface(s) data are parsed */
    if (if_ix < MIN(cfg_desc->bNumInterfaces, (uint8_t)USBH_MAX_NUM_INTERFACES))
 800d14c:	6a3b      	ldr	r3, [r7, #32]
 800d14e:	791b      	ldrb	r3, [r3, #4]
 800d150:	2b02      	cmp	r3, #2
 800d152:	bf28      	it	cs
 800d154:	2302      	movcs	r3, #2
 800d156:	b2db      	uxtb	r3, r3
 800d158:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 800d15c:	429a      	cmp	r2, r3
 800d15e:	d201      	bcs.n	800d164 <USBH_ParseCfgDesc+0x1e4>
    {
      return USBH_NOT_SUPPORTED;
 800d160:	2303      	movs	r3, #3
 800d162:	e001      	b.n	800d168 <USBH_ParseCfgDesc+0x1e8>
    }
  }

  return status;
 800d164:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 800d168:	4618      	mov	r0, r3
 800d16a:	3730      	adds	r7, #48	@ 0x30
 800d16c:	46bd      	mov	sp, r7
 800d16e:	bd80      	pop	{r7, pc}

0800d170 <USBH_ParseInterfaceDesc>:
  * @param  if_descriptor : Interface descriptor destination
  * @param  buf: Buffer where the descriptor data is available
  * @retval None
  */
static void USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor, uint8_t *buf)
{
 800d170:	b480      	push	{r7}
 800d172:	b083      	sub	sp, #12
 800d174:	af00      	add	r7, sp, #0
 800d176:	6078      	str	r0, [r7, #4]
 800d178:	6039      	str	r1, [r7, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0U);
 800d17a:	683b      	ldr	r3, [r7, #0]
 800d17c:	781a      	ldrb	r2, [r3, #0]
 800d17e:	687b      	ldr	r3, [r7, #4]
 800d180:	701a      	strb	r2, [r3, #0]
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1U);
 800d182:	683b      	ldr	r3, [r7, #0]
 800d184:	785a      	ldrb	r2, [r3, #1]
 800d186:	687b      	ldr	r3, [r7, #4]
 800d188:	705a      	strb	r2, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2U);
 800d18a:	683b      	ldr	r3, [r7, #0]
 800d18c:	789a      	ldrb	r2, [r3, #2]
 800d18e:	687b      	ldr	r3, [r7, #4]
 800d190:	709a      	strb	r2, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3U);
 800d192:	683b      	ldr	r3, [r7, #0]
 800d194:	78da      	ldrb	r2, [r3, #3]
 800d196:	687b      	ldr	r3, [r7, #4]
 800d198:	70da      	strb	r2, [r3, #3]
  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4U), USBH_MAX_NUM_ENDPOINTS);
 800d19a:	683b      	ldr	r3, [r7, #0]
 800d19c:	3304      	adds	r3, #4
 800d19e:	781b      	ldrb	r3, [r3, #0]
 800d1a0:	2b02      	cmp	r3, #2
 800d1a2:	bf28      	it	cs
 800d1a4:	2302      	movcs	r3, #2
 800d1a6:	b2da      	uxtb	r2, r3
 800d1a8:	687b      	ldr	r3, [r7, #4]
 800d1aa:	711a      	strb	r2, [r3, #4]
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5U);
 800d1ac:	683b      	ldr	r3, [r7, #0]
 800d1ae:	795a      	ldrb	r2, [r3, #5]
 800d1b0:	687b      	ldr	r3, [r7, #4]
 800d1b2:	715a      	strb	r2, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6U);
 800d1b4:	683b      	ldr	r3, [r7, #0]
 800d1b6:	799a      	ldrb	r2, [r3, #6]
 800d1b8:	687b      	ldr	r3, [r7, #4]
 800d1ba:	719a      	strb	r2, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7U);
 800d1bc:	683b      	ldr	r3, [r7, #0]
 800d1be:	79da      	ldrb	r2, [r3, #7]
 800d1c0:	687b      	ldr	r3, [r7, #4]
 800d1c2:	71da      	strb	r2, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8U);
 800d1c4:	683b      	ldr	r3, [r7, #0]
 800d1c6:	7a1a      	ldrb	r2, [r3, #8]
 800d1c8:	687b      	ldr	r3, [r7, #4]
 800d1ca:	721a      	strb	r2, [r3, #8]
}
 800d1cc:	bf00      	nop
 800d1ce:	370c      	adds	r7, #12
 800d1d0:	46bd      	mov	sp, r7
 800d1d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1d6:	4770      	bx	lr

0800d1d8 <USBH_ParseEPDesc>:
  * @param  ep_descriptor: Endpoint descriptor destination address
  * @param  buf: Buffer where the parsed descriptor stored
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_ParseEPDesc(USBH_HandleTypeDef *phost, USBH_EpDescTypeDef *ep_descriptor, uint8_t *buf)
{
 800d1d8:	b480      	push	{r7}
 800d1da:	b087      	sub	sp, #28
 800d1dc:	af00      	add	r7, sp, #0
 800d1de:	60f8      	str	r0, [r7, #12]
 800d1e0:	60b9      	str	r1, [r7, #8]
 800d1e2:	607a      	str	r2, [r7, #4]
  USBH_StatusTypeDef status = USBH_OK;
 800d1e4:	2300      	movs	r3, #0
 800d1e6:	75fb      	strb	r3, [r7, #23]

  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800d1e8:	687b      	ldr	r3, [r7, #4]
 800d1ea:	781a      	ldrb	r2, [r3, #0]
 800d1ec:	68bb      	ldr	r3, [r7, #8]
 800d1ee:	701a      	strb	r2, [r3, #0]
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1U);
 800d1f0:	687b      	ldr	r3, [r7, #4]
 800d1f2:	785a      	ldrb	r2, [r3, #1]
 800d1f4:	68bb      	ldr	r3, [r7, #8]
 800d1f6:	705a      	strb	r2, [r3, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2U);
 800d1f8:	687b      	ldr	r3, [r7, #4]
 800d1fa:	789a      	ldrb	r2, [r3, #2]
 800d1fc:	68bb      	ldr	r3, [r7, #8]
 800d1fe:	709a      	strb	r2, [r3, #2]
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3U);
 800d200:	687b      	ldr	r3, [r7, #4]
 800d202:	78da      	ldrb	r2, [r3, #3]
 800d204:	68bb      	ldr	r3, [r7, #8]
 800d206:	70da      	strb	r2, [r3, #3]
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 800d208:	687b      	ldr	r3, [r7, #4]
 800d20a:	3304      	adds	r3, #4
 800d20c:	781b      	ldrb	r3, [r3, #0]
 800d20e:	461a      	mov	r2, r3
 800d210:	687b      	ldr	r3, [r7, #4]
 800d212:	3305      	adds	r3, #5
 800d214:	781b      	ldrb	r3, [r3, #0]
 800d216:	021b      	lsls	r3, r3, #8
 800d218:	b29b      	uxth	r3, r3
 800d21a:	4313      	orrs	r3, r2
 800d21c:	b29a      	uxth	r2, r3
 800d21e:	68bb      	ldr	r3, [r7, #8]
 800d220:	809a      	strh	r2, [r3, #4]
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6U);
 800d222:	687b      	ldr	r3, [r7, #4]
 800d224:	799a      	ldrb	r2, [r3, #6]
 800d226:	68bb      	ldr	r3, [r7, #8]
 800d228:	719a      	strb	r2, [r3, #6]

  /* Make sure that wMaxPacketSize is different from 0 */
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 800d22a:	68bb      	ldr	r3, [r7, #8]
 800d22c:	889b      	ldrh	r3, [r3, #4]
 800d22e:	2b00      	cmp	r3, #0
 800d230:	d009      	beq.n	800d246 <USBH_ParseEPDesc+0x6e>
      (ep_descriptor->wMaxPacketSize > USBH_MAX_EP_PACKET_SIZE) ||
 800d232:	68bb      	ldr	r3, [r7, #8]
 800d234:	889b      	ldrh	r3, [r3, #4]
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 800d236:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800d23a:	d804      	bhi.n	800d246 <USBH_ParseEPDesc+0x6e>
      (ep_descriptor->wMaxPacketSize > USBH_MAX_DATA_BUFFER))
 800d23c:	68bb      	ldr	r3, [r7, #8]
 800d23e:	889b      	ldrh	r3, [r3, #4]
      (ep_descriptor->wMaxPacketSize > USBH_MAX_EP_PACKET_SIZE) ||
 800d240:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d244:	d901      	bls.n	800d24a <USBH_ParseEPDesc+0x72>
  {
    status = USBH_NOT_SUPPORTED;
 800d246:	2303      	movs	r3, #3
 800d248:	75fb      	strb	r3, [r7, #23]
  }

  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 800d24a:	68fb      	ldr	r3, [r7, #12]
 800d24c:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d250:	2b00      	cmp	r3, #0
 800d252:	d136      	bne.n	800d2c2 <USBH_ParseEPDesc+0xea>
  {
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK)
 800d254:	68bb      	ldr	r3, [r7, #8]
 800d256:	78db      	ldrb	r3, [r3, #3]
 800d258:	f003 0303 	and.w	r3, r3, #3
 800d25c:	2b02      	cmp	r3, #2
 800d25e:	d108      	bne.n	800d272 <USBH_ParseEPDesc+0x9a>
    {
      if (ep_descriptor->wMaxPacketSize > 512U)
 800d260:	68bb      	ldr	r3, [r7, #8]
 800d262:	889b      	ldrh	r3, [r3, #4]
 800d264:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d268:	f240 8097 	bls.w	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d26c:	2303      	movs	r3, #3
 800d26e:	75fb      	strb	r3, [r7, #23]
 800d270:	e093      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800d272:	68bb      	ldr	r3, [r7, #8]
 800d274:	78db      	ldrb	r3, [r3, #3]
 800d276:	f003 0303 	and.w	r3, r3, #3
 800d27a:	2b00      	cmp	r3, #0
 800d27c:	d107      	bne.n	800d28e <USBH_ParseEPDesc+0xb6>
    {
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d27e:	68bb      	ldr	r3, [r7, #8]
 800d280:	889b      	ldrh	r3, [r3, #4]
 800d282:	2b40      	cmp	r3, #64	@ 0x40
 800d284:	f240 8089 	bls.w	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d288:	2303      	movs	r3, #3
 800d28a:	75fb      	strb	r3, [r7, #23]
 800d28c:	e085      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For high-speed interrupt/isochronous endpoints, bInterval can vary from 1 to 16 */
    else if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 800d28e:	68bb      	ldr	r3, [r7, #8]
 800d290:	78db      	ldrb	r3, [r3, #3]
 800d292:	f003 0303 	and.w	r3, r3, #3
 800d296:	2b01      	cmp	r3, #1
 800d298:	d005      	beq.n	800d2a6 <USBH_ParseEPDesc+0xce>
        ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR))
 800d29a:	68bb      	ldr	r3, [r7, #8]
 800d29c:	78db      	ldrb	r3, [r3, #3]
 800d29e:	f003 0303 	and.w	r3, r3, #3
    else if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 800d2a2:	2b03      	cmp	r3, #3
 800d2a4:	d10a      	bne.n	800d2bc <USBH_ParseEPDesc+0xe4>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d2a6:	68bb      	ldr	r3, [r7, #8]
 800d2a8:	799b      	ldrb	r3, [r3, #6]
 800d2aa:	2b00      	cmp	r3, #0
 800d2ac:	d003      	beq.n	800d2b6 <USBH_ParseEPDesc+0xde>
 800d2ae:	68bb      	ldr	r3, [r7, #8]
 800d2b0:	799b      	ldrb	r3, [r3, #6]
 800d2b2:	2b10      	cmp	r3, #16
 800d2b4:	d970      	bls.n	800d398 <USBH_ParseEPDesc+0x1c0>
      {
        status = USBH_NOT_SUPPORTED;
 800d2b6:	2303      	movs	r3, #3
 800d2b8:	75fb      	strb	r3, [r7, #23]
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d2ba:	e06d      	b.n	800d398 <USBH_ParseEPDesc+0x1c0>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d2bc:	2303      	movs	r3, #3
 800d2be:	75fb      	strb	r3, [r7, #23]
 800d2c0:	e06b      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 800d2c2:	68fb      	ldr	r3, [r7, #12]
 800d2c4:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d2c8:	2b01      	cmp	r3, #1
 800d2ca:	d13c      	bne.n	800d346 <USBH_ParseEPDesc+0x16e>
  {
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 800d2cc:	68bb      	ldr	r3, [r7, #8]
 800d2ce:	78db      	ldrb	r3, [r3, #3]
 800d2d0:	f003 0303 	and.w	r3, r3, #3
 800d2d4:	2b02      	cmp	r3, #2
 800d2d6:	d005      	beq.n	800d2e4 <USBH_ParseEPDesc+0x10c>
        ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL))
 800d2d8:	68bb      	ldr	r3, [r7, #8]
 800d2da:	78db      	ldrb	r3, [r3, #3]
 800d2dc:	f003 0303 	and.w	r3, r3, #3
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 800d2e0:	2b00      	cmp	r3, #0
 800d2e2:	d106      	bne.n	800d2f2 <USBH_ParseEPDesc+0x11a>
    {
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d2e4:	68bb      	ldr	r3, [r7, #8]
 800d2e6:	889b      	ldrh	r3, [r3, #4]
 800d2e8:	2b40      	cmp	r3, #64	@ 0x40
 800d2ea:	d956      	bls.n	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d2ec:	2303      	movs	r3, #3
 800d2ee:	75fb      	strb	r3, [r7, #23]
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d2f0:	e053      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For full-speed isochronous endpoints, the value of bInterval must be in the range from 1 to 16.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC)
 800d2f2:	68bb      	ldr	r3, [r7, #8]
 800d2f4:	78db      	ldrb	r3, [r3, #3]
 800d2f6:	f003 0303 	and.w	r3, r3, #3
 800d2fa:	2b01      	cmp	r3, #1
 800d2fc:	d10e      	bne.n	800d31c <USBH_ParseEPDesc+0x144>
    {
      if ((ep_descriptor->bInterval == 0U) ||
 800d2fe:	68bb      	ldr	r3, [r7, #8]
 800d300:	799b      	ldrb	r3, [r3, #6]
 800d302:	2b00      	cmp	r3, #0
 800d304:	d007      	beq.n	800d316 <USBH_ParseEPDesc+0x13e>
          (ep_descriptor->bInterval > 0x10U) ||
 800d306:	68bb      	ldr	r3, [r7, #8]
 800d308:	799b      	ldrb	r3, [r3, #6]
      if ((ep_descriptor->bInterval == 0U) ||
 800d30a:	2b10      	cmp	r3, #16
 800d30c:	d803      	bhi.n	800d316 <USBH_ParseEPDesc+0x13e>
          (ep_descriptor->wMaxPacketSize > 64U))
 800d30e:	68bb      	ldr	r3, [r7, #8]
 800d310:	889b      	ldrh	r3, [r3, #4]
          (ep_descriptor->bInterval > 0x10U) ||
 800d312:	2b40      	cmp	r3, #64	@ 0x40
 800d314:	d941      	bls.n	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d316:	2303      	movs	r3, #3
 800d318:	75fb      	strb	r3, [r7, #23]
 800d31a:	e03e      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For full-speed interrupt endpoints, the value of bInterval may be from 1 to 255.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR)
 800d31c:	68bb      	ldr	r3, [r7, #8]
 800d31e:	78db      	ldrb	r3, [r3, #3]
 800d320:	f003 0303 	and.w	r3, r3, #3
 800d324:	2b03      	cmp	r3, #3
 800d326:	d10b      	bne.n	800d340 <USBH_ParseEPDesc+0x168>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 1023U))
 800d328:	68bb      	ldr	r3, [r7, #8]
 800d32a:	799b      	ldrb	r3, [r3, #6]
 800d32c:	2b00      	cmp	r3, #0
 800d32e:	d004      	beq.n	800d33a <USBH_ParseEPDesc+0x162>
 800d330:	68bb      	ldr	r3, [r7, #8]
 800d332:	889b      	ldrh	r3, [r3, #4]
 800d334:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800d338:	d32f      	bcc.n	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d33a:	2303      	movs	r3, #3
 800d33c:	75fb      	strb	r3, [r7, #23]
 800d33e:	e02c      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d340:	2303      	movs	r3, #3
 800d342:	75fb      	strb	r3, [r7, #23]
 800d344:	e029      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800d346:	68fb      	ldr	r3, [r7, #12]
 800d348:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d34c:	2b02      	cmp	r3, #2
 800d34e:	d120      	bne.n	800d392 <USBH_ParseEPDesc+0x1ba>
  {
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800d350:	68bb      	ldr	r3, [r7, #8]
 800d352:	78db      	ldrb	r3, [r3, #3]
 800d354:	f003 0303 	and.w	r3, r3, #3
 800d358:	2b00      	cmp	r3, #0
 800d35a:	d106      	bne.n	800d36a <USBH_ParseEPDesc+0x192>
    {
      if (ep_descriptor->wMaxPacketSize != 8U)
 800d35c:	68bb      	ldr	r3, [r7, #8]
 800d35e:	889b      	ldrh	r3, [r3, #4]
 800d360:	2b08      	cmp	r3, #8
 800d362:	d01a      	beq.n	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d364:	2303      	movs	r3, #3
 800d366:	75fb      	strb	r3, [r7, #23]
 800d368:	e017      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For low-speed interrupt endpoints, the value of bInterval may be from 1 to 255.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR)
 800d36a:	68bb      	ldr	r3, [r7, #8]
 800d36c:	78db      	ldrb	r3, [r3, #3]
 800d36e:	f003 0303 	and.w	r3, r3, #3
 800d372:	2b03      	cmp	r3, #3
 800d374:	d10a      	bne.n	800d38c <USBH_ParseEPDesc+0x1b4>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 8U))
 800d376:	68bb      	ldr	r3, [r7, #8]
 800d378:	799b      	ldrb	r3, [r3, #6]
 800d37a:	2b00      	cmp	r3, #0
 800d37c:	d003      	beq.n	800d386 <USBH_ParseEPDesc+0x1ae>
 800d37e:	68bb      	ldr	r3, [r7, #8]
 800d380:	889b      	ldrh	r3, [r3, #4]
 800d382:	2b08      	cmp	r3, #8
 800d384:	d909      	bls.n	800d39a <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d386:	2303      	movs	r3, #3
 800d388:	75fb      	strb	r3, [r7, #23]
 800d38a:	e006      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d38c:	2303      	movs	r3, #3
 800d38e:	75fb      	strb	r3, [r7, #23]
 800d390:	e003      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
    }
  }
  else
  {
    status = USBH_NOT_SUPPORTED;
 800d392:	2303      	movs	r3, #3
 800d394:	75fb      	strb	r3, [r7, #23]
 800d396:	e000      	b.n	800d39a <USBH_ParseEPDesc+0x1c2>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d398:	bf00      	nop
  }

  return status;
 800d39a:	7dfb      	ldrb	r3, [r7, #23]
}
 800d39c:	4618      	mov	r0, r3
 800d39e:	371c      	adds	r7, #28
 800d3a0:	46bd      	mov	sp, r7
 800d3a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3a6:	4770      	bx	lr

0800d3a8 <USBH_ParseStringDesc>:
  * @param  pdest: Destination address pointer
  * @param  length: Length of the descriptor
  * @retval None
  */
static void USBH_ParseStringDesc(uint8_t *psrc, uint8_t *pdest, uint16_t length)
{
 800d3a8:	b480      	push	{r7}
 800d3aa:	b087      	sub	sp, #28
 800d3ac:	af00      	add	r7, sp, #0
 800d3ae:	60f8      	str	r0, [r7, #12]
 800d3b0:	60b9      	str	r1, [r7, #8]
 800d3b2:	4613      	mov	r3, r2
 800d3b4:	80fb      	strh	r3, [r7, #6]
  */

  /* Check which is lower size, the Size of string or the length of bytes read
  from the device */

  if (psrc[1] == USB_DESC_TYPE_STRING)
 800d3b6:	68fb      	ldr	r3, [r7, #12]
 800d3b8:	3301      	adds	r3, #1
 800d3ba:	781b      	ldrb	r3, [r3, #0]
 800d3bc:	2b03      	cmp	r3, #3
 800d3be:	d120      	bne.n	800d402 <USBH_ParseStringDesc+0x5a>
  {
    /* Make sure the Descriptor is String Type */

    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 800d3c0:	68fb      	ldr	r3, [r7, #12]
 800d3c2:	781b      	ldrb	r3, [r3, #0]
 800d3c4:	1e9a      	subs	r2, r3, #2
 800d3c6:	88fb      	ldrh	r3, [r7, #6]
 800d3c8:	4293      	cmp	r3, r2
 800d3ca:	bf28      	it	cs
 800d3cc:	4613      	movcs	r3, r2
 800d3ce:	82bb      	strh	r3, [r7, #20]

    /* Adjust the offset ignoring the String Len and Descriptor type */
    psrc += 2U;
 800d3d0:	68fb      	ldr	r3, [r7, #12]
 800d3d2:	3302      	adds	r3, #2
 800d3d4:	60fb      	str	r3, [r7, #12]

    for (idx = 0U; idx < strlength; idx += 2U)
 800d3d6:	2300      	movs	r3, #0
 800d3d8:	82fb      	strh	r3, [r7, #22]
 800d3da:	e00b      	b.n	800d3f4 <USBH_ParseStringDesc+0x4c>
    {
      /* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
 800d3dc:	8afb      	ldrh	r3, [r7, #22]
 800d3de:	68fa      	ldr	r2, [r7, #12]
 800d3e0:	4413      	add	r3, r2
 800d3e2:	781a      	ldrb	r2, [r3, #0]
 800d3e4:	68bb      	ldr	r3, [r7, #8]
 800d3e6:	701a      	strb	r2, [r3, #0]
      pdest++;
 800d3e8:	68bb      	ldr	r3, [r7, #8]
 800d3ea:	3301      	adds	r3, #1
 800d3ec:	60bb      	str	r3, [r7, #8]
    for (idx = 0U; idx < strlength; idx += 2U)
 800d3ee:	8afb      	ldrh	r3, [r7, #22]
 800d3f0:	3302      	adds	r3, #2
 800d3f2:	82fb      	strh	r3, [r7, #22]
 800d3f4:	8afa      	ldrh	r2, [r7, #22]
 800d3f6:	8abb      	ldrh	r3, [r7, #20]
 800d3f8:	429a      	cmp	r2, r3
 800d3fa:	d3ef      	bcc.n	800d3dc <USBH_ParseStringDesc+0x34>
    }
    *pdest = 0U; /* mark end of string */
 800d3fc:	68bb      	ldr	r3, [r7, #8]
 800d3fe:	2200      	movs	r2, #0
 800d400:	701a      	strb	r2, [r3, #0]
  }
}
 800d402:	bf00      	nop
 800d404:	371c      	adds	r7, #28
 800d406:	46bd      	mov	sp, r7
 800d408:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d40c:	4770      	bx	lr

0800d40e <USBH_GetNextDesc>:
  * @param  buf: Buffer where the cfg descriptor is available
  * @param  ptr: data pointer inside the cfg descriptor
  * @retval next header
  */
USBH_DescHeader_t *USBH_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 800d40e:	b480      	push	{r7}
 800d410:	b085      	sub	sp, #20
 800d412:	af00      	add	r7, sp, #0
 800d414:	6078      	str	r0, [r7, #4]
 800d416:	6039      	str	r1, [r7, #0]
  USBH_DescHeader_t *pnext;

  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800d418:	683b      	ldr	r3, [r7, #0]
 800d41a:	881b      	ldrh	r3, [r3, #0]
 800d41c:	687a      	ldr	r2, [r7, #4]
 800d41e:	7812      	ldrb	r2, [r2, #0]
 800d420:	4413      	add	r3, r2
 800d422:	b29a      	uxth	r2, r3
 800d424:	683b      	ldr	r3, [r7, #0]
 800d426:	801a      	strh	r2, [r3, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
                                        ((USBH_DescHeader_t *)(void *)pbuf)->bLength);
 800d428:	687b      	ldr	r3, [r7, #4]
 800d42a:	781b      	ldrb	r3, [r3, #0]
 800d42c:	461a      	mov	r2, r3
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800d42e:	687b      	ldr	r3, [r7, #4]
 800d430:	4413      	add	r3, r2
 800d432:	60fb      	str	r3, [r7, #12]

  return (pnext);
 800d434:	68fb      	ldr	r3, [r7, #12]
}
 800d436:	4618      	mov	r0, r3
 800d438:	3714      	adds	r7, #20
 800d43a:	46bd      	mov	sp, r7
 800d43c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d440:	4770      	bx	lr

0800d442 <USBH_CtlReq>:
  * @param  length: length of the response
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
                               uint16_t length)
{
 800d442:	b580      	push	{r7, lr}
 800d444:	b086      	sub	sp, #24
 800d446:	af00      	add	r7, sp, #0
 800d448:	60f8      	str	r0, [r7, #12]
 800d44a:	60b9      	str	r1, [r7, #8]
 800d44c:	4613      	mov	r3, r2
 800d44e:	80fb      	strh	r3, [r7, #6]
  USBH_StatusTypeDef status;
  status = USBH_BUSY;
 800d450:	2301      	movs	r3, #1
 800d452:	75fb      	strb	r3, [r7, #23]

  switch (phost->RequestState)
 800d454:	68fb      	ldr	r3, [r7, #12]
 800d456:	789b      	ldrb	r3, [r3, #2]
 800d458:	2b01      	cmp	r3, #1
 800d45a:	d002      	beq.n	800d462 <USBH_CtlReq+0x20>
 800d45c:	2b02      	cmp	r3, #2
 800d45e:	d00f      	beq.n	800d480 <USBH_CtlReq+0x3e>
#endif
#endif
      break;

    default:
      break;
 800d460:	e027      	b.n	800d4b2 <USBH_CtlReq+0x70>
      phost->Control.buff = buff;
 800d462:	68fb      	ldr	r3, [r7, #12]
 800d464:	68ba      	ldr	r2, [r7, #8]
 800d466:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 800d468:	68fb      	ldr	r3, [r7, #12]
 800d46a:	88fa      	ldrh	r2, [r7, #6]
 800d46c:	819a      	strh	r2, [r3, #12]
      phost->Control.state = CTRL_SETUP;
 800d46e:	68fb      	ldr	r3, [r7, #12]
 800d470:	2201      	movs	r2, #1
 800d472:	761a      	strb	r2, [r3, #24]
      phost->RequestState = CMD_WAIT;
 800d474:	68fb      	ldr	r3, [r7, #12]
 800d476:	2202      	movs	r2, #2
 800d478:	709a      	strb	r2, [r3, #2]
      status = USBH_BUSY;
 800d47a:	2301      	movs	r3, #1
 800d47c:	75fb      	strb	r3, [r7, #23]
      break;
 800d47e:	e018      	b.n	800d4b2 <USBH_CtlReq+0x70>
      status = USBH_HandleControl(phost);
 800d480:	68f8      	ldr	r0, [r7, #12]
 800d482:	f000 f81b 	bl	800d4bc <USBH_HandleControl>
 800d486:	4603      	mov	r3, r0
 800d488:	75fb      	strb	r3, [r7, #23]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800d48a:	7dfb      	ldrb	r3, [r7, #23]
 800d48c:	2b00      	cmp	r3, #0
 800d48e:	d002      	beq.n	800d496 <USBH_CtlReq+0x54>
 800d490:	7dfb      	ldrb	r3, [r7, #23]
 800d492:	2b03      	cmp	r3, #3
 800d494:	d106      	bne.n	800d4a4 <USBH_CtlReq+0x62>
        phost->RequestState = CMD_SEND;
 800d496:	68fb      	ldr	r3, [r7, #12]
 800d498:	2201      	movs	r2, #1
 800d49a:	709a      	strb	r2, [r3, #2]
        phost->Control.state = CTRL_IDLE;
 800d49c:	68fb      	ldr	r3, [r7, #12]
 800d49e:	2200      	movs	r2, #0
 800d4a0:	761a      	strb	r2, [r3, #24]
      break;
 800d4a2:	e005      	b.n	800d4b0 <USBH_CtlReq+0x6e>
      else if (status == USBH_FAIL)
 800d4a4:	7dfb      	ldrb	r3, [r7, #23]
 800d4a6:	2b02      	cmp	r3, #2
 800d4a8:	d102      	bne.n	800d4b0 <USBH_CtlReq+0x6e>
        phost->RequestState = CMD_SEND;
 800d4aa:	68fb      	ldr	r3, [r7, #12]
 800d4ac:	2201      	movs	r2, #1
 800d4ae:	709a      	strb	r2, [r3, #2]
      break;
 800d4b0:	bf00      	nop
  }
  return status;
 800d4b2:	7dfb      	ldrb	r3, [r7, #23]
}
 800d4b4:	4618      	mov	r0, r3
 800d4b6:	3718      	adds	r7, #24
 800d4b8:	46bd      	mov	sp, r7
 800d4ba:	bd80      	pop	{r7, pc}

0800d4bc <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
{
 800d4bc:	b580      	push	{r7, lr}
 800d4be:	b086      	sub	sp, #24
 800d4c0:	af02      	add	r7, sp, #8
 800d4c2:	6078      	str	r0, [r7, #4]
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
 800d4c4:	2301      	movs	r3, #1
 800d4c6:	73fb      	strb	r3, [r7, #15]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 800d4c8:	2300      	movs	r3, #0
 800d4ca:	73bb      	strb	r3, [r7, #14]

  switch (phost->Control.state)
 800d4cc:	687b      	ldr	r3, [r7, #4]
 800d4ce:	7e1b      	ldrb	r3, [r3, #24]
 800d4d0:	3b01      	subs	r3, #1
 800d4d2:	2b0a      	cmp	r3, #10
 800d4d4:	f200 8156 	bhi.w	800d784 <USBH_HandleControl+0x2c8>
 800d4d8:	a201      	add	r2, pc, #4	@ (adr r2, 800d4e0 <USBH_HandleControl+0x24>)
 800d4da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d4de:	bf00      	nop
 800d4e0:	0800d50d 	.word	0x0800d50d
 800d4e4:	0800d527 	.word	0x0800d527
 800d4e8:	0800d591 	.word	0x0800d591
 800d4ec:	0800d5b7 	.word	0x0800d5b7
 800d4f0:	0800d5ef 	.word	0x0800d5ef
 800d4f4:	0800d619 	.word	0x0800d619
 800d4f8:	0800d66b 	.word	0x0800d66b
 800d4fc:	0800d68d 	.word	0x0800d68d
 800d500:	0800d6c9 	.word	0x0800d6c9
 800d504:	0800d6ef 	.word	0x0800d6ef
 800d508:	0800d72d 	.word	0x0800d72d
  {
    case CTRL_SETUP:
      /* send a SETUP packet */
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800d50c:	687b      	ldr	r3, [r7, #4]
 800d50e:	f103 0110 	add.w	r1, r3, #16
 800d512:	687b      	ldr	r3, [r7, #4]
 800d514:	795b      	ldrb	r3, [r3, #5]
 800d516:	461a      	mov	r2, r3
 800d518:	6878      	ldr	r0, [r7, #4]
 800d51a:	f000 f943 	bl	800d7a4 <USBH_CtlSendSetup>
                              phost->Control.pipe_out);

      phost->Control.state = CTRL_SETUP_WAIT;
 800d51e:	687b      	ldr	r3, [r7, #4]
 800d520:	2202      	movs	r2, #2
 800d522:	761a      	strb	r2, [r3, #24]
      break;
 800d524:	e139      	b.n	800d79a <USBH_HandleControl+0x2de>

    case CTRL_SETUP_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d526:	687b      	ldr	r3, [r7, #4]
 800d528:	795b      	ldrb	r3, [r3, #5]
 800d52a:	4619      	mov	r1, r3
 800d52c:	6878      	ldr	r0, [r7, #4]
 800d52e:	f01f fe87 	bl	802d240 <USBH_LL_GetURBState>
 800d532:	4603      	mov	r3, r0
 800d534:	73bb      	strb	r3, [r7, #14]
      /* case SETUP packet sent successfully */
      if (URB_Status == USBH_URB_DONE)
 800d536:	7bbb      	ldrb	r3, [r7, #14]
 800d538:	2b01      	cmp	r3, #1
 800d53a:	d11e      	bne.n	800d57a <USBH_HandleControl+0xbe>
      {
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800d53c:	687b      	ldr	r3, [r7, #4]
 800d53e:	7c1b      	ldrb	r3, [r3, #16]
 800d540:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 800d544:	737b      	strb	r3, [r7, #13]

        /* check if there is a data stage */
        if (phost->Control.setup.b.wLength.w != 0U)
 800d546:	687b      	ldr	r3, [r7, #4]
 800d548:	8adb      	ldrh	r3, [r3, #22]
 800d54a:	2b00      	cmp	r3, #0
 800d54c:	d00a      	beq.n	800d564 <USBH_HandleControl+0xa8>
        {
          if (direction == USB_D2H)
 800d54e:	7b7b      	ldrb	r3, [r7, #13]
 800d550:	2b80      	cmp	r3, #128	@ 0x80
 800d552:	d103      	bne.n	800d55c <USBH_HandleControl+0xa0>
          {
            /* Data Direction is IN */
            phost->Control.state = CTRL_DATA_IN;
 800d554:	687b      	ldr	r3, [r7, #4]
 800d556:	2203      	movs	r2, #3
 800d558:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d55a:	e115      	b.n	800d788 <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_DATA_OUT;
 800d55c:	687b      	ldr	r3, [r7, #4]
 800d55e:	2205      	movs	r2, #5
 800d560:	761a      	strb	r2, [r3, #24]
      break;
 800d562:	e111      	b.n	800d788 <USBH_HandleControl+0x2cc>
          if (direction == USB_D2H)
 800d564:	7b7b      	ldrb	r3, [r7, #13]
 800d566:	2b80      	cmp	r3, #128	@ 0x80
 800d568:	d103      	bne.n	800d572 <USBH_HandleControl+0xb6>
            phost->Control.state = CTRL_STATUS_OUT;
 800d56a:	687b      	ldr	r3, [r7, #4]
 800d56c:	2209      	movs	r2, #9
 800d56e:	761a      	strb	r2, [r3, #24]
      break;
 800d570:	e10a      	b.n	800d788 <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_STATUS_IN;
 800d572:	687b      	ldr	r3, [r7, #4]
 800d574:	2207      	movs	r2, #7
 800d576:	761a      	strb	r2, [r3, #24]
      break;
 800d578:	e106      	b.n	800d788 <USBH_HandleControl+0x2cc>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800d57a:	7bbb      	ldrb	r3, [r7, #14]
 800d57c:	2b04      	cmp	r3, #4
 800d57e:	d003      	beq.n	800d588 <USBH_HandleControl+0xcc>
 800d580:	7bbb      	ldrb	r3, [r7, #14]
 800d582:	2b02      	cmp	r3, #2
 800d584:	f040 8100 	bne.w	800d788 <USBH_HandleControl+0x2cc>
          phost->Control.state = CTRL_ERROR;
 800d588:	687b      	ldr	r3, [r7, #4]
 800d58a:	220b      	movs	r2, #11
 800d58c:	761a      	strb	r2, [r3, #24]
      break;
 800d58e:	e0fb      	b.n	800d788 <USBH_HandleControl+0x2cc>

    case CTRL_DATA_IN:
      /* Issue an IN token */
      phost->Control.timer = (uint16_t)phost->Timer;
 800d590:	687b      	ldr	r3, [r7, #4]
 800d592:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d596:	b29a      	uxth	r2, r3
 800d598:	687b      	ldr	r3, [r7, #4]
 800d59a:	81da      	strh	r2, [r3, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800d59c:	687b      	ldr	r3, [r7, #4]
 800d59e:	6899      	ldr	r1, [r3, #8]
 800d5a0:	687b      	ldr	r3, [r7, #4]
 800d5a2:	899a      	ldrh	r2, [r3, #12]
 800d5a4:	687b      	ldr	r3, [r7, #4]
 800d5a6:	791b      	ldrb	r3, [r3, #4]
 800d5a8:	6878      	ldr	r0, [r7, #4]
 800d5aa:	f000 f93a 	bl	800d822 <USBH_CtlReceiveData>
                                phost->Control.length, phost->Control.pipe_in);

      phost->Control.state = CTRL_DATA_IN_WAIT;
 800d5ae:	687b      	ldr	r3, [r7, #4]
 800d5b0:	2204      	movs	r2, #4
 800d5b2:	761a      	strb	r2, [r3, #24]
      break;
 800d5b4:	e0f1      	b.n	800d79a <USBH_HandleControl+0x2de>

    case CTRL_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800d5b6:	687b      	ldr	r3, [r7, #4]
 800d5b8:	791b      	ldrb	r3, [r3, #4]
 800d5ba:	4619      	mov	r1, r3
 800d5bc:	6878      	ldr	r0, [r7, #4]
 800d5be:	f01f fe3f 	bl	802d240 <USBH_LL_GetURBState>
 800d5c2:	4603      	mov	r3, r0
 800d5c4:	73bb      	strb	r3, [r7, #14]

      /* check is DATA packet transferred successfully */
      if (URB_Status == USBH_URB_DONE)
 800d5c6:	7bbb      	ldrb	r3, [r7, #14]
 800d5c8:	2b01      	cmp	r3, #1
 800d5ca:	d102      	bne.n	800d5d2 <USBH_HandleControl+0x116>
      {
        phost->Control.state = CTRL_STATUS_OUT;
 800d5cc:	687b      	ldr	r3, [r7, #4]
 800d5ce:	2209      	movs	r2, #9
 800d5d0:	761a      	strb	r2, [r3, #24]
#endif
#endif
      }

      /* manage error cases*/
      if (URB_Status == USBH_URB_STALL)
 800d5d2:	7bbb      	ldrb	r3, [r7, #14]
 800d5d4:	2b05      	cmp	r3, #5
 800d5d6:	d102      	bne.n	800d5de <USBH_HandleControl+0x122>
      {
        /* In stall case, return to previous machine state*/
        status = USBH_NOT_SUPPORTED;
 800d5d8:	2303      	movs	r3, #3
 800d5da:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d5dc:	e0d6      	b.n	800d78c <USBH_HandleControl+0x2d0>
        if (URB_Status == USBH_URB_ERROR)
 800d5de:	7bbb      	ldrb	r3, [r7, #14]
 800d5e0:	2b04      	cmp	r3, #4
 800d5e2:	f040 80d3 	bne.w	800d78c <USBH_HandleControl+0x2d0>
          phost->Control.state = CTRL_ERROR;
 800d5e6:	687b      	ldr	r3, [r7, #4]
 800d5e8:	220b      	movs	r2, #11
 800d5ea:	761a      	strb	r2, [r3, #24]
      break;
 800d5ec:	e0ce      	b.n	800d78c <USBH_HandleControl+0x2d0>

    case CTRL_DATA_OUT:

      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800d5ee:	687b      	ldr	r3, [r7, #4]
 800d5f0:	6899      	ldr	r1, [r3, #8]
 800d5f2:	687b      	ldr	r3, [r7, #4]
 800d5f4:	899a      	ldrh	r2, [r3, #12]
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	795b      	ldrb	r3, [r3, #5]
 800d5fa:	2001      	movs	r0, #1
 800d5fc:	9000      	str	r0, [sp, #0]
 800d5fe:	6878      	ldr	r0, [r7, #4]
 800d600:	f000 f8ea 	bl	800d7d8 <USBH_CtlSendData>
                             phost->Control.pipe_out, 1U);

      phost->Control.timer = (uint16_t)phost->Timer;
 800d604:	687b      	ldr	r3, [r7, #4]
 800d606:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d60a:	b29a      	uxth	r2, r3
 800d60c:	687b      	ldr	r3, [r7, #4]
 800d60e:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800d610:	687b      	ldr	r3, [r7, #4]
 800d612:	2206      	movs	r2, #6
 800d614:	761a      	strb	r2, [r3, #24]
      break;
 800d616:	e0c0      	b.n	800d79a <USBH_HandleControl+0x2de>

    case CTRL_DATA_OUT_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d618:	687b      	ldr	r3, [r7, #4]
 800d61a:	795b      	ldrb	r3, [r3, #5]
 800d61c:	4619      	mov	r1, r3
 800d61e:	6878      	ldr	r0, [r7, #4]
 800d620:	f01f fe0e 	bl	802d240 <USBH_LL_GetURBState>
 800d624:	4603      	mov	r3, r0
 800d626:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 800d628:	7bbb      	ldrb	r3, [r7, #14]
 800d62a:	2b01      	cmp	r3, #1
 800d62c:	d103      	bne.n	800d636 <USBH_HandleControl+0x17a>
      {
        /* If the Setup Pkt is sent successful, then change the state */
        phost->Control.state = CTRL_STATUS_IN;
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	2207      	movs	r2, #7
 800d632:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d634:	e0ac      	b.n	800d790 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_STALL)
 800d636:	7bbb      	ldrb	r3, [r7, #14]
 800d638:	2b05      	cmp	r3, #5
 800d63a:	d105      	bne.n	800d648 <USBH_HandleControl+0x18c>
        phost->Control.state = CTRL_STALLED;
 800d63c:	687b      	ldr	r3, [r7, #4]
 800d63e:	220c      	movs	r2, #12
 800d640:	761a      	strb	r2, [r3, #24]
        status = USBH_NOT_SUPPORTED;
 800d642:	2303      	movs	r3, #3
 800d644:	73fb      	strb	r3, [r7, #15]
      break;
 800d646:	e0a3      	b.n	800d790 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_NOTREADY)
 800d648:	7bbb      	ldrb	r3, [r7, #14]
 800d64a:	2b02      	cmp	r3, #2
 800d64c:	d103      	bne.n	800d656 <USBH_HandleControl+0x19a>
        phost->Control.state = CTRL_DATA_OUT;
 800d64e:	687b      	ldr	r3, [r7, #4]
 800d650:	2205      	movs	r2, #5
 800d652:	761a      	strb	r2, [r3, #24]
      break;
 800d654:	e09c      	b.n	800d790 <USBH_HandleControl+0x2d4>
        if (URB_Status == USBH_URB_ERROR)
 800d656:	7bbb      	ldrb	r3, [r7, #14]
 800d658:	2b04      	cmp	r3, #4
 800d65a:	f040 8099 	bne.w	800d790 <USBH_HandleControl+0x2d4>
          phost->Control.state = CTRL_ERROR;
 800d65e:	687b      	ldr	r3, [r7, #4]
 800d660:	220b      	movs	r2, #11
 800d662:	761a      	strb	r2, [r3, #24]
          status = USBH_FAIL;
 800d664:	2302      	movs	r3, #2
 800d666:	73fb      	strb	r3, [r7, #15]
      break;
 800d668:	e092      	b.n	800d790 <USBH_HandleControl+0x2d4>

    case CTRL_STATUS_IN:
      /* Send 0 bytes out packet */
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800d66a:	687b      	ldr	r3, [r7, #4]
 800d66c:	791b      	ldrb	r3, [r3, #4]
 800d66e:	2200      	movs	r2, #0
 800d670:	2100      	movs	r1, #0
 800d672:	6878      	ldr	r0, [r7, #4]
 800d674:	f000 f8d5 	bl	800d822 <USBH_CtlReceiveData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800d678:	687b      	ldr	r3, [r7, #4]
 800d67a:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d67e:	b29a      	uxth	r2, r3
 800d680:	687b      	ldr	r3, [r7, #4]
 800d682:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800d684:	687b      	ldr	r3, [r7, #4]
 800d686:	2208      	movs	r2, #8
 800d688:	761a      	strb	r2, [r3, #24]

      break;
 800d68a:	e086      	b.n	800d79a <USBH_HandleControl+0x2de>

    case CTRL_STATUS_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800d68c:	687b      	ldr	r3, [r7, #4]
 800d68e:	791b      	ldrb	r3, [r3, #4]
 800d690:	4619      	mov	r1, r3
 800d692:	6878      	ldr	r0, [r7, #4]
 800d694:	f01f fdd4 	bl	802d240 <USBH_LL_GetURBState>
 800d698:	4603      	mov	r3, r0
 800d69a:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 800d69c:	7bbb      	ldrb	r3, [r7, #14]
 800d69e:	2b01      	cmp	r3, #1
 800d6a0:	d105      	bne.n	800d6ae <USBH_HandleControl+0x1f2>
      {
        /* Control transfers completed, Exit the State Machine */
        phost->Control.state = CTRL_COMPLETE;
 800d6a2:	687b      	ldr	r3, [r7, #4]
 800d6a4:	220d      	movs	r2, #13
 800d6a6:	761a      	strb	r2, [r3, #24]
        status = USBH_OK;
 800d6a8:	2300      	movs	r3, #0
 800d6aa:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d6ac:	e072      	b.n	800d794 <USBH_HandleControl+0x2d8>
      else if (URB_Status == USBH_URB_ERROR)
 800d6ae:	7bbb      	ldrb	r3, [r7, #14]
 800d6b0:	2b04      	cmp	r3, #4
 800d6b2:	d103      	bne.n	800d6bc <USBH_HandleControl+0x200>
        phost->Control.state = CTRL_ERROR;
 800d6b4:	687b      	ldr	r3, [r7, #4]
 800d6b6:	220b      	movs	r2, #11
 800d6b8:	761a      	strb	r2, [r3, #24]
      break;
 800d6ba:	e06b      	b.n	800d794 <USBH_HandleControl+0x2d8>
        if (URB_Status == USBH_URB_STALL)
 800d6bc:	7bbb      	ldrb	r3, [r7, #14]
 800d6be:	2b05      	cmp	r3, #5
 800d6c0:	d168      	bne.n	800d794 <USBH_HandleControl+0x2d8>
          status = USBH_NOT_SUPPORTED;
 800d6c2:	2303      	movs	r3, #3
 800d6c4:	73fb      	strb	r3, [r7, #15]
      break;
 800d6c6:	e065      	b.n	800d794 <USBH_HandleControl+0x2d8>

    case CTRL_STATUS_OUT:
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	795b      	ldrb	r3, [r3, #5]
 800d6cc:	2201      	movs	r2, #1
 800d6ce:	9200      	str	r2, [sp, #0]
 800d6d0:	2200      	movs	r2, #0
 800d6d2:	2100      	movs	r1, #0
 800d6d4:	6878      	ldr	r0, [r7, #4]
 800d6d6:	f000 f87f 	bl	800d7d8 <USBH_CtlSendData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800d6da:	687b      	ldr	r3, [r7, #4]
 800d6dc:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d6e0:	b29a      	uxth	r2, r3
 800d6e2:	687b      	ldr	r3, [r7, #4]
 800d6e4:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	220a      	movs	r2, #10
 800d6ea:	761a      	strb	r2, [r3, #24]
      break;
 800d6ec:	e055      	b.n	800d79a <USBH_HandleControl+0x2de>

    case CTRL_STATUS_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d6ee:	687b      	ldr	r3, [r7, #4]
 800d6f0:	795b      	ldrb	r3, [r3, #5]
 800d6f2:	4619      	mov	r1, r3
 800d6f4:	6878      	ldr	r0, [r7, #4]
 800d6f6:	f01f fda3 	bl	802d240 <USBH_LL_GetURBState>
 800d6fa:	4603      	mov	r3, r0
 800d6fc:	73bb      	strb	r3, [r7, #14]
      if (URB_Status == USBH_URB_DONE)
 800d6fe:	7bbb      	ldrb	r3, [r7, #14]
 800d700:	2b01      	cmp	r3, #1
 800d702:	d105      	bne.n	800d710 <USBH_HandleControl+0x254>
      {
        status = USBH_OK;
 800d704:	2300      	movs	r3, #0
 800d706:	73fb      	strb	r3, [r7, #15]
        phost->Control.state = CTRL_COMPLETE;
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	220d      	movs	r2, #13
 800d70c:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d70e:	e043      	b.n	800d798 <USBH_HandleControl+0x2dc>
      else if (URB_Status == USBH_URB_NOTREADY)
 800d710:	7bbb      	ldrb	r3, [r7, #14]
 800d712:	2b02      	cmp	r3, #2
 800d714:	d103      	bne.n	800d71e <USBH_HandleControl+0x262>
        phost->Control.state = CTRL_STATUS_OUT;
 800d716:	687b      	ldr	r3, [r7, #4]
 800d718:	2209      	movs	r2, #9
 800d71a:	761a      	strb	r2, [r3, #24]
      break;
 800d71c:	e03c      	b.n	800d798 <USBH_HandleControl+0x2dc>
        if (URB_Status == USBH_URB_ERROR)
 800d71e:	7bbb      	ldrb	r3, [r7, #14]
 800d720:	2b04      	cmp	r3, #4
 800d722:	d139      	bne.n	800d798 <USBH_HandleControl+0x2dc>
          phost->Control.state = CTRL_ERROR;
 800d724:	687b      	ldr	r3, [r7, #4]
 800d726:	220b      	movs	r2, #11
 800d728:	761a      	strb	r2, [r3, #24]
      break;
 800d72a:	e035      	b.n	800d798 <USBH_HandleControl+0x2dc>
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	7e5b      	ldrb	r3, [r3, #25]
 800d730:	3301      	adds	r3, #1
 800d732:	b2da      	uxtb	r2, r3
 800d734:	687b      	ldr	r3, [r7, #4]
 800d736:	765a      	strb	r2, [r3, #25]
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	7e5b      	ldrb	r3, [r3, #25]
 800d73c:	2b02      	cmp	r3, #2
 800d73e:	d806      	bhi.n	800d74e <USBH_HandleControl+0x292>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 800d740:	687b      	ldr	r3, [r7, #4]
 800d742:	2201      	movs	r2, #1
 800d744:	761a      	strb	r2, [r3, #24]
        phost->RequestState = CMD_SEND;
 800d746:	687b      	ldr	r3, [r7, #4]
 800d748:	2201      	movs	r2, #1
 800d74a:	709a      	strb	r2, [r3, #2]
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);

        phost->gState = HOST_IDLE;
        status = USBH_FAIL;
      }
      break;
 800d74c:	e025      	b.n	800d79a <USBH_HandleControl+0x2de>
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800d74e:	687b      	ldr	r3, [r7, #4]
 800d750:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800d754:	2106      	movs	r1, #6
 800d756:	6878      	ldr	r0, [r7, #4]
 800d758:	4798      	blx	r3
        phost->Control.errorcount = 0U;
 800d75a:	687b      	ldr	r3, [r7, #4]
 800d75c:	2200      	movs	r2, #0
 800d75e:	765a      	strb	r2, [r3, #25]
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800d760:	687b      	ldr	r3, [r7, #4]
 800d762:	795b      	ldrb	r3, [r3, #5]
 800d764:	4619      	mov	r1, r3
 800d766:	6878      	ldr	r0, [r7, #4]
 800d768:	f000 f90c 	bl	800d984 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800d76c:	687b      	ldr	r3, [r7, #4]
 800d76e:	791b      	ldrb	r3, [r3, #4]
 800d770:	4619      	mov	r1, r3
 800d772:	6878      	ldr	r0, [r7, #4]
 800d774:	f000 f906 	bl	800d984 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800d778:	687b      	ldr	r3, [r7, #4]
 800d77a:	2200      	movs	r2, #0
 800d77c:	701a      	strb	r2, [r3, #0]
        status = USBH_FAIL;
 800d77e:	2302      	movs	r3, #2
 800d780:	73fb      	strb	r3, [r7, #15]
      break;
 800d782:	e00a      	b.n	800d79a <USBH_HandleControl+0x2de>

    default:
      break;
 800d784:	bf00      	nop
 800d786:	e008      	b.n	800d79a <USBH_HandleControl+0x2de>
      break;
 800d788:	bf00      	nop
 800d78a:	e006      	b.n	800d79a <USBH_HandleControl+0x2de>
      break;
 800d78c:	bf00      	nop
 800d78e:	e004      	b.n	800d79a <USBH_HandleControl+0x2de>
      break;
 800d790:	bf00      	nop
 800d792:	e002      	b.n	800d79a <USBH_HandleControl+0x2de>
      break;
 800d794:	bf00      	nop
 800d796:	e000      	b.n	800d79a <USBH_HandleControl+0x2de>
      break;
 800d798:	bf00      	nop
  }

  return status;
 800d79a:	7bfb      	ldrb	r3, [r7, #15]
}
 800d79c:	4618      	mov	r0, r3
 800d79e:	3710      	adds	r7, #16
 800d7a0:	46bd      	mov	sp, r7
 800d7a2:	bd80      	pop	{r7, pc}

0800d7a4 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 800d7a4:	b580      	push	{r7, lr}
 800d7a6:	b088      	sub	sp, #32
 800d7a8:	af04      	add	r7, sp, #16
 800d7aa:	60f8      	str	r0, [r7, #12]
 800d7ac:	60b9      	str	r1, [r7, #8]
 800d7ae:	4613      	mov	r3, r2
 800d7b0:	71fb      	strb	r3, [r7, #7]

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d7b2:	79f9      	ldrb	r1, [r7, #7]
 800d7b4:	2300      	movs	r3, #0
 800d7b6:	9303      	str	r3, [sp, #12]
 800d7b8:	2308      	movs	r3, #8
 800d7ba:	9302      	str	r3, [sp, #8]
 800d7bc:	68bb      	ldr	r3, [r7, #8]
 800d7be:	9301      	str	r3, [sp, #4]
 800d7c0:	2300      	movs	r3, #0
 800d7c2:	9300      	str	r3, [sp, #0]
 800d7c4:	2300      	movs	r3, #0
 800d7c6:	2200      	movs	r2, #0
 800d7c8:	68f8      	ldr	r0, [r7, #12]
 800d7ca:	f01f fd08 	bl	802d1de <USBH_LL_SubmitURB>
                          USBH_EP_CONTROL,      /* EP type          */
                          USBH_PID_SETUP,       /* Type setup       */
                          buff,                 /* data buffer      */
                          USBH_SETUP_PKT_SIZE,  /* data length      */
                          0U);
  return USBH_OK;
 800d7ce:	2300      	movs	r3, #0
}
 800d7d0:	4618      	mov	r0, r3
 800d7d2:	3710      	adds	r7, #16
 800d7d4:	46bd      	mov	sp, r7
 800d7d6:	bd80      	pop	{r7, pc}

0800d7d8 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 800d7d8:	b580      	push	{r7, lr}
 800d7da:	b088      	sub	sp, #32
 800d7dc:	af04      	add	r7, sp, #16
 800d7de:	60f8      	str	r0, [r7, #12]
 800d7e0:	60b9      	str	r1, [r7, #8]
 800d7e2:	4611      	mov	r1, r2
 800d7e4:	461a      	mov	r2, r3
 800d7e6:	460b      	mov	r3, r1
 800d7e8:	80fb      	strh	r3, [r7, #6]
 800d7ea:	4613      	mov	r3, r2
 800d7ec:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 800d7ee:	68fb      	ldr	r3, [r7, #12]
 800d7f0:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d7f4:	2b00      	cmp	r3, #0
 800d7f6:	d001      	beq.n	800d7fc <USBH_CtlSendData+0x24>
  {
    do_ping = 0U;
 800d7f8:	2300      	movs	r3, #0
 800d7fa:	763b      	strb	r3, [r7, #24]
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d7fc:	7979      	ldrb	r1, [r7, #5]
 800d7fe:	7e3b      	ldrb	r3, [r7, #24]
 800d800:	9303      	str	r3, [sp, #12]
 800d802:	88fb      	ldrh	r3, [r7, #6]
 800d804:	9302      	str	r3, [sp, #8]
 800d806:	68bb      	ldr	r3, [r7, #8]
 800d808:	9301      	str	r3, [sp, #4]
 800d80a:	2301      	movs	r3, #1
 800d80c:	9300      	str	r3, [sp, #0]
 800d80e:	2300      	movs	r3, #0
 800d810:	2200      	movs	r2, #0
 800d812:	68f8      	ldr	r0, [r7, #12]
 800d814:	f01f fce3 	bl	802d1de <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
 800d818:	2300      	movs	r3, #0
}
 800d81a:	4618      	mov	r0, r3
 800d81c:	3710      	adds	r7, #16
 800d81e:	46bd      	mov	sp, r7
 800d820:	bd80      	pop	{r7, pc}

0800d822 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 800d822:	b580      	push	{r7, lr}
 800d824:	b088      	sub	sp, #32
 800d826:	af04      	add	r7, sp, #16
 800d828:	60f8      	str	r0, [r7, #12]
 800d82a:	60b9      	str	r1, [r7, #8]
 800d82c:	4611      	mov	r1, r2
 800d82e:	461a      	mov	r2, r3
 800d830:	460b      	mov	r3, r1
 800d832:	80fb      	strh	r3, [r7, #6]
 800d834:	4613      	mov	r3, r2
 800d836:	717b      	strb	r3, [r7, #5]
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d838:	7979      	ldrb	r1, [r7, #5]
 800d83a:	2300      	movs	r3, #0
 800d83c:	9303      	str	r3, [sp, #12]
 800d83e:	88fb      	ldrh	r3, [r7, #6]
 800d840:	9302      	str	r3, [sp, #8]
 800d842:	68bb      	ldr	r3, [r7, #8]
 800d844:	9301      	str	r3, [sp, #4]
 800d846:	2301      	movs	r3, #1
 800d848:	9300      	str	r3, [sp, #0]
 800d84a:	2300      	movs	r3, #0
 800d84c:	2201      	movs	r2, #1
 800d84e:	68f8      	ldr	r0, [r7, #12]
 800d850:	f01f fcc5 	bl	802d1de <USBH_LL_SubmitURB>
                          USBH_EP_CONTROL,      /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
 800d854:	2300      	movs	r3, #0

}
 800d856:	4618      	mov	r0, r3
 800d858:	3710      	adds	r7, #16
 800d85a:	46bd      	mov	sp, r7
 800d85c:	bd80      	pop	{r7, pc}

0800d85e <USBH_BulkSendData>:
USBH_StatusTypeDef USBH_BulkSendData(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint16_t length,
                                     uint8_t pipe_num,
                                     uint8_t do_ping)
{
 800d85e:	b580      	push	{r7, lr}
 800d860:	b088      	sub	sp, #32
 800d862:	af04      	add	r7, sp, #16
 800d864:	60f8      	str	r0, [r7, #12]
 800d866:	60b9      	str	r1, [r7, #8]
 800d868:	4611      	mov	r1, r2
 800d86a:	461a      	mov	r2, r3
 800d86c:	460b      	mov	r3, r1
 800d86e:	80fb      	strh	r3, [r7, #6]
 800d870:	4613      	mov	r3, r2
 800d872:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 800d874:	68fb      	ldr	r3, [r7, #12]
 800d876:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d87a:	2b00      	cmp	r3, #0
 800d87c:	d001      	beq.n	800d882 <USBH_BulkSendData+0x24>
  {
    do_ping = 0U;
 800d87e:	2300      	movs	r3, #0
 800d880:	763b      	strb	r3, [r7, #24]
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d882:	7979      	ldrb	r1, [r7, #5]
 800d884:	7e3b      	ldrb	r3, [r7, #24]
 800d886:	9303      	str	r3, [sp, #12]
 800d888:	88fb      	ldrh	r3, [r7, #6]
 800d88a:	9302      	str	r3, [sp, #8]
 800d88c:	68bb      	ldr	r3, [r7, #8]
 800d88e:	9301      	str	r3, [sp, #4]
 800d890:	2301      	movs	r3, #1
 800d892:	9300      	str	r3, [sp, #0]
 800d894:	2302      	movs	r3, #2
 800d896:	2200      	movs	r2, #0
 800d898:	68f8      	ldr	r0, [r7, #12]
 800d89a:	f01f fca0 	bl	802d1de <USBH_LL_SubmitURB>
                          USBH_EP_BULK,         /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/
  return USBH_OK;
 800d89e:	2300      	movs	r3, #0
}
 800d8a0:	4618      	mov	r0, r3
 800d8a2:	3710      	adds	r7, #16
 800d8a4:	46bd      	mov	sp, r7
 800d8a6:	bd80      	pop	{r7, pc}

0800d8a8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 800d8a8:	b580      	push	{r7, lr}
 800d8aa:	b088      	sub	sp, #32
 800d8ac:	af04      	add	r7, sp, #16
 800d8ae:	60f8      	str	r0, [r7, #12]
 800d8b0:	60b9      	str	r1, [r7, #8]
 800d8b2:	4611      	mov	r1, r2
 800d8b4:	461a      	mov	r2, r3
 800d8b6:	460b      	mov	r3, r1
 800d8b8:	80fb      	strh	r3, [r7, #6]
 800d8ba:	4613      	mov	r3, r2
 800d8bc:	717b      	strb	r3, [r7, #5]
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d8be:	7979      	ldrb	r1, [r7, #5]
 800d8c0:	2300      	movs	r3, #0
 800d8c2:	9303      	str	r3, [sp, #12]
 800d8c4:	88fb      	ldrh	r3, [r7, #6]
 800d8c6:	9302      	str	r3, [sp, #8]
 800d8c8:	68bb      	ldr	r3, [r7, #8]
 800d8ca:	9301      	str	r3, [sp, #4]
 800d8cc:	2301      	movs	r3, #1
 800d8ce:	9300      	str	r3, [sp, #0]
 800d8d0:	2302      	movs	r3, #2
 800d8d2:	2201      	movs	r2, #1
 800d8d4:	68f8      	ldr	r0, [r7, #12]
 800d8d6:	f01f fc82 	bl	802d1de <USBH_LL_SubmitURB>
                          USBH_EP_BULK,         /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
 800d8da:	2300      	movs	r3, #0
}
 800d8dc:	4618      	mov	r0, r3
 800d8de:	3710      	adds	r7, #16
 800d8e0:	46bd      	mov	sp, r7
 800d8e2:	bd80      	pop	{r7, pc}

0800d8e4 <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 800d8e4:	b580      	push	{r7, lr}
 800d8e6:	b086      	sub	sp, #24
 800d8e8:	af04      	add	r7, sp, #16
 800d8ea:	6078      	str	r0, [r7, #4]
 800d8ec:	4608      	mov	r0, r1
 800d8ee:	4611      	mov	r1, r2
 800d8f0:	461a      	mov	r2, r3
 800d8f2:	4603      	mov	r3, r0
 800d8f4:	70fb      	strb	r3, [r7, #3]
 800d8f6:	460b      	mov	r3, r1
 800d8f8:	70bb      	strb	r3, [r7, #2]
 800d8fa:	4613      	mov	r3, r2
 800d8fc:	707b      	strb	r3, [r7, #1]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800d8fe:	7878      	ldrb	r0, [r7, #1]
 800d900:	78ba      	ldrb	r2, [r7, #2]
 800d902:	78f9      	ldrb	r1, [r7, #3]
 800d904:	8b3b      	ldrh	r3, [r7, #24]
 800d906:	9302      	str	r3, [sp, #8]
 800d908:	7d3b      	ldrb	r3, [r7, #20]
 800d90a:	9301      	str	r3, [sp, #4]
 800d90c:	7c3b      	ldrb	r3, [r7, #16]
 800d90e:	9300      	str	r3, [sp, #0]
 800d910:	4603      	mov	r3, r0
 800d912:	6878      	ldr	r0, [r7, #4]
 800d914:	f01f fc15 	bl	802d142 <USBH_LL_OpenPipe>

  return USBH_OK;
 800d918:	2300      	movs	r3, #0
}
 800d91a:	4618      	mov	r0, r3
 800d91c:	3708      	adds	r7, #8
 800d91e:	46bd      	mov	sp, r7
 800d920:	bd80      	pop	{r7, pc}

0800d922 <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 800d922:	b580      	push	{r7, lr}
 800d924:	b082      	sub	sp, #8
 800d926:	af00      	add	r7, sp, #0
 800d928:	6078      	str	r0, [r7, #4]
 800d92a:	460b      	mov	r3, r1
 800d92c:	70fb      	strb	r3, [r7, #3]
  (void)USBH_LL_ClosePipe(phost, pipe_num);
 800d92e:	78fb      	ldrb	r3, [r7, #3]
 800d930:	4619      	mov	r1, r3
 800d932:	6878      	ldr	r0, [r7, #4]
 800d934:	f01f fc34 	bl	802d1a0 <USBH_LL_ClosePipe>

  return USBH_OK;
 800d938:	2300      	movs	r3, #0
}
 800d93a:	4618      	mov	r0, r3
 800d93c:	3708      	adds	r7, #8
 800d93e:	46bd      	mov	sp, r7
 800d940:	bd80      	pop	{r7, pc}

0800d942 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 800d942:	b580      	push	{r7, lr}
 800d944:	b084      	sub	sp, #16
 800d946:	af00      	add	r7, sp, #0
 800d948:	6078      	str	r0, [r7, #4]
 800d94a:	460b      	mov	r3, r1
 800d94c:	70fb      	strb	r3, [r7, #3]
  uint16_t pipe;

  pipe =  USBH_GetFreePipe(phost);
 800d94e:	6878      	ldr	r0, [r7, #4]
 800d950:	f000 f836 	bl	800d9c0 <USBH_GetFreePipe>
 800d954:	4603      	mov	r3, r0
 800d956:	81fb      	strh	r3, [r7, #14]

  if (pipe != 0xFFFFU)
 800d958:	89fb      	ldrh	r3, [r7, #14]
 800d95a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d95e:	4293      	cmp	r3, r2
 800d960:	d00a      	beq.n	800d978 <USBH_AllocPipe+0x36>
  {
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800d962:	78fa      	ldrb	r2, [r7, #3]
 800d964:	89fb      	ldrh	r3, [r7, #14]
 800d966:	f003 030f 	and.w	r3, r3, #15
 800d96a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800d96e:	6879      	ldr	r1, [r7, #4]
 800d970:	33e0      	adds	r3, #224	@ 0xe0
 800d972:	009b      	lsls	r3, r3, #2
 800d974:	440b      	add	r3, r1
 800d976:	605a      	str	r2, [r3, #4]
  }

  return (uint8_t)pipe;
 800d978:	89fb      	ldrh	r3, [r7, #14]
 800d97a:	b2db      	uxtb	r3, r3
}
 800d97c:	4618      	mov	r0, r3
 800d97e:	3710      	adds	r7, #16
 800d980:	46bd      	mov	sp, r7
 800d982:	bd80      	pop	{r7, pc}

0800d984 <USBH_FreePipe>:
  * @param  phost: Host Handle
  * @param  idx: Pipe number to be freed
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_FreePipe(USBH_HandleTypeDef *phost, uint8_t idx)
{
 800d984:	b480      	push	{r7}
 800d986:	b083      	sub	sp, #12
 800d988:	af00      	add	r7, sp, #0
 800d98a:	6078      	str	r0, [r7, #4]
 800d98c:	460b      	mov	r3, r1
 800d98e:	70fb      	strb	r3, [r7, #3]
  if (idx < USBH_MAX_PIPES_NBR)
 800d990:	78fb      	ldrb	r3, [r7, #3]
 800d992:	2b0f      	cmp	r3, #15
 800d994:	d80d      	bhi.n	800d9b2 <USBH_FreePipe+0x2e>
  {
    phost->Pipes[idx] &= 0x7FFFU;
 800d996:	78fb      	ldrb	r3, [r7, #3]
 800d998:	687a      	ldr	r2, [r7, #4]
 800d99a:	33e0      	adds	r3, #224	@ 0xe0
 800d99c:	009b      	lsls	r3, r3, #2
 800d99e:	4413      	add	r3, r2
 800d9a0:	685a      	ldr	r2, [r3, #4]
 800d9a2:	78fb      	ldrb	r3, [r7, #3]
 800d9a4:	f3c2 020e 	ubfx	r2, r2, #0, #15
 800d9a8:	6879      	ldr	r1, [r7, #4]
 800d9aa:	33e0      	adds	r3, #224	@ 0xe0
 800d9ac:	009b      	lsls	r3, r3, #2
 800d9ae:	440b      	add	r3, r1
 800d9b0:	605a      	str	r2, [r3, #4]
  }

  return USBH_OK;
 800d9b2:	2300      	movs	r3, #0
}
 800d9b4:	4618      	mov	r0, r3
 800d9b6:	370c      	adds	r7, #12
 800d9b8:	46bd      	mov	sp, r7
 800d9ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9be:	4770      	bx	lr

0800d9c0 <USBH_GetFreePipe>:
  * @param  phost: Host Handle
  *         Get a free Pipe number for allocation to a device endpoint
  * @retval idx: Free Pipe number
  */
static uint16_t USBH_GetFreePipe(USBH_HandleTypeDef *phost)
{
 800d9c0:	b480      	push	{r7}
 800d9c2:	b085      	sub	sp, #20
 800d9c4:	af00      	add	r7, sp, #0
 800d9c6:	6078      	str	r0, [r7, #4]
  uint8_t idx = 0U;
 800d9c8:	2300      	movs	r3, #0
 800d9ca:	73fb      	strb	r3, [r7, #15]

  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d9cc:	2300      	movs	r3, #0
 800d9ce:	73fb      	strb	r3, [r7, #15]
 800d9d0:	e00f      	b.n	800d9f2 <USBH_GetFreePipe+0x32>
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 800d9d2:	7bfb      	ldrb	r3, [r7, #15]
 800d9d4:	687a      	ldr	r2, [r7, #4]
 800d9d6:	33e0      	adds	r3, #224	@ 0xe0
 800d9d8:	009b      	lsls	r3, r3, #2
 800d9da:	4413      	add	r3, r2
 800d9dc:	685b      	ldr	r3, [r3, #4]
 800d9de:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800d9e2:	2b00      	cmp	r3, #0
 800d9e4:	d102      	bne.n	800d9ec <USBH_GetFreePipe+0x2c>
    {
      return (uint16_t)idx;
 800d9e6:	7bfb      	ldrb	r3, [r7, #15]
 800d9e8:	b29b      	uxth	r3, r3
 800d9ea:	e007      	b.n	800d9fc <USBH_GetFreePipe+0x3c>
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d9ec:	7bfb      	ldrb	r3, [r7, #15]
 800d9ee:	3301      	adds	r3, #1
 800d9f0:	73fb      	strb	r3, [r7, #15]
 800d9f2:	7bfb      	ldrb	r3, [r7, #15]
 800d9f4:	2b0f      	cmp	r3, #15
 800d9f6:	d9ec      	bls.n	800d9d2 <USBH_GetFreePipe+0x12>
    }
  }

  return 0xFFFFU;
 800d9f8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
}
 800d9fc:	4618      	mov	r0, r3
 800d9fe:	3714      	adds	r7, #20
 800da00:	46bd      	mov	sp, r7
 800da02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da06:	4770      	bx	lr

0800da08 <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
 800da08:	b580      	push	{r7, lr}
 800da0a:	b084      	sub	sp, #16
 800da0c:	af00      	add	r7, sp, #0
 800da0e:	4603      	mov	r3, r0
 800da10:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800da12:	79fb      	ldrb	r3, [r7, #7]
 800da14:	4a08      	ldr	r2, [pc, #32]	@ (800da38 <disk_status+0x30>)
 800da16:	009b      	lsls	r3, r3, #2
 800da18:	4413      	add	r3, r2
 800da1a:	685b      	ldr	r3, [r3, #4]
 800da1c:	685b      	ldr	r3, [r3, #4]
 800da1e:	79fa      	ldrb	r2, [r7, #7]
 800da20:	4905      	ldr	r1, [pc, #20]	@ (800da38 <disk_status+0x30>)
 800da22:	440a      	add	r2, r1
 800da24:	7a12      	ldrb	r2, [r2, #8]
 800da26:	4610      	mov	r0, r2
 800da28:	4798      	blx	r3
 800da2a:	4603      	mov	r3, r0
 800da2c:	73fb      	strb	r3, [r7, #15]
  return stat;
 800da2e:	7bfb      	ldrb	r3, [r7, #15]
}
 800da30:	4618      	mov	r0, r3
 800da32:	3710      	adds	r7, #16
 800da34:	46bd      	mov	sp, r7
 800da36:	bd80      	pop	{r7, pc}
 800da38:	20002914 	.word	0x20002914

0800da3c <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 800da3c:	b580      	push	{r7, lr}
 800da3e:	b084      	sub	sp, #16
 800da40:	af00      	add	r7, sp, #0
 800da42:	4603      	mov	r3, r0
 800da44:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat = RES_OK;
 800da46:	2300      	movs	r3, #0
 800da48:	73fb      	strb	r3, [r7, #15]

  if(disk.is_initialized[pdrv] == 0)
 800da4a:	79fb      	ldrb	r3, [r7, #7]
 800da4c:	4a0e      	ldr	r2, [pc, #56]	@ (800da88 <disk_initialize+0x4c>)
 800da4e:	5cd3      	ldrb	r3, [r2, r3]
 800da50:	2b00      	cmp	r3, #0
 800da52:	d114      	bne.n	800da7e <disk_initialize+0x42>
  {
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800da54:	79fb      	ldrb	r3, [r7, #7]
 800da56:	4a0c      	ldr	r2, [pc, #48]	@ (800da88 <disk_initialize+0x4c>)
 800da58:	009b      	lsls	r3, r3, #2
 800da5a:	4413      	add	r3, r2
 800da5c:	685b      	ldr	r3, [r3, #4]
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	79fa      	ldrb	r2, [r7, #7]
 800da62:	4909      	ldr	r1, [pc, #36]	@ (800da88 <disk_initialize+0x4c>)
 800da64:	440a      	add	r2, r1
 800da66:	7a12      	ldrb	r2, [r2, #8]
 800da68:	4610      	mov	r0, r2
 800da6a:	4798      	blx	r3
 800da6c:	4603      	mov	r3, r0
 800da6e:	73fb      	strb	r3, [r7, #15]
    if(stat == RES_OK)
 800da70:	7bfb      	ldrb	r3, [r7, #15]
 800da72:	2b00      	cmp	r3, #0
 800da74:	d103      	bne.n	800da7e <disk_initialize+0x42>
    {
      disk.is_initialized[pdrv] = 1;
 800da76:	79fb      	ldrb	r3, [r7, #7]
 800da78:	4a03      	ldr	r2, [pc, #12]	@ (800da88 <disk_initialize+0x4c>)
 800da7a:	2101      	movs	r1, #1
 800da7c:	54d1      	strb	r1, [r2, r3]
    }
  }
  return stat;
 800da7e:	7bfb      	ldrb	r3, [r7, #15]
}
 800da80:	4618      	mov	r0, r3
 800da82:	3710      	adds	r7, #16
 800da84:	46bd      	mov	sp, r7
 800da86:	bd80      	pop	{r7, pc}
 800da88:	20002914 	.word	0x20002914

0800da8c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800da8c:	b590      	push	{r4, r7, lr}
 800da8e:	b087      	sub	sp, #28
 800da90:	af00      	add	r7, sp, #0
 800da92:	60b9      	str	r1, [r7, #8]
 800da94:	607a      	str	r2, [r7, #4]
 800da96:	603b      	str	r3, [r7, #0]
 800da98:	4603      	mov	r3, r0
 800da9a:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800da9c:	7bfb      	ldrb	r3, [r7, #15]
 800da9e:	4a0a      	ldr	r2, [pc, #40]	@ (800dac8 <disk_read+0x3c>)
 800daa0:	009b      	lsls	r3, r3, #2
 800daa2:	4413      	add	r3, r2
 800daa4:	685b      	ldr	r3, [r3, #4]
 800daa6:	689c      	ldr	r4, [r3, #8]
 800daa8:	7bfb      	ldrb	r3, [r7, #15]
 800daaa:	4a07      	ldr	r2, [pc, #28]	@ (800dac8 <disk_read+0x3c>)
 800daac:	4413      	add	r3, r2
 800daae:	7a18      	ldrb	r0, [r3, #8]
 800dab0:	683b      	ldr	r3, [r7, #0]
 800dab2:	687a      	ldr	r2, [r7, #4]
 800dab4:	68b9      	ldr	r1, [r7, #8]
 800dab6:	47a0      	blx	r4
 800dab8:	4603      	mov	r3, r0
 800daba:	75fb      	strb	r3, [r7, #23]
  return res;
 800dabc:	7dfb      	ldrb	r3, [r7, #23]
}
 800dabe:	4618      	mov	r0, r3
 800dac0:	371c      	adds	r7, #28
 800dac2:	46bd      	mov	sp, r7
 800dac4:	bd90      	pop	{r4, r7, pc}
 800dac6:	bf00      	nop
 800dac8:	20002914 	.word	0x20002914

0800dacc <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 800dacc:	b590      	push	{r4, r7, lr}
 800dace:	b087      	sub	sp, #28
 800dad0:	af00      	add	r7, sp, #0
 800dad2:	60b9      	str	r1, [r7, #8]
 800dad4:	607a      	str	r2, [r7, #4]
 800dad6:	603b      	str	r3, [r7, #0]
 800dad8:	4603      	mov	r3, r0
 800dada:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 800dadc:	7bfb      	ldrb	r3, [r7, #15]
 800dade:	4a0a      	ldr	r2, [pc, #40]	@ (800db08 <disk_write+0x3c>)
 800dae0:	009b      	lsls	r3, r3, #2
 800dae2:	4413      	add	r3, r2
 800dae4:	685b      	ldr	r3, [r3, #4]
 800dae6:	68dc      	ldr	r4, [r3, #12]
 800dae8:	7bfb      	ldrb	r3, [r7, #15]
 800daea:	4a07      	ldr	r2, [pc, #28]	@ (800db08 <disk_write+0x3c>)
 800daec:	4413      	add	r3, r2
 800daee:	7a18      	ldrb	r0, [r3, #8]
 800daf0:	683b      	ldr	r3, [r7, #0]
 800daf2:	687a      	ldr	r2, [r7, #4]
 800daf4:	68b9      	ldr	r1, [r7, #8]
 800daf6:	47a0      	blx	r4
 800daf8:	4603      	mov	r3, r0
 800dafa:	75fb      	strb	r3, [r7, #23]
  return res;
 800dafc:	7dfb      	ldrb	r3, [r7, #23]
}
 800dafe:	4618      	mov	r0, r3
 800db00:	371c      	adds	r7, #28
 800db02:	46bd      	mov	sp, r7
 800db04:	bd90      	pop	{r4, r7, pc}
 800db06:	bf00      	nop
 800db08:	20002914 	.word	0x20002914

0800db0c <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 800db0c:	b580      	push	{r7, lr}
 800db0e:	b084      	sub	sp, #16
 800db10:	af00      	add	r7, sp, #0
 800db12:	4603      	mov	r3, r0
 800db14:	603a      	str	r2, [r7, #0]
 800db16:	71fb      	strb	r3, [r7, #7]
 800db18:	460b      	mov	r3, r1
 800db1a:	71bb      	strb	r3, [r7, #6]
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800db1c:	79fb      	ldrb	r3, [r7, #7]
 800db1e:	4a09      	ldr	r2, [pc, #36]	@ (800db44 <disk_ioctl+0x38>)
 800db20:	009b      	lsls	r3, r3, #2
 800db22:	4413      	add	r3, r2
 800db24:	685b      	ldr	r3, [r3, #4]
 800db26:	691b      	ldr	r3, [r3, #16]
 800db28:	79fa      	ldrb	r2, [r7, #7]
 800db2a:	4906      	ldr	r1, [pc, #24]	@ (800db44 <disk_ioctl+0x38>)
 800db2c:	440a      	add	r2, r1
 800db2e:	7a10      	ldrb	r0, [r2, #8]
 800db30:	79b9      	ldrb	r1, [r7, #6]
 800db32:	683a      	ldr	r2, [r7, #0]
 800db34:	4798      	blx	r3
 800db36:	4603      	mov	r3, r0
 800db38:	73fb      	strb	r3, [r7, #15]
  return res;
 800db3a:	7bfb      	ldrb	r3, [r7, #15]
}
 800db3c:	4618      	mov	r0, r3
 800db3e:	3710      	adds	r7, #16
 800db40:	46bd      	mov	sp, r7
 800db42:	bd80      	pop	{r7, pc}
 800db44:	20002914 	.word	0x20002914

0800db48 <ld_word>:
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static
WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
 800db48:	b480      	push	{r7}
 800db4a:	b085      	sub	sp, #20
 800db4c:	af00      	add	r7, sp, #0
 800db4e:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
 800db50:	687b      	ldr	r3, [r7, #4]
 800db52:	3301      	adds	r3, #1
 800db54:	781b      	ldrb	r3, [r3, #0]
 800db56:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
 800db58:	89fb      	ldrh	r3, [r7, #14]
 800db5a:	021b      	lsls	r3, r3, #8
 800db5c:	b21a      	sxth	r2, r3
 800db5e:	687b      	ldr	r3, [r7, #4]
 800db60:	781b      	ldrb	r3, [r3, #0]
 800db62:	b21b      	sxth	r3, r3
 800db64:	4313      	orrs	r3, r2
 800db66:	b21b      	sxth	r3, r3
 800db68:	81fb      	strh	r3, [r7, #14]
	return rv;
 800db6a:	89fb      	ldrh	r3, [r7, #14]
}
 800db6c:	4618      	mov	r0, r3
 800db6e:	3714      	adds	r7, #20
 800db70:	46bd      	mov	sp, r7
 800db72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db76:	4770      	bx	lr

0800db78 <ld_dword>:

static
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
 800db78:	b480      	push	{r7}
 800db7a:	b085      	sub	sp, #20
 800db7c:	af00      	add	r7, sp, #0
 800db7e:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
 800db80:	687b      	ldr	r3, [r7, #4]
 800db82:	3303      	adds	r3, #3
 800db84:	781b      	ldrb	r3, [r3, #0]
 800db86:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
 800db88:	68fb      	ldr	r3, [r7, #12]
 800db8a:	021b      	lsls	r3, r3, #8
 800db8c:	687a      	ldr	r2, [r7, #4]
 800db8e:	3202      	adds	r2, #2
 800db90:	7812      	ldrb	r2, [r2, #0]
 800db92:	4313      	orrs	r3, r2
 800db94:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
 800db96:	68fb      	ldr	r3, [r7, #12]
 800db98:	021b      	lsls	r3, r3, #8
 800db9a:	687a      	ldr	r2, [r7, #4]
 800db9c:	3201      	adds	r2, #1
 800db9e:	7812      	ldrb	r2, [r2, #0]
 800dba0:	4313      	orrs	r3, r2
 800dba2:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
 800dba4:	68fb      	ldr	r3, [r7, #12]
 800dba6:	021b      	lsls	r3, r3, #8
 800dba8:	687a      	ldr	r2, [r7, #4]
 800dbaa:	7812      	ldrb	r2, [r2, #0]
 800dbac:	4313      	orrs	r3, r2
 800dbae:	60fb      	str	r3, [r7, #12]
	return rv;
 800dbb0:	68fb      	ldr	r3, [r7, #12]
}
 800dbb2:	4618      	mov	r0, r3
 800dbb4:	3714      	adds	r7, #20
 800dbb6:	46bd      	mov	sp, r7
 800dbb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbbc:	4770      	bx	lr

0800dbbe <st_word>:
#endif

#if !_FS_READONLY
static
void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
 800dbbe:	b480      	push	{r7}
 800dbc0:	b083      	sub	sp, #12
 800dbc2:	af00      	add	r7, sp, #0
 800dbc4:	6078      	str	r0, [r7, #4]
 800dbc6:	460b      	mov	r3, r1
 800dbc8:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 800dbca:	687b      	ldr	r3, [r7, #4]
 800dbcc:	1c5a      	adds	r2, r3, #1
 800dbce:	607a      	str	r2, [r7, #4]
 800dbd0:	887a      	ldrh	r2, [r7, #2]
 800dbd2:	b2d2      	uxtb	r2, r2
 800dbd4:	701a      	strb	r2, [r3, #0]
 800dbd6:	887b      	ldrh	r3, [r7, #2]
 800dbd8:	0a1b      	lsrs	r3, r3, #8
 800dbda:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
 800dbdc:	687b      	ldr	r3, [r7, #4]
 800dbde:	1c5a      	adds	r2, r3, #1
 800dbe0:	607a      	str	r2, [r7, #4]
 800dbe2:	887a      	ldrh	r2, [r7, #2]
 800dbe4:	b2d2      	uxtb	r2, r2
 800dbe6:	701a      	strb	r2, [r3, #0]
}
 800dbe8:	bf00      	nop
 800dbea:	370c      	adds	r7, #12
 800dbec:	46bd      	mov	sp, r7
 800dbee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbf2:	4770      	bx	lr

0800dbf4 <st_dword>:

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
 800dbf4:	b480      	push	{r7}
 800dbf6:	b083      	sub	sp, #12
 800dbf8:	af00      	add	r7, sp, #0
 800dbfa:	6078      	str	r0, [r7, #4]
 800dbfc:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dbfe:	687b      	ldr	r3, [r7, #4]
 800dc00:	1c5a      	adds	r2, r3, #1
 800dc02:	607a      	str	r2, [r7, #4]
 800dc04:	683a      	ldr	r2, [r7, #0]
 800dc06:	b2d2      	uxtb	r2, r2
 800dc08:	701a      	strb	r2, [r3, #0]
 800dc0a:	683b      	ldr	r3, [r7, #0]
 800dc0c:	0a1b      	lsrs	r3, r3, #8
 800dc0e:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc10:	687b      	ldr	r3, [r7, #4]
 800dc12:	1c5a      	adds	r2, r3, #1
 800dc14:	607a      	str	r2, [r7, #4]
 800dc16:	683a      	ldr	r2, [r7, #0]
 800dc18:	b2d2      	uxtb	r2, r2
 800dc1a:	701a      	strb	r2, [r3, #0]
 800dc1c:	683b      	ldr	r3, [r7, #0]
 800dc1e:	0a1b      	lsrs	r3, r3, #8
 800dc20:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc22:	687b      	ldr	r3, [r7, #4]
 800dc24:	1c5a      	adds	r2, r3, #1
 800dc26:	607a      	str	r2, [r7, #4]
 800dc28:	683a      	ldr	r2, [r7, #0]
 800dc2a:	b2d2      	uxtb	r2, r2
 800dc2c:	701a      	strb	r2, [r3, #0]
 800dc2e:	683b      	ldr	r3, [r7, #0]
 800dc30:	0a1b      	lsrs	r3, r3, #8
 800dc32:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
 800dc34:	687b      	ldr	r3, [r7, #4]
 800dc36:	1c5a      	adds	r2, r3, #1
 800dc38:	607a      	str	r2, [r7, #4]
 800dc3a:	683a      	ldr	r2, [r7, #0]
 800dc3c:	b2d2      	uxtb	r2, r2
 800dc3e:	701a      	strb	r2, [r3, #0]
}
 800dc40:	bf00      	nop
 800dc42:	370c      	adds	r7, #12
 800dc44:	46bd      	mov	sp, r7
 800dc46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc4a:	4770      	bx	lr

0800dc4c <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800dc4c:	b480      	push	{r7}
 800dc4e:	b087      	sub	sp, #28
 800dc50:	af00      	add	r7, sp, #0
 800dc52:	60f8      	str	r0, [r7, #12]
 800dc54:	60b9      	str	r1, [r7, #8]
 800dc56:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800dc58:	68fb      	ldr	r3, [r7, #12]
 800dc5a:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 800dc5c:	68bb      	ldr	r3, [r7, #8]
 800dc5e:	613b      	str	r3, [r7, #16]

	if (cnt) {
 800dc60:	687b      	ldr	r3, [r7, #4]
 800dc62:	2b00      	cmp	r3, #0
 800dc64:	d00d      	beq.n	800dc82 <mem_cpy+0x36>
		do {
			*d++ = *s++;
 800dc66:	693a      	ldr	r2, [r7, #16]
 800dc68:	1c53      	adds	r3, r2, #1
 800dc6a:	613b      	str	r3, [r7, #16]
 800dc6c:	697b      	ldr	r3, [r7, #20]
 800dc6e:	1c59      	adds	r1, r3, #1
 800dc70:	6179      	str	r1, [r7, #20]
 800dc72:	7812      	ldrb	r2, [r2, #0]
 800dc74:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
 800dc76:	687b      	ldr	r3, [r7, #4]
 800dc78:	3b01      	subs	r3, #1
 800dc7a:	607b      	str	r3, [r7, #4]
 800dc7c:	687b      	ldr	r3, [r7, #4]
 800dc7e:	2b00      	cmp	r3, #0
 800dc80:	d1f1      	bne.n	800dc66 <mem_cpy+0x1a>
	}
}
 800dc82:	bf00      	nop
 800dc84:	371c      	adds	r7, #28
 800dc86:	46bd      	mov	sp, r7
 800dc88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc8c:	4770      	bx	lr

0800dc8e <mem_set>:

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
 800dc8e:	b480      	push	{r7}
 800dc90:	b087      	sub	sp, #28
 800dc92:	af00      	add	r7, sp, #0
 800dc94:	60f8      	str	r0, [r7, #12]
 800dc96:	60b9      	str	r1, [r7, #8]
 800dc98:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800dc9a:	68fb      	ldr	r3, [r7, #12]
 800dc9c:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
 800dc9e:	697b      	ldr	r3, [r7, #20]
 800dca0:	1c5a      	adds	r2, r3, #1
 800dca2:	617a      	str	r2, [r7, #20]
 800dca4:	68ba      	ldr	r2, [r7, #8]
 800dca6:	b2d2      	uxtb	r2, r2
 800dca8:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
 800dcaa:	687b      	ldr	r3, [r7, #4]
 800dcac:	3b01      	subs	r3, #1
 800dcae:	607b      	str	r3, [r7, #4]
 800dcb0:	687b      	ldr	r3, [r7, #4]
 800dcb2:	2b00      	cmp	r3, #0
 800dcb4:	d1f3      	bne.n	800dc9e <mem_set+0x10>
}
 800dcb6:	bf00      	nop
 800dcb8:	bf00      	nop
 800dcba:	371c      	adds	r7, #28
 800dcbc:	46bd      	mov	sp, r7
 800dcbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcc2:	4770      	bx	lr

0800dcc4 <mem_cmp>:

/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
 800dcc4:	b480      	push	{r7}
 800dcc6:	b089      	sub	sp, #36	@ 0x24
 800dcc8:	af00      	add	r7, sp, #0
 800dcca:	60f8      	str	r0, [r7, #12]
 800dccc:	60b9      	str	r1, [r7, #8]
 800dcce:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 800dcd0:	68fb      	ldr	r3, [r7, #12]
 800dcd2:	61fb      	str	r3, [r7, #28]
 800dcd4:	68bb      	ldr	r3, [r7, #8]
 800dcd6:	61bb      	str	r3, [r7, #24]
	int r = 0;
 800dcd8:	2300      	movs	r3, #0
 800dcda:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
 800dcdc:	69fb      	ldr	r3, [r7, #28]
 800dcde:	1c5a      	adds	r2, r3, #1
 800dce0:	61fa      	str	r2, [r7, #28]
 800dce2:	781b      	ldrb	r3, [r3, #0]
 800dce4:	4619      	mov	r1, r3
 800dce6:	69bb      	ldr	r3, [r7, #24]
 800dce8:	1c5a      	adds	r2, r3, #1
 800dcea:	61ba      	str	r2, [r7, #24]
 800dcec:	781b      	ldrb	r3, [r3, #0]
 800dcee:	1acb      	subs	r3, r1, r3
 800dcf0:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	3b01      	subs	r3, #1
 800dcf6:	607b      	str	r3, [r7, #4]
 800dcf8:	687b      	ldr	r3, [r7, #4]
 800dcfa:	2b00      	cmp	r3, #0
 800dcfc:	d002      	beq.n	800dd04 <mem_cmp+0x40>
 800dcfe:	697b      	ldr	r3, [r7, #20]
 800dd00:	2b00      	cmp	r3, #0
 800dd02:	d0eb      	beq.n	800dcdc <mem_cmp+0x18>

	return r;
 800dd04:	697b      	ldr	r3, [r7, #20]
}
 800dd06:	4618      	mov	r0, r3
 800dd08:	3724      	adds	r7, #36	@ 0x24
 800dd0a:	46bd      	mov	sp, r7
 800dd0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd10:	4770      	bx	lr

0800dd12 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
 800dd12:	b480      	push	{r7}
 800dd14:	b083      	sub	sp, #12
 800dd16:	af00      	add	r7, sp, #0
 800dd18:	6078      	str	r0, [r7, #4]
 800dd1a:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 800dd1c:	e002      	b.n	800dd24 <chk_chr+0x12>
 800dd1e:	687b      	ldr	r3, [r7, #4]
 800dd20:	3301      	adds	r3, #1
 800dd22:	607b      	str	r3, [r7, #4]
 800dd24:	687b      	ldr	r3, [r7, #4]
 800dd26:	781b      	ldrb	r3, [r3, #0]
 800dd28:	2b00      	cmp	r3, #0
 800dd2a:	d005      	beq.n	800dd38 <chk_chr+0x26>
 800dd2c:	687b      	ldr	r3, [r7, #4]
 800dd2e:	781b      	ldrb	r3, [r3, #0]
 800dd30:	461a      	mov	r2, r3
 800dd32:	683b      	ldr	r3, [r7, #0]
 800dd34:	4293      	cmp	r3, r2
 800dd36:	d1f2      	bne.n	800dd1e <chk_chr+0xc>
	return *str;
 800dd38:	687b      	ldr	r3, [r7, #4]
 800dd3a:	781b      	ldrb	r3, [r3, #0]
}
 800dd3c:	4618      	mov	r0, r3
 800dd3e:	370c      	adds	r7, #12
 800dd40:	46bd      	mov	sp, r7
 800dd42:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd46:	4770      	bx	lr

0800dd48 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 800dd48:	b480      	push	{r7}
 800dd4a:	b085      	sub	sp, #20
 800dd4c:	af00      	add	r7, sp, #0
 800dd4e:	6078      	str	r0, [r7, #4]
 800dd50:	6039      	str	r1, [r7, #0]
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 800dd52:	2300      	movs	r3, #0
 800dd54:	60bb      	str	r3, [r7, #8]
 800dd56:	68bb      	ldr	r3, [r7, #8]
 800dd58:	60fb      	str	r3, [r7, #12]
 800dd5a:	e029      	b.n	800ddb0 <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
 800dd5c:	4a27      	ldr	r2, [pc, #156]	@ (800ddfc <chk_lock+0xb4>)
 800dd5e:	68fb      	ldr	r3, [r7, #12]
 800dd60:	011b      	lsls	r3, r3, #4
 800dd62:	4413      	add	r3, r2
 800dd64:	681b      	ldr	r3, [r3, #0]
 800dd66:	2b00      	cmp	r3, #0
 800dd68:	d01d      	beq.n	800dda6 <chk_lock+0x5e>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800dd6a:	4a24      	ldr	r2, [pc, #144]	@ (800ddfc <chk_lock+0xb4>)
 800dd6c:	68fb      	ldr	r3, [r7, #12]
 800dd6e:	011b      	lsls	r3, r3, #4
 800dd70:	4413      	add	r3, r2
 800dd72:	681a      	ldr	r2, [r3, #0]
 800dd74:	687b      	ldr	r3, [r7, #4]
 800dd76:	681b      	ldr	r3, [r3, #0]
 800dd78:	429a      	cmp	r2, r3
 800dd7a:	d116      	bne.n	800ddaa <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
 800dd7c:	4a1f      	ldr	r2, [pc, #124]	@ (800ddfc <chk_lock+0xb4>)
 800dd7e:	68fb      	ldr	r3, [r7, #12]
 800dd80:	011b      	lsls	r3, r3, #4
 800dd82:	4413      	add	r3, r2
 800dd84:	3304      	adds	r3, #4
 800dd86:	681a      	ldr	r2, [r3, #0]
 800dd88:	687b      	ldr	r3, [r7, #4]
 800dd8a:	689b      	ldr	r3, [r3, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800dd8c:	429a      	cmp	r2, r3
 800dd8e:	d10c      	bne.n	800ddaa <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 800dd90:	4a1a      	ldr	r2, [pc, #104]	@ (800ddfc <chk_lock+0xb4>)
 800dd92:	68fb      	ldr	r3, [r7, #12]
 800dd94:	011b      	lsls	r3, r3, #4
 800dd96:	4413      	add	r3, r2
 800dd98:	3308      	adds	r3, #8
 800dd9a:	681a      	ldr	r2, [r3, #0]
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	695b      	ldr	r3, [r3, #20]
				Files[i].clu == dp->obj.sclust &&
 800dda0:	429a      	cmp	r2, r3
 800dda2:	d102      	bne.n	800ddaa <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 800dda4:	e007      	b.n	800ddb6 <chk_lock+0x6e>
		} else {			/* Blank entry */
			be = 1;
 800dda6:	2301      	movs	r3, #1
 800dda8:	60bb      	str	r3, [r7, #8]
	for (i = be = 0; i < _FS_LOCK; i++) {
 800ddaa:	68fb      	ldr	r3, [r7, #12]
 800ddac:	3301      	adds	r3, #1
 800ddae:	60fb      	str	r3, [r7, #12]
 800ddb0:	68fb      	ldr	r3, [r7, #12]
 800ddb2:	2b01      	cmp	r3, #1
 800ddb4:	d9d2      	bls.n	800dd5c <chk_lock+0x14>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
 800ddb6:	68fb      	ldr	r3, [r7, #12]
 800ddb8:	2b02      	cmp	r3, #2
 800ddba:	d109      	bne.n	800ddd0 <chk_lock+0x88>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 800ddbc:	68bb      	ldr	r3, [r7, #8]
 800ddbe:	2b00      	cmp	r3, #0
 800ddc0:	d102      	bne.n	800ddc8 <chk_lock+0x80>
 800ddc2:	683b      	ldr	r3, [r7, #0]
 800ddc4:	2b02      	cmp	r3, #2
 800ddc6:	d101      	bne.n	800ddcc <chk_lock+0x84>
 800ddc8:	2300      	movs	r3, #0
 800ddca:	e010      	b.n	800ddee <chk_lock+0xa6>
 800ddcc:	2312      	movs	r3, #18
 800ddce:	e00e      	b.n	800ddee <chk_lock+0xa6>
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800ddd0:	683b      	ldr	r3, [r7, #0]
 800ddd2:	2b00      	cmp	r3, #0
 800ddd4:	d108      	bne.n	800dde8 <chk_lock+0xa0>
 800ddd6:	4a09      	ldr	r2, [pc, #36]	@ (800ddfc <chk_lock+0xb4>)
 800ddd8:	68fb      	ldr	r3, [r7, #12]
 800ddda:	011b      	lsls	r3, r3, #4
 800dddc:	4413      	add	r3, r2
 800ddde:	330c      	adds	r3, #12
 800dde0:	881b      	ldrh	r3, [r3, #0]
 800dde2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800dde6:	d101      	bne.n	800ddec <chk_lock+0xa4>
 800dde8:	2310      	movs	r3, #16
 800ddea:	e000      	b.n	800ddee <chk_lock+0xa6>
 800ddec:	2300      	movs	r3, #0
}
 800ddee:	4618      	mov	r0, r3
 800ddf0:	3714      	adds	r7, #20
 800ddf2:	46bd      	mov	sp, r7
 800ddf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddf8:	4770      	bx	lr
 800ddfa:	bf00      	nop
 800ddfc:	200028f4 	.word	0x200028f4

0800de00 <enq_lock>:


static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
 800de00:	b480      	push	{r7}
 800de02:	b083      	sub	sp, #12
 800de04:	af00      	add	r7, sp, #0
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800de06:	2300      	movs	r3, #0
 800de08:	607b      	str	r3, [r7, #4]
 800de0a:	e002      	b.n	800de12 <enq_lock+0x12>
 800de0c:	687b      	ldr	r3, [r7, #4]
 800de0e:	3301      	adds	r3, #1
 800de10:	607b      	str	r3, [r7, #4]
 800de12:	687b      	ldr	r3, [r7, #4]
 800de14:	2b01      	cmp	r3, #1
 800de16:	d806      	bhi.n	800de26 <enq_lock+0x26>
 800de18:	4a09      	ldr	r2, [pc, #36]	@ (800de40 <enq_lock+0x40>)
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	011b      	lsls	r3, r3, #4
 800de1e:	4413      	add	r3, r2
 800de20:	681b      	ldr	r3, [r3, #0]
 800de22:	2b00      	cmp	r3, #0
 800de24:	d1f2      	bne.n	800de0c <enq_lock+0xc>
	return (i == _FS_LOCK) ? 0 : 1;
 800de26:	687b      	ldr	r3, [r7, #4]
 800de28:	2b02      	cmp	r3, #2
 800de2a:	bf14      	ite	ne
 800de2c:	2301      	movne	r3, #1
 800de2e:	2300      	moveq	r3, #0
 800de30:	b2db      	uxtb	r3, r3
}
 800de32:	4618      	mov	r0, r3
 800de34:	370c      	adds	r7, #12
 800de36:	46bd      	mov	sp, r7
 800de38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de3c:	4770      	bx	lr
 800de3e:	bf00      	nop
 800de40:	200028f4 	.word	0x200028f4

0800de44 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 800de44:	b480      	push	{r7}
 800de46:	b085      	sub	sp, #20
 800de48:	af00      	add	r7, sp, #0
 800de4a:	6078      	str	r0, [r7, #4]
 800de4c:	6039      	str	r1, [r7, #0]
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800de4e:	2300      	movs	r3, #0
 800de50:	60fb      	str	r3, [r7, #12]
 800de52:	e01f      	b.n	800de94 <inc_lock+0x50>
		if (Files[i].fs == dp->obj.fs &&
 800de54:	4a41      	ldr	r2, [pc, #260]	@ (800df5c <inc_lock+0x118>)
 800de56:	68fb      	ldr	r3, [r7, #12]
 800de58:	011b      	lsls	r3, r3, #4
 800de5a:	4413      	add	r3, r2
 800de5c:	681a      	ldr	r2, [r3, #0]
 800de5e:	687b      	ldr	r3, [r7, #4]
 800de60:	681b      	ldr	r3, [r3, #0]
 800de62:	429a      	cmp	r2, r3
 800de64:	d113      	bne.n	800de8e <inc_lock+0x4a>
			Files[i].clu == dp->obj.sclust &&
 800de66:	4a3d      	ldr	r2, [pc, #244]	@ (800df5c <inc_lock+0x118>)
 800de68:	68fb      	ldr	r3, [r7, #12]
 800de6a:	011b      	lsls	r3, r3, #4
 800de6c:	4413      	add	r3, r2
 800de6e:	3304      	adds	r3, #4
 800de70:	681a      	ldr	r2, [r3, #0]
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	689b      	ldr	r3, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
 800de76:	429a      	cmp	r2, r3
 800de78:	d109      	bne.n	800de8e <inc_lock+0x4a>
			Files[i].ofs == dp->dptr) break;
 800de7a:	4a38      	ldr	r2, [pc, #224]	@ (800df5c <inc_lock+0x118>)
 800de7c:	68fb      	ldr	r3, [r7, #12]
 800de7e:	011b      	lsls	r3, r3, #4
 800de80:	4413      	add	r3, r2
 800de82:	3308      	adds	r3, #8
 800de84:	681a      	ldr	r2, [r3, #0]
 800de86:	687b      	ldr	r3, [r7, #4]
 800de88:	695b      	ldr	r3, [r3, #20]
			Files[i].clu == dp->obj.sclust &&
 800de8a:	429a      	cmp	r2, r3
 800de8c:	d006      	beq.n	800de9c <inc_lock+0x58>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800de8e:	68fb      	ldr	r3, [r7, #12]
 800de90:	3301      	adds	r3, #1
 800de92:	60fb      	str	r3, [r7, #12]
 800de94:	68fb      	ldr	r3, [r7, #12]
 800de96:	2b01      	cmp	r3, #1
 800de98:	d9dc      	bls.n	800de54 <inc_lock+0x10>
 800de9a:	e000      	b.n	800de9e <inc_lock+0x5a>
			Files[i].ofs == dp->dptr) break;
 800de9c:	bf00      	nop
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 800de9e:	68fb      	ldr	r3, [r7, #12]
 800dea0:	2b02      	cmp	r3, #2
 800dea2:	d132      	bne.n	800df0a <inc_lock+0xc6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800dea4:	2300      	movs	r3, #0
 800dea6:	60fb      	str	r3, [r7, #12]
 800dea8:	e002      	b.n	800deb0 <inc_lock+0x6c>
 800deaa:	68fb      	ldr	r3, [r7, #12]
 800deac:	3301      	adds	r3, #1
 800deae:	60fb      	str	r3, [r7, #12]
 800deb0:	68fb      	ldr	r3, [r7, #12]
 800deb2:	2b01      	cmp	r3, #1
 800deb4:	d806      	bhi.n	800dec4 <inc_lock+0x80>
 800deb6:	4a29      	ldr	r2, [pc, #164]	@ (800df5c <inc_lock+0x118>)
 800deb8:	68fb      	ldr	r3, [r7, #12]
 800deba:	011b      	lsls	r3, r3, #4
 800debc:	4413      	add	r3, r2
 800debe:	681b      	ldr	r3, [r3, #0]
 800dec0:	2b00      	cmp	r3, #0
 800dec2:	d1f2      	bne.n	800deaa <inc_lock+0x66>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 800dec4:	68fb      	ldr	r3, [r7, #12]
 800dec6:	2b02      	cmp	r3, #2
 800dec8:	d101      	bne.n	800dece <inc_lock+0x8a>
 800deca:	2300      	movs	r3, #0
 800decc:	e040      	b.n	800df50 <inc_lock+0x10c>
		Files[i].fs = dp->obj.fs;
 800dece:	687b      	ldr	r3, [r7, #4]
 800ded0:	681a      	ldr	r2, [r3, #0]
 800ded2:	4922      	ldr	r1, [pc, #136]	@ (800df5c <inc_lock+0x118>)
 800ded4:	68fb      	ldr	r3, [r7, #12]
 800ded6:	011b      	lsls	r3, r3, #4
 800ded8:	440b      	add	r3, r1
 800deda:	601a      	str	r2, [r3, #0]
		Files[i].clu = dp->obj.sclust;
 800dedc:	687b      	ldr	r3, [r7, #4]
 800dede:	689a      	ldr	r2, [r3, #8]
 800dee0:	491e      	ldr	r1, [pc, #120]	@ (800df5c <inc_lock+0x118>)
 800dee2:	68fb      	ldr	r3, [r7, #12]
 800dee4:	011b      	lsls	r3, r3, #4
 800dee6:	440b      	add	r3, r1
 800dee8:	3304      	adds	r3, #4
 800deea:	601a      	str	r2, [r3, #0]
		Files[i].ofs = dp->dptr;
 800deec:	687b      	ldr	r3, [r7, #4]
 800deee:	695a      	ldr	r2, [r3, #20]
 800def0:	491a      	ldr	r1, [pc, #104]	@ (800df5c <inc_lock+0x118>)
 800def2:	68fb      	ldr	r3, [r7, #12]
 800def4:	011b      	lsls	r3, r3, #4
 800def6:	440b      	add	r3, r1
 800def8:	3308      	adds	r3, #8
 800defa:	601a      	str	r2, [r3, #0]
		Files[i].ctr = 0;
 800defc:	4a17      	ldr	r2, [pc, #92]	@ (800df5c <inc_lock+0x118>)
 800defe:	68fb      	ldr	r3, [r7, #12]
 800df00:	011b      	lsls	r3, r3, #4
 800df02:	4413      	add	r3, r2
 800df04:	330c      	adds	r3, #12
 800df06:	2200      	movs	r2, #0
 800df08:	801a      	strh	r2, [r3, #0]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800df0a:	683b      	ldr	r3, [r7, #0]
 800df0c:	2b00      	cmp	r3, #0
 800df0e:	d009      	beq.n	800df24 <inc_lock+0xe0>
 800df10:	4a12      	ldr	r2, [pc, #72]	@ (800df5c <inc_lock+0x118>)
 800df12:	68fb      	ldr	r3, [r7, #12]
 800df14:	011b      	lsls	r3, r3, #4
 800df16:	4413      	add	r3, r2
 800df18:	330c      	adds	r3, #12
 800df1a:	881b      	ldrh	r3, [r3, #0]
 800df1c:	2b00      	cmp	r3, #0
 800df1e:	d001      	beq.n	800df24 <inc_lock+0xe0>
 800df20:	2300      	movs	r3, #0
 800df22:	e015      	b.n	800df50 <inc_lock+0x10c>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800df24:	683b      	ldr	r3, [r7, #0]
 800df26:	2b00      	cmp	r3, #0
 800df28:	d108      	bne.n	800df3c <inc_lock+0xf8>
 800df2a:	4a0c      	ldr	r2, [pc, #48]	@ (800df5c <inc_lock+0x118>)
 800df2c:	68fb      	ldr	r3, [r7, #12]
 800df2e:	011b      	lsls	r3, r3, #4
 800df30:	4413      	add	r3, r2
 800df32:	330c      	adds	r3, #12
 800df34:	881b      	ldrh	r3, [r3, #0]
 800df36:	3301      	adds	r3, #1
 800df38:	b29a      	uxth	r2, r3
 800df3a:	e001      	b.n	800df40 <inc_lock+0xfc>
 800df3c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800df40:	4906      	ldr	r1, [pc, #24]	@ (800df5c <inc_lock+0x118>)
 800df42:	68fb      	ldr	r3, [r7, #12]
 800df44:	011b      	lsls	r3, r3, #4
 800df46:	440b      	add	r3, r1
 800df48:	330c      	adds	r3, #12
 800df4a:	801a      	strh	r2, [r3, #0]

	return i + 1;
 800df4c:	68fb      	ldr	r3, [r7, #12]
 800df4e:	3301      	adds	r3, #1
}
 800df50:	4618      	mov	r0, r3
 800df52:	3714      	adds	r7, #20
 800df54:	46bd      	mov	sp, r7
 800df56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df5a:	4770      	bx	lr
 800df5c:	200028f4 	.word	0x200028f4

0800df60 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
 800df60:	b480      	push	{r7}
 800df62:	b085      	sub	sp, #20
 800df64:	af00      	add	r7, sp, #0
 800df66:	6078      	str	r0, [r7, #4]
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 800df68:	687b      	ldr	r3, [r7, #4]
 800df6a:	3b01      	subs	r3, #1
 800df6c:	607b      	str	r3, [r7, #4]
 800df6e:	687b      	ldr	r3, [r7, #4]
 800df70:	2b01      	cmp	r3, #1
 800df72:	d825      	bhi.n	800dfc0 <dec_lock+0x60>
		n = Files[i].ctr;
 800df74:	4a17      	ldr	r2, [pc, #92]	@ (800dfd4 <dec_lock+0x74>)
 800df76:	687b      	ldr	r3, [r7, #4]
 800df78:	011b      	lsls	r3, r3, #4
 800df7a:	4413      	add	r3, r2
 800df7c:	330c      	adds	r3, #12
 800df7e:	881b      	ldrh	r3, [r3, #0]
 800df80:	81fb      	strh	r3, [r7, #14]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 800df82:	89fb      	ldrh	r3, [r7, #14]
 800df84:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800df88:	d101      	bne.n	800df8e <dec_lock+0x2e>
 800df8a:	2300      	movs	r3, #0
 800df8c:	81fb      	strh	r3, [r7, #14]
		if (n > 0) n--;				/* Decrement read mode open count */
 800df8e:	89fb      	ldrh	r3, [r7, #14]
 800df90:	2b00      	cmp	r3, #0
 800df92:	d002      	beq.n	800df9a <dec_lock+0x3a>
 800df94:	89fb      	ldrh	r3, [r7, #14]
 800df96:	3b01      	subs	r3, #1
 800df98:	81fb      	strh	r3, [r7, #14]
		Files[i].ctr = n;
 800df9a:	4a0e      	ldr	r2, [pc, #56]	@ (800dfd4 <dec_lock+0x74>)
 800df9c:	687b      	ldr	r3, [r7, #4]
 800df9e:	011b      	lsls	r3, r3, #4
 800dfa0:	4413      	add	r3, r2
 800dfa2:	330c      	adds	r3, #12
 800dfa4:	89fa      	ldrh	r2, [r7, #14]
 800dfa6:	801a      	strh	r2, [r3, #0]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800dfa8:	89fb      	ldrh	r3, [r7, #14]
 800dfaa:	2b00      	cmp	r3, #0
 800dfac:	d105      	bne.n	800dfba <dec_lock+0x5a>
 800dfae:	4a09      	ldr	r2, [pc, #36]	@ (800dfd4 <dec_lock+0x74>)
 800dfb0:	687b      	ldr	r3, [r7, #4]
 800dfb2:	011b      	lsls	r3, r3, #4
 800dfb4:	4413      	add	r3, r2
 800dfb6:	2200      	movs	r2, #0
 800dfb8:	601a      	str	r2, [r3, #0]
		res = FR_OK;
 800dfba:	2300      	movs	r3, #0
 800dfbc:	737b      	strb	r3, [r7, #13]
 800dfbe:	e001      	b.n	800dfc4 <dec_lock+0x64>
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 800dfc0:	2302      	movs	r3, #2
 800dfc2:	737b      	strb	r3, [r7, #13]
	}
	return res;
 800dfc4:	7b7b      	ldrb	r3, [r7, #13]
}
 800dfc6:	4618      	mov	r0, r3
 800dfc8:	3714      	adds	r7, #20
 800dfca:	46bd      	mov	sp, r7
 800dfcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dfd0:	4770      	bx	lr
 800dfd2:	bf00      	nop
 800dfd4:	200028f4 	.word	0x200028f4

0800dfd8 <clear_lock>:

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
 800dfd8:	b480      	push	{r7}
 800dfda:	b085      	sub	sp, #20
 800dfdc:	af00      	add	r7, sp, #0
 800dfde:	6078      	str	r0, [r7, #4]
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 800dfe0:	2300      	movs	r3, #0
 800dfe2:	60fb      	str	r3, [r7, #12]
 800dfe4:	e010      	b.n	800e008 <clear_lock+0x30>
		if (Files[i].fs == fs) Files[i].fs = 0;
 800dfe6:	4a0d      	ldr	r2, [pc, #52]	@ (800e01c <clear_lock+0x44>)
 800dfe8:	68fb      	ldr	r3, [r7, #12]
 800dfea:	011b      	lsls	r3, r3, #4
 800dfec:	4413      	add	r3, r2
 800dfee:	681b      	ldr	r3, [r3, #0]
 800dff0:	687a      	ldr	r2, [r7, #4]
 800dff2:	429a      	cmp	r2, r3
 800dff4:	d105      	bne.n	800e002 <clear_lock+0x2a>
 800dff6:	4a09      	ldr	r2, [pc, #36]	@ (800e01c <clear_lock+0x44>)
 800dff8:	68fb      	ldr	r3, [r7, #12]
 800dffa:	011b      	lsls	r3, r3, #4
 800dffc:	4413      	add	r3, r2
 800dffe:	2200      	movs	r2, #0
 800e000:	601a      	str	r2, [r3, #0]
	for (i = 0; i < _FS_LOCK; i++) {
 800e002:	68fb      	ldr	r3, [r7, #12]
 800e004:	3301      	adds	r3, #1
 800e006:	60fb      	str	r3, [r7, #12]
 800e008:	68fb      	ldr	r3, [r7, #12]
 800e00a:	2b01      	cmp	r3, #1
 800e00c:	d9eb      	bls.n	800dfe6 <clear_lock+0xe>
	}
}
 800e00e:	bf00      	nop
 800e010:	bf00      	nop
 800e012:	3714      	adds	r7, #20
 800e014:	46bd      	mov	sp, r7
 800e016:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e01a:	4770      	bx	lr
 800e01c:	200028f4 	.word	0x200028f4

0800e020 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs			/* File system object */
)
{
 800e020:	b580      	push	{r7, lr}
 800e022:	b086      	sub	sp, #24
 800e024:	af00      	add	r7, sp, #0
 800e026:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 800e028:	2300      	movs	r3, #0
 800e02a:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800e02c:	687b      	ldr	r3, [r7, #4]
 800e02e:	78db      	ldrb	r3, [r3, #3]
 800e030:	2b00      	cmp	r3, #0
 800e032:	d034      	beq.n	800e09e <sync_window+0x7e>
		wsect = fs->winsect;	/* Current sector number */
 800e034:	687b      	ldr	r3, [r7, #4]
 800e036:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800e038:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800e03a:	687b      	ldr	r3, [r7, #4]
 800e03c:	7858      	ldrb	r0, [r3, #1]
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e044:	2301      	movs	r3, #1
 800e046:	697a      	ldr	r2, [r7, #20]
 800e048:	f7ff fd40 	bl	800dacc <disk_write>
 800e04c:	4603      	mov	r3, r0
 800e04e:	2b00      	cmp	r3, #0
 800e050:	d002      	beq.n	800e058 <sync_window+0x38>
			res = FR_DISK_ERR;
 800e052:	2301      	movs	r3, #1
 800e054:	73fb      	strb	r3, [r7, #15]
 800e056:	e022      	b.n	800e09e <sync_window+0x7e>
		} else {
			fs->wflag = 0;
 800e058:	687b      	ldr	r3, [r7, #4]
 800e05a:	2200      	movs	r2, #0
 800e05c:	70da      	strb	r2, [r3, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e062:	697a      	ldr	r2, [r7, #20]
 800e064:	1ad2      	subs	r2, r2, r3
 800e066:	687b      	ldr	r3, [r7, #4]
 800e068:	69db      	ldr	r3, [r3, #28]
 800e06a:	429a      	cmp	r2, r3
 800e06c:	d217      	bcs.n	800e09e <sync_window+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e06e:	687b      	ldr	r3, [r7, #4]
 800e070:	789b      	ldrb	r3, [r3, #2]
 800e072:	613b      	str	r3, [r7, #16]
 800e074:	e010      	b.n	800e098 <sync_window+0x78>
					wsect += fs->fsize;
 800e076:	687b      	ldr	r3, [r7, #4]
 800e078:	69db      	ldr	r3, [r3, #28]
 800e07a:	697a      	ldr	r2, [r7, #20]
 800e07c:	4413      	add	r3, r2
 800e07e:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
 800e080:	687b      	ldr	r3, [r7, #4]
 800e082:	7858      	ldrb	r0, [r3, #1]
 800e084:	687b      	ldr	r3, [r7, #4]
 800e086:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e08a:	2301      	movs	r3, #1
 800e08c:	697a      	ldr	r2, [r7, #20]
 800e08e:	f7ff fd1d 	bl	800dacc <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e092:	693b      	ldr	r3, [r7, #16]
 800e094:	3b01      	subs	r3, #1
 800e096:	613b      	str	r3, [r7, #16]
 800e098:	693b      	ldr	r3, [r7, #16]
 800e09a:	2b01      	cmp	r3, #1
 800e09c:	d8eb      	bhi.n	800e076 <sync_window+0x56>
				}
			}
		}
	}
	return res;
 800e09e:	7bfb      	ldrb	r3, [r7, #15]
}
 800e0a0:	4618      	mov	r0, r3
 800e0a2:	3718      	adds	r7, #24
 800e0a4:	46bd      	mov	sp, r7
 800e0a6:	bd80      	pop	{r7, pc}

0800e0a8 <move_window>:
static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs,			/* File system object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
 800e0a8:	b580      	push	{r7, lr}
 800e0aa:	b084      	sub	sp, #16
 800e0ac:	af00      	add	r7, sp, #0
 800e0ae:	6078      	str	r0, [r7, #4]
 800e0b0:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
 800e0b2:	2300      	movs	r3, #0
 800e0b4:	73fb      	strb	r3, [r7, #15]


	if (sector != fs->winsect) {	/* Window offset changed? */
 800e0b6:	687b      	ldr	r3, [r7, #4]
 800e0b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800e0ba:	683a      	ldr	r2, [r7, #0]
 800e0bc:	429a      	cmp	r2, r3
 800e0be:	d01b      	beq.n	800e0f8 <move_window+0x50>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 800e0c0:	6878      	ldr	r0, [r7, #4]
 800e0c2:	f7ff ffad 	bl	800e020 <sync_window>
 800e0c6:	4603      	mov	r3, r0
 800e0c8:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 800e0ca:	7bfb      	ldrb	r3, [r7, #15]
 800e0cc:	2b00      	cmp	r3, #0
 800e0ce:	d113      	bne.n	800e0f8 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800e0d0:	687b      	ldr	r3, [r7, #4]
 800e0d2:	7858      	ldrb	r0, [r3, #1]
 800e0d4:	687b      	ldr	r3, [r7, #4]
 800e0d6:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e0da:	2301      	movs	r3, #1
 800e0dc:	683a      	ldr	r2, [r7, #0]
 800e0de:	f7ff fcd5 	bl	800da8c <disk_read>
 800e0e2:	4603      	mov	r3, r0
 800e0e4:	2b00      	cmp	r3, #0
 800e0e6:	d004      	beq.n	800e0f2 <move_window+0x4a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 800e0e8:	f04f 33ff 	mov.w	r3, #4294967295
 800e0ec:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
 800e0ee:	2301      	movs	r3, #1
 800e0f0:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sector;
 800e0f2:	687b      	ldr	r3, [r7, #4]
 800e0f4:	683a      	ldr	r2, [r7, #0]
 800e0f6:	631a      	str	r2, [r3, #48]	@ 0x30
		}
	}
	return res;
 800e0f8:	7bfb      	ldrb	r3, [r7, #15]
}
 800e0fa:	4618      	mov	r0, r3
 800e0fc:	3710      	adds	r7, #16
 800e0fe:	46bd      	mov	sp, r7
 800e100:	bd80      	pop	{r7, pc}
	...

0800e104 <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 800e104:	b580      	push	{r7, lr}
 800e106:	b084      	sub	sp, #16
 800e108:	af00      	add	r7, sp, #0
 800e10a:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
 800e10c:	6878      	ldr	r0, [r7, #4]
 800e10e:	f7ff ff87 	bl	800e020 <sync_window>
 800e112:	4603      	mov	r3, r0
 800e114:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800e116:	7bfb      	ldrb	r3, [r7, #15]
 800e118:	2b00      	cmp	r3, #0
 800e11a:	d159      	bne.n	800e1d0 <sync_fs+0xcc>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	781b      	ldrb	r3, [r3, #0]
 800e120:	2b03      	cmp	r3, #3
 800e122:	d149      	bne.n	800e1b8 <sync_fs+0xb4>
 800e124:	687b      	ldr	r3, [r7, #4]
 800e126:	791b      	ldrb	r3, [r3, #4]
 800e128:	2b01      	cmp	r3, #1
 800e12a:	d145      	bne.n	800e1b8 <sync_fs+0xb4>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
 800e12c:	687b      	ldr	r3, [r7, #4]
 800e12e:	f103 0034 	add.w	r0, r3, #52	@ 0x34
 800e132:	687b      	ldr	r3, [r7, #4]
 800e134:	899b      	ldrh	r3, [r3, #12]
 800e136:	461a      	mov	r2, r3
 800e138:	2100      	movs	r1, #0
 800e13a:	f7ff fda8 	bl	800dc8e <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	3334      	adds	r3, #52	@ 0x34
 800e142:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 800e146:	f64a 2155 	movw	r1, #43605	@ 0xaa55
 800e14a:	4618      	mov	r0, r3
 800e14c:	f7ff fd37 	bl	800dbbe <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
 800e150:	687b      	ldr	r3, [r7, #4]
 800e152:	3334      	adds	r3, #52	@ 0x34
 800e154:	4921      	ldr	r1, [pc, #132]	@ (800e1dc <sync_fs+0xd8>)
 800e156:	4618      	mov	r0, r3
 800e158:	f7ff fd4c 	bl	800dbf4 <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	3334      	adds	r3, #52	@ 0x34
 800e160:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800e164:	491e      	ldr	r1, [pc, #120]	@ (800e1e0 <sync_fs+0xdc>)
 800e166:	4618      	mov	r0, r3
 800e168:	f7ff fd44 	bl	800dbf4 <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 800e16c:	687b      	ldr	r3, [r7, #4]
 800e16e:	3334      	adds	r3, #52	@ 0x34
 800e170:	f503 72f4 	add.w	r2, r3, #488	@ 0x1e8
 800e174:	687b      	ldr	r3, [r7, #4]
 800e176:	695b      	ldr	r3, [r3, #20]
 800e178:	4619      	mov	r1, r3
 800e17a:	4610      	mov	r0, r2
 800e17c:	f7ff fd3a 	bl	800dbf4 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	3334      	adds	r3, #52	@ 0x34
 800e184:	f503 72f6 	add.w	r2, r3, #492	@ 0x1ec
 800e188:	687b      	ldr	r3, [r7, #4]
 800e18a:	691b      	ldr	r3, [r3, #16]
 800e18c:	4619      	mov	r1, r3
 800e18e:	4610      	mov	r0, r2
 800e190:	f7ff fd30 	bl	800dbf4 <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
 800e194:	687b      	ldr	r3, [r7, #4]
 800e196:	6a1b      	ldr	r3, [r3, #32]
 800e198:	1c5a      	adds	r2, r3, #1
 800e19a:	687b      	ldr	r3, [r7, #4]
 800e19c:	631a      	str	r2, [r3, #48]	@ 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800e19e:	687b      	ldr	r3, [r7, #4]
 800e1a0:	7858      	ldrb	r0, [r3, #1]
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e1a8:	687b      	ldr	r3, [r7, #4]
 800e1aa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800e1ac:	2301      	movs	r3, #1
 800e1ae:	f7ff fc8d 	bl	800dacc <disk_write>
			fs->fsi_flag = 0;
 800e1b2:	687b      	ldr	r3, [r7, #4]
 800e1b4:	2200      	movs	r2, #0
 800e1b6:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800e1b8:	687b      	ldr	r3, [r7, #4]
 800e1ba:	785b      	ldrb	r3, [r3, #1]
 800e1bc:	2200      	movs	r2, #0
 800e1be:	2100      	movs	r1, #0
 800e1c0:	4618      	mov	r0, r3
 800e1c2:	f7ff fca3 	bl	800db0c <disk_ioctl>
 800e1c6:	4603      	mov	r3, r0
 800e1c8:	2b00      	cmp	r3, #0
 800e1ca:	d001      	beq.n	800e1d0 <sync_fs+0xcc>
 800e1cc:	2301      	movs	r3, #1
 800e1ce:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 800e1d0:	7bfb      	ldrb	r3, [r7, #15]
}
 800e1d2:	4618      	mov	r0, r3
 800e1d4:	3710      	adds	r7, #16
 800e1d6:	46bd      	mov	sp, r7
 800e1d8:	bd80      	pop	{r7, pc}
 800e1da:	bf00      	nop
 800e1dc:	41615252 	.word	0x41615252
 800e1e0:	61417272 	.word	0x61417272

0800e1e4 <clust2sect>:
static
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 800e1e4:	b480      	push	{r7}
 800e1e6:	b083      	sub	sp, #12
 800e1e8:	af00      	add	r7, sp, #0
 800e1ea:	6078      	str	r0, [r7, #4]
 800e1ec:	6039      	str	r1, [r7, #0]
	clst -= 2;
 800e1ee:	683b      	ldr	r3, [r7, #0]
 800e1f0:	3b02      	subs	r3, #2
 800e1f2:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e1f4:	687b      	ldr	r3, [r7, #4]
 800e1f6:	699b      	ldr	r3, [r3, #24]
 800e1f8:	3b02      	subs	r3, #2
 800e1fa:	683a      	ldr	r2, [r7, #0]
 800e1fc:	429a      	cmp	r2, r3
 800e1fe:	d301      	bcc.n	800e204 <clust2sect+0x20>
 800e200:	2300      	movs	r3, #0
 800e202:	e008      	b.n	800e216 <clust2sect+0x32>
	return clst * fs->csize + fs->database;
 800e204:	687b      	ldr	r3, [r7, #4]
 800e206:	895b      	ldrh	r3, [r3, #10]
 800e208:	461a      	mov	r2, r3
 800e20a:	683b      	ldr	r3, [r7, #0]
 800e20c:	fb03 f202 	mul.w	r2, r3, r2
 800e210:	687b      	ldr	r3, [r7, #4]
 800e212:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e214:	4413      	add	r3, r2
}
 800e216:	4618      	mov	r0, r3
 800e218:	370c      	adds	r7, #12
 800e21a:	46bd      	mov	sp, r7
 800e21c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e220:	4770      	bx	lr

0800e222 <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	_FDID* obj,	/* Corresponding object */
	DWORD clst	/* Cluster number to get the value */
)
{
 800e222:	b580      	push	{r7, lr}
 800e224:	b086      	sub	sp, #24
 800e226:	af00      	add	r7, sp, #0
 800e228:	6078      	str	r0, [r7, #4]
 800e22a:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
 800e22c:	687b      	ldr	r3, [r7, #4]
 800e22e:	681b      	ldr	r3, [r3, #0]
 800e230:	613b      	str	r3, [r7, #16]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800e232:	683b      	ldr	r3, [r7, #0]
 800e234:	2b01      	cmp	r3, #1
 800e236:	d904      	bls.n	800e242 <get_fat+0x20>
 800e238:	693b      	ldr	r3, [r7, #16]
 800e23a:	699b      	ldr	r3, [r3, #24]
 800e23c:	683a      	ldr	r2, [r7, #0]
 800e23e:	429a      	cmp	r2, r3
 800e240:	d302      	bcc.n	800e248 <get_fat+0x26>
		val = 1;	/* Internal error */
 800e242:	2301      	movs	r3, #1
 800e244:	617b      	str	r3, [r7, #20]
 800e246:	e0ba      	b.n	800e3be <get_fat+0x19c>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800e248:	f04f 33ff 	mov.w	r3, #4294967295
 800e24c:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
 800e24e:	693b      	ldr	r3, [r7, #16]
 800e250:	781b      	ldrb	r3, [r3, #0]
 800e252:	2b03      	cmp	r3, #3
 800e254:	f000 8082 	beq.w	800e35c <get_fat+0x13a>
 800e258:	2b03      	cmp	r3, #3
 800e25a:	f300 80a6 	bgt.w	800e3aa <get_fat+0x188>
 800e25e:	2b01      	cmp	r3, #1
 800e260:	d002      	beq.n	800e268 <get_fat+0x46>
 800e262:	2b02      	cmp	r3, #2
 800e264:	d055      	beq.n	800e312 <get_fat+0xf0>
 800e266:	e0a0      	b.n	800e3aa <get_fat+0x188>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 800e268:	683b      	ldr	r3, [r7, #0]
 800e26a:	60fb      	str	r3, [r7, #12]
 800e26c:	68fb      	ldr	r3, [r7, #12]
 800e26e:	085b      	lsrs	r3, r3, #1
 800e270:	68fa      	ldr	r2, [r7, #12]
 800e272:	4413      	add	r3, r2
 800e274:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e276:	693b      	ldr	r3, [r7, #16]
 800e278:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e27a:	693b      	ldr	r3, [r7, #16]
 800e27c:	899b      	ldrh	r3, [r3, #12]
 800e27e:	4619      	mov	r1, r3
 800e280:	68fb      	ldr	r3, [r7, #12]
 800e282:	fbb3 f3f1 	udiv	r3, r3, r1
 800e286:	4413      	add	r3, r2
 800e288:	4619      	mov	r1, r3
 800e28a:	6938      	ldr	r0, [r7, #16]
 800e28c:	f7ff ff0c 	bl	800e0a8 <move_window>
 800e290:	4603      	mov	r3, r0
 800e292:	2b00      	cmp	r3, #0
 800e294:	f040 808c 	bne.w	800e3b0 <get_fat+0x18e>
			wc = fs->win[bc++ % SS(fs)];
 800e298:	68fb      	ldr	r3, [r7, #12]
 800e29a:	1c5a      	adds	r2, r3, #1
 800e29c:	60fa      	str	r2, [r7, #12]
 800e29e:	693a      	ldr	r2, [r7, #16]
 800e2a0:	8992      	ldrh	r2, [r2, #12]
 800e2a2:	fbb3 f1f2 	udiv	r1, r3, r2
 800e2a6:	fb01 f202 	mul.w	r2, r1, r2
 800e2aa:	1a9b      	subs	r3, r3, r2
 800e2ac:	693a      	ldr	r2, [r7, #16]
 800e2ae:	4413      	add	r3, r2
 800e2b0:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800e2b4:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e2b6:	693b      	ldr	r3, [r7, #16]
 800e2b8:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e2ba:	693b      	ldr	r3, [r7, #16]
 800e2bc:	899b      	ldrh	r3, [r3, #12]
 800e2be:	4619      	mov	r1, r3
 800e2c0:	68fb      	ldr	r3, [r7, #12]
 800e2c2:	fbb3 f3f1 	udiv	r3, r3, r1
 800e2c6:	4413      	add	r3, r2
 800e2c8:	4619      	mov	r1, r3
 800e2ca:	6938      	ldr	r0, [r7, #16]
 800e2cc:	f7ff feec 	bl	800e0a8 <move_window>
 800e2d0:	4603      	mov	r3, r0
 800e2d2:	2b00      	cmp	r3, #0
 800e2d4:	d16e      	bne.n	800e3b4 <get_fat+0x192>
			wc |= fs->win[bc % SS(fs)] << 8;
 800e2d6:	693b      	ldr	r3, [r7, #16]
 800e2d8:	899b      	ldrh	r3, [r3, #12]
 800e2da:	461a      	mov	r2, r3
 800e2dc:	68fb      	ldr	r3, [r7, #12]
 800e2de:	fbb3 f1f2 	udiv	r1, r3, r2
 800e2e2:	fb01 f202 	mul.w	r2, r1, r2
 800e2e6:	1a9b      	subs	r3, r3, r2
 800e2e8:	693a      	ldr	r2, [r7, #16]
 800e2ea:	4413      	add	r3, r2
 800e2ec:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800e2f0:	021b      	lsls	r3, r3, #8
 800e2f2:	68ba      	ldr	r2, [r7, #8]
 800e2f4:	4313      	orrs	r3, r2
 800e2f6:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800e2f8:	683b      	ldr	r3, [r7, #0]
 800e2fa:	f003 0301 	and.w	r3, r3, #1
 800e2fe:	2b00      	cmp	r3, #0
 800e300:	d002      	beq.n	800e308 <get_fat+0xe6>
 800e302:	68bb      	ldr	r3, [r7, #8]
 800e304:	091b      	lsrs	r3, r3, #4
 800e306:	e002      	b.n	800e30e <get_fat+0xec>
 800e308:	68bb      	ldr	r3, [r7, #8]
 800e30a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e30e:	617b      	str	r3, [r7, #20]
			break;
 800e310:	e055      	b.n	800e3be <get_fat+0x19c>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e312:	693b      	ldr	r3, [r7, #16]
 800e314:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e316:	693b      	ldr	r3, [r7, #16]
 800e318:	899b      	ldrh	r3, [r3, #12]
 800e31a:	085b      	lsrs	r3, r3, #1
 800e31c:	b29b      	uxth	r3, r3
 800e31e:	4619      	mov	r1, r3
 800e320:	683b      	ldr	r3, [r7, #0]
 800e322:	fbb3 f3f1 	udiv	r3, r3, r1
 800e326:	4413      	add	r3, r2
 800e328:	4619      	mov	r1, r3
 800e32a:	6938      	ldr	r0, [r7, #16]
 800e32c:	f7ff febc 	bl	800e0a8 <move_window>
 800e330:	4603      	mov	r3, r0
 800e332:	2b00      	cmp	r3, #0
 800e334:	d140      	bne.n	800e3b8 <get_fat+0x196>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e336:	693b      	ldr	r3, [r7, #16]
 800e338:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e33c:	683b      	ldr	r3, [r7, #0]
 800e33e:	005b      	lsls	r3, r3, #1
 800e340:	693a      	ldr	r2, [r7, #16]
 800e342:	8992      	ldrh	r2, [r2, #12]
 800e344:	fbb3 f0f2 	udiv	r0, r3, r2
 800e348:	fb00 f202 	mul.w	r2, r0, r2
 800e34c:	1a9b      	subs	r3, r3, r2
 800e34e:	440b      	add	r3, r1
 800e350:	4618      	mov	r0, r3
 800e352:	f7ff fbf9 	bl	800db48 <ld_word>
 800e356:	4603      	mov	r3, r0
 800e358:	617b      	str	r3, [r7, #20]
			break;
 800e35a:	e030      	b.n	800e3be <get_fat+0x19c>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e35c:	693b      	ldr	r3, [r7, #16]
 800e35e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e360:	693b      	ldr	r3, [r7, #16]
 800e362:	899b      	ldrh	r3, [r3, #12]
 800e364:	089b      	lsrs	r3, r3, #2
 800e366:	b29b      	uxth	r3, r3
 800e368:	4619      	mov	r1, r3
 800e36a:	683b      	ldr	r3, [r7, #0]
 800e36c:	fbb3 f3f1 	udiv	r3, r3, r1
 800e370:	4413      	add	r3, r2
 800e372:	4619      	mov	r1, r3
 800e374:	6938      	ldr	r0, [r7, #16]
 800e376:	f7ff fe97 	bl	800e0a8 <move_window>
 800e37a:	4603      	mov	r3, r0
 800e37c:	2b00      	cmp	r3, #0
 800e37e:	d11d      	bne.n	800e3bc <get_fat+0x19a>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800e380:	693b      	ldr	r3, [r7, #16]
 800e382:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e386:	683b      	ldr	r3, [r7, #0]
 800e388:	009b      	lsls	r3, r3, #2
 800e38a:	693a      	ldr	r2, [r7, #16]
 800e38c:	8992      	ldrh	r2, [r2, #12]
 800e38e:	fbb3 f0f2 	udiv	r0, r3, r2
 800e392:	fb00 f202 	mul.w	r2, r0, r2
 800e396:	1a9b      	subs	r3, r3, r2
 800e398:	440b      	add	r3, r1
 800e39a:	4618      	mov	r0, r3
 800e39c:	f7ff fbec 	bl	800db78 <ld_dword>
 800e3a0:	4603      	mov	r3, r0
 800e3a2:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 800e3a6:	617b      	str	r3, [r7, #20]
			break;
 800e3a8:	e009      	b.n	800e3be <get_fat+0x19c>
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
 800e3aa:	2301      	movs	r3, #1
 800e3ac:	617b      	str	r3, [r7, #20]
 800e3ae:	e006      	b.n	800e3be <get_fat+0x19c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e3b0:	bf00      	nop
 800e3b2:	e004      	b.n	800e3be <get_fat+0x19c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e3b4:	bf00      	nop
 800e3b6:	e002      	b.n	800e3be <get_fat+0x19c>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e3b8:	bf00      	nop
 800e3ba:	e000      	b.n	800e3be <get_fat+0x19c>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e3bc:	bf00      	nop
		}
	}

	return val;
 800e3be:	697b      	ldr	r3, [r7, #20]
}
 800e3c0:	4618      	mov	r0, r3
 800e3c2:	3718      	adds	r7, #24
 800e3c4:	46bd      	mov	sp, r7
 800e3c6:	bd80      	pop	{r7, pc}

0800e3c8 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding file system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 800e3c8:	b590      	push	{r4, r7, lr}
 800e3ca:	b089      	sub	sp, #36	@ 0x24
 800e3cc:	af00      	add	r7, sp, #0
 800e3ce:	60f8      	str	r0, [r7, #12]
 800e3d0:	60b9      	str	r1, [r7, #8]
 800e3d2:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
 800e3d4:	2302      	movs	r3, #2
 800e3d6:	77fb      	strb	r3, [r7, #31]

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800e3d8:	68bb      	ldr	r3, [r7, #8]
 800e3da:	2b01      	cmp	r3, #1
 800e3dc:	f240 8109 	bls.w	800e5f2 <put_fat+0x22a>
 800e3e0:	68fb      	ldr	r3, [r7, #12]
 800e3e2:	699b      	ldr	r3, [r3, #24]
 800e3e4:	68ba      	ldr	r2, [r7, #8]
 800e3e6:	429a      	cmp	r2, r3
 800e3e8:	f080 8103 	bcs.w	800e5f2 <put_fat+0x22a>
		switch (fs->fs_type) {
 800e3ec:	68fb      	ldr	r3, [r7, #12]
 800e3ee:	781b      	ldrb	r3, [r3, #0]
 800e3f0:	2b03      	cmp	r3, #3
 800e3f2:	f000 80b6 	beq.w	800e562 <put_fat+0x19a>
 800e3f6:	2b03      	cmp	r3, #3
 800e3f8:	f300 80fb 	bgt.w	800e5f2 <put_fat+0x22a>
 800e3fc:	2b01      	cmp	r3, #1
 800e3fe:	d003      	beq.n	800e408 <put_fat+0x40>
 800e400:	2b02      	cmp	r3, #2
 800e402:	f000 8083 	beq.w	800e50c <put_fat+0x144>
 800e406:	e0f4      	b.n	800e5f2 <put_fat+0x22a>
		case FS_FAT12 :	/* Bitfield items */
			bc = (UINT)clst; bc += bc / 2;
 800e408:	68bb      	ldr	r3, [r7, #8]
 800e40a:	61bb      	str	r3, [r7, #24]
 800e40c:	69bb      	ldr	r3, [r7, #24]
 800e40e:	085b      	lsrs	r3, r3, #1
 800e410:	69ba      	ldr	r2, [r7, #24]
 800e412:	4413      	add	r3, r2
 800e414:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800e416:	68fb      	ldr	r3, [r7, #12]
 800e418:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e41a:	68fb      	ldr	r3, [r7, #12]
 800e41c:	899b      	ldrh	r3, [r3, #12]
 800e41e:	4619      	mov	r1, r3
 800e420:	69bb      	ldr	r3, [r7, #24]
 800e422:	fbb3 f3f1 	udiv	r3, r3, r1
 800e426:	4413      	add	r3, r2
 800e428:	4619      	mov	r1, r3
 800e42a:	68f8      	ldr	r0, [r7, #12]
 800e42c:	f7ff fe3c 	bl	800e0a8 <move_window>
 800e430:	4603      	mov	r3, r0
 800e432:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e434:	7ffb      	ldrb	r3, [r7, #31]
 800e436:	2b00      	cmp	r3, #0
 800e438:	f040 80d4 	bne.w	800e5e4 <put_fat+0x21c>
			p = fs->win + bc++ % SS(fs);
 800e43c:	68fb      	ldr	r3, [r7, #12]
 800e43e:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e442:	69bb      	ldr	r3, [r7, #24]
 800e444:	1c5a      	adds	r2, r3, #1
 800e446:	61ba      	str	r2, [r7, #24]
 800e448:	68fa      	ldr	r2, [r7, #12]
 800e44a:	8992      	ldrh	r2, [r2, #12]
 800e44c:	fbb3 f0f2 	udiv	r0, r3, r2
 800e450:	fb00 f202 	mul.w	r2, r0, r2
 800e454:	1a9b      	subs	r3, r3, r2
 800e456:	440b      	add	r3, r1
 800e458:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800e45a:	68bb      	ldr	r3, [r7, #8]
 800e45c:	f003 0301 	and.w	r3, r3, #1
 800e460:	2b00      	cmp	r3, #0
 800e462:	d00d      	beq.n	800e480 <put_fat+0xb8>
 800e464:	697b      	ldr	r3, [r7, #20]
 800e466:	781b      	ldrb	r3, [r3, #0]
 800e468:	b25b      	sxtb	r3, r3
 800e46a:	f003 030f 	and.w	r3, r3, #15
 800e46e:	b25a      	sxtb	r2, r3
 800e470:	687b      	ldr	r3, [r7, #4]
 800e472:	b2db      	uxtb	r3, r3
 800e474:	011b      	lsls	r3, r3, #4
 800e476:	b25b      	sxtb	r3, r3
 800e478:	4313      	orrs	r3, r2
 800e47a:	b25b      	sxtb	r3, r3
 800e47c:	b2db      	uxtb	r3, r3
 800e47e:	e001      	b.n	800e484 <put_fat+0xbc>
 800e480:	687b      	ldr	r3, [r7, #4]
 800e482:	b2db      	uxtb	r3, r3
 800e484:	697a      	ldr	r2, [r7, #20]
 800e486:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 800e488:	68fb      	ldr	r3, [r7, #12]
 800e48a:	2201      	movs	r2, #1
 800e48c:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800e48e:	68fb      	ldr	r3, [r7, #12]
 800e490:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e492:	68fb      	ldr	r3, [r7, #12]
 800e494:	899b      	ldrh	r3, [r3, #12]
 800e496:	4619      	mov	r1, r3
 800e498:	69bb      	ldr	r3, [r7, #24]
 800e49a:	fbb3 f3f1 	udiv	r3, r3, r1
 800e49e:	4413      	add	r3, r2
 800e4a0:	4619      	mov	r1, r3
 800e4a2:	68f8      	ldr	r0, [r7, #12]
 800e4a4:	f7ff fe00 	bl	800e0a8 <move_window>
 800e4a8:	4603      	mov	r3, r0
 800e4aa:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e4ac:	7ffb      	ldrb	r3, [r7, #31]
 800e4ae:	2b00      	cmp	r3, #0
 800e4b0:	f040 809a 	bne.w	800e5e8 <put_fat+0x220>
			p = fs->win + bc % SS(fs);
 800e4b4:	68fb      	ldr	r3, [r7, #12]
 800e4b6:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e4ba:	68fb      	ldr	r3, [r7, #12]
 800e4bc:	899b      	ldrh	r3, [r3, #12]
 800e4be:	461a      	mov	r2, r3
 800e4c0:	69bb      	ldr	r3, [r7, #24]
 800e4c2:	fbb3 f0f2 	udiv	r0, r3, r2
 800e4c6:	fb00 f202 	mul.w	r2, r0, r2
 800e4ca:	1a9b      	subs	r3, r3, r2
 800e4cc:	440b      	add	r3, r1
 800e4ce:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800e4d0:	68bb      	ldr	r3, [r7, #8]
 800e4d2:	f003 0301 	and.w	r3, r3, #1
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d003      	beq.n	800e4e2 <put_fat+0x11a>
 800e4da:	687b      	ldr	r3, [r7, #4]
 800e4dc:	091b      	lsrs	r3, r3, #4
 800e4de:	b2db      	uxtb	r3, r3
 800e4e0:	e00e      	b.n	800e500 <put_fat+0x138>
 800e4e2:	697b      	ldr	r3, [r7, #20]
 800e4e4:	781b      	ldrb	r3, [r3, #0]
 800e4e6:	b25b      	sxtb	r3, r3
 800e4e8:	f023 030f 	bic.w	r3, r3, #15
 800e4ec:	b25a      	sxtb	r2, r3
 800e4ee:	687b      	ldr	r3, [r7, #4]
 800e4f0:	0a1b      	lsrs	r3, r3, #8
 800e4f2:	b25b      	sxtb	r3, r3
 800e4f4:	f003 030f 	and.w	r3, r3, #15
 800e4f8:	b25b      	sxtb	r3, r3
 800e4fa:	4313      	orrs	r3, r2
 800e4fc:	b25b      	sxtb	r3, r3
 800e4fe:	b2db      	uxtb	r3, r3
 800e500:	697a      	ldr	r2, [r7, #20]
 800e502:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 800e504:	68fb      	ldr	r3, [r7, #12]
 800e506:	2201      	movs	r2, #1
 800e508:	70da      	strb	r2, [r3, #3]
			break;
 800e50a:	e072      	b.n	800e5f2 <put_fat+0x22a>

		case FS_FAT16 :	/* WORD aligned items */
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800e50c:	68fb      	ldr	r3, [r7, #12]
 800e50e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e510:	68fb      	ldr	r3, [r7, #12]
 800e512:	899b      	ldrh	r3, [r3, #12]
 800e514:	085b      	lsrs	r3, r3, #1
 800e516:	b29b      	uxth	r3, r3
 800e518:	4619      	mov	r1, r3
 800e51a:	68bb      	ldr	r3, [r7, #8]
 800e51c:	fbb3 f3f1 	udiv	r3, r3, r1
 800e520:	4413      	add	r3, r2
 800e522:	4619      	mov	r1, r3
 800e524:	68f8      	ldr	r0, [r7, #12]
 800e526:	f7ff fdbf 	bl	800e0a8 <move_window>
 800e52a:	4603      	mov	r3, r0
 800e52c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e52e:	7ffb      	ldrb	r3, [r7, #31]
 800e530:	2b00      	cmp	r3, #0
 800e532:	d15b      	bne.n	800e5ec <put_fat+0x224>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 800e534:	68fb      	ldr	r3, [r7, #12]
 800e536:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e53a:	68bb      	ldr	r3, [r7, #8]
 800e53c:	005b      	lsls	r3, r3, #1
 800e53e:	68fa      	ldr	r2, [r7, #12]
 800e540:	8992      	ldrh	r2, [r2, #12]
 800e542:	fbb3 f0f2 	udiv	r0, r3, r2
 800e546:	fb00 f202 	mul.w	r2, r0, r2
 800e54a:	1a9b      	subs	r3, r3, r2
 800e54c:	440b      	add	r3, r1
 800e54e:	687a      	ldr	r2, [r7, #4]
 800e550:	b292      	uxth	r2, r2
 800e552:	4611      	mov	r1, r2
 800e554:	4618      	mov	r0, r3
 800e556:	f7ff fb32 	bl	800dbbe <st_word>
			fs->wflag = 1;
 800e55a:	68fb      	ldr	r3, [r7, #12]
 800e55c:	2201      	movs	r2, #1
 800e55e:	70da      	strb	r2, [r3, #3]
			break;
 800e560:	e047      	b.n	800e5f2 <put_fat+0x22a>

		case FS_FAT32 :	/* DWORD aligned items */
#if _FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800e562:	68fb      	ldr	r3, [r7, #12]
 800e564:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800e566:	68fb      	ldr	r3, [r7, #12]
 800e568:	899b      	ldrh	r3, [r3, #12]
 800e56a:	089b      	lsrs	r3, r3, #2
 800e56c:	b29b      	uxth	r3, r3
 800e56e:	4619      	mov	r1, r3
 800e570:	68bb      	ldr	r3, [r7, #8]
 800e572:	fbb3 f3f1 	udiv	r3, r3, r1
 800e576:	4413      	add	r3, r2
 800e578:	4619      	mov	r1, r3
 800e57a:	68f8      	ldr	r0, [r7, #12]
 800e57c:	f7ff fd94 	bl	800e0a8 <move_window>
 800e580:	4603      	mov	r3, r0
 800e582:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e584:	7ffb      	ldrb	r3, [r7, #31]
 800e586:	2b00      	cmp	r3, #0
 800e588:	d132      	bne.n	800e5f0 <put_fat+0x228>
			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800e58a:	687b      	ldr	r3, [r7, #4]
 800e58c:	f023 4470 	bic.w	r4, r3, #4026531840	@ 0xf0000000
 800e590:	68fb      	ldr	r3, [r7, #12]
 800e592:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e596:	68bb      	ldr	r3, [r7, #8]
 800e598:	009b      	lsls	r3, r3, #2
 800e59a:	68fa      	ldr	r2, [r7, #12]
 800e59c:	8992      	ldrh	r2, [r2, #12]
 800e59e:	fbb3 f0f2 	udiv	r0, r3, r2
 800e5a2:	fb00 f202 	mul.w	r2, r0, r2
 800e5a6:	1a9b      	subs	r3, r3, r2
 800e5a8:	440b      	add	r3, r1
 800e5aa:	4618      	mov	r0, r3
 800e5ac:	f7ff fae4 	bl	800db78 <ld_dword>
 800e5b0:	4603      	mov	r3, r0
 800e5b2:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 800e5b6:	4323      	orrs	r3, r4
 800e5b8:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
 800e5ba:	68fb      	ldr	r3, [r7, #12]
 800e5bc:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e5c0:	68bb      	ldr	r3, [r7, #8]
 800e5c2:	009b      	lsls	r3, r3, #2
 800e5c4:	68fa      	ldr	r2, [r7, #12]
 800e5c6:	8992      	ldrh	r2, [r2, #12]
 800e5c8:	fbb3 f0f2 	udiv	r0, r3, r2
 800e5cc:	fb00 f202 	mul.w	r2, r0, r2
 800e5d0:	1a9b      	subs	r3, r3, r2
 800e5d2:	440b      	add	r3, r1
 800e5d4:	6879      	ldr	r1, [r7, #4]
 800e5d6:	4618      	mov	r0, r3
 800e5d8:	f7ff fb0c 	bl	800dbf4 <st_dword>
			fs->wflag = 1;
 800e5dc:	68fb      	ldr	r3, [r7, #12]
 800e5de:	2201      	movs	r2, #1
 800e5e0:	70da      	strb	r2, [r3, #3]
			break;
 800e5e2:	e006      	b.n	800e5f2 <put_fat+0x22a>
			if (res != FR_OK) break;
 800e5e4:	bf00      	nop
 800e5e6:	e004      	b.n	800e5f2 <put_fat+0x22a>
			if (res != FR_OK) break;
 800e5e8:	bf00      	nop
 800e5ea:	e002      	b.n	800e5f2 <put_fat+0x22a>
			if (res != FR_OK) break;
 800e5ec:	bf00      	nop
 800e5ee:	e000      	b.n	800e5f2 <put_fat+0x22a>
			if (res != FR_OK) break;
 800e5f0:	bf00      	nop
		}
	}
	return res;
 800e5f2:	7ffb      	ldrb	r3, [r7, #31]
}
 800e5f4:	4618      	mov	r0, r3
 800e5f6:	3724      	adds	r7, #36	@ 0x24
 800e5f8:	46bd      	mov	sp, r7
 800e5fa:	bd90      	pop	{r4, r7, pc}

0800e5fc <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
 800e5fc:	b580      	push	{r7, lr}
 800e5fe:	b088      	sub	sp, #32
 800e600:	af00      	add	r7, sp, #0
 800e602:	60f8      	str	r0, [r7, #12]
 800e604:	60b9      	str	r1, [r7, #8]
 800e606:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
 800e608:	2300      	movs	r3, #0
 800e60a:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
 800e60c:	68fb      	ldr	r3, [r7, #12]
 800e60e:	681b      	ldr	r3, [r3, #0]
 800e610:	61bb      	str	r3, [r7, #24]
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800e612:	68bb      	ldr	r3, [r7, #8]
 800e614:	2b01      	cmp	r3, #1
 800e616:	d904      	bls.n	800e622 <remove_chain+0x26>
 800e618:	69bb      	ldr	r3, [r7, #24]
 800e61a:	699b      	ldr	r3, [r3, #24]
 800e61c:	68ba      	ldr	r2, [r7, #8]
 800e61e:	429a      	cmp	r2, r3
 800e620:	d301      	bcc.n	800e626 <remove_chain+0x2a>
 800e622:	2302      	movs	r3, #2
 800e624:	e04b      	b.n	800e6be <remove_chain+0xc2>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800e626:	687b      	ldr	r3, [r7, #4]
 800e628:	2b00      	cmp	r3, #0
 800e62a:	d00c      	beq.n	800e646 <remove_chain+0x4a>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 800e62c:	f04f 32ff 	mov.w	r2, #4294967295
 800e630:	6879      	ldr	r1, [r7, #4]
 800e632:	69b8      	ldr	r0, [r7, #24]
 800e634:	f7ff fec8 	bl	800e3c8 <put_fat>
 800e638:	4603      	mov	r3, r0
 800e63a:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
 800e63c:	7ffb      	ldrb	r3, [r7, #31]
 800e63e:	2b00      	cmp	r3, #0
 800e640:	d001      	beq.n	800e646 <remove_chain+0x4a>
 800e642:	7ffb      	ldrb	r3, [r7, #31]
 800e644:	e03b      	b.n	800e6be <remove_chain+0xc2>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800e646:	68b9      	ldr	r1, [r7, #8]
 800e648:	68f8      	ldr	r0, [r7, #12]
 800e64a:	f7ff fdea 	bl	800e222 <get_fat>
 800e64e:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
 800e650:	697b      	ldr	r3, [r7, #20]
 800e652:	2b00      	cmp	r3, #0
 800e654:	d031      	beq.n	800e6ba <remove_chain+0xbe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800e656:	697b      	ldr	r3, [r7, #20]
 800e658:	2b01      	cmp	r3, #1
 800e65a:	d101      	bne.n	800e660 <remove_chain+0x64>
 800e65c:	2302      	movs	r3, #2
 800e65e:	e02e      	b.n	800e6be <remove_chain+0xc2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800e660:	697b      	ldr	r3, [r7, #20]
 800e662:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e666:	d101      	bne.n	800e66c <remove_chain+0x70>
 800e668:	2301      	movs	r3, #1
 800e66a:	e028      	b.n	800e6be <remove_chain+0xc2>
		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 800e66c:	2200      	movs	r2, #0
 800e66e:	68b9      	ldr	r1, [r7, #8]
 800e670:	69b8      	ldr	r0, [r7, #24]
 800e672:	f7ff fea9 	bl	800e3c8 <put_fat>
 800e676:	4603      	mov	r3, r0
 800e678:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
 800e67a:	7ffb      	ldrb	r3, [r7, #31]
 800e67c:	2b00      	cmp	r3, #0
 800e67e:	d001      	beq.n	800e684 <remove_chain+0x88>
 800e680:	7ffb      	ldrb	r3, [r7, #31]
 800e682:	e01c      	b.n	800e6be <remove_chain+0xc2>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800e684:	69bb      	ldr	r3, [r7, #24]
 800e686:	695a      	ldr	r2, [r3, #20]
 800e688:	69bb      	ldr	r3, [r7, #24]
 800e68a:	699b      	ldr	r3, [r3, #24]
 800e68c:	3b02      	subs	r3, #2
 800e68e:	429a      	cmp	r2, r3
 800e690:	d20b      	bcs.n	800e6aa <remove_chain+0xae>
			fs->free_clst++;
 800e692:	69bb      	ldr	r3, [r7, #24]
 800e694:	695b      	ldr	r3, [r3, #20]
 800e696:	1c5a      	adds	r2, r3, #1
 800e698:	69bb      	ldr	r3, [r7, #24]
 800e69a:	615a      	str	r2, [r3, #20]
			fs->fsi_flag |= 1;
 800e69c:	69bb      	ldr	r3, [r7, #24]
 800e69e:	791b      	ldrb	r3, [r3, #4]
 800e6a0:	f043 0301 	orr.w	r3, r3, #1
 800e6a4:	b2da      	uxtb	r2, r3
 800e6a6:	69bb      	ldr	r3, [r7, #24]
 800e6a8:	711a      	strb	r2, [r3, #4]
			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
 800e6aa:	697b      	ldr	r3, [r7, #20]
 800e6ac:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 800e6ae:	69bb      	ldr	r3, [r7, #24]
 800e6b0:	699b      	ldr	r3, [r3, #24]
 800e6b2:	68ba      	ldr	r2, [r7, #8]
 800e6b4:	429a      	cmp	r2, r3
 800e6b6:	d3c6      	bcc.n	800e646 <remove_chain+0x4a>
 800e6b8:	e000      	b.n	800e6bc <remove_chain+0xc0>
		if (nxt == 0) break;				/* Empty cluster? */
 800e6ba:	bf00      	nop
				obj->stat = 2;	/* Change the object status 'contiguous' */
			}
		}
	}
#endif
	return FR_OK;
 800e6bc:	2300      	movs	r3, #0
}
 800e6be:	4618      	mov	r0, r3
 800e6c0:	3720      	adds	r7, #32
 800e6c2:	46bd      	mov	sp, r7
 800e6c4:	bd80      	pop	{r7, pc}

0800e6c6 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	_FDID* obj,			/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 800e6c6:	b580      	push	{r7, lr}
 800e6c8:	b088      	sub	sp, #32
 800e6ca:	af00      	add	r7, sp, #0
 800e6cc:	6078      	str	r0, [r7, #4]
 800e6ce:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
 800e6d0:	687b      	ldr	r3, [r7, #4]
 800e6d2:	681b      	ldr	r3, [r3, #0]
 800e6d4:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
 800e6d6:	683b      	ldr	r3, [r7, #0]
 800e6d8:	2b00      	cmp	r3, #0
 800e6da:	d10d      	bne.n	800e6f8 <create_chain+0x32>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 800e6dc:	693b      	ldr	r3, [r7, #16]
 800e6de:	691b      	ldr	r3, [r3, #16]
 800e6e0:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800e6e2:	69bb      	ldr	r3, [r7, #24]
 800e6e4:	2b00      	cmp	r3, #0
 800e6e6:	d004      	beq.n	800e6f2 <create_chain+0x2c>
 800e6e8:	693b      	ldr	r3, [r7, #16]
 800e6ea:	699b      	ldr	r3, [r3, #24]
 800e6ec:	69ba      	ldr	r2, [r7, #24]
 800e6ee:	429a      	cmp	r2, r3
 800e6f0:	d31b      	bcc.n	800e72a <create_chain+0x64>
 800e6f2:	2301      	movs	r3, #1
 800e6f4:	61bb      	str	r3, [r7, #24]
 800e6f6:	e018      	b.n	800e72a <create_chain+0x64>
	}
	else {				/* Stretch current chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800e6f8:	6839      	ldr	r1, [r7, #0]
 800e6fa:	6878      	ldr	r0, [r7, #4]
 800e6fc:	f7ff fd91 	bl	800e222 <get_fat>
 800e700:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Invalid FAT value */
 800e702:	68fb      	ldr	r3, [r7, #12]
 800e704:	2b01      	cmp	r3, #1
 800e706:	d801      	bhi.n	800e70c <create_chain+0x46>
 800e708:	2301      	movs	r3, #1
 800e70a:	e070      	b.n	800e7ee <create_chain+0x128>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 800e70c:	68fb      	ldr	r3, [r7, #12]
 800e70e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e712:	d101      	bne.n	800e718 <create_chain+0x52>
 800e714:	68fb      	ldr	r3, [r7, #12]
 800e716:	e06a      	b.n	800e7ee <create_chain+0x128>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800e718:	693b      	ldr	r3, [r7, #16]
 800e71a:	699b      	ldr	r3, [r3, #24]
 800e71c:	68fa      	ldr	r2, [r7, #12]
 800e71e:	429a      	cmp	r2, r3
 800e720:	d201      	bcs.n	800e726 <create_chain+0x60>
 800e722:	68fb      	ldr	r3, [r7, #12]
 800e724:	e063      	b.n	800e7ee <create_chain+0x128>
		scl = clst;
 800e726:	683b      	ldr	r3, [r7, #0]
 800e728:	61bb      	str	r3, [r7, #24]
			}
		}
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		ncl = scl;	/* Start cluster */
 800e72a:	69bb      	ldr	r3, [r7, #24]
 800e72c:	61fb      	str	r3, [r7, #28]
		for (;;) {
			ncl++;							/* Next cluster */
 800e72e:	69fb      	ldr	r3, [r7, #28]
 800e730:	3301      	adds	r3, #1
 800e732:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800e734:	693b      	ldr	r3, [r7, #16]
 800e736:	699b      	ldr	r3, [r3, #24]
 800e738:	69fa      	ldr	r2, [r7, #28]
 800e73a:	429a      	cmp	r2, r3
 800e73c:	d307      	bcc.n	800e74e <create_chain+0x88>
				ncl = 2;
 800e73e:	2302      	movs	r3, #2
 800e740:	61fb      	str	r3, [r7, #28]
				if (ncl > scl) return 0;	/* No free cluster */
 800e742:	69fa      	ldr	r2, [r7, #28]
 800e744:	69bb      	ldr	r3, [r7, #24]
 800e746:	429a      	cmp	r2, r3
 800e748:	d901      	bls.n	800e74e <create_chain+0x88>
 800e74a:	2300      	movs	r3, #0
 800e74c:	e04f      	b.n	800e7ee <create_chain+0x128>
			}
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 800e74e:	69f9      	ldr	r1, [r7, #28]
 800e750:	6878      	ldr	r0, [r7, #4]
 800e752:	f7ff fd66 	bl	800e222 <get_fat>
 800e756:	60f8      	str	r0, [r7, #12]
			if (cs == 0) break;				/* Found a free cluster */
 800e758:	68fb      	ldr	r3, [r7, #12]
 800e75a:	2b00      	cmp	r3, #0
 800e75c:	d00e      	beq.n	800e77c <create_chain+0xb6>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 800e75e:	68fb      	ldr	r3, [r7, #12]
 800e760:	2b01      	cmp	r3, #1
 800e762:	d003      	beq.n	800e76c <create_chain+0xa6>
 800e764:	68fb      	ldr	r3, [r7, #12]
 800e766:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e76a:	d101      	bne.n	800e770 <create_chain+0xaa>
 800e76c:	68fb      	ldr	r3, [r7, #12]
 800e76e:	e03e      	b.n	800e7ee <create_chain+0x128>
			if (ncl == scl) return 0;		/* No free cluster */
 800e770:	69fa      	ldr	r2, [r7, #28]
 800e772:	69bb      	ldr	r3, [r7, #24]
 800e774:	429a      	cmp	r2, r3
 800e776:	d1da      	bne.n	800e72e <create_chain+0x68>
 800e778:	2300      	movs	r3, #0
 800e77a:	e038      	b.n	800e7ee <create_chain+0x128>
			if (cs == 0) break;				/* Found a free cluster */
 800e77c:	bf00      	nop
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
 800e77e:	f04f 32ff 	mov.w	r2, #4294967295
 800e782:	69f9      	ldr	r1, [r7, #28]
 800e784:	6938      	ldr	r0, [r7, #16]
 800e786:	f7ff fe1f 	bl	800e3c8 <put_fat>
 800e78a:	4603      	mov	r3, r0
 800e78c:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
 800e78e:	7dfb      	ldrb	r3, [r7, #23]
 800e790:	2b00      	cmp	r3, #0
 800e792:	d109      	bne.n	800e7a8 <create_chain+0xe2>
 800e794:	683b      	ldr	r3, [r7, #0]
 800e796:	2b00      	cmp	r3, #0
 800e798:	d006      	beq.n	800e7a8 <create_chain+0xe2>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
 800e79a:	69fa      	ldr	r2, [r7, #28]
 800e79c:	6839      	ldr	r1, [r7, #0]
 800e79e:	6938      	ldr	r0, [r7, #16]
 800e7a0:	f7ff fe12 	bl	800e3c8 <put_fat>
 800e7a4:	4603      	mov	r3, r0
 800e7a6:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800e7a8:	7dfb      	ldrb	r3, [r7, #23]
 800e7aa:	2b00      	cmp	r3, #0
 800e7ac:	d116      	bne.n	800e7dc <create_chain+0x116>
		fs->last_clst = ncl;
 800e7ae:	693b      	ldr	r3, [r7, #16]
 800e7b0:	69fa      	ldr	r2, [r7, #28]
 800e7b2:	611a      	str	r2, [r3, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e7b4:	693b      	ldr	r3, [r7, #16]
 800e7b6:	695a      	ldr	r2, [r3, #20]
 800e7b8:	693b      	ldr	r3, [r7, #16]
 800e7ba:	699b      	ldr	r3, [r3, #24]
 800e7bc:	3b02      	subs	r3, #2
 800e7be:	429a      	cmp	r2, r3
 800e7c0:	d804      	bhi.n	800e7cc <create_chain+0x106>
 800e7c2:	693b      	ldr	r3, [r7, #16]
 800e7c4:	695b      	ldr	r3, [r3, #20]
 800e7c6:	1e5a      	subs	r2, r3, #1
 800e7c8:	693b      	ldr	r3, [r7, #16]
 800e7ca:	615a      	str	r2, [r3, #20]
		fs->fsi_flag |= 1;
 800e7cc:	693b      	ldr	r3, [r7, #16]
 800e7ce:	791b      	ldrb	r3, [r3, #4]
 800e7d0:	f043 0301 	orr.w	r3, r3, #1
 800e7d4:	b2da      	uxtb	r2, r3
 800e7d6:	693b      	ldr	r3, [r7, #16]
 800e7d8:	711a      	strb	r2, [r3, #4]
 800e7da:	e007      	b.n	800e7ec <create_chain+0x126>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800e7dc:	7dfb      	ldrb	r3, [r7, #23]
 800e7de:	2b01      	cmp	r3, #1
 800e7e0:	d102      	bne.n	800e7e8 <create_chain+0x122>
 800e7e2:	f04f 33ff 	mov.w	r3, #4294967295
 800e7e6:	e000      	b.n	800e7ea <create_chain+0x124>
 800e7e8:	2301      	movs	r3, #1
 800e7ea:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
 800e7ec:	69fb      	ldr	r3, [r7, #28]
}
 800e7ee:	4618      	mov	r0, r3
 800e7f0:	3720      	adds	r7, #32
 800e7f2:	46bd      	mov	sp, r7
 800e7f4:	bd80      	pop	{r7, pc}

0800e7f6 <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
 800e7f6:	b480      	push	{r7}
 800e7f8:	b087      	sub	sp, #28
 800e7fa:	af00      	add	r7, sp, #0
 800e7fc:	6078      	str	r0, [r7, #4]
 800e7fe:	6039      	str	r1, [r7, #0]
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;
 800e800:	687b      	ldr	r3, [r7, #4]
 800e802:	681b      	ldr	r3, [r3, #0]
 800e804:	60fb      	str	r3, [r7, #12]


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800e806:	687b      	ldr	r3, [r7, #4]
 800e808:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e80a:	3304      	adds	r3, #4
 800e80c:	613b      	str	r3, [r7, #16]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800e80e:	68fb      	ldr	r3, [r7, #12]
 800e810:	899b      	ldrh	r3, [r3, #12]
 800e812:	461a      	mov	r2, r3
 800e814:	683b      	ldr	r3, [r7, #0]
 800e816:	fbb3 f3f2 	udiv	r3, r3, r2
 800e81a:	68fa      	ldr	r2, [r7, #12]
 800e81c:	8952      	ldrh	r2, [r2, #10]
 800e81e:	fbb3 f3f2 	udiv	r3, r3, r2
 800e822:	617b      	str	r3, [r7, #20]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800e824:	693b      	ldr	r3, [r7, #16]
 800e826:	1d1a      	adds	r2, r3, #4
 800e828:	613a      	str	r2, [r7, #16]
 800e82a:	681b      	ldr	r3, [r3, #0]
 800e82c:	60bb      	str	r3, [r7, #8]
		if (ncl == 0) return 0;	/* End of table? (error) */
 800e82e:	68bb      	ldr	r3, [r7, #8]
 800e830:	2b00      	cmp	r3, #0
 800e832:	d101      	bne.n	800e838 <clmt_clust+0x42>
 800e834:	2300      	movs	r3, #0
 800e836:	e010      	b.n	800e85a <clmt_clust+0x64>
		if (cl < ncl) break;	/* In this fragment? */
 800e838:	697a      	ldr	r2, [r7, #20]
 800e83a:	68bb      	ldr	r3, [r7, #8]
 800e83c:	429a      	cmp	r2, r3
 800e83e:	d307      	bcc.n	800e850 <clmt_clust+0x5a>
		cl -= ncl; tbl++;		/* Next fragment */
 800e840:	697a      	ldr	r2, [r7, #20]
 800e842:	68bb      	ldr	r3, [r7, #8]
 800e844:	1ad3      	subs	r3, r2, r3
 800e846:	617b      	str	r3, [r7, #20]
 800e848:	693b      	ldr	r3, [r7, #16]
 800e84a:	3304      	adds	r3, #4
 800e84c:	613b      	str	r3, [r7, #16]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800e84e:	e7e9      	b.n	800e824 <clmt_clust+0x2e>
		if (cl < ncl) break;	/* In this fragment? */
 800e850:	bf00      	nop
	}
	return cl + *tbl;	/* Return the cluster number */
 800e852:	693b      	ldr	r3, [r7, #16]
 800e854:	681a      	ldr	r2, [r3, #0]
 800e856:	697b      	ldr	r3, [r7, #20]
 800e858:	4413      	add	r3, r2
}
 800e85a:	4618      	mov	r0, r3
 800e85c:	371c      	adds	r7, #28
 800e85e:	46bd      	mov	sp, r7
 800e860:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e864:	4770      	bx	lr

0800e866 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
 800e866:	b580      	push	{r7, lr}
 800e868:	b086      	sub	sp, #24
 800e86a:	af00      	add	r7, sp, #0
 800e86c:	6078      	str	r0, [r7, #4]
 800e86e:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
 800e870:	687b      	ldr	r3, [r7, #4]
 800e872:	681b      	ldr	r3, [r3, #0]
 800e874:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800e876:	683b      	ldr	r3, [r7, #0]
 800e878:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800e87c:	d204      	bcs.n	800e888 <dir_sdi+0x22>
 800e87e:	683b      	ldr	r3, [r7, #0]
 800e880:	f003 031f 	and.w	r3, r3, #31
 800e884:	2b00      	cmp	r3, #0
 800e886:	d001      	beq.n	800e88c <dir_sdi+0x26>
		return FR_INT_ERR;
 800e888:	2302      	movs	r3, #2
 800e88a:	e071      	b.n	800e970 <dir_sdi+0x10a>
	}
	dp->dptr = ofs;				/* Set current offset */
 800e88c:	687b      	ldr	r3, [r7, #4]
 800e88e:	683a      	ldr	r2, [r7, #0]
 800e890:	615a      	str	r2, [r3, #20]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800e892:	687b      	ldr	r3, [r7, #4]
 800e894:	689b      	ldr	r3, [r3, #8]
 800e896:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800e898:	697b      	ldr	r3, [r7, #20]
 800e89a:	2b00      	cmp	r3, #0
 800e89c:	d106      	bne.n	800e8ac <dir_sdi+0x46>
 800e89e:	693b      	ldr	r3, [r7, #16]
 800e8a0:	781b      	ldrb	r3, [r3, #0]
 800e8a2:	2b02      	cmp	r3, #2
 800e8a4:	d902      	bls.n	800e8ac <dir_sdi+0x46>
		clst = fs->dirbase;
 800e8a6:	693b      	ldr	r3, [r7, #16]
 800e8a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e8aa:	617b      	str	r3, [r7, #20]
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800e8ac:	697b      	ldr	r3, [r7, #20]
 800e8ae:	2b00      	cmp	r3, #0
 800e8b0:	d10c      	bne.n	800e8cc <dir_sdi+0x66>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 800e8b2:	683b      	ldr	r3, [r7, #0]
 800e8b4:	095b      	lsrs	r3, r3, #5
 800e8b6:	693a      	ldr	r2, [r7, #16]
 800e8b8:	8912      	ldrh	r2, [r2, #8]
 800e8ba:	4293      	cmp	r3, r2
 800e8bc:	d301      	bcc.n	800e8c2 <dir_sdi+0x5c>
 800e8be:	2302      	movs	r3, #2
 800e8c0:	e056      	b.n	800e970 <dir_sdi+0x10a>
		dp->sect = fs->dirbase;
 800e8c2:	693b      	ldr	r3, [r7, #16]
 800e8c4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800e8c6:	687b      	ldr	r3, [r7, #4]
 800e8c8:	61da      	str	r2, [r3, #28]
 800e8ca:	e02d      	b.n	800e928 <dir_sdi+0xc2>

	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800e8cc:	693b      	ldr	r3, [r7, #16]
 800e8ce:	895b      	ldrh	r3, [r3, #10]
 800e8d0:	461a      	mov	r2, r3
 800e8d2:	693b      	ldr	r3, [r7, #16]
 800e8d4:	899b      	ldrh	r3, [r3, #12]
 800e8d6:	fb02 f303 	mul.w	r3, r2, r3
 800e8da:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
 800e8dc:	e019      	b.n	800e912 <dir_sdi+0xac>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800e8de:	687b      	ldr	r3, [r7, #4]
 800e8e0:	6979      	ldr	r1, [r7, #20]
 800e8e2:	4618      	mov	r0, r3
 800e8e4:	f7ff fc9d 	bl	800e222 <get_fat>
 800e8e8:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e8ea:	697b      	ldr	r3, [r7, #20]
 800e8ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e8f0:	d101      	bne.n	800e8f6 <dir_sdi+0x90>
 800e8f2:	2301      	movs	r3, #1
 800e8f4:	e03c      	b.n	800e970 <dir_sdi+0x10a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800e8f6:	697b      	ldr	r3, [r7, #20]
 800e8f8:	2b01      	cmp	r3, #1
 800e8fa:	d904      	bls.n	800e906 <dir_sdi+0xa0>
 800e8fc:	693b      	ldr	r3, [r7, #16]
 800e8fe:	699b      	ldr	r3, [r3, #24]
 800e900:	697a      	ldr	r2, [r7, #20]
 800e902:	429a      	cmp	r2, r3
 800e904:	d301      	bcc.n	800e90a <dir_sdi+0xa4>
 800e906:	2302      	movs	r3, #2
 800e908:	e032      	b.n	800e970 <dir_sdi+0x10a>
			ofs -= csz;
 800e90a:	683a      	ldr	r2, [r7, #0]
 800e90c:	68fb      	ldr	r3, [r7, #12]
 800e90e:	1ad3      	subs	r3, r2, r3
 800e910:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
 800e912:	683a      	ldr	r2, [r7, #0]
 800e914:	68fb      	ldr	r3, [r7, #12]
 800e916:	429a      	cmp	r2, r3
 800e918:	d2e1      	bcs.n	800e8de <dir_sdi+0x78>
		}
		dp->sect = clust2sect(fs, clst);
 800e91a:	6979      	ldr	r1, [r7, #20]
 800e91c:	6938      	ldr	r0, [r7, #16]
 800e91e:	f7ff fc61 	bl	800e1e4 <clust2sect>
 800e922:	4602      	mov	r2, r0
 800e924:	687b      	ldr	r3, [r7, #4]
 800e926:	61da      	str	r2, [r3, #28]
	}
	dp->clust = clst;					/* Current cluster# */
 800e928:	687b      	ldr	r3, [r7, #4]
 800e92a:	697a      	ldr	r2, [r7, #20]
 800e92c:	619a      	str	r2, [r3, #24]
	if (!dp->sect) return FR_INT_ERR;
 800e92e:	687b      	ldr	r3, [r7, #4]
 800e930:	69db      	ldr	r3, [r3, #28]
 800e932:	2b00      	cmp	r3, #0
 800e934:	d101      	bne.n	800e93a <dir_sdi+0xd4>
 800e936:	2302      	movs	r3, #2
 800e938:	e01a      	b.n	800e970 <dir_sdi+0x10a>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800e93a:	687b      	ldr	r3, [r7, #4]
 800e93c:	69da      	ldr	r2, [r3, #28]
 800e93e:	693b      	ldr	r3, [r7, #16]
 800e940:	899b      	ldrh	r3, [r3, #12]
 800e942:	4619      	mov	r1, r3
 800e944:	683b      	ldr	r3, [r7, #0]
 800e946:	fbb3 f3f1 	udiv	r3, r3, r1
 800e94a:	441a      	add	r2, r3
 800e94c:	687b      	ldr	r3, [r7, #4]
 800e94e:	61da      	str	r2, [r3, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800e950:	693b      	ldr	r3, [r7, #16]
 800e952:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800e956:	693b      	ldr	r3, [r7, #16]
 800e958:	899b      	ldrh	r3, [r3, #12]
 800e95a:	461a      	mov	r2, r3
 800e95c:	683b      	ldr	r3, [r7, #0]
 800e95e:	fbb3 f0f2 	udiv	r0, r3, r2
 800e962:	fb00 f202 	mul.w	r2, r0, r2
 800e966:	1a9b      	subs	r3, r3, r2
 800e968:	18ca      	adds	r2, r1, r3
 800e96a:	687b      	ldr	r3, [r7, #4]
 800e96c:	621a      	str	r2, [r3, #32]

	return FR_OK;
 800e96e:	2300      	movs	r3, #0
}
 800e970:	4618      	mov	r0, r3
 800e972:	3718      	adds	r7, #24
 800e974:	46bd      	mov	sp, r7
 800e976:	bd80      	pop	{r7, pc}

0800e978 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 800e978:	b580      	push	{r7, lr}
 800e97a:	b086      	sub	sp, #24
 800e97c:	af00      	add	r7, sp, #0
 800e97e:	6078      	str	r0, [r7, #4]
 800e980:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
 800e982:	687b      	ldr	r3, [r7, #4]
 800e984:	681b      	ldr	r3, [r3, #0]
 800e986:	60fb      	str	r3, [r7, #12]
#if !_FS_READONLY
	UINT n;
#endif

	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800e988:	687b      	ldr	r3, [r7, #4]
 800e98a:	695b      	ldr	r3, [r3, #20]
 800e98c:	3320      	adds	r3, #32
 800e98e:	60bb      	str	r3, [r7, #8]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e990:	687b      	ldr	r3, [r7, #4]
 800e992:	69db      	ldr	r3, [r3, #28]
 800e994:	2b00      	cmp	r3, #0
 800e996:	d003      	beq.n	800e9a0 <dir_next+0x28>
 800e998:	68bb      	ldr	r3, [r7, #8]
 800e99a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800e99e:	d301      	bcc.n	800e9a4 <dir_next+0x2c>
 800e9a0:	2304      	movs	r3, #4
 800e9a2:	e0bb      	b.n	800eb1c <dir_next+0x1a4>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800e9a4:	68fb      	ldr	r3, [r7, #12]
 800e9a6:	899b      	ldrh	r3, [r3, #12]
 800e9a8:	461a      	mov	r2, r3
 800e9aa:	68bb      	ldr	r3, [r7, #8]
 800e9ac:	fbb3 f1f2 	udiv	r1, r3, r2
 800e9b0:	fb01 f202 	mul.w	r2, r1, r2
 800e9b4:	1a9b      	subs	r3, r3, r2
 800e9b6:	2b00      	cmp	r3, #0
 800e9b8:	f040 809d 	bne.w	800eaf6 <dir_next+0x17e>
		dp->sect++;				/* Next sector */
 800e9bc:	687b      	ldr	r3, [r7, #4]
 800e9be:	69db      	ldr	r3, [r3, #28]
 800e9c0:	1c5a      	adds	r2, r3, #1
 800e9c2:	687b      	ldr	r3, [r7, #4]
 800e9c4:	61da      	str	r2, [r3, #28]

		if (!dp->clust) {		/* Static table */
 800e9c6:	687b      	ldr	r3, [r7, #4]
 800e9c8:	699b      	ldr	r3, [r3, #24]
 800e9ca:	2b00      	cmp	r3, #0
 800e9cc:	d10b      	bne.n	800e9e6 <dir_next+0x6e>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800e9ce:	68bb      	ldr	r3, [r7, #8]
 800e9d0:	095b      	lsrs	r3, r3, #5
 800e9d2:	68fa      	ldr	r2, [r7, #12]
 800e9d4:	8912      	ldrh	r2, [r2, #8]
 800e9d6:	4293      	cmp	r3, r2
 800e9d8:	f0c0 808d 	bcc.w	800eaf6 <dir_next+0x17e>
				dp->sect = 0; return FR_NO_FILE;
 800e9dc:	687b      	ldr	r3, [r7, #4]
 800e9de:	2200      	movs	r2, #0
 800e9e0:	61da      	str	r2, [r3, #28]
 800e9e2:	2304      	movs	r3, #4
 800e9e4:	e09a      	b.n	800eb1c <dir_next+0x1a4>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800e9e6:	68fb      	ldr	r3, [r7, #12]
 800e9e8:	899b      	ldrh	r3, [r3, #12]
 800e9ea:	461a      	mov	r2, r3
 800e9ec:	68bb      	ldr	r3, [r7, #8]
 800e9ee:	fbb3 f3f2 	udiv	r3, r3, r2
 800e9f2:	68fa      	ldr	r2, [r7, #12]
 800e9f4:	8952      	ldrh	r2, [r2, #10]
 800e9f6:	3a01      	subs	r2, #1
 800e9f8:	4013      	ands	r3, r2
 800e9fa:	2b00      	cmp	r3, #0
 800e9fc:	d17b      	bne.n	800eaf6 <dir_next+0x17e>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800e9fe:	687a      	ldr	r2, [r7, #4]
 800ea00:	687b      	ldr	r3, [r7, #4]
 800ea02:	699b      	ldr	r3, [r3, #24]
 800ea04:	4619      	mov	r1, r3
 800ea06:	4610      	mov	r0, r2
 800ea08:	f7ff fc0b 	bl	800e222 <get_fat>
 800ea0c:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800ea0e:	697b      	ldr	r3, [r7, #20]
 800ea10:	2b01      	cmp	r3, #1
 800ea12:	d801      	bhi.n	800ea18 <dir_next+0xa0>
 800ea14:	2302      	movs	r3, #2
 800ea16:	e081      	b.n	800eb1c <dir_next+0x1a4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800ea18:	697b      	ldr	r3, [r7, #20]
 800ea1a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ea1e:	d101      	bne.n	800ea24 <dir_next+0xac>
 800ea20:	2301      	movs	r3, #1
 800ea22:	e07b      	b.n	800eb1c <dir_next+0x1a4>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800ea24:	68fb      	ldr	r3, [r7, #12]
 800ea26:	699b      	ldr	r3, [r3, #24]
 800ea28:	697a      	ldr	r2, [r7, #20]
 800ea2a:	429a      	cmp	r2, r3
 800ea2c:	d359      	bcc.n	800eae2 <dir_next+0x16a>
#if !_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
 800ea2e:	683b      	ldr	r3, [r7, #0]
 800ea30:	2b00      	cmp	r3, #0
 800ea32:	d104      	bne.n	800ea3e <dir_next+0xc6>
						dp->sect = 0; return FR_NO_FILE;
 800ea34:	687b      	ldr	r3, [r7, #4]
 800ea36:	2200      	movs	r2, #0
 800ea38:	61da      	str	r2, [r3, #28]
 800ea3a:	2304      	movs	r3, #4
 800ea3c:	e06e      	b.n	800eb1c <dir_next+0x1a4>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800ea3e:	687a      	ldr	r2, [r7, #4]
 800ea40:	687b      	ldr	r3, [r7, #4]
 800ea42:	699b      	ldr	r3, [r3, #24]
 800ea44:	4619      	mov	r1, r3
 800ea46:	4610      	mov	r0, r2
 800ea48:	f7ff fe3d 	bl	800e6c6 <create_chain>
 800ea4c:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800ea4e:	697b      	ldr	r3, [r7, #20]
 800ea50:	2b00      	cmp	r3, #0
 800ea52:	d101      	bne.n	800ea58 <dir_next+0xe0>
 800ea54:	2307      	movs	r3, #7
 800ea56:	e061      	b.n	800eb1c <dir_next+0x1a4>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800ea58:	697b      	ldr	r3, [r7, #20]
 800ea5a:	2b01      	cmp	r3, #1
 800ea5c:	d101      	bne.n	800ea62 <dir_next+0xea>
 800ea5e:	2302      	movs	r3, #2
 800ea60:	e05c      	b.n	800eb1c <dir_next+0x1a4>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800ea62:	697b      	ldr	r3, [r7, #20]
 800ea64:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ea68:	d101      	bne.n	800ea6e <dir_next+0xf6>
 800ea6a:	2301      	movs	r3, #1
 800ea6c:	e056      	b.n	800eb1c <dir_next+0x1a4>
					/* Clean-up the stretched table */
					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 800ea6e:	68f8      	ldr	r0, [r7, #12]
 800ea70:	f7ff fad6 	bl	800e020 <sync_window>
 800ea74:	4603      	mov	r3, r0
 800ea76:	2b00      	cmp	r3, #0
 800ea78:	d001      	beq.n	800ea7e <dir_next+0x106>
 800ea7a:	2301      	movs	r3, #1
 800ea7c:	e04e      	b.n	800eb1c <dir_next+0x1a4>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 800ea7e:	68fb      	ldr	r3, [r7, #12]
 800ea80:	f103 0034 	add.w	r0, r3, #52	@ 0x34
 800ea84:	68fb      	ldr	r3, [r7, #12]
 800ea86:	899b      	ldrh	r3, [r3, #12]
 800ea88:	461a      	mov	r2, r3
 800ea8a:	2100      	movs	r1, #0
 800ea8c:	f7ff f8ff 	bl	800dc8e <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800ea90:	2300      	movs	r3, #0
 800ea92:	613b      	str	r3, [r7, #16]
 800ea94:	6979      	ldr	r1, [r7, #20]
 800ea96:	68f8      	ldr	r0, [r7, #12]
 800ea98:	f7ff fba4 	bl	800e1e4 <clust2sect>
 800ea9c:	4602      	mov	r2, r0
 800ea9e:	68fb      	ldr	r3, [r7, #12]
 800eaa0:	631a      	str	r2, [r3, #48]	@ 0x30
 800eaa2:	e012      	b.n	800eaca <dir_next+0x152>
						fs->wflag = 1;
 800eaa4:	68fb      	ldr	r3, [r7, #12]
 800eaa6:	2201      	movs	r2, #1
 800eaa8:	70da      	strb	r2, [r3, #3]
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 800eaaa:	68f8      	ldr	r0, [r7, #12]
 800eaac:	f7ff fab8 	bl	800e020 <sync_window>
 800eab0:	4603      	mov	r3, r0
 800eab2:	2b00      	cmp	r3, #0
 800eab4:	d001      	beq.n	800eaba <dir_next+0x142>
 800eab6:	2301      	movs	r3, #1
 800eab8:	e030      	b.n	800eb1c <dir_next+0x1a4>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800eaba:	693b      	ldr	r3, [r7, #16]
 800eabc:	3301      	adds	r3, #1
 800eabe:	613b      	str	r3, [r7, #16]
 800eac0:	68fb      	ldr	r3, [r7, #12]
 800eac2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eac4:	1c5a      	adds	r2, r3, #1
 800eac6:	68fb      	ldr	r3, [r7, #12]
 800eac8:	631a      	str	r2, [r3, #48]	@ 0x30
 800eaca:	68fb      	ldr	r3, [r7, #12]
 800eacc:	895b      	ldrh	r3, [r3, #10]
 800eace:	461a      	mov	r2, r3
 800ead0:	693b      	ldr	r3, [r7, #16]
 800ead2:	4293      	cmp	r3, r2
 800ead4:	d3e6      	bcc.n	800eaa4 <dir_next+0x12c>
					}
					fs->winsect -= n;							/* Restore window offset */
 800ead6:	68fb      	ldr	r3, [r7, #12]
 800ead8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800eada:	693b      	ldr	r3, [r7, #16]
 800eadc:	1ad2      	subs	r2, r2, r3
 800eade:	68fb      	ldr	r3, [r7, #12]
 800eae0:	631a      	str	r2, [r3, #48]	@ 0x30
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
 800eae2:	687b      	ldr	r3, [r7, #4]
 800eae4:	697a      	ldr	r2, [r7, #20]
 800eae6:	619a      	str	r2, [r3, #24]
				dp->sect = clust2sect(fs, clst);
 800eae8:	6979      	ldr	r1, [r7, #20]
 800eaea:	68f8      	ldr	r0, [r7, #12]
 800eaec:	f7ff fb7a 	bl	800e1e4 <clust2sect>
 800eaf0:	4602      	mov	r2, r0
 800eaf2:	687b      	ldr	r3, [r7, #4]
 800eaf4:	61da      	str	r2, [r3, #28]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
 800eaf6:	687b      	ldr	r3, [r7, #4]
 800eaf8:	68ba      	ldr	r2, [r7, #8]
 800eafa:	615a      	str	r2, [r3, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800eafc:	68fb      	ldr	r3, [r7, #12]
 800eafe:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800eb02:	68fb      	ldr	r3, [r7, #12]
 800eb04:	899b      	ldrh	r3, [r3, #12]
 800eb06:	461a      	mov	r2, r3
 800eb08:	68bb      	ldr	r3, [r7, #8]
 800eb0a:	fbb3 f0f2 	udiv	r0, r3, r2
 800eb0e:	fb00 f202 	mul.w	r2, r0, r2
 800eb12:	1a9b      	subs	r3, r3, r2
 800eb14:	18ca      	adds	r2, r1, r3
 800eb16:	687b      	ldr	r3, [r7, #4]
 800eb18:	621a      	str	r2, [r3, #32]

	return FR_OK;
 800eb1a:	2300      	movs	r3, #0
}
 800eb1c:	4618      	mov	r0, r3
 800eb1e:	3718      	adds	r7, #24
 800eb20:	46bd      	mov	sp, r7
 800eb22:	bd80      	pop	{r7, pc}

0800eb24 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate */
)
{
 800eb24:	b580      	push	{r7, lr}
 800eb26:	b086      	sub	sp, #24
 800eb28:	af00      	add	r7, sp, #0
 800eb2a:	6078      	str	r0, [r7, #4]
 800eb2c:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
 800eb2e:	687b      	ldr	r3, [r7, #4]
 800eb30:	681b      	ldr	r3, [r3, #0]
 800eb32:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
 800eb34:	2100      	movs	r1, #0
 800eb36:	6878      	ldr	r0, [r7, #4]
 800eb38:	f7ff fe95 	bl	800e866 <dir_sdi>
 800eb3c:	4603      	mov	r3, r0
 800eb3e:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800eb40:	7dfb      	ldrb	r3, [r7, #23]
 800eb42:	2b00      	cmp	r3, #0
 800eb44:	d12b      	bne.n	800eb9e <dir_alloc+0x7a>
		n = 0;
 800eb46:	2300      	movs	r3, #0
 800eb48:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
 800eb4a:	687b      	ldr	r3, [r7, #4]
 800eb4c:	69db      	ldr	r3, [r3, #28]
 800eb4e:	4619      	mov	r1, r3
 800eb50:	68f8      	ldr	r0, [r7, #12]
 800eb52:	f7ff faa9 	bl	800e0a8 <move_window>
 800eb56:	4603      	mov	r3, r0
 800eb58:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800eb5a:	7dfb      	ldrb	r3, [r7, #23]
 800eb5c:	2b00      	cmp	r3, #0
 800eb5e:	d11d      	bne.n	800eb9c <dir_alloc+0x78>
#if _FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 800eb60:	687b      	ldr	r3, [r7, #4]
 800eb62:	6a1b      	ldr	r3, [r3, #32]
 800eb64:	781b      	ldrb	r3, [r3, #0]
 800eb66:	2be5      	cmp	r3, #229	@ 0xe5
 800eb68:	d004      	beq.n	800eb74 <dir_alloc+0x50>
 800eb6a:	687b      	ldr	r3, [r7, #4]
 800eb6c:	6a1b      	ldr	r3, [r3, #32]
 800eb6e:	781b      	ldrb	r3, [r3, #0]
 800eb70:	2b00      	cmp	r3, #0
 800eb72:	d107      	bne.n	800eb84 <dir_alloc+0x60>
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 800eb74:	693b      	ldr	r3, [r7, #16]
 800eb76:	3301      	adds	r3, #1
 800eb78:	613b      	str	r3, [r7, #16]
 800eb7a:	693a      	ldr	r2, [r7, #16]
 800eb7c:	683b      	ldr	r3, [r7, #0]
 800eb7e:	429a      	cmp	r2, r3
 800eb80:	d102      	bne.n	800eb88 <dir_alloc+0x64>
 800eb82:	e00c      	b.n	800eb9e <dir_alloc+0x7a>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 800eb84:	2300      	movs	r3, #0
 800eb86:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);
 800eb88:	2101      	movs	r1, #1
 800eb8a:	6878      	ldr	r0, [r7, #4]
 800eb8c:	f7ff fef4 	bl	800e978 <dir_next>
 800eb90:	4603      	mov	r3, r0
 800eb92:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 800eb94:	7dfb      	ldrb	r3, [r7, #23]
 800eb96:	2b00      	cmp	r3, #0
 800eb98:	d0d7      	beq.n	800eb4a <dir_alloc+0x26>
 800eb9a:	e000      	b.n	800eb9e <dir_alloc+0x7a>
			if (res != FR_OK) break;
 800eb9c:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800eb9e:	7dfb      	ldrb	r3, [r7, #23]
 800eba0:	2b04      	cmp	r3, #4
 800eba2:	d101      	bne.n	800eba8 <dir_alloc+0x84>
 800eba4:	2307      	movs	r3, #7
 800eba6:	75fb      	strb	r3, [r7, #23]
	return res;
 800eba8:	7dfb      	ldrb	r3, [r7, #23]
}
 800ebaa:	4618      	mov	r0, r3
 800ebac:	3718      	adds	r7, #24
 800ebae:	46bd      	mov	sp, r7
 800ebb0:	bd80      	pop	{r7, pc}

0800ebb2 <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the key entry */
)
{
 800ebb2:	b580      	push	{r7, lr}
 800ebb4:	b084      	sub	sp, #16
 800ebb6:	af00      	add	r7, sp, #0
 800ebb8:	6078      	str	r0, [r7, #4]
 800ebba:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
 800ebbc:	683b      	ldr	r3, [r7, #0]
 800ebbe:	331a      	adds	r3, #26
 800ebc0:	4618      	mov	r0, r3
 800ebc2:	f7fe ffc1 	bl	800db48 <ld_word>
 800ebc6:	4603      	mov	r3, r0
 800ebc8:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
 800ebca:	687b      	ldr	r3, [r7, #4]
 800ebcc:	781b      	ldrb	r3, [r3, #0]
 800ebce:	2b03      	cmp	r3, #3
 800ebd0:	d109      	bne.n	800ebe6 <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800ebd2:	683b      	ldr	r3, [r7, #0]
 800ebd4:	3314      	adds	r3, #20
 800ebd6:	4618      	mov	r0, r3
 800ebd8:	f7fe ffb6 	bl	800db48 <ld_word>
 800ebdc:	4603      	mov	r3, r0
 800ebde:	041b      	lsls	r3, r3, #16
 800ebe0:	68fa      	ldr	r2, [r7, #12]
 800ebe2:	4313      	orrs	r3, r2
 800ebe4:	60fb      	str	r3, [r7, #12]
	}

	return cl;
 800ebe6:	68fb      	ldr	r3, [r7, #12]
}
 800ebe8:	4618      	mov	r0, r3
 800ebea:	3710      	adds	r7, #16
 800ebec:	46bd      	mov	sp, r7
 800ebee:	bd80      	pop	{r7, pc}

0800ebf0 <st_clust>:
void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
 800ebf0:	b580      	push	{r7, lr}
 800ebf2:	b084      	sub	sp, #16
 800ebf4:	af00      	add	r7, sp, #0
 800ebf6:	60f8      	str	r0, [r7, #12]
 800ebf8:	60b9      	str	r1, [r7, #8]
 800ebfa:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 800ebfc:	68bb      	ldr	r3, [r7, #8]
 800ebfe:	331a      	adds	r3, #26
 800ec00:	687a      	ldr	r2, [r7, #4]
 800ec02:	b292      	uxth	r2, r2
 800ec04:	4611      	mov	r1, r2
 800ec06:	4618      	mov	r0, r3
 800ec08:	f7fe ffd9 	bl	800dbbe <st_word>
	if (fs->fs_type == FS_FAT32) {
 800ec0c:	68fb      	ldr	r3, [r7, #12]
 800ec0e:	781b      	ldrb	r3, [r3, #0]
 800ec10:	2b03      	cmp	r3, #3
 800ec12:	d109      	bne.n	800ec28 <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800ec14:	68bb      	ldr	r3, [r7, #8]
 800ec16:	f103 0214 	add.w	r2, r3, #20
 800ec1a:	687b      	ldr	r3, [r7, #4]
 800ec1c:	0c1b      	lsrs	r3, r3, #16
 800ec1e:	b29b      	uxth	r3, r3
 800ec20:	4619      	mov	r1, r3
 800ec22:	4610      	mov	r0, r2
 800ec24:	f7fe ffcb 	bl	800dbbe <st_word>
	}
}
 800ec28:	bf00      	nop
 800ec2a:	3710      	adds	r7, #16
 800ec2c:	46bd      	mov	sp, r7
 800ec2e:	bd80      	pop	{r7, pc}

0800ec30 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
 800ec30:	b580      	push	{r7, lr}
 800ec32:	b086      	sub	sp, #24
 800ec34:	af00      	add	r7, sp, #0
 800ec36:	6078      	str	r0, [r7, #4]
 800ec38:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_NO_FILE;
 800ec3a:	2304      	movs	r3, #4
 800ec3c:	75fb      	strb	r3, [r7, #23]
	FATFS *fs = dp->obj.fs;
 800ec3e:	687b      	ldr	r3, [r7, #4]
 800ec40:	681b      	ldr	r3, [r3, #0]
 800ec42:	613b      	str	r3, [r7, #16]
	BYTE a, c;
#if _USE_LFN != 0
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	while (dp->sect) {
 800ec44:	e03c      	b.n	800ecc0 <dir_read+0x90>
		res = move_window(fs, dp->sect);
 800ec46:	687b      	ldr	r3, [r7, #4]
 800ec48:	69db      	ldr	r3, [r3, #28]
 800ec4a:	4619      	mov	r1, r3
 800ec4c:	6938      	ldr	r0, [r7, #16]
 800ec4e:	f7ff fa2b 	bl	800e0a8 <move_window>
 800ec52:	4603      	mov	r3, r0
 800ec54:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800ec56:	7dfb      	ldrb	r3, [r7, #23]
 800ec58:	2b00      	cmp	r3, #0
 800ec5a:	d136      	bne.n	800ecca <dir_read+0x9a>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800ec5c:	687b      	ldr	r3, [r7, #4]
 800ec5e:	6a1b      	ldr	r3, [r3, #32]
 800ec60:	781b      	ldrb	r3, [r3, #0]
 800ec62:	73fb      	strb	r3, [r7, #15]
		if (c == 0) {
 800ec64:	7bfb      	ldrb	r3, [r7, #15]
 800ec66:	2b00      	cmp	r3, #0
 800ec68:	d102      	bne.n	800ec70 <dir_read+0x40>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800ec6a:	2304      	movs	r3, #4
 800ec6c:	75fb      	strb	r3, [r7, #23]
 800ec6e:	e031      	b.n	800ecd4 <dir_read+0xa4>
				}
			}
		} else
#endif
		{	/* On the FAT12/16/32 volume */
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800ec70:	687b      	ldr	r3, [r7, #4]
 800ec72:	6a1b      	ldr	r3, [r3, #32]
 800ec74:	330b      	adds	r3, #11
 800ec76:	781b      	ldrb	r3, [r3, #0]
 800ec78:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800ec7c:	73bb      	strb	r3, [r7, #14]
 800ec7e:	687b      	ldr	r3, [r7, #4]
 800ec80:	7bba      	ldrb	r2, [r7, #14]
 800ec82:	719a      	strb	r2, [r3, #6]
					}
					break;
				}
			}
#else		/* Non LFN configuration */
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800ec84:	7bfb      	ldrb	r3, [r7, #15]
 800ec86:	2be5      	cmp	r3, #229	@ 0xe5
 800ec88:	d011      	beq.n	800ecae <dir_read+0x7e>
 800ec8a:	7bfb      	ldrb	r3, [r7, #15]
 800ec8c:	2b2e      	cmp	r3, #46	@ 0x2e
 800ec8e:	d00e      	beq.n	800ecae <dir_read+0x7e>
 800ec90:	7bbb      	ldrb	r3, [r7, #14]
 800ec92:	2b0f      	cmp	r3, #15
 800ec94:	d00b      	beq.n	800ecae <dir_read+0x7e>
 800ec96:	7bbb      	ldrb	r3, [r7, #14]
 800ec98:	f023 0320 	bic.w	r3, r3, #32
 800ec9c:	2b08      	cmp	r3, #8
 800ec9e:	bf0c      	ite	eq
 800eca0:	2301      	moveq	r3, #1
 800eca2:	2300      	movne	r3, #0
 800eca4:	b2db      	uxtb	r3, r3
 800eca6:	461a      	mov	r2, r3
 800eca8:	683b      	ldr	r3, [r7, #0]
 800ecaa:	4293      	cmp	r3, r2
 800ecac:	d00f      	beq.n	800ecce <dir_read+0x9e>
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
 800ecae:	2100      	movs	r1, #0
 800ecb0:	6878      	ldr	r0, [r7, #4]
 800ecb2:	f7ff fe61 	bl	800e978 <dir_next>
 800ecb6:	4603      	mov	r3, r0
 800ecb8:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800ecba:	7dfb      	ldrb	r3, [r7, #23]
 800ecbc:	2b00      	cmp	r3, #0
 800ecbe:	d108      	bne.n	800ecd2 <dir_read+0xa2>
	while (dp->sect) {
 800ecc0:	687b      	ldr	r3, [r7, #4]
 800ecc2:	69db      	ldr	r3, [r3, #28]
 800ecc4:	2b00      	cmp	r3, #0
 800ecc6:	d1be      	bne.n	800ec46 <dir_read+0x16>
 800ecc8:	e004      	b.n	800ecd4 <dir_read+0xa4>
		if (res != FR_OK) break;
 800ecca:	bf00      	nop
 800eccc:	e002      	b.n	800ecd4 <dir_read+0xa4>
				break;
 800ecce:	bf00      	nop
 800ecd0:	e000      	b.n	800ecd4 <dir_read+0xa4>
		if (res != FR_OK) break;
 800ecd2:	bf00      	nop
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800ecd4:	7dfb      	ldrb	r3, [r7, #23]
 800ecd6:	2b00      	cmp	r3, #0
 800ecd8:	d002      	beq.n	800ece0 <dir_read+0xb0>
 800ecda:	687b      	ldr	r3, [r7, #4]
 800ecdc:	2200      	movs	r2, #0
 800ecde:	61da      	str	r2, [r3, #28]
	return res;
 800ece0:	7dfb      	ldrb	r3, [r7, #23]
}
 800ece2:	4618      	mov	r0, r3
 800ece4:	3718      	adds	r7, #24
 800ece6:	46bd      	mov	sp, r7
 800ece8:	bd80      	pop	{r7, pc}

0800ecea <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object with the file name */
)
{
 800ecea:	b580      	push	{r7, lr}
 800ecec:	b086      	sub	sp, #24
 800ecee:	af00      	add	r7, sp, #0
 800ecf0:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800ecf2:	687b      	ldr	r3, [r7, #4]
 800ecf4:	681b      	ldr	r3, [r3, #0]
 800ecf6:	613b      	str	r3, [r7, #16]
	BYTE c;
#if _USE_LFN != 0
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800ecf8:	2100      	movs	r1, #0
 800ecfa:	6878      	ldr	r0, [r7, #4]
 800ecfc:	f7ff fdb3 	bl	800e866 <dir_sdi>
 800ed00:	4603      	mov	r3, r0
 800ed02:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 800ed04:	7dfb      	ldrb	r3, [r7, #23]
 800ed06:	2b00      	cmp	r3, #0
 800ed08:	d001      	beq.n	800ed0e <dir_find+0x24>
 800ed0a:	7dfb      	ldrb	r3, [r7, #23]
 800ed0c:	e03e      	b.n	800ed8c <dir_find+0xa2>
	/* On the FAT12/16/32 volume */
#if _USE_LFN != 0
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(fs, dp->sect);
 800ed0e:	687b      	ldr	r3, [r7, #4]
 800ed10:	69db      	ldr	r3, [r3, #28]
 800ed12:	4619      	mov	r1, r3
 800ed14:	6938      	ldr	r0, [r7, #16]
 800ed16:	f7ff f9c7 	bl	800e0a8 <move_window>
 800ed1a:	4603      	mov	r3, r0
 800ed1c:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800ed1e:	7dfb      	ldrb	r3, [r7, #23]
 800ed20:	2b00      	cmp	r3, #0
 800ed22:	d12f      	bne.n	800ed84 <dir_find+0x9a>
		c = dp->dir[DIR_Name];
 800ed24:	687b      	ldr	r3, [r7, #4]
 800ed26:	6a1b      	ldr	r3, [r3, #32]
 800ed28:	781b      	ldrb	r3, [r3, #0]
 800ed2a:	73fb      	strb	r3, [r7, #15]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800ed2c:	7bfb      	ldrb	r3, [r7, #15]
 800ed2e:	2b00      	cmp	r3, #0
 800ed30:	d102      	bne.n	800ed38 <dir_find+0x4e>
 800ed32:	2304      	movs	r3, #4
 800ed34:	75fb      	strb	r3, [r7, #23]
 800ed36:	e028      	b.n	800ed8a <dir_find+0xa0>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 800ed38:	687b      	ldr	r3, [r7, #4]
 800ed3a:	6a1b      	ldr	r3, [r3, #32]
 800ed3c:	330b      	adds	r3, #11
 800ed3e:	781b      	ldrb	r3, [r3, #0]
 800ed40:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800ed44:	b2da      	uxtb	r2, r3
 800ed46:	687b      	ldr	r3, [r7, #4]
 800ed48:	719a      	strb	r2, [r3, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 800ed4a:	687b      	ldr	r3, [r7, #4]
 800ed4c:	6a1b      	ldr	r3, [r3, #32]
 800ed4e:	330b      	adds	r3, #11
 800ed50:	781b      	ldrb	r3, [r3, #0]
 800ed52:	f003 0308 	and.w	r3, r3, #8
 800ed56:	2b00      	cmp	r3, #0
 800ed58:	d10a      	bne.n	800ed70 <dir_find+0x86>
 800ed5a:	687b      	ldr	r3, [r7, #4]
 800ed5c:	6a18      	ldr	r0, [r3, #32]
 800ed5e:	687b      	ldr	r3, [r7, #4]
 800ed60:	3324      	adds	r3, #36	@ 0x24
 800ed62:	220b      	movs	r2, #11
 800ed64:	4619      	mov	r1, r3
 800ed66:	f7fe ffad 	bl	800dcc4 <mem_cmp>
 800ed6a:	4603      	mov	r3, r0
 800ed6c:	2b00      	cmp	r3, #0
 800ed6e:	d00b      	beq.n	800ed88 <dir_find+0x9e>
#endif
		res = dir_next(dp, 0);	/* Next entry */
 800ed70:	2100      	movs	r1, #0
 800ed72:	6878      	ldr	r0, [r7, #4]
 800ed74:	f7ff fe00 	bl	800e978 <dir_next>
 800ed78:	4603      	mov	r3, r0
 800ed7a:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 800ed7c:	7dfb      	ldrb	r3, [r7, #23]
 800ed7e:	2b00      	cmp	r3, #0
 800ed80:	d0c5      	beq.n	800ed0e <dir_find+0x24>
 800ed82:	e002      	b.n	800ed8a <dir_find+0xa0>
		if (res != FR_OK) break;
 800ed84:	bf00      	nop
 800ed86:	e000      	b.n	800ed8a <dir_find+0xa0>
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 800ed88:	bf00      	nop

	return res;
 800ed8a:	7dfb      	ldrb	r3, [r7, #23]
}
 800ed8c:	4618      	mov	r0, r3
 800ed8e:	3718      	adds	r7, #24
 800ed90:	46bd      	mov	sp, r7
 800ed92:	bd80      	pop	{r7, pc}

0800ed94 <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 800ed94:	b580      	push	{r7, lr}
 800ed96:	b084      	sub	sp, #16
 800ed98:	af00      	add	r7, sp, #0
 800ed9a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800ed9c:	687b      	ldr	r3, [r7, #4]
 800ed9e:	681b      	ldr	r3, [r3, #0]
 800eda0:	60bb      	str	r3, [r7, #8]
			} while (res == FR_OK && --nent);
		}
	}

#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
 800eda2:	2101      	movs	r1, #1
 800eda4:	6878      	ldr	r0, [r7, #4]
 800eda6:	f7ff febd 	bl	800eb24 <dir_alloc>
 800edaa:	4603      	mov	r3, r0
 800edac:	73fb      	strb	r3, [r7, #15]

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
 800edae:	7bfb      	ldrb	r3, [r7, #15]
 800edb0:	2b00      	cmp	r3, #0
 800edb2:	d11c      	bne.n	800edee <dir_register+0x5a>
		res = move_window(fs, dp->sect);
 800edb4:	687b      	ldr	r3, [r7, #4]
 800edb6:	69db      	ldr	r3, [r3, #28]
 800edb8:	4619      	mov	r1, r3
 800edba:	68b8      	ldr	r0, [r7, #8]
 800edbc:	f7ff f974 	bl	800e0a8 <move_window>
 800edc0:	4603      	mov	r3, r0
 800edc2:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 800edc4:	7bfb      	ldrb	r3, [r7, #15]
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d111      	bne.n	800edee <dir_register+0x5a>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 800edca:	687b      	ldr	r3, [r7, #4]
 800edcc:	6a1b      	ldr	r3, [r3, #32]
 800edce:	2220      	movs	r2, #32
 800edd0:	2100      	movs	r1, #0
 800edd2:	4618      	mov	r0, r3
 800edd4:	f7fe ff5b 	bl	800dc8e <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800edd8:	687b      	ldr	r3, [r7, #4]
 800edda:	6a18      	ldr	r0, [r3, #32]
 800eddc:	687b      	ldr	r3, [r7, #4]
 800edde:	3324      	adds	r3, #36	@ 0x24
 800ede0:	220b      	movs	r2, #11
 800ede2:	4619      	mov	r1, r3
 800ede4:	f7fe ff32 	bl	800dc4c <mem_cpy>
#if _USE_LFN != 0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			fs->wflag = 1;
 800ede8:	68bb      	ldr	r3, [r7, #8]
 800edea:	2201      	movs	r2, #1
 800edec:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
 800edee:	7bfb      	ldrb	r3, [r7, #15]
}
 800edf0:	4618      	mov	r0, r3
 800edf2:	3710      	adds	r7, #16
 800edf4:	46bd      	mov	sp, r7
 800edf6:	bd80      	pop	{r7, pc}

0800edf8 <dir_remove>:

static
FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
	DIR* dp				/* Directory object pointing the entry to be removed */
)
{
 800edf8:	b580      	push	{r7, lr}
 800edfa:	b084      	sub	sp, #16
 800edfc:	af00      	add	r7, sp, #0
 800edfe:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800ee00:	687b      	ldr	r3, [r7, #4]
 800ee02:	681b      	ldr	r3, [r3, #0]
 800ee04:	60fb      	str	r3, [r7, #12]
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}
#else			/* Non LFN configuration */

	res = move_window(fs, dp->sect);
 800ee06:	687b      	ldr	r3, [r7, #4]
 800ee08:	69db      	ldr	r3, [r3, #28]
 800ee0a:	4619      	mov	r1, r3
 800ee0c:	68f8      	ldr	r0, [r7, #12]
 800ee0e:	f7ff f94b 	bl	800e0a8 <move_window>
 800ee12:	4603      	mov	r3, r0
 800ee14:	72fb      	strb	r3, [r7, #11]
	if (res == FR_OK) {
 800ee16:	7afb      	ldrb	r3, [r7, #11]
 800ee18:	2b00      	cmp	r3, #0
 800ee1a:	d106      	bne.n	800ee2a <dir_remove+0x32>
		dp->dir[DIR_Name] = DDEM;
 800ee1c:	687b      	ldr	r3, [r7, #4]
 800ee1e:	6a1b      	ldr	r3, [r3, #32]
 800ee20:	22e5      	movs	r2, #229	@ 0xe5
 800ee22:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
 800ee24:	68fb      	ldr	r3, [r7, #12]
 800ee26:	2201      	movs	r2, #1
 800ee28:	70da      	strb	r2, [r3, #3]
	}
#endif

	return res;
 800ee2a:	7afb      	ldrb	r3, [r7, #11]
}
 800ee2c:	4618      	mov	r0, r3
 800ee2e:	3710      	adds	r7, #16
 800ee30:	46bd      	mov	sp, r7
 800ee32:	bd80      	pop	{r7, pc}

0800ee34 <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
 800ee34:	b580      	push	{r7, lr}
 800ee36:	b088      	sub	sp, #32
 800ee38:	af00      	add	r7, sp, #0
 800ee3a:	6078      	str	r0, [r7, #4]
 800ee3c:	6039      	str	r1, [r7, #0]
	BYTE c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	p = *path; sfn = dp->fn;
 800ee3e:	683b      	ldr	r3, [r7, #0]
 800ee40:	681b      	ldr	r3, [r3, #0]
 800ee42:	60fb      	str	r3, [r7, #12]
 800ee44:	687b      	ldr	r3, [r7, #4]
 800ee46:	3324      	adds	r3, #36	@ 0x24
 800ee48:	60bb      	str	r3, [r7, #8]
	mem_set(sfn, ' ', 11);
 800ee4a:	220b      	movs	r2, #11
 800ee4c:	2120      	movs	r1, #32
 800ee4e:	68b8      	ldr	r0, [r7, #8]
 800ee50:	f7fe ff1d 	bl	800dc8e <mem_set>
	si = i = 0; ni = 8;
 800ee54:	2300      	movs	r3, #0
 800ee56:	613b      	str	r3, [r7, #16]
 800ee58:	693b      	ldr	r3, [r7, #16]
 800ee5a:	61fb      	str	r3, [r7, #28]
 800ee5c:	2308      	movs	r3, #8
 800ee5e:	617b      	str	r3, [r7, #20]
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 800ee60:	69fb      	ldr	r3, [r7, #28]
 800ee62:	1c5a      	adds	r2, r3, #1
 800ee64:	61fa      	str	r2, [r7, #28]
 800ee66:	68fa      	ldr	r2, [r7, #12]
 800ee68:	4413      	add	r3, r2
 800ee6a:	781b      	ldrb	r3, [r3, #0]
 800ee6c:	76fb      	strb	r3, [r7, #27]
		if (c <= ' ') break; 			/* Break if end of the path name */
 800ee6e:	7efb      	ldrb	r3, [r7, #27]
 800ee70:	2b20      	cmp	r3, #32
 800ee72:	d94e      	bls.n	800ef12 <create_name+0xde>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 800ee74:	7efb      	ldrb	r3, [r7, #27]
 800ee76:	2b2f      	cmp	r3, #47	@ 0x2f
 800ee78:	d006      	beq.n	800ee88 <create_name+0x54>
 800ee7a:	7efb      	ldrb	r3, [r7, #27]
 800ee7c:	2b5c      	cmp	r3, #92	@ 0x5c
 800ee7e:	d110      	bne.n	800eea2 <create_name+0x6e>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800ee80:	e002      	b.n	800ee88 <create_name+0x54>
 800ee82:	69fb      	ldr	r3, [r7, #28]
 800ee84:	3301      	adds	r3, #1
 800ee86:	61fb      	str	r3, [r7, #28]
 800ee88:	68fa      	ldr	r2, [r7, #12]
 800ee8a:	69fb      	ldr	r3, [r7, #28]
 800ee8c:	4413      	add	r3, r2
 800ee8e:	781b      	ldrb	r3, [r3, #0]
 800ee90:	2b2f      	cmp	r3, #47	@ 0x2f
 800ee92:	d0f6      	beq.n	800ee82 <create_name+0x4e>
 800ee94:	68fa      	ldr	r2, [r7, #12]
 800ee96:	69fb      	ldr	r3, [r7, #28]
 800ee98:	4413      	add	r3, r2
 800ee9a:	781b      	ldrb	r3, [r3, #0]
 800ee9c:	2b5c      	cmp	r3, #92	@ 0x5c
 800ee9e:	d0f0      	beq.n	800ee82 <create_name+0x4e>
			break;
 800eea0:	e038      	b.n	800ef14 <create_name+0xe0>
		}
		if (c == '.' || i >= ni) {		/* End of body or over size? */
 800eea2:	7efb      	ldrb	r3, [r7, #27]
 800eea4:	2b2e      	cmp	r3, #46	@ 0x2e
 800eea6:	d003      	beq.n	800eeb0 <create_name+0x7c>
 800eea8:	693a      	ldr	r2, [r7, #16]
 800eeaa:	697b      	ldr	r3, [r7, #20]
 800eeac:	429a      	cmp	r2, r3
 800eeae:	d30c      	bcc.n	800eeca <create_name+0x96>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
 800eeb0:	697b      	ldr	r3, [r7, #20]
 800eeb2:	2b0b      	cmp	r3, #11
 800eeb4:	d002      	beq.n	800eebc <create_name+0x88>
 800eeb6:	7efb      	ldrb	r3, [r7, #27]
 800eeb8:	2b2e      	cmp	r3, #46	@ 0x2e
 800eeba:	d001      	beq.n	800eec0 <create_name+0x8c>
 800eebc:	2306      	movs	r3, #6
 800eebe:	e044      	b.n	800ef4a <create_name+0x116>
			i = 8; ni = 11;				/* Goto extension */
 800eec0:	2308      	movs	r3, #8
 800eec2:	613b      	str	r3, [r7, #16]
 800eec4:	230b      	movs	r3, #11
 800eec6:	617b      	str	r3, [r7, #20]
			continue;
 800eec8:	e022      	b.n	800ef10 <create_name+0xdc>
		}
		if (c >= 0x80) {				/* Extended character? */
 800eeca:	f997 301b 	ldrsb.w	r3, [r7, #27]
 800eece:	2b00      	cmp	r3, #0
 800eed0:	da04      	bge.n	800eedc <create_name+0xa8>
#ifdef _EXCVT
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 800eed2:	7efb      	ldrb	r3, [r7, #27]
 800eed4:	3b80      	subs	r3, #128	@ 0x80
 800eed6:	4a1f      	ldr	r2, [pc, #124]	@ (800ef54 <create_name+0x120>)
 800eed8:	5cd3      	ldrb	r3, [r2, r3]
 800eeda:	76fb      	strb	r3, [r7, #27]
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
 800eedc:	7efb      	ldrb	r3, [r7, #27]
 800eede:	4619      	mov	r1, r3
 800eee0:	481d      	ldr	r0, [pc, #116]	@ (800ef58 <create_name+0x124>)
 800eee2:	f7fe ff16 	bl	800dd12 <chk_chr>
 800eee6:	4603      	mov	r3, r0
 800eee8:	2b00      	cmp	r3, #0
 800eeea:	d001      	beq.n	800eef0 <create_name+0xbc>
 800eeec:	2306      	movs	r3, #6
 800eeee:	e02c      	b.n	800ef4a <create_name+0x116>
			if (IsLower(c)) c -= 0x20;	/* To upper */
 800eef0:	7efb      	ldrb	r3, [r7, #27]
 800eef2:	2b60      	cmp	r3, #96	@ 0x60
 800eef4:	d905      	bls.n	800ef02 <create_name+0xce>
 800eef6:	7efb      	ldrb	r3, [r7, #27]
 800eef8:	2b7a      	cmp	r3, #122	@ 0x7a
 800eefa:	d802      	bhi.n	800ef02 <create_name+0xce>
 800eefc:	7efb      	ldrb	r3, [r7, #27]
 800eefe:	3b20      	subs	r3, #32
 800ef00:	76fb      	strb	r3, [r7, #27]
			sfn[i++] = c;
 800ef02:	693b      	ldr	r3, [r7, #16]
 800ef04:	1c5a      	adds	r2, r3, #1
 800ef06:	613a      	str	r2, [r7, #16]
 800ef08:	68ba      	ldr	r2, [r7, #8]
 800ef0a:	4413      	add	r3, r2
 800ef0c:	7efa      	ldrb	r2, [r7, #27]
 800ef0e:	701a      	strb	r2, [r3, #0]
		c = (BYTE)p[si++];
 800ef10:	e7a6      	b.n	800ee60 <create_name+0x2c>
		if (c <= ' ') break; 			/* Break if end of the path name */
 800ef12:	bf00      	nop
		}
	}
	*path = p + si;						/* Return pointer to the next segment */
 800ef14:	68fa      	ldr	r2, [r7, #12]
 800ef16:	69fb      	ldr	r3, [r7, #28]
 800ef18:	441a      	add	r2, r3
 800ef1a:	683b      	ldr	r3, [r7, #0]
 800ef1c:	601a      	str	r2, [r3, #0]
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 800ef1e:	693b      	ldr	r3, [r7, #16]
 800ef20:	2b00      	cmp	r3, #0
 800ef22:	d101      	bne.n	800ef28 <create_name+0xf4>
 800ef24:	2306      	movs	r3, #6
 800ef26:	e010      	b.n	800ef4a <create_name+0x116>

	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ef28:	68bb      	ldr	r3, [r7, #8]
 800ef2a:	781b      	ldrb	r3, [r3, #0]
 800ef2c:	2be5      	cmp	r3, #229	@ 0xe5
 800ef2e:	d102      	bne.n	800ef36 <create_name+0x102>
 800ef30:	68bb      	ldr	r3, [r7, #8]
 800ef32:	2205      	movs	r2, #5
 800ef34:	701a      	strb	r2, [r3, #0]
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800ef36:	7efb      	ldrb	r3, [r7, #27]
 800ef38:	2b20      	cmp	r3, #32
 800ef3a:	d801      	bhi.n	800ef40 <create_name+0x10c>
 800ef3c:	2204      	movs	r2, #4
 800ef3e:	e000      	b.n	800ef42 <create_name+0x10e>
 800ef40:	2200      	movs	r2, #0
 800ef42:	68bb      	ldr	r3, [r7, #8]
 800ef44:	330b      	adds	r3, #11
 800ef46:	701a      	strb	r2, [r3, #0]

	return FR_OK;
 800ef48:	2300      	movs	r3, #0
#endif /* _USE_LFN != 0 */
}
 800ef4a:	4618      	mov	r0, r3
 800ef4c:	3720      	adds	r7, #32
 800ef4e:	46bd      	mov	sp, r7
 800ef50:	bd80      	pop	{r7, pc}
 800ef52:	bf00      	nop
 800ef54:	0802ff18 	.word	0x0802ff18
 800ef58:	0802e780 	.word	0x0802e780

0800ef5c <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 800ef5c:	b580      	push	{r7, lr}
 800ef5e:	b086      	sub	sp, #24
 800ef60:	af00      	add	r7, sp, #0
 800ef62:	6078      	str	r0, [r7, #4]
 800ef64:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
 800ef66:	687b      	ldr	r3, [r7, #4]
 800ef68:	613b      	str	r3, [r7, #16]
	FATFS *fs = obj->fs;
 800ef6a:	693b      	ldr	r3, [r7, #16]
 800ef6c:	681b      	ldr	r3, [r3, #0]
 800ef6e:	60fb      	str	r3, [r7, #12]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800ef70:	e002      	b.n	800ef78 <follow_path+0x1c>
 800ef72:	683b      	ldr	r3, [r7, #0]
 800ef74:	3301      	adds	r3, #1
 800ef76:	603b      	str	r3, [r7, #0]
 800ef78:	683b      	ldr	r3, [r7, #0]
 800ef7a:	781b      	ldrb	r3, [r3, #0]
 800ef7c:	2b2f      	cmp	r3, #47	@ 0x2f
 800ef7e:	d0f8      	beq.n	800ef72 <follow_path+0x16>
 800ef80:	683b      	ldr	r3, [r7, #0]
 800ef82:	781b      	ldrb	r3, [r3, #0]
 800ef84:	2b5c      	cmp	r3, #92	@ 0x5c
 800ef86:	d0f4      	beq.n	800ef72 <follow_path+0x16>
		obj->sclust = 0;					/* Start from root directory */
 800ef88:	693b      	ldr	r3, [r7, #16]
 800ef8a:	2200      	movs	r2, #0
 800ef8c:	609a      	str	r2, [r3, #8]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800ef8e:	683b      	ldr	r3, [r7, #0]
 800ef90:	781b      	ldrb	r3, [r3, #0]
 800ef92:	2b1f      	cmp	r3, #31
 800ef94:	d80a      	bhi.n	800efac <follow_path+0x50>
		dp->fn[NSFLAG] = NS_NONAME;
 800ef96:	687b      	ldr	r3, [r7, #4]
 800ef98:	2280      	movs	r2, #128	@ 0x80
 800ef9a:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
		res = dir_sdi(dp, 0);
 800ef9e:	2100      	movs	r1, #0
 800efa0:	6878      	ldr	r0, [r7, #4]
 800efa2:	f7ff fc60 	bl	800e866 <dir_sdi>
 800efa6:	4603      	mov	r3, r0
 800efa8:	75fb      	strb	r3, [r7, #23]
 800efaa:	e048      	b.n	800f03e <follow_path+0xe2>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800efac:	463b      	mov	r3, r7
 800efae:	4619      	mov	r1, r3
 800efb0:	6878      	ldr	r0, [r7, #4]
 800efb2:	f7ff ff3f 	bl	800ee34 <create_name>
 800efb6:	4603      	mov	r3, r0
 800efb8:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800efba:	7dfb      	ldrb	r3, [r7, #23]
 800efbc:	2b00      	cmp	r3, #0
 800efbe:	d139      	bne.n	800f034 <follow_path+0xd8>
			res = dir_find(dp);				/* Find an object with the segment name */
 800efc0:	6878      	ldr	r0, [r7, #4]
 800efc2:	f7ff fe92 	bl	800ecea <dir_find>
 800efc6:	4603      	mov	r3, r0
 800efc8:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 800efd0:	72fb      	strb	r3, [r7, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 800efd2:	7dfb      	ldrb	r3, [r7, #23]
 800efd4:	2b00      	cmp	r3, #0
 800efd6:	d00a      	beq.n	800efee <follow_path+0x92>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800efd8:	7dfb      	ldrb	r3, [r7, #23]
 800efda:	2b04      	cmp	r3, #4
 800efdc:	d12c      	bne.n	800f038 <follow_path+0xdc>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800efde:	7afb      	ldrb	r3, [r7, #11]
 800efe0:	f003 0304 	and.w	r3, r3, #4
 800efe4:	2b00      	cmp	r3, #0
 800efe6:	d127      	bne.n	800f038 <follow_path+0xdc>
 800efe8:	2305      	movs	r3, #5
 800efea:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
 800efec:	e024      	b.n	800f038 <follow_path+0xdc>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800efee:	7afb      	ldrb	r3, [r7, #11]
 800eff0:	f003 0304 	and.w	r3, r3, #4
 800eff4:	2b00      	cmp	r3, #0
 800eff6:	d121      	bne.n	800f03c <follow_path+0xe0>
			/* Get into the sub-directory */
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 800eff8:	693b      	ldr	r3, [r7, #16]
 800effa:	799b      	ldrb	r3, [r3, #6]
 800effc:	f003 0310 	and.w	r3, r3, #16
 800f000:	2b00      	cmp	r3, #0
 800f002:	d102      	bne.n	800f00a <follow_path+0xae>
				res = FR_NO_PATH; break;
 800f004:	2305      	movs	r3, #5
 800f006:	75fb      	strb	r3, [r7, #23]
 800f008:	e019      	b.n	800f03e <follow_path+0xe2>
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
			} else
#endif
			{
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800f00a:	68fb      	ldr	r3, [r7, #12]
 800f00c:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 800f010:	687b      	ldr	r3, [r7, #4]
 800f012:	695b      	ldr	r3, [r3, #20]
 800f014:	68fa      	ldr	r2, [r7, #12]
 800f016:	8992      	ldrh	r2, [r2, #12]
 800f018:	fbb3 f0f2 	udiv	r0, r3, r2
 800f01c:	fb00 f202 	mul.w	r2, r0, r2
 800f020:	1a9b      	subs	r3, r3, r2
 800f022:	440b      	add	r3, r1
 800f024:	4619      	mov	r1, r3
 800f026:	68f8      	ldr	r0, [r7, #12]
 800f028:	f7ff fdc3 	bl	800ebb2 <ld_clust>
 800f02c:	4602      	mov	r2, r0
 800f02e:	693b      	ldr	r3, [r7, #16]
 800f030:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800f032:	e7bb      	b.n	800efac <follow_path+0x50>
			if (res != FR_OK) break;
 800f034:	bf00      	nop
 800f036:	e002      	b.n	800f03e <follow_path+0xe2>
				break;
 800f038:	bf00      	nop
 800f03a:	e000      	b.n	800f03e <follow_path+0xe2>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800f03c:	bf00      	nop
			}
		}
	}

	return res;
 800f03e:	7dfb      	ldrb	r3, [r7, #23]
}
 800f040:	4618      	mov	r0, r3
 800f042:	3718      	adds	r7, #24
 800f044:	46bd      	mov	sp, r7
 800f046:	bd80      	pop	{r7, pc}

0800f048 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 800f048:	b480      	push	{r7}
 800f04a:	b087      	sub	sp, #28
 800f04c:	af00      	add	r7, sp, #0
 800f04e:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 800f050:	f04f 33ff 	mov.w	r3, #4294967295
 800f054:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 800f056:	687b      	ldr	r3, [r7, #4]
 800f058:	681b      	ldr	r3, [r3, #0]
 800f05a:	2b00      	cmp	r3, #0
 800f05c:	d031      	beq.n	800f0c2 <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800f05e:	687b      	ldr	r3, [r7, #4]
 800f060:	681b      	ldr	r3, [r3, #0]
 800f062:	617b      	str	r3, [r7, #20]
 800f064:	e002      	b.n	800f06c <get_ldnumber+0x24>
 800f066:	697b      	ldr	r3, [r7, #20]
 800f068:	3301      	adds	r3, #1
 800f06a:	617b      	str	r3, [r7, #20]
 800f06c:	697b      	ldr	r3, [r7, #20]
 800f06e:	781b      	ldrb	r3, [r3, #0]
 800f070:	2b20      	cmp	r3, #32
 800f072:	d903      	bls.n	800f07c <get_ldnumber+0x34>
 800f074:	697b      	ldr	r3, [r7, #20]
 800f076:	781b      	ldrb	r3, [r3, #0]
 800f078:	2b3a      	cmp	r3, #58	@ 0x3a
 800f07a:	d1f4      	bne.n	800f066 <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 800f07c:	697b      	ldr	r3, [r7, #20]
 800f07e:	781b      	ldrb	r3, [r3, #0]
 800f080:	2b3a      	cmp	r3, #58	@ 0x3a
 800f082:	d11c      	bne.n	800f0be <get_ldnumber+0x76>
			tp = *path;
 800f084:	687b      	ldr	r3, [r7, #4]
 800f086:	681b      	ldr	r3, [r3, #0]
 800f088:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0';
 800f08a:	68fb      	ldr	r3, [r7, #12]
 800f08c:	1c5a      	adds	r2, r3, #1
 800f08e:	60fa      	str	r2, [r7, #12]
 800f090:	781b      	ldrb	r3, [r3, #0]
 800f092:	3b30      	subs	r3, #48	@ 0x30
 800f094:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800f096:	68bb      	ldr	r3, [r7, #8]
 800f098:	2b09      	cmp	r3, #9
 800f09a:	d80e      	bhi.n	800f0ba <get_ldnumber+0x72>
 800f09c:	68fa      	ldr	r2, [r7, #12]
 800f09e:	697b      	ldr	r3, [r7, #20]
 800f0a0:	429a      	cmp	r2, r3
 800f0a2:	d10a      	bne.n	800f0ba <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800f0a4:	68bb      	ldr	r3, [r7, #8]
 800f0a6:	2b00      	cmp	r3, #0
 800f0a8:	d107      	bne.n	800f0ba <get_ldnumber+0x72>
					vol = (int)i;
 800f0aa:	68bb      	ldr	r3, [r7, #8]
 800f0ac:	613b      	str	r3, [r7, #16]
					*path = ++tt;
 800f0ae:	697b      	ldr	r3, [r7, #20]
 800f0b0:	3301      	adds	r3, #1
 800f0b2:	617b      	str	r3, [r7, #20]
 800f0b4:	687b      	ldr	r3, [r7, #4]
 800f0b6:	697a      	ldr	r2, [r7, #20]
 800f0b8:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
 800f0ba:	693b      	ldr	r3, [r7, #16]
 800f0bc:	e002      	b.n	800f0c4 <get_ldnumber+0x7c>
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 800f0be:	2300      	movs	r3, #0
 800f0c0:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
 800f0c2:	693b      	ldr	r3, [r7, #16]
}
 800f0c4:	4618      	mov	r0, r3
 800f0c6:	371c      	adds	r7, #28
 800f0c8:	46bd      	mov	sp, r7
 800f0ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0ce:	4770      	bx	lr

0800f0d0 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 800f0d0:	b580      	push	{r7, lr}
 800f0d2:	b082      	sub	sp, #8
 800f0d4:	af00      	add	r7, sp, #0
 800f0d6:	6078      	str	r0, [r7, #4]
 800f0d8:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800f0da:	687b      	ldr	r3, [r7, #4]
 800f0dc:	2200      	movs	r2, #0
 800f0de:	70da      	strb	r2, [r3, #3]
 800f0e0:	687b      	ldr	r3, [r7, #4]
 800f0e2:	f04f 32ff 	mov.w	r2, #4294967295
 800f0e6:	631a      	str	r2, [r3, #48]	@ 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800f0e8:	6839      	ldr	r1, [r7, #0]
 800f0ea:	6878      	ldr	r0, [r7, #4]
 800f0ec:	f7fe ffdc 	bl	800e0a8 <move_window>
 800f0f0:	4603      	mov	r3, r0
 800f0f2:	2b00      	cmp	r3, #0
 800f0f4:	d001      	beq.n	800f0fa <check_fs+0x2a>
 800f0f6:	2304      	movs	r3, #4
 800f0f8:	e038      	b.n	800f16c <check_fs+0x9c>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800f0fa:	687b      	ldr	r3, [r7, #4]
 800f0fc:	3334      	adds	r3, #52	@ 0x34
 800f0fe:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 800f102:	4618      	mov	r0, r3
 800f104:	f7fe fd20 	bl	800db48 <ld_word>
 800f108:	4603      	mov	r3, r0
 800f10a:	461a      	mov	r2, r3
 800f10c:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 800f110:	429a      	cmp	r2, r3
 800f112:	d001      	beq.n	800f118 <check_fs+0x48>
 800f114:	2303      	movs	r3, #3
 800f116:	e029      	b.n	800f16c <check_fs+0x9c>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 800f118:	687b      	ldr	r3, [r7, #4]
 800f11a:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800f11e:	2be9      	cmp	r3, #233	@ 0xe9
 800f120:	d009      	beq.n	800f136 <check_fs+0x66>
 800f122:	687b      	ldr	r3, [r7, #4]
 800f124:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800f128:	2beb      	cmp	r3, #235	@ 0xeb
 800f12a:	d11e      	bne.n	800f16a <check_fs+0x9a>
 800f12c:	687b      	ldr	r3, [r7, #4]
 800f12e:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
 800f132:	2b90      	cmp	r3, #144	@ 0x90
 800f134:	d119      	bne.n	800f16a <check_fs+0x9a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800f136:	687b      	ldr	r3, [r7, #4]
 800f138:	3334      	adds	r3, #52	@ 0x34
 800f13a:	3336      	adds	r3, #54	@ 0x36
 800f13c:	4618      	mov	r0, r3
 800f13e:	f7fe fd1b 	bl	800db78 <ld_dword>
 800f142:	4603      	mov	r3, r0
 800f144:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 800f148:	4a0a      	ldr	r2, [pc, #40]	@ (800f174 <check_fs+0xa4>)
 800f14a:	4293      	cmp	r3, r2
 800f14c:	d101      	bne.n	800f152 <check_fs+0x82>
 800f14e:	2300      	movs	r3, #0
 800f150:	e00c      	b.n	800f16c <check_fs+0x9c>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800f152:	687b      	ldr	r3, [r7, #4]
 800f154:	3334      	adds	r3, #52	@ 0x34
 800f156:	3352      	adds	r3, #82	@ 0x52
 800f158:	4618      	mov	r0, r3
 800f15a:	f7fe fd0d 	bl	800db78 <ld_dword>
 800f15e:	4603      	mov	r3, r0
 800f160:	4a05      	ldr	r2, [pc, #20]	@ (800f178 <check_fs+0xa8>)
 800f162:	4293      	cmp	r3, r2
 800f164:	d101      	bne.n	800f16a <check_fs+0x9a>
 800f166:	2300      	movs	r3, #0
 800f168:	e000      	b.n	800f16c <check_fs+0x9c>
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
 800f16a:	2302      	movs	r3, #2
}
 800f16c:	4618      	mov	r0, r3
 800f16e:	3708      	adds	r7, #8
 800f170:	46bd      	mov	sp, r7
 800f172:	bd80      	pop	{r7, pc}
 800f174:	00544146 	.word	0x00544146
 800f178:	33544146 	.word	0x33544146

0800f17c <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 800f17c:	b580      	push	{r7, lr}
 800f17e:	b096      	sub	sp, #88	@ 0x58
 800f180:	af00      	add	r7, sp, #0
 800f182:	60f8      	str	r0, [r7, #12]
 800f184:	60b9      	str	r1, [r7, #8]
 800f186:	4613      	mov	r3, r2
 800f188:	71fb      	strb	r3, [r7, #7]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 800f18a:	68bb      	ldr	r3, [r7, #8]
 800f18c:	2200      	movs	r2, #0
 800f18e:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
 800f190:	68f8      	ldr	r0, [r7, #12]
 800f192:	f7ff ff59 	bl	800f048 <get_ldnumber>
 800f196:	63f8      	str	r0, [r7, #60]	@ 0x3c
	if (vol < 0) return FR_INVALID_DRIVE;
 800f198:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f19a:	2b00      	cmp	r3, #0
 800f19c:	da01      	bge.n	800f1a2 <find_volume+0x26>
 800f19e:	230b      	movs	r3, #11
 800f1a0:	e262      	b.n	800f668 <find_volume+0x4ec>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 800f1a2:	4a9f      	ldr	r2, [pc, #636]	@ (800f420 <find_volume+0x2a4>)
 800f1a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f1a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f1aa:	63bb      	str	r3, [r7, #56]	@ 0x38
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800f1ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f1ae:	2b00      	cmp	r3, #0
 800f1b0:	d101      	bne.n	800f1b6 <find_volume+0x3a>
 800f1b2:	230c      	movs	r3, #12
 800f1b4:	e258      	b.n	800f668 <find_volume+0x4ec>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 800f1b6:	68bb      	ldr	r3, [r7, #8]
 800f1b8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800f1ba:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800f1bc:	79fb      	ldrb	r3, [r7, #7]
 800f1be:	f023 0301 	bic.w	r3, r3, #1
 800f1c2:	71fb      	strb	r3, [r7, #7]
	if (fs->fs_type) {					/* If the volume has been mounted */
 800f1c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f1c6:	781b      	ldrb	r3, [r3, #0]
 800f1c8:	2b00      	cmp	r3, #0
 800f1ca:	d01a      	beq.n	800f202 <find_volume+0x86>
		stat = disk_status(fs->drv);
 800f1cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f1ce:	785b      	ldrb	r3, [r3, #1]
 800f1d0:	4618      	mov	r0, r3
 800f1d2:	f7fe fc19 	bl	800da08 <disk_status>
 800f1d6:	4603      	mov	r3, r0
 800f1d8:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800f1dc:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f1e0:	f003 0301 	and.w	r3, r3, #1
 800f1e4:	2b00      	cmp	r3, #0
 800f1e6:	d10c      	bne.n	800f202 <find_volume+0x86>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800f1e8:	79fb      	ldrb	r3, [r7, #7]
 800f1ea:	2b00      	cmp	r3, #0
 800f1ec:	d007      	beq.n	800f1fe <find_volume+0x82>
 800f1ee:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f1f2:	f003 0304 	and.w	r3, r3, #4
 800f1f6:	2b00      	cmp	r3, #0
 800f1f8:	d001      	beq.n	800f1fe <find_volume+0x82>
				return FR_WRITE_PROTECTED;
 800f1fa:	230a      	movs	r3, #10
 800f1fc:	e234      	b.n	800f668 <find_volume+0x4ec>
			}
			return FR_OK;				/* The file system object is valid */
 800f1fe:	2300      	movs	r3, #0
 800f200:	e232      	b.n	800f668 <find_volume+0x4ec>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800f202:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f204:	2200      	movs	r2, #0
 800f206:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800f208:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f20a:	b2da      	uxtb	r2, r3
 800f20c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f20e:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800f210:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f212:	785b      	ldrb	r3, [r3, #1]
 800f214:	4618      	mov	r0, r3
 800f216:	f7fe fc11 	bl	800da3c <disk_initialize>
 800f21a:	4603      	mov	r3, r0
 800f21c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800f220:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f224:	f003 0301 	and.w	r3, r3, #1
 800f228:	2b00      	cmp	r3, #0
 800f22a:	d001      	beq.n	800f230 <find_volume+0xb4>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800f22c:	2303      	movs	r3, #3
 800f22e:	e21b      	b.n	800f668 <find_volume+0x4ec>
	}
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800f230:	79fb      	ldrb	r3, [r7, #7]
 800f232:	2b00      	cmp	r3, #0
 800f234:	d007      	beq.n	800f246 <find_volume+0xca>
 800f236:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f23a:	f003 0304 	and.w	r3, r3, #4
 800f23e:	2b00      	cmp	r3, #0
 800f240:	d001      	beq.n	800f246 <find_volume+0xca>
		return FR_WRITE_PROTECTED;
 800f242:	230a      	movs	r3, #10
 800f244:	e210      	b.n	800f668 <find_volume+0x4ec>
	}
#if _MAX_SS != _MIN_SS					/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
 800f246:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f248:	7858      	ldrb	r0, [r3, #1]
 800f24a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f24c:	330c      	adds	r3, #12
 800f24e:	461a      	mov	r2, r3
 800f250:	2102      	movs	r1, #2
 800f252:	f7fe fc5b 	bl	800db0c <disk_ioctl>
 800f256:	4603      	mov	r3, r0
 800f258:	2b00      	cmp	r3, #0
 800f25a:	d001      	beq.n	800f260 <find_volume+0xe4>
 800f25c:	2301      	movs	r3, #1
 800f25e:	e203      	b.n	800f668 <find_volume+0x4ec>
	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
 800f260:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f262:	899b      	ldrh	r3, [r3, #12]
 800f264:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800f268:	d80d      	bhi.n	800f286 <find_volume+0x10a>
 800f26a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f26c:	899b      	ldrh	r3, [r3, #12]
 800f26e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800f272:	d308      	bcc.n	800f286 <find_volume+0x10a>
 800f274:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f276:	899b      	ldrh	r3, [r3, #12]
 800f278:	461a      	mov	r2, r3
 800f27a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f27c:	899b      	ldrh	r3, [r3, #12]
 800f27e:	3b01      	subs	r3, #1
 800f280:	4013      	ands	r3, r2
 800f282:	2b00      	cmp	r3, #0
 800f284:	d001      	beq.n	800f28a <find_volume+0x10e>
 800f286:	2301      	movs	r3, #1
 800f288:	e1ee      	b.n	800f668 <find_volume+0x4ec>
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
	bsect = 0;
 800f28a:	2300      	movs	r3, #0
 800f28c:	653b      	str	r3, [r7, #80]	@ 0x50
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 800f28e:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f290:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800f292:	f7ff ff1d 	bl	800f0d0 <check_fs>
 800f296:	4603      	mov	r3, r0
 800f298:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 800f29c:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f2a0:	2b02      	cmp	r3, #2
 800f2a2:	d149      	bne.n	800f338 <find_volume+0x1bc>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800f2a4:	2300      	movs	r3, #0
 800f2a6:	643b      	str	r3, [r7, #64]	@ 0x40
 800f2a8:	e01e      	b.n	800f2e8 <find_volume+0x16c>
			pt = fs->win + (MBR_Table + i * SZ_PTE);
 800f2aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f2ac:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 800f2b0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2b2:	011b      	lsls	r3, r3, #4
 800f2b4:	f503 73df 	add.w	r3, r3, #446	@ 0x1be
 800f2b8:	4413      	add	r3, r2
 800f2ba:	633b      	str	r3, [r7, #48]	@ 0x30
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800f2bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f2be:	3304      	adds	r3, #4
 800f2c0:	781b      	ldrb	r3, [r3, #0]
 800f2c2:	2b00      	cmp	r3, #0
 800f2c4:	d006      	beq.n	800f2d4 <find_volume+0x158>
 800f2c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f2c8:	3308      	adds	r3, #8
 800f2ca:	4618      	mov	r0, r3
 800f2cc:	f7fe fc54 	bl	800db78 <ld_dword>
 800f2d0:	4602      	mov	r2, r0
 800f2d2:	e000      	b.n	800f2d6 <find_volume+0x15a>
 800f2d4:	2200      	movs	r2, #0
 800f2d6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2d8:	009b      	lsls	r3, r3, #2
 800f2da:	3358      	adds	r3, #88	@ 0x58
 800f2dc:	443b      	add	r3, r7
 800f2de:	f843 2c44 	str.w	r2, [r3, #-68]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800f2e2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2e4:	3301      	adds	r3, #1
 800f2e6:	643b      	str	r3, [r7, #64]	@ 0x40
 800f2e8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2ea:	2b03      	cmp	r3, #3
 800f2ec:	d9dd      	bls.n	800f2aa <find_volume+0x12e>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
 800f2ee:	2300      	movs	r3, #0
 800f2f0:	643b      	str	r3, [r7, #64]	@ 0x40
		if (i) i--;
 800f2f2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2f4:	2b00      	cmp	r3, #0
 800f2f6:	d002      	beq.n	800f2fe <find_volume+0x182>
 800f2f8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2fa:	3b01      	subs	r3, #1
 800f2fc:	643b      	str	r3, [r7, #64]	@ 0x40
		do {							/* Find an FAT volume */
			bsect = br[i];
 800f2fe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f300:	009b      	lsls	r3, r3, #2
 800f302:	3358      	adds	r3, #88	@ 0x58
 800f304:	443b      	add	r3, r7
 800f306:	f853 3c44 	ldr.w	r3, [r3, #-68]
 800f30a:	653b      	str	r3, [r7, #80]	@ 0x50
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800f30c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f30e:	2b00      	cmp	r3, #0
 800f310:	d005      	beq.n	800f31e <find_volume+0x1a2>
 800f312:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f314:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800f316:	f7ff fedb 	bl	800f0d0 <check_fs>
 800f31a:	4603      	mov	r3, r0
 800f31c:	e000      	b.n	800f320 <find_volume+0x1a4>
 800f31e:	2303      	movs	r3, #3
 800f320:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800f324:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f328:	2b01      	cmp	r3, #1
 800f32a:	d905      	bls.n	800f338 <find_volume+0x1bc>
 800f32c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f32e:	3301      	adds	r3, #1
 800f330:	643b      	str	r3, [r7, #64]	@ 0x40
 800f332:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f334:	2b03      	cmp	r3, #3
 800f336:	d9e2      	bls.n	800f2fe <find_volume+0x182>
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800f338:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f33c:	2b04      	cmp	r3, #4
 800f33e:	d101      	bne.n	800f344 <find_volume+0x1c8>
 800f340:	2301      	movs	r3, #1
 800f342:	e191      	b.n	800f668 <find_volume+0x4ec>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800f344:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f348:	2b01      	cmp	r3, #1
 800f34a:	d901      	bls.n	800f350 <find_volume+0x1d4>
 800f34c:	230d      	movs	r3, #13
 800f34e:	e18b      	b.n	800f668 <find_volume+0x4ec>
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* _FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800f350:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f352:	3334      	adds	r3, #52	@ 0x34
 800f354:	330b      	adds	r3, #11
 800f356:	4618      	mov	r0, r3
 800f358:	f7fe fbf6 	bl	800db48 <ld_word>
 800f35c:	4603      	mov	r3, r0
 800f35e:	461a      	mov	r2, r3
 800f360:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f362:	899b      	ldrh	r3, [r3, #12]
 800f364:	429a      	cmp	r2, r3
 800f366:	d001      	beq.n	800f36c <find_volume+0x1f0>
 800f368:	230d      	movs	r3, #13
 800f36a:	e17d      	b.n	800f668 <find_volume+0x4ec>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800f36c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f36e:	3334      	adds	r3, #52	@ 0x34
 800f370:	3316      	adds	r3, #22
 800f372:	4618      	mov	r0, r3
 800f374:	f7fe fbe8 	bl	800db48 <ld_word>
 800f378:	4603      	mov	r3, r0
 800f37a:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800f37c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f37e:	2b00      	cmp	r3, #0
 800f380:	d106      	bne.n	800f390 <find_volume+0x214>
 800f382:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f384:	3334      	adds	r3, #52	@ 0x34
 800f386:	3324      	adds	r3, #36	@ 0x24
 800f388:	4618      	mov	r0, r3
 800f38a:	f7fe fbf5 	bl	800db78 <ld_dword>
 800f38e:	64f8      	str	r0, [r7, #76]	@ 0x4c
		fs->fsize = fasize;
 800f390:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f392:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f394:	61da      	str	r2, [r3, #28]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800f396:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f398:	f893 2044 	ldrb.w	r2, [r3, #68]	@ 0x44
 800f39c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f39e:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800f3a0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3a2:	789b      	ldrb	r3, [r3, #2]
 800f3a4:	2b01      	cmp	r3, #1
 800f3a6:	d005      	beq.n	800f3b4 <find_volume+0x238>
 800f3a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3aa:	789b      	ldrb	r3, [r3, #2]
 800f3ac:	2b02      	cmp	r3, #2
 800f3ae:	d001      	beq.n	800f3b4 <find_volume+0x238>
 800f3b0:	230d      	movs	r3, #13
 800f3b2:	e159      	b.n	800f668 <find_volume+0x4ec>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800f3b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3b6:	789b      	ldrb	r3, [r3, #2]
 800f3b8:	461a      	mov	r2, r3
 800f3ba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f3bc:	fb02 f303 	mul.w	r3, r2, r3
 800f3c0:	64fb      	str	r3, [r7, #76]	@ 0x4c

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800f3c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3c4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800f3c8:	461a      	mov	r2, r3
 800f3ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3cc:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800f3ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3d0:	895b      	ldrh	r3, [r3, #10]
 800f3d2:	2b00      	cmp	r3, #0
 800f3d4:	d008      	beq.n	800f3e8 <find_volume+0x26c>
 800f3d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3d8:	895b      	ldrh	r3, [r3, #10]
 800f3da:	461a      	mov	r2, r3
 800f3dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3de:	895b      	ldrh	r3, [r3, #10]
 800f3e0:	3b01      	subs	r3, #1
 800f3e2:	4013      	ands	r3, r2
 800f3e4:	2b00      	cmp	r3, #0
 800f3e6:	d001      	beq.n	800f3ec <find_volume+0x270>
 800f3e8:	230d      	movs	r3, #13
 800f3ea:	e13d      	b.n	800f668 <find_volume+0x4ec>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800f3ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3ee:	3334      	adds	r3, #52	@ 0x34
 800f3f0:	3311      	adds	r3, #17
 800f3f2:	4618      	mov	r0, r3
 800f3f4:	f7fe fba8 	bl	800db48 <ld_word>
 800f3f8:	4603      	mov	r3, r0
 800f3fa:	461a      	mov	r2, r3
 800f3fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f3fe:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800f400:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f402:	891b      	ldrh	r3, [r3, #8]
 800f404:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800f406:	8992      	ldrh	r2, [r2, #12]
 800f408:	0952      	lsrs	r2, r2, #5
 800f40a:	b292      	uxth	r2, r2
 800f40c:	fbb3 f1f2 	udiv	r1, r3, r2
 800f410:	fb01 f202 	mul.w	r2, r1, r2
 800f414:	1a9b      	subs	r3, r3, r2
 800f416:	b29b      	uxth	r3, r3
 800f418:	2b00      	cmp	r3, #0
 800f41a:	d003      	beq.n	800f424 <find_volume+0x2a8>
 800f41c:	230d      	movs	r3, #13
 800f41e:	e123      	b.n	800f668 <find_volume+0x4ec>
 800f420:	200028ec 	.word	0x200028ec

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 800f424:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f426:	3334      	adds	r3, #52	@ 0x34
 800f428:	3313      	adds	r3, #19
 800f42a:	4618      	mov	r0, r3
 800f42c:	f7fe fb8c 	bl	800db48 <ld_word>
 800f430:	4603      	mov	r3, r0
 800f432:	64bb      	str	r3, [r7, #72]	@ 0x48
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800f434:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f436:	2b00      	cmp	r3, #0
 800f438:	d106      	bne.n	800f448 <find_volume+0x2cc>
 800f43a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f43c:	3334      	adds	r3, #52	@ 0x34
 800f43e:	3320      	adds	r3, #32
 800f440:	4618      	mov	r0, r3
 800f442:	f7fe fb99 	bl	800db78 <ld_dword>
 800f446:	64b8      	str	r0, [r7, #72]	@ 0x48

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 800f448:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f44a:	3334      	adds	r3, #52	@ 0x34
 800f44c:	330e      	adds	r3, #14
 800f44e:	4618      	mov	r0, r3
 800f450:	f7fe fb7a 	bl	800db48 <ld_word>
 800f454:	4603      	mov	r3, r0
 800f456:	85fb      	strh	r3, [r7, #46]	@ 0x2e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800f458:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 800f45a:	2b00      	cmp	r3, #0
 800f45c:	d101      	bne.n	800f462 <find_volume+0x2e6>
 800f45e:	230d      	movs	r3, #13
 800f460:	e102      	b.n	800f668 <find_volume+0x4ec>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800f462:	8dfa      	ldrh	r2, [r7, #46]	@ 0x2e
 800f464:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f466:	4413      	add	r3, r2
 800f468:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800f46a:	8911      	ldrh	r1, [r2, #8]
 800f46c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800f46e:	8992      	ldrh	r2, [r2, #12]
 800f470:	0952      	lsrs	r2, r2, #5
 800f472:	b292      	uxth	r2, r2
 800f474:	fbb1 f2f2 	udiv	r2, r1, r2
 800f478:	b292      	uxth	r2, r2
 800f47a:	4413      	add	r3, r2
 800f47c:	62bb      	str	r3, [r7, #40]	@ 0x28
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800f47e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f480:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f482:	429a      	cmp	r2, r3
 800f484:	d201      	bcs.n	800f48a <find_volume+0x30e>
 800f486:	230d      	movs	r3, #13
 800f488:	e0ee      	b.n	800f668 <find_volume+0x4ec>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800f48a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f48c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f48e:	1ad3      	subs	r3, r2, r3
 800f490:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800f492:	8952      	ldrh	r2, [r2, #10]
 800f494:	fbb3 f3f2 	udiv	r3, r3, r2
 800f498:	627b      	str	r3, [r7, #36]	@ 0x24
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800f49a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f49c:	2b00      	cmp	r3, #0
 800f49e:	d101      	bne.n	800f4a4 <find_volume+0x328>
 800f4a0:	230d      	movs	r3, #13
 800f4a2:	e0e1      	b.n	800f668 <find_volume+0x4ec>
		fmt = FS_FAT32;
 800f4a4:	2303      	movs	r3, #3
 800f4a6:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800f4aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f4ac:	f64f 72f5 	movw	r2, #65525	@ 0xfff5
 800f4b0:	4293      	cmp	r3, r2
 800f4b2:	d802      	bhi.n	800f4ba <find_volume+0x33e>
 800f4b4:	2302      	movs	r3, #2
 800f4b6:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800f4ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f4bc:	f640 72f5 	movw	r2, #4085	@ 0xff5
 800f4c0:	4293      	cmp	r3, r2
 800f4c2:	d802      	bhi.n	800f4ca <find_volume+0x34e>
 800f4c4:	2301      	movs	r3, #1
 800f4c6:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800f4ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f4cc:	1c9a      	adds	r2, r3, #2
 800f4ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4d0:	619a      	str	r2, [r3, #24]
		fs->volbase = bsect;							/* Volume start sector */
 800f4d2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4d4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f4d6:	621a      	str	r2, [r3, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800f4d8:	8dfa      	ldrh	r2, [r7, #46]	@ 0x2e
 800f4da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f4dc:	441a      	add	r2, r3
 800f4de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4e0:	625a      	str	r2, [r3, #36]	@ 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 800f4e2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f4e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f4e6:	441a      	add	r2, r3
 800f4e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4ea:	62da      	str	r2, [r3, #44]	@ 0x2c
		if (fmt == FS_FAT32) {
 800f4ec:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f4f0:	2b03      	cmp	r3, #3
 800f4f2:	d11e      	bne.n	800f532 <find_volume+0x3b6>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800f4f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4f6:	3334      	adds	r3, #52	@ 0x34
 800f4f8:	332a      	adds	r3, #42	@ 0x2a
 800f4fa:	4618      	mov	r0, r3
 800f4fc:	f7fe fb24 	bl	800db48 <ld_word>
 800f500:	4603      	mov	r3, r0
 800f502:	2b00      	cmp	r3, #0
 800f504:	d001      	beq.n	800f50a <find_volume+0x38e>
 800f506:	230d      	movs	r3, #13
 800f508:	e0ae      	b.n	800f668 <find_volume+0x4ec>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800f50a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f50c:	891b      	ldrh	r3, [r3, #8]
 800f50e:	2b00      	cmp	r3, #0
 800f510:	d001      	beq.n	800f516 <find_volume+0x39a>
 800f512:	230d      	movs	r3, #13
 800f514:	e0a8      	b.n	800f668 <find_volume+0x4ec>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800f516:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f518:	3334      	adds	r3, #52	@ 0x34
 800f51a:	332c      	adds	r3, #44	@ 0x2c
 800f51c:	4618      	mov	r0, r3
 800f51e:	f7fe fb2b 	bl	800db78 <ld_dword>
 800f522:	4602      	mov	r2, r0
 800f524:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f526:	629a      	str	r2, [r3, #40]	@ 0x28
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800f528:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f52a:	699b      	ldr	r3, [r3, #24]
 800f52c:	009b      	lsls	r3, r3, #2
 800f52e:	647b      	str	r3, [r7, #68]	@ 0x44
 800f530:	e01f      	b.n	800f572 <find_volume+0x3f6>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800f532:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f534:	891b      	ldrh	r3, [r3, #8]
 800f536:	2b00      	cmp	r3, #0
 800f538:	d101      	bne.n	800f53e <find_volume+0x3c2>
 800f53a:	230d      	movs	r3, #13
 800f53c:	e094      	b.n	800f668 <find_volume+0x4ec>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800f53e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f540:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800f542:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f544:	441a      	add	r2, r3
 800f546:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f548:	629a      	str	r2, [r3, #40]	@ 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800f54a:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f54e:	2b02      	cmp	r3, #2
 800f550:	d103      	bne.n	800f55a <find_volume+0x3de>
 800f552:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f554:	699b      	ldr	r3, [r3, #24]
 800f556:	005b      	lsls	r3, r3, #1
 800f558:	e00a      	b.n	800f570 <find_volume+0x3f4>
 800f55a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f55c:	699a      	ldr	r2, [r3, #24]
 800f55e:	4613      	mov	r3, r2
 800f560:	005b      	lsls	r3, r3, #1
 800f562:	4413      	add	r3, r2
 800f564:	085a      	lsrs	r2, r3, #1
 800f566:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f568:	699b      	ldr	r3, [r3, #24]
 800f56a:	f003 0301 	and.w	r3, r3, #1
 800f56e:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800f570:	647b      	str	r3, [r7, #68]	@ 0x44
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800f572:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f574:	69da      	ldr	r2, [r3, #28]
 800f576:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f578:	899b      	ldrh	r3, [r3, #12]
 800f57a:	4619      	mov	r1, r3
 800f57c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f57e:	440b      	add	r3, r1
 800f580:	3b01      	subs	r3, #1
 800f582:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 800f584:	8989      	ldrh	r1, [r1, #12]
 800f586:	fbb3 f3f1 	udiv	r3, r3, r1
 800f58a:	429a      	cmp	r2, r3
 800f58c:	d201      	bcs.n	800f592 <find_volume+0x416>
 800f58e:	230d      	movs	r3, #13
 800f590:	e06a      	b.n	800f668 <find_volume+0x4ec>

#if !_FS_READONLY
		/* Get FSINFO if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800f592:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f594:	f04f 32ff 	mov.w	r2, #4294967295
 800f598:	615a      	str	r2, [r3, #20]
 800f59a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f59c:	695a      	ldr	r2, [r3, #20]
 800f59e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5a0:	611a      	str	r2, [r3, #16]
		fs->fsi_flag = 0x80;
 800f5a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5a4:	2280      	movs	r2, #128	@ 0x80
 800f5a6:	711a      	strb	r2, [r3, #4]
#if (_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 800f5a8:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 800f5ac:	2b03      	cmp	r3, #3
 800f5ae:	d149      	bne.n	800f644 <find_volume+0x4c8>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800f5b0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5b2:	3334      	adds	r3, #52	@ 0x34
 800f5b4:	3330      	adds	r3, #48	@ 0x30
 800f5b6:	4618      	mov	r0, r3
 800f5b8:	f7fe fac6 	bl	800db48 <ld_word>
 800f5bc:	4603      	mov	r3, r0
 800f5be:	2b01      	cmp	r3, #1
 800f5c0:	d140      	bne.n	800f644 <find_volume+0x4c8>
			&& move_window(fs, bsect + 1) == FR_OK)
 800f5c2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f5c4:	3301      	adds	r3, #1
 800f5c6:	4619      	mov	r1, r3
 800f5c8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800f5ca:	f7fe fd6d 	bl	800e0a8 <move_window>
 800f5ce:	4603      	mov	r3, r0
 800f5d0:	2b00      	cmp	r3, #0
 800f5d2:	d137      	bne.n	800f644 <find_volume+0x4c8>
		{
			fs->fsi_flag = 0;
 800f5d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5d6:	2200      	movs	r2, #0
 800f5d8:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800f5da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5dc:	3334      	adds	r3, #52	@ 0x34
 800f5de:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 800f5e2:	4618      	mov	r0, r3
 800f5e4:	f7fe fab0 	bl	800db48 <ld_word>
 800f5e8:	4603      	mov	r3, r0
 800f5ea:	461a      	mov	r2, r3
 800f5ec:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 800f5f0:	429a      	cmp	r2, r3
 800f5f2:	d127      	bne.n	800f644 <find_volume+0x4c8>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800f5f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5f6:	3334      	adds	r3, #52	@ 0x34
 800f5f8:	4618      	mov	r0, r3
 800f5fa:	f7fe fabd 	bl	800db78 <ld_dword>
 800f5fe:	4603      	mov	r3, r0
 800f600:	4a1b      	ldr	r2, [pc, #108]	@ (800f670 <find_volume+0x4f4>)
 800f602:	4293      	cmp	r3, r2
 800f604:	d11e      	bne.n	800f644 <find_volume+0x4c8>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800f606:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f608:	3334      	adds	r3, #52	@ 0x34
 800f60a:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800f60e:	4618      	mov	r0, r3
 800f610:	f7fe fab2 	bl	800db78 <ld_dword>
 800f614:	4603      	mov	r3, r0
 800f616:	4a17      	ldr	r2, [pc, #92]	@ (800f674 <find_volume+0x4f8>)
 800f618:	4293      	cmp	r3, r2
 800f61a:	d113      	bne.n	800f644 <find_volume+0x4c8>
			{
#if (_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 800f61c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f61e:	3334      	adds	r3, #52	@ 0x34
 800f620:	f503 73f4 	add.w	r3, r3, #488	@ 0x1e8
 800f624:	4618      	mov	r0, r3
 800f626:	f7fe faa7 	bl	800db78 <ld_dword>
 800f62a:	4602      	mov	r2, r0
 800f62c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f62e:	615a      	str	r2, [r3, #20]
#endif
#if (_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800f630:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f632:	3334      	adds	r3, #52	@ 0x34
 800f634:	f503 73f6 	add.w	r3, r3, #492	@ 0x1ec
 800f638:	4618      	mov	r0, r3
 800f63a:	f7fe fa9d 	bl	800db78 <ld_dword>
 800f63e:	4602      	mov	r2, r0
 800f640:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f642:	611a      	str	r2, [r3, #16]
		}
#endif	/* (_FS_NOFSINFO & 3) != 3 */
#endif	/* !_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
 800f644:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f646:	f897 2057 	ldrb.w	r2, [r7, #87]	@ 0x57
 800f64a:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 800f64c:	4b0a      	ldr	r3, [pc, #40]	@ (800f678 <find_volume+0x4fc>)
 800f64e:	881b      	ldrh	r3, [r3, #0]
 800f650:	3301      	adds	r3, #1
 800f652:	b29a      	uxth	r2, r3
 800f654:	4b08      	ldr	r3, [pc, #32]	@ (800f678 <find_volume+0x4fc>)
 800f656:	801a      	strh	r2, [r3, #0]
 800f658:	4b07      	ldr	r3, [pc, #28]	@ (800f678 <find_volume+0x4fc>)
 800f65a:	881a      	ldrh	r2, [r3, #0]
 800f65c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f65e:	80da      	strh	r2, [r3, #6]
#endif
#if _FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
 800f660:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800f662:	f7fe fcb9 	bl	800dfd8 <clear_lock>
#endif
	return FR_OK;
 800f666:	2300      	movs	r3, #0
}
 800f668:	4618      	mov	r0, r3
 800f66a:	3758      	adds	r7, #88	@ 0x58
 800f66c:	46bd      	mov	sp, r7
 800f66e:	bd80      	pop	{r7, pc}
 800f670:	41615252 	.word	0x41615252
 800f674:	61417272 	.word	0x61417272
 800f678:	200028f0 	.word	0x200028f0

0800f67c <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 800f67c:	b580      	push	{r7, lr}
 800f67e:	b084      	sub	sp, #16
 800f680:	af00      	add	r7, sp, #0
 800f682:	6078      	str	r0, [r7, #4]
 800f684:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
 800f686:	2309      	movs	r3, #9
 800f688:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800f68a:	687b      	ldr	r3, [r7, #4]
 800f68c:	2b00      	cmp	r3, #0
 800f68e:	d01c      	beq.n	800f6ca <validate+0x4e>
 800f690:	687b      	ldr	r3, [r7, #4]
 800f692:	681b      	ldr	r3, [r3, #0]
 800f694:	2b00      	cmp	r3, #0
 800f696:	d018      	beq.n	800f6ca <validate+0x4e>
 800f698:	687b      	ldr	r3, [r7, #4]
 800f69a:	681b      	ldr	r3, [r3, #0]
 800f69c:	781b      	ldrb	r3, [r3, #0]
 800f69e:	2b00      	cmp	r3, #0
 800f6a0:	d013      	beq.n	800f6ca <validate+0x4e>
 800f6a2:	687b      	ldr	r3, [r7, #4]
 800f6a4:	889a      	ldrh	r2, [r3, #4]
 800f6a6:	687b      	ldr	r3, [r7, #4]
 800f6a8:	681b      	ldr	r3, [r3, #0]
 800f6aa:	88db      	ldrh	r3, [r3, #6]
 800f6ac:	429a      	cmp	r2, r3
 800f6ae:	d10c      	bne.n	800f6ca <validate+0x4e>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800f6b0:	687b      	ldr	r3, [r7, #4]
 800f6b2:	681b      	ldr	r3, [r3, #0]
 800f6b4:	785b      	ldrb	r3, [r3, #1]
 800f6b6:	4618      	mov	r0, r3
 800f6b8:	f7fe f9a6 	bl	800da08 <disk_status>
 800f6bc:	4603      	mov	r3, r0
 800f6be:	f003 0301 	and.w	r3, r3, #1
 800f6c2:	2b00      	cmp	r3, #0
 800f6c4:	d101      	bne.n	800f6ca <validate+0x4e>
			res = FR_OK;
 800f6c6:	2300      	movs	r3, #0
 800f6c8:	73fb      	strb	r3, [r7, #15]
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800f6ca:	7bfb      	ldrb	r3, [r7, #15]
 800f6cc:	2b00      	cmp	r3, #0
 800f6ce:	d102      	bne.n	800f6d6 <validate+0x5a>
 800f6d0:	687b      	ldr	r3, [r7, #4]
 800f6d2:	681b      	ldr	r3, [r3, #0]
 800f6d4:	e000      	b.n	800f6d8 <validate+0x5c>
 800f6d6:	2300      	movs	r3, #0
 800f6d8:	683a      	ldr	r2, [r7, #0]
 800f6da:	6013      	str	r3, [r2, #0]
	return res;
 800f6dc:	7bfb      	ldrb	r3, [r7, #15]
}
 800f6de:	4618      	mov	r0, r3
 800f6e0:	3710      	adds	r7, #16
 800f6e2:	46bd      	mov	sp, r7
 800f6e4:	bd80      	pop	{r7, pc}
	...

0800f6e8 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800f6e8:	b580      	push	{r7, lr}
 800f6ea:	b088      	sub	sp, #32
 800f6ec:	af00      	add	r7, sp, #0
 800f6ee:	60f8      	str	r0, [r7, #12]
 800f6f0:	60b9      	str	r1, [r7, #8]
 800f6f2:	4613      	mov	r3, r2
 800f6f4:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800f6f6:	68bb      	ldr	r3, [r7, #8]
 800f6f8:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 800f6fa:	f107 0310 	add.w	r3, r7, #16
 800f6fe:	4618      	mov	r0, r3
 800f700:	f7ff fca2 	bl	800f048 <get_ldnumber>
 800f704:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
 800f706:	69fb      	ldr	r3, [r7, #28]
 800f708:	2b00      	cmp	r3, #0
 800f70a:	da01      	bge.n	800f710 <f_mount+0x28>
 800f70c:	230b      	movs	r3, #11
 800f70e:	e02b      	b.n	800f768 <f_mount+0x80>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800f710:	4a17      	ldr	r2, [pc, #92]	@ (800f770 <f_mount+0x88>)
 800f712:	69fb      	ldr	r3, [r7, #28]
 800f714:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f718:	61bb      	str	r3, [r7, #24]

	if (cfs) {
 800f71a:	69bb      	ldr	r3, [r7, #24]
 800f71c:	2b00      	cmp	r3, #0
 800f71e:	d005      	beq.n	800f72c <f_mount+0x44>
#if _FS_LOCK != 0
		clear_lock(cfs);
 800f720:	69b8      	ldr	r0, [r7, #24]
 800f722:	f7fe fc59 	bl	800dfd8 <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 800f726:	69bb      	ldr	r3, [r7, #24]
 800f728:	2200      	movs	r2, #0
 800f72a:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 800f72c:	68fb      	ldr	r3, [r7, #12]
 800f72e:	2b00      	cmp	r3, #0
 800f730:	d002      	beq.n	800f738 <f_mount+0x50>
		fs->fs_type = 0;				/* Clear new fs object */
 800f732:	68fb      	ldr	r3, [r7, #12]
 800f734:	2200      	movs	r2, #0
 800f736:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800f738:	68fa      	ldr	r2, [r7, #12]
 800f73a:	490d      	ldr	r1, [pc, #52]	@ (800f770 <f_mount+0x88>)
 800f73c:	69fb      	ldr	r3, [r7, #28]
 800f73e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800f742:	68fb      	ldr	r3, [r7, #12]
 800f744:	2b00      	cmp	r3, #0
 800f746:	d002      	beq.n	800f74e <f_mount+0x66>
 800f748:	79fb      	ldrb	r3, [r7, #7]
 800f74a:	2b01      	cmp	r3, #1
 800f74c:	d001      	beq.n	800f752 <f_mount+0x6a>
 800f74e:	2300      	movs	r3, #0
 800f750:	e00a      	b.n	800f768 <f_mount+0x80>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800f752:	f107 010c 	add.w	r1, r7, #12
 800f756:	f107 0308 	add.w	r3, r7, #8
 800f75a:	2200      	movs	r2, #0
 800f75c:	4618      	mov	r0, r3
 800f75e:	f7ff fd0d 	bl	800f17c <find_volume>
 800f762:	4603      	mov	r3, r0
 800f764:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
 800f766:	7dfb      	ldrb	r3, [r7, #23]
}
 800f768:	4618      	mov	r0, r3
 800f76a:	3720      	adds	r7, #32
 800f76c:	46bd      	mov	sp, r7
 800f76e:	bd80      	pop	{r7, pc}
 800f770:	200028ec 	.word	0x200028ec

0800f774 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800f774:	b580      	push	{r7, lr}
 800f776:	b098      	sub	sp, #96	@ 0x60
 800f778:	af00      	add	r7, sp, #0
 800f77a:	60f8      	str	r0, [r7, #12]
 800f77c:	60b9      	str	r1, [r7, #8]
 800f77e:	4613      	mov	r3, r2
 800f780:	71fb      	strb	r3, [r7, #7]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800f782:	68fb      	ldr	r3, [r7, #12]
 800f784:	2b00      	cmp	r3, #0
 800f786:	d101      	bne.n	800f78c <f_open+0x18>
 800f788:	2309      	movs	r3, #9
 800f78a:	e1b7      	b.n	800fafc <f_open+0x388>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800f78c:	79fb      	ldrb	r3, [r7, #7]
 800f78e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800f792:	71fb      	strb	r3, [r7, #7]
	res = find_volume(&path, &fs, mode);
 800f794:	79fa      	ldrb	r2, [r7, #7]
 800f796:	f107 0110 	add.w	r1, r7, #16
 800f79a:	f107 0308 	add.w	r3, r7, #8
 800f79e:	4618      	mov	r0, r3
 800f7a0:	f7ff fcec 	bl	800f17c <find_volume>
 800f7a4:	4603      	mov	r3, r0
 800f7a6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
	if (res == FR_OK) {
 800f7aa:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f7ae:	2b00      	cmp	r3, #0
 800f7b0:	f040 819b 	bne.w	800faea <f_open+0x376>
		dj.obj.fs = fs;
 800f7b4:	693b      	ldr	r3, [r7, #16]
 800f7b6:	617b      	str	r3, [r7, #20]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 800f7b8:	68ba      	ldr	r2, [r7, #8]
 800f7ba:	f107 0314 	add.w	r3, r7, #20
 800f7be:	4611      	mov	r1, r2
 800f7c0:	4618      	mov	r0, r3
 800f7c2:	f7ff fbcb 	bl	800ef5c <follow_path>
 800f7c6:	4603      	mov	r3, r0
 800f7c8:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 800f7cc:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f7d0:	2b00      	cmp	r3, #0
 800f7d2:	d118      	bne.n	800f806 <f_open+0x92>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800f7d4:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 800f7d8:	b25b      	sxtb	r3, r3
 800f7da:	2b00      	cmp	r3, #0
 800f7dc:	da03      	bge.n	800f7e6 <f_open+0x72>
				res = FR_INVALID_NAME;
 800f7de:	2306      	movs	r3, #6
 800f7e0:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 800f7e4:	e00f      	b.n	800f806 <f_open+0x92>
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800f7e6:	79fb      	ldrb	r3, [r7, #7]
 800f7e8:	2b01      	cmp	r3, #1
 800f7ea:	bf8c      	ite	hi
 800f7ec:	2301      	movhi	r3, #1
 800f7ee:	2300      	movls	r3, #0
 800f7f0:	b2db      	uxtb	r3, r3
 800f7f2:	461a      	mov	r2, r3
 800f7f4:	f107 0314 	add.w	r3, r7, #20
 800f7f8:	4611      	mov	r1, r2
 800f7fa:	4618      	mov	r0, r3
 800f7fc:	f7fe faa4 	bl	800dd48 <chk_lock>
 800f800:	4603      	mov	r3, r0
 800f802:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800f806:	79fb      	ldrb	r3, [r7, #7]
 800f808:	f003 031c 	and.w	r3, r3, #28
 800f80c:	2b00      	cmp	r3, #0
 800f80e:	d07f      	beq.n	800f910 <f_open+0x19c>
			if (res != FR_OK) {					/* No file, create new */
 800f810:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f814:	2b00      	cmp	r3, #0
 800f816:	d017      	beq.n	800f848 <f_open+0xd4>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 800f818:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f81c:	2b04      	cmp	r3, #4
 800f81e:	d10e      	bne.n	800f83e <f_open+0xca>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 800f820:	f7fe faee 	bl	800de00 <enq_lock>
 800f824:	4603      	mov	r3, r0
 800f826:	2b00      	cmp	r3, #0
 800f828:	d006      	beq.n	800f838 <f_open+0xc4>
 800f82a:	f107 0314 	add.w	r3, r7, #20
 800f82e:	4618      	mov	r0, r3
 800f830:	f7ff fab0 	bl	800ed94 <dir_register>
 800f834:	4603      	mov	r3, r0
 800f836:	e000      	b.n	800f83a <f_open+0xc6>
 800f838:	2312      	movs	r3, #18
 800f83a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800f83e:	79fb      	ldrb	r3, [r7, #7]
 800f840:	f043 0308 	orr.w	r3, r3, #8
 800f844:	71fb      	strb	r3, [r7, #7]
 800f846:	e010      	b.n	800f86a <f_open+0xf6>
			}
			else {								/* Any object is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800f848:	7ebb      	ldrb	r3, [r7, #26]
 800f84a:	f003 0311 	and.w	r3, r3, #17
 800f84e:	2b00      	cmp	r3, #0
 800f850:	d003      	beq.n	800f85a <f_open+0xe6>
					res = FR_DENIED;
 800f852:	2307      	movs	r3, #7
 800f854:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 800f858:	e007      	b.n	800f86a <f_open+0xf6>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800f85a:	79fb      	ldrb	r3, [r7, #7]
 800f85c:	f003 0304 	and.w	r3, r3, #4
 800f860:	2b00      	cmp	r3, #0
 800f862:	d002      	beq.n	800f86a <f_open+0xf6>
 800f864:	2308      	movs	r3, #8
 800f866:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800f86a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f86e:	2b00      	cmp	r3, #0
 800f870:	d168      	bne.n	800f944 <f_open+0x1d0>
 800f872:	79fb      	ldrb	r3, [r7, #7]
 800f874:	f003 0308 	and.w	r3, r3, #8
 800f878:	2b00      	cmp	r3, #0
 800f87a:	d063      	beq.n	800f944 <f_open+0x1d0>
				dw = GET_FATTIME();
 800f87c:	f7fa ff22 	bl	800a6c4 <get_fattime>
 800f880:	6538      	str	r0, [r7, #80]	@ 0x50
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 800f882:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f884:	330e      	adds	r3, #14
 800f886:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f888:	4618      	mov	r0, r3
 800f88a:	f7fe f9b3 	bl	800dbf4 <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 800f88e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f890:	3316      	adds	r3, #22
 800f892:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f894:	4618      	mov	r0, r3
 800f896:	f7fe f9ad 	bl	800dbf4 <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 800f89a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f89c:	330b      	adds	r3, #11
 800f89e:	2220      	movs	r2, #32
 800f8a0:	701a      	strb	r2, [r3, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800f8a2:	693b      	ldr	r3, [r7, #16]
 800f8a4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f8a6:	4611      	mov	r1, r2
 800f8a8:	4618      	mov	r0, r3
 800f8aa:	f7ff f982 	bl	800ebb2 <ld_clust>
 800f8ae:	64f8      	str	r0, [r7, #76]	@ 0x4c
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 800f8b0:	693b      	ldr	r3, [r7, #16]
 800f8b2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800f8b4:	2200      	movs	r2, #0
 800f8b6:	4618      	mov	r0, r3
 800f8b8:	f7ff f99a 	bl	800ebf0 <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
 800f8bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8be:	331c      	adds	r3, #28
 800f8c0:	2100      	movs	r1, #0
 800f8c2:	4618      	mov	r0, r3
 800f8c4:	f7fe f996 	bl	800dbf4 <st_dword>
					fs->wflag = 1;
 800f8c8:	693b      	ldr	r3, [r7, #16]
 800f8ca:	2201      	movs	r2, #1
 800f8cc:	70da      	strb	r2, [r3, #3]

					if (cl) {							/* Remove the cluster chain if exist */
 800f8ce:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f8d0:	2b00      	cmp	r3, #0
 800f8d2:	d037      	beq.n	800f944 <f_open+0x1d0>
						dw = fs->winsect;
 800f8d4:	693b      	ldr	r3, [r7, #16]
 800f8d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f8d8:	653b      	str	r3, [r7, #80]	@ 0x50
						res = remove_chain(&dj.obj, cl, 0);
 800f8da:	f107 0314 	add.w	r3, r7, #20
 800f8de:	2200      	movs	r2, #0
 800f8e0:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800f8e2:	4618      	mov	r0, r3
 800f8e4:	f7fe fe8a 	bl	800e5fc <remove_chain>
 800f8e8:	4603      	mov	r3, r0
 800f8ea:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
						if (res == FR_OK) {
 800f8ee:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f8f2:	2b00      	cmp	r3, #0
 800f8f4:	d126      	bne.n	800f944 <f_open+0x1d0>
							res = move_window(fs, dw);
 800f8f6:	693b      	ldr	r3, [r7, #16]
 800f8f8:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f8fa:	4618      	mov	r0, r3
 800f8fc:	f7fe fbd4 	bl	800e0a8 <move_window>
 800f900:	4603      	mov	r3, r0
 800f902:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800f906:	693b      	ldr	r3, [r7, #16]
 800f908:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f90a:	3a01      	subs	r2, #1
 800f90c:	611a      	str	r2, [r3, #16]
 800f90e:	e019      	b.n	800f944 <f_open+0x1d0>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
 800f910:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f914:	2b00      	cmp	r3, #0
 800f916:	d115      	bne.n	800f944 <f_open+0x1d0>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 800f918:	7ebb      	ldrb	r3, [r7, #26]
 800f91a:	f003 0310 	and.w	r3, r3, #16
 800f91e:	2b00      	cmp	r3, #0
 800f920:	d003      	beq.n	800f92a <f_open+0x1b6>
					res = FR_NO_FILE;
 800f922:	2304      	movs	r3, #4
 800f924:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 800f928:	e00c      	b.n	800f944 <f_open+0x1d0>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 800f92a:	79fb      	ldrb	r3, [r7, #7]
 800f92c:	f003 0302 	and.w	r3, r3, #2
 800f930:	2b00      	cmp	r3, #0
 800f932:	d007      	beq.n	800f944 <f_open+0x1d0>
 800f934:	7ebb      	ldrb	r3, [r7, #26]
 800f936:	f003 0301 	and.w	r3, r3, #1
 800f93a:	2b00      	cmp	r3, #0
 800f93c:	d002      	beq.n	800f944 <f_open+0x1d0>
						res = FR_DENIED;
 800f93e:	2307      	movs	r3, #7
 800f940:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
					}
				}
			}
		}
		if (res == FR_OK) {
 800f944:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f948:	2b00      	cmp	r3, #0
 800f94a:	d126      	bne.n	800f99a <f_open+0x226>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 800f94c:	79fb      	ldrb	r3, [r7, #7]
 800f94e:	f003 0308 	and.w	r3, r3, #8
 800f952:	2b00      	cmp	r3, #0
 800f954:	d003      	beq.n	800f95e <f_open+0x1ea>
				mode |= FA_MODIFIED;
 800f956:	79fb      	ldrb	r3, [r7, #7]
 800f958:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800f95c:	71fb      	strb	r3, [r7, #7]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800f95e:	693b      	ldr	r3, [r7, #16]
 800f960:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800f962:	68fb      	ldr	r3, [r7, #12]
 800f964:	625a      	str	r2, [r3, #36]	@ 0x24
			fp->dir_ptr = dj.dir;
 800f966:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f968:	68fb      	ldr	r3, [r7, #12]
 800f96a:	629a      	str	r2, [r3, #40]	@ 0x28
#if _FS_LOCK != 0
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800f96c:	79fb      	ldrb	r3, [r7, #7]
 800f96e:	2b01      	cmp	r3, #1
 800f970:	bf8c      	ite	hi
 800f972:	2301      	movhi	r3, #1
 800f974:	2300      	movls	r3, #0
 800f976:	b2db      	uxtb	r3, r3
 800f978:	461a      	mov	r2, r3
 800f97a:	f107 0314 	add.w	r3, r7, #20
 800f97e:	4611      	mov	r1, r2
 800f980:	4618      	mov	r0, r3
 800f982:	f7fe fa5f 	bl	800de44 <inc_lock>
 800f986:	4602      	mov	r2, r0
 800f988:	68fb      	ldr	r3, [r7, #12]
 800f98a:	611a      	str	r2, [r3, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 800f98c:	68fb      	ldr	r3, [r7, #12]
 800f98e:	691b      	ldr	r3, [r3, #16]
 800f990:	2b00      	cmp	r3, #0
 800f992:	d102      	bne.n	800f99a <f_open+0x226>
 800f994:	2302      	movs	r3, #2
 800f996:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
				}
			}
		}
#endif

		if (res == FR_OK) {
 800f99a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800f99e:	2b00      	cmp	r3, #0
 800f9a0:	f040 80a3 	bne.w	800faea <f_open+0x376>
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800f9a4:	693b      	ldr	r3, [r7, #16]
 800f9a6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f9a8:	4611      	mov	r1, r2
 800f9aa:	4618      	mov	r0, r3
 800f9ac:	f7ff f901 	bl	800ebb2 <ld_clust>
 800f9b0:	4602      	mov	r2, r0
 800f9b2:	68fb      	ldr	r3, [r7, #12]
 800f9b4:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800f9b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9b8:	331c      	adds	r3, #28
 800f9ba:	4618      	mov	r0, r3
 800f9bc:	f7fe f8dc 	bl	800db78 <ld_dword>
 800f9c0:	4602      	mov	r2, r0
 800f9c2:	68fb      	ldr	r3, [r7, #12]
 800f9c4:	60da      	str	r2, [r3, #12]
			}
#if _USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
 800f9c6:	68fb      	ldr	r3, [r7, #12]
 800f9c8:	2200      	movs	r2, #0
 800f9ca:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
 800f9cc:	693a      	ldr	r2, [r7, #16]
 800f9ce:	68fb      	ldr	r3, [r7, #12]
 800f9d0:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
 800f9d2:	693b      	ldr	r3, [r7, #16]
 800f9d4:	88da      	ldrh	r2, [r3, #6]
 800f9d6:	68fb      	ldr	r3, [r7, #12]
 800f9d8:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
 800f9da:	68fb      	ldr	r3, [r7, #12]
 800f9dc:	79fa      	ldrb	r2, [r7, #7]
 800f9de:	751a      	strb	r2, [r3, #20]
			fp->err = 0;			/* Clear error flag */
 800f9e0:	68fb      	ldr	r3, [r7, #12]
 800f9e2:	2200      	movs	r2, #0
 800f9e4:	755a      	strb	r2, [r3, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 800f9e6:	68fb      	ldr	r3, [r7, #12]
 800f9e8:	2200      	movs	r2, #0
 800f9ea:	621a      	str	r2, [r3, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800f9ec:	68fb      	ldr	r3, [r7, #12]
 800f9ee:	2200      	movs	r2, #0
 800f9f0:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
#if !_FS_TINY
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 800f9f2:	68fb      	ldr	r3, [r7, #12]
 800f9f4:	3330      	adds	r3, #48	@ 0x30
 800f9f6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 800f9fa:	2100      	movs	r1, #0
 800f9fc:	4618      	mov	r0, r3
 800f9fe:	f7fe f946 	bl	800dc8e <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800fa02:	79fb      	ldrb	r3, [r7, #7]
 800fa04:	f003 0320 	and.w	r3, r3, #32
 800fa08:	2b00      	cmp	r3, #0
 800fa0a:	d06e      	beq.n	800faea <f_open+0x376>
 800fa0c:	68fb      	ldr	r3, [r7, #12]
 800fa0e:	68db      	ldr	r3, [r3, #12]
 800fa10:	2b00      	cmp	r3, #0
 800fa12:	d06a      	beq.n	800faea <f_open+0x376>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800fa14:	68fb      	ldr	r3, [r7, #12]
 800fa16:	68da      	ldr	r2, [r3, #12]
 800fa18:	68fb      	ldr	r3, [r7, #12]
 800fa1a:	619a      	str	r2, [r3, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800fa1c:	693b      	ldr	r3, [r7, #16]
 800fa1e:	895b      	ldrh	r3, [r3, #10]
 800fa20:	461a      	mov	r2, r3
 800fa22:	693b      	ldr	r3, [r7, #16]
 800fa24:	899b      	ldrh	r3, [r3, #12]
 800fa26:	fb02 f303 	mul.w	r3, r2, r3
 800fa2a:	64bb      	str	r3, [r7, #72]	@ 0x48
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 800fa2c:	68fb      	ldr	r3, [r7, #12]
 800fa2e:	689b      	ldr	r3, [r3, #8]
 800fa30:	65bb      	str	r3, [r7, #88]	@ 0x58
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fa32:	68fb      	ldr	r3, [r7, #12]
 800fa34:	68db      	ldr	r3, [r3, #12]
 800fa36:	657b      	str	r3, [r7, #84]	@ 0x54
 800fa38:	e016      	b.n	800fa68 <f_open+0x2f4>
					clst = get_fat(&fp->obj, clst);
 800fa3a:	68fb      	ldr	r3, [r7, #12]
 800fa3c:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 800fa3e:	4618      	mov	r0, r3
 800fa40:	f7fe fbef 	bl	800e222 <get_fat>
 800fa44:	65b8      	str	r0, [r7, #88]	@ 0x58
					if (clst <= 1) res = FR_INT_ERR;
 800fa46:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800fa48:	2b01      	cmp	r3, #1
 800fa4a:	d802      	bhi.n	800fa52 <f_open+0x2de>
 800fa4c:	2302      	movs	r3, #2
 800fa4e:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800fa52:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800fa54:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fa58:	d102      	bne.n	800fa60 <f_open+0x2ec>
 800fa5a:	2301      	movs	r3, #1
 800fa5c:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fa60:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800fa62:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800fa64:	1ad3      	subs	r3, r2, r3
 800fa66:	657b      	str	r3, [r7, #84]	@ 0x54
 800fa68:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800fa6c:	2b00      	cmp	r3, #0
 800fa6e:	d103      	bne.n	800fa78 <f_open+0x304>
 800fa70:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800fa72:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800fa74:	429a      	cmp	r2, r3
 800fa76:	d8e0      	bhi.n	800fa3a <f_open+0x2c6>
				}
				fp->clust = clst;
 800fa78:	68fb      	ldr	r3, [r7, #12]
 800fa7a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800fa7c:	61da      	str	r2, [r3, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800fa7e:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800fa82:	2b00      	cmp	r3, #0
 800fa84:	d131      	bne.n	800faea <f_open+0x376>
 800fa86:	693b      	ldr	r3, [r7, #16]
 800fa88:	899b      	ldrh	r3, [r3, #12]
 800fa8a:	461a      	mov	r2, r3
 800fa8c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800fa8e:	fbb3 f1f2 	udiv	r1, r3, r2
 800fa92:	fb01 f202 	mul.w	r2, r1, r2
 800fa96:	1a9b      	subs	r3, r3, r2
 800fa98:	2b00      	cmp	r3, #0
 800fa9a:	d026      	beq.n	800faea <f_open+0x376>
					if ((sc = clust2sect(fs, clst)) == 0) {
 800fa9c:	693b      	ldr	r3, [r7, #16]
 800fa9e:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 800faa0:	4618      	mov	r0, r3
 800faa2:	f7fe fb9f 	bl	800e1e4 <clust2sect>
 800faa6:	6478      	str	r0, [r7, #68]	@ 0x44
 800faa8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800faaa:	2b00      	cmp	r3, #0
 800faac:	d103      	bne.n	800fab6 <f_open+0x342>
						res = FR_INT_ERR;
 800faae:	2302      	movs	r3, #2
 800fab0:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 800fab4:	e019      	b.n	800faea <f_open+0x376>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 800fab6:	693b      	ldr	r3, [r7, #16]
 800fab8:	899b      	ldrh	r3, [r3, #12]
 800faba:	461a      	mov	r2, r3
 800fabc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800fabe:	fbb3 f2f2 	udiv	r2, r3, r2
 800fac2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800fac4:	441a      	add	r2, r3
 800fac6:	68fb      	ldr	r3, [r7, #12]
 800fac8:	621a      	str	r2, [r3, #32]
#if !_FS_TINY
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 800faca:	693b      	ldr	r3, [r7, #16]
 800facc:	7858      	ldrb	r0, [r3, #1]
 800face:	68fb      	ldr	r3, [r7, #12]
 800fad0:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800fad4:	68fb      	ldr	r3, [r7, #12]
 800fad6:	6a1a      	ldr	r2, [r3, #32]
 800fad8:	2301      	movs	r3, #1
 800fada:	f7fd ffd7 	bl	800da8c <disk_read>
 800fade:	4603      	mov	r3, r0
 800fae0:	2b00      	cmp	r3, #0
 800fae2:	d002      	beq.n	800faea <f_open+0x376>
 800fae4:	2301      	movs	r3, #1
 800fae6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800faea:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800faee:	2b00      	cmp	r3, #0
 800faf0:	d002      	beq.n	800faf8 <f_open+0x384>
 800faf2:	68fb      	ldr	r3, [r7, #12]
 800faf4:	2200      	movs	r2, #0
 800faf6:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 800faf8:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
 800fafc:	4618      	mov	r0, r3
 800fafe:	3760      	adds	r7, #96	@ 0x60
 800fb00:	46bd      	mov	sp, r7
 800fb02:	bd80      	pop	{r7, pc}

0800fb04 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 800fb04:	b580      	push	{r7, lr}
 800fb06:	b08e      	sub	sp, #56	@ 0x38
 800fb08:	af00      	add	r7, sp, #0
 800fb0a:	60f8      	str	r0, [r7, #12]
 800fb0c:	60b9      	str	r1, [r7, #8]
 800fb0e:	607a      	str	r2, [r7, #4]
 800fb10:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
 800fb12:	68bb      	ldr	r3, [r7, #8]
 800fb14:	627b      	str	r3, [r7, #36]	@ 0x24


	*br = 0;	/* Clear read byte counter */
 800fb16:	683b      	ldr	r3, [r7, #0]
 800fb18:	2200      	movs	r2, #0
 800fb1a:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800fb1c:	68fb      	ldr	r3, [r7, #12]
 800fb1e:	f107 0214 	add.w	r2, r7, #20
 800fb22:	4611      	mov	r1, r2
 800fb24:	4618      	mov	r0, r3
 800fb26:	f7ff fda9 	bl	800f67c <validate>
 800fb2a:	4603      	mov	r3, r0
 800fb2c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800fb30:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800fb34:	2b00      	cmp	r3, #0
 800fb36:	d107      	bne.n	800fb48 <f_read+0x44>
 800fb38:	68fb      	ldr	r3, [r7, #12]
 800fb3a:	7d5b      	ldrb	r3, [r3, #21]
 800fb3c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 800fb40:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800fb44:	2b00      	cmp	r3, #0
 800fb46:	d002      	beq.n	800fb4e <f_read+0x4a>
 800fb48:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800fb4c:	e135      	b.n	800fdba <f_read+0x2b6>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800fb4e:	68fb      	ldr	r3, [r7, #12]
 800fb50:	7d1b      	ldrb	r3, [r3, #20]
 800fb52:	f003 0301 	and.w	r3, r3, #1
 800fb56:	2b00      	cmp	r3, #0
 800fb58:	d101      	bne.n	800fb5e <f_read+0x5a>
 800fb5a:	2307      	movs	r3, #7
 800fb5c:	e12d      	b.n	800fdba <f_read+0x2b6>
	remain = fp->obj.objsize - fp->fptr;
 800fb5e:	68fb      	ldr	r3, [r7, #12]
 800fb60:	68da      	ldr	r2, [r3, #12]
 800fb62:	68fb      	ldr	r3, [r7, #12]
 800fb64:	699b      	ldr	r3, [r3, #24]
 800fb66:	1ad3      	subs	r3, r2, r3
 800fb68:	623b      	str	r3, [r7, #32]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 800fb6a:	687a      	ldr	r2, [r7, #4]
 800fb6c:	6a3b      	ldr	r3, [r7, #32]
 800fb6e:	429a      	cmp	r2, r3
 800fb70:	f240 811e 	bls.w	800fdb0 <f_read+0x2ac>
 800fb74:	6a3b      	ldr	r3, [r7, #32]
 800fb76:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
 800fb78:	e11a      	b.n	800fdb0 <f_read+0x2ac>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800fb7a:	68fb      	ldr	r3, [r7, #12]
 800fb7c:	699b      	ldr	r3, [r3, #24]
 800fb7e:	697a      	ldr	r2, [r7, #20]
 800fb80:	8992      	ldrh	r2, [r2, #12]
 800fb82:	fbb3 f1f2 	udiv	r1, r3, r2
 800fb86:	fb01 f202 	mul.w	r2, r1, r2
 800fb8a:	1a9b      	subs	r3, r3, r2
 800fb8c:	2b00      	cmp	r3, #0
 800fb8e:	f040 80d5 	bne.w	800fd3c <f_read+0x238>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800fb92:	68fb      	ldr	r3, [r7, #12]
 800fb94:	699b      	ldr	r3, [r3, #24]
 800fb96:	697a      	ldr	r2, [r7, #20]
 800fb98:	8992      	ldrh	r2, [r2, #12]
 800fb9a:	fbb3 f3f2 	udiv	r3, r3, r2
 800fb9e:	697a      	ldr	r2, [r7, #20]
 800fba0:	8952      	ldrh	r2, [r2, #10]
 800fba2:	3a01      	subs	r2, #1
 800fba4:	4013      	ands	r3, r2
 800fba6:	61fb      	str	r3, [r7, #28]
			if (csect == 0) {					/* On the cluster boundary? */
 800fba8:	69fb      	ldr	r3, [r7, #28]
 800fbaa:	2b00      	cmp	r3, #0
 800fbac:	d12f      	bne.n	800fc0e <f_read+0x10a>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800fbae:	68fb      	ldr	r3, [r7, #12]
 800fbb0:	699b      	ldr	r3, [r3, #24]
 800fbb2:	2b00      	cmp	r3, #0
 800fbb4:	d103      	bne.n	800fbbe <f_read+0xba>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800fbb6:	68fb      	ldr	r3, [r7, #12]
 800fbb8:	689b      	ldr	r3, [r3, #8]
 800fbba:	633b      	str	r3, [r7, #48]	@ 0x30
 800fbbc:	e013      	b.n	800fbe6 <f_read+0xe2>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 800fbbe:	68fb      	ldr	r3, [r7, #12]
 800fbc0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800fbc2:	2b00      	cmp	r3, #0
 800fbc4:	d007      	beq.n	800fbd6 <f_read+0xd2>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 800fbc6:	68fb      	ldr	r3, [r7, #12]
 800fbc8:	699b      	ldr	r3, [r3, #24]
 800fbca:	4619      	mov	r1, r3
 800fbcc:	68f8      	ldr	r0, [r7, #12]
 800fbce:	f7fe fe12 	bl	800e7f6 <clmt_clust>
 800fbd2:	6338      	str	r0, [r7, #48]	@ 0x30
 800fbd4:	e007      	b.n	800fbe6 <f_read+0xe2>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800fbd6:	68fa      	ldr	r2, [r7, #12]
 800fbd8:	68fb      	ldr	r3, [r7, #12]
 800fbda:	69db      	ldr	r3, [r3, #28]
 800fbdc:	4619      	mov	r1, r3
 800fbde:	4610      	mov	r0, r2
 800fbe0:	f7fe fb1f 	bl	800e222 <get_fat>
 800fbe4:	6338      	str	r0, [r7, #48]	@ 0x30
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800fbe6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fbe8:	2b01      	cmp	r3, #1
 800fbea:	d804      	bhi.n	800fbf6 <f_read+0xf2>
 800fbec:	68fb      	ldr	r3, [r7, #12]
 800fbee:	2202      	movs	r2, #2
 800fbf0:	755a      	strb	r2, [r3, #21]
 800fbf2:	2302      	movs	r3, #2
 800fbf4:	e0e1      	b.n	800fdba <f_read+0x2b6>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800fbf6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fbf8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fbfc:	d104      	bne.n	800fc08 <f_read+0x104>
 800fbfe:	68fb      	ldr	r3, [r7, #12]
 800fc00:	2201      	movs	r2, #1
 800fc02:	755a      	strb	r2, [r3, #21]
 800fc04:	2301      	movs	r3, #1
 800fc06:	e0d8      	b.n	800fdba <f_read+0x2b6>
				fp->clust = clst;				/* Update current cluster */
 800fc08:	68fb      	ldr	r3, [r7, #12]
 800fc0a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800fc0c:	61da      	str	r2, [r3, #28]
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 800fc0e:	697a      	ldr	r2, [r7, #20]
 800fc10:	68fb      	ldr	r3, [r7, #12]
 800fc12:	69db      	ldr	r3, [r3, #28]
 800fc14:	4619      	mov	r1, r3
 800fc16:	4610      	mov	r0, r2
 800fc18:	f7fe fae4 	bl	800e1e4 <clust2sect>
 800fc1c:	61b8      	str	r0, [r7, #24]
			if (!sect) ABORT(fs, FR_INT_ERR);
 800fc1e:	69bb      	ldr	r3, [r7, #24]
 800fc20:	2b00      	cmp	r3, #0
 800fc22:	d104      	bne.n	800fc2e <f_read+0x12a>
 800fc24:	68fb      	ldr	r3, [r7, #12]
 800fc26:	2202      	movs	r2, #2
 800fc28:	755a      	strb	r2, [r3, #21]
 800fc2a:	2302      	movs	r3, #2
 800fc2c:	e0c5      	b.n	800fdba <f_read+0x2b6>
			sect += csect;
 800fc2e:	69ba      	ldr	r2, [r7, #24]
 800fc30:	69fb      	ldr	r3, [r7, #28]
 800fc32:	4413      	add	r3, r2
 800fc34:	61bb      	str	r3, [r7, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800fc36:	697b      	ldr	r3, [r7, #20]
 800fc38:	899b      	ldrh	r3, [r3, #12]
 800fc3a:	461a      	mov	r2, r3
 800fc3c:	687b      	ldr	r3, [r7, #4]
 800fc3e:	fbb3 f3f2 	udiv	r3, r3, r2
 800fc42:	62bb      	str	r3, [r7, #40]	@ 0x28
			if (cc) {							/* Read maximum contiguous sectors directly */
 800fc44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc46:	2b00      	cmp	r3, #0
 800fc48:	d041      	beq.n	800fcce <f_read+0x1ca>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800fc4a:	69fa      	ldr	r2, [r7, #28]
 800fc4c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc4e:	4413      	add	r3, r2
 800fc50:	697a      	ldr	r2, [r7, #20]
 800fc52:	8952      	ldrh	r2, [r2, #10]
 800fc54:	4293      	cmp	r3, r2
 800fc56:	d905      	bls.n	800fc64 <f_read+0x160>
					cc = fs->csize - csect;
 800fc58:	697b      	ldr	r3, [r7, #20]
 800fc5a:	895b      	ldrh	r3, [r3, #10]
 800fc5c:	461a      	mov	r2, r3
 800fc5e:	69fb      	ldr	r3, [r7, #28]
 800fc60:	1ad3      	subs	r3, r2, r3
 800fc62:	62bb      	str	r3, [r7, #40]	@ 0x28
				}
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800fc64:	697b      	ldr	r3, [r7, #20]
 800fc66:	7858      	ldrb	r0, [r3, #1]
 800fc68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc6a:	69ba      	ldr	r2, [r7, #24]
 800fc6c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800fc6e:	f7fd ff0d 	bl	800da8c <disk_read>
 800fc72:	4603      	mov	r3, r0
 800fc74:	2b00      	cmp	r3, #0
 800fc76:	d004      	beq.n	800fc82 <f_read+0x17e>
 800fc78:	68fb      	ldr	r3, [r7, #12]
 800fc7a:	2201      	movs	r2, #1
 800fc7c:	755a      	strb	r2, [r3, #21]
 800fc7e:	2301      	movs	r3, #1
 800fc80:	e09b      	b.n	800fdba <f_read+0x2b6>
#if _FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800fc82:	68fb      	ldr	r3, [r7, #12]
 800fc84:	7d1b      	ldrb	r3, [r3, #20]
 800fc86:	b25b      	sxtb	r3, r3
 800fc88:	2b00      	cmp	r3, #0
 800fc8a:	da18      	bge.n	800fcbe <f_read+0x1ba>
 800fc8c:	68fb      	ldr	r3, [r7, #12]
 800fc8e:	6a1a      	ldr	r2, [r3, #32]
 800fc90:	69bb      	ldr	r3, [r7, #24]
 800fc92:	1ad3      	subs	r3, r2, r3
 800fc94:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800fc96:	429a      	cmp	r2, r3
 800fc98:	d911      	bls.n	800fcbe <f_read+0x1ba>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 800fc9a:	68fb      	ldr	r3, [r7, #12]
 800fc9c:	6a1a      	ldr	r2, [r3, #32]
 800fc9e:	69bb      	ldr	r3, [r7, #24]
 800fca0:	1ad3      	subs	r3, r2, r3
 800fca2:	697a      	ldr	r2, [r7, #20]
 800fca4:	8992      	ldrh	r2, [r2, #12]
 800fca6:	fb02 f303 	mul.w	r3, r2, r3
 800fcaa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800fcac:	18d0      	adds	r0, r2, r3
 800fcae:	68fb      	ldr	r3, [r7, #12]
 800fcb0:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800fcb4:	697b      	ldr	r3, [r7, #20]
 800fcb6:	899b      	ldrh	r3, [r3, #12]
 800fcb8:	461a      	mov	r2, r3
 800fcba:	f7fd ffc7 	bl	800dc4c <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800fcbe:	697b      	ldr	r3, [r7, #20]
 800fcc0:	899b      	ldrh	r3, [r3, #12]
 800fcc2:	461a      	mov	r2, r3
 800fcc4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fcc6:	fb02 f303 	mul.w	r3, r2, r3
 800fcca:	62fb      	str	r3, [r7, #44]	@ 0x2c
				continue;
 800fccc:	e05c      	b.n	800fd88 <f_read+0x284>
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 800fcce:	68fb      	ldr	r3, [r7, #12]
 800fcd0:	6a1b      	ldr	r3, [r3, #32]
 800fcd2:	69ba      	ldr	r2, [r7, #24]
 800fcd4:	429a      	cmp	r2, r3
 800fcd6:	d02e      	beq.n	800fd36 <f_read+0x232>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 800fcd8:	68fb      	ldr	r3, [r7, #12]
 800fcda:	7d1b      	ldrb	r3, [r3, #20]
 800fcdc:	b25b      	sxtb	r3, r3
 800fcde:	2b00      	cmp	r3, #0
 800fce0:	da18      	bge.n	800fd14 <f_read+0x210>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800fce2:	697b      	ldr	r3, [r7, #20]
 800fce4:	7858      	ldrb	r0, [r3, #1]
 800fce6:	68fb      	ldr	r3, [r7, #12]
 800fce8:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800fcec:	68fb      	ldr	r3, [r7, #12]
 800fcee:	6a1a      	ldr	r2, [r3, #32]
 800fcf0:	2301      	movs	r3, #1
 800fcf2:	f7fd feeb 	bl	800dacc <disk_write>
 800fcf6:	4603      	mov	r3, r0
 800fcf8:	2b00      	cmp	r3, #0
 800fcfa:	d004      	beq.n	800fd06 <f_read+0x202>
 800fcfc:	68fb      	ldr	r3, [r7, #12]
 800fcfe:	2201      	movs	r2, #1
 800fd00:	755a      	strb	r2, [r3, #21]
 800fd02:	2301      	movs	r3, #1
 800fd04:	e059      	b.n	800fdba <f_read+0x2b6>
					fp->flag &= (BYTE)~FA_DIRTY;
 800fd06:	68fb      	ldr	r3, [r7, #12]
 800fd08:	7d1b      	ldrb	r3, [r3, #20]
 800fd0a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800fd0e:	b2da      	uxtb	r2, r3
 800fd10:	68fb      	ldr	r3, [r7, #12]
 800fd12:	751a      	strb	r2, [r3, #20]
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800fd14:	697b      	ldr	r3, [r7, #20]
 800fd16:	7858      	ldrb	r0, [r3, #1]
 800fd18:	68fb      	ldr	r3, [r7, #12]
 800fd1a:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800fd1e:	2301      	movs	r3, #1
 800fd20:	69ba      	ldr	r2, [r7, #24]
 800fd22:	f7fd feb3 	bl	800da8c <disk_read>
 800fd26:	4603      	mov	r3, r0
 800fd28:	2b00      	cmp	r3, #0
 800fd2a:	d004      	beq.n	800fd36 <f_read+0x232>
 800fd2c:	68fb      	ldr	r3, [r7, #12]
 800fd2e:	2201      	movs	r2, #1
 800fd30:	755a      	strb	r2, [r3, #21]
 800fd32:	2301      	movs	r3, #1
 800fd34:	e041      	b.n	800fdba <f_read+0x2b6>
			}
#endif
			fp->sect = sect;
 800fd36:	68fb      	ldr	r3, [r7, #12]
 800fd38:	69ba      	ldr	r2, [r7, #24]
 800fd3a:	621a      	str	r2, [r3, #32]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800fd3c:	697b      	ldr	r3, [r7, #20]
 800fd3e:	899b      	ldrh	r3, [r3, #12]
 800fd40:	4618      	mov	r0, r3
 800fd42:	68fb      	ldr	r3, [r7, #12]
 800fd44:	699b      	ldr	r3, [r3, #24]
 800fd46:	697a      	ldr	r2, [r7, #20]
 800fd48:	8992      	ldrh	r2, [r2, #12]
 800fd4a:	fbb3 f1f2 	udiv	r1, r3, r2
 800fd4e:	fb01 f202 	mul.w	r2, r1, r2
 800fd52:	1a9b      	subs	r3, r3, r2
 800fd54:	1ac3      	subs	r3, r0, r3
 800fd56:	62fb      	str	r3, [r7, #44]	@ 0x2c
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 800fd58:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800fd5a:	687b      	ldr	r3, [r7, #4]
 800fd5c:	429a      	cmp	r2, r3
 800fd5e:	d901      	bls.n	800fd64 <f_read+0x260>
 800fd60:	687b      	ldr	r3, [r7, #4]
 800fd62:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800fd64:	68fb      	ldr	r3, [r7, #12]
 800fd66:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800fd6a:	68fb      	ldr	r3, [r7, #12]
 800fd6c:	699b      	ldr	r3, [r3, #24]
 800fd6e:	697a      	ldr	r2, [r7, #20]
 800fd70:	8992      	ldrh	r2, [r2, #12]
 800fd72:	fbb3 f0f2 	udiv	r0, r3, r2
 800fd76:	fb00 f202 	mul.w	r2, r0, r2
 800fd7a:	1a9b      	subs	r3, r3, r2
 800fd7c:	440b      	add	r3, r1
 800fd7e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800fd80:	4619      	mov	r1, r3
 800fd82:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800fd84:	f7fd ff62 	bl	800dc4c <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800fd88:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800fd8a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fd8c:	4413      	add	r3, r2
 800fd8e:	627b      	str	r3, [r7, #36]	@ 0x24
 800fd90:	68fb      	ldr	r3, [r7, #12]
 800fd92:	699a      	ldr	r2, [r3, #24]
 800fd94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fd96:	441a      	add	r2, r3
 800fd98:	68fb      	ldr	r3, [r7, #12]
 800fd9a:	619a      	str	r2, [r3, #24]
 800fd9c:	683b      	ldr	r3, [r7, #0]
 800fd9e:	681a      	ldr	r2, [r3, #0]
 800fda0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fda2:	441a      	add	r2, r3
 800fda4:	683b      	ldr	r3, [r7, #0]
 800fda6:	601a      	str	r2, [r3, #0]
 800fda8:	687a      	ldr	r2, [r7, #4]
 800fdaa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fdac:	1ad3      	subs	r3, r2, r3
 800fdae:	607b      	str	r3, [r7, #4]
	for ( ;  btr;								/* Repeat until all data read */
 800fdb0:	687b      	ldr	r3, [r7, #4]
 800fdb2:	2b00      	cmp	r3, #0
 800fdb4:	f47f aee1 	bne.w	800fb7a <f_read+0x76>
#endif
	}

	LEAVE_FF(fs, FR_OK);
 800fdb8:	2300      	movs	r3, #0
}
 800fdba:	4618      	mov	r0, r3
 800fdbc:	3738      	adds	r7, #56	@ 0x38
 800fdbe:	46bd      	mov	sp, r7
 800fdc0:	bd80      	pop	{r7, pc}

0800fdc2 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 800fdc2:	b580      	push	{r7, lr}
 800fdc4:	b08c      	sub	sp, #48	@ 0x30
 800fdc6:	af00      	add	r7, sp, #0
 800fdc8:	60f8      	str	r0, [r7, #12]
 800fdca:	60b9      	str	r1, [r7, #8]
 800fdcc:	607a      	str	r2, [r7, #4]
 800fdce:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;
 800fdd0:	68bb      	ldr	r3, [r7, #8]
 800fdd2:	61fb      	str	r3, [r7, #28]


	*bw = 0;	/* Clear write byte counter */
 800fdd4:	683b      	ldr	r3, [r7, #0]
 800fdd6:	2200      	movs	r2, #0
 800fdd8:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800fdda:	68fb      	ldr	r3, [r7, #12]
 800fddc:	f107 0210 	add.w	r2, r7, #16
 800fde0:	4611      	mov	r1, r2
 800fde2:	4618      	mov	r0, r3
 800fde4:	f7ff fc4a 	bl	800f67c <validate>
 800fde8:	4603      	mov	r3, r0
 800fdea:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800fdee:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800fdf2:	2b00      	cmp	r3, #0
 800fdf4:	d107      	bne.n	800fe06 <f_write+0x44>
 800fdf6:	68fb      	ldr	r3, [r7, #12]
 800fdf8:	7d5b      	ldrb	r3, [r3, #21]
 800fdfa:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 800fdfe:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800fe02:	2b00      	cmp	r3, #0
 800fe04:	d002      	beq.n	800fe0c <f_write+0x4a>
 800fe06:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800fe0a:	e16a      	b.n	80100e2 <f_write+0x320>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 800fe0c:	68fb      	ldr	r3, [r7, #12]
 800fe0e:	7d1b      	ldrb	r3, [r3, #20]
 800fe10:	f003 0302 	and.w	r3, r3, #2
 800fe14:	2b00      	cmp	r3, #0
 800fe16:	d101      	bne.n	800fe1c <f_write+0x5a>
 800fe18:	2307      	movs	r3, #7
 800fe1a:	e162      	b.n	80100e2 <f_write+0x320>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 800fe1c:	68fb      	ldr	r3, [r7, #12]
 800fe1e:	699a      	ldr	r2, [r3, #24]
 800fe20:	687b      	ldr	r3, [r7, #4]
 800fe22:	441a      	add	r2, r3
 800fe24:	68fb      	ldr	r3, [r7, #12]
 800fe26:	699b      	ldr	r3, [r3, #24]
 800fe28:	429a      	cmp	r2, r3
 800fe2a:	f080 814c 	bcs.w	80100c6 <f_write+0x304>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 800fe2e:	68fb      	ldr	r3, [r7, #12]
 800fe30:	699b      	ldr	r3, [r3, #24]
 800fe32:	43db      	mvns	r3, r3
 800fe34:	607b      	str	r3, [r7, #4]
	}

	for ( ;  btw;							/* Repeat until all data written */
 800fe36:	e146      	b.n	80100c6 <f_write+0x304>
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 800fe38:	68fb      	ldr	r3, [r7, #12]
 800fe3a:	699b      	ldr	r3, [r3, #24]
 800fe3c:	693a      	ldr	r2, [r7, #16]
 800fe3e:	8992      	ldrh	r2, [r2, #12]
 800fe40:	fbb3 f1f2 	udiv	r1, r3, r2
 800fe44:	fb01 f202 	mul.w	r2, r1, r2
 800fe48:	1a9b      	subs	r3, r3, r2
 800fe4a:	2b00      	cmp	r3, #0
 800fe4c:	f040 80f1 	bne.w	8010032 <f_write+0x270>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 800fe50:	68fb      	ldr	r3, [r7, #12]
 800fe52:	699b      	ldr	r3, [r3, #24]
 800fe54:	693a      	ldr	r2, [r7, #16]
 800fe56:	8992      	ldrh	r2, [r2, #12]
 800fe58:	fbb3 f3f2 	udiv	r3, r3, r2
 800fe5c:	693a      	ldr	r2, [r7, #16]
 800fe5e:	8952      	ldrh	r2, [r2, #10]
 800fe60:	3a01      	subs	r2, #1
 800fe62:	4013      	ands	r3, r2
 800fe64:	61bb      	str	r3, [r7, #24]
			if (csect == 0) {				/* On the cluster boundary? */
 800fe66:	69bb      	ldr	r3, [r7, #24]
 800fe68:	2b00      	cmp	r3, #0
 800fe6a:	d143      	bne.n	800fef4 <f_write+0x132>
				if (fp->fptr == 0) {		/* On the top of the file? */
 800fe6c:	68fb      	ldr	r3, [r7, #12]
 800fe6e:	699b      	ldr	r3, [r3, #24]
 800fe70:	2b00      	cmp	r3, #0
 800fe72:	d10c      	bne.n	800fe8e <f_write+0xcc>
					clst = fp->obj.sclust;	/* Follow from the origin */
 800fe74:	68fb      	ldr	r3, [r7, #12]
 800fe76:	689b      	ldr	r3, [r3, #8]
 800fe78:	62bb      	str	r3, [r7, #40]	@ 0x28
					if (clst == 0) {		/* If no cluster is allocated, */
 800fe7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fe7c:	2b00      	cmp	r3, #0
 800fe7e:	d11a      	bne.n	800feb6 <f_write+0xf4>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 800fe80:	68fb      	ldr	r3, [r7, #12]
 800fe82:	2100      	movs	r1, #0
 800fe84:	4618      	mov	r0, r3
 800fe86:	f7fe fc1e 	bl	800e6c6 <create_chain>
 800fe8a:	62b8      	str	r0, [r7, #40]	@ 0x28
 800fe8c:	e013      	b.n	800feb6 <f_write+0xf4>
					}
				} else {					/* On the middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 800fe8e:	68fb      	ldr	r3, [r7, #12]
 800fe90:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800fe92:	2b00      	cmp	r3, #0
 800fe94:	d007      	beq.n	800fea6 <f_write+0xe4>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 800fe96:	68fb      	ldr	r3, [r7, #12]
 800fe98:	699b      	ldr	r3, [r3, #24]
 800fe9a:	4619      	mov	r1, r3
 800fe9c:	68f8      	ldr	r0, [r7, #12]
 800fe9e:	f7fe fcaa 	bl	800e7f6 <clmt_clust>
 800fea2:	62b8      	str	r0, [r7, #40]	@ 0x28
 800fea4:	e007      	b.n	800feb6 <f_write+0xf4>
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800fea6:	68fa      	ldr	r2, [r7, #12]
 800fea8:	68fb      	ldr	r3, [r7, #12]
 800feaa:	69db      	ldr	r3, [r3, #28]
 800feac:	4619      	mov	r1, r3
 800feae:	4610      	mov	r0, r2
 800feb0:	f7fe fc09 	bl	800e6c6 <create_chain>
 800feb4:	62b8      	str	r0, [r7, #40]	@ 0x28
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800feb6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800feb8:	2b00      	cmp	r3, #0
 800feba:	f000 8109 	beq.w	80100d0 <f_write+0x30e>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 800febe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fec0:	2b01      	cmp	r3, #1
 800fec2:	d104      	bne.n	800fece <f_write+0x10c>
 800fec4:	68fb      	ldr	r3, [r7, #12]
 800fec6:	2202      	movs	r2, #2
 800fec8:	755a      	strb	r2, [r3, #21]
 800feca:	2302      	movs	r3, #2
 800fecc:	e109      	b.n	80100e2 <f_write+0x320>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800fece:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fed0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fed4:	d104      	bne.n	800fee0 <f_write+0x11e>
 800fed6:	68fb      	ldr	r3, [r7, #12]
 800fed8:	2201      	movs	r2, #1
 800feda:	755a      	strb	r2, [r3, #21]
 800fedc:	2301      	movs	r3, #1
 800fede:	e100      	b.n	80100e2 <f_write+0x320>
				fp->clust = clst;			/* Update current cluster */
 800fee0:	68fb      	ldr	r3, [r7, #12]
 800fee2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800fee4:	61da      	str	r2, [r3, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 800fee6:	68fb      	ldr	r3, [r7, #12]
 800fee8:	689b      	ldr	r3, [r3, #8]
 800feea:	2b00      	cmp	r3, #0
 800feec:	d102      	bne.n	800fef4 <f_write+0x132>
 800feee:	68fb      	ldr	r3, [r7, #12]
 800fef0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800fef2:	609a      	str	r2, [r3, #8]
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800fef4:	68fb      	ldr	r3, [r7, #12]
 800fef6:	7d1b      	ldrb	r3, [r3, #20]
 800fef8:	b25b      	sxtb	r3, r3
 800fefa:	2b00      	cmp	r3, #0
 800fefc:	da18      	bge.n	800ff30 <f_write+0x16e>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800fefe:	693b      	ldr	r3, [r7, #16]
 800ff00:	7858      	ldrb	r0, [r3, #1]
 800ff02:	68fb      	ldr	r3, [r7, #12]
 800ff04:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 800ff08:	68fb      	ldr	r3, [r7, #12]
 800ff0a:	6a1a      	ldr	r2, [r3, #32]
 800ff0c:	2301      	movs	r3, #1
 800ff0e:	f7fd fddd 	bl	800dacc <disk_write>
 800ff12:	4603      	mov	r3, r0
 800ff14:	2b00      	cmp	r3, #0
 800ff16:	d004      	beq.n	800ff22 <f_write+0x160>
 800ff18:	68fb      	ldr	r3, [r7, #12]
 800ff1a:	2201      	movs	r2, #1
 800ff1c:	755a      	strb	r2, [r3, #21]
 800ff1e:	2301      	movs	r3, #1
 800ff20:	e0df      	b.n	80100e2 <f_write+0x320>
				fp->flag &= (BYTE)~FA_DIRTY;
 800ff22:	68fb      	ldr	r3, [r7, #12]
 800ff24:	7d1b      	ldrb	r3, [r3, #20]
 800ff26:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ff2a:	b2da      	uxtb	r2, r3
 800ff2c:	68fb      	ldr	r3, [r7, #12]
 800ff2e:	751a      	strb	r2, [r3, #20]
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 800ff30:	693a      	ldr	r2, [r7, #16]
 800ff32:	68fb      	ldr	r3, [r7, #12]
 800ff34:	69db      	ldr	r3, [r3, #28]
 800ff36:	4619      	mov	r1, r3
 800ff38:	4610      	mov	r0, r2
 800ff3a:	f7fe f953 	bl	800e1e4 <clust2sect>
 800ff3e:	6178      	str	r0, [r7, #20]
			if (!sect) ABORT(fs, FR_INT_ERR);
 800ff40:	697b      	ldr	r3, [r7, #20]
 800ff42:	2b00      	cmp	r3, #0
 800ff44:	d104      	bne.n	800ff50 <f_write+0x18e>
 800ff46:	68fb      	ldr	r3, [r7, #12]
 800ff48:	2202      	movs	r2, #2
 800ff4a:	755a      	strb	r2, [r3, #21]
 800ff4c:	2302      	movs	r3, #2
 800ff4e:	e0c8      	b.n	80100e2 <f_write+0x320>
			sect += csect;
 800ff50:	697a      	ldr	r2, [r7, #20]
 800ff52:	69bb      	ldr	r3, [r7, #24]
 800ff54:	4413      	add	r3, r2
 800ff56:	617b      	str	r3, [r7, #20]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 800ff58:	693b      	ldr	r3, [r7, #16]
 800ff5a:	899b      	ldrh	r3, [r3, #12]
 800ff5c:	461a      	mov	r2, r3
 800ff5e:	687b      	ldr	r3, [r7, #4]
 800ff60:	fbb3 f3f2 	udiv	r3, r3, r2
 800ff64:	623b      	str	r3, [r7, #32]
			if (cc) {						/* Write maximum contiguous sectors directly */
 800ff66:	6a3b      	ldr	r3, [r7, #32]
 800ff68:	2b00      	cmp	r3, #0
 800ff6a:	d043      	beq.n	800fff4 <f_write+0x232>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800ff6c:	69ba      	ldr	r2, [r7, #24]
 800ff6e:	6a3b      	ldr	r3, [r7, #32]
 800ff70:	4413      	add	r3, r2
 800ff72:	693a      	ldr	r2, [r7, #16]
 800ff74:	8952      	ldrh	r2, [r2, #10]
 800ff76:	4293      	cmp	r3, r2
 800ff78:	d905      	bls.n	800ff86 <f_write+0x1c4>
					cc = fs->csize - csect;
 800ff7a:	693b      	ldr	r3, [r7, #16]
 800ff7c:	895b      	ldrh	r3, [r3, #10]
 800ff7e:	461a      	mov	r2, r3
 800ff80:	69bb      	ldr	r3, [r7, #24]
 800ff82:	1ad3      	subs	r3, r2, r3
 800ff84:	623b      	str	r3, [r7, #32]
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800ff86:	693b      	ldr	r3, [r7, #16]
 800ff88:	7858      	ldrb	r0, [r3, #1]
 800ff8a:	6a3b      	ldr	r3, [r7, #32]
 800ff8c:	697a      	ldr	r2, [r7, #20]
 800ff8e:	69f9      	ldr	r1, [r7, #28]
 800ff90:	f7fd fd9c 	bl	800dacc <disk_write>
 800ff94:	4603      	mov	r3, r0
 800ff96:	2b00      	cmp	r3, #0
 800ff98:	d004      	beq.n	800ffa4 <f_write+0x1e2>
 800ff9a:	68fb      	ldr	r3, [r7, #12]
 800ff9c:	2201      	movs	r2, #1
 800ff9e:	755a      	strb	r2, [r3, #21]
 800ffa0:	2301      	movs	r3, #1
 800ffa2:	e09e      	b.n	80100e2 <f_write+0x320>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 800ffa4:	68fb      	ldr	r3, [r7, #12]
 800ffa6:	6a1a      	ldr	r2, [r3, #32]
 800ffa8:	697b      	ldr	r3, [r7, #20]
 800ffaa:	1ad3      	subs	r3, r2, r3
 800ffac:	6a3a      	ldr	r2, [r7, #32]
 800ffae:	429a      	cmp	r2, r3
 800ffb0:	d918      	bls.n	800ffe4 <f_write+0x222>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 800ffb2:	68fb      	ldr	r3, [r7, #12]
 800ffb4:	f103 0030 	add.w	r0, r3, #48	@ 0x30
 800ffb8:	68fb      	ldr	r3, [r7, #12]
 800ffba:	6a1a      	ldr	r2, [r3, #32]
 800ffbc:	697b      	ldr	r3, [r7, #20]
 800ffbe:	1ad3      	subs	r3, r2, r3
 800ffc0:	693a      	ldr	r2, [r7, #16]
 800ffc2:	8992      	ldrh	r2, [r2, #12]
 800ffc4:	fb02 f303 	mul.w	r3, r2, r3
 800ffc8:	69fa      	ldr	r2, [r7, #28]
 800ffca:	18d1      	adds	r1, r2, r3
 800ffcc:	693b      	ldr	r3, [r7, #16]
 800ffce:	899b      	ldrh	r3, [r3, #12]
 800ffd0:	461a      	mov	r2, r3
 800ffd2:	f7fd fe3b 	bl	800dc4c <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 800ffd6:	68fb      	ldr	r3, [r7, #12]
 800ffd8:	7d1b      	ldrb	r3, [r3, #20]
 800ffda:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ffde:	b2da      	uxtb	r2, r3
 800ffe0:	68fb      	ldr	r3, [r7, #12]
 800ffe2:	751a      	strb	r2, [r3, #20]
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 800ffe4:	693b      	ldr	r3, [r7, #16]
 800ffe6:	899b      	ldrh	r3, [r3, #12]
 800ffe8:	461a      	mov	r2, r3
 800ffea:	6a3b      	ldr	r3, [r7, #32]
 800ffec:	fb02 f303 	mul.w	r3, r2, r3
 800fff0:	627b      	str	r3, [r7, #36]	@ 0x24
				continue;
 800fff2:	e04b      	b.n	801008c <f_write+0x2ca>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 800fff4:	68fb      	ldr	r3, [r7, #12]
 800fff6:	6a1b      	ldr	r3, [r3, #32]
 800fff8:	697a      	ldr	r2, [r7, #20]
 800fffa:	429a      	cmp	r2, r3
 800fffc:	d016      	beq.n	801002c <f_write+0x26a>
				fp->fptr < fp->obj.objsize &&
 800fffe:	68fb      	ldr	r3, [r7, #12]
 8010000:	699a      	ldr	r2, [r3, #24]
 8010002:	68fb      	ldr	r3, [r7, #12]
 8010004:	68db      	ldr	r3, [r3, #12]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8010006:	429a      	cmp	r2, r3
 8010008:	d210      	bcs.n	801002c <f_write+0x26a>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 801000a:	693b      	ldr	r3, [r7, #16]
 801000c:	7858      	ldrb	r0, [r3, #1]
 801000e:	68fb      	ldr	r3, [r7, #12]
 8010010:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8010014:	2301      	movs	r3, #1
 8010016:	697a      	ldr	r2, [r7, #20]
 8010018:	f7fd fd38 	bl	800da8c <disk_read>
 801001c:	4603      	mov	r3, r0
				fp->fptr < fp->obj.objsize &&
 801001e:	2b00      	cmp	r3, #0
 8010020:	d004      	beq.n	801002c <f_write+0x26a>
					ABORT(fs, FR_DISK_ERR);
 8010022:	68fb      	ldr	r3, [r7, #12]
 8010024:	2201      	movs	r2, #1
 8010026:	755a      	strb	r2, [r3, #21]
 8010028:	2301      	movs	r3, #1
 801002a:	e05a      	b.n	80100e2 <f_write+0x320>
			}
#endif
			fp->sect = sect;
 801002c:	68fb      	ldr	r3, [r7, #12]
 801002e:	697a      	ldr	r2, [r7, #20]
 8010030:	621a      	str	r2, [r3, #32]
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8010032:	693b      	ldr	r3, [r7, #16]
 8010034:	899b      	ldrh	r3, [r3, #12]
 8010036:	4618      	mov	r0, r3
 8010038:	68fb      	ldr	r3, [r7, #12]
 801003a:	699b      	ldr	r3, [r3, #24]
 801003c:	693a      	ldr	r2, [r7, #16]
 801003e:	8992      	ldrh	r2, [r2, #12]
 8010040:	fbb3 f1f2 	udiv	r1, r3, r2
 8010044:	fb01 f202 	mul.w	r2, r1, r2
 8010048:	1a9b      	subs	r3, r3, r2
 801004a:	1ac3      	subs	r3, r0, r3
 801004c:	627b      	str	r3, [r7, #36]	@ 0x24
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 801004e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010050:	687b      	ldr	r3, [r7, #4]
 8010052:	429a      	cmp	r2, r3
 8010054:	d901      	bls.n	801005a <f_write+0x298>
 8010056:	687b      	ldr	r3, [r7, #4]
 8010058:	627b      	str	r3, [r7, #36]	@ 0x24
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 801005a:	68fb      	ldr	r3, [r7, #12]
 801005c:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8010060:	68fb      	ldr	r3, [r7, #12]
 8010062:	699b      	ldr	r3, [r3, #24]
 8010064:	693a      	ldr	r2, [r7, #16]
 8010066:	8992      	ldrh	r2, [r2, #12]
 8010068:	fbb3 f0f2 	udiv	r0, r3, r2
 801006c:	fb00 f202 	mul.w	r2, r0, r2
 8010070:	1a9b      	subs	r3, r3, r2
 8010072:	440b      	add	r3, r1
 8010074:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010076:	69f9      	ldr	r1, [r7, #28]
 8010078:	4618      	mov	r0, r3
 801007a:	f7fd fde7 	bl	800dc4c <mem_cpy>
		fp->flag |= FA_DIRTY;
 801007e:	68fb      	ldr	r3, [r7, #12]
 8010080:	7d1b      	ldrb	r3, [r3, #20]
 8010082:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8010086:	b2da      	uxtb	r2, r3
 8010088:	68fb      	ldr	r3, [r7, #12]
 801008a:	751a      	strb	r2, [r3, #20]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 801008c:	69fa      	ldr	r2, [r7, #28]
 801008e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010090:	4413      	add	r3, r2
 8010092:	61fb      	str	r3, [r7, #28]
 8010094:	68fb      	ldr	r3, [r7, #12]
 8010096:	699a      	ldr	r2, [r3, #24]
 8010098:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801009a:	441a      	add	r2, r3
 801009c:	68fb      	ldr	r3, [r7, #12]
 801009e:	619a      	str	r2, [r3, #24]
 80100a0:	68fb      	ldr	r3, [r7, #12]
 80100a2:	68da      	ldr	r2, [r3, #12]
 80100a4:	68fb      	ldr	r3, [r7, #12]
 80100a6:	699b      	ldr	r3, [r3, #24]
 80100a8:	429a      	cmp	r2, r3
 80100aa:	bf38      	it	cc
 80100ac:	461a      	movcc	r2, r3
 80100ae:	68fb      	ldr	r3, [r7, #12]
 80100b0:	60da      	str	r2, [r3, #12]
 80100b2:	683b      	ldr	r3, [r7, #0]
 80100b4:	681a      	ldr	r2, [r3, #0]
 80100b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80100b8:	441a      	add	r2, r3
 80100ba:	683b      	ldr	r3, [r7, #0]
 80100bc:	601a      	str	r2, [r3, #0]
 80100be:	687a      	ldr	r2, [r7, #4]
 80100c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80100c2:	1ad3      	subs	r3, r2, r3
 80100c4:	607b      	str	r3, [r7, #4]
	for ( ;  btw;							/* Repeat until all data written */
 80100c6:	687b      	ldr	r3, [r7, #4]
 80100c8:	2b00      	cmp	r3, #0
 80100ca:	f47f aeb5 	bne.w	800fe38 <f_write+0x76>
 80100ce:	e000      	b.n	80100d2 <f_write+0x310>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 80100d0:	bf00      	nop
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 80100d2:	68fb      	ldr	r3, [r7, #12]
 80100d4:	7d1b      	ldrb	r3, [r3, #20]
 80100d6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80100da:	b2da      	uxtb	r2, r3
 80100dc:	68fb      	ldr	r3, [r7, #12]
 80100de:	751a      	strb	r2, [r3, #20]

	LEAVE_FF(fs, FR_OK);
 80100e0:	2300      	movs	r3, #0
}
 80100e2:	4618      	mov	r0, r3
 80100e4:	3730      	adds	r7, #48	@ 0x30
 80100e6:	46bd      	mov	sp, r7
 80100e8:	bd80      	pop	{r7, pc}

080100ea <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80100ea:	b580      	push	{r7, lr}
 80100ec:	b086      	sub	sp, #24
 80100ee:	af00      	add	r7, sp, #0
 80100f0:	6078      	str	r0, [r7, #4]
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 80100f2:	687b      	ldr	r3, [r7, #4]
 80100f4:	f107 0208 	add.w	r2, r7, #8
 80100f8:	4611      	mov	r1, r2
 80100fa:	4618      	mov	r0, r3
 80100fc:	f7ff fabe 	bl	800f67c <validate>
 8010100:	4603      	mov	r3, r0
 8010102:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8010104:	7dfb      	ldrb	r3, [r7, #23]
 8010106:	2b00      	cmp	r3, #0
 8010108:	d168      	bne.n	80101dc <f_sync+0xf2>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 801010a:	687b      	ldr	r3, [r7, #4]
 801010c:	7d1b      	ldrb	r3, [r3, #20]
 801010e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8010112:	2b00      	cmp	r3, #0
 8010114:	d062      	beq.n	80101dc <f_sync+0xf2>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8010116:	687b      	ldr	r3, [r7, #4]
 8010118:	7d1b      	ldrb	r3, [r3, #20]
 801011a:	b25b      	sxtb	r3, r3
 801011c:	2b00      	cmp	r3, #0
 801011e:	da15      	bge.n	801014c <f_sync+0x62>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8010120:	68bb      	ldr	r3, [r7, #8]
 8010122:	7858      	ldrb	r0, [r3, #1]
 8010124:	687b      	ldr	r3, [r7, #4]
 8010126:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801012a:	687b      	ldr	r3, [r7, #4]
 801012c:	6a1a      	ldr	r2, [r3, #32]
 801012e:	2301      	movs	r3, #1
 8010130:	f7fd fccc 	bl	800dacc <disk_write>
 8010134:	4603      	mov	r3, r0
 8010136:	2b00      	cmp	r3, #0
 8010138:	d001      	beq.n	801013e <f_sync+0x54>
 801013a:	2301      	movs	r3, #1
 801013c:	e04f      	b.n	80101de <f_sync+0xf4>
				fp->flag &= (BYTE)~FA_DIRTY;
 801013e:	687b      	ldr	r3, [r7, #4]
 8010140:	7d1b      	ldrb	r3, [r3, #20]
 8010142:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8010146:	b2da      	uxtb	r2, r3
 8010148:	687b      	ldr	r3, [r7, #4]
 801014a:	751a      	strb	r2, [r3, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 801014c:	f7fa faba 	bl	800a6c4 <get_fattime>
 8010150:	6138      	str	r0, [r7, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 8010152:	68ba      	ldr	r2, [r7, #8]
 8010154:	687b      	ldr	r3, [r7, #4]
 8010156:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010158:	4619      	mov	r1, r3
 801015a:	4610      	mov	r0, r2
 801015c:	f7fd ffa4 	bl	800e0a8 <move_window>
 8010160:	4603      	mov	r3, r0
 8010162:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) {
 8010164:	7dfb      	ldrb	r3, [r7, #23]
 8010166:	2b00      	cmp	r3, #0
 8010168:	d138      	bne.n	80101dc <f_sync+0xf2>
					dir = fp->dir_ptr;
 801016a:	687b      	ldr	r3, [r7, #4]
 801016c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801016e:	60fb      	str	r3, [r7, #12]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 8010170:	68fb      	ldr	r3, [r7, #12]
 8010172:	330b      	adds	r3, #11
 8010174:	781a      	ldrb	r2, [r3, #0]
 8010176:	68fb      	ldr	r3, [r7, #12]
 8010178:	330b      	adds	r3, #11
 801017a:	f042 0220 	orr.w	r2, r2, #32
 801017e:	b2d2      	uxtb	r2, r2
 8010180:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8010182:	687b      	ldr	r3, [r7, #4]
 8010184:	6818      	ldr	r0, [r3, #0]
 8010186:	687b      	ldr	r3, [r7, #4]
 8010188:	689b      	ldr	r3, [r3, #8]
 801018a:	461a      	mov	r2, r3
 801018c:	68f9      	ldr	r1, [r7, #12]
 801018e:	f7fe fd2f 	bl	800ebf0 <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8010192:	68fb      	ldr	r3, [r7, #12]
 8010194:	f103 021c 	add.w	r2, r3, #28
 8010198:	687b      	ldr	r3, [r7, #4]
 801019a:	68db      	ldr	r3, [r3, #12]
 801019c:	4619      	mov	r1, r3
 801019e:	4610      	mov	r0, r2
 80101a0:	f7fd fd28 	bl	800dbf4 <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 80101a4:	68fb      	ldr	r3, [r7, #12]
 80101a6:	3316      	adds	r3, #22
 80101a8:	6939      	ldr	r1, [r7, #16]
 80101aa:	4618      	mov	r0, r3
 80101ac:	f7fd fd22 	bl	800dbf4 <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
 80101b0:	68fb      	ldr	r3, [r7, #12]
 80101b2:	3312      	adds	r3, #18
 80101b4:	2100      	movs	r1, #0
 80101b6:	4618      	mov	r0, r3
 80101b8:	f7fd fd01 	bl	800dbbe <st_word>
					fs->wflag = 1;
 80101bc:	68bb      	ldr	r3, [r7, #8]
 80101be:	2201      	movs	r2, #1
 80101c0:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 80101c2:	68bb      	ldr	r3, [r7, #8]
 80101c4:	4618      	mov	r0, r3
 80101c6:	f7fd ff9d 	bl	800e104 <sync_fs>
 80101ca:	4603      	mov	r3, r0
 80101cc:	75fb      	strb	r3, [r7, #23]
					fp->flag &= (BYTE)~FA_MODIFIED;
 80101ce:	687b      	ldr	r3, [r7, #4]
 80101d0:	7d1b      	ldrb	r3, [r3, #20]
 80101d2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80101d6:	b2da      	uxtb	r2, r3
 80101d8:	687b      	ldr	r3, [r7, #4]
 80101da:	751a      	strb	r2, [r3, #20]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 80101dc:	7dfb      	ldrb	r3, [r7, #23]
}
 80101de:	4618      	mov	r0, r3
 80101e0:	3718      	adds	r7, #24
 80101e2:	46bd      	mov	sp, r7
 80101e4:	bd80      	pop	{r7, pc}

080101e6 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 80101e6:	b580      	push	{r7, lr}
 80101e8:	b084      	sub	sp, #16
 80101ea:	af00      	add	r7, sp, #0
 80101ec:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 80101ee:	6878      	ldr	r0, [r7, #4]
 80101f0:	f7ff ff7b 	bl	80100ea <f_sync>
 80101f4:	4603      	mov	r3, r0
 80101f6:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
 80101f8:	7bfb      	ldrb	r3, [r7, #15]
 80101fa:	2b00      	cmp	r3, #0
 80101fc:	d118      	bne.n	8010230 <f_close+0x4a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 80101fe:	687b      	ldr	r3, [r7, #4]
 8010200:	f107 0208 	add.w	r2, r7, #8
 8010204:	4611      	mov	r1, r2
 8010206:	4618      	mov	r0, r3
 8010208:	f7ff fa38 	bl	800f67c <validate>
 801020c:	4603      	mov	r3, r0
 801020e:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 8010210:	7bfb      	ldrb	r3, [r7, #15]
 8010212:	2b00      	cmp	r3, #0
 8010214:	d10c      	bne.n	8010230 <f_close+0x4a>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 8010216:	687b      	ldr	r3, [r7, #4]
 8010218:	691b      	ldr	r3, [r3, #16]
 801021a:	4618      	mov	r0, r3
 801021c:	f7fd fea0 	bl	800df60 <dec_lock>
 8010220:	4603      	mov	r3, r0
 8010222:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK)
 8010224:	7bfb      	ldrb	r3, [r7, #15]
 8010226:	2b00      	cmp	r3, #0
 8010228:	d102      	bne.n	8010230 <f_close+0x4a>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
 801022a:	687b      	ldr	r3, [r7, #4]
 801022c:	2200      	movs	r2, #0
 801022e:	601a      	str	r2, [r3, #0]
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
 8010230:	7bfb      	ldrb	r3, [r7, #15]
}
 8010232:	4618      	mov	r0, r3
 8010234:	3710      	adds	r7, #16
 8010236:	46bd      	mov	sp, r7
 8010238:	bd80      	pop	{r7, pc}

0801023a <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 801023a:	b580      	push	{r7, lr}
 801023c:	b090      	sub	sp, #64	@ 0x40
 801023e:	af00      	add	r7, sp, #0
 8010240:	6078      	str	r0, [r7, #4]
 8010242:	6039      	str	r1, [r7, #0]
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8010244:	687b      	ldr	r3, [r7, #4]
 8010246:	f107 0208 	add.w	r2, r7, #8
 801024a:	4611      	mov	r1, r2
 801024c:	4618      	mov	r0, r3
 801024e:	f7ff fa15 	bl	800f67c <validate>
 8010252:	4603      	mov	r3, r0
 8010254:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
	if (res == FR_OK) res = (FRESULT)fp->err;
 8010258:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801025c:	2b00      	cmp	r3, #0
 801025e:	d103      	bne.n	8010268 <f_lseek+0x2e>
 8010260:	687b      	ldr	r3, [r7, #4]
 8010262:	7d5b      	ldrb	r3, [r3, #21]
 8010264:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 8010268:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801026c:	2b00      	cmp	r3, #0
 801026e:	d002      	beq.n	8010276 <f_lseek+0x3c>
 8010270:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8010274:	e201      	b.n	801067a <f_lseek+0x440>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 8010276:	687b      	ldr	r3, [r7, #4]
 8010278:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801027a:	2b00      	cmp	r3, #0
 801027c:	f000 80d9 	beq.w	8010432 <f_lseek+0x1f8>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8010280:	683b      	ldr	r3, [r7, #0]
 8010282:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010286:	d15a      	bne.n	801033e <f_lseek+0x104>
			tbl = fp->cltbl;
 8010288:	687b      	ldr	r3, [r7, #4]
 801028a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801028c:	627b      	str	r3, [r7, #36]	@ 0x24
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 801028e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010290:	1d1a      	adds	r2, r3, #4
 8010292:	627a      	str	r2, [r7, #36]	@ 0x24
 8010294:	681b      	ldr	r3, [r3, #0]
 8010296:	617b      	str	r3, [r7, #20]
 8010298:	2302      	movs	r3, #2
 801029a:	62bb      	str	r3, [r7, #40]	@ 0x28
			cl = fp->obj.sclust;		/* Origin of the chain */
 801029c:	687b      	ldr	r3, [r7, #4]
 801029e:	689b      	ldr	r3, [r3, #8]
 80102a0:	633b      	str	r3, [r7, #48]	@ 0x30
			if (cl) {
 80102a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102a4:	2b00      	cmp	r3, #0
 80102a6:	d03a      	beq.n	801031e <f_lseek+0xe4>
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 80102a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102aa:	613b      	str	r3, [r7, #16]
 80102ac:	2300      	movs	r3, #0
 80102ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80102b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80102b2:	3302      	adds	r3, #2
 80102b4:	62bb      	str	r3, [r7, #40]	@ 0x28
					do {
						pcl = cl; ncl++;
 80102b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102b8:	60fb      	str	r3, [r7, #12]
 80102ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80102bc:	3301      	adds	r3, #1
 80102be:	62fb      	str	r3, [r7, #44]	@ 0x2c
						cl = get_fat(&fp->obj, cl);
 80102c0:	687b      	ldr	r3, [r7, #4]
 80102c2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80102c4:	4618      	mov	r0, r3
 80102c6:	f7fd ffac 	bl	800e222 <get_fat>
 80102ca:	6338      	str	r0, [r7, #48]	@ 0x30
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 80102cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102ce:	2b01      	cmp	r3, #1
 80102d0:	d804      	bhi.n	80102dc <f_lseek+0xa2>
 80102d2:	687b      	ldr	r3, [r7, #4]
 80102d4:	2202      	movs	r2, #2
 80102d6:	755a      	strb	r2, [r3, #21]
 80102d8:	2302      	movs	r3, #2
 80102da:	e1ce      	b.n	801067a <f_lseek+0x440>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80102dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102de:	f1b3 3fff 	cmp.w	r3, #4294967295
 80102e2:	d104      	bne.n	80102ee <f_lseek+0xb4>
 80102e4:	687b      	ldr	r3, [r7, #4]
 80102e6:	2201      	movs	r2, #1
 80102e8:	755a      	strb	r2, [r3, #21]
 80102ea:	2301      	movs	r3, #1
 80102ec:	e1c5      	b.n	801067a <f_lseek+0x440>
					} while (cl == pcl + 1);
 80102ee:	68fb      	ldr	r3, [r7, #12]
 80102f0:	3301      	adds	r3, #1
 80102f2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80102f4:	429a      	cmp	r2, r3
 80102f6:	d0de      	beq.n	80102b6 <f_lseek+0x7c>
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 80102f8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80102fa:	697b      	ldr	r3, [r7, #20]
 80102fc:	429a      	cmp	r2, r3
 80102fe:	d809      	bhi.n	8010314 <f_lseek+0xda>
						*tbl++ = ncl; *tbl++ = tcl;
 8010300:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010302:	1d1a      	adds	r2, r3, #4
 8010304:	627a      	str	r2, [r7, #36]	@ 0x24
 8010306:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010308:	601a      	str	r2, [r3, #0]
 801030a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801030c:	1d1a      	adds	r2, r3, #4
 801030e:	627a      	str	r2, [r7, #36]	@ 0x24
 8010310:	693a      	ldr	r2, [r7, #16]
 8010312:	601a      	str	r2, [r3, #0]
					}
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8010314:	68bb      	ldr	r3, [r7, #8]
 8010316:	699b      	ldr	r3, [r3, #24]
 8010318:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801031a:	429a      	cmp	r2, r3
 801031c:	d3c4      	bcc.n	80102a8 <f_lseek+0x6e>
			}
			*fp->cltbl = ulen;	/* Number of items used */
 801031e:	687b      	ldr	r3, [r7, #4]
 8010320:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8010322:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010324:	601a      	str	r2, [r3, #0]
			if (ulen <= tlen) {
 8010326:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010328:	697b      	ldr	r3, [r7, #20]
 801032a:	429a      	cmp	r2, r3
 801032c:	d803      	bhi.n	8010336 <f_lseek+0xfc>
				*tbl = 0;		/* Terminate table */
 801032e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010330:	2200      	movs	r2, #0
 8010332:	601a      	str	r2, [r3, #0]
 8010334:	e19f      	b.n	8010676 <f_lseek+0x43c>
			} else {
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8010336:	2311      	movs	r3, #17
 8010338:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 801033c:	e19b      	b.n	8010676 <f_lseek+0x43c>
			}
		} else {						/* Fast seek */
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 801033e:	687b      	ldr	r3, [r7, #4]
 8010340:	68db      	ldr	r3, [r3, #12]
 8010342:	683a      	ldr	r2, [r7, #0]
 8010344:	429a      	cmp	r2, r3
 8010346:	d902      	bls.n	801034e <f_lseek+0x114>
 8010348:	687b      	ldr	r3, [r7, #4]
 801034a:	68db      	ldr	r3, [r3, #12]
 801034c:	603b      	str	r3, [r7, #0]
			fp->fptr = ofs;				/* Set file pointer */
 801034e:	687b      	ldr	r3, [r7, #4]
 8010350:	683a      	ldr	r2, [r7, #0]
 8010352:	619a      	str	r2, [r3, #24]
			if (ofs) {
 8010354:	683b      	ldr	r3, [r7, #0]
 8010356:	2b00      	cmp	r3, #0
 8010358:	f000 818d 	beq.w	8010676 <f_lseek+0x43c>
				fp->clust = clmt_clust(fp, ofs - 1);
 801035c:	683b      	ldr	r3, [r7, #0]
 801035e:	3b01      	subs	r3, #1
 8010360:	4619      	mov	r1, r3
 8010362:	6878      	ldr	r0, [r7, #4]
 8010364:	f7fe fa47 	bl	800e7f6 <clmt_clust>
 8010368:	4602      	mov	r2, r0
 801036a:	687b      	ldr	r3, [r7, #4]
 801036c:	61da      	str	r2, [r3, #28]
				dsc = clust2sect(fs, fp->clust);
 801036e:	68ba      	ldr	r2, [r7, #8]
 8010370:	687b      	ldr	r3, [r7, #4]
 8010372:	69db      	ldr	r3, [r3, #28]
 8010374:	4619      	mov	r1, r3
 8010376:	4610      	mov	r0, r2
 8010378:	f7fd ff34 	bl	800e1e4 <clust2sect>
 801037c:	61b8      	str	r0, [r7, #24]
				if (!dsc) ABORT(fs, FR_INT_ERR);
 801037e:	69bb      	ldr	r3, [r7, #24]
 8010380:	2b00      	cmp	r3, #0
 8010382:	d104      	bne.n	801038e <f_lseek+0x154>
 8010384:	687b      	ldr	r3, [r7, #4]
 8010386:	2202      	movs	r2, #2
 8010388:	755a      	strb	r2, [r3, #21]
 801038a:	2302      	movs	r3, #2
 801038c:	e175      	b.n	801067a <f_lseek+0x440>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 801038e:	683b      	ldr	r3, [r7, #0]
 8010390:	3b01      	subs	r3, #1
 8010392:	68ba      	ldr	r2, [r7, #8]
 8010394:	8992      	ldrh	r2, [r2, #12]
 8010396:	fbb3 f3f2 	udiv	r3, r3, r2
 801039a:	68ba      	ldr	r2, [r7, #8]
 801039c:	8952      	ldrh	r2, [r2, #10]
 801039e:	3a01      	subs	r2, #1
 80103a0:	4013      	ands	r3, r2
 80103a2:	69ba      	ldr	r2, [r7, #24]
 80103a4:	4413      	add	r3, r2
 80103a6:	61bb      	str	r3, [r7, #24]
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 80103a8:	687b      	ldr	r3, [r7, #4]
 80103aa:	699b      	ldr	r3, [r3, #24]
 80103ac:	68ba      	ldr	r2, [r7, #8]
 80103ae:	8992      	ldrh	r2, [r2, #12]
 80103b0:	fbb3 f1f2 	udiv	r1, r3, r2
 80103b4:	fb01 f202 	mul.w	r2, r1, r2
 80103b8:	1a9b      	subs	r3, r3, r2
 80103ba:	2b00      	cmp	r3, #0
 80103bc:	f000 815b 	beq.w	8010676 <f_lseek+0x43c>
 80103c0:	687b      	ldr	r3, [r7, #4]
 80103c2:	6a1b      	ldr	r3, [r3, #32]
 80103c4:	69ba      	ldr	r2, [r7, #24]
 80103c6:	429a      	cmp	r2, r3
 80103c8:	f000 8155 	beq.w	8010676 <f_lseek+0x43c>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 80103cc:	687b      	ldr	r3, [r7, #4]
 80103ce:	7d1b      	ldrb	r3, [r3, #20]
 80103d0:	b25b      	sxtb	r3, r3
 80103d2:	2b00      	cmp	r3, #0
 80103d4:	da18      	bge.n	8010408 <f_lseek+0x1ce>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80103d6:	68bb      	ldr	r3, [r7, #8]
 80103d8:	7858      	ldrb	r0, [r3, #1]
 80103da:	687b      	ldr	r3, [r7, #4]
 80103dc:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 80103e0:	687b      	ldr	r3, [r7, #4]
 80103e2:	6a1a      	ldr	r2, [r3, #32]
 80103e4:	2301      	movs	r3, #1
 80103e6:	f7fd fb71 	bl	800dacc <disk_write>
 80103ea:	4603      	mov	r3, r0
 80103ec:	2b00      	cmp	r3, #0
 80103ee:	d004      	beq.n	80103fa <f_lseek+0x1c0>
 80103f0:	687b      	ldr	r3, [r7, #4]
 80103f2:	2201      	movs	r2, #1
 80103f4:	755a      	strb	r2, [r3, #21]
 80103f6:	2301      	movs	r3, #1
 80103f8:	e13f      	b.n	801067a <f_lseek+0x440>
						fp->flag &= (BYTE)~FA_DIRTY;
 80103fa:	687b      	ldr	r3, [r7, #4]
 80103fc:	7d1b      	ldrb	r3, [r3, #20]
 80103fe:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8010402:	b2da      	uxtb	r2, r3
 8010404:	687b      	ldr	r3, [r7, #4]
 8010406:	751a      	strb	r2, [r3, #20]
					}
#endif
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8010408:	68bb      	ldr	r3, [r7, #8]
 801040a:	7858      	ldrb	r0, [r3, #1]
 801040c:	687b      	ldr	r3, [r7, #4]
 801040e:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8010412:	2301      	movs	r3, #1
 8010414:	69ba      	ldr	r2, [r7, #24]
 8010416:	f7fd fb39 	bl	800da8c <disk_read>
 801041a:	4603      	mov	r3, r0
 801041c:	2b00      	cmp	r3, #0
 801041e:	d004      	beq.n	801042a <f_lseek+0x1f0>
 8010420:	687b      	ldr	r3, [r7, #4]
 8010422:	2201      	movs	r2, #1
 8010424:	755a      	strb	r2, [r3, #21]
 8010426:	2301      	movs	r3, #1
 8010428:	e127      	b.n	801067a <f_lseek+0x440>
#endif
					fp->sect = dsc;
 801042a:	687b      	ldr	r3, [r7, #4]
 801042c:	69ba      	ldr	r2, [r7, #24]
 801042e:	621a      	str	r2, [r3, #32]
 8010430:	e121      	b.n	8010676 <f_lseek+0x43c>
	/* Normal Seek */
	{
#if _FS_EXFAT
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
#endif
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8010432:	687b      	ldr	r3, [r7, #4]
 8010434:	68db      	ldr	r3, [r3, #12]
 8010436:	683a      	ldr	r2, [r7, #0]
 8010438:	429a      	cmp	r2, r3
 801043a:	d908      	bls.n	801044e <f_lseek+0x214>
 801043c:	687b      	ldr	r3, [r7, #4]
 801043e:	7d1b      	ldrb	r3, [r3, #20]
 8010440:	f003 0302 	and.w	r3, r3, #2
 8010444:	2b00      	cmp	r3, #0
 8010446:	d102      	bne.n	801044e <f_lseek+0x214>
			ofs = fp->obj.objsize;
 8010448:	687b      	ldr	r3, [r7, #4]
 801044a:	68db      	ldr	r3, [r3, #12]
 801044c:	603b      	str	r3, [r7, #0]
		}
		ifptr = fp->fptr;
 801044e:	687b      	ldr	r3, [r7, #4]
 8010450:	699b      	ldr	r3, [r3, #24]
 8010452:	623b      	str	r3, [r7, #32]
		fp->fptr = nsect = 0;
 8010454:	2300      	movs	r3, #0
 8010456:	637b      	str	r3, [r7, #52]	@ 0x34
 8010458:	687b      	ldr	r3, [r7, #4]
 801045a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801045c:	619a      	str	r2, [r3, #24]
		if (ofs) {
 801045e:	683b      	ldr	r3, [r7, #0]
 8010460:	2b00      	cmp	r3, #0
 8010462:	f000 80b5 	beq.w	80105d0 <f_lseek+0x396>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8010466:	68bb      	ldr	r3, [r7, #8]
 8010468:	895b      	ldrh	r3, [r3, #10]
 801046a:	461a      	mov	r2, r3
 801046c:	68bb      	ldr	r3, [r7, #8]
 801046e:	899b      	ldrh	r3, [r3, #12]
 8010470:	fb02 f303 	mul.w	r3, r2, r3
 8010474:	61fb      	str	r3, [r7, #28]
			if (ifptr > 0 &&
 8010476:	6a3b      	ldr	r3, [r7, #32]
 8010478:	2b00      	cmp	r3, #0
 801047a:	d01b      	beq.n	80104b4 <f_lseek+0x27a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 801047c:	683b      	ldr	r3, [r7, #0]
 801047e:	1e5a      	subs	r2, r3, #1
 8010480:	69fb      	ldr	r3, [r7, #28]
 8010482:	fbb2 f2f3 	udiv	r2, r2, r3
 8010486:	6a3b      	ldr	r3, [r7, #32]
 8010488:	1e59      	subs	r1, r3, #1
 801048a:	69fb      	ldr	r3, [r7, #28]
 801048c:	fbb1 f3f3 	udiv	r3, r1, r3
			if (ifptr > 0 &&
 8010490:	429a      	cmp	r2, r3
 8010492:	d30f      	bcc.n	80104b4 <f_lseek+0x27a>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8010494:	6a3b      	ldr	r3, [r7, #32]
 8010496:	1e5a      	subs	r2, r3, #1
 8010498:	69fb      	ldr	r3, [r7, #28]
 801049a:	425b      	negs	r3, r3
 801049c:	401a      	ands	r2, r3
 801049e:	687b      	ldr	r3, [r7, #4]
 80104a0:	619a      	str	r2, [r3, #24]
				ofs -= fp->fptr;
 80104a2:	687b      	ldr	r3, [r7, #4]
 80104a4:	699b      	ldr	r3, [r3, #24]
 80104a6:	683a      	ldr	r2, [r7, #0]
 80104a8:	1ad3      	subs	r3, r2, r3
 80104aa:	603b      	str	r3, [r7, #0]
				clst = fp->clust;
 80104ac:	687b      	ldr	r3, [r7, #4]
 80104ae:	69db      	ldr	r3, [r3, #28]
 80104b0:	63bb      	str	r3, [r7, #56]	@ 0x38
 80104b2:	e022      	b.n	80104fa <f_lseek+0x2c0>
			} else {									/* When seek to back cluster, */
				clst = fp->obj.sclust;					/* start from the first cluster */
 80104b4:	687b      	ldr	r3, [r7, #4]
 80104b6:	689b      	ldr	r3, [r3, #8]
 80104b8:	63bb      	str	r3, [r7, #56]	@ 0x38
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 80104ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80104bc:	2b00      	cmp	r3, #0
 80104be:	d119      	bne.n	80104f4 <f_lseek+0x2ba>
					clst = create_chain(&fp->obj, 0);
 80104c0:	687b      	ldr	r3, [r7, #4]
 80104c2:	2100      	movs	r1, #0
 80104c4:	4618      	mov	r0, r3
 80104c6:	f7fe f8fe 	bl	800e6c6 <create_chain>
 80104ca:	63b8      	str	r0, [r7, #56]	@ 0x38
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 80104cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80104ce:	2b01      	cmp	r3, #1
 80104d0:	d104      	bne.n	80104dc <f_lseek+0x2a2>
 80104d2:	687b      	ldr	r3, [r7, #4]
 80104d4:	2202      	movs	r2, #2
 80104d6:	755a      	strb	r2, [r3, #21]
 80104d8:	2302      	movs	r3, #2
 80104da:	e0ce      	b.n	801067a <f_lseek+0x440>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80104dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80104de:	f1b3 3fff 	cmp.w	r3, #4294967295
 80104e2:	d104      	bne.n	80104ee <f_lseek+0x2b4>
 80104e4:	687b      	ldr	r3, [r7, #4]
 80104e6:	2201      	movs	r2, #1
 80104e8:	755a      	strb	r2, [r3, #21]
 80104ea:	2301      	movs	r3, #1
 80104ec:	e0c5      	b.n	801067a <f_lseek+0x440>
					fp->obj.sclust = clst;
 80104ee:	687b      	ldr	r3, [r7, #4]
 80104f0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80104f2:	609a      	str	r2, [r3, #8]
				}
#endif
				fp->clust = clst;
 80104f4:	687b      	ldr	r3, [r7, #4]
 80104f6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80104f8:	61da      	str	r2, [r3, #28]
			}
			if (clst != 0) {
 80104fa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80104fc:	2b00      	cmp	r3, #0
 80104fe:	d067      	beq.n	80105d0 <f_lseek+0x396>
				while (ofs > bcs) {						/* Cluster following loop */
 8010500:	e03a      	b.n	8010578 <f_lseek+0x33e>
					ofs -= bcs; fp->fptr += bcs;
 8010502:	683a      	ldr	r2, [r7, #0]
 8010504:	69fb      	ldr	r3, [r7, #28]
 8010506:	1ad3      	subs	r3, r2, r3
 8010508:	603b      	str	r3, [r7, #0]
 801050a:	687b      	ldr	r3, [r7, #4]
 801050c:	699a      	ldr	r2, [r3, #24]
 801050e:	69fb      	ldr	r3, [r7, #28]
 8010510:	441a      	add	r2, r3
 8010512:	687b      	ldr	r3, [r7, #4]
 8010514:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8010516:	687b      	ldr	r3, [r7, #4]
 8010518:	7d1b      	ldrb	r3, [r3, #20]
 801051a:	f003 0302 	and.w	r3, r3, #2
 801051e:	2b00      	cmp	r3, #0
 8010520:	d00b      	beq.n	801053a <f_lseek+0x300>
						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
							fp->obj.objsize = fp->fptr;
							fp->flag |= FA_MODIFIED;
						}
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8010522:	687b      	ldr	r3, [r7, #4]
 8010524:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8010526:	4618      	mov	r0, r3
 8010528:	f7fe f8cd 	bl	800e6c6 <create_chain>
 801052c:	63b8      	str	r0, [r7, #56]	@ 0x38
						if (clst == 0) {				/* Clip file size in case of disk full */
 801052e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010530:	2b00      	cmp	r3, #0
 8010532:	d108      	bne.n	8010546 <f_lseek+0x30c>
							ofs = 0; break;
 8010534:	2300      	movs	r3, #0
 8010536:	603b      	str	r3, [r7, #0]
 8010538:	e022      	b.n	8010580 <f_lseek+0x346>
						}
					} else
#endif
					{
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 801053a:	687b      	ldr	r3, [r7, #4]
 801053c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801053e:	4618      	mov	r0, r3
 8010540:	f7fd fe6f 	bl	800e222 <get_fat>
 8010544:	63b8      	str	r0, [r7, #56]	@ 0x38
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8010546:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010548:	f1b3 3fff 	cmp.w	r3, #4294967295
 801054c:	d104      	bne.n	8010558 <f_lseek+0x31e>
 801054e:	687b      	ldr	r3, [r7, #4]
 8010550:	2201      	movs	r2, #1
 8010552:	755a      	strb	r2, [r3, #21]
 8010554:	2301      	movs	r3, #1
 8010556:	e090      	b.n	801067a <f_lseek+0x440>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8010558:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801055a:	2b01      	cmp	r3, #1
 801055c:	d904      	bls.n	8010568 <f_lseek+0x32e>
 801055e:	68bb      	ldr	r3, [r7, #8]
 8010560:	699b      	ldr	r3, [r3, #24]
 8010562:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010564:	429a      	cmp	r2, r3
 8010566:	d304      	bcc.n	8010572 <f_lseek+0x338>
 8010568:	687b      	ldr	r3, [r7, #4]
 801056a:	2202      	movs	r2, #2
 801056c:	755a      	strb	r2, [r3, #21]
 801056e:	2302      	movs	r3, #2
 8010570:	e083      	b.n	801067a <f_lseek+0x440>
					fp->clust = clst;
 8010572:	687b      	ldr	r3, [r7, #4]
 8010574:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010576:	61da      	str	r2, [r3, #28]
				while (ofs > bcs) {						/* Cluster following loop */
 8010578:	683a      	ldr	r2, [r7, #0]
 801057a:	69fb      	ldr	r3, [r7, #28]
 801057c:	429a      	cmp	r2, r3
 801057e:	d8c0      	bhi.n	8010502 <f_lseek+0x2c8>
				}
				fp->fptr += ofs;
 8010580:	687b      	ldr	r3, [r7, #4]
 8010582:	699a      	ldr	r2, [r3, #24]
 8010584:	683b      	ldr	r3, [r7, #0]
 8010586:	441a      	add	r2, r3
 8010588:	687b      	ldr	r3, [r7, #4]
 801058a:	619a      	str	r2, [r3, #24]
				if (ofs % SS(fs)) {
 801058c:	68bb      	ldr	r3, [r7, #8]
 801058e:	899b      	ldrh	r3, [r3, #12]
 8010590:	461a      	mov	r2, r3
 8010592:	683b      	ldr	r3, [r7, #0]
 8010594:	fbb3 f1f2 	udiv	r1, r3, r2
 8010598:	fb01 f202 	mul.w	r2, r1, r2
 801059c:	1a9b      	subs	r3, r3, r2
 801059e:	2b00      	cmp	r3, #0
 80105a0:	d016      	beq.n	80105d0 <f_lseek+0x396>
					nsect = clust2sect(fs, clst);	/* Current sector */
 80105a2:	68bb      	ldr	r3, [r7, #8]
 80105a4:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80105a6:	4618      	mov	r0, r3
 80105a8:	f7fd fe1c 	bl	800e1e4 <clust2sect>
 80105ac:	6378      	str	r0, [r7, #52]	@ 0x34
					if (!nsect) ABORT(fs, FR_INT_ERR);
 80105ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80105b0:	2b00      	cmp	r3, #0
 80105b2:	d104      	bne.n	80105be <f_lseek+0x384>
 80105b4:	687b      	ldr	r3, [r7, #4]
 80105b6:	2202      	movs	r2, #2
 80105b8:	755a      	strb	r2, [r3, #21]
 80105ba:	2302      	movs	r3, #2
 80105bc:	e05d      	b.n	801067a <f_lseek+0x440>
					nsect += (DWORD)(ofs / SS(fs));
 80105be:	68bb      	ldr	r3, [r7, #8]
 80105c0:	899b      	ldrh	r3, [r3, #12]
 80105c2:	461a      	mov	r2, r3
 80105c4:	683b      	ldr	r3, [r7, #0]
 80105c6:	fbb3 f3f2 	udiv	r3, r3, r2
 80105ca:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80105cc:	4413      	add	r3, r2
 80105ce:	637b      	str	r3, [r7, #52]	@ 0x34
				}
			}
		}
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 80105d0:	687b      	ldr	r3, [r7, #4]
 80105d2:	699a      	ldr	r2, [r3, #24]
 80105d4:	687b      	ldr	r3, [r7, #4]
 80105d6:	68db      	ldr	r3, [r3, #12]
 80105d8:	429a      	cmp	r2, r3
 80105da:	d90a      	bls.n	80105f2 <f_lseek+0x3b8>
			fp->obj.objsize = fp->fptr;
 80105dc:	687b      	ldr	r3, [r7, #4]
 80105de:	699a      	ldr	r2, [r3, #24]
 80105e0:	687b      	ldr	r3, [r7, #4]
 80105e2:	60da      	str	r2, [r3, #12]
			fp->flag |= FA_MODIFIED;
 80105e4:	687b      	ldr	r3, [r7, #4]
 80105e6:	7d1b      	ldrb	r3, [r3, #20]
 80105e8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80105ec:	b2da      	uxtb	r2, r3
 80105ee:	687b      	ldr	r3, [r7, #4]
 80105f0:	751a      	strb	r2, [r3, #20]
		}
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 80105f2:	687b      	ldr	r3, [r7, #4]
 80105f4:	699b      	ldr	r3, [r3, #24]
 80105f6:	68ba      	ldr	r2, [r7, #8]
 80105f8:	8992      	ldrh	r2, [r2, #12]
 80105fa:	fbb3 f1f2 	udiv	r1, r3, r2
 80105fe:	fb01 f202 	mul.w	r2, r1, r2
 8010602:	1a9b      	subs	r3, r3, r2
 8010604:	2b00      	cmp	r3, #0
 8010606:	d036      	beq.n	8010676 <f_lseek+0x43c>
 8010608:	687b      	ldr	r3, [r7, #4]
 801060a:	6a1b      	ldr	r3, [r3, #32]
 801060c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801060e:	429a      	cmp	r2, r3
 8010610:	d031      	beq.n	8010676 <f_lseek+0x43c>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8010612:	687b      	ldr	r3, [r7, #4]
 8010614:	7d1b      	ldrb	r3, [r3, #20]
 8010616:	b25b      	sxtb	r3, r3
 8010618:	2b00      	cmp	r3, #0
 801061a:	da18      	bge.n	801064e <f_lseek+0x414>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 801061c:	68bb      	ldr	r3, [r7, #8]
 801061e:	7858      	ldrb	r0, [r3, #1]
 8010620:	687b      	ldr	r3, [r7, #4]
 8010622:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8010626:	687b      	ldr	r3, [r7, #4]
 8010628:	6a1a      	ldr	r2, [r3, #32]
 801062a:	2301      	movs	r3, #1
 801062c:	f7fd fa4e 	bl	800dacc <disk_write>
 8010630:	4603      	mov	r3, r0
 8010632:	2b00      	cmp	r3, #0
 8010634:	d004      	beq.n	8010640 <f_lseek+0x406>
 8010636:	687b      	ldr	r3, [r7, #4]
 8010638:	2201      	movs	r2, #1
 801063a:	755a      	strb	r2, [r3, #21]
 801063c:	2301      	movs	r3, #1
 801063e:	e01c      	b.n	801067a <f_lseek+0x440>
				fp->flag &= (BYTE)~FA_DIRTY;
 8010640:	687b      	ldr	r3, [r7, #4]
 8010642:	7d1b      	ldrb	r3, [r3, #20]
 8010644:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8010648:	b2da      	uxtb	r2, r3
 801064a:	687b      	ldr	r3, [r7, #4]
 801064c:	751a      	strb	r2, [r3, #20]
			}
#endif
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 801064e:	68bb      	ldr	r3, [r7, #8]
 8010650:	7858      	ldrb	r0, [r3, #1]
 8010652:	687b      	ldr	r3, [r7, #4]
 8010654:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8010658:	2301      	movs	r3, #1
 801065a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801065c:	f7fd fa16 	bl	800da8c <disk_read>
 8010660:	4603      	mov	r3, r0
 8010662:	2b00      	cmp	r3, #0
 8010664:	d004      	beq.n	8010670 <f_lseek+0x436>
 8010666:	687b      	ldr	r3, [r7, #4]
 8010668:	2201      	movs	r2, #1
 801066a:	755a      	strb	r2, [r3, #21]
 801066c:	2301      	movs	r3, #1
 801066e:	e004      	b.n	801067a <f_lseek+0x440>
#endif
			fp->sect = nsect;
 8010670:	687b      	ldr	r3, [r7, #4]
 8010672:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010674:	621a      	str	r2, [r3, #32]
		}
	}

	LEAVE_FF(fs, res);
 8010676:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
}
 801067a:	4618      	mov	r0, r3
 801067c:	3740      	adds	r7, #64	@ 0x40
 801067e:	46bd      	mov	sp, r7
 8010680:	bd80      	pop	{r7, pc}

08010682 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 8010682:	b580      	push	{r7, lr}
 8010684:	b09e      	sub	sp, #120	@ 0x78
 8010686:	af00      	add	r7, sp, #0
 8010688:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj, sdj;
	DWORD dclst = 0;
 801068a:	2300      	movs	r3, #0
 801068c:	673b      	str	r3, [r7, #112]	@ 0x70
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 801068e:	f107 010c 	add.w	r1, r7, #12
 8010692:	1d3b      	adds	r3, r7, #4
 8010694:	2202      	movs	r2, #2
 8010696:	4618      	mov	r0, r3
 8010698:	f7fe fd70 	bl	800f17c <find_volume>
 801069c:	4603      	mov	r3, r0
 801069e:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
	dj.obj.fs = fs;
 80106a2:	68fb      	ldr	r3, [r7, #12]
 80106a4:	643b      	str	r3, [r7, #64]	@ 0x40
	if (res == FR_OK) {
 80106a6:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 80106aa:	2b00      	cmp	r3, #0
 80106ac:	f040 808e 	bne.w	80107cc <f_unlink+0x14a>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
 80106b0:	687a      	ldr	r2, [r7, #4]
 80106b2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80106b6:	4611      	mov	r1, r2
 80106b8:	4618      	mov	r0, r3
 80106ba:	f7fe fc4f 	bl	800ef5c <follow_path>
 80106be:	4603      	mov	r3, r0
 80106c0:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if _FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 80106c4:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 80106c8:	2b00      	cmp	r3, #0
 80106ca:	d108      	bne.n	80106de <f_unlink+0x5c>
 80106cc:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80106d0:	2102      	movs	r1, #2
 80106d2:	4618      	mov	r0, r3
 80106d4:	f7fd fb38 	bl	800dd48 <chk_lock>
 80106d8:	4603      	mov	r3, r0
 80106da:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
#endif
		if (res == FR_OK) {					/* The object is accessible */
 80106de:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 80106e2:	2b00      	cmp	r3, #0
 80106e4:	d172      	bne.n	80107cc <f_unlink+0x14a>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 80106e6:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 80106ea:	b25b      	sxtb	r3, r3
 80106ec:	2b00      	cmp	r3, #0
 80106ee:	da03      	bge.n	80106f8 <f_unlink+0x76>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 80106f0:	2306      	movs	r3, #6
 80106f2:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
 80106f6:	e008      	b.n	801070a <f_unlink+0x88>
			} else {
				if (dj.obj.attr & AM_RDO) {
 80106f8:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80106fc:	f003 0301 	and.w	r3, r3, #1
 8010700:	2b00      	cmp	r3, #0
 8010702:	d002      	beq.n	801070a <f_unlink+0x88>
					res = FR_DENIED;		/* Cannot remove R/O object */
 8010704:	2307      	movs	r3, #7
 8010706:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
				}
			}
			if (res == FR_OK) {
 801070a:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801070e:	2b00      	cmp	r3, #0
 8010710:	d134      	bne.n	801077c <f_unlink+0xfa>
					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
 8010712:	68fb      	ldr	r3, [r7, #12]
 8010714:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8010716:	4611      	mov	r1, r2
 8010718:	4618      	mov	r0, r3
 801071a:	f7fe fa4a 	bl	800ebb2 <ld_clust>
 801071e:	6738      	str	r0, [r7, #112]	@ 0x70
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 8010720:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 8010724:	f003 0310 	and.w	r3, r3, #16
 8010728:	2b00      	cmp	r3, #0
 801072a:	d027      	beq.n	801077c <f_unlink+0xfa>
					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
						res = FR_DENIED;
					} else
#endif
					{
						sdj.obj.fs = fs;						/* Open the sub-directory */
 801072c:	68fb      	ldr	r3, [r7, #12]
 801072e:	613b      	str	r3, [r7, #16]
						sdj.obj.sclust = dclst;
 8010730:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8010732:	61bb      	str	r3, [r7, #24]
						if (fs->fs_type == FS_EXFAT) {
							sdj.obj.objsize = obj.objsize;
							sdj.obj.stat = obj.stat;
						}
#endif
						res = dir_sdi(&sdj, 0);
 8010734:	f107 0310 	add.w	r3, r7, #16
 8010738:	2100      	movs	r1, #0
 801073a:	4618      	mov	r0, r3
 801073c:	f7fe f893 	bl	800e866 <dir_sdi>
 8010740:	4603      	mov	r3, r0
 8010742:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
						if (res == FR_OK) {
 8010746:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801074a:	2b00      	cmp	r3, #0
 801074c:	d116      	bne.n	801077c <f_unlink+0xfa>
							res = dir_read(&sdj, 0);			/* Read an item */
 801074e:	f107 0310 	add.w	r3, r7, #16
 8010752:	2100      	movs	r1, #0
 8010754:	4618      	mov	r0, r3
 8010756:	f7fe fa6b 	bl	800ec30 <dir_read>
 801075a:	4603      	mov	r3, r0
 801075c:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 8010760:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 8010764:	2b00      	cmp	r3, #0
 8010766:	d102      	bne.n	801076e <f_unlink+0xec>
 8010768:	2307      	movs	r3, #7
 801076a:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 801076e:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 8010772:	2b04      	cmp	r3, #4
 8010774:	d102      	bne.n	801077c <f_unlink+0xfa>
 8010776:	2300      	movs	r3, #0
 8010778:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
						}
					}
				}
			}
			if (res == FR_OK) {
 801077c:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 8010780:	2b00      	cmp	r3, #0
 8010782:	d123      	bne.n	80107cc <f_unlink+0x14a>
				res = dir_remove(&dj);			/* Remove the directory entry */
 8010784:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 8010788:	4618      	mov	r0, r3
 801078a:	f7fe fb35 	bl	800edf8 <dir_remove>
 801078e:	4603      	mov	r3, r0
 8010790:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
 8010794:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 8010798:	2b00      	cmp	r3, #0
 801079a:	d10c      	bne.n	80107b6 <f_unlink+0x134>
 801079c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801079e:	2b00      	cmp	r3, #0
 80107a0:	d009      	beq.n	80107b6 <f_unlink+0x134>
#if _FS_EXFAT
					res = remove_chain(&obj, dclst, 0);
#else
					res = remove_chain(&dj.obj, dclst, 0);
 80107a2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80107a6:	2200      	movs	r2, #0
 80107a8:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80107aa:	4618      	mov	r0, r3
 80107ac:	f7fd ff26 	bl	800e5fc <remove_chain>
 80107b0:	4603      	mov	r3, r0
 80107b2:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
 80107b6:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 80107ba:	2b00      	cmp	r3, #0
 80107bc:	d106      	bne.n	80107cc <f_unlink+0x14a>
 80107be:	68fb      	ldr	r3, [r7, #12]
 80107c0:	4618      	mov	r0, r3
 80107c2:	f7fd fc9f 	bl	800e104 <sync_fs>
 80107c6:	4603      	mov	r3, r0
 80107c8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
			}
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
 80107cc:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
 80107d0:	4618      	mov	r0, r3
 80107d2:	3778      	adds	r7, #120	@ 0x78
 80107d4:	46bd      	mov	sp, r7
 80107d6:	bd80      	pop	{r7, pc}

080107d8 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 80107d8:	b580      	push	{r7, lr}
 80107da:	b096      	sub	sp, #88	@ 0x58
 80107dc:	af00      	add	r7, sp, #0
 80107de:	6078      	str	r0, [r7, #4]
	DWORD dsc, dcl, pcl, tm;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 80107e0:	f107 0108 	add.w	r1, r7, #8
 80107e4:	1d3b      	adds	r3, r7, #4
 80107e6:	2202      	movs	r2, #2
 80107e8:	4618      	mov	r0, r3
 80107ea:	f7fe fcc7 	bl	800f17c <find_volume>
 80107ee:	4603      	mov	r3, r0
 80107f0:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
	dj.obj.fs = fs;
 80107f4:	68bb      	ldr	r3, [r7, #8]
 80107f6:	60fb      	str	r3, [r7, #12]
	if (res == FR_OK) {
 80107f8:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 80107fc:	2b00      	cmp	r3, #0
 80107fe:	f040 80f2 	bne.w	80109e6 <f_mkdir+0x20e>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
 8010802:	687a      	ldr	r2, [r7, #4]
 8010804:	f107 030c 	add.w	r3, r7, #12
 8010808:	4611      	mov	r1, r2
 801080a:	4618      	mov	r0, r3
 801080c:	f7fe fba6 	bl	800ef5c <follow_path>
 8010810:	4603      	mov	r3, r0
 8010812:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8010816:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801081a:	2b00      	cmp	r3, #0
 801081c:	d102      	bne.n	8010824 <f_mkdir+0x4c>
 801081e:	2308      	movs	r3, #8
 8010820:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;
		}
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 8010824:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8010828:	2b04      	cmp	r3, #4
 801082a:	f040 80dc 	bne.w	80109e6 <f_mkdir+0x20e>
			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
 801082e:	f107 030c 	add.w	r3, r7, #12
 8010832:	2100      	movs	r1, #0
 8010834:	4618      	mov	r0, r3
 8010836:	f7fd ff46 	bl	800e6c6 <create_chain>
 801083a:	6478      	str	r0, [r7, #68]	@ 0x44
			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
 801083c:	68bb      	ldr	r3, [r7, #8]
 801083e:	895b      	ldrh	r3, [r3, #10]
 8010840:	461a      	mov	r2, r3
 8010842:	68bb      	ldr	r3, [r7, #8]
 8010844:	899b      	ldrh	r3, [r3, #12]
 8010846:	fb02 f303 	mul.w	r3, r2, r3
 801084a:	61bb      	str	r3, [r7, #24]
			res = FR_OK;
 801084c:	2300      	movs	r3, #0
 801084e:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8010852:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010854:	2b00      	cmp	r3, #0
 8010856:	d102      	bne.n	801085e <f_mkdir+0x86>
 8010858:	2307      	movs	r3, #7
 801085a:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			if (dcl == 1) res = FR_INT_ERR;
 801085e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010860:	2b01      	cmp	r3, #1
 8010862:	d102      	bne.n	801086a <f_mkdir+0x92>
 8010864:	2302      	movs	r3, #2
 8010866:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 801086a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801086c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010870:	d102      	bne.n	8010878 <f_mkdir+0xa0>
 8010872:	2301      	movs	r3, #1
 8010874:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
 8010878:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801087c:	2b00      	cmp	r3, #0
 801087e:	d106      	bne.n	801088e <f_mkdir+0xb6>
 8010880:	68bb      	ldr	r3, [r7, #8]
 8010882:	4618      	mov	r0, r3
 8010884:	f7fd fbcc 	bl	800e020 <sync_window>
 8010888:	4603      	mov	r3, r0
 801088a:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			tm = GET_FATTIME();
 801088e:	f7f9 ff19 	bl	800a6c4 <get_fattime>
 8010892:	6438      	str	r0, [r7, #64]	@ 0x40
			if (res == FR_OK) {					/* Initialize the new directory table */
 8010894:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8010898:	2b00      	cmp	r3, #0
 801089a:	d16c      	bne.n	8010976 <f_mkdir+0x19e>
				dsc = clust2sect(fs, dcl);
 801089c:	68bb      	ldr	r3, [r7, #8]
 801089e:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80108a0:	4618      	mov	r0, r3
 80108a2:	f7fd fc9f 	bl	800e1e4 <clust2sect>
 80108a6:	64f8      	str	r0, [r7, #76]	@ 0x4c
				dir = fs->win;
 80108a8:	68bb      	ldr	r3, [r7, #8]
 80108aa:	3334      	adds	r3, #52	@ 0x34
 80108ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
				mem_set(dir, 0, SS(fs));
 80108ae:	68bb      	ldr	r3, [r7, #8]
 80108b0:	899b      	ldrh	r3, [r3, #12]
 80108b2:	461a      	mov	r2, r3
 80108b4:	2100      	movs	r1, #0
 80108b6:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80108b8:	f7fd f9e9 	bl	800dc8e <mem_set>
				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
 80108bc:	220b      	movs	r2, #11
 80108be:	2120      	movs	r1, #32
 80108c0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80108c2:	f7fd f9e4 	bl	800dc8e <mem_set>
					dir[DIR_Name] = '.';
 80108c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80108c8:	222e      	movs	r2, #46	@ 0x2e
 80108ca:	701a      	strb	r2, [r3, #0]
					dir[DIR_Attr] = AM_DIR;
 80108cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80108ce:	330b      	adds	r3, #11
 80108d0:	2210      	movs	r2, #16
 80108d2:	701a      	strb	r2, [r3, #0]
					st_dword(dir + DIR_ModTime, tm);
 80108d4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80108d6:	3316      	adds	r3, #22
 80108d8:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80108da:	4618      	mov	r0, r3
 80108dc:	f7fd f98a 	bl	800dbf4 <st_dword>
					st_clust(fs, dir, dcl);
 80108e0:	68bb      	ldr	r3, [r7, #8]
 80108e2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80108e4:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 80108e6:	4618      	mov	r0, r3
 80108e8:	f7fe f982 	bl	800ebf0 <st_clust>
					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
 80108ec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80108ee:	3320      	adds	r3, #32
 80108f0:	2220      	movs	r2, #32
 80108f2:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 80108f4:	4618      	mov	r0, r3
 80108f6:	f7fd f9a9 	bl	800dc4c <mem_cpy>
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 80108fa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80108fc:	3321      	adds	r3, #33	@ 0x21
 80108fe:	222e      	movs	r2, #46	@ 0x2e
 8010900:	701a      	strb	r2, [r3, #0]
 8010902:	697b      	ldr	r3, [r7, #20]
 8010904:	64bb      	str	r3, [r7, #72]	@ 0x48
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8010906:	68bb      	ldr	r3, [r7, #8]
 8010908:	781b      	ldrb	r3, [r3, #0]
 801090a:	2b03      	cmp	r3, #3
 801090c:	d106      	bne.n	801091c <f_mkdir+0x144>
 801090e:	68bb      	ldr	r3, [r7, #8]
 8010910:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010912:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010914:	429a      	cmp	r2, r3
 8010916:	d101      	bne.n	801091c <f_mkdir+0x144>
 8010918:	2300      	movs	r3, #0
 801091a:	64bb      	str	r3, [r7, #72]	@ 0x48
					st_clust(fs, dir + SZDIRE, pcl);
 801091c:	68b8      	ldr	r0, [r7, #8]
 801091e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010920:	3320      	adds	r3, #32
 8010922:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010924:	4619      	mov	r1, r3
 8010926:	f7fe f963 	bl	800ebf0 <st_clust>
				}
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 801092a:	68bb      	ldr	r3, [r7, #8]
 801092c:	895b      	ldrh	r3, [r3, #10]
 801092e:	653b      	str	r3, [r7, #80]	@ 0x50
 8010930:	e01c      	b.n	801096c <f_mkdir+0x194>
					fs->winsect = dsc++;
 8010932:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010934:	1c5a      	adds	r2, r3, #1
 8010936:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8010938:	68ba      	ldr	r2, [r7, #8]
 801093a:	6313      	str	r3, [r2, #48]	@ 0x30
					fs->wflag = 1;
 801093c:	68bb      	ldr	r3, [r7, #8]
 801093e:	2201      	movs	r2, #1
 8010940:	70da      	strb	r2, [r3, #3]
					res = sync_window(fs);
 8010942:	68bb      	ldr	r3, [r7, #8]
 8010944:	4618      	mov	r0, r3
 8010946:	f7fd fb6b 	bl	800e020 <sync_window>
 801094a:	4603      	mov	r3, r0
 801094c:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
					if (res != FR_OK) break;
 8010950:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8010954:	2b00      	cmp	r3, #0
 8010956:	d10d      	bne.n	8010974 <f_mkdir+0x19c>
					mem_set(dir, 0, SS(fs));
 8010958:	68bb      	ldr	r3, [r7, #8]
 801095a:	899b      	ldrh	r3, [r3, #12]
 801095c:	461a      	mov	r2, r3
 801095e:	2100      	movs	r1, #0
 8010960:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010962:	f7fd f994 	bl	800dc8e <mem_set>
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8010966:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010968:	3b01      	subs	r3, #1
 801096a:	653b      	str	r3, [r7, #80]	@ 0x50
 801096c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801096e:	2b00      	cmp	r3, #0
 8010970:	d1df      	bne.n	8010932 <f_mkdir+0x15a>
 8010972:	e000      	b.n	8010976 <f_mkdir+0x19e>
					if (res != FR_OK) break;
 8010974:	bf00      	nop
				}
			}
			if (res == FR_OK) {
 8010976:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801097a:	2b00      	cmp	r3, #0
 801097c:	d107      	bne.n	801098e <f_mkdir+0x1b6>
				res = dir_register(&dj);	/* Register the object to the directoy */
 801097e:	f107 030c 	add.w	r3, r7, #12
 8010982:	4618      	mov	r0, r3
 8010984:	f7fe fa06 	bl	800ed94 <dir_register>
 8010988:	4603      	mov	r3, r0
 801098a:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
			}
			if (res == FR_OK) {
 801098e:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8010992:	2b00      	cmp	r3, #0
 8010994:	d120      	bne.n	80109d8 <f_mkdir+0x200>
					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
					res = store_xdir(&dj);
				} else
#endif
				{
					dir = dj.dir;
 8010996:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010998:	63fb      	str	r3, [r7, #60]	@ 0x3c
					st_dword(dir + DIR_ModTime, tm);	/* Created time */
 801099a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801099c:	3316      	adds	r3, #22
 801099e:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80109a0:	4618      	mov	r0, r3
 80109a2:	f7fd f927 	bl	800dbf4 <st_dword>
					st_clust(fs, dir, dcl);				/* Table start cluster */
 80109a6:	68bb      	ldr	r3, [r7, #8]
 80109a8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80109aa:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 80109ac:	4618      	mov	r0, r3
 80109ae:	f7fe f91f 	bl	800ebf0 <st_clust>
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 80109b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80109b4:	330b      	adds	r3, #11
 80109b6:	2210      	movs	r2, #16
 80109b8:	701a      	strb	r2, [r3, #0]
					fs->wflag = 1;
 80109ba:	68bb      	ldr	r3, [r7, #8]
 80109bc:	2201      	movs	r2, #1
 80109be:	70da      	strb	r2, [r3, #3]
				}
				if (res == FR_OK) {
 80109c0:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 80109c4:	2b00      	cmp	r3, #0
 80109c6:	d10e      	bne.n	80109e6 <f_mkdir+0x20e>
					res = sync_fs(fs);
 80109c8:	68bb      	ldr	r3, [r7, #8]
 80109ca:	4618      	mov	r0, r3
 80109cc:	f7fd fb9a 	bl	800e104 <sync_fs>
 80109d0:	4603      	mov	r3, r0
 80109d2:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
 80109d6:	e006      	b.n	80109e6 <f_mkdir+0x20e>
				}
			} else {
				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 80109d8:	f107 030c 	add.w	r3, r7, #12
 80109dc:	2200      	movs	r2, #0
 80109de:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80109e0:	4618      	mov	r0, r3
 80109e2:	f7fd fe0b 	bl	800e5fc <remove_chain>
			}
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
 80109e6:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
}
 80109ea:	4618      	mov	r0, r3
 80109ec:	3758      	adds	r7, #88	@ 0x58
 80109ee:	46bd      	mov	sp, r7
 80109f0:	bd80      	pop	{r7, pc}
	...

080109f4 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 80109f4:	b480      	push	{r7}
 80109f6:	b087      	sub	sp, #28
 80109f8:	af00      	add	r7, sp, #0
 80109fa:	60f8      	str	r0, [r7, #12]
 80109fc:	60b9      	str	r1, [r7, #8]
 80109fe:	4613      	mov	r3, r2
 8010a00:	71fb      	strb	r3, [r7, #7]
  uint8_t ret = 1;
 8010a02:	2301      	movs	r3, #1
 8010a04:	75fb      	strb	r3, [r7, #23]
  uint8_t DiskNum = 0;
 8010a06:	2300      	movs	r3, #0
 8010a08:	75bb      	strb	r3, [r7, #22]

  if(disk.nbr < _VOLUMES)
 8010a0a:	4b1f      	ldr	r3, [pc, #124]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a0c:	7a5b      	ldrb	r3, [r3, #9]
 8010a0e:	b2db      	uxtb	r3, r3
 8010a10:	2b00      	cmp	r3, #0
 8010a12:	d131      	bne.n	8010a78 <FATFS_LinkDriverEx+0x84>
  {
    disk.is_initialized[disk.nbr] = 0;
 8010a14:	4b1c      	ldr	r3, [pc, #112]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a16:	7a5b      	ldrb	r3, [r3, #9]
 8010a18:	b2db      	uxtb	r3, r3
 8010a1a:	461a      	mov	r2, r3
 8010a1c:	4b1a      	ldr	r3, [pc, #104]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a1e:	2100      	movs	r1, #0
 8010a20:	5499      	strb	r1, [r3, r2]
    disk.drv[disk.nbr] = drv;
 8010a22:	4b19      	ldr	r3, [pc, #100]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a24:	7a5b      	ldrb	r3, [r3, #9]
 8010a26:	b2db      	uxtb	r3, r3
 8010a28:	4a17      	ldr	r2, [pc, #92]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a2a:	009b      	lsls	r3, r3, #2
 8010a2c:	4413      	add	r3, r2
 8010a2e:	68fa      	ldr	r2, [r7, #12]
 8010a30:	605a      	str	r2, [r3, #4]
    disk.lun[disk.nbr] = lun;
 8010a32:	4b15      	ldr	r3, [pc, #84]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a34:	7a5b      	ldrb	r3, [r3, #9]
 8010a36:	b2db      	uxtb	r3, r3
 8010a38:	461a      	mov	r2, r3
 8010a3a:	4b13      	ldr	r3, [pc, #76]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a3c:	4413      	add	r3, r2
 8010a3e:	79fa      	ldrb	r2, [r7, #7]
 8010a40:	721a      	strb	r2, [r3, #8]
    DiskNum = disk.nbr++;
 8010a42:	4b11      	ldr	r3, [pc, #68]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a44:	7a5b      	ldrb	r3, [r3, #9]
 8010a46:	b2db      	uxtb	r3, r3
 8010a48:	1c5a      	adds	r2, r3, #1
 8010a4a:	b2d1      	uxtb	r1, r2
 8010a4c:	4a0e      	ldr	r2, [pc, #56]	@ (8010a88 <FATFS_LinkDriverEx+0x94>)
 8010a4e:	7251      	strb	r1, [r2, #9]
 8010a50:	75bb      	strb	r3, [r7, #22]
    path[0] = DiskNum + '0';
 8010a52:	7dbb      	ldrb	r3, [r7, #22]
 8010a54:	3330      	adds	r3, #48	@ 0x30
 8010a56:	b2da      	uxtb	r2, r3
 8010a58:	68bb      	ldr	r3, [r7, #8]
 8010a5a:	701a      	strb	r2, [r3, #0]
    path[1] = ':';
 8010a5c:	68bb      	ldr	r3, [r7, #8]
 8010a5e:	3301      	adds	r3, #1
 8010a60:	223a      	movs	r2, #58	@ 0x3a
 8010a62:	701a      	strb	r2, [r3, #0]
    path[2] = '/';
 8010a64:	68bb      	ldr	r3, [r7, #8]
 8010a66:	3302      	adds	r3, #2
 8010a68:	222f      	movs	r2, #47	@ 0x2f
 8010a6a:	701a      	strb	r2, [r3, #0]
    path[3] = 0;
 8010a6c:	68bb      	ldr	r3, [r7, #8]
 8010a6e:	3303      	adds	r3, #3
 8010a70:	2200      	movs	r2, #0
 8010a72:	701a      	strb	r2, [r3, #0]
    ret = 0;
 8010a74:	2300      	movs	r3, #0
 8010a76:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8010a78:	7dfb      	ldrb	r3, [r7, #23]
}
 8010a7a:	4618      	mov	r0, r3
 8010a7c:	371c      	adds	r7, #28
 8010a7e:	46bd      	mov	sp, r7
 8010a80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a84:	4770      	bx	lr
 8010a86:	bf00      	nop
 8010a88:	20002914 	.word	0x20002914

08010a8c <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8010a8c:	b580      	push	{r7, lr}
 8010a8e:	b082      	sub	sp, #8
 8010a90:	af00      	add	r7, sp, #0
 8010a92:	6078      	str	r0, [r7, #4]
 8010a94:	6039      	str	r1, [r7, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
 8010a96:	2200      	movs	r2, #0
 8010a98:	6839      	ldr	r1, [r7, #0]
 8010a9a:	6878      	ldr	r0, [r7, #4]
 8010a9c:	f7ff ffaa 	bl	80109f4 <FATFS_LinkDriverEx>
 8010aa0:	4603      	mov	r3, r0
}
 8010aa2:	4618      	mov	r0, r3
 8010aa4:	3708      	adds	r7, #8
 8010aa6:	46bd      	mov	sp, r7
 8010aa8:	bd80      	pop	{r7, pc}

08010aaa <jpeg_abort>:
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
 8010aaa:	b580      	push	{r7, lr}
 8010aac:	b084      	sub	sp, #16
 8010aae:	af00      	add	r7, sp, #0
 8010ab0:	6078      	str	r0, [r7, #4]
  int pool;

  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
  if (cinfo->mem == NULL)
 8010ab2:	687b      	ldr	r3, [r7, #4]
 8010ab4:	685b      	ldr	r3, [r3, #4]
 8010ab6:	2b00      	cmp	r3, #0
 8010ab8:	d01e      	beq.n	8010af8 <jpeg_abort+0x4e>
    return;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 8010aba:	2301      	movs	r3, #1
 8010abc:	60fb      	str	r3, [r7, #12]
 8010abe:	e008      	b.n	8010ad2 <jpeg_abort+0x28>
    (*cinfo->mem->free_pool) (cinfo, pool);
 8010ac0:	687b      	ldr	r3, [r7, #4]
 8010ac2:	685b      	ldr	r3, [r3, #4]
 8010ac4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010ac6:	68f9      	ldr	r1, [r7, #12]
 8010ac8:	6878      	ldr	r0, [r7, #4]
 8010aca:	4798      	blx	r3
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 8010acc:	68fb      	ldr	r3, [r7, #12]
 8010ace:	3b01      	subs	r3, #1
 8010ad0:	60fb      	str	r3, [r7, #12]
 8010ad2:	68fb      	ldr	r3, [r7, #12]
 8010ad4:	2b00      	cmp	r3, #0
 8010ad6:	dcf3      	bgt.n	8010ac0 <jpeg_abort+0x16>
  }

  /* Reset overall state for possible reuse of object */
  if (cinfo->is_decompressor) {
 8010ad8:	687b      	ldr	r3, [r7, #4]
 8010ada:	691b      	ldr	r3, [r3, #16]
 8010adc:	2b00      	cmp	r3, #0
 8010ade:	d007      	beq.n	8010af0 <jpeg_abort+0x46>
    cinfo->global_state = DSTATE_START;
 8010ae0:	687b      	ldr	r3, [r7, #4]
 8010ae2:	22c8      	movs	r2, #200	@ 0xc8
 8010ae4:	615a      	str	r2, [r3, #20]
    /* Try to keep application from accessing now-deleted marker list.
     * A bit kludgy to do it here, but this is the most central place.
     */
    ((j_decompress_ptr) cinfo)->marker_list = NULL;
 8010ae6:	687b      	ldr	r3, [r7, #4]
 8010ae8:	2200      	movs	r2, #0
 8010aea:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
 8010aee:	e004      	b.n	8010afa <jpeg_abort+0x50>
  } else {
    cinfo->global_state = CSTATE_START;
 8010af0:	687b      	ldr	r3, [r7, #4]
 8010af2:	2264      	movs	r2, #100	@ 0x64
 8010af4:	615a      	str	r2, [r3, #20]
 8010af6:	e000      	b.n	8010afa <jpeg_abort+0x50>
    return;
 8010af8:	bf00      	nop
  }
}
 8010afa:	3710      	adds	r7, #16
 8010afc:	46bd      	mov	sp, r7
 8010afe:	bd80      	pop	{r7, pc}

08010b00 <jpeg_destroy>:
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
 8010b00:	b580      	push	{r7, lr}
 8010b02:	b082      	sub	sp, #8
 8010b04:	af00      	add	r7, sp, #0
 8010b06:	6078      	str	r0, [r7, #4]
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
 8010b08:	687b      	ldr	r3, [r7, #4]
 8010b0a:	685b      	ldr	r3, [r3, #4]
 8010b0c:	2b00      	cmp	r3, #0
 8010b0e:	d004      	beq.n	8010b1a <jpeg_destroy+0x1a>
    (*cinfo->mem->self_destruct) (cinfo);
 8010b10:	687b      	ldr	r3, [r7, #4]
 8010b12:	685b      	ldr	r3, [r3, #4]
 8010b14:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8010b16:	6878      	ldr	r0, [r7, #4]
 8010b18:	4798      	blx	r3
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
 8010b1a:	687b      	ldr	r3, [r7, #4]
 8010b1c:	2200      	movs	r2, #0
 8010b1e:	605a      	str	r2, [r3, #4]
  cinfo->global_state = 0;	/* mark it destroyed */
 8010b20:	687b      	ldr	r3, [r7, #4]
 8010b22:	2200      	movs	r2, #0
 8010b24:	615a      	str	r2, [r3, #20]
}
 8010b26:	bf00      	nop
 8010b28:	3708      	adds	r7, #8
 8010b2a:	46bd      	mov	sp, r7
 8010b2c:	bd80      	pop	{r7, pc}

08010b2e <jpeg_alloc_quant_table>:
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
 8010b2e:	b580      	push	{r7, lr}
 8010b30:	b084      	sub	sp, #16
 8010b32:	af00      	add	r7, sp, #0
 8010b34:	6078      	str	r0, [r7, #4]
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
 8010b36:	687b      	ldr	r3, [r7, #4]
 8010b38:	685b      	ldr	r3, [r3, #4]
 8010b3a:	681b      	ldr	r3, [r3, #0]
 8010b3c:	2284      	movs	r2, #132	@ 0x84
 8010b3e:	2100      	movs	r1, #0
 8010b40:	6878      	ldr	r0, [r7, #4]
 8010b42:	4798      	blx	r3
 8010b44:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 8010b46:	68fb      	ldr	r3, [r7, #12]
 8010b48:	2200      	movs	r2, #0
 8010b4a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  return tbl;
 8010b4e:	68fb      	ldr	r3, [r7, #12]
}
 8010b50:	4618      	mov	r0, r3
 8010b52:	3710      	adds	r7, #16
 8010b54:	46bd      	mov	sp, r7
 8010b56:	bd80      	pop	{r7, pc}

08010b58 <jpeg_alloc_huff_table>:


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
 8010b58:	b580      	push	{r7, lr}
 8010b5a:	b084      	sub	sp, #16
 8010b5c:	af00      	add	r7, sp, #0
 8010b5e:	6078      	str	r0, [r7, #4]
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
 8010b60:	687b      	ldr	r3, [r7, #4]
 8010b62:	685b      	ldr	r3, [r3, #4]
 8010b64:	681b      	ldr	r3, [r3, #0]
 8010b66:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8010b6a:	2100      	movs	r1, #0
 8010b6c:	6878      	ldr	r0, [r7, #4]
 8010b6e:	4798      	blx	r3
 8010b70:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 8010b72:	68fb      	ldr	r3, [r7, #12]
 8010b74:	2200      	movs	r2, #0
 8010b76:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
  return tbl;
 8010b7a:	68fb      	ldr	r3, [r7, #12]
}
 8010b7c:	4618      	mov	r0, r3
 8010b7e:	3710      	adds	r7, #16
 8010b80:	46bd      	mov	sp, r7
 8010b82:	bd80      	pop	{r7, pc}

08010b84 <jpeg_CreateDecompress>:
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
 8010b84:	b580      	push	{r7, lr}
 8010b86:	b088      	sub	sp, #32
 8010b88:	af00      	add	r7, sp, #0
 8010b8a:	60f8      	str	r0, [r7, #12]
 8010b8c:	60b9      	str	r1, [r7, #8]
 8010b8e:	607a      	str	r2, [r7, #4]
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
 8010b90:	68fb      	ldr	r3, [r7, #12]
 8010b92:	2200      	movs	r2, #0
 8010b94:	605a      	str	r2, [r3, #4]
  if (version != JPEG_LIB_VERSION)
 8010b96:	68bb      	ldr	r3, [r7, #8]
 8010b98:	2b50      	cmp	r3, #80	@ 0x50
 8010b9a:	d010      	beq.n	8010bbe <jpeg_CreateDecompress+0x3a>
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
 8010b9c:	68fb      	ldr	r3, [r7, #12]
 8010b9e:	681b      	ldr	r3, [r3, #0]
 8010ba0:	220d      	movs	r2, #13
 8010ba2:	615a      	str	r2, [r3, #20]
 8010ba4:	68fb      	ldr	r3, [r7, #12]
 8010ba6:	681b      	ldr	r3, [r3, #0]
 8010ba8:	2250      	movs	r2, #80	@ 0x50
 8010baa:	619a      	str	r2, [r3, #24]
 8010bac:	68fb      	ldr	r3, [r7, #12]
 8010bae:	681b      	ldr	r3, [r3, #0]
 8010bb0:	68ba      	ldr	r2, [r7, #8]
 8010bb2:	61da      	str	r2, [r3, #28]
 8010bb4:	68fb      	ldr	r3, [r7, #12]
 8010bb6:	681b      	ldr	r3, [r3, #0]
 8010bb8:	681b      	ldr	r3, [r3, #0]
 8010bba:	68f8      	ldr	r0, [r7, #12]
 8010bbc:	4798      	blx	r3
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
 8010bbe:	687b      	ldr	r3, [r7, #4]
 8010bc0:	f5b3 7ff4 	cmp.w	r3, #488	@ 0x1e8
 8010bc4:	d011      	beq.n	8010bea <jpeg_CreateDecompress+0x66>
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
 8010bc6:	68fb      	ldr	r3, [r7, #12]
 8010bc8:	681b      	ldr	r3, [r3, #0]
 8010bca:	2216      	movs	r2, #22
 8010bcc:	615a      	str	r2, [r3, #20]
 8010bce:	68fb      	ldr	r3, [r7, #12]
 8010bd0:	681b      	ldr	r3, [r3, #0]
 8010bd2:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8010bd6:	619a      	str	r2, [r3, #24]
 8010bd8:	68fb      	ldr	r3, [r7, #12]
 8010bda:	681b      	ldr	r3, [r3, #0]
 8010bdc:	687a      	ldr	r2, [r7, #4]
 8010bde:	61da      	str	r2, [r3, #28]
 8010be0:	68fb      	ldr	r3, [r7, #12]
 8010be2:	681b      	ldr	r3, [r3, #0]
 8010be4:	681b      	ldr	r3, [r3, #0]
 8010be6:	68f8      	ldr	r0, [r7, #12]
 8010be8:	4798      	blx	r3
   * client_data, so we have to save and restore those fields.
   * Note: if application hasn't set client_data, tools like Purify may
   * complain here.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
 8010bea:	68fb      	ldr	r3, [r7, #12]
 8010bec:	681b      	ldr	r3, [r3, #0]
 8010bee:	61bb      	str	r3, [r7, #24]
    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
 8010bf0:	68fb      	ldr	r3, [r7, #12]
 8010bf2:	68db      	ldr	r3, [r3, #12]
 8010bf4:	617b      	str	r3, [r7, #20]
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
 8010bf6:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8010bfa:	2100      	movs	r1, #0
 8010bfc:	68f8      	ldr	r0, [r7, #12]
 8010bfe:	f01c fdf8 	bl	802d7f2 <memset>
    cinfo->err = err;
 8010c02:	68fb      	ldr	r3, [r7, #12]
 8010c04:	69ba      	ldr	r2, [r7, #24]
 8010c06:	601a      	str	r2, [r3, #0]
    cinfo->client_data = client_data;
 8010c08:	68fb      	ldr	r3, [r7, #12]
 8010c0a:	697a      	ldr	r2, [r7, #20]
 8010c0c:	60da      	str	r2, [r3, #12]
  }
  cinfo->is_decompressor = TRUE;
 8010c0e:	68fb      	ldr	r3, [r7, #12]
 8010c10:	2201      	movs	r2, #1
 8010c12:	611a      	str	r2, [r3, #16]

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);
 8010c14:	68f8      	ldr	r0, [r7, #12]
 8010c16:	f019 fc8d 	bl	802a534 <jinit_memory_mgr>

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
 8010c1a:	68fb      	ldr	r3, [r7, #12]
 8010c1c:	2200      	movs	r2, #0
 8010c1e:	609a      	str	r2, [r3, #8]
  cinfo->src = NULL;
 8010c20:	68fb      	ldr	r3, [r7, #12]
 8010c22:	2200      	movs	r2, #0
 8010c24:	619a      	str	r2, [r3, #24]

  for (i = 0; i < NUM_QUANT_TBLS; i++)
 8010c26:	2300      	movs	r3, #0
 8010c28:	61fb      	str	r3, [r7, #28]
 8010c2a:	e009      	b.n	8010c40 <jpeg_CreateDecompress+0xbc>
    cinfo->quant_tbl_ptrs[i] = NULL;
 8010c2c:	68fa      	ldr	r2, [r7, #12]
 8010c2e:	69fb      	ldr	r3, [r7, #28]
 8010c30:	3328      	adds	r3, #40	@ 0x28
 8010c32:	009b      	lsls	r3, r3, #2
 8010c34:	4413      	add	r3, r2
 8010c36:	2200      	movs	r2, #0
 8010c38:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_QUANT_TBLS; i++)
 8010c3a:	69fb      	ldr	r3, [r7, #28]
 8010c3c:	3301      	adds	r3, #1
 8010c3e:	61fb      	str	r3, [r7, #28]
 8010c40:	69fb      	ldr	r3, [r7, #28]
 8010c42:	2b03      	cmp	r3, #3
 8010c44:	ddf2      	ble.n	8010c2c <jpeg_CreateDecompress+0xa8>

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8010c46:	2300      	movs	r3, #0
 8010c48:	61fb      	str	r3, [r7, #28]
 8010c4a:	e010      	b.n	8010c6e <jpeg_CreateDecompress+0xea>
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
 8010c4c:	68fa      	ldr	r2, [r7, #12]
 8010c4e:	69fb      	ldr	r3, [r7, #28]
 8010c50:	332c      	adds	r3, #44	@ 0x2c
 8010c52:	009b      	lsls	r3, r3, #2
 8010c54:	4413      	add	r3, r2
 8010c56:	2200      	movs	r2, #0
 8010c58:	605a      	str	r2, [r3, #4]
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
 8010c5a:	68fa      	ldr	r2, [r7, #12]
 8010c5c:	69fb      	ldr	r3, [r7, #28]
 8010c5e:	3330      	adds	r3, #48	@ 0x30
 8010c60:	009b      	lsls	r3, r3, #2
 8010c62:	4413      	add	r3, r2
 8010c64:	2200      	movs	r2, #0
 8010c66:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8010c68:	69fb      	ldr	r3, [r7, #28]
 8010c6a:	3301      	adds	r3, #1
 8010c6c:	61fb      	str	r3, [r7, #28]
 8010c6e:	69fb      	ldr	r3, [r7, #28]
 8010c70:	2b03      	cmp	r3, #3
 8010c72:	ddeb      	ble.n	8010c4c <jpeg_CreateDecompress+0xc8>
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  cinfo->marker_list = NULL;
 8010c74:	68fb      	ldr	r3, [r7, #12]
 8010c76:	2200      	movs	r2, #0
 8010c78:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
  jinit_marker_reader(cinfo);
 8010c7c:	68f8      	ldr	r0, [r7, #12]
 8010c7e:	f009 fdd9 	bl	801a834 <jinit_marker_reader>

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);
 8010c82:	68f8      	ldr	r0, [r7, #12]
 8010c84:	f006 ffde 	bl	8017c44 <jinit_input_controller>

  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
 8010c88:	68fb      	ldr	r3, [r7, #12]
 8010c8a:	22c8      	movs	r2, #200	@ 0xc8
 8010c8c:	615a      	str	r2, [r3, #20]
}
 8010c8e:	bf00      	nop
 8010c90:	3720      	adds	r7, #32
 8010c92:	46bd      	mov	sp, r7
 8010c94:	bd80      	pop	{r7, pc}

08010c96 <jpeg_destroy_decompress>:
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
 8010c96:	b580      	push	{r7, lr}
 8010c98:	b082      	sub	sp, #8
 8010c9a:	af00      	add	r7, sp, #0
 8010c9c:	6078      	str	r0, [r7, #4]
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
 8010c9e:	6878      	ldr	r0, [r7, #4]
 8010ca0:	f7ff ff2e 	bl	8010b00 <jpeg_destroy>
}
 8010ca4:	bf00      	nop
 8010ca6:	3708      	adds	r7, #8
 8010ca8:	46bd      	mov	sp, r7
 8010caa:	bd80      	pop	{r7, pc}

08010cac <default_decompress_parms>:
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
 8010cac:	b580      	push	{r7, lr}
 8010cae:	b086      	sub	sp, #24
 8010cb0:	af00      	add	r7, sp, #0
 8010cb2:	6078      	str	r0, [r7, #4]
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
 8010cb4:	687b      	ldr	r3, [r7, #4]
 8010cb6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010cb8:	2b04      	cmp	r3, #4
 8010cba:	f000 8097 	beq.w	8010dec <default_decompress_parms+0x140>
 8010cbe:	2b04      	cmp	r3, #4
 8010cc0:	f300 80ca 	bgt.w	8010e58 <default_decompress_parms+0x1ac>
 8010cc4:	2b01      	cmp	r3, #1
 8010cc6:	d002      	beq.n	8010cce <default_decompress_parms+0x22>
 8010cc8:	2b03      	cmp	r3, #3
 8010cca:	d009      	beq.n	8010ce0 <default_decompress_parms+0x34>
 8010ccc:	e0c4      	b.n	8010e58 <default_decompress_parms+0x1ac>
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
 8010cce:	687b      	ldr	r3, [r7, #4]
 8010cd0:	2201      	movs	r2, #1
 8010cd2:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    cinfo->out_color_space = JCS_GRAYSCALE;
 8010cd6:	687b      	ldr	r3, [r7, #4]
 8010cd8:	2201      	movs	r2, #1
 8010cda:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8010cde:	e0c4      	b.n	8010e6a <default_decompress_parms+0x1be>
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
 8010ce0:	687b      	ldr	r3, [r7, #4]
 8010ce2:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8010ce6:	2b00      	cmp	r3, #0
 8010ce8:	d004      	beq.n	8010cf4 <default_decompress_parms+0x48>
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
 8010cea:	687b      	ldr	r3, [r7, #4]
 8010cec:	2203      	movs	r2, #3
 8010cee:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 8010cf2:	e076      	b.n	8010de2 <default_decompress_parms+0x136>
    } else if (cinfo->saw_Adobe_marker) {
 8010cf4:	687b      	ldr	r3, [r7, #4]
 8010cf6:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
 8010cfa:	2b00      	cmp	r3, #0
 8010cfc:	d027      	beq.n	8010d4e <default_decompress_parms+0xa2>
      switch (cinfo->Adobe_transform) {
 8010cfe:	687b      	ldr	r3, [r7, #4]
 8010d00:	f893 312c 	ldrb.w	r3, [r3, #300]	@ 0x12c
 8010d04:	2b00      	cmp	r3, #0
 8010d06:	d002      	beq.n	8010d0e <default_decompress_parms+0x62>
 8010d08:	2b01      	cmp	r3, #1
 8010d0a:	d005      	beq.n	8010d18 <default_decompress_parms+0x6c>
 8010d0c:	e009      	b.n	8010d22 <default_decompress_parms+0x76>
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
 8010d0e:	687b      	ldr	r3, [r7, #4]
 8010d10:	2202      	movs	r2, #2
 8010d12:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010d16:	e064      	b.n	8010de2 <default_decompress_parms+0x136>
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
 8010d18:	687b      	ldr	r3, [r7, #4]
 8010d1a:	2203      	movs	r2, #3
 8010d1c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010d20:	e05f      	b.n	8010de2 <default_decompress_parms+0x136>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 8010d22:	687b      	ldr	r3, [r7, #4]
 8010d24:	681b      	ldr	r3, [r3, #0]
 8010d26:	2274      	movs	r2, #116	@ 0x74
 8010d28:	615a      	str	r2, [r3, #20]
 8010d2a:	687b      	ldr	r3, [r7, #4]
 8010d2c:	f893 212c 	ldrb.w	r2, [r3, #300]	@ 0x12c
 8010d30:	687b      	ldr	r3, [r7, #4]
 8010d32:	681b      	ldr	r3, [r3, #0]
 8010d34:	619a      	str	r2, [r3, #24]
 8010d36:	687b      	ldr	r3, [r7, #4]
 8010d38:	681b      	ldr	r3, [r3, #0]
 8010d3a:	685b      	ldr	r3, [r3, #4]
 8010d3c:	f04f 31ff 	mov.w	r1, #4294967295
 8010d40:	6878      	ldr	r0, [r7, #4]
 8010d42:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 8010d44:	687b      	ldr	r3, [r7, #4]
 8010d46:	2203      	movs	r2, #3
 8010d48:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010d4c:	e049      	b.n	8010de2 <default_decompress_parms+0x136>
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
 8010d4e:	687b      	ldr	r3, [r7, #4]
 8010d50:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8010d54:	681b      	ldr	r3, [r3, #0]
 8010d56:	617b      	str	r3, [r7, #20]
      int cid1 = cinfo->comp_info[1].component_id;
 8010d58:	687b      	ldr	r3, [r7, #4]
 8010d5a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8010d5e:	3358      	adds	r3, #88	@ 0x58
 8010d60:	681b      	ldr	r3, [r3, #0]
 8010d62:	613b      	str	r3, [r7, #16]
      int cid2 = cinfo->comp_info[2].component_id;
 8010d64:	687b      	ldr	r3, [r7, #4]
 8010d66:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8010d6a:	33b0      	adds	r3, #176	@ 0xb0
 8010d6c:	681b      	ldr	r3, [r3, #0]
 8010d6e:	60fb      	str	r3, [r7, #12]

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
 8010d70:	697b      	ldr	r3, [r7, #20]
 8010d72:	2b01      	cmp	r3, #1
 8010d74:	d10a      	bne.n	8010d8c <default_decompress_parms+0xe0>
 8010d76:	693b      	ldr	r3, [r7, #16]
 8010d78:	2b02      	cmp	r3, #2
 8010d7a:	d107      	bne.n	8010d8c <default_decompress_parms+0xe0>
 8010d7c:	68fb      	ldr	r3, [r7, #12]
 8010d7e:	2b03      	cmp	r3, #3
 8010d80:	d104      	bne.n	8010d8c <default_decompress_parms+0xe0>
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
 8010d82:	687b      	ldr	r3, [r7, #4]
 8010d84:	2203      	movs	r2, #3
 8010d86:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 8010d8a:	e02a      	b.n	8010de2 <default_decompress_parms+0x136>
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
 8010d8c:	697b      	ldr	r3, [r7, #20]
 8010d8e:	2b52      	cmp	r3, #82	@ 0x52
 8010d90:	d10a      	bne.n	8010da8 <default_decompress_parms+0xfc>
 8010d92:	693b      	ldr	r3, [r7, #16]
 8010d94:	2b47      	cmp	r3, #71	@ 0x47
 8010d96:	d107      	bne.n	8010da8 <default_decompress_parms+0xfc>
 8010d98:	68fb      	ldr	r3, [r7, #12]
 8010d9a:	2b42      	cmp	r3, #66	@ 0x42
 8010d9c:	d104      	bne.n	8010da8 <default_decompress_parms+0xfc>
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
 8010d9e:	687b      	ldr	r3, [r7, #4]
 8010da0:	2202      	movs	r2, #2
 8010da2:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 8010da6:	e01c      	b.n	8010de2 <default_decompress_parms+0x136>
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
 8010da8:	687b      	ldr	r3, [r7, #4]
 8010daa:	681b      	ldr	r3, [r3, #0]
 8010dac:	3318      	adds	r3, #24
 8010dae:	60bb      	str	r3, [r7, #8]
 8010db0:	68bb      	ldr	r3, [r7, #8]
 8010db2:	697a      	ldr	r2, [r7, #20]
 8010db4:	601a      	str	r2, [r3, #0]
 8010db6:	68bb      	ldr	r3, [r7, #8]
 8010db8:	3304      	adds	r3, #4
 8010dba:	693a      	ldr	r2, [r7, #16]
 8010dbc:	601a      	str	r2, [r3, #0]
 8010dbe:	68bb      	ldr	r3, [r7, #8]
 8010dc0:	3308      	adds	r3, #8
 8010dc2:	68fa      	ldr	r2, [r7, #12]
 8010dc4:	601a      	str	r2, [r3, #0]
 8010dc6:	687b      	ldr	r3, [r7, #4]
 8010dc8:	681b      	ldr	r3, [r3, #0]
 8010dca:	2271      	movs	r2, #113	@ 0x71
 8010dcc:	615a      	str	r2, [r3, #20]
 8010dce:	687b      	ldr	r3, [r7, #4]
 8010dd0:	681b      	ldr	r3, [r3, #0]
 8010dd2:	685b      	ldr	r3, [r3, #4]
 8010dd4:	2101      	movs	r1, #1
 8010dd6:	6878      	ldr	r0, [r7, #4]
 8010dd8:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 8010dda:	687b      	ldr	r3, [r7, #4]
 8010ddc:	2203      	movs	r2, #3
 8010dde:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
 8010de2:	687b      	ldr	r3, [r7, #4]
 8010de4:	2202      	movs	r2, #2
 8010de6:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8010dea:	e03e      	b.n	8010e6a <default_decompress_parms+0x1be>
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
 8010dec:	687b      	ldr	r3, [r7, #4]
 8010dee:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
 8010df2:	2b00      	cmp	r3, #0
 8010df4:	d027      	beq.n	8010e46 <default_decompress_parms+0x19a>
      switch (cinfo->Adobe_transform) {
 8010df6:	687b      	ldr	r3, [r7, #4]
 8010df8:	f893 312c 	ldrb.w	r3, [r3, #300]	@ 0x12c
 8010dfc:	2b00      	cmp	r3, #0
 8010dfe:	d002      	beq.n	8010e06 <default_decompress_parms+0x15a>
 8010e00:	2b02      	cmp	r3, #2
 8010e02:	d005      	beq.n	8010e10 <default_decompress_parms+0x164>
 8010e04:	e009      	b.n	8010e1a <default_decompress_parms+0x16e>
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
 8010e06:	687b      	ldr	r3, [r7, #4]
 8010e08:	2204      	movs	r2, #4
 8010e0a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010e0e:	e01e      	b.n	8010e4e <default_decompress_parms+0x1a2>
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
 8010e10:	687b      	ldr	r3, [r7, #4]
 8010e12:	2205      	movs	r2, #5
 8010e14:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010e18:	e019      	b.n	8010e4e <default_decompress_parms+0x1a2>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 8010e1a:	687b      	ldr	r3, [r7, #4]
 8010e1c:	681b      	ldr	r3, [r3, #0]
 8010e1e:	2274      	movs	r2, #116	@ 0x74
 8010e20:	615a      	str	r2, [r3, #20]
 8010e22:	687b      	ldr	r3, [r7, #4]
 8010e24:	f893 212c 	ldrb.w	r2, [r3, #300]	@ 0x12c
 8010e28:	687b      	ldr	r3, [r7, #4]
 8010e2a:	681b      	ldr	r3, [r3, #0]
 8010e2c:	619a      	str	r2, [r3, #24]
 8010e2e:	687b      	ldr	r3, [r7, #4]
 8010e30:	681b      	ldr	r3, [r3, #0]
 8010e32:	685b      	ldr	r3, [r3, #4]
 8010e34:	f04f 31ff 	mov.w	r1, #4294967295
 8010e38:	6878      	ldr	r0, [r7, #4]
 8010e3a:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
 8010e3c:	687b      	ldr	r3, [r7, #4]
 8010e3e:	2205      	movs	r2, #5
 8010e40:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8010e44:	e003      	b.n	8010e4e <default_decompress_parms+0x1a2>
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
 8010e46:	687b      	ldr	r3, [r7, #4]
 8010e48:	2204      	movs	r2, #4
 8010e4a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    }
    cinfo->out_color_space = JCS_CMYK;
 8010e4e:	687b      	ldr	r3, [r7, #4]
 8010e50:	2204      	movs	r2, #4
 8010e52:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8010e56:	e008      	b.n	8010e6a <default_decompress_parms+0x1be>
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
 8010e58:	687b      	ldr	r3, [r7, #4]
 8010e5a:	2200      	movs	r2, #0
 8010e5c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    cinfo->out_color_space = JCS_UNKNOWN;
 8010e60:	687b      	ldr	r3, [r7, #4]
 8010e62:	2200      	movs	r2, #0
 8010e64:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8010e68:	bf00      	nop
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = cinfo->block_size;		/* 1:1 scaling */
 8010e6a:	687b      	ldr	r3, [r7, #4]
 8010e6c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8010e70:	461a      	mov	r2, r3
 8010e72:	687b      	ldr	r3, [r7, #4]
 8010e74:	62da      	str	r2, [r3, #44]	@ 0x2c
  cinfo->scale_denom = cinfo->block_size;
 8010e76:	687b      	ldr	r3, [r7, #4]
 8010e78:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8010e7c:	461a      	mov	r2, r3
 8010e7e:	687b      	ldr	r3, [r7, #4]
 8010e80:	631a      	str	r2, [r3, #48]	@ 0x30
  cinfo->output_gamma = 1.0;
 8010e82:	6879      	ldr	r1, [r7, #4]
 8010e84:	f04f 0200 	mov.w	r2, #0
 8010e88:	4b18      	ldr	r3, [pc, #96]	@ (8010eec <default_decompress_parms+0x240>)
 8010e8a:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
  cinfo->buffered_image = FALSE;
 8010e8e:	687b      	ldr	r3, [r7, #4]
 8010e90:	2200      	movs	r2, #0
 8010e92:	641a      	str	r2, [r3, #64]	@ 0x40
  cinfo->raw_data_out = FALSE;
 8010e94:	687b      	ldr	r3, [r7, #4]
 8010e96:	2200      	movs	r2, #0
 8010e98:	645a      	str	r2, [r3, #68]	@ 0x44
  cinfo->dct_method = JDCT_DEFAULT;
 8010e9a:	687b      	ldr	r3, [r7, #4]
 8010e9c:	2200      	movs	r2, #0
 8010e9e:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
  cinfo->do_fancy_upsampling = TRUE;
 8010ea2:	687b      	ldr	r3, [r7, #4]
 8010ea4:	2201      	movs	r2, #1
 8010ea6:	64da      	str	r2, [r3, #76]	@ 0x4c
  cinfo->do_block_smoothing = TRUE;
 8010ea8:	687b      	ldr	r3, [r7, #4]
 8010eaa:	2201      	movs	r2, #1
 8010eac:	651a      	str	r2, [r3, #80]	@ 0x50
  cinfo->quantize_colors = FALSE;
 8010eae:	687b      	ldr	r3, [r7, #4]
 8010eb0:	2200      	movs	r2, #0
 8010eb2:	655a      	str	r2, [r3, #84]	@ 0x54
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
 8010eb4:	687b      	ldr	r3, [r7, #4]
 8010eb6:	2202      	movs	r2, #2
 8010eb8:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
 8010ebc:	687b      	ldr	r3, [r7, #4]
 8010ebe:	2201      	movs	r2, #1
 8010ec0:	65da      	str	r2, [r3, #92]	@ 0x5c
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
 8010ec2:	687b      	ldr	r3, [r7, #4]
 8010ec4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8010ec8:	661a      	str	r2, [r3, #96]	@ 0x60
  cinfo->colormap = NULL;
 8010eca:	687b      	ldr	r3, [r7, #4]
 8010ecc:	2200      	movs	r2, #0
 8010ece:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
 8010ed2:	687b      	ldr	r3, [r7, #4]
 8010ed4:	2200      	movs	r2, #0
 8010ed6:	665a      	str	r2, [r3, #100]	@ 0x64
  cinfo->enable_external_quant = FALSE;
 8010ed8:	687b      	ldr	r3, [r7, #4]
 8010eda:	2200      	movs	r2, #0
 8010edc:	669a      	str	r2, [r3, #104]	@ 0x68
  cinfo->enable_2pass_quant = FALSE;
 8010ede:	687b      	ldr	r3, [r7, #4]
 8010ee0:	2200      	movs	r2, #0
 8010ee2:	66da      	str	r2, [r3, #108]	@ 0x6c
}
 8010ee4:	bf00      	nop
 8010ee6:	3718      	adds	r7, #24
 8010ee8:	46bd      	mov	sp, r7
 8010eea:	bd80      	pop	{r7, pc}
 8010eec:	3ff00000 	.word	0x3ff00000

08010ef0 <jpeg_read_header>:
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
 8010ef0:	b580      	push	{r7, lr}
 8010ef2:	b084      	sub	sp, #16
 8010ef4:	af00      	add	r7, sp, #0
 8010ef6:	6078      	str	r0, [r7, #4]
 8010ef8:	6039      	str	r1, [r7, #0]
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
 8010efa:	687b      	ldr	r3, [r7, #4]
 8010efc:	695b      	ldr	r3, [r3, #20]
 8010efe:	2bc8      	cmp	r3, #200	@ 0xc8
 8010f00:	d011      	beq.n	8010f26 <jpeg_read_header+0x36>
      cinfo->global_state != DSTATE_INHEADER)
 8010f02:	687b      	ldr	r3, [r7, #4]
 8010f04:	695b      	ldr	r3, [r3, #20]
  if (cinfo->global_state != DSTATE_START &&
 8010f06:	2bc9      	cmp	r3, #201	@ 0xc9
 8010f08:	d00d      	beq.n	8010f26 <jpeg_read_header+0x36>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 8010f0a:	687b      	ldr	r3, [r7, #4]
 8010f0c:	681b      	ldr	r3, [r3, #0]
 8010f0e:	2215      	movs	r2, #21
 8010f10:	615a      	str	r2, [r3, #20]
 8010f12:	687b      	ldr	r3, [r7, #4]
 8010f14:	681b      	ldr	r3, [r3, #0]
 8010f16:	687a      	ldr	r2, [r7, #4]
 8010f18:	6952      	ldr	r2, [r2, #20]
 8010f1a:	619a      	str	r2, [r3, #24]
 8010f1c:	687b      	ldr	r3, [r7, #4]
 8010f1e:	681b      	ldr	r3, [r3, #0]
 8010f20:	681b      	ldr	r3, [r3, #0]
 8010f22:	6878      	ldr	r0, [r7, #4]
 8010f24:	4798      	blx	r3

  retcode = jpeg_consume_input(cinfo);
 8010f26:	6878      	ldr	r0, [r7, #4]
 8010f28:	f000 f828 	bl	8010f7c <jpeg_consume_input>
 8010f2c:	60f8      	str	r0, [r7, #12]

  switch (retcode) {
 8010f2e:	68fb      	ldr	r3, [r7, #12]
 8010f30:	2b02      	cmp	r3, #2
 8010f32:	d00b      	beq.n	8010f4c <jpeg_read_header+0x5c>
 8010f34:	68fb      	ldr	r3, [r7, #12]
 8010f36:	2b02      	cmp	r3, #2
 8010f38:	dc1b      	bgt.n	8010f72 <jpeg_read_header+0x82>
 8010f3a:	68fb      	ldr	r3, [r7, #12]
 8010f3c:	2b00      	cmp	r3, #0
 8010f3e:	d017      	beq.n	8010f70 <jpeg_read_header+0x80>
 8010f40:	68fb      	ldr	r3, [r7, #12]
 8010f42:	2b01      	cmp	r3, #1
 8010f44:	d115      	bne.n	8010f72 <jpeg_read_header+0x82>
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
 8010f46:	2301      	movs	r3, #1
 8010f48:	60fb      	str	r3, [r7, #12]
    break;
 8010f4a:	e012      	b.n	8010f72 <jpeg_read_header+0x82>
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
 8010f4c:	683b      	ldr	r3, [r7, #0]
 8010f4e:	2b00      	cmp	r3, #0
 8010f50:	d008      	beq.n	8010f64 <jpeg_read_header+0x74>
      ERREXIT(cinfo, JERR_NO_IMAGE);
 8010f52:	687b      	ldr	r3, [r7, #4]
 8010f54:	681b      	ldr	r3, [r3, #0]
 8010f56:	2235      	movs	r2, #53	@ 0x35
 8010f58:	615a      	str	r2, [r3, #20]
 8010f5a:	687b      	ldr	r3, [r7, #4]
 8010f5c:	681b      	ldr	r3, [r3, #0]
 8010f5e:	681b      	ldr	r3, [r3, #0]
 8010f60:	6878      	ldr	r0, [r7, #4]
 8010f62:	4798      	blx	r3
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
 8010f64:	6878      	ldr	r0, [r7, #4]
 8010f66:	f7ff fda0 	bl	8010aaa <jpeg_abort>
    retcode = JPEG_HEADER_TABLES_ONLY;
 8010f6a:	2302      	movs	r3, #2
 8010f6c:	60fb      	str	r3, [r7, #12]
    break;
 8010f6e:	e000      	b.n	8010f72 <jpeg_read_header+0x82>
  case JPEG_SUSPENDED:
    /* no work */
    break;
 8010f70:	bf00      	nop
  }

  return retcode;
 8010f72:	68fb      	ldr	r3, [r7, #12]
}
 8010f74:	4618      	mov	r0, r3
 8010f76:	3710      	adds	r7, #16
 8010f78:	46bd      	mov	sp, r7
 8010f7a:	bd80      	pop	{r7, pc}

08010f7c <jpeg_consume_input>:
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
 8010f7c:	b580      	push	{r7, lr}
 8010f7e:	b084      	sub	sp, #16
 8010f80:	af00      	add	r7, sp, #0
 8010f82:	6078      	str	r0, [r7, #4]
  int retcode = JPEG_SUSPENDED;
 8010f84:	2300      	movs	r3, #0
 8010f86:	60fb      	str	r3, [r7, #12]

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
 8010f88:	687b      	ldr	r3, [r7, #4]
 8010f8a:	695b      	ldr	r3, [r3, #20]
 8010f8c:	3bc8      	subs	r3, #200	@ 0xc8
 8010f8e:	2b0a      	cmp	r3, #10
 8010f90:	d842      	bhi.n	8011018 <jpeg_consume_input+0x9c>
 8010f92:	a201      	add	r2, pc, #4	@ (adr r2, 8010f98 <jpeg_consume_input+0x1c>)
 8010f94:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010f98:	08010fc5 	.word	0x08010fc5
 8010f9c:	08010fe1 	.word	0x08010fe1
 8010fa0:	08011003 	.word	0x08011003
 8010fa4:	08011009 	.word	0x08011009
 8010fa8:	08011009 	.word	0x08011009
 8010fac:	08011009 	.word	0x08011009
 8010fb0:	08011009 	.word	0x08011009
 8010fb4:	08011009 	.word	0x08011009
 8010fb8:	08011009 	.word	0x08011009
 8010fbc:	08011019 	.word	0x08011019
 8010fc0:	08011009 	.word	0x08011009
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
 8010fc4:	687b      	ldr	r3, [r7, #4]
 8010fc6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8010fca:	685b      	ldr	r3, [r3, #4]
 8010fcc:	6878      	ldr	r0, [r7, #4]
 8010fce:	4798      	blx	r3
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
 8010fd0:	687b      	ldr	r3, [r7, #4]
 8010fd2:	699b      	ldr	r3, [r3, #24]
 8010fd4:	689b      	ldr	r3, [r3, #8]
 8010fd6:	6878      	ldr	r0, [r7, #4]
 8010fd8:	4798      	blx	r3
    cinfo->global_state = DSTATE_INHEADER;
 8010fda:	687b      	ldr	r3, [r7, #4]
 8010fdc:	22c9      	movs	r2, #201	@ 0xc9
 8010fde:	615a      	str	r2, [r3, #20]
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 8010fe0:	687b      	ldr	r3, [r7, #4]
 8010fe2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8010fe6:	681b      	ldr	r3, [r3, #0]
 8010fe8:	6878      	ldr	r0, [r7, #4]
 8010fea:	4798      	blx	r3
 8010fec:	60f8      	str	r0, [r7, #12]
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
 8010fee:	68fb      	ldr	r3, [r7, #12]
 8010ff0:	2b01      	cmp	r3, #1
 8010ff2:	d120      	bne.n	8011036 <jpeg_consume_input+0xba>
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
 8010ff4:	6878      	ldr	r0, [r7, #4]
 8010ff6:	f7ff fe59 	bl	8010cac <default_decompress_parms>
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
 8010ffa:	687b      	ldr	r3, [r7, #4]
 8010ffc:	22ca      	movs	r2, #202	@ 0xca
 8010ffe:	615a      	str	r2, [r3, #20]
    }
    break;
 8011000:	e019      	b.n	8011036 <jpeg_consume_input+0xba>
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
 8011002:	2301      	movs	r3, #1
 8011004:	60fb      	str	r3, [r7, #12]
    break;
 8011006:	e017      	b.n	8011038 <jpeg_consume_input+0xbc>
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 8011008:	687b      	ldr	r3, [r7, #4]
 801100a:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801100e:	681b      	ldr	r3, [r3, #0]
 8011010:	6878      	ldr	r0, [r7, #4]
 8011012:	4798      	blx	r3
 8011014:	60f8      	str	r0, [r7, #12]
    break;
 8011016:	e00f      	b.n	8011038 <jpeg_consume_input+0xbc>
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 8011018:	687b      	ldr	r3, [r7, #4]
 801101a:	681b      	ldr	r3, [r3, #0]
 801101c:	2215      	movs	r2, #21
 801101e:	615a      	str	r2, [r3, #20]
 8011020:	687b      	ldr	r3, [r7, #4]
 8011022:	681b      	ldr	r3, [r3, #0]
 8011024:	687a      	ldr	r2, [r7, #4]
 8011026:	6952      	ldr	r2, [r2, #20]
 8011028:	619a      	str	r2, [r3, #24]
 801102a:	687b      	ldr	r3, [r7, #4]
 801102c:	681b      	ldr	r3, [r3, #0]
 801102e:	681b      	ldr	r3, [r3, #0]
 8011030:	6878      	ldr	r0, [r7, #4]
 8011032:	4798      	blx	r3
 8011034:	e000      	b.n	8011038 <jpeg_consume_input+0xbc>
    break;
 8011036:	bf00      	nop
  }
  return retcode;
 8011038:	68fb      	ldr	r3, [r7, #12]
}
 801103a:	4618      	mov	r0, r3
 801103c:	3710      	adds	r7, #16
 801103e:	46bd      	mov	sp, r7
 8011040:	bd80      	pop	{r7, pc}
 8011042:	bf00      	nop

08011044 <jpeg_finish_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
 8011044:	b580      	push	{r7, lr}
 8011046:	b082      	sub	sp, #8
 8011048:	af00      	add	r7, sp, #0
 801104a:	6078      	str	r0, [r7, #4]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 801104c:	687b      	ldr	r3, [r7, #4]
 801104e:	695b      	ldr	r3, [r3, #20]
 8011050:	2bcd      	cmp	r3, #205	@ 0xcd
 8011052:	d003      	beq.n	801105c <jpeg_finish_decompress+0x18>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 8011054:	687b      	ldr	r3, [r7, #4]
 8011056:	695b      	ldr	r3, [r3, #20]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 8011058:	2bce      	cmp	r3, #206	@ 0xce
 801105a:	d11d      	bne.n	8011098 <jpeg_finish_decompress+0x54>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 801105c:	687b      	ldr	r3, [r7, #4]
 801105e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011060:	2b00      	cmp	r3, #0
 8011062:	d119      	bne.n	8011098 <jpeg_finish_decompress+0x54>
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
 8011064:	687b      	ldr	r3, [r7, #4]
 8011066:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 801106a:	687b      	ldr	r3, [r7, #4]
 801106c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801106e:	429a      	cmp	r2, r3
 8011070:	d208      	bcs.n	8011084 <jpeg_finish_decompress+0x40>
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
 8011072:	687b      	ldr	r3, [r7, #4]
 8011074:	681b      	ldr	r3, [r3, #0]
 8011076:	2245      	movs	r2, #69	@ 0x45
 8011078:	615a      	str	r2, [r3, #20]
 801107a:	687b      	ldr	r3, [r7, #4]
 801107c:	681b      	ldr	r3, [r3, #0]
 801107e:	681b      	ldr	r3, [r3, #0]
 8011080:	6878      	ldr	r0, [r7, #4]
 8011082:	4798      	blx	r3
    (*cinfo->master->finish_output_pass) (cinfo);
 8011084:	687b      	ldr	r3, [r7, #4]
 8011086:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801108a:	685b      	ldr	r3, [r3, #4]
 801108c:	6878      	ldr	r0, [r7, #4]
 801108e:	4798      	blx	r3
    cinfo->global_state = DSTATE_STOPPING;
 8011090:	687b      	ldr	r3, [r7, #4]
 8011092:	22d2      	movs	r2, #210	@ 0xd2
 8011094:	615a      	str	r2, [r3, #20]
 8011096:	e019      	b.n	80110cc <jpeg_finish_decompress+0x88>
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
 8011098:	687b      	ldr	r3, [r7, #4]
 801109a:	695b      	ldr	r3, [r3, #20]
 801109c:	2bcf      	cmp	r3, #207	@ 0xcf
 801109e:	d103      	bne.n	80110a8 <jpeg_finish_decompress+0x64>
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
 80110a0:	687b      	ldr	r3, [r7, #4]
 80110a2:	22d2      	movs	r2, #210	@ 0xd2
 80110a4:	615a      	str	r2, [r3, #20]
 80110a6:	e01d      	b.n	80110e4 <jpeg_finish_decompress+0xa0>
  } else if (cinfo->global_state != DSTATE_STOPPING) {
 80110a8:	687b      	ldr	r3, [r7, #4]
 80110aa:	695b      	ldr	r3, [r3, #20]
 80110ac:	2bd2      	cmp	r3, #210	@ 0xd2
 80110ae:	d019      	beq.n	80110e4 <jpeg_finish_decompress+0xa0>
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80110b0:	687b      	ldr	r3, [r7, #4]
 80110b2:	681b      	ldr	r3, [r3, #0]
 80110b4:	2215      	movs	r2, #21
 80110b6:	615a      	str	r2, [r3, #20]
 80110b8:	687b      	ldr	r3, [r7, #4]
 80110ba:	681b      	ldr	r3, [r3, #0]
 80110bc:	687a      	ldr	r2, [r7, #4]
 80110be:	6952      	ldr	r2, [r2, #20]
 80110c0:	619a      	str	r2, [r3, #24]
 80110c2:	687b      	ldr	r3, [r7, #4]
 80110c4:	681b      	ldr	r3, [r3, #0]
 80110c6:	681b      	ldr	r3, [r3, #0]
 80110c8:	6878      	ldr	r0, [r7, #4]
 80110ca:	4798      	blx	r3
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
 80110cc:	e00a      	b.n	80110e4 <jpeg_finish_decompress+0xa0>
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
 80110ce:	687b      	ldr	r3, [r7, #4]
 80110d0:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80110d4:	681b      	ldr	r3, [r3, #0]
 80110d6:	6878      	ldr	r0, [r7, #4]
 80110d8:	4798      	blx	r3
 80110da:	4603      	mov	r3, r0
 80110dc:	2b00      	cmp	r3, #0
 80110de:	d101      	bne.n	80110e4 <jpeg_finish_decompress+0xa0>
      return FALSE;		/* Suspend, come back later */
 80110e0:	2300      	movs	r3, #0
 80110e2:	e00e      	b.n	8011102 <jpeg_finish_decompress+0xbe>
  while (! cinfo->inputctl->eoi_reached) {
 80110e4:	687b      	ldr	r3, [r7, #4]
 80110e6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80110ea:	695b      	ldr	r3, [r3, #20]
 80110ec:	2b00      	cmp	r3, #0
 80110ee:	d0ee      	beq.n	80110ce <jpeg_finish_decompress+0x8a>
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
 80110f0:	687b      	ldr	r3, [r7, #4]
 80110f2:	699b      	ldr	r3, [r3, #24]
 80110f4:	699b      	ldr	r3, [r3, #24]
 80110f6:	6878      	ldr	r0, [r7, #4]
 80110f8:	4798      	blx	r3
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
 80110fa:	6878      	ldr	r0, [r7, #4]
 80110fc:	f7ff fcd5 	bl	8010aaa <jpeg_abort>
  return TRUE;
 8011100:	2301      	movs	r3, #1
}
 8011102:	4618      	mov	r0, r3
 8011104:	3708      	adds	r7, #8
 8011106:	46bd      	mov	sp, r7
 8011108:	bd80      	pop	{r7, pc}

0801110a <jpeg_start_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
 801110a:	b580      	push	{r7, lr}
 801110c:	b084      	sub	sp, #16
 801110e:	af00      	add	r7, sp, #0
 8011110:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state == DSTATE_READY) {
 8011112:	687b      	ldr	r3, [r7, #4]
 8011114:	695b      	ldr	r3, [r3, #20]
 8011116:	2bca      	cmp	r3, #202	@ 0xca
 8011118:	d10e      	bne.n	8011138 <jpeg_start_decompress+0x2e>
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
 801111a:	6878      	ldr	r0, [r7, #4]
 801111c:	f009 fff0 	bl	801b100 <jinit_master_decompress>
    if (cinfo->buffered_image) {
 8011120:	687b      	ldr	r3, [r7, #4]
 8011122:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011124:	2b00      	cmp	r3, #0
 8011126:	d004      	beq.n	8011132 <jpeg_start_decompress+0x28>
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
 8011128:	687b      	ldr	r3, [r7, #4]
 801112a:	22cf      	movs	r2, #207	@ 0xcf
 801112c:	615a      	str	r2, [r3, #20]
      return TRUE;
 801112e:	2301      	movs	r3, #1
 8011130:	e063      	b.n	80111fa <jpeg_start_decompress+0xf0>
    }
    cinfo->global_state = DSTATE_PRELOAD;
 8011132:	687b      	ldr	r3, [r7, #4]
 8011134:	22cb      	movs	r2, #203	@ 0xcb
 8011136:	615a      	str	r2, [r3, #20]
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
 8011138:	687b      	ldr	r3, [r7, #4]
 801113a:	695b      	ldr	r3, [r3, #20]
 801113c:	2bcb      	cmp	r3, #203	@ 0xcb
 801113e:	d146      	bne.n	80111ce <jpeg_start_decompress+0xc4>
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
 8011140:	687b      	ldr	r3, [r7, #4]
 8011142:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8011146:	691b      	ldr	r3, [r3, #16]
 8011148:	2b00      	cmp	r3, #0
 801114a:	d039      	beq.n	80111c0 <jpeg_start_decompress+0xb6>
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
 801114c:	687b      	ldr	r3, [r7, #4]
 801114e:	689b      	ldr	r3, [r3, #8]
 8011150:	2b00      	cmp	r3, #0
 8011152:	d004      	beq.n	801115e <jpeg_start_decompress+0x54>
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 8011154:	687b      	ldr	r3, [r7, #4]
 8011156:	689b      	ldr	r3, [r3, #8]
 8011158:	681b      	ldr	r3, [r3, #0]
 801115a:	6878      	ldr	r0, [r7, #4]
 801115c:	4798      	blx	r3
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
 801115e:	687b      	ldr	r3, [r7, #4]
 8011160:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8011164:	681b      	ldr	r3, [r3, #0]
 8011166:	6878      	ldr	r0, [r7, #4]
 8011168:	4798      	blx	r3
 801116a:	60f8      	str	r0, [r7, #12]
	if (retcode == JPEG_SUSPENDED)
 801116c:	68fb      	ldr	r3, [r7, #12]
 801116e:	2b00      	cmp	r3, #0
 8011170:	d101      	bne.n	8011176 <jpeg_start_decompress+0x6c>
	  return FALSE;
 8011172:	2300      	movs	r3, #0
 8011174:	e041      	b.n	80111fa <jpeg_start_decompress+0xf0>
	if (retcode == JPEG_REACHED_EOI)
 8011176:	68fb      	ldr	r3, [r7, #12]
 8011178:	2b02      	cmp	r3, #2
 801117a:	d020      	beq.n	80111be <jpeg_start_decompress+0xb4>
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
 801117c:	687b      	ldr	r3, [r7, #4]
 801117e:	689b      	ldr	r3, [r3, #8]
 8011180:	2b00      	cmp	r3, #0
 8011182:	d0e3      	beq.n	801114c <jpeg_start_decompress+0x42>
 8011184:	68fb      	ldr	r3, [r7, #12]
 8011186:	2b03      	cmp	r3, #3
 8011188:	d002      	beq.n	8011190 <jpeg_start_decompress+0x86>
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
 801118a:	68fb      	ldr	r3, [r7, #12]
 801118c:	2b01      	cmp	r3, #1
 801118e:	d1dd      	bne.n	801114c <jpeg_start_decompress+0x42>
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
 8011190:	687b      	ldr	r3, [r7, #4]
 8011192:	689b      	ldr	r3, [r3, #8]
 8011194:	685a      	ldr	r2, [r3, #4]
 8011196:	3201      	adds	r2, #1
 8011198:	605a      	str	r2, [r3, #4]
 801119a:	685a      	ldr	r2, [r3, #4]
 801119c:	687b      	ldr	r3, [r7, #4]
 801119e:	689b      	ldr	r3, [r3, #8]
 80111a0:	689b      	ldr	r3, [r3, #8]
 80111a2:	429a      	cmp	r2, r3
 80111a4:	dbd2      	blt.n	801114c <jpeg_start_decompress+0x42>
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
 80111a6:	687b      	ldr	r3, [r7, #4]
 80111a8:	689b      	ldr	r3, [r3, #8]
 80111aa:	689a      	ldr	r2, [r3, #8]
 80111ac:	687b      	ldr	r3, [r7, #4]
 80111ae:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80111b2:	4619      	mov	r1, r3
 80111b4:	687b      	ldr	r3, [r7, #4]
 80111b6:	689b      	ldr	r3, [r3, #8]
 80111b8:	440a      	add	r2, r1
 80111ba:	609a      	str	r2, [r3, #8]
      for (;;) {
 80111bc:	e7c6      	b.n	801114c <jpeg_start_decompress+0x42>
	  break;
 80111be:	bf00      	nop
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
 80111c0:	687b      	ldr	r3, [r7, #4]
 80111c2:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80111c6:	687b      	ldr	r3, [r7, #4]
 80111c8:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 80111cc:	e011      	b.n	80111f2 <jpeg_start_decompress+0xe8>
  } else if (cinfo->global_state != DSTATE_PRESCAN)
 80111ce:	687b      	ldr	r3, [r7, #4]
 80111d0:	695b      	ldr	r3, [r3, #20]
 80111d2:	2bcc      	cmp	r3, #204	@ 0xcc
 80111d4:	d00d      	beq.n	80111f2 <jpeg_start_decompress+0xe8>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80111d6:	687b      	ldr	r3, [r7, #4]
 80111d8:	681b      	ldr	r3, [r3, #0]
 80111da:	2215      	movs	r2, #21
 80111dc:	615a      	str	r2, [r3, #20]
 80111de:	687b      	ldr	r3, [r7, #4]
 80111e0:	681b      	ldr	r3, [r3, #0]
 80111e2:	687a      	ldr	r2, [r7, #4]
 80111e4:	6952      	ldr	r2, [r2, #20]
 80111e6:	619a      	str	r2, [r3, #24]
 80111e8:	687b      	ldr	r3, [r7, #4]
 80111ea:	681b      	ldr	r3, [r3, #0]
 80111ec:	681b      	ldr	r3, [r3, #0]
 80111ee:	6878      	ldr	r0, [r7, #4]
 80111f0:	4798      	blx	r3
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
 80111f2:	6878      	ldr	r0, [r7, #4]
 80111f4:	f000 f805 	bl	8011202 <output_pass_setup>
 80111f8:	4603      	mov	r3, r0
}
 80111fa:	4618      	mov	r0, r3
 80111fc:	3710      	adds	r7, #16
 80111fe:	46bd      	mov	sp, r7
 8011200:	bd80      	pop	{r7, pc}

08011202 <output_pass_setup>:
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
 8011202:	b590      	push	{r4, r7, lr}
 8011204:	b085      	sub	sp, #20
 8011206:	af00      	add	r7, sp, #0
 8011208:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state != DSTATE_PRESCAN) {
 801120a:	687b      	ldr	r3, [r7, #4]
 801120c:	695b      	ldr	r3, [r3, #20]
 801120e:	2bcc      	cmp	r3, #204	@ 0xcc
 8011210:	d04f      	beq.n	80112b2 <output_pass_setup+0xb0>
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 8011212:	687b      	ldr	r3, [r7, #4]
 8011214:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8011218:	681b      	ldr	r3, [r3, #0]
 801121a:	6878      	ldr	r0, [r7, #4]
 801121c:	4798      	blx	r3
    cinfo->output_scanline = 0;
 801121e:	687b      	ldr	r3, [r7, #4]
 8011220:	2200      	movs	r2, #0
 8011222:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    cinfo->global_state = DSTATE_PRESCAN;
 8011226:	687b      	ldr	r3, [r7, #4]
 8011228:	22cc      	movs	r2, #204	@ 0xcc
 801122a:	615a      	str	r2, [r3, #20]
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
 801122c:	e041      	b.n	80112b2 <output_pass_setup+0xb0>
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
 801122e:	687b      	ldr	r3, [r7, #4]
 8011230:	689b      	ldr	r3, [r3, #8]
 8011232:	2b00      	cmp	r3, #0
 8011234:	d00f      	beq.n	8011256 <output_pass_setup+0x54>
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 8011236:	687b      	ldr	r3, [r7, #4]
 8011238:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 801123c:	687b      	ldr	r3, [r7, #4]
 801123e:	689b      	ldr	r3, [r3, #8]
 8011240:	605a      	str	r2, [r3, #4]
	cinfo->progress->pass_limit = (long) cinfo->output_height;
 8011242:	687b      	ldr	r3, [r7, #4]
 8011244:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 8011246:	687b      	ldr	r3, [r7, #4]
 8011248:	689b      	ldr	r3, [r3, #8]
 801124a:	609a      	str	r2, [r3, #8]
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 801124c:	687b      	ldr	r3, [r7, #4]
 801124e:	689b      	ldr	r3, [r3, #8]
 8011250:	681b      	ldr	r3, [r3, #0]
 8011252:	6878      	ldr	r0, [r7, #4]
 8011254:	4798      	blx	r3
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
 8011256:	687b      	ldr	r3, [r7, #4]
 8011258:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 801125c:	60fb      	str	r3, [r7, #12]
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
 801125e:	687b      	ldr	r3, [r7, #4]
 8011260:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8011264:	685c      	ldr	r4, [r3, #4]
 8011266:	687b      	ldr	r3, [r7, #4]
 8011268:	f103 028c 	add.w	r2, r3, #140	@ 0x8c
 801126c:	2300      	movs	r3, #0
 801126e:	2100      	movs	r1, #0
 8011270:	6878      	ldr	r0, [r7, #4]
 8011272:	47a0      	blx	r4
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
 8011274:	687b      	ldr	r3, [r7, #4]
 8011276:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 801127a:	68fa      	ldr	r2, [r7, #12]
 801127c:	429a      	cmp	r2, r3
 801127e:	d101      	bne.n	8011284 <output_pass_setup+0x82>
	return FALSE;		/* No progress made, must suspend */
 8011280:	2300      	movs	r3, #0
 8011282:	e026      	b.n	80112d2 <output_pass_setup+0xd0>
    while (cinfo->output_scanline < cinfo->output_height) {
 8011284:	687b      	ldr	r3, [r7, #4]
 8011286:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 801128a:	687b      	ldr	r3, [r7, #4]
 801128c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801128e:	429a      	cmp	r2, r3
 8011290:	d3cd      	bcc.n	801122e <output_pass_setup+0x2c>
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
 8011292:	687b      	ldr	r3, [r7, #4]
 8011294:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8011298:	685b      	ldr	r3, [r3, #4]
 801129a:	6878      	ldr	r0, [r7, #4]
 801129c:	4798      	blx	r3
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 801129e:	687b      	ldr	r3, [r7, #4]
 80112a0:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 80112a4:	681b      	ldr	r3, [r3, #0]
 80112a6:	6878      	ldr	r0, [r7, #4]
 80112a8:	4798      	blx	r3
    cinfo->output_scanline = 0;
 80112aa:	687b      	ldr	r3, [r7, #4]
 80112ac:	2200      	movs	r2, #0
 80112ae:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  while (cinfo->master->is_dummy_pass) {
 80112b2:	687b      	ldr	r3, [r7, #4]
 80112b4:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 80112b8:	689b      	ldr	r3, [r3, #8]
 80112ba:	2b00      	cmp	r3, #0
 80112bc:	d1e2      	bne.n	8011284 <output_pass_setup+0x82>
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
 80112be:	687b      	ldr	r3, [r7, #4]
 80112c0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80112c2:	2b00      	cmp	r3, #0
 80112c4:	d001      	beq.n	80112ca <output_pass_setup+0xc8>
 80112c6:	22ce      	movs	r2, #206	@ 0xce
 80112c8:	e000      	b.n	80112cc <output_pass_setup+0xca>
 80112ca:	22cd      	movs	r2, #205	@ 0xcd
 80112cc:	687b      	ldr	r3, [r7, #4]
 80112ce:	615a      	str	r2, [r3, #20]
  return TRUE;
 80112d0:	2301      	movs	r3, #1
}
 80112d2:	4618      	mov	r0, r3
 80112d4:	3714      	adds	r7, #20
 80112d6:	46bd      	mov	sp, r7
 80112d8:	bd90      	pop	{r4, r7, pc}

080112da <jpeg_read_scanlines>:
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
 80112da:	b590      	push	{r4, r7, lr}
 80112dc:	b087      	sub	sp, #28
 80112de:	af00      	add	r7, sp, #0
 80112e0:	60f8      	str	r0, [r7, #12]
 80112e2:	60b9      	str	r1, [r7, #8]
 80112e4:	607a      	str	r2, [r7, #4]
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
 80112e6:	68fb      	ldr	r3, [r7, #12]
 80112e8:	695b      	ldr	r3, [r3, #20]
 80112ea:	2bcd      	cmp	r3, #205	@ 0xcd
 80112ec:	d00d      	beq.n	801130a <jpeg_read_scanlines+0x30>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80112ee:	68fb      	ldr	r3, [r7, #12]
 80112f0:	681b      	ldr	r3, [r3, #0]
 80112f2:	2215      	movs	r2, #21
 80112f4:	615a      	str	r2, [r3, #20]
 80112f6:	68fb      	ldr	r3, [r7, #12]
 80112f8:	681b      	ldr	r3, [r3, #0]
 80112fa:	68fa      	ldr	r2, [r7, #12]
 80112fc:	6952      	ldr	r2, [r2, #20]
 80112fe:	619a      	str	r2, [r3, #24]
 8011300:	68fb      	ldr	r3, [r7, #12]
 8011302:	681b      	ldr	r3, [r3, #0]
 8011304:	681b      	ldr	r3, [r3, #0]
 8011306:	68f8      	ldr	r0, [r7, #12]
 8011308:	4798      	blx	r3
  if (cinfo->output_scanline >= cinfo->output_height) {
 801130a:	68fb      	ldr	r3, [r7, #12]
 801130c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8011310:	68fb      	ldr	r3, [r7, #12]
 8011312:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8011314:	429a      	cmp	r2, r3
 8011316:	d30c      	bcc.n	8011332 <jpeg_read_scanlines+0x58>
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
 8011318:	68fb      	ldr	r3, [r7, #12]
 801131a:	681b      	ldr	r3, [r3, #0]
 801131c:	227e      	movs	r2, #126	@ 0x7e
 801131e:	615a      	str	r2, [r3, #20]
 8011320:	68fb      	ldr	r3, [r7, #12]
 8011322:	681b      	ldr	r3, [r3, #0]
 8011324:	685b      	ldr	r3, [r3, #4]
 8011326:	f04f 31ff 	mov.w	r1, #4294967295
 801132a:	68f8      	ldr	r0, [r7, #12]
 801132c:	4798      	blx	r3
    return 0;
 801132e:	2300      	movs	r3, #0
 8011330:	e028      	b.n	8011384 <jpeg_read_scanlines+0xaa>
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
 8011332:	68fb      	ldr	r3, [r7, #12]
 8011334:	689b      	ldr	r3, [r3, #8]
 8011336:	2b00      	cmp	r3, #0
 8011338:	d00f      	beq.n	801135a <jpeg_read_scanlines+0x80>
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 801133a:	68fb      	ldr	r3, [r7, #12]
 801133c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8011340:	68fb      	ldr	r3, [r7, #12]
 8011342:	689b      	ldr	r3, [r3, #8]
 8011344:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->output_height;
 8011346:	68fb      	ldr	r3, [r7, #12]
 8011348:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801134a:	68fb      	ldr	r3, [r7, #12]
 801134c:	689b      	ldr	r3, [r3, #8]
 801134e:	609a      	str	r2, [r3, #8]
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 8011350:	68fb      	ldr	r3, [r7, #12]
 8011352:	689b      	ldr	r3, [r3, #8]
 8011354:	681b      	ldr	r3, [r3, #0]
 8011356:	68f8      	ldr	r0, [r7, #12]
 8011358:	4798      	blx	r3
  }

  /* Process some data */
  row_ctr = 0;
 801135a:	2300      	movs	r3, #0
 801135c:	617b      	str	r3, [r7, #20]
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
 801135e:	68fb      	ldr	r3, [r7, #12]
 8011360:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8011364:	685c      	ldr	r4, [r3, #4]
 8011366:	f107 0214 	add.w	r2, r7, #20
 801136a:	687b      	ldr	r3, [r7, #4]
 801136c:	68b9      	ldr	r1, [r7, #8]
 801136e:	68f8      	ldr	r0, [r7, #12]
 8011370:	47a0      	blx	r4
  cinfo->output_scanline += row_ctr;
 8011372:	68fb      	ldr	r3, [r7, #12]
 8011374:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8011378:	697b      	ldr	r3, [r7, #20]
 801137a:	441a      	add	r2, r3
 801137c:	68fb      	ldr	r3, [r7, #12]
 801137e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  return row_ctr;
 8011382:	697b      	ldr	r3, [r7, #20]
}
 8011384:	4618      	mov	r0, r3
 8011386:	371c      	adds	r7, #28
 8011388:	46bd      	mov	sp, r7
 801138a:	bd90      	pop	{r4, r7, pc}

0801138c <get_byte>:


LOCAL(int)
get_byte (j_decompress_ptr cinfo)
/* Read next input byte; we do not support suspension in this module. */
{
 801138c:	b580      	push	{r7, lr}
 801138e:	b084      	sub	sp, #16
 8011390:	af00      	add	r7, sp, #0
 8011392:	6078      	str	r0, [r7, #4]
  struct jpeg_source_mgr * src = cinfo->src;
 8011394:	687b      	ldr	r3, [r7, #4]
 8011396:	699b      	ldr	r3, [r3, #24]
 8011398:	60fb      	str	r3, [r7, #12]

  if (src->bytes_in_buffer == 0)
 801139a:	68fb      	ldr	r3, [r7, #12]
 801139c:	685b      	ldr	r3, [r3, #4]
 801139e:	2b00      	cmp	r3, #0
 80113a0:	d10f      	bne.n	80113c2 <get_byte+0x36>
    if (! (*src->fill_input_buffer) (cinfo))
 80113a2:	68fb      	ldr	r3, [r7, #12]
 80113a4:	68db      	ldr	r3, [r3, #12]
 80113a6:	6878      	ldr	r0, [r7, #4]
 80113a8:	4798      	blx	r3
 80113aa:	4603      	mov	r3, r0
 80113ac:	2b00      	cmp	r3, #0
 80113ae:	d108      	bne.n	80113c2 <get_byte+0x36>
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
 80113b0:	687b      	ldr	r3, [r7, #4]
 80113b2:	681b      	ldr	r3, [r3, #0]
 80113b4:	2219      	movs	r2, #25
 80113b6:	615a      	str	r2, [r3, #20]
 80113b8:	687b      	ldr	r3, [r7, #4]
 80113ba:	681b      	ldr	r3, [r3, #0]
 80113bc:	681b      	ldr	r3, [r3, #0]
 80113be:	6878      	ldr	r0, [r7, #4]
 80113c0:	4798      	blx	r3
  src->bytes_in_buffer--;
 80113c2:	68fb      	ldr	r3, [r7, #12]
 80113c4:	685b      	ldr	r3, [r3, #4]
 80113c6:	1e5a      	subs	r2, r3, #1
 80113c8:	68fb      	ldr	r3, [r7, #12]
 80113ca:	605a      	str	r2, [r3, #4]
  return GETJOCTET(*src->next_input_byte++);
 80113cc:	68fb      	ldr	r3, [r7, #12]
 80113ce:	681b      	ldr	r3, [r3, #0]
 80113d0:	1c59      	adds	r1, r3, #1
 80113d2:	68fa      	ldr	r2, [r7, #12]
 80113d4:	6011      	str	r1, [r2, #0]
 80113d6:	781b      	ldrb	r3, [r3, #0]
}
 80113d8:	4618      	mov	r0, r3
 80113da:	3710      	adds	r7, #16
 80113dc:	46bd      	mov	sp, r7
 80113de:	bd80      	pop	{r7, pc}

080113e0 <arith_decode>:
 * derived from Markus Kuhn's JBIG implementation.
 */

LOCAL(int)
arith_decode (j_decompress_ptr cinfo, unsigned char *st)
{
 80113e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80113e4:	b083      	sub	sp, #12
 80113e6:	af00      	add	r7, sp, #0
 80113e8:	6078      	str	r0, [r7, #4]
 80113ea:	6039      	str	r1, [r7, #0]
  register arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;
 80113ec:	687b      	ldr	r3, [r7, #4]
 80113ee:	f8d3 41d0 	ldr.w	r4, [r3, #464]	@ 0x1d0
  register unsigned char nl, nm;
  register INT32 qe, temp;
  register int sv, data;

  /* Renormalization & data input per section D.2.6 */
  while (e->a < 0x8000L) {
 80113f2:	e036      	b.n	8011462 <arith_decode+0x82>
    if (--e->ct < 0) {
 80113f4:	6923      	ldr	r3, [r4, #16]
 80113f6:	3b01      	subs	r3, #1
 80113f8:	6123      	str	r3, [r4, #16]
 80113fa:	6923      	ldr	r3, [r4, #16]
 80113fc:	2b00      	cmp	r3, #0
 80113fe:	da2d      	bge.n	801145c <arith_decode+0x7c>
      /* Need to fetch next data byte */
      if (cinfo->unread_marker)
 8011400:	687b      	ldr	r3, [r7, #4]
 8011402:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 8011406:	2b00      	cmp	r3, #0
 8011408:	d001      	beq.n	801140e <arith_decode+0x2e>
	data = 0;		/* stuff zero data */
 801140a:	2500      	movs	r5, #0
 801140c:	e013      	b.n	8011436 <arith_decode+0x56>
      else {
	data = get_byte(cinfo);	/* read next input byte */
 801140e:	6878      	ldr	r0, [r7, #4]
 8011410:	f7ff ffbc 	bl	801138c <get_byte>
 8011414:	4605      	mov	r5, r0
	if (data == 0xFF) {	/* zero stuff or marker code */
 8011416:	2dff      	cmp	r5, #255	@ 0xff
 8011418:	d10d      	bne.n	8011436 <arith_decode+0x56>
	  do data = get_byte(cinfo);
 801141a:	6878      	ldr	r0, [r7, #4]
 801141c:	f7ff ffb6 	bl	801138c <get_byte>
 8011420:	4605      	mov	r5, r0
	  while (data == 0xFF);	/* swallow extra 0xFF bytes */
 8011422:	2dff      	cmp	r5, #255	@ 0xff
 8011424:	d0f9      	beq.n	801141a <arith_decode+0x3a>
	  if (data == 0)
 8011426:	2d00      	cmp	r5, #0
 8011428:	d101      	bne.n	801142e <arith_decode+0x4e>
	    data = 0xFF;	/* discard stuffed zero byte */
 801142a:	25ff      	movs	r5, #255	@ 0xff
 801142c:	e003      	b.n	8011436 <arith_decode+0x56>
	     * a marker while processing the compressed data
	     * segment is legal in arithmetic coding.
	     * The convention is to supply zero data
	     * then until decoding is complete.
	     */
	    cinfo->unread_marker = data;
 801142e:	687b      	ldr	r3, [r7, #4]
 8011430:	f8c3 51b4 	str.w	r5, [r3, #436]	@ 0x1b4
	    data = 0;
 8011434:	2500      	movs	r5, #0
	  }
	}
      }
      e->c = (e->c << 8) | data; /* insert data into C register */
 8011436:	68a3      	ldr	r3, [r4, #8]
 8011438:	021b      	lsls	r3, r3, #8
 801143a:	432b      	orrs	r3, r5
 801143c:	60a3      	str	r3, [r4, #8]
      if ((e->ct += 8) < 0)	 /* update bit shift counter */
 801143e:	6923      	ldr	r3, [r4, #16]
 8011440:	3308      	adds	r3, #8
 8011442:	6123      	str	r3, [r4, #16]
 8011444:	6923      	ldr	r3, [r4, #16]
 8011446:	2b00      	cmp	r3, #0
 8011448:	da08      	bge.n	801145c <arith_decode+0x7c>
	/* Need more initial bytes */
	if (++e->ct == 0)
 801144a:	6923      	ldr	r3, [r4, #16]
 801144c:	3301      	adds	r3, #1
 801144e:	6123      	str	r3, [r4, #16]
 8011450:	6923      	ldr	r3, [r4, #16]
 8011452:	2b00      	cmp	r3, #0
 8011454:	d102      	bne.n	801145c <arith_decode+0x7c>
	  /* Got 2 initial bytes -> re-init A and exit loop */
	  e->a = 0x8000L; /* => e->a = 0x10000L after loop exit */
 8011456:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801145a:	60e3      	str	r3, [r4, #12]
    }
    e->a <<= 1;
 801145c:	68e3      	ldr	r3, [r4, #12]
 801145e:	005b      	lsls	r3, r3, #1
 8011460:	60e3      	str	r3, [r4, #12]
  while (e->a < 0x8000L) {
 8011462:	68e3      	ldr	r3, [r4, #12]
 8011464:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8011468:	dbc4      	blt.n	80113f4 <arith_decode+0x14>
  }

  /* Fetch values from our compact representation of Table D.3(D.2):
   * Qe values and probability estimation state machine
   */
  sv = *st;
 801146a:	683b      	ldr	r3, [r7, #0]
 801146c:	781b      	ldrb	r3, [r3, #0]
 801146e:	461e      	mov	r6, r3
  qe = jpeg_aritab[sv & 0x7F];	/* => Qe_Value */
 8011470:	f006 037f 	and.w	r3, r6, #127	@ 0x7f
 8011474:	4a2c      	ldr	r2, [pc, #176]	@ (8011528 <arith_decode+0x148>)
 8011476:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
  nl = qe & 0xFF; qe >>= 8;	/* Next_Index_LPS + Switch_MPS */
 801147a:	fa5f f985 	uxtb.w	r9, r5
 801147e:	122d      	asrs	r5, r5, #8
  nm = qe & 0xFF; qe >>= 8;	/* Next_Index_MPS */
 8011480:	fa5f f885 	uxtb.w	r8, r5
 8011484:	122d      	asrs	r5, r5, #8

  /* Decode & estimation procedures per sections D.2.4 & D.2.5 */
  temp = e->a - qe;
 8011486:	68e3      	ldr	r3, [r4, #12]
 8011488:	1b5a      	subs	r2, r3, r5
  e->a = temp;
 801148a:	60e2      	str	r2, [r4, #12]
  temp <<= e->ct;
 801148c:	6923      	ldr	r3, [r4, #16]
 801148e:	409a      	lsls	r2, r3
  if (e->c >= temp) {
 8011490:	68a3      	ldr	r3, [r4, #8]
 8011492:	429a      	cmp	r2, r3
 8011494:	dc21      	bgt.n	80114da <arith_decode+0xfa>
    e->c -= temp;
 8011496:	68a3      	ldr	r3, [r4, #8]
 8011498:	1a9b      	subs	r3, r3, r2
 801149a:	60a3      	str	r3, [r4, #8]
    /* Conditional LPS (less probable symbol) exchange */
    if (e->a < qe) {
 801149c:	68e3      	ldr	r3, [r4, #12]
 801149e:	429d      	cmp	r5, r3
 80114a0:	dd0c      	ble.n	80114bc <arith_decode+0xdc>
      e->a = qe;
 80114a2:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 80114a4:	b273      	sxtb	r3, r6
 80114a6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80114aa:	b25a      	sxtb	r2, r3
 80114ac:	fa4f f388 	sxtb.w	r3, r8
 80114b0:	4053      	eors	r3, r2
 80114b2:	b25b      	sxtb	r3, r3
 80114b4:	b2da      	uxtb	r2, r3
 80114b6:	683b      	ldr	r3, [r7, #0]
 80114b8:	701a      	strb	r2, [r3, #0]
 80114ba:	e02e      	b.n	801151a <arith_decode+0x13a>
    } else {
      e->a = qe;
 80114bc:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 80114be:	b273      	sxtb	r3, r6
 80114c0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80114c4:	b25a      	sxtb	r2, r3
 80114c6:	fa4f f389 	sxtb.w	r3, r9
 80114ca:	4053      	eors	r3, r2
 80114cc:	b25b      	sxtb	r3, r3
 80114ce:	b2da      	uxtb	r2, r3
 80114d0:	683b      	ldr	r3, [r7, #0]
 80114d2:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 80114d4:	f086 0680 	eor.w	r6, r6, #128	@ 0x80
 80114d8:	e01f      	b.n	801151a <arith_decode+0x13a>
    }
  } else if (e->a < 0x8000L) {
 80114da:	68e3      	ldr	r3, [r4, #12]
 80114dc:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80114e0:	da1b      	bge.n	801151a <arith_decode+0x13a>
    /* Conditional MPS (more probable symbol) exchange */
    if (e->a < qe) {
 80114e2:	68e3      	ldr	r3, [r4, #12]
 80114e4:	429d      	cmp	r5, r3
 80114e6:	dd0d      	ble.n	8011504 <arith_decode+0x124>
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 80114e8:	b273      	sxtb	r3, r6
 80114ea:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80114ee:	b25a      	sxtb	r2, r3
 80114f0:	fa4f f389 	sxtb.w	r3, r9
 80114f4:	4053      	eors	r3, r2
 80114f6:	b25b      	sxtb	r3, r3
 80114f8:	b2da      	uxtb	r2, r3
 80114fa:	683b      	ldr	r3, [r7, #0]
 80114fc:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 80114fe:	f086 0680 	eor.w	r6, r6, #128	@ 0x80
 8011502:	e00a      	b.n	801151a <arith_decode+0x13a>
    } else {
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 8011504:	b273      	sxtb	r3, r6
 8011506:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801150a:	b25a      	sxtb	r2, r3
 801150c:	fa4f f388 	sxtb.w	r3, r8
 8011510:	4053      	eors	r3, r2
 8011512:	b25b      	sxtb	r3, r3
 8011514:	b2da      	uxtb	r2, r3
 8011516:	683b      	ldr	r3, [r7, #0]
 8011518:	701a      	strb	r2, [r3, #0]
    }
  }

  return sv >> 7;
 801151a:	11f3      	asrs	r3, r6, #7
}
 801151c:	4618      	mov	r0, r3
 801151e:	370c      	adds	r7, #12
 8011520:	46bd      	mov	sp, r7
 8011522:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8011526:	bf00      	nop
 8011528:	0802ff98 	.word	0x0802ff98

0801152c <process_restart>:
 * Check for a restart marker & resynchronize decoder.
 */

LOCAL(void)
process_restart (j_decompress_ptr cinfo)
{
 801152c:	b580      	push	{r7, lr}
 801152e:	b086      	sub	sp, #24
 8011530:	af00      	add	r7, sp, #0
 8011532:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8011534:	687b      	ldr	r3, [r7, #4]
 8011536:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801153a:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 801153c:	687b      	ldr	r3, [r7, #4]
 801153e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8011542:	689b      	ldr	r3, [r3, #8]
 8011544:	6878      	ldr	r0, [r7, #4]
 8011546:	4798      	blx	r3
 8011548:	4603      	mov	r3, r0
 801154a:	2b00      	cmp	r3, #0
 801154c:	d108      	bne.n	8011560 <process_restart+0x34>
    ERREXIT(cinfo, JERR_CANT_SUSPEND);
 801154e:	687b      	ldr	r3, [r7, #4]
 8011550:	681b      	ldr	r3, [r3, #0]
 8011552:	2219      	movs	r2, #25
 8011554:	615a      	str	r2, [r3, #20]
 8011556:	687b      	ldr	r3, [r7, #4]
 8011558:	681b      	ldr	r3, [r3, #0]
 801155a:	681b      	ldr	r3, [r3, #0]
 801155c:	6878      	ldr	r0, [r7, #4]
 801155e:	4798      	blx	r3

  /* Re-initialize statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8011560:	2300      	movs	r3, #0
 8011562:	617b      	str	r3, [r7, #20]
 8011564:	e051      	b.n	801160a <process_restart+0xde>
    compptr = cinfo->cur_comp_info[ci];
 8011566:	687a      	ldr	r2, [r7, #4]
 8011568:	697b      	ldr	r3, [r7, #20]
 801156a:	3354      	adds	r3, #84	@ 0x54
 801156c:	009b      	lsls	r3, r3, #2
 801156e:	4413      	add	r3, r2
 8011570:	685b      	ldr	r3, [r3, #4]
 8011572:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 8011574:	687b      	ldr	r3, [r7, #4]
 8011576:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801157a:	2b00      	cmp	r3, #0
 801157c:	d009      	beq.n	8011592 <process_restart+0x66>
 801157e:	687b      	ldr	r3, [r7, #4]
 8011580:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8011584:	2b00      	cmp	r3, #0
 8011586:	d11d      	bne.n	80115c4 <process_restart+0x98>
 8011588:	687b      	ldr	r3, [r7, #4]
 801158a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801158e:	2b00      	cmp	r3, #0
 8011590:	d118      	bne.n	80115c4 <process_restart+0x98>
      MEMZERO(entropy->dc_stats[compptr->dc_tbl_no], DC_STAT_BINS);
 8011592:	68fb      	ldr	r3, [r7, #12]
 8011594:	695a      	ldr	r2, [r3, #20]
 8011596:	693b      	ldr	r3, [r7, #16]
 8011598:	320e      	adds	r2, #14
 801159a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801159e:	2240      	movs	r2, #64	@ 0x40
 80115a0:	2100      	movs	r1, #0
 80115a2:	4618      	mov	r0, r3
 80115a4:	f01c f925 	bl	802d7f2 <memset>
      /* Reset DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 80115a8:	693a      	ldr	r2, [r7, #16]
 80115aa:	697b      	ldr	r3, [r7, #20]
 80115ac:	3304      	adds	r3, #4
 80115ae:	009b      	lsls	r3, r3, #2
 80115b0:	4413      	add	r3, r2
 80115b2:	2200      	movs	r2, #0
 80115b4:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 80115b6:	693a      	ldr	r2, [r7, #16]
 80115b8:	697b      	ldr	r3, [r7, #20]
 80115ba:	3308      	adds	r3, #8
 80115bc:	009b      	lsls	r3, r3, #2
 80115be:	4413      	add	r3, r2
 80115c0:	2200      	movs	r2, #0
 80115c2:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 80115c4:	687b      	ldr	r3, [r7, #4]
 80115c6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80115ca:	2b00      	cmp	r3, #0
 80115cc:	d104      	bne.n	80115d8 <process_restart+0xac>
 80115ce:	687b      	ldr	r3, [r7, #4]
 80115d0:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80115d4:	2b00      	cmp	r3, #0
 80115d6:	d109      	bne.n	80115ec <process_restart+0xc0>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80115d8:	687b      	ldr	r3, [r7, #4]
 80115da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 80115de:	2b00      	cmp	r3, #0
 80115e0:	d010      	beq.n	8011604 <process_restart+0xd8>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80115e2:	687b      	ldr	r3, [r7, #4]
 80115e4:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80115e8:	2b00      	cmp	r3, #0
 80115ea:	d00b      	beq.n	8011604 <process_restart+0xd8>
      MEMZERO(entropy->ac_stats[compptr->ac_tbl_no], AC_STAT_BINS);
 80115ec:	68fb      	ldr	r3, [r7, #12]
 80115ee:	699a      	ldr	r2, [r3, #24]
 80115f0:	693b      	ldr	r3, [r7, #16]
 80115f2:	321e      	adds	r2, #30
 80115f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80115f8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80115fc:	2100      	movs	r1, #0
 80115fe:	4618      	mov	r0, r3
 8011600:	f01c f8f7 	bl	802d7f2 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8011604:	697b      	ldr	r3, [r7, #20]
 8011606:	3301      	adds	r3, #1
 8011608:	617b      	str	r3, [r7, #20]
 801160a:	687b      	ldr	r3, [r7, #4]
 801160c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8011610:	697a      	ldr	r2, [r7, #20]
 8011612:	429a      	cmp	r2, r3
 8011614:	dba7      	blt.n	8011566 <process_restart+0x3a>
    }
  }

  /* Reset arithmetic decoding variables */
  entropy->c = 0;
 8011616:	693b      	ldr	r3, [r7, #16]
 8011618:	2200      	movs	r2, #0
 801161a:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 801161c:	693b      	ldr	r3, [r7, #16]
 801161e:	2200      	movs	r2, #0
 8011620:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 8011622:	693b      	ldr	r3, [r7, #16]
 8011624:	f06f 020f 	mvn.w	r2, #15
 8011628:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 801162a:	687b      	ldr	r3, [r7, #4]
 801162c:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8011630:	693b      	ldr	r3, [r7, #16]
 8011632:	635a      	str	r2, [r3, #52]	@ 0x34
}
 8011634:	bf00      	nop
 8011636:	3718      	adds	r7, #24
 8011638:	46bd      	mov	sp, r7
 801163a:	bd80      	pop	{r7, pc}

0801163c <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 801163c:	b580      	push	{r7, lr}
 801163e:	b08c      	sub	sp, #48	@ 0x30
 8011640:	af00      	add	r7, sp, #0
 8011642:	6078      	str	r0, [r7, #4]
 8011644:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801164c:	61fb      	str	r3, [r7, #28]
  unsigned char *st;
  int blkn, ci, tbl, sign;
  int v, m;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 801164e:	687b      	ldr	r3, [r7, #4]
 8011650:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8011654:	2b00      	cmp	r3, #0
 8011656:	d00b      	beq.n	8011670 <decode_mcu_DC_first+0x34>
    if (entropy->restarts_to_go == 0)
 8011658:	69fb      	ldr	r3, [r7, #28]
 801165a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801165c:	2b00      	cmp	r3, #0
 801165e:	d102      	bne.n	8011666 <decode_mcu_DC_first+0x2a>
      process_restart(cinfo);
 8011660:	6878      	ldr	r0, [r7, #4]
 8011662:	f7ff ff63 	bl	801152c <process_restart>
    entropy->restarts_to_go--;
 8011666:	69fb      	ldr	r3, [r7, #28]
 8011668:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801166a:	1e5a      	subs	r2, r3, #1
 801166c:	69fb      	ldr	r3, [r7, #28]
 801166e:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8011670:	69fb      	ldr	r3, [r7, #28]
 8011672:	691b      	ldr	r3, [r3, #16]
 8011674:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011678:	d101      	bne.n	801167e <decode_mcu_DC_first+0x42>
 801167a:	2301      	movs	r3, #1
 801167c:	e0ec      	b.n	8011858 <decode_mcu_DC_first+0x21c>

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801167e:	2300      	movs	r3, #0
 8011680:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011682:	e0e1      	b.n	8011848 <decode_mcu_DC_first+0x20c>
    block = MCU_data[blkn];
 8011684:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011686:	009b      	lsls	r3, r3, #2
 8011688:	683a      	ldr	r2, [r7, #0]
 801168a:	4413      	add	r3, r2
 801168c:	681b      	ldr	r3, [r3, #0]
 801168e:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 8011690:	687b      	ldr	r3, [r7, #4]
 8011692:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011694:	325c      	adds	r2, #92	@ 0x5c
 8011696:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801169a:	617b      	str	r3, [r7, #20]
    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;
 801169c:	687a      	ldr	r2, [r7, #4]
 801169e:	697b      	ldr	r3, [r7, #20]
 80116a0:	3354      	adds	r3, #84	@ 0x54
 80116a2:	009b      	lsls	r3, r3, #2
 80116a4:	4413      	add	r3, r2
 80116a6:	685b      	ldr	r3, [r3, #4]
 80116a8:	695b      	ldr	r3, [r3, #20]
 80116aa:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 80116ac:	69fb      	ldr	r3, [r7, #28]
 80116ae:	693a      	ldr	r2, [r7, #16]
 80116b0:	320e      	adds	r2, #14
 80116b2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80116b6:	69f9      	ldr	r1, [r7, #28]
 80116b8:	697b      	ldr	r3, [r7, #20]
 80116ba:	3308      	adds	r3, #8
 80116bc:	009b      	lsls	r3, r3, #2
 80116be:	440b      	add	r3, r1
 80116c0:	685b      	ldr	r3, [r3, #4]
 80116c2:	4413      	add	r3, r2
 80116c4:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 80116c6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80116c8:	6878      	ldr	r0, [r7, #4]
 80116ca:	f7ff fe89 	bl	80113e0 <arith_decode>
 80116ce:	4603      	mov	r3, r0
 80116d0:	2b00      	cmp	r3, #0
 80116d2:	d107      	bne.n	80116e4 <decode_mcu_DC_first+0xa8>
      entropy->dc_context[ci] = 0;
 80116d4:	69fa      	ldr	r2, [r7, #28]
 80116d6:	697b      	ldr	r3, [r7, #20]
 80116d8:	3308      	adds	r3, #8
 80116da:	009b      	lsls	r3, r3, #2
 80116dc:	4413      	add	r3, r2
 80116de:	2200      	movs	r2, #0
 80116e0:	605a      	str	r2, [r3, #4]
 80116e2:	e0a0      	b.n	8011826 <decode_mcu_DC_first+0x1ea>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 80116e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116e6:	3301      	adds	r3, #1
 80116e8:	4619      	mov	r1, r3
 80116ea:	6878      	ldr	r0, [r7, #4]
 80116ec:	f7ff fe78 	bl	80113e0 <arith_decode>
 80116f0:	60f8      	str	r0, [r7, #12]
      st += 2; st += sign;
 80116f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116f4:	3302      	adds	r3, #2
 80116f6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80116f8:	68fb      	ldr	r3, [r7, #12]
 80116fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80116fc:	4413      	add	r3, r2
 80116fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8011700:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011702:	6878      	ldr	r0, [r7, #4]
 8011704:	f7ff fe6c 	bl	80113e0 <arith_decode>
 8011708:	6238      	str	r0, [r7, #32]
 801170a:	6a3b      	ldr	r3, [r7, #32]
 801170c:	2b00      	cmp	r3, #0
 801170e:	d029      	beq.n	8011764 <decode_mcu_DC_first+0x128>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 8011710:	69fb      	ldr	r3, [r7, #28]
 8011712:	693a      	ldr	r2, [r7, #16]
 8011714:	320e      	adds	r2, #14
 8011716:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801171a:	3314      	adds	r3, #20
 801171c:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 801171e:	e01a      	b.n	8011756 <decode_mcu_DC_first+0x11a>
	  if ((m <<= 1) == 0x8000) {
 8011720:	6a3b      	ldr	r3, [r7, #32]
 8011722:	005b      	lsls	r3, r3, #1
 8011724:	623b      	str	r3, [r7, #32]
 8011726:	6a3b      	ldr	r3, [r7, #32]
 8011728:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 801172c:	d110      	bne.n	8011750 <decode_mcu_DC_first+0x114>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 801172e:	687b      	ldr	r3, [r7, #4]
 8011730:	681b      	ldr	r3, [r3, #0]
 8011732:	2275      	movs	r2, #117	@ 0x75
 8011734:	615a      	str	r2, [r3, #20]
 8011736:	687b      	ldr	r3, [r7, #4]
 8011738:	681b      	ldr	r3, [r3, #0]
 801173a:	685b      	ldr	r3, [r3, #4]
 801173c:	f04f 31ff 	mov.w	r1, #4294967295
 8011740:	6878      	ldr	r0, [r7, #4]
 8011742:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 8011744:	69fb      	ldr	r3, [r7, #28]
 8011746:	f04f 32ff 	mov.w	r2, #4294967295
 801174a:	611a      	str	r2, [r3, #16]
	    return TRUE;
 801174c:	2301      	movs	r3, #1
 801174e:	e083      	b.n	8011858 <decode_mcu_DC_first+0x21c>
	  }
	  st += 1;
 8011750:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011752:	3301      	adds	r3, #1
 8011754:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 8011756:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011758:	6878      	ldr	r0, [r7, #4]
 801175a:	f7ff fe41 	bl	80113e0 <arith_decode>
 801175e:	4603      	mov	r3, r0
 8011760:	2b00      	cmp	r3, #0
 8011762:	d1dd      	bne.n	8011720 <decode_mcu_DC_first+0xe4>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 8011764:	687a      	ldr	r2, [r7, #4]
 8011766:	693b      	ldr	r3, [r7, #16]
 8011768:	4413      	add	r3, r2
 801176a:	33e8      	adds	r3, #232	@ 0xe8
 801176c:	781b      	ldrb	r3, [r3, #0]
 801176e:	461a      	mov	r2, r3
 8011770:	2301      	movs	r3, #1
 8011772:	4093      	lsls	r3, r2
 8011774:	105b      	asrs	r3, r3, #1
 8011776:	6a3a      	ldr	r2, [r7, #32]
 8011778:	429a      	cmp	r2, r3
 801177a:	da07      	bge.n	801178c <decode_mcu_DC_first+0x150>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 801177c:	69fa      	ldr	r2, [r7, #28]
 801177e:	697b      	ldr	r3, [r7, #20]
 8011780:	3308      	adds	r3, #8
 8011782:	009b      	lsls	r3, r3, #2
 8011784:	4413      	add	r3, r2
 8011786:	2200      	movs	r2, #0
 8011788:	605a      	str	r2, [r3, #4]
 801178a:	e01e      	b.n	80117ca <decode_mcu_DC_first+0x18e>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 801178c:	687a      	ldr	r2, [r7, #4]
 801178e:	693b      	ldr	r3, [r7, #16]
 8011790:	4413      	add	r3, r2
 8011792:	33f8      	adds	r3, #248	@ 0xf8
 8011794:	781b      	ldrb	r3, [r3, #0]
 8011796:	461a      	mov	r2, r3
 8011798:	2301      	movs	r3, #1
 801179a:	4093      	lsls	r3, r2
 801179c:	105b      	asrs	r3, r3, #1
 801179e:	6a3a      	ldr	r2, [r7, #32]
 80117a0:	429a      	cmp	r2, r3
 80117a2:	dd09      	ble.n	80117b8 <decode_mcu_DC_first+0x17c>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 80117a4:	68fb      	ldr	r3, [r7, #12]
 80117a6:	3303      	adds	r3, #3
 80117a8:	009a      	lsls	r2, r3, #2
 80117aa:	69f9      	ldr	r1, [r7, #28]
 80117ac:	697b      	ldr	r3, [r7, #20]
 80117ae:	3308      	adds	r3, #8
 80117b0:	009b      	lsls	r3, r3, #2
 80117b2:	440b      	add	r3, r1
 80117b4:	605a      	str	r2, [r3, #4]
 80117b6:	e008      	b.n	80117ca <decode_mcu_DC_first+0x18e>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 80117b8:	68fb      	ldr	r3, [r7, #12]
 80117ba:	3301      	adds	r3, #1
 80117bc:	009a      	lsls	r2, r3, #2
 80117be:	69f9      	ldr	r1, [r7, #28]
 80117c0:	697b      	ldr	r3, [r7, #20]
 80117c2:	3308      	adds	r3, #8
 80117c4:	009b      	lsls	r3, r3, #2
 80117c6:	440b      	add	r3, r1
 80117c8:	605a      	str	r2, [r3, #4]
      v = m;
 80117ca:	6a3b      	ldr	r3, [r7, #32]
 80117cc:	627b      	str	r3, [r7, #36]	@ 0x24
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 80117ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117d0:	330e      	adds	r3, #14
 80117d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      while (m >>= 1)
 80117d4:	e00a      	b.n	80117ec <decode_mcu_DC_first+0x1b0>
	if (arith_decode(cinfo, st)) v |= m;
 80117d6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80117d8:	6878      	ldr	r0, [r7, #4]
 80117da:	f7ff fe01 	bl	80113e0 <arith_decode>
 80117de:	4603      	mov	r3, r0
 80117e0:	2b00      	cmp	r3, #0
 80117e2:	d003      	beq.n	80117ec <decode_mcu_DC_first+0x1b0>
 80117e4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80117e6:	6a3b      	ldr	r3, [r7, #32]
 80117e8:	4313      	orrs	r3, r2
 80117ea:	627b      	str	r3, [r7, #36]	@ 0x24
      while (m >>= 1)
 80117ec:	6a3b      	ldr	r3, [r7, #32]
 80117ee:	105b      	asrs	r3, r3, #1
 80117f0:	623b      	str	r3, [r7, #32]
 80117f2:	6a3b      	ldr	r3, [r7, #32]
 80117f4:	2b00      	cmp	r3, #0
 80117f6:	d1ee      	bne.n	80117d6 <decode_mcu_DC_first+0x19a>
      v += 1; if (sign) v = -v;
 80117f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80117fa:	3301      	adds	r3, #1
 80117fc:	627b      	str	r3, [r7, #36]	@ 0x24
 80117fe:	68fb      	ldr	r3, [r7, #12]
 8011800:	2b00      	cmp	r3, #0
 8011802:	d002      	beq.n	801180a <decode_mcu_DC_first+0x1ce>
 8011804:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011806:	425b      	negs	r3, r3
 8011808:	627b      	str	r3, [r7, #36]	@ 0x24
      entropy->last_dc_val[ci] += v;
 801180a:	69fa      	ldr	r2, [r7, #28]
 801180c:	697b      	ldr	r3, [r7, #20]
 801180e:	3304      	adds	r3, #4
 8011810:	009b      	lsls	r3, r3, #2
 8011812:	4413      	add	r3, r2
 8011814:	685a      	ldr	r2, [r3, #4]
 8011816:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011818:	441a      	add	r2, r3
 801181a:	69f9      	ldr	r1, [r7, #28]
 801181c:	697b      	ldr	r3, [r7, #20]
 801181e:	3304      	adds	r3, #4
 8011820:	009b      	lsls	r3, r3, #2
 8011822:	440b      	add	r3, r1
 8011824:	605a      	str	r2, [r3, #4]
    }

    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
    (*block)[0] = (JCOEF) (entropy->last_dc_val[ci] << cinfo->Al);
 8011826:	69fa      	ldr	r2, [r7, #28]
 8011828:	697b      	ldr	r3, [r7, #20]
 801182a:	3304      	adds	r3, #4
 801182c:	009b      	lsls	r3, r3, #2
 801182e:	4413      	add	r3, r2
 8011830:	685a      	ldr	r2, [r3, #4]
 8011832:	687b      	ldr	r3, [r7, #4]
 8011834:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8011838:	fa02 f303 	lsl.w	r3, r2, r3
 801183c:	b21a      	sxth	r2, r3
 801183e:	69bb      	ldr	r3, [r7, #24]
 8011840:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8011842:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011844:	3301      	adds	r3, #1
 8011846:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011848:	687b      	ldr	r3, [r7, #4]
 801184a:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 801184e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011850:	429a      	cmp	r2, r3
 8011852:	f6ff af17 	blt.w	8011684 <decode_mcu_DC_first+0x48>
  }

  return TRUE;
 8011856:	2301      	movs	r3, #1
}
 8011858:	4618      	mov	r0, r3
 801185a:	3730      	adds	r7, #48	@ 0x30
 801185c:	46bd      	mov	sp, r7
 801185e:	bd80      	pop	{r7, pc}

08011860 <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8011860:	b580      	push	{r7, lr}
 8011862:	b08c      	sub	sp, #48	@ 0x30
 8011864:	af00      	add	r7, sp, #0
 8011866:	6078      	str	r0, [r7, #4]
 8011868:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 801186a:	687b      	ldr	r3, [r7, #4]
 801186c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8011870:	61fb      	str	r3, [r7, #28]
  int tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8011872:	687b      	ldr	r3, [r7, #4]
 8011874:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8011878:	2b00      	cmp	r3, #0
 801187a:	d00b      	beq.n	8011894 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 801187c:	69fb      	ldr	r3, [r7, #28]
 801187e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011880:	2b00      	cmp	r3, #0
 8011882:	d102      	bne.n	801188a <decode_mcu_AC_first+0x2a>
      process_restart(cinfo);
 8011884:	6878      	ldr	r0, [r7, #4]
 8011886:	f7ff fe51 	bl	801152c <process_restart>
    entropy->restarts_to_go--;
 801188a:	69fb      	ldr	r3, [r7, #28]
 801188c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801188e:	1e5a      	subs	r2, r3, #1
 8011890:	69fb      	ldr	r3, [r7, #28]
 8011892:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8011894:	69fb      	ldr	r3, [r7, #28]
 8011896:	691b      	ldr	r3, [r3, #16]
 8011898:	f1b3 3fff 	cmp.w	r3, #4294967295
 801189c:	d101      	bne.n	80118a2 <decode_mcu_AC_first+0x42>
 801189e:	2301      	movs	r3, #1
 80118a0:	e0da      	b.n	8011a58 <decode_mcu_AC_first+0x1f8>

  natural_order = cinfo->natural_order;
 80118a2:	687b      	ldr	r3, [r7, #4]
 80118a4:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 80118a8:	61bb      	str	r3, [r7, #24]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 80118aa:	683b      	ldr	r3, [r7, #0]
 80118ac:	681b      	ldr	r3, [r3, #0]
 80118ae:	617b      	str	r3, [r7, #20]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 80118b0:	687b      	ldr	r3, [r7, #4]
 80118b2:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80118b6:	699b      	ldr	r3, [r3, #24]
 80118b8:	613b      	str	r3, [r7, #16]

  /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

  /* Figure F.20: Decode_AC_coefficients */
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 80118ba:	687b      	ldr	r3, [r7, #4]
 80118bc:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80118c0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80118c2:	e0bf      	b.n	8011a44 <decode_mcu_AC_first+0x1e4>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 80118c4:	69fb      	ldr	r3, [r7, #28]
 80118c6:	693a      	ldr	r2, [r7, #16]
 80118c8:	321e      	adds	r2, #30
 80118ca:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80118ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80118d0:	1e5a      	subs	r2, r3, #1
 80118d2:	4613      	mov	r3, r2
 80118d4:	005b      	lsls	r3, r3, #1
 80118d6:	4413      	add	r3, r2
 80118d8:	440b      	add	r3, r1
 80118da:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 80118dc:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80118de:	6878      	ldr	r0, [r7, #4]
 80118e0:	f7ff fd7e 	bl	80113e0 <arith_decode>
 80118e4:	4603      	mov	r3, r0
 80118e6:	2b00      	cmp	r3, #0
 80118e8:	f040 80b4 	bne.w	8011a54 <decode_mcu_AC_first+0x1f4>
    while (arith_decode(cinfo, st + 1) == 0) {
 80118ec:	e01c      	b.n	8011928 <decode_mcu_AC_first+0xc8>
      st += 3; k++;
 80118ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118f0:	3303      	adds	r3, #3
 80118f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80118f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80118f6:	3301      	adds	r3, #1
 80118f8:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (k > cinfo->Se) {
 80118fa:	687b      	ldr	r3, [r7, #4]
 80118fc:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8011900:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011902:	429a      	cmp	r2, r3
 8011904:	dd10      	ble.n	8011928 <decode_mcu_AC_first+0xc8>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8011906:	687b      	ldr	r3, [r7, #4]
 8011908:	681b      	ldr	r3, [r3, #0]
 801190a:	2275      	movs	r2, #117	@ 0x75
 801190c:	615a      	str	r2, [r3, #20]
 801190e:	687b      	ldr	r3, [r7, #4]
 8011910:	681b      	ldr	r3, [r3, #0]
 8011912:	685b      	ldr	r3, [r3, #4]
 8011914:	f04f 31ff 	mov.w	r1, #4294967295
 8011918:	6878      	ldr	r0, [r7, #4]
 801191a:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 801191c:	69fb      	ldr	r3, [r7, #28]
 801191e:	f04f 32ff 	mov.w	r2, #4294967295
 8011922:	611a      	str	r2, [r3, #16]
	return TRUE;
 8011924:	2301      	movs	r3, #1
 8011926:	e097      	b.n	8011a58 <decode_mcu_AC_first+0x1f8>
    while (arith_decode(cinfo, st + 1) == 0) {
 8011928:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801192a:	3301      	adds	r3, #1
 801192c:	4619      	mov	r1, r3
 801192e:	6878      	ldr	r0, [r7, #4]
 8011930:	f7ff fd56 	bl	80113e0 <arith_decode>
 8011934:	4603      	mov	r3, r0
 8011936:	2b00      	cmp	r3, #0
 8011938:	d0d9      	beq.n	80118ee <decode_mcu_AC_first+0x8e>
      }
    }
    /* Figure F.21: Decoding nonzero value v */
    /* Figure F.22: Decoding the sign of v */
    sign = arith_decode(cinfo, entropy->fixed_bin);
 801193a:	69fb      	ldr	r3, [r7, #28]
 801193c:	33b8      	adds	r3, #184	@ 0xb8
 801193e:	4619      	mov	r1, r3
 8011940:	6878      	ldr	r0, [r7, #4]
 8011942:	f7ff fd4d 	bl	80113e0 <arith_decode>
 8011946:	60f8      	str	r0, [r7, #12]
    st += 2;
 8011948:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801194a:	3302      	adds	r3, #2
 801194c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    /* Figure F.23: Decoding the magnitude category of v */
    if ((m = arith_decode(cinfo, st)) != 0) {
 801194e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011950:	6878      	ldr	r0, [r7, #4]
 8011952:	f7ff fd45 	bl	80113e0 <arith_decode>
 8011956:	6238      	str	r0, [r7, #32]
 8011958:	6a3b      	ldr	r3, [r7, #32]
 801195a:	2b00      	cmp	r3, #0
 801195c:	d040      	beq.n	80119e0 <decode_mcu_AC_first+0x180>
      if (arith_decode(cinfo, st)) {
 801195e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011960:	6878      	ldr	r0, [r7, #4]
 8011962:	f7ff fd3d 	bl	80113e0 <arith_decode>
 8011966:	4603      	mov	r3, r0
 8011968:	2b00      	cmp	r3, #0
 801196a:	d039      	beq.n	80119e0 <decode_mcu_AC_first+0x180>
	m <<= 1;
 801196c:	6a3b      	ldr	r3, [r7, #32]
 801196e:	005b      	lsls	r3, r3, #1
 8011970:	623b      	str	r3, [r7, #32]
	st = entropy->ac_stats[tbl] +
 8011972:	69fb      	ldr	r3, [r7, #28]
 8011974:	693a      	ldr	r2, [r7, #16]
 8011976:	321e      	adds	r2, #30
 8011978:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	     (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 801197c:	6879      	ldr	r1, [r7, #4]
 801197e:	693b      	ldr	r3, [r7, #16]
 8011980:	440b      	add	r3, r1
 8011982:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8011986:	781b      	ldrb	r3, [r3, #0]
 8011988:	4619      	mov	r1, r3
 801198a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801198c:	428b      	cmp	r3, r1
 801198e:	dc01      	bgt.n	8011994 <decode_mcu_AC_first+0x134>
 8011990:	23bd      	movs	r3, #189	@ 0xbd
 8011992:	e000      	b.n	8011996 <decode_mcu_AC_first+0x136>
 8011994:	23d9      	movs	r3, #217	@ 0xd9
	st = entropy->ac_stats[tbl] +
 8011996:	4413      	add	r3, r2
 8011998:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 801199a:	e01a      	b.n	80119d2 <decode_mcu_AC_first+0x172>
	  if ((m <<= 1) == 0x8000) {
 801199c:	6a3b      	ldr	r3, [r7, #32]
 801199e:	005b      	lsls	r3, r3, #1
 80119a0:	623b      	str	r3, [r7, #32]
 80119a2:	6a3b      	ldr	r3, [r7, #32]
 80119a4:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80119a8:	d110      	bne.n	80119cc <decode_mcu_AC_first+0x16c>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 80119aa:	687b      	ldr	r3, [r7, #4]
 80119ac:	681b      	ldr	r3, [r3, #0]
 80119ae:	2275      	movs	r2, #117	@ 0x75
 80119b0:	615a      	str	r2, [r3, #20]
 80119b2:	687b      	ldr	r3, [r7, #4]
 80119b4:	681b      	ldr	r3, [r3, #0]
 80119b6:	685b      	ldr	r3, [r3, #4]
 80119b8:	f04f 31ff 	mov.w	r1, #4294967295
 80119bc:	6878      	ldr	r0, [r7, #4]
 80119be:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 80119c0:	69fb      	ldr	r3, [r7, #28]
 80119c2:	f04f 32ff 	mov.w	r2, #4294967295
 80119c6:	611a      	str	r2, [r3, #16]
	    return TRUE;
 80119c8:	2301      	movs	r3, #1
 80119ca:	e045      	b.n	8011a58 <decode_mcu_AC_first+0x1f8>
	  }
	  st += 1;
 80119cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80119ce:	3301      	adds	r3, #1
 80119d0:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 80119d2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80119d4:	6878      	ldr	r0, [r7, #4]
 80119d6:	f7ff fd03 	bl	80113e0 <arith_decode>
 80119da:	4603      	mov	r3, r0
 80119dc:	2b00      	cmp	r3, #0
 80119de:	d1dd      	bne.n	801199c <decode_mcu_AC_first+0x13c>
	}
      }
    }
    v = m;
 80119e0:	6a3b      	ldr	r3, [r7, #32]
 80119e2:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Figure F.24: Decoding the magnitude bit pattern of v */
    st += 14;
 80119e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80119e6:	330e      	adds	r3, #14
 80119e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    while (m >>= 1)
 80119ea:	e00a      	b.n	8011a02 <decode_mcu_AC_first+0x1a2>
      if (arith_decode(cinfo, st)) v |= m;
 80119ec:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80119ee:	6878      	ldr	r0, [r7, #4]
 80119f0:	f7ff fcf6 	bl	80113e0 <arith_decode>
 80119f4:	4603      	mov	r3, r0
 80119f6:	2b00      	cmp	r3, #0
 80119f8:	d003      	beq.n	8011a02 <decode_mcu_AC_first+0x1a2>
 80119fa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80119fc:	6a3b      	ldr	r3, [r7, #32]
 80119fe:	4313      	orrs	r3, r2
 8011a00:	627b      	str	r3, [r7, #36]	@ 0x24
    while (m >>= 1)
 8011a02:	6a3b      	ldr	r3, [r7, #32]
 8011a04:	105b      	asrs	r3, r3, #1
 8011a06:	623b      	str	r3, [r7, #32]
 8011a08:	6a3b      	ldr	r3, [r7, #32]
 8011a0a:	2b00      	cmp	r3, #0
 8011a0c:	d1ee      	bne.n	80119ec <decode_mcu_AC_first+0x18c>
    v += 1; if (sign) v = -v;
 8011a0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a10:	3301      	adds	r3, #1
 8011a12:	627b      	str	r3, [r7, #36]	@ 0x24
 8011a14:	68fb      	ldr	r3, [r7, #12]
 8011a16:	2b00      	cmp	r3, #0
 8011a18:	d002      	beq.n	8011a20 <decode_mcu_AC_first+0x1c0>
 8011a1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a1c:	425b      	negs	r3, r3
 8011a1e:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Scale and output coefficient in natural (dezigzagged) order */
    (*block)[natural_order[k]] = (JCOEF) (v << cinfo->Al);
 8011a20:	687b      	ldr	r3, [r7, #4]
 8011a22:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8011a26:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011a28:	fa02 f103 	lsl.w	r1, r2, r3
 8011a2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011a2e:	009b      	lsls	r3, r3, #2
 8011a30:	69ba      	ldr	r2, [r7, #24]
 8011a32:	4413      	add	r3, r2
 8011a34:	681a      	ldr	r2, [r3, #0]
 8011a36:	b209      	sxth	r1, r1
 8011a38:	697b      	ldr	r3, [r7, #20]
 8011a3a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8011a3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011a40:	3301      	adds	r3, #1
 8011a42:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011a44:	687b      	ldr	r3, [r7, #4]
 8011a46:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8011a4a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011a4c:	429a      	cmp	r2, r3
 8011a4e:	f77f af39 	ble.w	80118c4 <decode_mcu_AC_first+0x64>
 8011a52:	e000      	b.n	8011a56 <decode_mcu_AC_first+0x1f6>
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 8011a54:	bf00      	nop
  }

  return TRUE;
 8011a56:	2301      	movs	r3, #1
}
 8011a58:	4618      	mov	r0, r3
 8011a5a:	3730      	adds	r7, #48	@ 0x30
 8011a5c:	46bd      	mov	sp, r7
 8011a5e:	bd80      	pop	{r7, pc}

08011a60 <decode_mcu_DC_refine>:
 * MCU decoding for DC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8011a60:	b580      	push	{r7, lr}
 8011a62:	b086      	sub	sp, #24
 8011a64:	af00      	add	r7, sp, #0
 8011a66:	6078      	str	r0, [r7, #4]
 8011a68:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8011a6a:	687b      	ldr	r3, [r7, #4]
 8011a6c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8011a70:	613b      	str	r3, [r7, #16]
  unsigned char *st;
  int p1, blkn;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8011a72:	687b      	ldr	r3, [r7, #4]
 8011a74:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8011a78:	2b00      	cmp	r3, #0
 8011a7a:	d00b      	beq.n	8011a94 <decode_mcu_DC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 8011a7c:	693b      	ldr	r3, [r7, #16]
 8011a7e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011a80:	2b00      	cmp	r3, #0
 8011a82:	d102      	bne.n	8011a8a <decode_mcu_DC_refine+0x2a>
      process_restart(cinfo);
 8011a84:	6878      	ldr	r0, [r7, #4]
 8011a86:	f7ff fd51 	bl	801152c <process_restart>
    entropy->restarts_to_go--;
 8011a8a:	693b      	ldr	r3, [r7, #16]
 8011a8c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011a8e:	1e5a      	subs	r2, r3, #1
 8011a90:	693b      	ldr	r3, [r7, #16]
 8011a92:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  st = entropy->fixed_bin;	/* use fixed probability estimation */
 8011a94:	693b      	ldr	r3, [r7, #16]
 8011a96:	33b8      	adds	r3, #184	@ 0xb8
 8011a98:	60fb      	str	r3, [r7, #12]
  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 8011a9a:	687b      	ldr	r3, [r7, #4]
 8011a9c:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8011aa0:	2201      	movs	r2, #1
 8011aa2:	fa02 f303 	lsl.w	r3, r2, r3
 8011aa6:	60bb      	str	r3, [r7, #8]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8011aa8:	2300      	movs	r3, #0
 8011aaa:	617b      	str	r3, [r7, #20]
 8011aac:	e01a      	b.n	8011ae4 <decode_mcu_DC_refine+0x84>
    /* Encoded data is simply the next bit of the two's-complement DC value */
    if (arith_decode(cinfo, st))
 8011aae:	68f9      	ldr	r1, [r7, #12]
 8011ab0:	6878      	ldr	r0, [r7, #4]
 8011ab2:	f7ff fc95 	bl	80113e0 <arith_decode>
 8011ab6:	4603      	mov	r3, r0
 8011ab8:	2b00      	cmp	r3, #0
 8011aba:	d010      	beq.n	8011ade <decode_mcu_DC_refine+0x7e>
      MCU_data[blkn][0][0] |= p1;
 8011abc:	697b      	ldr	r3, [r7, #20]
 8011abe:	009b      	lsls	r3, r3, #2
 8011ac0:	683a      	ldr	r2, [r7, #0]
 8011ac2:	4413      	add	r3, r2
 8011ac4:	681b      	ldr	r3, [r3, #0]
 8011ac6:	f9b3 1000 	ldrsh.w	r1, [r3]
 8011aca:	68bb      	ldr	r3, [r7, #8]
 8011acc:	b21a      	sxth	r2, r3
 8011ace:	697b      	ldr	r3, [r7, #20]
 8011ad0:	009b      	lsls	r3, r3, #2
 8011ad2:	6838      	ldr	r0, [r7, #0]
 8011ad4:	4403      	add	r3, r0
 8011ad6:	681b      	ldr	r3, [r3, #0]
 8011ad8:	430a      	orrs	r2, r1
 8011ada:	b212      	sxth	r2, r2
 8011adc:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8011ade:	697b      	ldr	r3, [r7, #20]
 8011ae0:	3301      	adds	r3, #1
 8011ae2:	617b      	str	r3, [r7, #20]
 8011ae4:	687b      	ldr	r3, [r7, #4]
 8011ae6:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8011aea:	697a      	ldr	r2, [r7, #20]
 8011aec:	429a      	cmp	r2, r3
 8011aee:	dbde      	blt.n	8011aae <decode_mcu_DC_refine+0x4e>
  }

  return TRUE;
 8011af0:	2301      	movs	r3, #1
}
 8011af2:	4618      	mov	r0, r3
 8011af4:	3718      	adds	r7, #24
 8011af6:	46bd      	mov	sp, r7
 8011af8:	bd80      	pop	{r7, pc}

08011afa <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8011afa:	b580      	push	{r7, lr}
 8011afc:	b08c      	sub	sp, #48	@ 0x30
 8011afe:	af00      	add	r7, sp, #0
 8011b00:	6078      	str	r0, [r7, #4]
 8011b02:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8011b04:	687b      	ldr	r3, [r7, #4]
 8011b06:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8011b0a:	623b      	str	r3, [r7, #32]
  int tbl, k, kex;
  int p1, m1;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8011b0c:	687b      	ldr	r3, [r7, #4]
 8011b0e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8011b12:	2b00      	cmp	r3, #0
 8011b14:	d00b      	beq.n	8011b2e <decode_mcu_AC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 8011b16:	6a3b      	ldr	r3, [r7, #32]
 8011b18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011b1a:	2b00      	cmp	r3, #0
 8011b1c:	d102      	bne.n	8011b24 <decode_mcu_AC_refine+0x2a>
      process_restart(cinfo);
 8011b1e:	6878      	ldr	r0, [r7, #4]
 8011b20:	f7ff fd04 	bl	801152c <process_restart>
    entropy->restarts_to_go--;
 8011b24:	6a3b      	ldr	r3, [r7, #32]
 8011b26:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011b28:	1e5a      	subs	r2, r3, #1
 8011b2a:	6a3b      	ldr	r3, [r7, #32]
 8011b2c:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8011b2e:	6a3b      	ldr	r3, [r7, #32]
 8011b30:	691b      	ldr	r3, [r3, #16]
 8011b32:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011b36:	d101      	bne.n	8011b3c <decode_mcu_AC_refine+0x42>
 8011b38:	2301      	movs	r3, #1
 8011b3a:	e0c8      	b.n	8011cce <decode_mcu_AC_refine+0x1d4>

  natural_order = cinfo->natural_order;
 8011b3c:	687b      	ldr	r3, [r7, #4]
 8011b3e:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8011b42:	61fb      	str	r3, [r7, #28]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 8011b44:	683b      	ldr	r3, [r7, #0]
 8011b46:	681b      	ldr	r3, [r3, #0]
 8011b48:	61bb      	str	r3, [r7, #24]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 8011b4a:	687b      	ldr	r3, [r7, #4]
 8011b4c:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8011b50:	699b      	ldr	r3, [r3, #24]
 8011b52:	617b      	str	r3, [r7, #20]

  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 8011b54:	687b      	ldr	r3, [r7, #4]
 8011b56:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8011b5a:	2201      	movs	r2, #1
 8011b5c:	fa02 f303 	lsl.w	r3, r2, r3
 8011b60:	613b      	str	r3, [r7, #16]
  m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 8011b62:	687b      	ldr	r3, [r7, #4]
 8011b64:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8011b68:	f04f 32ff 	mov.w	r2, #4294967295
 8011b6c:	fa02 f303 	lsl.w	r3, r2, r3
 8011b70:	60fb      	str	r3, [r7, #12]

  /* Establish EOBx (previous stage end-of-block) index */
  for (kex = cinfo->Se; kex > 0; kex--)
 8011b72:	687b      	ldr	r3, [r7, #4]
 8011b74:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8011b78:	627b      	str	r3, [r7, #36]	@ 0x24
 8011b7a:	e00c      	b.n	8011b96 <decode_mcu_AC_refine+0x9c>
    if ((*block)[natural_order[kex]]) break;
 8011b7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b7e:	009b      	lsls	r3, r3, #2
 8011b80:	69fa      	ldr	r2, [r7, #28]
 8011b82:	4413      	add	r3, r2
 8011b84:	681a      	ldr	r2, [r3, #0]
 8011b86:	69bb      	ldr	r3, [r7, #24]
 8011b88:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8011b8c:	2b00      	cmp	r3, #0
 8011b8e:	d106      	bne.n	8011b9e <decode_mcu_AC_refine+0xa4>
  for (kex = cinfo->Se; kex > 0; kex--)
 8011b90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b92:	3b01      	subs	r3, #1
 8011b94:	627b      	str	r3, [r7, #36]	@ 0x24
 8011b96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b98:	2b00      	cmp	r3, #0
 8011b9a:	dcef      	bgt.n	8011b7c <decode_mcu_AC_refine+0x82>
 8011b9c:	e000      	b.n	8011ba0 <decode_mcu_AC_refine+0xa6>
    if ((*block)[natural_order[kex]]) break;
 8011b9e:	bf00      	nop

  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8011ba0:	687b      	ldr	r3, [r7, #4]
 8011ba2:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8011ba6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011ba8:	e089      	b.n	8011cbe <decode_mcu_AC_refine+0x1c4>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 8011baa:	6a3b      	ldr	r3, [r7, #32]
 8011bac:	697a      	ldr	r2, [r7, #20]
 8011bae:	321e      	adds	r2, #30
 8011bb0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011bb4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011bb6:	1e5a      	subs	r2, r3, #1
 8011bb8:	4613      	mov	r3, r2
 8011bba:	005b      	lsls	r3, r3, #1
 8011bbc:	4413      	add	r3, r2
 8011bbe:	440b      	add	r3, r1
 8011bc0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (k > kex)
 8011bc2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011bc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bc6:	429a      	cmp	r2, r3
 8011bc8:	dc00      	bgt.n	8011bcc <decode_mcu_AC_refine+0xd2>
 8011bca:	e007      	b.n	8011bdc <decode_mcu_AC_refine+0xe2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 8011bcc:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011bce:	6878      	ldr	r0, [r7, #4]
 8011bd0:	f7ff fc06 	bl	80113e0 <arith_decode>
 8011bd4:	4603      	mov	r3, r0
 8011bd6:	2b00      	cmp	r3, #0
 8011bd8:	d000      	beq.n	8011bdc <decode_mcu_AC_refine+0xe2>
 8011bda:	e077      	b.n	8011ccc <decode_mcu_AC_refine+0x1d2>
    for (;;) {
      thiscoef = *block + natural_order[k];
 8011bdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011bde:	009b      	lsls	r3, r3, #2
 8011be0:	69fa      	ldr	r2, [r7, #28]
 8011be2:	4413      	add	r3, r2
 8011be4:	681b      	ldr	r3, [r3, #0]
 8011be6:	005b      	lsls	r3, r3, #1
 8011be8:	69ba      	ldr	r2, [r7, #24]
 8011bea:	4413      	add	r3, r2
 8011bec:	60bb      	str	r3, [r7, #8]
      if (*thiscoef) {				/* previously nonzero coef */
 8011bee:	68bb      	ldr	r3, [r7, #8]
 8011bf0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011bf4:	2b00      	cmp	r3, #0
 8011bf6:	d025      	beq.n	8011c44 <decode_mcu_AC_refine+0x14a>
	if (arith_decode(cinfo, st + 2)) {
 8011bf8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011bfa:	3302      	adds	r3, #2
 8011bfc:	4619      	mov	r1, r3
 8011bfe:	6878      	ldr	r0, [r7, #4]
 8011c00:	f7ff fbee 	bl	80113e0 <arith_decode>
 8011c04:	4603      	mov	r3, r0
 8011c06:	2b00      	cmp	r3, #0
 8011c08:	d055      	beq.n	8011cb6 <decode_mcu_AC_refine+0x1bc>
	  if (*thiscoef < 0)
 8011c0a:	68bb      	ldr	r3, [r7, #8]
 8011c0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c10:	2b00      	cmp	r3, #0
 8011c12:	da0b      	bge.n	8011c2c <decode_mcu_AC_refine+0x132>
	    *thiscoef += m1;
 8011c14:	68bb      	ldr	r3, [r7, #8]
 8011c16:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c1a:	b29a      	uxth	r2, r3
 8011c1c:	68fb      	ldr	r3, [r7, #12]
 8011c1e:	b29b      	uxth	r3, r3
 8011c20:	4413      	add	r3, r2
 8011c22:	b29b      	uxth	r3, r3
 8011c24:	b21a      	sxth	r2, r3
 8011c26:	68bb      	ldr	r3, [r7, #8]
 8011c28:	801a      	strh	r2, [r3, #0]
	  else
	    *thiscoef += p1;
	}
	break;
 8011c2a:	e044      	b.n	8011cb6 <decode_mcu_AC_refine+0x1bc>
	    *thiscoef += p1;
 8011c2c:	68bb      	ldr	r3, [r7, #8]
 8011c2e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c32:	b29a      	uxth	r2, r3
 8011c34:	693b      	ldr	r3, [r7, #16]
 8011c36:	b29b      	uxth	r3, r3
 8011c38:	4413      	add	r3, r2
 8011c3a:	b29b      	uxth	r3, r3
 8011c3c:	b21a      	sxth	r2, r3
 8011c3e:	68bb      	ldr	r3, [r7, #8]
 8011c40:	801a      	strh	r2, [r3, #0]
	break;
 8011c42:	e038      	b.n	8011cb6 <decode_mcu_AC_refine+0x1bc>
      }
      if (arith_decode(cinfo, st + 1)) {	/* newly nonzero coef */
 8011c44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011c46:	3301      	adds	r3, #1
 8011c48:	4619      	mov	r1, r3
 8011c4a:	6878      	ldr	r0, [r7, #4]
 8011c4c:	f7ff fbc8 	bl	80113e0 <arith_decode>
 8011c50:	4603      	mov	r3, r0
 8011c52:	2b00      	cmp	r3, #0
 8011c54:	d012      	beq.n	8011c7c <decode_mcu_AC_refine+0x182>
	if (arith_decode(cinfo, entropy->fixed_bin))
 8011c56:	6a3b      	ldr	r3, [r7, #32]
 8011c58:	33b8      	adds	r3, #184	@ 0xb8
 8011c5a:	4619      	mov	r1, r3
 8011c5c:	6878      	ldr	r0, [r7, #4]
 8011c5e:	f7ff fbbf 	bl	80113e0 <arith_decode>
 8011c62:	4603      	mov	r3, r0
 8011c64:	2b00      	cmp	r3, #0
 8011c66:	d004      	beq.n	8011c72 <decode_mcu_AC_refine+0x178>
	  *thiscoef = m1;
 8011c68:	68fb      	ldr	r3, [r7, #12]
 8011c6a:	b21a      	sxth	r2, r3
 8011c6c:	68bb      	ldr	r3, [r7, #8]
 8011c6e:	801a      	strh	r2, [r3, #0]
	else
	  *thiscoef = p1;
	break;
 8011c70:	e022      	b.n	8011cb8 <decode_mcu_AC_refine+0x1be>
	  *thiscoef = p1;
 8011c72:	693b      	ldr	r3, [r7, #16]
 8011c74:	b21a      	sxth	r2, r3
 8011c76:	68bb      	ldr	r3, [r7, #8]
 8011c78:	801a      	strh	r2, [r3, #0]
	break;
 8011c7a:	e01d      	b.n	8011cb8 <decode_mcu_AC_refine+0x1be>
      }
      st += 3; k++;
 8011c7c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011c7e:	3303      	adds	r3, #3
 8011c80:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011c82:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011c84:	3301      	adds	r3, #1
 8011c86:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (k > cinfo->Se) {
 8011c88:	687b      	ldr	r3, [r7, #4]
 8011c8a:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8011c8e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011c90:	429a      	cmp	r2, r3
 8011c92:	dda3      	ble.n	8011bdc <decode_mcu_AC_refine+0xe2>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8011c94:	687b      	ldr	r3, [r7, #4]
 8011c96:	681b      	ldr	r3, [r3, #0]
 8011c98:	2275      	movs	r2, #117	@ 0x75
 8011c9a:	615a      	str	r2, [r3, #20]
 8011c9c:	687b      	ldr	r3, [r7, #4]
 8011c9e:	681b      	ldr	r3, [r3, #0]
 8011ca0:	685b      	ldr	r3, [r3, #4]
 8011ca2:	f04f 31ff 	mov.w	r1, #4294967295
 8011ca6:	6878      	ldr	r0, [r7, #4]
 8011ca8:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 8011caa:	6a3b      	ldr	r3, [r7, #32]
 8011cac:	f04f 32ff 	mov.w	r2, #4294967295
 8011cb0:	611a      	str	r2, [r3, #16]
	return TRUE;
 8011cb2:	2301      	movs	r3, #1
 8011cb4:	e00b      	b.n	8011cce <decode_mcu_AC_refine+0x1d4>
	break;
 8011cb6:	bf00      	nop
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8011cb8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011cba:	3301      	adds	r3, #1
 8011cbc:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011cbe:	687b      	ldr	r3, [r7, #4]
 8011cc0:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8011cc4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011cc6:	429a      	cmp	r2, r3
 8011cc8:	f77f af6f 	ble.w	8011baa <decode_mcu_AC_refine+0xb0>
      }
    }
  }

  return TRUE;
 8011ccc:	2301      	movs	r3, #1
}
 8011cce:	4618      	mov	r0, r3
 8011cd0:	3730      	adds	r7, #48	@ 0x30
 8011cd2:	46bd      	mov	sp, r7
 8011cd4:	bd80      	pop	{r7, pc}

08011cd6 <decode_mcu>:
 * Decode one MCU's worth of arithmetic-compressed coefficients.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8011cd6:	b580      	push	{r7, lr}
 8011cd8:	b08e      	sub	sp, #56	@ 0x38
 8011cda:	af00      	add	r7, sp, #0
 8011cdc:	6078      	str	r0, [r7, #4]
 8011cde:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8011ce6:	623b      	str	r3, [r7, #32]
  int blkn, ci, tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8011ce8:	687b      	ldr	r3, [r7, #4]
 8011cea:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8011cee:	2b00      	cmp	r3, #0
 8011cf0:	d00b      	beq.n	8011d0a <decode_mcu+0x34>
    if (entropy->restarts_to_go == 0)
 8011cf2:	6a3b      	ldr	r3, [r7, #32]
 8011cf4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011cf6:	2b00      	cmp	r3, #0
 8011cf8:	d102      	bne.n	8011d00 <decode_mcu+0x2a>
      process_restart(cinfo);
 8011cfa:	6878      	ldr	r0, [r7, #4]
 8011cfc:	f7ff fc16 	bl	801152c <process_restart>
    entropy->restarts_to_go--;
 8011d00:	6a3b      	ldr	r3, [r7, #32]
 8011d02:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011d04:	1e5a      	subs	r2, r3, #1
 8011d06:	6a3b      	ldr	r3, [r7, #32]
 8011d08:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8011d0a:	6a3b      	ldr	r3, [r7, #32]
 8011d0c:	691b      	ldr	r3, [r3, #16]
 8011d0e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011d12:	d101      	bne.n	8011d18 <decode_mcu+0x42>
 8011d14:	2301      	movs	r3, #1
 8011d16:	e1ba      	b.n	801208e <decode_mcu+0x3b8>

  natural_order = cinfo->natural_order;
 8011d18:	687b      	ldr	r3, [r7, #4]
 8011d1a:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8011d1e:	61fb      	str	r3, [r7, #28]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8011d20:	2300      	movs	r3, #0
 8011d22:	633b      	str	r3, [r7, #48]	@ 0x30
 8011d24:	e1ab      	b.n	801207e <decode_mcu+0x3a8>
    block = MCU_data[blkn];
 8011d26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011d28:	009b      	lsls	r3, r3, #2
 8011d2a:	683a      	ldr	r2, [r7, #0]
 8011d2c:	4413      	add	r3, r2
 8011d2e:	681b      	ldr	r3, [r3, #0]
 8011d30:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 8011d32:	687b      	ldr	r3, [r7, #4]
 8011d34:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011d36:	325c      	adds	r2, #92	@ 0x5c
 8011d38:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011d3c:	617b      	str	r3, [r7, #20]
    compptr = cinfo->cur_comp_info[ci];
 8011d3e:	687a      	ldr	r2, [r7, #4]
 8011d40:	697b      	ldr	r3, [r7, #20]
 8011d42:	3354      	adds	r3, #84	@ 0x54
 8011d44:	009b      	lsls	r3, r3, #2
 8011d46:	4413      	add	r3, r2
 8011d48:	685b      	ldr	r3, [r3, #4]
 8011d4a:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    tbl = compptr->dc_tbl_no;
 8011d4c:	693b      	ldr	r3, [r7, #16]
 8011d4e:	695b      	ldr	r3, [r3, #20]
 8011d50:	60fb      	str	r3, [r7, #12]

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 8011d52:	6a3b      	ldr	r3, [r7, #32]
 8011d54:	68fa      	ldr	r2, [r7, #12]
 8011d56:	320e      	adds	r2, #14
 8011d58:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011d5c:	6a39      	ldr	r1, [r7, #32]
 8011d5e:	697b      	ldr	r3, [r7, #20]
 8011d60:	3308      	adds	r3, #8
 8011d62:	009b      	lsls	r3, r3, #2
 8011d64:	440b      	add	r3, r1
 8011d66:	685b      	ldr	r3, [r3, #4]
 8011d68:	4413      	add	r3, r2
 8011d6a:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 8011d6c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011d6e:	6878      	ldr	r0, [r7, #4]
 8011d70:	f7ff fb36 	bl	80113e0 <arith_decode>
 8011d74:	4603      	mov	r3, r0
 8011d76:	2b00      	cmp	r3, #0
 8011d78:	d107      	bne.n	8011d8a <decode_mcu+0xb4>
      entropy->dc_context[ci] = 0;
 8011d7a:	6a3a      	ldr	r2, [r7, #32]
 8011d7c:	697b      	ldr	r3, [r7, #20]
 8011d7e:	3308      	adds	r3, #8
 8011d80:	009b      	lsls	r3, r3, #2
 8011d82:	4413      	add	r3, r2
 8011d84:	2200      	movs	r2, #0
 8011d86:	605a      	str	r2, [r3, #4]
 8011d88:	e0a0      	b.n	8011ecc <decode_mcu+0x1f6>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 8011d8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d8c:	3301      	adds	r3, #1
 8011d8e:	4619      	mov	r1, r3
 8011d90:	6878      	ldr	r0, [r7, #4]
 8011d92:	f7ff fb25 	bl	80113e0 <arith_decode>
 8011d96:	60b8      	str	r0, [r7, #8]
      st += 2; st += sign;
 8011d98:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d9a:	3302      	adds	r3, #2
 8011d9c:	637b      	str	r3, [r7, #52]	@ 0x34
 8011d9e:	68bb      	ldr	r3, [r7, #8]
 8011da0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011da2:	4413      	add	r3, r2
 8011da4:	637b      	str	r3, [r7, #52]	@ 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8011da6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011da8:	6878      	ldr	r0, [r7, #4]
 8011daa:	f7ff fb19 	bl	80113e0 <arith_decode>
 8011dae:	6278      	str	r0, [r7, #36]	@ 0x24
 8011db0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011db2:	2b00      	cmp	r3, #0
 8011db4:	d029      	beq.n	8011e0a <decode_mcu+0x134>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 8011db6:	6a3b      	ldr	r3, [r7, #32]
 8011db8:	68fa      	ldr	r2, [r7, #12]
 8011dba:	320e      	adds	r2, #14
 8011dbc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011dc0:	3314      	adds	r3, #20
 8011dc2:	637b      	str	r3, [r7, #52]	@ 0x34
	while (arith_decode(cinfo, st)) {
 8011dc4:	e01a      	b.n	8011dfc <decode_mcu+0x126>
	  if ((m <<= 1) == 0x8000) {
 8011dc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011dc8:	005b      	lsls	r3, r3, #1
 8011dca:	627b      	str	r3, [r7, #36]	@ 0x24
 8011dcc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011dce:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8011dd2:	d110      	bne.n	8011df6 <decode_mcu+0x120>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8011dd4:	687b      	ldr	r3, [r7, #4]
 8011dd6:	681b      	ldr	r3, [r3, #0]
 8011dd8:	2275      	movs	r2, #117	@ 0x75
 8011dda:	615a      	str	r2, [r3, #20]
 8011ddc:	687b      	ldr	r3, [r7, #4]
 8011dde:	681b      	ldr	r3, [r3, #0]
 8011de0:	685b      	ldr	r3, [r3, #4]
 8011de2:	f04f 31ff 	mov.w	r1, #4294967295
 8011de6:	6878      	ldr	r0, [r7, #4]
 8011de8:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 8011dea:	6a3b      	ldr	r3, [r7, #32]
 8011dec:	f04f 32ff 	mov.w	r2, #4294967295
 8011df0:	611a      	str	r2, [r3, #16]
	    return TRUE;
 8011df2:	2301      	movs	r3, #1
 8011df4:	e14b      	b.n	801208e <decode_mcu+0x3b8>
	  }
	  st += 1;
 8011df6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011df8:	3301      	adds	r3, #1
 8011dfa:	637b      	str	r3, [r7, #52]	@ 0x34
	while (arith_decode(cinfo, st)) {
 8011dfc:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011dfe:	6878      	ldr	r0, [r7, #4]
 8011e00:	f7ff faee 	bl	80113e0 <arith_decode>
 8011e04:	4603      	mov	r3, r0
 8011e06:	2b00      	cmp	r3, #0
 8011e08:	d1dd      	bne.n	8011dc6 <decode_mcu+0xf0>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 8011e0a:	687a      	ldr	r2, [r7, #4]
 8011e0c:	68fb      	ldr	r3, [r7, #12]
 8011e0e:	4413      	add	r3, r2
 8011e10:	33e8      	adds	r3, #232	@ 0xe8
 8011e12:	781b      	ldrb	r3, [r3, #0]
 8011e14:	461a      	mov	r2, r3
 8011e16:	2301      	movs	r3, #1
 8011e18:	4093      	lsls	r3, r2
 8011e1a:	105b      	asrs	r3, r3, #1
 8011e1c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011e1e:	429a      	cmp	r2, r3
 8011e20:	da07      	bge.n	8011e32 <decode_mcu+0x15c>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 8011e22:	6a3a      	ldr	r2, [r7, #32]
 8011e24:	697b      	ldr	r3, [r7, #20]
 8011e26:	3308      	adds	r3, #8
 8011e28:	009b      	lsls	r3, r3, #2
 8011e2a:	4413      	add	r3, r2
 8011e2c:	2200      	movs	r2, #0
 8011e2e:	605a      	str	r2, [r3, #4]
 8011e30:	e01e      	b.n	8011e70 <decode_mcu+0x19a>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 8011e32:	687a      	ldr	r2, [r7, #4]
 8011e34:	68fb      	ldr	r3, [r7, #12]
 8011e36:	4413      	add	r3, r2
 8011e38:	33f8      	adds	r3, #248	@ 0xf8
 8011e3a:	781b      	ldrb	r3, [r3, #0]
 8011e3c:	461a      	mov	r2, r3
 8011e3e:	2301      	movs	r3, #1
 8011e40:	4093      	lsls	r3, r2
 8011e42:	105b      	asrs	r3, r3, #1
 8011e44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011e46:	429a      	cmp	r2, r3
 8011e48:	dd09      	ble.n	8011e5e <decode_mcu+0x188>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 8011e4a:	68bb      	ldr	r3, [r7, #8]
 8011e4c:	3303      	adds	r3, #3
 8011e4e:	009a      	lsls	r2, r3, #2
 8011e50:	6a39      	ldr	r1, [r7, #32]
 8011e52:	697b      	ldr	r3, [r7, #20]
 8011e54:	3308      	adds	r3, #8
 8011e56:	009b      	lsls	r3, r3, #2
 8011e58:	440b      	add	r3, r1
 8011e5a:	605a      	str	r2, [r3, #4]
 8011e5c:	e008      	b.n	8011e70 <decode_mcu+0x19a>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 8011e5e:	68bb      	ldr	r3, [r7, #8]
 8011e60:	3301      	adds	r3, #1
 8011e62:	009a      	lsls	r2, r3, #2
 8011e64:	6a39      	ldr	r1, [r7, #32]
 8011e66:	697b      	ldr	r3, [r7, #20]
 8011e68:	3308      	adds	r3, #8
 8011e6a:	009b      	lsls	r3, r3, #2
 8011e6c:	440b      	add	r3, r1
 8011e6e:	605a      	str	r2, [r3, #4]
      v = m;
 8011e70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011e72:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 8011e74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011e76:	330e      	adds	r3, #14
 8011e78:	637b      	str	r3, [r7, #52]	@ 0x34
      while (m >>= 1)
 8011e7a:	e00a      	b.n	8011e92 <decode_mcu+0x1bc>
	if (arith_decode(cinfo, st)) v |= m;
 8011e7c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011e7e:	6878      	ldr	r0, [r7, #4]
 8011e80:	f7ff faae 	bl	80113e0 <arith_decode>
 8011e84:	4603      	mov	r3, r0
 8011e86:	2b00      	cmp	r3, #0
 8011e88:	d003      	beq.n	8011e92 <decode_mcu+0x1bc>
 8011e8a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011e8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011e8e:	4313      	orrs	r3, r2
 8011e90:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (m >>= 1)
 8011e92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011e94:	105b      	asrs	r3, r3, #1
 8011e96:	627b      	str	r3, [r7, #36]	@ 0x24
 8011e98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011e9a:	2b00      	cmp	r3, #0
 8011e9c:	d1ee      	bne.n	8011e7c <decode_mcu+0x1a6>
      v += 1; if (sign) v = -v;
 8011e9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011ea0:	3301      	adds	r3, #1
 8011ea2:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011ea4:	68bb      	ldr	r3, [r7, #8]
 8011ea6:	2b00      	cmp	r3, #0
 8011ea8:	d002      	beq.n	8011eb0 <decode_mcu+0x1da>
 8011eaa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011eac:	425b      	negs	r3, r3
 8011eae:	62bb      	str	r3, [r7, #40]	@ 0x28
      entropy->last_dc_val[ci] += v;
 8011eb0:	6a3a      	ldr	r2, [r7, #32]
 8011eb2:	697b      	ldr	r3, [r7, #20]
 8011eb4:	3304      	adds	r3, #4
 8011eb6:	009b      	lsls	r3, r3, #2
 8011eb8:	4413      	add	r3, r2
 8011eba:	685a      	ldr	r2, [r3, #4]
 8011ebc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011ebe:	441a      	add	r2, r3
 8011ec0:	6a39      	ldr	r1, [r7, #32]
 8011ec2:	697b      	ldr	r3, [r7, #20]
 8011ec4:	3304      	adds	r3, #4
 8011ec6:	009b      	lsls	r3, r3, #2
 8011ec8:	440b      	add	r3, r1
 8011eca:	605a      	str	r2, [r3, #4]
    }

    (*block)[0] = (JCOEF) entropy->last_dc_val[ci];
 8011ecc:	6a3a      	ldr	r2, [r7, #32]
 8011ece:	697b      	ldr	r3, [r7, #20]
 8011ed0:	3304      	adds	r3, #4
 8011ed2:	009b      	lsls	r3, r3, #2
 8011ed4:	4413      	add	r3, r2
 8011ed6:	685b      	ldr	r3, [r3, #4]
 8011ed8:	b21a      	sxth	r2, r3
 8011eda:	69bb      	ldr	r3, [r7, #24]
 8011edc:	801a      	strh	r2, [r3, #0]

    /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

    if (cinfo->lim_Se == 0) continue;
 8011ede:	687b      	ldr	r3, [r7, #4]
 8011ee0:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8011ee4:	2b00      	cmp	r3, #0
 8011ee6:	f000 80c4 	beq.w	8012072 <decode_mcu+0x39c>
    tbl = compptr->ac_tbl_no;
 8011eea:	693b      	ldr	r3, [r7, #16]
 8011eec:	699b      	ldr	r3, [r3, #24]
 8011eee:	60fb      	str	r3, [r7, #12]
    k = 0;
 8011ef0:	2300      	movs	r3, #0
 8011ef2:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Figure F.20: Decode_AC_coefficients */
    do {
      st = entropy->ac_stats[tbl] + 3 * k;
 8011ef4:	6a3b      	ldr	r3, [r7, #32]
 8011ef6:	68fa      	ldr	r2, [r7, #12]
 8011ef8:	321e      	adds	r2, #30
 8011efa:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011efe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011f00:	4613      	mov	r3, r2
 8011f02:	005b      	lsls	r3, r3, #1
 8011f04:	4413      	add	r3, r2
 8011f06:	440b      	add	r3, r1
 8011f08:	637b      	str	r3, [r7, #52]	@ 0x34
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 8011f0a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011f0c:	6878      	ldr	r0, [r7, #4]
 8011f0e:	f7ff fa67 	bl	80113e0 <arith_decode>
 8011f12:	4603      	mov	r3, r0
 8011f14:	2b00      	cmp	r3, #0
 8011f16:	f040 80ae 	bne.w	8012076 <decode_mcu+0x3a0>
      for (;;) {
	k++;
 8011f1a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011f1c:	3301      	adds	r3, #1
 8011f1e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	if (arith_decode(cinfo, st + 1)) break;
 8011f20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011f22:	3301      	adds	r3, #1
 8011f24:	4619      	mov	r1, r3
 8011f26:	6878      	ldr	r0, [r7, #4]
 8011f28:	f7ff fa5a 	bl	80113e0 <arith_decode>
 8011f2c:	4603      	mov	r3, r0
 8011f2e:	2b00      	cmp	r3, #0
 8011f30:	d119      	bne.n	8011f66 <decode_mcu+0x290>
	st += 3;
 8011f32:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011f34:	3303      	adds	r3, #3
 8011f36:	637b      	str	r3, [r7, #52]	@ 0x34
	if (k >= cinfo->lim_Se) {
 8011f38:	687b      	ldr	r3, [r7, #4]
 8011f3a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8011f3e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011f40:	429a      	cmp	r2, r3
 8011f42:	dbea      	blt.n	8011f1a <decode_mcu+0x244>
	  WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8011f44:	687b      	ldr	r3, [r7, #4]
 8011f46:	681b      	ldr	r3, [r3, #0]
 8011f48:	2275      	movs	r2, #117	@ 0x75
 8011f4a:	615a      	str	r2, [r3, #20]
 8011f4c:	687b      	ldr	r3, [r7, #4]
 8011f4e:	681b      	ldr	r3, [r3, #0]
 8011f50:	685b      	ldr	r3, [r3, #4]
 8011f52:	f04f 31ff 	mov.w	r1, #4294967295
 8011f56:	6878      	ldr	r0, [r7, #4]
 8011f58:	4798      	blx	r3
	  entropy->ct = -1;			/* spectral overflow */
 8011f5a:	6a3b      	ldr	r3, [r7, #32]
 8011f5c:	f04f 32ff 	mov.w	r2, #4294967295
 8011f60:	611a      	str	r2, [r3, #16]
	  return TRUE;
 8011f62:	2301      	movs	r3, #1
 8011f64:	e093      	b.n	801208e <decode_mcu+0x3b8>
	if (arith_decode(cinfo, st + 1)) break;
 8011f66:	bf00      	nop
	}
      }
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, entropy->fixed_bin);
 8011f68:	6a3b      	ldr	r3, [r7, #32]
 8011f6a:	33b8      	adds	r3, #184	@ 0xb8
 8011f6c:	4619      	mov	r1, r3
 8011f6e:	6878      	ldr	r0, [r7, #4]
 8011f70:	f7ff fa36 	bl	80113e0 <arith_decode>
 8011f74:	60b8      	str	r0, [r7, #8]
      st += 2;
 8011f76:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011f78:	3302      	adds	r3, #2
 8011f7a:	637b      	str	r3, [r7, #52]	@ 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8011f7c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011f7e:	6878      	ldr	r0, [r7, #4]
 8011f80:	f7ff fa2e 	bl	80113e0 <arith_decode>
 8011f84:	6278      	str	r0, [r7, #36]	@ 0x24
 8011f86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011f88:	2b00      	cmp	r3, #0
 8011f8a:	d040      	beq.n	801200e <decode_mcu+0x338>
	if (arith_decode(cinfo, st)) {
 8011f8c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011f8e:	6878      	ldr	r0, [r7, #4]
 8011f90:	f7ff fa26 	bl	80113e0 <arith_decode>
 8011f94:	4603      	mov	r3, r0
 8011f96:	2b00      	cmp	r3, #0
 8011f98:	d039      	beq.n	801200e <decode_mcu+0x338>
	  m <<= 1;
 8011f9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011f9c:	005b      	lsls	r3, r3, #1
 8011f9e:	627b      	str	r3, [r7, #36]	@ 0x24
	  st = entropy->ac_stats[tbl] +
 8011fa0:	6a3b      	ldr	r3, [r7, #32]
 8011fa2:	68fa      	ldr	r2, [r7, #12]
 8011fa4:	321e      	adds	r2, #30
 8011fa6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	       (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 8011faa:	6879      	ldr	r1, [r7, #4]
 8011fac:	68fb      	ldr	r3, [r7, #12]
 8011fae:	440b      	add	r3, r1
 8011fb0:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8011fb4:	781b      	ldrb	r3, [r3, #0]
 8011fb6:	4619      	mov	r1, r3
 8011fb8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011fba:	428b      	cmp	r3, r1
 8011fbc:	dc01      	bgt.n	8011fc2 <decode_mcu+0x2ec>
 8011fbe:	23bd      	movs	r3, #189	@ 0xbd
 8011fc0:	e000      	b.n	8011fc4 <decode_mcu+0x2ee>
 8011fc2:	23d9      	movs	r3, #217	@ 0xd9
	  st = entropy->ac_stats[tbl] +
 8011fc4:	4413      	add	r3, r2
 8011fc6:	637b      	str	r3, [r7, #52]	@ 0x34
	  while (arith_decode(cinfo, st)) {
 8011fc8:	e01a      	b.n	8012000 <decode_mcu+0x32a>
	    if ((m <<= 1) == 0x8000) {
 8011fca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011fcc:	005b      	lsls	r3, r3, #1
 8011fce:	627b      	str	r3, [r7, #36]	@ 0x24
 8011fd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011fd2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8011fd6:	d110      	bne.n	8011ffa <decode_mcu+0x324>
	      WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8011fd8:	687b      	ldr	r3, [r7, #4]
 8011fda:	681b      	ldr	r3, [r3, #0]
 8011fdc:	2275      	movs	r2, #117	@ 0x75
 8011fde:	615a      	str	r2, [r3, #20]
 8011fe0:	687b      	ldr	r3, [r7, #4]
 8011fe2:	681b      	ldr	r3, [r3, #0]
 8011fe4:	685b      	ldr	r3, [r3, #4]
 8011fe6:	f04f 31ff 	mov.w	r1, #4294967295
 8011fea:	6878      	ldr	r0, [r7, #4]
 8011fec:	4798      	blx	r3
	      entropy->ct = -1;			/* magnitude overflow */
 8011fee:	6a3b      	ldr	r3, [r7, #32]
 8011ff0:	f04f 32ff 	mov.w	r2, #4294967295
 8011ff4:	611a      	str	r2, [r3, #16]
	      return TRUE;
 8011ff6:	2301      	movs	r3, #1
 8011ff8:	e049      	b.n	801208e <decode_mcu+0x3b8>
	    }
	    st += 1;
 8011ffa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011ffc:	3301      	adds	r3, #1
 8011ffe:	637b      	str	r3, [r7, #52]	@ 0x34
	  while (arith_decode(cinfo, st)) {
 8012000:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8012002:	6878      	ldr	r0, [r7, #4]
 8012004:	f7ff f9ec 	bl	80113e0 <arith_decode>
 8012008:	4603      	mov	r3, r0
 801200a:	2b00      	cmp	r3, #0
 801200c:	d1dd      	bne.n	8011fca <decode_mcu+0x2f4>
	  }
	}
      }
      v = m;
 801200e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012010:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 8012012:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012014:	330e      	adds	r3, #14
 8012016:	637b      	str	r3, [r7, #52]	@ 0x34
      while (m >>= 1)
 8012018:	e00a      	b.n	8012030 <decode_mcu+0x35a>
	if (arith_decode(cinfo, st)) v |= m;
 801201a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801201c:	6878      	ldr	r0, [r7, #4]
 801201e:	f7ff f9df 	bl	80113e0 <arith_decode>
 8012022:	4603      	mov	r3, r0
 8012024:	2b00      	cmp	r3, #0
 8012026:	d003      	beq.n	8012030 <decode_mcu+0x35a>
 8012028:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801202a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801202c:	4313      	orrs	r3, r2
 801202e:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (m >>= 1)
 8012030:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012032:	105b      	asrs	r3, r3, #1
 8012034:	627b      	str	r3, [r7, #36]	@ 0x24
 8012036:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012038:	2b00      	cmp	r3, #0
 801203a:	d1ee      	bne.n	801201a <decode_mcu+0x344>
      v += 1; if (sign) v = -v;
 801203c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801203e:	3301      	adds	r3, #1
 8012040:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012042:	68bb      	ldr	r3, [r7, #8]
 8012044:	2b00      	cmp	r3, #0
 8012046:	d002      	beq.n	801204e <decode_mcu+0x378>
 8012048:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801204a:	425b      	negs	r3, r3
 801204c:	62bb      	str	r3, [r7, #40]	@ 0x28
      (*block)[natural_order[k]] = (JCOEF) v;
 801204e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012050:	009b      	lsls	r3, r3, #2
 8012052:	69fa      	ldr	r2, [r7, #28]
 8012054:	4413      	add	r3, r2
 8012056:	681a      	ldr	r2, [r3, #0]
 8012058:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801205a:	b219      	sxth	r1, r3
 801205c:	69bb      	ldr	r3, [r7, #24]
 801205e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    } while (k < cinfo->lim_Se);
 8012062:	687b      	ldr	r3, [r7, #4]
 8012064:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8012068:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801206a:	429a      	cmp	r2, r3
 801206c:	f6ff af42 	blt.w	8011ef4 <decode_mcu+0x21e>
 8012070:	e002      	b.n	8012078 <decode_mcu+0x3a2>
    if (cinfo->lim_Se == 0) continue;
 8012072:	bf00      	nop
 8012074:	e000      	b.n	8012078 <decode_mcu+0x3a2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 8012076:	bf00      	nop
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8012078:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801207a:	3301      	adds	r3, #1
 801207c:	633b      	str	r3, [r7, #48]	@ 0x30
 801207e:	687b      	ldr	r3, [r7, #4]
 8012080:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8012084:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012086:	429a      	cmp	r2, r3
 8012088:	f6ff ae4d 	blt.w	8011d26 <decode_mcu+0x50>
  }

  return TRUE;
 801208c:	2301      	movs	r3, #1
}
 801208e:	4618      	mov	r0, r3
 8012090:	3738      	adds	r7, #56	@ 0x38
 8012092:	46bd      	mov	sp, r7
 8012094:	bd80      	pop	{r7, pc}
	...

08012098 <start_pass>:
 * Initialize for an arithmetic-compressed scan.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 8012098:	b580      	push	{r7, lr}
 801209a:	b08a      	sub	sp, #40	@ 0x28
 801209c:	af00      	add	r7, sp, #0
 801209e:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 80120a0:	687b      	ldr	r3, [r7, #4]
 80120a2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80120a6:	61fb      	str	r3, [r7, #28]
  int ci, tbl;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 80120a8:	687b      	ldr	r3, [r7, #4]
 80120aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80120ae:	2b00      	cmp	r3, #0
 80120b0:	f000 80e7 	beq.w	8012282 <start_pass+0x1ea>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 80120b4:	687b      	ldr	r3, [r7, #4]
 80120b6:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80120ba:	2b00      	cmp	r3, #0
 80120bc:	d105      	bne.n	80120ca <start_pass+0x32>
      if (cinfo->Se != 0)
 80120be:	687b      	ldr	r3, [r7, #4]
 80120c0:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80120c4:	2b00      	cmp	r3, #0
 80120c6:	d015      	beq.n	80120f4 <start_pass+0x5c>
	goto bad;
 80120c8:	e02d      	b.n	8012126 <start_pass+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 80120ca:	687b      	ldr	r3, [r7, #4]
 80120cc:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80120d0:	687b      	ldr	r3, [r7, #4]
 80120d2:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80120d6:	429a      	cmp	r2, r3
 80120d8:	db20      	blt.n	801211c <start_pass+0x84>
 80120da:	687b      	ldr	r3, [r7, #4]
 80120dc:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80120e0:	687b      	ldr	r3, [r7, #4]
 80120e2:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80120e6:	429a      	cmp	r2, r3
 80120e8:	dc18      	bgt.n	801211c <start_pass+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 80120ea:	687b      	ldr	r3, [r7, #4]
 80120ec:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80120f0:	2b01      	cmp	r3, #1
 80120f2:	d115      	bne.n	8012120 <start_pass+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 80120f4:	687b      	ldr	r3, [r7, #4]
 80120f6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80120fa:	2b00      	cmp	r3, #0
 80120fc:	d008      	beq.n	8012110 <start_pass+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8012104:	1e5a      	subs	r2, r3, #1
 8012106:	687b      	ldr	r3, [r7, #4]
 8012108:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 801210c:	429a      	cmp	r2, r3
 801210e:	d109      	bne.n	8012124 <start_pass+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 8012110:	687b      	ldr	r3, [r7, #4]
 8012112:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8012116:	2b0d      	cmp	r3, #13
 8012118:	dd26      	ble.n	8012168 <start_pass+0xd0>
      bad:
 801211a:	e004      	b.n	8012126 <start_pass+0x8e>
	goto bad;
 801211c:	bf00      	nop
 801211e:	e002      	b.n	8012126 <start_pass+0x8e>
	goto bad;
 8012120:	bf00      	nop
 8012122:	e000      	b.n	8012126 <start_pass+0x8e>
	goto bad;
 8012124:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 8012126:	687b      	ldr	r3, [r7, #4]
 8012128:	681b      	ldr	r3, [r3, #0]
 801212a:	2211      	movs	r2, #17
 801212c:	615a      	str	r2, [r3, #20]
 801212e:	687b      	ldr	r3, [r7, #4]
 8012130:	681b      	ldr	r3, [r3, #0]
 8012132:	687a      	ldr	r2, [r7, #4]
 8012134:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 8012138:	619a      	str	r2, [r3, #24]
 801213a:	687b      	ldr	r3, [r7, #4]
 801213c:	681b      	ldr	r3, [r3, #0]
 801213e:	687a      	ldr	r2, [r7, #4]
 8012140:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 8012144:	61da      	str	r2, [r3, #28]
 8012146:	687b      	ldr	r3, [r7, #4]
 8012148:	681b      	ldr	r3, [r3, #0]
 801214a:	687a      	ldr	r2, [r7, #4]
 801214c:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 8012150:	621a      	str	r2, [r3, #32]
 8012152:	687b      	ldr	r3, [r7, #4]
 8012154:	681b      	ldr	r3, [r3, #0]
 8012156:	687a      	ldr	r2, [r7, #4]
 8012158:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 801215c:	625a      	str	r2, [r3, #36]	@ 0x24
 801215e:	687b      	ldr	r3, [r7, #4]
 8012160:	681b      	ldr	r3, [r3, #0]
 8012162:	681b      	ldr	r3, [r3, #0]
 8012164:	6878      	ldr	r0, [r7, #4]
 8012166:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012168:	2300      	movs	r3, #0
 801216a:	627b      	str	r3, [r7, #36]	@ 0x24
 801216c:	e064      	b.n	8012238 <start_pass+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 801216e:	687a      	ldr	r2, [r7, #4]
 8012170:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012172:	3354      	adds	r3, #84	@ 0x54
 8012174:	009b      	lsls	r3, r3, #2
 8012176:	4413      	add	r3, r2
 8012178:	685b      	ldr	r3, [r3, #4]
 801217a:	685b      	ldr	r3, [r3, #4]
 801217c:	61bb      	str	r3, [r7, #24]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 801217e:	687b      	ldr	r3, [r7, #4]
 8012180:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8012184:	69bb      	ldr	r3, [r7, #24]
 8012186:	021b      	lsls	r3, r3, #8
 8012188:	4413      	add	r3, r2
 801218a:	617b      	str	r3, [r7, #20]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 801218c:	687b      	ldr	r3, [r7, #4]
 801218e:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8012192:	2b00      	cmp	r3, #0
 8012194:	d016      	beq.n	80121c4 <start_pass+0x12c>
 8012196:	697b      	ldr	r3, [r7, #20]
 8012198:	681b      	ldr	r3, [r3, #0]
 801219a:	2b00      	cmp	r3, #0
 801219c:	da12      	bge.n	80121c4 <start_pass+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 801219e:	687b      	ldr	r3, [r7, #4]
 80121a0:	681b      	ldr	r3, [r3, #0]
 80121a2:	2276      	movs	r2, #118	@ 0x76
 80121a4:	615a      	str	r2, [r3, #20]
 80121a6:	687b      	ldr	r3, [r7, #4]
 80121a8:	681b      	ldr	r3, [r3, #0]
 80121aa:	69ba      	ldr	r2, [r7, #24]
 80121ac:	619a      	str	r2, [r3, #24]
 80121ae:	687b      	ldr	r3, [r7, #4]
 80121b0:	681b      	ldr	r3, [r3, #0]
 80121b2:	2200      	movs	r2, #0
 80121b4:	61da      	str	r2, [r3, #28]
 80121b6:	687b      	ldr	r3, [r7, #4]
 80121b8:	681b      	ldr	r3, [r3, #0]
 80121ba:	685b      	ldr	r3, [r3, #4]
 80121bc:	f04f 31ff 	mov.w	r1, #4294967295
 80121c0:	6878      	ldr	r0, [r7, #4]
 80121c2:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80121c4:	687b      	ldr	r3, [r7, #4]
 80121c6:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80121ca:	623b      	str	r3, [r7, #32]
 80121cc:	e02b      	b.n	8012226 <start_pass+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 80121ce:	6a3b      	ldr	r3, [r7, #32]
 80121d0:	009b      	lsls	r3, r3, #2
 80121d2:	697a      	ldr	r2, [r7, #20]
 80121d4:	4413      	add	r3, r2
 80121d6:	681b      	ldr	r3, [r3, #0]
 80121d8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80121dc:	613b      	str	r3, [r7, #16]
	if (cinfo->Ah != expected)
 80121de:	687b      	ldr	r3, [r7, #4]
 80121e0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80121e4:	693a      	ldr	r2, [r7, #16]
 80121e6:	429a      	cmp	r2, r3
 80121e8:	d012      	beq.n	8012210 <start_pass+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 80121ea:	687b      	ldr	r3, [r7, #4]
 80121ec:	681b      	ldr	r3, [r3, #0]
 80121ee:	2276      	movs	r2, #118	@ 0x76
 80121f0:	615a      	str	r2, [r3, #20]
 80121f2:	687b      	ldr	r3, [r7, #4]
 80121f4:	681b      	ldr	r3, [r3, #0]
 80121f6:	69ba      	ldr	r2, [r7, #24]
 80121f8:	619a      	str	r2, [r3, #24]
 80121fa:	687b      	ldr	r3, [r7, #4]
 80121fc:	681b      	ldr	r3, [r3, #0]
 80121fe:	6a3a      	ldr	r2, [r7, #32]
 8012200:	61da      	str	r2, [r3, #28]
 8012202:	687b      	ldr	r3, [r7, #4]
 8012204:	681b      	ldr	r3, [r3, #0]
 8012206:	685b      	ldr	r3, [r3, #4]
 8012208:	f04f 31ff 	mov.w	r1, #4294967295
 801220c:	6878      	ldr	r0, [r7, #4]
 801220e:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 8012210:	6a3b      	ldr	r3, [r7, #32]
 8012212:	009b      	lsls	r3, r3, #2
 8012214:	697a      	ldr	r2, [r7, #20]
 8012216:	4413      	add	r3, r2
 8012218:	687a      	ldr	r2, [r7, #4]
 801221a:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 801221e:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 8012220:	6a3b      	ldr	r3, [r7, #32]
 8012222:	3301      	adds	r3, #1
 8012224:	623b      	str	r3, [r7, #32]
 8012226:	687b      	ldr	r3, [r7, #4]
 8012228:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 801222c:	6a3a      	ldr	r2, [r7, #32]
 801222e:	429a      	cmp	r2, r3
 8012230:	ddcd      	ble.n	80121ce <start_pass+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012232:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012234:	3301      	adds	r3, #1
 8012236:	627b      	str	r3, [r7, #36]	@ 0x24
 8012238:	687b      	ldr	r3, [r7, #4]
 801223a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 801223e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012240:	429a      	cmp	r2, r3
 8012242:	db94      	blt.n	801216e <start_pass+0xd6>
      }
    }
    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 8012244:	687b      	ldr	r3, [r7, #4]
 8012246:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801224a:	2b00      	cmp	r3, #0
 801224c:	d10c      	bne.n	8012268 <start_pass+0x1d0>
      if (cinfo->Ss == 0)
 801224e:	687b      	ldr	r3, [r7, #4]
 8012250:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8012254:	2b00      	cmp	r3, #0
 8012256:	d103      	bne.n	8012260 <start_pass+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 8012258:	69fb      	ldr	r3, [r7, #28]
 801225a:	4a80      	ldr	r2, [pc, #512]	@ (801245c <start_pass+0x3c4>)
 801225c:	605a      	str	r2, [r3, #4]
 801225e:	e03a      	b.n	80122d6 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 8012260:	69fb      	ldr	r3, [r7, #28]
 8012262:	4a7f      	ldr	r2, [pc, #508]	@ (8012460 <start_pass+0x3c8>)
 8012264:	605a      	str	r2, [r3, #4]
 8012266:	e036      	b.n	80122d6 <start_pass+0x23e>
    } else {
      if (cinfo->Ss == 0)
 8012268:	687b      	ldr	r3, [r7, #4]
 801226a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801226e:	2b00      	cmp	r3, #0
 8012270:	d103      	bne.n	801227a <start_pass+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 8012272:	69fb      	ldr	r3, [r7, #28]
 8012274:	4a7b      	ldr	r2, [pc, #492]	@ (8012464 <start_pass+0x3cc>)
 8012276:	605a      	str	r2, [r3, #4]
 8012278:	e02d      	b.n	80122d6 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 801227a:	69fb      	ldr	r3, [r7, #28]
 801227c:	4a7a      	ldr	r2, [pc, #488]	@ (8012468 <start_pass+0x3d0>)
 801227e:	605a      	str	r2, [r3, #4]
 8012280:	e029      	b.n	80122d6 <start_pass+0x23e>
    }
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 8012282:	687b      	ldr	r3, [r7, #4]
 8012284:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8012288:	2b00      	cmp	r3, #0
 801228a:	d116      	bne.n	80122ba <start_pass+0x222>
 801228c:	687b      	ldr	r3, [r7, #4]
 801228e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8012292:	2b00      	cmp	r3, #0
 8012294:	d111      	bne.n	80122ba <start_pass+0x222>
 8012296:	687b      	ldr	r3, [r7, #4]
 8012298:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 801229c:	2b00      	cmp	r3, #0
 801229e:	d10c      	bne.n	80122ba <start_pass+0x222>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 80122a0:	687b      	ldr	r3, [r7, #4]
 80122a2:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 80122a6:	2b3f      	cmp	r3, #63	@ 0x3f
 80122a8:	dc12      	bgt.n	80122d0 <start_pass+0x238>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 80122aa:	687b      	ldr	r3, [r7, #4]
 80122ac:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80122b0:	687b      	ldr	r3, [r7, #4]
 80122b2:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80122b6:	429a      	cmp	r2, r3
 80122b8:	d00a      	beq.n	80122d0 <start_pass+0x238>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 80122ba:	687b      	ldr	r3, [r7, #4]
 80122bc:	681b      	ldr	r3, [r3, #0]
 80122be:	227d      	movs	r2, #125	@ 0x7d
 80122c0:	615a      	str	r2, [r3, #20]
 80122c2:	687b      	ldr	r3, [r7, #4]
 80122c4:	681b      	ldr	r3, [r3, #0]
 80122c6:	685b      	ldr	r3, [r3, #4]
 80122c8:	f04f 31ff 	mov.w	r1, #4294967295
 80122cc:	6878      	ldr	r0, [r7, #4]
 80122ce:	4798      	blx	r3
    /* Select MCU decoding routine */
    entropy->pub.decode_mcu = decode_mcu;
 80122d0:	69fb      	ldr	r3, [r7, #28]
 80122d2:	4a66      	ldr	r2, [pc, #408]	@ (801246c <start_pass+0x3d4>)
 80122d4:	605a      	str	r2, [r3, #4]
  }

  /* Allocate & initialize requested statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80122d6:	2300      	movs	r3, #0
 80122d8:	627b      	str	r3, [r7, #36]	@ 0x24
 80122da:	e0a4      	b.n	8012426 <start_pass+0x38e>
    compptr = cinfo->cur_comp_info[ci];
 80122dc:	687a      	ldr	r2, [r7, #4]
 80122de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80122e0:	3354      	adds	r3, #84	@ 0x54
 80122e2:	009b      	lsls	r3, r3, #2
 80122e4:	4413      	add	r3, r2
 80122e6:	685b      	ldr	r3, [r3, #4]
 80122e8:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 80122ea:	687b      	ldr	r3, [r7, #4]
 80122ec:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80122f0:	2b00      	cmp	r3, #0
 80122f2:	d009      	beq.n	8012308 <start_pass+0x270>
 80122f4:	687b      	ldr	r3, [r7, #4]
 80122f6:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80122fa:	2b00      	cmp	r3, #0
 80122fc:	d146      	bne.n	801238c <start_pass+0x2f4>
 80122fe:	687b      	ldr	r3, [r7, #4]
 8012300:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8012304:	2b00      	cmp	r3, #0
 8012306:	d141      	bne.n	801238c <start_pass+0x2f4>
      tbl = compptr->dc_tbl_no;
 8012308:	68fb      	ldr	r3, [r7, #12]
 801230a:	695b      	ldr	r3, [r3, #20]
 801230c:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 801230e:	68bb      	ldr	r3, [r7, #8]
 8012310:	2b00      	cmp	r3, #0
 8012312:	db02      	blt.n	801231a <start_pass+0x282>
 8012314:	68bb      	ldr	r3, [r7, #8]
 8012316:	2b0f      	cmp	r3, #15
 8012318:	dd0c      	ble.n	8012334 <start_pass+0x29c>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 801231a:	687b      	ldr	r3, [r7, #4]
 801231c:	681b      	ldr	r3, [r3, #0]
 801231e:	2232      	movs	r2, #50	@ 0x32
 8012320:	615a      	str	r2, [r3, #20]
 8012322:	687b      	ldr	r3, [r7, #4]
 8012324:	681b      	ldr	r3, [r3, #0]
 8012326:	68ba      	ldr	r2, [r7, #8]
 8012328:	619a      	str	r2, [r3, #24]
 801232a:	687b      	ldr	r3, [r7, #4]
 801232c:	681b      	ldr	r3, [r3, #0]
 801232e:	681b      	ldr	r3, [r3, #0]
 8012330:	6878      	ldr	r0, [r7, #4]
 8012332:	4798      	blx	r3
      if (entropy->dc_stats[tbl] == NULL)
 8012334:	69fb      	ldr	r3, [r7, #28]
 8012336:	68ba      	ldr	r2, [r7, #8]
 8012338:	320e      	adds	r2, #14
 801233a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801233e:	2b00      	cmp	r3, #0
 8012340:	d10c      	bne.n	801235c <start_pass+0x2c4>
	entropy->dc_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 8012342:	687b      	ldr	r3, [r7, #4]
 8012344:	685b      	ldr	r3, [r3, #4]
 8012346:	681b      	ldr	r3, [r3, #0]
 8012348:	2240      	movs	r2, #64	@ 0x40
 801234a:	2101      	movs	r1, #1
 801234c:	6878      	ldr	r0, [r7, #4]
 801234e:	4798      	blx	r3
 8012350:	4601      	mov	r1, r0
 8012352:	69fb      	ldr	r3, [r7, #28]
 8012354:	68ba      	ldr	r2, [r7, #8]
 8012356:	320e      	adds	r2, #14
 8012358:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, DC_STAT_BINS);
      MEMZERO(entropy->dc_stats[tbl], DC_STAT_BINS);
 801235c:	69fb      	ldr	r3, [r7, #28]
 801235e:	68ba      	ldr	r2, [r7, #8]
 8012360:	320e      	adds	r2, #14
 8012362:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012366:	2240      	movs	r2, #64	@ 0x40
 8012368:	2100      	movs	r1, #0
 801236a:	4618      	mov	r0, r3
 801236c:	f01b fa41 	bl	802d7f2 <memset>
      /* Initialize DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 8012370:	69fa      	ldr	r2, [r7, #28]
 8012372:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012374:	3304      	adds	r3, #4
 8012376:	009b      	lsls	r3, r3, #2
 8012378:	4413      	add	r3, r2
 801237a:	2200      	movs	r2, #0
 801237c:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 801237e:	69fa      	ldr	r2, [r7, #28]
 8012380:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012382:	3308      	adds	r3, #8
 8012384:	009b      	lsls	r3, r3, #2
 8012386:	4413      	add	r3, r2
 8012388:	2200      	movs	r2, #0
 801238a:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 801238c:	687b      	ldr	r3, [r7, #4]
 801238e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012392:	2b00      	cmp	r3, #0
 8012394:	d104      	bne.n	80123a0 <start_pass+0x308>
 8012396:	687b      	ldr	r3, [r7, #4]
 8012398:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801239c:	2b00      	cmp	r3, #0
 801239e:	d109      	bne.n	80123b4 <start_pass+0x31c>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80123a0:	687b      	ldr	r3, [r7, #4]
 80123a2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 80123a6:	2b00      	cmp	r3, #0
 80123a8:	d03a      	beq.n	8012420 <start_pass+0x388>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80123aa:	687b      	ldr	r3, [r7, #4]
 80123ac:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80123b0:	2b00      	cmp	r3, #0
 80123b2:	d035      	beq.n	8012420 <start_pass+0x388>
      tbl = compptr->ac_tbl_no;
 80123b4:	68fb      	ldr	r3, [r7, #12]
 80123b6:	699b      	ldr	r3, [r3, #24]
 80123b8:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 80123ba:	68bb      	ldr	r3, [r7, #8]
 80123bc:	2b00      	cmp	r3, #0
 80123be:	db02      	blt.n	80123c6 <start_pass+0x32e>
 80123c0:	68bb      	ldr	r3, [r7, #8]
 80123c2:	2b0f      	cmp	r3, #15
 80123c4:	dd0c      	ble.n	80123e0 <start_pass+0x348>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 80123c6:	687b      	ldr	r3, [r7, #4]
 80123c8:	681b      	ldr	r3, [r3, #0]
 80123ca:	2232      	movs	r2, #50	@ 0x32
 80123cc:	615a      	str	r2, [r3, #20]
 80123ce:	687b      	ldr	r3, [r7, #4]
 80123d0:	681b      	ldr	r3, [r3, #0]
 80123d2:	68ba      	ldr	r2, [r7, #8]
 80123d4:	619a      	str	r2, [r3, #24]
 80123d6:	687b      	ldr	r3, [r7, #4]
 80123d8:	681b      	ldr	r3, [r3, #0]
 80123da:	681b      	ldr	r3, [r3, #0]
 80123dc:	6878      	ldr	r0, [r7, #4]
 80123de:	4798      	blx	r3
      if (entropy->ac_stats[tbl] == NULL)
 80123e0:	69fb      	ldr	r3, [r7, #28]
 80123e2:	68ba      	ldr	r2, [r7, #8]
 80123e4:	321e      	adds	r2, #30
 80123e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80123ea:	2b00      	cmp	r3, #0
 80123ec:	d10d      	bne.n	801240a <start_pass+0x372>
	entropy->ac_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 80123ee:	687b      	ldr	r3, [r7, #4]
 80123f0:	685b      	ldr	r3, [r3, #4]
 80123f2:	681b      	ldr	r3, [r3, #0]
 80123f4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80123f8:	2101      	movs	r1, #1
 80123fa:	6878      	ldr	r0, [r7, #4]
 80123fc:	4798      	blx	r3
 80123fe:	4601      	mov	r1, r0
 8012400:	69fb      	ldr	r3, [r7, #28]
 8012402:	68ba      	ldr	r2, [r7, #8]
 8012404:	321e      	adds	r2, #30
 8012406:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, AC_STAT_BINS);
      MEMZERO(entropy->ac_stats[tbl], AC_STAT_BINS);
 801240a:	69fb      	ldr	r3, [r7, #28]
 801240c:	68ba      	ldr	r2, [r7, #8]
 801240e:	321e      	adds	r2, #30
 8012410:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012414:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8012418:	2100      	movs	r1, #0
 801241a:	4618      	mov	r0, r3
 801241c:	f01b f9e9 	bl	802d7f2 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012420:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012422:	3301      	adds	r3, #1
 8012424:	627b      	str	r3, [r7, #36]	@ 0x24
 8012426:	687b      	ldr	r3, [r7, #4]
 8012428:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 801242c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801242e:	429a      	cmp	r2, r3
 8012430:	f6ff af54 	blt.w	80122dc <start_pass+0x244>
    }
  }

  /* Initialize arithmetic decoding variables */
  entropy->c = 0;
 8012434:	69fb      	ldr	r3, [r7, #28]
 8012436:	2200      	movs	r2, #0
 8012438:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 801243a:	69fb      	ldr	r3, [r7, #28]
 801243c:	2200      	movs	r2, #0
 801243e:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 8012440:	69fb      	ldr	r3, [r7, #28]
 8012442:	f06f 020f 	mvn.w	r2, #15
 8012446:	611a      	str	r2, [r3, #16]

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8012448:	687b      	ldr	r3, [r7, #4]
 801244a:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801244e:	69fb      	ldr	r3, [r7, #28]
 8012450:	635a      	str	r2, [r3, #52]	@ 0x34
}
 8012452:	bf00      	nop
 8012454:	3728      	adds	r7, #40	@ 0x28
 8012456:	46bd      	mov	sp, r7
 8012458:	bd80      	pop	{r7, pc}
 801245a:	bf00      	nop
 801245c:	0801163d 	.word	0x0801163d
 8012460:	08011861 	.word	0x08011861
 8012464:	08011a61 	.word	0x08011a61
 8012468:	08011afb 	.word	0x08011afb
 801246c:	08011cd7 	.word	0x08011cd7

08012470 <jinit_arith_decoder>:
 * Module initialization routine for arithmetic entropy decoding.
 */

GLOBAL(void)
jinit_arith_decoder (j_decompress_ptr cinfo)
{
 8012470:	b580      	push	{r7, lr}
 8012472:	b086      	sub	sp, #24
 8012474:	af00      	add	r7, sp, #0
 8012476:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy;
  int i;

  entropy = (arith_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8012478:	687b      	ldr	r3, [r7, #4]
 801247a:	685b      	ldr	r3, [r3, #4]
 801247c:	681b      	ldr	r3, [r3, #0]
 801247e:	22bc      	movs	r2, #188	@ 0xbc
 8012480:	2101      	movs	r1, #1
 8012482:	6878      	ldr	r0, [r7, #4]
 8012484:	4798      	blx	r3
 8012486:	60b8      	str	r0, [r7, #8]
				SIZEOF(arith_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 8012488:	687b      	ldr	r3, [r7, #4]
 801248a:	68ba      	ldr	r2, [r7, #8]
 801248c:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
  entropy->pub.start_pass = start_pass;
 8012490:	68bb      	ldr	r3, [r7, #8]
 8012492:	4a27      	ldr	r2, [pc, #156]	@ (8012530 <jinit_arith_decoder+0xc0>)
 8012494:	601a      	str	r2, [r3, #0]

  /* Mark tables unallocated */
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 8012496:	2300      	movs	r3, #0
 8012498:	617b      	str	r3, [r7, #20]
 801249a:	e00e      	b.n	80124ba <jinit_arith_decoder+0x4a>
    entropy->dc_stats[i] = NULL;
 801249c:	68bb      	ldr	r3, [r7, #8]
 801249e:	697a      	ldr	r2, [r7, #20]
 80124a0:	320e      	adds	r2, #14
 80124a2:	2100      	movs	r1, #0
 80124a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    entropy->ac_stats[i] = NULL;
 80124a8:	68bb      	ldr	r3, [r7, #8]
 80124aa:	697a      	ldr	r2, [r7, #20]
 80124ac:	321e      	adds	r2, #30
 80124ae:	2100      	movs	r1, #0
 80124b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 80124b4:	697b      	ldr	r3, [r7, #20]
 80124b6:	3301      	adds	r3, #1
 80124b8:	617b      	str	r3, [r7, #20]
 80124ba:	697b      	ldr	r3, [r7, #20]
 80124bc:	2b0f      	cmp	r3, #15
 80124be:	dded      	ble.n	801249c <jinit_arith_decoder+0x2c>
  }

  /* Initialize index for fixed probability estimation */
  entropy->fixed_bin[0] = 113;
 80124c0:	68bb      	ldr	r3, [r7, #8]
 80124c2:	2271      	movs	r2, #113	@ 0x71
 80124c4:	f883 20b8 	strb.w	r2, [r3, #184]	@ 0xb8

  if (cinfo->progressive_mode) {
 80124c8:	687b      	ldr	r3, [r7, #4]
 80124ca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80124ce:	2b00      	cmp	r3, #0
 80124d0:	d02a      	beq.n	8012528 <jinit_arith_decoder+0xb8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80124d2:	687b      	ldr	r3, [r7, #4]
 80124d4:	685b      	ldr	r3, [r3, #4]
 80124d6:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 80124d8:	687a      	ldr	r2, [r7, #4]
 80124da:	6a52      	ldr	r2, [r2, #36]	@ 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80124dc:	0212      	lsls	r2, r2, #8
 80124de:	2101      	movs	r1, #1
 80124e0:	6878      	ldr	r0, [r7, #4]
 80124e2:	4798      	blx	r3
 80124e4:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 80124e6:	687b      	ldr	r3, [r7, #4]
 80124e8:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 80124ec:	687b      	ldr	r3, [r7, #4]
 80124ee:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80124f2:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++) 
 80124f4:	2300      	movs	r3, #0
 80124f6:	60fb      	str	r3, [r7, #12]
 80124f8:	e011      	b.n	801251e <jinit_arith_decoder+0xae>
      for (i = 0; i < DCTSIZE2; i++)
 80124fa:	2300      	movs	r3, #0
 80124fc:	617b      	str	r3, [r7, #20]
 80124fe:	e008      	b.n	8012512 <jinit_arith_decoder+0xa2>
	*coef_bit_ptr++ = -1;
 8012500:	693b      	ldr	r3, [r7, #16]
 8012502:	1d1a      	adds	r2, r3, #4
 8012504:	613a      	str	r2, [r7, #16]
 8012506:	f04f 32ff 	mov.w	r2, #4294967295
 801250a:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 801250c:	697b      	ldr	r3, [r7, #20]
 801250e:	3301      	adds	r3, #1
 8012510:	617b      	str	r3, [r7, #20]
 8012512:	697b      	ldr	r3, [r7, #20]
 8012514:	2b3f      	cmp	r3, #63	@ 0x3f
 8012516:	ddf3      	ble.n	8012500 <jinit_arith_decoder+0x90>
    for (ci = 0; ci < cinfo->num_components; ci++) 
 8012518:	68fb      	ldr	r3, [r7, #12]
 801251a:	3301      	adds	r3, #1
 801251c:	60fb      	str	r3, [r7, #12]
 801251e:	687b      	ldr	r3, [r7, #4]
 8012520:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012522:	68fa      	ldr	r2, [r7, #12]
 8012524:	429a      	cmp	r2, r3
 8012526:	dbe8      	blt.n	80124fa <jinit_arith_decoder+0x8a>
  }
}
 8012528:	bf00      	nop
 801252a:	3718      	adds	r7, #24
 801252c:	46bd      	mov	sp, r7
 801252e:	bd80      	pop	{r7, pc}
 8012530:	08012099 	.word	0x08012099

08012534 <init_mem_source>:
}
#endif /* 0 */

METHODDEF(void)
init_mem_source (j_decompress_ptr cinfo)
{
 8012534:	b480      	push	{r7}
 8012536:	b083      	sub	sp, #12
 8012538:	af00      	add	r7, sp, #0
 801253a:	6078      	str	r0, [r7, #4]
  /* no work necessary here */
}
 801253c:	bf00      	nop
 801253e:	370c      	adds	r7, #12
 8012540:	46bd      	mov	sp, r7
 8012542:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012546:	4770      	bx	lr

08012548 <fill_mem_input_buffer>:
}
#endif /* JFILE */

METHODDEF(boolean)
fill_mem_input_buffer (j_decompress_ptr cinfo)
{
 8012548:	b580      	push	{r7, lr}
 801254a:	b082      	sub	sp, #8
 801254c:	af00      	add	r7, sp, #0
 801254e:	6078      	str	r0, [r7, #4]

  /* The whole JPEG data is expected to reside in the supplied memory
   * buffer, so any request for more data beyond the given buffer size
   * is treated as an error.
   */
  WARNMS(cinfo, JWRN_JPEG_EOF);
 8012550:	687b      	ldr	r3, [r7, #4]
 8012552:	681b      	ldr	r3, [r3, #0]
 8012554:	227b      	movs	r2, #123	@ 0x7b
 8012556:	615a      	str	r2, [r3, #20]
 8012558:	687b      	ldr	r3, [r7, #4]
 801255a:	681b      	ldr	r3, [r3, #0]
 801255c:	685b      	ldr	r3, [r3, #4]
 801255e:	f04f 31ff 	mov.w	r1, #4294967295
 8012562:	6878      	ldr	r0, [r7, #4]
 8012564:	4798      	blx	r3

  /* Insert a fake EOI marker */

  cinfo->src->next_input_byte = mybuffer;
 8012566:	687b      	ldr	r3, [r7, #4]
 8012568:	699b      	ldr	r3, [r3, #24]
 801256a:	4a05      	ldr	r2, [pc, #20]	@ (8012580 <fill_mem_input_buffer+0x38>)
 801256c:	601a      	str	r2, [r3, #0]
  cinfo->src->bytes_in_buffer = 2;
 801256e:	687b      	ldr	r3, [r7, #4]
 8012570:	699b      	ldr	r3, [r3, #24]
 8012572:	2202      	movs	r2, #2
 8012574:	605a      	str	r2, [r3, #4]

  return TRUE;
 8012576:	2301      	movs	r3, #1
}
 8012578:	4618      	mov	r0, r3
 801257a:	3708      	adds	r7, #8
 801257c:	46bd      	mov	sp, r7
 801257e:	bd80      	pop	{r7, pc}
 8012580:	08030160 	.word	0x08030160

08012584 <skip_input_data>:
 * buffer is the application writer's problem.
 */

METHODDEF(void)
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
 8012584:	b580      	push	{r7, lr}
 8012586:	b084      	sub	sp, #16
 8012588:	af00      	add	r7, sp, #0
 801258a:	6078      	str	r0, [r7, #4]
 801258c:	6039      	str	r1, [r7, #0]
  struct jpeg_source_mgr * src = cinfo->src;
 801258e:	687b      	ldr	r3, [r7, #4]
 8012590:	699b      	ldr	r3, [r3, #24]
 8012592:	60fb      	str	r3, [r7, #12]

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
 8012594:	683b      	ldr	r3, [r7, #0]
 8012596:	2b00      	cmp	r3, #0
 8012598:	dd1c      	ble.n	80125d4 <skip_input_data+0x50>
    while (num_bytes > (long) src->bytes_in_buffer) {
 801259a:	e009      	b.n	80125b0 <skip_input_data+0x2c>
      num_bytes -= (long) src->bytes_in_buffer;
 801259c:	68fb      	ldr	r3, [r7, #12]
 801259e:	685b      	ldr	r3, [r3, #4]
 80125a0:	461a      	mov	r2, r3
 80125a2:	683b      	ldr	r3, [r7, #0]
 80125a4:	1a9b      	subs	r3, r3, r2
 80125a6:	603b      	str	r3, [r7, #0]
      (void) (*src->fill_input_buffer) (cinfo);
 80125a8:	68fb      	ldr	r3, [r7, #12]
 80125aa:	68db      	ldr	r3, [r3, #12]
 80125ac:	6878      	ldr	r0, [r7, #4]
 80125ae:	4798      	blx	r3
    while (num_bytes > (long) src->bytes_in_buffer) {
 80125b0:	68fb      	ldr	r3, [r7, #12]
 80125b2:	685b      	ldr	r3, [r3, #4]
 80125b4:	461a      	mov	r2, r3
 80125b6:	683b      	ldr	r3, [r7, #0]
 80125b8:	4293      	cmp	r3, r2
 80125ba:	dcef      	bgt.n	801259c <skip_input_data+0x18>
      /* note we assume that fill_input_buffer will never return FALSE,
       * so suspension need not be handled.
       */
    }
    src->next_input_byte += (size_t) num_bytes;
 80125bc:	68fb      	ldr	r3, [r7, #12]
 80125be:	681a      	ldr	r2, [r3, #0]
 80125c0:	683b      	ldr	r3, [r7, #0]
 80125c2:	441a      	add	r2, r3
 80125c4:	68fb      	ldr	r3, [r7, #12]
 80125c6:	601a      	str	r2, [r3, #0]
    src->bytes_in_buffer -= (size_t) num_bytes;
 80125c8:	68fb      	ldr	r3, [r7, #12]
 80125ca:	685a      	ldr	r2, [r3, #4]
 80125cc:	683b      	ldr	r3, [r7, #0]
 80125ce:	1ad2      	subs	r2, r2, r3
 80125d0:	68fb      	ldr	r3, [r7, #12]
 80125d2:	605a      	str	r2, [r3, #4]
  }
}
 80125d4:	bf00      	nop
 80125d6:	3710      	adds	r7, #16
 80125d8:	46bd      	mov	sp, r7
 80125da:	bd80      	pop	{r7, pc}

080125dc <term_source>:
 * for error exit.
 */

METHODDEF(void)
term_source (j_decompress_ptr cinfo)
{
 80125dc:	b480      	push	{r7}
 80125de:	b083      	sub	sp, #12
 80125e0:	af00      	add	r7, sp, #0
 80125e2:	6078      	str	r0, [r7, #4]
  /* no work necessary here */
}
 80125e4:	bf00      	nop
 80125e6:	370c      	adds	r7, #12
 80125e8:	46bd      	mov	sp, r7
 80125ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125ee:	4770      	bx	lr

080125f0 <jpeg_mem_src>:
 */

GLOBAL(void)
jpeg_mem_src (j_decompress_ptr cinfo,
	      unsigned char * inbuffer, unsigned long insize)
{
 80125f0:	b580      	push	{r7, lr}
 80125f2:	b086      	sub	sp, #24
 80125f4:	af00      	add	r7, sp, #0
 80125f6:	60f8      	str	r0, [r7, #12]
 80125f8:	60b9      	str	r1, [r7, #8]
 80125fa:	607a      	str	r2, [r7, #4]
  struct jpeg_source_mgr * src;

  if (inbuffer == NULL || insize == 0)	/* Treat empty input as fatal error */
 80125fc:	68bb      	ldr	r3, [r7, #8]
 80125fe:	2b00      	cmp	r3, #0
 8012600:	d002      	beq.n	8012608 <jpeg_mem_src+0x18>
 8012602:	687b      	ldr	r3, [r7, #4]
 8012604:	2b00      	cmp	r3, #0
 8012606:	d108      	bne.n	801261a <jpeg_mem_src+0x2a>
    ERREXIT(cinfo, JERR_INPUT_EMPTY);
 8012608:	68fb      	ldr	r3, [r7, #12]
 801260a:	681b      	ldr	r3, [r3, #0]
 801260c:	222b      	movs	r2, #43	@ 0x2b
 801260e:	615a      	str	r2, [r3, #20]
 8012610:	68fb      	ldr	r3, [r7, #12]
 8012612:	681b      	ldr	r3, [r3, #0]
 8012614:	681b      	ldr	r3, [r3, #0]
 8012616:	68f8      	ldr	r0, [r7, #12]
 8012618:	4798      	blx	r3

  /* The source object is made permanent so that a series of JPEG images
   * can be read from the same buffer by calling jpeg_mem_src only before
   * the first one.
   */
  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
 801261a:	68fb      	ldr	r3, [r7, #12]
 801261c:	699b      	ldr	r3, [r3, #24]
 801261e:	2b00      	cmp	r3, #0
 8012620:	d109      	bne.n	8012636 <jpeg_mem_src+0x46>
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 8012622:	68fb      	ldr	r3, [r7, #12]
 8012624:	685b      	ldr	r3, [r3, #4]
 8012626:	681b      	ldr	r3, [r3, #0]
 8012628:	221c      	movs	r2, #28
 801262a:	2100      	movs	r1, #0
 801262c:	68f8      	ldr	r0, [r7, #12]
 801262e:	4798      	blx	r3
 8012630:	4602      	mov	r2, r0
    cinfo->src = (struct jpeg_source_mgr *)
 8012632:	68fb      	ldr	r3, [r7, #12]
 8012634:	619a      	str	r2, [r3, #24]
				  SIZEOF(struct jpeg_source_mgr));
  }

  src = cinfo->src;
 8012636:	68fb      	ldr	r3, [r7, #12]
 8012638:	699b      	ldr	r3, [r3, #24]
 801263a:	617b      	str	r3, [r7, #20]
  src->init_source = init_mem_source;
 801263c:	697b      	ldr	r3, [r7, #20]
 801263e:	4a0c      	ldr	r2, [pc, #48]	@ (8012670 <jpeg_mem_src+0x80>)
 8012640:	609a      	str	r2, [r3, #8]
  src->fill_input_buffer = fill_mem_input_buffer;
 8012642:	697b      	ldr	r3, [r7, #20]
 8012644:	4a0b      	ldr	r2, [pc, #44]	@ (8012674 <jpeg_mem_src+0x84>)
 8012646:	60da      	str	r2, [r3, #12]
  src->skip_input_data = skip_input_data;
 8012648:	697b      	ldr	r3, [r7, #20]
 801264a:	4a0b      	ldr	r2, [pc, #44]	@ (8012678 <jpeg_mem_src+0x88>)
 801264c:	611a      	str	r2, [r3, #16]
  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */
 801264e:	697b      	ldr	r3, [r7, #20]
 8012650:	4a0a      	ldr	r2, [pc, #40]	@ (801267c <jpeg_mem_src+0x8c>)
 8012652:	615a      	str	r2, [r3, #20]
  src->term_source = term_source;
 8012654:	697b      	ldr	r3, [r7, #20]
 8012656:	4a0a      	ldr	r2, [pc, #40]	@ (8012680 <jpeg_mem_src+0x90>)
 8012658:	619a      	str	r2, [r3, #24]
  src->bytes_in_buffer = (size_t) insize;
 801265a:	697b      	ldr	r3, [r7, #20]
 801265c:	687a      	ldr	r2, [r7, #4]
 801265e:	605a      	str	r2, [r3, #4]
  src->next_input_byte = (JOCTET *) inbuffer;
 8012660:	697b      	ldr	r3, [r7, #20]
 8012662:	68ba      	ldr	r2, [r7, #8]
 8012664:	601a      	str	r2, [r3, #0]
}
 8012666:	bf00      	nop
 8012668:	3718      	adds	r7, #24
 801266a:	46bd      	mov	sp, r7
 801266c:	bd80      	pop	{r7, pc}
 801266e:	bf00      	nop
 8012670:	08012535 	.word	0x08012535
 8012674:	08012549 	.word	0x08012549
 8012678:	08012585 	.word	0x08012585
 801267c:	0801a6c9 	.word	0x0801a6c9
 8012680:	080125dd 	.word	0x080125dd

08012684 <start_iMCU_row>:


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
 8012684:	b480      	push	{r7}
 8012686:	b085      	sub	sp, #20
 8012688:	af00      	add	r7, sp, #0
 801268a:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 801268c:	687b      	ldr	r3, [r7, #4]
 801268e:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012692:	60fb      	str	r3, [r7, #12]

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
 8012694:	687b      	ldr	r3, [r7, #4]
 8012696:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 801269a:	2b01      	cmp	r3, #1
 801269c:	dd03      	ble.n	80126a6 <start_iMCU_row+0x22>
    coef->MCU_rows_per_iMCU_row = 1;
 801269e:	68fb      	ldr	r3, [r7, #12]
 80126a0:	2201      	movs	r2, #1
 80126a2:	61da      	str	r2, [r3, #28]
 80126a4:	e015      	b.n	80126d2 <start_iMCU_row+0x4e>
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
 80126a6:	687b      	ldr	r3, [r7, #4]
 80126a8:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 80126ac:	687b      	ldr	r3, [r7, #4]
 80126ae:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80126b2:	3b01      	subs	r3, #1
 80126b4:	429a      	cmp	r2, r3
 80126b6:	d206      	bcs.n	80126c6 <start_iMCU_row+0x42>
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
 80126b8:	687b      	ldr	r3, [r7, #4]
 80126ba:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80126be:	68da      	ldr	r2, [r3, #12]
 80126c0:	68fb      	ldr	r3, [r7, #12]
 80126c2:	61da      	str	r2, [r3, #28]
 80126c4:	e005      	b.n	80126d2 <start_iMCU_row+0x4e>
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
 80126c6:	687b      	ldr	r3, [r7, #4]
 80126c8:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80126cc:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80126ce:	68fb      	ldr	r3, [r7, #12]
 80126d0:	61da      	str	r2, [r3, #28]
  }

  coef->MCU_ctr = 0;
 80126d2:	68fb      	ldr	r3, [r7, #12]
 80126d4:	2200      	movs	r2, #0
 80126d6:	615a      	str	r2, [r3, #20]
  coef->MCU_vert_offset = 0;
 80126d8:	68fb      	ldr	r3, [r7, #12]
 80126da:	2200      	movs	r2, #0
 80126dc:	619a      	str	r2, [r3, #24]
}
 80126de:	bf00      	nop
 80126e0:	3714      	adds	r7, #20
 80126e2:	46bd      	mov	sp, r7
 80126e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126e8:	4770      	bx	lr

080126ea <start_input_pass>:
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 80126ea:	b580      	push	{r7, lr}
 80126ec:	b082      	sub	sp, #8
 80126ee:	af00      	add	r7, sp, #0
 80126f0:	6078      	str	r0, [r7, #4]
  cinfo->input_iMCU_row = 0;
 80126f2:	687b      	ldr	r3, [r7, #4]
 80126f4:	2200      	movs	r2, #0
 80126f6:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  start_iMCU_row(cinfo);
 80126fa:	6878      	ldr	r0, [r7, #4]
 80126fc:	f7ff ffc2 	bl	8012684 <start_iMCU_row>
}
 8012700:	bf00      	nop
 8012702:	3708      	adds	r7, #8
 8012704:	46bd      	mov	sp, r7
 8012706:	bd80      	pop	{r7, pc}

08012708 <start_output_pass>:
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
 8012708:	b580      	push	{r7, lr}
 801270a:	b084      	sub	sp, #16
 801270c:	af00      	add	r7, sp, #0
 801270e:	6078      	str	r0, [r7, #4]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012710:	687b      	ldr	r3, [r7, #4]
 8012712:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012716:	60fb      	str	r3, [r7, #12]

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
 8012718:	68fb      	ldr	r3, [r7, #12]
 801271a:	691b      	ldr	r3, [r3, #16]
 801271c:	2b00      	cmp	r3, #0
 801271e:	d010      	beq.n	8012742 <start_output_pass+0x3a>
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
 8012720:	687b      	ldr	r3, [r7, #4]
 8012722:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012724:	2b00      	cmp	r3, #0
 8012726:	d009      	beq.n	801273c <start_output_pass+0x34>
 8012728:	6878      	ldr	r0, [r7, #4]
 801272a:	f000 fad0 	bl	8012cce <smoothing_ok>
 801272e:	4603      	mov	r3, r0
 8012730:	2b00      	cmp	r3, #0
 8012732:	d003      	beq.n	801273c <start_output_pass+0x34>
      coef->pub.decompress_data = decompress_smooth_data;
 8012734:	68fb      	ldr	r3, [r7, #12]
 8012736:	4a07      	ldr	r2, [pc, #28]	@ (8012754 <start_output_pass+0x4c>)
 8012738:	60da      	str	r2, [r3, #12]
 801273a:	e002      	b.n	8012742 <start_output_pass+0x3a>
    else
      coef->pub.decompress_data = decompress_data;
 801273c:	68fb      	ldr	r3, [r7, #12]
 801273e:	4a06      	ldr	r2, [pc, #24]	@ (8012758 <start_output_pass+0x50>)
 8012740:	60da      	str	r2, [r3, #12]
  }
#endif
  cinfo->output_iMCU_row = 0;
 8012742:	687b      	ldr	r3, [r7, #4]
 8012744:	2200      	movs	r2, #0
 8012746:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
}
 801274a:	bf00      	nop
 801274c:	3710      	adds	r7, #16
 801274e:	46bd      	mov	sp, r7
 8012750:	bd80      	pop	{r7, pc}
 8012752:	bf00      	nop
 8012754:	08012df5 	.word	0x08012df5
 8012758:	08012b25 	.word	0x08012b25

0801275c <decompress_onepass>:
 * which we index according to the component's SOF position.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 801275c:	b590      	push	{r4, r7, lr}
 801275e:	b095      	sub	sp, #84	@ 0x54
 8012760:	af02      	add	r7, sp, #8
 8012762:	6078      	str	r0, [r7, #4]
 8012764:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012766:	687b      	ldr	r3, [r7, #4]
 8012768:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801276c:	627b      	str	r3, [r7, #36]	@ 0x24
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
 801276e:	687b      	ldr	r3, [r7, #4]
 8012770:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8012774:	3b01      	subs	r3, #1
 8012776:	623b      	str	r3, [r7, #32]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 8012778:	687b      	ldr	r3, [r7, #4]
 801277a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801277e:	3b01      	subs	r3, #1
 8012780:	61fb      	str	r3, [r7, #28]
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8012782:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012784:	699b      	ldr	r3, [r3, #24]
 8012786:	633b      	str	r3, [r7, #48]	@ 0x30
 8012788:	e0bf      	b.n	801290a <decompress_onepass+0x1ae>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 801278a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801278c:	695b      	ldr	r3, [r3, #20]
 801278e:	647b      	str	r3, [r7, #68]	@ 0x44
 8012790:	e0b0      	b.n	80128f4 <decompress_onepass+0x198>
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      if (cinfo->lim_Se)	/* can bypass in DC only case */
 8012792:	687b      	ldr	r3, [r7, #4]
 8012794:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8012798:	2b00      	cmp	r3, #0
 801279a:	d009      	beq.n	80127b0 <decompress_onepass+0x54>
	FMEMZERO((void FAR *) coef->MCU_buffer[0],
 801279c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801279e:	6a18      	ldr	r0, [r3, #32]
 80127a0:	687b      	ldr	r3, [r7, #4]
 80127a2:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 80127a6:	01db      	lsls	r3, r3, #7
 80127a8:	461a      	mov	r2, r3
 80127aa:	2100      	movs	r1, #0
 80127ac:	f01b f821 	bl	802d7f2 <memset>
		 (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 80127b0:	687b      	ldr	r3, [r7, #4]
 80127b2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80127b6:	685b      	ldr	r3, [r3, #4]
 80127b8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80127ba:	3220      	adds	r2, #32
 80127bc:	4611      	mov	r1, r2
 80127be:	6878      	ldr	r0, [r7, #4]
 80127c0:	4798      	blx	r3
 80127c2:	4603      	mov	r3, r0
 80127c4:	2b00      	cmp	r3, #0
 80127c6:	d107      	bne.n	80127d8 <decompress_onepass+0x7c>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 80127c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80127ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80127cc:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 80127ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80127d0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80127d2:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 80127d4:	2300      	movs	r3, #0
 80127d6:	e0c0      	b.n	801295a <decompress_onepass+0x1fe>
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
 80127d8:	2300      	movs	r3, #0
 80127da:	643b      	str	r3, [r7, #64]	@ 0x40
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80127dc:	2300      	movs	r3, #0
 80127de:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80127e0:	e07e      	b.n	80128e0 <decompress_onepass+0x184>
	compptr = cinfo->cur_comp_info[ci];
 80127e2:	687a      	ldr	r2, [r7, #4]
 80127e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80127e6:	3354      	adds	r3, #84	@ 0x54
 80127e8:	009b      	lsls	r3, r3, #2
 80127ea:	4413      	add	r3, r2
 80127ec:	685b      	ldr	r3, [r3, #4]
 80127ee:	61bb      	str	r3, [r7, #24]
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
 80127f0:	69bb      	ldr	r3, [r7, #24]
 80127f2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80127f4:	2b00      	cmp	r3, #0
 80127f6:	d105      	bne.n	8012804 <decompress_onepass+0xa8>
	  blkn += compptr->MCU_blocks;
 80127f8:	69bb      	ldr	r3, [r7, #24]
 80127fa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80127fc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80127fe:	4413      	add	r3, r2
 8012800:	643b      	str	r3, [r7, #64]	@ 0x40
	  continue;
 8012802:	e06a      	b.n	80128da <decompress_onepass+0x17e>
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
 8012804:	687b      	ldr	r3, [r7, #4]
 8012806:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 801280a:	69bb      	ldr	r3, [r7, #24]
 801280c:	685b      	ldr	r3, [r3, #4]
 801280e:	009b      	lsls	r3, r3, #2
 8012810:	4413      	add	r3, r2
 8012812:	685b      	ldr	r3, [r3, #4]
 8012814:	617b      	str	r3, [r7, #20]
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
 8012816:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8012818:	6a3b      	ldr	r3, [r7, #32]
 801281a:	429a      	cmp	r2, r3
 801281c:	d202      	bcs.n	8012824 <decompress_onepass+0xc8>
 801281e:	69bb      	ldr	r3, [r7, #24]
 8012820:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012822:	e001      	b.n	8012828 <decompress_onepass+0xcc>
 8012824:	69bb      	ldr	r3, [r7, #24]
 8012826:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
 8012828:	613b      	str	r3, [r7, #16]
	output_ptr = output_buf[compptr->component_index] +
 801282a:	69bb      	ldr	r3, [r7, #24]
 801282c:	685b      	ldr	r3, [r3, #4]
 801282e:	009b      	lsls	r3, r3, #2
 8012830:	683a      	ldr	r2, [r7, #0]
 8012832:	4413      	add	r3, r2
 8012834:	681a      	ldr	r2, [r3, #0]
	  yoffset * compptr->DCT_v_scaled_size;
 8012836:	69bb      	ldr	r3, [r7, #24]
 8012838:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801283a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801283c:	fb01 f303 	mul.w	r3, r1, r3
	output_ptr = output_buf[compptr->component_index] +
 8012840:	009b      	lsls	r3, r3, #2
 8012842:	4413      	add	r3, r2
 8012844:	62fb      	str	r3, [r7, #44]	@ 0x2c
	start_col = MCU_col_num * compptr->MCU_sample_width;
 8012846:	69bb      	ldr	r3, [r7, #24]
 8012848:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801284a:	461a      	mov	r2, r3
 801284c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801284e:	fb02 f303 	mul.w	r3, r2, r3
 8012852:	60fb      	str	r3, [r7, #12]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8012854:	2300      	movs	r3, #0
 8012856:	637b      	str	r3, [r7, #52]	@ 0x34
 8012858:	e03a      	b.n	80128d0 <decompress_onepass+0x174>
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 801285a:	687b      	ldr	r3, [r7, #4]
 801285c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012860:	69fa      	ldr	r2, [r7, #28]
 8012862:	429a      	cmp	r2, r3
 8012864:	d806      	bhi.n	8012874 <decompress_onepass+0x118>
	      yoffset+yindex < compptr->last_row_height) {
 8012866:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012868:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801286a:	441a      	add	r2, r3
 801286c:	69bb      	ldr	r3, [r7, #24]
 801286e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 8012870:	429a      	cmp	r2, r3
 8012872:	da1f      	bge.n	80128b4 <decompress_onepass+0x158>
	    output_col = start_col;
 8012874:	68fb      	ldr	r3, [r7, #12]
 8012876:	62bb      	str	r3, [r7, #40]	@ 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 8012878:	2300      	movs	r3, #0
 801287a:	63bb      	str	r3, [r7, #56]	@ 0x38
 801287c:	e016      	b.n	80128ac <decompress_onepass+0x150>
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
 801287e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012880:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012882:	441a      	add	r2, r3
 8012884:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012886:	3208      	adds	r2, #8
 8012888:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	      (*inverse_DCT) (cinfo, compptr,
 801288c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801288e:	9300      	str	r3, [sp, #0]
 8012890:	697c      	ldr	r4, [r7, #20]
 8012892:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012894:	69b9      	ldr	r1, [r7, #24]
 8012896:	6878      	ldr	r0, [r7, #4]
 8012898:	47a0      	blx	r4
			      output_ptr, output_col);
	      output_col += compptr->DCT_h_scaled_size;
 801289a:	69bb      	ldr	r3, [r7, #24]
 801289c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801289e:	461a      	mov	r2, r3
 80128a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80128a2:	4413      	add	r3, r2
 80128a4:	62bb      	str	r3, [r7, #40]	@ 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 80128a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80128a8:	3301      	adds	r3, #1
 80128aa:	63bb      	str	r3, [r7, #56]	@ 0x38
 80128ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80128ae:	693b      	ldr	r3, [r7, #16]
 80128b0:	429a      	cmp	r2, r3
 80128b2:	dbe4      	blt.n	801287e <decompress_onepass+0x122>
	    }
	  }
	  blkn += compptr->MCU_width;
 80128b4:	69bb      	ldr	r3, [r7, #24]
 80128b6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80128b8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80128ba:	4413      	add	r3, r2
 80128bc:	643b      	str	r3, [r7, #64]	@ 0x40
	  output_ptr += compptr->DCT_v_scaled_size;
 80128be:	69bb      	ldr	r3, [r7, #24]
 80128c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80128c2:	009b      	lsls	r3, r3, #2
 80128c4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80128c6:	4413      	add	r3, r2
 80128c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 80128ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80128cc:	3301      	adds	r3, #1
 80128ce:	637b      	str	r3, [r7, #52]	@ 0x34
 80128d0:	69bb      	ldr	r3, [r7, #24]
 80128d2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80128d4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80128d6:	429a      	cmp	r2, r3
 80128d8:	dbbf      	blt.n	801285a <decompress_onepass+0xfe>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80128da:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80128dc:	3301      	adds	r3, #1
 80128de:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80128e0:	687b      	ldr	r3, [r7, #4]
 80128e2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80128e6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80128e8:	429a      	cmp	r2, r3
 80128ea:	f6ff af7a 	blt.w	80127e2 <decompress_onepass+0x86>
	 MCU_col_num++) {
 80128ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80128f0:	3301      	adds	r3, #1
 80128f2:	647b      	str	r3, [r7, #68]	@ 0x44
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 80128f4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80128f6:	6a3b      	ldr	r3, [r7, #32]
 80128f8:	429a      	cmp	r2, r3
 80128fa:	f67f af4a 	bls.w	8012792 <decompress_onepass+0x36>
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 80128fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012900:	2200      	movs	r2, #0
 8012902:	615a      	str	r2, [r3, #20]
       yoffset++) {
 8012904:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012906:	3301      	adds	r3, #1
 8012908:	633b      	str	r3, [r7, #48]	@ 0x30
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 801290a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801290c:	69db      	ldr	r3, [r3, #28]
 801290e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012910:	429a      	cmp	r2, r3
 8012912:	f6ff af3a 	blt.w	801278a <decompress_onepass+0x2e>
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
 8012916:	687b      	ldr	r3, [r7, #4]
 8012918:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 801291c:	1c5a      	adds	r2, r3, #1
 801291e:	687b      	ldr	r3, [r7, #4]
 8012920:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 8012924:	687b      	ldr	r3, [r7, #4]
 8012926:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 801292a:	1c5a      	adds	r2, r3, #1
 801292c:	687b      	ldr	r3, [r7, #4]
 801292e:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 8012932:	687b      	ldr	r3, [r7, #4]
 8012934:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8012938:	687b      	ldr	r3, [r7, #4]
 801293a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801293e:	429a      	cmp	r2, r3
 8012940:	d204      	bcs.n	801294c <decompress_onepass+0x1f0>
    start_iMCU_row(cinfo);
 8012942:	6878      	ldr	r0, [r7, #4]
 8012944:	f7ff fe9e 	bl	8012684 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 8012948:	2303      	movs	r3, #3
 801294a:	e006      	b.n	801295a <decompress_onepass+0x1fe>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 801294c:	687b      	ldr	r3, [r7, #4]
 801294e:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8012952:	68db      	ldr	r3, [r3, #12]
 8012954:	6878      	ldr	r0, [r7, #4]
 8012956:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 8012958:	2304      	movs	r3, #4
}
 801295a:	4618      	mov	r0, r3
 801295c:	374c      	adds	r7, #76	@ 0x4c
 801295e:	46bd      	mov	sp, r7
 8012960:	bd90      	pop	{r4, r7, pc}

08012962 <dummy_consume_data>:
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
 8012962:	b480      	push	{r7}
 8012964:	b083      	sub	sp, #12
 8012966:	af00      	add	r7, sp, #0
 8012968:	6078      	str	r0, [r7, #4]
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
 801296a:	2300      	movs	r3, #0
}
 801296c:	4618      	mov	r0, r3
 801296e:	370c      	adds	r7, #12
 8012970:	46bd      	mov	sp, r7
 8012972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012976:	4770      	bx	lr

08012978 <consume_data>:
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
 8012978:	b590      	push	{r4, r7, lr}
 801297a:	b093      	sub	sp, #76	@ 0x4c
 801297c:	af02      	add	r7, sp, #8
 801297e:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012980:	687b      	ldr	r3, [r7, #4]
 8012982:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012986:	623b      	str	r3, [r7, #32]
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012988:	2300      	movs	r3, #0
 801298a:	637b      	str	r3, [r7, #52]	@ 0x34
 801298c:	e028      	b.n	80129e0 <consume_data+0x68>
    compptr = cinfo->cur_comp_info[ci];
 801298e:	687a      	ldr	r2, [r7, #4]
 8012990:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012992:	3354      	adds	r3, #84	@ 0x54
 8012994:	009b      	lsls	r3, r3, #2
 8012996:	4413      	add	r3, r2
 8012998:	685b      	ldr	r3, [r3, #4]
 801299a:	61fb      	str	r3, [r7, #28]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 801299c:	687b      	ldr	r3, [r7, #4]
 801299e:	685b      	ldr	r3, [r3, #4]
 80129a0:	6a1c      	ldr	r4, [r3, #32]
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
 80129a2:	69fb      	ldr	r3, [r7, #28]
 80129a4:	685a      	ldr	r2, [r3, #4]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 80129a6:	6a3b      	ldr	r3, [r7, #32]
 80129a8:	3212      	adds	r2, #18
 80129aa:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
       cinfo->input_iMCU_row * compptr->v_samp_factor,
 80129ae:	687b      	ldr	r3, [r7, #4]
 80129b0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80129b4:	69fa      	ldr	r2, [r7, #28]
 80129b6:	68d2      	ldr	r2, [r2, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 80129b8:	fb03 f202 	mul.w	r2, r3, r2
       (JDIMENSION) compptr->v_samp_factor, TRUE);
 80129bc:	69fb      	ldr	r3, [r7, #28]
 80129be:	68db      	ldr	r3, [r3, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 80129c0:	4618      	mov	r0, r3
 80129c2:	2301      	movs	r3, #1
 80129c4:	9300      	str	r3, [sp, #0]
 80129c6:	4603      	mov	r3, r0
 80129c8:	6878      	ldr	r0, [r7, #4]
 80129ca:	47a0      	blx	r4
 80129cc:	4602      	mov	r2, r0
 80129ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80129d0:	009b      	lsls	r3, r3, #2
 80129d2:	3340      	adds	r3, #64	@ 0x40
 80129d4:	443b      	add	r3, r7
 80129d6:	f843 2c38 	str.w	r2, [r3, #-56]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80129da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80129dc:	3301      	adds	r3, #1
 80129de:	637b      	str	r3, [r7, #52]	@ 0x34
 80129e0:	687b      	ldr	r3, [r7, #4]
 80129e2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80129e6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80129e8:	429a      	cmp	r2, r3
 80129ea:	dbd0      	blt.n	801298e <consume_data+0x16>
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 80129ec:	6a3b      	ldr	r3, [r7, #32]
 80129ee:	699b      	ldr	r3, [r3, #24]
 80129f0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80129f2:	e073      	b.n	8012adc <consume_data+0x164>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 80129f4:	6a3b      	ldr	r3, [r7, #32]
 80129f6:	695b      	ldr	r3, [r3, #20]
 80129f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80129fa:	e063      	b.n	8012ac4 <consume_data+0x14c>
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
 80129fc:	2300      	movs	r3, #0
 80129fe:	63bb      	str	r3, [r7, #56]	@ 0x38
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012a00:	2300      	movs	r3, #0
 8012a02:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a04:	e041      	b.n	8012a8a <consume_data+0x112>
	compptr = cinfo->cur_comp_info[ci];
 8012a06:	687a      	ldr	r2, [r7, #4]
 8012a08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012a0a:	3354      	adds	r3, #84	@ 0x54
 8012a0c:	009b      	lsls	r3, r3, #2
 8012a0e:	4413      	add	r3, r2
 8012a10:	685b      	ldr	r3, [r3, #4]
 8012a12:	61fb      	str	r3, [r7, #28]
	start_col = MCU_col_num * compptr->MCU_width;
 8012a14:	69fb      	ldr	r3, [r7, #28]
 8012a16:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012a18:	461a      	mov	r2, r3
 8012a1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012a1c:	fb02 f303 	mul.w	r3, r2, r3
 8012a20:	61bb      	str	r3, [r7, #24]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8012a22:	2300      	movs	r3, #0
 8012a24:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012a26:	e028      	b.n	8012a7a <consume_data+0x102>
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
 8012a28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012a2a:	009b      	lsls	r3, r3, #2
 8012a2c:	3340      	adds	r3, #64	@ 0x40
 8012a2e:	443b      	add	r3, r7
 8012a30:	f853 2c38 	ldr.w	r2, [r3, #-56]
 8012a34:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8012a36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012a38:	440b      	add	r3, r1
 8012a3a:	009b      	lsls	r3, r3, #2
 8012a3c:	4413      	add	r3, r2
 8012a3e:	681a      	ldr	r2, [r3, #0]
 8012a40:	69bb      	ldr	r3, [r7, #24]
 8012a42:	01db      	lsls	r3, r3, #7
 8012a44:	4413      	add	r3, r2
 8012a46:	627b      	str	r3, [r7, #36]	@ 0x24
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 8012a48:	2300      	movs	r3, #0
 8012a4a:	633b      	str	r3, [r7, #48]	@ 0x30
 8012a4c:	e00d      	b.n	8012a6a <consume_data+0xf2>
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
 8012a4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a50:	f103 0280 	add.w	r2, r3, #128	@ 0x80
 8012a54:	627a      	str	r2, [r7, #36]	@ 0x24
 8012a56:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012a58:	1c51      	adds	r1, r2, #1
 8012a5a:	63b9      	str	r1, [r7, #56]	@ 0x38
 8012a5c:	6a39      	ldr	r1, [r7, #32]
 8012a5e:	3208      	adds	r2, #8
 8012a60:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 8012a64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012a66:	3301      	adds	r3, #1
 8012a68:	633b      	str	r3, [r7, #48]	@ 0x30
 8012a6a:	69fb      	ldr	r3, [r7, #28]
 8012a6c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012a6e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012a70:	429a      	cmp	r2, r3
 8012a72:	dbec      	blt.n	8012a4e <consume_data+0xd6>
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8012a74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012a76:	3301      	adds	r3, #1
 8012a78:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012a7a:	69fb      	ldr	r3, [r7, #28]
 8012a7c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012a7e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012a80:	429a      	cmp	r2, r3
 8012a82:	dbd1      	blt.n	8012a28 <consume_data+0xb0>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012a84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012a86:	3301      	adds	r3, #1
 8012a88:	637b      	str	r3, [r7, #52]	@ 0x34
 8012a8a:	687b      	ldr	r3, [r7, #4]
 8012a8c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8012a90:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8012a92:	429a      	cmp	r2, r3
 8012a94:	dbb7      	blt.n	8012a06 <consume_data+0x8e>
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 8012a96:	687b      	ldr	r3, [r7, #4]
 8012a98:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8012a9c:	685b      	ldr	r3, [r3, #4]
 8012a9e:	6a3a      	ldr	r2, [r7, #32]
 8012aa0:	3220      	adds	r2, #32
 8012aa2:	4611      	mov	r1, r2
 8012aa4:	6878      	ldr	r0, [r7, #4]
 8012aa6:	4798      	blx	r3
 8012aa8:	4603      	mov	r3, r0
 8012aaa:	2b00      	cmp	r3, #0
 8012aac:	d107      	bne.n	8012abe <consume_data+0x146>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 8012aae:	6a3b      	ldr	r3, [r7, #32]
 8012ab0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012ab2:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 8012ab4:	6a3b      	ldr	r3, [r7, #32]
 8012ab6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012ab8:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 8012aba:	2300      	movs	r3, #0
 8012abc:	e02e      	b.n	8012b1c <consume_data+0x1a4>
	 MCU_col_num++) {
 8012abe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012ac0:	3301      	adds	r3, #1
 8012ac2:	63fb      	str	r3, [r7, #60]	@ 0x3c
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 8012ac4:	687b      	ldr	r3, [r7, #4]
 8012ac6:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8012aca:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012acc:	429a      	cmp	r2, r3
 8012ace:	d395      	bcc.n	80129fc <consume_data+0x84>
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 8012ad0:	6a3b      	ldr	r3, [r7, #32]
 8012ad2:	2200      	movs	r2, #0
 8012ad4:	615a      	str	r2, [r3, #20]
       yoffset++) {
 8012ad6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012ad8:	3301      	adds	r3, #1
 8012ada:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8012adc:	6a3b      	ldr	r3, [r7, #32]
 8012ade:	69db      	ldr	r3, [r3, #28]
 8012ae0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012ae2:	429a      	cmp	r2, r3
 8012ae4:	db86      	blt.n	80129f4 <consume_data+0x7c>
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 8012ae6:	687b      	ldr	r3, [r7, #4]
 8012ae8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012aec:	1c5a      	adds	r2, r3, #1
 8012aee:	687b      	ldr	r3, [r7, #4]
 8012af0:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 8012af4:	687b      	ldr	r3, [r7, #4]
 8012af6:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8012afa:	687b      	ldr	r3, [r7, #4]
 8012afc:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8012b00:	429a      	cmp	r2, r3
 8012b02:	d204      	bcs.n	8012b0e <consume_data+0x196>
    start_iMCU_row(cinfo);
 8012b04:	6878      	ldr	r0, [r7, #4]
 8012b06:	f7ff fdbd 	bl	8012684 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 8012b0a:	2303      	movs	r3, #3
 8012b0c:	e006      	b.n	8012b1c <consume_data+0x1a4>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 8012b0e:	687b      	ldr	r3, [r7, #4]
 8012b10:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8012b14:	68db      	ldr	r3, [r3, #12]
 8012b16:	6878      	ldr	r0, [r7, #4]
 8012b18:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 8012b1a:	2304      	movs	r3, #4
}
 8012b1c:	4618      	mov	r0, r3
 8012b1e:	3744      	adds	r7, #68	@ 0x44
 8012b20:	46bd      	mov	sp, r7
 8012b22:	bd90      	pop	{r4, r7, pc}

08012b24 <decompress_data>:
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 8012b24:	b590      	push	{r4, r7, lr}
 8012b26:	b091      	sub	sp, #68	@ 0x44
 8012b28:	af02      	add	r7, sp, #8
 8012b2a:	6078      	str	r0, [r7, #4]
 8012b2c:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012b2e:	687b      	ldr	r3, [r7, #4]
 8012b30:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012b34:	617b      	str	r3, [r7, #20]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 8012b36:	687b      	ldr	r3, [r7, #4]
 8012b38:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8012b3c:	3b01      	subs	r3, #1
 8012b3e:	613b      	str	r3, [r7, #16]
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8012b40:	e00a      	b.n	8012b58 <decompress_data+0x34>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 8012b42:	687b      	ldr	r3, [r7, #4]
 8012b44:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8012b48:	681b      	ldr	r3, [r3, #0]
 8012b4a:	6878      	ldr	r0, [r7, #4]
 8012b4c:	4798      	blx	r3
 8012b4e:	4603      	mov	r3, r0
 8012b50:	2b00      	cmp	r3, #0
 8012b52:	d101      	bne.n	8012b58 <decompress_data+0x34>
      return JPEG_SUSPENDED;
 8012b54:	2300      	movs	r3, #0
 8012b56:	e0b6      	b.n	8012cc6 <decompress_data+0x1a2>
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8012b58:	687b      	ldr	r3, [r7, #4]
 8012b5a:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8012b5e:	687b      	ldr	r3, [r7, #4]
 8012b60:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8012b64:	429a      	cmp	r2, r3
 8012b66:	dbec      	blt.n	8012b42 <decompress_data+0x1e>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 8012b68:	687b      	ldr	r3, [r7, #4]
 8012b6a:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8012b6e:	687b      	ldr	r3, [r7, #4]
 8012b70:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8012b74:	429a      	cmp	r2, r3
 8012b76:	d107      	bne.n	8012b88 <decompress_data+0x64>
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
 8012b78:	687b      	ldr	r3, [r7, #4]
 8012b7a:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8012b7e:	687b      	ldr	r3, [r7, #4]
 8012b80:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 8012b84:	429a      	cmp	r2, r3
 8012b86:	d9dc      	bls.n	8012b42 <decompress_data+0x1e>
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012b88:	2300      	movs	r3, #0
 8012b8a:	633b      	str	r3, [r7, #48]	@ 0x30
 8012b8c:	687b      	ldr	r3, [r7, #4]
 8012b8e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012b92:	61bb      	str	r3, [r7, #24]
 8012b94:	e07f      	b.n	8012c96 <decompress_data+0x172>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 8012b96:	69bb      	ldr	r3, [r7, #24]
 8012b98:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012b9a:	2b00      	cmp	r3, #0
 8012b9c:	d074      	beq.n	8012c88 <decompress_data+0x164>
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
 8012b9e:	687b      	ldr	r3, [r7, #4]
 8012ba0:	685b      	ldr	r3, [r3, #4]
 8012ba2:	6a1c      	ldr	r4, [r3, #32]
 8012ba4:	697b      	ldr	r3, [r7, #20]
 8012ba6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012ba8:	3212      	adds	r2, #18
 8012baa:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
 8012bae:	687b      	ldr	r3, [r7, #4]
 8012bb0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012bb4:	69ba      	ldr	r2, [r7, #24]
 8012bb6:	68d2      	ldr	r2, [r2, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 8012bb8:	fb03 f202 	mul.w	r2, r3, r2
       (JDIMENSION) compptr->v_samp_factor, FALSE);
 8012bbc:	69bb      	ldr	r3, [r7, #24]
 8012bbe:	68db      	ldr	r3, [r3, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 8012bc0:	4618      	mov	r0, r3
 8012bc2:	2300      	movs	r3, #0
 8012bc4:	9300      	str	r3, [sp, #0]
 8012bc6:	4603      	mov	r3, r0
 8012bc8:	6878      	ldr	r0, [r7, #4]
 8012bca:	47a0      	blx	r4
 8012bcc:	60f8      	str	r0, [r7, #12]
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
 8012bce:	687b      	ldr	r3, [r7, #4]
 8012bd0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012bd4:	693a      	ldr	r2, [r7, #16]
 8012bd6:	429a      	cmp	r2, r3
 8012bd8:	d903      	bls.n	8012be2 <decompress_data+0xbe>
      block_rows = compptr->v_samp_factor;
 8012bda:	69bb      	ldr	r3, [r7, #24]
 8012bdc:	68db      	ldr	r3, [r3, #12]
 8012bde:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012be0:	e00f      	b.n	8012c02 <decompress_data+0xde>
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 8012be2:	69bb      	ldr	r3, [r7, #24]
 8012be4:	6a1b      	ldr	r3, [r3, #32]
 8012be6:	69ba      	ldr	r2, [r7, #24]
 8012be8:	68d2      	ldr	r2, [r2, #12]
 8012bea:	fbb3 f1f2 	udiv	r1, r3, r2
 8012bee:	fb01 f202 	mul.w	r2, r1, r2
 8012bf2:	1a9b      	subs	r3, r3, r2
 8012bf4:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 8012bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012bf8:	2b00      	cmp	r3, #0
 8012bfa:	d102      	bne.n	8012c02 <decompress_data+0xde>
 8012bfc:	69bb      	ldr	r3, [r7, #24]
 8012bfe:	68db      	ldr	r3, [r3, #12]
 8012c00:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 8012c02:	687b      	ldr	r3, [r7, #4]
 8012c04:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 8012c08:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c0a:	009b      	lsls	r3, r3, #2
 8012c0c:	4413      	add	r3, r2
 8012c0e:	685b      	ldr	r3, [r3, #4]
 8012c10:	60bb      	str	r3, [r7, #8]
    output_ptr = output_buf[ci];
 8012c12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c14:	009b      	lsls	r3, r3, #2
 8012c16:	683a      	ldr	r2, [r7, #0]
 8012c18:	4413      	add	r3, r2
 8012c1a:	681b      	ldr	r3, [r3, #0]
 8012c1c:	623b      	str	r3, [r7, #32]
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 8012c1e:	2300      	movs	r3, #0
 8012c20:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012c22:	e02c      	b.n	8012c7e <decompress_data+0x15a>
      buffer_ptr = buffer[block_row];
 8012c24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012c26:	009b      	lsls	r3, r3, #2
 8012c28:	68fa      	ldr	r2, [r7, #12]
 8012c2a:	4413      	add	r3, r2
 8012c2c:	681b      	ldr	r3, [r3, #0]
 8012c2e:	627b      	str	r3, [r7, #36]	@ 0x24
      output_col = 0;
 8012c30:	2300      	movs	r3, #0
 8012c32:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 8012c34:	2300      	movs	r3, #0
 8012c36:	637b      	str	r3, [r7, #52]	@ 0x34
 8012c38:	e013      	b.n	8012c62 <decompress_data+0x13e>
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
 8012c3a:	69fb      	ldr	r3, [r7, #28]
 8012c3c:	9300      	str	r3, [sp, #0]
 8012c3e:	68bc      	ldr	r4, [r7, #8]
 8012c40:	6a3b      	ldr	r3, [r7, #32]
 8012c42:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c44:	69b9      	ldr	r1, [r7, #24]
 8012c46:	6878      	ldr	r0, [r7, #4]
 8012c48:	47a0      	blx	r4
			output_ptr, output_col);
	buffer_ptr++;
 8012c4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c4c:	3380      	adds	r3, #128	@ 0x80
 8012c4e:	627b      	str	r3, [r7, #36]	@ 0x24
	output_col += compptr->DCT_h_scaled_size;
 8012c50:	69bb      	ldr	r3, [r7, #24]
 8012c52:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012c54:	461a      	mov	r2, r3
 8012c56:	69fb      	ldr	r3, [r7, #28]
 8012c58:	4413      	add	r3, r2
 8012c5a:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 8012c5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012c5e:	3301      	adds	r3, #1
 8012c60:	637b      	str	r3, [r7, #52]	@ 0x34
 8012c62:	69bb      	ldr	r3, [r7, #24]
 8012c64:	69db      	ldr	r3, [r3, #28]
 8012c66:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8012c68:	429a      	cmp	r2, r3
 8012c6a:	d3e6      	bcc.n	8012c3a <decompress_data+0x116>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 8012c6c:	69bb      	ldr	r3, [r7, #24]
 8012c6e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012c70:	009b      	lsls	r3, r3, #2
 8012c72:	6a3a      	ldr	r2, [r7, #32]
 8012c74:	4413      	add	r3, r2
 8012c76:	623b      	str	r3, [r7, #32]
    for (block_row = 0; block_row < block_rows; block_row++) {
 8012c78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012c7a:	3301      	adds	r3, #1
 8012c7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012c7e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012c80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012c82:	429a      	cmp	r2, r3
 8012c84:	dbce      	blt.n	8012c24 <decompress_data+0x100>
 8012c86:	e000      	b.n	8012c8a <decompress_data+0x166>
      continue;
 8012c88:	bf00      	nop
       ci++, compptr++) {
 8012c8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c8c:	3301      	adds	r3, #1
 8012c8e:	633b      	str	r3, [r7, #48]	@ 0x30
 8012c90:	69bb      	ldr	r3, [r7, #24]
 8012c92:	3358      	adds	r3, #88	@ 0x58
 8012c94:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012c96:	687b      	ldr	r3, [r7, #4]
 8012c98:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012c9a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012c9c:	429a      	cmp	r2, r3
 8012c9e:	f6ff af7a 	blt.w	8012b96 <decompress_data+0x72>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 8012ca2:	687b      	ldr	r3, [r7, #4]
 8012ca4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012ca8:	1c5a      	adds	r2, r3, #1
 8012caa:	687b      	ldr	r3, [r7, #4]
 8012cac:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
 8012cb0:	687b      	ldr	r3, [r7, #4]
 8012cb2:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 8012cb6:	687b      	ldr	r3, [r7, #4]
 8012cb8:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8012cbc:	429a      	cmp	r2, r3
 8012cbe:	d201      	bcs.n	8012cc4 <decompress_data+0x1a0>
    return JPEG_ROW_COMPLETED;
 8012cc0:	2303      	movs	r3, #3
 8012cc2:	e000      	b.n	8012cc6 <decompress_data+0x1a2>
  return JPEG_SCAN_COMPLETED;
 8012cc4:	2304      	movs	r3, #4
}
 8012cc6:	4618      	mov	r0, r3
 8012cc8:	373c      	adds	r7, #60	@ 0x3c
 8012cca:	46bd      	mov	sp, r7
 8012ccc:	bd90      	pop	{r4, r7, pc}

08012cce <smoothing_ok>:
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
 8012cce:	b590      	push	{r4, r7, lr}
 8012cd0:	b08b      	sub	sp, #44	@ 0x2c
 8012cd2:	af00      	add	r7, sp, #0
 8012cd4:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012cd6:	687b      	ldr	r3, [r7, #4]
 8012cd8:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012cdc:	613b      	str	r3, [r7, #16]
  boolean smoothing_useful = FALSE;
 8012cde:	2300      	movs	r3, #0
 8012ce0:	627b      	str	r3, [r7, #36]	@ 0x24
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
 8012ce2:	687b      	ldr	r3, [r7, #4]
 8012ce4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012ce8:	2b00      	cmp	r3, #0
 8012cea:	d004      	beq.n	8012cf6 <smoothing_ok+0x28>
 8012cec:	687b      	ldr	r3, [r7, #4]
 8012cee:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8012cf2:	2b00      	cmp	r3, #0
 8012cf4:	d101      	bne.n	8012cfa <smoothing_ok+0x2c>
    return FALSE;
 8012cf6:	2300      	movs	r3, #0
 8012cf8:	e078      	b.n	8012dec <smoothing_ok+0x11e>

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
 8012cfa:	693b      	ldr	r3, [r7, #16]
 8012cfc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8012cfe:	2b00      	cmp	r3, #0
 8012d00:	d110      	bne.n	8012d24 <smoothing_ok+0x56>
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8012d02:	687b      	ldr	r3, [r7, #4]
 8012d04:	685b      	ldr	r3, [r3, #4]
 8012d06:	681c      	ldr	r4, [r3, #0]
				  cinfo->num_components *
 8012d08:	687b      	ldr	r3, [r7, #4]
 8012d0a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012d0c:	461a      	mov	r2, r3
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8012d0e:	4613      	mov	r3, r2
 8012d10:	005b      	lsls	r3, r3, #1
 8012d12:	4413      	add	r3, r2
 8012d14:	00db      	lsls	r3, r3, #3
 8012d16:	461a      	mov	r2, r3
 8012d18:	2101      	movs	r1, #1
 8012d1a:	6878      	ldr	r0, [r7, #4]
 8012d1c:	47a0      	blx	r4
 8012d1e:	4602      	mov	r2, r0
    coef->coef_bits_latch = (int *)
 8012d20:	693b      	ldr	r3, [r7, #16]
 8012d22:	671a      	str	r2, [r3, #112]	@ 0x70
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;
 8012d24:	693b      	ldr	r3, [r7, #16]
 8012d26:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8012d28:	617b      	str	r3, [r7, #20]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012d2a:	2300      	movs	r3, #0
 8012d2c:	623b      	str	r3, [r7, #32]
 8012d2e:	687b      	ldr	r3, [r7, #4]
 8012d30:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012d34:	61bb      	str	r3, [r7, #24]
 8012d36:	e053      	b.n	8012de0 <smoothing_ok+0x112>
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
 8012d38:	69bb      	ldr	r3, [r7, #24]
 8012d3a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012d3c:	60fb      	str	r3, [r7, #12]
 8012d3e:	68fb      	ldr	r3, [r7, #12]
 8012d40:	2b00      	cmp	r3, #0
 8012d42:	d101      	bne.n	8012d48 <smoothing_ok+0x7a>
      return FALSE;
 8012d44:	2300      	movs	r3, #0
 8012d46:	e051      	b.n	8012dec <smoothing_ok+0x11e>
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
 8012d48:	68fb      	ldr	r3, [r7, #12]
 8012d4a:	881b      	ldrh	r3, [r3, #0]
 8012d4c:	2b00      	cmp	r3, #0
 8012d4e:	d013      	beq.n	8012d78 <smoothing_ok+0xaa>
	qtable->quantval[Q01_POS] == 0 ||
 8012d50:	68fb      	ldr	r3, [r7, #12]
 8012d52:	885b      	ldrh	r3, [r3, #2]
    if (qtable->quantval[0] == 0 ||
 8012d54:	2b00      	cmp	r3, #0
 8012d56:	d00f      	beq.n	8012d78 <smoothing_ok+0xaa>
	qtable->quantval[Q10_POS] == 0 ||
 8012d58:	68fb      	ldr	r3, [r7, #12]
 8012d5a:	8a1b      	ldrh	r3, [r3, #16]
	qtable->quantval[Q01_POS] == 0 ||
 8012d5c:	2b00      	cmp	r3, #0
 8012d5e:	d00b      	beq.n	8012d78 <smoothing_ok+0xaa>
	qtable->quantval[Q20_POS] == 0 ||
 8012d60:	68fb      	ldr	r3, [r7, #12]
 8012d62:	8c1b      	ldrh	r3, [r3, #32]
	qtable->quantval[Q10_POS] == 0 ||
 8012d64:	2b00      	cmp	r3, #0
 8012d66:	d007      	beq.n	8012d78 <smoothing_ok+0xaa>
	qtable->quantval[Q11_POS] == 0 ||
 8012d68:	68fb      	ldr	r3, [r7, #12]
 8012d6a:	8a5b      	ldrh	r3, [r3, #18]
	qtable->quantval[Q20_POS] == 0 ||
 8012d6c:	2b00      	cmp	r3, #0
 8012d6e:	d003      	beq.n	8012d78 <smoothing_ok+0xaa>
	qtable->quantval[Q02_POS] == 0)
 8012d70:	68fb      	ldr	r3, [r7, #12]
 8012d72:	889b      	ldrh	r3, [r3, #4]
	qtable->quantval[Q11_POS] == 0 ||
 8012d74:	2b00      	cmp	r3, #0
 8012d76:	d101      	bne.n	8012d7c <smoothing_ok+0xae>
      return FALSE;
 8012d78:	2300      	movs	r3, #0
 8012d7a:	e037      	b.n	8012dec <smoothing_ok+0x11e>
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
 8012d7c:	687b      	ldr	r3, [r7, #4]
 8012d7e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8012d82:	6a3b      	ldr	r3, [r7, #32]
 8012d84:	021b      	lsls	r3, r3, #8
 8012d86:	4413      	add	r3, r2
 8012d88:	60bb      	str	r3, [r7, #8]
    if (coef_bits[0] < 0)
 8012d8a:	68bb      	ldr	r3, [r7, #8]
 8012d8c:	681b      	ldr	r3, [r3, #0]
 8012d8e:	2b00      	cmp	r3, #0
 8012d90:	da01      	bge.n	8012d96 <smoothing_ok+0xc8>
      return FALSE;
 8012d92:	2300      	movs	r3, #0
 8012d94:	e02a      	b.n	8012dec <smoothing_ok+0x11e>
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
 8012d96:	2301      	movs	r3, #1
 8012d98:	61fb      	str	r3, [r7, #28]
 8012d9a:	e015      	b.n	8012dc8 <smoothing_ok+0xfa>
      coef_bits_latch[coefi] = coef_bits[coefi];
 8012d9c:	69fb      	ldr	r3, [r7, #28]
 8012d9e:	009b      	lsls	r3, r3, #2
 8012da0:	68ba      	ldr	r2, [r7, #8]
 8012da2:	441a      	add	r2, r3
 8012da4:	69fb      	ldr	r3, [r7, #28]
 8012da6:	009b      	lsls	r3, r3, #2
 8012da8:	6979      	ldr	r1, [r7, #20]
 8012daa:	440b      	add	r3, r1
 8012dac:	6812      	ldr	r2, [r2, #0]
 8012dae:	601a      	str	r2, [r3, #0]
      if (coef_bits[coefi] != 0)
 8012db0:	69fb      	ldr	r3, [r7, #28]
 8012db2:	009b      	lsls	r3, r3, #2
 8012db4:	68ba      	ldr	r2, [r7, #8]
 8012db6:	4413      	add	r3, r2
 8012db8:	681b      	ldr	r3, [r3, #0]
 8012dba:	2b00      	cmp	r3, #0
 8012dbc:	d001      	beq.n	8012dc2 <smoothing_ok+0xf4>
	smoothing_useful = TRUE;
 8012dbe:	2301      	movs	r3, #1
 8012dc0:	627b      	str	r3, [r7, #36]	@ 0x24
    for (coefi = 1; coefi <= 5; coefi++) {
 8012dc2:	69fb      	ldr	r3, [r7, #28]
 8012dc4:	3301      	adds	r3, #1
 8012dc6:	61fb      	str	r3, [r7, #28]
 8012dc8:	69fb      	ldr	r3, [r7, #28]
 8012dca:	2b05      	cmp	r3, #5
 8012dcc:	dde6      	ble.n	8012d9c <smoothing_ok+0xce>
    }
    coef_bits_latch += SAVED_COEFS;
 8012dce:	697b      	ldr	r3, [r7, #20]
 8012dd0:	3318      	adds	r3, #24
 8012dd2:	617b      	str	r3, [r7, #20]
       ci++, compptr++) {
 8012dd4:	6a3b      	ldr	r3, [r7, #32]
 8012dd6:	3301      	adds	r3, #1
 8012dd8:	623b      	str	r3, [r7, #32]
 8012dda:	69bb      	ldr	r3, [r7, #24]
 8012ddc:	3358      	adds	r3, #88	@ 0x58
 8012dde:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012de0:	687b      	ldr	r3, [r7, #4]
 8012de2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012de4:	6a3a      	ldr	r2, [r7, #32]
 8012de6:	429a      	cmp	r2, r3
 8012de8:	dba6      	blt.n	8012d38 <smoothing_ok+0x6a>
  }

  return smoothing_useful;
 8012dea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8012dec:	4618      	mov	r0, r3
 8012dee:	372c      	adds	r7, #44	@ 0x2c
 8012df0:	46bd      	mov	sp, r7
 8012df2:	bd90      	pop	{r4, r7, pc}

08012df4 <decompress_smooth_data>:
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 8012df4:	b5b0      	push	{r4, r5, r7, lr}
 8012df6:	b0cc      	sub	sp, #304	@ 0x130
 8012df8:	af02      	add	r7, sp, #8
 8012dfa:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012dfe:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e02:	6018      	str	r0, [r3, #0]
 8012e04:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e08:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8012e0c:	6019      	str	r1, [r3, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8012e0e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e12:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e16:	681b      	ldr	r3, [r3, #0]
 8012e18:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8012e1c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 8012e20:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e24:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e28:	681b      	ldr	r3, [r3, #0]
 8012e2a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8012e2e:	3b01      	subs	r3, #1
 8012e30:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 8012e34:	e044      	b.n	8012ec0 <decompress_smooth_data+0xcc>
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
 8012e36:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e3a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e3e:	681b      	ldr	r3, [r3, #0]
 8012e40:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8012e44:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e48:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e4c:	681b      	ldr	r3, [r3, #0]
 8012e4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8012e52:	429a      	cmp	r2, r3
 8012e54:	d120      	bne.n	8012e98 <decompress_smooth_data+0xa4>
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
 8012e56:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e5a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e5e:	681b      	ldr	r3, [r3, #0]
 8012e60:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8012e64:	2b00      	cmp	r3, #0
 8012e66:	bf0c      	ite	eq
 8012e68:	2301      	moveq	r3, #1
 8012e6a:	2300      	movne	r3, #0
 8012e6c:	b2db      	uxtb	r3, r3
 8012e6e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
 8012e72:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e76:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e7a:	681b      	ldr	r3, [r3, #0]
 8012e7c:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8012e80:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e84:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012e88:	681b      	ldr	r3, [r3, #0]
 8012e8a:	f8d3 109c 	ldr.w	r1, [r3, #156]	@ 0x9c
 8012e8e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8012e92:	440b      	add	r3, r1
 8012e94:	429a      	cmp	r2, r3
 8012e96:	d82e      	bhi.n	8012ef6 <decompress_smooth_data+0x102>
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 8012e98:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012e9c:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012ea0:	681b      	ldr	r3, [r3, #0]
 8012ea2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8012ea6:	681b      	ldr	r3, [r3, #0]
 8012ea8:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8012eac:	f5a2 7292 	sub.w	r2, r2, #292	@ 0x124
 8012eb0:	6810      	ldr	r0, [r2, #0]
 8012eb2:	4798      	blx	r3
 8012eb4:	4603      	mov	r3, r0
 8012eb6:	2b00      	cmp	r3, #0
 8012eb8:	d102      	bne.n	8012ec0 <decompress_smooth_data+0xcc>
      return JPEG_SUSPENDED;
 8012eba:	2300      	movs	r3, #0
 8012ebc:	f000 bca0 	b.w	8013800 <decompress_smooth_data+0xa0c>
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 8012ec0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012ec4:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012ec8:	681b      	ldr	r3, [r3, #0]
 8012eca:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8012ece:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012ed2:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012ed6:	681b      	ldr	r3, [r3, #0]
 8012ed8:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8012edc:	429a      	cmp	r2, r3
 8012ede:	dc0b      	bgt.n	8012ef8 <decompress_smooth_data+0x104>
	 ! cinfo->inputctl->eoi_reached) {
 8012ee0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012ee4:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012ee8:	681b      	ldr	r3, [r3, #0]
 8012eea:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8012eee:	695b      	ldr	r3, [r3, #20]
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 8012ef0:	2b00      	cmp	r3, #0
 8012ef2:	d0a0      	beq.n	8012e36 <decompress_smooth_data+0x42>
 8012ef4:	e000      	b.n	8012ef8 <decompress_smooth_data+0x104>
	break;
 8012ef6:	bf00      	nop
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012ef8:	2300      	movs	r3, #0
 8012efa:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8012efe:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012f02:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012f06:	681b      	ldr	r3, [r3, #0]
 8012f08:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8012f0c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8012f10:	f000 bc49 	b.w	80137a6 <decompress_smooth_data+0x9b2>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 8012f14:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8012f18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012f1a:	2b00      	cmp	r3, #0
 8012f1c:	f000 8438 	beq.w	8013790 <decompress_smooth_data+0x99c>
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
 8012f20:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012f24:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012f28:	681b      	ldr	r3, [r3, #0]
 8012f2a:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012f2e:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8012f32:	429a      	cmp	r2, r3
 8012f34:	d90d      	bls.n	8012f52 <decompress_smooth_data+0x15e>
      block_rows = compptr->v_samp_factor;
 8012f36:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8012f3a:	68db      	ldr	r3, [r3, #12]
 8012f3c:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      access_rows = block_rows * 2; /* this and next iMCU row */
 8012f40:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8012f44:	005b      	lsls	r3, r3, #1
 8012f46:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      last_row = FALSE;
 8012f4a:	2300      	movs	r3, #0
 8012f4c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8012f50:	e01c      	b.n	8012f8c <decompress_smooth_data+0x198>
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 8012f52:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8012f56:	6a1b      	ldr	r3, [r3, #32]
 8012f58:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8012f5c:	68d2      	ldr	r2, [r2, #12]
 8012f5e:	fbb3 f1f2 	udiv	r1, r3, r2
 8012f62:	fb01 f202 	mul.w	r2, r1, r2
 8012f66:	1a9b      	subs	r3, r3, r2
 8012f68:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 8012f6c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8012f70:	2b00      	cmp	r3, #0
 8012f72:	d104      	bne.n	8012f7e <decompress_smooth_data+0x18a>
 8012f74:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8012f78:	68db      	ldr	r3, [r3, #12]
 8012f7a:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      access_rows = block_rows; /* this iMCU row only */
 8012f7e:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8012f82:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      last_row = TRUE;
 8012f86:	2301      	movs	r3, #1
 8012f88:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
 8012f8c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012f90:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012f94:	681b      	ldr	r3, [r3, #0]
 8012f96:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012f9a:	2b00      	cmp	r3, #0
 8012f9c:	d03b      	beq.n	8013016 <decompress_smooth_data+0x222>
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
 8012f9e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8012fa2:	68db      	ldr	r3, [r3, #12]
 8012fa4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8012fa8:	4413      	add	r3, r2
 8012faa:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      buffer = (*cinfo->mem->access_virt_barray)
 8012fae:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012fb2:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012fb6:	681b      	ldr	r3, [r3, #0]
 8012fb8:	685b      	ldr	r3, [r3, #4]
 8012fba:	6a1c      	ldr	r4, [r3, #32]
 8012fbc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8012fc0:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8012fc4:	3212      	adds	r2, #18
 8012fc6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
 8012fca:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8012fce:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8012fd2:	681b      	ldr	r3, [r3, #0]
 8012fd4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8012fd8:	3b01      	subs	r3, #1
 8012fda:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8012fde:	68d2      	ldr	r2, [r2, #12]
      buffer = (*cinfo->mem->access_virt_barray)
 8012fe0:	fb03 f202 	mul.w	r2, r3, r2
 8012fe4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8012fe8:	f507 7094 	add.w	r0, r7, #296	@ 0x128
 8012fec:	f5a0 7092 	sub.w	r0, r0, #292	@ 0x124
 8012ff0:	2500      	movs	r5, #0
 8012ff2:	9500      	str	r5, [sp, #0]
 8012ff4:	6800      	ldr	r0, [r0, #0]
 8012ff6:	47a0      	blx	r4
 8012ff8:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
 8012ffc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8013000:	68db      	ldr	r3, [r3, #12]
 8013002:	009b      	lsls	r3, r3, #2
 8013004:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8013008:	4413      	add	r3, r2
 801300a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
      first_row = FALSE;
 801300e:	2300      	movs	r3, #0
 8013010:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8013014:	e01d      	b.n	8013052 <decompress_smooth_data+0x25e>
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
 8013016:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801301a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801301e:	681b      	ldr	r3, [r3, #0]
 8013020:	685b      	ldr	r3, [r3, #4]
 8013022:	6a1c      	ldr	r4, [r3, #32]
 8013024:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8013028:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801302c:	3212      	adds	r2, #18
 801302e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013032:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8013036:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 801303a:	f5a2 7092 	sub.w	r0, r2, #292	@ 0x124
 801303e:	2200      	movs	r2, #0
 8013040:	9200      	str	r2, [sp, #0]
 8013042:	2200      	movs	r2, #0
 8013044:	6800      	ldr	r0, [r0, #0]
 8013046:	47a0      	blx	r4
 8013048:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
 801304c:	2301      	movs	r3, #1
 801304e:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
 8013052:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8013056:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 8013058:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801305c:	4613      	mov	r3, r2
 801305e:	005b      	lsls	r3, r3, #1
 8013060:	4413      	add	r3, r2
 8013062:	00db      	lsls	r3, r3, #3
 8013064:	440b      	add	r3, r1
 8013066:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    quanttbl = compptr->quant_table;
 801306a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801306e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8013070:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    Q00 = quanttbl->quantval[0];
 8013074:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013078:	881b      	ldrh	r3, [r3, #0]
 801307a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    Q01 = quanttbl->quantval[Q01_POS];
 801307e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013082:	885b      	ldrh	r3, [r3, #2]
 8013084:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    Q10 = quanttbl->quantval[Q10_POS];
 8013088:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801308c:	8a1b      	ldrh	r3, [r3, #16]
 801308e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    Q20 = quanttbl->quantval[Q20_POS];
 8013092:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013096:	8c1b      	ldrh	r3, [r3, #32]
 8013098:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    Q11 = quanttbl->quantval[Q11_POS];
 801309c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80130a0:	8a5b      	ldrh	r3, [r3, #18]
 80130a2:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    Q02 = quanttbl->quantval[Q02_POS];
 80130a6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80130aa:	889b      	ldrh	r3, [r3, #4]
 80130ac:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 80130b0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80130b4:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80130b8:	681b      	ldr	r3, [r3, #0]
 80130ba:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 80130be:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80130c2:	009b      	lsls	r3, r3, #2
 80130c4:	4413      	add	r3, r2
 80130c6:	685b      	ldr	r3, [r3, #4]
 80130c8:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    output_ptr = output_buf[ci];
 80130cc:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80130d0:	009b      	lsls	r3, r3, #2
 80130d2:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 80130d6:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 80130da:	6812      	ldr	r2, [r2, #0]
 80130dc:	4413      	add	r3, r2
 80130de:	681b      	ldr	r3, [r3, #0]
 80130e0:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 80130e4:	2300      	movs	r3, #0
 80130e6:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 80130ea:	e349      	b.n	8013780 <decompress_smooth_data+0x98c>
      buffer_ptr = buffer[block_row];
 80130ec:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80130f0:	009b      	lsls	r3, r3, #2
 80130f2:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80130f6:	4413      	add	r3, r2
 80130f8:	681b      	ldr	r3, [r3, #0]
 80130fa:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
      if (first_row && block_row == 0)
 80130fe:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8013102:	2b00      	cmp	r3, #0
 8013104:	d008      	beq.n	8013118 <decompress_smooth_data+0x324>
 8013106:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801310a:	2b00      	cmp	r3, #0
 801310c:	d104      	bne.n	8013118 <decompress_smooth_data+0x324>
	prev_block_row = buffer_ptr;
 801310e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8013112:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8013116:	e00b      	b.n	8013130 <decompress_smooth_data+0x33c>
      else
	prev_block_row = buffer[block_row-1];
 8013118:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801311c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8013120:	3b01      	subs	r3, #1
 8013122:	009b      	lsls	r3, r3, #2
 8013124:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8013128:	4413      	add	r3, r2
 801312a:	681b      	ldr	r3, [r3, #0]
 801312c:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
      if (last_row && block_row == block_rows-1)
 8013130:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8013134:	2b00      	cmp	r3, #0
 8013136:	d00b      	beq.n	8013150 <decompress_smooth_data+0x35c>
 8013138:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801313c:	3b01      	subs	r3, #1
 801313e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8013142:	429a      	cmp	r2, r3
 8013144:	d104      	bne.n	8013150 <decompress_smooth_data+0x35c>
	next_block_row = buffer_ptr;
 8013146:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801314a:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 801314e:	e009      	b.n	8013164 <decompress_smooth_data+0x370>
      else
	next_block_row = buffer[block_row+1];
 8013150:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8013154:	3301      	adds	r3, #1
 8013156:	009b      	lsls	r3, r3, #2
 8013158:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801315c:	4413      	add	r3, r2
 801315e:	681b      	ldr	r3, [r3, #0]
 8013160:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
 8013164:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8013168:	f9b3 3000 	ldrsh.w	r3, [r3]
 801316c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013170:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013174:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 8013178:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801317c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
 8013180:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8013184:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013188:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 801318c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8013190:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 8013194:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013198:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
 801319c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80131a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80131a4:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 80131a8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80131ac:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80131b0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80131b4:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      output_col = 0;
 80131b8:	2300      	movs	r3, #0
 80131ba:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
      last_block_column = compptr->width_in_blocks - 1;
 80131be:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80131c2:	69db      	ldr	r3, [r3, #28]
 80131c4:	3b01      	subs	r3, #1
 80131c6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 80131ca:	2300      	movs	r3, #0
 80131cc:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 80131d0:	e2c1      	b.n	8013756 <decompress_smooth_data+0x962>
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
 80131d2:	f107 030c 	add.w	r3, r7, #12
 80131d6:	2201      	movs	r2, #1
 80131d8:	4619      	mov	r1, r3
 80131da:	f8d7 010c 	ldr.w	r0, [r7, #268]	@ 0x10c
 80131de:	f019 fdbb 	bl	802cd58 <jcopy_block_row>
	/* Update DC values */
	if (block_num < last_block_column) {
 80131e2:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80131e6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80131ea:	429a      	cmp	r2, r3
 80131ec:	d214      	bcs.n	8013218 <decompress_smooth_data+0x424>
	  DC3 = (int) prev_block_row[1][0];
 80131ee:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80131f2:	3380      	adds	r3, #128	@ 0x80
 80131f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80131f8:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
	  DC6 = (int) buffer_ptr[1][0];
 80131fc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8013200:	3380      	adds	r3, #128	@ 0x80
 8013202:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013206:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
	  DC9 = (int) next_block_row[1][0];
 801320a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801320e:	3380      	adds	r3, #128	@ 0x80
 8013210:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013214:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
 8013218:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801321c:	685b      	ldr	r3, [r3, #4]
 801321e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8013222:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013226:	2b00      	cmp	r3, #0
 8013228:	d06c      	beq.n	8013304 <decompress_smooth_data+0x510>
 801322a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801322e:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8013232:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8013236:	2b00      	cmp	r3, #0
 8013238:	d164      	bne.n	8013304 <decompress_smooth_data+0x510>
	  num = 36 * Q00 * (DC4 - DC6);
 801323a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 801323e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8013242:	1ad3      	subs	r3, r2, r3
 8013244:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8013248:	fb03 f202 	mul.w	r2, r3, r2
 801324c:	4613      	mov	r3, r2
 801324e:	00db      	lsls	r3, r3, #3
 8013250:	4413      	add	r3, r2
 8013252:	009b      	lsls	r3, r3, #2
 8013254:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8013258:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801325c:	2b00      	cmp	r3, #0
 801325e:	db22      	blt.n	80132a6 <decompress_smooth_data+0x4b2>
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
 8013260:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8013264:	01da      	lsls	r2, r3, #7
 8013266:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801326a:	441a      	add	r2, r3
 801326c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8013270:	021b      	lsls	r3, r3, #8
 8013272:	fb92 f3f3 	sdiv	r3, r2, r3
 8013276:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801327a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801327e:	2b00      	cmp	r3, #0
 8013280:	dd38      	ble.n	80132f4 <decompress_smooth_data+0x500>
 8013282:	2201      	movs	r2, #1
 8013284:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013288:	fa02 f303 	lsl.w	r3, r2, r3
 801328c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8013290:	429a      	cmp	r2, r3
 8013292:	db2f      	blt.n	80132f4 <decompress_smooth_data+0x500>
	      pred = (1<<Al)-1;
 8013294:	2201      	movs	r2, #1
 8013296:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801329a:	fa02 f303 	lsl.w	r3, r2, r3
 801329e:	3b01      	subs	r3, #1
 80132a0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80132a4:	e026      	b.n	80132f4 <decompress_smooth_data+0x500>
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
 80132a6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80132aa:	01da      	lsls	r2, r3, #7
 80132ac:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80132b0:	1ad2      	subs	r2, r2, r3
 80132b2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80132b6:	021b      	lsls	r3, r3, #8
 80132b8:	fb92 f3f3 	sdiv	r3, r2, r3
 80132bc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 80132c0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80132c4:	2b00      	cmp	r3, #0
 80132c6:	dd10      	ble.n	80132ea <decompress_smooth_data+0x4f6>
 80132c8:	2201      	movs	r2, #1
 80132ca:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80132ce:	fa02 f303 	lsl.w	r3, r2, r3
 80132d2:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80132d6:	429a      	cmp	r2, r3
 80132d8:	db07      	blt.n	80132ea <decompress_smooth_data+0x4f6>
	      pred = (1<<Al)-1;
 80132da:	2201      	movs	r2, #1
 80132dc:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80132e0:	fa02 f303 	lsl.w	r3, r2, r3
 80132e4:	3b01      	subs	r3, #1
 80132e6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80132ea:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80132ee:	425b      	negs	r3, r3
 80132f0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[1] = (JCOEF) pred;
 80132f4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80132f8:	b21a      	sxth	r2, r3
 80132fa:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80132fe:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8013302:	805a      	strh	r2, [r3, #2]
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
 8013304:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8013308:	689b      	ldr	r3, [r3, #8]
 801330a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 801330e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013312:	2b00      	cmp	r3, #0
 8013314:	d06c      	beq.n	80133f0 <decompress_smooth_data+0x5fc>
 8013316:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801331a:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801331e:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8013322:	2b00      	cmp	r3, #0
 8013324:	d164      	bne.n	80133f0 <decompress_smooth_data+0x5fc>
	  num = 36 * Q00 * (DC2 - DC8);
 8013326:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801332a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801332e:	1ad3      	subs	r3, r2, r3
 8013330:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8013334:	fb03 f202 	mul.w	r2, r3, r2
 8013338:	4613      	mov	r3, r2
 801333a:	00db      	lsls	r3, r3, #3
 801333c:	4413      	add	r3, r2
 801333e:	009b      	lsls	r3, r3, #2
 8013340:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8013344:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013348:	2b00      	cmp	r3, #0
 801334a:	db22      	blt.n	8013392 <decompress_smooth_data+0x59e>
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
 801334c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8013350:	01da      	lsls	r2, r3, #7
 8013352:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013356:	441a      	add	r2, r3
 8013358:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801335c:	021b      	lsls	r3, r3, #8
 801335e:	fb92 f3f3 	sdiv	r3, r2, r3
 8013362:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8013366:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801336a:	2b00      	cmp	r3, #0
 801336c:	dd38      	ble.n	80133e0 <decompress_smooth_data+0x5ec>
 801336e:	2201      	movs	r2, #1
 8013370:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013374:	fa02 f303 	lsl.w	r3, r2, r3
 8013378:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801337c:	429a      	cmp	r2, r3
 801337e:	db2f      	blt.n	80133e0 <decompress_smooth_data+0x5ec>
	      pred = (1<<Al)-1;
 8013380:	2201      	movs	r2, #1
 8013382:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013386:	fa02 f303 	lsl.w	r3, r2, r3
 801338a:	3b01      	subs	r3, #1
 801338c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8013390:	e026      	b.n	80133e0 <decompress_smooth_data+0x5ec>
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
 8013392:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8013396:	01da      	lsls	r2, r3, #7
 8013398:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801339c:	1ad2      	subs	r2, r2, r3
 801339e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80133a2:	021b      	lsls	r3, r3, #8
 80133a4:	fb92 f3f3 	sdiv	r3, r2, r3
 80133a8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 80133ac:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80133b0:	2b00      	cmp	r3, #0
 80133b2:	dd10      	ble.n	80133d6 <decompress_smooth_data+0x5e2>
 80133b4:	2201      	movs	r2, #1
 80133b6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80133ba:	fa02 f303 	lsl.w	r3, r2, r3
 80133be:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80133c2:	429a      	cmp	r2, r3
 80133c4:	db07      	blt.n	80133d6 <decompress_smooth_data+0x5e2>
	      pred = (1<<Al)-1;
 80133c6:	2201      	movs	r2, #1
 80133c8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80133cc:	fa02 f303 	lsl.w	r3, r2, r3
 80133d0:	3b01      	subs	r3, #1
 80133d2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80133d6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80133da:	425b      	negs	r3, r3
 80133dc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[8] = (JCOEF) pred;
 80133e0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80133e4:	b21a      	sxth	r2, r3
 80133e6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80133ea:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80133ee:	821a      	strh	r2, [r3, #16]
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
 80133f0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80133f4:	68db      	ldr	r3, [r3, #12]
 80133f6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80133fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80133fe:	2b00      	cmp	r3, #0
 8013400:	d06f      	beq.n	80134e2 <decompress_smooth_data+0x6ee>
 8013402:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8013406:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801340a:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 801340e:	2b00      	cmp	r3, #0
 8013410:	d167      	bne.n	80134e2 <decompress_smooth_data+0x6ee>
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
 8013412:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8013416:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801341a:	441a      	add	r2, r3
 801341c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013420:	005b      	lsls	r3, r3, #1
 8013422:	1ad3      	subs	r3, r2, r3
 8013424:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8013428:	fb03 f202 	mul.w	r2, r3, r2
 801342c:	4613      	mov	r3, r2
 801342e:	00db      	lsls	r3, r3, #3
 8013430:	4413      	add	r3, r2
 8013432:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8013436:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801343a:	2b00      	cmp	r3, #0
 801343c:	db22      	blt.n	8013484 <decompress_smooth_data+0x690>
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
 801343e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8013442:	01da      	lsls	r2, r3, #7
 8013444:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013448:	441a      	add	r2, r3
 801344a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801344e:	021b      	lsls	r3, r3, #8
 8013450:	fb92 f3f3 	sdiv	r3, r2, r3
 8013454:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8013458:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801345c:	2b00      	cmp	r3, #0
 801345e:	dd38      	ble.n	80134d2 <decompress_smooth_data+0x6de>
 8013460:	2201      	movs	r2, #1
 8013462:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013466:	fa02 f303 	lsl.w	r3, r2, r3
 801346a:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801346e:	429a      	cmp	r2, r3
 8013470:	db2f      	blt.n	80134d2 <decompress_smooth_data+0x6de>
	      pred = (1<<Al)-1;
 8013472:	2201      	movs	r2, #1
 8013474:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013478:	fa02 f303 	lsl.w	r3, r2, r3
 801347c:	3b01      	subs	r3, #1
 801347e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8013482:	e026      	b.n	80134d2 <decompress_smooth_data+0x6de>
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
 8013484:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8013488:	01da      	lsls	r2, r3, #7
 801348a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801348e:	1ad2      	subs	r2, r2, r3
 8013490:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8013494:	021b      	lsls	r3, r3, #8
 8013496:	fb92 f3f3 	sdiv	r3, r2, r3
 801349a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801349e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80134a2:	2b00      	cmp	r3, #0
 80134a4:	dd10      	ble.n	80134c8 <decompress_smooth_data+0x6d4>
 80134a6:	2201      	movs	r2, #1
 80134a8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80134ac:	fa02 f303 	lsl.w	r3, r2, r3
 80134b0:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80134b4:	429a      	cmp	r2, r3
 80134b6:	db07      	blt.n	80134c8 <decompress_smooth_data+0x6d4>
	      pred = (1<<Al)-1;
 80134b8:	2201      	movs	r2, #1
 80134ba:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80134be:	fa02 f303 	lsl.w	r3, r2, r3
 80134c2:	3b01      	subs	r3, #1
 80134c4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80134c8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80134cc:	425b      	negs	r3, r3
 80134ce:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[16] = (JCOEF) pred;
 80134d2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80134d6:	b21a      	sxth	r2, r3
 80134d8:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80134dc:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80134e0:	841a      	strh	r2, [r3, #32]
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
 80134e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80134e6:	691b      	ldr	r3, [r3, #16]
 80134e8:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80134ec:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80134f0:	2b00      	cmp	r3, #0
 80134f2:	d071      	beq.n	80135d8 <decompress_smooth_data+0x7e4>
 80134f4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80134f8:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80134fc:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013500:	2b00      	cmp	r3, #0
 8013502:	d169      	bne.n	80135d8 <decompress_smooth_data+0x7e4>
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
 8013504:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8013508:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801350c:	1ad2      	subs	r2, r2, r3
 801350e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013512:	1ad2      	subs	r2, r2, r3
 8013514:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013518:	4413      	add	r3, r2
 801351a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801351e:	fb03 f202 	mul.w	r2, r3, r2
 8013522:	4613      	mov	r3, r2
 8013524:	009b      	lsls	r3, r3, #2
 8013526:	4413      	add	r3, r2
 8013528:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 801352c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013530:	2b00      	cmp	r3, #0
 8013532:	db22      	blt.n	801357a <decompress_smooth_data+0x786>
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
 8013534:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8013538:	01da      	lsls	r2, r3, #7
 801353a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801353e:	441a      	add	r2, r3
 8013540:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8013544:	021b      	lsls	r3, r3, #8
 8013546:	fb92 f3f3 	sdiv	r3, r2, r3
 801354a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801354e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013552:	2b00      	cmp	r3, #0
 8013554:	dd38      	ble.n	80135c8 <decompress_smooth_data+0x7d4>
 8013556:	2201      	movs	r2, #1
 8013558:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801355c:	fa02 f303 	lsl.w	r3, r2, r3
 8013560:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8013564:	429a      	cmp	r2, r3
 8013566:	db2f      	blt.n	80135c8 <decompress_smooth_data+0x7d4>
	      pred = (1<<Al)-1;
 8013568:	2201      	movs	r2, #1
 801356a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801356e:	fa02 f303 	lsl.w	r3, r2, r3
 8013572:	3b01      	subs	r3, #1
 8013574:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8013578:	e026      	b.n	80135c8 <decompress_smooth_data+0x7d4>
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
 801357a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801357e:	01da      	lsls	r2, r3, #7
 8013580:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013584:	1ad2      	subs	r2, r2, r3
 8013586:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801358a:	021b      	lsls	r3, r3, #8
 801358c:	fb92 f3f3 	sdiv	r3, r2, r3
 8013590:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8013594:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013598:	2b00      	cmp	r3, #0
 801359a:	dd10      	ble.n	80135be <decompress_smooth_data+0x7ca>
 801359c:	2201      	movs	r2, #1
 801359e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80135a2:	fa02 f303 	lsl.w	r3, r2, r3
 80135a6:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80135aa:	429a      	cmp	r2, r3
 80135ac:	db07      	blt.n	80135be <decompress_smooth_data+0x7ca>
	      pred = (1<<Al)-1;
 80135ae:	2201      	movs	r2, #1
 80135b0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80135b4:	fa02 f303 	lsl.w	r3, r2, r3
 80135b8:	3b01      	subs	r3, #1
 80135ba:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80135be:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80135c2:	425b      	negs	r3, r3
 80135c4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[9] = (JCOEF) pred;
 80135c8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80135cc:	b21a      	sxth	r2, r3
 80135ce:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80135d2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80135d6:	825a      	strh	r2, [r3, #18]
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
 80135d8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80135dc:	695b      	ldr	r3, [r3, #20]
 80135de:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80135e2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80135e6:	2b00      	cmp	r3, #0
 80135e8:	d06f      	beq.n	80136ca <decompress_smooth_data+0x8d6>
 80135ea:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80135ee:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80135f2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80135f6:	2b00      	cmp	r3, #0
 80135f8:	d167      	bne.n	80136ca <decompress_smooth_data+0x8d6>
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
 80135fa:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80135fe:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8013602:	441a      	add	r2, r3
 8013604:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013608:	005b      	lsls	r3, r3, #1
 801360a:	1ad3      	subs	r3, r2, r3
 801360c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8013610:	fb03 f202 	mul.w	r2, r3, r2
 8013614:	4613      	mov	r3, r2
 8013616:	00db      	lsls	r3, r3, #3
 8013618:	4413      	add	r3, r2
 801361a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 801361e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013622:	2b00      	cmp	r3, #0
 8013624:	db22      	blt.n	801366c <decompress_smooth_data+0x878>
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
 8013626:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801362a:	01da      	lsls	r2, r3, #7
 801362c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013630:	441a      	add	r2, r3
 8013632:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8013636:	021b      	lsls	r3, r3, #8
 8013638:	fb92 f3f3 	sdiv	r3, r2, r3
 801363c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8013640:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013644:	2b00      	cmp	r3, #0
 8013646:	dd38      	ble.n	80136ba <decompress_smooth_data+0x8c6>
 8013648:	2201      	movs	r2, #1
 801364a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801364e:	fa02 f303 	lsl.w	r3, r2, r3
 8013652:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8013656:	429a      	cmp	r2, r3
 8013658:	db2f      	blt.n	80136ba <decompress_smooth_data+0x8c6>
	      pred = (1<<Al)-1;
 801365a:	2201      	movs	r2, #1
 801365c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013660:	fa02 f303 	lsl.w	r3, r2, r3
 8013664:	3b01      	subs	r3, #1
 8013666:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 801366a:	e026      	b.n	80136ba <decompress_smooth_data+0x8c6>
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
 801366c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8013670:	01da      	lsls	r2, r3, #7
 8013672:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8013676:	1ad2      	subs	r2, r2, r3
 8013678:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801367c:	021b      	lsls	r3, r3, #8
 801367e:	fb92 f3f3 	sdiv	r3, r2, r3
 8013682:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8013686:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801368a:	2b00      	cmp	r3, #0
 801368c:	dd10      	ble.n	80136b0 <decompress_smooth_data+0x8bc>
 801368e:	2201      	movs	r2, #1
 8013690:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8013694:	fa02 f303 	lsl.w	r3, r2, r3
 8013698:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801369c:	429a      	cmp	r2, r3
 801369e:	db07      	blt.n	80136b0 <decompress_smooth_data+0x8bc>
	      pred = (1<<Al)-1;
 80136a0:	2201      	movs	r2, #1
 80136a2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80136a6:	fa02 f303 	lsl.w	r3, r2, r3
 80136aa:	3b01      	subs	r3, #1
 80136ac:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80136b0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80136b4:	425b      	negs	r3, r3
 80136b6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[2] = (JCOEF) pred;
 80136ba:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80136be:	b21a      	sxth	r2, r3
 80136c0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80136c4:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80136c8:	809a      	strh	r2, [r3, #4]
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
 80136ca:	f107 020c 	add.w	r2, r7, #12
 80136ce:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80136d2:	f5a3 7092 	sub.w	r0, r3, #292	@ 0x124
 80136d6:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80136da:	9300      	str	r3, [sp, #0]
 80136dc:	f8d7 4098 	ldr.w	r4, [r7, #152]	@ 0x98
 80136e0:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80136e4:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80136e8:	6800      	ldr	r0, [r0, #0]
 80136ea:	47a0      	blx	r4
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
 80136ec:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80136f0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 80136f4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80136f8:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
	DC4 = DC5; DC5 = DC6;
 80136fc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013700:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8013704:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8013708:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
	DC7 = DC8; DC8 = DC9;
 801370c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8013710:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8013714:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013718:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
	buffer_ptr++, prev_block_row++, next_block_row++;
 801371c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8013720:	3380      	adds	r3, #128	@ 0x80
 8013722:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 8013726:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801372a:	3380      	adds	r3, #128	@ 0x80
 801372c:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8013730:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8013734:	3380      	adds	r3, #128	@ 0x80
 8013736:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
	output_col += compptr->DCT_h_scaled_size;
 801373a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801373e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8013740:	461a      	mov	r2, r3
 8013742:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8013746:	4413      	add	r3, r2
 8013748:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 801374c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8013750:	3301      	adds	r3, #1
 8013752:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 8013756:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801375a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801375e:	429a      	cmp	r2, r3
 8013760:	f67f ad37 	bls.w	80131d2 <decompress_smooth_data+0x3de>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 8013764:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8013768:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801376a:	009b      	lsls	r3, r3, #2
 801376c:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8013770:	4413      	add	r3, r2
 8013772:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    for (block_row = 0; block_row < block_rows; block_row++) {
 8013776:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801377a:	3301      	adds	r3, #1
 801377c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8013780:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8013784:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8013788:	429a      	cmp	r2, r3
 801378a:	f6ff acaf 	blt.w	80130ec <decompress_smooth_data+0x2f8>
 801378e:	e000      	b.n	8013792 <decompress_smooth_data+0x99e>
      continue;
 8013790:	bf00      	nop
       ci++, compptr++) {
 8013792:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8013796:	3301      	adds	r3, #1
 8013798:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 801379c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80137a0:	3358      	adds	r3, #88	@ 0x58
 80137a2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80137a6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80137aa:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80137ae:	681b      	ldr	r3, [r3, #0]
 80137b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80137b2:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80137b6:	429a      	cmp	r2, r3
 80137b8:	f6ff abac 	blt.w	8012f14 <decompress_smooth_data+0x120>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 80137bc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80137c0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80137c4:	681b      	ldr	r3, [r3, #0]
 80137c6:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 80137ca:	1c5a      	adds	r2, r3, #1
 80137cc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80137d0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80137d4:	681b      	ldr	r3, [r3, #0]
 80137d6:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
 80137da:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80137de:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80137e2:	681b      	ldr	r3, [r3, #0]
 80137e4:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 80137e8:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80137ec:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80137f0:	681b      	ldr	r3, [r3, #0]
 80137f2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80137f6:	429a      	cmp	r2, r3
 80137f8:	d201      	bcs.n	80137fe <decompress_smooth_data+0xa0a>
    return JPEG_ROW_COMPLETED;
 80137fa:	2303      	movs	r3, #3
 80137fc:	e000      	b.n	8013800 <decompress_smooth_data+0xa0c>
  return JPEG_SCAN_COMPLETED;
 80137fe:	2304      	movs	r3, #4
}
 8013800:	4618      	mov	r0, r3
 8013802:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 8013806:	46bd      	mov	sp, r7
 8013808:	bdb0      	pop	{r4, r5, r7, pc}
	...

0801380c <jinit_d_coef_controller>:
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 801380c:	b5b0      	push	{r4, r5, r7, lr}
 801380e:	b08a      	sub	sp, #40	@ 0x28
 8013810:	af02      	add	r7, sp, #8
 8013812:	6078      	str	r0, [r7, #4]
 8013814:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013816:	687b      	ldr	r3, [r7, #4]
 8013818:	685b      	ldr	r3, [r3, #4]
 801381a:	681b      	ldr	r3, [r3, #0]
 801381c:	2274      	movs	r2, #116	@ 0x74
 801381e:	2101      	movs	r1, #1
 8013820:	6878      	ldr	r0, [r7, #4]
 8013822:	4798      	blx	r3
 8013824:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
 8013826:	687b      	ldr	r3, [r7, #4]
 8013828:	68fa      	ldr	r2, [r7, #12]
 801382a:	f8c3 21c0 	str.w	r2, [r3, #448]	@ 0x1c0
  coef->pub.start_input_pass = start_input_pass;
 801382e:	68fb      	ldr	r3, [r7, #12]
 8013830:	4a47      	ldr	r2, [pc, #284]	@ (8013950 <jinit_d_coef_controller+0x144>)
 8013832:	601a      	str	r2, [r3, #0]
  coef->pub.start_output_pass = start_output_pass;
 8013834:	68fb      	ldr	r3, [r7, #12]
 8013836:	4a47      	ldr	r2, [pc, #284]	@ (8013954 <jinit_d_coef_controller+0x148>)
 8013838:	609a      	str	r2, [r3, #8]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
 801383a:	68fb      	ldr	r3, [r7, #12]
 801383c:	2200      	movs	r2, #0
 801383e:	671a      	str	r2, [r3, #112]	@ 0x70
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
 8013840:	683b      	ldr	r3, [r7, #0]
 8013842:	2b00      	cmp	r3, #0
 8013844:	d051      	beq.n	80138ea <jinit_d_coef_controller+0xde>
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013846:	2300      	movs	r3, #0
 8013848:	61fb      	str	r3, [r7, #28]
 801384a:	687b      	ldr	r3, [r7, #4]
 801384c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8013850:	617b      	str	r3, [r7, #20]
 8013852:	e039      	b.n	80138c8 <jinit_d_coef_controller+0xbc>
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
 8013854:	697b      	ldr	r3, [r7, #20]
 8013856:	68db      	ldr	r3, [r3, #12]
 8013858:	61bb      	str	r3, [r7, #24]
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
 801385a:	687b      	ldr	r3, [r7, #4]
 801385c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013860:	2b00      	cmp	r3, #0
 8013862:	d004      	beq.n	801386e <jinit_d_coef_controller+0x62>
	access_rows *= 3;
 8013864:	69ba      	ldr	r2, [r7, #24]
 8013866:	4613      	mov	r3, r2
 8013868:	005b      	lsls	r3, r3, #1
 801386a:	4413      	add	r3, r2
 801386c:	61bb      	str	r3, [r7, #24]
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 801386e:	687b      	ldr	r3, [r7, #4]
 8013870:	685b      	ldr	r3, [r3, #4]
 8013872:	695c      	ldr	r4, [r3, #20]
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 8013874:	697b      	ldr	r3, [r7, #20]
 8013876:	69db      	ldr	r3, [r3, #28]
 8013878:	461a      	mov	r2, r3
				(long) compptr->h_samp_factor),
 801387a:	697b      	ldr	r3, [r7, #20]
 801387c:	689b      	ldr	r3, [r3, #8]
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 801387e:	4619      	mov	r1, r3
 8013880:	4610      	mov	r0, r2
 8013882:	f019 fa27 	bl	802ccd4 <jround_up>
 8013886:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 8013888:	461d      	mov	r5, r3
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 801388a:	697b      	ldr	r3, [r7, #20]
 801388c:	6a1b      	ldr	r3, [r3, #32]
 801388e:	461a      	mov	r2, r3
				(long) compptr->v_samp_factor),
 8013890:	697b      	ldr	r3, [r7, #20]
 8013892:	68db      	ldr	r3, [r3, #12]
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 8013894:	4619      	mov	r1, r3
 8013896:	4610      	mov	r0, r2
 8013898:	f019 fa1c 	bl	802ccd4 <jround_up>
 801389c:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 801389e:	461a      	mov	r2, r3
 80138a0:	69bb      	ldr	r3, [r7, #24]
 80138a2:	9301      	str	r3, [sp, #4]
 80138a4:	9200      	str	r2, [sp, #0]
 80138a6:	462b      	mov	r3, r5
 80138a8:	2201      	movs	r2, #1
 80138aa:	2101      	movs	r1, #1
 80138ac:	6878      	ldr	r0, [r7, #4]
 80138ae:	47a0      	blx	r4
 80138b0:	4601      	mov	r1, r0
 80138b2:	68fb      	ldr	r3, [r7, #12]
 80138b4:	69fa      	ldr	r2, [r7, #28]
 80138b6:	3212      	adds	r2, #18
 80138b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	 ci++, compptr++) {
 80138bc:	69fb      	ldr	r3, [r7, #28]
 80138be:	3301      	adds	r3, #1
 80138c0:	61fb      	str	r3, [r7, #28]
 80138c2:	697b      	ldr	r3, [r7, #20]
 80138c4:	3358      	adds	r3, #88	@ 0x58
 80138c6:	617b      	str	r3, [r7, #20]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80138c8:	687b      	ldr	r3, [r7, #4]
 80138ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80138cc:	69fa      	ldr	r2, [r7, #28]
 80138ce:	429a      	cmp	r2, r3
 80138d0:	dbc0      	blt.n	8013854 <jinit_d_coef_controller+0x48>
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
 80138d2:	68fb      	ldr	r3, [r7, #12]
 80138d4:	4a20      	ldr	r2, [pc, #128]	@ (8013958 <jinit_d_coef_controller+0x14c>)
 80138d6:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_data;
 80138d8:	68fb      	ldr	r3, [r7, #12]
 80138da:	4a20      	ldr	r2, [pc, #128]	@ (801395c <jinit_d_coef_controller+0x150>)
 80138dc:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
 80138de:	68fb      	ldr	r3, [r7, #12]
 80138e0:	f103 0248 	add.w	r2, r3, #72	@ 0x48
 80138e4:	68fb      	ldr	r3, [r7, #12]
 80138e6:	611a      	str	r2, [r3, #16]
	       (size_t) (D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK)));
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
 80138e8:	e02e      	b.n	8013948 <jinit_d_coef_controller+0x13c>
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80138ea:	687b      	ldr	r3, [r7, #4]
 80138ec:	685b      	ldr	r3, [r3, #4]
 80138ee:	685b      	ldr	r3, [r3, #4]
 80138f0:	f44f 62a0 	mov.w	r2, #1280	@ 0x500
 80138f4:	2101      	movs	r1, #1
 80138f6:	6878      	ldr	r0, [r7, #4]
 80138f8:	4798      	blx	r3
 80138fa:	60b8      	str	r0, [r7, #8]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 80138fc:	2300      	movs	r3, #0
 80138fe:	613b      	str	r3, [r7, #16]
 8013900:	e00b      	b.n	801391a <jinit_d_coef_controller+0x10e>
      coef->MCU_buffer[i] = buffer + i;
 8013902:	693b      	ldr	r3, [r7, #16]
 8013904:	01db      	lsls	r3, r3, #7
 8013906:	68ba      	ldr	r2, [r7, #8]
 8013908:	18d1      	adds	r1, r2, r3
 801390a:	68fb      	ldr	r3, [r7, #12]
 801390c:	693a      	ldr	r2, [r7, #16]
 801390e:	3208      	adds	r2, #8
 8013910:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 8013914:	693b      	ldr	r3, [r7, #16]
 8013916:	3301      	adds	r3, #1
 8013918:	613b      	str	r3, [r7, #16]
 801391a:	693b      	ldr	r3, [r7, #16]
 801391c:	2b09      	cmp	r3, #9
 801391e:	ddf0      	ble.n	8013902 <jinit_d_coef_controller+0xf6>
    if (cinfo->lim_Se == 0)	/* DC only case: want to bypass later */
 8013920:	687b      	ldr	r3, [r7, #4]
 8013922:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8013926:	2b00      	cmp	r3, #0
 8013928:	d105      	bne.n	8013936 <jinit_d_coef_controller+0x12a>
      FMEMZERO((void FAR *) buffer,
 801392a:	f44f 62a0 	mov.w	r2, #1280	@ 0x500
 801392e:	2100      	movs	r1, #0
 8013930:	68b8      	ldr	r0, [r7, #8]
 8013932:	f019 ff5e 	bl	802d7f2 <memset>
    coef->pub.consume_data = dummy_consume_data;
 8013936:	68fb      	ldr	r3, [r7, #12]
 8013938:	4a09      	ldr	r2, [pc, #36]	@ (8013960 <jinit_d_coef_controller+0x154>)
 801393a:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_onepass;
 801393c:	68fb      	ldr	r3, [r7, #12]
 801393e:	4a09      	ldr	r2, [pc, #36]	@ (8013964 <jinit_d_coef_controller+0x158>)
 8013940:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
 8013942:	68fb      	ldr	r3, [r7, #12]
 8013944:	2200      	movs	r2, #0
 8013946:	611a      	str	r2, [r3, #16]
}
 8013948:	bf00      	nop
 801394a:	3720      	adds	r7, #32
 801394c:	46bd      	mov	sp, r7
 801394e:	bdb0      	pop	{r4, r5, r7, pc}
 8013950:	080126eb 	.word	0x080126eb
 8013954:	08012709 	.word	0x08012709
 8013958:	08012979 	.word	0x08012979
 801395c:	08012b25 	.word	0x08012b25
 8013960:	08012963 	.word	0x08012963
 8013964:	0801275d 	.word	0x0801275d

08013968 <build_ycc_rgb_table>:
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 8013968:	b580      	push	{r7, lr}
 801396a:	b086      	sub	sp, #24
 801396c:	af00      	add	r7, sp, #0
 801396e:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8013970:	687b      	ldr	r3, [r7, #4]
 8013972:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8013976:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013978:	687b      	ldr	r3, [r7, #4]
 801397a:	685b      	ldr	r3, [r3, #4]
 801397c:	681b      	ldr	r3, [r3, #0]
 801397e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8013982:	2101      	movs	r1, #1
 8013984:	6878      	ldr	r0, [r7, #4]
 8013986:	4798      	blx	r3
 8013988:	4602      	mov	r2, r0
  cconvert->Cr_r_tab = (int *)
 801398a:	68fb      	ldr	r3, [r7, #12]
 801398c:	609a      	str	r2, [r3, #8]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801398e:	687b      	ldr	r3, [r7, #4]
 8013990:	685b      	ldr	r3, [r3, #4]
 8013992:	681b      	ldr	r3, [r3, #0]
 8013994:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8013998:	2101      	movs	r1, #1
 801399a:	6878      	ldr	r0, [r7, #4]
 801399c:	4798      	blx	r3
 801399e:	4602      	mov	r2, r0
  cconvert->Cb_b_tab = (int *)
 80139a0:	68fb      	ldr	r3, [r7, #12]
 80139a2:	60da      	str	r2, [r3, #12]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80139a4:	687b      	ldr	r3, [r7, #4]
 80139a6:	685b      	ldr	r3, [r3, #4]
 80139a8:	681b      	ldr	r3, [r3, #0]
 80139aa:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80139ae:	2101      	movs	r1, #1
 80139b0:	6878      	ldr	r0, [r7, #4]
 80139b2:	4798      	blx	r3
 80139b4:	4602      	mov	r2, r0
  cconvert->Cr_g_tab = (INT32 *)
 80139b6:	68fb      	ldr	r3, [r7, #12]
 80139b8:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80139ba:	687b      	ldr	r3, [r7, #4]
 80139bc:	685b      	ldr	r3, [r3, #4]
 80139be:	681b      	ldr	r3, [r3, #0]
 80139c0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80139c4:	2101      	movs	r1, #1
 80139c6:	6878      	ldr	r0, [r7, #4]
 80139c8:	4798      	blx	r3
 80139ca:	4602      	mov	r2, r0
  cconvert->Cb_g_tab = (INT32 *)
 80139cc:	68fb      	ldr	r3, [r7, #12]
 80139ce:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 80139d0:	2300      	movs	r3, #0
 80139d2:	617b      	str	r3, [r7, #20]
 80139d4:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 80139d8:	613b      	str	r3, [r7, #16]
 80139da:	e035      	b.n	8013a48 <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 80139dc:	693b      	ldr	r3, [r7, #16]
 80139de:	4a1e      	ldr	r2, [pc, #120]	@ (8013a58 <build_ycc_rgb_table+0xf0>)
 80139e0:	fb02 f303 	mul.w	r3, r2, r3
 80139e4:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    cconvert->Cr_r_tab[i] = (int)
 80139e8:	68fb      	ldr	r3, [r7, #12]
 80139ea:	6899      	ldr	r1, [r3, #8]
 80139ec:	697b      	ldr	r3, [r7, #20]
 80139ee:	009b      	lsls	r3, r3, #2
 80139f0:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 80139f2:	1412      	asrs	r2, r2, #16
    cconvert->Cr_r_tab[i] = (int)
 80139f4:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 80139f6:	693b      	ldr	r3, [r7, #16]
 80139f8:	4a18      	ldr	r2, [pc, #96]	@ (8013a5c <build_ycc_rgb_table+0xf4>)
 80139fa:	fb02 f303 	mul.w	r3, r2, r3
 80139fe:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    cconvert->Cb_b_tab[i] = (int)
 8013a02:	68fb      	ldr	r3, [r7, #12]
 8013a04:	68d9      	ldr	r1, [r3, #12]
 8013a06:	697b      	ldr	r3, [r7, #20]
 8013a08:	009b      	lsls	r3, r3, #2
 8013a0a:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 8013a0c:	1412      	asrs	r2, r2, #16
    cconvert->Cb_b_tab[i] = (int)
 8013a0e:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 8013a10:	68fb      	ldr	r3, [r7, #12]
 8013a12:	691a      	ldr	r2, [r3, #16]
 8013a14:	697b      	ldr	r3, [r7, #20]
 8013a16:	009b      	lsls	r3, r3, #2
 8013a18:	4413      	add	r3, r2
 8013a1a:	693a      	ldr	r2, [r7, #16]
 8013a1c:	4910      	ldr	r1, [pc, #64]	@ (8013a60 <build_ycc_rgb_table+0xf8>)
 8013a1e:	fb01 f202 	mul.w	r2, r1, r2
 8013a22:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 8013a24:	693b      	ldr	r3, [r7, #16]
 8013a26:	4a0f      	ldr	r2, [pc, #60]	@ (8013a64 <build_ycc_rgb_table+0xfc>)
 8013a28:	fb03 f202 	mul.w	r2, r3, r2
 8013a2c:	68fb      	ldr	r3, [r7, #12]
 8013a2e:	6959      	ldr	r1, [r3, #20]
 8013a30:	697b      	ldr	r3, [r7, #20]
 8013a32:	009b      	lsls	r3, r3, #2
 8013a34:	440b      	add	r3, r1
 8013a36:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 8013a3a:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 8013a3c:	697b      	ldr	r3, [r7, #20]
 8013a3e:	3301      	adds	r3, #1
 8013a40:	617b      	str	r3, [r7, #20]
 8013a42:	693b      	ldr	r3, [r7, #16]
 8013a44:	3301      	adds	r3, #1
 8013a46:	613b      	str	r3, [r7, #16]
 8013a48:	697b      	ldr	r3, [r7, #20]
 8013a4a:	2bff      	cmp	r3, #255	@ 0xff
 8013a4c:	ddc6      	ble.n	80139dc <build_ycc_rgb_table+0x74>
  }
}
 8013a4e:	bf00      	nop
 8013a50:	bf00      	nop
 8013a52:	3718      	adds	r7, #24
 8013a54:	46bd      	mov	sp, r7
 8013a56:	bd80      	pop	{r7, pc}
 8013a58:	000166e9 	.word	0x000166e9
 8013a5c:	0001c5a2 	.word	0x0001c5a2
 8013a60:	ffff492e 	.word	0xffff492e
 8013a64:	ffffa7e6 	.word	0xffffa7e6

08013a68 <ycc_rgb_convert>:

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
 8013a68:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013a6c:	b08d      	sub	sp, #52	@ 0x34
 8013a6e:	af00      	add	r7, sp, #0
 8013a70:	6278      	str	r0, [r7, #36]	@ 0x24
 8013a72:	6239      	str	r1, [r7, #32]
 8013a74:	61fa      	str	r2, [r7, #28]
 8013a76:	61bb      	str	r3, [r7, #24]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8013a78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013a7a:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8013a7e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8013a80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013a82:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013a84:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 8013a86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013a88:	f8d3 614c 	ldr.w	r6, [r3, #332]	@ 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 8013a8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013a8e:	689b      	ldr	r3, [r3, #8]
 8013a90:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 8013a92:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013a94:	68db      	ldr	r3, [r3, #12]
 8013a96:	617b      	str	r3, [r7, #20]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 8013a98:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013a9a:	691b      	ldr	r3, [r3, #16]
 8013a9c:	4619      	mov	r1, r3
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 8013a9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013aa0:	695b      	ldr	r3, [r3, #20]
 8013aa2:	613b      	str	r3, [r7, #16]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 8013aa4:	e053      	b.n	8013b4e <ycc_rgb_convert+0xe6>
    inptr0 = input_buf[0][input_row];
 8013aa6:	6a3b      	ldr	r3, [r7, #32]
 8013aa8:	681a      	ldr	r2, [r3, #0]
 8013aaa:	69fb      	ldr	r3, [r7, #28]
 8013aac:	009b      	lsls	r3, r3, #2
 8013aae:	4413      	add	r3, r2
 8013ab0:	681b      	ldr	r3, [r3, #0]
 8013ab2:	60fb      	str	r3, [r7, #12]
    inptr1 = input_buf[1][input_row];
 8013ab4:	6a3b      	ldr	r3, [r7, #32]
 8013ab6:	3304      	adds	r3, #4
 8013ab8:	681a      	ldr	r2, [r3, #0]
 8013aba:	69fb      	ldr	r3, [r7, #28]
 8013abc:	009b      	lsls	r3, r3, #2
 8013abe:	4413      	add	r3, r2
 8013ac0:	681b      	ldr	r3, [r3, #0]
 8013ac2:	60bb      	str	r3, [r7, #8]
    inptr2 = input_buf[2][input_row];
 8013ac4:	6a3b      	ldr	r3, [r7, #32]
 8013ac6:	3308      	adds	r3, #8
 8013ac8:	681a      	ldr	r2, [r3, #0]
 8013aca:	69fb      	ldr	r3, [r7, #28]
 8013acc:	009b      	lsls	r3, r3, #2
 8013ace:	4413      	add	r3, r2
 8013ad0:	681b      	ldr	r3, [r3, #0]
 8013ad2:	607b      	str	r3, [r7, #4]
    input_row++;
 8013ad4:	69fb      	ldr	r3, [r7, #28]
 8013ad6:	3301      	adds	r3, #1
 8013ad8:	61fb      	str	r3, [r7, #28]
    outptr = *output_buf++;
 8013ada:	69bb      	ldr	r3, [r7, #24]
 8013adc:	1d1a      	adds	r2, r3, #4
 8013ade:	61ba      	str	r2, [r7, #24]
 8013ae0:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8013ae2:	2400      	movs	r4, #0
 8013ae4:	e030      	b.n	8013b48 <ycc_rgb_convert+0xe0>
      y  = GETJSAMPLE(inptr0[col]);
 8013ae6:	68fb      	ldr	r3, [r7, #12]
 8013ae8:	4423      	add	r3, r4
 8013aea:	781b      	ldrb	r3, [r3, #0]
 8013aec:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 8013aee:	68bb      	ldr	r3, [r7, #8]
 8013af0:	4423      	add	r3, r4
 8013af2:	781b      	ldrb	r3, [r3, #0]
 8013af4:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 8013af6:	687b      	ldr	r3, [r7, #4]
 8013af8:	4423      	add	r3, r4
 8013afa:	781b      	ldrb	r3, [r3, #0]
 8013afc:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
 8013afe:	464b      	mov	r3, r9
 8013b00:	009b      	lsls	r3, r3, #2
 8013b02:	4602      	mov	r2, r0
 8013b04:	4413      	add	r3, r2
 8013b06:	681b      	ldr	r3, [r3, #0]
 8013b08:	4443      	add	r3, r8
 8013b0a:	4433      	add	r3, r6
 8013b0c:	781b      	ldrb	r3, [r3, #0]
 8013b0e:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 8013b10:	4653      	mov	r3, sl
 8013b12:	009b      	lsls	r3, r3, #2
 8013b14:	693a      	ldr	r2, [r7, #16]
 8013b16:	4413      	add	r3, r2
 8013b18:	681a      	ldr	r2, [r3, #0]
 8013b1a:	464b      	mov	r3, r9
 8013b1c:	009b      	lsls	r3, r3, #2
 8013b1e:	440b      	add	r3, r1
 8013b20:	681b      	ldr	r3, [r3, #0]
 8013b22:	4413      	add	r3, r2
 8013b24:	141b      	asrs	r3, r3, #16
      outptr[RGB_GREEN] = range_limit[y +
 8013b26:	4443      	add	r3, r8
 8013b28:	4433      	add	r3, r6
 8013b2a:	1c6a      	adds	r2, r5, #1
 8013b2c:	781b      	ldrb	r3, [r3, #0]
 8013b2e:	7013      	strb	r3, [r2, #0]
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
 8013b30:	4653      	mov	r3, sl
 8013b32:	009b      	lsls	r3, r3, #2
 8013b34:	697a      	ldr	r2, [r7, #20]
 8013b36:	4413      	add	r3, r2
 8013b38:	681b      	ldr	r3, [r3, #0]
 8013b3a:	4443      	add	r3, r8
 8013b3c:	18f2      	adds	r2, r6, r3
 8013b3e:	1cab      	adds	r3, r5, #2
 8013b40:	7812      	ldrb	r2, [r2, #0]
 8013b42:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 8013b44:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 8013b46:	3401      	adds	r4, #1
 8013b48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013b4a:	429c      	cmp	r4, r3
 8013b4c:	d3cb      	bcc.n	8013ae6 <ycc_rgb_convert+0x7e>
  while (--num_rows >= 0) {
 8013b4e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013b50:	3b01      	subs	r3, #1
 8013b52:	653b      	str	r3, [r7, #80]	@ 0x50
 8013b54:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013b56:	2b00      	cmp	r3, #0
 8013b58:	daa5      	bge.n	8013aa6 <ycc_rgb_convert+0x3e>
    }
  }
}
 8013b5a:	bf00      	nop
 8013b5c:	bf00      	nop
 8013b5e:	3734      	adds	r7, #52	@ 0x34
 8013b60:	46bd      	mov	sp, r7
 8013b62:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013b66:	4770      	bx	lr

08013b68 <build_rgb_y_table>:
 * Initialize for RGB->grayscale colorspace conversion.
 */

LOCAL(void)
build_rgb_y_table (j_decompress_ptr cinfo)
{
 8013b68:	b580      	push	{r7, lr}
 8013b6a:	b086      	sub	sp, #24
 8013b6c:	af00      	add	r7, sp, #0
 8013b6e:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8013b70:	687b      	ldr	r3, [r7, #4]
 8013b72:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8013b76:	613b      	str	r3, [r7, #16]
  INT32 * rgb_y_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013b78:	687b      	ldr	r3, [r7, #4]
 8013b7a:	685b      	ldr	r3, [r3, #4]
 8013b7c:	681b      	ldr	r3, [r3, #0]
 8013b7e:	f44f 6240 	mov.w	r2, #3072	@ 0xc00
 8013b82:	2101      	movs	r1, #1
 8013b84:	6878      	ldr	r0, [r7, #4]
 8013b86:	4798      	blx	r3
 8013b88:	60f8      	str	r0, [r7, #12]
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
 8013b8a:	693b      	ldr	r3, [r7, #16]
 8013b8c:	68fa      	ldr	r2, [r7, #12]
 8013b8e:	619a      	str	r2, [r3, #24]
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
 8013b90:	2300      	movs	r3, #0
 8013b92:	617b      	str	r3, [r7, #20]
 8013b94:	e026      	b.n	8013be4 <build_rgb_y_table+0x7c>
    rgb_y_tab[i+R_Y_OFF] = FIX(0.29900) * i;
 8013b96:	697b      	ldr	r3, [r7, #20]
 8013b98:	009b      	lsls	r3, r3, #2
 8013b9a:	68fa      	ldr	r2, [r7, #12]
 8013b9c:	4413      	add	r3, r2
 8013b9e:	697a      	ldr	r2, [r7, #20]
 8013ba0:	f644 418b 	movw	r1, #19595	@ 0x4c8b
 8013ba4:	fb01 f202 	mul.w	r2, r1, r2
 8013ba8:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+G_Y_OFF] = FIX(0.58700) * i;
 8013baa:	697b      	ldr	r3, [r7, #20]
 8013bac:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8013bb0:	009b      	lsls	r3, r3, #2
 8013bb2:	68fa      	ldr	r2, [r7, #12]
 8013bb4:	4413      	add	r3, r2
 8013bb6:	697a      	ldr	r2, [r7, #20]
 8013bb8:	f249 6146 	movw	r1, #38470	@ 0x9646
 8013bbc:	fb01 f202 	mul.w	r2, r1, r2
 8013bc0:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;
 8013bc2:	697b      	ldr	r3, [r7, #20]
 8013bc4:	f641 522f 	movw	r2, #7471	@ 0x1d2f
 8013bc8:	fb03 f202 	mul.w	r2, r3, r2
 8013bcc:	697b      	ldr	r3, [r7, #20]
 8013bce:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8013bd2:	009b      	lsls	r3, r3, #2
 8013bd4:	68f9      	ldr	r1, [r7, #12]
 8013bd6:	440b      	add	r3, r1
 8013bd8:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 8013bdc:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++) {
 8013bde:	697b      	ldr	r3, [r7, #20]
 8013be0:	3301      	adds	r3, #1
 8013be2:	617b      	str	r3, [r7, #20]
 8013be4:	697b      	ldr	r3, [r7, #20]
 8013be6:	2bff      	cmp	r3, #255	@ 0xff
 8013be8:	ddd5      	ble.n	8013b96 <build_rgb_y_table+0x2e>
  }
}
 8013bea:	bf00      	nop
 8013bec:	bf00      	nop
 8013bee:	3718      	adds	r7, #24
 8013bf0:	46bd      	mov	sp, r7
 8013bf2:	bd80      	pop	{r7, pc}

08013bf4 <rgb_gray_convert>:

METHODDEF(void)
rgb_gray_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 8013bf4:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013bf8:	b089      	sub	sp, #36	@ 0x24
 8013bfa:	af00      	add	r7, sp, #0
 8013bfc:	6178      	str	r0, [r7, #20]
 8013bfe:	6139      	str	r1, [r7, #16]
 8013c00:	60fa      	str	r2, [r7, #12]
 8013c02:	60bb      	str	r3, [r7, #8]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8013c04:	697b      	ldr	r3, [r7, #20]
 8013c06:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8013c0a:	61fb      	str	r3, [r7, #28]
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_y_tab;
 8013c0c:	69fb      	ldr	r3, [r7, #28]
 8013c0e:	699d      	ldr	r5, [r3, #24]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8013c10:	697b      	ldr	r3, [r7, #20]
 8013c12:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013c14:	61bb      	str	r3, [r7, #24]

  while (--num_rows >= 0) {
 8013c16:	e045      	b.n	8013ca4 <rgb_gray_convert+0xb0>
    inptr0 = input_buf[0][input_row];
 8013c18:	693b      	ldr	r3, [r7, #16]
 8013c1a:	681a      	ldr	r2, [r3, #0]
 8013c1c:	68fb      	ldr	r3, [r7, #12]
 8013c1e:	009b      	lsls	r3, r3, #2
 8013c20:	4413      	add	r3, r2
 8013c22:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 8013c24:	693b      	ldr	r3, [r7, #16]
 8013c26:	3304      	adds	r3, #4
 8013c28:	681a      	ldr	r2, [r3, #0]
 8013c2a:	68fb      	ldr	r3, [r7, #12]
 8013c2c:	009b      	lsls	r3, r3, #2
 8013c2e:	4413      	add	r3, r2
 8013c30:	681b      	ldr	r3, [r3, #0]
 8013c32:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 8013c34:	693b      	ldr	r3, [r7, #16]
 8013c36:	3308      	adds	r3, #8
 8013c38:	681a      	ldr	r2, [r3, #0]
 8013c3a:	68fb      	ldr	r3, [r7, #12]
 8013c3c:	009b      	lsls	r3, r3, #2
 8013c3e:	4413      	add	r3, r2
 8013c40:	681b      	ldr	r3, [r3, #0]
 8013c42:	4618      	mov	r0, r3
    input_row++;
 8013c44:	68fb      	ldr	r3, [r7, #12]
 8013c46:	3301      	adds	r3, #1
 8013c48:	60fb      	str	r3, [r7, #12]
    outptr = *output_buf++;
 8013c4a:	68bb      	ldr	r3, [r7, #8]
 8013c4c:	1d1a      	adds	r2, r3, #4
 8013c4e:	60ba      	str	r2, [r7, #8]
 8013c50:	681b      	ldr	r3, [r3, #0]
 8013c52:	607b      	str	r3, [r7, #4]
    for (col = 0; col < num_cols; col++) {
 8013c54:	2400      	movs	r4, #0
 8013c56:	e022      	b.n	8013c9e <rgb_gray_convert+0xaa>
      r = GETJSAMPLE(inptr0[col]);
 8013c58:	1933      	adds	r3, r6, r4
 8013c5a:	781b      	ldrb	r3, [r3, #0]
 8013c5c:	469a      	mov	sl, r3
      g = GETJSAMPLE(inptr1[col]);
 8013c5e:	460b      	mov	r3, r1
 8013c60:	4423      	add	r3, r4
 8013c62:	781b      	ldrb	r3, [r3, #0]
 8013c64:	4699      	mov	r9, r3
      b = GETJSAMPLE(inptr2[col]);
 8013c66:	4603      	mov	r3, r0
 8013c68:	4423      	add	r3, r4
 8013c6a:	781b      	ldrb	r3, [r3, #0]
 8013c6c:	4698      	mov	r8, r3
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 8013c6e:	4653      	mov	r3, sl
 8013c70:	009b      	lsls	r3, r3, #2
 8013c72:	442b      	add	r3, r5
 8013c74:	681a      	ldr	r2, [r3, #0]
 8013c76:	464b      	mov	r3, r9
 8013c78:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8013c7c:	009b      	lsls	r3, r3, #2
 8013c7e:	442b      	add	r3, r5
 8013c80:	681b      	ldr	r3, [r3, #0]
 8013c82:	441a      	add	r2, r3
 8013c84:	4643      	mov	r3, r8
 8013c86:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8013c8a:	009b      	lsls	r3, r3, #2
 8013c8c:	442b      	add	r3, r5
 8013c8e:	681b      	ldr	r3, [r3, #0]
 8013c90:	4413      	add	r3, r2
		 >> SCALEBITS);
 8013c92:	141a      	asrs	r2, r3, #16
      outptr[col] = (JSAMPLE)
 8013c94:	687b      	ldr	r3, [r7, #4]
 8013c96:	4423      	add	r3, r4
 8013c98:	b2d2      	uxtb	r2, r2
 8013c9a:	701a      	strb	r2, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8013c9c:	3401      	adds	r4, #1
 8013c9e:	69bb      	ldr	r3, [r7, #24]
 8013ca0:	429c      	cmp	r4, r3
 8013ca2:	d3d9      	bcc.n	8013c58 <rgb_gray_convert+0x64>
  while (--num_rows >= 0) {
 8013ca4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8013ca6:	3b01      	subs	r3, #1
 8013ca8:	643b      	str	r3, [r7, #64]	@ 0x40
 8013caa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8013cac:	2b00      	cmp	r3, #0
 8013cae:	dab3      	bge.n	8013c18 <rgb_gray_convert+0x24>
    }
  }
}
 8013cb0:	bf00      	nop
 8013cb2:	bf00      	nop
 8013cb4:	3724      	adds	r7, #36	@ 0x24
 8013cb6:	46bd      	mov	sp, r7
 8013cb8:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013cbc:	4770      	bx	lr

08013cbe <rgb_convert>:

METHODDEF(void)
rgb_convert (j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION input_row,
	     JSAMPARRAY output_buf, int num_rows)
{
 8013cbe:	b4f0      	push	{r4, r5, r6, r7}
 8013cc0:	b086      	sub	sp, #24
 8013cc2:	af00      	add	r7, sp, #0
 8013cc4:	60f8      	str	r0, [r7, #12]
 8013cc6:	60b9      	str	r1, [r7, #8]
 8013cc8:	607a      	str	r2, [r7, #4]
 8013cca:	603b      	str	r3, [r7, #0]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8013ccc:	68fb      	ldr	r3, [r7, #12]
 8013cce:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013cd0:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 8013cd2:	e030      	b.n	8013d36 <rgb_convert+0x78>
    inptr0 = input_buf[0][input_row];
 8013cd4:	68bb      	ldr	r3, [r7, #8]
 8013cd6:	681a      	ldr	r2, [r3, #0]
 8013cd8:	687b      	ldr	r3, [r7, #4]
 8013cda:	009b      	lsls	r3, r3, #2
 8013cdc:	4413      	add	r3, r2
 8013cde:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 8013ce0:	68bb      	ldr	r3, [r7, #8]
 8013ce2:	3304      	adds	r3, #4
 8013ce4:	681a      	ldr	r2, [r3, #0]
 8013ce6:	687b      	ldr	r3, [r7, #4]
 8013ce8:	009b      	lsls	r3, r3, #2
 8013cea:	4413      	add	r3, r2
 8013cec:	681b      	ldr	r3, [r3, #0]
 8013cee:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 8013cf0:	68bb      	ldr	r3, [r7, #8]
 8013cf2:	3308      	adds	r3, #8
 8013cf4:	681a      	ldr	r2, [r3, #0]
 8013cf6:	687b      	ldr	r3, [r7, #4]
 8013cf8:	009b      	lsls	r3, r3, #2
 8013cfa:	4413      	add	r3, r2
 8013cfc:	681b      	ldr	r3, [r3, #0]
 8013cfe:	4618      	mov	r0, r3
    input_row++;
 8013d00:	687b      	ldr	r3, [r7, #4]
 8013d02:	3301      	adds	r3, #1
 8013d04:	607b      	str	r3, [r7, #4]
    outptr = *output_buf++;
 8013d06:	683b      	ldr	r3, [r7, #0]
 8013d08:	1d1a      	adds	r2, r3, #4
 8013d0a:	603a      	str	r2, [r7, #0]
 8013d0c:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8013d0e:	2400      	movs	r4, #0
 8013d10:	e00e      	b.n	8013d30 <rgb_convert+0x72>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED]   = inptr0[col];
 8013d12:	1933      	adds	r3, r6, r4
 8013d14:	781b      	ldrb	r3, [r3, #0]
 8013d16:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = inptr1[col];
 8013d18:	460b      	mov	r3, r1
 8013d1a:	191a      	adds	r2, r3, r4
 8013d1c:	1c6b      	adds	r3, r5, #1
 8013d1e:	7812      	ldrb	r2, [r2, #0]
 8013d20:	701a      	strb	r2, [r3, #0]
      outptr[RGB_BLUE]  = inptr2[col];
 8013d22:	4603      	mov	r3, r0
 8013d24:	191a      	adds	r2, r3, r4
 8013d26:	1cab      	adds	r3, r5, #2
 8013d28:	7812      	ldrb	r2, [r2, #0]
 8013d2a:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 8013d2c:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 8013d2e:	3401      	adds	r4, #1
 8013d30:	697b      	ldr	r3, [r7, #20]
 8013d32:	429c      	cmp	r4, r3
 8013d34:	d3ed      	bcc.n	8013d12 <rgb_convert+0x54>
  while (--num_rows >= 0) {
 8013d36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013d38:	3b01      	subs	r3, #1
 8013d3a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013d3c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013d3e:	2b00      	cmp	r3, #0
 8013d40:	dac8      	bge.n	8013cd4 <rgb_convert+0x16>
    }
  }
}
 8013d42:	bf00      	nop
 8013d44:	bf00      	nop
 8013d46:	3718      	adds	r7, #24
 8013d48:	46bd      	mov	sp, r7
 8013d4a:	bcf0      	pop	{r4, r5, r6, r7}
 8013d4c:	4770      	bx	lr

08013d4e <null_convert>:

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
 8013d4e:	b4f0      	push	{r4, r5, r6, r7}
 8013d50:	b086      	sub	sp, #24
 8013d52:	af00      	add	r7, sp, #0
 8013d54:	60f8      	str	r0, [r7, #12]
 8013d56:	60b9      	str	r1, [r7, #8]
 8013d58:	607a      	str	r2, [r7, #4]
 8013d5a:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
 8013d5c:	68fb      	ldr	r3, [r7, #12]
 8013d5e:	6a5e      	ldr	r6, [r3, #36]	@ 0x24
  JDIMENSION num_cols = cinfo->output_width;
 8013d60:	68fb      	ldr	r3, [r7, #12]
 8013d62:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013d64:	613b      	str	r3, [r7, #16]
  int ci;

  while (--num_rows >= 0) {
 8013d66:	e028      	b.n	8013dba <null_convert+0x6c>
    for (ci = 0; ci < num_components; ci++) {
 8013d68:	2300      	movs	r3, #0
 8013d6a:	617b      	str	r3, [r7, #20]
 8013d6c:	e01c      	b.n	8013da8 <null_convert+0x5a>
      inptr = input_buf[ci][input_row];
 8013d6e:	697b      	ldr	r3, [r7, #20]
 8013d70:	009b      	lsls	r3, r3, #2
 8013d72:	68ba      	ldr	r2, [r7, #8]
 8013d74:	4413      	add	r3, r2
 8013d76:	681a      	ldr	r2, [r3, #0]
 8013d78:	687b      	ldr	r3, [r7, #4]
 8013d7a:	009b      	lsls	r3, r3, #2
 8013d7c:	4413      	add	r3, r2
 8013d7e:	681b      	ldr	r3, [r3, #0]
 8013d80:	4619      	mov	r1, r3
      outptr = output_buf[0] + ci;
 8013d82:	683b      	ldr	r3, [r7, #0]
 8013d84:	681a      	ldr	r2, [r3, #0]
 8013d86:	697b      	ldr	r3, [r7, #20]
 8013d88:	18d5      	adds	r5, r2, r3
      for (count = num_cols; count > 0; count--) {
 8013d8a:	693c      	ldr	r4, [r7, #16]
 8013d8c:	e007      	b.n	8013d9e <null_convert+0x50>
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
 8013d8e:	460b      	mov	r3, r1
 8013d90:	1c5a      	adds	r2, r3, #1
 8013d92:	4611      	mov	r1, r2
 8013d94:	781b      	ldrb	r3, [r3, #0]
 8013d96:	702b      	strb	r3, [r5, #0]
	outptr += num_components;
 8013d98:	4633      	mov	r3, r6
 8013d9a:	441d      	add	r5, r3
      for (count = num_cols; count > 0; count--) {
 8013d9c:	3c01      	subs	r4, #1
 8013d9e:	2c00      	cmp	r4, #0
 8013da0:	d1f5      	bne.n	8013d8e <null_convert+0x40>
    for (ci = 0; ci < num_components; ci++) {
 8013da2:	697b      	ldr	r3, [r7, #20]
 8013da4:	3301      	adds	r3, #1
 8013da6:	617b      	str	r3, [r7, #20]
 8013da8:	697b      	ldr	r3, [r7, #20]
 8013daa:	42b3      	cmp	r3, r6
 8013dac:	dbdf      	blt.n	8013d6e <null_convert+0x20>
      }
    }
    input_row++;
 8013dae:	687b      	ldr	r3, [r7, #4]
 8013db0:	3301      	adds	r3, #1
 8013db2:	607b      	str	r3, [r7, #4]
    output_buf++;
 8013db4:	683b      	ldr	r3, [r7, #0]
 8013db6:	3304      	adds	r3, #4
 8013db8:	603b      	str	r3, [r7, #0]
  while (--num_rows >= 0) {
 8013dba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013dbc:	3b01      	subs	r3, #1
 8013dbe:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013dc0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013dc2:	2b00      	cmp	r3, #0
 8013dc4:	dad0      	bge.n	8013d68 <null_convert+0x1a>
  }
}
 8013dc6:	bf00      	nop
 8013dc8:	bf00      	nop
 8013dca:	3718      	adds	r7, #24
 8013dcc:	46bd      	mov	sp, r7
 8013dce:	bcf0      	pop	{r4, r5, r6, r7}
 8013dd0:	4770      	bx	lr

08013dd2 <grayscale_convert>:

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 8013dd2:	b580      	push	{r7, lr}
 8013dd4:	b086      	sub	sp, #24
 8013dd6:	af02      	add	r7, sp, #8
 8013dd8:	60f8      	str	r0, [r7, #12]
 8013dda:	60b9      	str	r1, [r7, #8]
 8013ddc:	607a      	str	r2, [r7, #4]
 8013dde:	603b      	str	r3, [r7, #0]
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
 8013de0:	68bb      	ldr	r3, [r7, #8]
 8013de2:	6818      	ldr	r0, [r3, #0]
 8013de4:	6879      	ldr	r1, [r7, #4]
 8013de6:	68fb      	ldr	r3, [r7, #12]
 8013de8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013dea:	9301      	str	r3, [sp, #4]
 8013dec:	69bb      	ldr	r3, [r7, #24]
 8013dee:	9300      	str	r3, [sp, #0]
 8013df0:	2300      	movs	r3, #0
 8013df2:	683a      	ldr	r2, [r7, #0]
 8013df4:	f018 ff88 	bl	802cd08 <jcopy_sample_rows>
		    num_rows, cinfo->output_width);
}
 8013df8:	bf00      	nop
 8013dfa:	3710      	adds	r7, #16
 8013dfc:	46bd      	mov	sp, r7
 8013dfe:	bd80      	pop	{r7, pc}

08013e00 <gray_rgb_convert>:

METHODDEF(void)
gray_rgb_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 8013e00:	b4f0      	push	{r4, r5, r6, r7}
 8013e02:	b086      	sub	sp, #24
 8013e04:	af00      	add	r7, sp, #0
 8013e06:	60f8      	str	r0, [r7, #12]
 8013e08:	60b9      	str	r1, [r7, #8]
 8013e0a:	607a      	str	r2, [r7, #4]
 8013e0c:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8013e0e:	68fb      	ldr	r3, [r7, #12]
 8013e10:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013e12:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 8013e14:	e01b      	b.n	8013e4e <gray_rgb_convert+0x4e>
    inptr = input_buf[0][input_row++];
 8013e16:	68bb      	ldr	r3, [r7, #8]
 8013e18:	681a      	ldr	r2, [r3, #0]
 8013e1a:	687b      	ldr	r3, [r7, #4]
 8013e1c:	1c59      	adds	r1, r3, #1
 8013e1e:	6079      	str	r1, [r7, #4]
 8013e20:	009b      	lsls	r3, r3, #2
 8013e22:	4413      	add	r3, r2
 8013e24:	681e      	ldr	r6, [r3, #0]
    outptr = *output_buf++;
 8013e26:	683b      	ldr	r3, [r7, #0]
 8013e28:	1d1a      	adds	r2, r3, #4
 8013e2a:	603a      	str	r2, [r7, #0]
 8013e2c:	681c      	ldr	r4, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8013e2e:	2500      	movs	r5, #0
 8013e30:	e00a      	b.n	8013e48 <gray_rgb_convert+0x48>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
 8013e32:	1973      	adds	r3, r6, r5
 8013e34:	1ca2      	adds	r2, r4, #2
 8013e36:	781b      	ldrb	r3, [r3, #0]
 8013e38:	7013      	strb	r3, [r2, #0]
 8013e3a:	1c63      	adds	r3, r4, #1
 8013e3c:	7812      	ldrb	r2, [r2, #0]
 8013e3e:	701a      	strb	r2, [r3, #0]
 8013e40:	781b      	ldrb	r3, [r3, #0]
 8013e42:	7023      	strb	r3, [r4, #0]
      outptr += RGB_PIXELSIZE;
 8013e44:	3403      	adds	r4, #3
    for (col = 0; col < num_cols; col++) {
 8013e46:	3501      	adds	r5, #1
 8013e48:	697b      	ldr	r3, [r7, #20]
 8013e4a:	429d      	cmp	r5, r3
 8013e4c:	d3f1      	bcc.n	8013e32 <gray_rgb_convert+0x32>
  while (--num_rows >= 0) {
 8013e4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013e50:	3b01      	subs	r3, #1
 8013e52:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013e54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013e56:	2b00      	cmp	r3, #0
 8013e58:	dadd      	bge.n	8013e16 <gray_rgb_convert+0x16>
    }
  }
}
 8013e5a:	bf00      	nop
 8013e5c:	bf00      	nop
 8013e5e:	3718      	adds	r7, #24
 8013e60:	46bd      	mov	sp, r7
 8013e62:	bcf0      	pop	{r4, r5, r6, r7}
 8013e64:	4770      	bx	lr

08013e66 <ycck_cmyk_convert>:

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 8013e66:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013e6a:	b08d      	sub	sp, #52	@ 0x34
 8013e6c:	af00      	add	r7, sp, #0
 8013e6e:	6278      	str	r0, [r7, #36]	@ 0x24
 8013e70:	6239      	str	r1, [r7, #32]
 8013e72:	61fa      	str	r2, [r7, #28]
 8013e74:	61bb      	str	r3, [r7, #24]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8013e76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013e78:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8013e7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8013e7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013e80:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013e82:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 8013e84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013e86:	f8d3 614c 	ldr.w	r6, [r3, #332]	@ 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 8013e8a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013e8c:	689b      	ldr	r3, [r3, #8]
 8013e8e:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 8013e90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013e92:	68db      	ldr	r3, [r3, #12]
 8013e94:	617b      	str	r3, [r7, #20]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 8013e96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013e98:	691b      	ldr	r3, [r3, #16]
 8013e9a:	4619      	mov	r1, r3
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 8013e9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013e9e:	695b      	ldr	r3, [r3, #20]
 8013ea0:	613b      	str	r3, [r7, #16]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 8013ea2:	e066      	b.n	8013f72 <ycck_cmyk_convert+0x10c>
    inptr0 = input_buf[0][input_row];
 8013ea4:	6a3b      	ldr	r3, [r7, #32]
 8013ea6:	681a      	ldr	r2, [r3, #0]
 8013ea8:	69fb      	ldr	r3, [r7, #28]
 8013eaa:	009b      	lsls	r3, r3, #2
 8013eac:	4413      	add	r3, r2
 8013eae:	681b      	ldr	r3, [r3, #0]
 8013eb0:	60fb      	str	r3, [r7, #12]
    inptr1 = input_buf[1][input_row];
 8013eb2:	6a3b      	ldr	r3, [r7, #32]
 8013eb4:	3304      	adds	r3, #4
 8013eb6:	681a      	ldr	r2, [r3, #0]
 8013eb8:	69fb      	ldr	r3, [r7, #28]
 8013eba:	009b      	lsls	r3, r3, #2
 8013ebc:	4413      	add	r3, r2
 8013ebe:	681b      	ldr	r3, [r3, #0]
 8013ec0:	60bb      	str	r3, [r7, #8]
    inptr2 = input_buf[2][input_row];
 8013ec2:	6a3b      	ldr	r3, [r7, #32]
 8013ec4:	3308      	adds	r3, #8
 8013ec6:	681a      	ldr	r2, [r3, #0]
 8013ec8:	69fb      	ldr	r3, [r7, #28]
 8013eca:	009b      	lsls	r3, r3, #2
 8013ecc:	4413      	add	r3, r2
 8013ece:	681b      	ldr	r3, [r3, #0]
 8013ed0:	607b      	str	r3, [r7, #4]
    inptr3 = input_buf[3][input_row];
 8013ed2:	6a3b      	ldr	r3, [r7, #32]
 8013ed4:	330c      	adds	r3, #12
 8013ed6:	681a      	ldr	r2, [r3, #0]
 8013ed8:	69fb      	ldr	r3, [r7, #28]
 8013eda:	009b      	lsls	r3, r3, #2
 8013edc:	4413      	add	r3, r2
 8013ede:	681b      	ldr	r3, [r3, #0]
 8013ee0:	603b      	str	r3, [r7, #0]
    input_row++;
 8013ee2:	69fb      	ldr	r3, [r7, #28]
 8013ee4:	3301      	adds	r3, #1
 8013ee6:	61fb      	str	r3, [r7, #28]
    outptr = *output_buf++;
 8013ee8:	69bb      	ldr	r3, [r7, #24]
 8013eea:	1d1a      	adds	r2, r3, #4
 8013eec:	61ba      	str	r2, [r7, #24]
 8013eee:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8013ef0:	2400      	movs	r4, #0
 8013ef2:	e03b      	b.n	8013f6c <ycck_cmyk_convert+0x106>
      y  = GETJSAMPLE(inptr0[col]);
 8013ef4:	68fb      	ldr	r3, [r7, #12]
 8013ef6:	4423      	add	r3, r4
 8013ef8:	781b      	ldrb	r3, [r3, #0]
 8013efa:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 8013efc:	68bb      	ldr	r3, [r7, #8]
 8013efe:	4423      	add	r3, r4
 8013f00:	781b      	ldrb	r3, [r3, #0]
 8013f02:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 8013f04:	687b      	ldr	r3, [r7, #4]
 8013f06:	4423      	add	r3, r4
 8013f08:	781b      	ldrb	r3, [r3, #0]
 8013f0a:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
 8013f0c:	464b      	mov	r3, r9
 8013f0e:	009b      	lsls	r3, r3, #2
 8013f10:	4602      	mov	r2, r0
 8013f12:	4413      	add	r3, r2
 8013f14:	681b      	ldr	r3, [r3, #0]
 8013f16:	4443      	add	r3, r8
 8013f18:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8013f1c:	4433      	add	r3, r6
 8013f1e:	781b      	ldrb	r3, [r3, #0]
 8013f20:	702b      	strb	r3, [r5, #0]
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 8013f22:	4653      	mov	r3, sl
 8013f24:	009b      	lsls	r3, r3, #2
 8013f26:	693a      	ldr	r2, [r7, #16]
 8013f28:	4413      	add	r3, r2
 8013f2a:	681a      	ldr	r2, [r3, #0]
 8013f2c:	464b      	mov	r3, r9
 8013f2e:	009b      	lsls	r3, r3, #2
 8013f30:	440b      	add	r3, r1
 8013f32:	681b      	ldr	r3, [r3, #0]
 8013f34:	4413      	add	r3, r2
 8013f36:	141b      	asrs	r3, r3, #16
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
 8013f38:	4443      	add	r3, r8
 8013f3a:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8013f3e:	4433      	add	r3, r6
 8013f40:	1c6a      	adds	r2, r5, #1
 8013f42:	781b      	ldrb	r3, [r3, #0]
 8013f44:	7013      	strb	r3, [r2, #0]
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
 8013f46:	4653      	mov	r3, sl
 8013f48:	009b      	lsls	r3, r3, #2
 8013f4a:	697a      	ldr	r2, [r7, #20]
 8013f4c:	4413      	add	r3, r2
 8013f4e:	681b      	ldr	r3, [r3, #0]
 8013f50:	4443      	add	r3, r8
 8013f52:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8013f56:	18f2      	adds	r2, r6, r3
 8013f58:	1cab      	adds	r3, r5, #2
 8013f5a:	7812      	ldrb	r2, [r2, #0]
 8013f5c:	701a      	strb	r2, [r3, #0]
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
 8013f5e:	683b      	ldr	r3, [r7, #0]
 8013f60:	191a      	adds	r2, r3, r4
 8013f62:	1ceb      	adds	r3, r5, #3
 8013f64:	7812      	ldrb	r2, [r2, #0]
 8013f66:	701a      	strb	r2, [r3, #0]
      outptr += 4;
 8013f68:	3504      	adds	r5, #4
    for (col = 0; col < num_cols; col++) {
 8013f6a:	3401      	adds	r4, #1
 8013f6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013f6e:	429c      	cmp	r4, r3
 8013f70:	d3c0      	bcc.n	8013ef4 <ycck_cmyk_convert+0x8e>
  while (--num_rows >= 0) {
 8013f72:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013f74:	3b01      	subs	r3, #1
 8013f76:	653b      	str	r3, [r7, #80]	@ 0x50
 8013f78:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013f7a:	2b00      	cmp	r3, #0
 8013f7c:	da92      	bge.n	8013ea4 <ycck_cmyk_convert+0x3e>
    }
  }
}
 8013f7e:	bf00      	nop
 8013f80:	bf00      	nop
 8013f82:	3734      	adds	r7, #52	@ 0x34
 8013f84:	46bd      	mov	sp, r7
 8013f86:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8013f8a:	4770      	bx	lr

08013f8c <start_pass_dcolor>:
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
 8013f8c:	b480      	push	{r7}
 8013f8e:	b083      	sub	sp, #12
 8013f90:	af00      	add	r7, sp, #0
 8013f92:	6078      	str	r0, [r7, #4]
  /* no work needed */
}
 8013f94:	bf00      	nop
 8013f96:	370c      	adds	r7, #12
 8013f98:	46bd      	mov	sp, r7
 8013f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f9e:	4770      	bx	lr

08013fa0 <jinit_color_deconverter>:
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
 8013fa0:	b580      	push	{r7, lr}
 8013fa2:	b084      	sub	sp, #16
 8013fa4:	af00      	add	r7, sp, #0
 8013fa6:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013fa8:	687b      	ldr	r3, [r7, #4]
 8013faa:	685b      	ldr	r3, [r3, #4]
 8013fac:	681b      	ldr	r3, [r3, #0]
 8013fae:	221c      	movs	r2, #28
 8013fb0:	2101      	movs	r1, #1
 8013fb2:	6878      	ldr	r0, [r7, #4]
 8013fb4:	4798      	blx	r3
 8013fb6:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
 8013fb8:	687b      	ldr	r3, [r7, #4]
 8013fba:	68ba      	ldr	r2, [r7, #8]
 8013fbc:	f8c3 21dc 	str.w	r2, [r3, #476]	@ 0x1dc
  cconvert->pub.start_pass = start_pass_dcolor;
 8013fc0:	68bb      	ldr	r3, [r7, #8]
 8013fc2:	4a88      	ldr	r2, [pc, #544]	@ (80141e4 <jinit_color_deconverter+0x244>)
 8013fc4:	601a      	str	r2, [r3, #0]

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
 8013fc6:	687b      	ldr	r3, [r7, #4]
 8013fc8:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8013fcc:	2b05      	cmp	r3, #5
 8013fce:	dc33      	bgt.n	8014038 <jinit_color_deconverter+0x98>
 8013fd0:	2b04      	cmp	r3, #4
 8013fd2:	da23      	bge.n	801401c <jinit_color_deconverter+0x7c>
 8013fd4:	2b01      	cmp	r3, #1
 8013fd6:	d005      	beq.n	8013fe4 <jinit_color_deconverter+0x44>
 8013fd8:	2b00      	cmp	r3, #0
 8013fda:	dd2d      	ble.n	8014038 <jinit_color_deconverter+0x98>
 8013fdc:	3b02      	subs	r3, #2
 8013fde:	2b01      	cmp	r3, #1
 8013fe0:	d82a      	bhi.n	8014038 <jinit_color_deconverter+0x98>
 8013fe2:	e00d      	b.n	8014000 <jinit_color_deconverter+0x60>
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
 8013fe4:	687b      	ldr	r3, [r7, #4]
 8013fe6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8013fe8:	2b01      	cmp	r3, #1
 8013fea:	d033      	beq.n	8014054 <jinit_color_deconverter+0xb4>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 8013fec:	687b      	ldr	r3, [r7, #4]
 8013fee:	681b      	ldr	r3, [r3, #0]
 8013ff0:	220b      	movs	r2, #11
 8013ff2:	615a      	str	r2, [r3, #20]
 8013ff4:	687b      	ldr	r3, [r7, #4]
 8013ff6:	681b      	ldr	r3, [r3, #0]
 8013ff8:	681b      	ldr	r3, [r3, #0]
 8013ffa:	6878      	ldr	r0, [r7, #4]
 8013ffc:	4798      	blx	r3
    break;
 8013ffe:	e029      	b.n	8014054 <jinit_color_deconverter+0xb4>

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
 8014000:	687b      	ldr	r3, [r7, #4]
 8014002:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014004:	2b03      	cmp	r3, #3
 8014006:	d027      	beq.n	8014058 <jinit_color_deconverter+0xb8>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 8014008:	687b      	ldr	r3, [r7, #4]
 801400a:	681b      	ldr	r3, [r3, #0]
 801400c:	220b      	movs	r2, #11
 801400e:	615a      	str	r2, [r3, #20]
 8014010:	687b      	ldr	r3, [r7, #4]
 8014012:	681b      	ldr	r3, [r3, #0]
 8014014:	681b      	ldr	r3, [r3, #0]
 8014016:	6878      	ldr	r0, [r7, #4]
 8014018:	4798      	blx	r3
    break;
 801401a:	e01d      	b.n	8014058 <jinit_color_deconverter+0xb8>

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
 801401c:	687b      	ldr	r3, [r7, #4]
 801401e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014020:	2b04      	cmp	r3, #4
 8014022:	d01b      	beq.n	801405c <jinit_color_deconverter+0xbc>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 8014024:	687b      	ldr	r3, [r7, #4]
 8014026:	681b      	ldr	r3, [r3, #0]
 8014028:	220b      	movs	r2, #11
 801402a:	615a      	str	r2, [r3, #20]
 801402c:	687b      	ldr	r3, [r7, #4]
 801402e:	681b      	ldr	r3, [r3, #0]
 8014030:	681b      	ldr	r3, [r3, #0]
 8014032:	6878      	ldr	r0, [r7, #4]
 8014034:	4798      	blx	r3
    break;
 8014036:	e011      	b.n	801405c <jinit_color_deconverter+0xbc>

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
 8014038:	687b      	ldr	r3, [r7, #4]
 801403a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801403c:	2b00      	cmp	r3, #0
 801403e:	dc0f      	bgt.n	8014060 <jinit_color_deconverter+0xc0>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 8014040:	687b      	ldr	r3, [r7, #4]
 8014042:	681b      	ldr	r3, [r3, #0]
 8014044:	220b      	movs	r2, #11
 8014046:	615a      	str	r2, [r3, #20]
 8014048:	687b      	ldr	r3, [r7, #4]
 801404a:	681b      	ldr	r3, [r3, #0]
 801404c:	681b      	ldr	r3, [r3, #0]
 801404e:	6878      	ldr	r0, [r7, #4]
 8014050:	4798      	blx	r3
    break;
 8014052:	e005      	b.n	8014060 <jinit_color_deconverter+0xc0>
    break;
 8014054:	bf00      	nop
 8014056:	e004      	b.n	8014062 <jinit_color_deconverter+0xc2>
    break;
 8014058:	bf00      	nop
 801405a:	e002      	b.n	8014062 <jinit_color_deconverter+0xc2>
    break;
 801405c:	bf00      	nop
 801405e:	e000      	b.n	8014062 <jinit_color_deconverter+0xc2>
    break;
 8014060:	bf00      	nop
  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
 8014062:	687b      	ldr	r3, [r7, #4]
 8014064:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 8014068:	2b04      	cmp	r3, #4
 801406a:	d06f      	beq.n	801414c <jinit_color_deconverter+0x1ac>
 801406c:	2b04      	cmp	r3, #4
 801406e:	f300 808f 	bgt.w	8014190 <jinit_color_deconverter+0x1f0>
 8014072:	2b01      	cmp	r3, #1
 8014074:	d002      	beq.n	801407c <jinit_color_deconverter+0xdc>
 8014076:	2b02      	cmp	r3, #2
 8014078:	d03d      	beq.n	80140f6 <jinit_color_deconverter+0x156>
 801407a:	e089      	b.n	8014190 <jinit_color_deconverter+0x1f0>
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 801407c:	687b      	ldr	r3, [r7, #4]
 801407e:	2201      	movs	r2, #1
 8014080:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 8014082:	687b      	ldr	r3, [r7, #4]
 8014084:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8014088:	2b01      	cmp	r3, #1
 801408a:	d004      	beq.n	8014096 <jinit_color_deconverter+0xf6>
	cinfo->jpeg_color_space == JCS_YCbCr) {
 801408c:	687b      	ldr	r3, [r7, #4]
 801408e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 8014092:	2b03      	cmp	r3, #3
 8014094:	d118      	bne.n	80140c8 <jinit_color_deconverter+0x128>
      cconvert->pub.color_convert = grayscale_convert;
 8014096:	68bb      	ldr	r3, [r7, #8]
 8014098:	4a53      	ldr	r2, [pc, #332]	@ (80141e8 <jinit_color_deconverter+0x248>)
 801409a:	605a      	str	r2, [r3, #4]
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
 801409c:	2301      	movs	r3, #1
 801409e:	60fb      	str	r3, [r7, #12]
 80140a0:	e00c      	b.n	80140bc <jinit_color_deconverter+0x11c>
	cinfo->comp_info[ci].component_needed = FALSE;
 80140a2:	687b      	ldr	r3, [r7, #4]
 80140a4:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 80140a8:	68fb      	ldr	r3, [r7, #12]
 80140aa:	2158      	movs	r1, #88	@ 0x58
 80140ac:	fb01 f303 	mul.w	r3, r1, r3
 80140b0:	4413      	add	r3, r2
 80140b2:	2200      	movs	r2, #0
 80140b4:	635a      	str	r2, [r3, #52]	@ 0x34
      for (ci = 1; ci < cinfo->num_components; ci++)
 80140b6:	68fb      	ldr	r3, [r7, #12]
 80140b8:	3301      	adds	r3, #1
 80140ba:	60fb      	str	r3, [r7, #12]
 80140bc:	687b      	ldr	r3, [r7, #4]
 80140be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80140c0:	68fa      	ldr	r2, [r7, #12]
 80140c2:	429a      	cmp	r2, r3
 80140c4:	dbed      	blt.n	80140a2 <jinit_color_deconverter+0x102>
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 80140c6:	e015      	b.n	80140f4 <jinit_color_deconverter+0x154>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 80140c8:	687b      	ldr	r3, [r7, #4]
 80140ca:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 80140ce:	2b02      	cmp	r3, #2
 80140d0:	d106      	bne.n	80140e0 <jinit_color_deconverter+0x140>
      cconvert->pub.color_convert = rgb_gray_convert;
 80140d2:	68bb      	ldr	r3, [r7, #8]
 80140d4:	4a45      	ldr	r2, [pc, #276]	@ (80141ec <jinit_color_deconverter+0x24c>)
 80140d6:	605a      	str	r2, [r3, #4]
      build_rgb_y_table(cinfo);
 80140d8:	6878      	ldr	r0, [r7, #4]
 80140da:	f7ff fd45 	bl	8013b68 <build_rgb_y_table>
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 80140de:	e071      	b.n	80141c4 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 80140e0:	687b      	ldr	r3, [r7, #4]
 80140e2:	681b      	ldr	r3, [r3, #0]
 80140e4:	221c      	movs	r2, #28
 80140e6:	615a      	str	r2, [r3, #20]
 80140e8:	687b      	ldr	r3, [r7, #4]
 80140ea:	681b      	ldr	r3, [r3, #0]
 80140ec:	681b      	ldr	r3, [r3, #0]
 80140ee:	6878      	ldr	r0, [r7, #4]
 80140f0:	4798      	blx	r3
    break;
 80140f2:	e067      	b.n	80141c4 <jinit_color_deconverter+0x224>
 80140f4:	e066      	b.n	80141c4 <jinit_color_deconverter+0x224>

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 80140f6:	687b      	ldr	r3, [r7, #4]
 80140f8:	2203      	movs	r2, #3
 80140fa:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
 80140fc:	687b      	ldr	r3, [r7, #4]
 80140fe:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8014102:	2b03      	cmp	r3, #3
 8014104:	d106      	bne.n	8014114 <jinit_color_deconverter+0x174>
      cconvert->pub.color_convert = ycc_rgb_convert;
 8014106:	68bb      	ldr	r3, [r7, #8]
 8014108:	4a39      	ldr	r2, [pc, #228]	@ (80141f0 <jinit_color_deconverter+0x250>)
 801410a:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 801410c:	6878      	ldr	r0, [r7, #4]
 801410e:	f7ff fc2b 	bl	8013968 <build_ycc_rgb_table>
      cconvert->pub.color_convert = gray_rgb_convert;
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
      cconvert->pub.color_convert = rgb_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 8014112:	e057      	b.n	80141c4 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
 8014114:	687b      	ldr	r3, [r7, #4]
 8014116:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801411a:	2b01      	cmp	r3, #1
 801411c:	d103      	bne.n	8014126 <jinit_color_deconverter+0x186>
      cconvert->pub.color_convert = gray_rgb_convert;
 801411e:	68bb      	ldr	r3, [r7, #8]
 8014120:	4a34      	ldr	r2, [pc, #208]	@ (80141f4 <jinit_color_deconverter+0x254>)
 8014122:	605a      	str	r2, [r3, #4]
    break;
 8014124:	e04e      	b.n	80141c4 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 8014126:	687b      	ldr	r3, [r7, #4]
 8014128:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801412c:	2b02      	cmp	r3, #2
 801412e:	d103      	bne.n	8014138 <jinit_color_deconverter+0x198>
      cconvert->pub.color_convert = rgb_convert;
 8014130:	68bb      	ldr	r3, [r7, #8]
 8014132:	4a31      	ldr	r2, [pc, #196]	@ (80141f8 <jinit_color_deconverter+0x258>)
 8014134:	605a      	str	r2, [r3, #4]
    break;
 8014136:	e045      	b.n	80141c4 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 8014138:	687b      	ldr	r3, [r7, #4]
 801413a:	681b      	ldr	r3, [r3, #0]
 801413c:	221c      	movs	r2, #28
 801413e:	615a      	str	r2, [r3, #20]
 8014140:	687b      	ldr	r3, [r7, #4]
 8014142:	681b      	ldr	r3, [r3, #0]
 8014144:	681b      	ldr	r3, [r3, #0]
 8014146:	6878      	ldr	r0, [r7, #4]
 8014148:	4798      	blx	r3
    break;
 801414a:	e03b      	b.n	80141c4 <jinit_color_deconverter+0x224>

  case JCS_CMYK:
    cinfo->out_color_components = 4;
 801414c:	687b      	ldr	r3, [r7, #4]
 801414e:	2204      	movs	r2, #4
 8014150:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_YCCK) {
 8014152:	687b      	ldr	r3, [r7, #4]
 8014154:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8014158:	2b05      	cmp	r3, #5
 801415a:	d106      	bne.n	801416a <jinit_color_deconverter+0x1ca>
      cconvert->pub.color_convert = ycck_cmyk_convert;
 801415c:	68bb      	ldr	r3, [r7, #8]
 801415e:	4a27      	ldr	r2, [pc, #156]	@ (80141fc <jinit_color_deconverter+0x25c>)
 8014160:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 8014162:	6878      	ldr	r0, [r7, #4]
 8014164:	f7ff fc00 	bl	8013968 <build_ycc_rgb_table>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 8014168:	e02c      	b.n	80141c4 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
 801416a:	687b      	ldr	r3, [r7, #4]
 801416c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8014170:	2b04      	cmp	r3, #4
 8014172:	d103      	bne.n	801417c <jinit_color_deconverter+0x1dc>
      cconvert->pub.color_convert = null_convert;
 8014174:	68bb      	ldr	r3, [r7, #8]
 8014176:	4a22      	ldr	r2, [pc, #136]	@ (8014200 <jinit_color_deconverter+0x260>)
 8014178:	605a      	str	r2, [r3, #4]
    break;
 801417a:	e023      	b.n	80141c4 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 801417c:	687b      	ldr	r3, [r7, #4]
 801417e:	681b      	ldr	r3, [r3, #0]
 8014180:	221c      	movs	r2, #28
 8014182:	615a      	str	r2, [r3, #20]
 8014184:	687b      	ldr	r3, [r7, #4]
 8014186:	681b      	ldr	r3, [r3, #0]
 8014188:	681b      	ldr	r3, [r3, #0]
 801418a:	6878      	ldr	r0, [r7, #4]
 801418c:	4798      	blx	r3
    break;
 801418e:	e019      	b.n	80141c4 <jinit_color_deconverter+0x224>

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
 8014190:	687b      	ldr	r3, [r7, #4]
 8014192:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 8014196:	687b      	ldr	r3, [r7, #4]
 8014198:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801419c:	429a      	cmp	r2, r3
 801419e:	d107      	bne.n	80141b0 <jinit_color_deconverter+0x210>
      cinfo->out_color_components = cinfo->num_components;
 80141a0:	687b      	ldr	r3, [r7, #4]
 80141a2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80141a4:	687b      	ldr	r3, [r7, #4]
 80141a6:	679a      	str	r2, [r3, #120]	@ 0x78
      cconvert->pub.color_convert = null_convert;
 80141a8:	68bb      	ldr	r3, [r7, #8]
 80141aa:	4a15      	ldr	r2, [pc, #84]	@ (8014200 <jinit_color_deconverter+0x260>)
 80141ac:	605a      	str	r2, [r3, #4]
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 80141ae:	e008      	b.n	80141c2 <jinit_color_deconverter+0x222>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 80141b0:	687b      	ldr	r3, [r7, #4]
 80141b2:	681b      	ldr	r3, [r3, #0]
 80141b4:	221c      	movs	r2, #28
 80141b6:	615a      	str	r2, [r3, #20]
 80141b8:	687b      	ldr	r3, [r7, #4]
 80141ba:	681b      	ldr	r3, [r3, #0]
 80141bc:	681b      	ldr	r3, [r3, #0]
 80141be:	6878      	ldr	r0, [r7, #4]
 80141c0:	4798      	blx	r3
    break;
 80141c2:	bf00      	nop
  }

  if (cinfo->quantize_colors)
 80141c4:	687b      	ldr	r3, [r7, #4]
 80141c6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80141c8:	2b00      	cmp	r3, #0
 80141ca:	d003      	beq.n	80141d4 <jinit_color_deconverter+0x234>
    cinfo->output_components = 1; /* single colormapped output component */
 80141cc:	687b      	ldr	r3, [r7, #4]
 80141ce:	2201      	movs	r2, #1
 80141d0:	67da      	str	r2, [r3, #124]	@ 0x7c
  else
    cinfo->output_components = cinfo->out_color_components;
}
 80141d2:	e003      	b.n	80141dc <jinit_color_deconverter+0x23c>
    cinfo->output_components = cinfo->out_color_components;
 80141d4:	687b      	ldr	r3, [r7, #4]
 80141d6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 80141d8:	687b      	ldr	r3, [r7, #4]
 80141da:	67da      	str	r2, [r3, #124]	@ 0x7c
}
 80141dc:	bf00      	nop
 80141de:	3710      	adds	r7, #16
 80141e0:	46bd      	mov	sp, r7
 80141e2:	bd80      	pop	{r7, pc}
 80141e4:	08013f8d 	.word	0x08013f8d
 80141e8:	08013dd3 	.word	0x08013dd3
 80141ec:	08013bf5 	.word	0x08013bf5
 80141f0:	08013a69 	.word	0x08013a69
 80141f4:	08013e01 	.word	0x08013e01
 80141f8:	08013cbf 	.word	0x08013cbf
 80141fc:	08013e67 	.word	0x08013e67
 8014200:	08013d4f 	.word	0x08013d4f

08014204 <start_pass>:
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 8014204:	b590      	push	{r4, r7, lr}
 8014206:	b08f      	sub	sp, #60	@ 0x3c
 8014208:	af00      	add	r7, sp, #0
 801420a:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
 801420c:	687b      	ldr	r3, [r7, #4]
 801420e:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
 8014212:	61bb      	str	r3, [r7, #24]
  int ci, i;
  jpeg_component_info *compptr;
  int method = 0;
 8014214:	2300      	movs	r3, #0
 8014216:	62bb      	str	r3, [r7, #40]	@ 0x28
  inverse_DCT_method_ptr method_ptr = NULL;
 8014218:	2300      	movs	r3, #0
 801421a:	627b      	str	r3, [r7, #36]	@ 0x24
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801421c:	2300      	movs	r3, #0
 801421e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014220:	687b      	ldr	r3, [r7, #4]
 8014222:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8014226:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8014228:	e30d      	b.n	8014846 <start_pass+0x642>
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch ((compptr->DCT_h_scaled_size << 8) + compptr->DCT_v_scaled_size) {
 801422a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801422c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801422e:	021a      	lsls	r2, r3, #8
 8014230:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014232:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014234:	4413      	add	r3, r2
 8014236:	f241 0210 	movw	r2, #4112	@ 0x1010
 801423a:	4293      	cmp	r3, r2
 801423c:	f000 8168 	beq.w	8014510 <start_pass+0x30c>
 8014240:	f241 0210 	movw	r2, #4112	@ 0x1010
 8014244:	4293      	cmp	r3, r2
 8014246:	f300 81de 	bgt.w	8014606 <start_pass+0x402>
 801424a:	f241 0208 	movw	r2, #4104	@ 0x1008
 801424e:	4293      	cmp	r3, r2
 8014250:	f000 8163 	beq.w	801451a <start_pass+0x316>
 8014254:	f241 0208 	movw	r2, #4104	@ 0x1008
 8014258:	4293      	cmp	r3, r2
 801425a:	f300 81d4 	bgt.w	8014606 <start_pass+0x402>
 801425e:	f640 720f 	movw	r2, #3855	@ 0xf0f
 8014262:	4293      	cmp	r3, r2
 8014264:	f000 814f 	beq.w	8014506 <start_pass+0x302>
 8014268:	f5b3 6f71 	cmp.w	r3, #3856	@ 0xf10
 801426c:	f280 81cb 	bge.w	8014606 <start_pass+0x402>
 8014270:	f640 620e 	movw	r2, #3598	@ 0xe0e
 8014274:	4293      	cmp	r3, r2
 8014276:	f000 8141 	beq.w	80144fc <start_pass+0x2f8>
 801427a:	f640 620e 	movw	r2, #3598	@ 0xe0e
 801427e:	4293      	cmp	r3, r2
 8014280:	f300 81c1 	bgt.w	8014606 <start_pass+0x402>
 8014284:	f640 6207 	movw	r2, #3591	@ 0xe07
 8014288:	4293      	cmp	r3, r2
 801428a:	f000 814b 	beq.w	8014524 <start_pass+0x320>
 801428e:	f640 6207 	movw	r2, #3591	@ 0xe07
 8014292:	4293      	cmp	r3, r2
 8014294:	f300 81b7 	bgt.w	8014606 <start_pass+0x402>
 8014298:	f640 520d 	movw	r2, #3341	@ 0xd0d
 801429c:	4293      	cmp	r3, r2
 801429e:	f000 8128 	beq.w	80144f2 <start_pass+0x2ee>
 80142a2:	f640 520d 	movw	r2, #3341	@ 0xd0d
 80142a6:	4293      	cmp	r3, r2
 80142a8:	f300 81ad 	bgt.w	8014606 <start_pass+0x402>
 80142ac:	f640 420c 	movw	r2, #3084	@ 0xc0c
 80142b0:	4293      	cmp	r3, r2
 80142b2:	f000 8119 	beq.w	80144e8 <start_pass+0x2e4>
 80142b6:	f640 420c 	movw	r2, #3084	@ 0xc0c
 80142ba:	4293      	cmp	r3, r2
 80142bc:	f300 81a3 	bgt.w	8014606 <start_pass+0x402>
 80142c0:	f640 4206 	movw	r2, #3078	@ 0xc06
 80142c4:	4293      	cmp	r3, r2
 80142c6:	f000 8132 	beq.w	801452e <start_pass+0x32a>
 80142ca:	f640 4206 	movw	r2, #3078	@ 0xc06
 80142ce:	4293      	cmp	r3, r2
 80142d0:	f300 8199 	bgt.w	8014606 <start_pass+0x402>
 80142d4:	f640 320b 	movw	r2, #2827	@ 0xb0b
 80142d8:	4293      	cmp	r3, r2
 80142da:	f000 8100 	beq.w	80144de <start_pass+0x2da>
 80142de:	f640 320b 	movw	r2, #2827	@ 0xb0b
 80142e2:	4293      	cmp	r3, r2
 80142e4:	f300 818f 	bgt.w	8014606 <start_pass+0x402>
 80142e8:	f640 220a 	movw	r2, #2570	@ 0xa0a
 80142ec:	4293      	cmp	r3, r2
 80142ee:	f000 80f1 	beq.w	80144d4 <start_pass+0x2d0>
 80142f2:	f640 220a 	movw	r2, #2570	@ 0xa0a
 80142f6:	4293      	cmp	r3, r2
 80142f8:	f300 8185 	bgt.w	8014606 <start_pass+0x402>
 80142fc:	f640 2205 	movw	r2, #2565	@ 0xa05
 8014300:	4293      	cmp	r3, r2
 8014302:	f000 8119 	beq.w	8014538 <start_pass+0x334>
 8014306:	f640 2205 	movw	r2, #2565	@ 0xa05
 801430a:	4293      	cmp	r3, r2
 801430c:	f300 817b 	bgt.w	8014606 <start_pass+0x402>
 8014310:	f640 1209 	movw	r2, #2313	@ 0x909
 8014314:	4293      	cmp	r3, r2
 8014316:	f000 80d8 	beq.w	80144ca <start_pass+0x2c6>
 801431a:	f640 1209 	movw	r2, #2313	@ 0x909
 801431e:	4293      	cmp	r3, r2
 8014320:	f300 8171 	bgt.w	8014606 <start_pass+0x402>
 8014324:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 8014328:	f000 811f 	beq.w	801456a <start_pass+0x366>
 801432c:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 8014330:	f300 8169 	bgt.w	8014606 <start_pass+0x402>
 8014334:	f640 0208 	movw	r2, #2056	@ 0x808
 8014338:	4293      	cmp	r3, r2
 801433a:	f000 813e 	beq.w	80145ba <start_pass+0x3b6>
 801433e:	f640 0208 	movw	r2, #2056	@ 0x808
 8014342:	4293      	cmp	r3, r2
 8014344:	f300 815f 	bgt.w	8014606 <start_pass+0x402>
 8014348:	f640 0204 	movw	r2, #2052	@ 0x804
 801434c:	4293      	cmp	r3, r2
 801434e:	f000 80f8 	beq.w	8014542 <start_pass+0x33e>
 8014352:	f640 0204 	movw	r2, #2052	@ 0x804
 8014356:	4293      	cmp	r3, r2
 8014358:	f300 8155 	bgt.w	8014606 <start_pass+0x402>
 801435c:	f240 720e 	movw	r2, #1806	@ 0x70e
 8014360:	4293      	cmp	r3, r2
 8014362:	f000 8107 	beq.w	8014574 <start_pass+0x370>
 8014366:	f240 720e 	movw	r2, #1806	@ 0x70e
 801436a:	4293      	cmp	r3, r2
 801436c:	f300 814b 	bgt.w	8014606 <start_pass+0x402>
 8014370:	f240 7207 	movw	r2, #1799	@ 0x707
 8014374:	4293      	cmp	r3, r2
 8014376:	f000 80a3 	beq.w	80144c0 <start_pass+0x2bc>
 801437a:	f5b3 6fe1 	cmp.w	r3, #1800	@ 0x708
 801437e:	f280 8142 	bge.w	8014606 <start_pass+0x402>
 8014382:	f240 620c 	movw	r2, #1548	@ 0x60c
 8014386:	4293      	cmp	r3, r2
 8014388:	f000 80f9 	beq.w	801457e <start_pass+0x37a>
 801438c:	f240 620c 	movw	r2, #1548	@ 0x60c
 8014390:	4293      	cmp	r3, r2
 8014392:	f300 8138 	bgt.w	8014606 <start_pass+0x402>
 8014396:	f240 6206 	movw	r2, #1542	@ 0x606
 801439a:	4293      	cmp	r3, r2
 801439c:	f000 808b 	beq.w	80144b6 <start_pass+0x2b2>
 80143a0:	f240 6206 	movw	r2, #1542	@ 0x606
 80143a4:	4293      	cmp	r3, r2
 80143a6:	f300 812e 	bgt.w	8014606 <start_pass+0x402>
 80143aa:	f240 6203 	movw	r2, #1539	@ 0x603
 80143ae:	4293      	cmp	r3, r2
 80143b0:	f000 80cc 	beq.w	801454c <start_pass+0x348>
 80143b4:	f240 6203 	movw	r2, #1539	@ 0x603
 80143b8:	4293      	cmp	r3, r2
 80143ba:	f300 8124 	bgt.w	8014606 <start_pass+0x402>
 80143be:	f240 520a 	movw	r2, #1290	@ 0x50a
 80143c2:	4293      	cmp	r3, r2
 80143c4:	f000 80e0 	beq.w	8014588 <start_pass+0x384>
 80143c8:	f240 520a 	movw	r2, #1290	@ 0x50a
 80143cc:	4293      	cmp	r3, r2
 80143ce:	f300 811a 	bgt.w	8014606 <start_pass+0x402>
 80143d2:	f240 5205 	movw	r2, #1285	@ 0x505
 80143d6:	4293      	cmp	r3, r2
 80143d8:	d068      	beq.n	80144ac <start_pass+0x2a8>
 80143da:	f240 5205 	movw	r2, #1285	@ 0x505
 80143de:	4293      	cmp	r3, r2
 80143e0:	f300 8111 	bgt.w	8014606 <start_pass+0x402>
 80143e4:	f5b3 6f81 	cmp.w	r3, #1032	@ 0x408
 80143e8:	f000 80d3 	beq.w	8014592 <start_pass+0x38e>
 80143ec:	f5b3 6f81 	cmp.w	r3, #1032	@ 0x408
 80143f0:	f300 8109 	bgt.w	8014606 <start_pass+0x402>
 80143f4:	f240 4204 	movw	r2, #1028	@ 0x404
 80143f8:	4293      	cmp	r3, r2
 80143fa:	d052      	beq.n	80144a2 <start_pass+0x29e>
 80143fc:	f240 4204 	movw	r2, #1028	@ 0x404
 8014400:	4293      	cmp	r3, r2
 8014402:	f300 8100 	bgt.w	8014606 <start_pass+0x402>
 8014406:	f240 4202 	movw	r2, #1026	@ 0x402
 801440a:	4293      	cmp	r3, r2
 801440c:	f000 80a3 	beq.w	8014556 <start_pass+0x352>
 8014410:	f240 4202 	movw	r2, #1026	@ 0x402
 8014414:	4293      	cmp	r3, r2
 8014416:	f300 80f6 	bgt.w	8014606 <start_pass+0x402>
 801441a:	f240 3206 	movw	r2, #774	@ 0x306
 801441e:	4293      	cmp	r3, r2
 8014420:	f000 80bc 	beq.w	801459c <start_pass+0x398>
 8014424:	f240 3206 	movw	r2, #774	@ 0x306
 8014428:	4293      	cmp	r3, r2
 801442a:	f300 80ec 	bgt.w	8014606 <start_pass+0x402>
 801442e:	f240 3203 	movw	r2, #771	@ 0x303
 8014432:	4293      	cmp	r3, r2
 8014434:	d030      	beq.n	8014498 <start_pass+0x294>
 8014436:	f5b3 7f41 	cmp.w	r3, #772	@ 0x304
 801443a:	f280 80e4 	bge.w	8014606 <start_pass+0x402>
 801443e:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 8014442:	f000 80b0 	beq.w	80145a6 <start_pass+0x3a2>
 8014446:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 801444a:	f300 80dc 	bgt.w	8014606 <start_pass+0x402>
 801444e:	f240 2202 	movw	r2, #514	@ 0x202
 8014452:	4293      	cmp	r3, r2
 8014454:	d01b      	beq.n	801448e <start_pass+0x28a>
 8014456:	f240 2202 	movw	r2, #514	@ 0x202
 801445a:	4293      	cmp	r3, r2
 801445c:	f300 80d3 	bgt.w	8014606 <start_pass+0x402>
 8014460:	f240 2201 	movw	r2, #513	@ 0x201
 8014464:	4293      	cmp	r3, r2
 8014466:	d07b      	beq.n	8014560 <start_pass+0x35c>
 8014468:	f240 2201 	movw	r2, #513	@ 0x201
 801446c:	4293      	cmp	r3, r2
 801446e:	f300 80ca 	bgt.w	8014606 <start_pass+0x402>
 8014472:	f240 1201 	movw	r2, #257	@ 0x101
 8014476:	4293      	cmp	r3, r2
 8014478:	d004      	beq.n	8014484 <start_pass+0x280>
 801447a:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801447e:	f000 8097 	beq.w	80145b0 <start_pass+0x3ac>
 8014482:	e0c0      	b.n	8014606 <start_pass+0x402>
#ifdef IDCT_SCALING_SUPPORTED
    case ((1 << 8) + 1):
      method_ptr = jpeg_idct_1x1;
 8014484:	4b8e      	ldr	r3, [pc, #568]	@ (80146c0 <start_pass+0x4bc>)
 8014486:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014488:	2300      	movs	r3, #0
 801448a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801448c:	e0cf      	b.n	801462e <start_pass+0x42a>
    case ((2 << 8) + 2):
      method_ptr = jpeg_idct_2x2;
 801448e:	4b8d      	ldr	r3, [pc, #564]	@ (80146c4 <start_pass+0x4c0>)
 8014490:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014492:	2300      	movs	r3, #0
 8014494:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014496:	e0ca      	b.n	801462e <start_pass+0x42a>
    case ((3 << 8) + 3):
      method_ptr = jpeg_idct_3x3;
 8014498:	4b8b      	ldr	r3, [pc, #556]	@ (80146c8 <start_pass+0x4c4>)
 801449a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801449c:	2300      	movs	r3, #0
 801449e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144a0:	e0c5      	b.n	801462e <start_pass+0x42a>
    case ((4 << 8) + 4):
      method_ptr = jpeg_idct_4x4;
 80144a2:	4b8a      	ldr	r3, [pc, #552]	@ (80146cc <start_pass+0x4c8>)
 80144a4:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144a6:	2300      	movs	r3, #0
 80144a8:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144aa:	e0c0      	b.n	801462e <start_pass+0x42a>
    case ((5 << 8) + 5):
      method_ptr = jpeg_idct_5x5;
 80144ac:	4b88      	ldr	r3, [pc, #544]	@ (80146d0 <start_pass+0x4cc>)
 80144ae:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144b0:	2300      	movs	r3, #0
 80144b2:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144b4:	e0bb      	b.n	801462e <start_pass+0x42a>
    case ((6 << 8) + 6):
      method_ptr = jpeg_idct_6x6;
 80144b6:	4b87      	ldr	r3, [pc, #540]	@ (80146d4 <start_pass+0x4d0>)
 80144b8:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144ba:	2300      	movs	r3, #0
 80144bc:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144be:	e0b6      	b.n	801462e <start_pass+0x42a>
    case ((7 << 8) + 7):
      method_ptr = jpeg_idct_7x7;
 80144c0:	4b85      	ldr	r3, [pc, #532]	@ (80146d8 <start_pass+0x4d4>)
 80144c2:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144c4:	2300      	movs	r3, #0
 80144c6:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144c8:	e0b1      	b.n	801462e <start_pass+0x42a>
    case ((9 << 8) + 9):
      method_ptr = jpeg_idct_9x9;
 80144ca:	4b84      	ldr	r3, [pc, #528]	@ (80146dc <start_pass+0x4d8>)
 80144cc:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144ce:	2300      	movs	r3, #0
 80144d0:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144d2:	e0ac      	b.n	801462e <start_pass+0x42a>
    case ((10 << 8) + 10):
      method_ptr = jpeg_idct_10x10;
 80144d4:	4b82      	ldr	r3, [pc, #520]	@ (80146e0 <start_pass+0x4dc>)
 80144d6:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144d8:	2300      	movs	r3, #0
 80144da:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144dc:	e0a7      	b.n	801462e <start_pass+0x42a>
    case ((11 << 8) + 11):
      method_ptr = jpeg_idct_11x11;
 80144de:	4b81      	ldr	r3, [pc, #516]	@ (80146e4 <start_pass+0x4e0>)
 80144e0:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144e2:	2300      	movs	r3, #0
 80144e4:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144e6:	e0a2      	b.n	801462e <start_pass+0x42a>
    case ((12 << 8) + 12):
      method_ptr = jpeg_idct_12x12;
 80144e8:	4b7f      	ldr	r3, [pc, #508]	@ (80146e8 <start_pass+0x4e4>)
 80144ea:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144ec:	2300      	movs	r3, #0
 80144ee:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144f0:	e09d      	b.n	801462e <start_pass+0x42a>
    case ((13 << 8) + 13):
      method_ptr = jpeg_idct_13x13;
 80144f2:	4b7e      	ldr	r3, [pc, #504]	@ (80146ec <start_pass+0x4e8>)
 80144f4:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80144f6:	2300      	movs	r3, #0
 80144f8:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80144fa:	e098      	b.n	801462e <start_pass+0x42a>
    case ((14 << 8) + 14):
      method_ptr = jpeg_idct_14x14;
 80144fc:	4b7c      	ldr	r3, [pc, #496]	@ (80146f0 <start_pass+0x4ec>)
 80144fe:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014500:	2300      	movs	r3, #0
 8014502:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014504:	e093      	b.n	801462e <start_pass+0x42a>
    case ((15 << 8) + 15):
      method_ptr = jpeg_idct_15x15;
 8014506:	4b7b      	ldr	r3, [pc, #492]	@ (80146f4 <start_pass+0x4f0>)
 8014508:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801450a:	2300      	movs	r3, #0
 801450c:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801450e:	e08e      	b.n	801462e <start_pass+0x42a>
    case ((16 << 8) + 16):
      method_ptr = jpeg_idct_16x16;
 8014510:	4b79      	ldr	r3, [pc, #484]	@ (80146f8 <start_pass+0x4f4>)
 8014512:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014514:	2300      	movs	r3, #0
 8014516:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014518:	e089      	b.n	801462e <start_pass+0x42a>
    case ((16 << 8) + 8):
      method_ptr = jpeg_idct_16x8;
 801451a:	4b78      	ldr	r3, [pc, #480]	@ (80146fc <start_pass+0x4f8>)
 801451c:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801451e:	2300      	movs	r3, #0
 8014520:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014522:	e084      	b.n	801462e <start_pass+0x42a>
    case ((14 << 8) + 7):
      method_ptr = jpeg_idct_14x7;
 8014524:	4b76      	ldr	r3, [pc, #472]	@ (8014700 <start_pass+0x4fc>)
 8014526:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014528:	2300      	movs	r3, #0
 801452a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801452c:	e07f      	b.n	801462e <start_pass+0x42a>
    case ((12 << 8) + 6):
      method_ptr = jpeg_idct_12x6;
 801452e:	4b75      	ldr	r3, [pc, #468]	@ (8014704 <start_pass+0x500>)
 8014530:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014532:	2300      	movs	r3, #0
 8014534:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014536:	e07a      	b.n	801462e <start_pass+0x42a>
    case ((10 << 8) + 5):
      method_ptr = jpeg_idct_10x5;
 8014538:	4b73      	ldr	r3, [pc, #460]	@ (8014708 <start_pass+0x504>)
 801453a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801453c:	2300      	movs	r3, #0
 801453e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014540:	e075      	b.n	801462e <start_pass+0x42a>
    case ((8 << 8) + 4):
      method_ptr = jpeg_idct_8x4;
 8014542:	4b72      	ldr	r3, [pc, #456]	@ (801470c <start_pass+0x508>)
 8014544:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014546:	2300      	movs	r3, #0
 8014548:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801454a:	e070      	b.n	801462e <start_pass+0x42a>
    case ((6 << 8) + 3):
      method_ptr = jpeg_idct_6x3;
 801454c:	4b70      	ldr	r3, [pc, #448]	@ (8014710 <start_pass+0x50c>)
 801454e:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014550:	2300      	movs	r3, #0
 8014552:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014554:	e06b      	b.n	801462e <start_pass+0x42a>
    case ((4 << 8) + 2):
      method_ptr = jpeg_idct_4x2;
 8014556:	4b6f      	ldr	r3, [pc, #444]	@ (8014714 <start_pass+0x510>)
 8014558:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801455a:	2300      	movs	r3, #0
 801455c:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801455e:	e066      	b.n	801462e <start_pass+0x42a>
    case ((2 << 8) + 1):
      method_ptr = jpeg_idct_2x1;
 8014560:	4b6d      	ldr	r3, [pc, #436]	@ (8014718 <start_pass+0x514>)
 8014562:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014564:	2300      	movs	r3, #0
 8014566:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014568:	e061      	b.n	801462e <start_pass+0x42a>
    case ((8 << 8) + 16):
      method_ptr = jpeg_idct_8x16;
 801456a:	4b6c      	ldr	r3, [pc, #432]	@ (801471c <start_pass+0x518>)
 801456c:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801456e:	2300      	movs	r3, #0
 8014570:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014572:	e05c      	b.n	801462e <start_pass+0x42a>
    case ((7 << 8) + 14):
      method_ptr = jpeg_idct_7x14;
 8014574:	4b6a      	ldr	r3, [pc, #424]	@ (8014720 <start_pass+0x51c>)
 8014576:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014578:	2300      	movs	r3, #0
 801457a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801457c:	e057      	b.n	801462e <start_pass+0x42a>
    case ((6 << 8) + 12):
      method_ptr = jpeg_idct_6x12;
 801457e:	4b69      	ldr	r3, [pc, #420]	@ (8014724 <start_pass+0x520>)
 8014580:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014582:	2300      	movs	r3, #0
 8014584:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014586:	e052      	b.n	801462e <start_pass+0x42a>
    case ((5 << 8) + 10):
      method_ptr = jpeg_idct_5x10;
 8014588:	4b67      	ldr	r3, [pc, #412]	@ (8014728 <start_pass+0x524>)
 801458a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801458c:	2300      	movs	r3, #0
 801458e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8014590:	e04d      	b.n	801462e <start_pass+0x42a>
    case ((4 << 8) + 8):
      method_ptr = jpeg_idct_4x8;
 8014592:	4b66      	ldr	r3, [pc, #408]	@ (801472c <start_pass+0x528>)
 8014594:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8014596:	2300      	movs	r3, #0
 8014598:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801459a:	e048      	b.n	801462e <start_pass+0x42a>
    case ((3 << 8) + 6):
      method_ptr = jpeg_idct_3x6;
 801459c:	4b64      	ldr	r3, [pc, #400]	@ (8014730 <start_pass+0x52c>)
 801459e:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80145a0:	2300      	movs	r3, #0
 80145a2:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80145a4:	e043      	b.n	801462e <start_pass+0x42a>
    case ((2 << 8) + 4):
      method_ptr = jpeg_idct_2x4;
 80145a6:	4b63      	ldr	r3, [pc, #396]	@ (8014734 <start_pass+0x530>)
 80145a8:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80145aa:	2300      	movs	r3, #0
 80145ac:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80145ae:	e03e      	b.n	801462e <start_pass+0x42a>
    case ((1 << 8) + 2):
      method_ptr = jpeg_idct_1x2;
 80145b0:	4b61      	ldr	r3, [pc, #388]	@ (8014738 <start_pass+0x534>)
 80145b2:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80145b4:	2300      	movs	r3, #0
 80145b6:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80145b8:	e039      	b.n	801462e <start_pass+0x42a>
#endif
    case ((DCTSIZE << 8) + DCTSIZE):
      switch (cinfo->dct_method) {
 80145ba:	687b      	ldr	r3, [r7, #4]
 80145bc:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 80145c0:	2b02      	cmp	r3, #2
 80145c2:	d010      	beq.n	80145e6 <start_pass+0x3e2>
 80145c4:	2b02      	cmp	r3, #2
 80145c6:	dc13      	bgt.n	80145f0 <start_pass+0x3ec>
 80145c8:	2b00      	cmp	r3, #0
 80145ca:	d002      	beq.n	80145d2 <start_pass+0x3ce>
 80145cc:	2b01      	cmp	r3, #1
 80145ce:	d005      	beq.n	80145dc <start_pass+0x3d8>
 80145d0:	e00e      	b.n	80145f0 <start_pass+0x3ec>
#ifdef DCT_ISLOW_SUPPORTED
      case JDCT_ISLOW:
	method_ptr = jpeg_idct_islow;
 80145d2:	4b5a      	ldr	r3, [pc, #360]	@ (801473c <start_pass+0x538>)
 80145d4:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_ISLOW;
 80145d6:	2300      	movs	r3, #0
 80145d8:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80145da:	e013      	b.n	8014604 <start_pass+0x400>
#endif
#ifdef DCT_IFAST_SUPPORTED
      case JDCT_IFAST:
	method_ptr = jpeg_idct_ifast;
 80145dc:	4b58      	ldr	r3, [pc, #352]	@ (8014740 <start_pass+0x53c>)
 80145de:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_IFAST;
 80145e0:	2301      	movs	r3, #1
 80145e2:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80145e4:	e00e      	b.n	8014604 <start_pass+0x400>
#endif
#ifdef DCT_FLOAT_SUPPORTED
      case JDCT_FLOAT:
	method_ptr = jpeg_idct_float;
 80145e6:	4b57      	ldr	r3, [pc, #348]	@ (8014744 <start_pass+0x540>)
 80145e8:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_FLOAT;
 80145ea:	2302      	movs	r3, #2
 80145ec:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80145ee:	e009      	b.n	8014604 <start_pass+0x400>
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
 80145f0:	687b      	ldr	r3, [r7, #4]
 80145f2:	681b      	ldr	r3, [r3, #0]
 80145f4:	2231      	movs	r2, #49	@ 0x31
 80145f6:	615a      	str	r2, [r3, #20]
 80145f8:	687b      	ldr	r3, [r7, #4]
 80145fa:	681b      	ldr	r3, [r3, #0]
 80145fc:	681b      	ldr	r3, [r3, #0]
 80145fe:	6878      	ldr	r0, [r7, #4]
 8014600:	4798      	blx	r3
	break;
 8014602:	bf00      	nop
      }
      break;
 8014604:	e013      	b.n	801462e <start_pass+0x42a>
    default:
      ERREXIT2(cinfo, JERR_BAD_DCTSIZE,
 8014606:	687b      	ldr	r3, [r7, #4]
 8014608:	681b      	ldr	r3, [r3, #0]
 801460a:	2207      	movs	r2, #7
 801460c:	615a      	str	r2, [r3, #20]
 801460e:	687b      	ldr	r3, [r7, #4]
 8014610:	681b      	ldr	r3, [r3, #0]
 8014612:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8014614:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8014616:	619a      	str	r2, [r3, #24]
 8014618:	687b      	ldr	r3, [r7, #4]
 801461a:	681b      	ldr	r3, [r3, #0]
 801461c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801461e:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8014620:	61da      	str	r2, [r3, #28]
 8014622:	687b      	ldr	r3, [r7, #4]
 8014624:	681b      	ldr	r3, [r3, #0]
 8014626:	681b      	ldr	r3, [r3, #0]
 8014628:	6878      	ldr	r0, [r7, #4]
 801462a:	4798      	blx	r3
	       compptr->DCT_h_scaled_size, compptr->DCT_v_scaled_size);
      break;
 801462c:	bf00      	nop
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
 801462e:	69ba      	ldr	r2, [r7, #24]
 8014630:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014632:	009b      	lsls	r3, r3, #2
 8014634:	4413      	add	r3, r2
 8014636:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8014638:	605a      	str	r2, [r3, #4]
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
 801463a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801463c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801463e:	2b00      	cmp	r3, #0
 8014640:	f000 80f8 	beq.w	8014834 <start_pass+0x630>
 8014644:	69ba      	ldr	r2, [r7, #24]
 8014646:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014648:	330a      	adds	r3, #10
 801464a:	009b      	lsls	r3, r3, #2
 801464c:	4413      	add	r3, r2
 801464e:	685b      	ldr	r3, [r3, #4]
 8014650:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014652:	429a      	cmp	r2, r3
 8014654:	f000 80ee 	beq.w	8014834 <start_pass+0x630>
      continue;
    qtbl = compptr->quant_table;
 8014658:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801465a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801465c:	617b      	str	r3, [r7, #20]
    if (qtbl == NULL)		/* happens if no data yet for component */
 801465e:	697b      	ldr	r3, [r7, #20]
 8014660:	2b00      	cmp	r3, #0
 8014662:	f000 80e9 	beq.w	8014838 <start_pass+0x634>
      continue;
    idct->cur_method[ci] = method;
 8014666:	69ba      	ldr	r2, [r7, #24]
 8014668:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801466a:	330a      	adds	r3, #10
 801466c:	009b      	lsls	r3, r3, #2
 801466e:	4413      	add	r3, r2
 8014670:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014672:	605a      	str	r2, [r3, #4]
    switch (method) {
 8014674:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014676:	2b02      	cmp	r3, #2
 8014678:	f000 8086 	beq.w	8014788 <start_pass+0x584>
 801467c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801467e:	2b02      	cmp	r3, #2
 8014680:	f300 80ce 	bgt.w	8014820 <start_pass+0x61c>
 8014684:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014686:	2b00      	cmp	r3, #0
 8014688:	d003      	beq.n	8014692 <start_pass+0x48e>
 801468a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801468c:	2b01      	cmp	r3, #1
 801468e:	d05b      	beq.n	8014748 <start_pass+0x544>
 8014690:	e0c6      	b.n	8014820 <start_pass+0x61c>
    case JDCT_ISLOW:
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8014692:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014694:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8014696:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < DCTSIZE2; i++) {
 8014698:	2300      	movs	r3, #0
 801469a:	633b      	str	r3, [r7, #48]	@ 0x30
 801469c:	e00c      	b.n	80146b8 <start_pass+0x4b4>
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
 801469e:	697b      	ldr	r3, [r7, #20]
 80146a0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80146a2:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 80146a6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146a8:	009b      	lsls	r3, r3, #2
 80146aa:	68ba      	ldr	r2, [r7, #8]
 80146ac:	4413      	add	r3, r2
 80146ae:	460a      	mov	r2, r1
 80146b0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 80146b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146b4:	3301      	adds	r3, #1
 80146b6:	633b      	str	r3, [r7, #48]	@ 0x30
 80146b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146ba:	2b3f      	cmp	r3, #63	@ 0x3f
 80146bc:	ddef      	ble.n	801469e <start_pass+0x49a>
	}
      }
      break;
 80146be:	e0bc      	b.n	801483a <start_pass+0x636>
 80146c0:	0801f15b 	.word	0x0801f15b
 80146c4:	0801f045 	.word	0x0801f045
 80146c8:	0801ee95 	.word	0x0801ee95
 80146cc:	0801ec59 	.word	0x0801ec59
 80146d0:	0801e88d 	.word	0x0801e88d
 80146d4:	0801e425 	.word	0x0801e425
 80146d8:	0801dd99 	.word	0x0801dd99
 80146dc:	0801f1b5 	.word	0x0801f1b5
 80146e0:	0801f8e5 	.word	0x0801f8e5
 80146e4:	080200e1 	.word	0x080200e1
 80146e8:	08020a91 	.word	0x08020a91
 80146ec:	080213d1 	.word	0x080213d1
 80146f0:	08021ef5 	.word	0x08021ef5
 80146f4:	08022995 	.word	0x08022995
 80146f8:	080234c1 	.word	0x080234c1
 80146fc:	080241c5 	.word	0x080241c5
 8014700:	08024d35 	.word	0x08024d35
 8014704:	080255e5 	.word	0x080255e5
 8014708:	08025ce9 	.word	0x08025ce9
 801470c:	080262d5 	.word	0x080262d5
 8014710:	080267e5 	.word	0x080267e5
 8014714:	08026aad 	.word	0x08026aad
 8014718:	08026c31 	.word	0x08026c31
 801471c:	08026cc1 	.word	0x08026cc1
 8014720:	080276d9 	.word	0x080276d9
 8014724:	08027f51 	.word	0x08027f51
 8014728:	08028631 	.word	0x08028631
 801472c:	08028c3d 	.word	0x08028c3d
 8014730:	08029269 	.word	0x08029269
 8014734:	08029539 	.word	0x08029539
 8014738:	080296c9 	.word	0x080296c9
 801473c:	0801d439 	.word	0x0801d439
 8014740:	0801cc29 	.word	0x0801cc29
 8014744:	0801c3c9 	.word	0x0801c3c9
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * For integer operation, the multiplier table is to be scaled by
	 * IFAST_SCALE_BITS.
	 */
	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
 8014748:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801474a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801474c:	60fb      	str	r3, [r7, #12]
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
 801474e:	2300      	movs	r3, #0
 8014750:	633b      	str	r3, [r7, #48]	@ 0x30
 8014752:	e015      	b.n	8014780 <start_pass+0x57c>
	  ifmtbl[i] = (IFAST_MULT_TYPE)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 8014754:	697b      	ldr	r3, [r7, #20]
 8014756:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014758:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 801475c:	4619      	mov	r1, r3
 801475e:	4a3f      	ldr	r2, [pc, #252]	@ (801485c <start_pass+0x658>)
 8014760:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014762:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 8014766:	fb01 f303 	mul.w	r3, r1, r3
 801476a:	f503 6200 	add.w	r2, r3, #2048	@ 0x800
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 801476e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014770:	009b      	lsls	r3, r3, #2
 8014772:	68f9      	ldr	r1, [r7, #12]
 8014774:	440b      	add	r3, r1
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 8014776:	1312      	asrs	r2, r2, #12
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 8014778:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 801477a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801477c:	3301      	adds	r3, #1
 801477e:	633b      	str	r3, [r7, #48]	@ 0x30
 8014780:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014782:	2b3f      	cmp	r3, #63	@ 0x3f
 8014784:	dde6      	ble.n	8014754 <start_pass+0x550>
				  (INT32) aanscales[i]),
		    CONST_BITS-IFAST_SCALE_BITS);
	}
      }
      break;
 8014786:	e058      	b.n	801483a <start_pass+0x636>
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 1/8.
	 */
	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
 8014788:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801478a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801478c:	613b      	str	r3, [r7, #16]
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	i = 0;
 801478e:	2300      	movs	r3, #0
 8014790:	633b      	str	r3, [r7, #48]	@ 0x30
	for (row = 0; row < DCTSIZE; row++) {
 8014792:	2300      	movs	r3, #0
 8014794:	623b      	str	r3, [r7, #32]
 8014796:	e03f      	b.n	8014818 <start_pass+0x614>
	  for (col = 0; col < DCTSIZE; col++) {
 8014798:	2300      	movs	r3, #0
 801479a:	61fb      	str	r3, [r7, #28]
 801479c:	e036      	b.n	801480c <start_pass+0x608>
	    fmtbl[i] = (FLOAT_MULT_TYPE)
	      ((double) qtbl->quantval[i] *
 801479e:	697b      	ldr	r3, [r7, #20]
 80147a0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80147a2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80147a6:	4618      	mov	r0, r3
 80147a8:	f7eb fea4 	bl	80004f4 <__aeabi_ui2d>
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 80147ac:	4a2c      	ldr	r2, [pc, #176]	@ (8014860 <start_pass+0x65c>)
 80147ae:	6a3b      	ldr	r3, [r7, #32]
 80147b0:	00db      	lsls	r3, r3, #3
 80147b2:	4413      	add	r3, r2
 80147b4:	e9d3 2300 	ldrd	r2, r3, [r3]
	      ((double) qtbl->quantval[i] *
 80147b8:	f7eb ff16 	bl	80005e8 <__aeabi_dmul>
 80147bc:	4602      	mov	r2, r0
 80147be:	460b      	mov	r3, r1
 80147c0:	4610      	mov	r0, r2
 80147c2:	4619      	mov	r1, r3
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 80147c4:	4a26      	ldr	r2, [pc, #152]	@ (8014860 <start_pass+0x65c>)
 80147c6:	69fb      	ldr	r3, [r7, #28]
 80147c8:	00db      	lsls	r3, r3, #3
 80147ca:	4413      	add	r3, r2
 80147cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80147d0:	f7eb ff0a 	bl	80005e8 <__aeabi_dmul>
 80147d4:	4602      	mov	r2, r0
 80147d6:	460b      	mov	r3, r1
 80147d8:	4610      	mov	r0, r2
 80147da:	4619      	mov	r1, r3
 80147dc:	f04f 0200 	mov.w	r2, #0
 80147e0:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 80147e4:	f7eb ff00 	bl	80005e8 <__aeabi_dmul>
 80147e8:	4602      	mov	r2, r0
 80147ea:	460b      	mov	r3, r1
 80147ec:	4610      	mov	r0, r2
 80147ee:	4619      	mov	r1, r3
	    fmtbl[i] = (FLOAT_MULT_TYPE)
 80147f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80147f2:	009b      	lsls	r3, r3, #2
 80147f4:	693a      	ldr	r2, [r7, #16]
 80147f6:	18d4      	adds	r4, r2, r3
 80147f8:	f7ec f908 	bl	8000a0c <__aeabi_d2f>
 80147fc:	4603      	mov	r3, r0
 80147fe:	6023      	str	r3, [r4, #0]
	    i++;
 8014800:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014802:	3301      	adds	r3, #1
 8014804:	633b      	str	r3, [r7, #48]	@ 0x30
	  for (col = 0; col < DCTSIZE; col++) {
 8014806:	69fb      	ldr	r3, [r7, #28]
 8014808:	3301      	adds	r3, #1
 801480a:	61fb      	str	r3, [r7, #28]
 801480c:	69fb      	ldr	r3, [r7, #28]
 801480e:	2b07      	cmp	r3, #7
 8014810:	ddc5      	ble.n	801479e <start_pass+0x59a>
	for (row = 0; row < DCTSIZE; row++) {
 8014812:	6a3b      	ldr	r3, [r7, #32]
 8014814:	3301      	adds	r3, #1
 8014816:	623b      	str	r3, [r7, #32]
 8014818:	6a3b      	ldr	r3, [r7, #32]
 801481a:	2b07      	cmp	r3, #7
 801481c:	ddbc      	ble.n	8014798 <start_pass+0x594>
	  }
	}
      }
      break;
 801481e:	e00c      	b.n	801483a <start_pass+0x636>
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
 8014820:	687b      	ldr	r3, [r7, #4]
 8014822:	681b      	ldr	r3, [r3, #0]
 8014824:	2231      	movs	r2, #49	@ 0x31
 8014826:	615a      	str	r2, [r3, #20]
 8014828:	687b      	ldr	r3, [r7, #4]
 801482a:	681b      	ldr	r3, [r3, #0]
 801482c:	681b      	ldr	r3, [r3, #0]
 801482e:	6878      	ldr	r0, [r7, #4]
 8014830:	4798      	blx	r3
      break;
 8014832:	e002      	b.n	801483a <start_pass+0x636>
      continue;
 8014834:	bf00      	nop
 8014836:	e000      	b.n	801483a <start_pass+0x636>
      continue;
 8014838:	bf00      	nop
       ci++, compptr++) {
 801483a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801483c:	3301      	adds	r3, #1
 801483e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014840:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014842:	3358      	adds	r3, #88	@ 0x58
 8014844:	62fb      	str	r3, [r7, #44]	@ 0x2c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8014846:	687b      	ldr	r3, [r7, #4]
 8014848:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801484a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801484c:	429a      	cmp	r2, r3
 801484e:	f6ff acec 	blt.w	801422a <start_pass+0x26>
    }
  }
}
 8014852:	bf00      	nop
 8014854:	bf00      	nop
 8014856:	373c      	adds	r7, #60	@ 0x3c
 8014858:	46bd      	mov	sp, r7
 801485a:	bd90      	pop	{r4, r7, pc}
 801485c:	08030164 	.word	0x08030164
 8014860:	080301e8 	.word	0x080301e8

08014864 <jinit_inverse_dct>:
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
 8014864:	b580      	push	{r7, lr}
 8014866:	b086      	sub	sp, #24
 8014868:	af00      	add	r7, sp, #0
 801486a:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801486c:	687b      	ldr	r3, [r7, #4]
 801486e:	685b      	ldr	r3, [r3, #4]
 8014870:	681b      	ldr	r3, [r3, #0]
 8014872:	2254      	movs	r2, #84	@ 0x54
 8014874:	2101      	movs	r1, #1
 8014876:	6878      	ldr	r0, [r7, #4]
 8014878:	4798      	blx	r3
 801487a:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
 801487c:	687b      	ldr	r3, [r7, #4]
 801487e:	68fa      	ldr	r2, [r7, #12]
 8014880:	f8c3 21d4 	str.w	r2, [r3, #468]	@ 0x1d4
  idct->pub.start_pass = start_pass;
 8014884:	68fb      	ldr	r3, [r7, #12]
 8014886:	4a1a      	ldr	r2, [pc, #104]	@ (80148f0 <jinit_inverse_dct+0x8c>)
 8014888:	601a      	str	r2, [r3, #0]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801488a:	2300      	movs	r3, #0
 801488c:	617b      	str	r3, [r7, #20]
 801488e:	687b      	ldr	r3, [r7, #4]
 8014890:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8014894:	613b      	str	r3, [r7, #16]
 8014896:	e020      	b.n	80148da <jinit_inverse_dct+0x76>
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8014898:	687b      	ldr	r3, [r7, #4]
 801489a:	685b      	ldr	r3, [r3, #4]
 801489c:	681b      	ldr	r3, [r3, #0]
 801489e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80148a2:	2101      	movs	r1, #1
 80148a4:	6878      	ldr	r0, [r7, #4]
 80148a6:	4798      	blx	r3
 80148a8:	4602      	mov	r2, r0
    compptr->dct_table =
 80148aa:	693b      	ldr	r3, [r7, #16]
 80148ac:	655a      	str	r2, [r3, #84]	@ 0x54
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
 80148ae:	693b      	ldr	r3, [r7, #16]
 80148b0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80148b2:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80148b6:	2100      	movs	r1, #0
 80148b8:	4618      	mov	r0, r3
 80148ba:	f018 ff9a 	bl	802d7f2 <memset>
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
 80148be:	68fa      	ldr	r2, [r7, #12]
 80148c0:	697b      	ldr	r3, [r7, #20]
 80148c2:	330a      	adds	r3, #10
 80148c4:	009b      	lsls	r3, r3, #2
 80148c6:	4413      	add	r3, r2
 80148c8:	f04f 32ff 	mov.w	r2, #4294967295
 80148cc:	605a      	str	r2, [r3, #4]
       ci++, compptr++) {
 80148ce:	697b      	ldr	r3, [r7, #20]
 80148d0:	3301      	adds	r3, #1
 80148d2:	617b      	str	r3, [r7, #20]
 80148d4:	693b      	ldr	r3, [r7, #16]
 80148d6:	3358      	adds	r3, #88	@ 0x58
 80148d8:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80148da:	687b      	ldr	r3, [r7, #4]
 80148dc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80148de:	697a      	ldr	r2, [r7, #20]
 80148e0:	429a      	cmp	r2, r3
 80148e2:	dbd9      	blt.n	8014898 <jinit_inverse_dct+0x34>
  }
}
 80148e4:	bf00      	nop
 80148e6:	bf00      	nop
 80148e8:	3718      	adds	r7, #24
 80148ea:	46bd      	mov	sp, r7
 80148ec:	bd80      	pop	{r7, pc}
 80148ee:	bf00      	nop
 80148f0:	08014205 	.word	0x08014205

080148f4 <jpeg_make_d_derived_tbl>:
 */

LOCAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
			 d_derived_tbl ** pdtbl)
{
 80148f4:	b590      	push	{r4, r7, lr}
 80148f6:	f2ad 5d4c 	subw	sp, sp, #1356	@ 0x54c
 80148fa:	af00      	add	r7, sp, #0
 80148fc:	f507 64a9 	add.w	r4, r7, #1352	@ 0x548
 8014900:	f2a4 543c 	subw	r4, r4, #1340	@ 0x53c
 8014904:	6020      	str	r0, [r4, #0]
 8014906:	f507 60a9 	add.w	r0, r7, #1352	@ 0x548
 801490a:	f5a0 60a8 	sub.w	r0, r0, #1344	@ 0x540
 801490e:	6001      	str	r1, [r0, #0]
 8014910:	f507 61a9 	add.w	r1, r7, #1352	@ 0x548
 8014914:	f2a1 5144 	subw	r1, r1, #1348	@ 0x544
 8014918:	600a      	str	r2, [r1, #0]
 801491a:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 801491e:	f5a2 62a9 	sub.w	r2, r2, #1352	@ 0x548
 8014922:	6013      	str	r3, [r2, #0]
  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
 8014924:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014928:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 801492c:	681b      	ldr	r3, [r3, #0]
 801492e:	2b00      	cmp	r3, #0
 8014930:	db06      	blt.n	8014940 <jpeg_make_d_derived_tbl+0x4c>
 8014932:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014936:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 801493a:	681b      	ldr	r3, [r3, #0]
 801493c:	2b03      	cmp	r3, #3
 801493e:	dd20      	ble.n	8014982 <jpeg_make_d_derived_tbl+0x8e>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 8014940:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014944:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014948:	681b      	ldr	r3, [r3, #0]
 801494a:	681b      	ldr	r3, [r3, #0]
 801494c:	2234      	movs	r2, #52	@ 0x34
 801494e:	615a      	str	r2, [r3, #20]
 8014950:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014954:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014958:	681b      	ldr	r3, [r3, #0]
 801495a:	681b      	ldr	r3, [r3, #0]
 801495c:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014960:	f2a2 5244 	subw	r2, r2, #1348	@ 0x544
 8014964:	6812      	ldr	r2, [r2, #0]
 8014966:	619a      	str	r2, [r3, #24]
 8014968:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 801496c:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014970:	681b      	ldr	r3, [r3, #0]
 8014972:	681b      	ldr	r3, [r3, #0]
 8014974:	681b      	ldr	r3, [r3, #0]
 8014976:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 801497a:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 801497e:	6810      	ldr	r0, [r2, #0]
 8014980:	4798      	blx	r3
  htbl =
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
 8014982:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014986:	f5a3 63a8 	sub.w	r3, r3, #1344	@ 0x540
 801498a:	681b      	ldr	r3, [r3, #0]
 801498c:	2b00      	cmp	r3, #0
 801498e:	d00e      	beq.n	80149ae <jpeg_make_d_derived_tbl+0xba>
 8014990:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014994:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014998:	681a      	ldr	r2, [r3, #0]
 801499a:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 801499e:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 80149a2:	681b      	ldr	r3, [r3, #0]
 80149a4:	332c      	adds	r3, #44	@ 0x2c
 80149a6:	009b      	lsls	r3, r3, #2
 80149a8:	4413      	add	r3, r2
 80149aa:	685b      	ldr	r3, [r3, #4]
 80149ac:	e00d      	b.n	80149ca <jpeg_make_d_derived_tbl+0xd6>
 80149ae:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 80149b2:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 80149b6:	681a      	ldr	r2, [r3, #0]
 80149b8:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 80149bc:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 80149c0:	681b      	ldr	r3, [r3, #0]
 80149c2:	3330      	adds	r3, #48	@ 0x30
 80149c4:	009b      	lsls	r3, r3, #2
 80149c6:	4413      	add	r3, r2
 80149c8:	685b      	ldr	r3, [r3, #4]
  htbl =
 80149ca:	f8c7 3528 	str.w	r3, [r7, #1320]	@ 0x528
  if (htbl == NULL)
 80149ce:	f8d7 3528 	ldr.w	r3, [r7, #1320]	@ 0x528
 80149d2:	2b00      	cmp	r3, #0
 80149d4:	d120      	bne.n	8014a18 <jpeg_make_d_derived_tbl+0x124>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 80149d6:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 80149da:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 80149de:	681b      	ldr	r3, [r3, #0]
 80149e0:	681b      	ldr	r3, [r3, #0]
 80149e2:	2234      	movs	r2, #52	@ 0x34
 80149e4:	615a      	str	r2, [r3, #20]
 80149e6:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 80149ea:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 80149ee:	681b      	ldr	r3, [r3, #0]
 80149f0:	681b      	ldr	r3, [r3, #0]
 80149f2:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 80149f6:	f2a2 5244 	subw	r2, r2, #1348	@ 0x544
 80149fa:	6812      	ldr	r2, [r2, #0]
 80149fc:	619a      	str	r2, [r3, #24]
 80149fe:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014a02:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014a06:	681b      	ldr	r3, [r3, #0]
 8014a08:	681b      	ldr	r3, [r3, #0]
 8014a0a:	681b      	ldr	r3, [r3, #0]
 8014a0c:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014a10:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8014a14:	6810      	ldr	r0, [r2, #0]
 8014a16:	4798      	blx	r3

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
 8014a18:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014a1c:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8014a20:	681b      	ldr	r3, [r3, #0]
 8014a22:	681b      	ldr	r3, [r3, #0]
 8014a24:	2b00      	cmp	r3, #0
 8014a26:	d116      	bne.n	8014a56 <jpeg_make_d_derived_tbl+0x162>
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8014a28:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014a2c:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014a30:	681b      	ldr	r3, [r3, #0]
 8014a32:	685b      	ldr	r3, [r3, #4]
 8014a34:	681b      	ldr	r3, [r3, #0]
 8014a36:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014a3a:	f2a2 503c 	subw	r0, r2, #1340	@ 0x53c
 8014a3e:	f44f 62b2 	mov.w	r2, #1424	@ 0x590
 8014a42:	2101      	movs	r1, #1
 8014a44:	6800      	ldr	r0, [r0, #0]
 8014a46:	4798      	blx	r3
 8014a48:	4602      	mov	r2, r0
    *pdtbl = (d_derived_tbl *)
 8014a4a:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014a4e:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8014a52:	681b      	ldr	r3, [r3, #0]
 8014a54:	601a      	str	r2, [r3, #0]
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
 8014a56:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014a5a:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8014a5e:	681b      	ldr	r3, [r3, #0]
 8014a60:	681b      	ldr	r3, [r3, #0]
 8014a62:	f8c7 3524 	str.w	r3, [r7, #1316]	@ 0x524
  dtbl->pub = htbl;		/* fill in back link */
 8014a66:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014a6a:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014a6e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  
  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
 8014a72:	2300      	movs	r3, #0
 8014a74:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= 16; l++) {
 8014a78:	2301      	movs	r3, #1
 8014a7a:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014a7e:	e042      	b.n	8014b06 <jpeg_make_d_derived_tbl+0x212>
    i = (int) htbl->bits[l];
 8014a80:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014a84:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014a88:	4413      	add	r3, r2
 8014a8a:	781b      	ldrb	r3, [r3, #0]
 8014a8c:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
    if (i < 0 || p + i > 256)	/* protect against table overrun */
 8014a90:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014a94:	2b00      	cmp	r3, #0
 8014a96:	db07      	blt.n	8014aa8 <jpeg_make_d_derived_tbl+0x1b4>
 8014a98:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 8014a9c:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014aa0:	4413      	add	r3, r2
 8014aa2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8014aa6:	dd22      	ble.n	8014aee <jpeg_make_d_derived_tbl+0x1fa>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8014aa8:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014aac:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014ab0:	681b      	ldr	r3, [r3, #0]
 8014ab2:	681b      	ldr	r3, [r3, #0]
 8014ab4:	2209      	movs	r2, #9
 8014ab6:	615a      	str	r2, [r3, #20]
 8014ab8:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014abc:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014ac0:	681b      	ldr	r3, [r3, #0]
 8014ac2:	681b      	ldr	r3, [r3, #0]
 8014ac4:	681b      	ldr	r3, [r3, #0]
 8014ac6:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014aca:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8014ace:	6810      	ldr	r0, [r2, #0]
 8014ad0:	4798      	blx	r3
    while (i--)
 8014ad2:	e00c      	b.n	8014aee <jpeg_make_d_derived_tbl+0x1fa>
      huffsize[p++] = (char) l;
 8014ad4:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014ad8:	1c5a      	adds	r2, r3, #1
 8014ada:	f8c7 2544 	str.w	r2, [r7, #1348]	@ 0x544
 8014ade:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8014ae2:	b2d1      	uxtb	r1, r2
 8014ae4:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014ae8:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 8014aec:	54d1      	strb	r1, [r2, r3]
    while (i--)
 8014aee:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014af2:	1e5a      	subs	r2, r3, #1
 8014af4:	f8c7 2540 	str.w	r2, [r7, #1344]	@ 0x540
 8014af8:	2b00      	cmp	r3, #0
 8014afa:	d1eb      	bne.n	8014ad4 <jpeg_make_d_derived_tbl+0x1e0>
  for (l = 1; l <= 16; l++) {
 8014afc:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014b00:	3301      	adds	r3, #1
 8014b02:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014b06:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014b0a:	2b10      	cmp	r3, #16
 8014b0c:	ddb8      	ble.n	8014a80 <jpeg_make_d_derived_tbl+0x18c>
  }
  huffsize[p] = 0;
 8014b0e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014b12:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8014b16:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014b1a:	4413      	add	r3, r2
 8014b1c:	2200      	movs	r2, #0
 8014b1e:	701a      	strb	r2, [r3, #0]
  numsymbols = p;
 8014b20:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014b24:	f8c7 3520 	str.w	r3, [r7, #1312]	@ 0x520
  
  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */
  
  code = 0;
 8014b28:	2300      	movs	r3, #0
 8014b2a:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
  si = huffsize[0];
 8014b2e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014b32:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
 8014b36:	781b      	ldrb	r3, [r3, #0]
 8014b38:	f8c7 3538 	str.w	r3, [r7, #1336]	@ 0x538
  p = 0;
 8014b3c:	2300      	movs	r3, #0
 8014b3e:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  while (huffsize[p]) {
 8014b42:	e045      	b.n	8014bd0 <jpeg_make_d_derived_tbl+0x2dc>
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
 8014b44:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014b48:	1c5a      	adds	r2, r3, #1
 8014b4a:	f8c7 2544 	str.w	r2, [r7, #1348]	@ 0x544
 8014b4e:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014b52:	f2a2 5234 	subw	r2, r2, #1332	@ 0x534
 8014b56:	f8d7 152c 	ldr.w	r1, [r7, #1324]	@ 0x52c
 8014b5a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      code++;
 8014b5e:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8014b62:	3301      	adds	r3, #1
 8014b64:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
    while (((int) huffsize[p]) == si) {
 8014b68:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014b6c:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8014b70:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014b74:	4413      	add	r3, r2
 8014b76:	781b      	ldrb	r3, [r3, #0]
 8014b78:	461a      	mov	r2, r3
 8014b7a:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8014b7e:	4293      	cmp	r3, r2
 8014b80:	d0e0      	beq.n	8014b44 <jpeg_make_d_derived_tbl+0x250>
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
 8014b82:	2201      	movs	r2, #1
 8014b84:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8014b88:	409a      	lsls	r2, r3
 8014b8a:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8014b8e:	429a      	cmp	r2, r3
 8014b90:	dc14      	bgt.n	8014bbc <jpeg_make_d_derived_tbl+0x2c8>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8014b92:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014b96:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014b9a:	681b      	ldr	r3, [r3, #0]
 8014b9c:	681b      	ldr	r3, [r3, #0]
 8014b9e:	2209      	movs	r2, #9
 8014ba0:	615a      	str	r2, [r3, #20]
 8014ba2:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014ba6:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014baa:	681b      	ldr	r3, [r3, #0]
 8014bac:	681b      	ldr	r3, [r3, #0]
 8014bae:	681b      	ldr	r3, [r3, #0]
 8014bb0:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014bb4:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8014bb8:	6810      	ldr	r0, [r2, #0]
 8014bba:	4798      	blx	r3
    code <<= 1;
 8014bbc:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8014bc0:	005b      	lsls	r3, r3, #1
 8014bc2:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
    si++;
 8014bc6:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8014bca:	3301      	adds	r3, #1
 8014bcc:	f8c7 3538 	str.w	r3, [r7, #1336]	@ 0x538
  while (huffsize[p]) {
 8014bd0:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014bd4:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8014bd8:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014bdc:	4413      	add	r3, r2
 8014bde:	781b      	ldrb	r3, [r3, #0]
 8014be0:	2b00      	cmp	r3, #0
 8014be2:	d1c1      	bne.n	8014b68 <jpeg_make_d_derived_tbl+0x274>
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
 8014be4:	2300      	movs	r3, #0
 8014be6:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= 16; l++) {
 8014bea:	2301      	movs	r3, #1
 8014bec:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014bf0:	e044      	b.n	8014c7c <jpeg_make_d_derived_tbl+0x388>
    if (htbl->bits[l]) {
 8014bf2:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014bf6:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014bfa:	4413      	add	r3, r2
 8014bfc:	781b      	ldrb	r3, [r3, #0]
 8014bfe:	2b00      	cmp	r3, #0
 8014c00:	d02f      	beq.n	8014c62 <jpeg_make_d_derived_tbl+0x36e>
      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
       * minus the minimum code of length l
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
 8014c02:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014c06:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 8014c0a:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 8014c0e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014c12:	461a      	mov	r2, r3
 8014c14:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014c18:	1a99      	subs	r1, r3, r2
 8014c1a:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014c1e:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8014c22:	3212      	adds	r2, #18
 8014c24:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      p += htbl->bits[l];
 8014c28:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014c2c:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014c30:	4413      	add	r3, r2
 8014c32:	781b      	ldrb	r3, [r3, #0]
 8014c34:	461a      	mov	r2, r3
 8014c36:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014c3a:	4413      	add	r3, r2
 8014c3c:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
 8014c40:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014c44:	1e5a      	subs	r2, r3, #1
 8014c46:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014c4a:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 8014c4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014c52:	4619      	mov	r1, r3
 8014c54:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014c58:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8014c5c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8014c60:	e007      	b.n	8014c72 <jpeg_make_d_derived_tbl+0x37e>
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
 8014c62:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014c66:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8014c6a:	f04f 31ff 	mov.w	r1, #4294967295
 8014c6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (l = 1; l <= 16; l++) {
 8014c72:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014c76:	3301      	adds	r3, #1
 8014c78:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014c7c:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014c80:	2b10      	cmp	r3, #16
 8014c82:	ddb6      	ble.n	8014bf2 <jpeg_make_d_derived_tbl+0x2fe>
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
 8014c84:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014c88:	4a5a      	ldr	r2, [pc, #360]	@ (8014df4 <jpeg_make_d_derived_tbl+0x500>)
 8014c8a:	645a      	str	r2, [r3, #68]	@ 0x44
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
 8014c8c:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014c90:	3390      	adds	r3, #144	@ 0x90
 8014c92:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8014c96:	2100      	movs	r1, #0
 8014c98:	4618      	mov	r0, r3
 8014c9a:	f018 fdaa 	bl	802d7f2 <memset>

  p = 0;
 8014c9e:	2300      	movs	r3, #0
 8014ca0:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 8014ca4:	2301      	movs	r3, #1
 8014ca6:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014caa:	e05e      	b.n	8014d6a <jpeg_make_d_derived_tbl+0x476>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 8014cac:	2301      	movs	r3, #1
 8014cae:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 8014cb2:	e04a      	b.n	8014d4a <jpeg_make_d_derived_tbl+0x456>
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
 8014cb4:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014cb8:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 8014cbc:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 8014cc0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8014cc4:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014cc8:	f1c3 0308 	rsb	r3, r3, #8
 8014ccc:	fa02 f303 	lsl.w	r3, r2, r3
 8014cd0:	f8c7 3534 	str.w	r3, [r7, #1332]	@ 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 8014cd4:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014cd8:	f1c3 0308 	rsb	r3, r3, #8
 8014cdc:	2201      	movs	r2, #1
 8014cde:	fa02 f303 	lsl.w	r3, r2, r3
 8014ce2:	f8c7 3530 	str.w	r3, [r7, #1328]	@ 0x530
 8014ce6:	e022      	b.n	8014d2e <jpeg_make_d_derived_tbl+0x43a>
	dtbl->look_nbits[lookbits] = l;
 8014ce8:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8014cec:	f8d7 2534 	ldr.w	r2, [r7, #1332]	@ 0x534
 8014cf0:	3224      	adds	r2, #36	@ 0x24
 8014cf2:	f8d7 153c 	ldr.w	r1, [r7, #1340]	@ 0x53c
 8014cf6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	dtbl->look_sym[lookbits] = htbl->huffval[p];
 8014cfa:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014cfe:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014d02:	4413      	add	r3, r2
 8014d04:	3311      	adds	r3, #17
 8014d06:	7819      	ldrb	r1, [r3, #0]
 8014d08:	f8d7 2524 	ldr.w	r2, [r7, #1316]	@ 0x524
 8014d0c:	f8d7 3534 	ldr.w	r3, [r7, #1332]	@ 0x534
 8014d10:	4413      	add	r3, r2
 8014d12:	f503 6392 	add.w	r3, r3, #1168	@ 0x490
 8014d16:	460a      	mov	r2, r1
 8014d18:	701a      	strb	r2, [r3, #0]
	lookbits++;
 8014d1a:	f8d7 3534 	ldr.w	r3, [r7, #1332]	@ 0x534
 8014d1e:	3301      	adds	r3, #1
 8014d20:	f8c7 3534 	str.w	r3, [r7, #1332]	@ 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 8014d24:	f8d7 3530 	ldr.w	r3, [r7, #1328]	@ 0x530
 8014d28:	3b01      	subs	r3, #1
 8014d2a:	f8c7 3530 	str.w	r3, [r7, #1328]	@ 0x530
 8014d2e:	f8d7 3530 	ldr.w	r3, [r7, #1328]	@ 0x530
 8014d32:	2b00      	cmp	r3, #0
 8014d34:	dcd8      	bgt.n	8014ce8 <jpeg_make_d_derived_tbl+0x3f4>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 8014d36:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014d3a:	3301      	adds	r3, #1
 8014d3c:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 8014d40:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8014d44:	3301      	adds	r3, #1
 8014d46:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
 8014d4a:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014d4e:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014d52:	4413      	add	r3, r2
 8014d54:	781b      	ldrb	r3, [r3, #0]
 8014d56:	461a      	mov	r2, r3
 8014d58:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014d5c:	4293      	cmp	r3, r2
 8014d5e:	dda9      	ble.n	8014cb4 <jpeg_make_d_derived_tbl+0x3c0>
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 8014d60:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014d64:	3301      	adds	r3, #1
 8014d66:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8014d6a:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8014d6e:	2b08      	cmp	r3, #8
 8014d70:	dd9c      	ble.n	8014cac <jpeg_make_d_derived_tbl+0x3b8>
   * For AC tables, we make no check, but accept all byte values 0..255.
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
 8014d72:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014d76:	f5a3 63a8 	sub.w	r3, r3, #1344	@ 0x540
 8014d7a:	681b      	ldr	r3, [r3, #0]
 8014d7c:	2b00      	cmp	r3, #0
 8014d7e:	d034      	beq.n	8014dea <jpeg_make_d_derived_tbl+0x4f6>
    for (i = 0; i < numsymbols; i++) {
 8014d80:	2300      	movs	r3, #0
 8014d82:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 8014d86:	e02a      	b.n	8014dde <jpeg_make_d_derived_tbl+0x4ea>
      int sym = htbl->huffval[i];
 8014d88:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8014d8c:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014d90:	4413      	add	r3, r2
 8014d92:	3311      	adds	r3, #17
 8014d94:	781b      	ldrb	r3, [r3, #0]
 8014d96:	f8c7 351c 	str.w	r3, [r7, #1308]	@ 0x51c
      if (sym < 0 || sym > 15)
 8014d9a:	f8d7 351c 	ldr.w	r3, [r7, #1308]	@ 0x51c
 8014d9e:	2b00      	cmp	r3, #0
 8014da0:	db03      	blt.n	8014daa <jpeg_make_d_derived_tbl+0x4b6>
 8014da2:	f8d7 351c 	ldr.w	r3, [r7, #1308]	@ 0x51c
 8014da6:	2b0f      	cmp	r3, #15
 8014da8:	dd14      	ble.n	8014dd4 <jpeg_make_d_derived_tbl+0x4e0>
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8014daa:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014dae:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014db2:	681b      	ldr	r3, [r3, #0]
 8014db4:	681b      	ldr	r3, [r3, #0]
 8014db6:	2209      	movs	r2, #9
 8014db8:	615a      	str	r2, [r3, #20]
 8014dba:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8014dbe:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8014dc2:	681b      	ldr	r3, [r3, #0]
 8014dc4:	681b      	ldr	r3, [r3, #0]
 8014dc6:	681b      	ldr	r3, [r3, #0]
 8014dc8:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8014dcc:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8014dd0:	6810      	ldr	r0, [r2, #0]
 8014dd2:	4798      	blx	r3
    for (i = 0; i < numsymbols; i++) {
 8014dd4:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8014dd8:	3301      	adds	r3, #1
 8014dda:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 8014dde:	f8d7 2540 	ldr.w	r2, [r7, #1344]	@ 0x540
 8014de2:	f8d7 3520 	ldr.w	r3, [r7, #1312]	@ 0x520
 8014de6:	429a      	cmp	r2, r3
 8014de8:	dbce      	blt.n	8014d88 <jpeg_make_d_derived_tbl+0x494>
    }
  }
}
 8014dea:	bf00      	nop
 8014dec:	f207 574c 	addw	r7, r7, #1356	@ 0x54c
 8014df0:	46bd      	mov	sp, r7
 8014df2:	bd90      	pop	{r4, r7, pc}
 8014df4:	000fffff 	.word	0x000fffff

08014df8 <jpeg_fill_bit_buffer>:
LOCAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
 8014df8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014dfa:	b087      	sub	sp, #28
 8014dfc:	af00      	add	r7, sp, #0
 8014dfe:	60f8      	str	r0, [r7, #12]
 8014e00:	6079      	str	r1, [r7, #4]
 8014e02:	4615      	mov	r5, r2
 8014e04:	60bb      	str	r3, [r7, #8]
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
 8014e06:	68fb      	ldr	r3, [r7, #12]
 8014e08:	681e      	ldr	r6, [r3, #0]
  register size_t bytes_in_buffer = state->bytes_in_buffer;
 8014e0a:	68fb      	ldr	r3, [r7, #12]
 8014e0c:	685c      	ldr	r4, [r3, #4]
  j_decompress_ptr cinfo = state->cinfo;
 8014e0e:	68fb      	ldr	r3, [r7, #12]
 8014e10:	691b      	ldr	r3, [r3, #16]
 8014e12:	617b      	str	r3, [r7, #20]

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
 8014e14:	697b      	ldr	r3, [r7, #20]
 8014e16:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 8014e1a:	2b00      	cmp	r3, #0
 8014e1c:	d143      	bne.n	8014ea6 <jpeg_fill_bit_buffer+0xae>
    while (bits_left < MIN_GET_BITS) {
 8014e1e:	e03f      	b.n	8014ea0 <jpeg_fill_bit_buffer+0xa8>
      register int c;

      /* Attempt to read a byte */
      if (bytes_in_buffer == 0) {
 8014e20:	2c00      	cmp	r4, #0
 8014e22:	d10f      	bne.n	8014e44 <jpeg_fill_bit_buffer+0x4c>
	if (! (*cinfo->src->fill_input_buffer) (cinfo))
 8014e24:	697b      	ldr	r3, [r7, #20]
 8014e26:	699b      	ldr	r3, [r3, #24]
 8014e28:	68db      	ldr	r3, [r3, #12]
 8014e2a:	6978      	ldr	r0, [r7, #20]
 8014e2c:	4798      	blx	r3
 8014e2e:	4603      	mov	r3, r0
 8014e30:	2b00      	cmp	r3, #0
 8014e32:	d101      	bne.n	8014e38 <jpeg_fill_bit_buffer+0x40>
	  return FALSE;
 8014e34:	2300      	movs	r3, #0
 8014e36:	e060      	b.n	8014efa <jpeg_fill_bit_buffer+0x102>
	next_input_byte = cinfo->src->next_input_byte;
 8014e38:	697b      	ldr	r3, [r7, #20]
 8014e3a:	699b      	ldr	r3, [r3, #24]
 8014e3c:	681e      	ldr	r6, [r3, #0]
	bytes_in_buffer = cinfo->src->bytes_in_buffer;
 8014e3e:	697b      	ldr	r3, [r7, #20]
 8014e40:	699b      	ldr	r3, [r3, #24]
 8014e42:	685c      	ldr	r4, [r3, #4]
      }
      bytes_in_buffer--;
 8014e44:	3c01      	subs	r4, #1
      c = GETJOCTET(*next_input_byte++);
 8014e46:	4633      	mov	r3, r6
 8014e48:	1c5e      	adds	r6, r3, #1
 8014e4a:	781b      	ldrb	r3, [r3, #0]
 8014e4c:	461a      	mov	r2, r3

      /* If it's 0xFF, check and discard stuffed zero byte */
      if (c == 0xFF) {
 8014e4e:	2bff      	cmp	r3, #255	@ 0xff
 8014e50:	d121      	bne.n	8014e96 <jpeg_fill_bit_buffer+0x9e>
	 * so that we can save a valid unread_marker value.  NOTE: we will
	 * accept multiple FF's followed by a 0 as meaning a single FF data
	 * byte.  This data pattern is not valid according to the standard.
	 */
	do {
	  if (bytes_in_buffer == 0) {
 8014e52:	2c00      	cmp	r4, #0
 8014e54:	d10f      	bne.n	8014e76 <jpeg_fill_bit_buffer+0x7e>
	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
 8014e56:	697b      	ldr	r3, [r7, #20]
 8014e58:	699b      	ldr	r3, [r3, #24]
 8014e5a:	68db      	ldr	r3, [r3, #12]
 8014e5c:	6978      	ldr	r0, [r7, #20]
 8014e5e:	4798      	blx	r3
 8014e60:	4603      	mov	r3, r0
 8014e62:	2b00      	cmp	r3, #0
 8014e64:	d101      	bne.n	8014e6a <jpeg_fill_bit_buffer+0x72>
	      return FALSE;
 8014e66:	2300      	movs	r3, #0
 8014e68:	e047      	b.n	8014efa <jpeg_fill_bit_buffer+0x102>
	    next_input_byte = cinfo->src->next_input_byte;
 8014e6a:	697b      	ldr	r3, [r7, #20]
 8014e6c:	699b      	ldr	r3, [r3, #24]
 8014e6e:	681e      	ldr	r6, [r3, #0]
	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
 8014e70:	697b      	ldr	r3, [r7, #20]
 8014e72:	699b      	ldr	r3, [r3, #24]
 8014e74:	685c      	ldr	r4, [r3, #4]
	  }
	  bytes_in_buffer--;
 8014e76:	3c01      	subs	r4, #1
	  c = GETJOCTET(*next_input_byte++);
 8014e78:	4633      	mov	r3, r6
 8014e7a:	1c5e      	adds	r6, r3, #1
 8014e7c:	781b      	ldrb	r3, [r3, #0]
 8014e7e:	461a      	mov	r2, r3
	} while (c == 0xFF);
 8014e80:	2bff      	cmp	r3, #255	@ 0xff
 8014e82:	d0e6      	beq.n	8014e52 <jpeg_fill_bit_buffer+0x5a>

	if (c == 0) {
 8014e84:	2b00      	cmp	r3, #0
 8014e86:	d102      	bne.n	8014e8e <jpeg_fill_bit_buffer+0x96>
	  /* Found FF/00, which represents an FF data byte */
	  c = 0xFF;
 8014e88:	23ff      	movs	r3, #255	@ 0xff
 8014e8a:	461a      	mov	r2, r3
 8014e8c:	e003      	b.n	8014e96 <jpeg_fill_bit_buffer+0x9e>
	   * bitread working state, not straight into permanent state.  But
	   * once we have hit a marker, we cannot need to suspend within the
	   * current MCU, because we will read no more bytes from the data
	   * source.  So it is OK to update permanent state right away.
	   */
	  cinfo->unread_marker = c;
 8014e8e:	697b      	ldr	r3, [r7, #20]
 8014e90:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
	  /* See if we need to insert some fake zero bits. */
	  goto no_more_bytes;
 8014e94:	e008      	b.n	8014ea8 <jpeg_fill_bit_buffer+0xb0>
	}
      }

      /* OK, load c into get_buffer */
      get_buffer = (get_buffer << 8) | c;
 8014e96:	687b      	ldr	r3, [r7, #4]
 8014e98:	021b      	lsls	r3, r3, #8
 8014e9a:	431a      	orrs	r2, r3
 8014e9c:	607a      	str	r2, [r7, #4]
      bits_left += 8;
 8014e9e:	3508      	adds	r5, #8
    while (bits_left < MIN_GET_BITS) {
 8014ea0:	2d18      	cmp	r5, #24
 8014ea2:	ddbd      	ble.n	8014e20 <jpeg_fill_bit_buffer+0x28>
 8014ea4:	e01f      	b.n	8014ee6 <jpeg_fill_bit_buffer+0xee>
    } /* end while */
  } else {
  no_more_bytes:
 8014ea6:	bf00      	nop
    /* We get here if we've read the marker that terminates the compressed
     * data segment.  There should be enough bits in the buffer register
     * to satisfy the request; if so, no problem.
     */
    if (nbits > bits_left) {
 8014ea8:	68bb      	ldr	r3, [r7, #8]
 8014eaa:	42ab      	cmp	r3, r5
 8014eac:	dd1b      	ble.n	8014ee6 <jpeg_fill_bit_buffer+0xee>
      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
       * the data stream, so that we can produce some kind of image.
       * We use a nonvolatile flag to ensure that only one warning message
       * appears per data segment.
       */
      if (! ((huff_entropy_ptr) cinfo->entropy)->insufficient_data) {
 8014eae:	697b      	ldr	r3, [r7, #20]
 8014eb0:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014eb4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014eb6:	2b00      	cmp	r3, #0
 8014eb8:	d10f      	bne.n	8014eda <jpeg_fill_bit_buffer+0xe2>
	WARNMS(cinfo, JWRN_HIT_MARKER);
 8014eba:	697b      	ldr	r3, [r7, #20]
 8014ebc:	681b      	ldr	r3, [r3, #0]
 8014ebe:	2278      	movs	r2, #120	@ 0x78
 8014ec0:	615a      	str	r2, [r3, #20]
 8014ec2:	697b      	ldr	r3, [r7, #20]
 8014ec4:	681b      	ldr	r3, [r3, #0]
 8014ec6:	685b      	ldr	r3, [r3, #4]
 8014ec8:	f04f 31ff 	mov.w	r1, #4294967295
 8014ecc:	6978      	ldr	r0, [r7, #20]
 8014ece:	4798      	blx	r3
	((huff_entropy_ptr) cinfo->entropy)->insufficient_data = TRUE;
 8014ed0:	697b      	ldr	r3, [r7, #20]
 8014ed2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014ed6:	2201      	movs	r2, #1
 8014ed8:	625a      	str	r2, [r3, #36]	@ 0x24
      }
      /* Fill the buffer with zero bits */
      get_buffer <<= MIN_GET_BITS - bits_left;
 8014eda:	f1c5 0319 	rsb	r3, r5, #25
 8014ede:	687a      	ldr	r2, [r7, #4]
 8014ee0:	409a      	lsls	r2, r3
 8014ee2:	607a      	str	r2, [r7, #4]
      bits_left = MIN_GET_BITS;
 8014ee4:	2519      	movs	r5, #25
    }
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
 8014ee6:	68fb      	ldr	r3, [r7, #12]
 8014ee8:	601e      	str	r6, [r3, #0]
  state->bytes_in_buffer = bytes_in_buffer;
 8014eea:	68fb      	ldr	r3, [r7, #12]
 8014eec:	605c      	str	r4, [r3, #4]
  state->get_buffer = get_buffer;
 8014eee:	68fb      	ldr	r3, [r7, #12]
 8014ef0:	687a      	ldr	r2, [r7, #4]
 8014ef2:	609a      	str	r2, [r3, #8]
  state->bits_left = bits_left;
 8014ef4:	68fb      	ldr	r3, [r7, #12]
 8014ef6:	60dd      	str	r5, [r3, #12]

  return TRUE;
 8014ef8:	2301      	movs	r3, #1
}
 8014efa:	4618      	mov	r0, r3
 8014efc:	371c      	adds	r7, #28
 8014efe:	46bd      	mov	sp, r7
 8014f00:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08014f04 <jpeg_huff_decode>:

LOCAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
 8014f04:	b5b0      	push	{r4, r5, r7, lr}
 8014f06:	b082      	sub	sp, #8
 8014f08:	af00      	add	r7, sp, #0
 8014f0a:	6078      	str	r0, [r7, #4]
 8014f0c:	603b      	str	r3, [r7, #0]
  register int l = min_bits;
 8014f0e:	69bc      	ldr	r4, [r7, #24]
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
 8014f10:	42a2      	cmp	r2, r4
 8014f12:	da0d      	bge.n	8014f30 <jpeg_huff_decode+0x2c>
 8014f14:	4623      	mov	r3, r4
 8014f16:	6878      	ldr	r0, [r7, #4]
 8014f18:	f7ff ff6e 	bl	8014df8 <jpeg_fill_bit_buffer>
 8014f1c:	4603      	mov	r3, r0
 8014f1e:	2b00      	cmp	r3, #0
 8014f20:	d102      	bne.n	8014f28 <jpeg_huff_decode+0x24>
 8014f22:	f04f 33ff 	mov.w	r3, #4294967295
 8014f26:	e04b      	b.n	8014fc0 <jpeg_huff_decode+0xbc>
 8014f28:	687b      	ldr	r3, [r7, #4]
 8014f2a:	6899      	ldr	r1, [r3, #8]
 8014f2c:	687b      	ldr	r3, [r7, #4]
 8014f2e:	68da      	ldr	r2, [r3, #12]
  code = GET_BITS(l);
 8014f30:	1b12      	subs	r2, r2, r4
 8014f32:	fa41 f002 	asr.w	r0, r1, r2
 8014f36:	4b24      	ldr	r3, [pc, #144]	@ (8014fc8 <jpeg_huff_decode+0xc4>)
 8014f38:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8014f3c:	ea00 0503 	and.w	r5, r0, r3

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
 8014f40:	e017      	b.n	8014f72 <jpeg_huff_decode+0x6e>
    code <<= 1;
 8014f42:	006d      	lsls	r5, r5, #1
    CHECK_BIT_BUFFER(*state, 1, return -1);
 8014f44:	2a00      	cmp	r2, #0
 8014f46:	dc0d      	bgt.n	8014f64 <jpeg_huff_decode+0x60>
 8014f48:	2301      	movs	r3, #1
 8014f4a:	6878      	ldr	r0, [r7, #4]
 8014f4c:	f7ff ff54 	bl	8014df8 <jpeg_fill_bit_buffer>
 8014f50:	4603      	mov	r3, r0
 8014f52:	2b00      	cmp	r3, #0
 8014f54:	d102      	bne.n	8014f5c <jpeg_huff_decode+0x58>
 8014f56:	f04f 33ff 	mov.w	r3, #4294967295
 8014f5a:	e031      	b.n	8014fc0 <jpeg_huff_decode+0xbc>
 8014f5c:	687b      	ldr	r3, [r7, #4]
 8014f5e:	6899      	ldr	r1, [r3, #8]
 8014f60:	687b      	ldr	r3, [r7, #4]
 8014f62:	68da      	ldr	r2, [r3, #12]
    code |= GET_BITS(1);
 8014f64:	3a01      	subs	r2, #1
 8014f66:	fa41 f302 	asr.w	r3, r1, r2
 8014f6a:	2001      	movs	r0, #1
 8014f6c:	4003      	ands	r3, r0
 8014f6e:	431d      	orrs	r5, r3
    l++;
 8014f70:	3401      	adds	r4, #1
  while (code > htbl->maxcode[l]) {
 8014f72:	683b      	ldr	r3, [r7, #0]
 8014f74:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8014f78:	429d      	cmp	r5, r3
 8014f7a:	dce2      	bgt.n	8014f42 <jpeg_huff_decode+0x3e>
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
 8014f7c:	687b      	ldr	r3, [r7, #4]
 8014f7e:	6099      	str	r1, [r3, #8]
  state->bits_left = bits_left;
 8014f80:	687b      	ldr	r3, [r7, #4]
 8014f82:	60da      	str	r2, [r3, #12]

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
 8014f84:	2c10      	cmp	r4, #16
 8014f86:	dd10      	ble.n	8014faa <jpeg_huff_decode+0xa6>
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
 8014f88:	687b      	ldr	r3, [r7, #4]
 8014f8a:	691b      	ldr	r3, [r3, #16]
 8014f8c:	681b      	ldr	r3, [r3, #0]
 8014f8e:	2279      	movs	r2, #121	@ 0x79
 8014f90:	615a      	str	r2, [r3, #20]
 8014f92:	687b      	ldr	r3, [r7, #4]
 8014f94:	691b      	ldr	r3, [r3, #16]
 8014f96:	681b      	ldr	r3, [r3, #0]
 8014f98:	685b      	ldr	r3, [r3, #4]
 8014f9a:	687a      	ldr	r2, [r7, #4]
 8014f9c:	6912      	ldr	r2, [r2, #16]
 8014f9e:	f04f 31ff 	mov.w	r1, #4294967295
 8014fa2:	4610      	mov	r0, r2
 8014fa4:	4798      	blx	r3
    return 0;			/* fake a zero as the safest result */
 8014fa6:	2300      	movs	r3, #0
 8014fa8:	e00a      	b.n	8014fc0 <jpeg_huff_decode+0xbc>
  }

  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
 8014faa:	683b      	ldr	r3, [r7, #0]
 8014fac:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8014fb0:	683b      	ldr	r3, [r7, #0]
 8014fb2:	f104 0112 	add.w	r1, r4, #18
 8014fb6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8014fba:	442b      	add	r3, r5
 8014fbc:	4413      	add	r3, r2
 8014fbe:	7c5b      	ldrb	r3, [r3, #17]
}
 8014fc0:	4618      	mov	r0, r3
 8014fc2:	3708      	adds	r7, #8
 8014fc4:	46bd      	mov	sp, r7
 8014fc6:	bdb0      	pop	{r4, r5, r7, pc}
 8014fc8:	08030554 	.word	0x08030554

08014fcc <process_restart>:
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
 8014fcc:	b580      	push	{r7, lr}
 8014fce:	b084      	sub	sp, #16
 8014fd0:	af00      	add	r7, sp, #0
 8014fd2:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8014fd4:	687b      	ldr	r3, [r7, #4]
 8014fd6:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014fda:	60bb      	str	r3, [r7, #8]
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
 8014fdc:	687b      	ldr	r3, [r7, #4]
 8014fde:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8014fe2:	699a      	ldr	r2, [r3, #24]
 8014fe4:	68bb      	ldr	r3, [r7, #8]
 8014fe6:	68db      	ldr	r3, [r3, #12]
 8014fe8:	2b00      	cmp	r3, #0
 8014fea:	da00      	bge.n	8014fee <process_restart+0x22>
 8014fec:	3307      	adds	r3, #7
 8014fee:	10db      	asrs	r3, r3, #3
 8014ff0:	4619      	mov	r1, r3
 8014ff2:	687b      	ldr	r3, [r7, #4]
 8014ff4:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8014ff8:	440a      	add	r2, r1
 8014ffa:	619a      	str	r2, [r3, #24]
  entropy->bitstate.bits_left = 0;
 8014ffc:	68bb      	ldr	r3, [r7, #8]
 8014ffe:	2200      	movs	r2, #0
 8015000:	60da      	str	r2, [r3, #12]

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 8015002:	687b      	ldr	r3, [r7, #4]
 8015004:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8015008:	689b      	ldr	r3, [r3, #8]
 801500a:	6878      	ldr	r0, [r7, #4]
 801500c:	4798      	blx	r3
 801500e:	4603      	mov	r3, r0
 8015010:	2b00      	cmp	r3, #0
 8015012:	d101      	bne.n	8015018 <process_restart+0x4c>
    return FALSE;
 8015014:	2300      	movs	r3, #0
 8015016:	e023      	b.n	8015060 <process_restart+0x94>

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 8015018:	2300      	movs	r3, #0
 801501a:	60fb      	str	r3, [r7, #12]
 801501c:	e009      	b.n	8015032 <process_restart+0x66>
    entropy->saved.last_dc_val[ci] = 0;
 801501e:	68ba      	ldr	r2, [r7, #8]
 8015020:	68fb      	ldr	r3, [r7, #12]
 8015022:	3304      	adds	r3, #4
 8015024:	009b      	lsls	r3, r3, #2
 8015026:	4413      	add	r3, r2
 8015028:	2200      	movs	r2, #0
 801502a:	605a      	str	r2, [r3, #4]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 801502c:	68fb      	ldr	r3, [r7, #12]
 801502e:	3301      	adds	r3, #1
 8015030:	60fb      	str	r3, [r7, #12]
 8015032:	687b      	ldr	r3, [r7, #4]
 8015034:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8015038:	68fa      	ldr	r2, [r7, #12]
 801503a:	429a      	cmp	r2, r3
 801503c:	dbef      	blt.n	801501e <process_restart+0x52>
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;
 801503e:	68bb      	ldr	r3, [r7, #8]
 8015040:	2200      	movs	r2, #0
 8015042:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8015044:	687b      	ldr	r3, [r7, #4]
 8015046:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801504a:	68bb      	ldr	r3, [r7, #8]
 801504c:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
 801504e:	687b      	ldr	r3, [r7, #4]
 8015050:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 8015054:	2b00      	cmp	r3, #0
 8015056:	d102      	bne.n	801505e <process_restart+0x92>
    entropy->insufficient_data = FALSE;
 8015058:	68bb      	ldr	r3, [r7, #8]
 801505a:	2200      	movs	r2, #0
 801505c:	625a      	str	r2, [r3, #36]	@ 0x24

  return TRUE;
 801505e:	2301      	movs	r3, #1
}
 8015060:	4618      	mov	r0, r3
 8015062:	3710      	adds	r7, #16
 8015064:	46bd      	mov	sp, r7
 8015066:	bd80      	pop	{r7, pc}

08015068 <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8015068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801506c:	b096      	sub	sp, #88	@ 0x58
 801506e:	af02      	add	r7, sp, #8
 8015070:	6078      	str	r0, [r7, #4]
 8015072:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8015074:	687b      	ldr	r3, [r7, #4]
 8015076:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801507a:	64bb      	str	r3, [r7, #72]	@ 0x48
  int Al = cinfo->Al;
 801507c:	687b      	ldr	r3, [r7, #4]
 801507e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8015082:	647b      	str	r3, [r7, #68]	@ 0x44
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8015084:	687b      	ldr	r3, [r7, #4]
 8015086:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801508a:	2b00      	cmp	r3, #0
 801508c:	d00b      	beq.n	80150a6 <decode_mcu_DC_first+0x3e>
    if (entropy->restarts_to_go == 0)
 801508e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015090:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015092:	2b00      	cmp	r3, #0
 8015094:	d107      	bne.n	80150a6 <decode_mcu_DC_first+0x3e>
      if (! process_restart(cinfo))
 8015096:	6878      	ldr	r0, [r7, #4]
 8015098:	f7ff ff98 	bl	8014fcc <process_restart>
 801509c:	4603      	mov	r3, r0
 801509e:	2b00      	cmp	r3, #0
 80150a0:	d101      	bne.n	80150a6 <decode_mcu_DC_first+0x3e>
	return FALSE;
 80150a2:	2300      	movs	r3, #0
 80150a4:	e0d4      	b.n	8015250 <decode_mcu_DC_first+0x1e8>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 80150a6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80150a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80150aa:	2b00      	cmp	r3, #0
 80150ac:	f040 80ca 	bne.w	8015244 <decode_mcu_DC_first+0x1dc>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80150b0:	687b      	ldr	r3, [r7, #4]
 80150b2:	633b      	str	r3, [r7, #48]	@ 0x30
 80150b4:	687b      	ldr	r3, [r7, #4]
 80150b6:	699b      	ldr	r3, [r3, #24]
 80150b8:	681b      	ldr	r3, [r3, #0]
 80150ba:	623b      	str	r3, [r7, #32]
 80150bc:	687b      	ldr	r3, [r7, #4]
 80150be:	699b      	ldr	r3, [r3, #24]
 80150c0:	685b      	ldr	r3, [r3, #4]
 80150c2:	627b      	str	r3, [r7, #36]	@ 0x24
 80150c4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80150c6:	689e      	ldr	r6, [r3, #8]
 80150c8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80150ca:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 80150cc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80150ce:	f107 050c 	add.w	r5, r7, #12
 80150d2:	f103 0c10 	add.w	ip, r3, #16
 80150d6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80150da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80150dc:	f8dc 3000 	ldr.w	r3, [ip]
 80150e0:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80150e2:	2300      	movs	r3, #0
 80150e4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80150e6:	e091      	b.n	801520c <decode_mcu_DC_first+0x1a4>
      block = MCU_data[blkn];
 80150e8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80150ea:	009b      	lsls	r3, r3, #2
 80150ec:	683a      	ldr	r2, [r7, #0]
 80150ee:	4413      	add	r3, r2
 80150f0:	681b      	ldr	r3, [r3, #0]
 80150f2:	643b      	str	r3, [r7, #64]	@ 0x40
      ci = cinfo->MCU_membership[blkn];
 80150f4:	687b      	ldr	r3, [r7, #4]
 80150f6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80150f8:	325c      	adds	r2, #92	@ 0x5c
 80150fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80150fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
      compptr = cinfo->cur_comp_info[ci];
 8015100:	687a      	ldr	r2, [r7, #4]
 8015102:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015104:	3354      	adds	r3, #84	@ 0x54
 8015106:	009b      	lsls	r3, r3, #2
 8015108:	4413      	add	r3, r2
 801510a:	685b      	ldr	r3, [r3, #4]
 801510c:	63bb      	str	r3, [r7, #56]	@ 0x38
      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
 801510e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015110:	695b      	ldr	r3, [r3, #20]
 8015112:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8015114:	330a      	adds	r3, #10
 8015116:	009b      	lsls	r3, r3, #2
 8015118:	4413      	add	r3, r2
 801511a:	685b      	ldr	r3, [r3, #4]
 801511c:	637b      	str	r3, [r7, #52]	@ 0x34

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 801511e:	2c07      	cmp	r4, #7
 8015120:	dc11      	bgt.n	8015146 <decode_mcu_DC_first+0xde>
 8015122:	f107 0020 	add.w	r0, r7, #32
 8015126:	2300      	movs	r3, #0
 8015128:	4622      	mov	r2, r4
 801512a:	4631      	mov	r1, r6
 801512c:	f7ff fe64 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015130:	4603      	mov	r3, r0
 8015132:	2b00      	cmp	r3, #0
 8015134:	d101      	bne.n	801513a <decode_mcu_DC_first+0xd2>
 8015136:	2300      	movs	r3, #0
 8015138:	e08a      	b.n	8015250 <decode_mcu_DC_first+0x1e8>
 801513a:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 801513c:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
 801513e:	2c07      	cmp	r4, #7
 8015140:	dc01      	bgt.n	8015146 <decode_mcu_DC_first+0xde>
 8015142:	2501      	movs	r5, #1
 8015144:	e015      	b.n	8015172 <decode_mcu_DC_first+0x10a>
 8015146:	f1a4 0308 	sub.w	r3, r4, #8
 801514a:	fa46 f303 	asr.w	r3, r6, r3
 801514e:	22ff      	movs	r2, #255	@ 0xff
 8015150:	ea03 0802 	and.w	r8, r3, r2
 8015154:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015156:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 801515a:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801515e:	2d00      	cmp	r5, #0
 8015160:	d006      	beq.n	8015170 <decode_mcu_DC_first+0x108>
 8015162:	1b64      	subs	r4, r4, r5
 8015164:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015166:	4443      	add	r3, r8
 8015168:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801516c:	461d      	mov	r5, r3
 801516e:	e00f      	b.n	8015190 <decode_mcu_DC_first+0x128>
 8015170:	2509      	movs	r5, #9
 8015172:	f107 0020 	add.w	r0, r7, #32
 8015176:	9500      	str	r5, [sp, #0]
 8015178:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801517a:	4622      	mov	r2, r4
 801517c:	4631      	mov	r1, r6
 801517e:	f7ff fec1 	bl	8014f04 <jpeg_huff_decode>
 8015182:	4605      	mov	r5, r0
 8015184:	2d00      	cmp	r5, #0
 8015186:	da01      	bge.n	801518c <decode_mcu_DC_first+0x124>
 8015188:	2300      	movs	r3, #0
 801518a:	e061      	b.n	8015250 <decode_mcu_DC_first+0x1e8>
 801518c:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 801518e:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
      if (s) {
 8015190:	2d00      	cmp	r5, #0
 8015192:	d025      	beq.n	80151e0 <decode_mcu_DC_first+0x178>
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015194:	42ac      	cmp	r4, r5
 8015196:	da0d      	bge.n	80151b4 <decode_mcu_DC_first+0x14c>
 8015198:	f107 0020 	add.w	r0, r7, #32
 801519c:	462b      	mov	r3, r5
 801519e:	4622      	mov	r2, r4
 80151a0:	4631      	mov	r1, r6
 80151a2:	f7ff fe29 	bl	8014df8 <jpeg_fill_bit_buffer>
 80151a6:	4603      	mov	r3, r0
 80151a8:	2b00      	cmp	r3, #0
 80151aa:	d101      	bne.n	80151b0 <decode_mcu_DC_first+0x148>
 80151ac:	2300      	movs	r3, #0
 80151ae:	e04f      	b.n	8015250 <decode_mcu_DC_first+0x1e8>
 80151b0:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 80151b2:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
	r = GET_BITS(s);
 80151b4:	1b64      	subs	r4, r4, r5
 80151b6:	fa46 f204 	asr.w	r2, r6, r4
 80151ba:	4b28      	ldr	r3, [pc, #160]	@ (801525c <decode_mcu_DC_first+0x1f4>)
 80151bc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80151c0:	ea02 0803 	and.w	r8, r2, r3
	s = HUFF_EXTEND(r, s);
 80151c4:	1e6b      	subs	r3, r5, #1
 80151c6:	4a25      	ldr	r2, [pc, #148]	@ (801525c <decode_mcu_DC_first+0x1f4>)
 80151c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80151cc:	4598      	cmp	r8, r3
 80151ce:	dc05      	bgt.n	80151dc <decode_mcu_DC_first+0x174>
 80151d0:	4b22      	ldr	r3, [pc, #136]	@ (801525c <decode_mcu_DC_first+0x1f4>)
 80151d2:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80151d6:	eba8 0303 	sub.w	r3, r8, r3
 80151da:	e000      	b.n	80151de <decode_mcu_DC_first+0x176>
 80151dc:	4643      	mov	r3, r8
 80151de:	461d      	mov	r5, r3
      }

      /* Convert DC difference to actual value, update last_dc_val */
      s += state.last_dc_val[ci];
 80151e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80151e2:	009b      	lsls	r3, r3, #2
 80151e4:	3350      	adds	r3, #80	@ 0x50
 80151e6:	443b      	add	r3, r7
 80151e8:	f853 3c40 	ldr.w	r3, [r3, #-64]
 80151ec:	441d      	add	r5, r3
      state.last_dc_val[ci] = s;
 80151ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80151f0:	009b      	lsls	r3, r3, #2
 80151f2:	3350      	adds	r3, #80	@ 0x50
 80151f4:	443b      	add	r3, r7
 80151f6:	f843 5c40 	str.w	r5, [r3, #-64]
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
 80151fa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80151fc:	fa05 f303 	lsl.w	r3, r5, r3
 8015200:	b21a      	sxth	r2, r3
 8015202:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015204:	801a      	strh	r2, [r3, #0]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8015206:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015208:	3301      	adds	r3, #1
 801520a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801520c:	687b      	ldr	r3, [r7, #4]
 801520e:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8015212:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015214:	429a      	cmp	r2, r3
 8015216:	f6ff af67 	blt.w	80150e8 <decode_mcu_DC_first+0x80>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 801521a:	687b      	ldr	r3, [r7, #4]
 801521c:	699b      	ldr	r3, [r3, #24]
 801521e:	6a3a      	ldr	r2, [r7, #32]
 8015220:	601a      	str	r2, [r3, #0]
 8015222:	687b      	ldr	r3, [r7, #4]
 8015224:	699b      	ldr	r3, [r3, #24]
 8015226:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8015228:	605a      	str	r2, [r3, #4]
 801522a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801522c:	609e      	str	r6, [r3, #8]
 801522e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015230:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 8015232:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015234:	f103 0410 	add.w	r4, r3, #16
 8015238:	f107 050c 	add.w	r5, r7, #12
 801523c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801523e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015240:	682b      	ldr	r3, [r5, #0]
 8015242:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8015244:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015246:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015248:	1e5a      	subs	r2, r3, #1
 801524a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801524c:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 801524e:	2301      	movs	r3, #1
}
 8015250:	4618      	mov	r0, r3
 8015252:	3750      	adds	r7, #80	@ 0x50
 8015254:	46bd      	mov	sp, r7
 8015256:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801525a:	bf00      	nop
 801525c:	08030554 	.word	0x08030554

08015260 <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8015260:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015262:	b093      	sub	sp, #76	@ 0x4c
 8015264:	af02      	add	r7, sp, #8
 8015266:	60f8      	str	r0, [r7, #12]
 8015268:	60b9      	str	r1, [r7, #8]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 801526a:	68fb      	ldr	r3, [r7, #12]
 801526c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8015270:	63bb      	str	r3, [r7, #56]	@ 0x38
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8015272:	68fb      	ldr	r3, [r7, #12]
 8015274:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8015278:	2b00      	cmp	r3, #0
 801527a:	d00b      	beq.n	8015294 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 801527c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801527e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015280:	2b00      	cmp	r3, #0
 8015282:	d107      	bne.n	8015294 <decode_mcu_AC_first+0x34>
      if (! process_restart(cinfo))
 8015284:	68f8      	ldr	r0, [r7, #12]
 8015286:	f7ff fea1 	bl	8014fcc <process_restart>
 801528a:	4603      	mov	r3, r0
 801528c:	2b00      	cmp	r3, #0
 801528e:	d101      	bne.n	8015294 <decode_mcu_AC_first+0x34>
	return FALSE;
 8015290:	2300      	movs	r3, #0
 8015292:	e0f7      	b.n	8015484 <decode_mcu_AC_first+0x224>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8015294:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015296:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015298:	2b00      	cmp	r3, #0
 801529a:	f040 80ed 	bne.w	8015478 <decode_mcu_AC_first+0x218>

    Se = cinfo->Se;
 801529e:	68fb      	ldr	r3, [r7, #12]
 80152a0:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80152a4:	637b      	str	r3, [r7, #52]	@ 0x34
    Al = cinfo->Al;
 80152a6:	68fb      	ldr	r3, [r7, #12]
 80152a8:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80152ac:	633b      	str	r3, [r7, #48]	@ 0x30
    natural_order = cinfo->natural_order;
 80152ae:	68fb      	ldr	r3, [r7, #12]
 80152b0:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 80152b4:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Load up working state.
     * We can avoid loading/saving bitread state if in an EOB run.
     */
    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
 80152b6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80152b8:	691b      	ldr	r3, [r3, #16]
 80152ba:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* There is always only one block per MCU */

    if (EOBRUN > 0)		/* if it's a band of zeroes... */
 80152bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80152be:	2b00      	cmp	r3, #0
 80152c0:	d003      	beq.n	80152ca <decode_mcu_AC_first+0x6a>
      EOBRUN--;			/* ...process it now (we do nothing) */
 80152c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80152c4:	3b01      	subs	r3, #1
 80152c6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80152c8:	e0d3      	b.n	8015472 <decode_mcu_AC_first+0x212>
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80152ca:	68fb      	ldr	r3, [r7, #12]
 80152cc:	623b      	str	r3, [r7, #32]
 80152ce:	68fb      	ldr	r3, [r7, #12]
 80152d0:	699b      	ldr	r3, [r3, #24]
 80152d2:	681b      	ldr	r3, [r3, #0]
 80152d4:	613b      	str	r3, [r7, #16]
 80152d6:	68fb      	ldr	r3, [r7, #12]
 80152d8:	699b      	ldr	r3, [r3, #24]
 80152da:	685b      	ldr	r3, [r3, #4]
 80152dc:	617b      	str	r3, [r7, #20]
 80152de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80152e0:	689b      	ldr	r3, [r3, #8]
 80152e2:	607b      	str	r3, [r7, #4]
 80152e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80152e6:	68dc      	ldr	r4, [r3, #12]
      block = MCU_data[0];
 80152e8:	68bb      	ldr	r3, [r7, #8]
 80152ea:	681b      	ldr	r3, [r3, #0]
 80152ec:	62bb      	str	r3, [r7, #40]	@ 0x28
      tbl = entropy->ac_derived_tbl;
 80152ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80152f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80152f2:	627b      	str	r3, [r7, #36]	@ 0x24

      for (k = cinfo->Ss; k <= Se; k++) {
 80152f4:	68fb      	ldr	r3, [r7, #12]
 80152f6:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80152fa:	603b      	str	r3, [r7, #0]
 80152fc:	e0a7      	b.n	801544e <decode_mcu_AC_first+0x1ee>
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 80152fe:	2c07      	cmp	r4, #7
 8015300:	dc12      	bgt.n	8015328 <decode_mcu_AC_first+0xc8>
 8015302:	f107 0010 	add.w	r0, r7, #16
 8015306:	2300      	movs	r3, #0
 8015308:	4622      	mov	r2, r4
 801530a:	6879      	ldr	r1, [r7, #4]
 801530c:	f7ff fd74 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015310:	4603      	mov	r3, r0
 8015312:	2b00      	cmp	r3, #0
 8015314:	d101      	bne.n	801531a <decode_mcu_AC_first+0xba>
 8015316:	2300      	movs	r3, #0
 8015318:	e0b4      	b.n	8015484 <decode_mcu_AC_first+0x224>
 801531a:	69bb      	ldr	r3, [r7, #24]
 801531c:	607b      	str	r3, [r7, #4]
 801531e:	69fc      	ldr	r4, [r7, #28]
 8015320:	2c07      	cmp	r4, #7
 8015322:	dc01      	bgt.n	8015328 <decode_mcu_AC_first+0xc8>
 8015324:	2501      	movs	r5, #1
 8015326:	e016      	b.n	8015356 <decode_mcu_AC_first+0xf6>
 8015328:	f1a4 0308 	sub.w	r3, r4, #8
 801532c:	687a      	ldr	r2, [r7, #4]
 801532e:	fa42 f303 	asr.w	r3, r2, r3
 8015332:	22ff      	movs	r2, #255	@ 0xff
 8015334:	ea03 0602 	and.w	r6, r3, r2
 8015338:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801533a:	f106 0224 	add.w	r2, r6, #36	@ 0x24
 801533e:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8015342:	2d00      	cmp	r5, #0
 8015344:	d006      	beq.n	8015354 <decode_mcu_AC_first+0xf4>
 8015346:	1b64      	subs	r4, r4, r5
 8015348:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801534a:	4433      	add	r3, r6
 801534c:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8015350:	461e      	mov	r6, r3
 8015352:	e010      	b.n	8015376 <decode_mcu_AC_first+0x116>
 8015354:	2509      	movs	r5, #9
 8015356:	f107 0010 	add.w	r0, r7, #16
 801535a:	9500      	str	r5, [sp, #0]
 801535c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801535e:	4622      	mov	r2, r4
 8015360:	6879      	ldr	r1, [r7, #4]
 8015362:	f7ff fdcf 	bl	8014f04 <jpeg_huff_decode>
 8015366:	4606      	mov	r6, r0
 8015368:	2e00      	cmp	r6, #0
 801536a:	da01      	bge.n	8015370 <decode_mcu_AC_first+0x110>
 801536c:	2300      	movs	r3, #0
 801536e:	e089      	b.n	8015484 <decode_mcu_AC_first+0x224>
 8015370:	69bb      	ldr	r3, [r7, #24]
 8015372:	607b      	str	r3, [r7, #4]
 8015374:	69fc      	ldr	r4, [r7, #28]
	r = s >> 4;
 8015376:	1135      	asrs	r5, r6, #4
	s &= 15;
 8015378:	f006 060f 	and.w	r6, r6, #15
	if (s) {
 801537c:	2e00      	cmp	r6, #0
 801537e:	d036      	beq.n	80153ee <decode_mcu_AC_first+0x18e>
	  k += r;
 8015380:	683b      	ldr	r3, [r7, #0]
 8015382:	442b      	add	r3, r5
 8015384:	603b      	str	r3, [r7, #0]
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015386:	42b4      	cmp	r4, r6
 8015388:	da0e      	bge.n	80153a8 <decode_mcu_AC_first+0x148>
 801538a:	f107 0010 	add.w	r0, r7, #16
 801538e:	4633      	mov	r3, r6
 8015390:	4622      	mov	r2, r4
 8015392:	6879      	ldr	r1, [r7, #4]
 8015394:	f7ff fd30 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015398:	4603      	mov	r3, r0
 801539a:	2b00      	cmp	r3, #0
 801539c:	d101      	bne.n	80153a2 <decode_mcu_AC_first+0x142>
 801539e:	2300      	movs	r3, #0
 80153a0:	e070      	b.n	8015484 <decode_mcu_AC_first+0x224>
 80153a2:	69bb      	ldr	r3, [r7, #24]
 80153a4:	607b      	str	r3, [r7, #4]
 80153a6:	69fc      	ldr	r4, [r7, #28]
	  r = GET_BITS(s);
 80153a8:	1ba4      	subs	r4, r4, r6
 80153aa:	687b      	ldr	r3, [r7, #4]
 80153ac:	fa43 f204 	asr.w	r2, r3, r4
 80153b0:	4b36      	ldr	r3, [pc, #216]	@ (801548c <decode_mcu_AC_first+0x22c>)
 80153b2:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 80153b6:	ea02 0503 	and.w	r5, r2, r3
	  s = HUFF_EXTEND(r, s);
 80153ba:	1e73      	subs	r3, r6, #1
 80153bc:	4a33      	ldr	r2, [pc, #204]	@ (801548c <decode_mcu_AC_first+0x22c>)
 80153be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80153c2:	429d      	cmp	r5, r3
 80153c4:	dc04      	bgt.n	80153d0 <decode_mcu_AC_first+0x170>
 80153c6:	4b31      	ldr	r3, [pc, #196]	@ (801548c <decode_mcu_AC_first+0x22c>)
 80153c8:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 80153cc:	1aeb      	subs	r3, r5, r3
 80153ce:	e000      	b.n	80153d2 <decode_mcu_AC_first+0x172>
 80153d0:	462b      	mov	r3, r5
 80153d2:	461e      	mov	r6, r3
	  /* Scale and output coefficient in natural (dezigzagged) order */
	  (*block)[natural_order[k]] = (JCOEF) (s << Al);
 80153d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80153d6:	fa06 f103 	lsl.w	r1, r6, r3
 80153da:	683b      	ldr	r3, [r7, #0]
 80153dc:	009b      	lsls	r3, r3, #2
 80153de:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80153e0:	4413      	add	r3, r2
 80153e2:	681a      	ldr	r2, [r3, #0]
 80153e4:	b209      	sxth	r1, r1
 80153e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80153e8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 80153ec:	e02c      	b.n	8015448 <decode_mcu_AC_first+0x1e8>
	} else {
	  if (r == 15) {	/* ZRL */
 80153ee:	2d0f      	cmp	r5, #15
 80153f0:	d103      	bne.n	80153fa <decode_mcu_AC_first+0x19a>
	    k += 15;		/* skip 15 zeroes in band */
 80153f2:	683b      	ldr	r3, [r7, #0]
 80153f4:	330f      	adds	r3, #15
 80153f6:	603b      	str	r3, [r7, #0]
 80153f8:	e026      	b.n	8015448 <decode_mcu_AC_first+0x1e8>
	  } else {		/* EOBr, run length is 2^r + appended bits */
	    EOBRUN = 1 << r;
 80153fa:	2301      	movs	r3, #1
 80153fc:	40ab      	lsls	r3, r5
 80153fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    if (r) {		/* EOBr, r > 0 */
 8015400:	2d00      	cmp	r5, #0
 8015402:	d01d      	beq.n	8015440 <decode_mcu_AC_first+0x1e0>
	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
 8015404:	42ac      	cmp	r4, r5
 8015406:	da0e      	bge.n	8015426 <decode_mcu_AC_first+0x1c6>
 8015408:	f107 0010 	add.w	r0, r7, #16
 801540c:	462b      	mov	r3, r5
 801540e:	4622      	mov	r2, r4
 8015410:	6879      	ldr	r1, [r7, #4]
 8015412:	f7ff fcf1 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015416:	4603      	mov	r3, r0
 8015418:	2b00      	cmp	r3, #0
 801541a:	d101      	bne.n	8015420 <decode_mcu_AC_first+0x1c0>
 801541c:	2300      	movs	r3, #0
 801541e:	e031      	b.n	8015484 <decode_mcu_AC_first+0x224>
 8015420:	69bb      	ldr	r3, [r7, #24]
 8015422:	607b      	str	r3, [r7, #4]
 8015424:	69fc      	ldr	r4, [r7, #28]
	      r = GET_BITS(r);
 8015426:	1b64      	subs	r4, r4, r5
 8015428:	687b      	ldr	r3, [r7, #4]
 801542a:	fa43 f204 	asr.w	r2, r3, r4
 801542e:	4b17      	ldr	r3, [pc, #92]	@ (801548c <decode_mcu_AC_first+0x22c>)
 8015430:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015434:	ea02 0503 	and.w	r5, r2, r3
	      EOBRUN += r;
 8015438:	462a      	mov	r2, r5
 801543a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801543c:	4413      	add	r3, r2
 801543e:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    }
	    EOBRUN--;		/* this band is processed at this moment */
 8015440:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015442:	3b01      	subs	r3, #1
 8015444:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    break;		/* force end-of-band */
 8015446:	e007      	b.n	8015458 <decode_mcu_AC_first+0x1f8>
      for (k = cinfo->Ss; k <= Se; k++) {
 8015448:	683b      	ldr	r3, [r7, #0]
 801544a:	3301      	adds	r3, #1
 801544c:	603b      	str	r3, [r7, #0]
 801544e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015450:	683a      	ldr	r2, [r7, #0]
 8015452:	429a      	cmp	r2, r3
 8015454:	f77f af53 	ble.w	80152fe <decode_mcu_AC_first+0x9e>
	  }
	}
      }

      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8015458:	68fb      	ldr	r3, [r7, #12]
 801545a:	699b      	ldr	r3, [r3, #24]
 801545c:	693a      	ldr	r2, [r7, #16]
 801545e:	601a      	str	r2, [r3, #0]
 8015460:	68fb      	ldr	r3, [r7, #12]
 8015462:	699b      	ldr	r3, [r3, #24]
 8015464:	697a      	ldr	r2, [r7, #20]
 8015466:	605a      	str	r2, [r3, #4]
 8015468:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801546a:	687a      	ldr	r2, [r7, #4]
 801546c:	609a      	str	r2, [r3, #8]
 801546e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015470:	60dc      	str	r4, [r3, #12]
    }

    /* Completed MCU, so update state */
    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
 8015472:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015474:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015476:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8015478:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801547a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801547c:	1e5a      	subs	r2, r3, #1
 801547e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015480:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8015482:	2301      	movs	r3, #1
}
 8015484:	4618      	mov	r0, r3
 8015486:	3744      	adds	r7, #68	@ 0x44
 8015488:	46bd      	mov	sp, r7
 801548a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801548c:	08030554 	.word	0x08030554

08015490 <decode_mcu_DC_refine>:
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8015490:	b5b0      	push	{r4, r5, r7, lr}
 8015492:	b08c      	sub	sp, #48	@ 0x30
 8015494:	af00      	add	r7, sp, #0
 8015496:	6078      	str	r0, [r7, #4]
 8015498:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 801549a:	687b      	ldr	r3, [r7, #4]
 801549c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80154a0:	62bb      	str	r3, [r7, #40]	@ 0x28
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 80154a2:	687b      	ldr	r3, [r7, #4]
 80154a4:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80154a8:	2201      	movs	r2, #1
 80154aa:	fa02 f303 	lsl.w	r3, r2, r3
 80154ae:	627b      	str	r3, [r7, #36]	@ 0x24
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 80154b0:	687b      	ldr	r3, [r7, #4]
 80154b2:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80154b6:	2b00      	cmp	r3, #0
 80154b8:	d00b      	beq.n	80154d2 <decode_mcu_DC_refine+0x42>
    if (entropy->restarts_to_go == 0)
 80154ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80154bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80154be:	2b00      	cmp	r3, #0
 80154c0:	d107      	bne.n	80154d2 <decode_mcu_DC_refine+0x42>
      if (! process_restart(cinfo))
 80154c2:	6878      	ldr	r0, [r7, #4]
 80154c4:	f7ff fd82 	bl	8014fcc <process_restart>
 80154c8:	4603      	mov	r3, r0
 80154ca:	2b00      	cmp	r3, #0
 80154cc:	d101      	bne.n	80154d2 <decode_mcu_DC_refine+0x42>
	return FALSE;
 80154ce:	2300      	movs	r3, #0
 80154d0:	e051      	b.n	8015576 <decode_mcu_DC_refine+0xe6>
  /* Not worth the cycles to check insufficient_data here,
   * since we will not change the data anyway if we read zeroes.
   */

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80154d2:	687b      	ldr	r3, [r7, #4]
 80154d4:	61fb      	str	r3, [r7, #28]
 80154d6:	687b      	ldr	r3, [r7, #4]
 80154d8:	699b      	ldr	r3, [r3, #24]
 80154da:	681b      	ldr	r3, [r3, #0]
 80154dc:	60fb      	str	r3, [r7, #12]
 80154de:	687b      	ldr	r3, [r7, #4]
 80154e0:	699b      	ldr	r3, [r3, #24]
 80154e2:	685b      	ldr	r3, [r3, #4]
 80154e4:	613b      	str	r3, [r7, #16]
 80154e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80154e8:	689d      	ldr	r5, [r3, #8]
 80154ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80154ec:	68dc      	ldr	r4, [r3, #12]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80154ee:	2300      	movs	r3, #0
 80154f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80154f2:	e028      	b.n	8015546 <decode_mcu_DC_refine+0xb6>
    block = MCU_data[blkn];
 80154f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80154f6:	009b      	lsls	r3, r3, #2
 80154f8:	683a      	ldr	r2, [r7, #0]
 80154fa:	4413      	add	r3, r2
 80154fc:	681b      	ldr	r3, [r3, #0]
 80154fe:	623b      	str	r3, [r7, #32]

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 8015500:	2c00      	cmp	r4, #0
 8015502:	dc0d      	bgt.n	8015520 <decode_mcu_DC_refine+0x90>
 8015504:	f107 000c 	add.w	r0, r7, #12
 8015508:	2301      	movs	r3, #1
 801550a:	4622      	mov	r2, r4
 801550c:	4629      	mov	r1, r5
 801550e:	f7ff fc73 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015512:	4603      	mov	r3, r0
 8015514:	2b00      	cmp	r3, #0
 8015516:	d101      	bne.n	801551c <decode_mcu_DC_refine+0x8c>
 8015518:	2300      	movs	r3, #0
 801551a:	e02c      	b.n	8015576 <decode_mcu_DC_refine+0xe6>
 801551c:	697d      	ldr	r5, [r7, #20]
 801551e:	69bc      	ldr	r4, [r7, #24]
    if (GET_BITS(1))
 8015520:	3c01      	subs	r4, #1
 8015522:	fa45 f304 	asr.w	r3, r5, r4
 8015526:	2201      	movs	r2, #1
 8015528:	4013      	ands	r3, r2
 801552a:	2b00      	cmp	r3, #0
 801552c:	d008      	beq.n	8015540 <decode_mcu_DC_refine+0xb0>
      (*block)[0] |= p1;
 801552e:	6a3b      	ldr	r3, [r7, #32]
 8015530:	f9b3 2000 	ldrsh.w	r2, [r3]
 8015534:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015536:	b21b      	sxth	r3, r3
 8015538:	4313      	orrs	r3, r2
 801553a:	b21a      	sxth	r2, r3
 801553c:	6a3b      	ldr	r3, [r7, #32]
 801553e:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8015540:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015542:	3301      	adds	r3, #1
 8015544:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8015546:	687b      	ldr	r3, [r7, #4]
 8015548:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 801554c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801554e:	429a      	cmp	r2, r3
 8015550:	dbd0      	blt.n	80154f4 <decode_mcu_DC_refine+0x64>
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8015552:	687b      	ldr	r3, [r7, #4]
 8015554:	699b      	ldr	r3, [r3, #24]
 8015556:	68fa      	ldr	r2, [r7, #12]
 8015558:	601a      	str	r2, [r3, #0]
 801555a:	687b      	ldr	r3, [r7, #4]
 801555c:	699b      	ldr	r3, [r3, #24]
 801555e:	693a      	ldr	r2, [r7, #16]
 8015560:	605a      	str	r2, [r3, #4]
 8015562:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015564:	609d      	str	r5, [r3, #8]
 8015566:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015568:	60dc      	str	r4, [r3, #12]

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 801556a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801556c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801556e:	1e5a      	subs	r2, r3, #1
 8015570:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015572:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8015574:	2301      	movs	r3, #1
}
 8015576:	4618      	mov	r0, r3
 8015578:	3730      	adds	r7, #48	@ 0x30
 801557a:	46bd      	mov	sp, r7
 801557c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08015580 <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8015580:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015584:	b0d6      	sub	sp, #344	@ 0x158
 8015586:	af02      	add	r7, sp, #8
 8015588:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801558c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015590:	6018      	str	r0, [r3, #0]
 8015592:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015596:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 801559a:	6019      	str	r1, [r3, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 801559c:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80155a0:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80155a4:	681b      	ldr	r3, [r3, #0]
 80155a6:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80155aa:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 80155ae:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80155b2:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80155b6:	681b      	ldr	r3, [r3, #0]
 80155b8:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80155bc:	2b00      	cmp	r3, #0
 80155be:	d010      	beq.n	80155e2 <decode_mcu_AC_refine+0x62>
    if (entropy->restarts_to_go == 0)
 80155c0:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80155c4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80155c6:	2b00      	cmp	r3, #0
 80155c8:	d10b      	bne.n	80155e2 <decode_mcu_AC_refine+0x62>
      if (! process_restart(cinfo))
 80155ca:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80155ce:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80155d2:	6818      	ldr	r0, [r3, #0]
 80155d4:	f7ff fcfa 	bl	8014fcc <process_restart>
 80155d8:	4603      	mov	r3, r0
 80155da:	2b00      	cmp	r3, #0
 80155dc:	d101      	bne.n	80155e2 <decode_mcu_AC_refine+0x62>
	return FALSE;
 80155de:	2300      	movs	r3, #0
 80155e0:	e24f      	b.n	8015a82 <decode_mcu_AC_refine+0x502>
  }

  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->insufficient_data) {
 80155e2:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80155e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80155e8:	2b00      	cmp	r3, #0
 80155ea:	f040 8229 	bne.w	8015a40 <decode_mcu_AC_refine+0x4c0>

    Se = cinfo->Se;
 80155ee:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80155f2:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80155f6:	681b      	ldr	r3, [r3, #0]
 80155f8:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80155fc:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 8015600:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015604:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015608:	681b      	ldr	r3, [r3, #0]
 801560a:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 801560e:	2201      	movs	r2, #1
 8015610:	fa02 f303 	lsl.w	r3, r2, r3
 8015614:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 8015618:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801561c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015620:	681b      	ldr	r3, [r3, #0]
 8015622:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8015626:	f04f 32ff 	mov.w	r2, #4294967295
 801562a:	fa02 f303 	lsl.w	r3, r2, r3
 801562e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    natural_order = cinfo->natural_order;
 8015632:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015636:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801563a:	681b      	ldr	r3, [r3, #0]
 801563c:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8015640:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8015644:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015648:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801564c:	681b      	ldr	r3, [r3, #0]
 801564e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8015652:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015656:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801565a:	681b      	ldr	r3, [r3, #0]
 801565c:	699b      	ldr	r3, [r3, #24]
 801565e:	681b      	ldr	r3, [r3, #0]
 8015660:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 8015664:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015668:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801566c:	681b      	ldr	r3, [r3, #0]
 801566e:	699b      	ldr	r3, [r3, #24]
 8015670:	685b      	ldr	r3, [r3, #4]
 8015672:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 8015676:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801567a:	689d      	ldr	r5, [r3, #8]
 801567c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015680:	68dc      	ldr	r4, [r3, #12]
    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
 8015682:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015686:	691b      	ldr	r3, [r3, #16]
 8015688:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    /* There is always only one block per MCU */
    block = MCU_data[0];
 801568c:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015690:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 8015694:	681b      	ldr	r3, [r3, #0]
 8015696:	681b      	ldr	r3, [r3, #0]
 8015698:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tbl = entropy->ac_derived_tbl;
 801569c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80156a0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80156a2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
     * nonzero coefficients in the block, because otherwise we'd get confused
     * next time about which coefficients were already nonzero.
     * But we need not undo addition of bits to already-nonzero coefficients;
     * instead, we can test the current bit to see if we already did it.
     */
    num_newnz = 0;
 80156a6:	2300      	movs	r3, #0
 80156a8:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;
 80156ac:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80156b0:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80156b4:	681b      	ldr	r3, [r3, #0]
 80156b6:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80156ba:	607b      	str	r3, [r7, #4]

    if (EOBRUN == 0) {
 80156bc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80156c0:	2b00      	cmp	r3, #0
 80156c2:	f040 8138 	bne.w	8015936 <decode_mcu_AC_refine+0x3b6>
      for (; k <= Se; k++) {
 80156c6:	e12e      	b.n	8015926 <decode_mcu_AC_refine+0x3a6>
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
 80156c8:	2c07      	cmp	r4, #7
 80156ca:	dc12      	bgt.n	80156f2 <decode_mcu_AC_refine+0x172>
 80156cc:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 80156d0:	2300      	movs	r3, #0
 80156d2:	4622      	mov	r2, r4
 80156d4:	4629      	mov	r1, r5
 80156d6:	f7ff fb8f 	bl	8014df8 <jpeg_fill_bit_buffer>
 80156da:	4603      	mov	r3, r0
 80156dc:	2b00      	cmp	r3, #0
 80156de:	f000 81b8 	beq.w	8015a52 <decode_mcu_AC_refine+0x4d2>
 80156e2:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 80156e6:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
 80156ea:	2c07      	cmp	r4, #7
 80156ec:	dc01      	bgt.n	80156f2 <decode_mcu_AC_refine+0x172>
 80156ee:	2601      	movs	r6, #1
 80156f0:	e017      	b.n	8015722 <decode_mcu_AC_refine+0x1a2>
 80156f2:	f1a4 0308 	sub.w	r3, r4, #8
 80156f6:	fa45 f303 	asr.w	r3, r5, r3
 80156fa:	22ff      	movs	r2, #255	@ 0xff
 80156fc:	ea03 0802 	and.w	r8, r3, r2
 8015700:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8015704:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8015708:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
 801570c:	2e00      	cmp	r6, #0
 801570e:	d007      	beq.n	8015720 <decode_mcu_AC_refine+0x1a0>
 8015710:	1ba4      	subs	r4, r4, r6
 8015712:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8015716:	4443      	add	r3, r8
 8015718:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801571c:	603b      	str	r3, [r7, #0]
 801571e:	e012      	b.n	8015746 <decode_mcu_AC_refine+0x1c6>
 8015720:	2609      	movs	r6, #9
 8015722:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8015726:	9600      	str	r6, [sp, #0]
 8015728:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801572c:	4622      	mov	r2, r4
 801572e:	4629      	mov	r1, r5
 8015730:	f7ff fbe8 	bl	8014f04 <jpeg_huff_decode>
 8015734:	4603      	mov	r3, r0
 8015736:	603b      	str	r3, [r7, #0]
 8015738:	2b00      	cmp	r3, #0
 801573a:	f2c0 818a 	blt.w	8015a52 <decode_mcu_AC_refine+0x4d2>
 801573e:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8015742:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	r = s >> 4;
 8015746:	683b      	ldr	r3, [r7, #0]
 8015748:	111e      	asrs	r6, r3, #4
	s &= 15;
 801574a:	f003 030f 	and.w	r3, r3, #15
 801574e:	603b      	str	r3, [r7, #0]
	if (s) {
 8015750:	2b00      	cmp	r3, #0
 8015752:	d038      	beq.n	80157c6 <decode_mcu_AC_refine+0x246>
	  if (s != 1)		/* size of new coef should always be 1 */
 8015754:	2b01      	cmp	r3, #1
 8015756:	d016      	beq.n	8015786 <decode_mcu_AC_refine+0x206>
	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
 8015758:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801575c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015760:	681b      	ldr	r3, [r3, #0]
 8015762:	681b      	ldr	r3, [r3, #0]
 8015764:	2279      	movs	r2, #121	@ 0x79
 8015766:	615a      	str	r2, [r3, #20]
 8015768:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801576c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015770:	681b      	ldr	r3, [r3, #0]
 8015772:	681b      	ldr	r3, [r3, #0]
 8015774:	685b      	ldr	r3, [r3, #4]
 8015776:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 801577a:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801577e:	f04f 31ff 	mov.w	r1, #4294967295
 8015782:	6810      	ldr	r0, [r2, #0]
 8015784:	4798      	blx	r3
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8015786:	2c00      	cmp	r4, #0
 8015788:	dc0e      	bgt.n	80157a8 <decode_mcu_AC_refine+0x228>
 801578a:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 801578e:	2301      	movs	r3, #1
 8015790:	4622      	mov	r2, r4
 8015792:	4629      	mov	r1, r5
 8015794:	f7ff fb30 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015798:	4603      	mov	r3, r0
 801579a:	2b00      	cmp	r3, #0
 801579c:	f000 8159 	beq.w	8015a52 <decode_mcu_AC_refine+0x4d2>
 80157a0:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 80157a4:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	  if (GET_BITS(1))
 80157a8:	3c01      	subs	r4, #1
 80157aa:	fa45 f304 	asr.w	r3, r5, r4
 80157ae:	2201      	movs	r2, #1
 80157b0:	4013      	ands	r3, r2
 80157b2:	2b00      	cmp	r3, #0
 80157b4:	d003      	beq.n	80157be <decode_mcu_AC_refine+0x23e>
	    s = p1;		/* newly nonzero coef is positive */
 80157b6:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80157ba:	603b      	str	r3, [r7, #0]
 80157bc:	e02c      	b.n	8015818 <decode_mcu_AC_refine+0x298>
	  else
	    s = m1;		/* newly nonzero coef is negative */
 80157be:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80157c2:	603b      	str	r3, [r7, #0]
 80157c4:	e028      	b.n	8015818 <decode_mcu_AC_refine+0x298>
	} else {
	  if (r != 15) {
 80157c6:	2e0f      	cmp	r6, #15
 80157c8:	d026      	beq.n	8015818 <decode_mcu_AC_refine+0x298>
	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
 80157ca:	2301      	movs	r3, #1
 80157cc:	40b3      	lsls	r3, r6
 80157ce:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    if (r) {
 80157d2:	2e00      	cmp	r6, #0
 80157d4:	f000 80ae 	beq.w	8015934 <decode_mcu_AC_refine+0x3b4>
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
 80157d8:	42b4      	cmp	r4, r6
 80157da:	da0e      	bge.n	80157fa <decode_mcu_AC_refine+0x27a>
 80157dc:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 80157e0:	4633      	mov	r3, r6
 80157e2:	4622      	mov	r2, r4
 80157e4:	4629      	mov	r1, r5
 80157e6:	f7ff fb07 	bl	8014df8 <jpeg_fill_bit_buffer>
 80157ea:	4603      	mov	r3, r0
 80157ec:	2b00      	cmp	r3, #0
 80157ee:	f000 8130 	beq.w	8015a52 <decode_mcu_AC_refine+0x4d2>
 80157f2:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 80157f6:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	      r = GET_BITS(r);
 80157fa:	1ba4      	subs	r4, r4, r6
 80157fc:	fa45 f204 	asr.w	r2, r5, r4
 8015800:	4ba3      	ldr	r3, [pc, #652]	@ (8015a90 <decode_mcu_AC_refine+0x510>)
 8015802:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8015806:	ea02 0603 	and.w	r6, r2, r3
	      EOBRUN += r;
 801580a:	4632      	mov	r2, r6
 801580c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8015810:	4413      	add	r3, r2
 8015812:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    }
	    break;		/* rest of block is handled by EOB logic */
 8015816:	e08d      	b.n	8015934 <decode_mcu_AC_refine+0x3b4>
	/* Advance over already-nonzero coefs and r still-zero coefs,
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + natural_order[k];
 8015818:	687b      	ldr	r3, [r7, #4]
 801581a:	009b      	lsls	r3, r3, #2
 801581c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8015820:	4413      	add	r3, r2
 8015822:	681b      	ldr	r3, [r3, #0]
 8015824:	005b      	lsls	r3, r3, #1
 8015826:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801582a:	4413      	add	r3, r2
 801582c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
	  if (*thiscoef != 0) {
 8015830:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8015834:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015838:	2b00      	cmp	r3, #0
 801583a:	d045      	beq.n	80158c8 <decode_mcu_AC_refine+0x348>
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 801583c:	2c00      	cmp	r4, #0
 801583e:	dc0e      	bgt.n	801585e <decode_mcu_AC_refine+0x2de>
 8015840:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8015844:	2301      	movs	r3, #1
 8015846:	4622      	mov	r2, r4
 8015848:	4629      	mov	r1, r5
 801584a:	f7ff fad5 	bl	8014df8 <jpeg_fill_bit_buffer>
 801584e:	4603      	mov	r3, r0
 8015850:	2b00      	cmp	r3, #0
 8015852:	f000 80fe 	beq.w	8015a52 <decode_mcu_AC_refine+0x4d2>
 8015856:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 801585a:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	    if (GET_BITS(1)) {
 801585e:	3c01      	subs	r4, #1
 8015860:	fa45 f304 	asr.w	r3, r5, r4
 8015864:	2201      	movs	r2, #1
 8015866:	4013      	ands	r3, r2
 8015868:	2b00      	cmp	r3, #0
 801586a:	d030      	beq.n	80158ce <decode_mcu_AC_refine+0x34e>
	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
 801586c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8015870:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015874:	461a      	mov	r2, r3
 8015876:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801587a:	4013      	ands	r3, r2
 801587c:	2b00      	cmp	r3, #0
 801587e:	d126      	bne.n	80158ce <decode_mcu_AC_refine+0x34e>
		if (*thiscoef >= 0)
 8015880:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8015884:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015888:	2b00      	cmp	r3, #0
 801588a:	db0e      	blt.n	80158aa <decode_mcu_AC_refine+0x32a>
		  *thiscoef += p1;
 801588c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8015890:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015894:	b29a      	uxth	r2, r3
 8015896:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801589a:	b29b      	uxth	r3, r3
 801589c:	4413      	add	r3, r2
 801589e:	b29b      	uxth	r3, r3
 80158a0:	b21a      	sxth	r2, r3
 80158a2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80158a6:	801a      	strh	r2, [r3, #0]
 80158a8:	e011      	b.n	80158ce <decode_mcu_AC_refine+0x34e>
		else
		  *thiscoef += m1;
 80158aa:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80158ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 80158b2:	b29a      	uxth	r2, r3
 80158b4:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80158b8:	b29b      	uxth	r3, r3
 80158ba:	4413      	add	r3, r2
 80158bc:	b29b      	uxth	r3, r3
 80158be:	b21a      	sxth	r2, r3
 80158c0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80158c4:	801a      	strh	r2, [r3, #0]
 80158c6:	e002      	b.n	80158ce <decode_mcu_AC_refine+0x34e>
	      }
	    }
	  } else {
	    if (--r < 0)
 80158c8:	3e01      	subs	r6, #1
 80158ca:	2e00      	cmp	r6, #0
 80158cc:	db08      	blt.n	80158e0 <decode_mcu_AC_refine+0x360>
	      break;		/* reached target zero coefficient */
	  }
	  k++;
 80158ce:	687b      	ldr	r3, [r7, #4]
 80158d0:	3301      	adds	r3, #1
 80158d2:	461a      	mov	r2, r3
 80158d4:	607a      	str	r2, [r7, #4]
	} while (k <= Se);
 80158d6:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80158da:	429a      	cmp	r2, r3
 80158dc:	dd9c      	ble.n	8015818 <decode_mcu_AC_refine+0x298>
 80158de:	e000      	b.n	80158e2 <decode_mcu_AC_refine+0x362>
	      break;		/* reached target zero coefficient */
 80158e0:	bf00      	nop
	if (s) {
 80158e2:	6839      	ldr	r1, [r7, #0]
 80158e4:	2900      	cmp	r1, #0
 80158e6:	d01b      	beq.n	8015920 <decode_mcu_AC_refine+0x3a0>
	  int pos = natural_order[k];
 80158e8:	687b      	ldr	r3, [r7, #4]
 80158ea:	009b      	lsls	r3, r3, #2
 80158ec:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80158f0:	4413      	add	r3, r2
 80158f2:	681b      	ldr	r3, [r3, #0]
 80158f4:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
	  /* Output newly nonzero coefficient */
	  (*block)[pos] = (JCOEF) s;
 80158f8:	b209      	sxth	r1, r1
 80158fa:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80158fe:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8015902:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	  /* Remember its position in case we have to suspend */
	  newnz_pos[num_newnz++] = pos;
 8015906:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801590a:	1c5a      	adds	r2, r3, #1
 801590c:	f8c7 2148 	str.w	r2, [r7, #328]	@ 0x148
 8015910:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 8015914:	f5a2 72a0 	sub.w	r2, r2, #320	@ 0x140
 8015918:	f8d7 1124 	ldr.w	r1, [r7, #292]	@ 0x124
 801591c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      for (; k <= Se; k++) {
 8015920:	687b      	ldr	r3, [r7, #4]
 8015922:	3301      	adds	r3, #1
 8015924:	607b      	str	r3, [r7, #4]
 8015926:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801592a:	687a      	ldr	r2, [r7, #4]
 801592c:	429a      	cmp	r2, r3
 801592e:	f77f aecb 	ble.w	80156c8 <decode_mcu_AC_refine+0x148>
 8015932:	e000      	b.n	8015936 <decode_mcu_AC_refine+0x3b6>
	    break;		/* rest of block is handled by EOB logic */
 8015934:	bf00      	nop
	}
      }
    }

    if (EOBRUN > 0) {
 8015936:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801593a:	2b00      	cmp	r3, #0
 801593c:	d063      	beq.n	8015a06 <decode_mcu_AC_refine+0x486>
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
 801593e:	e058      	b.n	80159f2 <decode_mcu_AC_refine+0x472>
	thiscoef = *block + natural_order[k];
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	009b      	lsls	r3, r3, #2
 8015944:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8015948:	4413      	add	r3, r2
 801594a:	681b      	ldr	r3, [r3, #0]
 801594c:	005b      	lsls	r3, r3, #1
 801594e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8015952:	4413      	add	r3, r2
 8015954:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
	if (*thiscoef != 0) {
 8015958:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801595c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015960:	2b00      	cmp	r3, #0
 8015962:	d043      	beq.n	80159ec <decode_mcu_AC_refine+0x46c>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8015964:	2c00      	cmp	r4, #0
 8015966:	dc0d      	bgt.n	8015984 <decode_mcu_AC_refine+0x404>
 8015968:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 801596c:	2301      	movs	r3, #1
 801596e:	4622      	mov	r2, r4
 8015970:	4629      	mov	r1, r5
 8015972:	f7ff fa41 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015976:	4603      	mov	r3, r0
 8015978:	2b00      	cmp	r3, #0
 801597a:	d06a      	beq.n	8015a52 <decode_mcu_AC_refine+0x4d2>
 801597c:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8015980:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	  if (GET_BITS(1)) {
 8015984:	3c01      	subs	r4, #1
 8015986:	fa45 f304 	asr.w	r3, r5, r4
 801598a:	2201      	movs	r2, #1
 801598c:	4013      	ands	r3, r2
 801598e:	2b00      	cmp	r3, #0
 8015990:	d02c      	beq.n	80159ec <decode_mcu_AC_refine+0x46c>
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
 8015992:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8015996:	f9b3 3000 	ldrsh.w	r3, [r3]
 801599a:	461a      	mov	r2, r3
 801599c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80159a0:	4013      	ands	r3, r2
 80159a2:	2b00      	cmp	r3, #0
 80159a4:	d122      	bne.n	80159ec <decode_mcu_AC_refine+0x46c>
	      if (*thiscoef >= 0)
 80159a6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80159aa:	f9b3 3000 	ldrsh.w	r3, [r3]
 80159ae:	2b00      	cmp	r3, #0
 80159b0:	db0e      	blt.n	80159d0 <decode_mcu_AC_refine+0x450>
		*thiscoef += p1;
 80159b2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80159b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80159ba:	b29a      	uxth	r2, r3
 80159bc:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80159c0:	b29b      	uxth	r3, r3
 80159c2:	4413      	add	r3, r2
 80159c4:	b29b      	uxth	r3, r3
 80159c6:	b21a      	sxth	r2, r3
 80159c8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80159cc:	801a      	strh	r2, [r3, #0]
 80159ce:	e00d      	b.n	80159ec <decode_mcu_AC_refine+0x46c>
	      else
		*thiscoef += m1;
 80159d0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80159d4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80159d8:	b29a      	uxth	r2, r3
 80159da:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80159de:	b29b      	uxth	r3, r3
 80159e0:	4413      	add	r3, r2
 80159e2:	b29b      	uxth	r3, r3
 80159e4:	b21a      	sxth	r2, r3
 80159e6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80159ea:	801a      	strh	r2, [r3, #0]
      for (; k <= Se; k++) {
 80159ec:	687b      	ldr	r3, [r7, #4]
 80159ee:	3301      	adds	r3, #1
 80159f0:	607b      	str	r3, [r7, #4]
 80159f2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80159f6:	687a      	ldr	r2, [r7, #4]
 80159f8:	429a      	cmp	r2, r3
 80159fa:	dda1      	ble.n	8015940 <decode_mcu_AC_refine+0x3c0>
	    }
	  }
	}
      }
      /* Count one block completed in EOB run */
      EOBRUN--;
 80159fc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8015a00:	3b01      	subs	r3, #1
 8015a02:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8015a06:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015a0a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015a0e:	681b      	ldr	r3, [r3, #0]
 8015a10:	699b      	ldr	r3, [r3, #24]
 8015a12:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8015a16:	601a      	str	r2, [r3, #0]
 8015a18:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015a1c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8015a20:	681b      	ldr	r3, [r3, #0]
 8015a22:	699b      	ldr	r3, [r3, #24]
 8015a24:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8015a28:	605a      	str	r2, [r3, #4]
 8015a2a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015a2e:	609d      	str	r5, [r3, #8]
 8015a30:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015a34:	60dc      	str	r4, [r3, #12]
    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
 8015a36:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015a3a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8015a3e:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8015a40:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015a44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015a46:	1e5a      	subs	r2, r3, #1
 8015a48:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8015a4c:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8015a4e:	2301      	movs	r3, #1
 8015a50:	e017      	b.n	8015a82 <decode_mcu_AC_refine+0x502>

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
 8015a52:	e011      	b.n	8015a78 <decode_mcu_AC_refine+0x4f8>
    (*block)[newnz_pos[--num_newnz]] = 0;
 8015a54:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8015a58:	3b01      	subs	r3, #1
 8015a5a:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 8015a5e:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8015a62:	f5a3 73a0 	sub.w	r3, r3, #320	@ 0x140
 8015a66:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8015a6a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8015a6e:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8015a72:	2100      	movs	r1, #0
 8015a74:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  while (num_newnz > 0)
 8015a78:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8015a7c:	2b00      	cmp	r3, #0
 8015a7e:	dce9      	bgt.n	8015a54 <decode_mcu_AC_refine+0x4d4>

  return FALSE;
 8015a80:	2300      	movs	r3, #0
}
 8015a82:	4618      	mov	r0, r3
 8015a84:	f507 77a8 	add.w	r7, r7, #336	@ 0x150
 8015a88:	46bd      	mov	sp, r7
 8015a8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015a8e:	bf00      	nop
 8015a90:	08030554 	.word	0x08030554

08015a94 <decode_mcu_sub>:
 * partial blocks.
 */

METHODDEF(boolean)
decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8015a94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015a98:	b097      	sub	sp, #92	@ 0x5c
 8015a9a:	af02      	add	r7, sp, #8
 8015a9c:	6078      	str	r0, [r7, #4]
 8015a9e:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8015aa0:	687b      	ldr	r3, [r7, #4]
 8015aa2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8015aa6:	64bb      	str	r3, [r7, #72]	@ 0x48
  int Se, blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8015aa8:	687b      	ldr	r3, [r7, #4]
 8015aaa:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8015aae:	2b00      	cmp	r3, #0
 8015ab0:	d00b      	beq.n	8015aca <decode_mcu_sub+0x36>
    if (entropy->restarts_to_go == 0)
 8015ab2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015ab4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015ab6:	2b00      	cmp	r3, #0
 8015ab8:	d107      	bne.n	8015aca <decode_mcu_sub+0x36>
      if (! process_restart(cinfo))
 8015aba:	6878      	ldr	r0, [r7, #4]
 8015abc:	f7ff fa86 	bl	8014fcc <process_restart>
 8015ac0:	4603      	mov	r3, r0
 8015ac2:	2b00      	cmp	r3, #0
 8015ac4:	d101      	bne.n	8015aca <decode_mcu_sub+0x36>
	return FALSE;
 8015ac6:	2300      	movs	r3, #0
 8015ac8:	e1d2      	b.n	8015e70 <decode_mcu_sub+0x3dc>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8015aca:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015acc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015ace:	2b00      	cmp	r3, #0
 8015ad0:	f040 81c8 	bne.w	8015e64 <decode_mcu_sub+0x3d0>

    natural_order = cinfo->natural_order;
 8015ad4:	687b      	ldr	r3, [r7, #4]
 8015ad6:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8015ada:	647b      	str	r3, [r7, #68]	@ 0x44
    Se = cinfo->lim_Se;
 8015adc:	687b      	ldr	r3, [r7, #4]
 8015ade:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8015ae2:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8015ae4:	687b      	ldr	r3, [r7, #4]
 8015ae6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8015ae8:	687b      	ldr	r3, [r7, #4]
 8015aea:	699b      	ldr	r3, [r3, #24]
 8015aec:	681b      	ldr	r3, [r3, #0]
 8015aee:	61fb      	str	r3, [r7, #28]
 8015af0:	687b      	ldr	r3, [r7, #4]
 8015af2:	699b      	ldr	r3, [r3, #24]
 8015af4:	685b      	ldr	r3, [r3, #4]
 8015af6:	623b      	str	r3, [r7, #32]
 8015af8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015afa:	689e      	ldr	r6, [r3, #8]
 8015afc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015afe:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 8015b00:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015b02:	f107 0508 	add.w	r5, r7, #8
 8015b06:	f103 0c10 	add.w	ip, r3, #16
 8015b0a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015b0e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8015b10:	f8dc 3000 	ldr.w	r3, [ip]
 8015b14:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8015b16:	2300      	movs	r3, #0
 8015b18:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8015b1a:	e187      	b.n	8015e2c <decode_mcu_sub+0x398>
      JBLOCKROW block = MCU_data[blkn];
 8015b1c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015b1e:	009b      	lsls	r3, r3, #2
 8015b20:	683a      	ldr	r2, [r7, #0]
 8015b22:	4413      	add	r3, r2
 8015b24:	681b      	ldr	r3, [r3, #0]
 8015b26:	63fb      	str	r3, [r7, #60]	@ 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 8015b28:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015b2a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015b2c:	3218      	adds	r2, #24
 8015b2e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015b32:	63bb      	str	r3, [r7, #56]	@ 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 8015b34:	2c07      	cmp	r4, #7
 8015b36:	dc11      	bgt.n	8015b5c <decode_mcu_sub+0xc8>
 8015b38:	f107 001c 	add.w	r0, r7, #28
 8015b3c:	2300      	movs	r3, #0
 8015b3e:	4622      	mov	r2, r4
 8015b40:	4631      	mov	r1, r6
 8015b42:	f7ff f959 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015b46:	4603      	mov	r3, r0
 8015b48:	2b00      	cmp	r3, #0
 8015b4a:	d101      	bne.n	8015b50 <decode_mcu_sub+0xbc>
 8015b4c:	2300      	movs	r3, #0
 8015b4e:	e18f      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015b50:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015b52:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8015b54:	2c07      	cmp	r4, #7
 8015b56:	dc01      	bgt.n	8015b5c <decode_mcu_sub+0xc8>
 8015b58:	2501      	movs	r5, #1
 8015b5a:	e015      	b.n	8015b88 <decode_mcu_sub+0xf4>
 8015b5c:	f1a4 0308 	sub.w	r3, r4, #8
 8015b60:	fa46 f303 	asr.w	r3, r6, r3
 8015b64:	22ff      	movs	r2, #255	@ 0xff
 8015b66:	ea03 0802 	and.w	r8, r3, r2
 8015b6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015b6c:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8015b70:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8015b74:	2d00      	cmp	r5, #0
 8015b76:	d006      	beq.n	8015b86 <decode_mcu_sub+0xf2>
 8015b78:	1b64      	subs	r4, r4, r5
 8015b7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015b7c:	4443      	add	r3, r8
 8015b7e:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8015b82:	461d      	mov	r5, r3
 8015b84:	e00f      	b.n	8015ba6 <decode_mcu_sub+0x112>
 8015b86:	2509      	movs	r5, #9
 8015b88:	f107 001c 	add.w	r0, r7, #28
 8015b8c:	9500      	str	r5, [sp, #0]
 8015b8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015b90:	4622      	mov	r2, r4
 8015b92:	4631      	mov	r1, r6
 8015b94:	f7ff f9b6 	bl	8014f04 <jpeg_huff_decode>
 8015b98:	4605      	mov	r5, r0
 8015b9a:	2d00      	cmp	r5, #0
 8015b9c:	da01      	bge.n	8015ba2 <decode_mcu_sub+0x10e>
 8015b9e:	2300      	movs	r3, #0
 8015ba0:	e166      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015ba2:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015ba4:	6abc      	ldr	r4, [r7, #40]	@ 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 8015ba6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015ba8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015baa:	3222      	adds	r2, #34	@ 0x22
 8015bac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015bb0:	63bb      	str	r3, [r7, #56]	@ 0x38
      k = 1;
 8015bb2:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 8015bb6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015bb8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015bba:	322c      	adds	r2, #44	@ 0x2c
 8015bbc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015bc0:	637b      	str	r3, [r7, #52]	@ 0x34
      if (coef_limit) {
 8015bc2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015bc4:	2b00      	cmp	r3, #0
 8015bc6:	f000 80ba 	beq.w	8015d3e <decode_mcu_sub+0x2aa>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 8015bca:	2d00      	cmp	r5, #0
 8015bcc:	d025      	beq.n	8015c1a <decode_mcu_sub+0x186>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015bce:	42ac      	cmp	r4, r5
 8015bd0:	da0d      	bge.n	8015bee <decode_mcu_sub+0x15a>
 8015bd2:	f107 001c 	add.w	r0, r7, #28
 8015bd6:	462b      	mov	r3, r5
 8015bd8:	4622      	mov	r2, r4
 8015bda:	4631      	mov	r1, r6
 8015bdc:	f7ff f90c 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015be0:	4603      	mov	r3, r0
 8015be2:	2b00      	cmp	r3, #0
 8015be4:	d101      	bne.n	8015bea <decode_mcu_sub+0x156>
 8015be6:	2300      	movs	r3, #0
 8015be8:	e142      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015bea:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015bec:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  r = GET_BITS(s);
 8015bee:	1b64      	subs	r4, r4, r5
 8015bf0:	fa46 f204 	asr.w	r2, r6, r4
 8015bf4:	4ba1      	ldr	r3, [pc, #644]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015bf6:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015bfa:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 8015bfe:	1e6b      	subs	r3, r5, #1
 8015c00:	4a9e      	ldr	r2, [pc, #632]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015c02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015c06:	4599      	cmp	r9, r3
 8015c08:	dc05      	bgt.n	8015c16 <decode_mcu_sub+0x182>
 8015c0a:	4b9c      	ldr	r3, [pc, #624]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015c0c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015c10:	eba9 0303 	sub.w	r3, r9, r3
 8015c14:	e000      	b.n	8015c18 <decode_mcu_sub+0x184>
 8015c16:	464b      	mov	r3, r9
 8015c18:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 8015c1a:	687b      	ldr	r3, [r7, #4]
 8015c1c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015c1e:	325c      	adds	r2, #92	@ 0x5c
 8015c20:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015c24:	633b      	str	r3, [r7, #48]	@ 0x30
	s += state.last_dc_val[ci];
 8015c26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015c28:	009b      	lsls	r3, r3, #2
 8015c2a:	3350      	adds	r3, #80	@ 0x50
 8015c2c:	443b      	add	r3, r7
 8015c2e:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8015c32:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 8015c34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015c36:	009b      	lsls	r3, r3, #2
 8015c38:	3350      	adds	r3, #80	@ 0x50
 8015c3a:	443b      	add	r3, r7
 8015c3c:	f843 5c44 	str.w	r5, [r3, #-68]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 8015c40:	b22a      	sxth	r2, r5
 8015c42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015c44:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 8015c46:	e076      	b.n	8015d36 <decode_mcu_sub+0x2a2>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8015c48:	2c07      	cmp	r4, #7
 8015c4a:	dc11      	bgt.n	8015c70 <decode_mcu_sub+0x1dc>
 8015c4c:	f107 001c 	add.w	r0, r7, #28
 8015c50:	2300      	movs	r3, #0
 8015c52:	4622      	mov	r2, r4
 8015c54:	4631      	mov	r1, r6
 8015c56:	f7ff f8cf 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015c5a:	4603      	mov	r3, r0
 8015c5c:	2b00      	cmp	r3, #0
 8015c5e:	d101      	bne.n	8015c64 <decode_mcu_sub+0x1d0>
 8015c60:	2300      	movs	r3, #0
 8015c62:	e105      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015c64:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015c66:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8015c68:	2c07      	cmp	r4, #7
 8015c6a:	dc01      	bgt.n	8015c70 <decode_mcu_sub+0x1dc>
 8015c6c:	2501      	movs	r5, #1
 8015c6e:	e015      	b.n	8015c9c <decode_mcu_sub+0x208>
 8015c70:	f1a4 0308 	sub.w	r3, r4, #8
 8015c74:	fa46 f303 	asr.w	r3, r6, r3
 8015c78:	22ff      	movs	r2, #255	@ 0xff
 8015c7a:	ea03 0902 	and.w	r9, r3, r2
 8015c7e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c80:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 8015c84:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8015c88:	2d00      	cmp	r5, #0
 8015c8a:	d006      	beq.n	8015c9a <decode_mcu_sub+0x206>
 8015c8c:	1b64      	subs	r4, r4, r5
 8015c8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c90:	444b      	add	r3, r9
 8015c92:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8015c96:	461d      	mov	r5, r3
 8015c98:	e00f      	b.n	8015cba <decode_mcu_sub+0x226>
 8015c9a:	2509      	movs	r5, #9
 8015c9c:	f107 001c 	add.w	r0, r7, #28
 8015ca0:	9500      	str	r5, [sp, #0]
 8015ca2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015ca4:	4622      	mov	r2, r4
 8015ca6:	4631      	mov	r1, r6
 8015ca8:	f7ff f92c 	bl	8014f04 <jpeg_huff_decode>
 8015cac:	4605      	mov	r5, r0
 8015cae:	2d00      	cmp	r5, #0
 8015cb0:	da01      	bge.n	8015cb6 <decode_mcu_sub+0x222>
 8015cb2:	2300      	movs	r3, #0
 8015cb4:	e0dc      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015cb6:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015cb8:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	  r = s >> 4;
 8015cba:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 8015cbe:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 8015cc2:	2d00      	cmp	r5, #0
 8015cc4:	d030      	beq.n	8015d28 <decode_mcu_sub+0x294>
	    k += r;
 8015cc6:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015cc8:	42ac      	cmp	r4, r5
 8015cca:	da0d      	bge.n	8015ce8 <decode_mcu_sub+0x254>
 8015ccc:	f107 001c 	add.w	r0, r7, #28
 8015cd0:	462b      	mov	r3, r5
 8015cd2:	4622      	mov	r2, r4
 8015cd4:	4631      	mov	r1, r6
 8015cd6:	f7ff f88f 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015cda:	4603      	mov	r3, r0
 8015cdc:	2b00      	cmp	r3, #0
 8015cde:	d101      	bne.n	8015ce4 <decode_mcu_sub+0x250>
 8015ce0:	2300      	movs	r3, #0
 8015ce2:	e0c5      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015ce4:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015ce6:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	    r = GET_BITS(s);
 8015ce8:	1b64      	subs	r4, r4, r5
 8015cea:	fa46 f204 	asr.w	r2, r6, r4
 8015cee:	4b63      	ldr	r3, [pc, #396]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015cf0:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015cf4:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 8015cf8:	1e6b      	subs	r3, r5, #1
 8015cfa:	4a60      	ldr	r2, [pc, #384]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015d00:	4599      	cmp	r9, r3
 8015d02:	dc05      	bgt.n	8015d10 <decode_mcu_sub+0x27c>
 8015d04:	4b5d      	ldr	r3, [pc, #372]	@ (8015e7c <decode_mcu_sub+0x3e8>)
 8015d06:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015d0a:	eba9 0303 	sub.w	r3, r9, r3
 8015d0e:	e000      	b.n	8015d12 <decode_mcu_sub+0x27e>
 8015d10:	464b      	mov	r3, r9
 8015d12:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in natural_order[] will save us
	     * if k > Se, which could happen if the data is corrupted.
	     */
	    (*block)[natural_order[k]] = (JCOEF) s;
 8015d14:	4643      	mov	r3, r8
 8015d16:	009b      	lsls	r3, r3, #2
 8015d18:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015d1a:	4413      	add	r3, r2
 8015d1c:	681a      	ldr	r2, [r3, #0]
 8015d1e:	b229      	sxth	r1, r5
 8015d20:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d22:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 8015d26:	e004      	b.n	8015d32 <decode_mcu_sub+0x29e>
	  } else {
	    if (r != 15)
 8015d28:	f1b9 0f0f 	cmp.w	r9, #15
 8015d2c:	d178      	bne.n	8015e20 <decode_mcu_sub+0x38c>
	      goto EndOfBlock;
	    k += 15;
 8015d2e:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 8015d32:	f108 0801 	add.w	r8, r8, #1
 8015d36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015d38:	4598      	cmp	r8, r3
 8015d3a:	db85      	blt.n	8015c48 <decode_mcu_sub+0x1b4>
 8015d3c:	e06c      	b.n	8015e18 <decode_mcu_sub+0x384>
	  }
	}
      } else {
	if (s) {
 8015d3e:	2d00      	cmp	r5, #0
 8015d40:	d06a      	beq.n	8015e18 <decode_mcu_sub+0x384>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015d42:	42ac      	cmp	r4, r5
 8015d44:	da0d      	bge.n	8015d62 <decode_mcu_sub+0x2ce>
 8015d46:	f107 001c 	add.w	r0, r7, #28
 8015d4a:	462b      	mov	r3, r5
 8015d4c:	4622      	mov	r2, r4
 8015d4e:	4631      	mov	r1, r6
 8015d50:	f7ff f852 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015d54:	4603      	mov	r3, r0
 8015d56:	2b00      	cmp	r3, #0
 8015d58:	d101      	bne.n	8015d5e <decode_mcu_sub+0x2ca>
 8015d5a:	2300      	movs	r3, #0
 8015d5c:	e088      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015d5e:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015d60:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 8015d62:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k <= Se; k++) {
 8015d64:	e058      	b.n	8015e18 <decode_mcu_sub+0x384>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 8015d66:	2c07      	cmp	r4, #7
 8015d68:	dc11      	bgt.n	8015d8e <decode_mcu_sub+0x2fa>
 8015d6a:	f107 001c 	add.w	r0, r7, #28
 8015d6e:	2300      	movs	r3, #0
 8015d70:	4622      	mov	r2, r4
 8015d72:	4631      	mov	r1, r6
 8015d74:	f7ff f840 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015d78:	4603      	mov	r3, r0
 8015d7a:	2b00      	cmp	r3, #0
 8015d7c:	d101      	bne.n	8015d82 <decode_mcu_sub+0x2ee>
 8015d7e:	2300      	movs	r3, #0
 8015d80:	e076      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015d82:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015d84:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8015d86:	2c07      	cmp	r4, #7
 8015d88:	dc01      	bgt.n	8015d8e <decode_mcu_sub+0x2fa>
 8015d8a:	2501      	movs	r5, #1
 8015d8c:	e015      	b.n	8015dba <decode_mcu_sub+0x326>
 8015d8e:	f1a4 0308 	sub.w	r3, r4, #8
 8015d92:	fa46 f303 	asr.w	r3, r6, r3
 8015d96:	22ff      	movs	r2, #255	@ 0xff
 8015d98:	ea03 0902 	and.w	r9, r3, r2
 8015d9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d9e:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 8015da2:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8015da6:	2d00      	cmp	r5, #0
 8015da8:	d006      	beq.n	8015db8 <decode_mcu_sub+0x324>
 8015daa:	1b64      	subs	r4, r4, r5
 8015dac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dae:	444b      	add	r3, r9
 8015db0:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8015db4:	461d      	mov	r5, r3
 8015db6:	e00f      	b.n	8015dd8 <decode_mcu_sub+0x344>
 8015db8:	2509      	movs	r5, #9
 8015dba:	f107 001c 	add.w	r0, r7, #28
 8015dbe:	9500      	str	r5, [sp, #0]
 8015dc0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dc2:	4622      	mov	r2, r4
 8015dc4:	4631      	mov	r1, r6
 8015dc6:	f7ff f89d 	bl	8014f04 <jpeg_huff_decode>
 8015dca:	4605      	mov	r5, r0
 8015dcc:	2d00      	cmp	r5, #0
 8015dce:	da01      	bge.n	8015dd4 <decode_mcu_sub+0x340>
 8015dd0:	2300      	movs	r3, #0
 8015dd2:	e04d      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015dd4:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015dd6:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	r = s >> 4;
 8015dd8:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 8015ddc:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 8015de0:	2d00      	cmp	r5, #0
 8015de2:	d012      	beq.n	8015e0a <decode_mcu_sub+0x376>
	  k += r;
 8015de4:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015de6:	42ac      	cmp	r4, r5
 8015de8:	da0d      	bge.n	8015e06 <decode_mcu_sub+0x372>
 8015dea:	f107 001c 	add.w	r0, r7, #28
 8015dee:	462b      	mov	r3, r5
 8015df0:	4622      	mov	r2, r4
 8015df2:	4631      	mov	r1, r6
 8015df4:	f7ff f800 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015df8:	4603      	mov	r3, r0
 8015dfa:	2b00      	cmp	r3, #0
 8015dfc:	d101      	bne.n	8015e02 <decode_mcu_sub+0x36e>
 8015dfe:	2300      	movs	r3, #0
 8015e00:	e036      	b.n	8015e70 <decode_mcu_sub+0x3dc>
 8015e02:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015e04:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 8015e06:	1b64      	subs	r4, r4, r5
 8015e08:	e004      	b.n	8015e14 <decode_mcu_sub+0x380>
	} else {
	  if (r != 15)
 8015e0a:	f1b9 0f0f 	cmp.w	r9, #15
 8015e0e:	d109      	bne.n	8015e24 <decode_mcu_sub+0x390>
	    break;
	  k += 15;
 8015e10:	f108 080f 	add.w	r8, r8, #15
      for (; k <= Se; k++) {
 8015e14:	f108 0801 	add.w	r8, r8, #1
 8015e18:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015e1a:	4598      	cmp	r8, r3
 8015e1c:	dda3      	ble.n	8015d66 <decode_mcu_sub+0x2d2>
	}
      }

      EndOfBlock: ;
 8015e1e:	e002      	b.n	8015e26 <decode_mcu_sub+0x392>
	      goto EndOfBlock;
 8015e20:	bf00      	nop
 8015e22:	e000      	b.n	8015e26 <decode_mcu_sub+0x392>
	    break;
 8015e24:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8015e26:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015e28:	3301      	adds	r3, #1
 8015e2a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8015e2c:	687b      	ldr	r3, [r7, #4]
 8015e2e:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8015e32:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8015e34:	429a      	cmp	r2, r3
 8015e36:	f6ff ae71 	blt.w	8015b1c <decode_mcu_sub+0x88>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8015e3a:	687b      	ldr	r3, [r7, #4]
 8015e3c:	699b      	ldr	r3, [r3, #24]
 8015e3e:	69fa      	ldr	r2, [r7, #28]
 8015e40:	601a      	str	r2, [r3, #0]
 8015e42:	687b      	ldr	r3, [r7, #4]
 8015e44:	699b      	ldr	r3, [r3, #24]
 8015e46:	6a3a      	ldr	r2, [r7, #32]
 8015e48:	605a      	str	r2, [r3, #4]
 8015e4a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015e4c:	609e      	str	r6, [r3, #8]
 8015e4e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015e50:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 8015e52:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015e54:	f103 0410 	add.w	r4, r3, #16
 8015e58:	f107 0508 	add.w	r5, r7, #8
 8015e5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015e5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015e60:	682b      	ldr	r3, [r5, #0]
 8015e62:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8015e64:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015e66:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015e68:	1e5a      	subs	r2, r3, #1
 8015e6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015e6c:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8015e6e:	2301      	movs	r3, #1
}
 8015e70:	4618      	mov	r0, r3
 8015e72:	3754      	adds	r7, #84	@ 0x54
 8015e74:	46bd      	mov	sp, r7
 8015e76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015e7a:	bf00      	nop
 8015e7c:	08030554 	.word	0x08030554

08015e80 <decode_mcu>:
 * full-size blocks.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8015e80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015e84:	b095      	sub	sp, #84	@ 0x54
 8015e86:	af02      	add	r7, sp, #8
 8015e88:	6078      	str	r0, [r7, #4]
 8015e8a:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8015e8c:	687b      	ldr	r3, [r7, #4]
 8015e8e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8015e92:	643b      	str	r3, [r7, #64]	@ 0x40
  int blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8015e94:	687b      	ldr	r3, [r7, #4]
 8015e96:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8015e9a:	2b00      	cmp	r3, #0
 8015e9c:	d00b      	beq.n	8015eb6 <decode_mcu+0x36>
    if (entropy->restarts_to_go == 0)
 8015e9e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015ea0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015ea2:	2b00      	cmp	r3, #0
 8015ea4:	d107      	bne.n	8015eb6 <decode_mcu+0x36>
      if (! process_restart(cinfo))
 8015ea6:	6878      	ldr	r0, [r7, #4]
 8015ea8:	f7ff f890 	bl	8014fcc <process_restart>
 8015eac:	4603      	mov	r3, r0
 8015eae:	2b00      	cmp	r3, #0
 8015eb0:	d101      	bne.n	8015eb6 <decode_mcu+0x36>
	return FALSE;
 8015eb2:	2300      	movs	r3, #0
 8015eb4:	e1c8      	b.n	8016248 <decode_mcu+0x3c8>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8015eb6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015eb8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015eba:	2b00      	cmp	r3, #0
 8015ebc:	f040 81be 	bne.w	801623c <decode_mcu+0x3bc>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8015ec0:	687b      	ldr	r3, [r7, #4]
 8015ec2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8015ec4:	687b      	ldr	r3, [r7, #4]
 8015ec6:	699b      	ldr	r3, [r3, #24]
 8015ec8:	681b      	ldr	r3, [r3, #0]
 8015eca:	61fb      	str	r3, [r7, #28]
 8015ecc:	687b      	ldr	r3, [r7, #4]
 8015ece:	699b      	ldr	r3, [r3, #24]
 8015ed0:	685b      	ldr	r3, [r3, #4]
 8015ed2:	623b      	str	r3, [r7, #32]
 8015ed4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015ed6:	689e      	ldr	r6, [r3, #8]
 8015ed8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015eda:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 8015edc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015ede:	f107 0508 	add.w	r5, r7, #8
 8015ee2:	f103 0c10 	add.w	ip, r3, #16
 8015ee6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015eea:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8015eec:	f8dc 3000 	ldr.w	r3, [ip]
 8015ef0:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8015ef2:	2300      	movs	r3, #0
 8015ef4:	647b      	str	r3, [r7, #68]	@ 0x44
 8015ef6:	e185      	b.n	8016204 <decode_mcu+0x384>
      JBLOCKROW block = MCU_data[blkn];
 8015ef8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015efa:	009b      	lsls	r3, r3, #2
 8015efc:	683a      	ldr	r2, [r7, #0]
 8015efe:	4413      	add	r3, r2
 8015f00:	681b      	ldr	r3, [r3, #0]
 8015f02:	63fb      	str	r3, [r7, #60]	@ 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 8015f04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015f06:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015f08:	3218      	adds	r2, #24
 8015f0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015f0e:	63bb      	str	r3, [r7, #56]	@ 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 8015f10:	2c07      	cmp	r4, #7
 8015f12:	dc11      	bgt.n	8015f38 <decode_mcu+0xb8>
 8015f14:	f107 001c 	add.w	r0, r7, #28
 8015f18:	2300      	movs	r3, #0
 8015f1a:	4622      	mov	r2, r4
 8015f1c:	4631      	mov	r1, r6
 8015f1e:	f7fe ff6b 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015f22:	4603      	mov	r3, r0
 8015f24:	2b00      	cmp	r3, #0
 8015f26:	d101      	bne.n	8015f2c <decode_mcu+0xac>
 8015f28:	2300      	movs	r3, #0
 8015f2a:	e18d      	b.n	8016248 <decode_mcu+0x3c8>
 8015f2c:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015f2e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8015f30:	2c07      	cmp	r4, #7
 8015f32:	dc01      	bgt.n	8015f38 <decode_mcu+0xb8>
 8015f34:	2501      	movs	r5, #1
 8015f36:	e015      	b.n	8015f64 <decode_mcu+0xe4>
 8015f38:	f1a4 0308 	sub.w	r3, r4, #8
 8015f3c:	fa46 f303 	asr.w	r3, r6, r3
 8015f40:	22ff      	movs	r2, #255	@ 0xff
 8015f42:	ea03 0802 	and.w	r8, r3, r2
 8015f46:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f48:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8015f4c:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8015f50:	2d00      	cmp	r5, #0
 8015f52:	d006      	beq.n	8015f62 <decode_mcu+0xe2>
 8015f54:	1b64      	subs	r4, r4, r5
 8015f56:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f58:	4443      	add	r3, r8
 8015f5a:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8015f5e:	461d      	mov	r5, r3
 8015f60:	e00f      	b.n	8015f82 <decode_mcu+0x102>
 8015f62:	2509      	movs	r5, #9
 8015f64:	f107 001c 	add.w	r0, r7, #28
 8015f68:	9500      	str	r5, [sp, #0]
 8015f6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f6c:	4622      	mov	r2, r4
 8015f6e:	4631      	mov	r1, r6
 8015f70:	f7fe ffc8 	bl	8014f04 <jpeg_huff_decode>
 8015f74:	4605      	mov	r5, r0
 8015f76:	2d00      	cmp	r5, #0
 8015f78:	da01      	bge.n	8015f7e <decode_mcu+0xfe>
 8015f7a:	2300      	movs	r3, #0
 8015f7c:	e164      	b.n	8016248 <decode_mcu+0x3c8>
 8015f7e:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015f80:	6abc      	ldr	r4, [r7, #40]	@ 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 8015f82:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015f84:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015f86:	3222      	adds	r2, #34	@ 0x22
 8015f88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015f8c:	63bb      	str	r3, [r7, #56]	@ 0x38
      k = 1;
 8015f8e:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 8015f92:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015f94:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015f96:	322c      	adds	r2, #44	@ 0x2c
 8015f98:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015f9c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (coef_limit) {
 8015f9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015fa0:	2b00      	cmp	r3, #0
 8015fa2:	f000 80b8 	beq.w	8016116 <decode_mcu+0x296>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 8015fa6:	2d00      	cmp	r5, #0
 8015fa8:	d025      	beq.n	8015ff6 <decode_mcu+0x176>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8015faa:	42ac      	cmp	r4, r5
 8015fac:	da0d      	bge.n	8015fca <decode_mcu+0x14a>
 8015fae:	f107 001c 	add.w	r0, r7, #28
 8015fb2:	462b      	mov	r3, r5
 8015fb4:	4622      	mov	r2, r4
 8015fb6:	4631      	mov	r1, r6
 8015fb8:	f7fe ff1e 	bl	8014df8 <jpeg_fill_bit_buffer>
 8015fbc:	4603      	mov	r3, r0
 8015fbe:	2b00      	cmp	r3, #0
 8015fc0:	d101      	bne.n	8015fc6 <decode_mcu+0x146>
 8015fc2:	2300      	movs	r3, #0
 8015fc4:	e140      	b.n	8016248 <decode_mcu+0x3c8>
 8015fc6:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8015fc8:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  r = GET_BITS(s);
 8015fca:	1b64      	subs	r4, r4, r5
 8015fcc:	fa46 f204 	asr.w	r2, r6, r4
 8015fd0:	4ba0      	ldr	r3, [pc, #640]	@ (8016254 <decode_mcu+0x3d4>)
 8015fd2:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015fd6:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 8015fda:	1e6b      	subs	r3, r5, #1
 8015fdc:	4a9d      	ldr	r2, [pc, #628]	@ (8016254 <decode_mcu+0x3d4>)
 8015fde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015fe2:	4599      	cmp	r9, r3
 8015fe4:	dc05      	bgt.n	8015ff2 <decode_mcu+0x172>
 8015fe6:	4b9b      	ldr	r3, [pc, #620]	@ (8016254 <decode_mcu+0x3d4>)
 8015fe8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8015fec:	eba9 0303 	sub.w	r3, r9, r3
 8015ff0:	e000      	b.n	8015ff4 <decode_mcu+0x174>
 8015ff2:	464b      	mov	r3, r9
 8015ff4:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 8015ff6:	687b      	ldr	r3, [r7, #4]
 8015ff8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015ffa:	325c      	adds	r2, #92	@ 0x5c
 8015ffc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016000:	633b      	str	r3, [r7, #48]	@ 0x30
	s += state.last_dc_val[ci];
 8016002:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016004:	009b      	lsls	r3, r3, #2
 8016006:	3348      	adds	r3, #72	@ 0x48
 8016008:	443b      	add	r3, r7
 801600a:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 801600e:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 8016010:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016012:	009b      	lsls	r3, r3, #2
 8016014:	3348      	adds	r3, #72	@ 0x48
 8016016:	443b      	add	r3, r7
 8016018:	f843 5c3c 	str.w	r5, [r3, #-60]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 801601c:	b22a      	sxth	r2, r5
 801601e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016020:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 8016022:	e074      	b.n	801610e <decode_mcu+0x28e>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8016024:	2c07      	cmp	r4, #7
 8016026:	dc11      	bgt.n	801604c <decode_mcu+0x1cc>
 8016028:	f107 001c 	add.w	r0, r7, #28
 801602c:	2300      	movs	r3, #0
 801602e:	4622      	mov	r2, r4
 8016030:	4631      	mov	r1, r6
 8016032:	f7fe fee1 	bl	8014df8 <jpeg_fill_bit_buffer>
 8016036:	4603      	mov	r3, r0
 8016038:	2b00      	cmp	r3, #0
 801603a:	d101      	bne.n	8016040 <decode_mcu+0x1c0>
 801603c:	2300      	movs	r3, #0
 801603e:	e103      	b.n	8016248 <decode_mcu+0x3c8>
 8016040:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8016042:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8016044:	2c07      	cmp	r4, #7
 8016046:	dc01      	bgt.n	801604c <decode_mcu+0x1cc>
 8016048:	2501      	movs	r5, #1
 801604a:	e015      	b.n	8016078 <decode_mcu+0x1f8>
 801604c:	f1a4 0308 	sub.w	r3, r4, #8
 8016050:	fa46 f303 	asr.w	r3, r6, r3
 8016054:	22ff      	movs	r2, #255	@ 0xff
 8016056:	ea03 0902 	and.w	r9, r3, r2
 801605a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801605c:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 8016060:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8016064:	2d00      	cmp	r5, #0
 8016066:	d006      	beq.n	8016076 <decode_mcu+0x1f6>
 8016068:	1b64      	subs	r4, r4, r5
 801606a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801606c:	444b      	add	r3, r9
 801606e:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8016072:	461d      	mov	r5, r3
 8016074:	e00f      	b.n	8016096 <decode_mcu+0x216>
 8016076:	2509      	movs	r5, #9
 8016078:	f107 001c 	add.w	r0, r7, #28
 801607c:	9500      	str	r5, [sp, #0]
 801607e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016080:	4622      	mov	r2, r4
 8016082:	4631      	mov	r1, r6
 8016084:	f7fe ff3e 	bl	8014f04 <jpeg_huff_decode>
 8016088:	4605      	mov	r5, r0
 801608a:	2d00      	cmp	r5, #0
 801608c:	da01      	bge.n	8016092 <decode_mcu+0x212>
 801608e:	2300      	movs	r3, #0
 8016090:	e0da      	b.n	8016248 <decode_mcu+0x3c8>
 8016092:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8016094:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	  r = s >> 4;
 8016096:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 801609a:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 801609e:	2d00      	cmp	r5, #0
 80160a0:	d02e      	beq.n	8016100 <decode_mcu+0x280>
	    k += r;
 80160a2:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 80160a4:	42ac      	cmp	r4, r5
 80160a6:	da0d      	bge.n	80160c4 <decode_mcu+0x244>
 80160a8:	f107 001c 	add.w	r0, r7, #28
 80160ac:	462b      	mov	r3, r5
 80160ae:	4622      	mov	r2, r4
 80160b0:	4631      	mov	r1, r6
 80160b2:	f7fe fea1 	bl	8014df8 <jpeg_fill_bit_buffer>
 80160b6:	4603      	mov	r3, r0
 80160b8:	2b00      	cmp	r3, #0
 80160ba:	d101      	bne.n	80160c0 <decode_mcu+0x240>
 80160bc:	2300      	movs	r3, #0
 80160be:	e0c3      	b.n	8016248 <decode_mcu+0x3c8>
 80160c0:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80160c2:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	    r = GET_BITS(s);
 80160c4:	1b64      	subs	r4, r4, r5
 80160c6:	fa46 f204 	asr.w	r2, r6, r4
 80160ca:	4b62      	ldr	r3, [pc, #392]	@ (8016254 <decode_mcu+0x3d4>)
 80160cc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80160d0:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 80160d4:	1e6b      	subs	r3, r5, #1
 80160d6:	4a5f      	ldr	r2, [pc, #380]	@ (8016254 <decode_mcu+0x3d4>)
 80160d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80160dc:	4599      	cmp	r9, r3
 80160de:	dc05      	bgt.n	80160ec <decode_mcu+0x26c>
 80160e0:	4b5c      	ldr	r3, [pc, #368]	@ (8016254 <decode_mcu+0x3d4>)
 80160e2:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80160e6:	eba9 0303 	sub.w	r3, r9, r3
 80160ea:	e000      	b.n	80160ee <decode_mcu+0x26e>
 80160ec:	464b      	mov	r3, r9
 80160ee:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
 80160f0:	4b59      	ldr	r3, [pc, #356]	@ (8016258 <decode_mcu+0x3d8>)
 80160f2:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
 80160f6:	b229      	sxth	r1, r5
 80160f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80160fa:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 80160fe:	e004      	b.n	801610a <decode_mcu+0x28a>
	  } else {
	    if (r != 15)
 8016100:	f1b9 0f0f 	cmp.w	r9, #15
 8016104:	d178      	bne.n	80161f8 <decode_mcu+0x378>
	      goto EndOfBlock;
	    k += 15;
 8016106:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 801610a:	f108 0801 	add.w	r8, r8, #1
 801610e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016110:	4598      	cmp	r8, r3
 8016112:	db87      	blt.n	8016024 <decode_mcu+0x1a4>
 8016114:	e06c      	b.n	80161f0 <decode_mcu+0x370>
	  }
	}
      } else {
	if (s) {
 8016116:	2d00      	cmp	r5, #0
 8016118:	d06a      	beq.n	80161f0 <decode_mcu+0x370>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801611a:	42ac      	cmp	r4, r5
 801611c:	da0d      	bge.n	801613a <decode_mcu+0x2ba>
 801611e:	f107 001c 	add.w	r0, r7, #28
 8016122:	462b      	mov	r3, r5
 8016124:	4622      	mov	r2, r4
 8016126:	4631      	mov	r1, r6
 8016128:	f7fe fe66 	bl	8014df8 <jpeg_fill_bit_buffer>
 801612c:	4603      	mov	r3, r0
 801612e:	2b00      	cmp	r3, #0
 8016130:	d101      	bne.n	8016136 <decode_mcu+0x2b6>
 8016132:	2300      	movs	r3, #0
 8016134:	e088      	b.n	8016248 <decode_mcu+0x3c8>
 8016136:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8016138:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 801613a:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k < DCTSIZE2; k++) {
 801613c:	e058      	b.n	80161f0 <decode_mcu+0x370>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 801613e:	2c07      	cmp	r4, #7
 8016140:	dc11      	bgt.n	8016166 <decode_mcu+0x2e6>
 8016142:	f107 001c 	add.w	r0, r7, #28
 8016146:	2300      	movs	r3, #0
 8016148:	4622      	mov	r2, r4
 801614a:	4631      	mov	r1, r6
 801614c:	f7fe fe54 	bl	8014df8 <jpeg_fill_bit_buffer>
 8016150:	4603      	mov	r3, r0
 8016152:	2b00      	cmp	r3, #0
 8016154:	d101      	bne.n	801615a <decode_mcu+0x2da>
 8016156:	2300      	movs	r3, #0
 8016158:	e076      	b.n	8016248 <decode_mcu+0x3c8>
 801615a:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801615c:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 801615e:	2c07      	cmp	r4, #7
 8016160:	dc01      	bgt.n	8016166 <decode_mcu+0x2e6>
 8016162:	2501      	movs	r5, #1
 8016164:	e015      	b.n	8016192 <decode_mcu+0x312>
 8016166:	f1a4 0308 	sub.w	r3, r4, #8
 801616a:	fa46 f303 	asr.w	r3, r6, r3
 801616e:	22ff      	movs	r2, #255	@ 0xff
 8016170:	ea03 0902 	and.w	r9, r3, r2
 8016174:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016176:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 801617a:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801617e:	2d00      	cmp	r5, #0
 8016180:	d006      	beq.n	8016190 <decode_mcu+0x310>
 8016182:	1b64      	subs	r4, r4, r5
 8016184:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016186:	444b      	add	r3, r9
 8016188:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801618c:	461d      	mov	r5, r3
 801618e:	e00f      	b.n	80161b0 <decode_mcu+0x330>
 8016190:	2509      	movs	r5, #9
 8016192:	f107 001c 	add.w	r0, r7, #28
 8016196:	9500      	str	r5, [sp, #0]
 8016198:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801619a:	4622      	mov	r2, r4
 801619c:	4631      	mov	r1, r6
 801619e:	f7fe feb1 	bl	8014f04 <jpeg_huff_decode>
 80161a2:	4605      	mov	r5, r0
 80161a4:	2d00      	cmp	r5, #0
 80161a6:	da01      	bge.n	80161ac <decode_mcu+0x32c>
 80161a8:	2300      	movs	r3, #0
 80161aa:	e04d      	b.n	8016248 <decode_mcu+0x3c8>
 80161ac:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80161ae:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	r = s >> 4;
 80161b0:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 80161b4:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 80161b8:	2d00      	cmp	r5, #0
 80161ba:	d012      	beq.n	80161e2 <decode_mcu+0x362>
	  k += r;
 80161bc:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 80161be:	42ac      	cmp	r4, r5
 80161c0:	da0d      	bge.n	80161de <decode_mcu+0x35e>
 80161c2:	f107 001c 	add.w	r0, r7, #28
 80161c6:	462b      	mov	r3, r5
 80161c8:	4622      	mov	r2, r4
 80161ca:	4631      	mov	r1, r6
 80161cc:	f7fe fe14 	bl	8014df8 <jpeg_fill_bit_buffer>
 80161d0:	4603      	mov	r3, r0
 80161d2:	2b00      	cmp	r3, #0
 80161d4:	d101      	bne.n	80161da <decode_mcu+0x35a>
 80161d6:	2300      	movs	r3, #0
 80161d8:	e036      	b.n	8016248 <decode_mcu+0x3c8>
 80161da:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80161dc:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 80161de:	1b64      	subs	r4, r4, r5
 80161e0:	e004      	b.n	80161ec <decode_mcu+0x36c>
	} else {
	  if (r != 15)
 80161e2:	f1b9 0f0f 	cmp.w	r9, #15
 80161e6:	d109      	bne.n	80161fc <decode_mcu+0x37c>
	    break;
	  k += 15;
 80161e8:	f108 080f 	add.w	r8, r8, #15
      for (; k < DCTSIZE2; k++) {
 80161ec:	f108 0801 	add.w	r8, r8, #1
 80161f0:	f1b8 0f3f 	cmp.w	r8, #63	@ 0x3f
 80161f4:	dda3      	ble.n	801613e <decode_mcu+0x2be>
	}
      }

      EndOfBlock: ;
 80161f6:	e002      	b.n	80161fe <decode_mcu+0x37e>
	      goto EndOfBlock;
 80161f8:	bf00      	nop
 80161fa:	e000      	b.n	80161fe <decode_mcu+0x37e>
	    break;
 80161fc:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80161fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8016200:	3301      	adds	r3, #1
 8016202:	647b      	str	r3, [r7, #68]	@ 0x44
 8016204:	687b      	ldr	r3, [r7, #4]
 8016206:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 801620a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801620c:	429a      	cmp	r2, r3
 801620e:	f6ff ae73 	blt.w	8015ef8 <decode_mcu+0x78>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8016212:	687b      	ldr	r3, [r7, #4]
 8016214:	699b      	ldr	r3, [r3, #24]
 8016216:	69fa      	ldr	r2, [r7, #28]
 8016218:	601a      	str	r2, [r3, #0]
 801621a:	687b      	ldr	r3, [r7, #4]
 801621c:	699b      	ldr	r3, [r3, #24]
 801621e:	6a3a      	ldr	r2, [r7, #32]
 8016220:	605a      	str	r2, [r3, #4]
 8016222:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8016224:	609e      	str	r6, [r3, #8]
 8016226:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8016228:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 801622a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801622c:	f103 0410 	add.w	r4, r3, #16
 8016230:	f107 0508 	add.w	r5, r7, #8
 8016234:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016236:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016238:	682b      	ldr	r3, [r5, #0]
 801623a:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 801623c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801623e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8016240:	1e5a      	subs	r2, r3, #1
 8016242:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8016244:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8016246:	2301      	movs	r3, #1
}
 8016248:	4618      	mov	r0, r3
 801624a:	374c      	adds	r7, #76	@ 0x4c
 801624c:	46bd      	mov	sp, r7
 801624e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8016252:	bf00      	nop
 8016254:	08030554 	.word	0x08030554
 8016258:	080308b0 	.word	0x080308b0

0801625c <start_pass_huff_decoder>:
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
 801625c:	b580      	push	{r7, lr}
 801625e:	b08c      	sub	sp, #48	@ 0x30
 8016260:	af00      	add	r7, sp, #0
 8016262:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8016264:	687b      	ldr	r3, [r7, #4]
 8016266:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801626a:	61fb      	str	r3, [r7, #28]
  int ci, blkn, tbl, i;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 801626c:	687b      	ldr	r3, [r7, #4]
 801626e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8016272:	2b00      	cmp	r3, #0
 8016274:	f000 8133 	beq.w	80164de <start_pass_huff_decoder+0x282>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 8016278:	687b      	ldr	r3, [r7, #4]
 801627a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801627e:	2b00      	cmp	r3, #0
 8016280:	d105      	bne.n	801628e <start_pass_huff_decoder+0x32>
      if (cinfo->Se != 0)
 8016282:	687b      	ldr	r3, [r7, #4]
 8016284:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8016288:	2b00      	cmp	r3, #0
 801628a:	d015      	beq.n	80162b8 <start_pass_huff_decoder+0x5c>
	goto bad;
 801628c:	e02d      	b.n	80162ea <start_pass_huff_decoder+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 801628e:	687b      	ldr	r3, [r7, #4]
 8016290:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8016294:	687b      	ldr	r3, [r7, #4]
 8016296:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801629a:	429a      	cmp	r2, r3
 801629c:	db20      	blt.n	80162e0 <start_pass_huff_decoder+0x84>
 801629e:	687b      	ldr	r3, [r7, #4]
 80162a0:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80162a4:	687b      	ldr	r3, [r7, #4]
 80162a6:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80162aa:	429a      	cmp	r2, r3
 80162ac:	dc18      	bgt.n	80162e0 <start_pass_huff_decoder+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 80162ae:	687b      	ldr	r3, [r7, #4]
 80162b0:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80162b4:	2b01      	cmp	r3, #1
 80162b6:	d115      	bne.n	80162e4 <start_pass_huff_decoder+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 80162b8:	687b      	ldr	r3, [r7, #4]
 80162ba:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80162be:	2b00      	cmp	r3, #0
 80162c0:	d008      	beq.n	80162d4 <start_pass_huff_decoder+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 80162c2:	687b      	ldr	r3, [r7, #4]
 80162c4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80162c8:	1e5a      	subs	r2, r3, #1
 80162ca:	687b      	ldr	r3, [r7, #4]
 80162cc:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80162d0:	429a      	cmp	r2, r3
 80162d2:	d109      	bne.n	80162e8 <start_pass_huff_decoder+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 80162d4:	687b      	ldr	r3, [r7, #4]
 80162d6:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80162da:	2b0d      	cmp	r3, #13
 80162dc:	dd26      	ble.n	801632c <start_pass_huff_decoder+0xd0>
       * but the spec doesn't say so, and we try to be liberal about what we
       * accept.  Note: large Al values could result in out-of-range DC
       * coefficients during early scans, leading to bizarre displays due to
       * overflows in the IDCT math.  But we won't crash.
       */
      bad:
 80162de:	e004      	b.n	80162ea <start_pass_huff_decoder+0x8e>
	goto bad;
 80162e0:	bf00      	nop
 80162e2:	e002      	b.n	80162ea <start_pass_huff_decoder+0x8e>
	goto bad;
 80162e4:	bf00      	nop
 80162e6:	e000      	b.n	80162ea <start_pass_huff_decoder+0x8e>
	goto bad;
 80162e8:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 80162ea:	687b      	ldr	r3, [r7, #4]
 80162ec:	681b      	ldr	r3, [r3, #0]
 80162ee:	2211      	movs	r2, #17
 80162f0:	615a      	str	r2, [r3, #20]
 80162f2:	687b      	ldr	r3, [r7, #4]
 80162f4:	681b      	ldr	r3, [r3, #0]
 80162f6:	687a      	ldr	r2, [r7, #4]
 80162f8:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 80162fc:	619a      	str	r2, [r3, #24]
 80162fe:	687b      	ldr	r3, [r7, #4]
 8016300:	681b      	ldr	r3, [r3, #0]
 8016302:	687a      	ldr	r2, [r7, #4]
 8016304:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 8016308:	61da      	str	r2, [r3, #28]
 801630a:	687b      	ldr	r3, [r7, #4]
 801630c:	681b      	ldr	r3, [r3, #0]
 801630e:	687a      	ldr	r2, [r7, #4]
 8016310:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 8016314:	621a      	str	r2, [r3, #32]
 8016316:	687b      	ldr	r3, [r7, #4]
 8016318:	681b      	ldr	r3, [r3, #0]
 801631a:	687a      	ldr	r2, [r7, #4]
 801631c:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 8016320:	625a      	str	r2, [r3, #36]	@ 0x24
 8016322:	687b      	ldr	r3, [r7, #4]
 8016324:	681b      	ldr	r3, [r3, #0]
 8016326:	681b      	ldr	r3, [r3, #0]
 8016328:	6878      	ldr	r0, [r7, #4]
 801632a:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801632c:	2300      	movs	r3, #0
 801632e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8016330:	e064      	b.n	80163fc <start_pass_huff_decoder+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 8016332:	687a      	ldr	r2, [r7, #4]
 8016334:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016336:	3354      	adds	r3, #84	@ 0x54
 8016338:	009b      	lsls	r3, r3, #2
 801633a:	4413      	add	r3, r2
 801633c:	685b      	ldr	r3, [r3, #4]
 801633e:	685b      	ldr	r3, [r3, #4]
 8016340:	613b      	str	r3, [r7, #16]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 8016342:	687b      	ldr	r3, [r7, #4]
 8016344:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8016348:	693b      	ldr	r3, [r7, #16]
 801634a:	021b      	lsls	r3, r3, #8
 801634c:	4413      	add	r3, r2
 801634e:	60fb      	str	r3, [r7, #12]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 8016350:	687b      	ldr	r3, [r7, #4]
 8016352:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8016356:	2b00      	cmp	r3, #0
 8016358:	d016      	beq.n	8016388 <start_pass_huff_decoder+0x12c>
 801635a:	68fb      	ldr	r3, [r7, #12]
 801635c:	681b      	ldr	r3, [r3, #0]
 801635e:	2b00      	cmp	r3, #0
 8016360:	da12      	bge.n	8016388 <start_pass_huff_decoder+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 8016362:	687b      	ldr	r3, [r7, #4]
 8016364:	681b      	ldr	r3, [r3, #0]
 8016366:	2276      	movs	r2, #118	@ 0x76
 8016368:	615a      	str	r2, [r3, #20]
 801636a:	687b      	ldr	r3, [r7, #4]
 801636c:	681b      	ldr	r3, [r3, #0]
 801636e:	693a      	ldr	r2, [r7, #16]
 8016370:	619a      	str	r2, [r3, #24]
 8016372:	687b      	ldr	r3, [r7, #4]
 8016374:	681b      	ldr	r3, [r3, #0]
 8016376:	2200      	movs	r2, #0
 8016378:	61da      	str	r2, [r3, #28]
 801637a:	687b      	ldr	r3, [r7, #4]
 801637c:	681b      	ldr	r3, [r3, #0]
 801637e:	685b      	ldr	r3, [r3, #4]
 8016380:	f04f 31ff 	mov.w	r1, #4294967295
 8016384:	6878      	ldr	r0, [r7, #4]
 8016386:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 8016388:	687b      	ldr	r3, [r7, #4]
 801638a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801638e:	623b      	str	r3, [r7, #32]
 8016390:	e02b      	b.n	80163ea <start_pass_huff_decoder+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 8016392:	6a3b      	ldr	r3, [r7, #32]
 8016394:	009b      	lsls	r3, r3, #2
 8016396:	68fa      	ldr	r2, [r7, #12]
 8016398:	4413      	add	r3, r2
 801639a:	681b      	ldr	r3, [r3, #0]
 801639c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80163a0:	60bb      	str	r3, [r7, #8]
	if (cinfo->Ah != expected)
 80163a2:	687b      	ldr	r3, [r7, #4]
 80163a4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80163a8:	68ba      	ldr	r2, [r7, #8]
 80163aa:	429a      	cmp	r2, r3
 80163ac:	d012      	beq.n	80163d4 <start_pass_huff_decoder+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 80163ae:	687b      	ldr	r3, [r7, #4]
 80163b0:	681b      	ldr	r3, [r3, #0]
 80163b2:	2276      	movs	r2, #118	@ 0x76
 80163b4:	615a      	str	r2, [r3, #20]
 80163b6:	687b      	ldr	r3, [r7, #4]
 80163b8:	681b      	ldr	r3, [r3, #0]
 80163ba:	693a      	ldr	r2, [r7, #16]
 80163bc:	619a      	str	r2, [r3, #24]
 80163be:	687b      	ldr	r3, [r7, #4]
 80163c0:	681b      	ldr	r3, [r3, #0]
 80163c2:	6a3a      	ldr	r2, [r7, #32]
 80163c4:	61da      	str	r2, [r3, #28]
 80163c6:	687b      	ldr	r3, [r7, #4]
 80163c8:	681b      	ldr	r3, [r3, #0]
 80163ca:	685b      	ldr	r3, [r3, #4]
 80163cc:	f04f 31ff 	mov.w	r1, #4294967295
 80163d0:	6878      	ldr	r0, [r7, #4]
 80163d2:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 80163d4:	6a3b      	ldr	r3, [r7, #32]
 80163d6:	009b      	lsls	r3, r3, #2
 80163d8:	68fa      	ldr	r2, [r7, #12]
 80163da:	4413      	add	r3, r2
 80163dc:	687a      	ldr	r2, [r7, #4]
 80163de:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 80163e2:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80163e4:	6a3b      	ldr	r3, [r7, #32]
 80163e6:	3301      	adds	r3, #1
 80163e8:	623b      	str	r3, [r7, #32]
 80163ea:	687b      	ldr	r3, [r7, #4]
 80163ec:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80163f0:	6a3a      	ldr	r2, [r7, #32]
 80163f2:	429a      	cmp	r2, r3
 80163f4:	ddcd      	ble.n	8016392 <start_pass_huff_decoder+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80163f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80163f8:	3301      	adds	r3, #1
 80163fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80163fc:	687b      	ldr	r3, [r7, #4]
 80163fe:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8016402:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8016404:	429a      	cmp	r2, r3
 8016406:	db94      	blt.n	8016332 <start_pass_huff_decoder+0xd6>
      }
    }

    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 8016408:	687b      	ldr	r3, [r7, #4]
 801640a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801640e:	2b00      	cmp	r3, #0
 8016410:	d10c      	bne.n	801642c <start_pass_huff_decoder+0x1d0>
      if (cinfo->Ss == 0)
 8016412:	687b      	ldr	r3, [r7, #4]
 8016414:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8016418:	2b00      	cmp	r3, #0
 801641a:	d103      	bne.n	8016424 <start_pass_huff_decoder+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 801641c:	69fb      	ldr	r3, [r7, #28]
 801641e:	4a6a      	ldr	r2, [pc, #424]	@ (80165c8 <start_pass_huff_decoder+0x36c>)
 8016420:	605a      	str	r2, [r3, #4]
 8016422:	e00f      	b.n	8016444 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 8016424:	69fb      	ldr	r3, [r7, #28]
 8016426:	4a69      	ldr	r2, [pc, #420]	@ (80165cc <start_pass_huff_decoder+0x370>)
 8016428:	605a      	str	r2, [r3, #4]
 801642a:	e00b      	b.n	8016444 <start_pass_huff_decoder+0x1e8>
    } else {
      if (cinfo->Ss == 0)
 801642c:	687b      	ldr	r3, [r7, #4]
 801642e:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8016432:	2b00      	cmp	r3, #0
 8016434:	d103      	bne.n	801643e <start_pass_huff_decoder+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 8016436:	69fb      	ldr	r3, [r7, #28]
 8016438:	4a65      	ldr	r2, [pc, #404]	@ (80165d0 <start_pass_huff_decoder+0x374>)
 801643a:	605a      	str	r2, [r3, #4]
 801643c:	e002      	b.n	8016444 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 801643e:	69fb      	ldr	r3, [r7, #28]
 8016440:	4a64      	ldr	r2, [pc, #400]	@ (80165d4 <start_pass_huff_decoder+0x378>)
 8016442:	605a      	str	r2, [r3, #4]
    }

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8016444:	2300      	movs	r3, #0
 8016446:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8016448:	e03f      	b.n	80164ca <start_pass_huff_decoder+0x26e>
      compptr = cinfo->cur_comp_info[ci];
 801644a:	687a      	ldr	r2, [r7, #4]
 801644c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801644e:	3354      	adds	r3, #84	@ 0x54
 8016450:	009b      	lsls	r3, r3, #2
 8016452:	4413      	add	r3, r2
 8016454:	685b      	ldr	r3, [r3, #4]
 8016456:	61bb      	str	r3, [r7, #24]
      /* Make sure requested tables are present, and compute derived tables.
       * We may build same derived table more than once, but it's not expensive.
       */
      if (cinfo->Ss == 0) {
 8016458:	687b      	ldr	r3, [r7, #4]
 801645a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801645e:	2b00      	cmp	r3, #0
 8016460:	d113      	bne.n	801648a <start_pass_huff_decoder+0x22e>
	if (cinfo->Ah == 0) {	/* DC refinement needs no table */
 8016462:	687b      	ldr	r3, [r7, #4]
 8016464:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8016468:	2b00      	cmp	r3, #0
 801646a:	d124      	bne.n	80164b6 <start_pass_huff_decoder+0x25a>
	  tbl = compptr->dc_tbl_no;
 801646c:	69bb      	ldr	r3, [r7, #24]
 801646e:	695b      	ldr	r3, [r3, #20]
 8016470:	617b      	str	r3, [r7, #20]
	  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 8016472:	697b      	ldr	r3, [r7, #20]
 8016474:	330a      	adds	r3, #10
 8016476:	009b      	lsls	r3, r3, #2
 8016478:	69fa      	ldr	r2, [r7, #28]
 801647a:	4413      	add	r3, r2
 801647c:	3304      	adds	r3, #4
 801647e:	697a      	ldr	r2, [r7, #20]
 8016480:	2101      	movs	r1, #1
 8016482:	6878      	ldr	r0, [r7, #4]
 8016484:	f7fe fa36 	bl	80148f4 <jpeg_make_d_derived_tbl>
 8016488:	e015      	b.n	80164b6 <start_pass_huff_decoder+0x25a>
				  & entropy->derived_tbls[tbl]);
	}
      } else {
	tbl = compptr->ac_tbl_no;
 801648a:	69bb      	ldr	r3, [r7, #24]
 801648c:	699b      	ldr	r3, [r3, #24]
 801648e:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 8016490:	697b      	ldr	r3, [r7, #20]
 8016492:	330a      	adds	r3, #10
 8016494:	009b      	lsls	r3, r3, #2
 8016496:	69fa      	ldr	r2, [r7, #28]
 8016498:	4413      	add	r3, r2
 801649a:	3304      	adds	r3, #4
 801649c:	697a      	ldr	r2, [r7, #20]
 801649e:	2100      	movs	r1, #0
 80164a0:	6878      	ldr	r0, [r7, #4]
 80164a2:	f7fe fa27 	bl	80148f4 <jpeg_make_d_derived_tbl>
				& entropy->derived_tbls[tbl]);
	/* remember the single active table */
	entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
 80164a6:	69fa      	ldr	r2, [r7, #28]
 80164a8:	697b      	ldr	r3, [r7, #20]
 80164aa:	330a      	adds	r3, #10
 80164ac:	009b      	lsls	r3, r3, #2
 80164ae:	4413      	add	r3, r2
 80164b0:	685a      	ldr	r2, [r3, #4]
 80164b2:	69fb      	ldr	r3, [r7, #28]
 80164b4:	63da      	str	r2, [r3, #60]	@ 0x3c
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 80164b6:	69fa      	ldr	r2, [r7, #28]
 80164b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80164ba:	3304      	adds	r3, #4
 80164bc:	009b      	lsls	r3, r3, #2
 80164be:	4413      	add	r3, r2
 80164c0:	2200      	movs	r2, #0
 80164c2:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80164c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80164c6:	3301      	adds	r3, #1
 80164c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80164ca:	687b      	ldr	r3, [r7, #4]
 80164cc:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80164d0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80164d2:	429a      	cmp	r2, r3
 80164d4:	dbb9      	blt.n	801644a <start_pass_huff_decoder+0x1ee>
    }

    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
 80164d6:	69fb      	ldr	r3, [r7, #28]
 80164d8:	2200      	movs	r2, #0
 80164da:	611a      	str	r2, [r3, #16]
 80164dc:	e21a      	b.n	8016914 <start_pass_huff_decoder+0x6b8>
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning because
     * there are some baseline files out there with all zeroes in these bytes.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 80164de:	687b      	ldr	r3, [r7, #4]
 80164e0:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80164e4:	2b00      	cmp	r3, #0
 80164e6:	d11b      	bne.n	8016520 <start_pass_huff_decoder+0x2c4>
 80164e8:	687b      	ldr	r3, [r7, #4]
 80164ea:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80164ee:	2b00      	cmp	r3, #0
 80164f0:	d116      	bne.n	8016520 <start_pass_huff_decoder+0x2c4>
 80164f2:	687b      	ldr	r3, [r7, #4]
 80164f4:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80164f8:	2b00      	cmp	r3, #0
 80164fa:	d111      	bne.n	8016520 <start_pass_huff_decoder+0x2c4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 80164fc:	687b      	ldr	r3, [r7, #4]
 80164fe:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 8016502:	2b00      	cmp	r3, #0
 8016504:	d104      	bne.n	8016510 <start_pass_huff_decoder+0x2b4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 8016506:	687b      	ldr	r3, [r7, #4]
 8016508:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 801650c:	2b3f      	cmp	r3, #63	@ 0x3f
 801650e:	dc12      	bgt.n	8016536 <start_pass_huff_decoder+0x2da>
	cinfo->Se != cinfo->lim_Se))
 8016510:	687b      	ldr	r3, [r7, #4]
 8016512:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8016516:	687b      	ldr	r3, [r7, #4]
 8016518:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 801651c:	429a      	cmp	r2, r3
 801651e:	d00a      	beq.n	8016536 <start_pass_huff_decoder+0x2da>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 8016520:	687b      	ldr	r3, [r7, #4]
 8016522:	681b      	ldr	r3, [r3, #0]
 8016524:	227d      	movs	r2, #125	@ 0x7d
 8016526:	615a      	str	r2, [r3, #20]
 8016528:	687b      	ldr	r3, [r7, #4]
 801652a:	681b      	ldr	r3, [r3, #0]
 801652c:	685b      	ldr	r3, [r3, #4]
 801652e:	f04f 31ff 	mov.w	r1, #4294967295
 8016532:	6878      	ldr	r0, [r7, #4]
 8016534:	4798      	blx	r3
     * This is not necessary, but it appears that this version is slightly
     * more performant in the given implementation.
     * With an improved implementation we would prefer a single optimized
     * function.
     */
    if (cinfo->lim_Se != DCTSIZE2-1)
 8016536:	687b      	ldr	r3, [r7, #4]
 8016538:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801653c:	2b3f      	cmp	r3, #63	@ 0x3f
 801653e:	d003      	beq.n	8016548 <start_pass_huff_decoder+0x2ec>
      entropy->pub.decode_mcu = decode_mcu_sub;
 8016540:	69fb      	ldr	r3, [r7, #28]
 8016542:	4a25      	ldr	r2, [pc, #148]	@ (80165d8 <start_pass_huff_decoder+0x37c>)
 8016544:	605a      	str	r2, [r3, #4]
 8016546:	e002      	b.n	801654e <start_pass_huff_decoder+0x2f2>
    else
      entropy->pub.decode_mcu = decode_mcu;
 8016548:	69fb      	ldr	r3, [r7, #28]
 801654a:	4a24      	ldr	r2, [pc, #144]	@ (80165dc <start_pass_huff_decoder+0x380>)
 801654c:	605a      	str	r2, [r3, #4]

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801654e:	2300      	movs	r3, #0
 8016550:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8016552:	e02f      	b.n	80165b4 <start_pass_huff_decoder+0x358>
      compptr = cinfo->cur_comp_info[ci];
 8016554:	687a      	ldr	r2, [r7, #4]
 8016556:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016558:	3354      	adds	r3, #84	@ 0x54
 801655a:	009b      	lsls	r3, r3, #2
 801655c:	4413      	add	r3, r2
 801655e:	685b      	ldr	r3, [r3, #4]
 8016560:	61bb      	str	r3, [r7, #24]
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      tbl = compptr->dc_tbl_no;
 8016562:	69bb      	ldr	r3, [r7, #24]
 8016564:	695b      	ldr	r3, [r3, #20]
 8016566:	617b      	str	r3, [r7, #20]
      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 8016568:	697b      	ldr	r3, [r7, #20]
 801656a:	3310      	adds	r3, #16
 801656c:	009b      	lsls	r3, r3, #2
 801656e:	69fa      	ldr	r2, [r7, #28]
 8016570:	4413      	add	r3, r2
 8016572:	697a      	ldr	r2, [r7, #20]
 8016574:	2101      	movs	r1, #1
 8016576:	6878      	ldr	r0, [r7, #4]
 8016578:	f7fe f9bc 	bl	80148f4 <jpeg_make_d_derived_tbl>
			      & entropy->dc_derived_tbls[tbl]);
      if (cinfo->lim_Se) {	/* AC needs no table when not present */
 801657c:	687b      	ldr	r3, [r7, #4]
 801657e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8016582:	2b00      	cmp	r3, #0
 8016584:	d00c      	beq.n	80165a0 <start_pass_huff_decoder+0x344>
	tbl = compptr->ac_tbl_no;
 8016586:	69bb      	ldr	r3, [r7, #24]
 8016588:	699b      	ldr	r3, [r3, #24]
 801658a:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 801658c:	697b      	ldr	r3, [r7, #20]
 801658e:	3314      	adds	r3, #20
 8016590:	009b      	lsls	r3, r3, #2
 8016592:	69fa      	ldr	r2, [r7, #28]
 8016594:	4413      	add	r3, r2
 8016596:	697a      	ldr	r2, [r7, #20]
 8016598:	2100      	movs	r1, #0
 801659a:	6878      	ldr	r0, [r7, #4]
 801659c:	f7fe f9aa 	bl	80148f4 <jpeg_make_d_derived_tbl>
				& entropy->ac_derived_tbls[tbl]);
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 80165a0:	69fa      	ldr	r2, [r7, #28]
 80165a2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80165a4:	3304      	adds	r3, #4
 80165a6:	009b      	lsls	r3, r3, #2
 80165a8:	4413      	add	r3, r2
 80165aa:	2200      	movs	r2, #0
 80165ac:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80165ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80165b0:	3301      	adds	r3, #1
 80165b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80165b4:	687b      	ldr	r3, [r7, #4]
 80165b6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80165ba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80165bc:	429a      	cmp	r2, r3
 80165be:	dbc9      	blt.n	8016554 <start_pass_huff_decoder+0x2f8>
    }

    /* Precalculate decoding info for each block in an MCU of this scan */
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80165c0:	2300      	movs	r3, #0
 80165c2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80165c4:	e19f      	b.n	8016906 <start_pass_huff_decoder+0x6aa>
 80165c6:	bf00      	nop
 80165c8:	08015069 	.word	0x08015069
 80165cc:	08015261 	.word	0x08015261
 80165d0:	08015491 	.word	0x08015491
 80165d4:	08015581 	.word	0x08015581
 80165d8:	08015a95 	.word	0x08015a95
 80165dc:	08015e81 	.word	0x08015e81
      ci = cinfo->MCU_membership[blkn];
 80165e0:	687b      	ldr	r3, [r7, #4]
 80165e2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80165e4:	325c      	adds	r2, #92	@ 0x5c
 80165e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80165ea:	62fb      	str	r3, [r7, #44]	@ 0x2c
      compptr = cinfo->cur_comp_info[ci];
 80165ec:	687a      	ldr	r2, [r7, #4]
 80165ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80165f0:	3354      	adds	r3, #84	@ 0x54
 80165f2:	009b      	lsls	r3, r3, #2
 80165f4:	4413      	add	r3, r2
 80165f6:	685b      	ldr	r3, [r3, #4]
 80165f8:	61bb      	str	r3, [r7, #24]
      /* Precalculate which table to use for each block */
      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
 80165fa:	69bb      	ldr	r3, [r7, #24]
 80165fc:	695a      	ldr	r2, [r3, #20]
 80165fe:	69fb      	ldr	r3, [r7, #28]
 8016600:	3210      	adds	r2, #16
 8016602:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8016606:	69fb      	ldr	r3, [r7, #28]
 8016608:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801660a:	3218      	adds	r2, #24
 801660c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
 8016610:	69bb      	ldr	r3, [r7, #24]
 8016612:	699a      	ldr	r2, [r3, #24]
 8016614:	69fb      	ldr	r3, [r7, #28]
 8016616:	3214      	adds	r2, #20
 8016618:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801661c:	69fb      	ldr	r3, [r7, #28]
 801661e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016620:	3222      	adds	r2, #34	@ 0x22
 8016622:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      /* Decide whether we really care about the coefficient values */
      if (compptr->component_needed) {
 8016626:	69bb      	ldr	r3, [r7, #24]
 8016628:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801662a:	2b00      	cmp	r3, #0
 801662c:	f000 8162 	beq.w	80168f4 <start_pass_huff_decoder+0x698>
	ci = compptr->DCT_v_scaled_size;
 8016630:	69bb      	ldr	r3, [r7, #24]
 8016632:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8016634:	62fb      	str	r3, [r7, #44]	@ 0x2c
	i = compptr->DCT_h_scaled_size;
 8016636:	69bb      	ldr	r3, [r7, #24]
 8016638:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801663a:	627b      	str	r3, [r7, #36]	@ 0x24
	switch (cinfo->lim_Se) {
 801663c:	687b      	ldr	r3, [r7, #4]
 801663e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8016642:	2b30      	cmp	r3, #48	@ 0x30
 8016644:	f200 8136 	bhi.w	80168b4 <start_pass_huff_decoder+0x658>
 8016648:	a201      	add	r2, pc, #4	@ (adr r2, 8016650 <start_pass_huff_decoder+0x3f4>)
 801664a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801664e:	bf00      	nop
 8016650:	08016715 	.word	0x08016715
 8016654:	080168b5 	.word	0x080168b5
 8016658:	080168b5 	.word	0x080168b5
 801665c:	08016723 	.word	0x08016723
 8016660:	080168b5 	.word	0x080168b5
 8016664:	080168b5 	.word	0x080168b5
 8016668:	080168b5 	.word	0x080168b5
 801666c:	080168b5 	.word	0x080168b5
 8016670:	08016763 	.word	0x08016763
 8016674:	080168b5 	.word	0x080168b5
 8016678:	080168b5 	.word	0x080168b5
 801667c:	080168b5 	.word	0x080168b5
 8016680:	080168b5 	.word	0x080168b5
 8016684:	080168b5 	.word	0x080168b5
 8016688:	080168b5 	.word	0x080168b5
 801668c:	080167a7 	.word	0x080167a7
 8016690:	080168b5 	.word	0x080168b5
 8016694:	080168b5 	.word	0x080168b5
 8016698:	080168b5 	.word	0x080168b5
 801669c:	080168b5 	.word	0x080168b5
 80166a0:	080168b5 	.word	0x080168b5
 80166a4:	080168b5 	.word	0x080168b5
 80166a8:	080168b5 	.word	0x080168b5
 80166ac:	080168b5 	.word	0x080168b5
 80166b0:	080167e7 	.word	0x080167e7
 80166b4:	080168b5 	.word	0x080168b5
 80166b8:	080168b5 	.word	0x080168b5
 80166bc:	080168b5 	.word	0x080168b5
 80166c0:	080168b5 	.word	0x080168b5
 80166c4:	080168b5 	.word	0x080168b5
 80166c8:	080168b5 	.word	0x080168b5
 80166cc:	080168b5 	.word	0x080168b5
 80166d0:	080168b5 	.word	0x080168b5
 80166d4:	080168b5 	.word	0x080168b5
 80166d8:	080168b5 	.word	0x080168b5
 80166dc:	0801682b 	.word	0x0801682b
 80166e0:	080168b5 	.word	0x080168b5
 80166e4:	080168b5 	.word	0x080168b5
 80166e8:	080168b5 	.word	0x080168b5
 80166ec:	080168b5 	.word	0x080168b5
 80166f0:	080168b5 	.word	0x080168b5
 80166f4:	080168b5 	.word	0x080168b5
 80166f8:	080168b5 	.word	0x080168b5
 80166fc:	080168b5 	.word	0x080168b5
 8016700:	080168b5 	.word	0x080168b5
 8016704:	080168b5 	.word	0x080168b5
 8016708:	080168b5 	.word	0x080168b5
 801670c:	080168b5 	.word	0x080168b5
 8016710:	08016871 	.word	0x08016871
	case (1*1-1):
	  entropy->coef_limit[blkn] = 1;
 8016714:	69fb      	ldr	r3, [r7, #28]
 8016716:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016718:	322c      	adds	r2, #44	@ 0x2c
 801671a:	2101      	movs	r1, #1
 801671c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8016720:	e0ee      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (2*2-1):
	  if (ci <= 0 || ci > 2) ci = 2;
 8016722:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016724:	2b00      	cmp	r3, #0
 8016726:	dd02      	ble.n	801672e <start_pass_huff_decoder+0x4d2>
 8016728:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801672a:	2b02      	cmp	r3, #2
 801672c:	dd01      	ble.n	8016732 <start_pass_huff_decoder+0x4d6>
 801672e:	2302      	movs	r3, #2
 8016730:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 2) i = 2;
 8016732:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016734:	2b00      	cmp	r3, #0
 8016736:	dd02      	ble.n	801673e <start_pass_huff_decoder+0x4e2>
 8016738:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801673a:	2b02      	cmp	r3, #2
 801673c:	dd01      	ble.n	8016742 <start_pass_huff_decoder+0x4e6>
 801673e:	2302      	movs	r3, #2
 8016740:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
 8016742:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016744:	1e5a      	subs	r2, r3, #1
 8016746:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016748:	3b01      	subs	r3, #1
 801674a:	497b      	ldr	r1, [pc, #492]	@ (8016938 <start_pass_huff_decoder+0x6dc>)
 801674c:	0052      	lsls	r2, r2, #1
 801674e:	4413      	add	r3, r2
 8016750:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8016754:	1c59      	adds	r1, r3, #1
 8016756:	69fb      	ldr	r3, [r7, #28]
 8016758:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801675a:	322c      	adds	r2, #44	@ 0x2c
 801675c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8016760:	e0ce      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (3*3-1):
	  if (ci <= 0 || ci > 3) ci = 3;
 8016762:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016764:	2b00      	cmp	r3, #0
 8016766:	dd02      	ble.n	801676e <start_pass_huff_decoder+0x512>
 8016768:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801676a:	2b03      	cmp	r3, #3
 801676c:	dd01      	ble.n	8016772 <start_pass_huff_decoder+0x516>
 801676e:	2303      	movs	r3, #3
 8016770:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 3) i = 3;
 8016772:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016774:	2b00      	cmp	r3, #0
 8016776:	dd02      	ble.n	801677e <start_pass_huff_decoder+0x522>
 8016778:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801677a:	2b03      	cmp	r3, #3
 801677c:	dd01      	ble.n	8016782 <start_pass_huff_decoder+0x526>
 801677e:	2303      	movs	r3, #3
 8016780:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
 8016782:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016784:	1e5a      	subs	r2, r3, #1
 8016786:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016788:	1e59      	subs	r1, r3, #1
 801678a:	486c      	ldr	r0, [pc, #432]	@ (801693c <start_pass_huff_decoder+0x6e0>)
 801678c:	4613      	mov	r3, r2
 801678e:	005b      	lsls	r3, r3, #1
 8016790:	4413      	add	r3, r2
 8016792:	440b      	add	r3, r1
 8016794:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8016798:	1c59      	adds	r1, r3, #1
 801679a:	69fb      	ldr	r3, [r7, #28]
 801679c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801679e:	322c      	adds	r2, #44	@ 0x2c
 80167a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 80167a4:	e0ac      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (4*4-1):
	  if (ci <= 0 || ci > 4) ci = 4;
 80167a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80167a8:	2b00      	cmp	r3, #0
 80167aa:	dd02      	ble.n	80167b2 <start_pass_huff_decoder+0x556>
 80167ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80167ae:	2b04      	cmp	r3, #4
 80167b0:	dd01      	ble.n	80167b6 <start_pass_huff_decoder+0x55a>
 80167b2:	2304      	movs	r3, #4
 80167b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 4) i = 4;
 80167b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80167b8:	2b00      	cmp	r3, #0
 80167ba:	dd02      	ble.n	80167c2 <start_pass_huff_decoder+0x566>
 80167bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80167be:	2b04      	cmp	r3, #4
 80167c0:	dd01      	ble.n	80167c6 <start_pass_huff_decoder+0x56a>
 80167c2:	2304      	movs	r3, #4
 80167c4:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];
 80167c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80167c8:	1e5a      	subs	r2, r3, #1
 80167ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80167cc:	3b01      	subs	r3, #1
 80167ce:	495c      	ldr	r1, [pc, #368]	@ (8016940 <start_pass_huff_decoder+0x6e4>)
 80167d0:	0092      	lsls	r2, r2, #2
 80167d2:	4413      	add	r3, r2
 80167d4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80167d8:	1c59      	adds	r1, r3, #1
 80167da:	69fb      	ldr	r3, [r7, #28]
 80167dc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80167de:	322c      	adds	r2, #44	@ 0x2c
 80167e0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 80167e4:	e08c      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (5*5-1):
	  if (ci <= 0 || ci > 5) ci = 5;
 80167e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80167e8:	2b00      	cmp	r3, #0
 80167ea:	dd02      	ble.n	80167f2 <start_pass_huff_decoder+0x596>
 80167ec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80167ee:	2b05      	cmp	r3, #5
 80167f0:	dd01      	ble.n	80167f6 <start_pass_huff_decoder+0x59a>
 80167f2:	2305      	movs	r3, #5
 80167f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 5) i = 5;
 80167f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80167f8:	2b00      	cmp	r3, #0
 80167fa:	dd02      	ble.n	8016802 <start_pass_huff_decoder+0x5a6>
 80167fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80167fe:	2b05      	cmp	r3, #5
 8016800:	dd01      	ble.n	8016806 <start_pass_huff_decoder+0x5aa>
 8016802:	2305      	movs	r3, #5
 8016804:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
 8016806:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016808:	1e5a      	subs	r2, r3, #1
 801680a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801680c:	1e59      	subs	r1, r3, #1
 801680e:	484d      	ldr	r0, [pc, #308]	@ (8016944 <start_pass_huff_decoder+0x6e8>)
 8016810:	4613      	mov	r3, r2
 8016812:	009b      	lsls	r3, r3, #2
 8016814:	4413      	add	r3, r2
 8016816:	440b      	add	r3, r1
 8016818:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 801681c:	1c59      	adds	r1, r3, #1
 801681e:	69fb      	ldr	r3, [r7, #28]
 8016820:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016822:	322c      	adds	r2, #44	@ 0x2c
 8016824:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8016828:	e06a      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (6*6-1):
	  if (ci <= 0 || ci > 6) ci = 6;
 801682a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801682c:	2b00      	cmp	r3, #0
 801682e:	dd02      	ble.n	8016836 <start_pass_huff_decoder+0x5da>
 8016830:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016832:	2b06      	cmp	r3, #6
 8016834:	dd01      	ble.n	801683a <start_pass_huff_decoder+0x5de>
 8016836:	2306      	movs	r3, #6
 8016838:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 6) i = 6;
 801683a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801683c:	2b00      	cmp	r3, #0
 801683e:	dd02      	ble.n	8016846 <start_pass_huff_decoder+0x5ea>
 8016840:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016842:	2b06      	cmp	r3, #6
 8016844:	dd01      	ble.n	801684a <start_pass_huff_decoder+0x5ee>
 8016846:	2306      	movs	r3, #6
 8016848:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
 801684a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801684c:	1e5a      	subs	r2, r3, #1
 801684e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016850:	1e59      	subs	r1, r3, #1
 8016852:	483d      	ldr	r0, [pc, #244]	@ (8016948 <start_pass_huff_decoder+0x6ec>)
 8016854:	4613      	mov	r3, r2
 8016856:	005b      	lsls	r3, r3, #1
 8016858:	4413      	add	r3, r2
 801685a:	005b      	lsls	r3, r3, #1
 801685c:	440b      	add	r3, r1
 801685e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8016862:	1c59      	adds	r1, r3, #1
 8016864:	69fb      	ldr	r3, [r7, #28]
 8016866:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016868:	322c      	adds	r2, #44	@ 0x2c
 801686a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 801686e:	e047      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	case (7*7-1):
	  if (ci <= 0 || ci > 7) ci = 7;
 8016870:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016872:	2b00      	cmp	r3, #0
 8016874:	dd02      	ble.n	801687c <start_pass_huff_decoder+0x620>
 8016876:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016878:	2b07      	cmp	r3, #7
 801687a:	dd01      	ble.n	8016880 <start_pass_huff_decoder+0x624>
 801687c:	2307      	movs	r3, #7
 801687e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 7) i = 7;
 8016880:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016882:	2b00      	cmp	r3, #0
 8016884:	dd02      	ble.n	801688c <start_pass_huff_decoder+0x630>
 8016886:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016888:	2b07      	cmp	r3, #7
 801688a:	dd01      	ble.n	8016890 <start_pass_huff_decoder+0x634>
 801688c:	2307      	movs	r3, #7
 801688e:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
 8016890:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016892:	1e5a      	subs	r2, r3, #1
 8016894:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016896:	1e59      	subs	r1, r3, #1
 8016898:	482c      	ldr	r0, [pc, #176]	@ (801694c <start_pass_huff_decoder+0x6f0>)
 801689a:	4613      	mov	r3, r2
 801689c:	00db      	lsls	r3, r3, #3
 801689e:	1a9b      	subs	r3, r3, r2
 80168a0:	440b      	add	r3, r1
 80168a2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80168a6:	1c59      	adds	r1, r3, #1
 80168a8:	69fb      	ldr	r3, [r7, #28]
 80168aa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80168ac:	322c      	adds	r2, #44	@ 0x2c
 80168ae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 80168b2:	e025      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	default:
	  if (ci <= 0 || ci > 8) ci = 8;
 80168b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80168b6:	2b00      	cmp	r3, #0
 80168b8:	dd02      	ble.n	80168c0 <start_pass_huff_decoder+0x664>
 80168ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80168bc:	2b08      	cmp	r3, #8
 80168be:	dd01      	ble.n	80168c4 <start_pass_huff_decoder+0x668>
 80168c0:	2308      	movs	r3, #8
 80168c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 8) i = 8;
 80168c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80168c6:	2b00      	cmp	r3, #0
 80168c8:	dd02      	ble.n	80168d0 <start_pass_huff_decoder+0x674>
 80168ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80168cc:	2b08      	cmp	r3, #8
 80168ce:	dd01      	ble.n	80168d4 <start_pass_huff_decoder+0x678>
 80168d0:	2308      	movs	r3, #8
 80168d2:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
 80168d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80168d6:	1e5a      	subs	r2, r3, #1
 80168d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80168da:	3b01      	subs	r3, #1
 80168dc:	491c      	ldr	r1, [pc, #112]	@ (8016950 <start_pass_huff_decoder+0x6f4>)
 80168de:	00d2      	lsls	r2, r2, #3
 80168e0:	4413      	add	r3, r2
 80168e2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80168e6:	1c59      	adds	r1, r3, #1
 80168e8:	69fb      	ldr	r3, [r7, #28]
 80168ea:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80168ec:	322c      	adds	r2, #44	@ 0x2c
 80168ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 80168f2:	e005      	b.n	8016900 <start_pass_huff_decoder+0x6a4>
	}
      } else {
	entropy->coef_limit[blkn] = 0;
 80168f4:	69fb      	ldr	r3, [r7, #28]
 80168f6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80168f8:	322c      	adds	r2, #44	@ 0x2c
 80168fa:	2100      	movs	r1, #0
 80168fc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8016900:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016902:	3301      	adds	r3, #1
 8016904:	62bb      	str	r3, [r7, #40]	@ 0x28
 8016906:	687b      	ldr	r3, [r7, #4]
 8016908:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 801690c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801690e:	429a      	cmp	r2, r3
 8016910:	f6ff ae66 	blt.w	80165e0 <start_pass_huff_decoder+0x384>
      }
    }
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
 8016914:	69fb      	ldr	r3, [r7, #28]
 8016916:	2200      	movs	r2, #0
 8016918:	60da      	str	r2, [r3, #12]
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
 801691a:	69fb      	ldr	r3, [r7, #28]
 801691c:	2200      	movs	r2, #0
 801691e:	609a      	str	r2, [r3, #8]
  entropy->insufficient_data = FALSE;
 8016920:	69fb      	ldr	r3, [r7, #28]
 8016922:	2200      	movs	r2, #0
 8016924:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8016926:	687b      	ldr	r3, [r7, #4]
 8016928:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801692c:	69fb      	ldr	r3, [r7, #28]
 801692e:	629a      	str	r2, [r3, #40]	@ 0x28
}
 8016930:	bf00      	nop
 8016932:	3730      	adds	r7, #48	@ 0x30
 8016934:	46bd      	mov	sp, r7
 8016936:	bd80      	pop	{r7, pc}
 8016938:	08030544 	.word	0x08030544
 801693c:	08030520 	.word	0x08030520
 8016940:	080304e0 	.word	0x080304e0
 8016944:	0803047c 	.word	0x0803047c
 8016948:	080303ec 	.word	0x080303ec
 801694c:	08030328 	.word	0x08030328
 8016950:	08030228 	.word	0x08030228

08016954 <jinit_huff_decoder>:
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
 8016954:	b580      	push	{r7, lr}
 8016956:	b086      	sub	sp, #24
 8016958:	af00      	add	r7, sp, #0
 801695a:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801695c:	687b      	ldr	r3, [r7, #4]
 801695e:	685b      	ldr	r3, [r3, #4]
 8016960:	681b      	ldr	r3, [r3, #0]
 8016962:	22d8      	movs	r2, #216	@ 0xd8
 8016964:	2101      	movs	r1, #1
 8016966:	6878      	ldr	r0, [r7, #4]
 8016968:	4798      	blx	r3
 801696a:	60b8      	str	r0, [r7, #8]
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 801696c:	687b      	ldr	r3, [r7, #4]
 801696e:	68ba      	ldr	r2, [r7, #8]
 8016970:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
  entropy->pub.start_pass = start_pass_huff_decoder;
 8016974:	68bb      	ldr	r3, [r7, #8]
 8016976:	4a30      	ldr	r2, [pc, #192]	@ (8016a38 <jinit_huff_decoder+0xe4>)
 8016978:	601a      	str	r2, [r3, #0]

  if (cinfo->progressive_mode) {
 801697a:	687b      	ldr	r3, [r7, #4]
 801697c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8016980:	2b00      	cmp	r3, #0
 8016982:	d03b      	beq.n	80169fc <jinit_huff_decoder+0xa8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016984:	687b      	ldr	r3, [r7, #4]
 8016986:	685b      	ldr	r3, [r3, #4]
 8016988:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 801698a:	687a      	ldr	r2, [r7, #4]
 801698c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801698e:	0212      	lsls	r2, r2, #8
 8016990:	2101      	movs	r1, #1
 8016992:	6878      	ldr	r0, [r7, #4]
 8016994:	4798      	blx	r3
 8016996:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 8016998:	687b      	ldr	r3, [r7, #4]
 801699a:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 801699e:	687b      	ldr	r3, [r7, #4]
 80169a0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80169a4:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++)
 80169a6:	2300      	movs	r3, #0
 80169a8:	60fb      	str	r3, [r7, #12]
 80169aa:	e011      	b.n	80169d0 <jinit_huff_decoder+0x7c>
      for (i = 0; i < DCTSIZE2; i++)
 80169ac:	2300      	movs	r3, #0
 80169ae:	617b      	str	r3, [r7, #20]
 80169b0:	e008      	b.n	80169c4 <jinit_huff_decoder+0x70>
	*coef_bit_ptr++ = -1;
 80169b2:	693b      	ldr	r3, [r7, #16]
 80169b4:	1d1a      	adds	r2, r3, #4
 80169b6:	613a      	str	r2, [r7, #16]
 80169b8:	f04f 32ff 	mov.w	r2, #4294967295
 80169bc:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 80169be:	697b      	ldr	r3, [r7, #20]
 80169c0:	3301      	adds	r3, #1
 80169c2:	617b      	str	r3, [r7, #20]
 80169c4:	697b      	ldr	r3, [r7, #20]
 80169c6:	2b3f      	cmp	r3, #63	@ 0x3f
 80169c8:	ddf3      	ble.n	80169b2 <jinit_huff_decoder+0x5e>
    for (ci = 0; ci < cinfo->num_components; ci++)
 80169ca:	68fb      	ldr	r3, [r7, #12]
 80169cc:	3301      	adds	r3, #1
 80169ce:	60fb      	str	r3, [r7, #12]
 80169d0:	687b      	ldr	r3, [r7, #4]
 80169d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80169d4:	68fa      	ldr	r2, [r7, #12]
 80169d6:	429a      	cmp	r2, r3
 80169d8:	dbe8      	blt.n	80169ac <jinit_huff_decoder+0x58>

    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 80169da:	2300      	movs	r3, #0
 80169dc:	617b      	str	r3, [r7, #20]
 80169de:	e009      	b.n	80169f4 <jinit_huff_decoder+0xa0>
      entropy->derived_tbls[i] = NULL;
 80169e0:	68ba      	ldr	r2, [r7, #8]
 80169e2:	697b      	ldr	r3, [r7, #20]
 80169e4:	330a      	adds	r3, #10
 80169e6:	009b      	lsls	r3, r3, #2
 80169e8:	4413      	add	r3, r2
 80169ea:	2200      	movs	r2, #0
 80169ec:	605a      	str	r2, [r3, #4]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 80169ee:	697b      	ldr	r3, [r7, #20]
 80169f0:	3301      	adds	r3, #1
 80169f2:	617b      	str	r3, [r7, #20]
 80169f4:	697b      	ldr	r3, [r7, #20]
 80169f6:	2b03      	cmp	r3, #3
 80169f8:	ddf2      	ble.n	80169e0 <jinit_huff_decoder+0x8c>
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
    }
  }
}
 80169fa:	e018      	b.n	8016a2e <jinit_huff_decoder+0xda>
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 80169fc:	2300      	movs	r3, #0
 80169fe:	617b      	str	r3, [r7, #20]
 8016a00:	e012      	b.n	8016a28 <jinit_huff_decoder+0xd4>
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
 8016a02:	68bb      	ldr	r3, [r7, #8]
 8016a04:	697a      	ldr	r2, [r7, #20]
 8016a06:	3214      	adds	r2, #20
 8016a08:	2100      	movs	r1, #0
 8016a0a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8016a0e:	68bb      	ldr	r3, [r7, #8]
 8016a10:	697a      	ldr	r2, [r7, #20]
 8016a12:	3214      	adds	r2, #20
 8016a14:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8016a18:	68bb      	ldr	r3, [r7, #8]
 8016a1a:	697a      	ldr	r2, [r7, #20]
 8016a1c:	3210      	adds	r2, #16
 8016a1e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8016a22:	697b      	ldr	r3, [r7, #20]
 8016a24:	3301      	adds	r3, #1
 8016a26:	617b      	str	r3, [r7, #20]
 8016a28:	697b      	ldr	r3, [r7, #20]
 8016a2a:	2b03      	cmp	r3, #3
 8016a2c:	dde9      	ble.n	8016a02 <jinit_huff_decoder+0xae>
}
 8016a2e:	bf00      	nop
 8016a30:	3718      	adds	r7, #24
 8016a32:	46bd      	mov	sp, r7
 8016a34:	bd80      	pop	{r7, pc}
 8016a36:	bf00      	nop
 8016a38:	0801625d 	.word	0x0801625d

08016a3c <jpeg_core_output_dimensions>:
GLOBAL(void)
jpeg_core_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for transcoding and full decompression.
 */
{
 8016a3c:	b580      	push	{r7, lr}
 8016a3e:	b084      	sub	sp, #16
 8016a40:	af00      	add	r7, sp, #0
 8016a42:	6078      	str	r0, [r7, #4]
#ifdef IDCT_SCALING_SUPPORTED
  int ci;
  jpeg_component_info *compptr;

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom) {
 8016a44:	687b      	ldr	r3, [r7, #4]
 8016a46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016a48:	687a      	ldr	r2, [r7, #4]
 8016a4a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016a4e:	fb03 f202 	mul.w	r2, r3, r2
 8016a52:	687b      	ldr	r3, [r7, #4]
 8016a54:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016a56:	429a      	cmp	r2, r3
 8016a58:	d824      	bhi.n	8016aa4 <jpeg_core_output_dimensions+0x68>
    /* Provide 1/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, (long) cinfo->block_size);
 8016a5a:	687b      	ldr	r3, [r7, #4]
 8016a5c:	69db      	ldr	r3, [r3, #28]
 8016a5e:	461a      	mov	r2, r3
 8016a60:	687b      	ldr	r3, [r7, #4]
 8016a62:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016a66:	4619      	mov	r1, r3
 8016a68:	4610      	mov	r0, r2
 8016a6a:	f016 f921 	bl	802ccb0 <jdiv_round_up>
 8016a6e:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016a70:	461a      	mov	r2, r3
 8016a72:	687b      	ldr	r3, [r7, #4]
 8016a74:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, (long) cinfo->block_size);
 8016a76:	687b      	ldr	r3, [r7, #4]
 8016a78:	6a1b      	ldr	r3, [r3, #32]
 8016a7a:	461a      	mov	r2, r3
 8016a7c:	687b      	ldr	r3, [r7, #4]
 8016a7e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016a82:	4619      	mov	r1, r3
 8016a84:	4610      	mov	r0, r2
 8016a86:	f016 f913 	bl	802ccb0 <jdiv_round_up>
 8016a8a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016a8c:	461a      	mov	r2, r3
 8016a8e:	687b      	ldr	r3, [r7, #4]
 8016a90:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 1;
 8016a92:	687b      	ldr	r3, [r7, #4]
 8016a94:	2201      	movs	r2, #1
 8016a96:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 1;
 8016a9a:	687b      	ldr	r3, [r7, #4]
 8016a9c:	2201      	movs	r2, #1
 8016a9e:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016aa2:	e349      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 2) {
 8016aa4:	687b      	ldr	r3, [r7, #4]
 8016aa6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016aa8:	687a      	ldr	r2, [r7, #4]
 8016aaa:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016aae:	fb03 f202 	mul.w	r2, r3, r2
 8016ab2:	687b      	ldr	r3, [r7, #4]
 8016ab4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016ab6:	005b      	lsls	r3, r3, #1
 8016ab8:	429a      	cmp	r2, r3
 8016aba:	d824      	bhi.n	8016b06 <jpeg_core_output_dimensions+0xca>
    /* Provide 2/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 2L, (long) cinfo->block_size);
 8016abc:	687b      	ldr	r3, [r7, #4]
 8016abe:	69db      	ldr	r3, [r3, #28]
 8016ac0:	005a      	lsls	r2, r3, #1
 8016ac2:	687b      	ldr	r3, [r7, #4]
 8016ac4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016ac8:	4619      	mov	r1, r3
 8016aca:	4610      	mov	r0, r2
 8016acc:	f016 f8f0 	bl	802ccb0 <jdiv_round_up>
 8016ad0:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016ad2:	461a      	mov	r2, r3
 8016ad4:	687b      	ldr	r3, [r7, #4]
 8016ad6:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 2L, (long) cinfo->block_size);
 8016ad8:	687b      	ldr	r3, [r7, #4]
 8016ada:	6a1b      	ldr	r3, [r3, #32]
 8016adc:	005a      	lsls	r2, r3, #1
 8016ade:	687b      	ldr	r3, [r7, #4]
 8016ae0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016ae4:	4619      	mov	r1, r3
 8016ae6:	4610      	mov	r0, r2
 8016ae8:	f016 f8e2 	bl	802ccb0 <jdiv_round_up>
 8016aec:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016aee:	461a      	mov	r2, r3
 8016af0:	687b      	ldr	r3, [r7, #4]
 8016af2:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 2;
 8016af4:	687b      	ldr	r3, [r7, #4]
 8016af6:	2202      	movs	r2, #2
 8016af8:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 2;
 8016afc:	687b      	ldr	r3, [r7, #4]
 8016afe:	2202      	movs	r2, #2
 8016b00:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016b04:	e318      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 3) {
 8016b06:	687b      	ldr	r3, [r7, #4]
 8016b08:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016b0a:	687a      	ldr	r2, [r7, #4]
 8016b0c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016b10:	fb02 f103 	mul.w	r1, r2, r3
 8016b14:	687b      	ldr	r3, [r7, #4]
 8016b16:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016b18:	4613      	mov	r3, r2
 8016b1a:	005b      	lsls	r3, r3, #1
 8016b1c:	4413      	add	r3, r2
 8016b1e:	4299      	cmp	r1, r3
 8016b20:	d82a      	bhi.n	8016b78 <jpeg_core_output_dimensions+0x13c>
    /* Provide 3/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 3L, (long) cinfo->block_size);
 8016b22:	687b      	ldr	r3, [r7, #4]
 8016b24:	69db      	ldr	r3, [r3, #28]
 8016b26:	461a      	mov	r2, r3
 8016b28:	4613      	mov	r3, r2
 8016b2a:	005b      	lsls	r3, r3, #1
 8016b2c:	441a      	add	r2, r3
 8016b2e:	687b      	ldr	r3, [r7, #4]
 8016b30:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016b34:	4619      	mov	r1, r3
 8016b36:	4610      	mov	r0, r2
 8016b38:	f016 f8ba 	bl	802ccb0 <jdiv_round_up>
 8016b3c:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016b3e:	461a      	mov	r2, r3
 8016b40:	687b      	ldr	r3, [r7, #4]
 8016b42:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 3L, (long) cinfo->block_size);
 8016b44:	687b      	ldr	r3, [r7, #4]
 8016b46:	6a1b      	ldr	r3, [r3, #32]
 8016b48:	461a      	mov	r2, r3
 8016b4a:	4613      	mov	r3, r2
 8016b4c:	005b      	lsls	r3, r3, #1
 8016b4e:	441a      	add	r2, r3
 8016b50:	687b      	ldr	r3, [r7, #4]
 8016b52:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016b56:	4619      	mov	r1, r3
 8016b58:	4610      	mov	r0, r2
 8016b5a:	f016 f8a9 	bl	802ccb0 <jdiv_round_up>
 8016b5e:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016b60:	461a      	mov	r2, r3
 8016b62:	687b      	ldr	r3, [r7, #4]
 8016b64:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 3;
 8016b66:	687b      	ldr	r3, [r7, #4]
 8016b68:	2203      	movs	r2, #3
 8016b6a:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 3;
 8016b6e:	687b      	ldr	r3, [r7, #4]
 8016b70:	2203      	movs	r2, #3
 8016b72:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016b76:	e2df      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 4) {
 8016b78:	687b      	ldr	r3, [r7, #4]
 8016b7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016b7c:	687a      	ldr	r2, [r7, #4]
 8016b7e:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016b82:	fb03 f202 	mul.w	r2, r3, r2
 8016b86:	687b      	ldr	r3, [r7, #4]
 8016b88:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016b8a:	009b      	lsls	r3, r3, #2
 8016b8c:	429a      	cmp	r2, r3
 8016b8e:	d824      	bhi.n	8016bda <jpeg_core_output_dimensions+0x19e>
    /* Provide 4/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 4L, (long) cinfo->block_size);
 8016b90:	687b      	ldr	r3, [r7, #4]
 8016b92:	69db      	ldr	r3, [r3, #28]
 8016b94:	009a      	lsls	r2, r3, #2
 8016b96:	687b      	ldr	r3, [r7, #4]
 8016b98:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016b9c:	4619      	mov	r1, r3
 8016b9e:	4610      	mov	r0, r2
 8016ba0:	f016 f886 	bl	802ccb0 <jdiv_round_up>
 8016ba4:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016ba6:	461a      	mov	r2, r3
 8016ba8:	687b      	ldr	r3, [r7, #4]
 8016baa:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 4L, (long) cinfo->block_size);
 8016bac:	687b      	ldr	r3, [r7, #4]
 8016bae:	6a1b      	ldr	r3, [r3, #32]
 8016bb0:	009a      	lsls	r2, r3, #2
 8016bb2:	687b      	ldr	r3, [r7, #4]
 8016bb4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016bb8:	4619      	mov	r1, r3
 8016bba:	4610      	mov	r0, r2
 8016bbc:	f016 f878 	bl	802ccb0 <jdiv_round_up>
 8016bc0:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016bc2:	461a      	mov	r2, r3
 8016bc4:	687b      	ldr	r3, [r7, #4]
 8016bc6:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 4;
 8016bc8:	687b      	ldr	r3, [r7, #4]
 8016bca:	2204      	movs	r2, #4
 8016bcc:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 4;
 8016bd0:	687b      	ldr	r3, [r7, #4]
 8016bd2:	2204      	movs	r2, #4
 8016bd4:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016bd8:	e2ae      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 5) {
 8016bda:	687b      	ldr	r3, [r7, #4]
 8016bdc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016bde:	687a      	ldr	r2, [r7, #4]
 8016be0:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016be4:	fb02 f103 	mul.w	r1, r2, r3
 8016be8:	687b      	ldr	r3, [r7, #4]
 8016bea:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016bec:	4613      	mov	r3, r2
 8016bee:	009b      	lsls	r3, r3, #2
 8016bf0:	4413      	add	r3, r2
 8016bf2:	4299      	cmp	r1, r3
 8016bf4:	d82a      	bhi.n	8016c4c <jpeg_core_output_dimensions+0x210>
    /* Provide 5/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 5L, (long) cinfo->block_size);
 8016bf6:	687b      	ldr	r3, [r7, #4]
 8016bf8:	69db      	ldr	r3, [r3, #28]
 8016bfa:	461a      	mov	r2, r3
 8016bfc:	4613      	mov	r3, r2
 8016bfe:	009b      	lsls	r3, r3, #2
 8016c00:	441a      	add	r2, r3
 8016c02:	687b      	ldr	r3, [r7, #4]
 8016c04:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016c08:	4619      	mov	r1, r3
 8016c0a:	4610      	mov	r0, r2
 8016c0c:	f016 f850 	bl	802ccb0 <jdiv_round_up>
 8016c10:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016c12:	461a      	mov	r2, r3
 8016c14:	687b      	ldr	r3, [r7, #4]
 8016c16:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 5L, (long) cinfo->block_size);
 8016c18:	687b      	ldr	r3, [r7, #4]
 8016c1a:	6a1b      	ldr	r3, [r3, #32]
 8016c1c:	461a      	mov	r2, r3
 8016c1e:	4613      	mov	r3, r2
 8016c20:	009b      	lsls	r3, r3, #2
 8016c22:	441a      	add	r2, r3
 8016c24:	687b      	ldr	r3, [r7, #4]
 8016c26:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016c2a:	4619      	mov	r1, r3
 8016c2c:	4610      	mov	r0, r2
 8016c2e:	f016 f83f 	bl	802ccb0 <jdiv_round_up>
 8016c32:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016c34:	461a      	mov	r2, r3
 8016c36:	687b      	ldr	r3, [r7, #4]
 8016c38:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 5;
 8016c3a:	687b      	ldr	r3, [r7, #4]
 8016c3c:	2205      	movs	r2, #5
 8016c3e:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 5;
 8016c42:	687b      	ldr	r3, [r7, #4]
 8016c44:	2205      	movs	r2, #5
 8016c46:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016c4a:	e275      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 6) {
 8016c4c:	687b      	ldr	r3, [r7, #4]
 8016c4e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016c50:	687a      	ldr	r2, [r7, #4]
 8016c52:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016c56:	fb02 f103 	mul.w	r1, r2, r3
 8016c5a:	687b      	ldr	r3, [r7, #4]
 8016c5c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016c5e:	4613      	mov	r3, r2
 8016c60:	005b      	lsls	r3, r3, #1
 8016c62:	4413      	add	r3, r2
 8016c64:	005b      	lsls	r3, r3, #1
 8016c66:	4299      	cmp	r1, r3
 8016c68:	d82e      	bhi.n	8016cc8 <jpeg_core_output_dimensions+0x28c>
    /* Provide 6/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 6L, (long) cinfo->block_size);
 8016c6a:	687b      	ldr	r3, [r7, #4]
 8016c6c:	69db      	ldr	r3, [r3, #28]
 8016c6e:	461a      	mov	r2, r3
 8016c70:	4613      	mov	r3, r2
 8016c72:	005b      	lsls	r3, r3, #1
 8016c74:	4413      	add	r3, r2
 8016c76:	005b      	lsls	r3, r3, #1
 8016c78:	461a      	mov	r2, r3
 8016c7a:	687b      	ldr	r3, [r7, #4]
 8016c7c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016c80:	4619      	mov	r1, r3
 8016c82:	4610      	mov	r0, r2
 8016c84:	f016 f814 	bl	802ccb0 <jdiv_round_up>
 8016c88:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016c8a:	461a      	mov	r2, r3
 8016c8c:	687b      	ldr	r3, [r7, #4]
 8016c8e:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 6L, (long) cinfo->block_size);
 8016c90:	687b      	ldr	r3, [r7, #4]
 8016c92:	6a1b      	ldr	r3, [r3, #32]
 8016c94:	461a      	mov	r2, r3
 8016c96:	4613      	mov	r3, r2
 8016c98:	005b      	lsls	r3, r3, #1
 8016c9a:	4413      	add	r3, r2
 8016c9c:	005b      	lsls	r3, r3, #1
 8016c9e:	461a      	mov	r2, r3
 8016ca0:	687b      	ldr	r3, [r7, #4]
 8016ca2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016ca6:	4619      	mov	r1, r3
 8016ca8:	4610      	mov	r0, r2
 8016caa:	f016 f801 	bl	802ccb0 <jdiv_round_up>
 8016cae:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016cb0:	461a      	mov	r2, r3
 8016cb2:	687b      	ldr	r3, [r7, #4]
 8016cb4:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 6;
 8016cb6:	687b      	ldr	r3, [r7, #4]
 8016cb8:	2206      	movs	r2, #6
 8016cba:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 6;
 8016cbe:	687b      	ldr	r3, [r7, #4]
 8016cc0:	2206      	movs	r2, #6
 8016cc2:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016cc6:	e237      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 7) {
 8016cc8:	687b      	ldr	r3, [r7, #4]
 8016cca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016ccc:	687a      	ldr	r2, [r7, #4]
 8016cce:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016cd2:	fb02 f103 	mul.w	r1, r2, r3
 8016cd6:	687b      	ldr	r3, [r7, #4]
 8016cd8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016cda:	4613      	mov	r3, r2
 8016cdc:	00db      	lsls	r3, r3, #3
 8016cde:	1a9b      	subs	r3, r3, r2
 8016ce0:	4299      	cmp	r1, r3
 8016ce2:	d82a      	bhi.n	8016d3a <jpeg_core_output_dimensions+0x2fe>
    /* Provide 7/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 7L, (long) cinfo->block_size);
 8016ce4:	687b      	ldr	r3, [r7, #4]
 8016ce6:	69db      	ldr	r3, [r3, #28]
 8016ce8:	461a      	mov	r2, r3
 8016cea:	4613      	mov	r3, r2
 8016cec:	00db      	lsls	r3, r3, #3
 8016cee:	1a9a      	subs	r2, r3, r2
 8016cf0:	687b      	ldr	r3, [r7, #4]
 8016cf2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016cf6:	4619      	mov	r1, r3
 8016cf8:	4610      	mov	r0, r2
 8016cfa:	f015 ffd9 	bl	802ccb0 <jdiv_round_up>
 8016cfe:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016d00:	461a      	mov	r2, r3
 8016d02:	687b      	ldr	r3, [r7, #4]
 8016d04:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 7L, (long) cinfo->block_size);
 8016d06:	687b      	ldr	r3, [r7, #4]
 8016d08:	6a1b      	ldr	r3, [r3, #32]
 8016d0a:	461a      	mov	r2, r3
 8016d0c:	4613      	mov	r3, r2
 8016d0e:	00db      	lsls	r3, r3, #3
 8016d10:	1a9a      	subs	r2, r3, r2
 8016d12:	687b      	ldr	r3, [r7, #4]
 8016d14:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016d18:	4619      	mov	r1, r3
 8016d1a:	4610      	mov	r0, r2
 8016d1c:	f015 ffc8 	bl	802ccb0 <jdiv_round_up>
 8016d20:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016d22:	461a      	mov	r2, r3
 8016d24:	687b      	ldr	r3, [r7, #4]
 8016d26:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 7;
 8016d28:	687b      	ldr	r3, [r7, #4]
 8016d2a:	2207      	movs	r2, #7
 8016d2c:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 7;
 8016d30:	687b      	ldr	r3, [r7, #4]
 8016d32:	2207      	movs	r2, #7
 8016d34:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016d38:	e1fe      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 8) {
 8016d3a:	687b      	ldr	r3, [r7, #4]
 8016d3c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016d3e:	687a      	ldr	r2, [r7, #4]
 8016d40:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016d44:	fb03 f202 	mul.w	r2, r3, r2
 8016d48:	687b      	ldr	r3, [r7, #4]
 8016d4a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016d4c:	00db      	lsls	r3, r3, #3
 8016d4e:	429a      	cmp	r2, r3
 8016d50:	d824      	bhi.n	8016d9c <jpeg_core_output_dimensions+0x360>
    /* Provide 8/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 8L, (long) cinfo->block_size);
 8016d52:	687b      	ldr	r3, [r7, #4]
 8016d54:	69db      	ldr	r3, [r3, #28]
 8016d56:	00da      	lsls	r2, r3, #3
 8016d58:	687b      	ldr	r3, [r7, #4]
 8016d5a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016d5e:	4619      	mov	r1, r3
 8016d60:	4610      	mov	r0, r2
 8016d62:	f015 ffa5 	bl	802ccb0 <jdiv_round_up>
 8016d66:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016d68:	461a      	mov	r2, r3
 8016d6a:	687b      	ldr	r3, [r7, #4]
 8016d6c:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 8L, (long) cinfo->block_size);
 8016d6e:	687b      	ldr	r3, [r7, #4]
 8016d70:	6a1b      	ldr	r3, [r3, #32]
 8016d72:	00da      	lsls	r2, r3, #3
 8016d74:	687b      	ldr	r3, [r7, #4]
 8016d76:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016d7a:	4619      	mov	r1, r3
 8016d7c:	4610      	mov	r0, r2
 8016d7e:	f015 ff97 	bl	802ccb0 <jdiv_round_up>
 8016d82:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016d84:	461a      	mov	r2, r3
 8016d86:	687b      	ldr	r3, [r7, #4]
 8016d88:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 8;
 8016d8a:	687b      	ldr	r3, [r7, #4]
 8016d8c:	2208      	movs	r2, #8
 8016d8e:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 8;
 8016d92:	687b      	ldr	r3, [r7, #4]
 8016d94:	2208      	movs	r2, #8
 8016d96:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016d9a:	e1cd      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 9) {
 8016d9c:	687b      	ldr	r3, [r7, #4]
 8016d9e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016da0:	687a      	ldr	r2, [r7, #4]
 8016da2:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016da6:	fb02 f103 	mul.w	r1, r2, r3
 8016daa:	687b      	ldr	r3, [r7, #4]
 8016dac:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016dae:	4613      	mov	r3, r2
 8016db0:	00db      	lsls	r3, r3, #3
 8016db2:	4413      	add	r3, r2
 8016db4:	4299      	cmp	r1, r3
 8016db6:	d82a      	bhi.n	8016e0e <jpeg_core_output_dimensions+0x3d2>
    /* Provide 9/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 9L, (long) cinfo->block_size);
 8016db8:	687b      	ldr	r3, [r7, #4]
 8016dba:	69db      	ldr	r3, [r3, #28]
 8016dbc:	461a      	mov	r2, r3
 8016dbe:	4613      	mov	r3, r2
 8016dc0:	00db      	lsls	r3, r3, #3
 8016dc2:	441a      	add	r2, r3
 8016dc4:	687b      	ldr	r3, [r7, #4]
 8016dc6:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016dca:	4619      	mov	r1, r3
 8016dcc:	4610      	mov	r0, r2
 8016dce:	f015 ff6f 	bl	802ccb0 <jdiv_round_up>
 8016dd2:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016dd4:	461a      	mov	r2, r3
 8016dd6:	687b      	ldr	r3, [r7, #4]
 8016dd8:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 9L, (long) cinfo->block_size);
 8016dda:	687b      	ldr	r3, [r7, #4]
 8016ddc:	6a1b      	ldr	r3, [r3, #32]
 8016dde:	461a      	mov	r2, r3
 8016de0:	4613      	mov	r3, r2
 8016de2:	00db      	lsls	r3, r3, #3
 8016de4:	441a      	add	r2, r3
 8016de6:	687b      	ldr	r3, [r7, #4]
 8016de8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016dec:	4619      	mov	r1, r3
 8016dee:	4610      	mov	r0, r2
 8016df0:	f015 ff5e 	bl	802ccb0 <jdiv_round_up>
 8016df4:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016df6:	461a      	mov	r2, r3
 8016df8:	687b      	ldr	r3, [r7, #4]
 8016dfa:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 9;
 8016dfc:	687b      	ldr	r3, [r7, #4]
 8016dfe:	2209      	movs	r2, #9
 8016e00:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 9;
 8016e04:	687b      	ldr	r3, [r7, #4]
 8016e06:	2209      	movs	r2, #9
 8016e08:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016e0c:	e194      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 10) {
 8016e0e:	687b      	ldr	r3, [r7, #4]
 8016e10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016e12:	687a      	ldr	r2, [r7, #4]
 8016e14:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016e18:	fb02 f103 	mul.w	r1, r2, r3
 8016e1c:	687b      	ldr	r3, [r7, #4]
 8016e1e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016e20:	4613      	mov	r3, r2
 8016e22:	009b      	lsls	r3, r3, #2
 8016e24:	4413      	add	r3, r2
 8016e26:	005b      	lsls	r3, r3, #1
 8016e28:	4299      	cmp	r1, r3
 8016e2a:	d82e      	bhi.n	8016e8a <jpeg_core_output_dimensions+0x44e>
    /* Provide 10/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 10L, (long) cinfo->block_size);
 8016e2c:	687b      	ldr	r3, [r7, #4]
 8016e2e:	69db      	ldr	r3, [r3, #28]
 8016e30:	461a      	mov	r2, r3
 8016e32:	4613      	mov	r3, r2
 8016e34:	009b      	lsls	r3, r3, #2
 8016e36:	4413      	add	r3, r2
 8016e38:	005b      	lsls	r3, r3, #1
 8016e3a:	461a      	mov	r2, r3
 8016e3c:	687b      	ldr	r3, [r7, #4]
 8016e3e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016e42:	4619      	mov	r1, r3
 8016e44:	4610      	mov	r0, r2
 8016e46:	f015 ff33 	bl	802ccb0 <jdiv_round_up>
 8016e4a:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016e4c:	461a      	mov	r2, r3
 8016e4e:	687b      	ldr	r3, [r7, #4]
 8016e50:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 10L, (long) cinfo->block_size);
 8016e52:	687b      	ldr	r3, [r7, #4]
 8016e54:	6a1b      	ldr	r3, [r3, #32]
 8016e56:	461a      	mov	r2, r3
 8016e58:	4613      	mov	r3, r2
 8016e5a:	009b      	lsls	r3, r3, #2
 8016e5c:	4413      	add	r3, r2
 8016e5e:	005b      	lsls	r3, r3, #1
 8016e60:	461a      	mov	r2, r3
 8016e62:	687b      	ldr	r3, [r7, #4]
 8016e64:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016e68:	4619      	mov	r1, r3
 8016e6a:	4610      	mov	r0, r2
 8016e6c:	f015 ff20 	bl	802ccb0 <jdiv_round_up>
 8016e70:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016e72:	461a      	mov	r2, r3
 8016e74:	687b      	ldr	r3, [r7, #4]
 8016e76:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 10;
 8016e78:	687b      	ldr	r3, [r7, #4]
 8016e7a:	220a      	movs	r2, #10
 8016e7c:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 10;
 8016e80:	687b      	ldr	r3, [r7, #4]
 8016e82:	220a      	movs	r2, #10
 8016e84:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016e88:	e156      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 11) {
 8016e8a:	687b      	ldr	r3, [r7, #4]
 8016e8c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016e8e:	687a      	ldr	r2, [r7, #4]
 8016e90:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016e94:	fb02 f103 	mul.w	r1, r2, r3
 8016e98:	687b      	ldr	r3, [r7, #4]
 8016e9a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016e9c:	4613      	mov	r3, r2
 8016e9e:	009b      	lsls	r3, r3, #2
 8016ea0:	4413      	add	r3, r2
 8016ea2:	005b      	lsls	r3, r3, #1
 8016ea4:	4413      	add	r3, r2
 8016ea6:	4299      	cmp	r1, r3
 8016ea8:	d82e      	bhi.n	8016f08 <jpeg_core_output_dimensions+0x4cc>
    /* Provide 11/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 11L, (long) cinfo->block_size);
 8016eaa:	687b      	ldr	r3, [r7, #4]
 8016eac:	69db      	ldr	r3, [r3, #28]
 8016eae:	461a      	mov	r2, r3
 8016eb0:	4613      	mov	r3, r2
 8016eb2:	009b      	lsls	r3, r3, #2
 8016eb4:	4413      	add	r3, r2
 8016eb6:	005b      	lsls	r3, r3, #1
 8016eb8:	441a      	add	r2, r3
 8016eba:	687b      	ldr	r3, [r7, #4]
 8016ebc:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016ec0:	4619      	mov	r1, r3
 8016ec2:	4610      	mov	r0, r2
 8016ec4:	f015 fef4 	bl	802ccb0 <jdiv_round_up>
 8016ec8:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016eca:	461a      	mov	r2, r3
 8016ecc:	687b      	ldr	r3, [r7, #4]
 8016ece:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 11L, (long) cinfo->block_size);
 8016ed0:	687b      	ldr	r3, [r7, #4]
 8016ed2:	6a1b      	ldr	r3, [r3, #32]
 8016ed4:	461a      	mov	r2, r3
 8016ed6:	4613      	mov	r3, r2
 8016ed8:	009b      	lsls	r3, r3, #2
 8016eda:	4413      	add	r3, r2
 8016edc:	005b      	lsls	r3, r3, #1
 8016ede:	441a      	add	r2, r3
 8016ee0:	687b      	ldr	r3, [r7, #4]
 8016ee2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016ee6:	4619      	mov	r1, r3
 8016ee8:	4610      	mov	r0, r2
 8016eea:	f015 fee1 	bl	802ccb0 <jdiv_round_up>
 8016eee:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016ef0:	461a      	mov	r2, r3
 8016ef2:	687b      	ldr	r3, [r7, #4]
 8016ef4:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 11;
 8016ef6:	687b      	ldr	r3, [r7, #4]
 8016ef8:	220b      	movs	r2, #11
 8016efa:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 11;
 8016efe:	687b      	ldr	r3, [r7, #4]
 8016f00:	220b      	movs	r2, #11
 8016f02:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016f06:	e117      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 12) {
 8016f08:	687b      	ldr	r3, [r7, #4]
 8016f0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016f0c:	687a      	ldr	r2, [r7, #4]
 8016f0e:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016f12:	fb02 f103 	mul.w	r1, r2, r3
 8016f16:	687b      	ldr	r3, [r7, #4]
 8016f18:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016f1a:	4613      	mov	r3, r2
 8016f1c:	005b      	lsls	r3, r3, #1
 8016f1e:	4413      	add	r3, r2
 8016f20:	009b      	lsls	r3, r3, #2
 8016f22:	4299      	cmp	r1, r3
 8016f24:	d82e      	bhi.n	8016f84 <jpeg_core_output_dimensions+0x548>
    /* Provide 12/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 12L, (long) cinfo->block_size);
 8016f26:	687b      	ldr	r3, [r7, #4]
 8016f28:	69db      	ldr	r3, [r3, #28]
 8016f2a:	461a      	mov	r2, r3
 8016f2c:	4613      	mov	r3, r2
 8016f2e:	005b      	lsls	r3, r3, #1
 8016f30:	4413      	add	r3, r2
 8016f32:	009b      	lsls	r3, r3, #2
 8016f34:	461a      	mov	r2, r3
 8016f36:	687b      	ldr	r3, [r7, #4]
 8016f38:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016f3c:	4619      	mov	r1, r3
 8016f3e:	4610      	mov	r0, r2
 8016f40:	f015 feb6 	bl	802ccb0 <jdiv_round_up>
 8016f44:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016f46:	461a      	mov	r2, r3
 8016f48:	687b      	ldr	r3, [r7, #4]
 8016f4a:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 12L, (long) cinfo->block_size);
 8016f4c:	687b      	ldr	r3, [r7, #4]
 8016f4e:	6a1b      	ldr	r3, [r3, #32]
 8016f50:	461a      	mov	r2, r3
 8016f52:	4613      	mov	r3, r2
 8016f54:	005b      	lsls	r3, r3, #1
 8016f56:	4413      	add	r3, r2
 8016f58:	009b      	lsls	r3, r3, #2
 8016f5a:	461a      	mov	r2, r3
 8016f5c:	687b      	ldr	r3, [r7, #4]
 8016f5e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016f62:	4619      	mov	r1, r3
 8016f64:	4610      	mov	r0, r2
 8016f66:	f015 fea3 	bl	802ccb0 <jdiv_round_up>
 8016f6a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016f6c:	461a      	mov	r2, r3
 8016f6e:	687b      	ldr	r3, [r7, #4]
 8016f70:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 12;
 8016f72:	687b      	ldr	r3, [r7, #4]
 8016f74:	220c      	movs	r2, #12
 8016f76:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 12;
 8016f7a:	687b      	ldr	r3, [r7, #4]
 8016f7c:	220c      	movs	r2, #12
 8016f7e:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8016f82:	e0d9      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 13) {
 8016f84:	687b      	ldr	r3, [r7, #4]
 8016f86:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016f88:	687a      	ldr	r2, [r7, #4]
 8016f8a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8016f8e:	fb02 f103 	mul.w	r1, r2, r3
 8016f92:	687b      	ldr	r3, [r7, #4]
 8016f94:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016f96:	4613      	mov	r3, r2
 8016f98:	005b      	lsls	r3, r3, #1
 8016f9a:	4413      	add	r3, r2
 8016f9c:	009b      	lsls	r3, r3, #2
 8016f9e:	4413      	add	r3, r2
 8016fa0:	4299      	cmp	r1, r3
 8016fa2:	d82e      	bhi.n	8017002 <jpeg_core_output_dimensions+0x5c6>
    /* Provide 13/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 13L, (long) cinfo->block_size);
 8016fa4:	687b      	ldr	r3, [r7, #4]
 8016fa6:	69db      	ldr	r3, [r3, #28]
 8016fa8:	461a      	mov	r2, r3
 8016faa:	4613      	mov	r3, r2
 8016fac:	005b      	lsls	r3, r3, #1
 8016fae:	4413      	add	r3, r2
 8016fb0:	009b      	lsls	r3, r3, #2
 8016fb2:	441a      	add	r2, r3
 8016fb4:	687b      	ldr	r3, [r7, #4]
 8016fb6:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016fba:	4619      	mov	r1, r3
 8016fbc:	4610      	mov	r0, r2
 8016fbe:	f015 fe77 	bl	802ccb0 <jdiv_round_up>
 8016fc2:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8016fc4:	461a      	mov	r2, r3
 8016fc6:	687b      	ldr	r3, [r7, #4]
 8016fc8:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 13L, (long) cinfo->block_size);
 8016fca:	687b      	ldr	r3, [r7, #4]
 8016fcc:	6a1b      	ldr	r3, [r3, #32]
 8016fce:	461a      	mov	r2, r3
 8016fd0:	4613      	mov	r3, r2
 8016fd2:	005b      	lsls	r3, r3, #1
 8016fd4:	4413      	add	r3, r2
 8016fd6:	009b      	lsls	r3, r3, #2
 8016fd8:	441a      	add	r2, r3
 8016fda:	687b      	ldr	r3, [r7, #4]
 8016fdc:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8016fe0:	4619      	mov	r1, r3
 8016fe2:	4610      	mov	r0, r2
 8016fe4:	f015 fe64 	bl	802ccb0 <jdiv_round_up>
 8016fe8:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8016fea:	461a      	mov	r2, r3
 8016fec:	687b      	ldr	r3, [r7, #4]
 8016fee:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 13;
 8016ff0:	687b      	ldr	r3, [r7, #4]
 8016ff2:	220d      	movs	r2, #13
 8016ff4:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 13;
 8016ff8:	687b      	ldr	r3, [r7, #4]
 8016ffa:	220d      	movs	r2, #13
 8016ffc:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8017000:	e09a      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 14) {
 8017002:	687b      	ldr	r3, [r7, #4]
 8017004:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8017006:	687a      	ldr	r2, [r7, #4]
 8017008:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801700c:	fb02 f103 	mul.w	r1, r2, r3
 8017010:	687b      	ldr	r3, [r7, #4]
 8017012:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8017014:	4613      	mov	r3, r2
 8017016:	00db      	lsls	r3, r3, #3
 8017018:	1a9b      	subs	r3, r3, r2
 801701a:	005b      	lsls	r3, r3, #1
 801701c:	4299      	cmp	r1, r3
 801701e:	d82e      	bhi.n	801707e <jpeg_core_output_dimensions+0x642>
    /* Provide 14/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 14L, (long) cinfo->block_size);
 8017020:	687b      	ldr	r3, [r7, #4]
 8017022:	69db      	ldr	r3, [r3, #28]
 8017024:	461a      	mov	r2, r3
 8017026:	4613      	mov	r3, r2
 8017028:	00db      	lsls	r3, r3, #3
 801702a:	1a9b      	subs	r3, r3, r2
 801702c:	005b      	lsls	r3, r3, #1
 801702e:	461a      	mov	r2, r3
 8017030:	687b      	ldr	r3, [r7, #4]
 8017032:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8017036:	4619      	mov	r1, r3
 8017038:	4610      	mov	r0, r2
 801703a:	f015 fe39 	bl	802ccb0 <jdiv_round_up>
 801703e:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8017040:	461a      	mov	r2, r3
 8017042:	687b      	ldr	r3, [r7, #4]
 8017044:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 14L, (long) cinfo->block_size);
 8017046:	687b      	ldr	r3, [r7, #4]
 8017048:	6a1b      	ldr	r3, [r3, #32]
 801704a:	461a      	mov	r2, r3
 801704c:	4613      	mov	r3, r2
 801704e:	00db      	lsls	r3, r3, #3
 8017050:	1a9b      	subs	r3, r3, r2
 8017052:	005b      	lsls	r3, r3, #1
 8017054:	461a      	mov	r2, r3
 8017056:	687b      	ldr	r3, [r7, #4]
 8017058:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801705c:	4619      	mov	r1, r3
 801705e:	4610      	mov	r0, r2
 8017060:	f015 fe26 	bl	802ccb0 <jdiv_round_up>
 8017064:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8017066:	461a      	mov	r2, r3
 8017068:	687b      	ldr	r3, [r7, #4]
 801706a:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 14;
 801706c:	687b      	ldr	r3, [r7, #4]
 801706e:	220e      	movs	r2, #14
 8017070:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 14;
 8017074:	687b      	ldr	r3, [r7, #4]
 8017076:	220e      	movs	r2, #14
 8017078:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 801707c:	e05c      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 15) {
 801707e:	687b      	ldr	r3, [r7, #4]
 8017080:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8017082:	687a      	ldr	r2, [r7, #4]
 8017084:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8017088:	fb02 f103 	mul.w	r1, r2, r3
 801708c:	687b      	ldr	r3, [r7, #4]
 801708e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8017090:	4613      	mov	r3, r2
 8017092:	011b      	lsls	r3, r3, #4
 8017094:	1a9b      	subs	r3, r3, r2
 8017096:	4299      	cmp	r1, r3
 8017098:	d82a      	bhi.n	80170f0 <jpeg_core_output_dimensions+0x6b4>
    /* Provide 15/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 15L, (long) cinfo->block_size);
 801709a:	687b      	ldr	r3, [r7, #4]
 801709c:	69db      	ldr	r3, [r3, #28]
 801709e:	461a      	mov	r2, r3
 80170a0:	4613      	mov	r3, r2
 80170a2:	011b      	lsls	r3, r3, #4
 80170a4:	1a9a      	subs	r2, r3, r2
 80170a6:	687b      	ldr	r3, [r7, #4]
 80170a8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80170ac:	4619      	mov	r1, r3
 80170ae:	4610      	mov	r0, r2
 80170b0:	f015 fdfe 	bl	802ccb0 <jdiv_round_up>
 80170b4:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80170b6:	461a      	mov	r2, r3
 80170b8:	687b      	ldr	r3, [r7, #4]
 80170ba:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 15L, (long) cinfo->block_size);
 80170bc:	687b      	ldr	r3, [r7, #4]
 80170be:	6a1b      	ldr	r3, [r3, #32]
 80170c0:	461a      	mov	r2, r3
 80170c2:	4613      	mov	r3, r2
 80170c4:	011b      	lsls	r3, r3, #4
 80170c6:	1a9a      	subs	r2, r3, r2
 80170c8:	687b      	ldr	r3, [r7, #4]
 80170ca:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80170ce:	4619      	mov	r1, r3
 80170d0:	4610      	mov	r0, r2
 80170d2:	f015 fded 	bl	802ccb0 <jdiv_round_up>
 80170d6:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80170d8:	461a      	mov	r2, r3
 80170da:	687b      	ldr	r3, [r7, #4]
 80170dc:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 15;
 80170de:	687b      	ldr	r3, [r7, #4]
 80170e0:	220f      	movs	r2, #15
 80170e2:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 15;
 80170e6:	687b      	ldr	r3, [r7, #4]
 80170e8:	220f      	movs	r2, #15
 80170ea:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80170ee:	e023      	b.n	8017138 <jpeg_core_output_dimensions+0x6fc>
  } else {
    /* Provide 16/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 16L, (long) cinfo->block_size);
 80170f0:	687b      	ldr	r3, [r7, #4]
 80170f2:	69db      	ldr	r3, [r3, #28]
 80170f4:	011a      	lsls	r2, r3, #4
 80170f6:	687b      	ldr	r3, [r7, #4]
 80170f8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80170fc:	4619      	mov	r1, r3
 80170fe:	4610      	mov	r0, r2
 8017100:	f015 fdd6 	bl	802ccb0 <jdiv_round_up>
 8017104:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8017106:	461a      	mov	r2, r3
 8017108:	687b      	ldr	r3, [r7, #4]
 801710a:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 16L, (long) cinfo->block_size);
 801710c:	687b      	ldr	r3, [r7, #4]
 801710e:	6a1b      	ldr	r3, [r3, #32]
 8017110:	011a      	lsls	r2, r3, #4
 8017112:	687b      	ldr	r3, [r7, #4]
 8017114:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8017118:	4619      	mov	r1, r3
 801711a:	4610      	mov	r0, r2
 801711c:	f015 fdc8 	bl	802ccb0 <jdiv_round_up>
 8017120:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8017122:	461a      	mov	r2, r3
 8017124:	687b      	ldr	r3, [r7, #4]
 8017126:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 16;
 8017128:	687b      	ldr	r3, [r7, #4]
 801712a:	2210      	movs	r2, #16
 801712c:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 16;
 8017130:	687b      	ldr	r3, [r7, #4]
 8017132:	2210      	movs	r2, #16
 8017134:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
  }

  /* Recompute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017138:	2300      	movs	r3, #0
 801713a:	60fb      	str	r3, [r7, #12]
 801713c:	687b      	ldr	r3, [r7, #4]
 801713e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8017142:	60bb      	str	r3, [r7, #8]
 8017144:	e00f      	b.n	8017166 <jpeg_core_output_dimensions+0x72a>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size;
 8017146:	687b      	ldr	r3, [r7, #4]
 8017148:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
 801714c:	68bb      	ldr	r3, [r7, #8]
 801714e:	625a      	str	r2, [r3, #36]	@ 0x24
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size;
 8017150:	687b      	ldr	r3, [r7, #4]
 8017152:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
 8017156:	68bb      	ldr	r3, [r7, #8]
 8017158:	629a      	str	r2, [r3, #40]	@ 0x28
       ci++, compptr++) {
 801715a:	68fb      	ldr	r3, [r7, #12]
 801715c:	3301      	adds	r3, #1
 801715e:	60fb      	str	r3, [r7, #12]
 8017160:	68bb      	ldr	r3, [r7, #8]
 8017162:	3358      	adds	r3, #88	@ 0x58
 8017164:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017166:	687b      	ldr	r3, [r7, #4]
 8017168:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801716a:	68fa      	ldr	r2, [r7, #12]
 801716c:	429a      	cmp	r2, r3
 801716e:	dbea      	blt.n	8017146 <jpeg_core_output_dimensions+0x70a>
  /* jdinput.c has already initialized DCT_scaled_size,
   * and has computed unscaled downsampled_width and downsampled_height.
   */

#endif /* IDCT_SCALING_SUPPORTED */
}
 8017170:	bf00      	nop
 8017172:	bf00      	nop
 8017174:	3710      	adds	r7, #16
 8017176:	46bd      	mov	sp, r7
 8017178:	bd80      	pop	{r7, pc}
	...

0801717c <initial_setup>:


LOCAL(void)
initial_setup (j_decompress_ptr cinfo)
/* Called once, when first SOS marker is reached */
{
 801717c:	b580      	push	{r7, lr}
 801717e:	b084      	sub	sp, #16
 8017180:	af00      	add	r7, sp, #0
 8017182:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 8017184:	687b      	ldr	r3, [r7, #4]
 8017186:	6a1b      	ldr	r3, [r3, #32]
 8017188:	461a      	mov	r2, r3
 801718a:	f64f 73dc 	movw	r3, #65500	@ 0xffdc
 801718e:	429a      	cmp	r2, r3
 8017190:	dc06      	bgt.n	80171a0 <initial_setup+0x24>
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
 8017192:	687b      	ldr	r3, [r7, #4]
 8017194:	69db      	ldr	r3, [r3, #28]
 8017196:	461a      	mov	r2, r3
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 8017198:	f64f 73dc 	movw	r3, #65500	@ 0xffdc
 801719c:	429a      	cmp	r2, r3
 801719e:	dd0d      	ble.n	80171bc <initial_setup+0x40>
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
 80171a0:	687b      	ldr	r3, [r7, #4]
 80171a2:	681b      	ldr	r3, [r3, #0]
 80171a4:	222a      	movs	r2, #42	@ 0x2a
 80171a6:	615a      	str	r2, [r3, #20]
 80171a8:	687b      	ldr	r3, [r7, #4]
 80171aa:	681b      	ldr	r3, [r3, #0]
 80171ac:	f64f 72dc 	movw	r2, #65500	@ 0xffdc
 80171b0:	619a      	str	r2, [r3, #24]
 80171b2:	687b      	ldr	r3, [r7, #4]
 80171b4:	681b      	ldr	r3, [r3, #0]
 80171b6:	681b      	ldr	r3, [r3, #0]
 80171b8:	6878      	ldr	r0, [r7, #4]
 80171ba:	4798      	blx	r3

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
 80171bc:	687b      	ldr	r3, [r7, #4]
 80171be:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 80171c2:	2b08      	cmp	r3, #8
 80171c4:	d00e      	beq.n	80171e4 <initial_setup+0x68>
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 80171c6:	687b      	ldr	r3, [r7, #4]
 80171c8:	681b      	ldr	r3, [r3, #0]
 80171ca:	2210      	movs	r2, #16
 80171cc:	615a      	str	r2, [r3, #20]
 80171ce:	687b      	ldr	r3, [r7, #4]
 80171d0:	681b      	ldr	r3, [r3, #0]
 80171d2:	687a      	ldr	r2, [r7, #4]
 80171d4:	f8d2 20d4 	ldr.w	r2, [r2, #212]	@ 0xd4
 80171d8:	619a      	str	r2, [r3, #24]
 80171da:	687b      	ldr	r3, [r7, #4]
 80171dc:	681b      	ldr	r3, [r3, #0]
 80171de:	681b      	ldr	r3, [r3, #0]
 80171e0:	6878      	ldr	r0, [r7, #4]
 80171e2:	4798      	blx	r3

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
 80171e4:	687b      	ldr	r3, [r7, #4]
 80171e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80171e8:	2b0a      	cmp	r3, #10
 80171ea:	dd11      	ble.n	8017210 <initial_setup+0x94>
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
 80171ec:	687b      	ldr	r3, [r7, #4]
 80171ee:	681b      	ldr	r3, [r3, #0]
 80171f0:	221b      	movs	r2, #27
 80171f2:	615a      	str	r2, [r3, #20]
 80171f4:	687b      	ldr	r3, [r7, #4]
 80171f6:	681b      	ldr	r3, [r3, #0]
 80171f8:	687a      	ldr	r2, [r7, #4]
 80171fa:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80171fc:	619a      	str	r2, [r3, #24]
 80171fe:	687b      	ldr	r3, [r7, #4]
 8017200:	681b      	ldr	r3, [r3, #0]
 8017202:	220a      	movs	r2, #10
 8017204:	61da      	str	r2, [r3, #28]
 8017206:	687b      	ldr	r3, [r7, #4]
 8017208:	681b      	ldr	r3, [r3, #0]
 801720a:	681b      	ldr	r3, [r3, #0]
 801720c:	6878      	ldr	r0, [r7, #4]
 801720e:	4798      	blx	r3
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
 8017210:	687b      	ldr	r3, [r7, #4]
 8017212:	2201      	movs	r2, #1
 8017214:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
  cinfo->max_v_samp_factor = 1;
 8017218:	687b      	ldr	r3, [r7, #4]
 801721a:	2201      	movs	r2, #1
 801721c:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017220:	2300      	movs	r3, #0
 8017222:	60fb      	str	r3, [r7, #12]
 8017224:	687b      	ldr	r3, [r7, #4]
 8017226:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801722a:	60bb      	str	r3, [r7, #8]
 801722c:	e034      	b.n	8017298 <initial_setup+0x11c>
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 801722e:	68bb      	ldr	r3, [r7, #8]
 8017230:	689b      	ldr	r3, [r3, #8]
 8017232:	2b00      	cmp	r3, #0
 8017234:	dd0b      	ble.n	801724e <initial_setup+0xd2>
 8017236:	68bb      	ldr	r3, [r7, #8]
 8017238:	689b      	ldr	r3, [r3, #8]
 801723a:	2b04      	cmp	r3, #4
 801723c:	dc07      	bgt.n	801724e <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 801723e:	68bb      	ldr	r3, [r7, #8]
 8017240:	68db      	ldr	r3, [r3, #12]
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 8017242:	2b00      	cmp	r3, #0
 8017244:	dd03      	ble.n	801724e <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 8017246:	68bb      	ldr	r3, [r7, #8]
 8017248:	68db      	ldr	r3, [r3, #12]
 801724a:	2b04      	cmp	r3, #4
 801724c:	dd08      	ble.n	8017260 <initial_setup+0xe4>
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
 801724e:	687b      	ldr	r3, [r7, #4]
 8017250:	681b      	ldr	r3, [r3, #0]
 8017252:	2213      	movs	r2, #19
 8017254:	615a      	str	r2, [r3, #20]
 8017256:	687b      	ldr	r3, [r7, #4]
 8017258:	681b      	ldr	r3, [r3, #0]
 801725a:	681b      	ldr	r3, [r3, #0]
 801725c:	6878      	ldr	r0, [r7, #4]
 801725e:	4798      	blx	r3
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
 8017260:	68bb      	ldr	r3, [r7, #8]
 8017262:	689a      	ldr	r2, [r3, #8]
 8017264:	687b      	ldr	r3, [r7, #4]
 8017266:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801726a:	429a      	cmp	r2, r3
 801726c:	bfb8      	it	lt
 801726e:	461a      	movlt	r2, r3
 8017270:	687b      	ldr	r3, [r7, #4]
 8017272:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
 8017276:	68bb      	ldr	r3, [r7, #8]
 8017278:	68da      	ldr	r2, [r3, #12]
 801727a:	687b      	ldr	r3, [r7, #4]
 801727c:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8017280:	429a      	cmp	r2, r3
 8017282:	bfb8      	it	lt
 8017284:	461a      	movlt	r2, r3
 8017286:	687b      	ldr	r3, [r7, #4]
 8017288:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
       ci++, compptr++) {
 801728c:	68fb      	ldr	r3, [r7, #12]
 801728e:	3301      	adds	r3, #1
 8017290:	60fb      	str	r3, [r7, #12]
 8017292:	68bb      	ldr	r3, [r7, #8]
 8017294:	3358      	adds	r3, #88	@ 0x58
 8017296:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017298:	687b      	ldr	r3, [r7, #4]
 801729a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801729c:	68fa      	ldr	r2, [r7, #12]
 801729e:	429a      	cmp	r2, r3
 80172a0:	dbc5      	blt.n	801722e <initial_setup+0xb2>
				   compptr->v_samp_factor);
  }

  /* Derive block_size, natural_order, and lim_Se */
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 80172a2:	687b      	ldr	r3, [r7, #4]
 80172a4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 80172a8:	2b00      	cmp	r3, #0
 80172aa:	d109      	bne.n	80172c0 <initial_setup+0x144>
 80172ac:	687b      	ldr	r3, [r7, #4]
 80172ae:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80172b2:	2b00      	cmp	r3, #0
 80172b4:	d011      	beq.n	80172da <initial_setup+0x15e>
      cinfo->comps_in_scan)) { /* no pseudo SOS marker */
 80172b6:	687b      	ldr	r3, [r7, #4]
 80172b8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 80172bc:	2b00      	cmp	r3, #0
 80172be:	d00c      	beq.n	80172da <initial_setup+0x15e>
    cinfo->block_size = DCTSIZE;
 80172c0:	687b      	ldr	r3, [r7, #4]
 80172c2:	2208      	movs	r2, #8
 80172c4:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
    cinfo->natural_order = jpeg_natural_order;
 80172c8:	687b      	ldr	r3, [r7, #4]
 80172ca:	4ac4      	ldr	r2, [pc, #784]	@ (80175dc <initial_setup+0x460>)
 80172cc:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
    cinfo->lim_Se = DCTSIZE2-1;
 80172d0:	687b      	ldr	r3, [r7, #4]
 80172d2:	223f      	movs	r2, #63	@ 0x3f
 80172d4:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
 80172d8:	e1ca      	b.n	8017670 <initial_setup+0x4f4>
  } else
    switch (cinfo->Se) {
 80172da:	687b      	ldr	r3, [r7, #4]
 80172dc:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80172e0:	2bff      	cmp	r3, #255	@ 0xff
 80172e2:	f000 8196 	beq.w	8017612 <initial_setup+0x496>
 80172e6:	2bff      	cmp	r3, #255	@ 0xff
 80172e8:	f300 81a0 	bgt.w	801762c <initial_setup+0x4b0>
 80172ec:	2be0      	cmp	r3, #224	@ 0xe0
 80172ee:	f000 8183 	beq.w	80175f8 <initial_setup+0x47c>
 80172f2:	2be0      	cmp	r3, #224	@ 0xe0
 80172f4:	f300 819a 	bgt.w	801762c <initial_setup+0x4b0>
 80172f8:	2bc3      	cmp	r3, #195	@ 0xc3
 80172fa:	f000 8161 	beq.w	80175c0 <initial_setup+0x444>
 80172fe:	2bc3      	cmp	r3, #195	@ 0xc3
 8017300:	f300 8194 	bgt.w	801762c <initial_setup+0x4b0>
 8017304:	2ba8      	cmp	r3, #168	@ 0xa8
 8017306:	f000 814e 	beq.w	80175a6 <initial_setup+0x42a>
 801730a:	2ba8      	cmp	r3, #168	@ 0xa8
 801730c:	f300 818e 	bgt.w	801762c <initial_setup+0x4b0>
 8017310:	2b8f      	cmp	r3, #143	@ 0x8f
 8017312:	f000 813b 	beq.w	801758c <initial_setup+0x410>
 8017316:	2b8f      	cmp	r3, #143	@ 0x8f
 8017318:	f300 8188 	bgt.w	801762c <initial_setup+0x4b0>
 801731c:	2b78      	cmp	r3, #120	@ 0x78
 801731e:	f000 8128 	beq.w	8017572 <initial_setup+0x3f6>
 8017322:	2b78      	cmp	r3, #120	@ 0x78
 8017324:	f300 8182 	bgt.w	801762c <initial_setup+0x4b0>
 8017328:	2b63      	cmp	r3, #99	@ 0x63
 801732a:	f000 8115 	beq.w	8017558 <initial_setup+0x3dc>
 801732e:	2b63      	cmp	r3, #99	@ 0x63
 8017330:	f300 817c 	bgt.w	801762c <initial_setup+0x4b0>
 8017334:	2b3f      	cmp	r3, #63	@ 0x3f
 8017336:	f300 8089 	bgt.w	801744c <initial_setup+0x2d0>
 801733a:	2b00      	cmp	r3, #0
 801733c:	f2c0 8176 	blt.w	801762c <initial_setup+0x4b0>
 8017340:	2b3f      	cmp	r3, #63	@ 0x3f
 8017342:	f200 8173 	bhi.w	801762c <initial_setup+0x4b0>
 8017346:	a201      	add	r2, pc, #4	@ (adr r2, 801734c <initial_setup+0x1d0>)
 8017348:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801734c:	08017453 	.word	0x08017453
 8017350:	0801762d 	.word	0x0801762d
 8017354:	0801762d 	.word	0x0801762d
 8017358:	08017471 	.word	0x08017471
 801735c:	0801762d 	.word	0x0801762d
 8017360:	0801762d 	.word	0x0801762d
 8017364:	0801762d 	.word	0x0801762d
 8017368:	0801762d 	.word	0x0801762d
 801736c:	0801748f 	.word	0x0801748f
 8017370:	0801762d 	.word	0x0801762d
 8017374:	0801762d 	.word	0x0801762d
 8017378:	0801762d 	.word	0x0801762d
 801737c:	0801762d 	.word	0x0801762d
 8017380:	0801762d 	.word	0x0801762d
 8017384:	0801762d 	.word	0x0801762d
 8017388:	080174ad 	.word	0x080174ad
 801738c:	0801762d 	.word	0x0801762d
 8017390:	0801762d 	.word	0x0801762d
 8017394:	0801762d 	.word	0x0801762d
 8017398:	0801762d 	.word	0x0801762d
 801739c:	0801762d 	.word	0x0801762d
 80173a0:	0801762d 	.word	0x0801762d
 80173a4:	0801762d 	.word	0x0801762d
 80173a8:	0801762d 	.word	0x0801762d
 80173ac:	080174cb 	.word	0x080174cb
 80173b0:	0801762d 	.word	0x0801762d
 80173b4:	0801762d 	.word	0x0801762d
 80173b8:	0801762d 	.word	0x0801762d
 80173bc:	0801762d 	.word	0x0801762d
 80173c0:	0801762d 	.word	0x0801762d
 80173c4:	0801762d 	.word	0x0801762d
 80173c8:	0801762d 	.word	0x0801762d
 80173cc:	0801762d 	.word	0x0801762d
 80173d0:	0801762d 	.word	0x0801762d
 80173d4:	0801762d 	.word	0x0801762d
 80173d8:	080174e9 	.word	0x080174e9
 80173dc:	0801762d 	.word	0x0801762d
 80173e0:	0801762d 	.word	0x0801762d
 80173e4:	0801762d 	.word	0x0801762d
 80173e8:	0801762d 	.word	0x0801762d
 80173ec:	0801762d 	.word	0x0801762d
 80173f0:	0801762d 	.word	0x0801762d
 80173f4:	0801762d 	.word	0x0801762d
 80173f8:	0801762d 	.word	0x0801762d
 80173fc:	0801762d 	.word	0x0801762d
 8017400:	0801762d 	.word	0x0801762d
 8017404:	0801762d 	.word	0x0801762d
 8017408:	0801762d 	.word	0x0801762d
 801740c:	08017507 	.word	0x08017507
 8017410:	0801762d 	.word	0x0801762d
 8017414:	0801762d 	.word	0x0801762d
 8017418:	0801762d 	.word	0x0801762d
 801741c:	0801762d 	.word	0x0801762d
 8017420:	0801762d 	.word	0x0801762d
 8017424:	0801762d 	.word	0x0801762d
 8017428:	0801762d 	.word	0x0801762d
 801742c:	0801762d 	.word	0x0801762d
 8017430:	0801762d 	.word	0x0801762d
 8017434:	0801762d 	.word	0x0801762d
 8017438:	0801762d 	.word	0x0801762d
 801743c:	0801762d 	.word	0x0801762d
 8017440:	0801762d 	.word	0x0801762d
 8017444:	0801762d 	.word	0x0801762d
 8017448:	08017525 	.word	0x08017525
 801744c:	2b50      	cmp	r3, #80	@ 0x50
 801744e:	d076      	beq.n	801753e <initial_setup+0x3c2>
 8017450:	e0ec      	b.n	801762c <initial_setup+0x4b0>
    case (1*1-1):
      cinfo->block_size = 1;
 8017452:	687b      	ldr	r3, [r7, #4]
 8017454:	2201      	movs	r2, #1
 8017456:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order; /* not needed */
 801745a:	687b      	ldr	r3, [r7, #4]
 801745c:	4a5f      	ldr	r2, [pc, #380]	@ (80175dc <initial_setup+0x460>)
 801745e:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8017462:	687b      	ldr	r3, [r7, #4]
 8017464:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8017468:	687b      	ldr	r3, [r7, #4]
 801746a:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801746e:	e0ff      	b.n	8017670 <initial_setup+0x4f4>
    case (2*2-1):
      cinfo->block_size = 2;
 8017470:	687b      	ldr	r3, [r7, #4]
 8017472:	2202      	movs	r2, #2
 8017474:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order2;
 8017478:	687b      	ldr	r3, [r7, #4]
 801747a:	4a59      	ldr	r2, [pc, #356]	@ (80175e0 <initial_setup+0x464>)
 801747c:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8017480:	687b      	ldr	r3, [r7, #4]
 8017482:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8017486:	687b      	ldr	r3, [r7, #4]
 8017488:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801748c:	e0f0      	b.n	8017670 <initial_setup+0x4f4>
    case (3*3-1):
      cinfo->block_size = 3;
 801748e:	687b      	ldr	r3, [r7, #4]
 8017490:	2203      	movs	r2, #3
 8017492:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order3;
 8017496:	687b      	ldr	r3, [r7, #4]
 8017498:	4a52      	ldr	r2, [pc, #328]	@ (80175e4 <initial_setup+0x468>)
 801749a:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 801749e:	687b      	ldr	r3, [r7, #4]
 80174a0:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80174a4:	687b      	ldr	r3, [r7, #4]
 80174a6:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80174aa:	e0e1      	b.n	8017670 <initial_setup+0x4f4>
    case (4*4-1):
      cinfo->block_size = 4;
 80174ac:	687b      	ldr	r3, [r7, #4]
 80174ae:	2204      	movs	r2, #4
 80174b0:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order4;
 80174b4:	687b      	ldr	r3, [r7, #4]
 80174b6:	4a4c      	ldr	r2, [pc, #304]	@ (80175e8 <initial_setup+0x46c>)
 80174b8:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80174bc:	687b      	ldr	r3, [r7, #4]
 80174be:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80174c2:	687b      	ldr	r3, [r7, #4]
 80174c4:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80174c8:	e0d2      	b.n	8017670 <initial_setup+0x4f4>
    case (5*5-1):
      cinfo->block_size = 5;
 80174ca:	687b      	ldr	r3, [r7, #4]
 80174cc:	2205      	movs	r2, #5
 80174ce:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order5;
 80174d2:	687b      	ldr	r3, [r7, #4]
 80174d4:	4a45      	ldr	r2, [pc, #276]	@ (80175ec <initial_setup+0x470>)
 80174d6:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80174da:	687b      	ldr	r3, [r7, #4]
 80174dc:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80174e0:	687b      	ldr	r3, [r7, #4]
 80174e2:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80174e6:	e0c3      	b.n	8017670 <initial_setup+0x4f4>
    case (6*6-1):
      cinfo->block_size = 6;
 80174e8:	687b      	ldr	r3, [r7, #4]
 80174ea:	2206      	movs	r2, #6
 80174ec:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order6;
 80174f0:	687b      	ldr	r3, [r7, #4]
 80174f2:	4a3f      	ldr	r2, [pc, #252]	@ (80175f0 <initial_setup+0x474>)
 80174f4:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80174f8:	687b      	ldr	r3, [r7, #4]
 80174fa:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80174fe:	687b      	ldr	r3, [r7, #4]
 8017500:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8017504:	e0b4      	b.n	8017670 <initial_setup+0x4f4>
    case (7*7-1):
      cinfo->block_size = 7;
 8017506:	687b      	ldr	r3, [r7, #4]
 8017508:	2207      	movs	r2, #7
 801750a:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order7;
 801750e:	687b      	ldr	r3, [r7, #4]
 8017510:	4a38      	ldr	r2, [pc, #224]	@ (80175f4 <initial_setup+0x478>)
 8017512:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8017516:	687b      	ldr	r3, [r7, #4]
 8017518:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 801751c:	687b      	ldr	r3, [r7, #4]
 801751e:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8017522:	e0a5      	b.n	8017670 <initial_setup+0x4f4>
    case (8*8-1):
      cinfo->block_size = 8;
 8017524:	687b      	ldr	r3, [r7, #4]
 8017526:	2208      	movs	r2, #8
 8017528:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801752c:	687b      	ldr	r3, [r7, #4]
 801752e:	4a2b      	ldr	r2, [pc, #172]	@ (80175dc <initial_setup+0x460>)
 8017530:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8017534:	687b      	ldr	r3, [r7, #4]
 8017536:	223f      	movs	r2, #63	@ 0x3f
 8017538:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801753c:	e098      	b.n	8017670 <initial_setup+0x4f4>
    case (9*9-1):
      cinfo->block_size = 9;
 801753e:	687b      	ldr	r3, [r7, #4]
 8017540:	2209      	movs	r2, #9
 8017542:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8017546:	687b      	ldr	r3, [r7, #4]
 8017548:	4a24      	ldr	r2, [pc, #144]	@ (80175dc <initial_setup+0x460>)
 801754a:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801754e:	687b      	ldr	r3, [r7, #4]
 8017550:	223f      	movs	r2, #63	@ 0x3f
 8017552:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8017556:	e08b      	b.n	8017670 <initial_setup+0x4f4>
    case (10*10-1):
      cinfo->block_size = 10;
 8017558:	687b      	ldr	r3, [r7, #4]
 801755a:	220a      	movs	r2, #10
 801755c:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8017560:	687b      	ldr	r3, [r7, #4]
 8017562:	4a1e      	ldr	r2, [pc, #120]	@ (80175dc <initial_setup+0x460>)
 8017564:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8017568:	687b      	ldr	r3, [r7, #4]
 801756a:	223f      	movs	r2, #63	@ 0x3f
 801756c:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8017570:	e07e      	b.n	8017670 <initial_setup+0x4f4>
    case (11*11-1):
      cinfo->block_size = 11;
 8017572:	687b      	ldr	r3, [r7, #4]
 8017574:	220b      	movs	r2, #11
 8017576:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801757a:	687b      	ldr	r3, [r7, #4]
 801757c:	4a17      	ldr	r2, [pc, #92]	@ (80175dc <initial_setup+0x460>)
 801757e:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8017582:	687b      	ldr	r3, [r7, #4]
 8017584:	223f      	movs	r2, #63	@ 0x3f
 8017586:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801758a:	e071      	b.n	8017670 <initial_setup+0x4f4>
    case (12*12-1):
      cinfo->block_size = 12;
 801758c:	687b      	ldr	r3, [r7, #4]
 801758e:	220c      	movs	r2, #12
 8017590:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8017594:	687b      	ldr	r3, [r7, #4]
 8017596:	4a11      	ldr	r2, [pc, #68]	@ (80175dc <initial_setup+0x460>)
 8017598:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801759c:	687b      	ldr	r3, [r7, #4]
 801759e:	223f      	movs	r2, #63	@ 0x3f
 80175a0:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80175a4:	e064      	b.n	8017670 <initial_setup+0x4f4>
    case (13*13-1):
      cinfo->block_size = 13;
 80175a6:	687b      	ldr	r3, [r7, #4]
 80175a8:	220d      	movs	r2, #13
 80175aa:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80175ae:	687b      	ldr	r3, [r7, #4]
 80175b0:	4a0a      	ldr	r2, [pc, #40]	@ (80175dc <initial_setup+0x460>)
 80175b2:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80175b6:	687b      	ldr	r3, [r7, #4]
 80175b8:	223f      	movs	r2, #63	@ 0x3f
 80175ba:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80175be:	e057      	b.n	8017670 <initial_setup+0x4f4>
    case (14*14-1):
      cinfo->block_size = 14;
 80175c0:	687b      	ldr	r3, [r7, #4]
 80175c2:	220e      	movs	r2, #14
 80175c4:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80175c8:	687b      	ldr	r3, [r7, #4]
 80175ca:	4a04      	ldr	r2, [pc, #16]	@ (80175dc <initial_setup+0x460>)
 80175cc:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80175d0:	687b      	ldr	r3, [r7, #4]
 80175d2:	223f      	movs	r2, #63	@ 0x3f
 80175d4:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80175d8:	e04a      	b.n	8017670 <initial_setup+0x4f4>
 80175da:	bf00      	nop
 80175dc:	080308b0 	.word	0x080308b0
 80175e0:	08030d4c 	.word	0x08030d4c
 80175e4:	08030ce8 	.word	0x08030ce8
 80175e8:	08030c68 	.word	0x08030c68
 80175ec:	08030bc4 	.word	0x08030bc4
 80175f0:	08030af4 	.word	0x08030af4
 80175f4:	080309f0 	.word	0x080309f0
    case (15*15-1):
      cinfo->block_size = 15;
 80175f8:	687b      	ldr	r3, [r7, #4]
 80175fa:	220f      	movs	r2, #15
 80175fc:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8017600:	687b      	ldr	r3, [r7, #4]
 8017602:	4a72      	ldr	r2, [pc, #456]	@ (80177cc <initial_setup+0x650>)
 8017604:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8017608:	687b      	ldr	r3, [r7, #4]
 801760a:	223f      	movs	r2, #63	@ 0x3f
 801760c:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8017610:	e02e      	b.n	8017670 <initial_setup+0x4f4>
    case (16*16-1):
      cinfo->block_size = 16;
 8017612:	687b      	ldr	r3, [r7, #4]
 8017614:	2210      	movs	r2, #16
 8017616:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801761a:	687b      	ldr	r3, [r7, #4]
 801761c:	4a6b      	ldr	r2, [pc, #428]	@ (80177cc <initial_setup+0x650>)
 801761e:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8017622:	687b      	ldr	r3, [r7, #4]
 8017624:	223f      	movs	r2, #63	@ 0x3f
 8017626:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801762a:	e021      	b.n	8017670 <initial_setup+0x4f4>
    default:
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 801762c:	687b      	ldr	r3, [r7, #4]
 801762e:	681b      	ldr	r3, [r3, #0]
 8017630:	2211      	movs	r2, #17
 8017632:	615a      	str	r2, [r3, #20]
 8017634:	687b      	ldr	r3, [r7, #4]
 8017636:	681b      	ldr	r3, [r3, #0]
 8017638:	687a      	ldr	r2, [r7, #4]
 801763a:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 801763e:	619a      	str	r2, [r3, #24]
 8017640:	687b      	ldr	r3, [r7, #4]
 8017642:	681b      	ldr	r3, [r3, #0]
 8017644:	687a      	ldr	r2, [r7, #4]
 8017646:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 801764a:	61da      	str	r2, [r3, #28]
 801764c:	687b      	ldr	r3, [r7, #4]
 801764e:	681b      	ldr	r3, [r3, #0]
 8017650:	687a      	ldr	r2, [r7, #4]
 8017652:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 8017656:	621a      	str	r2, [r3, #32]
 8017658:	687b      	ldr	r3, [r7, #4]
 801765a:	681b      	ldr	r3, [r3, #0]
 801765c:	687a      	ldr	r2, [r7, #4]
 801765e:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 8017662:	625a      	str	r2, [r3, #36]	@ 0x24
 8017664:	687b      	ldr	r3, [r7, #4]
 8017666:	681b      	ldr	r3, [r3, #0]
 8017668:	681b      	ldr	r3, [r3, #0]
 801766a:	6878      	ldr	r0, [r7, #4]
 801766c:	4798      	blx	r3
	       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
      break;
 801766e:	bf00      	nop
   * In the full decompressor,
   * this will be overridden by jpeg_calc_output_dimensions in jdmaster.c;
   * but in the transcoder,
   * jpeg_calc_output_dimensions is not used, so we must do it here.
   */
  cinfo->min_DCT_h_scaled_size = cinfo->block_size;
 8017670:	687b      	ldr	r3, [r7, #4]
 8017672:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8017676:	687b      	ldr	r3, [r7, #4]
 8017678:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
  cinfo->min_DCT_v_scaled_size = cinfo->block_size;
 801767c:	687b      	ldr	r3, [r7, #4]
 801767e:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8017682:	687b      	ldr	r3, [r7, #4]
 8017684:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017688:	2300      	movs	r3, #0
 801768a:	60fb      	str	r3, [r7, #12]
 801768c:	687b      	ldr	r3, [r7, #4]
 801768e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8017692:	60bb      	str	r3, [r7, #8]
 8017694:	e065      	b.n	8017762 <initial_setup+0x5e6>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->block_size;
 8017696:	687b      	ldr	r3, [r7, #4]
 8017698:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 801769c:	68bb      	ldr	r3, [r7, #8]
 801769e:	625a      	str	r2, [r3, #36]	@ 0x24
    compptr->DCT_v_scaled_size = cinfo->block_size;
 80176a0:	687b      	ldr	r3, [r7, #4]
 80176a2:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 80176a6:	68bb      	ldr	r3, [r7, #8]
 80176a8:	629a      	str	r2, [r3, #40]	@ 0x28
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 80176aa:	687b      	ldr	r3, [r7, #4]
 80176ac:	69db      	ldr	r3, [r3, #28]
 80176ae:	461a      	mov	r2, r3
 80176b0:	68bb      	ldr	r3, [r7, #8]
 80176b2:	689b      	ldr	r3, [r3, #8]
 80176b4:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 80176b8:	687b      	ldr	r3, [r7, #4]
 80176ba:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 80176be:	687a      	ldr	r2, [r7, #4]
 80176c0:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80176c4:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 80176c8:	4619      	mov	r1, r3
 80176ca:	f015 faf1 	bl	802ccb0 <jdiv_round_up>
 80176ce:	4603      	mov	r3, r0
    compptr->width_in_blocks = (JDIMENSION)
 80176d0:	461a      	mov	r2, r3
 80176d2:	68bb      	ldr	r3, [r7, #8]
 80176d4:	61da      	str	r2, [r3, #28]
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 80176d6:	687b      	ldr	r3, [r7, #4]
 80176d8:	6a1b      	ldr	r3, [r3, #32]
 80176da:	461a      	mov	r2, r3
 80176dc:	68bb      	ldr	r3, [r7, #8]
 80176de:	68db      	ldr	r3, [r3, #12]
 80176e0:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 80176e4:	687b      	ldr	r3, [r7, #4]
 80176e6:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 80176ea:	687a      	ldr	r2, [r7, #4]
 80176ec:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80176f0:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 80176f4:	4619      	mov	r1, r3
 80176f6:	f015 fadb 	bl	802ccb0 <jdiv_round_up>
 80176fa:	4603      	mov	r3, r0
    compptr->height_in_blocks = (JDIMENSION)
 80176fc:	461a      	mov	r2, r3
 80176fe:	68bb      	ldr	r3, [r7, #8]
 8017700:	621a      	str	r2, [r3, #32]
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8017702:	687b      	ldr	r3, [r7, #4]
 8017704:	69db      	ldr	r3, [r3, #28]
 8017706:	461a      	mov	r2, r3
 8017708:	68bb      	ldr	r3, [r7, #8]
 801770a:	689b      	ldr	r3, [r3, #8]
 801770c:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_h_samp_factor);
 8017710:	687b      	ldr	r3, [r7, #4]
 8017712:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8017716:	4619      	mov	r1, r3
 8017718:	4610      	mov	r0, r2
 801771a:	f015 fac9 	bl	802ccb0 <jdiv_round_up>
 801771e:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 8017720:	461a      	mov	r2, r3
 8017722:	68bb      	ldr	r3, [r7, #8]
 8017724:	62da      	str	r2, [r3, #44]	@ 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8017726:	687b      	ldr	r3, [r7, #4]
 8017728:	6a1b      	ldr	r3, [r3, #32]
 801772a:	461a      	mov	r2, r3
 801772c:	68bb      	ldr	r3, [r7, #8]
 801772e:	68db      	ldr	r3, [r3, #12]
 8017730:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_v_samp_factor);
 8017734:	687b      	ldr	r3, [r7, #4]
 8017736:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 801773a:	4619      	mov	r1, r3
 801773c:	4610      	mov	r0, r2
 801773e:	f015 fab7 	bl	802ccb0 <jdiv_round_up>
 8017742:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 8017744:	461a      	mov	r2, r3
 8017746:	68bb      	ldr	r3, [r7, #8]
 8017748:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
 801774a:	68bb      	ldr	r3, [r7, #8]
 801774c:	2201      	movs	r2, #1
 801774e:	635a      	str	r2, [r3, #52]	@ 0x34
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
 8017750:	68bb      	ldr	r3, [r7, #8]
 8017752:	2200      	movs	r2, #0
 8017754:	651a      	str	r2, [r3, #80]	@ 0x50
       ci++, compptr++) {
 8017756:	68fb      	ldr	r3, [r7, #12]
 8017758:	3301      	adds	r3, #1
 801775a:	60fb      	str	r3, [r7, #12]
 801775c:	68bb      	ldr	r3, [r7, #8]
 801775e:	3358      	adds	r3, #88	@ 0x58
 8017760:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017762:	687b      	ldr	r3, [r7, #4]
 8017764:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017766:	68fa      	ldr	r2, [r7, #12]
 8017768:	429a      	cmp	r2, r3
 801776a:	db94      	blt.n	8017696 <initial_setup+0x51a>
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
 801776c:	687b      	ldr	r3, [r7, #4]
 801776e:	6a1b      	ldr	r3, [r3, #32]
 8017770:	4618      	mov	r0, r3
	          (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8017772:	687b      	ldr	r3, [r7, #4]
 8017774:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8017778:	687a      	ldr	r2, [r7, #4]
 801777a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801777e:	fb02 f303 	mul.w	r3, r2, r3
    jdiv_round_up((long) cinfo->image_height,
 8017782:	4619      	mov	r1, r3
 8017784:	f015 fa94 	bl	802ccb0 <jdiv_round_up>
 8017788:	4603      	mov	r3, r0
  cinfo->total_iMCU_rows = (JDIMENSION)
 801778a:	461a      	mov	r2, r3
 801778c:	687b      	ldr	r3, [r7, #4]
 801778e:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
 8017792:	687b      	ldr	r3, [r7, #4]
 8017794:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
 8017798:	687b      	ldr	r3, [r7, #4]
 801779a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801779c:	429a      	cmp	r2, r3
 801779e:	db04      	blt.n	80177aa <initial_setup+0x62e>
 80177a0:	687b      	ldr	r3, [r7, #4]
 80177a2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80177a6:	2b00      	cmp	r3, #0
 80177a8:	d005      	beq.n	80177b6 <initial_setup+0x63a>
    cinfo->inputctl->has_multiple_scans = TRUE;
 80177aa:	687b      	ldr	r3, [r7, #4]
 80177ac:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80177b0:	2201      	movs	r2, #1
 80177b2:	611a      	str	r2, [r3, #16]
 80177b4:	e005      	b.n	80177c2 <initial_setup+0x646>
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
 80177b6:	687b      	ldr	r3, [r7, #4]
 80177b8:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80177bc:	2200      	movs	r2, #0
 80177be:	611a      	str	r2, [r3, #16]
}
 80177c0:	bf00      	nop
 80177c2:	bf00      	nop
 80177c4:	3710      	adds	r7, #16
 80177c6:	46bd      	mov	sp, r7
 80177c8:	bd80      	pop	{r7, pc}
 80177ca:	bf00      	nop
 80177cc:	080308b0 	.word	0x080308b0

080177d0 <per_scan_setup>:

LOCAL(void)
per_scan_setup (j_decompress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
 80177d0:	b580      	push	{r7, lr}
 80177d2:	b086      	sub	sp, #24
 80177d4:	af00      	add	r7, sp, #0
 80177d6:	6078      	str	r0, [r7, #4]
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
 80177d8:	687b      	ldr	r3, [r7, #4]
 80177da:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80177de:	2b01      	cmp	r3, #1
 80177e0:	d139      	bne.n	8017856 <per_scan_setup+0x86>
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
 80177e2:	687b      	ldr	r3, [r7, #4]
 80177e4:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80177e8:	60bb      	str	r3, [r7, #8]
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
 80177ea:	68bb      	ldr	r3, [r7, #8]
 80177ec:	69da      	ldr	r2, [r3, #28]
 80177ee:	687b      	ldr	r3, [r7, #4]
 80177f0:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
 80177f4:	68bb      	ldr	r3, [r7, #8]
 80177f6:	6a1a      	ldr	r2, [r3, #32]
 80177f8:	687b      	ldr	r3, [r7, #4]
 80177fa:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
 80177fe:	68bb      	ldr	r3, [r7, #8]
 8017800:	2201      	movs	r2, #1
 8017802:	639a      	str	r2, [r3, #56]	@ 0x38
    compptr->MCU_height = 1;
 8017804:	68bb      	ldr	r3, [r7, #8]
 8017806:	2201      	movs	r2, #1
 8017808:	63da      	str	r2, [r3, #60]	@ 0x3c
    compptr->MCU_blocks = 1;
 801780a:	68bb      	ldr	r3, [r7, #8]
 801780c:	2201      	movs	r2, #1
 801780e:	641a      	str	r2, [r3, #64]	@ 0x40
    compptr->MCU_sample_width = compptr->DCT_h_scaled_size;
 8017810:	68bb      	ldr	r3, [r7, #8]
 8017812:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017814:	68bb      	ldr	r3, [r7, #8]
 8017816:	645a      	str	r2, [r3, #68]	@ 0x44
    compptr->last_col_width = 1;
 8017818:	68bb      	ldr	r3, [r7, #8]
 801781a:	2201      	movs	r2, #1
 801781c:	649a      	str	r2, [r3, #72]	@ 0x48
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 801781e:	68bb      	ldr	r3, [r7, #8]
 8017820:	6a1b      	ldr	r3, [r3, #32]
 8017822:	68ba      	ldr	r2, [r7, #8]
 8017824:	68d2      	ldr	r2, [r2, #12]
 8017826:	fbb3 f1f2 	udiv	r1, r3, r2
 801782a:	fb01 f202 	mul.w	r2, r1, r2
 801782e:	1a9b      	subs	r3, r3, r2
 8017830:	60fb      	str	r3, [r7, #12]
    if (tmp == 0) tmp = compptr->v_samp_factor;
 8017832:	68fb      	ldr	r3, [r7, #12]
 8017834:	2b00      	cmp	r3, #0
 8017836:	d102      	bne.n	801783e <per_scan_setup+0x6e>
 8017838:	68bb      	ldr	r3, [r7, #8]
 801783a:	68db      	ldr	r3, [r3, #12]
 801783c:	60fb      	str	r3, [r7, #12]
    compptr->last_row_height = tmp;
 801783e:	68bb      	ldr	r3, [r7, #8]
 8017840:	68fa      	ldr	r2, [r7, #12]
 8017842:	64da      	str	r2, [r3, #76]	@ 0x4c
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
 8017844:	687b      	ldr	r3, [r7, #4]
 8017846:	2201      	movs	r2, #1
 8017848:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
    cinfo->MCU_membership[0] = 0;
 801784c:	687b      	ldr	r3, [r7, #4]
 801784e:	2200      	movs	r2, #0
 8017850:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }
}
 8017854:	e0bc      	b.n	80179d0 <per_scan_setup+0x200>
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
 8017856:	687b      	ldr	r3, [r7, #4]
 8017858:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 801785c:	2b00      	cmp	r3, #0
 801785e:	dd04      	ble.n	801786a <per_scan_setup+0x9a>
 8017860:	687b      	ldr	r3, [r7, #4]
 8017862:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8017866:	2b04      	cmp	r3, #4
 8017868:	dd12      	ble.n	8017890 <per_scan_setup+0xc0>
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
 801786a:	687b      	ldr	r3, [r7, #4]
 801786c:	681b      	ldr	r3, [r3, #0]
 801786e:	221b      	movs	r2, #27
 8017870:	615a      	str	r2, [r3, #20]
 8017872:	687b      	ldr	r3, [r7, #4]
 8017874:	681b      	ldr	r3, [r3, #0]
 8017876:	687a      	ldr	r2, [r7, #4]
 8017878:	f8d2 2150 	ldr.w	r2, [r2, #336]	@ 0x150
 801787c:	619a      	str	r2, [r3, #24]
 801787e:	687b      	ldr	r3, [r7, #4]
 8017880:	681b      	ldr	r3, [r3, #0]
 8017882:	2204      	movs	r2, #4
 8017884:	61da      	str	r2, [r3, #28]
 8017886:	687b      	ldr	r3, [r7, #4]
 8017888:	681b      	ldr	r3, [r3, #0]
 801788a:	681b      	ldr	r3, [r3, #0]
 801788c:	6878      	ldr	r0, [r7, #4]
 801788e:	4798      	blx	r3
      jdiv_round_up((long) cinfo->image_width,
 8017890:	687b      	ldr	r3, [r7, #4]
 8017892:	69db      	ldr	r3, [r3, #28]
 8017894:	4618      	mov	r0, r3
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8017896:	687b      	ldr	r3, [r7, #4]
 8017898:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801789c:	687a      	ldr	r2, [r7, #4]
 801789e:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80178a2:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width,
 80178a6:	4619      	mov	r1, r3
 80178a8:	f015 fa02 	bl	802ccb0 <jdiv_round_up>
 80178ac:	4603      	mov	r3, r0
    cinfo->MCUs_per_row = (JDIMENSION)
 80178ae:	461a      	mov	r2, r3
 80178b0:	687b      	ldr	r3, [r7, #4]
 80178b2:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
      jdiv_round_up((long) cinfo->image_height,
 80178b6:	687b      	ldr	r3, [r7, #4]
 80178b8:	6a1b      	ldr	r3, [r3, #32]
 80178ba:	4618      	mov	r0, r3
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 80178bc:	687b      	ldr	r3, [r7, #4]
 80178be:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 80178c2:	687a      	ldr	r2, [r7, #4]
 80178c4:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80178c8:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height,
 80178cc:	4619      	mov	r1, r3
 80178ce:	f015 f9ef 	bl	802ccb0 <jdiv_round_up>
 80178d2:	4603      	mov	r3, r0
    cinfo->MCU_rows_in_scan = (JDIMENSION)
 80178d4:	461a      	mov	r2, r3
 80178d6:	687b      	ldr	r3, [r7, #4]
 80178d8:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
    cinfo->blocks_in_MCU = 0;
 80178dc:	687b      	ldr	r3, [r7, #4]
 80178de:	2200      	movs	r2, #0
 80178e0:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80178e4:	2300      	movs	r3, #0
 80178e6:	617b      	str	r3, [r7, #20]
 80178e8:	e06c      	b.n	80179c4 <per_scan_setup+0x1f4>
      compptr = cinfo->cur_comp_info[ci];
 80178ea:	687a      	ldr	r2, [r7, #4]
 80178ec:	697b      	ldr	r3, [r7, #20]
 80178ee:	3354      	adds	r3, #84	@ 0x54
 80178f0:	009b      	lsls	r3, r3, #2
 80178f2:	4413      	add	r3, r2
 80178f4:	685b      	ldr	r3, [r3, #4]
 80178f6:	60bb      	str	r3, [r7, #8]
      compptr->MCU_width = compptr->h_samp_factor;
 80178f8:	68bb      	ldr	r3, [r7, #8]
 80178fa:	689a      	ldr	r2, [r3, #8]
 80178fc:	68bb      	ldr	r3, [r7, #8]
 80178fe:	639a      	str	r2, [r3, #56]	@ 0x38
      compptr->MCU_height = compptr->v_samp_factor;
 8017900:	68bb      	ldr	r3, [r7, #8]
 8017902:	68da      	ldr	r2, [r3, #12]
 8017904:	68bb      	ldr	r3, [r7, #8]
 8017906:	63da      	str	r2, [r3, #60]	@ 0x3c
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
 8017908:	68bb      	ldr	r3, [r7, #8]
 801790a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801790c:	68ba      	ldr	r2, [r7, #8]
 801790e:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8017910:	fb03 f202 	mul.w	r2, r3, r2
 8017914:	68bb      	ldr	r3, [r7, #8]
 8017916:	641a      	str	r2, [r3, #64]	@ 0x40
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_h_scaled_size;
 8017918:	68bb      	ldr	r3, [r7, #8]
 801791a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801791c:	68ba      	ldr	r2, [r7, #8]
 801791e:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8017920:	fb03 f202 	mul.w	r2, r3, r2
 8017924:	68bb      	ldr	r3, [r7, #8]
 8017926:	645a      	str	r2, [r3, #68]	@ 0x44
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
 8017928:	68bb      	ldr	r3, [r7, #8]
 801792a:	69db      	ldr	r3, [r3, #28]
 801792c:	68ba      	ldr	r2, [r7, #8]
 801792e:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8017930:	fbb3 f1f2 	udiv	r1, r3, r2
 8017934:	fb01 f202 	mul.w	r2, r1, r2
 8017938:	1a9b      	subs	r3, r3, r2
 801793a:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_width;
 801793c:	68fb      	ldr	r3, [r7, #12]
 801793e:	2b00      	cmp	r3, #0
 8017940:	d102      	bne.n	8017948 <per_scan_setup+0x178>
 8017942:	68bb      	ldr	r3, [r7, #8]
 8017944:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8017946:	60fb      	str	r3, [r7, #12]
      compptr->last_col_width = tmp;
 8017948:	68bb      	ldr	r3, [r7, #8]
 801794a:	68fa      	ldr	r2, [r7, #12]
 801794c:	649a      	str	r2, [r3, #72]	@ 0x48
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
 801794e:	68bb      	ldr	r3, [r7, #8]
 8017950:	6a1b      	ldr	r3, [r3, #32]
 8017952:	68ba      	ldr	r2, [r7, #8]
 8017954:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8017956:	fbb3 f1f2 	udiv	r1, r3, r2
 801795a:	fb01 f202 	mul.w	r2, r1, r2
 801795e:	1a9b      	subs	r3, r3, r2
 8017960:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_height;
 8017962:	68fb      	ldr	r3, [r7, #12]
 8017964:	2b00      	cmp	r3, #0
 8017966:	d102      	bne.n	801796e <per_scan_setup+0x19e>
 8017968:	68bb      	ldr	r3, [r7, #8]
 801796a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801796c:	60fb      	str	r3, [r7, #12]
      compptr->last_row_height = tmp;
 801796e:	68bb      	ldr	r3, [r7, #8]
 8017970:	68fa      	ldr	r2, [r7, #12]
 8017972:	64da      	str	r2, [r3, #76]	@ 0x4c
      mcublks = compptr->MCU_blocks;
 8017974:	68bb      	ldr	r3, [r7, #8]
 8017976:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8017978:	613b      	str	r3, [r7, #16]
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
 801797a:	687b      	ldr	r3, [r7, #4]
 801797c:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
 8017980:	693b      	ldr	r3, [r7, #16]
 8017982:	4413      	add	r3, r2
 8017984:	2b0a      	cmp	r3, #10
 8017986:	dd15      	ble.n	80179b4 <per_scan_setup+0x1e4>
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
 8017988:	687b      	ldr	r3, [r7, #4]
 801798a:	681b      	ldr	r3, [r3, #0]
 801798c:	220e      	movs	r2, #14
 801798e:	615a      	str	r2, [r3, #20]
 8017990:	687b      	ldr	r3, [r7, #4]
 8017992:	681b      	ldr	r3, [r3, #0]
 8017994:	681b      	ldr	r3, [r3, #0]
 8017996:	6878      	ldr	r0, [r7, #4]
 8017998:	4798      	blx	r3
      while (mcublks-- > 0) {
 801799a:	e00b      	b.n	80179b4 <per_scan_setup+0x1e4>
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
 801799c:	687b      	ldr	r3, [r7, #4]
 801799e:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 80179a2:	1c59      	adds	r1, r3, #1
 80179a4:	687a      	ldr	r2, [r7, #4]
 80179a6:	f8c2 116c 	str.w	r1, [r2, #364]	@ 0x16c
 80179aa:	687a      	ldr	r2, [r7, #4]
 80179ac:	335c      	adds	r3, #92	@ 0x5c
 80179ae:	6979      	ldr	r1, [r7, #20]
 80179b0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      while (mcublks-- > 0) {
 80179b4:	693b      	ldr	r3, [r7, #16]
 80179b6:	1e5a      	subs	r2, r3, #1
 80179b8:	613a      	str	r2, [r7, #16]
 80179ba:	2b00      	cmp	r3, #0
 80179bc:	dcee      	bgt.n	801799c <per_scan_setup+0x1cc>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80179be:	697b      	ldr	r3, [r7, #20]
 80179c0:	3301      	adds	r3, #1
 80179c2:	617b      	str	r3, [r7, #20]
 80179c4:	687b      	ldr	r3, [r7, #4]
 80179c6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80179ca:	697a      	ldr	r2, [r7, #20]
 80179cc:	429a      	cmp	r2, r3
 80179ce:	db8c      	blt.n	80178ea <per_scan_setup+0x11a>
}
 80179d0:	bf00      	nop
 80179d2:	3718      	adds	r7, #24
 80179d4:	46bd      	mov	sp, r7
 80179d6:	bd80      	pop	{r7, pc}

080179d8 <latch_quant_tables>:
 * not at the current Q-table slots.
 */

LOCAL(void)
latch_quant_tables (j_decompress_ptr cinfo)
{
 80179d8:	b580      	push	{r7, lr}
 80179da:	b086      	sub	sp, #24
 80179dc:	af00      	add	r7, sp, #0
 80179de:	6078      	str	r0, [r7, #4]
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80179e0:	2300      	movs	r3, #0
 80179e2:	617b      	str	r3, [r7, #20]
 80179e4:	e043      	b.n	8017a6e <latch_quant_tables+0x96>
    compptr = cinfo->cur_comp_info[ci];
 80179e6:	687a      	ldr	r2, [r7, #4]
 80179e8:	697b      	ldr	r3, [r7, #20]
 80179ea:	3354      	adds	r3, #84	@ 0x54
 80179ec:	009b      	lsls	r3, r3, #2
 80179ee:	4413      	add	r3, r2
 80179f0:	685b      	ldr	r3, [r3, #4]
 80179f2:	613b      	str	r3, [r7, #16]
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
 80179f4:	693b      	ldr	r3, [r7, #16]
 80179f6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80179f8:	2b00      	cmp	r3, #0
 80179fa:	d134      	bne.n	8017a66 <latch_quant_tables+0x8e>
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
 80179fc:	693b      	ldr	r3, [r7, #16]
 80179fe:	691b      	ldr	r3, [r3, #16]
 8017a00:	60fb      	str	r3, [r7, #12]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8017a02:	68fb      	ldr	r3, [r7, #12]
 8017a04:	2b00      	cmp	r3, #0
 8017a06:	db0a      	blt.n	8017a1e <latch_quant_tables+0x46>
 8017a08:	68fb      	ldr	r3, [r7, #12]
 8017a0a:	2b03      	cmp	r3, #3
 8017a0c:	dc07      	bgt.n	8017a1e <latch_quant_tables+0x46>
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
 8017a0e:	687a      	ldr	r2, [r7, #4]
 8017a10:	68fb      	ldr	r3, [r7, #12]
 8017a12:	3328      	adds	r3, #40	@ 0x28
 8017a14:	009b      	lsls	r3, r3, #2
 8017a16:	4413      	add	r3, r2
 8017a18:	685b      	ldr	r3, [r3, #4]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8017a1a:	2b00      	cmp	r3, #0
 8017a1c:	d10c      	bne.n	8017a38 <latch_quant_tables+0x60>
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
 8017a1e:	687b      	ldr	r3, [r7, #4]
 8017a20:	681b      	ldr	r3, [r3, #0]
 8017a22:	2236      	movs	r2, #54	@ 0x36
 8017a24:	615a      	str	r2, [r3, #20]
 8017a26:	687b      	ldr	r3, [r7, #4]
 8017a28:	681b      	ldr	r3, [r3, #0]
 8017a2a:	68fa      	ldr	r2, [r7, #12]
 8017a2c:	619a      	str	r2, [r3, #24]
 8017a2e:	687b      	ldr	r3, [r7, #4]
 8017a30:	681b      	ldr	r3, [r3, #0]
 8017a32:	681b      	ldr	r3, [r3, #0]
 8017a34:	6878      	ldr	r0, [r7, #4]
 8017a36:	4798      	blx	r3
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017a38:	687b      	ldr	r3, [r7, #4]
 8017a3a:	685b      	ldr	r3, [r3, #4]
 8017a3c:	681b      	ldr	r3, [r3, #0]
 8017a3e:	2284      	movs	r2, #132	@ 0x84
 8017a40:	2101      	movs	r1, #1
 8017a42:	6878      	ldr	r0, [r7, #4]
 8017a44:	4798      	blx	r3
 8017a46:	60b8      	str	r0, [r7, #8]
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
 8017a48:	687a      	ldr	r2, [r7, #4]
 8017a4a:	68fb      	ldr	r3, [r7, #12]
 8017a4c:	3328      	adds	r3, #40	@ 0x28
 8017a4e:	009b      	lsls	r3, r3, #2
 8017a50:	4413      	add	r3, r2
 8017a52:	685b      	ldr	r3, [r3, #4]
 8017a54:	2284      	movs	r2, #132	@ 0x84
 8017a56:	4619      	mov	r1, r3
 8017a58:	68b8      	ldr	r0, [r7, #8]
 8017a5a:	f015 ff56 	bl	802d90a <memcpy>
    compptr->quant_table = qtbl;
 8017a5e:	693b      	ldr	r3, [r7, #16]
 8017a60:	68ba      	ldr	r2, [r7, #8]
 8017a62:	651a      	str	r2, [r3, #80]	@ 0x50
 8017a64:	e000      	b.n	8017a68 <latch_quant_tables+0x90>
      continue;
 8017a66:	bf00      	nop
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8017a68:	697b      	ldr	r3, [r7, #20]
 8017a6a:	3301      	adds	r3, #1
 8017a6c:	617b      	str	r3, [r7, #20]
 8017a6e:	687b      	ldr	r3, [r7, #4]
 8017a70:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8017a74:	697a      	ldr	r2, [r7, #20]
 8017a76:	429a      	cmp	r2, r3
 8017a78:	dbb5      	blt.n	80179e6 <latch_quant_tables+0xe>
  }
}
 8017a7a:	bf00      	nop
 8017a7c:	bf00      	nop
 8017a7e:	3718      	adds	r7, #24
 8017a80:	46bd      	mov	sp, r7
 8017a82:	bd80      	pop	{r7, pc}

08017a84 <start_input_pass>:
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 8017a84:	b580      	push	{r7, lr}
 8017a86:	b082      	sub	sp, #8
 8017a88:	af00      	add	r7, sp, #0
 8017a8a:	6078      	str	r0, [r7, #4]
  per_scan_setup(cinfo);
 8017a8c:	6878      	ldr	r0, [r7, #4]
 8017a8e:	f7ff fe9f 	bl	80177d0 <per_scan_setup>
  latch_quant_tables(cinfo);
 8017a92:	6878      	ldr	r0, [r7, #4]
 8017a94:	f7ff ffa0 	bl	80179d8 <latch_quant_tables>
  (*cinfo->entropy->start_pass) (cinfo);
 8017a98:	687b      	ldr	r3, [r7, #4]
 8017a9a:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8017a9e:	681b      	ldr	r3, [r3, #0]
 8017aa0:	6878      	ldr	r0, [r7, #4]
 8017aa2:	4798      	blx	r3
  (*cinfo->coef->start_input_pass) (cinfo);
 8017aa4:	687b      	ldr	r3, [r7, #4]
 8017aa6:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8017aaa:	681b      	ldr	r3, [r3, #0]
 8017aac:	6878      	ldr	r0, [r7, #4]
 8017aae:	4798      	blx	r3
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
 8017ab0:	687b      	ldr	r3, [r7, #4]
 8017ab2:	f8d3 21c0 	ldr.w	r2, [r3, #448]	@ 0x1c0
 8017ab6:	687b      	ldr	r3, [r7, #4]
 8017ab8:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8017abc:	6852      	ldr	r2, [r2, #4]
 8017abe:	601a      	str	r2, [r3, #0]
}
 8017ac0:	bf00      	nop
 8017ac2:	3708      	adds	r7, #8
 8017ac4:	46bd      	mov	sp, r7
 8017ac6:	bd80      	pop	{r7, pc}

08017ac8 <finish_input_pass>:
 * the expected data of the scan.
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
 8017ac8:	b480      	push	{r7}
 8017aca:	b083      	sub	sp, #12
 8017acc:	af00      	add	r7, sp, #0
 8017ace:	6078      	str	r0, [r7, #4]
  cinfo->inputctl->consume_input = consume_markers;
 8017ad0:	687b      	ldr	r3, [r7, #4]
 8017ad2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8017ad6:	4a04      	ldr	r2, [pc, #16]	@ (8017ae8 <finish_input_pass+0x20>)
 8017ad8:	601a      	str	r2, [r3, #0]
}
 8017ada:	bf00      	nop
 8017adc:	370c      	adds	r7, #12
 8017ade:	46bd      	mov	sp, r7
 8017ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ae4:	4770      	bx	lr
 8017ae6:	bf00      	nop
 8017ae8:	08017aed 	.word	0x08017aed

08017aec <consume_markers>:
 * read_markers is processed and then skipped for other markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
 8017aec:	b580      	push	{r7, lr}
 8017aee:	b084      	sub	sp, #16
 8017af0:	af00      	add	r7, sp, #0
 8017af2:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8017af4:	687b      	ldr	r3, [r7, #4]
 8017af6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8017afa:	60fb      	str	r3, [r7, #12]
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
 8017afc:	68fb      	ldr	r3, [r7, #12]
 8017afe:	695b      	ldr	r3, [r3, #20]
 8017b00:	2b00      	cmp	r3, #0
 8017b02:	d001      	beq.n	8017b08 <consume_markers+0x1c>
    return JPEG_REACHED_EOI;
 8017b04:	2302      	movs	r3, #2
 8017b06:	e06e      	b.n	8017be6 <consume_markers+0xfa>

  for (;;) {			/* Loop to pass pseudo SOS marker */
    val = (*cinfo->marker->read_markers) (cinfo);
 8017b08:	687b      	ldr	r3, [r7, #4]
 8017b0a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8017b0e:	685b      	ldr	r3, [r3, #4]
 8017b10:	6878      	ldr	r0, [r7, #4]
 8017b12:	4798      	blx	r3
 8017b14:	60b8      	str	r0, [r7, #8]

    switch (val) {
 8017b16:	68bb      	ldr	r3, [r7, #8]
 8017b18:	2b02      	cmp	r3, #2
 8017b1a:	d037      	beq.n	8017b8c <consume_markers+0xa0>
 8017b1c:	68bb      	ldr	r3, [r7, #8]
 8017b1e:	2b02      	cmp	r3, #2
 8017b20:	dc5d      	bgt.n	8017bde <consume_markers+0xf2>
 8017b22:	68bb      	ldr	r3, [r7, #8]
 8017b24:	2b00      	cmp	r3, #0
 8017b26:	d058      	beq.n	8017bda <consume_markers+0xee>
 8017b28:	68bb      	ldr	r3, [r7, #8]
 8017b2a:	2b01      	cmp	r3, #1
 8017b2c:	d157      	bne.n	8017bde <consume_markers+0xf2>
    case JPEG_REACHED_SOS:	/* Found SOS */
      if (inputctl->inheaders) { /* 1st SOS */
 8017b2e:	68fb      	ldr	r3, [r7, #12]
 8017b30:	699b      	ldr	r3, [r3, #24]
 8017b32:	2b00      	cmp	r3, #0
 8017b34:	d013      	beq.n	8017b5e <consume_markers+0x72>
	if (inputctl->inheaders == 1)
 8017b36:	68fb      	ldr	r3, [r7, #12]
 8017b38:	699b      	ldr	r3, [r3, #24]
 8017b3a:	2b01      	cmp	r3, #1
 8017b3c:	d102      	bne.n	8017b44 <consume_markers+0x58>
	  initial_setup(cinfo);
 8017b3e:	6878      	ldr	r0, [r7, #4]
 8017b40:	f7ff fb1c 	bl	801717c <initial_setup>
	if (cinfo->comps_in_scan == 0) { /* pseudo SOS marker */
 8017b44:	687b      	ldr	r3, [r7, #4]
 8017b46:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8017b4a:	2b00      	cmp	r3, #0
 8017b4c:	d103      	bne.n	8017b56 <consume_markers+0x6a>
	  inputctl->inheaders = 2;
 8017b4e:	68fb      	ldr	r3, [r7, #12]
 8017b50:	2202      	movs	r2, #2
 8017b52:	619a      	str	r2, [r3, #24]
	  break;
 8017b54:	e046      	b.n	8017be4 <consume_markers+0xf8>
	}
	inputctl->inheaders = 0;
 8017b56:	68fb      	ldr	r3, [r7, #12]
 8017b58:	2200      	movs	r2, #0
 8017b5a:	619a      	str	r2, [r3, #24]
 8017b5c:	e014      	b.n	8017b88 <consume_markers+0x9c>
	/* Note: start_input_pass must be called by jdmaster.c
	 * before any more input can be consumed.  jdapimin.c is
	 * responsible for enforcing this sequencing.
	 */
      } else {			/* 2nd or later SOS marker */
	if (! inputctl->pub.has_multiple_scans)
 8017b5e:	68fb      	ldr	r3, [r7, #12]
 8017b60:	691b      	ldr	r3, [r3, #16]
 8017b62:	2b00      	cmp	r3, #0
 8017b64:	d108      	bne.n	8017b78 <consume_markers+0x8c>
	  ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
 8017b66:	687b      	ldr	r3, [r7, #4]
 8017b68:	681b      	ldr	r3, [r3, #0]
 8017b6a:	2224      	movs	r2, #36	@ 0x24
 8017b6c:	615a      	str	r2, [r3, #20]
 8017b6e:	687b      	ldr	r3, [r7, #4]
 8017b70:	681b      	ldr	r3, [r3, #0]
 8017b72:	681b      	ldr	r3, [r3, #0]
 8017b74:	6878      	ldr	r0, [r7, #4]
 8017b76:	4798      	blx	r3
	if (cinfo->comps_in_scan == 0) /* unexpected pseudo SOS marker */
 8017b78:	687b      	ldr	r3, [r7, #4]
 8017b7a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8017b7e:	2b00      	cmp	r3, #0
 8017b80:	d02f      	beq.n	8017be2 <consume_markers+0xf6>
	  break;
	start_input_pass(cinfo);
 8017b82:	6878      	ldr	r0, [r7, #4]
 8017b84:	f7ff ff7e 	bl	8017a84 <start_input_pass>
      }
      return val;
 8017b88:	68bb      	ldr	r3, [r7, #8]
 8017b8a:	e02c      	b.n	8017be6 <consume_markers+0xfa>
    case JPEG_REACHED_EOI:	/* Found EOI */
      inputctl->pub.eoi_reached = TRUE;
 8017b8c:	68fb      	ldr	r3, [r7, #12]
 8017b8e:	2201      	movs	r2, #1
 8017b90:	615a      	str	r2, [r3, #20]
      if (inputctl->inheaders) { /* Tables-only datastream, apparently */
 8017b92:	68fb      	ldr	r3, [r7, #12]
 8017b94:	699b      	ldr	r3, [r3, #24]
 8017b96:	2b00      	cmp	r3, #0
 8017b98:	d00f      	beq.n	8017bba <consume_markers+0xce>
	if (cinfo->marker->saw_SOF)
 8017b9a:	687b      	ldr	r3, [r7, #4]
 8017b9c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8017ba0:	691b      	ldr	r3, [r3, #16]
 8017ba2:	2b00      	cmp	r3, #0
 8017ba4:	d017      	beq.n	8017bd6 <consume_markers+0xea>
	  ERREXIT(cinfo, JERR_SOF_NO_SOS);
 8017ba6:	687b      	ldr	r3, [r7, #4]
 8017ba8:	681b      	ldr	r3, [r3, #0]
 8017baa:	223d      	movs	r2, #61	@ 0x3d
 8017bac:	615a      	str	r2, [r3, #20]
 8017bae:	687b      	ldr	r3, [r7, #4]
 8017bb0:	681b      	ldr	r3, [r3, #0]
 8017bb2:	681b      	ldr	r3, [r3, #0]
 8017bb4:	6878      	ldr	r0, [r7, #4]
 8017bb6:	4798      	blx	r3
 8017bb8:	e00d      	b.n	8017bd6 <consume_markers+0xea>
      } else {
	/* Prevent infinite loop in coef ctlr's decompress_data routine
	 * if user set output_scan_number larger than number of scans.
	 */
	if (cinfo->output_scan_number > cinfo->input_scan_number)
 8017bba:	687b      	ldr	r3, [r7, #4]
 8017bbc:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 8017bc0:	687b      	ldr	r3, [r7, #4]
 8017bc2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8017bc6:	429a      	cmp	r2, r3
 8017bc8:	dd05      	ble.n	8017bd6 <consume_markers+0xea>
	  cinfo->output_scan_number = cinfo->input_scan_number;
 8017bca:	687b      	ldr	r3, [r7, #4]
 8017bcc:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8017bd0:	687b      	ldr	r3, [r7, #4]
 8017bd2:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
      }
      return val;
 8017bd6:	68bb      	ldr	r3, [r7, #8]
 8017bd8:	e005      	b.n	8017be6 <consume_markers+0xfa>
    case JPEG_SUSPENDED:
      return val;
 8017bda:	68bb      	ldr	r3, [r7, #8]
 8017bdc:	e003      	b.n	8017be6 <consume_markers+0xfa>
    default:
      return val;
 8017bde:	68bb      	ldr	r3, [r7, #8]
 8017be0:	e001      	b.n	8017be6 <consume_markers+0xfa>
	  break;
 8017be2:	bf00      	nop
    val = (*cinfo->marker->read_markers) (cinfo);
 8017be4:	e790      	b.n	8017b08 <consume_markers+0x1c>
    }
  }
}
 8017be6:	4618      	mov	r0, r3
 8017be8:	3710      	adds	r7, #16
 8017bea:	46bd      	mov	sp, r7
 8017bec:	bd80      	pop	{r7, pc}
	...

08017bf0 <reset_input_controller>:
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
 8017bf0:	b580      	push	{r7, lr}
 8017bf2:	b084      	sub	sp, #16
 8017bf4:	af00      	add	r7, sp, #0
 8017bf6:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8017bf8:	687b      	ldr	r3, [r7, #4]
 8017bfa:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8017bfe:	60fb      	str	r3, [r7, #12]

  inputctl->pub.consume_input = consume_markers;
 8017c00:	68fb      	ldr	r3, [r7, #12]
 8017c02:	4a0f      	ldr	r2, [pc, #60]	@ (8017c40 <reset_input_controller+0x50>)
 8017c04:	601a      	str	r2, [r3, #0]
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 8017c06:	68fb      	ldr	r3, [r7, #12]
 8017c08:	2200      	movs	r2, #0
 8017c0a:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 8017c0c:	68fb      	ldr	r3, [r7, #12]
 8017c0e:	2200      	movs	r2, #0
 8017c10:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 8017c12:	68fb      	ldr	r3, [r7, #12]
 8017c14:	2201      	movs	r2, #1
 8017c16:	619a      	str	r2, [r3, #24]
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
 8017c18:	687b      	ldr	r3, [r7, #4]
 8017c1a:	681b      	ldr	r3, [r3, #0]
 8017c1c:	691b      	ldr	r3, [r3, #16]
 8017c1e:	6878      	ldr	r0, [r7, #4]
 8017c20:	4798      	blx	r3
  (*cinfo->marker->reset_marker_reader) (cinfo);
 8017c22:	687b      	ldr	r3, [r7, #4]
 8017c24:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8017c28:	681b      	ldr	r3, [r3, #0]
 8017c2a:	6878      	ldr	r0, [r7, #4]
 8017c2c:	4798      	blx	r3
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
 8017c2e:	687b      	ldr	r3, [r7, #4]
 8017c30:	2200      	movs	r2, #0
 8017c32:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
}
 8017c36:	bf00      	nop
 8017c38:	3710      	adds	r7, #16
 8017c3a:	46bd      	mov	sp, r7
 8017c3c:	bd80      	pop	{r7, pc}
 8017c3e:	bf00      	nop
 8017c40:	08017aed 	.word	0x08017aed

08017c44 <jinit_input_controller>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
 8017c44:	b580      	push	{r7, lr}
 8017c46:	b084      	sub	sp, #16
 8017c48:	af00      	add	r7, sp, #0
 8017c4a:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 8017c4c:	687b      	ldr	r3, [r7, #4]
 8017c4e:	685b      	ldr	r3, [r3, #4]
 8017c50:	681b      	ldr	r3, [r3, #0]
 8017c52:	221c      	movs	r2, #28
 8017c54:	2100      	movs	r1, #0
 8017c56:	6878      	ldr	r0, [r7, #4]
 8017c58:	4798      	blx	r3
 8017c5a:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
 8017c5c:	687b      	ldr	r3, [r7, #4]
 8017c5e:	68fa      	ldr	r2, [r7, #12]
 8017c60:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
 8017c64:	68fb      	ldr	r3, [r7, #12]
 8017c66:	4a0c      	ldr	r2, [pc, #48]	@ (8017c98 <jinit_input_controller+0x54>)
 8017c68:	601a      	str	r2, [r3, #0]
  inputctl->pub.reset_input_controller = reset_input_controller;
 8017c6a:	68fb      	ldr	r3, [r7, #12]
 8017c6c:	4a0b      	ldr	r2, [pc, #44]	@ (8017c9c <jinit_input_controller+0x58>)
 8017c6e:	605a      	str	r2, [r3, #4]
  inputctl->pub.start_input_pass = start_input_pass;
 8017c70:	68fb      	ldr	r3, [r7, #12]
 8017c72:	4a0b      	ldr	r2, [pc, #44]	@ (8017ca0 <jinit_input_controller+0x5c>)
 8017c74:	609a      	str	r2, [r3, #8]
  inputctl->pub.finish_input_pass = finish_input_pass;
 8017c76:	68fb      	ldr	r3, [r7, #12]
 8017c78:	4a0a      	ldr	r2, [pc, #40]	@ (8017ca4 <jinit_input_controller+0x60>)
 8017c7a:	60da      	str	r2, [r3, #12]
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 8017c7c:	68fb      	ldr	r3, [r7, #12]
 8017c7e:	2200      	movs	r2, #0
 8017c80:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 8017c82:	68fb      	ldr	r3, [r7, #12]
 8017c84:	2200      	movs	r2, #0
 8017c86:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 8017c88:	68fb      	ldr	r3, [r7, #12]
 8017c8a:	2201      	movs	r2, #1
 8017c8c:	619a      	str	r2, [r3, #24]
}
 8017c8e:	bf00      	nop
 8017c90:	3710      	adds	r7, #16
 8017c92:	46bd      	mov	sp, r7
 8017c94:	bd80      	pop	{r7, pc}
 8017c96:	bf00      	nop
 8017c98:	08017aed 	.word	0x08017aed
 8017c9c:	08017bf1 	.word	0x08017bf1
 8017ca0:	08017a85 	.word	0x08017a85
 8017ca4:	08017ac9 	.word	0x08017ac9

08017ca8 <alloc_funny_pointers>:
LOCAL(void)
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
 8017ca8:	b580      	push	{r7, lr}
 8017caa:	b088      	sub	sp, #32
 8017cac:	af00      	add	r7, sp, #0
 8017cae:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8017cb0:	687b      	ldr	r3, [r7, #4]
 8017cb2:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8017cb6:	617b      	str	r3, [r7, #20]
  int ci, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 8017cb8:	687b      	ldr	r3, [r7, #4]
 8017cba:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8017cbe:	613b      	str	r3, [r7, #16]

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017cc0:	687b      	ldr	r3, [r7, #4]
 8017cc2:	685b      	ldr	r3, [r3, #4]
 8017cc4:	681b      	ldr	r3, [r3, #0]
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
 8017cc6:	687a      	ldr	r2, [r7, #4]
 8017cc8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017cca:	00d2      	lsls	r2, r2, #3
 8017ccc:	2101      	movs	r1, #1
 8017cce:	6878      	ldr	r0, [r7, #4]
 8017cd0:	4798      	blx	r3
 8017cd2:	4602      	mov	r2, r0
  main->xbuffer[0] = (JSAMPIMAGE)
 8017cd4:	697b      	ldr	r3, [r7, #20]
 8017cd6:	639a      	str	r2, [r3, #56]	@ 0x38
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
 8017cd8:	697b      	ldr	r3, [r7, #20]
 8017cda:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8017cdc:	687b      	ldr	r3, [r7, #4]
 8017cde:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017ce0:	009b      	lsls	r3, r3, #2
 8017ce2:	441a      	add	r2, r3
 8017ce4:	697b      	ldr	r3, [r7, #20]
 8017ce6:	63da      	str	r2, [r3, #60]	@ 0x3c

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017ce8:	2300      	movs	r3, #0
 8017cea:	61fb      	str	r3, [r7, #28]
 8017cec:	687b      	ldr	r3, [r7, #4]
 8017cee:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8017cf2:	61bb      	str	r3, [r7, #24]
 8017cf4:	e03a      	b.n	8017d6c <alloc_funny_pointers+0xc4>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017cf6:	69bb      	ldr	r3, [r7, #24]
 8017cf8:	68db      	ldr	r3, [r3, #12]
 8017cfa:	69ba      	ldr	r2, [r7, #24]
 8017cfc:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8017cfe:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8017d02:	687b      	ldr	r3, [r7, #4]
 8017d04:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017d08:	fb92 f3f3 	sdiv	r3, r2, r3
 8017d0c:	60fb      	str	r3, [r7, #12]
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017d0e:	687b      	ldr	r3, [r7, #4]
 8017d10:	685b      	ldr	r3, [r3, #4]
 8017d12:	681b      	ldr	r3, [r3, #0]
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
 8017d14:	693a      	ldr	r2, [r7, #16]
 8017d16:	3204      	adds	r2, #4
 8017d18:	68f9      	ldr	r1, [r7, #12]
 8017d1a:	fb01 f202 	mul.w	r2, r1, r2
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017d1e:	00d2      	lsls	r2, r2, #3
 8017d20:	2101      	movs	r1, #1
 8017d22:	6878      	ldr	r0, [r7, #4]
 8017d24:	4798      	blx	r3
 8017d26:	60b8      	str	r0, [r7, #8]
    xbuf += rgroup;		/* want one row group at negative offsets */
 8017d28:	68fb      	ldr	r3, [r7, #12]
 8017d2a:	009b      	lsls	r3, r3, #2
 8017d2c:	68ba      	ldr	r2, [r7, #8]
 8017d2e:	4413      	add	r3, r2
 8017d30:	60bb      	str	r3, [r7, #8]
    main->xbuffer[0][ci] = xbuf;
 8017d32:	697b      	ldr	r3, [r7, #20]
 8017d34:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8017d36:	69fb      	ldr	r3, [r7, #28]
 8017d38:	009b      	lsls	r3, r3, #2
 8017d3a:	4413      	add	r3, r2
 8017d3c:	68ba      	ldr	r2, [r7, #8]
 8017d3e:	601a      	str	r2, [r3, #0]
    xbuf += rgroup * (M + 4);
 8017d40:	693b      	ldr	r3, [r7, #16]
 8017d42:	3304      	adds	r3, #4
 8017d44:	68fa      	ldr	r2, [r7, #12]
 8017d46:	fb02 f303 	mul.w	r3, r2, r3
 8017d4a:	009b      	lsls	r3, r3, #2
 8017d4c:	68ba      	ldr	r2, [r7, #8]
 8017d4e:	4413      	add	r3, r2
 8017d50:	60bb      	str	r3, [r7, #8]
    main->xbuffer[1][ci] = xbuf;
 8017d52:	697b      	ldr	r3, [r7, #20]
 8017d54:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8017d56:	69fb      	ldr	r3, [r7, #28]
 8017d58:	009b      	lsls	r3, r3, #2
 8017d5a:	4413      	add	r3, r2
 8017d5c:	68ba      	ldr	r2, [r7, #8]
 8017d5e:	601a      	str	r2, [r3, #0]
       ci++, compptr++) {
 8017d60:	69fb      	ldr	r3, [r7, #28]
 8017d62:	3301      	adds	r3, #1
 8017d64:	61fb      	str	r3, [r7, #28]
 8017d66:	69bb      	ldr	r3, [r7, #24]
 8017d68:	3358      	adds	r3, #88	@ 0x58
 8017d6a:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017d6c:	687b      	ldr	r3, [r7, #4]
 8017d6e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017d70:	69fa      	ldr	r2, [r7, #28]
 8017d72:	429a      	cmp	r2, r3
 8017d74:	dbbf      	blt.n	8017cf6 <alloc_funny_pointers+0x4e>
  }
}
 8017d76:	bf00      	nop
 8017d78:	bf00      	nop
 8017d7a:	3720      	adds	r7, #32
 8017d7c:	46bd      	mov	sp, r7
 8017d7e:	bd80      	pop	{r7, pc}

08017d80 <make_funny_pointers>:
 * The actual workspace is already allocated (in main->buffer),
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
 8017d80:	b480      	push	{r7}
 8017d82:	b08d      	sub	sp, #52	@ 0x34
 8017d84:	af00      	add	r7, sp, #0
 8017d86:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8017d88:	687b      	ldr	r3, [r7, #4]
 8017d8a:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8017d8e:	623b      	str	r3, [r7, #32]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 8017d90:	687b      	ldr	r3, [r7, #4]
 8017d92:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8017d96:	61fb      	str	r3, [r7, #28]
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017d98:	2300      	movs	r3, #0
 8017d9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8017d9c:	687b      	ldr	r3, [r7, #4]
 8017d9e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8017da2:	627b      	str	r3, [r7, #36]	@ 0x24
 8017da4:	e08b      	b.n	8017ebe <make_funny_pointers+0x13e>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017da6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017da8:	68db      	ldr	r3, [r3, #12]
 8017daa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017dac:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8017dae:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8017db2:	687b      	ldr	r3, [r7, #4]
 8017db4:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017db8:	fb92 f3f3 	sdiv	r3, r2, r3
 8017dbc:	61bb      	str	r3, [r7, #24]
    xbuf0 = main->xbuffer[0][ci];
 8017dbe:	6a3b      	ldr	r3, [r7, #32]
 8017dc0:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8017dc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dc4:	009b      	lsls	r3, r3, #2
 8017dc6:	4413      	add	r3, r2
 8017dc8:	681b      	ldr	r3, [r3, #0]
 8017dca:	617b      	str	r3, [r7, #20]
    xbuf1 = main->xbuffer[1][ci];
 8017dcc:	6a3b      	ldr	r3, [r7, #32]
 8017dce:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8017dd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dd2:	009b      	lsls	r3, r3, #2
 8017dd4:	4413      	add	r3, r2
 8017dd6:	681b      	ldr	r3, [r3, #0]
 8017dd8:	613b      	str	r3, [r7, #16]
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
 8017dda:	6a3b      	ldr	r3, [r7, #32]
 8017ddc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8017dde:	3202      	adds	r2, #2
 8017de0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017de4:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < rgroup * (M + 2); i++) {
 8017de6:	2300      	movs	r3, #0
 8017de8:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017dea:	e012      	b.n	8017e12 <make_funny_pointers+0x92>
      xbuf0[i] = xbuf1[i] = buf[i];
 8017dec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017dee:	009b      	lsls	r3, r3, #2
 8017df0:	68fa      	ldr	r2, [r7, #12]
 8017df2:	441a      	add	r2, r3
 8017df4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017df6:	009b      	lsls	r3, r3, #2
 8017df8:	6939      	ldr	r1, [r7, #16]
 8017dfa:	440b      	add	r3, r1
 8017dfc:	6812      	ldr	r2, [r2, #0]
 8017dfe:	601a      	str	r2, [r3, #0]
 8017e00:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e02:	0092      	lsls	r2, r2, #2
 8017e04:	6979      	ldr	r1, [r7, #20]
 8017e06:	440a      	add	r2, r1
 8017e08:	681b      	ldr	r3, [r3, #0]
 8017e0a:	6013      	str	r3, [r2, #0]
    for (i = 0; i < rgroup * (M + 2); i++) {
 8017e0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e0e:	3301      	adds	r3, #1
 8017e10:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017e12:	69fb      	ldr	r3, [r7, #28]
 8017e14:	3302      	adds	r3, #2
 8017e16:	69ba      	ldr	r2, [r7, #24]
 8017e18:	fb02 f303 	mul.w	r3, r2, r3
 8017e1c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e1e:	429a      	cmp	r2, r3
 8017e20:	dbe4      	blt.n	8017dec <make_funny_pointers+0x6c>
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
 8017e22:	2300      	movs	r3, #0
 8017e24:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017e26:	e02c      	b.n	8017e82 <make_funny_pointers+0x102>
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
 8017e28:	69bb      	ldr	r3, [r7, #24]
 8017e2a:	69fa      	ldr	r2, [r7, #28]
 8017e2c:	fb03 f202 	mul.w	r2, r3, r2
 8017e30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e32:	4413      	add	r3, r2
 8017e34:	009b      	lsls	r3, r3, #2
 8017e36:	68fa      	ldr	r2, [r7, #12]
 8017e38:	441a      	add	r2, r3
 8017e3a:	69fb      	ldr	r3, [r7, #28]
 8017e3c:	3b02      	subs	r3, #2
 8017e3e:	69b9      	ldr	r1, [r7, #24]
 8017e40:	fb03 f101 	mul.w	r1, r3, r1
 8017e44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e46:	440b      	add	r3, r1
 8017e48:	009b      	lsls	r3, r3, #2
 8017e4a:	6939      	ldr	r1, [r7, #16]
 8017e4c:	440b      	add	r3, r1
 8017e4e:	6812      	ldr	r2, [r2, #0]
 8017e50:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
 8017e52:	69fb      	ldr	r3, [r7, #28]
 8017e54:	3b02      	subs	r3, #2
 8017e56:	69ba      	ldr	r2, [r7, #24]
 8017e58:	fb03 f202 	mul.w	r2, r3, r2
 8017e5c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e5e:	4413      	add	r3, r2
 8017e60:	009b      	lsls	r3, r3, #2
 8017e62:	68fa      	ldr	r2, [r7, #12]
 8017e64:	441a      	add	r2, r3
 8017e66:	69bb      	ldr	r3, [r7, #24]
 8017e68:	69f9      	ldr	r1, [r7, #28]
 8017e6a:	fb03 f101 	mul.w	r1, r3, r1
 8017e6e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e70:	440b      	add	r3, r1
 8017e72:	009b      	lsls	r3, r3, #2
 8017e74:	6939      	ldr	r1, [r7, #16]
 8017e76:	440b      	add	r3, r1
 8017e78:	6812      	ldr	r2, [r2, #0]
 8017e7a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 8017e7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e7e:	3301      	adds	r3, #1
 8017e80:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017e82:	69bb      	ldr	r3, [r7, #24]
 8017e84:	005b      	lsls	r3, r3, #1
 8017e86:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e88:	429a      	cmp	r2, r3
 8017e8a:	dbcd      	blt.n	8017e28 <make_funny_pointers+0xa8>
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
 8017e8c:	2300      	movs	r3, #0
 8017e8e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017e90:	e00b      	b.n	8017eaa <make_funny_pointers+0x12a>
      xbuf0[i - rgroup] = xbuf0[0];
 8017e92:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e94:	69bb      	ldr	r3, [r7, #24]
 8017e96:	1ad3      	subs	r3, r2, r3
 8017e98:	009b      	lsls	r3, r3, #2
 8017e9a:	697a      	ldr	r2, [r7, #20]
 8017e9c:	4413      	add	r3, r2
 8017e9e:	697a      	ldr	r2, [r7, #20]
 8017ea0:	6812      	ldr	r2, [r2, #0]
 8017ea2:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 8017ea4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017ea6:	3301      	adds	r3, #1
 8017ea8:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017eaa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017eac:	69bb      	ldr	r3, [r7, #24]
 8017eae:	429a      	cmp	r2, r3
 8017eb0:	dbef      	blt.n	8017e92 <make_funny_pointers+0x112>
       ci++, compptr++) {
 8017eb2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017eb4:	3301      	adds	r3, #1
 8017eb6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8017eb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017eba:	3358      	adds	r3, #88	@ 0x58
 8017ebc:	627b      	str	r3, [r7, #36]	@ 0x24
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017ebe:	687b      	ldr	r3, [r7, #4]
 8017ec0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017ec2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8017ec4:	429a      	cmp	r2, r3
 8017ec6:	f6ff af6e 	blt.w	8017da6 <make_funny_pointers+0x26>
    }
  }
}
 8017eca:	bf00      	nop
 8017ecc:	bf00      	nop
 8017ece:	3734      	adds	r7, #52	@ 0x34
 8017ed0:	46bd      	mov	sp, r7
 8017ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ed6:	4770      	bx	lr

08017ed8 <set_wraparound_pointers>:
LOCAL(void)
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
 8017ed8:	b480      	push	{r7}
 8017eda:	b08b      	sub	sp, #44	@ 0x2c
 8017edc:	af00      	add	r7, sp, #0
 8017ede:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8017ee0:	687b      	ldr	r3, [r7, #4]
 8017ee2:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8017ee6:	61bb      	str	r3, [r7, #24]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 8017ee8:	687b      	ldr	r3, [r7, #4]
 8017eea:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8017eee:	617b      	str	r3, [r7, #20]
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017ef0:	2300      	movs	r3, #0
 8017ef2:	627b      	str	r3, [r7, #36]	@ 0x24
 8017ef4:	687b      	ldr	r3, [r7, #4]
 8017ef6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8017efa:	61fb      	str	r3, [r7, #28]
 8017efc:	e06d      	b.n	8017fda <set_wraparound_pointers+0x102>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017efe:	69fb      	ldr	r3, [r7, #28]
 8017f00:	68db      	ldr	r3, [r3, #12]
 8017f02:	69fa      	ldr	r2, [r7, #28]
 8017f04:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8017f06:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8017f0a:	687b      	ldr	r3, [r7, #4]
 8017f0c:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8017f10:	fb92 f3f3 	sdiv	r3, r2, r3
 8017f14:	613b      	str	r3, [r7, #16]
    xbuf0 = main->xbuffer[0][ci];
 8017f16:	69bb      	ldr	r3, [r7, #24]
 8017f18:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8017f1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017f1c:	009b      	lsls	r3, r3, #2
 8017f1e:	4413      	add	r3, r2
 8017f20:	681b      	ldr	r3, [r3, #0]
 8017f22:	60fb      	str	r3, [r7, #12]
    xbuf1 = main->xbuffer[1][ci];
 8017f24:	69bb      	ldr	r3, [r7, #24]
 8017f26:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8017f28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017f2a:	009b      	lsls	r3, r3, #2
 8017f2c:	4413      	add	r3, r2
 8017f2e:	681b      	ldr	r3, [r3, #0]
 8017f30:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup; i++) {
 8017f32:	2300      	movs	r3, #0
 8017f34:	623b      	str	r3, [r7, #32]
 8017f36:	e046      	b.n	8017fc6 <set_wraparound_pointers+0xee>
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
 8017f38:	697b      	ldr	r3, [r7, #20]
 8017f3a:	3301      	adds	r3, #1
 8017f3c:	693a      	ldr	r2, [r7, #16]
 8017f3e:	fb03 f202 	mul.w	r2, r3, r2
 8017f42:	6a3b      	ldr	r3, [r7, #32]
 8017f44:	4413      	add	r3, r2
 8017f46:	009b      	lsls	r3, r3, #2
 8017f48:	68fa      	ldr	r2, [r7, #12]
 8017f4a:	441a      	add	r2, r3
 8017f4c:	6a39      	ldr	r1, [r7, #32]
 8017f4e:	693b      	ldr	r3, [r7, #16]
 8017f50:	1acb      	subs	r3, r1, r3
 8017f52:	009b      	lsls	r3, r3, #2
 8017f54:	68f9      	ldr	r1, [r7, #12]
 8017f56:	440b      	add	r3, r1
 8017f58:	6812      	ldr	r2, [r2, #0]
 8017f5a:	601a      	str	r2, [r3, #0]
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
 8017f5c:	697b      	ldr	r3, [r7, #20]
 8017f5e:	3301      	adds	r3, #1
 8017f60:	693a      	ldr	r2, [r7, #16]
 8017f62:	fb03 f202 	mul.w	r2, r3, r2
 8017f66:	6a3b      	ldr	r3, [r7, #32]
 8017f68:	4413      	add	r3, r2
 8017f6a:	009b      	lsls	r3, r3, #2
 8017f6c:	68ba      	ldr	r2, [r7, #8]
 8017f6e:	441a      	add	r2, r3
 8017f70:	6a39      	ldr	r1, [r7, #32]
 8017f72:	693b      	ldr	r3, [r7, #16]
 8017f74:	1acb      	subs	r3, r1, r3
 8017f76:	009b      	lsls	r3, r3, #2
 8017f78:	68b9      	ldr	r1, [r7, #8]
 8017f7a:	440b      	add	r3, r1
 8017f7c:	6812      	ldr	r2, [r2, #0]
 8017f7e:	601a      	str	r2, [r3, #0]
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
 8017f80:	6a3b      	ldr	r3, [r7, #32]
 8017f82:	009b      	lsls	r3, r3, #2
 8017f84:	68fa      	ldr	r2, [r7, #12]
 8017f86:	441a      	add	r2, r3
 8017f88:	697b      	ldr	r3, [r7, #20]
 8017f8a:	3302      	adds	r3, #2
 8017f8c:	6939      	ldr	r1, [r7, #16]
 8017f8e:	fb03 f101 	mul.w	r1, r3, r1
 8017f92:	6a3b      	ldr	r3, [r7, #32]
 8017f94:	440b      	add	r3, r1
 8017f96:	009b      	lsls	r3, r3, #2
 8017f98:	68f9      	ldr	r1, [r7, #12]
 8017f9a:	440b      	add	r3, r1
 8017f9c:	6812      	ldr	r2, [r2, #0]
 8017f9e:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
 8017fa0:	6a3b      	ldr	r3, [r7, #32]
 8017fa2:	009b      	lsls	r3, r3, #2
 8017fa4:	68ba      	ldr	r2, [r7, #8]
 8017fa6:	441a      	add	r2, r3
 8017fa8:	697b      	ldr	r3, [r7, #20]
 8017faa:	3302      	adds	r3, #2
 8017fac:	6939      	ldr	r1, [r7, #16]
 8017fae:	fb03 f101 	mul.w	r1, r3, r1
 8017fb2:	6a3b      	ldr	r3, [r7, #32]
 8017fb4:	440b      	add	r3, r1
 8017fb6:	009b      	lsls	r3, r3, #2
 8017fb8:	68b9      	ldr	r1, [r7, #8]
 8017fba:	440b      	add	r3, r1
 8017fbc:	6812      	ldr	r2, [r2, #0]
 8017fbe:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 8017fc0:	6a3b      	ldr	r3, [r7, #32]
 8017fc2:	3301      	adds	r3, #1
 8017fc4:	623b      	str	r3, [r7, #32]
 8017fc6:	6a3a      	ldr	r2, [r7, #32]
 8017fc8:	693b      	ldr	r3, [r7, #16]
 8017fca:	429a      	cmp	r2, r3
 8017fcc:	dbb4      	blt.n	8017f38 <set_wraparound_pointers+0x60>
       ci++, compptr++) {
 8017fce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017fd0:	3301      	adds	r3, #1
 8017fd2:	627b      	str	r3, [r7, #36]	@ 0x24
 8017fd4:	69fb      	ldr	r3, [r7, #28]
 8017fd6:	3358      	adds	r3, #88	@ 0x58
 8017fd8:	61fb      	str	r3, [r7, #28]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017fda:	687b      	ldr	r3, [r7, #4]
 8017fdc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017fde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017fe0:	429a      	cmp	r2, r3
 8017fe2:	db8c      	blt.n	8017efe <set_wraparound_pointers+0x26>
    }
  }
}
 8017fe4:	bf00      	nop
 8017fe6:	bf00      	nop
 8017fe8:	372c      	adds	r7, #44	@ 0x2c
 8017fea:	46bd      	mov	sp, r7
 8017fec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ff0:	4770      	bx	lr

08017ff2 <set_bottom_pointers>:
set_bottom_pointers (j_decompress_ptr cinfo)
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
 8017ff2:	b480      	push	{r7}
 8017ff4:	b08b      	sub	sp, #44	@ 0x2c
 8017ff6:	af00      	add	r7, sp, #0
 8017ff8:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8017ffa:	687b      	ldr	r3, [r7, #4]
 8017ffc:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8018000:	617b      	str	r3, [r7, #20]
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8018002:	2300      	movs	r3, #0
 8018004:	627b      	str	r3, [r7, #36]	@ 0x24
 8018006:	687b      	ldr	r3, [r7, #4]
 8018008:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801800c:	61bb      	str	r3, [r7, #24]
 801800e:	e052      	b.n	80180b6 <set_bottom_pointers+0xc4>
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_v_scaled_size;
 8018010:	69bb      	ldr	r3, [r7, #24]
 8018012:	68db      	ldr	r3, [r3, #12]
 8018014:	69ba      	ldr	r2, [r7, #24]
 8018016:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8018018:	fb02 f303 	mul.w	r3, r2, r3
 801801c:	613b      	str	r3, [r7, #16]
    rgroup = iMCUheight / cinfo->min_DCT_v_scaled_size;
 801801e:	687b      	ldr	r3, [r7, #4]
 8018020:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8018024:	693a      	ldr	r2, [r7, #16]
 8018026:	fb92 f3f3 	sdiv	r3, r2, r3
 801802a:	60fb      	str	r3, [r7, #12]
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
 801802c:	69bb      	ldr	r3, [r7, #24]
 801802e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018030:	693a      	ldr	r2, [r7, #16]
 8018032:	fbb3 f1f2 	udiv	r1, r3, r2
 8018036:	fb01 f202 	mul.w	r2, r1, r2
 801803a:	1a9b      	subs	r3, r3, r2
 801803c:	61fb      	str	r3, [r7, #28]
    if (rows_left == 0) rows_left = iMCUheight;
 801803e:	69fb      	ldr	r3, [r7, #28]
 8018040:	2b00      	cmp	r3, #0
 8018042:	d101      	bne.n	8018048 <set_bottom_pointers+0x56>
 8018044:	693b      	ldr	r3, [r7, #16]
 8018046:	61fb      	str	r3, [r7, #28]
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
 8018048:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801804a:	2b00      	cmp	r3, #0
 801804c:	d108      	bne.n	8018060 <set_bottom_pointers+0x6e>
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
 801804e:	69fb      	ldr	r3, [r7, #28]
 8018050:	1e5a      	subs	r2, r3, #1
 8018052:	68fb      	ldr	r3, [r7, #12]
 8018054:	fb92 f3f3 	sdiv	r3, r2, r3
 8018058:	3301      	adds	r3, #1
 801805a:	461a      	mov	r2, r3
 801805c:	697b      	ldr	r3, [r7, #20]
 801805e:	649a      	str	r2, [r3, #72]	@ 0x48
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
 8018060:	697b      	ldr	r3, [r7, #20]
 8018062:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8018064:	697b      	ldr	r3, [r7, #20]
 8018066:	320e      	adds	r2, #14
 8018068:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801806c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801806e:	009b      	lsls	r3, r3, #2
 8018070:	4413      	add	r3, r2
 8018072:	681b      	ldr	r3, [r3, #0]
 8018074:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup * 2; i++) {
 8018076:	2300      	movs	r3, #0
 8018078:	623b      	str	r3, [r7, #32]
 801807a:	e011      	b.n	80180a0 <set_bottom_pointers+0xae>
      xbuf[rows_left + i] = xbuf[rows_left-1];
 801807c:	69fb      	ldr	r3, [r7, #28]
 801807e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8018082:	3b01      	subs	r3, #1
 8018084:	009b      	lsls	r3, r3, #2
 8018086:	68ba      	ldr	r2, [r7, #8]
 8018088:	441a      	add	r2, r3
 801808a:	69f9      	ldr	r1, [r7, #28]
 801808c:	6a3b      	ldr	r3, [r7, #32]
 801808e:	440b      	add	r3, r1
 8018090:	009b      	lsls	r3, r3, #2
 8018092:	68b9      	ldr	r1, [r7, #8]
 8018094:	440b      	add	r3, r1
 8018096:	6812      	ldr	r2, [r2, #0]
 8018098:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 801809a:	6a3b      	ldr	r3, [r7, #32]
 801809c:	3301      	adds	r3, #1
 801809e:	623b      	str	r3, [r7, #32]
 80180a0:	68fb      	ldr	r3, [r7, #12]
 80180a2:	005b      	lsls	r3, r3, #1
 80180a4:	6a3a      	ldr	r2, [r7, #32]
 80180a6:	429a      	cmp	r2, r3
 80180a8:	dbe8      	blt.n	801807c <set_bottom_pointers+0x8a>
       ci++, compptr++) {
 80180aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80180ac:	3301      	adds	r3, #1
 80180ae:	627b      	str	r3, [r7, #36]	@ 0x24
 80180b0:	69bb      	ldr	r3, [r7, #24]
 80180b2:	3358      	adds	r3, #88	@ 0x58
 80180b4:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80180b6:	687b      	ldr	r3, [r7, #4]
 80180b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80180ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80180bc:	429a      	cmp	r2, r3
 80180be:	dba7      	blt.n	8018010 <set_bottom_pointers+0x1e>
    }
  }
}
 80180c0:	bf00      	nop
 80180c2:	bf00      	nop
 80180c4:	372c      	adds	r7, #44	@ 0x2c
 80180c6:	46bd      	mov	sp, r7
 80180c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80180cc:	4770      	bx	lr
	...

080180d0 <start_pass_main>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 80180d0:	b580      	push	{r7, lr}
 80180d2:	b084      	sub	sp, #16
 80180d4:	af00      	add	r7, sp, #0
 80180d6:	6078      	str	r0, [r7, #4]
 80180d8:	460b      	mov	r3, r1
 80180da:	70fb      	strb	r3, [r7, #3]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 80180dc:	687b      	ldr	r3, [r7, #4]
 80180de:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 80180e2:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 80180e4:	78fb      	ldrb	r3, [r7, #3]
 80180e6:	2b00      	cmp	r3, #0
 80180e8:	d002      	beq.n	80180f0 <start_pass_main+0x20>
 80180ea:	2b02      	cmp	r3, #2
 80180ec:	d020      	beq.n	8018130 <start_pass_main+0x60>
 80180ee:	e023      	b.n	8018138 <start_pass_main+0x68>
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
 80180f0:	687b      	ldr	r3, [r7, #4]
 80180f2:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 80180f6:	689b      	ldr	r3, [r3, #8]
 80180f8:	2b00      	cmp	r3, #0
 80180fa:	d00f      	beq.n	801811c <start_pass_main+0x4c>
      main->pub.process_data = process_data_context_main;
 80180fc:	68fb      	ldr	r3, [r7, #12]
 80180fe:	4a15      	ldr	r2, [pc, #84]	@ (8018154 <start_pass_main+0x84>)
 8018100:	605a      	str	r2, [r3, #4]
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
 8018102:	6878      	ldr	r0, [r7, #4]
 8018104:	f7ff fe3c 	bl	8017d80 <make_funny_pointers>
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
 8018108:	68fb      	ldr	r3, [r7, #12]
 801810a:	2200      	movs	r2, #0
 801810c:	641a      	str	r2, [r3, #64]	@ 0x40
      main->context_state = CTX_PREPARE_FOR_IMCU;
 801810e:	68fb      	ldr	r3, [r7, #12]
 8018110:	2200      	movs	r2, #0
 8018112:	645a      	str	r2, [r3, #68]	@ 0x44
      main->iMCU_row_ctr = 0;
 8018114:	68fb      	ldr	r3, [r7, #12]
 8018116:	2200      	movs	r2, #0
 8018118:	64da      	str	r2, [r3, #76]	@ 0x4c
 801811a:	e002      	b.n	8018122 <start_pass_main+0x52>
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
 801811c:	68fb      	ldr	r3, [r7, #12]
 801811e:	4a0e      	ldr	r2, [pc, #56]	@ (8018158 <start_pass_main+0x88>)
 8018120:	605a      	str	r2, [r3, #4]
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
 8018122:	68fb      	ldr	r3, [r7, #12]
 8018124:	2200      	movs	r2, #0
 8018126:	631a      	str	r2, [r3, #48]	@ 0x30
    main->rowgroup_ctr = 0;
 8018128:	68fb      	ldr	r3, [r7, #12]
 801812a:	2200      	movs	r2, #0
 801812c:	635a      	str	r2, [r3, #52]	@ 0x34
    break;
 801812e:	e00d      	b.n	801814c <start_pass_main+0x7c>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
 8018130:	68fb      	ldr	r3, [r7, #12]
 8018132:	4a0a      	ldr	r2, [pc, #40]	@ (801815c <start_pass_main+0x8c>)
 8018134:	605a      	str	r2, [r3, #4]
    break;
 8018136:	e009      	b.n	801814c <start_pass_main+0x7c>
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 8018138:	687b      	ldr	r3, [r7, #4]
 801813a:	681b      	ldr	r3, [r3, #0]
 801813c:	2203      	movs	r2, #3
 801813e:	615a      	str	r2, [r3, #20]
 8018140:	687b      	ldr	r3, [r7, #4]
 8018142:	681b      	ldr	r3, [r3, #0]
 8018144:	681b      	ldr	r3, [r3, #0]
 8018146:	6878      	ldr	r0, [r7, #4]
 8018148:	4798      	blx	r3
    break;
 801814a:	bf00      	nop
  }
}
 801814c:	bf00      	nop
 801814e:	3710      	adds	r7, #16
 8018150:	46bd      	mov	sp, r7
 8018152:	bd80      	pop	{r7, pc}
 8018154:	080181eb 	.word	0x080181eb
 8018158:	08018161 	.word	0x08018161
 801815c:	08018361 	.word	0x08018361

08018160 <process_data_simple_main>:

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
 8018160:	b590      	push	{r4, r7, lr}
 8018162:	b08b      	sub	sp, #44	@ 0x2c
 8018164:	af04      	add	r7, sp, #16
 8018166:	60f8      	str	r0, [r7, #12]
 8018168:	60b9      	str	r1, [r7, #8]
 801816a:	607a      	str	r2, [r7, #4]
 801816c:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801816e:	68fb      	ldr	r3, [r7, #12]
 8018170:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8018174:	617b      	str	r3, [r7, #20]
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 8018176:	697b      	ldr	r3, [r7, #20]
 8018178:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801817a:	2b00      	cmp	r3, #0
 801817c:	d10e      	bne.n	801819c <process_data_simple_main+0x3c>
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
 801817e:	68fb      	ldr	r3, [r7, #12]
 8018180:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8018184:	68db      	ldr	r3, [r3, #12]
 8018186:	697a      	ldr	r2, [r7, #20]
 8018188:	3208      	adds	r2, #8
 801818a:	4611      	mov	r1, r2
 801818c:	68f8      	ldr	r0, [r7, #12]
 801818e:	4798      	blx	r3
 8018190:	4603      	mov	r3, r0
 8018192:	2b00      	cmp	r3, #0
 8018194:	d025      	beq.n	80181e2 <process_data_simple_main+0x82>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 8018196:	697b      	ldr	r3, [r7, #20]
 8018198:	2201      	movs	r2, #1
 801819a:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;
 801819c:	68fb      	ldr	r3, [r7, #12]
 801819e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 80181a2:	613b      	str	r3, [r7, #16]
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
 80181a4:	68fb      	ldr	r3, [r7, #12]
 80181a6:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 80181aa:	685c      	ldr	r4, [r3, #4]
 80181ac:	697b      	ldr	r3, [r7, #20]
 80181ae:	f103 0108 	add.w	r1, r3, #8
 80181b2:	697b      	ldr	r3, [r7, #20]
 80181b4:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80181b8:	683b      	ldr	r3, [r7, #0]
 80181ba:	9302      	str	r3, [sp, #8]
 80181bc:	687b      	ldr	r3, [r7, #4]
 80181be:	9301      	str	r3, [sp, #4]
 80181c0:	68bb      	ldr	r3, [r7, #8]
 80181c2:	9300      	str	r3, [sp, #0]
 80181c4:	693b      	ldr	r3, [r7, #16]
 80181c6:	68f8      	ldr	r0, [r7, #12]
 80181c8:	47a0      	blx	r4
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
 80181ca:	697b      	ldr	r3, [r7, #20]
 80181cc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80181ce:	693a      	ldr	r2, [r7, #16]
 80181d0:	429a      	cmp	r2, r3
 80181d2:	d807      	bhi.n	80181e4 <process_data_simple_main+0x84>
    main->buffer_full = FALSE;
 80181d4:	697b      	ldr	r3, [r7, #20]
 80181d6:	2200      	movs	r2, #0
 80181d8:	631a      	str	r2, [r3, #48]	@ 0x30
    main->rowgroup_ctr = 0;
 80181da:	697b      	ldr	r3, [r7, #20]
 80181dc:	2200      	movs	r2, #0
 80181de:	635a      	str	r2, [r3, #52]	@ 0x34
 80181e0:	e000      	b.n	80181e4 <process_data_simple_main+0x84>
      return;			/* suspension forced, can do nothing more */
 80181e2:	bf00      	nop
  }
}
 80181e4:	371c      	adds	r7, #28
 80181e6:	46bd      	mov	sp, r7
 80181e8:	bd90      	pop	{r4, r7, pc}

080181ea <process_data_context_main>:

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
 80181ea:	b590      	push	{r4, r7, lr}
 80181ec:	b08b      	sub	sp, #44	@ 0x2c
 80181ee:	af04      	add	r7, sp, #16
 80181f0:	60f8      	str	r0, [r7, #12]
 80181f2:	60b9      	str	r1, [r7, #8]
 80181f4:	607a      	str	r2, [r7, #4]
 80181f6:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 80181f8:	68fb      	ldr	r3, [r7, #12]
 80181fa:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 80181fe:	617b      	str	r3, [r7, #20]

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 8018200:	697b      	ldr	r3, [r7, #20]
 8018202:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018204:	2b00      	cmp	r3, #0
 8018206:	d118      	bne.n	801823a <process_data_context_main+0x50>
    if (! (*cinfo->coef->decompress_data) (cinfo,
 8018208:	68fb      	ldr	r3, [r7, #12]
 801820a:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801820e:	68db      	ldr	r3, [r3, #12]
					   main->xbuffer[main->whichptr]))
 8018210:	697a      	ldr	r2, [r7, #20]
 8018212:	6c11      	ldr	r1, [r2, #64]	@ 0x40
    if (! (*cinfo->coef->decompress_data) (cinfo,
 8018214:	697a      	ldr	r2, [r7, #20]
 8018216:	310e      	adds	r1, #14
 8018218:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 801821c:	4611      	mov	r1, r2
 801821e:	68f8      	ldr	r0, [r7, #12]
 8018220:	4798      	blx	r3
 8018222:	4603      	mov	r3, r0
 8018224:	2b00      	cmp	r3, #0
 8018226:	f000 8091 	beq.w	801834c <process_data_context_main+0x162>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 801822a:	697b      	ldr	r3, [r7, #20]
 801822c:	2201      	movs	r2, #1
 801822e:	631a      	str	r2, [r3, #48]	@ 0x30
    main->iMCU_row_ctr++;	/* count rows received */
 8018230:	697b      	ldr	r3, [r7, #20]
 8018232:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8018234:	1c5a      	adds	r2, r3, #1
 8018236:	697b      	ldr	r3, [r7, #20]
 8018238:	64da      	str	r2, [r3, #76]	@ 0x4c
  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
 801823a:	697b      	ldr	r3, [r7, #20]
 801823c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801823e:	2b02      	cmp	r3, #2
 8018240:	d007      	beq.n	8018252 <process_data_context_main+0x68>
 8018242:	2b02      	cmp	r3, #2
 8018244:	f300 8089 	bgt.w	801835a <process_data_context_main+0x170>
 8018248:	2b00      	cmp	r3, #0
 801824a:	d028      	beq.n	801829e <process_data_context_main+0xb4>
 801824c:	2b01      	cmp	r3, #1
 801824e:	d03d      	beq.n	80182cc <process_data_context_main+0xe2>
 8018250:	e083      	b.n	801835a <process_data_context_main+0x170>
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 8018252:	68fb      	ldr	r3, [r7, #12]
 8018254:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 8018258:	685c      	ldr	r4, [r3, #4]
 801825a:	697b      	ldr	r3, [r7, #20]
 801825c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801825e:	697b      	ldr	r3, [r7, #20]
 8018260:	320e      	adds	r2, #14
 8018262:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8018266:	697b      	ldr	r3, [r7, #20]
 8018268:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801826c:	697b      	ldr	r3, [r7, #20]
 801826e:	6c98      	ldr	r0, [r3, #72]	@ 0x48
 8018270:	683b      	ldr	r3, [r7, #0]
 8018272:	9302      	str	r3, [sp, #8]
 8018274:	687b      	ldr	r3, [r7, #4]
 8018276:	9301      	str	r3, [sp, #4]
 8018278:	68bb      	ldr	r3, [r7, #8]
 801827a:	9300      	str	r3, [sp, #0]
 801827c:	4603      	mov	r3, r0
 801827e:	68f8      	ldr	r0, [r7, #12]
 8018280:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 8018282:	697b      	ldr	r3, [r7, #20]
 8018284:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8018286:	697b      	ldr	r3, [r7, #20]
 8018288:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801828a:	429a      	cmp	r2, r3
 801828c:	d360      	bcc.n	8018350 <process_data_context_main+0x166>
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
 801828e:	697b      	ldr	r3, [r7, #20]
 8018290:	2200      	movs	r2, #0
 8018292:	645a      	str	r2, [r3, #68]	@ 0x44
    if (*out_row_ctr >= out_rows_avail)
 8018294:	687b      	ldr	r3, [r7, #4]
 8018296:	681b      	ldr	r3, [r3, #0]
 8018298:	683a      	ldr	r2, [r7, #0]
 801829a:	429a      	cmp	r2, r3
 801829c:	d95a      	bls.n	8018354 <process_data_context_main+0x16a>
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
 801829e:	697b      	ldr	r3, [r7, #20]
 80182a0:	2200      	movs	r2, #0
 80182a2:	635a      	str	r2, [r3, #52]	@ 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
 80182a4:	68fb      	ldr	r3, [r7, #12]
 80182a6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 80182aa:	3b01      	subs	r3, #1
 80182ac:	461a      	mov	r2, r3
 80182ae:	697b      	ldr	r3, [r7, #20]
 80182b0:	649a      	str	r2, [r3, #72]	@ 0x48
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
 80182b2:	697b      	ldr	r3, [r7, #20]
 80182b4:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80182b6:	68fb      	ldr	r3, [r7, #12]
 80182b8:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80182bc:	429a      	cmp	r2, r3
 80182be:	d102      	bne.n	80182c6 <process_data_context_main+0xdc>
      set_bottom_pointers(cinfo);
 80182c0:	68f8      	ldr	r0, [r7, #12]
 80182c2:	f7ff fe96 	bl	8017ff2 <set_bottom_pointers>
    main->context_state = CTX_PROCESS_IMCU;
 80182c6:	697b      	ldr	r3, [r7, #20]
 80182c8:	2201      	movs	r2, #1
 80182ca:	645a      	str	r2, [r3, #68]	@ 0x44
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 80182cc:	68fb      	ldr	r3, [r7, #12]
 80182ce:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 80182d2:	685c      	ldr	r4, [r3, #4]
 80182d4:	697b      	ldr	r3, [r7, #20]
 80182d6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80182d8:	697b      	ldr	r3, [r7, #20]
 80182da:	320e      	adds	r2, #14
 80182dc:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80182e0:	697b      	ldr	r3, [r7, #20]
 80182e2:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80182e6:	697b      	ldr	r3, [r7, #20]
 80182e8:	6c98      	ldr	r0, [r3, #72]	@ 0x48
 80182ea:	683b      	ldr	r3, [r7, #0]
 80182ec:	9302      	str	r3, [sp, #8]
 80182ee:	687b      	ldr	r3, [r7, #4]
 80182f0:	9301      	str	r3, [sp, #4]
 80182f2:	68bb      	ldr	r3, [r7, #8]
 80182f4:	9300      	str	r3, [sp, #0]
 80182f6:	4603      	mov	r3, r0
 80182f8:	68f8      	ldr	r0, [r7, #12]
 80182fa:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 80182fc:	697b      	ldr	r3, [r7, #20]
 80182fe:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8018300:	697b      	ldr	r3, [r7, #20]
 8018302:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8018304:	429a      	cmp	r2, r3
 8018306:	d327      	bcc.n	8018358 <process_data_context_main+0x16e>
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
 8018308:	697b      	ldr	r3, [r7, #20]
 801830a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801830c:	2b01      	cmp	r3, #1
 801830e:	d102      	bne.n	8018316 <process_data_context_main+0x12c>
      set_wraparound_pointers(cinfo);
 8018310:	68f8      	ldr	r0, [r7, #12]
 8018312:	f7ff fde1 	bl	8017ed8 <set_wraparound_pointers>
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
 8018316:	697b      	ldr	r3, [r7, #20]
 8018318:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801831a:	f083 0201 	eor.w	r2, r3, #1
 801831e:	697b      	ldr	r3, [r7, #20]
 8018320:	641a      	str	r2, [r3, #64]	@ 0x40
    main->buffer_full = FALSE;
 8018322:	697b      	ldr	r3, [r7, #20]
 8018324:	2200      	movs	r2, #0
 8018326:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
 8018328:	68fb      	ldr	r3, [r7, #12]
 801832a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801832e:	3301      	adds	r3, #1
 8018330:	461a      	mov	r2, r3
 8018332:	697b      	ldr	r3, [r7, #20]
 8018334:	635a      	str	r2, [r3, #52]	@ 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
 8018336:	68fb      	ldr	r3, [r7, #12]
 8018338:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801833c:	3302      	adds	r3, #2
 801833e:	461a      	mov	r2, r3
 8018340:	697b      	ldr	r3, [r7, #20]
 8018342:	649a      	str	r2, [r3, #72]	@ 0x48
    main->context_state = CTX_POSTPONED_ROW;
 8018344:	697b      	ldr	r3, [r7, #20]
 8018346:	2202      	movs	r2, #2
 8018348:	645a      	str	r2, [r3, #68]	@ 0x44
 801834a:	e006      	b.n	801835a <process_data_context_main+0x170>
      return;			/* suspension forced, can do nothing more */
 801834c:	bf00      	nop
 801834e:	e004      	b.n	801835a <process_data_context_main+0x170>
      return;			/* Need to suspend */
 8018350:	bf00      	nop
 8018352:	e002      	b.n	801835a <process_data_context_main+0x170>
      return;			/* Postprocessor exactly filled output buf */
 8018354:	bf00      	nop
 8018356:	e000      	b.n	801835a <process_data_context_main+0x170>
      return;			/* Need to suspend */
 8018358:	bf00      	nop
  }
}
 801835a:	371c      	adds	r7, #28
 801835c:	46bd      	mov	sp, r7
 801835e:	bd90      	pop	{r4, r7, pc}

08018360 <process_data_crank_post>:

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
 8018360:	b590      	push	{r4, r7, lr}
 8018362:	b089      	sub	sp, #36	@ 0x24
 8018364:	af04      	add	r7, sp, #16
 8018366:	60f8      	str	r0, [r7, #12]
 8018368:	60b9      	str	r1, [r7, #8]
 801836a:	607a      	str	r2, [r7, #4]
 801836c:	603b      	str	r3, [r7, #0]
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
 801836e:	68fb      	ldr	r3, [r7, #12]
 8018370:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 8018374:	685c      	ldr	r4, [r3, #4]
 8018376:	683b      	ldr	r3, [r7, #0]
 8018378:	9302      	str	r3, [sp, #8]
 801837a:	687b      	ldr	r3, [r7, #4]
 801837c:	9301      	str	r3, [sp, #4]
 801837e:	68bb      	ldr	r3, [r7, #8]
 8018380:	9300      	str	r3, [sp, #0]
 8018382:	2300      	movs	r3, #0
 8018384:	2200      	movs	r2, #0
 8018386:	2100      	movs	r1, #0
 8018388:	68f8      	ldr	r0, [r7, #12]
 801838a:	47a0      	blx	r4
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}
 801838c:	bf00      	nop
 801838e:	3714      	adds	r7, #20
 8018390:	46bd      	mov	sp, r7
 8018392:	bd90      	pop	{r4, r7, pc}

08018394 <jinit_d_main_controller>:
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 8018394:	b590      	push	{r4, r7, lr}
 8018396:	b089      	sub	sp, #36	@ 0x24
 8018398:	af00      	add	r7, sp, #0
 801839a:	6078      	str	r0, [r7, #4]
 801839c:	6039      	str	r1, [r7, #0]
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801839e:	687b      	ldr	r3, [r7, #4]
 80183a0:	685b      	ldr	r3, [r3, #4]
 80183a2:	681b      	ldr	r3, [r3, #0]
 80183a4:	2250      	movs	r2, #80	@ 0x50
 80183a6:	2101      	movs	r1, #1
 80183a8:	6878      	ldr	r0, [r7, #4]
 80183aa:	4798      	blx	r3
 80183ac:	6138      	str	r0, [r7, #16]
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
 80183ae:	687b      	ldr	r3, [r7, #4]
 80183b0:	693a      	ldr	r2, [r7, #16]
 80183b2:	f8c3 21bc 	str.w	r2, [r3, #444]	@ 0x1bc
  main->pub.start_pass = start_pass_main;
 80183b6:	693b      	ldr	r3, [r7, #16]
 80183b8:	4a34      	ldr	r2, [pc, #208]	@ (801848c <jinit_d_main_controller+0xf8>)
 80183ba:	601a      	str	r2, [r3, #0]

  if (need_full_buffer)		/* shouldn't happen */
 80183bc:	683b      	ldr	r3, [r7, #0]
 80183be:	2b00      	cmp	r3, #0
 80183c0:	d008      	beq.n	80183d4 <jinit_d_main_controller+0x40>
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 80183c2:	687b      	ldr	r3, [r7, #4]
 80183c4:	681b      	ldr	r3, [r3, #0]
 80183c6:	2203      	movs	r2, #3
 80183c8:	615a      	str	r2, [r3, #20]
 80183ca:	687b      	ldr	r3, [r7, #4]
 80183cc:	681b      	ldr	r3, [r3, #0]
 80183ce:	681b      	ldr	r3, [r3, #0]
 80183d0:	6878      	ldr	r0, [r7, #4]
 80183d2:	4798      	blx	r3

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
 80183d4:	687b      	ldr	r3, [r7, #4]
 80183d6:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 80183da:	689b      	ldr	r3, [r3, #8]
 80183dc:	2b00      	cmp	r3, #0
 80183de:	d016      	beq.n	801840e <jinit_d_main_controller+0x7a>
    if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */
 80183e0:	687b      	ldr	r3, [r7, #4]
 80183e2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 80183e6:	2b01      	cmp	r3, #1
 80183e8:	dc08      	bgt.n	80183fc <jinit_d_main_controller+0x68>
      ERREXIT(cinfo, JERR_NOTIMPL);
 80183ea:	687b      	ldr	r3, [r7, #4]
 80183ec:	681b      	ldr	r3, [r3, #0]
 80183ee:	2230      	movs	r2, #48	@ 0x30
 80183f0:	615a      	str	r2, [r3, #20]
 80183f2:	687b      	ldr	r3, [r7, #4]
 80183f4:	681b      	ldr	r3, [r3, #0]
 80183f6:	681b      	ldr	r3, [r3, #0]
 80183f8:	6878      	ldr	r0, [r7, #4]
 80183fa:	4798      	blx	r3
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
 80183fc:	6878      	ldr	r0, [r7, #4]
 80183fe:	f7ff fc53 	bl	8017ca8 <alloc_funny_pointers>
    ngroups = cinfo->min_DCT_v_scaled_size + 2;
 8018402:	687b      	ldr	r3, [r7, #4]
 8018404:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8018408:	3302      	adds	r3, #2
 801840a:	61bb      	str	r3, [r7, #24]
 801840c:	e003      	b.n	8018416 <jinit_d_main_controller+0x82>
  } else {
    ngroups = cinfo->min_DCT_v_scaled_size;
 801840e:	687b      	ldr	r3, [r7, #4]
 8018410:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 8018414:	61bb      	str	r3, [r7, #24]
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8018416:	2300      	movs	r3, #0
 8018418:	61fb      	str	r3, [r7, #28]
 801841a:	687b      	ldr	r3, [r7, #4]
 801841c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8018420:	617b      	str	r3, [r7, #20]
 8018422:	e028      	b.n	8018476 <jinit_d_main_controller+0xe2>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8018424:	697b      	ldr	r3, [r7, #20]
 8018426:	68db      	ldr	r3, [r3, #12]
 8018428:	697a      	ldr	r2, [r7, #20]
 801842a:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801842c:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8018430:	687b      	ldr	r3, [r7, #4]
 8018432:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8018436:	fb92 f3f3 	sdiv	r3, r2, r3
 801843a:	60fb      	str	r3, [r7, #12]
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 801843c:	687b      	ldr	r3, [r7, #4]
 801843e:	685b      	ldr	r3, [r3, #4]
 8018440:	689c      	ldr	r4, [r3, #8]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 8018442:	697b      	ldr	r3, [r7, #20]
 8018444:	69db      	ldr	r3, [r3, #28]
 8018446:	697a      	ldr	r2, [r7, #20]
 8018448:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 801844a:	fb02 f103 	mul.w	r1, r2, r3
			 (JDIMENSION) (rgroup * ngroups));
 801844e:	68fb      	ldr	r3, [r7, #12]
 8018450:	69ba      	ldr	r2, [r7, #24]
 8018452:	fb02 f303 	mul.w	r3, r2, r3
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 8018456:	460a      	mov	r2, r1
 8018458:	2101      	movs	r1, #1
 801845a:	6878      	ldr	r0, [r7, #4]
 801845c:	47a0      	blx	r4
 801845e:	4601      	mov	r1, r0
 8018460:	693b      	ldr	r3, [r7, #16]
 8018462:	69fa      	ldr	r2, [r7, #28]
 8018464:	3202      	adds	r2, #2
 8018466:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
       ci++, compptr++) {
 801846a:	69fb      	ldr	r3, [r7, #28]
 801846c:	3301      	adds	r3, #1
 801846e:	61fb      	str	r3, [r7, #28]
 8018470:	697b      	ldr	r3, [r7, #20]
 8018472:	3358      	adds	r3, #88	@ 0x58
 8018474:	617b      	str	r3, [r7, #20]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8018476:	687b      	ldr	r3, [r7, #4]
 8018478:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801847a:	69fa      	ldr	r2, [r7, #28]
 801847c:	429a      	cmp	r2, r3
 801847e:	dbd1      	blt.n	8018424 <jinit_d_main_controller+0x90>
  }
}
 8018480:	bf00      	nop
 8018482:	bf00      	nop
 8018484:	3724      	adds	r7, #36	@ 0x24
 8018486:	46bd      	mov	sp, r7
 8018488:	bd90      	pop	{r4, r7, pc}
 801848a:	bf00      	nop
 801848c:	080180d1 	.word	0x080180d1

08018490 <get_soi>:


LOCAL(boolean)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
 8018490:	b580      	push	{r7, lr}
 8018492:	b084      	sub	sp, #16
 8018494:	af00      	add	r7, sp, #0
 8018496:	6078      	str	r0, [r7, #4]
  int i;
  
  TRACEMS(cinfo, 1, JTRC_SOI);
 8018498:	687b      	ldr	r3, [r7, #4]
 801849a:	681b      	ldr	r3, [r3, #0]
 801849c:	2268      	movs	r2, #104	@ 0x68
 801849e:	615a      	str	r2, [r3, #20]
 80184a0:	687b      	ldr	r3, [r7, #4]
 80184a2:	681b      	ldr	r3, [r3, #0]
 80184a4:	685b      	ldr	r3, [r3, #4]
 80184a6:	2101      	movs	r1, #1
 80184a8:	6878      	ldr	r0, [r7, #4]
 80184aa:	4798      	blx	r3

  if (cinfo->marker->saw_SOI)
 80184ac:	687b      	ldr	r3, [r7, #4]
 80184ae:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80184b2:	68db      	ldr	r3, [r3, #12]
 80184b4:	2b00      	cmp	r3, #0
 80184b6:	d008      	beq.n	80184ca <get_soi+0x3a>
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);
 80184b8:	687b      	ldr	r3, [r7, #4]
 80184ba:	681b      	ldr	r3, [r3, #0]
 80184bc:	223f      	movs	r2, #63	@ 0x3f
 80184be:	615a      	str	r2, [r3, #20]
 80184c0:	687b      	ldr	r3, [r7, #4]
 80184c2:	681b      	ldr	r3, [r3, #0]
 80184c4:	681b      	ldr	r3, [r3, #0]
 80184c6:	6878      	ldr	r0, [r7, #4]
 80184c8:	4798      	blx	r3

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 80184ca:	2300      	movs	r3, #0
 80184cc:	60fb      	str	r3, [r7, #12]
 80184ce:	e015      	b.n	80184fc <get_soi+0x6c>
    cinfo->arith_dc_L[i] = 0;
 80184d0:	687a      	ldr	r2, [r7, #4]
 80184d2:	68fb      	ldr	r3, [r7, #12]
 80184d4:	4413      	add	r3, r2
 80184d6:	33e8      	adds	r3, #232	@ 0xe8
 80184d8:	2200      	movs	r2, #0
 80184da:	701a      	strb	r2, [r3, #0]
    cinfo->arith_dc_U[i] = 1;
 80184dc:	687a      	ldr	r2, [r7, #4]
 80184de:	68fb      	ldr	r3, [r7, #12]
 80184e0:	4413      	add	r3, r2
 80184e2:	33f8      	adds	r3, #248	@ 0xf8
 80184e4:	2201      	movs	r2, #1
 80184e6:	701a      	strb	r2, [r3, #0]
    cinfo->arith_ac_K[i] = 5;
 80184e8:	687a      	ldr	r2, [r7, #4]
 80184ea:	68fb      	ldr	r3, [r7, #12]
 80184ec:	4413      	add	r3, r2
 80184ee:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80184f2:	2205      	movs	r2, #5
 80184f4:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 80184f6:	68fb      	ldr	r3, [r7, #12]
 80184f8:	3301      	adds	r3, #1
 80184fa:	60fb      	str	r3, [r7, #12]
 80184fc:	68fb      	ldr	r3, [r7, #12]
 80184fe:	2b0f      	cmp	r3, #15
 8018500:	dde6      	ble.n	80184d0 <get_soi+0x40>
  }
  cinfo->restart_interval = 0;
 8018502:	687b      	ldr	r3, [r7, #4]
 8018504:	2200      	movs	r2, #0
 8018506:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
 801850a:	687b      	ldr	r3, [r7, #4]
 801850c:	2200      	movs	r2, #0
 801850e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
 8018512:	687b      	ldr	r3, [r7, #4]
 8018514:	2200      	movs	r2, #0
 8018516:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

  cinfo->saw_JFIF_marker = FALSE;
 801851a:	687b      	ldr	r3, [r7, #4]
 801851c:	2200      	movs	r2, #0
 801851e:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
 8018522:	687b      	ldr	r3, [r7, #4]
 8018524:	2201      	movs	r2, #1
 8018526:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
  cinfo->JFIF_minor_version = 1;
 801852a:	687b      	ldr	r3, [r7, #4]
 801852c:	2201      	movs	r2, #1
 801852e:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
  cinfo->density_unit = 0;
 8018532:	687b      	ldr	r3, [r7, #4]
 8018534:	2200      	movs	r2, #0
 8018536:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
  cinfo->X_density = 1;
 801853a:	687b      	ldr	r3, [r7, #4]
 801853c:	2201      	movs	r2, #1
 801853e:	f8a3 2124 	strh.w	r2, [r3, #292]	@ 0x124
  cinfo->Y_density = 1;
 8018542:	687b      	ldr	r3, [r7, #4]
 8018544:	2201      	movs	r2, #1
 8018546:	f8a3 2126 	strh.w	r2, [r3, #294]	@ 0x126
  cinfo->saw_Adobe_marker = FALSE;
 801854a:	687b      	ldr	r3, [r7, #4]
 801854c:	2200      	movs	r2, #0
 801854e:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
  cinfo->Adobe_transform = 0;
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	2200      	movs	r2, #0
 8018556:	f883 212c 	strb.w	r2, [r3, #300]	@ 0x12c

  cinfo->marker->saw_SOI = TRUE;
 801855a:	687b      	ldr	r3, [r7, #4]
 801855c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8018560:	2201      	movs	r2, #1
 8018562:	60da      	str	r2, [r3, #12]

  return TRUE;
 8018564:	2301      	movs	r3, #1
}
 8018566:	4618      	mov	r0, r3
 8018568:	3710      	adds	r7, #16
 801856a:	46bd      	mov	sp, r7
 801856c:	bd80      	pop	{r7, pc}

0801856e <get_sof>:

LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_baseline, boolean is_prog,
	 boolean is_arith)
/* Process a SOFn marker */
{
 801856e:	b580      	push	{r7, lr}
 8018570:	b08e      	sub	sp, #56	@ 0x38
 8018572:	af00      	add	r7, sp, #0
 8018574:	60f8      	str	r0, [r7, #12]
 8018576:	60b9      	str	r1, [r7, #8]
 8018578:	607a      	str	r2, [r7, #4]
 801857a:	603b      	str	r3, [r7, #0]
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 801857c:	68fb      	ldr	r3, [r7, #12]
 801857e:	699b      	ldr	r3, [r3, #24]
 8018580:	627b      	str	r3, [r7, #36]	@ 0x24
 8018582:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018584:	681b      	ldr	r3, [r3, #0]
 8018586:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018588:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801858a:	685b      	ldr	r3, [r3, #4]
 801858c:	62bb      	str	r3, [r7, #40]	@ 0x28

  cinfo->is_baseline = is_baseline;
 801858e:	68fb      	ldr	r3, [r7, #12]
 8018590:	68ba      	ldr	r2, [r7, #8]
 8018592:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  cinfo->progressive_mode = is_prog;
 8018596:	68fb      	ldr	r3, [r7, #12]
 8018598:	687a      	ldr	r2, [r7, #4]
 801859a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  cinfo->arith_code = is_arith;
 801859e:	68fb      	ldr	r3, [r7, #12]
 80185a0:	683a      	ldr	r2, [r7, #0]
 80185a2:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4

  INPUT_2BYTES(cinfo, length, return FALSE);
 80185a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80185a8:	2b00      	cmp	r3, #0
 80185aa:	d10e      	bne.n	80185ca <get_sof+0x5c>
 80185ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185ae:	68db      	ldr	r3, [r3, #12]
 80185b0:	68f8      	ldr	r0, [r7, #12]
 80185b2:	4798      	blx	r3
 80185b4:	4603      	mov	r3, r0
 80185b6:	2b00      	cmp	r3, #0
 80185b8:	d101      	bne.n	80185be <get_sof+0x50>
 80185ba:	2300      	movs	r3, #0
 80185bc:	e1e7      	b.n	801898e <get_sof+0x420>
 80185be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185c0:	681b      	ldr	r3, [r3, #0]
 80185c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80185c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185c6:	685b      	ldr	r3, [r3, #4]
 80185c8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80185ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80185cc:	3b01      	subs	r3, #1
 80185ce:	62bb      	str	r3, [r7, #40]	@ 0x28
 80185d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80185d2:	1c5a      	adds	r2, r3, #1
 80185d4:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80185d6:	781b      	ldrb	r3, [r3, #0]
 80185d8:	021b      	lsls	r3, r3, #8
 80185da:	623b      	str	r3, [r7, #32]
 80185dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80185de:	2b00      	cmp	r3, #0
 80185e0:	d10e      	bne.n	8018600 <get_sof+0x92>
 80185e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185e4:	68db      	ldr	r3, [r3, #12]
 80185e6:	68f8      	ldr	r0, [r7, #12]
 80185e8:	4798      	blx	r3
 80185ea:	4603      	mov	r3, r0
 80185ec:	2b00      	cmp	r3, #0
 80185ee:	d101      	bne.n	80185f4 <get_sof+0x86>
 80185f0:	2300      	movs	r3, #0
 80185f2:	e1cc      	b.n	801898e <get_sof+0x420>
 80185f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185f6:	681b      	ldr	r3, [r3, #0]
 80185f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80185fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80185fc:	685b      	ldr	r3, [r3, #4]
 80185fe:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018600:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018602:	3b01      	subs	r3, #1
 8018604:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018606:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018608:	1c5a      	adds	r2, r3, #1
 801860a:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801860c:	781b      	ldrb	r3, [r3, #0]
 801860e:	461a      	mov	r2, r3
 8018610:	6a3b      	ldr	r3, [r7, #32]
 8018612:	4413      	add	r3, r2
 8018614:	623b      	str	r3, [r7, #32]

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
 8018616:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018618:	2b00      	cmp	r3, #0
 801861a:	d10e      	bne.n	801863a <get_sof+0xcc>
 801861c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801861e:	68db      	ldr	r3, [r3, #12]
 8018620:	68f8      	ldr	r0, [r7, #12]
 8018622:	4798      	blx	r3
 8018624:	4603      	mov	r3, r0
 8018626:	2b00      	cmp	r3, #0
 8018628:	d101      	bne.n	801862e <get_sof+0xc0>
 801862a:	2300      	movs	r3, #0
 801862c:	e1af      	b.n	801898e <get_sof+0x420>
 801862e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018630:	681b      	ldr	r3, [r3, #0]
 8018632:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018634:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018636:	685b      	ldr	r3, [r3, #4]
 8018638:	62bb      	str	r3, [r7, #40]	@ 0x28
 801863a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801863c:	3b01      	subs	r3, #1
 801863e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018640:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018642:	1c5a      	adds	r2, r3, #1
 8018644:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8018646:	781b      	ldrb	r3, [r3, #0]
 8018648:	461a      	mov	r2, r3
 801864a:	68fb      	ldr	r3, [r7, #12]
 801864c:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
 8018650:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018652:	2b00      	cmp	r3, #0
 8018654:	d10e      	bne.n	8018674 <get_sof+0x106>
 8018656:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018658:	68db      	ldr	r3, [r3, #12]
 801865a:	68f8      	ldr	r0, [r7, #12]
 801865c:	4798      	blx	r3
 801865e:	4603      	mov	r3, r0
 8018660:	2b00      	cmp	r3, #0
 8018662:	d101      	bne.n	8018668 <get_sof+0xfa>
 8018664:	2300      	movs	r3, #0
 8018666:	e192      	b.n	801898e <get_sof+0x420>
 8018668:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801866a:	681b      	ldr	r3, [r3, #0]
 801866c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801866e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018670:	685b      	ldr	r3, [r3, #4]
 8018672:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018674:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018676:	3b01      	subs	r3, #1
 8018678:	62bb      	str	r3, [r7, #40]	@ 0x28
 801867a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801867c:	1c5a      	adds	r2, r3, #1
 801867e:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8018680:	781b      	ldrb	r3, [r3, #0]
 8018682:	021a      	lsls	r2, r3, #8
 8018684:	68fb      	ldr	r3, [r7, #12]
 8018686:	621a      	str	r2, [r3, #32]
 8018688:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801868a:	2b00      	cmp	r3, #0
 801868c:	d10e      	bne.n	80186ac <get_sof+0x13e>
 801868e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018690:	68db      	ldr	r3, [r3, #12]
 8018692:	68f8      	ldr	r0, [r7, #12]
 8018694:	4798      	blx	r3
 8018696:	4603      	mov	r3, r0
 8018698:	2b00      	cmp	r3, #0
 801869a:	d101      	bne.n	80186a0 <get_sof+0x132>
 801869c:	2300      	movs	r3, #0
 801869e:	e176      	b.n	801898e <get_sof+0x420>
 80186a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80186a2:	681b      	ldr	r3, [r3, #0]
 80186a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80186a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80186a8:	685b      	ldr	r3, [r3, #4]
 80186aa:	62bb      	str	r3, [r7, #40]	@ 0x28
 80186ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80186ae:	3b01      	subs	r3, #1
 80186b0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80186b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80186b4:	1c5a      	adds	r2, r3, #1
 80186b6:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80186b8:	781a      	ldrb	r2, [r3, #0]
 80186ba:	68fb      	ldr	r3, [r7, #12]
 80186bc:	6a1b      	ldr	r3, [r3, #32]
 80186be:	441a      	add	r2, r3
 80186c0:	68fb      	ldr	r3, [r7, #12]
 80186c2:	621a      	str	r2, [r3, #32]
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
 80186c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80186c6:	2b00      	cmp	r3, #0
 80186c8:	d10e      	bne.n	80186e8 <get_sof+0x17a>
 80186ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80186cc:	68db      	ldr	r3, [r3, #12]
 80186ce:	68f8      	ldr	r0, [r7, #12]
 80186d0:	4798      	blx	r3
 80186d2:	4603      	mov	r3, r0
 80186d4:	2b00      	cmp	r3, #0
 80186d6:	d101      	bne.n	80186dc <get_sof+0x16e>
 80186d8:	2300      	movs	r3, #0
 80186da:	e158      	b.n	801898e <get_sof+0x420>
 80186dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80186de:	681b      	ldr	r3, [r3, #0]
 80186e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80186e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80186e4:	685b      	ldr	r3, [r3, #4]
 80186e6:	62bb      	str	r3, [r7, #40]	@ 0x28
 80186e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80186ea:	3b01      	subs	r3, #1
 80186ec:	62bb      	str	r3, [r7, #40]	@ 0x28
 80186ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80186f0:	1c5a      	adds	r2, r3, #1
 80186f2:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80186f4:	781b      	ldrb	r3, [r3, #0]
 80186f6:	021a      	lsls	r2, r3, #8
 80186f8:	68fb      	ldr	r3, [r7, #12]
 80186fa:	61da      	str	r2, [r3, #28]
 80186fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80186fe:	2b00      	cmp	r3, #0
 8018700:	d10e      	bne.n	8018720 <get_sof+0x1b2>
 8018702:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018704:	68db      	ldr	r3, [r3, #12]
 8018706:	68f8      	ldr	r0, [r7, #12]
 8018708:	4798      	blx	r3
 801870a:	4603      	mov	r3, r0
 801870c:	2b00      	cmp	r3, #0
 801870e:	d101      	bne.n	8018714 <get_sof+0x1a6>
 8018710:	2300      	movs	r3, #0
 8018712:	e13c      	b.n	801898e <get_sof+0x420>
 8018714:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018716:	681b      	ldr	r3, [r3, #0]
 8018718:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801871a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801871c:	685b      	ldr	r3, [r3, #4]
 801871e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018720:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018722:	3b01      	subs	r3, #1
 8018724:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018726:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018728:	1c5a      	adds	r2, r3, #1
 801872a:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801872c:	781a      	ldrb	r2, [r3, #0]
 801872e:	68fb      	ldr	r3, [r7, #12]
 8018730:	69db      	ldr	r3, [r3, #28]
 8018732:	441a      	add	r2, r3
 8018734:	68fb      	ldr	r3, [r7, #12]
 8018736:	61da      	str	r2, [r3, #28]
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
 8018738:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801873a:	2b00      	cmp	r3, #0
 801873c:	d10e      	bne.n	801875c <get_sof+0x1ee>
 801873e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018740:	68db      	ldr	r3, [r3, #12]
 8018742:	68f8      	ldr	r0, [r7, #12]
 8018744:	4798      	blx	r3
 8018746:	4603      	mov	r3, r0
 8018748:	2b00      	cmp	r3, #0
 801874a:	d101      	bne.n	8018750 <get_sof+0x1e2>
 801874c:	2300      	movs	r3, #0
 801874e:	e11e      	b.n	801898e <get_sof+0x420>
 8018750:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018752:	681b      	ldr	r3, [r3, #0]
 8018754:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018756:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018758:	685b      	ldr	r3, [r3, #4]
 801875a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801875c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801875e:	3b01      	subs	r3, #1
 8018760:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018762:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018764:	1c5a      	adds	r2, r3, #1
 8018766:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8018768:	781b      	ldrb	r3, [r3, #0]
 801876a:	461a      	mov	r2, r3
 801876c:	68fb      	ldr	r3, [r7, #12]
 801876e:	625a      	str	r2, [r3, #36]	@ 0x24

  length -= 8;
 8018770:	6a3b      	ldr	r3, [r7, #32]
 8018772:	3b08      	subs	r3, #8
 8018774:	623b      	str	r3, [r7, #32]

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
 8018776:	68fb      	ldr	r3, [r7, #12]
 8018778:	681b      	ldr	r3, [r3, #0]
 801877a:	3318      	adds	r3, #24
 801877c:	61fb      	str	r3, [r7, #28]
 801877e:	68fb      	ldr	r3, [r7, #12]
 8018780:	f8d3 21b4 	ldr.w	r2, [r3, #436]	@ 0x1b4
 8018784:	69fb      	ldr	r3, [r7, #28]
 8018786:	601a      	str	r2, [r3, #0]
 8018788:	68fb      	ldr	r3, [r7, #12]
 801878a:	69da      	ldr	r2, [r3, #28]
 801878c:	69fb      	ldr	r3, [r7, #28]
 801878e:	3304      	adds	r3, #4
 8018790:	601a      	str	r2, [r3, #0]
 8018792:	68fb      	ldr	r3, [r7, #12]
 8018794:	6a1a      	ldr	r2, [r3, #32]
 8018796:	69fb      	ldr	r3, [r7, #28]
 8018798:	3308      	adds	r3, #8
 801879a:	601a      	str	r2, [r3, #0]
 801879c:	69fb      	ldr	r3, [r7, #28]
 801879e:	330c      	adds	r3, #12
 80187a0:	68fa      	ldr	r2, [r7, #12]
 80187a2:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80187a4:	601a      	str	r2, [r3, #0]
 80187a6:	68fb      	ldr	r3, [r7, #12]
 80187a8:	681b      	ldr	r3, [r3, #0]
 80187aa:	2266      	movs	r2, #102	@ 0x66
 80187ac:	615a      	str	r2, [r3, #20]
 80187ae:	68fb      	ldr	r3, [r7, #12]
 80187b0:	681b      	ldr	r3, [r3, #0]
 80187b2:	685b      	ldr	r3, [r3, #4]
 80187b4:	2101      	movs	r1, #1
 80187b6:	68f8      	ldr	r0, [r7, #12]
 80187b8:	4798      	blx	r3
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
 80187ba:	68fb      	ldr	r3, [r7, #12]
 80187bc:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80187c0:	691b      	ldr	r3, [r3, #16]
 80187c2:	2b00      	cmp	r3, #0
 80187c4:	d008      	beq.n	80187d8 <get_sof+0x26a>
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);
 80187c6:	68fb      	ldr	r3, [r7, #12]
 80187c8:	681b      	ldr	r3, [r3, #0]
 80187ca:	223c      	movs	r2, #60	@ 0x3c
 80187cc:	615a      	str	r2, [r3, #20]
 80187ce:	68fb      	ldr	r3, [r7, #12]
 80187d0:	681b      	ldr	r3, [r3, #0]
 80187d2:	681b      	ldr	r3, [r3, #0]
 80187d4:	68f8      	ldr	r0, [r7, #12]
 80187d6:	4798      	blx	r3

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
 80187d8:	68fb      	ldr	r3, [r7, #12]
 80187da:	6a1b      	ldr	r3, [r3, #32]
 80187dc:	2b00      	cmp	r3, #0
 80187de:	d007      	beq.n	80187f0 <get_sof+0x282>
 80187e0:	68fb      	ldr	r3, [r7, #12]
 80187e2:	69db      	ldr	r3, [r3, #28]
 80187e4:	2b00      	cmp	r3, #0
 80187e6:	d003      	beq.n	80187f0 <get_sof+0x282>
      || cinfo->num_components <= 0)
 80187e8:	68fb      	ldr	r3, [r7, #12]
 80187ea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80187ec:	2b00      	cmp	r3, #0
 80187ee:	dc08      	bgt.n	8018802 <get_sof+0x294>
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);
 80187f0:	68fb      	ldr	r3, [r7, #12]
 80187f2:	681b      	ldr	r3, [r3, #0]
 80187f4:	2221      	movs	r2, #33	@ 0x21
 80187f6:	615a      	str	r2, [r3, #20]
 80187f8:	68fb      	ldr	r3, [r7, #12]
 80187fa:	681b      	ldr	r3, [r3, #0]
 80187fc:	681b      	ldr	r3, [r3, #0]
 80187fe:	68f8      	ldr	r0, [r7, #12]
 8018800:	4798      	blx	r3

  if (length != (cinfo->num_components * 3))
 8018802:	68fb      	ldr	r3, [r7, #12]
 8018804:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8018806:	4613      	mov	r3, r2
 8018808:	005b      	lsls	r3, r3, #1
 801880a:	4413      	add	r3, r2
 801880c:	6a3a      	ldr	r2, [r7, #32]
 801880e:	429a      	cmp	r2, r3
 8018810:	d008      	beq.n	8018824 <get_sof+0x2b6>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8018812:	68fb      	ldr	r3, [r7, #12]
 8018814:	681b      	ldr	r3, [r3, #0]
 8018816:	220c      	movs	r2, #12
 8018818:	615a      	str	r2, [r3, #20]
 801881a:	68fb      	ldr	r3, [r7, #12]
 801881c:	681b      	ldr	r3, [r3, #0]
 801881e:	681b      	ldr	r3, [r3, #0]
 8018820:	68f8      	ldr	r0, [r7, #12]
 8018822:	4798      	blx	r3

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
 8018824:	68fb      	ldr	r3, [r7, #12]
 8018826:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801882a:	2b00      	cmp	r3, #0
 801882c:	d10f      	bne.n	801884e <get_sof+0x2e0>
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 801882e:	68fb      	ldr	r3, [r7, #12]
 8018830:	685b      	ldr	r3, [r3, #4]
 8018832:	681b      	ldr	r3, [r3, #0]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));
 8018834:	68fa      	ldr	r2, [r7, #12]
 8018836:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8018838:	4611      	mov	r1, r2
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 801883a:	2258      	movs	r2, #88	@ 0x58
 801883c:	fb01 f202 	mul.w	r2, r1, r2
 8018840:	2101      	movs	r1, #1
 8018842:	68f8      	ldr	r0, [r7, #12]
 8018844:	4798      	blx	r3
 8018846:	4602      	mov	r2, r0
 8018848:	68fb      	ldr	r3, [r7, #12]
 801884a:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801884e:	2300      	movs	r3, #0
 8018850:	637b      	str	r3, [r7, #52]	@ 0x34
 8018852:	68fb      	ldr	r3, [r7, #12]
 8018854:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8018858:	633b      	str	r3, [r7, #48]	@ 0x30
 801885a:	e086      	b.n	801896a <get_sof+0x3fc>
       ci++, compptr++) {
    compptr->component_index = ci;
 801885c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801885e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018860:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
 8018862:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018864:	2b00      	cmp	r3, #0
 8018866:	d10e      	bne.n	8018886 <get_sof+0x318>
 8018868:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801886a:	68db      	ldr	r3, [r3, #12]
 801886c:	68f8      	ldr	r0, [r7, #12]
 801886e:	4798      	blx	r3
 8018870:	4603      	mov	r3, r0
 8018872:	2b00      	cmp	r3, #0
 8018874:	d101      	bne.n	801887a <get_sof+0x30c>
 8018876:	2300      	movs	r3, #0
 8018878:	e089      	b.n	801898e <get_sof+0x420>
 801887a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801887c:	681b      	ldr	r3, [r3, #0]
 801887e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018880:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018882:	685b      	ldr	r3, [r3, #4]
 8018884:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018886:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018888:	3b01      	subs	r3, #1
 801888a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801888c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801888e:	1c5a      	adds	r2, r3, #1
 8018890:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8018892:	781b      	ldrb	r3, [r3, #0]
 8018894:	461a      	mov	r2, r3
 8018896:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018898:	601a      	str	r2, [r3, #0]
    INPUT_BYTE(cinfo, c, return FALSE);
 801889a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801889c:	2b00      	cmp	r3, #0
 801889e:	d10e      	bne.n	80188be <get_sof+0x350>
 80188a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80188a2:	68db      	ldr	r3, [r3, #12]
 80188a4:	68f8      	ldr	r0, [r7, #12]
 80188a6:	4798      	blx	r3
 80188a8:	4603      	mov	r3, r0
 80188aa:	2b00      	cmp	r3, #0
 80188ac:	d101      	bne.n	80188b2 <get_sof+0x344>
 80188ae:	2300      	movs	r3, #0
 80188b0:	e06d      	b.n	801898e <get_sof+0x420>
 80188b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80188b4:	681b      	ldr	r3, [r3, #0]
 80188b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80188b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80188ba:	685b      	ldr	r3, [r3, #4]
 80188bc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80188be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188c0:	3b01      	subs	r3, #1
 80188c2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80188c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80188c6:	1c5a      	adds	r2, r3, #1
 80188c8:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80188ca:	781b      	ldrb	r3, [r3, #0]
 80188cc:	61bb      	str	r3, [r7, #24]
    compptr->h_samp_factor = (c >> 4) & 15;
 80188ce:	69bb      	ldr	r3, [r7, #24]
 80188d0:	111b      	asrs	r3, r3, #4
 80188d2:	f003 020f 	and.w	r2, r3, #15
 80188d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80188d8:	609a      	str	r2, [r3, #8]
    compptr->v_samp_factor = (c     ) & 15;
 80188da:	69bb      	ldr	r3, [r7, #24]
 80188dc:	f003 020f 	and.w	r2, r3, #15
 80188e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80188e2:	60da      	str	r2, [r3, #12]
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
 80188e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188e6:	2b00      	cmp	r3, #0
 80188e8:	d10e      	bne.n	8018908 <get_sof+0x39a>
 80188ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80188ec:	68db      	ldr	r3, [r3, #12]
 80188ee:	68f8      	ldr	r0, [r7, #12]
 80188f0:	4798      	blx	r3
 80188f2:	4603      	mov	r3, r0
 80188f4:	2b00      	cmp	r3, #0
 80188f6:	d101      	bne.n	80188fc <get_sof+0x38e>
 80188f8:	2300      	movs	r3, #0
 80188fa:	e048      	b.n	801898e <get_sof+0x420>
 80188fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80188fe:	681b      	ldr	r3, [r3, #0]
 8018900:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018902:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018904:	685b      	ldr	r3, [r3, #4]
 8018906:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018908:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801890a:	3b01      	subs	r3, #1
 801890c:	62bb      	str	r3, [r7, #40]	@ 0x28
 801890e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018910:	1c5a      	adds	r2, r3, #1
 8018912:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8018914:	781b      	ldrb	r3, [r3, #0]
 8018916:	461a      	mov	r2, r3
 8018918:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801891a:	611a      	str	r2, [r3, #16]

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
 801891c:	68fb      	ldr	r3, [r7, #12]
 801891e:	681b      	ldr	r3, [r3, #0]
 8018920:	3318      	adds	r3, #24
 8018922:	617b      	str	r3, [r7, #20]
 8018924:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018926:	681a      	ldr	r2, [r3, #0]
 8018928:	697b      	ldr	r3, [r7, #20]
 801892a:	601a      	str	r2, [r3, #0]
 801892c:	697b      	ldr	r3, [r7, #20]
 801892e:	3304      	adds	r3, #4
 8018930:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018932:	6892      	ldr	r2, [r2, #8]
 8018934:	601a      	str	r2, [r3, #0]
 8018936:	697b      	ldr	r3, [r7, #20]
 8018938:	3308      	adds	r3, #8
 801893a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801893c:	68d2      	ldr	r2, [r2, #12]
 801893e:	601a      	str	r2, [r3, #0]
 8018940:	697b      	ldr	r3, [r7, #20]
 8018942:	330c      	adds	r3, #12
 8018944:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018946:	6912      	ldr	r2, [r2, #16]
 8018948:	601a      	str	r2, [r3, #0]
 801894a:	68fb      	ldr	r3, [r7, #12]
 801894c:	681b      	ldr	r3, [r3, #0]
 801894e:	2267      	movs	r2, #103	@ 0x67
 8018950:	615a      	str	r2, [r3, #20]
 8018952:	68fb      	ldr	r3, [r7, #12]
 8018954:	681b      	ldr	r3, [r3, #0]
 8018956:	685b      	ldr	r3, [r3, #4]
 8018958:	2101      	movs	r1, #1
 801895a:	68f8      	ldr	r0, [r7, #12]
 801895c:	4798      	blx	r3
       ci++, compptr++) {
 801895e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8018960:	3301      	adds	r3, #1
 8018962:	637b      	str	r3, [r7, #52]	@ 0x34
 8018964:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018966:	3358      	adds	r3, #88	@ 0x58
 8018968:	633b      	str	r3, [r7, #48]	@ 0x30
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801896a:	68fb      	ldr	r3, [r7, #12]
 801896c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801896e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018970:	429a      	cmp	r2, r3
 8018972:	f6ff af73 	blt.w	801885c <get_sof+0x2ee>
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;
 8018976:	68fb      	ldr	r3, [r7, #12]
 8018978:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801897c:	2201      	movs	r2, #1
 801897e:	611a      	str	r2, [r3, #16]

  INPUT_SYNC(cinfo);
 8018980:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018982:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018984:	601a      	str	r2, [r3, #0]
 8018986:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018988:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801898a:	605a      	str	r2, [r3, #4]
  return TRUE;
 801898c:	2301      	movs	r3, #1
}
 801898e:	4618      	mov	r0, r3
 8018990:	3738      	adds	r7, #56	@ 0x38
 8018992:	46bd      	mov	sp, r7
 8018994:	bd80      	pop	{r7, pc}

08018996 <get_sos>:


LOCAL(boolean)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
 8018996:	b580      	push	{r7, lr}
 8018998:	b08e      	sub	sp, #56	@ 0x38
 801899a:	af00      	add	r7, sp, #0
 801899c:	6078      	str	r0, [r7, #4]
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 801899e:	687b      	ldr	r3, [r7, #4]
 80189a0:	699b      	ldr	r3, [r3, #24]
 80189a2:	623b      	str	r3, [r7, #32]
 80189a4:	6a3b      	ldr	r3, [r7, #32]
 80189a6:	681b      	ldr	r3, [r3, #0]
 80189a8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80189aa:	6a3b      	ldr	r3, [r7, #32]
 80189ac:	685b      	ldr	r3, [r3, #4]
 80189ae:	627b      	str	r3, [r7, #36]	@ 0x24

  if (! cinfo->marker->saw_SOF)
 80189b0:	687b      	ldr	r3, [r7, #4]
 80189b2:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80189b6:	691b      	ldr	r3, [r3, #16]
 80189b8:	2b00      	cmp	r3, #0
 80189ba:	d108      	bne.n	80189ce <get_sos+0x38>
    ERREXIT(cinfo, JERR_SOS_NO_SOF);
 80189bc:	687b      	ldr	r3, [r7, #4]
 80189be:	681b      	ldr	r3, [r3, #0]
 80189c0:	2240      	movs	r2, #64	@ 0x40
 80189c2:	615a      	str	r2, [r3, #20]
 80189c4:	687b      	ldr	r3, [r7, #4]
 80189c6:	681b      	ldr	r3, [r3, #0]
 80189c8:	681b      	ldr	r3, [r3, #0]
 80189ca:	6878      	ldr	r0, [r7, #4]
 80189cc:	4798      	blx	r3

  INPUT_2BYTES(cinfo, length, return FALSE);
 80189ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80189d0:	2b00      	cmp	r3, #0
 80189d2:	d10e      	bne.n	80189f2 <get_sos+0x5c>
 80189d4:	6a3b      	ldr	r3, [r7, #32]
 80189d6:	68db      	ldr	r3, [r3, #12]
 80189d8:	6878      	ldr	r0, [r7, #4]
 80189da:	4798      	blx	r3
 80189dc:	4603      	mov	r3, r0
 80189de:	2b00      	cmp	r3, #0
 80189e0:	d101      	bne.n	80189e6 <get_sos+0x50>
 80189e2:	2300      	movs	r3, #0
 80189e4:	e1a1      	b.n	8018d2a <get_sos+0x394>
 80189e6:	6a3b      	ldr	r3, [r7, #32]
 80189e8:	681b      	ldr	r3, [r3, #0]
 80189ea:	62bb      	str	r3, [r7, #40]	@ 0x28
 80189ec:	6a3b      	ldr	r3, [r7, #32]
 80189ee:	685b      	ldr	r3, [r3, #4]
 80189f0:	627b      	str	r3, [r7, #36]	@ 0x24
 80189f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80189f4:	3b01      	subs	r3, #1
 80189f6:	627b      	str	r3, [r7, #36]	@ 0x24
 80189f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80189fa:	1c5a      	adds	r2, r3, #1
 80189fc:	62ba      	str	r2, [r7, #40]	@ 0x28
 80189fe:	781b      	ldrb	r3, [r3, #0]
 8018a00:	021b      	lsls	r3, r3, #8
 8018a02:	61fb      	str	r3, [r7, #28]
 8018a04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018a06:	2b00      	cmp	r3, #0
 8018a08:	d10e      	bne.n	8018a28 <get_sos+0x92>
 8018a0a:	6a3b      	ldr	r3, [r7, #32]
 8018a0c:	68db      	ldr	r3, [r3, #12]
 8018a0e:	6878      	ldr	r0, [r7, #4]
 8018a10:	4798      	blx	r3
 8018a12:	4603      	mov	r3, r0
 8018a14:	2b00      	cmp	r3, #0
 8018a16:	d101      	bne.n	8018a1c <get_sos+0x86>
 8018a18:	2300      	movs	r3, #0
 8018a1a:	e186      	b.n	8018d2a <get_sos+0x394>
 8018a1c:	6a3b      	ldr	r3, [r7, #32]
 8018a1e:	681b      	ldr	r3, [r3, #0]
 8018a20:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018a22:	6a3b      	ldr	r3, [r7, #32]
 8018a24:	685b      	ldr	r3, [r3, #4]
 8018a26:	627b      	str	r3, [r7, #36]	@ 0x24
 8018a28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018a2a:	3b01      	subs	r3, #1
 8018a2c:	627b      	str	r3, [r7, #36]	@ 0x24
 8018a2e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018a30:	1c5a      	adds	r2, r3, #1
 8018a32:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018a34:	781b      	ldrb	r3, [r3, #0]
 8018a36:	461a      	mov	r2, r3
 8018a38:	69fb      	ldr	r3, [r7, #28]
 8018a3a:	4413      	add	r3, r2
 8018a3c:	61fb      	str	r3, [r7, #28]

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
 8018a3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018a40:	2b00      	cmp	r3, #0
 8018a42:	d10e      	bne.n	8018a62 <get_sos+0xcc>
 8018a44:	6a3b      	ldr	r3, [r7, #32]
 8018a46:	68db      	ldr	r3, [r3, #12]
 8018a48:	6878      	ldr	r0, [r7, #4]
 8018a4a:	4798      	blx	r3
 8018a4c:	4603      	mov	r3, r0
 8018a4e:	2b00      	cmp	r3, #0
 8018a50:	d101      	bne.n	8018a56 <get_sos+0xc0>
 8018a52:	2300      	movs	r3, #0
 8018a54:	e169      	b.n	8018d2a <get_sos+0x394>
 8018a56:	6a3b      	ldr	r3, [r7, #32]
 8018a58:	681b      	ldr	r3, [r3, #0]
 8018a5a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018a5c:	6a3b      	ldr	r3, [r7, #32]
 8018a5e:	685b      	ldr	r3, [r3, #4]
 8018a60:	627b      	str	r3, [r7, #36]	@ 0x24
 8018a62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018a64:	3b01      	subs	r3, #1
 8018a66:	627b      	str	r3, [r7, #36]	@ 0x24
 8018a68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018a6a:	1c5a      	adds	r2, r3, #1
 8018a6c:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018a6e:	781b      	ldrb	r3, [r3, #0]
 8018a70:	61bb      	str	r3, [r7, #24]

  TRACEMS1(cinfo, 1, JTRC_SOS, n);
 8018a72:	687b      	ldr	r3, [r7, #4]
 8018a74:	681b      	ldr	r3, [r3, #0]
 8018a76:	2269      	movs	r2, #105	@ 0x69
 8018a78:	615a      	str	r2, [r3, #20]
 8018a7a:	687b      	ldr	r3, [r7, #4]
 8018a7c:	681b      	ldr	r3, [r3, #0]
 8018a7e:	69ba      	ldr	r2, [r7, #24]
 8018a80:	619a      	str	r2, [r3, #24]
 8018a82:	687b      	ldr	r3, [r7, #4]
 8018a84:	681b      	ldr	r3, [r3, #0]
 8018a86:	685b      	ldr	r3, [r3, #4]
 8018a88:	2101      	movs	r1, #1
 8018a8a:	6878      	ldr	r0, [r7, #4]
 8018a8c:	4798      	blx	r3

  if (length != (n * 2 + 6) || n > MAX_COMPS_IN_SCAN ||
 8018a8e:	69bb      	ldr	r3, [r7, #24]
 8018a90:	3303      	adds	r3, #3
 8018a92:	005b      	lsls	r3, r3, #1
 8018a94:	69fa      	ldr	r2, [r7, #28]
 8018a96:	429a      	cmp	r2, r3
 8018a98:	d10a      	bne.n	8018ab0 <get_sos+0x11a>
 8018a9a:	69bb      	ldr	r3, [r7, #24]
 8018a9c:	2b04      	cmp	r3, #4
 8018a9e:	dc07      	bgt.n	8018ab0 <get_sos+0x11a>
 8018aa0:	69bb      	ldr	r3, [r7, #24]
 8018aa2:	2b00      	cmp	r3, #0
 8018aa4:	d10d      	bne.n	8018ac2 <get_sos+0x12c>
      (n == 0 && !cinfo->progressive_mode))
 8018aa6:	687b      	ldr	r3, [r7, #4]
 8018aa8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8018aac:	2b00      	cmp	r3, #0
 8018aae:	d108      	bne.n	8018ac2 <get_sos+0x12c>
      /* pseudo SOS marker only allowed in progressive mode */
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8018ab0:	687b      	ldr	r3, [r7, #4]
 8018ab2:	681b      	ldr	r3, [r3, #0]
 8018ab4:	220c      	movs	r2, #12
 8018ab6:	615a      	str	r2, [r3, #20]
 8018ab8:	687b      	ldr	r3, [r7, #4]
 8018aba:	681b      	ldr	r3, [r3, #0]
 8018abc:	681b      	ldr	r3, [r3, #0]
 8018abe:	6878      	ldr	r0, [r7, #4]
 8018ac0:	4798      	blx	r3

  cinfo->comps_in_scan = n;
 8018ac2:	687b      	ldr	r3, [r7, #4]
 8018ac4:	69ba      	ldr	r2, [r7, #24]
 8018ac6:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
 8018aca:	2300      	movs	r3, #0
 8018acc:	637b      	str	r3, [r7, #52]	@ 0x34
 8018ace:	e089      	b.n	8018be4 <get_sos+0x24e>
    INPUT_BYTE(cinfo, cc, return FALSE);
 8018ad0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ad2:	2b00      	cmp	r3, #0
 8018ad4:	d10e      	bne.n	8018af4 <get_sos+0x15e>
 8018ad6:	6a3b      	ldr	r3, [r7, #32]
 8018ad8:	68db      	ldr	r3, [r3, #12]
 8018ada:	6878      	ldr	r0, [r7, #4]
 8018adc:	4798      	blx	r3
 8018ade:	4603      	mov	r3, r0
 8018ae0:	2b00      	cmp	r3, #0
 8018ae2:	d101      	bne.n	8018ae8 <get_sos+0x152>
 8018ae4:	2300      	movs	r3, #0
 8018ae6:	e120      	b.n	8018d2a <get_sos+0x394>
 8018ae8:	6a3b      	ldr	r3, [r7, #32]
 8018aea:	681b      	ldr	r3, [r3, #0]
 8018aec:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018aee:	6a3b      	ldr	r3, [r7, #32]
 8018af0:	685b      	ldr	r3, [r3, #4]
 8018af2:	627b      	str	r3, [r7, #36]	@ 0x24
 8018af4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018af6:	3b01      	subs	r3, #1
 8018af8:	627b      	str	r3, [r7, #36]	@ 0x24
 8018afa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018afc:	1c5a      	adds	r2, r3, #1
 8018afe:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018b00:	781b      	ldrb	r3, [r3, #0]
 8018b02:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, c, return FALSE);
 8018b04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b06:	2b00      	cmp	r3, #0
 8018b08:	d10e      	bne.n	8018b28 <get_sos+0x192>
 8018b0a:	6a3b      	ldr	r3, [r7, #32]
 8018b0c:	68db      	ldr	r3, [r3, #12]
 8018b0e:	6878      	ldr	r0, [r7, #4]
 8018b10:	4798      	blx	r3
 8018b12:	4603      	mov	r3, r0
 8018b14:	2b00      	cmp	r3, #0
 8018b16:	d101      	bne.n	8018b1c <get_sos+0x186>
 8018b18:	2300      	movs	r3, #0
 8018b1a:	e106      	b.n	8018d2a <get_sos+0x394>
 8018b1c:	6a3b      	ldr	r3, [r7, #32]
 8018b1e:	681b      	ldr	r3, [r3, #0]
 8018b20:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018b22:	6a3b      	ldr	r3, [r7, #32]
 8018b24:	685b      	ldr	r3, [r3, #4]
 8018b26:	627b      	str	r3, [r7, #36]	@ 0x24
 8018b28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b2a:	3b01      	subs	r3, #1
 8018b2c:	627b      	str	r3, [r7, #36]	@ 0x24
 8018b2e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018b30:	1c5a      	adds	r2, r3, #1
 8018b32:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018b34:	781b      	ldrb	r3, [r3, #0]
 8018b36:	617b      	str	r3, [r7, #20]
    
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8018b38:	2300      	movs	r3, #0
 8018b3a:	633b      	str	r3, [r7, #48]	@ 0x30
 8018b3c:	687b      	ldr	r3, [r7, #4]
 8018b3e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8018b42:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018b44:	e00a      	b.n	8018b5c <get_sos+0x1c6>
	 ci++, compptr++) {
      if (cc == compptr->component_id)
 8018b46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b48:	681b      	ldr	r3, [r3, #0]
 8018b4a:	68fa      	ldr	r2, [r7, #12]
 8018b4c:	429a      	cmp	r2, r3
 8018b4e:	d018      	beq.n	8018b82 <get_sos+0x1ec>
	 ci++, compptr++) {
 8018b50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018b52:	3301      	adds	r3, #1
 8018b54:	633b      	str	r3, [r7, #48]	@ 0x30
 8018b56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b58:	3358      	adds	r3, #88	@ 0x58
 8018b5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8018b5c:	687b      	ldr	r3, [r7, #4]
 8018b5e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018b60:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018b62:	429a      	cmp	r2, r3
 8018b64:	dbef      	blt.n	8018b46 <get_sos+0x1b0>
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
 8018b66:	687b      	ldr	r3, [r7, #4]
 8018b68:	681b      	ldr	r3, [r3, #0]
 8018b6a:	2204      	movs	r2, #4
 8018b6c:	615a      	str	r2, [r3, #20]
 8018b6e:	687b      	ldr	r3, [r7, #4]
 8018b70:	681b      	ldr	r3, [r3, #0]
 8018b72:	68fa      	ldr	r2, [r7, #12]
 8018b74:	619a      	str	r2, [r3, #24]
 8018b76:	687b      	ldr	r3, [r7, #4]
 8018b78:	681b      	ldr	r3, [r3, #0]
 8018b7a:	681b      	ldr	r3, [r3, #0]
 8018b7c:	6878      	ldr	r0, [r7, #4]
 8018b7e:	4798      	blx	r3
 8018b80:	e000      	b.n	8018b84 <get_sos+0x1ee>
	goto id_found;
 8018b82:	bf00      	nop

  id_found:

    cinfo->cur_comp_info[i] = compptr;
 8018b84:	687a      	ldr	r2, [r7, #4]
 8018b86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8018b88:	3354      	adds	r3, #84	@ 0x54
 8018b8a:	009b      	lsls	r3, r3, #2
 8018b8c:	4413      	add	r3, r2
 8018b8e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018b90:	605a      	str	r2, [r3, #4]
    compptr->dc_tbl_no = (c >> 4) & 15;
 8018b92:	697b      	ldr	r3, [r7, #20]
 8018b94:	111b      	asrs	r3, r3, #4
 8018b96:	f003 020f 	and.w	r2, r3, #15
 8018b9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b9c:	615a      	str	r2, [r3, #20]
    compptr->ac_tbl_no = (c     ) & 15;
 8018b9e:	697b      	ldr	r3, [r7, #20]
 8018ba0:	f003 020f 	and.w	r2, r3, #15
 8018ba4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018ba6:	619a      	str	r2, [r3, #24]
    
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
 8018ba8:	687b      	ldr	r3, [r7, #4]
 8018baa:	681b      	ldr	r3, [r3, #0]
 8018bac:	3318      	adds	r3, #24
 8018bae:	60bb      	str	r3, [r7, #8]
 8018bb0:	68bb      	ldr	r3, [r7, #8]
 8018bb2:	68fa      	ldr	r2, [r7, #12]
 8018bb4:	601a      	str	r2, [r3, #0]
 8018bb6:	68bb      	ldr	r3, [r7, #8]
 8018bb8:	3304      	adds	r3, #4
 8018bba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018bbc:	6952      	ldr	r2, [r2, #20]
 8018bbe:	601a      	str	r2, [r3, #0]
 8018bc0:	68bb      	ldr	r3, [r7, #8]
 8018bc2:	3308      	adds	r3, #8
 8018bc4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018bc6:	6992      	ldr	r2, [r2, #24]
 8018bc8:	601a      	str	r2, [r3, #0]
 8018bca:	687b      	ldr	r3, [r7, #4]
 8018bcc:	681b      	ldr	r3, [r3, #0]
 8018bce:	226a      	movs	r2, #106	@ 0x6a
 8018bd0:	615a      	str	r2, [r3, #20]
 8018bd2:	687b      	ldr	r3, [r7, #4]
 8018bd4:	681b      	ldr	r3, [r3, #0]
 8018bd6:	685b      	ldr	r3, [r3, #4]
 8018bd8:	2101      	movs	r1, #1
 8018bda:	6878      	ldr	r0, [r7, #4]
 8018bdc:	4798      	blx	r3
  for (i = 0; i < n; i++) {
 8018bde:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8018be0:	3301      	adds	r3, #1
 8018be2:	637b      	str	r3, [r7, #52]	@ 0x34
 8018be4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018be6:	69bb      	ldr	r3, [r7, #24]
 8018be8:	429a      	cmp	r2, r3
 8018bea:	f6ff af71 	blt.w	8018ad0 <get_sos+0x13a>
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
 8018bee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bf0:	2b00      	cmp	r3, #0
 8018bf2:	d10e      	bne.n	8018c12 <get_sos+0x27c>
 8018bf4:	6a3b      	ldr	r3, [r7, #32]
 8018bf6:	68db      	ldr	r3, [r3, #12]
 8018bf8:	6878      	ldr	r0, [r7, #4]
 8018bfa:	4798      	blx	r3
 8018bfc:	4603      	mov	r3, r0
 8018bfe:	2b00      	cmp	r3, #0
 8018c00:	d101      	bne.n	8018c06 <get_sos+0x270>
 8018c02:	2300      	movs	r3, #0
 8018c04:	e091      	b.n	8018d2a <get_sos+0x394>
 8018c06:	6a3b      	ldr	r3, [r7, #32]
 8018c08:	681b      	ldr	r3, [r3, #0]
 8018c0a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018c0c:	6a3b      	ldr	r3, [r7, #32]
 8018c0e:	685b      	ldr	r3, [r3, #4]
 8018c10:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c14:	3b01      	subs	r3, #1
 8018c16:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018c1a:	1c5a      	adds	r2, r3, #1
 8018c1c:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018c1e:	781b      	ldrb	r3, [r3, #0]
 8018c20:	617b      	str	r3, [r7, #20]
  cinfo->Ss = c;
 8018c22:	687b      	ldr	r3, [r7, #4]
 8018c24:	697a      	ldr	r2, [r7, #20]
 8018c26:	f8c3 2198 	str.w	r2, [r3, #408]	@ 0x198
  INPUT_BYTE(cinfo, c, return FALSE);
 8018c2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c2c:	2b00      	cmp	r3, #0
 8018c2e:	d10e      	bne.n	8018c4e <get_sos+0x2b8>
 8018c30:	6a3b      	ldr	r3, [r7, #32]
 8018c32:	68db      	ldr	r3, [r3, #12]
 8018c34:	6878      	ldr	r0, [r7, #4]
 8018c36:	4798      	blx	r3
 8018c38:	4603      	mov	r3, r0
 8018c3a:	2b00      	cmp	r3, #0
 8018c3c:	d101      	bne.n	8018c42 <get_sos+0x2ac>
 8018c3e:	2300      	movs	r3, #0
 8018c40:	e073      	b.n	8018d2a <get_sos+0x394>
 8018c42:	6a3b      	ldr	r3, [r7, #32]
 8018c44:	681b      	ldr	r3, [r3, #0]
 8018c46:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018c48:	6a3b      	ldr	r3, [r7, #32]
 8018c4a:	685b      	ldr	r3, [r3, #4]
 8018c4c:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c50:	3b01      	subs	r3, #1
 8018c52:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018c56:	1c5a      	adds	r2, r3, #1
 8018c58:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018c5a:	781b      	ldrb	r3, [r3, #0]
 8018c5c:	617b      	str	r3, [r7, #20]
  cinfo->Se = c;
 8018c5e:	687b      	ldr	r3, [r7, #4]
 8018c60:	697a      	ldr	r2, [r7, #20]
 8018c62:	f8c3 219c 	str.w	r2, [r3, #412]	@ 0x19c
  INPUT_BYTE(cinfo, c, return FALSE);
 8018c66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c68:	2b00      	cmp	r3, #0
 8018c6a:	d10e      	bne.n	8018c8a <get_sos+0x2f4>
 8018c6c:	6a3b      	ldr	r3, [r7, #32]
 8018c6e:	68db      	ldr	r3, [r3, #12]
 8018c70:	6878      	ldr	r0, [r7, #4]
 8018c72:	4798      	blx	r3
 8018c74:	4603      	mov	r3, r0
 8018c76:	2b00      	cmp	r3, #0
 8018c78:	d101      	bne.n	8018c7e <get_sos+0x2e8>
 8018c7a:	2300      	movs	r3, #0
 8018c7c:	e055      	b.n	8018d2a <get_sos+0x394>
 8018c7e:	6a3b      	ldr	r3, [r7, #32]
 8018c80:	681b      	ldr	r3, [r3, #0]
 8018c82:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018c84:	6a3b      	ldr	r3, [r7, #32]
 8018c86:	685b      	ldr	r3, [r3, #4]
 8018c88:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c8c:	3b01      	subs	r3, #1
 8018c8e:	627b      	str	r3, [r7, #36]	@ 0x24
 8018c90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018c92:	1c5a      	adds	r2, r3, #1
 8018c94:	62ba      	str	r2, [r7, #40]	@ 0x28
 8018c96:	781b      	ldrb	r3, [r3, #0]
 8018c98:	617b      	str	r3, [r7, #20]
  cinfo->Ah = (c >> 4) & 15;
 8018c9a:	697b      	ldr	r3, [r7, #20]
 8018c9c:	111b      	asrs	r3, r3, #4
 8018c9e:	f003 020f 	and.w	r2, r3, #15
 8018ca2:	687b      	ldr	r3, [r7, #4]
 8018ca4:	f8c3 21a0 	str.w	r2, [r3, #416]	@ 0x1a0
  cinfo->Al = (c     ) & 15;
 8018ca8:	697b      	ldr	r3, [r7, #20]
 8018caa:	f003 020f 	and.w	r2, r3, #15
 8018cae:	687b      	ldr	r3, [r7, #4]
 8018cb0:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
 8018cb4:	687b      	ldr	r3, [r7, #4]
 8018cb6:	681b      	ldr	r3, [r3, #0]
 8018cb8:	3318      	adds	r3, #24
 8018cba:	613b      	str	r3, [r7, #16]
 8018cbc:	687b      	ldr	r3, [r7, #4]
 8018cbe:	f8d3 2198 	ldr.w	r2, [r3, #408]	@ 0x198
 8018cc2:	693b      	ldr	r3, [r7, #16]
 8018cc4:	601a      	str	r2, [r3, #0]
 8018cc6:	693b      	ldr	r3, [r7, #16]
 8018cc8:	3304      	adds	r3, #4
 8018cca:	687a      	ldr	r2, [r7, #4]
 8018ccc:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 8018cd0:	601a      	str	r2, [r3, #0]
 8018cd2:	693b      	ldr	r3, [r7, #16]
 8018cd4:	3308      	adds	r3, #8
 8018cd6:	687a      	ldr	r2, [r7, #4]
 8018cd8:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 8018cdc:	601a      	str	r2, [r3, #0]
 8018cde:	693b      	ldr	r3, [r7, #16]
 8018ce0:	330c      	adds	r3, #12
 8018ce2:	687a      	ldr	r2, [r7, #4]
 8018ce4:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 8018ce8:	601a      	str	r2, [r3, #0]
 8018cea:	687b      	ldr	r3, [r7, #4]
 8018cec:	681b      	ldr	r3, [r3, #0]
 8018cee:	226b      	movs	r2, #107	@ 0x6b
 8018cf0:	615a      	str	r2, [r3, #20]
 8018cf2:	687b      	ldr	r3, [r7, #4]
 8018cf4:	681b      	ldr	r3, [r3, #0]
 8018cf6:	685b      	ldr	r3, [r3, #4]
 8018cf8:	2101      	movs	r1, #1
 8018cfa:	6878      	ldr	r0, [r7, #4]
 8018cfc:	4798      	blx	r3
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;
 8018cfe:	687b      	ldr	r3, [r7, #4]
 8018d00:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8018d04:	2200      	movs	r2, #0
 8018d06:	615a      	str	r2, [r3, #20]

  /* Count another (non-pseudo) SOS marker */
  if (n) cinfo->input_scan_number++;
 8018d08:	69bb      	ldr	r3, [r7, #24]
 8018d0a:	2b00      	cmp	r3, #0
 8018d0c:	d006      	beq.n	8018d1c <get_sos+0x386>
 8018d0e:	687b      	ldr	r3, [r7, #4]
 8018d10:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8018d14:	1c5a      	adds	r2, r3, #1
 8018d16:	687b      	ldr	r3, [r7, #4]
 8018d18:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  INPUT_SYNC(cinfo);
 8018d1c:	6a3b      	ldr	r3, [r7, #32]
 8018d1e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018d20:	601a      	str	r2, [r3, #0]
 8018d22:	6a3b      	ldr	r3, [r7, #32]
 8018d24:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018d26:	605a      	str	r2, [r3, #4]
  return TRUE;
 8018d28:	2301      	movs	r3, #1
}
 8018d2a:	4618      	mov	r0, r3
 8018d2c:	3738      	adds	r7, #56	@ 0x38
 8018d2e:	46bd      	mov	sp, r7
 8018d30:	bd80      	pop	{r7, pc}

08018d32 <get_dac>:
#ifdef D_ARITH_CODING_SUPPORTED

LOCAL(boolean)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
 8018d32:	b580      	push	{r7, lr}
 8018d34:	b088      	sub	sp, #32
 8018d36:	af00      	add	r7, sp, #0
 8018d38:	6078      	str	r0, [r7, #4]
  INT32 length;
  int index, val;
  INPUT_VARS(cinfo);
 8018d3a:	687b      	ldr	r3, [r7, #4]
 8018d3c:	699b      	ldr	r3, [r3, #24]
 8018d3e:	613b      	str	r3, [r7, #16]
 8018d40:	693b      	ldr	r3, [r7, #16]
 8018d42:	681b      	ldr	r3, [r3, #0]
 8018d44:	61bb      	str	r3, [r7, #24]
 8018d46:	693b      	ldr	r3, [r7, #16]
 8018d48:	685b      	ldr	r3, [r3, #4]
 8018d4a:	617b      	str	r3, [r7, #20]

  INPUT_2BYTES(cinfo, length, return FALSE);
 8018d4c:	697b      	ldr	r3, [r7, #20]
 8018d4e:	2b00      	cmp	r3, #0
 8018d50:	d10e      	bne.n	8018d70 <get_dac+0x3e>
 8018d52:	693b      	ldr	r3, [r7, #16]
 8018d54:	68db      	ldr	r3, [r3, #12]
 8018d56:	6878      	ldr	r0, [r7, #4]
 8018d58:	4798      	blx	r3
 8018d5a:	4603      	mov	r3, r0
 8018d5c:	2b00      	cmp	r3, #0
 8018d5e:	d101      	bne.n	8018d64 <get_dac+0x32>
 8018d60:	2300      	movs	r3, #0
 8018d62:	e0dc      	b.n	8018f1e <get_dac+0x1ec>
 8018d64:	693b      	ldr	r3, [r7, #16]
 8018d66:	681b      	ldr	r3, [r3, #0]
 8018d68:	61bb      	str	r3, [r7, #24]
 8018d6a:	693b      	ldr	r3, [r7, #16]
 8018d6c:	685b      	ldr	r3, [r3, #4]
 8018d6e:	617b      	str	r3, [r7, #20]
 8018d70:	697b      	ldr	r3, [r7, #20]
 8018d72:	3b01      	subs	r3, #1
 8018d74:	617b      	str	r3, [r7, #20]
 8018d76:	69bb      	ldr	r3, [r7, #24]
 8018d78:	1c5a      	adds	r2, r3, #1
 8018d7a:	61ba      	str	r2, [r7, #24]
 8018d7c:	781b      	ldrb	r3, [r3, #0]
 8018d7e:	021b      	lsls	r3, r3, #8
 8018d80:	61fb      	str	r3, [r7, #28]
 8018d82:	697b      	ldr	r3, [r7, #20]
 8018d84:	2b00      	cmp	r3, #0
 8018d86:	d10e      	bne.n	8018da6 <get_dac+0x74>
 8018d88:	693b      	ldr	r3, [r7, #16]
 8018d8a:	68db      	ldr	r3, [r3, #12]
 8018d8c:	6878      	ldr	r0, [r7, #4]
 8018d8e:	4798      	blx	r3
 8018d90:	4603      	mov	r3, r0
 8018d92:	2b00      	cmp	r3, #0
 8018d94:	d101      	bne.n	8018d9a <get_dac+0x68>
 8018d96:	2300      	movs	r3, #0
 8018d98:	e0c1      	b.n	8018f1e <get_dac+0x1ec>
 8018d9a:	693b      	ldr	r3, [r7, #16]
 8018d9c:	681b      	ldr	r3, [r3, #0]
 8018d9e:	61bb      	str	r3, [r7, #24]
 8018da0:	693b      	ldr	r3, [r7, #16]
 8018da2:	685b      	ldr	r3, [r3, #4]
 8018da4:	617b      	str	r3, [r7, #20]
 8018da6:	697b      	ldr	r3, [r7, #20]
 8018da8:	3b01      	subs	r3, #1
 8018daa:	617b      	str	r3, [r7, #20]
 8018dac:	69bb      	ldr	r3, [r7, #24]
 8018dae:	1c5a      	adds	r2, r3, #1
 8018db0:	61ba      	str	r2, [r7, #24]
 8018db2:	781b      	ldrb	r3, [r3, #0]
 8018db4:	461a      	mov	r2, r3
 8018db6:	69fb      	ldr	r3, [r7, #28]
 8018db8:	4413      	add	r3, r2
 8018dba:	61fb      	str	r3, [r7, #28]
  length -= 2;
 8018dbc:	69fb      	ldr	r3, [r7, #28]
 8018dbe:	3b02      	subs	r3, #2
 8018dc0:	61fb      	str	r3, [r7, #28]
  
  while (length > 0) {
 8018dc2:	e095      	b.n	8018ef0 <get_dac+0x1be>
    INPUT_BYTE(cinfo, index, return FALSE);
 8018dc4:	697b      	ldr	r3, [r7, #20]
 8018dc6:	2b00      	cmp	r3, #0
 8018dc8:	d10e      	bne.n	8018de8 <get_dac+0xb6>
 8018dca:	693b      	ldr	r3, [r7, #16]
 8018dcc:	68db      	ldr	r3, [r3, #12]
 8018dce:	6878      	ldr	r0, [r7, #4]
 8018dd0:	4798      	blx	r3
 8018dd2:	4603      	mov	r3, r0
 8018dd4:	2b00      	cmp	r3, #0
 8018dd6:	d101      	bne.n	8018ddc <get_dac+0xaa>
 8018dd8:	2300      	movs	r3, #0
 8018dda:	e0a0      	b.n	8018f1e <get_dac+0x1ec>
 8018ddc:	693b      	ldr	r3, [r7, #16]
 8018dde:	681b      	ldr	r3, [r3, #0]
 8018de0:	61bb      	str	r3, [r7, #24]
 8018de2:	693b      	ldr	r3, [r7, #16]
 8018de4:	685b      	ldr	r3, [r3, #4]
 8018de6:	617b      	str	r3, [r7, #20]
 8018de8:	697b      	ldr	r3, [r7, #20]
 8018dea:	3b01      	subs	r3, #1
 8018dec:	617b      	str	r3, [r7, #20]
 8018dee:	69bb      	ldr	r3, [r7, #24]
 8018df0:	1c5a      	adds	r2, r3, #1
 8018df2:	61ba      	str	r2, [r7, #24]
 8018df4:	781b      	ldrb	r3, [r3, #0]
 8018df6:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, val, return FALSE);
 8018df8:	697b      	ldr	r3, [r7, #20]
 8018dfa:	2b00      	cmp	r3, #0
 8018dfc:	d10e      	bne.n	8018e1c <get_dac+0xea>
 8018dfe:	693b      	ldr	r3, [r7, #16]
 8018e00:	68db      	ldr	r3, [r3, #12]
 8018e02:	6878      	ldr	r0, [r7, #4]
 8018e04:	4798      	blx	r3
 8018e06:	4603      	mov	r3, r0
 8018e08:	2b00      	cmp	r3, #0
 8018e0a:	d101      	bne.n	8018e10 <get_dac+0xde>
 8018e0c:	2300      	movs	r3, #0
 8018e0e:	e086      	b.n	8018f1e <get_dac+0x1ec>
 8018e10:	693b      	ldr	r3, [r7, #16]
 8018e12:	681b      	ldr	r3, [r3, #0]
 8018e14:	61bb      	str	r3, [r7, #24]
 8018e16:	693b      	ldr	r3, [r7, #16]
 8018e18:	685b      	ldr	r3, [r3, #4]
 8018e1a:	617b      	str	r3, [r7, #20]
 8018e1c:	697b      	ldr	r3, [r7, #20]
 8018e1e:	3b01      	subs	r3, #1
 8018e20:	617b      	str	r3, [r7, #20]
 8018e22:	69bb      	ldr	r3, [r7, #24]
 8018e24:	1c5a      	adds	r2, r3, #1
 8018e26:	61ba      	str	r2, [r7, #24]
 8018e28:	781b      	ldrb	r3, [r3, #0]
 8018e2a:	60bb      	str	r3, [r7, #8]

    length -= 2;
 8018e2c:	69fb      	ldr	r3, [r7, #28]
 8018e2e:	3b02      	subs	r3, #2
 8018e30:	61fb      	str	r3, [r7, #28]

    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);
 8018e32:	687b      	ldr	r3, [r7, #4]
 8018e34:	681b      	ldr	r3, [r3, #0]
 8018e36:	2251      	movs	r2, #81	@ 0x51
 8018e38:	615a      	str	r2, [r3, #20]
 8018e3a:	687b      	ldr	r3, [r7, #4]
 8018e3c:	681b      	ldr	r3, [r3, #0]
 8018e3e:	68fa      	ldr	r2, [r7, #12]
 8018e40:	619a      	str	r2, [r3, #24]
 8018e42:	687b      	ldr	r3, [r7, #4]
 8018e44:	681b      	ldr	r3, [r3, #0]
 8018e46:	68ba      	ldr	r2, [r7, #8]
 8018e48:	61da      	str	r2, [r3, #28]
 8018e4a:	687b      	ldr	r3, [r7, #4]
 8018e4c:	681b      	ldr	r3, [r3, #0]
 8018e4e:	685b      	ldr	r3, [r3, #4]
 8018e50:	2101      	movs	r1, #1
 8018e52:	6878      	ldr	r0, [r7, #4]
 8018e54:	4798      	blx	r3

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
 8018e56:	68fb      	ldr	r3, [r7, #12]
 8018e58:	2b00      	cmp	r3, #0
 8018e5a:	db02      	blt.n	8018e62 <get_dac+0x130>
 8018e5c:	68fb      	ldr	r3, [r7, #12]
 8018e5e:	2b1f      	cmp	r3, #31
 8018e60:	dd0c      	ble.n	8018e7c <get_dac+0x14a>
      ERREXIT1(cinfo, JERR_DAC_INDEX, index);
 8018e62:	687b      	ldr	r3, [r7, #4]
 8018e64:	681b      	ldr	r3, [r3, #0]
 8018e66:	221d      	movs	r2, #29
 8018e68:	615a      	str	r2, [r3, #20]
 8018e6a:	687b      	ldr	r3, [r7, #4]
 8018e6c:	681b      	ldr	r3, [r3, #0]
 8018e6e:	68fa      	ldr	r2, [r7, #12]
 8018e70:	619a      	str	r2, [r3, #24]
 8018e72:	687b      	ldr	r3, [r7, #4]
 8018e74:	681b      	ldr	r3, [r3, #0]
 8018e76:	681b      	ldr	r3, [r3, #0]
 8018e78:	6878      	ldr	r0, [r7, #4]
 8018e7a:	4798      	blx	r3

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
 8018e7c:	68fb      	ldr	r3, [r7, #12]
 8018e7e:	2b0f      	cmp	r3, #15
 8018e80:	dd09      	ble.n	8018e96 <get_dac+0x164>
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
 8018e82:	68fb      	ldr	r3, [r7, #12]
 8018e84:	3b10      	subs	r3, #16
 8018e86:	68ba      	ldr	r2, [r7, #8]
 8018e88:	b2d1      	uxtb	r1, r2
 8018e8a:	687a      	ldr	r2, [r7, #4]
 8018e8c:	4413      	add	r3, r2
 8018e8e:	460a      	mov	r2, r1
 8018e90:	f883 2108 	strb.w	r2, [r3, #264]	@ 0x108
 8018e94:	e02c      	b.n	8018ef0 <get_dac+0x1be>
    } else {			/* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
 8018e96:	68bb      	ldr	r3, [r7, #8]
 8018e98:	b2db      	uxtb	r3, r3
 8018e9a:	f003 030f 	and.w	r3, r3, #15
 8018e9e:	b2d9      	uxtb	r1, r3
 8018ea0:	687a      	ldr	r2, [r7, #4]
 8018ea2:	68fb      	ldr	r3, [r7, #12]
 8018ea4:	4413      	add	r3, r2
 8018ea6:	33e8      	adds	r3, #232	@ 0xe8
 8018ea8:	460a      	mov	r2, r1
 8018eaa:	701a      	strb	r2, [r3, #0]
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
 8018eac:	68bb      	ldr	r3, [r7, #8]
 8018eae:	111b      	asrs	r3, r3, #4
 8018eb0:	b2d9      	uxtb	r1, r3
 8018eb2:	687a      	ldr	r2, [r7, #4]
 8018eb4:	68fb      	ldr	r3, [r7, #12]
 8018eb6:	4413      	add	r3, r2
 8018eb8:	33f8      	adds	r3, #248	@ 0xf8
 8018eba:	460a      	mov	r2, r1
 8018ebc:	701a      	strb	r2, [r3, #0]
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
 8018ebe:	687a      	ldr	r2, [r7, #4]
 8018ec0:	68fb      	ldr	r3, [r7, #12]
 8018ec2:	4413      	add	r3, r2
 8018ec4:	33e8      	adds	r3, #232	@ 0xe8
 8018ec6:	781a      	ldrb	r2, [r3, #0]
 8018ec8:	6879      	ldr	r1, [r7, #4]
 8018eca:	68fb      	ldr	r3, [r7, #12]
 8018ecc:	440b      	add	r3, r1
 8018ece:	33f8      	adds	r3, #248	@ 0xf8
 8018ed0:	781b      	ldrb	r3, [r3, #0]
 8018ed2:	429a      	cmp	r2, r3
 8018ed4:	d90c      	bls.n	8018ef0 <get_dac+0x1be>
	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
 8018ed6:	687b      	ldr	r3, [r7, #4]
 8018ed8:	681b      	ldr	r3, [r3, #0]
 8018eda:	221e      	movs	r2, #30
 8018edc:	615a      	str	r2, [r3, #20]
 8018ede:	687b      	ldr	r3, [r7, #4]
 8018ee0:	681b      	ldr	r3, [r3, #0]
 8018ee2:	68ba      	ldr	r2, [r7, #8]
 8018ee4:	619a      	str	r2, [r3, #24]
 8018ee6:	687b      	ldr	r3, [r7, #4]
 8018ee8:	681b      	ldr	r3, [r3, #0]
 8018eea:	681b      	ldr	r3, [r3, #0]
 8018eec:	6878      	ldr	r0, [r7, #4]
 8018eee:	4798      	blx	r3
  while (length > 0) {
 8018ef0:	69fb      	ldr	r3, [r7, #28]
 8018ef2:	2b00      	cmp	r3, #0
 8018ef4:	f73f af66 	bgt.w	8018dc4 <get_dac+0x92>
    }
  }

  if (length != 0)
 8018ef8:	69fb      	ldr	r3, [r7, #28]
 8018efa:	2b00      	cmp	r3, #0
 8018efc:	d008      	beq.n	8018f10 <get_dac+0x1de>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8018efe:	687b      	ldr	r3, [r7, #4]
 8018f00:	681b      	ldr	r3, [r3, #0]
 8018f02:	220c      	movs	r2, #12
 8018f04:	615a      	str	r2, [r3, #20]
 8018f06:	687b      	ldr	r3, [r7, #4]
 8018f08:	681b      	ldr	r3, [r3, #0]
 8018f0a:	681b      	ldr	r3, [r3, #0]
 8018f0c:	6878      	ldr	r0, [r7, #4]
 8018f0e:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 8018f10:	693b      	ldr	r3, [r7, #16]
 8018f12:	69ba      	ldr	r2, [r7, #24]
 8018f14:	601a      	str	r2, [r3, #0]
 8018f16:	693b      	ldr	r3, [r7, #16]
 8018f18:	697a      	ldr	r2, [r7, #20]
 8018f1a:	605a      	str	r2, [r3, #4]
  return TRUE;
 8018f1c:	2301      	movs	r3, #1
}
 8018f1e:	4618      	mov	r0, r3
 8018f20:	3720      	adds	r7, #32
 8018f22:	46bd      	mov	sp, r7
 8018f24:	bd80      	pop	{r7, pc}

08018f26 <get_dht>:


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
 8018f26:	b5b0      	push	{r4, r5, r7, lr}
 8018f28:	b0d2      	sub	sp, #328	@ 0x148
 8018f2a:	af00      	add	r7, sp, #0
 8018f2c:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8018f30:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8018f34:	6018      	str	r0, [r3, #0]
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);
 8018f36:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8018f3a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8018f3e:	681b      	ldr	r3, [r3, #0]
 8018f40:	699b      	ldr	r3, [r3, #24]
 8018f42:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 8018f46:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018f4a:	681b      	ldr	r3, [r3, #0]
 8018f4c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8018f50:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018f54:	685b      	ldr	r3, [r3, #4]
 8018f56:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

  INPUT_2BYTES(cinfo, length, return FALSE);
 8018f5a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8018f5e:	2b00      	cmp	r3, #0
 8018f60:	d117      	bne.n	8018f92 <get_dht+0x6c>
 8018f62:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018f66:	68db      	ldr	r3, [r3, #12]
 8018f68:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 8018f6c:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 8018f70:	6810      	ldr	r0, [r2, #0]
 8018f72:	4798      	blx	r3
 8018f74:	4603      	mov	r3, r0
 8018f76:	2b00      	cmp	r3, #0
 8018f78:	d101      	bne.n	8018f7e <get_dht+0x58>
 8018f7a:	2300      	movs	r3, #0
 8018f7c:	e28a      	b.n	8019494 <get_dht+0x56e>
 8018f7e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018f82:	681b      	ldr	r3, [r3, #0]
 8018f84:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8018f88:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018f8c:	685b      	ldr	r3, [r3, #4]
 8018f8e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8018f92:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8018f96:	3b01      	subs	r3, #1
 8018f98:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8018f9c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8018fa0:	1c5a      	adds	r2, r3, #1
 8018fa2:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 8018fa6:	781b      	ldrb	r3, [r3, #0]
 8018fa8:	021b      	lsls	r3, r3, #8
 8018faa:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 8018fae:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8018fb2:	2b00      	cmp	r3, #0
 8018fb4:	d117      	bne.n	8018fe6 <get_dht+0xc0>
 8018fb6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018fba:	68db      	ldr	r3, [r3, #12]
 8018fbc:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 8018fc0:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 8018fc4:	6810      	ldr	r0, [r2, #0]
 8018fc6:	4798      	blx	r3
 8018fc8:	4603      	mov	r3, r0
 8018fca:	2b00      	cmp	r3, #0
 8018fcc:	d101      	bne.n	8018fd2 <get_dht+0xac>
 8018fce:	2300      	movs	r3, #0
 8018fd0:	e260      	b.n	8019494 <get_dht+0x56e>
 8018fd2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018fd6:	681b      	ldr	r3, [r3, #0]
 8018fd8:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8018fdc:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8018fe0:	685b      	ldr	r3, [r3, #4]
 8018fe2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8018fe6:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8018fea:	3b01      	subs	r3, #1
 8018fec:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8018ff0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8018ff4:	1c5a      	adds	r2, r3, #1
 8018ff6:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 8018ffa:	781b      	ldrb	r3, [r3, #0]
 8018ffc:	461a      	mov	r2, r3
 8018ffe:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8019002:	4413      	add	r3, r2
 8019004:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  length -= 2;
 8019008:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801900c:	3b02      	subs	r3, #2
 801900e:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  
  while (length > 16) {
 8019012:	e216      	b.n	8019442 <get_dht+0x51c>
    INPUT_BYTE(cinfo, index, return FALSE);
 8019014:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8019018:	2b00      	cmp	r3, #0
 801901a:	d117      	bne.n	801904c <get_dht+0x126>
 801901c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8019020:	68db      	ldr	r3, [r3, #12]
 8019022:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 8019026:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801902a:	6810      	ldr	r0, [r2, #0]
 801902c:	4798      	blx	r3
 801902e:	4603      	mov	r3, r0
 8019030:	2b00      	cmp	r3, #0
 8019032:	d101      	bne.n	8019038 <get_dht+0x112>
 8019034:	2300      	movs	r3, #0
 8019036:	e22d      	b.n	8019494 <get_dht+0x56e>
 8019038:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801903c:	681b      	ldr	r3, [r3, #0]
 801903e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 8019042:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8019046:	685b      	ldr	r3, [r3, #4]
 8019048:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801904c:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8019050:	3b01      	subs	r3, #1
 8019052:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8019056:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801905a:	1c5a      	adds	r2, r3, #1
 801905c:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 8019060:	781b      	ldrb	r3, [r3, #0]
 8019062:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
 8019066:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801906a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801906e:	681b      	ldr	r3, [r3, #0]
 8019070:	681b      	ldr	r3, [r3, #0]
 8019072:	2252      	movs	r2, #82	@ 0x52
 8019074:	615a      	str	r2, [r3, #20]
 8019076:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801907a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801907e:	681b      	ldr	r3, [r3, #0]
 8019080:	681b      	ldr	r3, [r3, #0]
 8019082:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8019086:	619a      	str	r2, [r3, #24]
 8019088:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801908c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8019090:	681b      	ldr	r3, [r3, #0]
 8019092:	681b      	ldr	r3, [r3, #0]
 8019094:	685b      	ldr	r3, [r3, #4]
 8019096:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801909a:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801909e:	2101      	movs	r1, #1
 80190a0:	6810      	ldr	r0, [r2, #0]
 80190a2:	4798      	blx	r3
      
    bits[0] = 0;
 80190a4:	2300      	movs	r3, #0
 80190a6:	f887 310c 	strb.w	r3, [r7, #268]	@ 0x10c
    count = 0;
 80190aa:	2300      	movs	r3, #0
 80190ac:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    for (i = 1; i <= 16; i++) {
 80190b0:	2301      	movs	r3, #1
 80190b2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 80190b6:	e03e      	b.n	8019136 <get_dht+0x210>
      INPUT_BYTE(cinfo, bits[i], return FALSE);
 80190b8:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80190bc:	2b00      	cmp	r3, #0
 80190be:	d117      	bne.n	80190f0 <get_dht+0x1ca>
 80190c0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80190c4:	68db      	ldr	r3, [r3, #12]
 80190c6:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 80190ca:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 80190ce:	6810      	ldr	r0, [r2, #0]
 80190d0:	4798      	blx	r3
 80190d2:	4603      	mov	r3, r0
 80190d4:	2b00      	cmp	r3, #0
 80190d6:	d101      	bne.n	80190dc <get_dht+0x1b6>
 80190d8:	2300      	movs	r3, #0
 80190da:	e1db      	b.n	8019494 <get_dht+0x56e>
 80190dc:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80190e0:	681b      	ldr	r3, [r3, #0]
 80190e2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 80190e6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80190ea:	685b      	ldr	r3, [r3, #4]
 80190ec:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 80190f0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80190f4:	3b01      	subs	r3, #1
 80190f6:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 80190fa:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80190fe:	1c5a      	adds	r2, r3, #1
 8019100:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 8019104:	7819      	ldrb	r1, [r3, #0]
 8019106:	f507 7286 	add.w	r2, r7, #268	@ 0x10c
 801910a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801910e:	4413      	add	r3, r2
 8019110:	460a      	mov	r2, r1
 8019112:	701a      	strb	r2, [r3, #0]
      count += bits[i];
 8019114:	f507 7286 	add.w	r2, r7, #268	@ 0x10c
 8019118:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801911c:	4413      	add	r3, r2
 801911e:	781b      	ldrb	r3, [r3, #0]
 8019120:	461a      	mov	r2, r3
 8019122:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8019126:	4413      	add	r3, r2
 8019128:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    for (i = 1; i <= 16; i++) {
 801912c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8019130:	3301      	adds	r3, #1
 8019132:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8019136:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801913a:	2b10      	cmp	r3, #16
 801913c:	ddbc      	ble.n	80190b8 <get_dht+0x192>
    }

    length -= 1 + 16;
 801913e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8019142:	3b11      	subs	r3, #17
 8019144:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 8019148:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801914c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8019150:	681b      	ldr	r3, [r3, #0]
 8019152:	681b      	ldr	r3, [r3, #0]
 8019154:	3318      	adds	r3, #24
 8019156:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 801915a:	f897 310d 	ldrb.w	r3, [r7, #269]	@ 0x10d
 801915e:	461a      	mov	r2, r3
 8019160:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8019164:	601a      	str	r2, [r3, #0]
 8019166:	f897 210e 	ldrb.w	r2, [r7, #270]	@ 0x10e
 801916a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801916e:	3304      	adds	r3, #4
 8019170:	601a      	str	r2, [r3, #0]
 8019172:	f897 210f 	ldrb.w	r2, [r7, #271]	@ 0x10f
 8019176:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801917a:	3308      	adds	r3, #8
 801917c:	601a      	str	r2, [r3, #0]
 801917e:	f897 2110 	ldrb.w	r2, [r7, #272]	@ 0x110
 8019182:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8019186:	330c      	adds	r3, #12
 8019188:	601a      	str	r2, [r3, #0]
 801918a:	f897 2111 	ldrb.w	r2, [r7, #273]	@ 0x111
 801918e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8019192:	3310      	adds	r3, #16
 8019194:	601a      	str	r2, [r3, #0]
 8019196:	f897 2112 	ldrb.w	r2, [r7, #274]	@ 0x112
 801919a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801919e:	3314      	adds	r3, #20
 80191a0:	601a      	str	r2, [r3, #0]
 80191a2:	f897 2113 	ldrb.w	r2, [r7, #275]	@ 0x113
 80191a6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80191aa:	3318      	adds	r3, #24
 80191ac:	601a      	str	r2, [r3, #0]
 80191ae:	f897 2114 	ldrb.w	r2, [r7, #276]	@ 0x114
 80191b2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80191b6:	331c      	adds	r3, #28
 80191b8:	601a      	str	r2, [r3, #0]
 80191ba:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80191be:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80191c2:	681b      	ldr	r3, [r3, #0]
 80191c4:	681b      	ldr	r3, [r3, #0]
 80191c6:	2258      	movs	r2, #88	@ 0x58
 80191c8:	615a      	str	r2, [r3, #20]
 80191ca:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80191ce:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80191d2:	681b      	ldr	r3, [r3, #0]
 80191d4:	681b      	ldr	r3, [r3, #0]
 80191d6:	685b      	ldr	r3, [r3, #4]
 80191d8:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 80191dc:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 80191e0:	2102      	movs	r1, #2
 80191e2:	6810      	ldr	r0, [r2, #0]
 80191e4:	4798      	blx	r3
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 80191e6:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80191ea:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80191ee:	681b      	ldr	r3, [r3, #0]
 80191f0:	681b      	ldr	r3, [r3, #0]
 80191f2:	3318      	adds	r3, #24
 80191f4:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 80191f8:	f897 3115 	ldrb.w	r3, [r7, #277]	@ 0x115
 80191fc:	461a      	mov	r2, r3
 80191fe:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019202:	601a      	str	r2, [r3, #0]
 8019204:	f897 2116 	ldrb.w	r2, [r7, #278]	@ 0x116
 8019208:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801920c:	3304      	adds	r3, #4
 801920e:	601a      	str	r2, [r3, #0]
 8019210:	f897 2117 	ldrb.w	r2, [r7, #279]	@ 0x117
 8019214:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019218:	3308      	adds	r3, #8
 801921a:	601a      	str	r2, [r3, #0]
 801921c:	f897 2118 	ldrb.w	r2, [r7, #280]	@ 0x118
 8019220:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019224:	330c      	adds	r3, #12
 8019226:	601a      	str	r2, [r3, #0]
 8019228:	f897 2119 	ldrb.w	r2, [r7, #281]	@ 0x119
 801922c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019230:	3310      	adds	r3, #16
 8019232:	601a      	str	r2, [r3, #0]
 8019234:	f897 211a 	ldrb.w	r2, [r7, #282]	@ 0x11a
 8019238:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801923c:	3314      	adds	r3, #20
 801923e:	601a      	str	r2, [r3, #0]
 8019240:	f897 211b 	ldrb.w	r2, [r7, #283]	@ 0x11b
 8019244:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019248:	3318      	adds	r3, #24
 801924a:	601a      	str	r2, [r3, #0]
 801924c:	f897 211c 	ldrb.w	r2, [r7, #284]	@ 0x11c
 8019250:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8019254:	331c      	adds	r3, #28
 8019256:	601a      	str	r2, [r3, #0]
 8019258:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801925c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8019260:	681b      	ldr	r3, [r3, #0]
 8019262:	681b      	ldr	r3, [r3, #0]
 8019264:	2258      	movs	r2, #88	@ 0x58
 8019266:	615a      	str	r2, [r3, #20]
 8019268:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801926c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8019270:	681b      	ldr	r3, [r3, #0]
 8019272:	681b      	ldr	r3, [r3, #0]
 8019274:	685b      	ldr	r3, [r3, #4]
 8019276:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801927a:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801927e:	2102      	movs	r1, #2
 8019280:	6810      	ldr	r0, [r2, #0]
 8019282:	4798      	blx	r3
	     bits[13], bits[14], bits[15], bits[16]);

    /* Here we just do minimal validation of the counts to avoid walking
     * off the end of our table space.  jdhuff.c will check more carefully.
     */
    if (count > 256 || ((INT32) count) > length)
 8019284:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8019288:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801928c:	dc05      	bgt.n	801929a <get_dht+0x374>
 801928e:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8019292:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8019296:	429a      	cmp	r2, r3
 8019298:	dd14      	ble.n	80192c4 <get_dht+0x39e>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 801929a:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801929e:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80192a2:	681b      	ldr	r3, [r3, #0]
 80192a4:	681b      	ldr	r3, [r3, #0]
 80192a6:	2209      	movs	r2, #9
 80192a8:	615a      	str	r2, [r3, #20]
 80192aa:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80192ae:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80192b2:	681b      	ldr	r3, [r3, #0]
 80192b4:	681b      	ldr	r3, [r3, #0]
 80192b6:	681b      	ldr	r3, [r3, #0]
 80192b8:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 80192bc:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 80192c0:	6810      	ldr	r0, [r2, #0]
 80192c2:	4798      	blx	r3

    for (i = 0; i < count; i++)
 80192c4:	2300      	movs	r3, #0
 80192c6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 80192ca:	e034      	b.n	8019336 <get_dht+0x410>
      INPUT_BYTE(cinfo, huffval[i], return FALSE);
 80192cc:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80192d0:	2b00      	cmp	r3, #0
 80192d2:	d117      	bne.n	8019304 <get_dht+0x3de>
 80192d4:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80192d8:	68db      	ldr	r3, [r3, #12]
 80192da:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 80192de:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 80192e2:	6810      	ldr	r0, [r2, #0]
 80192e4:	4798      	blx	r3
 80192e6:	4603      	mov	r3, r0
 80192e8:	2b00      	cmp	r3, #0
 80192ea:	d101      	bne.n	80192f0 <get_dht+0x3ca>
 80192ec:	2300      	movs	r3, #0
 80192ee:	e0d1      	b.n	8019494 <get_dht+0x56e>
 80192f0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80192f4:	681b      	ldr	r3, [r3, #0]
 80192f6:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 80192fa:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80192fe:	685b      	ldr	r3, [r3, #4]
 8019300:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8019304:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8019308:	3b01      	subs	r3, #1
 801930a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801930e:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8019312:	1c5a      	adds	r2, r3, #1
 8019314:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 8019318:	7819      	ldrb	r1, [r3, #0]
 801931a:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801931e:	f5a3 729e 	sub.w	r2, r3, #316	@ 0x13c
 8019322:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8019326:	4413      	add	r3, r2
 8019328:	460a      	mov	r2, r1
 801932a:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 801932c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8019330:	3301      	adds	r3, #1
 8019332:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8019336:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801933a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801933e:	429a      	cmp	r2, r3
 8019340:	dbc4      	blt.n	80192cc <get_dht+0x3a6>

    length -= count;
 8019342:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8019346:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801934a:	1ad3      	subs	r3, r2, r3
 801934c:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    if (index & 0x10) {		/* AC table definition */
 8019350:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8019354:	f003 0310 	and.w	r3, r3, #16
 8019358:	2b00      	cmp	r3, #0
 801935a:	d012      	beq.n	8019382 <get_dht+0x45c>
      index -= 0x10;
 801935c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8019360:	3b10      	subs	r3, #16
 8019362:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
 8019366:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801936a:	f5a3 72a2 	sub.w	r2, r3, #324	@ 0x144
 801936e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8019372:	3330      	adds	r3, #48	@ 0x30
 8019374:	009b      	lsls	r3, r3, #2
 8019376:	6812      	ldr	r2, [r2, #0]
 8019378:	4413      	add	r3, r2
 801937a:	3304      	adds	r3, #4
 801937c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 8019380:	e00c      	b.n	801939c <get_dht+0x476>
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
 8019382:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8019386:	f5a3 72a2 	sub.w	r2, r3, #324	@ 0x144
 801938a:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801938e:	332c      	adds	r3, #44	@ 0x2c
 8019390:	009b      	lsls	r3, r3, #2
 8019392:	6812      	ldr	r2, [r2, #0]
 8019394:	4413      	add	r3, r2
 8019396:	3304      	adds	r3, #4
 8019398:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
 801939c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80193a0:	2b00      	cmp	r3, #0
 80193a2:	db03      	blt.n	80193ac <get_dht+0x486>
 80193a4:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80193a8:	2b03      	cmp	r3, #3
 80193aa:	dd1d      	ble.n	80193e8 <get_dht+0x4c2>
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);
 80193ac:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80193b0:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80193b4:	681b      	ldr	r3, [r3, #0]
 80193b6:	681b      	ldr	r3, [r3, #0]
 80193b8:	221f      	movs	r2, #31
 80193ba:	615a      	str	r2, [r3, #20]
 80193bc:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80193c0:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80193c4:	681b      	ldr	r3, [r3, #0]
 80193c6:	681b      	ldr	r3, [r3, #0]
 80193c8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80193cc:	619a      	str	r2, [r3, #24]
 80193ce:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80193d2:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80193d6:	681b      	ldr	r3, [r3, #0]
 80193d8:	681b      	ldr	r3, [r3, #0]
 80193da:	681b      	ldr	r3, [r3, #0]
 80193dc:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 80193e0:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 80193e4:	6810      	ldr	r0, [r2, #0]
 80193e6:	4798      	blx	r3

    if (*htblptr == NULL)
 80193e8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80193ec:	681b      	ldr	r3, [r3, #0]
 80193ee:	2b00      	cmp	r3, #0
 80193f0:	d10a      	bne.n	8019408 <get_dht+0x4e2>
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 80193f2:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 80193f6:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80193fa:	6818      	ldr	r0, [r3, #0]
 80193fc:	f7f7 fbac 	bl	8010b58 <jpeg_alloc_huff_table>
 8019400:	4602      	mov	r2, r0
 8019402:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8019406:	601a      	str	r2, [r3, #0]
  
    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
 8019408:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801940c:	681b      	ldr	r3, [r3, #0]
 801940e:	461d      	mov	r5, r3
 8019410:	f507 7486 	add.w	r4, r7, #268	@ 0x10c
 8019414:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8019416:	6028      	str	r0, [r5, #0]
 8019418:	6069      	str	r1, [r5, #4]
 801941a:	60aa      	str	r2, [r5, #8]
 801941c:	60eb      	str	r3, [r5, #12]
 801941e:	7823      	ldrb	r3, [r4, #0]
 8019420:	742b      	strb	r3, [r5, #16]
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
 8019422:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8019426:	681b      	ldr	r3, [r3, #0]
 8019428:	f103 0211 	add.w	r2, r3, #17
 801942c:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8019430:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
 8019434:	4610      	mov	r0, r2
 8019436:	4619      	mov	r1, r3
 8019438:	f44f 7380 	mov.w	r3, #256	@ 0x100
 801943c:	461a      	mov	r2, r3
 801943e:	f014 fa64 	bl	802d90a <memcpy>
  while (length > 16) {
 8019442:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8019446:	2b10      	cmp	r3, #16
 8019448:	f73f ade4 	bgt.w	8019014 <get_dht+0xee>
  }

  if (length != 0)
 801944c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8019450:	2b00      	cmp	r3, #0
 8019452:	d014      	beq.n	801947e <get_dht+0x558>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8019454:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8019458:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801945c:	681b      	ldr	r3, [r3, #0]
 801945e:	681b      	ldr	r3, [r3, #0]
 8019460:	220c      	movs	r2, #12
 8019462:	615a      	str	r2, [r3, #20]
 8019464:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 8019468:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801946c:	681b      	ldr	r3, [r3, #0]
 801946e:	681b      	ldr	r3, [r3, #0]
 8019470:	681b      	ldr	r3, [r3, #0]
 8019472:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 8019476:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801947a:	6810      	ldr	r0, [r2, #0]
 801947c:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 801947e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8019482:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8019486:	601a      	str	r2, [r3, #0]
 8019488:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801948c:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8019490:	605a      	str	r2, [r3, #4]
  return TRUE;
 8019492:	2301      	movs	r3, #1
}
 8019494:	4618      	mov	r0, r3
 8019496:	f507 77a4 	add.w	r7, r7, #328	@ 0x148
 801949a:	46bd      	mov	sp, r7
 801949c:	bdb0      	pop	{r4, r5, r7, pc}
	...

080194a0 <get_dqt>:


LOCAL(boolean)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
 80194a0:	b580      	push	{r7, lr}
 80194a2:	b08e      	sub	sp, #56	@ 0x38
 80194a4:	af00      	add	r7, sp, #0
 80194a6:	6078      	str	r0, [r7, #4]
  INT32 length, count, i;
  int n, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  const int *natural_order;
  INPUT_VARS(cinfo);
 80194a8:	687b      	ldr	r3, [r7, #4]
 80194aa:	699b      	ldr	r3, [r3, #24]
 80194ac:	61bb      	str	r3, [r7, #24]
 80194ae:	69bb      	ldr	r3, [r7, #24]
 80194b0:	681b      	ldr	r3, [r3, #0]
 80194b2:	623b      	str	r3, [r7, #32]
 80194b4:	69bb      	ldr	r3, [r7, #24]
 80194b6:	685b      	ldr	r3, [r3, #4]
 80194b8:	61fb      	str	r3, [r7, #28]

  INPUT_2BYTES(cinfo, length, return FALSE);
 80194ba:	69fb      	ldr	r3, [r7, #28]
 80194bc:	2b00      	cmp	r3, #0
 80194be:	d10e      	bne.n	80194de <get_dqt+0x3e>
 80194c0:	69bb      	ldr	r3, [r7, #24]
 80194c2:	68db      	ldr	r3, [r3, #12]
 80194c4:	6878      	ldr	r0, [r7, #4]
 80194c6:	4798      	blx	r3
 80194c8:	4603      	mov	r3, r0
 80194ca:	2b00      	cmp	r3, #0
 80194cc:	d101      	bne.n	80194d2 <get_dqt+0x32>
 80194ce:	2300      	movs	r3, #0
 80194d0:	e21e      	b.n	8019910 <get_dqt+0x470>
 80194d2:	69bb      	ldr	r3, [r7, #24]
 80194d4:	681b      	ldr	r3, [r3, #0]
 80194d6:	623b      	str	r3, [r7, #32]
 80194d8:	69bb      	ldr	r3, [r7, #24]
 80194da:	685b      	ldr	r3, [r3, #4]
 80194dc:	61fb      	str	r3, [r7, #28]
 80194de:	69fb      	ldr	r3, [r7, #28]
 80194e0:	3b01      	subs	r3, #1
 80194e2:	61fb      	str	r3, [r7, #28]
 80194e4:	6a3b      	ldr	r3, [r7, #32]
 80194e6:	1c5a      	adds	r2, r3, #1
 80194e8:	623a      	str	r2, [r7, #32]
 80194ea:	781b      	ldrb	r3, [r3, #0]
 80194ec:	021b      	lsls	r3, r3, #8
 80194ee:	637b      	str	r3, [r7, #52]	@ 0x34
 80194f0:	69fb      	ldr	r3, [r7, #28]
 80194f2:	2b00      	cmp	r3, #0
 80194f4:	d10e      	bne.n	8019514 <get_dqt+0x74>
 80194f6:	69bb      	ldr	r3, [r7, #24]
 80194f8:	68db      	ldr	r3, [r3, #12]
 80194fa:	6878      	ldr	r0, [r7, #4]
 80194fc:	4798      	blx	r3
 80194fe:	4603      	mov	r3, r0
 8019500:	2b00      	cmp	r3, #0
 8019502:	d101      	bne.n	8019508 <get_dqt+0x68>
 8019504:	2300      	movs	r3, #0
 8019506:	e203      	b.n	8019910 <get_dqt+0x470>
 8019508:	69bb      	ldr	r3, [r7, #24]
 801950a:	681b      	ldr	r3, [r3, #0]
 801950c:	623b      	str	r3, [r7, #32]
 801950e:	69bb      	ldr	r3, [r7, #24]
 8019510:	685b      	ldr	r3, [r3, #4]
 8019512:	61fb      	str	r3, [r7, #28]
 8019514:	69fb      	ldr	r3, [r7, #28]
 8019516:	3b01      	subs	r3, #1
 8019518:	61fb      	str	r3, [r7, #28]
 801951a:	6a3b      	ldr	r3, [r7, #32]
 801951c:	1c5a      	adds	r2, r3, #1
 801951e:	623a      	str	r2, [r7, #32]
 8019520:	781b      	ldrb	r3, [r3, #0]
 8019522:	461a      	mov	r2, r3
 8019524:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8019526:	4413      	add	r3, r2
 8019528:	637b      	str	r3, [r7, #52]	@ 0x34
  length -= 2;
 801952a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801952c:	3b02      	subs	r3, #2
 801952e:	637b      	str	r3, [r7, #52]	@ 0x34

  while (length > 0) {
 8019530:	e1d7      	b.n	80198e2 <get_dqt+0x442>
    length--;
 8019532:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8019534:	3b01      	subs	r3, #1
 8019536:	637b      	str	r3, [r7, #52]	@ 0x34
    INPUT_BYTE(cinfo, n, return FALSE);
 8019538:	69fb      	ldr	r3, [r7, #28]
 801953a:	2b00      	cmp	r3, #0
 801953c:	d10e      	bne.n	801955c <get_dqt+0xbc>
 801953e:	69bb      	ldr	r3, [r7, #24]
 8019540:	68db      	ldr	r3, [r3, #12]
 8019542:	6878      	ldr	r0, [r7, #4]
 8019544:	4798      	blx	r3
 8019546:	4603      	mov	r3, r0
 8019548:	2b00      	cmp	r3, #0
 801954a:	d101      	bne.n	8019550 <get_dqt+0xb0>
 801954c:	2300      	movs	r3, #0
 801954e:	e1df      	b.n	8019910 <get_dqt+0x470>
 8019550:	69bb      	ldr	r3, [r7, #24]
 8019552:	681b      	ldr	r3, [r3, #0]
 8019554:	623b      	str	r3, [r7, #32]
 8019556:	69bb      	ldr	r3, [r7, #24]
 8019558:	685b      	ldr	r3, [r3, #4]
 801955a:	61fb      	str	r3, [r7, #28]
 801955c:	69fb      	ldr	r3, [r7, #28]
 801955e:	3b01      	subs	r3, #1
 8019560:	61fb      	str	r3, [r7, #28]
 8019562:	6a3b      	ldr	r3, [r7, #32]
 8019564:	1c5a      	adds	r2, r3, #1
 8019566:	623a      	str	r2, [r7, #32]
 8019568:	781b      	ldrb	r3, [r3, #0]
 801956a:	617b      	str	r3, [r7, #20]
    prec = n >> 4;
 801956c:	697b      	ldr	r3, [r7, #20]
 801956e:	111b      	asrs	r3, r3, #4
 8019570:	613b      	str	r3, [r7, #16]
    n &= 0x0F;
 8019572:	697b      	ldr	r3, [r7, #20]
 8019574:	f003 030f 	and.w	r3, r3, #15
 8019578:	617b      	str	r3, [r7, #20]

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);
 801957a:	687b      	ldr	r3, [r7, #4]
 801957c:	681b      	ldr	r3, [r3, #0]
 801957e:	2253      	movs	r2, #83	@ 0x53
 8019580:	615a      	str	r2, [r3, #20]
 8019582:	687b      	ldr	r3, [r7, #4]
 8019584:	681b      	ldr	r3, [r3, #0]
 8019586:	697a      	ldr	r2, [r7, #20]
 8019588:	619a      	str	r2, [r3, #24]
 801958a:	687b      	ldr	r3, [r7, #4]
 801958c:	681b      	ldr	r3, [r3, #0]
 801958e:	693a      	ldr	r2, [r7, #16]
 8019590:	61da      	str	r2, [r3, #28]
 8019592:	687b      	ldr	r3, [r7, #4]
 8019594:	681b      	ldr	r3, [r3, #0]
 8019596:	685b      	ldr	r3, [r3, #4]
 8019598:	2101      	movs	r1, #1
 801959a:	6878      	ldr	r0, [r7, #4]
 801959c:	4798      	blx	r3

    if (n >= NUM_QUANT_TBLS)
 801959e:	697b      	ldr	r3, [r7, #20]
 80195a0:	2b03      	cmp	r3, #3
 80195a2:	dd0c      	ble.n	80195be <get_dqt+0x11e>
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
 80195a4:	687b      	ldr	r3, [r7, #4]
 80195a6:	681b      	ldr	r3, [r3, #0]
 80195a8:	2220      	movs	r2, #32
 80195aa:	615a      	str	r2, [r3, #20]
 80195ac:	687b      	ldr	r3, [r7, #4]
 80195ae:	681b      	ldr	r3, [r3, #0]
 80195b0:	697a      	ldr	r2, [r7, #20]
 80195b2:	619a      	str	r2, [r3, #24]
 80195b4:	687b      	ldr	r3, [r7, #4]
 80195b6:	681b      	ldr	r3, [r3, #0]
 80195b8:	681b      	ldr	r3, [r3, #0]
 80195ba:	6878      	ldr	r0, [r7, #4]
 80195bc:	4798      	blx	r3
      
    if (cinfo->quant_tbl_ptrs[n] == NULL)
 80195be:	687a      	ldr	r2, [r7, #4]
 80195c0:	697b      	ldr	r3, [r7, #20]
 80195c2:	3328      	adds	r3, #40	@ 0x28
 80195c4:	009b      	lsls	r3, r3, #2
 80195c6:	4413      	add	r3, r2
 80195c8:	685b      	ldr	r3, [r3, #4]
 80195ca:	2b00      	cmp	r3, #0
 80195cc:	d109      	bne.n	80195e2 <get_dqt+0x142>
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
 80195ce:	6878      	ldr	r0, [r7, #4]
 80195d0:	f7f7 faad 	bl	8010b2e <jpeg_alloc_quant_table>
 80195d4:	4601      	mov	r1, r0
 80195d6:	687a      	ldr	r2, [r7, #4]
 80195d8:	697b      	ldr	r3, [r7, #20]
 80195da:	3328      	adds	r3, #40	@ 0x28
 80195dc:	009b      	lsls	r3, r3, #2
 80195de:	4413      	add	r3, r2
 80195e0:	6059      	str	r1, [r3, #4]
    quant_ptr = cinfo->quant_tbl_ptrs[n];
 80195e2:	687a      	ldr	r2, [r7, #4]
 80195e4:	697b      	ldr	r3, [r7, #20]
 80195e6:	3328      	adds	r3, #40	@ 0x28
 80195e8:	009b      	lsls	r3, r3, #2
 80195ea:	4413      	add	r3, r2
 80195ec:	685b      	ldr	r3, [r3, #4]
 80195ee:	60fb      	str	r3, [r7, #12]

    if (prec) {
 80195f0:	693b      	ldr	r3, [r7, #16]
 80195f2:	2b00      	cmp	r3, #0
 80195f4:	d017      	beq.n	8019626 <get_dqt+0x186>
      if (length < DCTSIZE2 * 2) {
 80195f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80195f8:	2b7f      	cmp	r3, #127	@ 0x7f
 80195fa:	dc11      	bgt.n	8019620 <get_dqt+0x180>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 80195fc:	2300      	movs	r3, #0
 80195fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019600:	e007      	b.n	8019612 <get_dqt+0x172>
	  quant_ptr->quantval[i] = 1;
 8019602:	68fb      	ldr	r3, [r7, #12]
 8019604:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019606:	2101      	movs	r1, #1
 8019608:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 801960c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801960e:	3301      	adds	r3, #1
 8019610:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019612:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019614:	2b3f      	cmp	r3, #63	@ 0x3f
 8019616:	ddf4      	ble.n	8019602 <get_dqt+0x162>
	}
	count = length >> 1;
 8019618:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801961a:	105b      	asrs	r3, r3, #1
 801961c:	633b      	str	r3, [r7, #48]	@ 0x30
 801961e:	e018      	b.n	8019652 <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 8019620:	2340      	movs	r3, #64	@ 0x40
 8019622:	633b      	str	r3, [r7, #48]	@ 0x30
 8019624:	e015      	b.n	8019652 <get_dqt+0x1b2>
    } else {
      if (length < DCTSIZE2) {
 8019626:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8019628:	2b3f      	cmp	r3, #63	@ 0x3f
 801962a:	dc10      	bgt.n	801964e <get_dqt+0x1ae>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 801962c:	2300      	movs	r3, #0
 801962e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019630:	e007      	b.n	8019642 <get_dqt+0x1a2>
	  quant_ptr->quantval[i] = 1;
 8019632:	68fb      	ldr	r3, [r7, #12]
 8019634:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019636:	2101      	movs	r1, #1
 8019638:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 801963c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801963e:	3301      	adds	r3, #1
 8019640:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019642:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019644:	2b3f      	cmp	r3, #63	@ 0x3f
 8019646:	ddf4      	ble.n	8019632 <get_dqt+0x192>
	}
	count = length;
 8019648:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801964a:	633b      	str	r3, [r7, #48]	@ 0x30
 801964c:	e001      	b.n	8019652 <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 801964e:	2340      	movs	r3, #64	@ 0x40
 8019650:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    switch (count) {
 8019652:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019654:	3b04      	subs	r3, #4
 8019656:	2b2d      	cmp	r3, #45	@ 0x2d
 8019658:	d870      	bhi.n	801973c <get_dqt+0x29c>
 801965a:	a201      	add	r2, pc, #4	@ (adr r2, 8019660 <get_dqt+0x1c0>)
 801965c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019660:	08019719 	.word	0x08019719
 8019664:	0801973d 	.word	0x0801973d
 8019668:	0801973d 	.word	0x0801973d
 801966c:	0801973d 	.word	0x0801973d
 8019670:	0801973d 	.word	0x0801973d
 8019674:	0801971f 	.word	0x0801971f
 8019678:	0801973d 	.word	0x0801973d
 801967c:	0801973d 	.word	0x0801973d
 8019680:	0801973d 	.word	0x0801973d
 8019684:	0801973d 	.word	0x0801973d
 8019688:	0801973d 	.word	0x0801973d
 801968c:	0801973d 	.word	0x0801973d
 8019690:	08019725 	.word	0x08019725
 8019694:	0801973d 	.word	0x0801973d
 8019698:	0801973d 	.word	0x0801973d
 801969c:	0801973d 	.word	0x0801973d
 80196a0:	0801973d 	.word	0x0801973d
 80196a4:	0801973d 	.word	0x0801973d
 80196a8:	0801973d 	.word	0x0801973d
 80196ac:	0801973d 	.word	0x0801973d
 80196b0:	0801973d 	.word	0x0801973d
 80196b4:	0801972b 	.word	0x0801972b
 80196b8:	0801973d 	.word	0x0801973d
 80196bc:	0801973d 	.word	0x0801973d
 80196c0:	0801973d 	.word	0x0801973d
 80196c4:	0801973d 	.word	0x0801973d
 80196c8:	0801973d 	.word	0x0801973d
 80196cc:	0801973d 	.word	0x0801973d
 80196d0:	0801973d 	.word	0x0801973d
 80196d4:	0801973d 	.word	0x0801973d
 80196d8:	0801973d 	.word	0x0801973d
 80196dc:	0801973d 	.word	0x0801973d
 80196e0:	08019731 	.word	0x08019731
 80196e4:	0801973d 	.word	0x0801973d
 80196e8:	0801973d 	.word	0x0801973d
 80196ec:	0801973d 	.word	0x0801973d
 80196f0:	0801973d 	.word	0x0801973d
 80196f4:	0801973d 	.word	0x0801973d
 80196f8:	0801973d 	.word	0x0801973d
 80196fc:	0801973d 	.word	0x0801973d
 8019700:	0801973d 	.word	0x0801973d
 8019704:	0801973d 	.word	0x0801973d
 8019708:	0801973d 	.word	0x0801973d
 801970c:	0801973d 	.word	0x0801973d
 8019710:	0801973d 	.word	0x0801973d
 8019714:	08019737 	.word	0x08019737
    case (2*2): natural_order = jpeg_natural_order2; break;
 8019718:	4b7f      	ldr	r3, [pc, #508]	@ (8019918 <get_dqt+0x478>)
 801971a:	627b      	str	r3, [r7, #36]	@ 0x24
 801971c:	e011      	b.n	8019742 <get_dqt+0x2a2>
    case (3*3): natural_order = jpeg_natural_order3; break;
 801971e:	4b7f      	ldr	r3, [pc, #508]	@ (801991c <get_dqt+0x47c>)
 8019720:	627b      	str	r3, [r7, #36]	@ 0x24
 8019722:	e00e      	b.n	8019742 <get_dqt+0x2a2>
    case (4*4): natural_order = jpeg_natural_order4; break;
 8019724:	4b7e      	ldr	r3, [pc, #504]	@ (8019920 <get_dqt+0x480>)
 8019726:	627b      	str	r3, [r7, #36]	@ 0x24
 8019728:	e00b      	b.n	8019742 <get_dqt+0x2a2>
    case (5*5): natural_order = jpeg_natural_order5; break;
 801972a:	4b7e      	ldr	r3, [pc, #504]	@ (8019924 <get_dqt+0x484>)
 801972c:	627b      	str	r3, [r7, #36]	@ 0x24
 801972e:	e008      	b.n	8019742 <get_dqt+0x2a2>
    case (6*6): natural_order = jpeg_natural_order6; break;
 8019730:	4b7d      	ldr	r3, [pc, #500]	@ (8019928 <get_dqt+0x488>)
 8019732:	627b      	str	r3, [r7, #36]	@ 0x24
 8019734:	e005      	b.n	8019742 <get_dqt+0x2a2>
    case (7*7): natural_order = jpeg_natural_order7; break;
 8019736:	4b7d      	ldr	r3, [pc, #500]	@ (801992c <get_dqt+0x48c>)
 8019738:	627b      	str	r3, [r7, #36]	@ 0x24
 801973a:	e002      	b.n	8019742 <get_dqt+0x2a2>
    default:    natural_order = jpeg_natural_order;  break;
 801973c:	4b7c      	ldr	r3, [pc, #496]	@ (8019930 <get_dqt+0x490>)
 801973e:	627b      	str	r3, [r7, #36]	@ 0x24
 8019740:	bf00      	nop
    }

    for (i = 0; i < count; i++) {
 8019742:	2300      	movs	r3, #0
 8019744:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019746:	e062      	b.n	801980e <get_dqt+0x36e>
      if (prec)
 8019748:	693b      	ldr	r3, [r7, #16]
 801974a:	2b00      	cmp	r3, #0
 801974c:	d038      	beq.n	80197c0 <get_dqt+0x320>
	INPUT_2BYTES(cinfo, tmp, return FALSE);
 801974e:	69fb      	ldr	r3, [r7, #28]
 8019750:	2b00      	cmp	r3, #0
 8019752:	d10e      	bne.n	8019772 <get_dqt+0x2d2>
 8019754:	69bb      	ldr	r3, [r7, #24]
 8019756:	68db      	ldr	r3, [r3, #12]
 8019758:	6878      	ldr	r0, [r7, #4]
 801975a:	4798      	blx	r3
 801975c:	4603      	mov	r3, r0
 801975e:	2b00      	cmp	r3, #0
 8019760:	d101      	bne.n	8019766 <get_dqt+0x2c6>
 8019762:	2300      	movs	r3, #0
 8019764:	e0d4      	b.n	8019910 <get_dqt+0x470>
 8019766:	69bb      	ldr	r3, [r7, #24]
 8019768:	681b      	ldr	r3, [r3, #0]
 801976a:	623b      	str	r3, [r7, #32]
 801976c:	69bb      	ldr	r3, [r7, #24]
 801976e:	685b      	ldr	r3, [r3, #4]
 8019770:	61fb      	str	r3, [r7, #28]
 8019772:	69fb      	ldr	r3, [r7, #28]
 8019774:	3b01      	subs	r3, #1
 8019776:	61fb      	str	r3, [r7, #28]
 8019778:	6a3b      	ldr	r3, [r7, #32]
 801977a:	1c5a      	adds	r2, r3, #1
 801977c:	623a      	str	r2, [r7, #32]
 801977e:	781b      	ldrb	r3, [r3, #0]
 8019780:	021b      	lsls	r3, r3, #8
 8019782:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019784:	69fb      	ldr	r3, [r7, #28]
 8019786:	2b00      	cmp	r3, #0
 8019788:	d10e      	bne.n	80197a8 <get_dqt+0x308>
 801978a:	69bb      	ldr	r3, [r7, #24]
 801978c:	68db      	ldr	r3, [r3, #12]
 801978e:	6878      	ldr	r0, [r7, #4]
 8019790:	4798      	blx	r3
 8019792:	4603      	mov	r3, r0
 8019794:	2b00      	cmp	r3, #0
 8019796:	d101      	bne.n	801979c <get_dqt+0x2fc>
 8019798:	2300      	movs	r3, #0
 801979a:	e0b9      	b.n	8019910 <get_dqt+0x470>
 801979c:	69bb      	ldr	r3, [r7, #24]
 801979e:	681b      	ldr	r3, [r3, #0]
 80197a0:	623b      	str	r3, [r7, #32]
 80197a2:	69bb      	ldr	r3, [r7, #24]
 80197a4:	685b      	ldr	r3, [r3, #4]
 80197a6:	61fb      	str	r3, [r7, #28]
 80197a8:	69fb      	ldr	r3, [r7, #28]
 80197aa:	3b01      	subs	r3, #1
 80197ac:	61fb      	str	r3, [r7, #28]
 80197ae:	6a3b      	ldr	r3, [r7, #32]
 80197b0:	1c5a      	adds	r2, r3, #1
 80197b2:	623a      	str	r2, [r7, #32]
 80197b4:	781b      	ldrb	r3, [r3, #0]
 80197b6:	461a      	mov	r2, r3
 80197b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80197ba:	4413      	add	r3, r2
 80197bc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80197be:	e019      	b.n	80197f4 <get_dqt+0x354>
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
 80197c0:	69fb      	ldr	r3, [r7, #28]
 80197c2:	2b00      	cmp	r3, #0
 80197c4:	d10e      	bne.n	80197e4 <get_dqt+0x344>
 80197c6:	69bb      	ldr	r3, [r7, #24]
 80197c8:	68db      	ldr	r3, [r3, #12]
 80197ca:	6878      	ldr	r0, [r7, #4]
 80197cc:	4798      	blx	r3
 80197ce:	4603      	mov	r3, r0
 80197d0:	2b00      	cmp	r3, #0
 80197d2:	d101      	bne.n	80197d8 <get_dqt+0x338>
 80197d4:	2300      	movs	r3, #0
 80197d6:	e09b      	b.n	8019910 <get_dqt+0x470>
 80197d8:	69bb      	ldr	r3, [r7, #24]
 80197da:	681b      	ldr	r3, [r3, #0]
 80197dc:	623b      	str	r3, [r7, #32]
 80197de:	69bb      	ldr	r3, [r7, #24]
 80197e0:	685b      	ldr	r3, [r3, #4]
 80197e2:	61fb      	str	r3, [r7, #28]
 80197e4:	69fb      	ldr	r3, [r7, #28]
 80197e6:	3b01      	subs	r3, #1
 80197e8:	61fb      	str	r3, [r7, #28]
 80197ea:	6a3b      	ldr	r3, [r7, #32]
 80197ec:	1c5a      	adds	r2, r3, #1
 80197ee:	623a      	str	r2, [r7, #32]
 80197f0:	781b      	ldrb	r3, [r3, #0]
 80197f2:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[natural_order[i]] = (UINT16) tmp;
 80197f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80197f6:	009b      	lsls	r3, r3, #2
 80197f8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80197fa:	4413      	add	r3, r2
 80197fc:	681a      	ldr	r2, [r3, #0]
 80197fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019800:	b299      	uxth	r1, r3
 8019802:	68fb      	ldr	r3, [r7, #12]
 8019804:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < count; i++) {
 8019808:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801980a:	3301      	adds	r3, #1
 801980c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801980e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019810:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019812:	429a      	cmp	r2, r3
 8019814:	db98      	blt.n	8019748 <get_dqt+0x2a8>
    }

    if (cinfo->err->trace_level >= 2) {
 8019816:	687b      	ldr	r3, [r7, #4]
 8019818:	681b      	ldr	r3, [r3, #0]
 801981a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801981c:	2b01      	cmp	r3, #1
 801981e:	dd55      	ble.n	80198cc <get_dqt+0x42c>
      for (i = 0; i < DCTSIZE2; i += 8) {
 8019820:	2300      	movs	r3, #0
 8019822:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019824:	e04f      	b.n	80198c6 <get_dqt+0x426>
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
 8019826:	687b      	ldr	r3, [r7, #4]
 8019828:	681b      	ldr	r3, [r3, #0]
 801982a:	3318      	adds	r3, #24
 801982c:	60bb      	str	r3, [r7, #8]
 801982e:	68fb      	ldr	r3, [r7, #12]
 8019830:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019832:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8019836:	461a      	mov	r2, r3
 8019838:	68bb      	ldr	r3, [r7, #8]
 801983a:	601a      	str	r2, [r3, #0]
 801983c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801983e:	1c5a      	adds	r2, r3, #1
 8019840:	68fb      	ldr	r3, [r7, #12]
 8019842:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019846:	68bb      	ldr	r3, [r7, #8]
 8019848:	3304      	adds	r3, #4
 801984a:	601a      	str	r2, [r3, #0]
 801984c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801984e:	1c9a      	adds	r2, r3, #2
 8019850:	68fb      	ldr	r3, [r7, #12]
 8019852:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019856:	68bb      	ldr	r3, [r7, #8]
 8019858:	3308      	adds	r3, #8
 801985a:	601a      	str	r2, [r3, #0]
 801985c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801985e:	1cda      	adds	r2, r3, #3
 8019860:	68fb      	ldr	r3, [r7, #12]
 8019862:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019866:	68bb      	ldr	r3, [r7, #8]
 8019868:	330c      	adds	r3, #12
 801986a:	601a      	str	r2, [r3, #0]
 801986c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801986e:	1d1a      	adds	r2, r3, #4
 8019870:	68fb      	ldr	r3, [r7, #12]
 8019872:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019876:	68bb      	ldr	r3, [r7, #8]
 8019878:	3310      	adds	r3, #16
 801987a:	601a      	str	r2, [r3, #0]
 801987c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801987e:	1d5a      	adds	r2, r3, #5
 8019880:	68fb      	ldr	r3, [r7, #12]
 8019882:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019886:	68bb      	ldr	r3, [r7, #8]
 8019888:	3314      	adds	r3, #20
 801988a:	601a      	str	r2, [r3, #0]
 801988c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801988e:	1d9a      	adds	r2, r3, #6
 8019890:	68fb      	ldr	r3, [r7, #12]
 8019892:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8019896:	68bb      	ldr	r3, [r7, #8]
 8019898:	3318      	adds	r3, #24
 801989a:	601a      	str	r2, [r3, #0]
 801989c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801989e:	1dda      	adds	r2, r3, #7
 80198a0:	68fb      	ldr	r3, [r7, #12]
 80198a2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 80198a6:	68bb      	ldr	r3, [r7, #8]
 80198a8:	331c      	adds	r3, #28
 80198aa:	601a      	str	r2, [r3, #0]
 80198ac:	687b      	ldr	r3, [r7, #4]
 80198ae:	681b      	ldr	r3, [r3, #0]
 80198b0:	225f      	movs	r2, #95	@ 0x5f
 80198b2:	615a      	str	r2, [r3, #20]
 80198b4:	687b      	ldr	r3, [r7, #4]
 80198b6:	681b      	ldr	r3, [r3, #0]
 80198b8:	685b      	ldr	r3, [r3, #4]
 80198ba:	2102      	movs	r1, #2
 80198bc:	6878      	ldr	r0, [r7, #4]
 80198be:	4798      	blx	r3
      for (i = 0; i < DCTSIZE2; i += 8) {
 80198c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80198c2:	3308      	adds	r3, #8
 80198c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80198c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80198c8:	2b3f      	cmp	r3, #63	@ 0x3f
 80198ca:	ddac      	ble.n	8019826 <get_dqt+0x386>
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= count;
 80198cc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80198ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80198d0:	1ad3      	subs	r3, r2, r3
 80198d2:	637b      	str	r3, [r7, #52]	@ 0x34
    if (prec) length -= count;
 80198d4:	693b      	ldr	r3, [r7, #16]
 80198d6:	2b00      	cmp	r3, #0
 80198d8:	d003      	beq.n	80198e2 <get_dqt+0x442>
 80198da:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80198dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80198de:	1ad3      	subs	r3, r2, r3
 80198e0:	637b      	str	r3, [r7, #52]	@ 0x34
  while (length > 0) {
 80198e2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80198e4:	2b00      	cmp	r3, #0
 80198e6:	f73f ae24 	bgt.w	8019532 <get_dqt+0x92>
  }

  if (length != 0)
 80198ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80198ec:	2b00      	cmp	r3, #0
 80198ee:	d008      	beq.n	8019902 <get_dqt+0x462>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 80198f0:	687b      	ldr	r3, [r7, #4]
 80198f2:	681b      	ldr	r3, [r3, #0]
 80198f4:	220c      	movs	r2, #12
 80198f6:	615a      	str	r2, [r3, #20]
 80198f8:	687b      	ldr	r3, [r7, #4]
 80198fa:	681b      	ldr	r3, [r3, #0]
 80198fc:	681b      	ldr	r3, [r3, #0]
 80198fe:	6878      	ldr	r0, [r7, #4]
 8019900:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 8019902:	69bb      	ldr	r3, [r7, #24]
 8019904:	6a3a      	ldr	r2, [r7, #32]
 8019906:	601a      	str	r2, [r3, #0]
 8019908:	69bb      	ldr	r3, [r7, #24]
 801990a:	69fa      	ldr	r2, [r7, #28]
 801990c:	605a      	str	r2, [r3, #4]
  return TRUE;
 801990e:	2301      	movs	r3, #1
}
 8019910:	4618      	mov	r0, r3
 8019912:	3738      	adds	r7, #56	@ 0x38
 8019914:	46bd      	mov	sp, r7
 8019916:	bd80      	pop	{r7, pc}
 8019918:	08030d4c 	.word	0x08030d4c
 801991c:	08030ce8 	.word	0x08030ce8
 8019920:	08030c68 	.word	0x08030c68
 8019924:	08030bc4 	.word	0x08030bc4
 8019928:	08030af4 	.word	0x08030af4
 801992c:	080309f0 	.word	0x080309f0
 8019930:	080308b0 	.word	0x080308b0

08019934 <get_dri>:


LOCAL(boolean)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
 8019934:	b580      	push	{r7, lr}
 8019936:	b088      	sub	sp, #32
 8019938:	af00      	add	r7, sp, #0
 801993a:	6078      	str	r0, [r7, #4]
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);
 801993c:	687b      	ldr	r3, [r7, #4]
 801993e:	699b      	ldr	r3, [r3, #24]
 8019940:	617b      	str	r3, [r7, #20]
 8019942:	697b      	ldr	r3, [r7, #20]
 8019944:	681b      	ldr	r3, [r3, #0]
 8019946:	61fb      	str	r3, [r7, #28]
 8019948:	697b      	ldr	r3, [r7, #20]
 801994a:	685b      	ldr	r3, [r3, #4]
 801994c:	61bb      	str	r3, [r7, #24]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801994e:	69bb      	ldr	r3, [r7, #24]
 8019950:	2b00      	cmp	r3, #0
 8019952:	d10e      	bne.n	8019972 <get_dri+0x3e>
 8019954:	697b      	ldr	r3, [r7, #20]
 8019956:	68db      	ldr	r3, [r3, #12]
 8019958:	6878      	ldr	r0, [r7, #4]
 801995a:	4798      	blx	r3
 801995c:	4603      	mov	r3, r0
 801995e:	2b00      	cmp	r3, #0
 8019960:	d101      	bne.n	8019966 <get_dri+0x32>
 8019962:	2300      	movs	r3, #0
 8019964:	e088      	b.n	8019a78 <get_dri+0x144>
 8019966:	697b      	ldr	r3, [r7, #20]
 8019968:	681b      	ldr	r3, [r3, #0]
 801996a:	61fb      	str	r3, [r7, #28]
 801996c:	697b      	ldr	r3, [r7, #20]
 801996e:	685b      	ldr	r3, [r3, #4]
 8019970:	61bb      	str	r3, [r7, #24]
 8019972:	69bb      	ldr	r3, [r7, #24]
 8019974:	3b01      	subs	r3, #1
 8019976:	61bb      	str	r3, [r7, #24]
 8019978:	69fb      	ldr	r3, [r7, #28]
 801997a:	1c5a      	adds	r2, r3, #1
 801997c:	61fa      	str	r2, [r7, #28]
 801997e:	781b      	ldrb	r3, [r3, #0]
 8019980:	021b      	lsls	r3, r3, #8
 8019982:	613b      	str	r3, [r7, #16]
 8019984:	69bb      	ldr	r3, [r7, #24]
 8019986:	2b00      	cmp	r3, #0
 8019988:	d10e      	bne.n	80199a8 <get_dri+0x74>
 801998a:	697b      	ldr	r3, [r7, #20]
 801998c:	68db      	ldr	r3, [r3, #12]
 801998e:	6878      	ldr	r0, [r7, #4]
 8019990:	4798      	blx	r3
 8019992:	4603      	mov	r3, r0
 8019994:	2b00      	cmp	r3, #0
 8019996:	d101      	bne.n	801999c <get_dri+0x68>
 8019998:	2300      	movs	r3, #0
 801999a:	e06d      	b.n	8019a78 <get_dri+0x144>
 801999c:	697b      	ldr	r3, [r7, #20]
 801999e:	681b      	ldr	r3, [r3, #0]
 80199a0:	61fb      	str	r3, [r7, #28]
 80199a2:	697b      	ldr	r3, [r7, #20]
 80199a4:	685b      	ldr	r3, [r3, #4]
 80199a6:	61bb      	str	r3, [r7, #24]
 80199a8:	69bb      	ldr	r3, [r7, #24]
 80199aa:	3b01      	subs	r3, #1
 80199ac:	61bb      	str	r3, [r7, #24]
 80199ae:	69fb      	ldr	r3, [r7, #28]
 80199b0:	1c5a      	adds	r2, r3, #1
 80199b2:	61fa      	str	r2, [r7, #28]
 80199b4:	781b      	ldrb	r3, [r3, #0]
 80199b6:	461a      	mov	r2, r3
 80199b8:	693b      	ldr	r3, [r7, #16]
 80199ba:	4413      	add	r3, r2
 80199bc:	613b      	str	r3, [r7, #16]
  
  if (length != 4)
 80199be:	693b      	ldr	r3, [r7, #16]
 80199c0:	2b04      	cmp	r3, #4
 80199c2:	d008      	beq.n	80199d6 <get_dri+0xa2>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 80199c4:	687b      	ldr	r3, [r7, #4]
 80199c6:	681b      	ldr	r3, [r3, #0]
 80199c8:	220c      	movs	r2, #12
 80199ca:	615a      	str	r2, [r3, #20]
 80199cc:	687b      	ldr	r3, [r7, #4]
 80199ce:	681b      	ldr	r3, [r3, #0]
 80199d0:	681b      	ldr	r3, [r3, #0]
 80199d2:	6878      	ldr	r0, [r7, #4]
 80199d4:	4798      	blx	r3

  INPUT_2BYTES(cinfo, tmp, return FALSE);
 80199d6:	69bb      	ldr	r3, [r7, #24]
 80199d8:	2b00      	cmp	r3, #0
 80199da:	d10e      	bne.n	80199fa <get_dri+0xc6>
 80199dc:	697b      	ldr	r3, [r7, #20]
 80199de:	68db      	ldr	r3, [r3, #12]
 80199e0:	6878      	ldr	r0, [r7, #4]
 80199e2:	4798      	blx	r3
 80199e4:	4603      	mov	r3, r0
 80199e6:	2b00      	cmp	r3, #0
 80199e8:	d101      	bne.n	80199ee <get_dri+0xba>
 80199ea:	2300      	movs	r3, #0
 80199ec:	e044      	b.n	8019a78 <get_dri+0x144>
 80199ee:	697b      	ldr	r3, [r7, #20]
 80199f0:	681b      	ldr	r3, [r3, #0]
 80199f2:	61fb      	str	r3, [r7, #28]
 80199f4:	697b      	ldr	r3, [r7, #20]
 80199f6:	685b      	ldr	r3, [r3, #4]
 80199f8:	61bb      	str	r3, [r7, #24]
 80199fa:	69bb      	ldr	r3, [r7, #24]
 80199fc:	3b01      	subs	r3, #1
 80199fe:	61bb      	str	r3, [r7, #24]
 8019a00:	69fb      	ldr	r3, [r7, #28]
 8019a02:	1c5a      	adds	r2, r3, #1
 8019a04:	61fa      	str	r2, [r7, #28]
 8019a06:	781b      	ldrb	r3, [r3, #0]
 8019a08:	021b      	lsls	r3, r3, #8
 8019a0a:	60fb      	str	r3, [r7, #12]
 8019a0c:	69bb      	ldr	r3, [r7, #24]
 8019a0e:	2b00      	cmp	r3, #0
 8019a10:	d10e      	bne.n	8019a30 <get_dri+0xfc>
 8019a12:	697b      	ldr	r3, [r7, #20]
 8019a14:	68db      	ldr	r3, [r3, #12]
 8019a16:	6878      	ldr	r0, [r7, #4]
 8019a18:	4798      	blx	r3
 8019a1a:	4603      	mov	r3, r0
 8019a1c:	2b00      	cmp	r3, #0
 8019a1e:	d101      	bne.n	8019a24 <get_dri+0xf0>
 8019a20:	2300      	movs	r3, #0
 8019a22:	e029      	b.n	8019a78 <get_dri+0x144>
 8019a24:	697b      	ldr	r3, [r7, #20]
 8019a26:	681b      	ldr	r3, [r3, #0]
 8019a28:	61fb      	str	r3, [r7, #28]
 8019a2a:	697b      	ldr	r3, [r7, #20]
 8019a2c:	685b      	ldr	r3, [r3, #4]
 8019a2e:	61bb      	str	r3, [r7, #24]
 8019a30:	69bb      	ldr	r3, [r7, #24]
 8019a32:	3b01      	subs	r3, #1
 8019a34:	61bb      	str	r3, [r7, #24]
 8019a36:	69fb      	ldr	r3, [r7, #28]
 8019a38:	1c5a      	adds	r2, r3, #1
 8019a3a:	61fa      	str	r2, [r7, #28]
 8019a3c:	781b      	ldrb	r3, [r3, #0]
 8019a3e:	461a      	mov	r2, r3
 8019a40:	68fb      	ldr	r3, [r7, #12]
 8019a42:	4413      	add	r3, r2
 8019a44:	60fb      	str	r3, [r7, #12]

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);
 8019a46:	687b      	ldr	r3, [r7, #4]
 8019a48:	681b      	ldr	r3, [r3, #0]
 8019a4a:	2254      	movs	r2, #84	@ 0x54
 8019a4c:	615a      	str	r2, [r3, #20]
 8019a4e:	687b      	ldr	r3, [r7, #4]
 8019a50:	681b      	ldr	r3, [r3, #0]
 8019a52:	68fa      	ldr	r2, [r7, #12]
 8019a54:	619a      	str	r2, [r3, #24]
 8019a56:	687b      	ldr	r3, [r7, #4]
 8019a58:	681b      	ldr	r3, [r3, #0]
 8019a5a:	685b      	ldr	r3, [r3, #4]
 8019a5c:	2101      	movs	r1, #1
 8019a5e:	6878      	ldr	r0, [r7, #4]
 8019a60:	4798      	blx	r3

  cinfo->restart_interval = tmp;
 8019a62:	687b      	ldr	r3, [r7, #4]
 8019a64:	68fa      	ldr	r2, [r7, #12]
 8019a66:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118

  INPUT_SYNC(cinfo);
 8019a6a:	697b      	ldr	r3, [r7, #20]
 8019a6c:	69fa      	ldr	r2, [r7, #28]
 8019a6e:	601a      	str	r2, [r3, #0]
 8019a70:	697b      	ldr	r3, [r7, #20]
 8019a72:	69ba      	ldr	r2, [r7, #24]
 8019a74:	605a      	str	r2, [r3, #4]
  return TRUE;
 8019a76:	2301      	movs	r3, #1
}
 8019a78:	4618      	mov	r0, r3
 8019a7a:	3720      	adds	r7, #32
 8019a7c:	46bd      	mov	sp, r7
 8019a7e:	bd80      	pop	{r7, pc}

08019a80 <examine_app0>:
	      unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP0.
 * Take appropriate action if it is a JFIF marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 8019a80:	b580      	push	{r7, lr}
 8019a82:	b086      	sub	sp, #24
 8019a84:	af00      	add	r7, sp, #0
 8019a86:	60f8      	str	r0, [r7, #12]
 8019a88:	60b9      	str	r1, [r7, #8]
 8019a8a:	607a      	str	r2, [r7, #4]
 8019a8c:	603b      	str	r3, [r7, #0]
  INT32 totallen = (INT32) datalen + remaining;
 8019a8e:	687b      	ldr	r3, [r7, #4]
 8019a90:	683a      	ldr	r2, [r7, #0]
 8019a92:	4413      	add	r3, r2
 8019a94:	617b      	str	r3, [r7, #20]

  if (datalen >= APP0_DATA_LEN &&
 8019a96:	687b      	ldr	r3, [r7, #4]
 8019a98:	2b0d      	cmp	r3, #13
 8019a9a:	f240 80d4 	bls.w	8019c46 <examine_app0+0x1c6>
      GETJOCTET(data[0]) == 0x4A &&
 8019a9e:	68bb      	ldr	r3, [r7, #8]
 8019aa0:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP0_DATA_LEN &&
 8019aa2:	2b4a      	cmp	r3, #74	@ 0x4a
 8019aa4:	f040 80cf 	bne.w	8019c46 <examine_app0+0x1c6>
      GETJOCTET(data[1]) == 0x46 &&
 8019aa8:	68bb      	ldr	r3, [r7, #8]
 8019aaa:	3301      	adds	r3, #1
 8019aac:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 8019aae:	2b46      	cmp	r3, #70	@ 0x46
 8019ab0:	f040 80c9 	bne.w	8019c46 <examine_app0+0x1c6>
      GETJOCTET(data[2]) == 0x49 &&
 8019ab4:	68bb      	ldr	r3, [r7, #8]
 8019ab6:	3302      	adds	r3, #2
 8019ab8:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 8019aba:	2b49      	cmp	r3, #73	@ 0x49
 8019abc:	f040 80c3 	bne.w	8019c46 <examine_app0+0x1c6>
      GETJOCTET(data[3]) == 0x46 &&
 8019ac0:	68bb      	ldr	r3, [r7, #8]
 8019ac2:	3303      	adds	r3, #3
 8019ac4:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x49 &&
 8019ac6:	2b46      	cmp	r3, #70	@ 0x46
 8019ac8:	f040 80bd 	bne.w	8019c46 <examine_app0+0x1c6>
      GETJOCTET(data[4]) == 0) {
 8019acc:	68bb      	ldr	r3, [r7, #8]
 8019ace:	3304      	adds	r3, #4
 8019ad0:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x46 &&
 8019ad2:	2b00      	cmp	r3, #0
 8019ad4:	f040 80b7 	bne.w	8019c46 <examine_app0+0x1c6>
    /* Found JFIF APP0 marker: save info */
    cinfo->saw_JFIF_marker = TRUE;
 8019ad8:	68fb      	ldr	r3, [r7, #12]
 8019ada:	2201      	movs	r2, #1
 8019adc:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
    cinfo->JFIF_major_version = GETJOCTET(data[5]);
 8019ae0:	68bb      	ldr	r3, [r7, #8]
 8019ae2:	795a      	ldrb	r2, [r3, #5]
 8019ae4:	68fb      	ldr	r3, [r7, #12]
 8019ae6:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
 8019aea:	68bb      	ldr	r3, [r7, #8]
 8019aec:	799a      	ldrb	r2, [r3, #6]
 8019aee:	68fb      	ldr	r3, [r7, #12]
 8019af0:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
    cinfo->density_unit = GETJOCTET(data[7]);
 8019af4:	68bb      	ldr	r3, [r7, #8]
 8019af6:	79da      	ldrb	r2, [r3, #7]
 8019af8:	68fb      	ldr	r3, [r7, #12]
 8019afa:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
 8019afe:	68bb      	ldr	r3, [r7, #8]
 8019b00:	3308      	adds	r3, #8
 8019b02:	781b      	ldrb	r3, [r3, #0]
 8019b04:	021b      	lsls	r3, r3, #8
 8019b06:	b29b      	uxth	r3, r3
 8019b08:	68ba      	ldr	r2, [r7, #8]
 8019b0a:	3209      	adds	r2, #9
 8019b0c:	7812      	ldrb	r2, [r2, #0]
 8019b0e:	4413      	add	r3, r2
 8019b10:	b29a      	uxth	r2, r3
 8019b12:	68fb      	ldr	r3, [r7, #12]
 8019b14:	f8a3 2124 	strh.w	r2, [r3, #292]	@ 0x124
    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
 8019b18:	68bb      	ldr	r3, [r7, #8]
 8019b1a:	330a      	adds	r3, #10
 8019b1c:	781b      	ldrb	r3, [r3, #0]
 8019b1e:	021b      	lsls	r3, r3, #8
 8019b20:	b29b      	uxth	r3, r3
 8019b22:	68ba      	ldr	r2, [r7, #8]
 8019b24:	320b      	adds	r2, #11
 8019b26:	7812      	ldrb	r2, [r2, #0]
 8019b28:	4413      	add	r3, r2
 8019b2a:	b29a      	uxth	r2, r3
 8019b2c:	68fb      	ldr	r3, [r7, #12]
 8019b2e:	f8a3 2126 	strh.w	r2, [r3, #294]	@ 0x126
     * Major version must be 1, anything else signals an incompatible change.
     * (We used to treat this as an error, but now it's a nonfatal warning,
     * because some bozo at Hijaak couldn't read the spec.)
     * Minor version should be 0..2, but process anyway if newer.
     */
    if (cinfo->JFIF_major_version != 1)
 8019b32:	68fb      	ldr	r3, [r7, #12]
 8019b34:	f893 3120 	ldrb.w	r3, [r3, #288]	@ 0x120
 8019b38:	2b01      	cmp	r3, #1
 8019b3a:	d016      	beq.n	8019b6a <examine_app0+0xea>
      WARNMS2(cinfo, JWRN_JFIF_MAJOR,
 8019b3c:	68fb      	ldr	r3, [r7, #12]
 8019b3e:	681b      	ldr	r3, [r3, #0]
 8019b40:	227a      	movs	r2, #122	@ 0x7a
 8019b42:	615a      	str	r2, [r3, #20]
 8019b44:	68fb      	ldr	r3, [r7, #12]
 8019b46:	f893 2120 	ldrb.w	r2, [r3, #288]	@ 0x120
 8019b4a:	68fb      	ldr	r3, [r7, #12]
 8019b4c:	681b      	ldr	r3, [r3, #0]
 8019b4e:	619a      	str	r2, [r3, #24]
 8019b50:	68fb      	ldr	r3, [r7, #12]
 8019b52:	f893 2121 	ldrb.w	r2, [r3, #289]	@ 0x121
 8019b56:	68fb      	ldr	r3, [r7, #12]
 8019b58:	681b      	ldr	r3, [r3, #0]
 8019b5a:	61da      	str	r2, [r3, #28]
 8019b5c:	68fb      	ldr	r3, [r7, #12]
 8019b5e:	681b      	ldr	r3, [r3, #0]
 8019b60:	685b      	ldr	r3, [r3, #4]
 8019b62:	f04f 31ff 	mov.w	r1, #4294967295
 8019b66:	68f8      	ldr	r0, [r7, #12]
 8019b68:	4798      	blx	r3
	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
    /* Generate trace messages */
    TRACEMS5(cinfo, 1, JTRC_JFIF,
 8019b6a:	68fb      	ldr	r3, [r7, #12]
 8019b6c:	681b      	ldr	r3, [r3, #0]
 8019b6e:	3318      	adds	r3, #24
 8019b70:	613b      	str	r3, [r7, #16]
 8019b72:	68fb      	ldr	r3, [r7, #12]
 8019b74:	f893 3120 	ldrb.w	r3, [r3, #288]	@ 0x120
 8019b78:	461a      	mov	r2, r3
 8019b7a:	693b      	ldr	r3, [r7, #16]
 8019b7c:	601a      	str	r2, [r3, #0]
 8019b7e:	68fb      	ldr	r3, [r7, #12]
 8019b80:	f893 2121 	ldrb.w	r2, [r3, #289]	@ 0x121
 8019b84:	693b      	ldr	r3, [r7, #16]
 8019b86:	3304      	adds	r3, #4
 8019b88:	601a      	str	r2, [r3, #0]
 8019b8a:	68fb      	ldr	r3, [r7, #12]
 8019b8c:	f8b3 2124 	ldrh.w	r2, [r3, #292]	@ 0x124
 8019b90:	693b      	ldr	r3, [r7, #16]
 8019b92:	3308      	adds	r3, #8
 8019b94:	601a      	str	r2, [r3, #0]
 8019b96:	68fb      	ldr	r3, [r7, #12]
 8019b98:	f8b3 2126 	ldrh.w	r2, [r3, #294]	@ 0x126
 8019b9c:	693b      	ldr	r3, [r7, #16]
 8019b9e:	330c      	adds	r3, #12
 8019ba0:	601a      	str	r2, [r3, #0]
 8019ba2:	68fb      	ldr	r3, [r7, #12]
 8019ba4:	f893 2122 	ldrb.w	r2, [r3, #290]	@ 0x122
 8019ba8:	693b      	ldr	r3, [r7, #16]
 8019baa:	3310      	adds	r3, #16
 8019bac:	601a      	str	r2, [r3, #0]
 8019bae:	68fb      	ldr	r3, [r7, #12]
 8019bb0:	681b      	ldr	r3, [r3, #0]
 8019bb2:	2259      	movs	r2, #89	@ 0x59
 8019bb4:	615a      	str	r2, [r3, #20]
 8019bb6:	68fb      	ldr	r3, [r7, #12]
 8019bb8:	681b      	ldr	r3, [r3, #0]
 8019bba:	685b      	ldr	r3, [r3, #4]
 8019bbc:	2101      	movs	r1, #1
 8019bbe:	68f8      	ldr	r0, [r7, #12]
 8019bc0:	4798      	blx	r3
	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
    /* Validate thumbnail dimensions and issue appropriate messages */
    if (GETJOCTET(data[12]) | GETJOCTET(data[13]))
 8019bc2:	68bb      	ldr	r3, [r7, #8]
 8019bc4:	330c      	adds	r3, #12
 8019bc6:	781a      	ldrb	r2, [r3, #0]
 8019bc8:	68bb      	ldr	r3, [r7, #8]
 8019bca:	330d      	adds	r3, #13
 8019bcc:	781b      	ldrb	r3, [r3, #0]
 8019bce:	4313      	orrs	r3, r2
 8019bd0:	b2db      	uxtb	r3, r3
 8019bd2:	2b00      	cmp	r3, #0
 8019bd4:	d015      	beq.n	8019c02 <examine_app0+0x182>
      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,
 8019bd6:	68fb      	ldr	r3, [r7, #12]
 8019bd8:	681b      	ldr	r3, [r3, #0]
 8019bda:	225c      	movs	r2, #92	@ 0x5c
 8019bdc:	615a      	str	r2, [r3, #20]
 8019bde:	68bb      	ldr	r3, [r7, #8]
 8019be0:	330c      	adds	r3, #12
 8019be2:	781a      	ldrb	r2, [r3, #0]
 8019be4:	68fb      	ldr	r3, [r7, #12]
 8019be6:	681b      	ldr	r3, [r3, #0]
 8019be8:	619a      	str	r2, [r3, #24]
 8019bea:	68bb      	ldr	r3, [r7, #8]
 8019bec:	330d      	adds	r3, #13
 8019bee:	781a      	ldrb	r2, [r3, #0]
 8019bf0:	68fb      	ldr	r3, [r7, #12]
 8019bf2:	681b      	ldr	r3, [r3, #0]
 8019bf4:	61da      	str	r2, [r3, #28]
 8019bf6:	68fb      	ldr	r3, [r7, #12]
 8019bf8:	681b      	ldr	r3, [r3, #0]
 8019bfa:	685b      	ldr	r3, [r3, #4]
 8019bfc:	2101      	movs	r1, #1
 8019bfe:	68f8      	ldr	r0, [r7, #12]
 8019c00:	4798      	blx	r3
	       GETJOCTET(data[12]), GETJOCTET(data[13]));
    totallen -= APP0_DATA_LEN;
 8019c02:	697b      	ldr	r3, [r7, #20]
 8019c04:	3b0e      	subs	r3, #14
 8019c06:	617b      	str	r3, [r7, #20]
    if (totallen !=
	((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))
 8019c08:	68bb      	ldr	r3, [r7, #8]
 8019c0a:	330c      	adds	r3, #12
 8019c0c:	781b      	ldrb	r3, [r3, #0]
 8019c0e:	461a      	mov	r2, r3
 8019c10:	68bb      	ldr	r3, [r7, #8]
 8019c12:	330d      	adds	r3, #13
 8019c14:	781b      	ldrb	r3, [r3, #0]
 8019c16:	fb03 f202 	mul.w	r2, r3, r2
 8019c1a:	4613      	mov	r3, r2
 8019c1c:	005b      	lsls	r3, r3, #1
 8019c1e:	4413      	add	r3, r2
    if (totallen !=
 8019c20:	697a      	ldr	r2, [r7, #20]
 8019c22:	429a      	cmp	r2, r3
 8019c24:	f000 8088 	beq.w	8019d38 <examine_app0+0x2b8>
      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);
 8019c28:	68fb      	ldr	r3, [r7, #12]
 8019c2a:	681b      	ldr	r3, [r3, #0]
 8019c2c:	225a      	movs	r2, #90	@ 0x5a
 8019c2e:	615a      	str	r2, [r3, #20]
 8019c30:	68fb      	ldr	r3, [r7, #12]
 8019c32:	681b      	ldr	r3, [r3, #0]
 8019c34:	697a      	ldr	r2, [r7, #20]
 8019c36:	619a      	str	r2, [r3, #24]
 8019c38:	68fb      	ldr	r3, [r7, #12]
 8019c3a:	681b      	ldr	r3, [r3, #0]
 8019c3c:	685b      	ldr	r3, [r3, #4]
 8019c3e:	2101      	movs	r1, #1
 8019c40:	68f8      	ldr	r0, [r7, #12]
 8019c42:	4798      	blx	r3
    if (totallen !=
 8019c44:	e078      	b.n	8019d38 <examine_app0+0x2b8>
  } else if (datalen >= 6 &&
 8019c46:	687b      	ldr	r3, [r7, #4]
 8019c48:	2b05      	cmp	r3, #5
 8019c4a:	d966      	bls.n	8019d1a <examine_app0+0x29a>
      GETJOCTET(data[0]) == 0x4A &&
 8019c4c:	68bb      	ldr	r3, [r7, #8]
 8019c4e:	781b      	ldrb	r3, [r3, #0]
  } else if (datalen >= 6 &&
 8019c50:	2b4a      	cmp	r3, #74	@ 0x4a
 8019c52:	d162      	bne.n	8019d1a <examine_app0+0x29a>
      GETJOCTET(data[1]) == 0x46 &&
 8019c54:	68bb      	ldr	r3, [r7, #8]
 8019c56:	3301      	adds	r3, #1
 8019c58:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 8019c5a:	2b46      	cmp	r3, #70	@ 0x46
 8019c5c:	d15d      	bne.n	8019d1a <examine_app0+0x29a>
      GETJOCTET(data[2]) == 0x58 &&
 8019c5e:	68bb      	ldr	r3, [r7, #8]
 8019c60:	3302      	adds	r3, #2
 8019c62:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 8019c64:	2b58      	cmp	r3, #88	@ 0x58
 8019c66:	d158      	bne.n	8019d1a <examine_app0+0x29a>
      GETJOCTET(data[3]) == 0x58 &&
 8019c68:	68bb      	ldr	r3, [r7, #8]
 8019c6a:	3303      	adds	r3, #3
 8019c6c:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x58 &&
 8019c6e:	2b58      	cmp	r3, #88	@ 0x58
 8019c70:	d153      	bne.n	8019d1a <examine_app0+0x29a>
      GETJOCTET(data[4]) == 0) {
 8019c72:	68bb      	ldr	r3, [r7, #8]
 8019c74:	3304      	adds	r3, #4
 8019c76:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x58 &&
 8019c78:	2b00      	cmp	r3, #0
 8019c7a:	d14e      	bne.n	8019d1a <examine_app0+0x29a>
    /* Found JFIF "JFXX" extension APP0 marker */
    /* The library doesn't actually do anything with these,
     * but we try to produce a helpful trace message.
     */
    switch (GETJOCTET(data[5])) {
 8019c7c:	68bb      	ldr	r3, [r7, #8]
 8019c7e:	3305      	adds	r3, #5
 8019c80:	781b      	ldrb	r3, [r3, #0]
 8019c82:	2b13      	cmp	r3, #19
 8019c84:	d024      	beq.n	8019cd0 <examine_app0+0x250>
 8019c86:	2b13      	cmp	r3, #19
 8019c88:	dc31      	bgt.n	8019cee <examine_app0+0x26e>
 8019c8a:	2b10      	cmp	r3, #16
 8019c8c:	d002      	beq.n	8019c94 <examine_app0+0x214>
 8019c8e:	2b11      	cmp	r3, #17
 8019c90:	d00f      	beq.n	8019cb2 <examine_app0+0x232>
 8019c92:	e02c      	b.n	8019cee <examine_app0+0x26e>
    case 0x10:
      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
 8019c94:	68fb      	ldr	r3, [r7, #12]
 8019c96:	681b      	ldr	r3, [r3, #0]
 8019c98:	226e      	movs	r2, #110	@ 0x6e
 8019c9a:	615a      	str	r2, [r3, #20]
 8019c9c:	68fb      	ldr	r3, [r7, #12]
 8019c9e:	681b      	ldr	r3, [r3, #0]
 8019ca0:	697a      	ldr	r2, [r7, #20]
 8019ca2:	619a      	str	r2, [r3, #24]
 8019ca4:	68fb      	ldr	r3, [r7, #12]
 8019ca6:	681b      	ldr	r3, [r3, #0]
 8019ca8:	685b      	ldr	r3, [r3, #4]
 8019caa:	2101      	movs	r1, #1
 8019cac:	68f8      	ldr	r0, [r7, #12]
 8019cae:	4798      	blx	r3
      break;
 8019cb0:	e032      	b.n	8019d18 <examine_app0+0x298>
    case 0x11:
      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
 8019cb2:	68fb      	ldr	r3, [r7, #12]
 8019cb4:	681b      	ldr	r3, [r3, #0]
 8019cb6:	226f      	movs	r2, #111	@ 0x6f
 8019cb8:	615a      	str	r2, [r3, #20]
 8019cba:	68fb      	ldr	r3, [r7, #12]
 8019cbc:	681b      	ldr	r3, [r3, #0]
 8019cbe:	697a      	ldr	r2, [r7, #20]
 8019cc0:	619a      	str	r2, [r3, #24]
 8019cc2:	68fb      	ldr	r3, [r7, #12]
 8019cc4:	681b      	ldr	r3, [r3, #0]
 8019cc6:	685b      	ldr	r3, [r3, #4]
 8019cc8:	2101      	movs	r1, #1
 8019cca:	68f8      	ldr	r0, [r7, #12]
 8019ccc:	4798      	blx	r3
      break;
 8019cce:	e023      	b.n	8019d18 <examine_app0+0x298>
    case 0x13:
      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
 8019cd0:	68fb      	ldr	r3, [r7, #12]
 8019cd2:	681b      	ldr	r3, [r3, #0]
 8019cd4:	2270      	movs	r2, #112	@ 0x70
 8019cd6:	615a      	str	r2, [r3, #20]
 8019cd8:	68fb      	ldr	r3, [r7, #12]
 8019cda:	681b      	ldr	r3, [r3, #0]
 8019cdc:	697a      	ldr	r2, [r7, #20]
 8019cde:	619a      	str	r2, [r3, #24]
 8019ce0:	68fb      	ldr	r3, [r7, #12]
 8019ce2:	681b      	ldr	r3, [r3, #0]
 8019ce4:	685b      	ldr	r3, [r3, #4]
 8019ce6:	2101      	movs	r1, #1
 8019ce8:	68f8      	ldr	r0, [r7, #12]
 8019cea:	4798      	blx	r3
      break;
 8019cec:	e014      	b.n	8019d18 <examine_app0+0x298>
    default:
      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
 8019cee:	68fb      	ldr	r3, [r7, #12]
 8019cf0:	681b      	ldr	r3, [r3, #0]
 8019cf2:	225b      	movs	r2, #91	@ 0x5b
 8019cf4:	615a      	str	r2, [r3, #20]
 8019cf6:	68bb      	ldr	r3, [r7, #8]
 8019cf8:	3305      	adds	r3, #5
 8019cfa:	781a      	ldrb	r2, [r3, #0]
 8019cfc:	68fb      	ldr	r3, [r7, #12]
 8019cfe:	681b      	ldr	r3, [r3, #0]
 8019d00:	619a      	str	r2, [r3, #24]
 8019d02:	68fb      	ldr	r3, [r7, #12]
 8019d04:	681b      	ldr	r3, [r3, #0]
 8019d06:	697a      	ldr	r2, [r7, #20]
 8019d08:	61da      	str	r2, [r3, #28]
 8019d0a:	68fb      	ldr	r3, [r7, #12]
 8019d0c:	681b      	ldr	r3, [r3, #0]
 8019d0e:	685b      	ldr	r3, [r3, #4]
 8019d10:	2101      	movs	r1, #1
 8019d12:	68f8      	ldr	r0, [r7, #12]
 8019d14:	4798      	blx	r3
	       GETJOCTET(data[5]), (int) totallen);
      break;
 8019d16:	bf00      	nop
    switch (GETJOCTET(data[5])) {
 8019d18:	e00e      	b.n	8019d38 <examine_app0+0x2b8>
    }
  } else {
    /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
 8019d1a:	68fb      	ldr	r3, [r7, #12]
 8019d1c:	681b      	ldr	r3, [r3, #0]
 8019d1e:	224f      	movs	r2, #79	@ 0x4f
 8019d20:	615a      	str	r2, [r3, #20]
 8019d22:	68fb      	ldr	r3, [r7, #12]
 8019d24:	681b      	ldr	r3, [r3, #0]
 8019d26:	697a      	ldr	r2, [r7, #20]
 8019d28:	619a      	str	r2, [r3, #24]
 8019d2a:	68fb      	ldr	r3, [r7, #12]
 8019d2c:	681b      	ldr	r3, [r3, #0]
 8019d2e:	685b      	ldr	r3, [r3, #4]
 8019d30:	2101      	movs	r1, #1
 8019d32:	68f8      	ldr	r0, [r7, #12]
 8019d34:	4798      	blx	r3
  }
}
 8019d36:	bf00      	nop
 8019d38:	bf00      	nop
 8019d3a:	3718      	adds	r7, #24
 8019d3c:	46bd      	mov	sp, r7
 8019d3e:	bd80      	pop	{r7, pc}

08019d40 <examine_app14>:
	       unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP14.
 * Take appropriate action if it is an Adobe marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 8019d40:	b580      	push	{r7, lr}
 8019d42:	b08a      	sub	sp, #40	@ 0x28
 8019d44:	af00      	add	r7, sp, #0
 8019d46:	60f8      	str	r0, [r7, #12]
 8019d48:	60b9      	str	r1, [r7, #8]
 8019d4a:	607a      	str	r2, [r7, #4]
 8019d4c:	603b      	str	r3, [r7, #0]
  unsigned int version, flags0, flags1, transform;

  if (datalen >= APP14_DATA_LEN &&
 8019d4e:	687b      	ldr	r3, [r7, #4]
 8019d50:	2b0b      	cmp	r3, #11
 8019d52:	d95d      	bls.n	8019e10 <examine_app14+0xd0>
      GETJOCTET(data[0]) == 0x41 &&
 8019d54:	68bb      	ldr	r3, [r7, #8]
 8019d56:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP14_DATA_LEN &&
 8019d58:	2b41      	cmp	r3, #65	@ 0x41
 8019d5a:	d159      	bne.n	8019e10 <examine_app14+0xd0>
      GETJOCTET(data[1]) == 0x64 &&
 8019d5c:	68bb      	ldr	r3, [r7, #8]
 8019d5e:	3301      	adds	r3, #1
 8019d60:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x41 &&
 8019d62:	2b64      	cmp	r3, #100	@ 0x64
 8019d64:	d154      	bne.n	8019e10 <examine_app14+0xd0>
      GETJOCTET(data[2]) == 0x6F &&
 8019d66:	68bb      	ldr	r3, [r7, #8]
 8019d68:	3302      	adds	r3, #2
 8019d6a:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x64 &&
 8019d6c:	2b6f      	cmp	r3, #111	@ 0x6f
 8019d6e:	d14f      	bne.n	8019e10 <examine_app14+0xd0>
      GETJOCTET(data[3]) == 0x62 &&
 8019d70:	68bb      	ldr	r3, [r7, #8]
 8019d72:	3303      	adds	r3, #3
 8019d74:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x6F &&
 8019d76:	2b62      	cmp	r3, #98	@ 0x62
 8019d78:	d14a      	bne.n	8019e10 <examine_app14+0xd0>
      GETJOCTET(data[4]) == 0x65) {
 8019d7a:	68bb      	ldr	r3, [r7, #8]
 8019d7c:	3304      	adds	r3, #4
 8019d7e:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x62 &&
 8019d80:	2b65      	cmp	r3, #101	@ 0x65
 8019d82:	d145      	bne.n	8019e10 <examine_app14+0xd0>
    /* Found Adobe APP14 marker */
    version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
 8019d84:	68bb      	ldr	r3, [r7, #8]
 8019d86:	3305      	adds	r3, #5
 8019d88:	781b      	ldrb	r3, [r3, #0]
 8019d8a:	021b      	lsls	r3, r3, #8
 8019d8c:	68ba      	ldr	r2, [r7, #8]
 8019d8e:	3206      	adds	r2, #6
 8019d90:	7812      	ldrb	r2, [r2, #0]
 8019d92:	4413      	add	r3, r2
 8019d94:	627b      	str	r3, [r7, #36]	@ 0x24
    flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
 8019d96:	68bb      	ldr	r3, [r7, #8]
 8019d98:	3307      	adds	r3, #7
 8019d9a:	781b      	ldrb	r3, [r3, #0]
 8019d9c:	021b      	lsls	r3, r3, #8
 8019d9e:	68ba      	ldr	r2, [r7, #8]
 8019da0:	3208      	adds	r2, #8
 8019da2:	7812      	ldrb	r2, [r2, #0]
 8019da4:	4413      	add	r3, r2
 8019da6:	623b      	str	r3, [r7, #32]
    flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
 8019da8:	68bb      	ldr	r3, [r7, #8]
 8019daa:	3309      	adds	r3, #9
 8019dac:	781b      	ldrb	r3, [r3, #0]
 8019dae:	021b      	lsls	r3, r3, #8
 8019db0:	68ba      	ldr	r2, [r7, #8]
 8019db2:	320a      	adds	r2, #10
 8019db4:	7812      	ldrb	r2, [r2, #0]
 8019db6:	4413      	add	r3, r2
 8019db8:	61fb      	str	r3, [r7, #28]
    transform = GETJOCTET(data[11]);
 8019dba:	68bb      	ldr	r3, [r7, #8]
 8019dbc:	330b      	adds	r3, #11
 8019dbe:	781b      	ldrb	r3, [r3, #0]
 8019dc0:	61bb      	str	r3, [r7, #24]
    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
 8019dc2:	68fb      	ldr	r3, [r7, #12]
 8019dc4:	681b      	ldr	r3, [r3, #0]
 8019dc6:	3318      	adds	r3, #24
 8019dc8:	617b      	str	r3, [r7, #20]
 8019dca:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019dcc:	697b      	ldr	r3, [r7, #20]
 8019dce:	601a      	str	r2, [r3, #0]
 8019dd0:	697b      	ldr	r3, [r7, #20]
 8019dd2:	3304      	adds	r3, #4
 8019dd4:	6a3a      	ldr	r2, [r7, #32]
 8019dd6:	601a      	str	r2, [r3, #0]
 8019dd8:	697b      	ldr	r3, [r7, #20]
 8019dda:	3308      	adds	r3, #8
 8019ddc:	69fa      	ldr	r2, [r7, #28]
 8019dde:	601a      	str	r2, [r3, #0]
 8019de0:	697b      	ldr	r3, [r7, #20]
 8019de2:	330c      	adds	r3, #12
 8019de4:	69ba      	ldr	r2, [r7, #24]
 8019de6:	601a      	str	r2, [r3, #0]
 8019de8:	68fb      	ldr	r3, [r7, #12]
 8019dea:	681b      	ldr	r3, [r3, #0]
 8019dec:	224e      	movs	r2, #78	@ 0x4e
 8019dee:	615a      	str	r2, [r3, #20]
 8019df0:	68fb      	ldr	r3, [r7, #12]
 8019df2:	681b      	ldr	r3, [r3, #0]
 8019df4:	685b      	ldr	r3, [r3, #4]
 8019df6:	2101      	movs	r1, #1
 8019df8:	68f8      	ldr	r0, [r7, #12]
 8019dfa:	4798      	blx	r3
    cinfo->saw_Adobe_marker = TRUE;
 8019dfc:	68fb      	ldr	r3, [r7, #12]
 8019dfe:	2201      	movs	r2, #1
 8019e00:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
    cinfo->Adobe_transform = (UINT8) transform;
 8019e04:	69bb      	ldr	r3, [r7, #24]
 8019e06:	b2da      	uxtb	r2, r3
 8019e08:	68fb      	ldr	r3, [r7, #12]
 8019e0a:	f883 212c 	strb.w	r2, [r3, #300]	@ 0x12c
 8019e0e:	e010      	b.n	8019e32 <examine_app14+0xf2>
  } else {
    /* Start of APP14 does not match "Adobe", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));
 8019e10:	68fb      	ldr	r3, [r7, #12]
 8019e12:	681b      	ldr	r3, [r3, #0]
 8019e14:	2250      	movs	r2, #80	@ 0x50
 8019e16:	615a      	str	r2, [r3, #20]
 8019e18:	683a      	ldr	r2, [r7, #0]
 8019e1a:	687b      	ldr	r3, [r7, #4]
 8019e1c:	441a      	add	r2, r3
 8019e1e:	68fb      	ldr	r3, [r7, #12]
 8019e20:	681b      	ldr	r3, [r3, #0]
 8019e22:	619a      	str	r2, [r3, #24]
 8019e24:	68fb      	ldr	r3, [r7, #12]
 8019e26:	681b      	ldr	r3, [r3, #0]
 8019e28:	685b      	ldr	r3, [r3, #4]
 8019e2a:	2101      	movs	r1, #1
 8019e2c:	68f8      	ldr	r0, [r7, #12]
 8019e2e:	4798      	blx	r3
  }
}
 8019e30:	bf00      	nop
 8019e32:	bf00      	nop
 8019e34:	3728      	adds	r7, #40	@ 0x28
 8019e36:	46bd      	mov	sp, r7
 8019e38:	bd80      	pop	{r7, pc}

08019e3a <get_interesting_appn>:


METHODDEF(boolean)
get_interesting_appn (j_decompress_ptr cinfo)
/* Process an APP0 or APP14 marker without saving it */
{
 8019e3a:	b580      	push	{r7, lr}
 8019e3c:	b08c      	sub	sp, #48	@ 0x30
 8019e3e:	af00      	add	r7, sp, #0
 8019e40:	6078      	str	r0, [r7, #4]
  INT32 length;
  JOCTET b[APPN_DATA_LEN];
  unsigned int i, numtoread;
  INPUT_VARS(cinfo);
 8019e42:	687b      	ldr	r3, [r7, #4]
 8019e44:	699b      	ldr	r3, [r3, #24]
 8019e46:	61fb      	str	r3, [r7, #28]
 8019e48:	69fb      	ldr	r3, [r7, #28]
 8019e4a:	681b      	ldr	r3, [r3, #0]
 8019e4c:	627b      	str	r3, [r7, #36]	@ 0x24
 8019e4e:	69fb      	ldr	r3, [r7, #28]
 8019e50:	685b      	ldr	r3, [r3, #4]
 8019e52:	623b      	str	r3, [r7, #32]

  INPUT_2BYTES(cinfo, length, return FALSE);
 8019e54:	6a3b      	ldr	r3, [r7, #32]
 8019e56:	2b00      	cmp	r3, #0
 8019e58:	d10e      	bne.n	8019e78 <get_interesting_appn+0x3e>
 8019e5a:	69fb      	ldr	r3, [r7, #28]
 8019e5c:	68db      	ldr	r3, [r3, #12]
 8019e5e:	6878      	ldr	r0, [r7, #4]
 8019e60:	4798      	blx	r3
 8019e62:	4603      	mov	r3, r0
 8019e64:	2b00      	cmp	r3, #0
 8019e66:	d101      	bne.n	8019e6c <get_interesting_appn+0x32>
 8019e68:	2300      	movs	r3, #0
 8019e6a:	e0a1      	b.n	8019fb0 <get_interesting_appn+0x176>
 8019e6c:	69fb      	ldr	r3, [r7, #28]
 8019e6e:	681b      	ldr	r3, [r3, #0]
 8019e70:	627b      	str	r3, [r7, #36]	@ 0x24
 8019e72:	69fb      	ldr	r3, [r7, #28]
 8019e74:	685b      	ldr	r3, [r3, #4]
 8019e76:	623b      	str	r3, [r7, #32]
 8019e78:	6a3b      	ldr	r3, [r7, #32]
 8019e7a:	3b01      	subs	r3, #1
 8019e7c:	623b      	str	r3, [r7, #32]
 8019e7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019e80:	1c5a      	adds	r2, r3, #1
 8019e82:	627a      	str	r2, [r7, #36]	@ 0x24
 8019e84:	781b      	ldrb	r3, [r3, #0]
 8019e86:	021b      	lsls	r3, r3, #8
 8019e88:	61bb      	str	r3, [r7, #24]
 8019e8a:	6a3b      	ldr	r3, [r7, #32]
 8019e8c:	2b00      	cmp	r3, #0
 8019e8e:	d10e      	bne.n	8019eae <get_interesting_appn+0x74>
 8019e90:	69fb      	ldr	r3, [r7, #28]
 8019e92:	68db      	ldr	r3, [r3, #12]
 8019e94:	6878      	ldr	r0, [r7, #4]
 8019e96:	4798      	blx	r3
 8019e98:	4603      	mov	r3, r0
 8019e9a:	2b00      	cmp	r3, #0
 8019e9c:	d101      	bne.n	8019ea2 <get_interesting_appn+0x68>
 8019e9e:	2300      	movs	r3, #0
 8019ea0:	e086      	b.n	8019fb0 <get_interesting_appn+0x176>
 8019ea2:	69fb      	ldr	r3, [r7, #28]
 8019ea4:	681b      	ldr	r3, [r3, #0]
 8019ea6:	627b      	str	r3, [r7, #36]	@ 0x24
 8019ea8:	69fb      	ldr	r3, [r7, #28]
 8019eaa:	685b      	ldr	r3, [r3, #4]
 8019eac:	623b      	str	r3, [r7, #32]
 8019eae:	6a3b      	ldr	r3, [r7, #32]
 8019eb0:	3b01      	subs	r3, #1
 8019eb2:	623b      	str	r3, [r7, #32]
 8019eb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019eb6:	1c5a      	adds	r2, r3, #1
 8019eb8:	627a      	str	r2, [r7, #36]	@ 0x24
 8019eba:	781b      	ldrb	r3, [r3, #0]
 8019ebc:	461a      	mov	r2, r3
 8019ebe:	69bb      	ldr	r3, [r7, #24]
 8019ec0:	4413      	add	r3, r2
 8019ec2:	61bb      	str	r3, [r7, #24]
  length -= 2;
 8019ec4:	69bb      	ldr	r3, [r7, #24]
 8019ec6:	3b02      	subs	r3, #2
 8019ec8:	61bb      	str	r3, [r7, #24]

  /* get the interesting part of the marker data */
  if (length >= APPN_DATA_LEN)
 8019eca:	69bb      	ldr	r3, [r7, #24]
 8019ecc:	2b0d      	cmp	r3, #13
 8019ece:	dd02      	ble.n	8019ed6 <get_interesting_appn+0x9c>
    numtoread = APPN_DATA_LEN;
 8019ed0:	230e      	movs	r3, #14
 8019ed2:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019ed4:	e007      	b.n	8019ee6 <get_interesting_appn+0xac>
  else if (length > 0)
 8019ed6:	69bb      	ldr	r3, [r7, #24]
 8019ed8:	2b00      	cmp	r3, #0
 8019eda:	dd02      	ble.n	8019ee2 <get_interesting_appn+0xa8>
    numtoread = (unsigned int) length;
 8019edc:	69bb      	ldr	r3, [r7, #24]
 8019ede:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019ee0:	e001      	b.n	8019ee6 <get_interesting_appn+0xac>
  else
    numtoread = 0;
 8019ee2:	2300      	movs	r3, #0
 8019ee4:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = 0; i < numtoread; i++)
 8019ee6:	2300      	movs	r3, #0
 8019ee8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019eea:	e021      	b.n	8019f30 <get_interesting_appn+0xf6>
    INPUT_BYTE(cinfo, b[i], return FALSE);
 8019eec:	6a3b      	ldr	r3, [r7, #32]
 8019eee:	2b00      	cmp	r3, #0
 8019ef0:	d10e      	bne.n	8019f10 <get_interesting_appn+0xd6>
 8019ef2:	69fb      	ldr	r3, [r7, #28]
 8019ef4:	68db      	ldr	r3, [r3, #12]
 8019ef6:	6878      	ldr	r0, [r7, #4]
 8019ef8:	4798      	blx	r3
 8019efa:	4603      	mov	r3, r0
 8019efc:	2b00      	cmp	r3, #0
 8019efe:	d101      	bne.n	8019f04 <get_interesting_appn+0xca>
 8019f00:	2300      	movs	r3, #0
 8019f02:	e055      	b.n	8019fb0 <get_interesting_appn+0x176>
 8019f04:	69fb      	ldr	r3, [r7, #28]
 8019f06:	681b      	ldr	r3, [r3, #0]
 8019f08:	627b      	str	r3, [r7, #36]	@ 0x24
 8019f0a:	69fb      	ldr	r3, [r7, #28]
 8019f0c:	685b      	ldr	r3, [r3, #4]
 8019f0e:	623b      	str	r3, [r7, #32]
 8019f10:	6a3b      	ldr	r3, [r7, #32]
 8019f12:	3b01      	subs	r3, #1
 8019f14:	623b      	str	r3, [r7, #32]
 8019f16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019f18:	1c5a      	adds	r2, r3, #1
 8019f1a:	627a      	str	r2, [r7, #36]	@ 0x24
 8019f1c:	7819      	ldrb	r1, [r3, #0]
 8019f1e:	f107 0208 	add.w	r2, r7, #8
 8019f22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f24:	4413      	add	r3, r2
 8019f26:	460a      	mov	r2, r1
 8019f28:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numtoread; i++)
 8019f2a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f2c:	3301      	adds	r3, #1
 8019f2e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8019f30:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019f32:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019f34:	429a      	cmp	r2, r3
 8019f36:	d3d9      	bcc.n	8019eec <get_interesting_appn+0xb2>
  length -= numtoread;
 8019f38:	69ba      	ldr	r2, [r7, #24]
 8019f3a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019f3c:	1ad3      	subs	r3, r2, r3
 8019f3e:	61bb      	str	r3, [r7, #24]

  /* process it */
  switch (cinfo->unread_marker) {
 8019f40:	687b      	ldr	r3, [r7, #4]
 8019f42:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 8019f46:	2be0      	cmp	r3, #224	@ 0xe0
 8019f48:	d002      	beq.n	8019f50 <get_interesting_appn+0x116>
 8019f4a:	2bee      	cmp	r3, #238	@ 0xee
 8019f4c:	d008      	beq.n	8019f60 <get_interesting_appn+0x126>
 8019f4e:	e00f      	b.n	8019f70 <get_interesting_appn+0x136>
  case M_APP0:
    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
 8019f50:	f107 0108 	add.w	r1, r7, #8
 8019f54:	69bb      	ldr	r3, [r7, #24]
 8019f56:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8019f58:	6878      	ldr	r0, [r7, #4]
 8019f5a:	f7ff fd91 	bl	8019a80 <examine_app0>
    break;
 8019f5e:	e017      	b.n	8019f90 <get_interesting_appn+0x156>
  case M_APP14:
    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
 8019f60:	f107 0108 	add.w	r1, r7, #8
 8019f64:	69bb      	ldr	r3, [r7, #24]
 8019f66:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8019f68:	6878      	ldr	r0, [r7, #4]
 8019f6a:	f7ff fee9 	bl	8019d40 <examine_app14>
    break;
 8019f6e:	e00f      	b.n	8019f90 <get_interesting_appn+0x156>
  default:
    /* can't get here unless jpeg_save_markers chooses wrong processor */
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 8019f70:	687b      	ldr	r3, [r7, #4]
 8019f72:	681b      	ldr	r3, [r3, #0]
 8019f74:	2246      	movs	r2, #70	@ 0x46
 8019f76:	615a      	str	r2, [r3, #20]
 8019f78:	687b      	ldr	r3, [r7, #4]
 8019f7a:	681b      	ldr	r3, [r3, #0]
 8019f7c:	687a      	ldr	r2, [r7, #4]
 8019f7e:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 8019f82:	619a      	str	r2, [r3, #24]
 8019f84:	687b      	ldr	r3, [r7, #4]
 8019f86:	681b      	ldr	r3, [r3, #0]
 8019f88:	681b      	ldr	r3, [r3, #0]
 8019f8a:	6878      	ldr	r0, [r7, #4]
 8019f8c:	4798      	blx	r3
    break;
 8019f8e:	bf00      	nop
  }

  /* skip any remaining data -- could be lots */
  INPUT_SYNC(cinfo);
 8019f90:	69fb      	ldr	r3, [r7, #28]
 8019f92:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019f94:	601a      	str	r2, [r3, #0]
 8019f96:	69fb      	ldr	r3, [r7, #28]
 8019f98:	6a3a      	ldr	r2, [r7, #32]
 8019f9a:	605a      	str	r2, [r3, #4]
  if (length > 0)
 8019f9c:	69bb      	ldr	r3, [r7, #24]
 8019f9e:	2b00      	cmp	r3, #0
 8019fa0:	dd05      	ble.n	8019fae <get_interesting_appn+0x174>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 8019fa2:	687b      	ldr	r3, [r7, #4]
 8019fa4:	699b      	ldr	r3, [r3, #24]
 8019fa6:	691b      	ldr	r3, [r3, #16]
 8019fa8:	69b9      	ldr	r1, [r7, #24]
 8019faa:	6878      	ldr	r0, [r7, #4]
 8019fac:	4798      	blx	r3

  return TRUE;
 8019fae:	2301      	movs	r3, #1
}
 8019fb0:	4618      	mov	r0, r3
 8019fb2:	3730      	adds	r7, #48	@ 0x30
 8019fb4:	46bd      	mov	sp, r7
 8019fb6:	bd80      	pop	{r7, pc}

08019fb8 <skip_variable>:


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
 8019fb8:	b580      	push	{r7, lr}
 8019fba:	b086      	sub	sp, #24
 8019fbc:	af00      	add	r7, sp, #0
 8019fbe:	6078      	str	r0, [r7, #4]
  INT32 length;
  INPUT_VARS(cinfo);
 8019fc0:	687b      	ldr	r3, [r7, #4]
 8019fc2:	699b      	ldr	r3, [r3, #24]
 8019fc4:	60fb      	str	r3, [r7, #12]
 8019fc6:	68fb      	ldr	r3, [r7, #12]
 8019fc8:	681b      	ldr	r3, [r3, #0]
 8019fca:	617b      	str	r3, [r7, #20]
 8019fcc:	68fb      	ldr	r3, [r7, #12]
 8019fce:	685b      	ldr	r3, [r3, #4]
 8019fd0:	613b      	str	r3, [r7, #16]

  INPUT_2BYTES(cinfo, length, return FALSE);
 8019fd2:	693b      	ldr	r3, [r7, #16]
 8019fd4:	2b00      	cmp	r3, #0
 8019fd6:	d10e      	bne.n	8019ff6 <skip_variable+0x3e>
 8019fd8:	68fb      	ldr	r3, [r7, #12]
 8019fda:	68db      	ldr	r3, [r3, #12]
 8019fdc:	6878      	ldr	r0, [r7, #4]
 8019fde:	4798      	blx	r3
 8019fe0:	4603      	mov	r3, r0
 8019fe2:	2b00      	cmp	r3, #0
 8019fe4:	d101      	bne.n	8019fea <skip_variable+0x32>
 8019fe6:	2300      	movs	r3, #0
 8019fe8:	e052      	b.n	801a090 <skip_variable+0xd8>
 8019fea:	68fb      	ldr	r3, [r7, #12]
 8019fec:	681b      	ldr	r3, [r3, #0]
 8019fee:	617b      	str	r3, [r7, #20]
 8019ff0:	68fb      	ldr	r3, [r7, #12]
 8019ff2:	685b      	ldr	r3, [r3, #4]
 8019ff4:	613b      	str	r3, [r7, #16]
 8019ff6:	693b      	ldr	r3, [r7, #16]
 8019ff8:	3b01      	subs	r3, #1
 8019ffa:	613b      	str	r3, [r7, #16]
 8019ffc:	697b      	ldr	r3, [r7, #20]
 8019ffe:	1c5a      	adds	r2, r3, #1
 801a000:	617a      	str	r2, [r7, #20]
 801a002:	781b      	ldrb	r3, [r3, #0]
 801a004:	021b      	lsls	r3, r3, #8
 801a006:	60bb      	str	r3, [r7, #8]
 801a008:	693b      	ldr	r3, [r7, #16]
 801a00a:	2b00      	cmp	r3, #0
 801a00c:	d10e      	bne.n	801a02c <skip_variable+0x74>
 801a00e:	68fb      	ldr	r3, [r7, #12]
 801a010:	68db      	ldr	r3, [r3, #12]
 801a012:	6878      	ldr	r0, [r7, #4]
 801a014:	4798      	blx	r3
 801a016:	4603      	mov	r3, r0
 801a018:	2b00      	cmp	r3, #0
 801a01a:	d101      	bne.n	801a020 <skip_variable+0x68>
 801a01c:	2300      	movs	r3, #0
 801a01e:	e037      	b.n	801a090 <skip_variable+0xd8>
 801a020:	68fb      	ldr	r3, [r7, #12]
 801a022:	681b      	ldr	r3, [r3, #0]
 801a024:	617b      	str	r3, [r7, #20]
 801a026:	68fb      	ldr	r3, [r7, #12]
 801a028:	685b      	ldr	r3, [r3, #4]
 801a02a:	613b      	str	r3, [r7, #16]
 801a02c:	693b      	ldr	r3, [r7, #16]
 801a02e:	3b01      	subs	r3, #1
 801a030:	613b      	str	r3, [r7, #16]
 801a032:	697b      	ldr	r3, [r7, #20]
 801a034:	1c5a      	adds	r2, r3, #1
 801a036:	617a      	str	r2, [r7, #20]
 801a038:	781b      	ldrb	r3, [r3, #0]
 801a03a:	461a      	mov	r2, r3
 801a03c:	68bb      	ldr	r3, [r7, #8]
 801a03e:	4413      	add	r3, r2
 801a040:	60bb      	str	r3, [r7, #8]
  length -= 2;
 801a042:	68bb      	ldr	r3, [r7, #8]
 801a044:	3b02      	subs	r3, #2
 801a046:	60bb      	str	r3, [r7, #8]
  
  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
 801a048:	687b      	ldr	r3, [r7, #4]
 801a04a:	681b      	ldr	r3, [r3, #0]
 801a04c:	225d      	movs	r2, #93	@ 0x5d
 801a04e:	615a      	str	r2, [r3, #20]
 801a050:	687b      	ldr	r3, [r7, #4]
 801a052:	681b      	ldr	r3, [r3, #0]
 801a054:	687a      	ldr	r2, [r7, #4]
 801a056:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801a05a:	619a      	str	r2, [r3, #24]
 801a05c:	687b      	ldr	r3, [r7, #4]
 801a05e:	681b      	ldr	r3, [r3, #0]
 801a060:	68ba      	ldr	r2, [r7, #8]
 801a062:	61da      	str	r2, [r3, #28]
 801a064:	687b      	ldr	r3, [r7, #4]
 801a066:	681b      	ldr	r3, [r3, #0]
 801a068:	685b      	ldr	r3, [r3, #4]
 801a06a:	2101      	movs	r1, #1
 801a06c:	6878      	ldr	r0, [r7, #4]
 801a06e:	4798      	blx	r3

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
 801a070:	68fb      	ldr	r3, [r7, #12]
 801a072:	697a      	ldr	r2, [r7, #20]
 801a074:	601a      	str	r2, [r3, #0]
 801a076:	68fb      	ldr	r3, [r7, #12]
 801a078:	693a      	ldr	r2, [r7, #16]
 801a07a:	605a      	str	r2, [r3, #4]
  if (length > 0)
 801a07c:	68bb      	ldr	r3, [r7, #8]
 801a07e:	2b00      	cmp	r3, #0
 801a080:	dd05      	ble.n	801a08e <skip_variable+0xd6>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 801a082:	687b      	ldr	r3, [r7, #4]
 801a084:	699b      	ldr	r3, [r3, #24]
 801a086:	691b      	ldr	r3, [r3, #16]
 801a088:	68b9      	ldr	r1, [r7, #8]
 801a08a:	6878      	ldr	r0, [r7, #4]
 801a08c:	4798      	blx	r3

  return TRUE;
 801a08e:	2301      	movs	r3, #1
}
 801a090:	4618      	mov	r0, r3
 801a092:	3718      	adds	r7, #24
 801a094:	46bd      	mov	sp, r7
 801a096:	bd80      	pop	{r7, pc}

0801a098 <next_marker>:
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
 801a098:	b580      	push	{r7, lr}
 801a09a:	b086      	sub	sp, #24
 801a09c:	af00      	add	r7, sp, #0
 801a09e:	6078      	str	r0, [r7, #4]
  int c;
  INPUT_VARS(cinfo);
 801a0a0:	687b      	ldr	r3, [r7, #4]
 801a0a2:	699b      	ldr	r3, [r3, #24]
 801a0a4:	60bb      	str	r3, [r7, #8]
 801a0a6:	68bb      	ldr	r3, [r7, #8]
 801a0a8:	681b      	ldr	r3, [r3, #0]
 801a0aa:	613b      	str	r3, [r7, #16]
 801a0ac:	68bb      	ldr	r3, [r7, #8]
 801a0ae:	685b      	ldr	r3, [r3, #4]
 801a0b0:	60fb      	str	r3, [r7, #12]

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
 801a0b2:	68fb      	ldr	r3, [r7, #12]
 801a0b4:	2b00      	cmp	r3, #0
 801a0b6:	d10e      	bne.n	801a0d6 <next_marker+0x3e>
 801a0b8:	68bb      	ldr	r3, [r7, #8]
 801a0ba:	68db      	ldr	r3, [r3, #12]
 801a0bc:	6878      	ldr	r0, [r7, #4]
 801a0be:	4798      	blx	r3
 801a0c0:	4603      	mov	r3, r0
 801a0c2:	2b00      	cmp	r3, #0
 801a0c4:	d101      	bne.n	801a0ca <next_marker+0x32>
 801a0c6:	2300      	movs	r3, #0
 801a0c8:	e094      	b.n	801a1f4 <next_marker+0x15c>
 801a0ca:	68bb      	ldr	r3, [r7, #8]
 801a0cc:	681b      	ldr	r3, [r3, #0]
 801a0ce:	613b      	str	r3, [r7, #16]
 801a0d0:	68bb      	ldr	r3, [r7, #8]
 801a0d2:	685b      	ldr	r3, [r3, #4]
 801a0d4:	60fb      	str	r3, [r7, #12]
 801a0d6:	68fb      	ldr	r3, [r7, #12]
 801a0d8:	3b01      	subs	r3, #1
 801a0da:	60fb      	str	r3, [r7, #12]
 801a0dc:	693b      	ldr	r3, [r7, #16]
 801a0de:	1c5a      	adds	r2, r3, #1
 801a0e0:	613a      	str	r2, [r7, #16]
 801a0e2:	781b      	ldrb	r3, [r3, #0]
 801a0e4:	617b      	str	r3, [r7, #20]
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
 801a0e6:	e025      	b.n	801a134 <next_marker+0x9c>
      cinfo->marker->discarded_bytes++;
 801a0e8:	687b      	ldr	r3, [r7, #4]
 801a0ea:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a0ee:	699a      	ldr	r2, [r3, #24]
 801a0f0:	3201      	adds	r2, #1
 801a0f2:	619a      	str	r2, [r3, #24]
      INPUT_SYNC(cinfo);
 801a0f4:	68bb      	ldr	r3, [r7, #8]
 801a0f6:	693a      	ldr	r2, [r7, #16]
 801a0f8:	601a      	str	r2, [r3, #0]
 801a0fa:	68bb      	ldr	r3, [r7, #8]
 801a0fc:	68fa      	ldr	r2, [r7, #12]
 801a0fe:	605a      	str	r2, [r3, #4]
      INPUT_BYTE(cinfo, c, return FALSE);
 801a100:	68fb      	ldr	r3, [r7, #12]
 801a102:	2b00      	cmp	r3, #0
 801a104:	d10e      	bne.n	801a124 <next_marker+0x8c>
 801a106:	68bb      	ldr	r3, [r7, #8]
 801a108:	68db      	ldr	r3, [r3, #12]
 801a10a:	6878      	ldr	r0, [r7, #4]
 801a10c:	4798      	blx	r3
 801a10e:	4603      	mov	r3, r0
 801a110:	2b00      	cmp	r3, #0
 801a112:	d101      	bne.n	801a118 <next_marker+0x80>
 801a114:	2300      	movs	r3, #0
 801a116:	e06d      	b.n	801a1f4 <next_marker+0x15c>
 801a118:	68bb      	ldr	r3, [r7, #8]
 801a11a:	681b      	ldr	r3, [r3, #0]
 801a11c:	613b      	str	r3, [r7, #16]
 801a11e:	68bb      	ldr	r3, [r7, #8]
 801a120:	685b      	ldr	r3, [r3, #4]
 801a122:	60fb      	str	r3, [r7, #12]
 801a124:	68fb      	ldr	r3, [r7, #12]
 801a126:	3b01      	subs	r3, #1
 801a128:	60fb      	str	r3, [r7, #12]
 801a12a:	693b      	ldr	r3, [r7, #16]
 801a12c:	1c5a      	adds	r2, r3, #1
 801a12e:	613a      	str	r2, [r7, #16]
 801a130:	781b      	ldrb	r3, [r3, #0]
 801a132:	617b      	str	r3, [r7, #20]
    while (c != 0xFF) {
 801a134:	697b      	ldr	r3, [r7, #20]
 801a136:	2bff      	cmp	r3, #255	@ 0xff
 801a138:	d1d6      	bne.n	801a0e8 <next_marker+0x50>
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
 801a13a:	68fb      	ldr	r3, [r7, #12]
 801a13c:	2b00      	cmp	r3, #0
 801a13e:	d10e      	bne.n	801a15e <next_marker+0xc6>
 801a140:	68bb      	ldr	r3, [r7, #8]
 801a142:	68db      	ldr	r3, [r3, #12]
 801a144:	6878      	ldr	r0, [r7, #4]
 801a146:	4798      	blx	r3
 801a148:	4603      	mov	r3, r0
 801a14a:	2b00      	cmp	r3, #0
 801a14c:	d101      	bne.n	801a152 <next_marker+0xba>
 801a14e:	2300      	movs	r3, #0
 801a150:	e050      	b.n	801a1f4 <next_marker+0x15c>
 801a152:	68bb      	ldr	r3, [r7, #8]
 801a154:	681b      	ldr	r3, [r3, #0]
 801a156:	613b      	str	r3, [r7, #16]
 801a158:	68bb      	ldr	r3, [r7, #8]
 801a15a:	685b      	ldr	r3, [r3, #4]
 801a15c:	60fb      	str	r3, [r7, #12]
 801a15e:	68fb      	ldr	r3, [r7, #12]
 801a160:	3b01      	subs	r3, #1
 801a162:	60fb      	str	r3, [r7, #12]
 801a164:	693b      	ldr	r3, [r7, #16]
 801a166:	1c5a      	adds	r2, r3, #1
 801a168:	613a      	str	r2, [r7, #16]
 801a16a:	781b      	ldrb	r3, [r3, #0]
 801a16c:	617b      	str	r3, [r7, #20]
    } while (c == 0xFF);
 801a16e:	697b      	ldr	r3, [r7, #20]
 801a170:	2bff      	cmp	r3, #255	@ 0xff
 801a172:	d0e2      	beq.n	801a13a <next_marker+0xa2>
    if (c != 0)
 801a174:	697b      	ldr	r3, [r7, #20]
 801a176:	2b00      	cmp	r3, #0
 801a178:	d10f      	bne.n	801a19a <next_marker+0x102>
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
 801a17a:	687b      	ldr	r3, [r7, #4]
 801a17c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a180:	699a      	ldr	r2, [r3, #24]
 801a182:	687b      	ldr	r3, [r7, #4]
 801a184:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a188:	3202      	adds	r2, #2
 801a18a:	619a      	str	r2, [r3, #24]
    INPUT_SYNC(cinfo);
 801a18c:	68bb      	ldr	r3, [r7, #8]
 801a18e:	693a      	ldr	r2, [r7, #16]
 801a190:	601a      	str	r2, [r3, #0]
 801a192:	68bb      	ldr	r3, [r7, #8]
 801a194:	68fa      	ldr	r2, [r7, #12]
 801a196:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, c, return FALSE);
 801a198:	e78b      	b.n	801a0b2 <next_marker+0x1a>
      break;			/* found a valid marker, exit loop */
 801a19a:	bf00      	nop
  }

  if (cinfo->marker->discarded_bytes != 0) {
 801a19c:	687b      	ldr	r3, [r7, #4]
 801a19e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a1a2:	699b      	ldr	r3, [r3, #24]
 801a1a4:	2b00      	cmp	r3, #0
 801a1a6:	d01a      	beq.n	801a1de <next_marker+0x146>
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
 801a1a8:	687b      	ldr	r3, [r7, #4]
 801a1aa:	681b      	ldr	r3, [r3, #0]
 801a1ac:	2277      	movs	r2, #119	@ 0x77
 801a1ae:	615a      	str	r2, [r3, #20]
 801a1b0:	687b      	ldr	r3, [r7, #4]
 801a1b2:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a1b6:	699a      	ldr	r2, [r3, #24]
 801a1b8:	687b      	ldr	r3, [r7, #4]
 801a1ba:	681b      	ldr	r3, [r3, #0]
 801a1bc:	619a      	str	r2, [r3, #24]
 801a1be:	687b      	ldr	r3, [r7, #4]
 801a1c0:	681b      	ldr	r3, [r3, #0]
 801a1c2:	697a      	ldr	r2, [r7, #20]
 801a1c4:	61da      	str	r2, [r3, #28]
 801a1c6:	687b      	ldr	r3, [r7, #4]
 801a1c8:	681b      	ldr	r3, [r3, #0]
 801a1ca:	685b      	ldr	r3, [r3, #4]
 801a1cc:	f04f 31ff 	mov.w	r1, #4294967295
 801a1d0:	6878      	ldr	r0, [r7, #4]
 801a1d2:	4798      	blx	r3
    cinfo->marker->discarded_bytes = 0;
 801a1d4:	687b      	ldr	r3, [r7, #4]
 801a1d6:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a1da:	2200      	movs	r2, #0
 801a1dc:	619a      	str	r2, [r3, #24]
  }

  cinfo->unread_marker = c;
 801a1de:	687b      	ldr	r3, [r7, #4]
 801a1e0:	697a      	ldr	r2, [r7, #20]
 801a1e2:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4

  INPUT_SYNC(cinfo);
 801a1e6:	68bb      	ldr	r3, [r7, #8]
 801a1e8:	693a      	ldr	r2, [r7, #16]
 801a1ea:	601a      	str	r2, [r3, #0]
 801a1ec:	68bb      	ldr	r3, [r7, #8]
 801a1ee:	68fa      	ldr	r2, [r7, #12]
 801a1f0:	605a      	str	r2, [r3, #4]
  return TRUE;
 801a1f2:	2301      	movs	r3, #1
}
 801a1f4:	4618      	mov	r0, r3
 801a1f6:	3718      	adds	r7, #24
 801a1f8:	46bd      	mov	sp, r7
 801a1fa:	bd80      	pop	{r7, pc}

0801a1fc <first_marker>:
/* For this marker, we do not allow preceding garbage or fill; otherwise,
 * we might well scan an entire input file before realizing it ain't JPEG.
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
 801a1fc:	b580      	push	{r7, lr}
 801a1fe:	b088      	sub	sp, #32
 801a200:	af00      	add	r7, sp, #0
 801a202:	6078      	str	r0, [r7, #4]
  int c, c2;
  INPUT_VARS(cinfo);
 801a204:	687b      	ldr	r3, [r7, #4]
 801a206:	699b      	ldr	r3, [r3, #24]
 801a208:	617b      	str	r3, [r7, #20]
 801a20a:	697b      	ldr	r3, [r7, #20]
 801a20c:	681b      	ldr	r3, [r3, #0]
 801a20e:	61fb      	str	r3, [r7, #28]
 801a210:	697b      	ldr	r3, [r7, #20]
 801a212:	685b      	ldr	r3, [r3, #4]
 801a214:	61bb      	str	r3, [r7, #24]

  INPUT_BYTE(cinfo, c, return FALSE);
 801a216:	69bb      	ldr	r3, [r7, #24]
 801a218:	2b00      	cmp	r3, #0
 801a21a:	d10e      	bne.n	801a23a <first_marker+0x3e>
 801a21c:	697b      	ldr	r3, [r7, #20]
 801a21e:	68db      	ldr	r3, [r3, #12]
 801a220:	6878      	ldr	r0, [r7, #4]
 801a222:	4798      	blx	r3
 801a224:	4603      	mov	r3, r0
 801a226:	2b00      	cmp	r3, #0
 801a228:	d101      	bne.n	801a22e <first_marker+0x32>
 801a22a:	2300      	movs	r3, #0
 801a22c:	e049      	b.n	801a2c2 <first_marker+0xc6>
 801a22e:	697b      	ldr	r3, [r7, #20]
 801a230:	681b      	ldr	r3, [r3, #0]
 801a232:	61fb      	str	r3, [r7, #28]
 801a234:	697b      	ldr	r3, [r7, #20]
 801a236:	685b      	ldr	r3, [r3, #4]
 801a238:	61bb      	str	r3, [r7, #24]
 801a23a:	69bb      	ldr	r3, [r7, #24]
 801a23c:	3b01      	subs	r3, #1
 801a23e:	61bb      	str	r3, [r7, #24]
 801a240:	69fb      	ldr	r3, [r7, #28]
 801a242:	1c5a      	adds	r2, r3, #1
 801a244:	61fa      	str	r2, [r7, #28]
 801a246:	781b      	ldrb	r3, [r3, #0]
 801a248:	613b      	str	r3, [r7, #16]
  INPUT_BYTE(cinfo, c2, return FALSE);
 801a24a:	69bb      	ldr	r3, [r7, #24]
 801a24c:	2b00      	cmp	r3, #0
 801a24e:	d10e      	bne.n	801a26e <first_marker+0x72>
 801a250:	697b      	ldr	r3, [r7, #20]
 801a252:	68db      	ldr	r3, [r3, #12]
 801a254:	6878      	ldr	r0, [r7, #4]
 801a256:	4798      	blx	r3
 801a258:	4603      	mov	r3, r0
 801a25a:	2b00      	cmp	r3, #0
 801a25c:	d101      	bne.n	801a262 <first_marker+0x66>
 801a25e:	2300      	movs	r3, #0
 801a260:	e02f      	b.n	801a2c2 <first_marker+0xc6>
 801a262:	697b      	ldr	r3, [r7, #20]
 801a264:	681b      	ldr	r3, [r3, #0]
 801a266:	61fb      	str	r3, [r7, #28]
 801a268:	697b      	ldr	r3, [r7, #20]
 801a26a:	685b      	ldr	r3, [r3, #4]
 801a26c:	61bb      	str	r3, [r7, #24]
 801a26e:	69bb      	ldr	r3, [r7, #24]
 801a270:	3b01      	subs	r3, #1
 801a272:	61bb      	str	r3, [r7, #24]
 801a274:	69fb      	ldr	r3, [r7, #28]
 801a276:	1c5a      	adds	r2, r3, #1
 801a278:	61fa      	str	r2, [r7, #28]
 801a27a:	781b      	ldrb	r3, [r3, #0]
 801a27c:	60fb      	str	r3, [r7, #12]
  if (c != 0xFF || c2 != (int) M_SOI)
 801a27e:	693b      	ldr	r3, [r7, #16]
 801a280:	2bff      	cmp	r3, #255	@ 0xff
 801a282:	d102      	bne.n	801a28a <first_marker+0x8e>
 801a284:	68fb      	ldr	r3, [r7, #12]
 801a286:	2bd8      	cmp	r3, #216	@ 0xd8
 801a288:	d010      	beq.n	801a2ac <first_marker+0xb0>
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);
 801a28a:	687b      	ldr	r3, [r7, #4]
 801a28c:	681b      	ldr	r3, [r3, #0]
 801a28e:	2237      	movs	r2, #55	@ 0x37
 801a290:	615a      	str	r2, [r3, #20]
 801a292:	687b      	ldr	r3, [r7, #4]
 801a294:	681b      	ldr	r3, [r3, #0]
 801a296:	693a      	ldr	r2, [r7, #16]
 801a298:	619a      	str	r2, [r3, #24]
 801a29a:	687b      	ldr	r3, [r7, #4]
 801a29c:	681b      	ldr	r3, [r3, #0]
 801a29e:	68fa      	ldr	r2, [r7, #12]
 801a2a0:	61da      	str	r2, [r3, #28]
 801a2a2:	687b      	ldr	r3, [r7, #4]
 801a2a4:	681b      	ldr	r3, [r3, #0]
 801a2a6:	681b      	ldr	r3, [r3, #0]
 801a2a8:	6878      	ldr	r0, [r7, #4]
 801a2aa:	4798      	blx	r3

  cinfo->unread_marker = c2;
 801a2ac:	687b      	ldr	r3, [r7, #4]
 801a2ae:	68fa      	ldr	r2, [r7, #12]
 801a2b0:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4

  INPUT_SYNC(cinfo);
 801a2b4:	697b      	ldr	r3, [r7, #20]
 801a2b6:	69fa      	ldr	r2, [r7, #28]
 801a2b8:	601a      	str	r2, [r3, #0]
 801a2ba:	697b      	ldr	r3, [r7, #20]
 801a2bc:	69ba      	ldr	r2, [r7, #24]
 801a2be:	605a      	str	r2, [r3, #4]
  return TRUE;
 801a2c0:	2301      	movs	r3, #1
}
 801a2c2:	4618      	mov	r0, r3
 801a2c4:	3720      	adds	r7, #32
 801a2c6:	46bd      	mov	sp, r7
 801a2c8:	bd80      	pop	{r7, pc}
	...

0801a2cc <read_markers>:
 * after processing for the caller.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
 801a2cc:	b580      	push	{r7, lr}
 801a2ce:	b082      	sub	sp, #8
 801a2d0:	af00      	add	r7, sp, #0
 801a2d2:	6078      	str	r0, [r7, #4]
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
 801a2d4:	687b      	ldr	r3, [r7, #4]
 801a2d6:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801a2da:	2b00      	cmp	r3, #0
 801a2dc:	d115      	bne.n	801a30a <read_markers+0x3e>
      if (! cinfo->marker->saw_SOI) {
 801a2de:	687b      	ldr	r3, [r7, #4]
 801a2e0:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a2e4:	68db      	ldr	r3, [r3, #12]
 801a2e6:	2b00      	cmp	r3, #0
 801a2e8:	d107      	bne.n	801a2fa <read_markers+0x2e>
	if (! first_marker(cinfo))
 801a2ea:	6878      	ldr	r0, [r7, #4]
 801a2ec:	f7ff ff86 	bl	801a1fc <first_marker>
 801a2f0:	4603      	mov	r3, r0
 801a2f2:	2b00      	cmp	r3, #0
 801a2f4:	d109      	bne.n	801a30a <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801a2f6:	2300      	movs	r3, #0
 801a2f8:	e192      	b.n	801a620 <read_markers+0x354>
      } else {
	if (! next_marker(cinfo))
 801a2fa:	6878      	ldr	r0, [r7, #4]
 801a2fc:	f7ff fecc 	bl	801a098 <next_marker>
 801a300:	4603      	mov	r3, r0
 801a302:	2b00      	cmp	r3, #0
 801a304:	d101      	bne.n	801a30a <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801a306:	2300      	movs	r3, #0
 801a308:	e18a      	b.n	801a620 <read_markers+0x354>
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
 801a30a:	687b      	ldr	r3, [r7, #4]
 801a30c:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801a310:	2b01      	cmp	r3, #1
 801a312:	f000 813e 	beq.w	801a592 <read_markers+0x2c6>
 801a316:	2b00      	cmp	r3, #0
 801a318:	f340 8154 	ble.w	801a5c4 <read_markers+0x2f8>
 801a31c:	2bfe      	cmp	r3, #254	@ 0xfe
 801a31e:	f300 8151 	bgt.w	801a5c4 <read_markers+0x2f8>
 801a322:	2bc0      	cmp	r3, #192	@ 0xc0
 801a324:	f2c0 814e 	blt.w	801a5c4 <read_markers+0x2f8>
 801a328:	3bc0      	subs	r3, #192	@ 0xc0
 801a32a:	2b3e      	cmp	r3, #62	@ 0x3e
 801a32c:	f200 814a 	bhi.w	801a5c4 <read_markers+0x2f8>
 801a330:	a201      	add	r2, pc, #4	@ (adr r2, 801a338 <read_markers+0x6c>)
 801a332:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a336:	bf00      	nop
 801a338:	0801a447 	.word	0x0801a447
 801a33c:	0801a45f 	.word	0x0801a45f
 801a340:	0801a477 	.word	0x0801a477
 801a344:	0801a4bf 	.word	0x0801a4bf
 801a348:	0801a52b 	.word	0x0801a52b
 801a34c:	0801a4bf 	.word	0x0801a4bf
 801a350:	0801a4bf 	.word	0x0801a4bf
 801a354:	0801a4bf 	.word	0x0801a4bf
 801a358:	0801a4bf 	.word	0x0801a4bf
 801a35c:	0801a48f 	.word	0x0801a48f
 801a360:	0801a4a7 	.word	0x0801a4a7
 801a364:	0801a4bf 	.word	0x0801a4bf
 801a368:	0801a51b 	.word	0x0801a51b
 801a36c:	0801a4bf 	.word	0x0801a4bf
 801a370:	0801a4bf 	.word	0x0801a4bf
 801a374:	0801a4bf 	.word	0x0801a4bf
 801a378:	0801a593 	.word	0x0801a593
 801a37c:	0801a593 	.word	0x0801a593
 801a380:	0801a593 	.word	0x0801a593
 801a384:	0801a593 	.word	0x0801a593
 801a388:	0801a593 	.word	0x0801a593
 801a38c:	0801a593 	.word	0x0801a593
 801a390:	0801a593 	.word	0x0801a593
 801a394:	0801a593 	.word	0x0801a593
 801a398:	0801a435 	.word	0x0801a435
 801a39c:	0801a4fb 	.word	0x0801a4fb
 801a3a0:	0801a4df 	.word	0x0801a4df
 801a3a4:	0801a53b 	.word	0x0801a53b
 801a3a8:	0801a5b5 	.word	0x0801a5b5
 801a3ac:	0801a54b 	.word	0x0801a54b
 801a3b0:	0801a5c5 	.word	0x0801a5c5
 801a3b4:	0801a5c5 	.word	0x0801a5c5
 801a3b8:	0801a55b 	.word	0x0801a55b
 801a3bc:	0801a55b 	.word	0x0801a55b
 801a3c0:	0801a55b 	.word	0x0801a55b
 801a3c4:	0801a55b 	.word	0x0801a55b
 801a3c8:	0801a55b 	.word	0x0801a55b
 801a3cc:	0801a55b 	.word	0x0801a55b
 801a3d0:	0801a55b 	.word	0x0801a55b
 801a3d4:	0801a55b 	.word	0x0801a55b
 801a3d8:	0801a55b 	.word	0x0801a55b
 801a3dc:	0801a55b 	.word	0x0801a55b
 801a3e0:	0801a55b 	.word	0x0801a55b
 801a3e4:	0801a55b 	.word	0x0801a55b
 801a3e8:	0801a55b 	.word	0x0801a55b
 801a3ec:	0801a55b 	.word	0x0801a55b
 801a3f0:	0801a55b 	.word	0x0801a55b
 801a3f4:	0801a55b 	.word	0x0801a55b
 801a3f8:	0801a5c5 	.word	0x0801a5c5
 801a3fc:	0801a5c5 	.word	0x0801a5c5
 801a400:	0801a5c5 	.word	0x0801a5c5
 801a404:	0801a5c5 	.word	0x0801a5c5
 801a408:	0801a5c5 	.word	0x0801a5c5
 801a40c:	0801a5c5 	.word	0x0801a5c5
 801a410:	0801a5c5 	.word	0x0801a5c5
 801a414:	0801a5c5 	.word	0x0801a5c5
 801a418:	0801a5c5 	.word	0x0801a5c5
 801a41c:	0801a5c5 	.word	0x0801a5c5
 801a420:	0801a5c5 	.word	0x0801a5c5
 801a424:	0801a5c5 	.word	0x0801a5c5
 801a428:	0801a5c5 	.word	0x0801a5c5
 801a42c:	0801a5c5 	.word	0x0801a5c5
 801a430:	0801a57d 	.word	0x0801a57d
    case M_SOI:
      if (! get_soi(cinfo))
 801a434:	6878      	ldr	r0, [r7, #4]
 801a436:	f7fe f82b 	bl	8018490 <get_soi>
 801a43a:	4603      	mov	r3, r0
 801a43c:	2b00      	cmp	r3, #0
 801a43e:	f040 80d1 	bne.w	801a5e4 <read_markers+0x318>
	return JPEG_SUSPENDED;
 801a442:	2300      	movs	r3, #0
 801a444:	e0ec      	b.n	801a620 <read_markers+0x354>
      break;

    case M_SOF0:		/* Baseline */
      if (! get_sof(cinfo, TRUE, FALSE, FALSE))
 801a446:	2300      	movs	r3, #0
 801a448:	2200      	movs	r2, #0
 801a44a:	2101      	movs	r1, #1
 801a44c:	6878      	ldr	r0, [r7, #4]
 801a44e:	f7fe f88e 	bl	801856e <get_sof>
 801a452:	4603      	mov	r3, r0
 801a454:	2b00      	cmp	r3, #0
 801a456:	f040 80c7 	bne.w	801a5e8 <read_markers+0x31c>
	return JPEG_SUSPENDED;
 801a45a:	2300      	movs	r3, #0
 801a45c:	e0e0      	b.n	801a620 <read_markers+0x354>
      break;

    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE, FALSE))
 801a45e:	2300      	movs	r3, #0
 801a460:	2200      	movs	r2, #0
 801a462:	2100      	movs	r1, #0
 801a464:	6878      	ldr	r0, [r7, #4]
 801a466:	f7fe f882 	bl	801856e <get_sof>
 801a46a:	4603      	mov	r3, r0
 801a46c:	2b00      	cmp	r3, #0
 801a46e:	f040 80bd 	bne.w	801a5ec <read_markers+0x320>
	return JPEG_SUSPENDED;
 801a472:	2300      	movs	r3, #0
 801a474:	e0d4      	b.n	801a620 <read_markers+0x354>
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, FALSE, TRUE, FALSE))
 801a476:	2300      	movs	r3, #0
 801a478:	2201      	movs	r2, #1
 801a47a:	2100      	movs	r1, #0
 801a47c:	6878      	ldr	r0, [r7, #4]
 801a47e:	f7fe f876 	bl	801856e <get_sof>
 801a482:	4603      	mov	r3, r0
 801a484:	2b00      	cmp	r3, #0
 801a486:	f040 80b3 	bne.w	801a5f0 <read_markers+0x324>
	return JPEG_SUSPENDED;
 801a48a:	2300      	movs	r3, #0
 801a48c:	e0c8      	b.n	801a620 <read_markers+0x354>
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, FALSE, TRUE))
 801a48e:	2301      	movs	r3, #1
 801a490:	2200      	movs	r2, #0
 801a492:	2100      	movs	r1, #0
 801a494:	6878      	ldr	r0, [r7, #4]
 801a496:	f7fe f86a 	bl	801856e <get_sof>
 801a49a:	4603      	mov	r3, r0
 801a49c:	2b00      	cmp	r3, #0
 801a49e:	f040 80a9 	bne.w	801a5f4 <read_markers+0x328>
	return JPEG_SUSPENDED;
 801a4a2:	2300      	movs	r3, #0
 801a4a4:	e0bc      	b.n	801a620 <read_markers+0x354>
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE, TRUE))
 801a4a6:	2301      	movs	r3, #1
 801a4a8:	2201      	movs	r2, #1
 801a4aa:	2100      	movs	r1, #0
 801a4ac:	6878      	ldr	r0, [r7, #4]
 801a4ae:	f7fe f85e 	bl	801856e <get_sof>
 801a4b2:	4603      	mov	r3, r0
 801a4b4:	2b00      	cmp	r3, #0
 801a4b6:	f040 809f 	bne.w	801a5f8 <read_markers+0x32c>
	return JPEG_SUSPENDED;
 801a4ba:	2300      	movs	r3, #0
 801a4bc:	e0b0      	b.n	801a620 <read_markers+0x354>
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
 801a4be:	687b      	ldr	r3, [r7, #4]
 801a4c0:	681b      	ldr	r3, [r3, #0]
 801a4c2:	223e      	movs	r2, #62	@ 0x3e
 801a4c4:	615a      	str	r2, [r3, #20]
 801a4c6:	687b      	ldr	r3, [r7, #4]
 801a4c8:	681b      	ldr	r3, [r3, #0]
 801a4ca:	687a      	ldr	r2, [r7, #4]
 801a4cc:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801a4d0:	619a      	str	r2, [r3, #24]
 801a4d2:	687b      	ldr	r3, [r7, #4]
 801a4d4:	681b      	ldr	r3, [r3, #0]
 801a4d6:	681b      	ldr	r3, [r3, #0]
 801a4d8:	6878      	ldr	r0, [r7, #4]
 801a4da:	4798      	blx	r3
      break;
 801a4dc:	e09b      	b.n	801a616 <read_markers+0x34a>

    case M_SOS:
      if (! get_sos(cinfo))
 801a4de:	6878      	ldr	r0, [r7, #4]
 801a4e0:	f7fe fa59 	bl	8018996 <get_sos>
 801a4e4:	4603      	mov	r3, r0
 801a4e6:	2b00      	cmp	r3, #0
 801a4e8:	d101      	bne.n	801a4ee <read_markers+0x222>
	return JPEG_SUSPENDED;
 801a4ea:	2300      	movs	r3, #0
 801a4ec:	e098      	b.n	801a620 <read_markers+0x354>
      cinfo->unread_marker = 0;	/* processed the marker */
 801a4ee:	687b      	ldr	r3, [r7, #4]
 801a4f0:	2200      	movs	r2, #0
 801a4f2:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return JPEG_REACHED_SOS;
 801a4f6:	2301      	movs	r3, #1
 801a4f8:	e092      	b.n	801a620 <read_markers+0x354>
    
    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
 801a4fa:	687b      	ldr	r3, [r7, #4]
 801a4fc:	681b      	ldr	r3, [r3, #0]
 801a4fe:	2257      	movs	r2, #87	@ 0x57
 801a500:	615a      	str	r2, [r3, #20]
 801a502:	687b      	ldr	r3, [r7, #4]
 801a504:	681b      	ldr	r3, [r3, #0]
 801a506:	685b      	ldr	r3, [r3, #4]
 801a508:	2101      	movs	r1, #1
 801a50a:	6878      	ldr	r0, [r7, #4]
 801a50c:	4798      	blx	r3
      cinfo->unread_marker = 0;	/* processed the marker */
 801a50e:	687b      	ldr	r3, [r7, #4]
 801a510:	2200      	movs	r2, #0
 801a512:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return JPEG_REACHED_EOI;
 801a516:	2302      	movs	r3, #2
 801a518:	e082      	b.n	801a620 <read_markers+0x354>
      
    case M_DAC:
      if (! get_dac(cinfo))
 801a51a:	6878      	ldr	r0, [r7, #4]
 801a51c:	f7fe fc09 	bl	8018d32 <get_dac>
 801a520:	4603      	mov	r3, r0
 801a522:	2b00      	cmp	r3, #0
 801a524:	d16a      	bne.n	801a5fc <read_markers+0x330>
	return JPEG_SUSPENDED;
 801a526:	2300      	movs	r3, #0
 801a528:	e07a      	b.n	801a620 <read_markers+0x354>
      break;
      
    case M_DHT:
      if (! get_dht(cinfo))
 801a52a:	6878      	ldr	r0, [r7, #4]
 801a52c:	f7fe fcfb 	bl	8018f26 <get_dht>
 801a530:	4603      	mov	r3, r0
 801a532:	2b00      	cmp	r3, #0
 801a534:	d164      	bne.n	801a600 <read_markers+0x334>
	return JPEG_SUSPENDED;
 801a536:	2300      	movs	r3, #0
 801a538:	e072      	b.n	801a620 <read_markers+0x354>
      break;
      
    case M_DQT:
      if (! get_dqt(cinfo))
 801a53a:	6878      	ldr	r0, [r7, #4]
 801a53c:	f7fe ffb0 	bl	80194a0 <get_dqt>
 801a540:	4603      	mov	r3, r0
 801a542:	2b00      	cmp	r3, #0
 801a544:	d15e      	bne.n	801a604 <read_markers+0x338>
	return JPEG_SUSPENDED;
 801a546:	2300      	movs	r3, #0
 801a548:	e06a      	b.n	801a620 <read_markers+0x354>
      break;
      
    case M_DRI:
      if (! get_dri(cinfo))
 801a54a:	6878      	ldr	r0, [r7, #4]
 801a54c:	f7ff f9f2 	bl	8019934 <get_dri>
 801a550:	4603      	mov	r3, r0
 801a552:	2b00      	cmp	r3, #0
 801a554:	d158      	bne.n	801a608 <read_markers+0x33c>
	return JPEG_SUSPENDED;
 801a556:	2300      	movs	r3, #0
 801a558:	e062      	b.n	801a620 <read_markers+0x354>
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 801a55a:	687b      	ldr	r3, [r7, #4]
 801a55c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
		cinfo->unread_marker - (int) M_APP0]) (cinfo))
 801a560:	687a      	ldr	r2, [r7, #4]
 801a562:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801a566:	3ae0      	subs	r2, #224	@ 0xe0
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 801a568:	3208      	adds	r2, #8
 801a56a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a56e:	6878      	ldr	r0, [r7, #4]
 801a570:	4798      	blx	r3
 801a572:	4603      	mov	r3, r0
 801a574:	2b00      	cmp	r3, #0
 801a576:	d149      	bne.n	801a60c <read_markers+0x340>
	return JPEG_SUSPENDED;
 801a578:	2300      	movs	r3, #0
 801a57a:	e051      	b.n	801a620 <read_markers+0x354>
      break;
      
    case M_COM:
      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
 801a57c:	687b      	ldr	r3, [r7, #4]
 801a57e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a582:	69db      	ldr	r3, [r3, #28]
 801a584:	6878      	ldr	r0, [r7, #4]
 801a586:	4798      	blx	r3
 801a588:	4603      	mov	r3, r0
 801a58a:	2b00      	cmp	r3, #0
 801a58c:	d140      	bne.n	801a610 <read_markers+0x344>
	return JPEG_SUSPENDED;
 801a58e:	2300      	movs	r3, #0
 801a590:	e046      	b.n	801a620 <read_markers+0x354>
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
 801a592:	687b      	ldr	r3, [r7, #4]
 801a594:	681b      	ldr	r3, [r3, #0]
 801a596:	225e      	movs	r2, #94	@ 0x5e
 801a598:	615a      	str	r2, [r3, #20]
 801a59a:	687b      	ldr	r3, [r7, #4]
 801a59c:	681b      	ldr	r3, [r3, #0]
 801a59e:	687a      	ldr	r2, [r7, #4]
 801a5a0:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801a5a4:	619a      	str	r2, [r3, #24]
 801a5a6:	687b      	ldr	r3, [r7, #4]
 801a5a8:	681b      	ldr	r3, [r3, #0]
 801a5aa:	685b      	ldr	r3, [r3, #4]
 801a5ac:	2101      	movs	r1, #1
 801a5ae:	6878      	ldr	r0, [r7, #4]
 801a5b0:	4798      	blx	r3
      break;
 801a5b2:	e030      	b.n	801a616 <read_markers+0x34a>

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
 801a5b4:	6878      	ldr	r0, [r7, #4]
 801a5b6:	f7ff fcff 	bl	8019fb8 <skip_variable>
 801a5ba:	4603      	mov	r3, r0
 801a5bc:	2b00      	cmp	r3, #0
 801a5be:	d129      	bne.n	801a614 <read_markers+0x348>
	return JPEG_SUSPENDED;
 801a5c0:	2300      	movs	r3, #0
 801a5c2:	e02d      	b.n	801a620 <read_markers+0x354>
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 801a5c4:	687b      	ldr	r3, [r7, #4]
 801a5c6:	681b      	ldr	r3, [r3, #0]
 801a5c8:	2246      	movs	r2, #70	@ 0x46
 801a5ca:	615a      	str	r2, [r3, #20]
 801a5cc:	687b      	ldr	r3, [r7, #4]
 801a5ce:	681b      	ldr	r3, [r3, #0]
 801a5d0:	687a      	ldr	r2, [r7, #4]
 801a5d2:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801a5d6:	619a      	str	r2, [r3, #24]
 801a5d8:	687b      	ldr	r3, [r7, #4]
 801a5da:	681b      	ldr	r3, [r3, #0]
 801a5dc:	681b      	ldr	r3, [r3, #0]
 801a5de:	6878      	ldr	r0, [r7, #4]
 801a5e0:	4798      	blx	r3
      break;
 801a5e2:	e018      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5e4:	bf00      	nop
 801a5e6:	e016      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5e8:	bf00      	nop
 801a5ea:	e014      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5ec:	bf00      	nop
 801a5ee:	e012      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5f0:	bf00      	nop
 801a5f2:	e010      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5f4:	bf00      	nop
 801a5f6:	e00e      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5f8:	bf00      	nop
 801a5fa:	e00c      	b.n	801a616 <read_markers+0x34a>
      break;
 801a5fc:	bf00      	nop
 801a5fe:	e00a      	b.n	801a616 <read_markers+0x34a>
      break;
 801a600:	bf00      	nop
 801a602:	e008      	b.n	801a616 <read_markers+0x34a>
      break;
 801a604:	bf00      	nop
 801a606:	e006      	b.n	801a616 <read_markers+0x34a>
      break;
 801a608:	bf00      	nop
 801a60a:	e004      	b.n	801a616 <read_markers+0x34a>
      break;
 801a60c:	bf00      	nop
 801a60e:	e002      	b.n	801a616 <read_markers+0x34a>
      break;
 801a610:	bf00      	nop
 801a612:	e000      	b.n	801a616 <read_markers+0x34a>
      break;
 801a614:	bf00      	nop
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
 801a616:	687b      	ldr	r3, [r7, #4]
 801a618:	2200      	movs	r2, #0
 801a61a:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
    if (cinfo->unread_marker == 0) {
 801a61e:	e659      	b.n	801a2d4 <read_markers+0x8>
  } /* end loop */
}
 801a620:	4618      	mov	r0, r3
 801a622:	3708      	adds	r7, #8
 801a624:	46bd      	mov	sp, r7
 801a626:	bd80      	pop	{r7, pc}

0801a628 <read_restart_marker>:
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
 801a628:	b580      	push	{r7, lr}
 801a62a:	b082      	sub	sp, #8
 801a62c:	af00      	add	r7, sp, #0
 801a62e:	6078      	str	r0, [r7, #4]
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
 801a630:	687b      	ldr	r3, [r7, #4]
 801a632:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801a636:	2b00      	cmp	r3, #0
 801a638:	d107      	bne.n	801a64a <read_restart_marker+0x22>
    if (! next_marker(cinfo))
 801a63a:	6878      	ldr	r0, [r7, #4]
 801a63c:	f7ff fd2c 	bl	801a098 <next_marker>
 801a640:	4603      	mov	r3, r0
 801a642:	2b00      	cmp	r3, #0
 801a644:	d101      	bne.n	801a64a <read_restart_marker+0x22>
      return FALSE;
 801a646:	2300      	movs	r3, #0
 801a648:	e03a      	b.n	801a6c0 <read_restart_marker+0x98>
  }

  if (cinfo->unread_marker ==
 801a64a:	687b      	ldr	r3, [r7, #4]
 801a64c:	f8d3 21b4 	ldr.w	r2, [r3, #436]	@ 0x1b4
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
 801a650:	687b      	ldr	r3, [r7, #4]
 801a652:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a656:	695b      	ldr	r3, [r3, #20]
 801a658:	33d0      	adds	r3, #208	@ 0xd0
  if (cinfo->unread_marker ==
 801a65a:	429a      	cmp	r2, r3
 801a65c:	d115      	bne.n	801a68a <read_restart_marker+0x62>
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
 801a65e:	687b      	ldr	r3, [r7, #4]
 801a660:	681b      	ldr	r3, [r3, #0]
 801a662:	2264      	movs	r2, #100	@ 0x64
 801a664:	615a      	str	r2, [r3, #20]
 801a666:	687b      	ldr	r3, [r7, #4]
 801a668:	f8d3 21cc 	ldr.w	r2, [r3, #460]	@ 0x1cc
 801a66c:	687b      	ldr	r3, [r7, #4]
 801a66e:	681b      	ldr	r3, [r3, #0]
 801a670:	6952      	ldr	r2, [r2, #20]
 801a672:	619a      	str	r2, [r3, #24]
 801a674:	687b      	ldr	r3, [r7, #4]
 801a676:	681b      	ldr	r3, [r3, #0]
 801a678:	685b      	ldr	r3, [r3, #4]
 801a67a:	2103      	movs	r1, #3
 801a67c:	6878      	ldr	r0, [r7, #4]
 801a67e:	4798      	blx	r3
    cinfo->unread_marker = 0;
 801a680:	687b      	ldr	r3, [r7, #4]
 801a682:	2200      	movs	r2, #0
 801a684:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
 801a688:	e00e      	b.n	801a6a8 <read_restart_marker+0x80>
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 801a68a:	687b      	ldr	r3, [r7, #4]
 801a68c:	699b      	ldr	r3, [r3, #24]
 801a68e:	695b      	ldr	r3, [r3, #20]
					    cinfo->marker->next_restart_num))
 801a690:	687a      	ldr	r2, [r7, #4]
 801a692:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 801a696:	6952      	ldr	r2, [r2, #20]
 801a698:	4611      	mov	r1, r2
 801a69a:	6878      	ldr	r0, [r7, #4]
 801a69c:	4798      	blx	r3
 801a69e:	4603      	mov	r3, r0
 801a6a0:	2b00      	cmp	r3, #0
 801a6a2:	d101      	bne.n	801a6a8 <read_restart_marker+0x80>
      return FALSE;
 801a6a4:	2300      	movs	r3, #0
 801a6a6:	e00b      	b.n	801a6c0 <read_restart_marker+0x98>
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
 801a6a8:	687b      	ldr	r3, [r7, #4]
 801a6aa:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a6ae:	695b      	ldr	r3, [r3, #20]
 801a6b0:	1c5a      	adds	r2, r3, #1
 801a6b2:	687b      	ldr	r3, [r7, #4]
 801a6b4:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a6b8:	f002 0207 	and.w	r2, r2, #7
 801a6bc:	615a      	str	r2, [r3, #20]

  return TRUE;
 801a6be:	2301      	movs	r3, #1
}
 801a6c0:	4618      	mov	r0, r3
 801a6c2:	3708      	adds	r7, #8
 801a6c4:	46bd      	mov	sp, r7
 801a6c6:	bd80      	pop	{r7, pc}

0801a6c8 <jpeg_resync_to_restart>:
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
 801a6c8:	b580      	push	{r7, lr}
 801a6ca:	b084      	sub	sp, #16
 801a6cc:	af00      	add	r7, sp, #0
 801a6ce:	6078      	str	r0, [r7, #4]
 801a6d0:	6039      	str	r1, [r7, #0]
  int marker = cinfo->unread_marker;
 801a6d2:	687b      	ldr	r3, [r7, #4]
 801a6d4:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801a6d8:	60fb      	str	r3, [r7, #12]
  int action = 1;
 801a6da:	2301      	movs	r3, #1
 801a6dc:	60bb      	str	r3, [r7, #8]
  
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
 801a6de:	687b      	ldr	r3, [r7, #4]
 801a6e0:	681b      	ldr	r3, [r3, #0]
 801a6e2:	227c      	movs	r2, #124	@ 0x7c
 801a6e4:	615a      	str	r2, [r3, #20]
 801a6e6:	687b      	ldr	r3, [r7, #4]
 801a6e8:	681b      	ldr	r3, [r3, #0]
 801a6ea:	68fa      	ldr	r2, [r7, #12]
 801a6ec:	619a      	str	r2, [r3, #24]
 801a6ee:	687b      	ldr	r3, [r7, #4]
 801a6f0:	681b      	ldr	r3, [r3, #0]
 801a6f2:	683a      	ldr	r2, [r7, #0]
 801a6f4:	61da      	str	r2, [r3, #28]
 801a6f6:	687b      	ldr	r3, [r7, #4]
 801a6f8:	681b      	ldr	r3, [r3, #0]
 801a6fa:	685b      	ldr	r3, [r3, #4]
 801a6fc:	f04f 31ff 	mov.w	r1, #4294967295
 801a700:	6878      	ldr	r0, [r7, #4]
 801a702:	4798      	blx	r3
  
  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
 801a704:	68fb      	ldr	r3, [r7, #12]
 801a706:	2bbf      	cmp	r3, #191	@ 0xbf
 801a708:	dc02      	bgt.n	801a710 <jpeg_resync_to_restart+0x48>
      action = 2;		/* invalid marker */
 801a70a:	2302      	movs	r3, #2
 801a70c:	60bb      	str	r3, [r7, #8]
 801a70e:	e030      	b.n	801a772 <jpeg_resync_to_restart+0xaa>
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
 801a710:	68fb      	ldr	r3, [r7, #12]
 801a712:	2bcf      	cmp	r3, #207	@ 0xcf
 801a714:	dd02      	ble.n	801a71c <jpeg_resync_to_restart+0x54>
 801a716:	68fb      	ldr	r3, [r7, #12]
 801a718:	2bd7      	cmp	r3, #215	@ 0xd7
 801a71a:	dd02      	ble.n	801a722 <jpeg_resync_to_restart+0x5a>
      action = 3;		/* valid non-restart marker */
 801a71c:	2303      	movs	r3, #3
 801a71e:	60bb      	str	r3, [r7, #8]
 801a720:	e027      	b.n	801a772 <jpeg_resync_to_restart+0xaa>
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 801a722:	683b      	ldr	r3, [r7, #0]
 801a724:	3301      	adds	r3, #1
 801a726:	f003 0307 	and.w	r3, r3, #7
 801a72a:	33d0      	adds	r3, #208	@ 0xd0
 801a72c:	68fa      	ldr	r2, [r7, #12]
 801a72e:	429a      	cmp	r2, r3
 801a730:	d007      	beq.n	801a742 <jpeg_resync_to_restart+0x7a>
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
 801a732:	683b      	ldr	r3, [r7, #0]
 801a734:	3302      	adds	r3, #2
 801a736:	f003 0307 	and.w	r3, r3, #7
 801a73a:	33d0      	adds	r3, #208	@ 0xd0
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 801a73c:	68fa      	ldr	r2, [r7, #12]
 801a73e:	429a      	cmp	r2, r3
 801a740:	d102      	bne.n	801a748 <jpeg_resync_to_restart+0x80>
	action = 3;		/* one of the next two expected restarts */
 801a742:	2303      	movs	r3, #3
 801a744:	60bb      	str	r3, [r7, #8]
 801a746:	e014      	b.n	801a772 <jpeg_resync_to_restart+0xaa>
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 801a748:	683b      	ldr	r3, [r7, #0]
 801a74a:	3b01      	subs	r3, #1
 801a74c:	f003 0307 	and.w	r3, r3, #7
 801a750:	33d0      	adds	r3, #208	@ 0xd0
 801a752:	68fa      	ldr	r2, [r7, #12]
 801a754:	429a      	cmp	r2, r3
 801a756:	d007      	beq.n	801a768 <jpeg_resync_to_restart+0xa0>
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
 801a758:	683b      	ldr	r3, [r7, #0]
 801a75a:	3b02      	subs	r3, #2
 801a75c:	f003 0307 	and.w	r3, r3, #7
 801a760:	33d0      	adds	r3, #208	@ 0xd0
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 801a762:	68fa      	ldr	r2, [r7, #12]
 801a764:	429a      	cmp	r2, r3
 801a766:	d102      	bne.n	801a76e <jpeg_resync_to_restart+0xa6>
	action = 2;		/* a prior restart, so advance */
 801a768:	2302      	movs	r3, #2
 801a76a:	60bb      	str	r3, [r7, #8]
 801a76c:	e001      	b.n	801a772 <jpeg_resync_to_restart+0xaa>
      else
	action = 1;		/* desired restart or too far away */
 801a76e:	2301      	movs	r3, #1
 801a770:	60bb      	str	r3, [r7, #8]
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
 801a772:	687b      	ldr	r3, [r7, #4]
 801a774:	681b      	ldr	r3, [r3, #0]
 801a776:	2263      	movs	r2, #99	@ 0x63
 801a778:	615a      	str	r2, [r3, #20]
 801a77a:	687b      	ldr	r3, [r7, #4]
 801a77c:	681b      	ldr	r3, [r3, #0]
 801a77e:	68fa      	ldr	r2, [r7, #12]
 801a780:	619a      	str	r2, [r3, #24]
 801a782:	687b      	ldr	r3, [r7, #4]
 801a784:	681b      	ldr	r3, [r3, #0]
 801a786:	68ba      	ldr	r2, [r7, #8]
 801a788:	61da      	str	r2, [r3, #28]
 801a78a:	687b      	ldr	r3, [r7, #4]
 801a78c:	681b      	ldr	r3, [r3, #0]
 801a78e:	685b      	ldr	r3, [r3, #4]
 801a790:	2104      	movs	r1, #4
 801a792:	6878      	ldr	r0, [r7, #4]
 801a794:	4798      	blx	r3
    switch (action) {
 801a796:	68bb      	ldr	r3, [r7, #8]
 801a798:	2b03      	cmp	r3, #3
 801a79a:	d01c      	beq.n	801a7d6 <jpeg_resync_to_restart+0x10e>
 801a79c:	68bb      	ldr	r3, [r7, #8]
 801a79e:	2b03      	cmp	r3, #3
 801a7a0:	dcb0      	bgt.n	801a704 <jpeg_resync_to_restart+0x3c>
 801a7a2:	68bb      	ldr	r3, [r7, #8]
 801a7a4:	2b01      	cmp	r3, #1
 801a7a6:	d003      	beq.n	801a7b0 <jpeg_resync_to_restart+0xe8>
 801a7a8:	68bb      	ldr	r3, [r7, #8]
 801a7aa:	2b02      	cmp	r3, #2
 801a7ac:	d006      	beq.n	801a7bc <jpeg_resync_to_restart+0xf4>
 801a7ae:	e014      	b.n	801a7da <jpeg_resync_to_restart+0x112>
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
 801a7b0:	687b      	ldr	r3, [r7, #4]
 801a7b2:	2200      	movs	r2, #0
 801a7b4:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return TRUE;
 801a7b8:	2301      	movs	r3, #1
 801a7ba:	e00f      	b.n	801a7dc <jpeg_resync_to_restart+0x114>
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
 801a7bc:	6878      	ldr	r0, [r7, #4]
 801a7be:	f7ff fc6b 	bl	801a098 <next_marker>
 801a7c2:	4603      	mov	r3, r0
 801a7c4:	2b00      	cmp	r3, #0
 801a7c6:	d101      	bne.n	801a7cc <jpeg_resync_to_restart+0x104>
	return FALSE;
 801a7c8:	2300      	movs	r3, #0
 801a7ca:	e007      	b.n	801a7dc <jpeg_resync_to_restart+0x114>
      marker = cinfo->unread_marker;
 801a7cc:	687b      	ldr	r3, [r7, #4]
 801a7ce:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801a7d2:	60fb      	str	r3, [r7, #12]
      break;
 801a7d4:	e001      	b.n	801a7da <jpeg_resync_to_restart+0x112>
    case 3:
      /* Return without advancing past this marker. */
      /* Entropy decoder will be forced to process an empty segment. */
      return TRUE;
 801a7d6:	2301      	movs	r3, #1
 801a7d8:	e000      	b.n	801a7dc <jpeg_resync_to_restart+0x114>
    if (marker < (int) M_SOF0)
 801a7da:	e793      	b.n	801a704 <jpeg_resync_to_restart+0x3c>
    }
  } /* end loop */
}
 801a7dc:	4618      	mov	r0, r3
 801a7de:	3710      	adds	r7, #16
 801a7e0:	46bd      	mov	sp, r7
 801a7e2:	bd80      	pop	{r7, pc}

0801a7e4 <reset_marker_reader>:
 * Reset marker processing state to begin a fresh datastream.
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
 801a7e4:	b480      	push	{r7}
 801a7e6:	b085      	sub	sp, #20
 801a7e8:	af00      	add	r7, sp, #0
 801a7ea:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
 801a7ec:	687b      	ldr	r3, [r7, #4]
 801a7ee:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a7f2:	60fb      	str	r3, [r7, #12]

  cinfo->comp_info = NULL;		/* until allocated by get_sof */
 801a7f4:	687b      	ldr	r3, [r7, #4]
 801a7f6:	2200      	movs	r2, #0
 801a7f8:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
 801a7fc:	687b      	ldr	r3, [r7, #4]
 801a7fe:	2200      	movs	r2, #0
 801a800:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  cinfo->unread_marker = 0;		/* no pending marker */
 801a804:	687b      	ldr	r3, [r7, #4]
 801a806:	2200      	movs	r2, #0
 801a808:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
  marker->pub.saw_SOI = FALSE;		/* set internal state too */
 801a80c:	68fb      	ldr	r3, [r7, #12]
 801a80e:	2200      	movs	r2, #0
 801a810:	60da      	str	r2, [r3, #12]
  marker->pub.saw_SOF = FALSE;
 801a812:	68fb      	ldr	r3, [r7, #12]
 801a814:	2200      	movs	r2, #0
 801a816:	611a      	str	r2, [r3, #16]
  marker->pub.discarded_bytes = 0;
 801a818:	68fb      	ldr	r3, [r7, #12]
 801a81a:	2200      	movs	r2, #0
 801a81c:	619a      	str	r2, [r3, #24]
  marker->cur_marker = NULL;
 801a81e:	68fb      	ldr	r3, [r7, #12]
 801a820:	2200      	movs	r2, #0
 801a822:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
}
 801a826:	bf00      	nop
 801a828:	3714      	adds	r7, #20
 801a82a:	46bd      	mov	sp, r7
 801a82c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a830:	4770      	bx	lr
	...

0801a834 <jinit_marker_reader>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
 801a834:	b580      	push	{r7, lr}
 801a836:	b084      	sub	sp, #16
 801a838:	af00      	add	r7, sp, #0
 801a83a:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker;
  int i;

  /* Create subobject in permanent pool */
  marker = (my_marker_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 801a83c:	687b      	ldr	r3, [r7, #4]
 801a83e:	685b      	ldr	r3, [r3, #4]
 801a840:	681b      	ldr	r3, [r3, #0]
 801a842:	22ac      	movs	r2, #172	@ 0xac
 801a844:	2100      	movs	r1, #0
 801a846:	6878      	ldr	r0, [r7, #4]
 801a848:	4798      	blx	r3
 801a84a:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_marker_reader));
  cinfo->marker = (struct jpeg_marker_reader *) marker;
 801a84c:	687b      	ldr	r3, [r7, #4]
 801a84e:	68ba      	ldr	r2, [r7, #8]
 801a850:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
  /* Initialize public method pointers */
  marker->pub.reset_marker_reader = reset_marker_reader;
 801a854:	68bb      	ldr	r3, [r7, #8]
 801a856:	4a18      	ldr	r2, [pc, #96]	@ (801a8b8 <jinit_marker_reader+0x84>)
 801a858:	601a      	str	r2, [r3, #0]
  marker->pub.read_markers = read_markers;
 801a85a:	68bb      	ldr	r3, [r7, #8]
 801a85c:	4a17      	ldr	r2, [pc, #92]	@ (801a8bc <jinit_marker_reader+0x88>)
 801a85e:	605a      	str	r2, [r3, #4]
  marker->pub.read_restart_marker = read_restart_marker;
 801a860:	68bb      	ldr	r3, [r7, #8]
 801a862:	4a17      	ldr	r2, [pc, #92]	@ (801a8c0 <jinit_marker_reader+0x8c>)
 801a864:	609a      	str	r2, [r3, #8]
  /* Initialize COM/APPn processing.
   * By default, we examine and then discard APP0 and APP14,
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
 801a866:	68bb      	ldr	r3, [r7, #8]
 801a868:	4a16      	ldr	r2, [pc, #88]	@ (801a8c4 <jinit_marker_reader+0x90>)
 801a86a:	61da      	str	r2, [r3, #28]
  marker->length_limit_COM = 0;
 801a86c:	68bb      	ldr	r3, [r7, #8]
 801a86e:	2200      	movs	r2, #0
 801a870:	661a      	str	r2, [r3, #96]	@ 0x60
  for (i = 0; i < 16; i++) {
 801a872:	2300      	movs	r3, #0
 801a874:	60fb      	str	r3, [r7, #12]
 801a876:	e00f      	b.n	801a898 <jinit_marker_reader+0x64>
    marker->process_APPn[i] = skip_variable;
 801a878:	68bb      	ldr	r3, [r7, #8]
 801a87a:	68fa      	ldr	r2, [r7, #12]
 801a87c:	3208      	adds	r2, #8
 801a87e:	4911      	ldr	r1, [pc, #68]	@ (801a8c4 <jinit_marker_reader+0x90>)
 801a880:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    marker->length_limit_APPn[i] = 0;
 801a884:	68ba      	ldr	r2, [r7, #8]
 801a886:	68fb      	ldr	r3, [r7, #12]
 801a888:	3318      	adds	r3, #24
 801a88a:	009b      	lsls	r3, r3, #2
 801a88c:	4413      	add	r3, r2
 801a88e:	2200      	movs	r2, #0
 801a890:	605a      	str	r2, [r3, #4]
  for (i = 0; i < 16; i++) {
 801a892:	68fb      	ldr	r3, [r7, #12]
 801a894:	3301      	adds	r3, #1
 801a896:	60fb      	str	r3, [r7, #12]
 801a898:	68fb      	ldr	r3, [r7, #12]
 801a89a:	2b0f      	cmp	r3, #15
 801a89c:	ddec      	ble.n	801a878 <jinit_marker_reader+0x44>
  }
  marker->process_APPn[0] = get_interesting_appn;
 801a89e:	68bb      	ldr	r3, [r7, #8]
 801a8a0:	4a09      	ldr	r2, [pc, #36]	@ (801a8c8 <jinit_marker_reader+0x94>)
 801a8a2:	621a      	str	r2, [r3, #32]
  marker->process_APPn[14] = get_interesting_appn;
 801a8a4:	68bb      	ldr	r3, [r7, #8]
 801a8a6:	4a08      	ldr	r2, [pc, #32]	@ (801a8c8 <jinit_marker_reader+0x94>)
 801a8a8:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
 801a8aa:	6878      	ldr	r0, [r7, #4]
 801a8ac:	f7ff ff9a 	bl	801a7e4 <reset_marker_reader>
}
 801a8b0:	bf00      	nop
 801a8b2:	3710      	adds	r7, #16
 801a8b4:	46bd      	mov	sp, r7
 801a8b6:	bd80      	pop	{r7, pc}
 801a8b8:	0801a7e5 	.word	0x0801a7e5
 801a8bc:	0801a2cd 	.word	0x0801a2cd
 801a8c0:	0801a629 	.word	0x0801a629
 801a8c4:	08019fb9 	.word	0x08019fb9
 801a8c8:	08019e3b 	.word	0x08019e3b

0801a8cc <use_merged_upsample>:
 * CRUCIAL: this must match the actual capabilities of jdmerge.c!
 */

LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
 801a8cc:	b480      	push	{r7}
 801a8ce:	b083      	sub	sp, #12
 801a8d0:	af00      	add	r7, sp, #0
 801a8d2:	6078      	str	r0, [r7, #4]
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
 801a8d4:	687b      	ldr	r3, [r7, #4]
 801a8d6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801a8d8:	2b00      	cmp	r3, #0
 801a8da:	d104      	bne.n	801a8e6 <use_merged_upsample+0x1a>
 801a8dc:	687b      	ldr	r3, [r7, #4]
 801a8de:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 801a8e2:	2b00      	cmp	r3, #0
 801a8e4:	d001      	beq.n	801a8ea <use_merged_upsample+0x1e>
    return FALSE;
 801a8e6:	2300      	movs	r3, #0
 801a8e8:	e07a      	b.n	801a9e0 <use_merged_upsample+0x114>
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 801a8ea:	687b      	ldr	r3, [r7, #4]
 801a8ec:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a8f0:	2b03      	cmp	r3, #3
 801a8f2:	d10c      	bne.n	801a90e <use_merged_upsample+0x42>
 801a8f4:	687b      	ldr	r3, [r7, #4]
 801a8f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a8f8:	2b03      	cmp	r3, #3
 801a8fa:	d108      	bne.n	801a90e <use_merged_upsample+0x42>
      cinfo->out_color_space != JCS_RGB ||
 801a8fc:	687b      	ldr	r3, [r7, #4]
 801a8fe:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 801a902:	2b02      	cmp	r3, #2
 801a904:	d103      	bne.n	801a90e <use_merged_upsample+0x42>
      cinfo->out_color_components != RGB_PIXELSIZE)
 801a906:	687b      	ldr	r3, [r7, #4]
 801a908:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
      cinfo->out_color_space != JCS_RGB ||
 801a90a:	2b03      	cmp	r3, #3
 801a90c:	d001      	beq.n	801a912 <use_merged_upsample+0x46>
    return FALSE;
 801a90e:	2300      	movs	r3, #0
 801a910:	e066      	b.n	801a9e0 <use_merged_upsample+0x114>
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 801a912:	687b      	ldr	r3, [r7, #4]
 801a914:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a918:	689b      	ldr	r3, [r3, #8]
 801a91a:	2b02      	cmp	r3, #2
 801a91c:	d121      	bne.n	801a962 <use_merged_upsample+0x96>
      cinfo->comp_info[1].h_samp_factor != 1 ||
 801a91e:	687b      	ldr	r3, [r7, #4]
 801a920:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a924:	3358      	adds	r3, #88	@ 0x58
 801a926:	689b      	ldr	r3, [r3, #8]
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 801a928:	2b01      	cmp	r3, #1
 801a92a:	d11a      	bne.n	801a962 <use_merged_upsample+0x96>
      cinfo->comp_info[2].h_samp_factor != 1 ||
 801a92c:	687b      	ldr	r3, [r7, #4]
 801a92e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a932:	33b0      	adds	r3, #176	@ 0xb0
 801a934:	689b      	ldr	r3, [r3, #8]
      cinfo->comp_info[1].h_samp_factor != 1 ||
 801a936:	2b01      	cmp	r3, #1
 801a938:	d113      	bne.n	801a962 <use_merged_upsample+0x96>
      cinfo->comp_info[0].v_samp_factor >  2 ||
 801a93a:	687b      	ldr	r3, [r7, #4]
 801a93c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a940:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[2].h_samp_factor != 1 ||
 801a942:	2b02      	cmp	r3, #2
 801a944:	dc0d      	bgt.n	801a962 <use_merged_upsample+0x96>
      cinfo->comp_info[1].v_samp_factor != 1 ||
 801a946:	687b      	ldr	r3, [r7, #4]
 801a948:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a94c:	3358      	adds	r3, #88	@ 0x58
 801a94e:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[0].v_samp_factor >  2 ||
 801a950:	2b01      	cmp	r3, #1
 801a952:	d106      	bne.n	801a962 <use_merged_upsample+0x96>
      cinfo->comp_info[2].v_samp_factor != 1)
 801a954:	687b      	ldr	r3, [r7, #4]
 801a956:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a95a:	33b0      	adds	r3, #176	@ 0xb0
 801a95c:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[1].v_samp_factor != 1 ||
 801a95e:	2b01      	cmp	r3, #1
 801a960:	d001      	beq.n	801a966 <use_merged_upsample+0x9a>
    return FALSE;
 801a962:	2300      	movs	r3, #0
 801a964:	e03c      	b.n	801a9e0 <use_merged_upsample+0x114>
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a966:	687b      	ldr	r3, [r7, #4]
 801a968:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a96c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801a96e:	687b      	ldr	r3, [r7, #4]
 801a970:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801a974:	429a      	cmp	r2, r3
 801a976:	d130      	bne.n	801a9da <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a978:	687b      	ldr	r3, [r7, #4]
 801a97a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a97e:	3358      	adds	r3, #88	@ 0x58
 801a980:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801a982:	687b      	ldr	r3, [r7, #4]
 801a984:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a988:	429a      	cmp	r2, r3
 801a98a:	d126      	bne.n	801a9da <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a98c:	687b      	ldr	r3, [r7, #4]
 801a98e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a992:	33b0      	adds	r3, #176	@ 0xb0
 801a994:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801a996:	687b      	ldr	r3, [r7, #4]
 801a998:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a99c:	429a      	cmp	r2, r3
 801a99e:	d11c      	bne.n	801a9da <use_merged_upsample+0x10e>
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801a9a0:	687b      	ldr	r3, [r7, #4]
 801a9a2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a9a6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801a9a8:	687b      	ldr	r3, [r7, #4]
 801a9aa:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801a9ae:	429a      	cmp	r2, r3
 801a9b0:	d113      	bne.n	801a9da <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801a9b2:	687b      	ldr	r3, [r7, #4]
 801a9b4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a9b8:	3358      	adds	r3, #88	@ 0x58
 801a9ba:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801a9bc:	687b      	ldr	r3, [r7, #4]
 801a9be:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801a9c2:	429a      	cmp	r2, r3
 801a9c4:	d109      	bne.n	801a9da <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size)
 801a9c6:	687b      	ldr	r3, [r7, #4]
 801a9c8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a9cc:	33b0      	adds	r3, #176	@ 0xb0
 801a9ce:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801a9d0:	687b      	ldr	r3, [r7, #4]
 801a9d2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801a9d6:	429a      	cmp	r2, r3
 801a9d8:	d001      	beq.n	801a9de <use_merged_upsample+0x112>
    return FALSE;
 801a9da:	2300      	movs	r3, #0
 801a9dc:	e000      	b.n	801a9e0 <use_merged_upsample+0x114>
  /* ??? also need to test for upsample-time rescaling, when & if supported */
  return TRUE;			/* by golly, it'll work... */
 801a9de:	2301      	movs	r3, #1
#else
  return FALSE;
#endif
}
 801a9e0:	4618      	mov	r0, r3
 801a9e2:	370c      	adds	r7, #12
 801a9e4:	46bd      	mov	sp, r7
 801a9e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a9ea:	4770      	bx	lr

0801a9ec <jpeg_calc_output_dimensions>:
GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for full decompression.
 */
{
 801a9ec:	b580      	push	{r7, lr}
 801a9ee:	b086      	sub	sp, #24
 801a9f0:	af00      	add	r7, sp, #0
 801a9f2:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;
#endif

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
 801a9f4:	687b      	ldr	r3, [r7, #4]
 801a9f6:	695b      	ldr	r3, [r3, #20]
 801a9f8:	2bca      	cmp	r3, #202	@ 0xca
 801a9fa:	d00d      	beq.n	801aa18 <jpeg_calc_output_dimensions+0x2c>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 801a9fc:	687b      	ldr	r3, [r7, #4]
 801a9fe:	681b      	ldr	r3, [r3, #0]
 801aa00:	2215      	movs	r2, #21
 801aa02:	615a      	str	r2, [r3, #20]
 801aa04:	687b      	ldr	r3, [r7, #4]
 801aa06:	681b      	ldr	r3, [r3, #0]
 801aa08:	687a      	ldr	r2, [r7, #4]
 801aa0a:	6952      	ldr	r2, [r2, #20]
 801aa0c:	619a      	str	r2, [r3, #24]
 801aa0e:	687b      	ldr	r3, [r7, #4]
 801aa10:	681b      	ldr	r3, [r3, #0]
 801aa12:	681b      	ldr	r3, [r3, #0]
 801aa14:	6878      	ldr	r0, [r7, #4]
 801aa16:	4798      	blx	r3

  /* Compute core output image dimensions and DCT scaling choices. */
  jpeg_core_output_dimensions(cinfo);
 801aa18:	6878      	ldr	r0, [r7, #4]
 801aa1a:	f7fc f80f 	bl	8016a3c <jpeg_core_output_dimensions>
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code adapts subsampling ratios which are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801aa1e:	2300      	movs	r3, #0
 801aa20:	617b      	str	r3, [r7, #20]
 801aa22:	687b      	ldr	r3, [r7, #4]
 801aa24:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801aa28:	613b      	str	r3, [r7, #16]
 801aa2a:	e078      	b.n	801ab1e <jpeg_calc_output_dimensions+0x132>
       ci++, compptr++) {
    int ssize = 1;
 801aa2c:	2301      	movs	r3, #1
 801aa2e:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 801aa30:	e002      	b.n	801aa38 <jpeg_calc_output_dimensions+0x4c>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 801aa32:	68fb      	ldr	r3, [r7, #12]
 801aa34:	005b      	lsls	r3, r3, #1
 801aa36:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 801aa38:	687b      	ldr	r3, [r7, #4]
 801aa3a:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801aa3e:	68fa      	ldr	r2, [r7, #12]
 801aa40:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801aa44:	687a      	ldr	r2, [r7, #4]
 801aa46:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 801aa48:	2a00      	cmp	r2, #0
 801aa4a:	d001      	beq.n	801aa50 <jpeg_calc_output_dimensions+0x64>
 801aa4c:	2208      	movs	r2, #8
 801aa4e:	e000      	b.n	801aa52 <jpeg_calc_output_dimensions+0x66>
 801aa50:	2204      	movs	r2, #4
 801aa52:	429a      	cmp	r2, r3
 801aa54:	db0f      	blt.n	801aa76 <jpeg_calc_output_dimensions+0x8a>
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
 801aa56:	687b      	ldr	r3, [r7, #4]
 801aa58:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801aa5c:	693a      	ldr	r2, [r7, #16]
 801aa5e:	6892      	ldr	r2, [r2, #8]
 801aa60:	68f9      	ldr	r1, [r7, #12]
 801aa62:	fb01 f202 	mul.w	r2, r1, r2
 801aa66:	0052      	lsls	r2, r2, #1
 801aa68:	fb93 f1f2 	sdiv	r1, r3, r2
 801aa6c:	fb01 f202 	mul.w	r2, r1, r2
 801aa70:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801aa72:	2b00      	cmp	r3, #0
 801aa74:	d0dd      	beq.n	801aa32 <jpeg_calc_output_dimensions+0x46>
    }
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
 801aa76:	687b      	ldr	r3, [r7, #4]
 801aa78:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801aa7c:	68fa      	ldr	r2, [r7, #12]
 801aa7e:	fb03 f202 	mul.w	r2, r3, r2
 801aa82:	693b      	ldr	r3, [r7, #16]
 801aa84:	625a      	str	r2, [r3, #36]	@ 0x24
    ssize = 1;
 801aa86:	2301      	movs	r3, #1
 801aa88:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 801aa8a:	e002      	b.n	801aa92 <jpeg_calc_output_dimensions+0xa6>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 801aa8c:	68fb      	ldr	r3, [r7, #12]
 801aa8e:	005b      	lsls	r3, r3, #1
 801aa90:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 801aa92:	687b      	ldr	r3, [r7, #4]
 801aa94:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801aa98:	68fa      	ldr	r2, [r7, #12]
 801aa9a:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801aa9e:	687a      	ldr	r2, [r7, #4]
 801aaa0:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 801aaa2:	2a00      	cmp	r2, #0
 801aaa4:	d001      	beq.n	801aaaa <jpeg_calc_output_dimensions+0xbe>
 801aaa6:	2208      	movs	r2, #8
 801aaa8:	e000      	b.n	801aaac <jpeg_calc_output_dimensions+0xc0>
 801aaaa:	2204      	movs	r2, #4
 801aaac:	429a      	cmp	r2, r3
 801aaae:	db0f      	blt.n	801aad0 <jpeg_calc_output_dimensions+0xe4>
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
 801aab0:	687b      	ldr	r3, [r7, #4]
 801aab2:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801aab6:	693a      	ldr	r2, [r7, #16]
 801aab8:	68d2      	ldr	r2, [r2, #12]
 801aaba:	68f9      	ldr	r1, [r7, #12]
 801aabc:	fb01 f202 	mul.w	r2, r1, r2
 801aac0:	0052      	lsls	r2, r2, #1
 801aac2:	fb93 f1f2 	sdiv	r1, r3, r2
 801aac6:	fb01 f202 	mul.w	r2, r1, r2
 801aaca:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801aacc:	2b00      	cmp	r3, #0
 801aace:	d0dd      	beq.n	801aa8c <jpeg_calc_output_dimensions+0xa0>
    }
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 801aad0:	687b      	ldr	r3, [r7, #4]
 801aad2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801aad6:	68fa      	ldr	r2, [r7, #12]
 801aad8:	fb03 f202 	mul.w	r2, r3, r2
 801aadc:	693b      	ldr	r3, [r7, #16]
 801aade:	629a      	str	r2, [r3, #40]	@ 0x28

    /* We don't support IDCT ratios larger than 2. */
    if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
 801aae0:	693b      	ldr	r3, [r7, #16]
 801aae2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801aae4:	693b      	ldr	r3, [r7, #16]
 801aae6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801aae8:	005b      	lsls	r3, r3, #1
 801aaea:	429a      	cmp	r2, r3
 801aaec:	dd05      	ble.n	801aafa <jpeg_calc_output_dimensions+0x10e>
	compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size * 2;
 801aaee:	693b      	ldr	r3, [r7, #16]
 801aaf0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801aaf2:	005a      	lsls	r2, r3, #1
 801aaf4:	693b      	ldr	r3, [r7, #16]
 801aaf6:	625a      	str	r2, [r3, #36]	@ 0x24
 801aaf8:	e00b      	b.n	801ab12 <jpeg_calc_output_dimensions+0x126>
    else if (compptr->DCT_v_scaled_size > compptr->DCT_h_scaled_size * 2)
 801aafa:	693b      	ldr	r3, [r7, #16]
 801aafc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801aafe:	693b      	ldr	r3, [r7, #16]
 801ab00:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801ab02:	005b      	lsls	r3, r3, #1
 801ab04:	429a      	cmp	r2, r3
 801ab06:	dd04      	ble.n	801ab12 <jpeg_calc_output_dimensions+0x126>
	compptr->DCT_v_scaled_size = compptr->DCT_h_scaled_size * 2;
 801ab08:	693b      	ldr	r3, [r7, #16]
 801ab0a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801ab0c:	005a      	lsls	r2, r3, #1
 801ab0e:	693b      	ldr	r3, [r7, #16]
 801ab10:	629a      	str	r2, [r3, #40]	@ 0x28
       ci++, compptr++) {
 801ab12:	697b      	ldr	r3, [r7, #20]
 801ab14:	3301      	adds	r3, #1
 801ab16:	617b      	str	r3, [r7, #20]
 801ab18:	693b      	ldr	r3, [r7, #16]
 801ab1a:	3358      	adds	r3, #88	@ 0x58
 801ab1c:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801ab1e:	687b      	ldr	r3, [r7, #4]
 801ab20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801ab22:	697a      	ldr	r2, [r7, #20]
 801ab24:	429a      	cmp	r2, r3
 801ab26:	db81      	blt.n	801aa2c <jpeg_calc_output_dimensions+0x40>
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801ab28:	2300      	movs	r3, #0
 801ab2a:	617b      	str	r3, [r7, #20]
 801ab2c:	687b      	ldr	r3, [r7, #4]
 801ab2e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801ab32:	613b      	str	r3, [r7, #16]
 801ab34:	e039      	b.n	801abaa <jpeg_calc_output_dimensions+0x1be>
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width *
 801ab36:	687b      	ldr	r3, [r7, #4]
 801ab38:	69db      	ldr	r3, [r3, #28]
 801ab3a:	4619      	mov	r1, r3
		    (long) (compptr->h_samp_factor * compptr->DCT_h_scaled_size),
 801ab3c:	693b      	ldr	r3, [r7, #16]
 801ab3e:	689b      	ldr	r3, [r3, #8]
 801ab40:	693a      	ldr	r2, [r7, #16]
 801ab42:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801ab44:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 801ab48:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 801ab4c:	687b      	ldr	r3, [r7, #4]
 801ab4e:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801ab52:	687a      	ldr	r2, [r7, #4]
 801ab54:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801ab58:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 801ab5c:	4619      	mov	r1, r3
 801ab5e:	f012 f8a7 	bl	802ccb0 <jdiv_round_up>
 801ab62:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 801ab64:	461a      	mov	r2, r3
 801ab66:	693b      	ldr	r3, [r7, #16]
 801ab68:	62da      	str	r2, [r3, #44]	@ 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height *
 801ab6a:	687b      	ldr	r3, [r7, #4]
 801ab6c:	6a1b      	ldr	r3, [r3, #32]
 801ab6e:	4619      	mov	r1, r3
		    (long) (compptr->v_samp_factor * compptr->DCT_v_scaled_size),
 801ab70:	693b      	ldr	r3, [r7, #16]
 801ab72:	68db      	ldr	r3, [r3, #12]
 801ab74:	693a      	ldr	r2, [r7, #16]
 801ab76:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801ab78:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 801ab7c:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 801ab80:	687b      	ldr	r3, [r7, #4]
 801ab82:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801ab86:	687a      	ldr	r2, [r7, #4]
 801ab88:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801ab8c:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 801ab90:	4619      	mov	r1, r3
 801ab92:	f012 f88d 	bl	802ccb0 <jdiv_round_up>
 801ab96:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 801ab98:	461a      	mov	r2, r3
 801ab9a:	693b      	ldr	r3, [r7, #16]
 801ab9c:	631a      	str	r2, [r3, #48]	@ 0x30
       ci++, compptr++) {
 801ab9e:	697b      	ldr	r3, [r7, #20]
 801aba0:	3301      	adds	r3, #1
 801aba2:	617b      	str	r3, [r7, #20]
 801aba4:	693b      	ldr	r3, [r7, #16]
 801aba6:	3358      	adds	r3, #88	@ 0x58
 801aba8:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801abaa:	687b      	ldr	r3, [r7, #4]
 801abac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801abae:	697a      	ldr	r2, [r7, #20]
 801abb0:	429a      	cmp	r2, r3
 801abb2:	dbc0      	blt.n	801ab36 <jpeg_calc_output_dimensions+0x14a>

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
 801abb4:	687b      	ldr	r3, [r7, #4]
 801abb6:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 801abba:	3b01      	subs	r3, #1
 801abbc:	2b04      	cmp	r3, #4
 801abbe:	d81d      	bhi.n	801abfc <jpeg_calc_output_dimensions+0x210>
 801abc0:	a201      	add	r2, pc, #4	@ (adr r2, 801abc8 <jpeg_calc_output_dimensions+0x1dc>)
 801abc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801abc6:	bf00      	nop
 801abc8:	0801abdd 	.word	0x0801abdd
 801abcc:	0801abe5 	.word	0x0801abe5
 801abd0:	0801abed 	.word	0x0801abed
 801abd4:	0801abf5 	.word	0x0801abf5
 801abd8:	0801abf5 	.word	0x0801abf5
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 801abdc:	687b      	ldr	r3, [r7, #4]
 801abde:	2201      	movs	r2, #1
 801abe0:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801abe2:	e010      	b.n	801ac06 <jpeg_calc_output_dimensions+0x21a>
  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 801abe4:	687b      	ldr	r3, [r7, #4]
 801abe6:	2203      	movs	r2, #3
 801abe8:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801abea:	e00c      	b.n	801ac06 <jpeg_calc_output_dimensions+0x21a>
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
 801abec:	687b      	ldr	r3, [r7, #4]
 801abee:	2203      	movs	r2, #3
 801abf0:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801abf2:	e008      	b.n	801ac06 <jpeg_calc_output_dimensions+0x21a>
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
 801abf4:	687b      	ldr	r3, [r7, #4]
 801abf6:	2204      	movs	r2, #4
 801abf8:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801abfa:	e004      	b.n	801ac06 <jpeg_calc_output_dimensions+0x21a>
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
 801abfc:	687b      	ldr	r3, [r7, #4]
 801abfe:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801ac00:	687b      	ldr	r3, [r7, #4]
 801ac02:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801ac04:	bf00      	nop
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
 801ac06:	687b      	ldr	r3, [r7, #4]
 801ac08:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801ac0a:	2b00      	cmp	r3, #0
 801ac0c:	d102      	bne.n	801ac14 <jpeg_calc_output_dimensions+0x228>
 801ac0e:	687b      	ldr	r3, [r7, #4]
 801ac10:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801ac12:	e000      	b.n	801ac16 <jpeg_calc_output_dimensions+0x22a>
 801ac14:	2301      	movs	r3, #1
 801ac16:	687a      	ldr	r2, [r7, #4]
 801ac18:	67d3      	str	r3, [r2, #124]	@ 0x7c
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
 801ac1a:	6878      	ldr	r0, [r7, #4]
 801ac1c:	f7ff fe56 	bl	801a8cc <use_merged_upsample>
 801ac20:	4603      	mov	r3, r0
 801ac22:	2b00      	cmp	r3, #0
 801ac24:	d006      	beq.n	801ac34 <jpeg_calc_output_dimensions+0x248>
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
 801ac26:	687b      	ldr	r3, [r7, #4]
 801ac28:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801ac2c:	687b      	ldr	r3, [r7, #4]
 801ac2e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  else
    cinfo->rec_outbuf_height = 1;
}
 801ac32:	e003      	b.n	801ac3c <jpeg_calc_output_dimensions+0x250>
    cinfo->rec_outbuf_height = 1;
 801ac34:	687b      	ldr	r3, [r7, #4]
 801ac36:	2201      	movs	r2, #1
 801ac38:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
}
 801ac3c:	bf00      	nop
 801ac3e:	3718      	adds	r7, #24
 801ac40:	46bd      	mov	sp, r7
 801ac42:	bd80      	pop	{r7, pc}

0801ac44 <prepare_range_limit_table>:
 */

LOCAL(void)
prepare_range_limit_table (j_decompress_ptr cinfo)
/* Allocate and fill in the sample_range_limit table */
{
 801ac44:	b580      	push	{r7, lr}
 801ac46:	b084      	sub	sp, #16
 801ac48:	af00      	add	r7, sp, #0
 801ac4a:	6078      	str	r0, [r7, #4]
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801ac4c:	687b      	ldr	r3, [r7, #4]
 801ac4e:	685b      	ldr	r3, [r3, #4]
 801ac50:	681b      	ldr	r3, [r3, #0]
 801ac52:	f44f 62b0 	mov.w	r2, #1408	@ 0x580
 801ac56:	2101      	movs	r1, #1
 801ac58:	6878      	ldr	r0, [r7, #4]
 801ac5a:	4798      	blx	r3
 801ac5c:	60b8      	str	r0, [r7, #8]
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
 801ac5e:	68bb      	ldr	r3, [r7, #8]
 801ac60:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801ac64:	60bb      	str	r3, [r7, #8]
  cinfo->sample_range_limit = table;
 801ac66:	687b      	ldr	r3, [r7, #4]
 801ac68:	68ba      	ldr	r2, [r7, #8]
 801ac6a:	f8c3 214c 	str.w	r2, [r3, #332]	@ 0x14c
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
 801ac6e:	68bb      	ldr	r3, [r7, #8]
 801ac70:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 801ac74:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801ac78:	2100      	movs	r1, #0
 801ac7a:	4618      	mov	r0, r3
 801ac7c:	f012 fdb9 	bl	802d7f2 <memset>
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
 801ac80:	2300      	movs	r3, #0
 801ac82:	60fb      	str	r3, [r7, #12]
 801ac84:	e008      	b.n	801ac98 <prepare_range_limit_table+0x54>
    table[i] = (JSAMPLE) i;
 801ac86:	68fb      	ldr	r3, [r7, #12]
 801ac88:	68ba      	ldr	r2, [r7, #8]
 801ac8a:	4413      	add	r3, r2
 801ac8c:	68fa      	ldr	r2, [r7, #12]
 801ac8e:	b2d2      	uxtb	r2, r2
 801ac90:	701a      	strb	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++)
 801ac92:	68fb      	ldr	r3, [r7, #12]
 801ac94:	3301      	adds	r3, #1
 801ac96:	60fb      	str	r3, [r7, #12]
 801ac98:	68fb      	ldr	r3, [r7, #12]
 801ac9a:	2bff      	cmp	r3, #255	@ 0xff
 801ac9c:	ddf3      	ble.n	801ac86 <prepare_range_limit_table+0x42>
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
 801ac9e:	68bb      	ldr	r3, [r7, #8]
 801aca0:	3380      	adds	r3, #128	@ 0x80
 801aca2:	60bb      	str	r3, [r7, #8]
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 801aca4:	2380      	movs	r3, #128	@ 0x80
 801aca6:	60fb      	str	r3, [r7, #12]
 801aca8:	e007      	b.n	801acba <prepare_range_limit_table+0x76>
    table[i] = MAXJSAMPLE;
 801acaa:	68fb      	ldr	r3, [r7, #12]
 801acac:	68ba      	ldr	r2, [r7, #8]
 801acae:	4413      	add	r3, r2
 801acb0:	22ff      	movs	r2, #255	@ 0xff
 801acb2:	701a      	strb	r2, [r3, #0]
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 801acb4:	68fb      	ldr	r3, [r7, #12]
 801acb6:	3301      	adds	r3, #1
 801acb8:	60fb      	str	r3, [r7, #12]
 801acba:	68fb      	ldr	r3, [r7, #12]
 801acbc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801acc0:	dbf3      	blt.n	801acaa <prepare_range_limit_table+0x66>
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
 801acc2:	68bb      	ldr	r3, [r7, #8]
 801acc4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801acc8:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 801accc:	2100      	movs	r1, #0
 801acce:	4618      	mov	r0, r3
 801acd0:	f012 fd8f 	bl	802d7f2 <memset>
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
 801acd4:	68bb      	ldr	r3, [r7, #8]
 801acd6:	f503 7060 	add.w	r0, r3, #896	@ 0x380
 801acda:	687b      	ldr	r3, [r7, #4]
 801acdc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801ace0:	2280      	movs	r2, #128	@ 0x80
 801ace2:	4619      	mov	r1, r3
 801ace4:	f012 fe11 	bl	802d90a <memcpy>
	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
}
 801ace8:	bf00      	nop
 801acea:	3710      	adds	r7, #16
 801acec:	46bd      	mov	sp, r7
 801acee:	bd80      	pop	{r7, pc}

0801acf0 <master_selection>:
 * settings.
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
 801acf0:	b580      	push	{r7, lr}
 801acf2:	b088      	sub	sp, #32
 801acf4:	af00      	add	r7, sp, #0
 801acf6:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801acf8:	687b      	ldr	r3, [r7, #4]
 801acfa:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801acfe:	61bb      	str	r3, [r7, #24]
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
 801ad00:	6878      	ldr	r0, [r7, #4]
 801ad02:	f7ff fe73 	bl	801a9ec <jpeg_calc_output_dimensions>
  prepare_range_limit_table(cinfo);
 801ad06:	6878      	ldr	r0, [r7, #4]
 801ad08:	f7ff ff9c 	bl	801ac44 <prepare_range_limit_table>

  /* Width of an output scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
 801ad0c:	687b      	ldr	r3, [r7, #4]
 801ad0e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801ad10:	461a      	mov	r2, r3
 801ad12:	687b      	ldr	r3, [r7, #4]
 801ad14:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801ad16:	fb02 f303 	mul.w	r3, r2, r3
 801ad1a:	617b      	str	r3, [r7, #20]
  jd_samplesperrow = (JDIMENSION) samplesperrow;
 801ad1c:	697b      	ldr	r3, [r7, #20]
 801ad1e:	613b      	str	r3, [r7, #16]
  if ((long) jd_samplesperrow != samplesperrow)
 801ad20:	693b      	ldr	r3, [r7, #16]
 801ad22:	697a      	ldr	r2, [r7, #20]
 801ad24:	429a      	cmp	r2, r3
 801ad26:	d008      	beq.n	801ad3a <master_selection+0x4a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 801ad28:	687b      	ldr	r3, [r7, #4]
 801ad2a:	681b      	ldr	r3, [r3, #0]
 801ad2c:	2248      	movs	r2, #72	@ 0x48
 801ad2e:	615a      	str	r2, [r3, #20]
 801ad30:	687b      	ldr	r3, [r7, #4]
 801ad32:	681b      	ldr	r3, [r3, #0]
 801ad34:	681b      	ldr	r3, [r3, #0]
 801ad36:	6878      	ldr	r0, [r7, #4]
 801ad38:	4798      	blx	r3

  /* Initialize my private state */
  master->pass_number = 0;
 801ad3a:	69bb      	ldr	r3, [r7, #24]
 801ad3c:	2200      	movs	r2, #0
 801ad3e:	60da      	str	r2, [r3, #12]
  master->using_merged_upsample = use_merged_upsample(cinfo);
 801ad40:	6878      	ldr	r0, [r7, #4]
 801ad42:	f7ff fdc3 	bl	801a8cc <use_merged_upsample>
 801ad46:	4602      	mov	r2, r0
 801ad48:	69bb      	ldr	r3, [r7, #24]
 801ad4a:	611a      	str	r2, [r3, #16]

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
 801ad4c:	69bb      	ldr	r3, [r7, #24]
 801ad4e:	2200      	movs	r2, #0
 801ad50:	615a      	str	r2, [r3, #20]
  master->quantizer_2pass = NULL;
 801ad52:	69bb      	ldr	r3, [r7, #24]
 801ad54:	2200      	movs	r2, #0
 801ad56:	619a      	str	r2, [r3, #24]
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
 801ad58:	687b      	ldr	r3, [r7, #4]
 801ad5a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801ad5c:	2b00      	cmp	r3, #0
 801ad5e:	d003      	beq.n	801ad68 <master_selection+0x78>
 801ad60:	687b      	ldr	r3, [r7, #4]
 801ad62:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801ad64:	2b00      	cmp	r3, #0
 801ad66:	d108      	bne.n	801ad7a <master_selection+0x8a>
    cinfo->enable_1pass_quant = FALSE;
 801ad68:	687b      	ldr	r3, [r7, #4]
 801ad6a:	2200      	movs	r2, #0
 801ad6c:	665a      	str	r2, [r3, #100]	@ 0x64
    cinfo->enable_external_quant = FALSE;
 801ad6e:	687b      	ldr	r3, [r7, #4]
 801ad70:	2200      	movs	r2, #0
 801ad72:	669a      	str	r2, [r3, #104]	@ 0x68
    cinfo->enable_2pass_quant = FALSE;
 801ad74:	687b      	ldr	r3, [r7, #4]
 801ad76:	2200      	movs	r2, #0
 801ad78:	66da      	str	r2, [r3, #108]	@ 0x6c
  }
  if (cinfo->quantize_colors) {
 801ad7a:	687b      	ldr	r3, [r7, #4]
 801ad7c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801ad7e:	2b00      	cmp	r3, #0
 801ad80:	d04e      	beq.n	801ae20 <master_selection+0x130>
    if (cinfo->raw_data_out)
 801ad82:	687b      	ldr	r3, [r7, #4]
 801ad84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801ad86:	2b00      	cmp	r3, #0
 801ad88:	d008      	beq.n	801ad9c <master_selection+0xac>
      ERREXIT(cinfo, JERR_NOTIMPL);
 801ad8a:	687b      	ldr	r3, [r7, #4]
 801ad8c:	681b      	ldr	r3, [r3, #0]
 801ad8e:	2230      	movs	r2, #48	@ 0x30
 801ad90:	615a      	str	r2, [r3, #20]
 801ad92:	687b      	ldr	r3, [r7, #4]
 801ad94:	681b      	ldr	r3, [r3, #0]
 801ad96:	681b      	ldr	r3, [r3, #0]
 801ad98:	6878      	ldr	r0, [r7, #4]
 801ad9a:	4798      	blx	r3
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
 801ad9c:	687b      	ldr	r3, [r7, #4]
 801ad9e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801ada0:	2b03      	cmp	r3, #3
 801ada2:	d00d      	beq.n	801adc0 <master_selection+0xd0>
      cinfo->enable_1pass_quant = TRUE;
 801ada4:	687b      	ldr	r3, [r7, #4]
 801ada6:	2201      	movs	r2, #1
 801ada8:	665a      	str	r2, [r3, #100]	@ 0x64
      cinfo->enable_external_quant = FALSE;
 801adaa:	687b      	ldr	r3, [r7, #4]
 801adac:	2200      	movs	r2, #0
 801adae:	669a      	str	r2, [r3, #104]	@ 0x68
      cinfo->enable_2pass_quant = FALSE;
 801adb0:	687b      	ldr	r3, [r7, #4]
 801adb2:	2200      	movs	r2, #0
 801adb4:	66da      	str	r2, [r3, #108]	@ 0x6c
      cinfo->colormap = NULL;
 801adb6:	687b      	ldr	r3, [r7, #4]
 801adb8:	2200      	movs	r2, #0
 801adba:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 801adbe:	e013      	b.n	801ade8 <master_selection+0xf8>
    } else if (cinfo->colormap != NULL) {
 801adc0:	687b      	ldr	r3, [r7, #4]
 801adc2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801adc6:	2b00      	cmp	r3, #0
 801adc8:	d003      	beq.n	801add2 <master_selection+0xe2>
      cinfo->enable_external_quant = TRUE;
 801adca:	687b      	ldr	r3, [r7, #4]
 801adcc:	2201      	movs	r2, #1
 801adce:	669a      	str	r2, [r3, #104]	@ 0x68
 801add0:	e00a      	b.n	801ade8 <master_selection+0xf8>
    } else if (cinfo->two_pass_quantize) {
 801add2:	687b      	ldr	r3, [r7, #4]
 801add4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801add6:	2b00      	cmp	r3, #0
 801add8:	d003      	beq.n	801ade2 <master_selection+0xf2>
      cinfo->enable_2pass_quant = TRUE;
 801adda:	687b      	ldr	r3, [r7, #4]
 801addc:	2201      	movs	r2, #1
 801adde:	66da      	str	r2, [r3, #108]	@ 0x6c
 801ade0:	e002      	b.n	801ade8 <master_selection+0xf8>
    } else {
      cinfo->enable_1pass_quant = TRUE;
 801ade2:	687b      	ldr	r3, [r7, #4]
 801ade4:	2201      	movs	r2, #1
 801ade6:	665a      	str	r2, [r3, #100]	@ 0x64
    }

    if (cinfo->enable_1pass_quant) {
 801ade8:	687b      	ldr	r3, [r7, #4]
 801adea:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801adec:	2b00      	cmp	r3, #0
 801adee:	d007      	beq.n	801ae00 <master_selection+0x110>
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
 801adf0:	6878      	ldr	r0, [r7, #4]
 801adf2:	f010 faaf 	bl	802b354 <jinit_1pass_quantizer>
      master->quantizer_1pass = cinfo->cquantize;
 801adf6:	687b      	ldr	r3, [r7, #4]
 801adf8:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 801adfc:	69bb      	ldr	r3, [r7, #24]
 801adfe:	615a      	str	r2, [r3, #20]
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
 801ae00:	687b      	ldr	r3, [r7, #4]
 801ae02:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801ae04:	2b00      	cmp	r3, #0
 801ae06:	d103      	bne.n	801ae10 <master_selection+0x120>
 801ae08:	687b      	ldr	r3, [r7, #4]
 801ae0a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801ae0c:	2b00      	cmp	r3, #0
 801ae0e:	d007      	beq.n	801ae20 <master_selection+0x130>
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
 801ae10:	6878      	ldr	r0, [r7, #4]
 801ae12:	f011 fe99 	bl	802cb48 <jinit_2pass_quantizer>
      master->quantizer_2pass = cinfo->cquantize;
 801ae16:	687b      	ldr	r3, [r7, #4]
 801ae18:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 801ae1c:	69bb      	ldr	r3, [r7, #24]
 801ae1e:	619a      	str	r2, [r3, #24]
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
 801ae20:	687b      	ldr	r3, [r7, #4]
 801ae22:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801ae24:	2b00      	cmp	r3, #0
 801ae26:	d113      	bne.n	801ae50 <master_selection+0x160>
    if (master->using_merged_upsample) {
 801ae28:	69bb      	ldr	r3, [r7, #24]
 801ae2a:	691b      	ldr	r3, [r3, #16]
 801ae2c:	2b00      	cmp	r3, #0
 801ae2e:	d003      	beq.n	801ae38 <master_selection+0x148>
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
 801ae30:	6878      	ldr	r0, [r7, #4]
 801ae32:	f000 fc9f 	bl	801b774 <jinit_merged_upsampler>
 801ae36:	e005      	b.n	801ae44 <master_selection+0x154>
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
 801ae38:	6878      	ldr	r0, [r7, #4]
 801ae3a:	f7f9 f8b1 	bl	8013fa0 <jinit_color_deconverter>
      jinit_upsampler(cinfo);
 801ae3e:	6878      	ldr	r0, [r7, #4]
 801ae40:	f001 f88c 	bl	801bf5c <jinit_upsampler>
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
 801ae44:	687b      	ldr	r3, [r7, #4]
 801ae46:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801ae48:	4619      	mov	r1, r3
 801ae4a:	6878      	ldr	r0, [r7, #4]
 801ae4c:	f000 fe6c 	bl	801bb28 <jinit_d_post_controller>
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
 801ae50:	6878      	ldr	r0, [r7, #4]
 801ae52:	f7f9 fd07 	bl	8014864 <jinit_inverse_dct>
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code)
 801ae56:	687b      	ldr	r3, [r7, #4]
 801ae58:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 801ae5c:	2b00      	cmp	r3, #0
 801ae5e:	d003      	beq.n	801ae68 <master_selection+0x178>
    jinit_arith_decoder(cinfo);
 801ae60:	6878      	ldr	r0, [r7, #4]
 801ae62:	f7f7 fb05 	bl	8012470 <jinit_arith_decoder>
 801ae66:	e002      	b.n	801ae6e <master_selection+0x17e>
  else {
    jinit_huff_decoder(cinfo);
 801ae68:	6878      	ldr	r0, [r7, #4]
 801ae6a:	f7fb fd73 	bl	8016954 <jinit_huff_decoder>
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
 801ae6e:	687b      	ldr	r3, [r7, #4]
 801ae70:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801ae74:	691b      	ldr	r3, [r3, #16]
 801ae76:	2b00      	cmp	r3, #0
 801ae78:	d103      	bne.n	801ae82 <master_selection+0x192>
 801ae7a:	687b      	ldr	r3, [r7, #4]
 801ae7c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801ae7e:	2b00      	cmp	r3, #0
 801ae80:	d001      	beq.n	801ae86 <master_selection+0x196>
 801ae82:	2301      	movs	r3, #1
 801ae84:	e000      	b.n	801ae88 <master_selection+0x198>
 801ae86:	2300      	movs	r3, #0
 801ae88:	60fb      	str	r3, [r7, #12]
  jinit_d_coef_controller(cinfo, use_c_buffer);
 801ae8a:	68f9      	ldr	r1, [r7, #12]
 801ae8c:	6878      	ldr	r0, [r7, #4]
 801ae8e:	f7f8 fcbd 	bl	801380c <jinit_d_coef_controller>

  if (! cinfo->raw_data_out)
 801ae92:	687b      	ldr	r3, [r7, #4]
 801ae94:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801ae96:	2b00      	cmp	r3, #0
 801ae98:	d103      	bne.n	801aea2 <master_selection+0x1b2>
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
 801ae9a:	2100      	movs	r1, #0
 801ae9c:	6878      	ldr	r0, [r7, #4]
 801ae9e:	f7fd fa79 	bl	8018394 <jinit_d_main_controller>

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
 801aea2:	687b      	ldr	r3, [r7, #4]
 801aea4:	685b      	ldr	r3, [r3, #4]
 801aea6:	699b      	ldr	r3, [r3, #24]
 801aea8:	6878      	ldr	r0, [r7, #4]
 801aeaa:	4798      	blx	r3

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);
 801aeac:	687b      	ldr	r3, [r7, #4]
 801aeae:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801aeb2:	689b      	ldr	r3, [r3, #8]
 801aeb4:	6878      	ldr	r0, [r7, #4]
 801aeb6:	4798      	blx	r3
#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 801aeb8:	687b      	ldr	r3, [r7, #4]
 801aeba:	689b      	ldr	r3, [r3, #8]
 801aebc:	2b00      	cmp	r3, #0
 801aebe:	d03a      	beq.n	801af36 <master_selection+0x246>
 801aec0:	687b      	ldr	r3, [r7, #4]
 801aec2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801aec4:	2b00      	cmp	r3, #0
 801aec6:	d136      	bne.n	801af36 <master_selection+0x246>
      cinfo->inputctl->has_multiple_scans) {
 801aec8:	687b      	ldr	r3, [r7, #4]
 801aeca:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801aece:	691b      	ldr	r3, [r3, #16]
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 801aed0:	2b00      	cmp	r3, #0
 801aed2:	d030      	beq.n	801af36 <master_selection+0x246>
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
 801aed4:	687b      	ldr	r3, [r7, #4]
 801aed6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801aeda:	2b00      	cmp	r3, #0
 801aedc:	d007      	beq.n	801aeee <master_selection+0x1fe>
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
 801aede:	687b      	ldr	r3, [r7, #4]
 801aee0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801aee2:	4613      	mov	r3, r2
 801aee4:	005b      	lsls	r3, r3, #1
 801aee6:	4413      	add	r3, r2
 801aee8:	3302      	adds	r3, #2
 801aeea:	61fb      	str	r3, [r7, #28]
 801aeec:	e002      	b.n	801aef4 <master_selection+0x204>
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
 801aeee:	687b      	ldr	r3, [r7, #4]
 801aef0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801aef2:	61fb      	str	r3, [r7, #28]
    }
    cinfo->progress->pass_counter = 0L;
 801aef4:	687b      	ldr	r3, [r7, #4]
 801aef6:	689b      	ldr	r3, [r3, #8]
 801aef8:	2200      	movs	r2, #0
 801aefa:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
 801aefc:	687b      	ldr	r3, [r7, #4]
 801aefe:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801af02:	4619      	mov	r1, r3
 801af04:	687b      	ldr	r3, [r7, #4]
 801af06:	689b      	ldr	r3, [r3, #8]
 801af08:	69fa      	ldr	r2, [r7, #28]
 801af0a:	fb01 f202 	mul.w	r2, r1, r2
 801af0e:	609a      	str	r2, [r3, #8]
    cinfo->progress->completed_passes = 0;
 801af10:	687b      	ldr	r3, [r7, #4]
 801af12:	689b      	ldr	r3, [r3, #8]
 801af14:	2200      	movs	r2, #0
 801af16:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
 801af18:	687b      	ldr	r3, [r7, #4]
 801af1a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801af1c:	2b00      	cmp	r3, #0
 801af1e:	d001      	beq.n	801af24 <master_selection+0x234>
 801af20:	2203      	movs	r2, #3
 801af22:	e000      	b.n	801af26 <master_selection+0x236>
 801af24:	2202      	movs	r2, #2
 801af26:	687b      	ldr	r3, [r7, #4]
 801af28:	689b      	ldr	r3, [r3, #8]
 801af2a:	611a      	str	r2, [r3, #16]
    /* Count the input pass as done */
    master->pass_number++;
 801af2c:	69bb      	ldr	r3, [r7, #24]
 801af2e:	68db      	ldr	r3, [r3, #12]
 801af30:	1c5a      	adds	r2, r3, #1
 801af32:	69bb      	ldr	r3, [r7, #24]
 801af34:	60da      	str	r2, [r3, #12]
  }
#endif /* D_MULTISCAN_FILES_SUPPORTED */
}
 801af36:	bf00      	nop
 801af38:	3720      	adds	r7, #32
 801af3a:	46bd      	mov	sp, r7
 801af3c:	bd80      	pop	{r7, pc}

0801af3e <prepare_for_output_pass>:
 * (In the latter case, jdapistd.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
 801af3e:	b580      	push	{r7, lr}
 801af40:	b084      	sub	sp, #16
 801af42:	af00      	add	r7, sp, #0
 801af44:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801af46:	687b      	ldr	r3, [r7, #4]
 801af48:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801af4c:	60fb      	str	r3, [r7, #12]

  if (master->pub.is_dummy_pass) {
 801af4e:	68fb      	ldr	r3, [r7, #12]
 801af50:	689b      	ldr	r3, [r3, #8]
 801af52:	2b00      	cmp	r3, #0
 801af54:	d018      	beq.n	801af88 <prepare_for_output_pass+0x4a>
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
 801af56:	68fb      	ldr	r3, [r7, #12]
 801af58:	2200      	movs	r2, #0
 801af5a:	609a      	str	r2, [r3, #8]
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
 801af5c:	687b      	ldr	r3, [r7, #4]
 801af5e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801af62:	681b      	ldr	r3, [r3, #0]
 801af64:	2100      	movs	r1, #0
 801af66:	6878      	ldr	r0, [r7, #4]
 801af68:	4798      	blx	r3
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
 801af6a:	687b      	ldr	r3, [r7, #4]
 801af6c:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801af70:	681b      	ldr	r3, [r3, #0]
 801af72:	2102      	movs	r1, #2
 801af74:	6878      	ldr	r0, [r7, #4]
 801af76:	4798      	blx	r3
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
 801af78:	687b      	ldr	r3, [r7, #4]
 801af7a:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801af7e:	681b      	ldr	r3, [r3, #0]
 801af80:	2102      	movs	r1, #2
 801af82:	6878      	ldr	r0, [r7, #4]
 801af84:	4798      	blx	r3
 801af86:	e06e      	b.n	801b066 <prepare_for_output_pass+0x128>
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
 801af88:	687b      	ldr	r3, [r7, #4]
 801af8a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801af8c:	2b00      	cmp	r3, #0
 801af8e:	d028      	beq.n	801afe2 <prepare_for_output_pass+0xa4>
 801af90:	687b      	ldr	r3, [r7, #4]
 801af92:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801af96:	2b00      	cmp	r3, #0
 801af98:	d123      	bne.n	801afe2 <prepare_for_output_pass+0xa4>
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
 801af9a:	687b      	ldr	r3, [r7, #4]
 801af9c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801af9e:	2b00      	cmp	r3, #0
 801afa0:	d00c      	beq.n	801afbc <prepare_for_output_pass+0x7e>
 801afa2:	687b      	ldr	r3, [r7, #4]
 801afa4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801afa6:	2b00      	cmp	r3, #0
 801afa8:	d008      	beq.n	801afbc <prepare_for_output_pass+0x7e>
	cinfo->cquantize = master->quantizer_2pass;
 801afaa:	68fb      	ldr	r3, [r7, #12]
 801afac:	699a      	ldr	r2, [r3, #24]
 801afae:	687b      	ldr	r3, [r7, #4]
 801afb0:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
	master->pub.is_dummy_pass = TRUE;
 801afb4:	68fb      	ldr	r3, [r7, #12]
 801afb6:	2201      	movs	r2, #1
 801afb8:	609a      	str	r2, [r3, #8]
 801afba:	e012      	b.n	801afe2 <prepare_for_output_pass+0xa4>
      } else if (cinfo->enable_1pass_quant) {
 801afbc:	687b      	ldr	r3, [r7, #4]
 801afbe:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801afc0:	2b00      	cmp	r3, #0
 801afc2:	d005      	beq.n	801afd0 <prepare_for_output_pass+0x92>
	cinfo->cquantize = master->quantizer_1pass;
 801afc4:	68fb      	ldr	r3, [r7, #12]
 801afc6:	695a      	ldr	r2, [r3, #20]
 801afc8:	687b      	ldr	r3, [r7, #4]
 801afca:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
 801afce:	e008      	b.n	801afe2 <prepare_for_output_pass+0xa4>
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
 801afd0:	687b      	ldr	r3, [r7, #4]
 801afd2:	681b      	ldr	r3, [r3, #0]
 801afd4:	222f      	movs	r2, #47	@ 0x2f
 801afd6:	615a      	str	r2, [r3, #20]
 801afd8:	687b      	ldr	r3, [r7, #4]
 801afda:	681b      	ldr	r3, [r3, #0]
 801afdc:	681b      	ldr	r3, [r3, #0]
 801afde:	6878      	ldr	r0, [r7, #4]
 801afe0:	4798      	blx	r3
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
 801afe2:	687b      	ldr	r3, [r7, #4]
 801afe4:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
 801afe8:	681b      	ldr	r3, [r3, #0]
 801afea:	6878      	ldr	r0, [r7, #4]
 801afec:	4798      	blx	r3
    (*cinfo->coef->start_output_pass) (cinfo);
 801afee:	687b      	ldr	r3, [r7, #4]
 801aff0:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801aff4:	689b      	ldr	r3, [r3, #8]
 801aff6:	6878      	ldr	r0, [r7, #4]
 801aff8:	4798      	blx	r3
    if (! cinfo->raw_data_out) {
 801affa:	687b      	ldr	r3, [r7, #4]
 801affc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801affe:	2b00      	cmp	r3, #0
 801b000:	d131      	bne.n	801b066 <prepare_for_output_pass+0x128>
      if (! master->using_merged_upsample)
 801b002:	68fb      	ldr	r3, [r7, #12]
 801b004:	691b      	ldr	r3, [r3, #16]
 801b006:	2b00      	cmp	r3, #0
 801b008:	d105      	bne.n	801b016 <prepare_for_output_pass+0xd8>
	(*cinfo->cconvert->start_pass) (cinfo);
 801b00a:	687b      	ldr	r3, [r7, #4]
 801b00c:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 801b010:	681b      	ldr	r3, [r3, #0]
 801b012:	6878      	ldr	r0, [r7, #4]
 801b014:	4798      	blx	r3
      (*cinfo->upsample->start_pass) (cinfo);
 801b016:	687b      	ldr	r3, [r7, #4]
 801b018:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b01c:	681b      	ldr	r3, [r3, #0]
 801b01e:	6878      	ldr	r0, [r7, #4]
 801b020:	4798      	blx	r3
      if (cinfo->quantize_colors)
 801b022:	687b      	ldr	r3, [r7, #4]
 801b024:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801b026:	2b00      	cmp	r3, #0
 801b028:	d008      	beq.n	801b03c <prepare_for_output_pass+0xfe>
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
 801b02a:	687b      	ldr	r3, [r7, #4]
 801b02c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801b030:	681b      	ldr	r3, [r3, #0]
 801b032:	68fa      	ldr	r2, [r7, #12]
 801b034:	6892      	ldr	r2, [r2, #8]
 801b036:	4611      	mov	r1, r2
 801b038:	6878      	ldr	r0, [r7, #4]
 801b03a:	4798      	blx	r3
      (*cinfo->post->start_pass) (cinfo,
 801b03c:	687b      	ldr	r3, [r7, #4]
 801b03e:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801b042:	681b      	ldr	r3, [r3, #0]
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
 801b044:	68fa      	ldr	r2, [r7, #12]
 801b046:	6892      	ldr	r2, [r2, #8]
      (*cinfo->post->start_pass) (cinfo,
 801b048:	2a00      	cmp	r2, #0
 801b04a:	d001      	beq.n	801b050 <prepare_for_output_pass+0x112>
 801b04c:	2203      	movs	r2, #3
 801b04e:	e000      	b.n	801b052 <prepare_for_output_pass+0x114>
 801b050:	2200      	movs	r2, #0
 801b052:	4611      	mov	r1, r2
 801b054:	6878      	ldr	r0, [r7, #4]
 801b056:	4798      	blx	r3
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
 801b058:	687b      	ldr	r3, [r7, #4]
 801b05a:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801b05e:	681b      	ldr	r3, [r3, #0]
 801b060:	2100      	movs	r1, #0
 801b062:	6878      	ldr	r0, [r7, #4]
 801b064:	4798      	blx	r3
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
 801b066:	687b      	ldr	r3, [r7, #4]
 801b068:	689b      	ldr	r3, [r3, #8]
 801b06a:	2b00      	cmp	r3, #0
 801b06c:	d029      	beq.n	801b0c2 <prepare_for_output_pass+0x184>
    cinfo->progress->completed_passes = master->pass_number;
 801b06e:	687b      	ldr	r3, [r7, #4]
 801b070:	689b      	ldr	r3, [r3, #8]
 801b072:	68fa      	ldr	r2, [r7, #12]
 801b074:	68d2      	ldr	r2, [r2, #12]
 801b076:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = master->pass_number +
 801b078:	68fb      	ldr	r3, [r7, #12]
 801b07a:	68da      	ldr	r2, [r3, #12]
				    (master->pub.is_dummy_pass ? 2 : 1);
 801b07c:	68fb      	ldr	r3, [r7, #12]
 801b07e:	689b      	ldr	r3, [r3, #8]
 801b080:	2b00      	cmp	r3, #0
 801b082:	d001      	beq.n	801b088 <prepare_for_output_pass+0x14a>
 801b084:	2102      	movs	r1, #2
 801b086:	e000      	b.n	801b08a <prepare_for_output_pass+0x14c>
 801b088:	2101      	movs	r1, #1
    cinfo->progress->total_passes = master->pass_number +
 801b08a:	687b      	ldr	r3, [r7, #4]
 801b08c:	689b      	ldr	r3, [r3, #8]
 801b08e:	440a      	add	r2, r1
 801b090:	611a      	str	r2, [r3, #16]
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
 801b092:	687b      	ldr	r3, [r7, #4]
 801b094:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801b096:	2b00      	cmp	r3, #0
 801b098:	d013      	beq.n	801b0c2 <prepare_for_output_pass+0x184>
 801b09a:	687b      	ldr	r3, [r7, #4]
 801b09c:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801b0a0:	695b      	ldr	r3, [r3, #20]
 801b0a2:	2b00      	cmp	r3, #0
 801b0a4:	d10d      	bne.n	801b0c2 <prepare_for_output_pass+0x184>
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
 801b0a6:	687b      	ldr	r3, [r7, #4]
 801b0a8:	689b      	ldr	r3, [r3, #8]
 801b0aa:	691a      	ldr	r2, [r3, #16]
 801b0ac:	687b      	ldr	r3, [r7, #4]
 801b0ae:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801b0b0:	2b00      	cmp	r3, #0
 801b0b2:	d001      	beq.n	801b0b8 <prepare_for_output_pass+0x17a>
 801b0b4:	2102      	movs	r1, #2
 801b0b6:	e000      	b.n	801b0ba <prepare_for_output_pass+0x17c>
 801b0b8:	2101      	movs	r1, #1
 801b0ba:	687b      	ldr	r3, [r7, #4]
 801b0bc:	689b      	ldr	r3, [r3, #8]
 801b0be:	440a      	add	r2, r1
 801b0c0:	611a      	str	r2, [r3, #16]
    }
  }
}
 801b0c2:	bf00      	nop
 801b0c4:	3710      	adds	r7, #16
 801b0c6:	46bd      	mov	sp, r7
 801b0c8:	bd80      	pop	{r7, pc}

0801b0ca <finish_output_pass>:
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
 801b0ca:	b580      	push	{r7, lr}
 801b0cc:	b084      	sub	sp, #16
 801b0ce:	af00      	add	r7, sp, #0
 801b0d0:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801b0d2:	687b      	ldr	r3, [r7, #4]
 801b0d4:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801b0d8:	60fb      	str	r3, [r7, #12]

  if (cinfo->quantize_colors)
 801b0da:	687b      	ldr	r3, [r7, #4]
 801b0dc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801b0de:	2b00      	cmp	r3, #0
 801b0e0:	d005      	beq.n	801b0ee <finish_output_pass+0x24>
    (*cinfo->cquantize->finish_pass) (cinfo);
 801b0e2:	687b      	ldr	r3, [r7, #4]
 801b0e4:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801b0e8:	689b      	ldr	r3, [r3, #8]
 801b0ea:	6878      	ldr	r0, [r7, #4]
 801b0ec:	4798      	blx	r3
  master->pass_number++;
 801b0ee:	68fb      	ldr	r3, [r7, #12]
 801b0f0:	68db      	ldr	r3, [r3, #12]
 801b0f2:	1c5a      	adds	r2, r3, #1
 801b0f4:	68fb      	ldr	r3, [r7, #12]
 801b0f6:	60da      	str	r2, [r3, #12]
}
 801b0f8:	bf00      	nop
 801b0fa:	3710      	adds	r7, #16
 801b0fc:	46bd      	mov	sp, r7
 801b0fe:	bd80      	pop	{r7, pc}

0801b100 <jinit_master_decompress>:
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
 801b100:	b580      	push	{r7, lr}
 801b102:	b084      	sub	sp, #16
 801b104:	af00      	add	r7, sp, #0
 801b106:	6078      	str	r0, [r7, #4]
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b108:	687b      	ldr	r3, [r7, #4]
 801b10a:	685b      	ldr	r3, [r3, #4]
 801b10c:	681b      	ldr	r3, [r3, #0]
 801b10e:	221c      	movs	r2, #28
 801b110:	2101      	movs	r1, #1
 801b112:	6878      	ldr	r0, [r7, #4]
 801b114:	4798      	blx	r3
 801b116:	60f8      	str	r0, [r7, #12]
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
 801b118:	687b      	ldr	r3, [r7, #4]
 801b11a:	68fa      	ldr	r2, [r7, #12]
 801b11c:	f8c3 21b8 	str.w	r2, [r3, #440]	@ 0x1b8
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
 801b120:	68fb      	ldr	r3, [r7, #12]
 801b122:	4a07      	ldr	r2, [pc, #28]	@ (801b140 <jinit_master_decompress+0x40>)
 801b124:	601a      	str	r2, [r3, #0]
  master->pub.finish_output_pass = finish_output_pass;
 801b126:	68fb      	ldr	r3, [r7, #12]
 801b128:	4a06      	ldr	r2, [pc, #24]	@ (801b144 <jinit_master_decompress+0x44>)
 801b12a:	605a      	str	r2, [r3, #4]

  master->pub.is_dummy_pass = FALSE;
 801b12c:	68fb      	ldr	r3, [r7, #12]
 801b12e:	2200      	movs	r2, #0
 801b130:	609a      	str	r2, [r3, #8]

  master_selection(cinfo);
 801b132:	6878      	ldr	r0, [r7, #4]
 801b134:	f7ff fddc 	bl	801acf0 <master_selection>
}
 801b138:	bf00      	nop
 801b13a:	3710      	adds	r7, #16
 801b13c:	46bd      	mov	sp, r7
 801b13e:	bd80      	pop	{r7, pc}
 801b140:	0801af3f 	.word	0x0801af3f
 801b144:	0801b0cb 	.word	0x0801b0cb

0801b148 <build_ycc_rgb_table>:
 * This is taken directly from jdcolor.c; see that file for more info.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 801b148:	b580      	push	{r7, lr}
 801b14a:	b086      	sub	sp, #24
 801b14c:	af00      	add	r7, sp, #0
 801b14e:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b150:	687b      	ldr	r3, [r7, #4]
 801b152:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b156:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b158:	687b      	ldr	r3, [r7, #4]
 801b15a:	685b      	ldr	r3, [r3, #4]
 801b15c:	681b      	ldr	r3, [r3, #0]
 801b15e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801b162:	2101      	movs	r1, #1
 801b164:	6878      	ldr	r0, [r7, #4]
 801b166:	4798      	blx	r3
 801b168:	4602      	mov	r2, r0
  upsample->Cr_r_tab = (int *)
 801b16a:	68fb      	ldr	r3, [r7, #12]
 801b16c:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b16e:	687b      	ldr	r3, [r7, #4]
 801b170:	685b      	ldr	r3, [r3, #4]
 801b172:	681b      	ldr	r3, [r3, #0]
 801b174:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801b178:	2101      	movs	r1, #1
 801b17a:	6878      	ldr	r0, [r7, #4]
 801b17c:	4798      	blx	r3
 801b17e:	4602      	mov	r2, r0
  upsample->Cb_b_tab = (int *)
 801b180:	68fb      	ldr	r3, [r7, #12]
 801b182:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b184:	687b      	ldr	r3, [r7, #4]
 801b186:	685b      	ldr	r3, [r3, #4]
 801b188:	681b      	ldr	r3, [r3, #0]
 801b18a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801b18e:	2101      	movs	r1, #1
 801b190:	6878      	ldr	r0, [r7, #4]
 801b192:	4798      	blx	r3
 801b194:	4602      	mov	r2, r0
  upsample->Cr_g_tab = (INT32 *)
 801b196:	68fb      	ldr	r3, [r7, #12]
 801b198:	619a      	str	r2, [r3, #24]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b19a:	687b      	ldr	r3, [r7, #4]
 801b19c:	685b      	ldr	r3, [r3, #4]
 801b19e:	681b      	ldr	r3, [r3, #0]
 801b1a0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801b1a4:	2101      	movs	r1, #1
 801b1a6:	6878      	ldr	r0, [r7, #4]
 801b1a8:	4798      	blx	r3
 801b1aa:	4602      	mov	r2, r0
  upsample->Cb_g_tab = (INT32 *)
 801b1ac:	68fb      	ldr	r3, [r7, #12]
 801b1ae:	61da      	str	r2, [r3, #28]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 801b1b0:	2300      	movs	r3, #0
 801b1b2:	617b      	str	r3, [r7, #20]
 801b1b4:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 801b1b8:	613b      	str	r3, [r7, #16]
 801b1ba:	e035      	b.n	801b228 <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 801b1bc:	693b      	ldr	r3, [r7, #16]
 801b1be:	4a1e      	ldr	r2, [pc, #120]	@ (801b238 <build_ycc_rgb_table+0xf0>)
 801b1c0:	fb02 f303 	mul.w	r3, r2, r3
 801b1c4:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    upsample->Cr_r_tab[i] = (int)
 801b1c8:	68fb      	ldr	r3, [r7, #12]
 801b1ca:	6919      	ldr	r1, [r3, #16]
 801b1cc:	697b      	ldr	r3, [r7, #20]
 801b1ce:	009b      	lsls	r3, r3, #2
 801b1d0:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 801b1d2:	1412      	asrs	r2, r2, #16
    upsample->Cr_r_tab[i] = (int)
 801b1d4:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 801b1d6:	693b      	ldr	r3, [r7, #16]
 801b1d8:	4a18      	ldr	r2, [pc, #96]	@ (801b23c <build_ycc_rgb_table+0xf4>)
 801b1da:	fb02 f303 	mul.w	r3, r2, r3
 801b1de:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    upsample->Cb_b_tab[i] = (int)
 801b1e2:	68fb      	ldr	r3, [r7, #12]
 801b1e4:	6959      	ldr	r1, [r3, #20]
 801b1e6:	697b      	ldr	r3, [r7, #20]
 801b1e8:	009b      	lsls	r3, r3, #2
 801b1ea:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 801b1ec:	1412      	asrs	r2, r2, #16
    upsample->Cb_b_tab[i] = (int)
 801b1ee:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 801b1f0:	68fb      	ldr	r3, [r7, #12]
 801b1f2:	699a      	ldr	r2, [r3, #24]
 801b1f4:	697b      	ldr	r3, [r7, #20]
 801b1f6:	009b      	lsls	r3, r3, #2
 801b1f8:	4413      	add	r3, r2
 801b1fa:	693a      	ldr	r2, [r7, #16]
 801b1fc:	4910      	ldr	r1, [pc, #64]	@ (801b240 <build_ycc_rgb_table+0xf8>)
 801b1fe:	fb01 f202 	mul.w	r2, r1, r2
 801b202:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 801b204:	693b      	ldr	r3, [r7, #16]
 801b206:	4a0f      	ldr	r2, [pc, #60]	@ (801b244 <build_ycc_rgb_table+0xfc>)
 801b208:	fb03 f202 	mul.w	r2, r3, r2
 801b20c:	68fb      	ldr	r3, [r7, #12]
 801b20e:	69d9      	ldr	r1, [r3, #28]
 801b210:	697b      	ldr	r3, [r7, #20]
 801b212:	009b      	lsls	r3, r3, #2
 801b214:	440b      	add	r3, r1
 801b216:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 801b21a:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 801b21c:	697b      	ldr	r3, [r7, #20]
 801b21e:	3301      	adds	r3, #1
 801b220:	617b      	str	r3, [r7, #20]
 801b222:	693b      	ldr	r3, [r7, #16]
 801b224:	3301      	adds	r3, #1
 801b226:	613b      	str	r3, [r7, #16]
 801b228:	697b      	ldr	r3, [r7, #20]
 801b22a:	2bff      	cmp	r3, #255	@ 0xff
 801b22c:	ddc6      	ble.n	801b1bc <build_ycc_rgb_table+0x74>
  }
}
 801b22e:	bf00      	nop
 801b230:	bf00      	nop
 801b232:	3718      	adds	r7, #24
 801b234:	46bd      	mov	sp, r7
 801b236:	bd80      	pop	{r7, pc}
 801b238:	000166e9 	.word	0x000166e9
 801b23c:	0001c5a2 	.word	0x0001c5a2
 801b240:	ffff492e 	.word	0xffff492e
 801b244:	ffffa7e6 	.word	0xffffa7e6

0801b248 <start_pass_merged_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
 801b248:	b480      	push	{r7}
 801b24a:	b085      	sub	sp, #20
 801b24c:	af00      	add	r7, sp, #0
 801b24e:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b250:	687b      	ldr	r3, [r7, #4]
 801b252:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b256:	60fb      	str	r3, [r7, #12]

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
 801b258:	68fb      	ldr	r3, [r7, #12]
 801b25a:	2200      	movs	r2, #0
 801b25c:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 801b25e:	687b      	ldr	r3, [r7, #4]
 801b260:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801b262:	68fb      	ldr	r3, [r7, #12]
 801b264:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 801b266:	bf00      	nop
 801b268:	3714      	adds	r7, #20
 801b26a:	46bd      	mov	sp, r7
 801b26c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b270:	4770      	bx	lr

0801b272 <merged_2v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
 801b272:	b590      	push	{r4, r7, lr}
 801b274:	b08b      	sub	sp, #44	@ 0x2c
 801b276:	af02      	add	r7, sp, #8
 801b278:	60f8      	str	r0, [r7, #12]
 801b27a:	60b9      	str	r1, [r7, #8]
 801b27c:	607a      	str	r2, [r7, #4]
 801b27e:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b280:	68fb      	ldr	r3, [r7, #12]
 801b282:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b286:	61bb      	str	r3, [r7, #24]
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
 801b288:	69bb      	ldr	r3, [r7, #24]
 801b28a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801b28c:	2b00      	cmp	r3, #0
 801b28e:	d016      	beq.n	801b2be <merged_2v_upsample+0x4c>
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
 801b290:	69bb      	ldr	r3, [r7, #24]
 801b292:	f103 0020 	add.w	r0, r3, #32
 801b296:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b298:	681b      	ldr	r3, [r3, #0]
 801b29a:	009b      	lsls	r3, r3, #2
 801b29c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b29e:	441a      	add	r2, r3
 801b2a0:	69bb      	ldr	r3, [r7, #24]
 801b2a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801b2a4:	9301      	str	r3, [sp, #4]
 801b2a6:	2301      	movs	r3, #1
 801b2a8:	9300      	str	r3, [sp, #0]
 801b2aa:	2300      	movs	r3, #0
 801b2ac:	2100      	movs	r1, #0
 801b2ae:	f011 fd2b 	bl	802cd08 <jcopy_sample_rows>
		      1, upsample->out_row_width);
    num_rows = 1;
 801b2b2:	2301      	movs	r3, #1
 801b2b4:	61fb      	str	r3, [r7, #28]
    upsample->spare_full = FALSE;
 801b2b6:	69bb      	ldr	r3, [r7, #24]
 801b2b8:	2200      	movs	r2, #0
 801b2ba:	625a      	str	r2, [r3, #36]	@ 0x24
 801b2bc:	e036      	b.n	801b32c <merged_2v_upsample+0xba>
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
 801b2be:	2302      	movs	r3, #2
 801b2c0:	61fb      	str	r3, [r7, #28]
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
 801b2c2:	69bb      	ldr	r3, [r7, #24]
 801b2c4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801b2c6:	69fa      	ldr	r2, [r7, #28]
 801b2c8:	429a      	cmp	r2, r3
 801b2ca:	d902      	bls.n	801b2d2 <merged_2v_upsample+0x60>
      num_rows = upsample->rows_to_go;
 801b2cc:	69bb      	ldr	r3, [r7, #24]
 801b2ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801b2d0:	61fb      	str	r3, [r7, #28]
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
 801b2d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b2d4:	681b      	ldr	r3, [r3, #0]
 801b2d6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801b2d8:	1ad3      	subs	r3, r2, r3
 801b2da:	63bb      	str	r3, [r7, #56]	@ 0x38
    if (num_rows > out_rows_avail)
 801b2dc:	69fa      	ldr	r2, [r7, #28]
 801b2de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b2e0:	429a      	cmp	r2, r3
 801b2e2:	d901      	bls.n	801b2e8 <merged_2v_upsample+0x76>
      num_rows = out_rows_avail;
 801b2e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b2e6:	61fb      	str	r3, [r7, #28]
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
 801b2e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b2ea:	681b      	ldr	r3, [r3, #0]
 801b2ec:	009b      	lsls	r3, r3, #2
 801b2ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b2f0:	4413      	add	r3, r2
 801b2f2:	681b      	ldr	r3, [r3, #0]
 801b2f4:	613b      	str	r3, [r7, #16]
    if (num_rows > 1) {
 801b2f6:	69fb      	ldr	r3, [r7, #28]
 801b2f8:	2b01      	cmp	r3, #1
 801b2fa:	d908      	bls.n	801b30e <merged_2v_upsample+0x9c>
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
 801b2fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b2fe:	681b      	ldr	r3, [r3, #0]
 801b300:	3301      	adds	r3, #1
 801b302:	009b      	lsls	r3, r3, #2
 801b304:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b306:	4413      	add	r3, r2
 801b308:	681b      	ldr	r3, [r3, #0]
 801b30a:	617b      	str	r3, [r7, #20]
 801b30c:	e005      	b.n	801b31a <merged_2v_upsample+0xa8>
    } else {
      work_ptrs[1] = upsample->spare_row;
 801b30e:	69bb      	ldr	r3, [r7, #24]
 801b310:	6a1b      	ldr	r3, [r3, #32]
 801b312:	617b      	str	r3, [r7, #20]
      upsample->spare_full = TRUE;
 801b314:	69bb      	ldr	r3, [r7, #24]
 801b316:	2201      	movs	r2, #1
 801b318:	625a      	str	r2, [r3, #36]	@ 0x24
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
 801b31a:	69bb      	ldr	r3, [r7, #24]
 801b31c:	68dc      	ldr	r4, [r3, #12]
 801b31e:	687b      	ldr	r3, [r7, #4]
 801b320:	681a      	ldr	r2, [r3, #0]
 801b322:	f107 0310 	add.w	r3, r7, #16
 801b326:	68b9      	ldr	r1, [r7, #8]
 801b328:	68f8      	ldr	r0, [r7, #12]
 801b32a:	47a0      	blx	r4
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
 801b32c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b32e:	681a      	ldr	r2, [r3, #0]
 801b330:	69fb      	ldr	r3, [r7, #28]
 801b332:	441a      	add	r2, r3
 801b334:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b336:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 801b338:	69bb      	ldr	r3, [r7, #24]
 801b33a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801b33c:	69fb      	ldr	r3, [r7, #28]
 801b33e:	1ad2      	subs	r2, r2, r3
 801b340:	69bb      	ldr	r3, [r7, #24]
 801b342:	62da      	str	r2, [r3, #44]	@ 0x2c
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
 801b344:	69bb      	ldr	r3, [r7, #24]
 801b346:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801b348:	2b00      	cmp	r3, #0
 801b34a:	d104      	bne.n	801b356 <merged_2v_upsample+0xe4>
    (*in_row_group_ctr)++;
 801b34c:	687b      	ldr	r3, [r7, #4]
 801b34e:	681b      	ldr	r3, [r3, #0]
 801b350:	1c5a      	adds	r2, r3, #1
 801b352:	687b      	ldr	r3, [r7, #4]
 801b354:	601a      	str	r2, [r3, #0]
}
 801b356:	bf00      	nop
 801b358:	3724      	adds	r7, #36	@ 0x24
 801b35a:	46bd      	mov	sp, r7
 801b35c:	bd90      	pop	{r4, r7, pc}

0801b35e <merged_1v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
 801b35e:	b590      	push	{r4, r7, lr}
 801b360:	b087      	sub	sp, #28
 801b362:	af00      	add	r7, sp, #0
 801b364:	60f8      	str	r0, [r7, #12]
 801b366:	60b9      	str	r1, [r7, #8]
 801b368:	607a      	str	r2, [r7, #4]
 801b36a:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b36c:	68fb      	ldr	r3, [r7, #12]
 801b36e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b372:	617b      	str	r3, [r7, #20]

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801b374:	697b      	ldr	r3, [r7, #20]
 801b376:	68dc      	ldr	r4, [r3, #12]
 801b378:	687b      	ldr	r3, [r7, #4]
 801b37a:	6819      	ldr	r1, [r3, #0]
			 output_buf + *out_row_ctr);
 801b37c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b37e:	681b      	ldr	r3, [r3, #0]
 801b380:	009b      	lsls	r3, r3, #2
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801b382:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b384:	4413      	add	r3, r2
 801b386:	460a      	mov	r2, r1
 801b388:	68b9      	ldr	r1, [r7, #8]
 801b38a:	68f8      	ldr	r0, [r7, #12]
 801b38c:	47a0      	blx	r4
  /* Adjust counts */
  (*out_row_ctr)++;
 801b38e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b390:	681b      	ldr	r3, [r3, #0]
 801b392:	1c5a      	adds	r2, r3, #1
 801b394:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b396:	601a      	str	r2, [r3, #0]
  (*in_row_group_ctr)++;
 801b398:	687b      	ldr	r3, [r7, #4]
 801b39a:	681b      	ldr	r3, [r3, #0]
 801b39c:	1c5a      	adds	r2, r3, #1
 801b39e:	687b      	ldr	r3, [r7, #4]
 801b3a0:	601a      	str	r2, [r3, #0]
}
 801b3a2:	bf00      	nop
 801b3a4:	371c      	adds	r7, #28
 801b3a6:	46bd      	mov	sp, r7
 801b3a8:	bd90      	pop	{r4, r7, pc}

0801b3aa <h2v1_merged_upsample>:

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 801b3aa:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801b3ae:	b093      	sub	sp, #76	@ 0x4c
 801b3b0:	af00      	add	r7, sp, #0
 801b3b2:	6178      	str	r0, [r7, #20]
 801b3b4:	6139      	str	r1, [r7, #16]
 801b3b6:	60fa      	str	r2, [r7, #12]
 801b3b8:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b3ba:	697b      	ldr	r3, [r7, #20]
 801b3bc:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b3c0:	637b      	str	r3, [r7, #52]	@ 0x34
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 801b3c2:	697b      	ldr	r3, [r7, #20]
 801b3c4:	f8d3 514c 	ldr.w	r5, [r3, #332]	@ 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 801b3c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b3ca:	691b      	ldr	r3, [r3, #16]
 801b3cc:	633b      	str	r3, [r7, #48]	@ 0x30
  int * Cbbtab = upsample->Cb_b_tab;
 801b3ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b3d0:	695b      	ldr	r3, [r3, #20]
 801b3d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  INT32 * Crgtab = upsample->Cr_g_tab;
 801b3d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b3d6:	699b      	ldr	r3, [r3, #24]
 801b3d8:	62bb      	str	r3, [r7, #40]	@ 0x28
  INT32 * Cbgtab = upsample->Cb_g_tab;
 801b3da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b3dc:	69db      	ldr	r3, [r3, #28]
 801b3de:	627b      	str	r3, [r7, #36]	@ 0x24
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
 801b3e0:	693b      	ldr	r3, [r7, #16]
 801b3e2:	681a      	ldr	r2, [r3, #0]
 801b3e4:	68fb      	ldr	r3, [r7, #12]
 801b3e6:	009b      	lsls	r3, r3, #2
 801b3e8:	4413      	add	r3, r2
 801b3ea:	681b      	ldr	r3, [r3, #0]
 801b3ec:	647b      	str	r3, [r7, #68]	@ 0x44
  inptr1 = input_buf[1][in_row_group_ctr];
 801b3ee:	693b      	ldr	r3, [r7, #16]
 801b3f0:	3304      	adds	r3, #4
 801b3f2:	681a      	ldr	r2, [r3, #0]
 801b3f4:	68fb      	ldr	r3, [r7, #12]
 801b3f6:	009b      	lsls	r3, r3, #2
 801b3f8:	4413      	add	r3, r2
 801b3fa:	681b      	ldr	r3, [r3, #0]
 801b3fc:	643b      	str	r3, [r7, #64]	@ 0x40
  inptr2 = input_buf[2][in_row_group_ctr];
 801b3fe:	693b      	ldr	r3, [r7, #16]
 801b400:	3308      	adds	r3, #8
 801b402:	681a      	ldr	r2, [r3, #0]
 801b404:	68fb      	ldr	r3, [r7, #12]
 801b406:	009b      	lsls	r3, r3, #2
 801b408:	4413      	add	r3, r2
 801b40a:	681b      	ldr	r3, [r3, #0]
 801b40c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  outptr = output_buf[0];
 801b40e:	68bb      	ldr	r3, [r7, #8]
 801b410:	681c      	ldr	r4, [r3, #0]
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801b412:	697b      	ldr	r3, [r7, #20]
 801b414:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801b416:	085b      	lsrs	r3, r3, #1
 801b418:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b41a:	e050      	b.n	801b4be <h2v1_merged_upsample+0x114>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 801b41c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b41e:	1c5a      	adds	r2, r3, #1
 801b420:	643a      	str	r2, [r7, #64]	@ 0x40
 801b422:	781b      	ldrb	r3, [r3, #0]
 801b424:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2++);
 801b426:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b428:	1c5a      	adds	r2, r3, #1
 801b42a:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801b42c:	781b      	ldrb	r3, [r3, #0]
 801b42e:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 801b430:	69fb      	ldr	r3, [r7, #28]
 801b432:	009b      	lsls	r3, r3, #2
 801b434:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b436:	4413      	add	r3, r2
 801b438:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801b43a:	6a3b      	ldr	r3, [r7, #32]
 801b43c:	009b      	lsls	r3, r3, #2
 801b43e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b440:	4413      	add	r3, r2
 801b442:	681a      	ldr	r2, [r3, #0]
 801b444:	69fb      	ldr	r3, [r7, #28]
 801b446:	009b      	lsls	r3, r3, #2
 801b448:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b44a:	440b      	add	r3, r1
 801b44c:	681b      	ldr	r3, [r3, #0]
 801b44e:	4413      	add	r3, r2
 801b450:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801b454:	6a3b      	ldr	r3, [r7, #32]
 801b456:	009b      	lsls	r3, r3, #2
 801b458:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b45a:	4413      	add	r3, r2
 801b45c:	681b      	ldr	r3, [r3, #0]
 801b45e:	607b      	str	r3, [r7, #4]
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
 801b460:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b462:	1c5a      	adds	r2, r3, #1
 801b464:	647a      	str	r2, [r7, #68]	@ 0x44
 801b466:	781b      	ldrb	r3, [r3, #0]
 801b468:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801b46a:	4601      	mov	r1, r0
 801b46c:	1873      	adds	r3, r6, r1
 801b46e:	442b      	add	r3, r5
 801b470:	781b      	ldrb	r3, [r3, #0]
 801b472:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801b474:	eb06 0308 	add.w	r3, r6, r8
 801b478:	18ea      	adds	r2, r5, r3
 801b47a:	1c63      	adds	r3, r4, #1
 801b47c:	7812      	ldrb	r2, [r2, #0]
 801b47e:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801b480:	6878      	ldr	r0, [r7, #4]
 801b482:	1833      	adds	r3, r6, r0
 801b484:	18ea      	adds	r2, r5, r3
 801b486:	1ca3      	adds	r3, r4, #2
 801b488:	7812      	ldrb	r2, [r2, #0]
 801b48a:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 801b48c:	3403      	adds	r4, #3
    y  = GETJSAMPLE(*inptr0++);
 801b48e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b490:	1c5a      	adds	r2, r3, #1
 801b492:	647a      	str	r2, [r7, #68]	@ 0x44
 801b494:	781b      	ldrb	r3, [r3, #0]
 801b496:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801b498:	1873      	adds	r3, r6, r1
 801b49a:	442b      	add	r3, r5
 801b49c:	781b      	ldrb	r3, [r3, #0]
 801b49e:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801b4a0:	eb06 0308 	add.w	r3, r6, r8
 801b4a4:	18ea      	adds	r2, r5, r3
 801b4a6:	1c63      	adds	r3, r4, #1
 801b4a8:	7812      	ldrb	r2, [r2, #0]
 801b4aa:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801b4ac:	1833      	adds	r3, r6, r0
 801b4ae:	18ea      	adds	r2, r5, r3
 801b4b0:	1ca3      	adds	r3, r4, #2
 801b4b2:	7812      	ldrb	r2, [r2, #0]
 801b4b4:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 801b4b6:	3403      	adds	r4, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801b4b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b4ba:	3b01      	subs	r3, #1
 801b4bc:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b4be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b4c0:	2b00      	cmp	r3, #0
 801b4c2:	d1ab      	bne.n	801b41c <h2v1_merged_upsample+0x72>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801b4c4:	697b      	ldr	r3, [r7, #20]
 801b4c6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801b4c8:	f003 0301 	and.w	r3, r3, #1
 801b4cc:	2b00      	cmp	r3, #0
 801b4ce:	d02e      	beq.n	801b52e <h2v1_merged_upsample+0x184>
    cb = GETJSAMPLE(*inptr1);
 801b4d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b4d2:	781b      	ldrb	r3, [r3, #0]
 801b4d4:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2);
 801b4d6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b4d8:	781b      	ldrb	r3, [r3, #0]
 801b4da:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 801b4dc:	69fb      	ldr	r3, [r7, #28]
 801b4de:	009b      	lsls	r3, r3, #2
 801b4e0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b4e2:	4413      	add	r3, r2
 801b4e4:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801b4e6:	6a3b      	ldr	r3, [r7, #32]
 801b4e8:	009b      	lsls	r3, r3, #2
 801b4ea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b4ec:	4413      	add	r3, r2
 801b4ee:	681a      	ldr	r2, [r3, #0]
 801b4f0:	69fb      	ldr	r3, [r7, #28]
 801b4f2:	009b      	lsls	r3, r3, #2
 801b4f4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b4f6:	440b      	add	r3, r1
 801b4f8:	681b      	ldr	r3, [r3, #0]
 801b4fa:	4413      	add	r3, r2
 801b4fc:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801b500:	6a3b      	ldr	r3, [r7, #32]
 801b502:	009b      	lsls	r3, r3, #2
 801b504:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b506:	4413      	add	r3, r2
 801b508:	6819      	ldr	r1, [r3, #0]
    y  = GETJSAMPLE(*inptr0);
 801b50a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b50c:	781b      	ldrb	r3, [r3, #0]
 801b50e:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801b510:	1833      	adds	r3, r6, r0
 801b512:	442b      	add	r3, r5
 801b514:	781b      	ldrb	r3, [r3, #0]
 801b516:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801b518:	eb06 0308 	add.w	r3, r6, r8
 801b51c:	18ea      	adds	r2, r5, r3
 801b51e:	1c63      	adds	r3, r4, #1
 801b520:	7812      	ldrb	r2, [r2, #0]
 801b522:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801b524:	1873      	adds	r3, r6, r1
 801b526:	18ea      	adds	r2, r5, r3
 801b528:	1ca3      	adds	r3, r4, #2
 801b52a:	7812      	ldrb	r2, [r2, #0]
 801b52c:	701a      	strb	r2, [r3, #0]
  }
}
 801b52e:	bf00      	nop
 801b530:	374c      	adds	r7, #76	@ 0x4c
 801b532:	46bd      	mov	sp, r7
 801b534:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 801b538:	4770      	bx	lr

0801b53a <h2v2_merged_upsample>:

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 801b53a:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801b53e:	b093      	sub	sp, #76	@ 0x4c
 801b540:	af00      	add	r7, sp, #0
 801b542:	6178      	str	r0, [r7, #20]
 801b544:	6139      	str	r1, [r7, #16]
 801b546:	60fa      	str	r2, [r7, #12]
 801b548:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801b54a:	697b      	ldr	r3, [r7, #20]
 801b54c:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b550:	633b      	str	r3, [r7, #48]	@ 0x30
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 801b552:	697b      	ldr	r3, [r7, #20]
 801b554:	f8d3 414c 	ldr.w	r4, [r3, #332]	@ 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 801b558:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b55a:	691b      	ldr	r3, [r3, #16]
 801b55c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  int * Cbbtab = upsample->Cb_b_tab;
 801b55e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b560:	695b      	ldr	r3, [r3, #20]
 801b562:	62bb      	str	r3, [r7, #40]	@ 0x28
  INT32 * Crgtab = upsample->Cr_g_tab;
 801b564:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b566:	699b      	ldr	r3, [r3, #24]
 801b568:	627b      	str	r3, [r7, #36]	@ 0x24
  INT32 * Cbgtab = upsample->Cb_g_tab;
 801b56a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b56c:	69db      	ldr	r3, [r3, #28]
 801b56e:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
 801b570:	693b      	ldr	r3, [r7, #16]
 801b572:	681a      	ldr	r2, [r3, #0]
 801b574:	68fb      	ldr	r3, [r7, #12]
 801b576:	00db      	lsls	r3, r3, #3
 801b578:	4413      	add	r3, r2
 801b57a:	681b      	ldr	r3, [r3, #0]
 801b57c:	647b      	str	r3, [r7, #68]	@ 0x44
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
 801b57e:	693b      	ldr	r3, [r7, #16]
 801b580:	681a      	ldr	r2, [r3, #0]
 801b582:	68fb      	ldr	r3, [r7, #12]
 801b584:	00db      	lsls	r3, r3, #3
 801b586:	3304      	adds	r3, #4
 801b588:	4413      	add	r3, r2
 801b58a:	681b      	ldr	r3, [r3, #0]
 801b58c:	643b      	str	r3, [r7, #64]	@ 0x40
  inptr1 = input_buf[1][in_row_group_ctr];
 801b58e:	693b      	ldr	r3, [r7, #16]
 801b590:	3304      	adds	r3, #4
 801b592:	681a      	ldr	r2, [r3, #0]
 801b594:	68fb      	ldr	r3, [r7, #12]
 801b596:	009b      	lsls	r3, r3, #2
 801b598:	4413      	add	r3, r2
 801b59a:	681b      	ldr	r3, [r3, #0]
 801b59c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  inptr2 = input_buf[2][in_row_group_ctr];
 801b59e:	693b      	ldr	r3, [r7, #16]
 801b5a0:	3308      	adds	r3, #8
 801b5a2:	681a      	ldr	r2, [r3, #0]
 801b5a4:	68fb      	ldr	r3, [r7, #12]
 801b5a6:	009b      	lsls	r3, r3, #2
 801b5a8:	4413      	add	r3, r2
 801b5aa:	681b      	ldr	r3, [r3, #0]
 801b5ac:	63bb      	str	r3, [r7, #56]	@ 0x38
  outptr0 = output_buf[0];
 801b5ae:	68bb      	ldr	r3, [r7, #8]
 801b5b0:	681b      	ldr	r3, [r3, #0]
 801b5b2:	607b      	str	r3, [r7, #4]
  outptr1 = output_buf[1];
 801b5b4:	68bb      	ldr	r3, [r7, #8]
 801b5b6:	685e      	ldr	r6, [r3, #4]
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801b5b8:	697b      	ldr	r3, [r7, #20]
 801b5ba:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801b5bc:	085b      	lsrs	r3, r3, #1
 801b5be:	637b      	str	r3, [r7, #52]	@ 0x34
 801b5c0:	e083      	b.n	801b6ca <h2v2_merged_upsample+0x190>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 801b5c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b5c4:	1c5a      	adds	r2, r3, #1
 801b5c6:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801b5c8:	781b      	ldrb	r3, [r3, #0]
 801b5ca:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2++);
 801b5cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b5ce:	1c5a      	adds	r2, r3, #1
 801b5d0:	63ba      	str	r2, [r7, #56]	@ 0x38
 801b5d2:	781b      	ldrb	r3, [r3, #0]
 801b5d4:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 801b5d6:	69bb      	ldr	r3, [r7, #24]
 801b5d8:	009b      	lsls	r3, r3, #2
 801b5da:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b5dc:	4413      	add	r3, r2
 801b5de:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801b5e0:	69fb      	ldr	r3, [r7, #28]
 801b5e2:	009b      	lsls	r3, r3, #2
 801b5e4:	6a3a      	ldr	r2, [r7, #32]
 801b5e6:	4413      	add	r3, r2
 801b5e8:	681a      	ldr	r2, [r3, #0]
 801b5ea:	69bb      	ldr	r3, [r7, #24]
 801b5ec:	009b      	lsls	r3, r3, #2
 801b5ee:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801b5f0:	440b      	add	r3, r1
 801b5f2:	681b      	ldr	r3, [r3, #0]
 801b5f4:	4413      	add	r3, r2
 801b5f6:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801b5fa:	69fb      	ldr	r3, [r7, #28]
 801b5fc:	009b      	lsls	r3, r3, #2
 801b5fe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b600:	4413      	add	r3, r2
 801b602:	681b      	ldr	r3, [r3, #0]
 801b604:	603b      	str	r3, [r7, #0]
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
 801b606:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b608:	1c5a      	adds	r2, r3, #1
 801b60a:	647a      	str	r2, [r7, #68]	@ 0x44
 801b60c:	781b      	ldrb	r3, [r3, #0]
 801b60e:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801b610:	4601      	mov	r1, r0
 801b612:	186b      	adds	r3, r5, r1
 801b614:	4423      	add	r3, r4
 801b616:	781b      	ldrb	r3, [r3, #0]
 801b618:	6878      	ldr	r0, [r7, #4]
 801b61a:	4602      	mov	r2, r0
 801b61c:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801b61e:	eb05 0308 	add.w	r3, r5, r8
 801b622:	18e2      	adds	r2, r4, r3
 801b624:	6078      	str	r0, [r7, #4]
 801b626:	1c43      	adds	r3, r0, #1
 801b628:	7812      	ldrb	r2, [r2, #0]
 801b62a:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801b62c:	6838      	ldr	r0, [r7, #0]
 801b62e:	182b      	adds	r3, r5, r0
 801b630:	18e2      	adds	r2, r4, r3
 801b632:	687d      	ldr	r5, [r7, #4]
 801b634:	1cab      	adds	r3, r5, #2
 801b636:	7812      	ldrb	r2, [r2, #0]
 801b638:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 801b63a:	3503      	adds	r5, #3
 801b63c:	607d      	str	r5, [r7, #4]
    y  = GETJSAMPLE(*inptr00++);
 801b63e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b640:	1c5a      	adds	r2, r3, #1
 801b642:	647a      	str	r2, [r7, #68]	@ 0x44
 801b644:	781b      	ldrb	r3, [r3, #0]
 801b646:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801b648:	186b      	adds	r3, r5, r1
 801b64a:	4423      	add	r3, r4
 801b64c:	781b      	ldrb	r3, [r3, #0]
 801b64e:	687a      	ldr	r2, [r7, #4]
 801b650:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801b652:	eb05 0308 	add.w	r3, r5, r8
 801b656:	18e2      	adds	r2, r4, r3
 801b658:	687b      	ldr	r3, [r7, #4]
 801b65a:	3301      	adds	r3, #1
 801b65c:	7812      	ldrb	r2, [r2, #0]
 801b65e:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801b660:	182b      	adds	r3, r5, r0
 801b662:	18e2      	adds	r2, r4, r3
 801b664:	687d      	ldr	r5, [r7, #4]
 801b666:	1cab      	adds	r3, r5, #2
 801b668:	7812      	ldrb	r2, [r2, #0]
 801b66a:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 801b66c:	1ceb      	adds	r3, r5, #3
 801b66e:	607b      	str	r3, [r7, #4]
    y  = GETJSAMPLE(*inptr01++);
 801b670:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b672:	1c5a      	adds	r2, r3, #1
 801b674:	643a      	str	r2, [r7, #64]	@ 0x40
 801b676:	781b      	ldrb	r3, [r3, #0]
 801b678:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801b67a:	186b      	adds	r3, r5, r1
 801b67c:	4423      	add	r3, r4
 801b67e:	781b      	ldrb	r3, [r3, #0]
 801b680:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801b682:	eb05 0308 	add.w	r3, r5, r8
 801b686:	18e2      	adds	r2, r4, r3
 801b688:	1c73      	adds	r3, r6, #1
 801b68a:	7812      	ldrb	r2, [r2, #0]
 801b68c:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801b68e:	182b      	adds	r3, r5, r0
 801b690:	18e2      	adds	r2, r4, r3
 801b692:	1cb3      	adds	r3, r6, #2
 801b694:	7812      	ldrb	r2, [r2, #0]
 801b696:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 801b698:	3603      	adds	r6, #3
    y  = GETJSAMPLE(*inptr01++);
 801b69a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b69c:	1c5a      	adds	r2, r3, #1
 801b69e:	643a      	str	r2, [r7, #64]	@ 0x40
 801b6a0:	781b      	ldrb	r3, [r3, #0]
 801b6a2:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801b6a4:	186b      	adds	r3, r5, r1
 801b6a6:	4423      	add	r3, r4
 801b6a8:	781b      	ldrb	r3, [r3, #0]
 801b6aa:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801b6ac:	eb05 0308 	add.w	r3, r5, r8
 801b6b0:	18e2      	adds	r2, r4, r3
 801b6b2:	1c73      	adds	r3, r6, #1
 801b6b4:	7812      	ldrb	r2, [r2, #0]
 801b6b6:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801b6b8:	182b      	adds	r3, r5, r0
 801b6ba:	18e2      	adds	r2, r4, r3
 801b6bc:	1cb3      	adds	r3, r6, #2
 801b6be:	7812      	ldrb	r2, [r2, #0]
 801b6c0:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 801b6c2:	3603      	adds	r6, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801b6c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b6c6:	3b01      	subs	r3, #1
 801b6c8:	637b      	str	r3, [r7, #52]	@ 0x34
 801b6ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b6cc:	2b00      	cmp	r3, #0
 801b6ce:	f47f af78 	bne.w	801b5c2 <h2v2_merged_upsample+0x88>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801b6d2:	697b      	ldr	r3, [r7, #20]
 801b6d4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801b6d6:	f003 0301 	and.w	r3, r3, #1
 801b6da:	2b00      	cmp	r3, #0
 801b6dc:	d044      	beq.n	801b768 <h2v2_merged_upsample+0x22e>
    cb = GETJSAMPLE(*inptr1);
 801b6de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b6e0:	781b      	ldrb	r3, [r3, #0]
 801b6e2:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2);
 801b6e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b6e6:	781b      	ldrb	r3, [r3, #0]
 801b6e8:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 801b6ea:	69bb      	ldr	r3, [r7, #24]
 801b6ec:	009b      	lsls	r3, r3, #2
 801b6ee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b6f0:	4413      	add	r3, r2
 801b6f2:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801b6f4:	69fb      	ldr	r3, [r7, #28]
 801b6f6:	009b      	lsls	r3, r3, #2
 801b6f8:	6a3a      	ldr	r2, [r7, #32]
 801b6fa:	4413      	add	r3, r2
 801b6fc:	681a      	ldr	r2, [r3, #0]
 801b6fe:	69bb      	ldr	r3, [r7, #24]
 801b700:	009b      	lsls	r3, r3, #2
 801b702:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801b704:	440b      	add	r3, r1
 801b706:	681b      	ldr	r3, [r3, #0]
 801b708:	4413      	add	r3, r2
 801b70a:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801b70e:	69fb      	ldr	r3, [r7, #28]
 801b710:	009b      	lsls	r3, r3, #2
 801b712:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b714:	4413      	add	r3, r2
 801b716:	681b      	ldr	r3, [r3, #0]
 801b718:	603b      	str	r3, [r7, #0]
    y  = GETJSAMPLE(*inptr00);
 801b71a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b71c:	781b      	ldrb	r3, [r3, #0]
 801b71e:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801b720:	182b      	adds	r3, r5, r0
 801b722:	4423      	add	r3, r4
 801b724:	781b      	ldrb	r3, [r3, #0]
 801b726:	6879      	ldr	r1, [r7, #4]
 801b728:	700b      	strb	r3, [r1, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801b72a:	eb05 0308 	add.w	r3, r5, r8
 801b72e:	18e2      	adds	r2, r4, r3
 801b730:	1c4b      	adds	r3, r1, #1
 801b732:	7812      	ldrb	r2, [r2, #0]
 801b734:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801b736:	683b      	ldr	r3, [r7, #0]
 801b738:	18eb      	adds	r3, r5, r3
 801b73a:	18e2      	adds	r2, r4, r3
 801b73c:	1c8b      	adds	r3, r1, #2
 801b73e:	7812      	ldrb	r2, [r2, #0]
 801b740:	701a      	strb	r2, [r3, #0]
    y  = GETJSAMPLE(*inptr01);
 801b742:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b744:	781b      	ldrb	r3, [r3, #0]
 801b746:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801b748:	182b      	adds	r3, r5, r0
 801b74a:	4423      	add	r3, r4
 801b74c:	781b      	ldrb	r3, [r3, #0]
 801b74e:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801b750:	eb05 0308 	add.w	r3, r5, r8
 801b754:	18e2      	adds	r2, r4, r3
 801b756:	1c73      	adds	r3, r6, #1
 801b758:	7812      	ldrb	r2, [r2, #0]
 801b75a:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801b75c:	683b      	ldr	r3, [r7, #0]
 801b75e:	18eb      	adds	r3, r5, r3
 801b760:	18e2      	adds	r2, r4, r3
 801b762:	1cb3      	adds	r3, r6, #2
 801b764:	7812      	ldrb	r2, [r2, #0]
 801b766:	701a      	strb	r2, [r3, #0]
  }
}
 801b768:	bf00      	nop
 801b76a:	374c      	adds	r7, #76	@ 0x4c
 801b76c:	46bd      	mov	sp, r7
 801b76e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 801b772:	4770      	bx	lr

0801b774 <jinit_merged_upsampler>:
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
 801b774:	b580      	push	{r7, lr}
 801b776:	b084      	sub	sp, #16
 801b778:	af00      	add	r7, sp, #0
 801b77a:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b77c:	687b      	ldr	r3, [r7, #4]
 801b77e:	685b      	ldr	r3, [r3, #4]
 801b780:	681b      	ldr	r3, [r3, #0]
 801b782:	2230      	movs	r2, #48	@ 0x30
 801b784:	2101      	movs	r1, #1
 801b786:	6878      	ldr	r0, [r7, #4]
 801b788:	4798      	blx	r3
 801b78a:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 801b78c:	687b      	ldr	r3, [r7, #4]
 801b78e:	68fa      	ldr	r2, [r7, #12]
 801b790:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
  upsample->pub.start_pass = start_pass_merged_upsample;
 801b794:	68fb      	ldr	r3, [r7, #12]
 801b796:	4a1a      	ldr	r2, [pc, #104]	@ (801b800 <jinit_merged_upsampler+0x8c>)
 801b798:	601a      	str	r2, [r3, #0]
  upsample->pub.need_context_rows = FALSE;
 801b79a:	68fb      	ldr	r3, [r7, #12]
 801b79c:	2200      	movs	r2, #0
 801b79e:	609a      	str	r2, [r3, #8]

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
 801b7a0:	687b      	ldr	r3, [r7, #4]
 801b7a2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801b7a4:	687a      	ldr	r2, [r7, #4]
 801b7a6:	6f92      	ldr	r2, [r2, #120]	@ 0x78
 801b7a8:	fb03 f202 	mul.w	r2, r3, r2
 801b7ac:	68fb      	ldr	r3, [r7, #12]
 801b7ae:	629a      	str	r2, [r3, #40]	@ 0x28

  if (cinfo->max_v_samp_factor == 2) {
 801b7b0:	687b      	ldr	r3, [r7, #4]
 801b7b2:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801b7b6:	2b02      	cmp	r3, #2
 801b7b8:	d111      	bne.n	801b7de <jinit_merged_upsampler+0x6a>
    upsample->pub.upsample = merged_2v_upsample;
 801b7ba:	68fb      	ldr	r3, [r7, #12]
 801b7bc:	4a11      	ldr	r2, [pc, #68]	@ (801b804 <jinit_merged_upsampler+0x90>)
 801b7be:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v2_merged_upsample;
 801b7c0:	68fb      	ldr	r3, [r7, #12]
 801b7c2:	4a11      	ldr	r2, [pc, #68]	@ (801b808 <jinit_merged_upsampler+0x94>)
 801b7c4:	60da      	str	r2, [r3, #12]
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b7c6:	687b      	ldr	r3, [r7, #4]
 801b7c8:	685b      	ldr	r3, [r3, #4]
 801b7ca:	685b      	ldr	r3, [r3, #4]
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
 801b7cc:	68fa      	ldr	r2, [r7, #12]
 801b7ce:	6a92      	ldr	r2, [r2, #40]	@ 0x28
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801b7d0:	2101      	movs	r1, #1
 801b7d2:	6878      	ldr	r0, [r7, #4]
 801b7d4:	4798      	blx	r3
 801b7d6:	4602      	mov	r2, r0
    upsample->spare_row = (JSAMPROW)
 801b7d8:	68fb      	ldr	r3, [r7, #12]
 801b7da:	621a      	str	r2, [r3, #32]
 801b7dc:	e008      	b.n	801b7f0 <jinit_merged_upsampler+0x7c>
  } else {
    upsample->pub.upsample = merged_1v_upsample;
 801b7de:	68fb      	ldr	r3, [r7, #12]
 801b7e0:	4a0a      	ldr	r2, [pc, #40]	@ (801b80c <jinit_merged_upsampler+0x98>)
 801b7e2:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v1_merged_upsample;
 801b7e4:	68fb      	ldr	r3, [r7, #12]
 801b7e6:	4a0a      	ldr	r2, [pc, #40]	@ (801b810 <jinit_merged_upsampler+0x9c>)
 801b7e8:	60da      	str	r2, [r3, #12]
    /* No spare row needed */
    upsample->spare_row = NULL;
 801b7ea:	68fb      	ldr	r3, [r7, #12]
 801b7ec:	2200      	movs	r2, #0
 801b7ee:	621a      	str	r2, [r3, #32]
  }

  build_ycc_rgb_table(cinfo);
 801b7f0:	6878      	ldr	r0, [r7, #4]
 801b7f2:	f7ff fca9 	bl	801b148 <build_ycc_rgb_table>
}
 801b7f6:	bf00      	nop
 801b7f8:	3710      	adds	r7, #16
 801b7fa:	46bd      	mov	sp, r7
 801b7fc:	bd80      	pop	{r7, pc}
 801b7fe:	bf00      	nop
 801b800:	0801b249 	.word	0x0801b249
 801b804:	0801b273 	.word	0x0801b273
 801b808:	0801b53b 	.word	0x0801b53b
 801b80c:	0801b35f 	.word	0x0801b35f
 801b810:	0801b3ab 	.word	0x0801b3ab

0801b814 <start_pass_dpost>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 801b814:	b590      	push	{r4, r7, lr}
 801b816:	b087      	sub	sp, #28
 801b818:	af02      	add	r7, sp, #8
 801b81a:	6078      	str	r0, [r7, #4]
 801b81c:	460b      	mov	r3, r1
 801b81e:	70fb      	strb	r3, [r7, #3]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801b820:	687b      	ldr	r3, [r7, #4]
 801b822:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801b826:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 801b828:	78fb      	ldrb	r3, [r7, #3]
 801b82a:	2b03      	cmp	r3, #3
 801b82c:	d028      	beq.n	801b880 <start_pass_dpost+0x6c>
 801b82e:	2b03      	cmp	r3, #3
 801b830:	dc48      	bgt.n	801b8c4 <start_pass_dpost+0xb0>
 801b832:	2b00      	cmp	r3, #0
 801b834:	d002      	beq.n	801b83c <start_pass_dpost+0x28>
 801b836:	2b02      	cmp	r3, #2
 801b838:	d033      	beq.n	801b8a2 <start_pass_dpost+0x8e>
 801b83a:	e043      	b.n	801b8c4 <start_pass_dpost+0xb0>
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
 801b83c:	687b      	ldr	r3, [r7, #4]
 801b83e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801b840:	2b00      	cmp	r3, #0
 801b842:	d016      	beq.n	801b872 <start_pass_dpost+0x5e>
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
 801b844:	68fb      	ldr	r3, [r7, #12]
 801b846:	4a2a      	ldr	r2, [pc, #168]	@ (801b8f0 <start_pass_dpost+0xdc>)
 801b848:	605a      	str	r2, [r3, #4]
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
 801b84a:	68fb      	ldr	r3, [r7, #12]
 801b84c:	68db      	ldr	r3, [r3, #12]
 801b84e:	2b00      	cmp	r3, #0
 801b850:	d142      	bne.n	801b8d8 <start_pass_dpost+0xc4>
	post->buffer = (*cinfo->mem->access_virt_sarray)
 801b852:	687b      	ldr	r3, [r7, #4]
 801b854:	685b      	ldr	r3, [r3, #4]
 801b856:	69dc      	ldr	r4, [r3, #28]
 801b858:	68fb      	ldr	r3, [r7, #12]
 801b85a:	6899      	ldr	r1, [r3, #8]
 801b85c:	68fb      	ldr	r3, [r7, #12]
 801b85e:	691b      	ldr	r3, [r3, #16]
 801b860:	2201      	movs	r2, #1
 801b862:	9200      	str	r2, [sp, #0]
 801b864:	2200      	movs	r2, #0
 801b866:	6878      	ldr	r0, [r7, #4]
 801b868:	47a0      	blx	r4
 801b86a:	4602      	mov	r2, r0
 801b86c:	68fb      	ldr	r3, [r7, #12]
 801b86e:	60da      	str	r2, [r3, #12]
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
    }
    break;
 801b870:	e032      	b.n	801b8d8 <start_pass_dpost+0xc4>
      post->pub.post_process_data = cinfo->upsample->upsample;
 801b872:	687b      	ldr	r3, [r7, #4]
 801b874:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b878:	685a      	ldr	r2, [r3, #4]
 801b87a:	68fb      	ldr	r3, [r7, #12]
 801b87c:	605a      	str	r2, [r3, #4]
    break;
 801b87e:	e02b      	b.n	801b8d8 <start_pass_dpost+0xc4>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
 801b880:	68fb      	ldr	r3, [r7, #12]
 801b882:	689b      	ldr	r3, [r3, #8]
 801b884:	2b00      	cmp	r3, #0
 801b886:	d108      	bne.n	801b89a <start_pass_dpost+0x86>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801b888:	687b      	ldr	r3, [r7, #4]
 801b88a:	681b      	ldr	r3, [r3, #0]
 801b88c:	2203      	movs	r2, #3
 801b88e:	615a      	str	r2, [r3, #20]
 801b890:	687b      	ldr	r3, [r7, #4]
 801b892:	681b      	ldr	r3, [r3, #0]
 801b894:	681b      	ldr	r3, [r3, #0]
 801b896:	6878      	ldr	r0, [r7, #4]
 801b898:	4798      	blx	r3
    post->pub.post_process_data = post_process_prepass;
 801b89a:	68fb      	ldr	r3, [r7, #12]
 801b89c:	4a15      	ldr	r2, [pc, #84]	@ (801b8f4 <start_pass_dpost+0xe0>)
 801b89e:	605a      	str	r2, [r3, #4]
    break;
 801b8a0:	e01b      	b.n	801b8da <start_pass_dpost+0xc6>
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
 801b8a2:	68fb      	ldr	r3, [r7, #12]
 801b8a4:	689b      	ldr	r3, [r3, #8]
 801b8a6:	2b00      	cmp	r3, #0
 801b8a8:	d108      	bne.n	801b8bc <start_pass_dpost+0xa8>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801b8aa:	687b      	ldr	r3, [r7, #4]
 801b8ac:	681b      	ldr	r3, [r3, #0]
 801b8ae:	2203      	movs	r2, #3
 801b8b0:	615a      	str	r2, [r3, #20]
 801b8b2:	687b      	ldr	r3, [r7, #4]
 801b8b4:	681b      	ldr	r3, [r3, #0]
 801b8b6:	681b      	ldr	r3, [r3, #0]
 801b8b8:	6878      	ldr	r0, [r7, #4]
 801b8ba:	4798      	blx	r3
    post->pub.post_process_data = post_process_2pass;
 801b8bc:	68fb      	ldr	r3, [r7, #12]
 801b8be:	4a0e      	ldr	r2, [pc, #56]	@ (801b8f8 <start_pass_dpost+0xe4>)
 801b8c0:	605a      	str	r2, [r3, #4]
    break;
 801b8c2:	e00a      	b.n	801b8da <start_pass_dpost+0xc6>
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801b8c4:	687b      	ldr	r3, [r7, #4]
 801b8c6:	681b      	ldr	r3, [r3, #0]
 801b8c8:	2203      	movs	r2, #3
 801b8ca:	615a      	str	r2, [r3, #20]
 801b8cc:	687b      	ldr	r3, [r7, #4]
 801b8ce:	681b      	ldr	r3, [r3, #0]
 801b8d0:	681b      	ldr	r3, [r3, #0]
 801b8d2:	6878      	ldr	r0, [r7, #4]
 801b8d4:	4798      	blx	r3
    break;
 801b8d6:	e000      	b.n	801b8da <start_pass_dpost+0xc6>
    break;
 801b8d8:	bf00      	nop
  }
  post->starting_row = post->next_row = 0;
 801b8da:	68fb      	ldr	r3, [r7, #12]
 801b8dc:	2200      	movs	r2, #0
 801b8de:	619a      	str	r2, [r3, #24]
 801b8e0:	68fb      	ldr	r3, [r7, #12]
 801b8e2:	699a      	ldr	r2, [r3, #24]
 801b8e4:	68fb      	ldr	r3, [r7, #12]
 801b8e6:	615a      	str	r2, [r3, #20]
}
 801b8e8:	bf00      	nop
 801b8ea:	3714      	adds	r7, #20
 801b8ec:	46bd      	mov	sp, r7
 801b8ee:	bd90      	pop	{r4, r7, pc}
 801b8f0:	0801b8fd 	.word	0x0801b8fd
 801b8f4:	0801b983 	.word	0x0801b983
 801b8f8:	0801ba4d 	.word	0x0801ba4d

0801b8fc <post_process_1pass>:
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 801b8fc:	b590      	push	{r4, r7, lr}
 801b8fe:	b08d      	sub	sp, #52	@ 0x34
 801b900:	af04      	add	r7, sp, #16
 801b902:	60f8      	str	r0, [r7, #12]
 801b904:	60b9      	str	r1, [r7, #8]
 801b906:	607a      	str	r2, [r7, #4]
 801b908:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801b90a:	68fb      	ldr	r3, [r7, #12]
 801b90c:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801b910:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
 801b912:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b914:	681b      	ldr	r3, [r3, #0]
 801b916:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801b918:	1ad3      	subs	r3, r2, r3
 801b91a:	61fb      	str	r3, [r7, #28]
  if (max_rows > post->strip_height)
 801b91c:	69bb      	ldr	r3, [r7, #24]
 801b91e:	691b      	ldr	r3, [r3, #16]
 801b920:	69fa      	ldr	r2, [r7, #28]
 801b922:	429a      	cmp	r2, r3
 801b924:	d902      	bls.n	801b92c <post_process_1pass+0x30>
    max_rows = post->strip_height;
 801b926:	69bb      	ldr	r3, [r7, #24]
 801b928:	691b      	ldr	r3, [r3, #16]
 801b92a:	61fb      	str	r3, [r7, #28]
  num_rows = 0;
 801b92c:	2300      	movs	r3, #0
 801b92e:	617b      	str	r3, [r7, #20]
  (*cinfo->upsample->upsample) (cinfo,
 801b930:	68fb      	ldr	r3, [r7, #12]
 801b932:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b936:	685c      	ldr	r4, [r3, #4]
 801b938:	69bb      	ldr	r3, [r7, #24]
 801b93a:	68db      	ldr	r3, [r3, #12]
 801b93c:	69fa      	ldr	r2, [r7, #28]
 801b93e:	9202      	str	r2, [sp, #8]
 801b940:	f107 0214 	add.w	r2, r7, #20
 801b944:	9201      	str	r2, [sp, #4]
 801b946:	9300      	str	r3, [sp, #0]
 801b948:	683b      	ldr	r3, [r7, #0]
 801b94a:	687a      	ldr	r2, [r7, #4]
 801b94c:	68b9      	ldr	r1, [r7, #8]
 801b94e:	68f8      	ldr	r0, [r7, #12]
 801b950:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 801b952:	68fb      	ldr	r3, [r7, #12]
 801b954:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801b958:	685c      	ldr	r4, [r3, #4]
 801b95a:	69bb      	ldr	r3, [r7, #24]
 801b95c:	68d9      	ldr	r1, [r3, #12]
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
 801b95e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b960:	681b      	ldr	r3, [r3, #0]
 801b962:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801b964:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b966:	441a      	add	r2, r3
 801b968:	697b      	ldr	r3, [r7, #20]
 801b96a:	68f8      	ldr	r0, [r7, #12]
 801b96c:	47a0      	blx	r4
  *out_row_ctr += num_rows;
 801b96e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b970:	681a      	ldr	r2, [r3, #0]
 801b972:	697b      	ldr	r3, [r7, #20]
 801b974:	441a      	add	r2, r3
 801b976:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b978:	601a      	str	r2, [r3, #0]
}
 801b97a:	bf00      	nop
 801b97c:	3724      	adds	r7, #36	@ 0x24
 801b97e:	46bd      	mov	sp, r7
 801b980:	bd90      	pop	{r4, r7, pc}

0801b982 <post_process_prepass>:
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
 801b982:	b590      	push	{r4, r7, lr}
 801b984:	b08d      	sub	sp, #52	@ 0x34
 801b986:	af04      	add	r7, sp, #16
 801b988:	60f8      	str	r0, [r7, #12]
 801b98a:	60b9      	str	r1, [r7, #8]
 801b98c:	607a      	str	r2, [r7, #4]
 801b98e:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801b990:	68fb      	ldr	r3, [r7, #12]
 801b992:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801b996:	61fb      	str	r3, [r7, #28]
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 801b998:	69fb      	ldr	r3, [r7, #28]
 801b99a:	699b      	ldr	r3, [r3, #24]
 801b99c:	2b00      	cmp	r3, #0
 801b99e:	d10f      	bne.n	801b9c0 <post_process_prepass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 801b9a0:	68fb      	ldr	r3, [r7, #12]
 801b9a2:	685b      	ldr	r3, [r3, #4]
 801b9a4:	69dc      	ldr	r4, [r3, #28]
 801b9a6:	69fb      	ldr	r3, [r7, #28]
 801b9a8:	6899      	ldr	r1, [r3, #8]
 801b9aa:	69fb      	ldr	r3, [r7, #28]
 801b9ac:	695a      	ldr	r2, [r3, #20]
 801b9ae:	69fb      	ldr	r3, [r7, #28]
 801b9b0:	691b      	ldr	r3, [r3, #16]
 801b9b2:	2001      	movs	r0, #1
 801b9b4:	9000      	str	r0, [sp, #0]
 801b9b6:	68f8      	ldr	r0, [r7, #12]
 801b9b8:	47a0      	blx	r4
 801b9ba:	4602      	mov	r2, r0
 801b9bc:	69fb      	ldr	r3, [r7, #28]
 801b9be:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
 801b9c0:	69fb      	ldr	r3, [r7, #28]
 801b9c2:	699b      	ldr	r3, [r3, #24]
 801b9c4:	61bb      	str	r3, [r7, #24]
  (*cinfo->upsample->upsample) (cinfo,
 801b9c6:	68fb      	ldr	r3, [r7, #12]
 801b9c8:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801b9cc:	685c      	ldr	r4, [r3, #4]
 801b9ce:	69fb      	ldr	r3, [r7, #28]
 801b9d0:	68db      	ldr	r3, [r3, #12]
 801b9d2:	69fa      	ldr	r2, [r7, #28]
 801b9d4:	3218      	adds	r2, #24
 801b9d6:	69f9      	ldr	r1, [r7, #28]
 801b9d8:	6909      	ldr	r1, [r1, #16]
 801b9da:	9102      	str	r1, [sp, #8]
 801b9dc:	9201      	str	r2, [sp, #4]
 801b9de:	9300      	str	r3, [sp, #0]
 801b9e0:	683b      	ldr	r3, [r7, #0]
 801b9e2:	687a      	ldr	r2, [r7, #4]
 801b9e4:	68b9      	ldr	r1, [r7, #8]
 801b9e6:	68f8      	ldr	r0, [r7, #12]
 801b9e8:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
 801b9ea:	69fb      	ldr	r3, [r7, #28]
 801b9ec:	699b      	ldr	r3, [r3, #24]
 801b9ee:	69ba      	ldr	r2, [r7, #24]
 801b9f0:	429a      	cmp	r2, r3
 801b9f2:	d217      	bcs.n	801ba24 <post_process_prepass+0xa2>
    num_rows = post->next_row - old_next_row;
 801b9f4:	69fb      	ldr	r3, [r7, #28]
 801b9f6:	699a      	ldr	r2, [r3, #24]
 801b9f8:	69bb      	ldr	r3, [r7, #24]
 801b9fa:	1ad3      	subs	r3, r2, r3
 801b9fc:	617b      	str	r3, [r7, #20]
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
 801b9fe:	68fb      	ldr	r3, [r7, #12]
 801ba00:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801ba04:	685c      	ldr	r4, [r3, #4]
 801ba06:	69fb      	ldr	r3, [r7, #28]
 801ba08:	68da      	ldr	r2, [r3, #12]
 801ba0a:	69bb      	ldr	r3, [r7, #24]
 801ba0c:	009b      	lsls	r3, r3, #2
 801ba0e:	18d1      	adds	r1, r2, r3
 801ba10:	697b      	ldr	r3, [r7, #20]
 801ba12:	2200      	movs	r2, #0
 801ba14:	68f8      	ldr	r0, [r7, #12]
 801ba16:	47a0      	blx	r4
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
 801ba18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ba1a:	681a      	ldr	r2, [r3, #0]
 801ba1c:	697b      	ldr	r3, [r7, #20]
 801ba1e:	441a      	add	r2, r3
 801ba20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ba22:	601a      	str	r2, [r3, #0]
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
 801ba24:	69fb      	ldr	r3, [r7, #28]
 801ba26:	699a      	ldr	r2, [r3, #24]
 801ba28:	69fb      	ldr	r3, [r7, #28]
 801ba2a:	691b      	ldr	r3, [r3, #16]
 801ba2c:	429a      	cmp	r2, r3
 801ba2e:	d309      	bcc.n	801ba44 <post_process_prepass+0xc2>
    post->starting_row += post->strip_height;
 801ba30:	69fb      	ldr	r3, [r7, #28]
 801ba32:	695a      	ldr	r2, [r3, #20]
 801ba34:	69fb      	ldr	r3, [r7, #28]
 801ba36:	691b      	ldr	r3, [r3, #16]
 801ba38:	441a      	add	r2, r3
 801ba3a:	69fb      	ldr	r3, [r7, #28]
 801ba3c:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 801ba3e:	69fb      	ldr	r3, [r7, #28]
 801ba40:	2200      	movs	r2, #0
 801ba42:	619a      	str	r2, [r3, #24]
  }
}
 801ba44:	bf00      	nop
 801ba46:	3724      	adds	r7, #36	@ 0x24
 801ba48:	46bd      	mov	sp, r7
 801ba4a:	bd90      	pop	{r4, r7, pc}

0801ba4c <post_process_2pass>:
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 801ba4c:	b590      	push	{r4, r7, lr}
 801ba4e:	b08b      	sub	sp, #44	@ 0x2c
 801ba50:	af02      	add	r7, sp, #8
 801ba52:	60f8      	str	r0, [r7, #12]
 801ba54:	60b9      	str	r1, [r7, #8]
 801ba56:	607a      	str	r2, [r7, #4]
 801ba58:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801ba5a:	68fb      	ldr	r3, [r7, #12]
 801ba5c:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801ba60:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 801ba62:	69bb      	ldr	r3, [r7, #24]
 801ba64:	699b      	ldr	r3, [r3, #24]
 801ba66:	2b00      	cmp	r3, #0
 801ba68:	d10f      	bne.n	801ba8a <post_process_2pass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 801ba6a:	68fb      	ldr	r3, [r7, #12]
 801ba6c:	685b      	ldr	r3, [r3, #4]
 801ba6e:	69dc      	ldr	r4, [r3, #28]
 801ba70:	69bb      	ldr	r3, [r7, #24]
 801ba72:	6899      	ldr	r1, [r3, #8]
 801ba74:	69bb      	ldr	r3, [r7, #24]
 801ba76:	695a      	ldr	r2, [r3, #20]
 801ba78:	69bb      	ldr	r3, [r7, #24]
 801ba7a:	691b      	ldr	r3, [r3, #16]
 801ba7c:	2000      	movs	r0, #0
 801ba7e:	9000      	str	r0, [sp, #0]
 801ba80:	68f8      	ldr	r0, [r7, #12]
 801ba82:	47a0      	blx	r4
 801ba84:	4602      	mov	r2, r0
 801ba86:	69bb      	ldr	r3, [r7, #24]
 801ba88:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
 801ba8a:	69bb      	ldr	r3, [r7, #24]
 801ba8c:	691a      	ldr	r2, [r3, #16]
 801ba8e:	69bb      	ldr	r3, [r7, #24]
 801ba90:	699b      	ldr	r3, [r3, #24]
 801ba92:	1ad3      	subs	r3, r2, r3
 801ba94:	61fb      	str	r3, [r7, #28]
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
 801ba96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ba98:	681b      	ldr	r3, [r3, #0]
 801ba9a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801ba9c:	1ad3      	subs	r3, r2, r3
 801ba9e:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 801baa0:	69fa      	ldr	r2, [r7, #28]
 801baa2:	697b      	ldr	r3, [r7, #20]
 801baa4:	429a      	cmp	r2, r3
 801baa6:	d901      	bls.n	801baac <post_process_2pass+0x60>
    num_rows = max_rows;
 801baa8:	697b      	ldr	r3, [r7, #20]
 801baaa:	61fb      	str	r3, [r7, #28]
  /* We have to check bottom of image here, can't depend on upsampler. */
  max_rows = cinfo->output_height - post->starting_row;
 801baac:	68fb      	ldr	r3, [r7, #12]
 801baae:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801bab0:	69bb      	ldr	r3, [r7, #24]
 801bab2:	695b      	ldr	r3, [r3, #20]
 801bab4:	1ad3      	subs	r3, r2, r3
 801bab6:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 801bab8:	69fa      	ldr	r2, [r7, #28]
 801baba:	697b      	ldr	r3, [r7, #20]
 801babc:	429a      	cmp	r2, r3
 801babe:	d901      	bls.n	801bac4 <post_process_2pass+0x78>
    num_rows = max_rows;
 801bac0:	697b      	ldr	r3, [r7, #20]
 801bac2:	61fb      	str	r3, [r7, #28]

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 801bac4:	68fb      	ldr	r3, [r7, #12]
 801bac6:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801baca:	685c      	ldr	r4, [r3, #4]
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 801bacc:	69bb      	ldr	r3, [r7, #24]
 801bace:	68da      	ldr	r2, [r3, #12]
 801bad0:	69bb      	ldr	r3, [r7, #24]
 801bad2:	699b      	ldr	r3, [r3, #24]
 801bad4:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801bad6:	18d1      	adds	r1, r2, r3
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 801bad8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bada:	681b      	ldr	r3, [r3, #0]
 801badc:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801bade:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801bae0:	441a      	add	r2, r3
 801bae2:	69fb      	ldr	r3, [r7, #28]
 801bae4:	68f8      	ldr	r0, [r7, #12]
 801bae6:	47a0      	blx	r4
		(int) num_rows);
  *out_row_ctr += num_rows;
 801bae8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801baea:	681a      	ldr	r2, [r3, #0]
 801baec:	69fb      	ldr	r3, [r7, #28]
 801baee:	441a      	add	r2, r3
 801baf0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801baf2:	601a      	str	r2, [r3, #0]

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
 801baf4:	69bb      	ldr	r3, [r7, #24]
 801baf6:	699a      	ldr	r2, [r3, #24]
 801baf8:	69fb      	ldr	r3, [r7, #28]
 801bafa:	441a      	add	r2, r3
 801bafc:	69bb      	ldr	r3, [r7, #24]
 801bafe:	619a      	str	r2, [r3, #24]
  if (post->next_row >= post->strip_height) {
 801bb00:	69bb      	ldr	r3, [r7, #24]
 801bb02:	699a      	ldr	r2, [r3, #24]
 801bb04:	69bb      	ldr	r3, [r7, #24]
 801bb06:	691b      	ldr	r3, [r3, #16]
 801bb08:	429a      	cmp	r2, r3
 801bb0a:	d309      	bcc.n	801bb20 <post_process_2pass+0xd4>
    post->starting_row += post->strip_height;
 801bb0c:	69bb      	ldr	r3, [r7, #24]
 801bb0e:	695a      	ldr	r2, [r3, #20]
 801bb10:	69bb      	ldr	r3, [r7, #24]
 801bb12:	691b      	ldr	r3, [r3, #16]
 801bb14:	441a      	add	r2, r3
 801bb16:	69bb      	ldr	r3, [r7, #24]
 801bb18:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 801bb1a:	69bb      	ldr	r3, [r7, #24]
 801bb1c:	2200      	movs	r2, #0
 801bb1e:	619a      	str	r2, [r3, #24]
  }
}
 801bb20:	bf00      	nop
 801bb22:	3724      	adds	r7, #36	@ 0x24
 801bb24:	46bd      	mov	sp, r7
 801bb26:	bd90      	pop	{r4, r7, pc}

0801bb28 <jinit_d_post_controller>:
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 801bb28:	b5b0      	push	{r4, r5, r7, lr}
 801bb2a:	b086      	sub	sp, #24
 801bb2c:	af02      	add	r7, sp, #8
 801bb2e:	6078      	str	r0, [r7, #4]
 801bb30:	6039      	str	r1, [r7, #0]
  my_post_ptr post;

  post = (my_post_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801bb32:	687b      	ldr	r3, [r7, #4]
 801bb34:	685b      	ldr	r3, [r3, #4]
 801bb36:	681b      	ldr	r3, [r3, #0]
 801bb38:	221c      	movs	r2, #28
 801bb3a:	2101      	movs	r1, #1
 801bb3c:	6878      	ldr	r0, [r7, #4]
 801bb3e:	4798      	blx	r3
 801bb40:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
 801bb42:	687b      	ldr	r3, [r7, #4]
 801bb44:	68fa      	ldr	r2, [r7, #12]
 801bb46:	f8c3 21c4 	str.w	r2, [r3, #452]	@ 0x1c4
  post->pub.start_pass = start_pass_dpost;
 801bb4a:	68fb      	ldr	r3, [r7, #12]
 801bb4c:	4a25      	ldr	r2, [pc, #148]	@ (801bbe4 <jinit_d_post_controller+0xbc>)
 801bb4e:	601a      	str	r2, [r3, #0]
  post->whole_image = NULL;	/* flag for no virtual arrays */
 801bb50:	68fb      	ldr	r3, [r7, #12]
 801bb52:	2200      	movs	r2, #0
 801bb54:	609a      	str	r2, [r3, #8]
  post->buffer = NULL;		/* flag for no strip buffer */
 801bb56:	68fb      	ldr	r3, [r7, #12]
 801bb58:	2200      	movs	r2, #0
 801bb5a:	60da      	str	r2, [r3, #12]

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
 801bb5c:	687b      	ldr	r3, [r7, #4]
 801bb5e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801bb60:	2b00      	cmp	r3, #0
 801bb62:	d03a      	beq.n	801bbda <jinit_d_post_controller+0xb2>
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
 801bb64:	687b      	ldr	r3, [r7, #4]
 801bb66:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801bb6a:	461a      	mov	r2, r3
 801bb6c:	68fb      	ldr	r3, [r7, #12]
 801bb6e:	611a      	str	r2, [r3, #16]
    if (need_full_buffer) {
 801bb70:	683b      	ldr	r3, [r7, #0]
 801bb72:	2b00      	cmp	r3, #0
 801bb74:	d020      	beq.n	801bbb8 <jinit_d_post_controller+0x90>
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801bb76:	687b      	ldr	r3, [r7, #4]
 801bb78:	685b      	ldr	r3, [r3, #4]
 801bb7a:	691c      	ldr	r4, [r3, #16]
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 cinfo->output_width * cinfo->out_color_components,
 801bb7c:	687b      	ldr	r3, [r7, #4]
 801bb7e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801bb80:	687a      	ldr	r2, [r7, #4]
 801bb82:	6f92      	ldr	r2, [r2, #120]	@ 0x78
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801bb84:	fb02 f503 	mul.w	r5, r2, r3
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 801bb88:	687b      	ldr	r3, [r7, #4]
 801bb8a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801bb8c:	461a      	mov	r2, r3
				(long) post->strip_height),
 801bb8e:	68fb      	ldr	r3, [r7, #12]
 801bb90:	691b      	ldr	r3, [r3, #16]
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 801bb92:	4619      	mov	r1, r3
 801bb94:	4610      	mov	r0, r2
 801bb96:	f011 f89d 	bl	802ccd4 <jround_up>
 801bb9a:	4603      	mov	r3, r0
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801bb9c:	461a      	mov	r2, r3
 801bb9e:	68fb      	ldr	r3, [r7, #12]
 801bba0:	691b      	ldr	r3, [r3, #16]
 801bba2:	9301      	str	r3, [sp, #4]
 801bba4:	9200      	str	r2, [sp, #0]
 801bba6:	462b      	mov	r3, r5
 801bba8:	2200      	movs	r2, #0
 801bbaa:	2101      	movs	r1, #1
 801bbac:	6878      	ldr	r0, [r7, #4]
 801bbae:	47a0      	blx	r4
 801bbb0:	4602      	mov	r2, r0
 801bbb2:	68fb      	ldr	r3, [r7, #12]
 801bbb4:	609a      	str	r2, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 cinfo->output_width * cinfo->out_color_components,
	 post->strip_height);
    }
  }
}
 801bbb6:	e010      	b.n	801bbda <jinit_d_post_controller+0xb2>
      post->buffer = (*cinfo->mem->alloc_sarray)
 801bbb8:	687b      	ldr	r3, [r7, #4]
 801bbba:	685b      	ldr	r3, [r3, #4]
 801bbbc:	689c      	ldr	r4, [r3, #8]
	 cinfo->output_width * cinfo->out_color_components,
 801bbbe:	687b      	ldr	r3, [r7, #4]
 801bbc0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801bbc2:	687a      	ldr	r2, [r7, #4]
 801bbc4:	6f92      	ldr	r2, [r2, #120]	@ 0x78
      post->buffer = (*cinfo->mem->alloc_sarray)
 801bbc6:	fb03 f202 	mul.w	r2, r3, r2
 801bbca:	68fb      	ldr	r3, [r7, #12]
 801bbcc:	691b      	ldr	r3, [r3, #16]
 801bbce:	2101      	movs	r1, #1
 801bbd0:	6878      	ldr	r0, [r7, #4]
 801bbd2:	47a0      	blx	r4
 801bbd4:	4602      	mov	r2, r0
 801bbd6:	68fb      	ldr	r3, [r7, #12]
 801bbd8:	60da      	str	r2, [r3, #12]
}
 801bbda:	bf00      	nop
 801bbdc:	3710      	adds	r7, #16
 801bbde:	46bd      	mov	sp, r7
 801bbe0:	bdb0      	pop	{r4, r5, r7, pc}
 801bbe2:	bf00      	nop
 801bbe4:	0801b815 	.word	0x0801b815

0801bbe8 <start_pass_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
 801bbe8:	b480      	push	{r7}
 801bbea:	b085      	sub	sp, #20
 801bbec:	af00      	add	r7, sp, #0
 801bbee:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801bbf0:	687b      	ldr	r3, [r7, #4]
 801bbf2:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801bbf6:	60fb      	str	r3, [r7, #12]

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
 801bbf8:	687b      	ldr	r3, [r7, #4]
 801bbfa:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801bbfe:	68fb      	ldr	r3, [r7, #12]
 801bc00:	65da      	str	r2, [r3, #92]	@ 0x5c
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 801bc02:	687b      	ldr	r3, [r7, #4]
 801bc04:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801bc06:	68fb      	ldr	r3, [r7, #12]
 801bc08:	661a      	str	r2, [r3, #96]	@ 0x60
}
 801bc0a:	bf00      	nop
 801bc0c:	3714      	adds	r7, #20
 801bc0e:	46bd      	mov	sp, r7
 801bc10:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bc14:	4770      	bx	lr

0801bc16 <sep_upsample>:
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
 801bc16:	b590      	push	{r4, r7, lr}
 801bc18:	b08b      	sub	sp, #44	@ 0x2c
 801bc1a:	af02      	add	r7, sp, #8
 801bc1c:	60f8      	str	r0, [r7, #12]
 801bc1e:	60b9      	str	r1, [r7, #8]
 801bc20:	607a      	str	r2, [r7, #4]
 801bc22:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801bc24:	68fb      	ldr	r3, [r7, #12]
 801bc26:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801bc2a:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
 801bc2c:	693b      	ldr	r3, [r7, #16]
 801bc2e:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801bc30:	68fb      	ldr	r3, [r7, #12]
 801bc32:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801bc36:	429a      	cmp	r2, r3
 801bc38:	db35      	blt.n	801bca6 <sep_upsample+0x90>
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801bc3a:	2300      	movs	r3, #0
 801bc3c:	61fb      	str	r3, [r7, #28]
 801bc3e:	68fb      	ldr	r3, [r7, #12]
 801bc40:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801bc44:	61bb      	str	r3, [r7, #24]
 801bc46:	e026      	b.n	801bc96 <sep_upsample+0x80>
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
 801bc48:	693a      	ldr	r2, [r7, #16]
 801bc4a:	69fb      	ldr	r3, [r7, #28]
 801bc4c:	330c      	adds	r3, #12
 801bc4e:	009b      	lsls	r3, r3, #2
 801bc50:	4413      	add	r3, r2
 801bc52:	685c      	ldr	r4, [r3, #4]
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
 801bc54:	69fb      	ldr	r3, [r7, #28]
 801bc56:	009b      	lsls	r3, r3, #2
 801bc58:	68ba      	ldr	r2, [r7, #8]
 801bc5a:	4413      	add	r3, r2
 801bc5c:	681a      	ldr	r2, [r3, #0]
 801bc5e:	687b      	ldr	r3, [r7, #4]
 801bc60:	6819      	ldr	r1, [r3, #0]
 801bc62:	6938      	ldr	r0, [r7, #16]
 801bc64:	69fb      	ldr	r3, [r7, #28]
 801bc66:	3318      	adds	r3, #24
 801bc68:	009b      	lsls	r3, r3, #2
 801bc6a:	4403      	add	r3, r0
 801bc6c:	685b      	ldr	r3, [r3, #4]
 801bc6e:	fb01 f303 	mul.w	r3, r1, r3
 801bc72:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 801bc74:	18d1      	adds	r1, r2, r3
	upsample->color_buf + ci);
 801bc76:	693b      	ldr	r3, [r7, #16]
 801bc78:	f103 020c 	add.w	r2, r3, #12
 801bc7c:	69fb      	ldr	r3, [r7, #28]
 801bc7e:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 801bc80:	4413      	add	r3, r2
 801bc82:	460a      	mov	r2, r1
 801bc84:	69b9      	ldr	r1, [r7, #24]
 801bc86:	68f8      	ldr	r0, [r7, #12]
 801bc88:	47a0      	blx	r4
	 ci++, compptr++) {
 801bc8a:	69fb      	ldr	r3, [r7, #28]
 801bc8c:	3301      	adds	r3, #1
 801bc8e:	61fb      	str	r3, [r7, #28]
 801bc90:	69bb      	ldr	r3, [r7, #24]
 801bc92:	3358      	adds	r3, #88	@ 0x58
 801bc94:	61bb      	str	r3, [r7, #24]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801bc96:	68fb      	ldr	r3, [r7, #12]
 801bc98:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801bc9a:	69fa      	ldr	r2, [r7, #28]
 801bc9c:	429a      	cmp	r2, r3
 801bc9e:	dbd3      	blt.n	801bc48 <sep_upsample+0x32>
    }
    upsample->next_row_out = 0;
 801bca0:	693b      	ldr	r3, [r7, #16]
 801bca2:	2200      	movs	r2, #0
 801bca4:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
 801bca6:	68fb      	ldr	r3, [r7, #12]
 801bca8:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801bcac:	693b      	ldr	r3, [r7, #16]
 801bcae:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801bcb0:	1ad3      	subs	r3, r2, r3
 801bcb2:	617b      	str	r3, [r7, #20]
  /* Not more than the distance to the end of the image.  Need this test
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go) 
 801bcb4:	693b      	ldr	r3, [r7, #16]
 801bcb6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 801bcb8:	697a      	ldr	r2, [r7, #20]
 801bcba:	429a      	cmp	r2, r3
 801bcbc:	d902      	bls.n	801bcc4 <sep_upsample+0xae>
    num_rows = upsample->rows_to_go;
 801bcbe:	693b      	ldr	r3, [r7, #16]
 801bcc0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 801bcc2:	617b      	str	r3, [r7, #20]
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
 801bcc4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bcc6:	681b      	ldr	r3, [r3, #0]
 801bcc8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801bcca:	1ad3      	subs	r3, r2, r3
 801bccc:	63bb      	str	r3, [r7, #56]	@ 0x38
  if (num_rows > out_rows_avail)
 801bcce:	697a      	ldr	r2, [r7, #20]
 801bcd0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801bcd2:	429a      	cmp	r2, r3
 801bcd4:	d901      	bls.n	801bcda <sep_upsample+0xc4>
    num_rows = out_rows_avail;
 801bcd6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801bcd8:	617b      	str	r3, [r7, #20]

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801bcda:	68fb      	ldr	r3, [r7, #12]
 801bcdc:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 801bce0:	685c      	ldr	r4, [r3, #4]
 801bce2:	693b      	ldr	r3, [r7, #16]
 801bce4:	f103 010c 	add.w	r1, r3, #12
				     (JDIMENSION) upsample->next_row_out,
 801bce8:	693b      	ldr	r3, [r7, #16]
 801bcea:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801bcec:	4618      	mov	r0, r3
				     output_buf + *out_row_ctr,
 801bcee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bcf0:	681b      	ldr	r3, [r3, #0]
 801bcf2:	009b      	lsls	r3, r3, #2
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801bcf4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801bcf6:	441a      	add	r2, r3
 801bcf8:	697b      	ldr	r3, [r7, #20]
 801bcfa:	9300      	str	r3, [sp, #0]
 801bcfc:	4613      	mov	r3, r2
 801bcfe:	4602      	mov	r2, r0
 801bd00:	68f8      	ldr	r0, [r7, #12]
 801bd02:	47a0      	blx	r4
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
 801bd04:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bd06:	681a      	ldr	r2, [r3, #0]
 801bd08:	697b      	ldr	r3, [r7, #20]
 801bd0a:	441a      	add	r2, r3
 801bd0c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bd0e:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 801bd10:	693b      	ldr	r3, [r7, #16]
 801bd12:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 801bd14:	697b      	ldr	r3, [r7, #20]
 801bd16:	1ad2      	subs	r2, r2, r3
 801bd18:	693b      	ldr	r3, [r7, #16]
 801bd1a:	661a      	str	r2, [r3, #96]	@ 0x60
  upsample->next_row_out += num_rows;
 801bd1c:	693b      	ldr	r3, [r7, #16]
 801bd1e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801bd20:	461a      	mov	r2, r3
 801bd22:	697b      	ldr	r3, [r7, #20]
 801bd24:	4413      	add	r3, r2
 801bd26:	461a      	mov	r2, r3
 801bd28:	693b      	ldr	r3, [r7, #16]
 801bd2a:	65da      	str	r2, [r3, #92]	@ 0x5c
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
 801bd2c:	693b      	ldr	r3, [r7, #16]
 801bd2e:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801bd30:	68fb      	ldr	r3, [r7, #12]
 801bd32:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801bd36:	429a      	cmp	r2, r3
 801bd38:	db04      	blt.n	801bd44 <sep_upsample+0x12e>
    (*in_row_group_ctr)++;
 801bd3a:	687b      	ldr	r3, [r7, #4]
 801bd3c:	681b      	ldr	r3, [r3, #0]
 801bd3e:	1c5a      	adds	r2, r3, #1
 801bd40:	687b      	ldr	r3, [r7, #4]
 801bd42:	601a      	str	r2, [r3, #0]
}
 801bd44:	bf00      	nop
 801bd46:	3724      	adds	r7, #36	@ 0x24
 801bd48:	46bd      	mov	sp, r7
 801bd4a:	bd90      	pop	{r4, r7, pc}

0801bd4c <fullsize_upsample>:
 */

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801bd4c:	b480      	push	{r7}
 801bd4e:	b085      	sub	sp, #20
 801bd50:	af00      	add	r7, sp, #0
 801bd52:	60f8      	str	r0, [r7, #12]
 801bd54:	60b9      	str	r1, [r7, #8]
 801bd56:	607a      	str	r2, [r7, #4]
 801bd58:	603b      	str	r3, [r7, #0]
  *output_data_ptr = input_data;
 801bd5a:	683b      	ldr	r3, [r7, #0]
 801bd5c:	687a      	ldr	r2, [r7, #4]
 801bd5e:	601a      	str	r2, [r3, #0]
}
 801bd60:	bf00      	nop
 801bd62:	3714      	adds	r7, #20
 801bd64:	46bd      	mov	sp, r7
 801bd66:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd6a:	4770      	bx	lr

0801bd6c <noop_upsample>:
 */

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801bd6c:	b480      	push	{r7}
 801bd6e:	b085      	sub	sp, #20
 801bd70:	af00      	add	r7, sp, #0
 801bd72:	60f8      	str	r0, [r7, #12]
 801bd74:	60b9      	str	r1, [r7, #8]
 801bd76:	607a      	str	r2, [r7, #4]
 801bd78:	603b      	str	r3, [r7, #0]
  *output_data_ptr = NULL;	/* safety check */
 801bd7a:	683b      	ldr	r3, [r7, #0]
 801bd7c:	2200      	movs	r2, #0
 801bd7e:	601a      	str	r2, [r3, #0]
}
 801bd80:	bf00      	nop
 801bd82:	3714      	adds	r7, #20
 801bd84:	46bd      	mov	sp, r7
 801bd86:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd8a:	4770      	bx	lr

0801bd8c <int_upsample>:
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801bd8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801bd90:	b08e      	sub	sp, #56	@ 0x38
 801bd92:	af02      	add	r7, sp, #8
 801bd94:	60f8      	str	r0, [r7, #12]
 801bd96:	60b9      	str	r1, [r7, #8]
 801bd98:	607a      	str	r2, [r7, #4]
 801bd9a:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801bd9c:	68fb      	ldr	r3, [r7, #12]
 801bd9e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801bda2:	627b      	str	r3, [r7, #36]	@ 0x24
  JSAMPARRAY output_data = *output_data_ptr;
 801bda4:	683b      	ldr	r3, [r7, #0]
 801bda6:	681b      	ldr	r3, [r3, #0]
 801bda8:	623b      	str	r3, [r7, #32]
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
 801bdaa:	68bb      	ldr	r3, [r7, #8]
 801bdac:	685b      	ldr	r3, [r3, #4]
 801bdae:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801bdb0:	4413      	add	r3, r2
 801bdb2:	f893 308c 	ldrb.w	r3, [r3, #140]	@ 0x8c
 801bdb6:	61fb      	str	r3, [r7, #28]
  v_expand = upsample->v_expand[compptr->component_index];
 801bdb8:	68bb      	ldr	r3, [r7, #8]
 801bdba:	685b      	ldr	r3, [r3, #4]
 801bdbc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801bdbe:	4413      	add	r3, r2
 801bdc0:	f893 3096 	ldrb.w	r3, [r3, #150]	@ 0x96
 801bdc4:	61bb      	str	r3, [r7, #24]

  inrow = outrow = 0;
 801bdc6:	2300      	movs	r3, #0
 801bdc8:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bdca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bdcc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (outrow < cinfo->max_v_samp_factor) {
 801bdce:	e036      	b.n	801be3e <int_upsample+0xb2>
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
 801bdd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bdd2:	009b      	lsls	r3, r3, #2
 801bdd4:	687a      	ldr	r2, [r7, #4]
 801bdd6:	4413      	add	r3, r2
 801bdd8:	681e      	ldr	r6, [r3, #0]
    outptr = output_data[outrow];
 801bdda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bddc:	009b      	lsls	r3, r3, #2
 801bdde:	6a3a      	ldr	r2, [r7, #32]
 801bde0:	4413      	add	r3, r2
 801bde2:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801bde4:	68fb      	ldr	r3, [r7, #12]
 801bde6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801bde8:	4423      	add	r3, r4
 801bdea:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 801bdec:	e00c      	b.n	801be08 <int_upsample+0x7c>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801bdee:	4633      	mov	r3, r6
 801bdf0:	1c5e      	adds	r6, r3, #1
 801bdf2:	f893 8000 	ldrb.w	r8, [r3]
      for (h = h_expand; h > 0; h--) {
 801bdf6:	69fd      	ldr	r5, [r7, #28]
 801bdf8:	e004      	b.n	801be04 <int_upsample+0x78>
	*outptr++ = invalue;
 801bdfa:	4623      	mov	r3, r4
 801bdfc:	1c5c      	adds	r4, r3, #1
 801bdfe:	4642      	mov	r2, r8
 801be00:	701a      	strb	r2, [r3, #0]
      for (h = h_expand; h > 0; h--) {
 801be02:	3d01      	subs	r5, #1
 801be04:	2d00      	cmp	r5, #0
 801be06:	dcf8      	bgt.n	801bdfa <int_upsample+0x6e>
    while (outptr < outend) {
 801be08:	697b      	ldr	r3, [r7, #20]
 801be0a:	429c      	cmp	r4, r3
 801be0c:	d3ef      	bcc.n	801bdee <int_upsample+0x62>
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
 801be0e:	69bb      	ldr	r3, [r7, #24]
 801be10:	2b01      	cmp	r3, #1
 801be12:	dd0d      	ble.n	801be30 <int_upsample+0xa4>
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 801be14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801be16:	1c59      	adds	r1, r3, #1
 801be18:	69bb      	ldr	r3, [r7, #24]
 801be1a:	3b01      	subs	r3, #1
 801be1c:	68fa      	ldr	r2, [r7, #12]
 801be1e:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 801be20:	9201      	str	r2, [sp, #4]
 801be22:	9300      	str	r3, [sp, #0]
 801be24:	460b      	mov	r3, r1
 801be26:	6a3a      	ldr	r2, [r7, #32]
 801be28:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801be2a:	6a38      	ldr	r0, [r7, #32]
 801be2c:	f010 ff6c 	bl	802cd08 <jcopy_sample_rows>
			v_expand-1, cinfo->output_width);
    }
    inrow++;
 801be30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801be32:	3301      	adds	r3, #1
 801be34:	62fb      	str	r3, [r7, #44]	@ 0x2c
    outrow += v_expand;
 801be36:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801be38:	69bb      	ldr	r3, [r7, #24]
 801be3a:	4413      	add	r3, r2
 801be3c:	62bb      	str	r3, [r7, #40]	@ 0x28
  while (outrow < cinfo->max_v_samp_factor) {
 801be3e:	68fb      	ldr	r3, [r7, #12]
 801be40:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801be44:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801be46:	429a      	cmp	r2, r3
 801be48:	dbc2      	blt.n	801bdd0 <int_upsample+0x44>
  }
}
 801be4a:	bf00      	nop
 801be4c:	bf00      	nop
 801be4e:	3730      	adds	r7, #48	@ 0x30
 801be50:	46bd      	mov	sp, r7
 801be52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801be56 <h2v1_upsample>:
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801be56:	b4f0      	push	{r4, r5, r6, r7}
 801be58:	b088      	sub	sp, #32
 801be5a:	af00      	add	r7, sp, #0
 801be5c:	60f8      	str	r0, [r7, #12]
 801be5e:	60b9      	str	r1, [r7, #8]
 801be60:	607a      	str	r2, [r7, #4]
 801be62:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 801be64:	683b      	ldr	r3, [r7, #0]
 801be66:	681b      	ldr	r3, [r3, #0]
 801be68:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int outrow;

  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 801be6a:	2300      	movs	r3, #0
 801be6c:	61fb      	str	r3, [r7, #28]
 801be6e:	e01f      	b.n	801beb0 <h2v1_upsample+0x5a>
    inptr = input_data[outrow];
 801be70:	69fb      	ldr	r3, [r7, #28]
 801be72:	009b      	lsls	r3, r3, #2
 801be74:	687a      	ldr	r2, [r7, #4]
 801be76:	4413      	add	r3, r2
 801be78:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 801be7a:	69fb      	ldr	r3, [r7, #28]
 801be7c:	009b      	lsls	r3, r3, #2
 801be7e:	69ba      	ldr	r2, [r7, #24]
 801be80:	4413      	add	r3, r2
 801be82:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801be84:	68fb      	ldr	r3, [r7, #12]
 801be86:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801be88:	4423      	add	r3, r4
 801be8a:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 801be8c:	e00a      	b.n	801bea4 <h2v1_upsample+0x4e>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801be8e:	462b      	mov	r3, r5
 801be90:	1c5d      	adds	r5, r3, #1
 801be92:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 801be94:	4623      	mov	r3, r4
 801be96:	1c5c      	adds	r4, r3, #1
 801be98:	4632      	mov	r2, r6
 801be9a:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 801be9c:	4623      	mov	r3, r4
 801be9e:	1c5c      	adds	r4, r3, #1
 801bea0:	4632      	mov	r2, r6
 801bea2:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 801bea4:	697b      	ldr	r3, [r7, #20]
 801bea6:	429c      	cmp	r4, r3
 801bea8:	d3f1      	bcc.n	801be8e <h2v1_upsample+0x38>
  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 801beaa:	69fb      	ldr	r3, [r7, #28]
 801beac:	3301      	adds	r3, #1
 801beae:	61fb      	str	r3, [r7, #28]
 801beb0:	68fb      	ldr	r3, [r7, #12]
 801beb2:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801beb6:	69fa      	ldr	r2, [r7, #28]
 801beb8:	429a      	cmp	r2, r3
 801beba:	dbd9      	blt.n	801be70 <h2v1_upsample+0x1a>
    }
  }
}
 801bebc:	bf00      	nop
 801bebe:	bf00      	nop
 801bec0:	3720      	adds	r7, #32
 801bec2:	46bd      	mov	sp, r7
 801bec4:	bcf0      	pop	{r4, r5, r6, r7}
 801bec6:	4770      	bx	lr

0801bec8 <h2v2_upsample>:
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801bec8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801beca:	b08b      	sub	sp, #44	@ 0x2c
 801becc:	af02      	add	r7, sp, #8
 801bece:	60f8      	str	r0, [r7, #12]
 801bed0:	60b9      	str	r1, [r7, #8]
 801bed2:	607a      	str	r2, [r7, #4]
 801bed4:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 801bed6:	683b      	ldr	r3, [r7, #0]
 801bed8:	681b      	ldr	r3, [r3, #0]
 801beda:	617b      	str	r3, [r7, #20]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
 801bedc:	2300      	movs	r3, #0
 801bede:	61bb      	str	r3, [r7, #24]
 801bee0:	69bb      	ldr	r3, [r7, #24]
 801bee2:	61fb      	str	r3, [r7, #28]
  while (outrow < cinfo->max_v_samp_factor) {
 801bee4:	e02f      	b.n	801bf46 <h2v2_upsample+0x7e>
    inptr = input_data[inrow];
 801bee6:	69fb      	ldr	r3, [r7, #28]
 801bee8:	009b      	lsls	r3, r3, #2
 801beea:	687a      	ldr	r2, [r7, #4]
 801beec:	4413      	add	r3, r2
 801beee:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 801bef0:	69bb      	ldr	r3, [r7, #24]
 801bef2:	009b      	lsls	r3, r3, #2
 801bef4:	697a      	ldr	r2, [r7, #20]
 801bef6:	4413      	add	r3, r2
 801bef8:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801befa:	68fb      	ldr	r3, [r7, #12]
 801befc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801befe:	4423      	add	r3, r4
 801bf00:	613b      	str	r3, [r7, #16]
    while (outptr < outend) {
 801bf02:	e00a      	b.n	801bf1a <h2v2_upsample+0x52>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801bf04:	462b      	mov	r3, r5
 801bf06:	1c5d      	adds	r5, r3, #1
 801bf08:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 801bf0a:	4623      	mov	r3, r4
 801bf0c:	1c5c      	adds	r4, r3, #1
 801bf0e:	4632      	mov	r2, r6
 801bf10:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 801bf12:	4623      	mov	r3, r4
 801bf14:	1c5c      	adds	r4, r3, #1
 801bf16:	4632      	mov	r2, r6
 801bf18:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 801bf1a:	693b      	ldr	r3, [r7, #16]
 801bf1c:	429c      	cmp	r4, r3
 801bf1e:	d3f1      	bcc.n	801bf04 <h2v2_upsample+0x3c>
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 801bf20:	69bb      	ldr	r3, [r7, #24]
 801bf22:	1c5a      	adds	r2, r3, #1
 801bf24:	68fb      	ldr	r3, [r7, #12]
 801bf26:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801bf28:	9301      	str	r3, [sp, #4]
 801bf2a:	2301      	movs	r3, #1
 801bf2c:	9300      	str	r3, [sp, #0]
 801bf2e:	4613      	mov	r3, r2
 801bf30:	697a      	ldr	r2, [r7, #20]
 801bf32:	69b9      	ldr	r1, [r7, #24]
 801bf34:	6978      	ldr	r0, [r7, #20]
 801bf36:	f010 fee7 	bl	802cd08 <jcopy_sample_rows>
		      1, cinfo->output_width);
    inrow++;
 801bf3a:	69fb      	ldr	r3, [r7, #28]
 801bf3c:	3301      	adds	r3, #1
 801bf3e:	61fb      	str	r3, [r7, #28]
    outrow += 2;
 801bf40:	69bb      	ldr	r3, [r7, #24]
 801bf42:	3302      	adds	r3, #2
 801bf44:	61bb      	str	r3, [r7, #24]
  while (outrow < cinfo->max_v_samp_factor) {
 801bf46:	68fb      	ldr	r3, [r7, #12]
 801bf48:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801bf4c:	69ba      	ldr	r2, [r7, #24]
 801bf4e:	429a      	cmp	r2, r3
 801bf50:	dbc9      	blt.n	801bee6 <h2v2_upsample+0x1e>
  }
}
 801bf52:	bf00      	nop
 801bf54:	bf00      	nop
 801bf56:	3724      	adds	r7, #36	@ 0x24
 801bf58:	46bd      	mov	sp, r7
 801bf5a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801bf5c <jinit_upsampler>:
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
 801bf5c:	b590      	push	{r4, r7, lr}
 801bf5e:	b08b      	sub	sp, #44	@ 0x2c
 801bf60:	af00      	add	r7, sp, #0
 801bf62:	6078      	str	r0, [r7, #4]
  jpeg_component_info * compptr;
  boolean need_buffer;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801bf64:	687b      	ldr	r3, [r7, #4]
 801bf66:	685b      	ldr	r3, [r3, #4]
 801bf68:	681b      	ldr	r3, [r3, #0]
 801bf6a:	22a0      	movs	r2, #160	@ 0xa0
 801bf6c:	2101      	movs	r1, #1
 801bf6e:	6878      	ldr	r0, [r7, #4]
 801bf70:	4798      	blx	r3
 801bf72:	61b8      	str	r0, [r7, #24]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 801bf74:	687b      	ldr	r3, [r7, #4]
 801bf76:	69ba      	ldr	r2, [r7, #24]
 801bf78:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
  upsample->pub.start_pass = start_pass_upsample;
 801bf7c:	69bb      	ldr	r3, [r7, #24]
 801bf7e:	4a7a      	ldr	r2, [pc, #488]	@ (801c168 <jinit_upsampler+0x20c>)
 801bf80:	601a      	str	r2, [r3, #0]
  upsample->pub.upsample = sep_upsample;
 801bf82:	69bb      	ldr	r3, [r7, #24]
 801bf84:	4a79      	ldr	r2, [pc, #484]	@ (801c16c <jinit_upsampler+0x210>)
 801bf86:	605a      	str	r2, [r3, #4]
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
 801bf88:	69bb      	ldr	r3, [r7, #24]
 801bf8a:	2200      	movs	r2, #0
 801bf8c:	609a      	str	r2, [r3, #8]

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
 801bf8e:	687b      	ldr	r3, [r7, #4]
 801bf90:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 801bf94:	2b00      	cmp	r3, #0
 801bf96:	d008      	beq.n	801bfaa <jinit_upsampler+0x4e>
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
 801bf98:	687b      	ldr	r3, [r7, #4]
 801bf9a:	681b      	ldr	r3, [r3, #0]
 801bf9c:	221a      	movs	r2, #26
 801bf9e:	615a      	str	r2, [r3, #20]
 801bfa0:	687b      	ldr	r3, [r7, #4]
 801bfa2:	681b      	ldr	r3, [r3, #0]
 801bfa4:	681b      	ldr	r3, [r3, #0]
 801bfa6:	6878      	ldr	r0, [r7, #4]
 801bfa8:	4798      	blx	r3

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801bfaa:	2300      	movs	r3, #0
 801bfac:	627b      	str	r3, [r7, #36]	@ 0x24
 801bfae:	687b      	ldr	r3, [r7, #4]
 801bfb0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801bfb4:	623b      	str	r3, [r7, #32]
 801bfb6:	e0cb      	b.n	801c150 <jinit_upsampler+0x1f4>
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 801bfb8:	6a3b      	ldr	r3, [r7, #32]
 801bfba:	689b      	ldr	r3, [r3, #8]
 801bfbc:	6a3a      	ldr	r2, [r7, #32]
 801bfbe:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801bfc0:	fb03 f202 	mul.w	r2, r3, r2
		 cinfo->min_DCT_h_scaled_size;
 801bfc4:	687b      	ldr	r3, [r7, #4]
 801bfc6:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 801bfca:	fb92 f3f3 	sdiv	r3, r2, r3
 801bfce:	617b      	str	r3, [r7, #20]
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801bfd0:	6a3b      	ldr	r3, [r7, #32]
 801bfd2:	68db      	ldr	r3, [r3, #12]
 801bfd4:	6a3a      	ldr	r2, [r7, #32]
 801bfd6:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801bfd8:	fb03 f202 	mul.w	r2, r3, r2
		 cinfo->min_DCT_v_scaled_size;
 801bfdc:	687b      	ldr	r3, [r7, #4]
 801bfde:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801bfe2:	fb92 f3f3 	sdiv	r3, r2, r3
 801bfe6:	613b      	str	r3, [r7, #16]
    h_out_group = cinfo->max_h_samp_factor;
 801bfe8:	687b      	ldr	r3, [r7, #4]
 801bfea:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801bfee:	60fb      	str	r3, [r7, #12]
    v_out_group = cinfo->max_v_samp_factor;
 801bff0:	687b      	ldr	r3, [r7, #4]
 801bff2:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801bff6:	60bb      	str	r3, [r7, #8]
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
 801bff8:	69ba      	ldr	r2, [r7, #24]
 801bffa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801bffc:	3318      	adds	r3, #24
 801bffe:	009b      	lsls	r3, r3, #2
 801c000:	4413      	add	r3, r2
 801c002:	693a      	ldr	r2, [r7, #16]
 801c004:	605a      	str	r2, [r3, #4]
    need_buffer = TRUE;
 801c006:	2301      	movs	r3, #1
 801c008:	61fb      	str	r3, [r7, #28]
    if (! compptr->component_needed) {
 801c00a:	6a3b      	ldr	r3, [r7, #32]
 801c00c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801c00e:	2b00      	cmp	r3, #0
 801c010:	d109      	bne.n	801c026 <jinit_upsampler+0xca>
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
 801c012:	69ba      	ldr	r2, [r7, #24]
 801c014:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c016:	330c      	adds	r3, #12
 801c018:	009b      	lsls	r3, r3, #2
 801c01a:	4413      	add	r3, r2
 801c01c:	4a54      	ldr	r2, [pc, #336]	@ (801c170 <jinit_upsampler+0x214>)
 801c01e:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 801c020:	2300      	movs	r3, #0
 801c022:	61fb      	str	r3, [r7, #28]
 801c024:	e06f      	b.n	801c106 <jinit_upsampler+0x1aa>
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
 801c026:	697a      	ldr	r2, [r7, #20]
 801c028:	68fb      	ldr	r3, [r7, #12]
 801c02a:	429a      	cmp	r2, r3
 801c02c:	d10d      	bne.n	801c04a <jinit_upsampler+0xee>
 801c02e:	693a      	ldr	r2, [r7, #16]
 801c030:	68bb      	ldr	r3, [r7, #8]
 801c032:	429a      	cmp	r2, r3
 801c034:	d109      	bne.n	801c04a <jinit_upsampler+0xee>
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
 801c036:	69ba      	ldr	r2, [r7, #24]
 801c038:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c03a:	330c      	adds	r3, #12
 801c03c:	009b      	lsls	r3, r3, #2
 801c03e:	4413      	add	r3, r2
 801c040:	4a4c      	ldr	r2, [pc, #304]	@ (801c174 <jinit_upsampler+0x218>)
 801c042:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 801c044:	2300      	movs	r3, #0
 801c046:	61fb      	str	r3, [r7, #28]
 801c048:	e05d      	b.n	801c106 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 801c04a:	697b      	ldr	r3, [r7, #20]
 801c04c:	005b      	lsls	r3, r3, #1
 801c04e:	68fa      	ldr	r2, [r7, #12]
 801c050:	429a      	cmp	r2, r3
 801c052:	d10b      	bne.n	801c06c <jinit_upsampler+0x110>
 801c054:	693a      	ldr	r2, [r7, #16]
 801c056:	68bb      	ldr	r3, [r7, #8]
 801c058:	429a      	cmp	r2, r3
 801c05a:	d107      	bne.n	801c06c <jinit_upsampler+0x110>
	       v_in_group == v_out_group) {
      /* Special case for 2h1v upsampling */
      upsample->methods[ci] = h2v1_upsample;
 801c05c:	69ba      	ldr	r2, [r7, #24]
 801c05e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c060:	330c      	adds	r3, #12
 801c062:	009b      	lsls	r3, r3, #2
 801c064:	4413      	add	r3, r2
 801c066:	4a44      	ldr	r2, [pc, #272]	@ (801c178 <jinit_upsampler+0x21c>)
 801c068:	605a      	str	r2, [r3, #4]
 801c06a:	e04c      	b.n	801c106 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 801c06c:	697b      	ldr	r3, [r7, #20]
 801c06e:	005b      	lsls	r3, r3, #1
 801c070:	68fa      	ldr	r2, [r7, #12]
 801c072:	429a      	cmp	r2, r3
 801c074:	d10c      	bne.n	801c090 <jinit_upsampler+0x134>
	       v_in_group * 2 == v_out_group) {
 801c076:	693b      	ldr	r3, [r7, #16]
 801c078:	005b      	lsls	r3, r3, #1
    } else if (h_in_group * 2 == h_out_group &&
 801c07a:	68ba      	ldr	r2, [r7, #8]
 801c07c:	429a      	cmp	r2, r3
 801c07e:	d107      	bne.n	801c090 <jinit_upsampler+0x134>
      /* Special case for 2h2v upsampling */
      upsample->methods[ci] = h2v2_upsample;
 801c080:	69ba      	ldr	r2, [r7, #24]
 801c082:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c084:	330c      	adds	r3, #12
 801c086:	009b      	lsls	r3, r3, #2
 801c088:	4413      	add	r3, r2
 801c08a:	4a3c      	ldr	r2, [pc, #240]	@ (801c17c <jinit_upsampler+0x220>)
 801c08c:	605a      	str	r2, [r3, #4]
 801c08e:	e03a      	b.n	801c106 <jinit_upsampler+0x1aa>
    } else if ((h_out_group % h_in_group) == 0 &&
 801c090:	68fb      	ldr	r3, [r7, #12]
 801c092:	697a      	ldr	r2, [r7, #20]
 801c094:	fb93 f2f2 	sdiv	r2, r3, r2
 801c098:	6979      	ldr	r1, [r7, #20]
 801c09a:	fb01 f202 	mul.w	r2, r1, r2
 801c09e:	1a9b      	subs	r3, r3, r2
 801c0a0:	2b00      	cmp	r3, #0
 801c0a2:	d127      	bne.n	801c0f4 <jinit_upsampler+0x198>
	       (v_out_group % v_in_group) == 0) {
 801c0a4:	68bb      	ldr	r3, [r7, #8]
 801c0a6:	693a      	ldr	r2, [r7, #16]
 801c0a8:	fb93 f2f2 	sdiv	r2, r3, r2
 801c0ac:	6939      	ldr	r1, [r7, #16]
 801c0ae:	fb01 f202 	mul.w	r2, r1, r2
 801c0b2:	1a9b      	subs	r3, r3, r2
    } else if ((h_out_group % h_in_group) == 0 &&
 801c0b4:	2b00      	cmp	r3, #0
 801c0b6:	d11d      	bne.n	801c0f4 <jinit_upsampler+0x198>
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
 801c0b8:	69ba      	ldr	r2, [r7, #24]
 801c0ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c0bc:	330c      	adds	r3, #12
 801c0be:	009b      	lsls	r3, r3, #2
 801c0c0:	4413      	add	r3, r2
 801c0c2:	4a2f      	ldr	r2, [pc, #188]	@ (801c180 <jinit_upsampler+0x224>)
 801c0c4:	605a      	str	r2, [r3, #4]
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
 801c0c6:	68fa      	ldr	r2, [r7, #12]
 801c0c8:	697b      	ldr	r3, [r7, #20]
 801c0ca:	fb92 f3f3 	sdiv	r3, r2, r3
 801c0ce:	b2d9      	uxtb	r1, r3
 801c0d0:	69ba      	ldr	r2, [r7, #24]
 801c0d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c0d4:	4413      	add	r3, r2
 801c0d6:	338c      	adds	r3, #140	@ 0x8c
 801c0d8:	460a      	mov	r2, r1
 801c0da:	701a      	strb	r2, [r3, #0]
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
 801c0dc:	68ba      	ldr	r2, [r7, #8]
 801c0de:	693b      	ldr	r3, [r7, #16]
 801c0e0:	fb92 f3f3 	sdiv	r3, r2, r3
 801c0e4:	b2d9      	uxtb	r1, r3
 801c0e6:	69ba      	ldr	r2, [r7, #24]
 801c0e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c0ea:	4413      	add	r3, r2
 801c0ec:	3396      	adds	r3, #150	@ 0x96
 801c0ee:	460a      	mov	r2, r1
 801c0f0:	701a      	strb	r2, [r3, #0]
 801c0f2:	e008      	b.n	801c106 <jinit_upsampler+0x1aa>
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
 801c0f4:	687b      	ldr	r3, [r7, #4]
 801c0f6:	681b      	ldr	r3, [r3, #0]
 801c0f8:	2227      	movs	r2, #39	@ 0x27
 801c0fa:	615a      	str	r2, [r3, #20]
 801c0fc:	687b      	ldr	r3, [r7, #4]
 801c0fe:	681b      	ldr	r3, [r3, #0]
 801c100:	681b      	ldr	r3, [r3, #0]
 801c102:	6878      	ldr	r0, [r7, #4]
 801c104:	4798      	blx	r3
    if (need_buffer) {
 801c106:	69fb      	ldr	r3, [r7, #28]
 801c108:	2b00      	cmp	r3, #0
 801c10a:	d01b      	beq.n	801c144 <jinit_upsampler+0x1e8>
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801c10c:	687b      	ldr	r3, [r7, #4]
 801c10e:	685b      	ldr	r3, [r3, #4]
 801c110:	689c      	ldr	r4, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 801c112:	687b      	ldr	r3, [r7, #4]
 801c114:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801c116:	461a      	mov	r2, r3
				(long) cinfo->max_h_samp_factor),
 801c118:	687b      	ldr	r3, [r7, #4]
 801c11a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 801c11e:	4619      	mov	r1, r3
 801c120:	4610      	mov	r0, r2
 801c122:	f010 fdd7 	bl	802ccd4 <jround_up>
 801c126:	4603      	mov	r3, r0
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801c128:	461a      	mov	r2, r3
	 (JDIMENSION) cinfo->max_v_samp_factor);
 801c12a:	687b      	ldr	r3, [r7, #4]
 801c12c:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801c130:	2101      	movs	r1, #1
 801c132:	6878      	ldr	r0, [r7, #4]
 801c134:	47a0      	blx	r4
 801c136:	4601      	mov	r1, r0
 801c138:	69ba      	ldr	r2, [r7, #24]
 801c13a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c13c:	3302      	adds	r3, #2
 801c13e:	009b      	lsls	r3, r3, #2
 801c140:	4413      	add	r3, r2
 801c142:	6059      	str	r1, [r3, #4]
       ci++, compptr++) {
 801c144:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c146:	3301      	adds	r3, #1
 801c148:	627b      	str	r3, [r7, #36]	@ 0x24
 801c14a:	6a3b      	ldr	r3, [r7, #32]
 801c14c:	3358      	adds	r3, #88	@ 0x58
 801c14e:	623b      	str	r3, [r7, #32]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801c150:	687b      	ldr	r3, [r7, #4]
 801c152:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801c154:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c156:	429a      	cmp	r2, r3
 801c158:	f6ff af2e 	blt.w	801bfb8 <jinit_upsampler+0x5c>
    }
  }
}
 801c15c:	bf00      	nop
 801c15e:	bf00      	nop
 801c160:	372c      	adds	r7, #44	@ 0x2c
 801c162:	46bd      	mov	sp, r7
 801c164:	bd90      	pop	{r4, r7, pc}
 801c166:	bf00      	nop
 801c168:	0801bbe9 	.word	0x0801bbe9
 801c16c:	0801bc17 	.word	0x0801bc17
 801c170:	0801bd6d 	.word	0x0801bd6d
 801c174:	0801bd4d 	.word	0x0801bd4d
 801c178:	0801be57 	.word	0x0801be57
 801c17c:	0801bec9 	.word	0x0801bec9
 801c180:	0801bd8d 	.word	0x0801bd8d

0801c184 <error_exit>:
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
 801c184:	b580      	push	{r7, lr}
 801c186:	b082      	sub	sp, #8
 801c188:	af00      	add	r7, sp, #0
 801c18a:	6078      	str	r0, [r7, #4]
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);
 801c18c:	687b      	ldr	r3, [r7, #4]
 801c18e:	681b      	ldr	r3, [r3, #0]
 801c190:	689b      	ldr	r3, [r3, #8]
 801c192:	6878      	ldr	r0, [r7, #4]
 801c194:	4798      	blx	r3

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);
 801c196:	6878      	ldr	r0, [r7, #4]
 801c198:	f7f4 fcb2 	bl	8010b00 <jpeg_destroy>

  //exit(EXIT_FAILURE);
}
 801c19c:	bf00      	nop
 801c19e:	3708      	adds	r7, #8
 801c1a0:	46bd      	mov	sp, r7
 801c1a2:	bd80      	pop	{r7, pc}

0801c1a4 <output_message>:
 * not just not use this routine.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
 801c1a4:	b580      	push	{r7, lr}
 801c1a6:	b0b4      	sub	sp, #208	@ 0xd0
 801c1a8:	af00      	add	r7, sp, #0
 801c1aa:	6078      	str	r0, [r7, #4]
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);
 801c1ac:	687b      	ldr	r3, [r7, #4]
 801c1ae:	681b      	ldr	r3, [r3, #0]
 801c1b0:	68db      	ldr	r3, [r3, #12]
 801c1b2:	f107 0208 	add.w	r2, r7, #8
 801c1b6:	4611      	mov	r1, r2
 801c1b8:	6878      	ldr	r0, [r7, #4]
 801c1ba:	4798      	blx	r3
#else
  /* Send it to stderr, adding a newline */
//  fprintf(stderr, "%s\n", buffer);
//  printf( "%s\n", buffer);
#endif
}
 801c1bc:	bf00      	nop
 801c1be:	37d0      	adds	r7, #208	@ 0xd0
 801c1c0:	46bd      	mov	sp, r7
 801c1c2:	bd80      	pop	{r7, pc}

0801c1c4 <emit_message>:
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
 801c1c4:	b580      	push	{r7, lr}
 801c1c6:	b084      	sub	sp, #16
 801c1c8:	af00      	add	r7, sp, #0
 801c1ca:	6078      	str	r0, [r7, #4]
 801c1cc:	6039      	str	r1, [r7, #0]
  struct jpeg_error_mgr * err = cinfo->err;
 801c1ce:	687b      	ldr	r3, [r7, #4]
 801c1d0:	681b      	ldr	r3, [r3, #0]
 801c1d2:	60fb      	str	r3, [r7, #12]

  if (msg_level < 0) {
 801c1d4:	683b      	ldr	r3, [r7, #0]
 801c1d6:	2b00      	cmp	r3, #0
 801c1d8:	da11      	bge.n	801c1fe <emit_message+0x3a>
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
 801c1da:	68fb      	ldr	r3, [r7, #12]
 801c1dc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801c1de:	2b00      	cmp	r3, #0
 801c1e0:	d003      	beq.n	801c1ea <emit_message+0x26>
 801c1e2:	68fb      	ldr	r3, [r7, #12]
 801c1e4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801c1e6:	2b02      	cmp	r3, #2
 801c1e8:	dd03      	ble.n	801c1f2 <emit_message+0x2e>
      (*err->output_message) (cinfo);
 801c1ea:	68fb      	ldr	r3, [r7, #12]
 801c1ec:	689b      	ldr	r3, [r3, #8]
 801c1ee:	6878      	ldr	r0, [r7, #4]
 801c1f0:	4798      	blx	r3
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
 801c1f2:	68fb      	ldr	r3, [r7, #12]
 801c1f4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801c1f6:	1c5a      	adds	r2, r3, #1
 801c1f8:	68fb      	ldr	r3, [r7, #12]
 801c1fa:	66da      	str	r2, [r3, #108]	@ 0x6c
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}
 801c1fc:	e008      	b.n	801c210 <emit_message+0x4c>
    if (err->trace_level >= msg_level)
 801c1fe:	68fb      	ldr	r3, [r7, #12]
 801c200:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801c202:	683a      	ldr	r2, [r7, #0]
 801c204:	429a      	cmp	r2, r3
 801c206:	dc03      	bgt.n	801c210 <emit_message+0x4c>
      (*err->output_message) (cinfo);
 801c208:	68fb      	ldr	r3, [r7, #12]
 801c20a:	689b      	ldr	r3, [r3, #8]
 801c20c:	6878      	ldr	r0, [r7, #4]
 801c20e:	4798      	blx	r3
}
 801c210:	bf00      	nop
 801c212:	3710      	adds	r7, #16
 801c214:	46bd      	mov	sp, r7
 801c216:	bd80      	pop	{r7, pc}

0801c218 <format_message>:
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
 801c218:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c21a:	b091      	sub	sp, #68	@ 0x44
 801c21c:	af06      	add	r7, sp, #24
 801c21e:	60f8      	str	r0, [r7, #12]
 801c220:	60b9      	str	r1, [r7, #8]
  struct jpeg_error_mgr * err = cinfo->err;
 801c222:	68fb      	ldr	r3, [r7, #12]
 801c224:	681b      	ldr	r3, [r3, #0]
 801c226:	61bb      	str	r3, [r7, #24]
  int msg_code = err->msg_code;
 801c228:	69bb      	ldr	r3, [r7, #24]
 801c22a:	695b      	ldr	r3, [r3, #20]
 801c22c:	617b      	str	r3, [r7, #20]
  const char * msgtext = NULL;
 801c22e:	2300      	movs	r3, #0
 801c230:	627b      	str	r3, [r7, #36]	@ 0x24
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
 801c232:	697b      	ldr	r3, [r7, #20]
 801c234:	2b00      	cmp	r3, #0
 801c236:	dd0c      	ble.n	801c252 <format_message+0x3a>
 801c238:	69bb      	ldr	r3, [r7, #24]
 801c23a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801c23c:	697a      	ldr	r2, [r7, #20]
 801c23e:	429a      	cmp	r2, r3
 801c240:	dc07      	bgt.n	801c252 <format_message+0x3a>
    msgtext = err->jpeg_message_table[msg_code];
 801c242:	69bb      	ldr	r3, [r7, #24]
 801c244:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 801c246:	697b      	ldr	r3, [r7, #20]
 801c248:	009b      	lsls	r3, r3, #2
 801c24a:	4413      	add	r3, r2
 801c24c:	681b      	ldr	r3, [r3, #0]
 801c24e:	627b      	str	r3, [r7, #36]	@ 0x24
 801c250:	e018      	b.n	801c284 <format_message+0x6c>
  } else if (err->addon_message_table != NULL &&
 801c252:	69bb      	ldr	r3, [r7, #24]
 801c254:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801c256:	2b00      	cmp	r3, #0
 801c258:	d014      	beq.n	801c284 <format_message+0x6c>
	     msg_code >= err->first_addon_message &&
 801c25a:	69bb      	ldr	r3, [r7, #24]
 801c25c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
  } else if (err->addon_message_table != NULL &&
 801c25e:	697a      	ldr	r2, [r7, #20]
 801c260:	429a      	cmp	r2, r3
 801c262:	db0f      	blt.n	801c284 <format_message+0x6c>
	     msg_code <= err->last_addon_message) {
 801c264:	69bb      	ldr	r3, [r7, #24]
 801c266:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
	     msg_code >= err->first_addon_message &&
 801c26a:	697a      	ldr	r2, [r7, #20]
 801c26c:	429a      	cmp	r2, r3
 801c26e:	dc09      	bgt.n	801c284 <format_message+0x6c>
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
 801c270:	69bb      	ldr	r3, [r7, #24]
 801c272:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 801c274:	69bb      	ldr	r3, [r7, #24]
 801c276:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 801c278:	6979      	ldr	r1, [r7, #20]
 801c27a:	1acb      	subs	r3, r1, r3
 801c27c:	009b      	lsls	r3, r3, #2
 801c27e:	4413      	add	r3, r2
 801c280:	681b      	ldr	r3, [r3, #0]
 801c282:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
 801c284:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c286:	2b00      	cmp	r3, #0
 801c288:	d106      	bne.n	801c298 <format_message+0x80>
    err->msg_parm.i[0] = msg_code;
 801c28a:	69bb      	ldr	r3, [r7, #24]
 801c28c:	697a      	ldr	r2, [r7, #20]
 801c28e:	619a      	str	r2, [r3, #24]
    msgtext = err->jpeg_message_table[0];
 801c290:	69bb      	ldr	r3, [r7, #24]
 801c292:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801c294:	681b      	ldr	r3, [r3, #0]
 801c296:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
 801c298:	2300      	movs	r3, #0
 801c29a:	61fb      	str	r3, [r7, #28]
  msgptr = msgtext;
 801c29c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c29e:	623b      	str	r3, [r7, #32]
  while ((ch = *msgptr++) != '\0') {
 801c2a0:	e009      	b.n	801c2b6 <format_message+0x9e>
    if (ch == '%') {
 801c2a2:	7cfb      	ldrb	r3, [r7, #19]
 801c2a4:	2b25      	cmp	r3, #37	@ 0x25
 801c2a6:	d106      	bne.n	801c2b6 <format_message+0x9e>
      if (*msgptr == 's') isstring = TRUE;
 801c2a8:	6a3b      	ldr	r3, [r7, #32]
 801c2aa:	781b      	ldrb	r3, [r3, #0]
 801c2ac:	2b73      	cmp	r3, #115	@ 0x73
 801c2ae:	d10b      	bne.n	801c2c8 <format_message+0xb0>
 801c2b0:	2301      	movs	r3, #1
 801c2b2:	61fb      	str	r3, [r7, #28]
      break;
 801c2b4:	e008      	b.n	801c2c8 <format_message+0xb0>
  while ((ch = *msgptr++) != '\0') {
 801c2b6:	6a3b      	ldr	r3, [r7, #32]
 801c2b8:	1c5a      	adds	r2, r3, #1
 801c2ba:	623a      	str	r2, [r7, #32]
 801c2bc:	781b      	ldrb	r3, [r3, #0]
 801c2be:	74fb      	strb	r3, [r7, #19]
 801c2c0:	7cfb      	ldrb	r3, [r7, #19]
 801c2c2:	2b00      	cmp	r3, #0
 801c2c4:	d1ed      	bne.n	801c2a2 <format_message+0x8a>
 801c2c6:	e000      	b.n	801c2ca <format_message+0xb2>
      break;
 801c2c8:	bf00      	nop
    }
  }

  /* Format the message into the passed buffer */
  if (isstring)
 801c2ca:	69fb      	ldr	r3, [r7, #28]
 801c2cc:	2b00      	cmp	r3, #0
 801c2ce:	d007      	beq.n	801c2e0 <format_message+0xc8>
    sprintf(buffer, msgtext, err->msg_parm.s);
 801c2d0:	69bb      	ldr	r3, [r7, #24]
 801c2d2:	3318      	adds	r3, #24
 801c2d4:	461a      	mov	r2, r3
 801c2d6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c2d8:	68b8      	ldr	r0, [r7, #8]
 801c2da:	f011 fa27 	bl	802d72c <siprintf>
    sprintf(buffer, msgtext,
	    err->msg_parm.i[0], err->msg_parm.i[1],
	    err->msg_parm.i[2], err->msg_parm.i[3],
	    err->msg_parm.i[4], err->msg_parm.i[5],
	    err->msg_parm.i[6], err->msg_parm.i[7]);
}
 801c2de:	e01c      	b.n	801c31a <format_message+0x102>
    sprintf(buffer, msgtext,
 801c2e0:	69bb      	ldr	r3, [r7, #24]
 801c2e2:	699e      	ldr	r6, [r3, #24]
 801c2e4:	69bb      	ldr	r3, [r7, #24]
 801c2e6:	69db      	ldr	r3, [r3, #28]
 801c2e8:	607b      	str	r3, [r7, #4]
 801c2ea:	69bb      	ldr	r3, [r7, #24]
 801c2ec:	6a1b      	ldr	r3, [r3, #32]
 801c2ee:	69ba      	ldr	r2, [r7, #24]
 801c2f0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801c2f2:	69b9      	ldr	r1, [r7, #24]
 801c2f4:	6a89      	ldr	r1, [r1, #40]	@ 0x28
 801c2f6:	69b8      	ldr	r0, [r7, #24]
 801c2f8:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 801c2fa:	69bc      	ldr	r4, [r7, #24]
 801c2fc:	6b24      	ldr	r4, [r4, #48]	@ 0x30
 801c2fe:	69bd      	ldr	r5, [r7, #24]
 801c300:	6b6d      	ldr	r5, [r5, #52]	@ 0x34
 801c302:	9505      	str	r5, [sp, #20]
 801c304:	9404      	str	r4, [sp, #16]
 801c306:	9003      	str	r0, [sp, #12]
 801c308:	9102      	str	r1, [sp, #8]
 801c30a:	9201      	str	r2, [sp, #4]
 801c30c:	9300      	str	r3, [sp, #0]
 801c30e:	687b      	ldr	r3, [r7, #4]
 801c310:	4632      	mov	r2, r6
 801c312:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c314:	68b8      	ldr	r0, [r7, #8]
 801c316:	f011 fa09 	bl	802d72c <siprintf>
}
 801c31a:	bf00      	nop
 801c31c:	372c      	adds	r7, #44	@ 0x2c
 801c31e:	46bd      	mov	sp, r7
 801c320:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801c322 <reset_error_mgr>:
 * this method if it has additional error processing state.
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
 801c322:	b480      	push	{r7}
 801c324:	b083      	sub	sp, #12
 801c326:	af00      	add	r7, sp, #0
 801c328:	6078      	str	r0, [r7, #4]
  cinfo->err->num_warnings = 0;
 801c32a:	687b      	ldr	r3, [r7, #4]
 801c32c:	681b      	ldr	r3, [r3, #0]
 801c32e:	2200      	movs	r2, #0
 801c330:	66da      	str	r2, [r3, #108]	@ 0x6c
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
 801c332:	687b      	ldr	r3, [r7, #4]
 801c334:	681b      	ldr	r3, [r3, #0]
 801c336:	2200      	movs	r2, #0
 801c338:	615a      	str	r2, [r3, #20]
}
 801c33a:	bf00      	nop
 801c33c:	370c      	adds	r7, #12
 801c33e:	46bd      	mov	sp, r7
 801c340:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c344:	4770      	bx	lr
	...

0801c348 <jpeg_std_error>:
 * after which the application may override some of the methods.
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{
 801c348:	b480      	push	{r7}
 801c34a:	b083      	sub	sp, #12
 801c34c:	af00      	add	r7, sp, #0
 801c34e:	6078      	str	r0, [r7, #4]
  err->error_exit = error_exit;
 801c350:	687b      	ldr	r3, [r7, #4]
 801c352:	4a17      	ldr	r2, [pc, #92]	@ (801c3b0 <jpeg_std_error+0x68>)
 801c354:	601a      	str	r2, [r3, #0]
  err->emit_message = emit_message;
 801c356:	687b      	ldr	r3, [r7, #4]
 801c358:	4a16      	ldr	r2, [pc, #88]	@ (801c3b4 <jpeg_std_error+0x6c>)
 801c35a:	605a      	str	r2, [r3, #4]
  err->output_message = output_message;
 801c35c:	687b      	ldr	r3, [r7, #4]
 801c35e:	4a16      	ldr	r2, [pc, #88]	@ (801c3b8 <jpeg_std_error+0x70>)
 801c360:	609a      	str	r2, [r3, #8]
  err->format_message = format_message;
 801c362:	687b      	ldr	r3, [r7, #4]
 801c364:	4a15      	ldr	r2, [pc, #84]	@ (801c3bc <jpeg_std_error+0x74>)
 801c366:	60da      	str	r2, [r3, #12]
  err->reset_error_mgr = reset_error_mgr;
 801c368:	687b      	ldr	r3, [r7, #4]
 801c36a:	4a15      	ldr	r2, [pc, #84]	@ (801c3c0 <jpeg_std_error+0x78>)
 801c36c:	611a      	str	r2, [r3, #16]

  err->trace_level = 0;		/* default = no tracing */
 801c36e:	687b      	ldr	r3, [r7, #4]
 801c370:	2200      	movs	r2, #0
 801c372:	669a      	str	r2, [r3, #104]	@ 0x68
  err->num_warnings = 0;	/* no warnings emitted yet */
 801c374:	687b      	ldr	r3, [r7, #4]
 801c376:	2200      	movs	r2, #0
 801c378:	66da      	str	r2, [r3, #108]	@ 0x6c
  err->msg_code = 0;		/* may be useful as a flag for "no error" */
 801c37a:	687b      	ldr	r3, [r7, #4]
 801c37c:	2200      	movs	r2, #0
 801c37e:	615a      	str	r2, [r3, #20]

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
 801c380:	687b      	ldr	r3, [r7, #4]
 801c382:	4a10      	ldr	r2, [pc, #64]	@ (801c3c4 <jpeg_std_error+0x7c>)
 801c384:	671a      	str	r2, [r3, #112]	@ 0x70
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
 801c386:	687b      	ldr	r3, [r7, #4]
 801c388:	227e      	movs	r2, #126	@ 0x7e
 801c38a:	675a      	str	r2, [r3, #116]	@ 0x74

  err->addon_message_table = NULL;
 801c38c:	687b      	ldr	r3, [r7, #4]
 801c38e:	2200      	movs	r2, #0
 801c390:	679a      	str	r2, [r3, #120]	@ 0x78
  err->first_addon_message = 0;	/* for safety */
 801c392:	687b      	ldr	r3, [r7, #4]
 801c394:	2200      	movs	r2, #0
 801c396:	67da      	str	r2, [r3, #124]	@ 0x7c
  err->last_addon_message = 0;
 801c398:	687b      	ldr	r3, [r7, #4]
 801c39a:	2200      	movs	r2, #0
 801c39c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return err;
 801c3a0:	687b      	ldr	r3, [r7, #4]
}
 801c3a2:	4618      	mov	r0, r3
 801c3a4:	370c      	adds	r7, #12
 801c3a6:	46bd      	mov	sp, r7
 801c3a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c3ac:	4770      	bx	lr
 801c3ae:	bf00      	nop
 801c3b0:	0801c185 	.word	0x0801c185
 801c3b4:	0801c1c5 	.word	0x0801c1c5
 801c3b8:	0801c1a5 	.word	0x0801c1a5
 801c3bc:	0801c219 	.word	0x0801c219
 801c3c0:	0801c323 	.word	0x0801c323
 801c3c4:	08030594 	.word	0x08030594

0801c3c8 <jpeg_idct_float>:

GLOBAL(void)
jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801c3c8:	b490      	push	{r4, r7}
 801c3ca:	b0dc      	sub	sp, #368	@ 0x170
 801c3cc:	af00      	add	r7, sp, #0
 801c3ce:	f507 74b8 	add.w	r4, r7, #368	@ 0x170
 801c3d2:	f5a4 74b2 	sub.w	r4, r4, #356	@ 0x164
 801c3d6:	6020      	str	r0, [r4, #0]
 801c3d8:	f507 70b8 	add.w	r0, r7, #368	@ 0x170
 801c3dc:	f5a0 70b4 	sub.w	r0, r0, #360	@ 0x168
 801c3e0:	6001      	str	r1, [r0, #0]
 801c3e2:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
 801c3e6:	f5a1 71b6 	sub.w	r1, r1, #364	@ 0x16c
 801c3ea:	600a      	str	r2, [r1, #0]
 801c3ec:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
 801c3f0:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
 801c3f4:	6013      	str	r3, [r2, #0]
  FAST_FLOAT z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  FLOAT_MULT_TYPE * quantptr;
  FAST_FLOAT * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 801c3f6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801c3fa:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 801c3fe:	681b      	ldr	r3, [r3, #0]
 801c400:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801c404:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
  int ctr;
  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801c408:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801c40c:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 801c410:	681b      	ldr	r3, [r3, #0]
 801c412:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
 801c416:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801c41a:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 801c41e:	681b      	ldr	r3, [r3, #0]
 801c420:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801c422:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
  wsptr = workspace;
 801c426:	f107 0310 	add.w	r3, r7, #16
 801c42a:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801c42e:	2308      	movs	r3, #8
 801c430:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801c434:	e230      	b.n	801c898 <jpeg_idct_float+0x4d0>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801c436:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c43a:	3310      	adds	r3, #16
 801c43c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c440:	2b00      	cmp	r3, #0
 801c442:	d178      	bne.n	801c536 <jpeg_idct_float+0x16e>
 801c444:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c448:	3320      	adds	r3, #32
 801c44a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c44e:	2b00      	cmp	r3, #0
 801c450:	d171      	bne.n	801c536 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801c452:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c456:	3330      	adds	r3, #48	@ 0x30
 801c458:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801c45c:	2b00      	cmp	r3, #0
 801c45e:	d16a      	bne.n	801c536 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801c460:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c464:	3340      	adds	r3, #64	@ 0x40
 801c466:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c46a:	2b00      	cmp	r3, #0
 801c46c:	d163      	bne.n	801c536 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801c46e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c472:	3350      	adds	r3, #80	@ 0x50
 801c474:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801c478:	2b00      	cmp	r3, #0
 801c47a:	d15c      	bne.n	801c536 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801c47c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c480:	3360      	adds	r3, #96	@ 0x60
 801c482:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c486:	2b00      	cmp	r3, #0
 801c488:	d155      	bne.n	801c536 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*7] == 0) {
 801c48a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c48e:	3370      	adds	r3, #112	@ 0x70
 801c490:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801c494:	2b00      	cmp	r3, #0
 801c496:	d14e      	bne.n	801c536 <jpeg_idct_float+0x16e>
      /* AC terms all zero */
      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801c498:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c49c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c4a0:	ee07 3a90 	vmov	s15, r3
 801c4a4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c4a8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c4ac:	edd3 7a00 	vldr	s15, [r3]
 801c4b0:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c4b4:	edc7 7a44 	vstr	s15, [r7, #272]	@ 0x110
      
      wsptr[DCTSIZE*0] = dcval;
 801c4b8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4bc:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4c0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801c4c2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4c6:	3320      	adds	r3, #32
 801c4c8:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4cc:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801c4ce:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4d2:	3340      	adds	r3, #64	@ 0x40
 801c4d4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4d8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801c4da:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4de:	3360      	adds	r3, #96	@ 0x60
 801c4e0:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4e4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801c4e6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4ea:	3380      	adds	r3, #128	@ 0x80
 801c4ec:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4f0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801c4f2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c4f6:	33a0      	adds	r3, #160	@ 0xa0
 801c4f8:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c4fc:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801c4fe:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c502:	33c0      	adds	r3, #192	@ 0xc0
 801c504:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c508:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801c50a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c50e:	33e0      	adds	r3, #224	@ 0xe0
 801c510:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801c514:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 801c516:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c51a:	3302      	adds	r3, #2
 801c51c:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      quantptr++;
 801c520:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c524:	3304      	adds	r3, #4
 801c526:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
      wsptr++;
 801c52a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c52e:	3304      	adds	r3, #4
 801c530:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
      continue;
 801c534:	e1ab      	b.n	801c88e <jpeg_idct_float+0x4c6>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801c536:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c53a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c53e:	ee07 3a90 	vmov	s15, r3
 801c542:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c546:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c54a:	edd3 7a00 	vldr	s15, [r3]
 801c54e:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c552:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801c556:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c55a:	3320      	adds	r3, #32
 801c55c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c560:	ee07 3a90 	vmov	s15, r3
 801c564:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c568:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c56c:	3340      	adds	r3, #64	@ 0x40
 801c56e:	edd3 7a00 	vldr	s15, [r3]
 801c572:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c576:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801c57a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c57e:	3340      	adds	r3, #64	@ 0x40
 801c580:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c584:	ee07 3a90 	vmov	s15, r3
 801c588:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c58c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c590:	3380      	adds	r3, #128	@ 0x80
 801c592:	edd3 7a00 	vldr	s15, [r3]
 801c596:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c59a:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801c59e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c5a2:	3360      	adds	r3, #96	@ 0x60
 801c5a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c5a8:	ee07 3a90 	vmov	s15, r3
 801c5ac:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c5b0:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c5b4:	33c0      	adds	r3, #192	@ 0xc0
 801c5b6:	edd3 7a00 	vldr	s15, [r3]
 801c5ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c5be:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801c5c2:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801c5c6:	edd7 7a4d 	vldr	s15, [r7, #308]	@ 0x134
 801c5ca:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c5ce:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp11 = tmp0 - tmp2;
 801c5d2:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801c5d6:	edd7 7a4d 	vldr	s15, [r7, #308]	@ 0x134
 801c5da:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c5de:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801c5e2:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801c5e6:	edd7 7a4f 	vldr	s15, [r7, #316]	@ 0x13c
 801c5ea:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c5ee:	edc7 7a52 	vstr	s15, [r7, #328]	@ 0x148
    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */
 801c5f2:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801c5f6:	edd7 7a4f 	vldr	s15, [r7, #316]	@ 0x13c
 801c5fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c5fe:	ed9f 7aae 	vldr	s14, [pc, #696]	@ 801c8b8 <jpeg_idct_float+0x4f0>
 801c602:	ee27 7a87 	vmul.f32	s14, s15, s14
 801c606:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c60a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c60e:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 801c612:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801c616:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c61a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c61e:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp3 = tmp10 - tmp13;
 801c622:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801c626:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c62a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c62e:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c
    tmp1 = tmp11 + tmp12;
 801c632:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801c636:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801c63a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c63e:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = tmp11 - tmp12;
 801c642:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801c646:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801c64a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c64e:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801c652:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c656:	3310      	adds	r3, #16
 801c658:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c65c:	ee07 3a90 	vmov	s15, r3
 801c660:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c664:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c668:	3320      	adds	r3, #32
 801c66a:	edd3 7a00 	vldr	s15, [r3]
 801c66e:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c672:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801c676:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c67a:	3330      	adds	r3, #48	@ 0x30
 801c67c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c680:	ee07 3a90 	vmov	s15, r3
 801c684:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c688:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c68c:	3360      	adds	r3, #96	@ 0x60
 801c68e:	edd3 7a00 	vldr	s15, [r3]
 801c692:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c696:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801c69a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c69e:	3350      	adds	r3, #80	@ 0x50
 801c6a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c6a4:	ee07 3a90 	vmov	s15, r3
 801c6a8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c6ac:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c6b0:	33a0      	adds	r3, #160	@ 0xa0
 801c6b2:	edd3 7a00 	vldr	s15, [r3]
 801c6b6:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c6ba:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801c6be:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c6c2:	3370      	adds	r3, #112	@ 0x70
 801c6c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c6c8:	ee07 3a90 	vmov	s15, r3
 801c6cc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801c6d0:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c6d4:	33e0      	adds	r3, #224	@ 0xe0
 801c6d6:	edd3 7a00 	vldr	s15, [r3]
 801c6da:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c6de:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120

    z13 = tmp6 + tmp5;		/* phase 6 */
 801c6e2:	ed97 7a47 	vldr	s14, [r7, #284]	@ 0x11c
 801c6e6:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801c6ea:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c6ee:	edc7 7a4c 	vstr	s15, [r7, #304]	@ 0x130
    z10 = tmp6 - tmp5;
 801c6f2:	ed97 7a47 	vldr	s14, [r7, #284]	@ 0x11c
 801c6f6:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801c6fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c6fe:	edc7 7a4b 	vstr	s15, [r7, #300]	@ 0x12c
    z11 = tmp4 + tmp7;
 801c702:	ed97 7a45 	vldr	s14, [r7, #276]	@ 0x114
 801c706:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801c70a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c70e:	edc7 7a4a 	vstr	s15, [r7, #296]	@ 0x128
    z12 = tmp4 - tmp7;
 801c712:	ed97 7a45 	vldr	s14, [r7, #276]	@ 0x114
 801c716:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801c71a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c71e:	edc7 7a49 	vstr	s15, [r7, #292]	@ 0x124

    tmp7 = z11 + z13;		/* phase 5 */
 801c722:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801c726:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801c72a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c72e:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */
 801c732:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801c736:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801c73a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c73e:	ed9f 7a5e 	vldr	s14, [pc, #376]	@ 801c8b8 <jpeg_idct_float+0x4f0>
 801c742:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c746:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 801c74a:	ed97 7a4b 	vldr	s14, [r7, #300]	@ 0x12c
 801c74e:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801c752:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c756:	ed9f 7a59 	vldr	s14, [pc, #356]	@ 801c8bc <jpeg_idct_float+0x4f4>
 801c75a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c75e:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 801c762:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801c766:	ed9f 7a56 	vldr	s14, [pc, #344]	@ 801c8c0 <jpeg_idct_float+0x4f8>
 801c76a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c76e:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801c772:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c776:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 801c77a:	edd7 7a4b 	vldr	s15, [r7, #300]	@ 0x12c
 801c77e:	ed9f 7a51 	vldr	s14, [pc, #324]	@ 801c8c4 <jpeg_idct_float+0x4fc>
 801c782:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c786:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801c78a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c78e:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801c792:	ed97 7a51 	vldr	s14, [r7, #324]	@ 0x144
 801c796:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801c79a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c79e:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp5 = tmp11 - tmp6;
 801c7a2:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801c7a6:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801c7aa:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c7ae:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp4 = tmp10 - tmp5;
 801c7b2:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801c7b6:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801c7ba:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c7be:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114

    wsptr[DCTSIZE*0] = tmp0 + tmp7;
 801c7c2:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801c7c6:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801c7ca:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c7ce:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c7d2:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*7] = tmp0 - tmp7;
 801c7d6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c7da:	33e0      	adds	r3, #224	@ 0xe0
 801c7dc:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801c7e0:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801c7e4:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c7e8:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*1] = tmp1 + tmp6;
 801c7ec:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c7f0:	3320      	adds	r3, #32
 801c7f2:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801c7f6:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801c7fa:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c7fe:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*6] = tmp1 - tmp6;
 801c802:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c806:	33c0      	adds	r3, #192	@ 0xc0
 801c808:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801c80c:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801c810:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c814:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*2] = tmp2 + tmp5;
 801c818:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c81c:	3340      	adds	r3, #64	@ 0x40
 801c81e:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801c822:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801c826:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c82a:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*5] = tmp2 - tmp5;
 801c82e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c832:	33a0      	adds	r3, #160	@ 0xa0
 801c834:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801c838:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801c83c:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c840:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*3] = tmp3 + tmp4;
 801c844:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c848:	3360      	adds	r3, #96	@ 0x60
 801c84a:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801c84e:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801c852:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c856:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*4] = tmp3 - tmp4;
 801c85a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c85e:	3380      	adds	r3, #128	@ 0x80
 801c860:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801c864:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801c868:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c86c:	edc3 7a00 	vstr	s15, [r3]

    inptr++;			/* advance pointers to next column */
 801c870:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801c874:	3302      	adds	r3, #2
 801c876:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    quantptr++;
 801c87a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801c87e:	3304      	adds	r3, #4
 801c880:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    wsptr++;
 801c884:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c888:	3304      	adds	r3, #4
 801c88a:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801c88e:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801c892:	3b01      	subs	r3, #1
 801c894:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801c898:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801c89c:	2b00      	cmp	r3, #0
 801c89e:	f73f adca 	bgt.w	801c436 <jpeg_idct_float+0x6e>
  }
  
  /* Pass 2: process rows from work array, store into output array. */

  wsptr = workspace;
 801c8a2:	f107 0310 	add.w	r3, r7, #16
 801c8a6:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801c8aa:	2300      	movs	r3, #0
 801c8ac:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801c8b0:	e1ae      	b.n	801cc10 <jpeg_idct_float+0x848>
 801c8b2:	bf00      	nop
 801c8b4:	43008000 	.word	0x43008000
 801c8b8:	3fb504f3 	.word	0x3fb504f3
 801c8bc:	3fec835e 	.word	0x3fec835e
 801c8c0:	3f8a8bd4 	.word	0x3f8a8bd4
 801c8c4:	40273d75 	.word	0x40273d75
    outptr = output_buf[ctr] + output_col;
 801c8c8:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801c8cc:	009b      	lsls	r3, r3, #2
 801c8ce:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
 801c8d2:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
 801c8d6:	6812      	ldr	r2, [r2, #0]
 801c8d8:	4413      	add	r3, r2
 801c8da:	681a      	ldr	r2, [r3, #0]
 801c8dc:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801c8e0:	4413      	add	r3, r2
 801c8e2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
     */
    
    /* Even part */

    /* Apply signed->unsigned and prepare float->int conversion */
    z5 = wsptr[0] + ((FAST_FLOAT) CENTERJSAMPLE + (FAST_FLOAT) 0.5);
 801c8e6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c8ea:	edd3 7a00 	vldr	s15, [r3]
 801c8ee:	ed1f 7a0f 	vldr	s14, [pc, #-60]	@ 801c8b4 <jpeg_idct_float+0x4ec>
 801c8f2:	ee77 7a87 	vadd.f32	s15, s15, s14
 801c8f6:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 + wsptr[4];
 801c8fa:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c8fe:	3310      	adds	r3, #16
 801c900:	edd3 7a00 	vldr	s15, [r3]
 801c904:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801c908:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c90c:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp11 = z5 - wsptr[4];
 801c910:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c914:	3310      	adds	r3, #16
 801c916:	edd3 7a00 	vldr	s15, [r3]
 801c91a:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801c91e:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c922:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    tmp13 = wsptr[2] + wsptr[6];
 801c926:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c92a:	3308      	adds	r3, #8
 801c92c:	ed93 7a00 	vldr	s14, [r3]
 801c930:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c934:	3318      	adds	r3, #24
 801c936:	edd3 7a00 	vldr	s15, [r3]
 801c93a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c93e:	edc7 7a52 	vstr	s15, [r7, #328]	@ 0x148
    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;
 801c942:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c946:	3308      	adds	r3, #8
 801c948:	ed93 7a00 	vldr	s14, [r3]
 801c94c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c950:	3318      	adds	r3, #24
 801c952:	edd3 7a00 	vldr	s15, [r3]
 801c956:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c95a:	ed1f 7a29 	vldr	s14, [pc, #-164]	@ 801c8b8 <jpeg_idct_float+0x4f0>
 801c95e:	ee27 7a87 	vmul.f32	s14, s15, s14
 801c962:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c966:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c96a:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp0 = tmp10 + tmp13;
 801c96e:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801c972:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c976:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c97a:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp3 = tmp10 - tmp13;
 801c97e:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801c982:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801c986:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c98a:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c
    tmp1 = tmp11 + tmp12;
 801c98e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801c992:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801c996:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c99a:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = tmp11 - tmp12;
 801c99e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801c9a2:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801c9a6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c9aa:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134

    /* Odd part */

    z13 = wsptr[5] + wsptr[3];
 801c9ae:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9b2:	3314      	adds	r3, #20
 801c9b4:	ed93 7a00 	vldr	s14, [r3]
 801c9b8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9bc:	330c      	adds	r3, #12
 801c9be:	edd3 7a00 	vldr	s15, [r3]
 801c9c2:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c9c6:	edc7 7a4c 	vstr	s15, [r7, #304]	@ 0x130
    z10 = wsptr[5] - wsptr[3];
 801c9ca:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9ce:	3314      	adds	r3, #20
 801c9d0:	ed93 7a00 	vldr	s14, [r3]
 801c9d4:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9d8:	330c      	adds	r3, #12
 801c9da:	edd3 7a00 	vldr	s15, [r3]
 801c9de:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c9e2:	edc7 7a4b 	vstr	s15, [r7, #300]	@ 0x12c
    z11 = wsptr[1] + wsptr[7];
 801c9e6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9ea:	3304      	adds	r3, #4
 801c9ec:	ed93 7a00 	vldr	s14, [r3]
 801c9f0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801c9f4:	331c      	adds	r3, #28
 801c9f6:	edd3 7a00 	vldr	s15, [r3]
 801c9fa:	ee77 7a27 	vadd.f32	s15, s14, s15
 801c9fe:	edc7 7a4a 	vstr	s15, [r7, #296]	@ 0x128
    z12 = wsptr[1] - wsptr[7];
 801ca02:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ca06:	3304      	adds	r3, #4
 801ca08:	ed93 7a00 	vldr	s14, [r3]
 801ca0c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ca10:	331c      	adds	r3, #28
 801ca12:	edd3 7a00 	vldr	s15, [r3]
 801ca16:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ca1a:	edc7 7a49 	vstr	s15, [r7, #292]	@ 0x124

    tmp7 = z11 + z13;
 801ca1e:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801ca22:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801ca26:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ca2a:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);
 801ca2e:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801ca32:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801ca36:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ca3a:	ed1f 7a61 	vldr	s14, [pc, #-388]	@ 801c8b8 <jpeg_idct_float+0x4f0>
 801ca3e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ca42:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 801ca46:	ed97 7a4b 	vldr	s14, [r7, #300]	@ 0x12c
 801ca4a:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801ca4e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ca52:	ed1f 7a66 	vldr	s14, [pc, #-408]	@ 801c8bc <jpeg_idct_float+0x4f4>
 801ca56:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ca5a:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 801ca5e:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801ca62:	ed1f 7a69 	vldr	s14, [pc, #-420]	@ 801c8c0 <jpeg_idct_float+0x4f8>
 801ca66:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ca6a:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ca6e:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ca72:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 801ca76:	edd7 7a4b 	vldr	s15, [r7, #300]	@ 0x12c
 801ca7a:	ed1f 7a6e 	vldr	s14, [pc, #-440]	@ 801c8c4 <jpeg_idct_float+0x4fc>
 801ca7e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ca82:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ca86:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ca8a:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp6 = tmp12 - tmp7;
 801ca8e:	ed97 7a51 	vldr	s14, [r7, #324]	@ 0x144
 801ca92:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801ca96:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ca9a:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp5 = tmp11 - tmp6;
 801ca9e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801caa2:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801caa6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801caaa:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp4 = tmp10 - tmp5;
 801caae:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801cab2:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801cab6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801caba:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114

    /* Final output stage: float->int conversion and range-limit */

    outptr[0] = range_limit[((int) (tmp0 + tmp7)) & RANGE_MASK];
 801cabe:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801cac2:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801cac6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801caca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cace:	ee17 3a90 	vmov	r3, s15
 801cad2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cad6:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cada:	4413      	add	r3, r2
 801cadc:	781a      	ldrb	r2, [r3, #0]
 801cade:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cae2:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[((int) (tmp0 - tmp7)) & RANGE_MASK];
 801cae4:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801cae8:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801caec:	ee77 7a67 	vsub.f32	s15, s14, s15
 801caf0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801caf4:	ee17 3a90 	vmov	r3, s15
 801caf8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cafc:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cb00:	441a      	add	r2, r3
 801cb02:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cb06:	3307      	adds	r3, #7
 801cb08:	7812      	ldrb	r2, [r2, #0]
 801cb0a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[((int) (tmp1 + tmp6)) & RANGE_MASK];
 801cb0c:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801cb10:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801cb14:	ee77 7a27 	vadd.f32	s15, s14, s15
 801cb18:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cb1c:	ee17 3a90 	vmov	r3, s15
 801cb20:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cb24:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cb28:	441a      	add	r2, r3
 801cb2a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cb2e:	3301      	adds	r3, #1
 801cb30:	7812      	ldrb	r2, [r2, #0]
 801cb32:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[((int) (tmp1 - tmp6)) & RANGE_MASK];
 801cb34:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801cb38:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801cb3c:	ee77 7a67 	vsub.f32	s15, s14, s15
 801cb40:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cb44:	ee17 3a90 	vmov	r3, s15
 801cb48:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cb4c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cb50:	441a      	add	r2, r3
 801cb52:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cb56:	3306      	adds	r3, #6
 801cb58:	7812      	ldrb	r2, [r2, #0]
 801cb5a:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[((int) (tmp2 + tmp5)) & RANGE_MASK];
 801cb5c:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801cb60:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801cb64:	ee77 7a27 	vadd.f32	s15, s14, s15
 801cb68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cb6c:	ee17 3a90 	vmov	r3, s15
 801cb70:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cb74:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cb78:	441a      	add	r2, r3
 801cb7a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cb7e:	3302      	adds	r3, #2
 801cb80:	7812      	ldrb	r2, [r2, #0]
 801cb82:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[((int) (tmp2 - tmp5)) & RANGE_MASK];
 801cb84:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801cb88:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801cb8c:	ee77 7a67 	vsub.f32	s15, s14, s15
 801cb90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cb94:	ee17 3a90 	vmov	r3, s15
 801cb98:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cb9c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cba0:	441a      	add	r2, r3
 801cba2:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cba6:	3305      	adds	r3, #5
 801cba8:	7812      	ldrb	r2, [r2, #0]
 801cbaa:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[((int) (tmp3 + tmp4)) & RANGE_MASK];
 801cbac:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801cbb0:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801cbb4:	ee77 7a27 	vadd.f32	s15, s14, s15
 801cbb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cbbc:	ee17 3a90 	vmov	r3, s15
 801cbc0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cbc4:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cbc8:	441a      	add	r2, r3
 801cbca:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cbce:	3303      	adds	r3, #3
 801cbd0:	7812      	ldrb	r2, [r2, #0]
 801cbd2:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[((int) (tmp3 - tmp4)) & RANGE_MASK];
 801cbd4:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801cbd8:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801cbdc:	ee77 7a67 	vsub.f32	s15, s14, s15
 801cbe0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cbe4:	ee17 3a90 	vmov	r3, s15
 801cbe8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cbec:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801cbf0:	441a      	add	r2, r3
 801cbf2:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801cbf6:	3304      	adds	r3, #4
 801cbf8:	7812      	ldrb	r2, [r2, #0]
 801cbfa:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 801cbfc:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801cc00:	3320      	adds	r3, #32
 801cc02:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801cc06:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801cc0a:	3301      	adds	r3, #1
 801cc0c:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801cc10:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801cc14:	2b07      	cmp	r3, #7
 801cc16:	f77f ae57 	ble.w	801c8c8 <jpeg_idct_float+0x500>
  }
}
 801cc1a:	bf00      	nop
 801cc1c:	bf00      	nop
 801cc1e:	f507 77b8 	add.w	r7, r7, #368	@ 0x170
 801cc22:	46bd      	mov	sp, r7
 801cc24:	bc90      	pop	{r4, r7}
 801cc26:	4770      	bx	lr

0801cc28 <jpeg_idct_ifast>:

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801cc28:	b490      	push	{r4, r7}
 801cc2a:	b0de      	sub	sp, #376	@ 0x178
 801cc2c:	af00      	add	r7, sp, #0
 801cc2e:	f507 74bc 	add.w	r4, r7, #376	@ 0x178
 801cc32:	f5a4 74b6 	sub.w	r4, r4, #364	@ 0x16c
 801cc36:	6020      	str	r0, [r4, #0]
 801cc38:	f507 70bc 	add.w	r0, r7, #376	@ 0x178
 801cc3c:	f5a0 70b8 	sub.w	r0, r0, #368	@ 0x170
 801cc40:	6001      	str	r1, [r0, #0]
 801cc42:	f507 71bc 	add.w	r1, r7, #376	@ 0x178
 801cc46:	f5a1 71ba 	sub.w	r1, r1, #372	@ 0x174
 801cc4a:	600a      	str	r2, [r1, #0]
 801cc4c:	f507 72bc 	add.w	r2, r7, #376	@ 0x178
 801cc50:	f5a2 72bc 	sub.w	r2, r2, #376	@ 0x178
 801cc54:	6013      	str	r3, [r2, #0]
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  IFAST_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801cc56:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801cc5a:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 801cc5e:	681b      	ldr	r3, [r3, #0]
 801cc60:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801cc64:	3380      	adds	r3, #128	@ 0x80
 801cc66:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  SHIFT_TEMPS			/* for DESCALE */
  ISHIFT_TEMPS			/* for IDESCALE */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801cc6a:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801cc6e:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 801cc72:	681b      	ldr	r3, [r3, #0]
 801cc74:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
 801cc78:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801cc7c:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
 801cc80:	681b      	ldr	r3, [r3, #0]
 801cc82:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801cc84:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
  wsptr = workspace;
 801cc88:	f107 0314 	add.w	r3, r7, #20
 801cc8c:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801cc90:	2308      	movs	r3, #8
 801cc92:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801cc96:	e1ec      	b.n	801d072 <jpeg_idct_ifast+0x44a>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801cc98:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cc9c:	3310      	adds	r3, #16
 801cc9e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cca2:	2b00      	cmp	r3, #0
 801cca4:	d174      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
 801cca6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccaa:	3320      	adds	r3, #32
 801ccac:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ccb0:	2b00      	cmp	r3, #0
 801ccb2:	d16d      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801ccb4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccb8:	3330      	adds	r3, #48	@ 0x30
 801ccba:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801ccbe:	2b00      	cmp	r3, #0
 801ccc0:	d166      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801ccc2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccc6:	3340      	adds	r3, #64	@ 0x40
 801ccc8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cccc:	2b00      	cmp	r3, #0
 801ccce:	d15f      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801ccd0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccd4:	3350      	adds	r3, #80	@ 0x50
 801ccd6:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801ccda:	2b00      	cmp	r3, #0
 801ccdc:	d158      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801ccde:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cce2:	3360      	adds	r3, #96	@ 0x60
 801cce4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cce8:	2b00      	cmp	r3, #0
 801ccea:	d151      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*7] == 0) {
 801ccec:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccf0:	3370      	adds	r3, #112	@ 0x70
 801ccf2:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801ccf6:	2b00      	cmp	r3, #0
 801ccf8:	d14a      	bne.n	801cd90 <jpeg_idct_ifast+0x168>
      /* AC terms all zero */
      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801ccfa:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ccfe:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cd02:	461a      	mov	r2, r3
 801cd04:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cd08:	681b      	ldr	r3, [r3, #0]
 801cd0a:	fb02 f303 	mul.w	r3, r2, r3
 801cd0e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

      wsptr[DCTSIZE*0] = dcval;
 801cd12:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd16:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd1a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801cd1c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd20:	3320      	adds	r3, #32
 801cd22:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd26:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801cd28:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd2c:	3340      	adds	r3, #64	@ 0x40
 801cd2e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd32:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801cd34:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd38:	3360      	adds	r3, #96	@ 0x60
 801cd3a:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd3e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801cd40:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd44:	3380      	adds	r3, #128	@ 0x80
 801cd46:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd4a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801cd4c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd50:	33a0      	adds	r3, #160	@ 0xa0
 801cd52:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd56:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801cd58:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd5c:	33c0      	adds	r3, #192	@ 0xc0
 801cd5e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd62:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801cd64:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd68:	33e0      	adds	r3, #224	@ 0xe0
 801cd6a:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801cd6e:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 801cd70:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cd74:	3302      	adds	r3, #2
 801cd76:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
      quantptr++;
 801cd7a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cd7e:	3304      	adds	r3, #4
 801cd80:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
      wsptr++;
 801cd84:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cd88:	3304      	adds	r3, #4
 801cd8a:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      continue;
 801cd8e:	e16b      	b.n	801d068 <jpeg_idct_ifast+0x440>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801cd90:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cd94:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cd98:	461a      	mov	r2, r3
 801cd9a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cd9e:	681b      	ldr	r3, [r3, #0]
 801cda0:	fb02 f303 	mul.w	r3, r2, r3
 801cda4:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801cda8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cdac:	3320      	adds	r3, #32
 801cdae:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cdb2:	461a      	mov	r2, r3
 801cdb4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cdb8:	3340      	adds	r3, #64	@ 0x40
 801cdba:	681b      	ldr	r3, [r3, #0]
 801cdbc:	fb02 f303 	mul.w	r3, r2, r3
 801cdc0:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801cdc4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cdc8:	3340      	adds	r3, #64	@ 0x40
 801cdca:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cdce:	461a      	mov	r2, r3
 801cdd0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cdd4:	3380      	adds	r3, #128	@ 0x80
 801cdd6:	681b      	ldr	r3, [r3, #0]
 801cdd8:	fb02 f303 	mul.w	r3, r2, r3
 801cddc:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801cde0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801cde4:	3360      	adds	r3, #96	@ 0x60
 801cde6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cdea:	461a      	mov	r2, r3
 801cdec:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cdf0:	33c0      	adds	r3, #192	@ 0xc0
 801cdf2:	681b      	ldr	r3, [r3, #0]
 801cdf4:	fb02 f303 	mul.w	r3, r2, r3
 801cdf8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801cdfc:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801ce00:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801ce04:	4413      	add	r3, r2
 801ce06:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp11 = tmp0 - tmp2;
 801ce0a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801ce0e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801ce12:	1ad3      	subs	r3, r2, r3
 801ce14:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801ce18:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801ce1c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801ce20:	4413      	add	r3, r2
 801ce22:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
 801ce26:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801ce2a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801ce2e:	1ad3      	subs	r3, r2, r3
 801ce30:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801ce34:	fb02 f303 	mul.w	r3, r2, r3
 801ce38:	121a      	asrs	r2, r3, #8
 801ce3a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801ce3e:	1ad3      	subs	r3, r2, r3
 801ce40:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 801ce44:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801ce48:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801ce4c:	4413      	add	r3, r2
 801ce4e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp3 = tmp10 - tmp13;
 801ce52:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801ce56:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801ce5a:	1ad3      	subs	r3, r2, r3
 801ce5c:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp1 = tmp11 + tmp12;
 801ce60:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801ce64:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801ce68:	4413      	add	r3, r2
 801ce6a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = tmp11 - tmp12;
 801ce6e:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801ce72:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801ce76:	1ad3      	subs	r3, r2, r3
 801ce78:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ce7c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ce80:	3310      	adds	r3, #16
 801ce82:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ce86:	461a      	mov	r2, r3
 801ce88:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801ce8c:	3320      	adds	r3, #32
 801ce8e:	681b      	ldr	r3, [r3, #0]
 801ce90:	fb02 f303 	mul.w	r3, r2, r3
 801ce94:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801ce98:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ce9c:	3330      	adds	r3, #48	@ 0x30
 801ce9e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cea2:	461a      	mov	r2, r3
 801cea4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cea8:	3360      	adds	r3, #96	@ 0x60
 801ceaa:	681b      	ldr	r3, [r3, #0]
 801ceac:	fb02 f303 	mul.w	r3, r2, r3
 801ceb0:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801ceb4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ceb8:	3350      	adds	r3, #80	@ 0x50
 801ceba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801cebe:	461a      	mov	r2, r3
 801cec0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cec4:	33a0      	adds	r3, #160	@ 0xa0
 801cec6:	681b      	ldr	r3, [r3, #0]
 801cec8:	fb02 f303 	mul.w	r3, r2, r3
 801cecc:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801ced0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801ced4:	3370      	adds	r3, #112	@ 0x70
 801ced6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ceda:	461a      	mov	r2, r3
 801cedc:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801cee0:	33e0      	adds	r3, #224	@ 0xe0
 801cee2:	681b      	ldr	r3, [r3, #0]
 801cee4:	fb02 f303 	mul.w	r3, r2, r3
 801cee8:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    z13 = tmp6 + tmp5;		/* phase 6 */
 801ceec:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801cef0:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801cef4:	4413      	add	r3, r2
 801cef6:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z10 = tmp6 - tmp5;
 801cefa:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801cefe:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801cf02:	1ad3      	subs	r3, r2, r3
 801cf04:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z11 = tmp4 + tmp7;
 801cf08:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801cf0c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801cf10:	4413      	add	r3, r2
 801cf12:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z12 = tmp4 - tmp7;
 801cf16:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801cf1a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801cf1e:	1ad3      	subs	r3, r2, r3
 801cf20:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 801cf24:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801cf28:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801cf2c:	4413      	add	r3, r2
 801cf2e:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 801cf32:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801cf36:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801cf3a:	1ad3      	subs	r3, r2, r3
 801cf3c:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801cf40:	fb02 f303 	mul.w	r3, r2, r3
 801cf44:	121b      	asrs	r3, r3, #8
 801cf46:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 801cf4a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801cf4e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801cf52:	4413      	add	r3, r2
 801cf54:	f240 12d9 	movw	r2, #473	@ 0x1d9
 801cf58:	fb02 f303 	mul.w	r3, r2, r3
 801cf5c:	121b      	asrs	r3, r3, #8
 801cf5e:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 801cf62:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801cf66:	f240 1215 	movw	r2, #277	@ 0x115
 801cf6a:	fb02 f303 	mul.w	r3, r2, r3
 801cf6e:	121a      	asrs	r2, r3, #8
 801cf70:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801cf74:	1ad3      	subs	r3, r2, r3
 801cf76:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 801cf7a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801cf7e:	f46f 7227 	mvn.w	r2, #668	@ 0x29c
 801cf82:	fb02 f303 	mul.w	r3, r2, r3
 801cf86:	121b      	asrs	r3, r3, #8
 801cf88:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801cf8c:	4413      	add	r3, r2
 801cf8e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801cf92:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801cf96:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801cf9a:	1ad3      	subs	r3, r2, r3
 801cf9c:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp5 = tmp11 - tmp6;
 801cfa0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801cfa4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801cfa8:	1ad3      	subs	r3, r2, r3
 801cfaa:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp4 = tmp10 + tmp5;
 801cfae:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801cfb2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801cfb6:	4413      	add	r3, r2
 801cfb8:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
 801cfbc:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801cfc0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801cfc4:	441a      	add	r2, r3
 801cfc6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cfca:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
 801cfcc:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cfd0:	33e0      	adds	r3, #224	@ 0xe0
 801cfd2:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 801cfd6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801cfda:	1a8a      	subs	r2, r1, r2
 801cfdc:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
 801cfde:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cfe2:	3320      	adds	r3, #32
 801cfe4:	f8d7 1140 	ldr.w	r1, [r7, #320]	@ 0x140
 801cfe8:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801cfec:	440a      	add	r2, r1
 801cfee:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
 801cff0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801cff4:	33c0      	adds	r3, #192	@ 0xc0
 801cff6:	f8d7 1140 	ldr.w	r1, [r7, #320]	@ 0x140
 801cffa:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801cffe:	1a8a      	subs	r2, r1, r2
 801d000:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
 801d002:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d006:	3340      	adds	r3, #64	@ 0x40
 801d008:	f8d7 113c 	ldr.w	r1, [r7, #316]	@ 0x13c
 801d00c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801d010:	440a      	add	r2, r1
 801d012:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
 801d014:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d018:	33a0      	adds	r3, #160	@ 0xa0
 801d01a:	f8d7 113c 	ldr.w	r1, [r7, #316]	@ 0x13c
 801d01e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801d022:	1a8a      	subs	r2, r1, r2
 801d024:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
 801d026:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d02a:	3380      	adds	r3, #128	@ 0x80
 801d02c:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 801d030:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801d034:	440a      	add	r2, r1
 801d036:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
 801d038:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d03c:	3360      	adds	r3, #96	@ 0x60
 801d03e:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 801d042:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801d046:	1a8a      	subs	r2, r1, r2
 801d048:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 801d04a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801d04e:	3302      	adds	r3, #2
 801d050:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    quantptr++;
 801d054:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801d058:	3304      	adds	r3, #4
 801d05a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    wsptr++;
 801d05e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d062:	3304      	adds	r3, #4
 801d064:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801d068:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d06c:	3b01      	subs	r3, #1
 801d06e:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801d072:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d076:	2b00      	cmp	r3, #0
 801d078:	f73f ae0e 	bgt.w	801cc98 <jpeg_idct_ifast+0x70>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 801d07c:	f107 0314 	add.w	r3, r7, #20
 801d080:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801d084:	2300      	movs	r3, #0
 801d086:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801d08a:	e1c8      	b.n	801d41e <jpeg_idct_ifast+0x7f6>
    outptr = output_buf[ctr] + output_col;
 801d08c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d090:	009b      	lsls	r3, r3, #2
 801d092:	f507 72bc 	add.w	r2, r7, #376	@ 0x178
 801d096:	f5a2 72bc 	sub.w	r2, r2, #376	@ 0x178
 801d09a:	6812      	ldr	r2, [r2, #0]
 801d09c:	4413      	add	r3, r2
 801d09e:	681a      	ldr	r2, [r3, #0]
 801d0a0:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801d0a4:	4413      	add	r3, r2
 801d0a6:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801d0aa:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0ae:	3304      	adds	r3, #4
 801d0b0:	681b      	ldr	r3, [r3, #0]
 801d0b2:	2b00      	cmp	r3, #0
 801d0b4:	d164      	bne.n	801d180 <jpeg_idct_ifast+0x558>
 801d0b6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0ba:	3308      	adds	r3, #8
 801d0bc:	681b      	ldr	r3, [r3, #0]
 801d0be:	2b00      	cmp	r3, #0
 801d0c0:	d15e      	bne.n	801d180 <jpeg_idct_ifast+0x558>
 801d0c2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0c6:	330c      	adds	r3, #12
 801d0c8:	681b      	ldr	r3, [r3, #0]
 801d0ca:	2b00      	cmp	r3, #0
 801d0cc:	d158      	bne.n	801d180 <jpeg_idct_ifast+0x558>
 801d0ce:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0d2:	3310      	adds	r3, #16
 801d0d4:	681b      	ldr	r3, [r3, #0]
 801d0d6:	2b00      	cmp	r3, #0
 801d0d8:	d152      	bne.n	801d180 <jpeg_idct_ifast+0x558>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801d0da:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0de:	3314      	adds	r3, #20
 801d0e0:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801d0e2:	2b00      	cmp	r3, #0
 801d0e4:	d14c      	bne.n	801d180 <jpeg_idct_ifast+0x558>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801d0e6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0ea:	3318      	adds	r3, #24
 801d0ec:	681b      	ldr	r3, [r3, #0]
 801d0ee:	2b00      	cmp	r3, #0
 801d0f0:	d146      	bne.n	801d180 <jpeg_idct_ifast+0x558>
 801d0f2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d0f6:	331c      	adds	r3, #28
 801d0f8:	681b      	ldr	r3, [r3, #0]
 801d0fa:	2b00      	cmp	r3, #0
 801d0fc:	d140      	bne.n	801d180 <jpeg_idct_ifast+0x558>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 801d0fe:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d102:	681b      	ldr	r3, [r3, #0]
 801d104:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 801d106:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 801d10a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d10e:	4413      	add	r3, r2
 801d110:	781b      	ldrb	r3, [r3, #0]
 801d112:	f887 315f 	strb.w	r3, [r7, #351]	@ 0x15f
      
      outptr[0] = dcval;
 801d116:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d11a:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d11e:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 801d120:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d124:	3301      	adds	r3, #1
 801d126:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d12a:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 801d12c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d130:	3302      	adds	r3, #2
 801d132:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d136:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 801d138:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d13c:	3303      	adds	r3, #3
 801d13e:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d142:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 801d144:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d148:	3304      	adds	r3, #4
 801d14a:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d14e:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 801d150:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d154:	3305      	adds	r3, #5
 801d156:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d15a:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 801d15c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d160:	3306      	adds	r3, #6
 801d162:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d166:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 801d168:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d16c:	3307      	adds	r3, #7
 801d16e:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801d172:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 801d174:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d178:	3320      	adds	r3, #32
 801d17a:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      continue;
 801d17e:	e149      	b.n	801d414 <jpeg_idct_ifast+0x7ec>
    }
#endif
    
    /* Even part */

    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
 801d180:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d184:	681a      	ldr	r2, [r3, #0]
 801d186:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d18a:	3310      	adds	r3, #16
 801d18c:	681b      	ldr	r3, [r3, #0]
 801d18e:	4413      	add	r3, r2
 801d190:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
 801d194:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d198:	681a      	ldr	r2, [r3, #0]
 801d19a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d19e:	3310      	adds	r3, #16
 801d1a0:	681b      	ldr	r3, [r3, #0]
 801d1a2:	1ad3      	subs	r3, r2, r3
 801d1a4:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
 801d1a8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d1ac:	3308      	adds	r3, #8
 801d1ae:	681a      	ldr	r2, [r3, #0]
 801d1b0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d1b4:	3318      	adds	r3, #24
 801d1b6:	681b      	ldr	r3, [r3, #0]
 801d1b8:	4413      	add	r3, r2
 801d1ba:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
 801d1be:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d1c2:	3308      	adds	r3, #8
 801d1c4:	681a      	ldr	r2, [r3, #0]
 801d1c6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d1ca:	3318      	adds	r3, #24
 801d1cc:	681b      	ldr	r3, [r3, #0]
 801d1ce:	1ad3      	subs	r3, r2, r3
 801d1d0:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801d1d4:	fb02 f303 	mul.w	r3, r2, r3
 801d1d8:	121a      	asrs	r2, r3, #8
 801d1da:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d1de:	1ad3      	subs	r3, r2, r3
 801d1e0:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    - tmp13;

    tmp0 = tmp10 + tmp13;
 801d1e4:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801d1e8:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d1ec:	4413      	add	r3, r2
 801d1ee:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp3 = tmp10 - tmp13;
 801d1f2:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801d1f6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d1fa:	1ad3      	subs	r3, r2, r3
 801d1fc:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp1 = tmp11 + tmp12;
 801d200:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801d204:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801d208:	4413      	add	r3, r2
 801d20a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = tmp11 - tmp12;
 801d20e:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801d212:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801d216:	1ad3      	subs	r3, r2, r3
 801d218:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    /* Odd part */

    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
 801d21c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d220:	3314      	adds	r3, #20
 801d222:	681a      	ldr	r2, [r3, #0]
 801d224:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d228:	330c      	adds	r3, #12
 801d22a:	681b      	ldr	r3, [r3, #0]
 801d22c:	4413      	add	r3, r2
 801d22e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
 801d232:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d236:	3314      	adds	r3, #20
 801d238:	681a      	ldr	r2, [r3, #0]
 801d23a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d23e:	330c      	adds	r3, #12
 801d240:	681b      	ldr	r3, [r3, #0]
 801d242:	1ad3      	subs	r3, r2, r3
 801d244:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
 801d248:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d24c:	3304      	adds	r3, #4
 801d24e:	681a      	ldr	r2, [r3, #0]
 801d250:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d254:	331c      	adds	r3, #28
 801d256:	681b      	ldr	r3, [r3, #0]
 801d258:	4413      	add	r3, r2
 801d25a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
 801d25e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d262:	3304      	adds	r3, #4
 801d264:	681a      	ldr	r2, [r3, #0]
 801d266:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d26a:	331c      	adds	r3, #28
 801d26c:	681b      	ldr	r3, [r3, #0]
 801d26e:	1ad3      	subs	r3, r2, r3
 801d270:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 801d274:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801d278:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801d27c:	4413      	add	r3, r2
 801d27e:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 801d282:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801d286:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801d28a:	1ad3      	subs	r3, r2, r3
 801d28c:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801d290:	fb02 f303 	mul.w	r3, r2, r3
 801d294:	121b      	asrs	r3, r3, #8
 801d296:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 801d29a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801d29e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801d2a2:	4413      	add	r3, r2
 801d2a4:	f240 12d9 	movw	r2, #473	@ 0x1d9
 801d2a8:	fb02 f303 	mul.w	r3, r2, r3
 801d2ac:	121b      	asrs	r3, r3, #8
 801d2ae:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 801d2b2:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801d2b6:	f240 1215 	movw	r2, #277	@ 0x115
 801d2ba:	fb02 f303 	mul.w	r3, r2, r3
 801d2be:	121a      	asrs	r2, r3, #8
 801d2c0:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801d2c4:	1ad3      	subs	r3, r2, r3
 801d2c6:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 801d2ca:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d2ce:	f46f 7227 	mvn.w	r2, #668	@ 0x29c
 801d2d2:	fb02 f303 	mul.w	r3, r2, r3
 801d2d6:	121b      	asrs	r3, r3, #8
 801d2d8:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801d2dc:	4413      	add	r3, r2
 801d2de:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801d2e2:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801d2e6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d2ea:	1ad3      	subs	r3, r2, r3
 801d2ec:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp5 = tmp11 - tmp6;
 801d2f0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801d2f4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801d2f8:	1ad3      	subs	r3, r2, r3
 801d2fa:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp4 = tmp10 + tmp5;
 801d2fe:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801d302:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801d306:	4413      	add	r3, r2
 801d308:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 801d30c:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801d310:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d314:	4413      	add	r3, r2
 801d316:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d318:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 801d31c:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d320:	4413      	add	r3, r2
 801d322:	781a      	ldrb	r2, [r3, #0]
 801d324:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d328:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 801d32a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801d32e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d332:	1ad3      	subs	r3, r2, r3
 801d334:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d336:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 801d33a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d33e:	441a      	add	r2, r3
 801d340:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d344:	3307      	adds	r3, #7
 801d346:	7812      	ldrb	r2, [r2, #0]
 801d348:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 801d34a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d34e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801d352:	4413      	add	r3, r2
 801d354:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d356:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 801d35a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d35e:	441a      	add	r2, r3
 801d360:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d364:	3301      	adds	r3, #1
 801d366:	7812      	ldrb	r2, [r2, #0]
 801d368:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 801d36a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d36e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801d372:	1ad3      	subs	r3, r2, r3
 801d374:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d376:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 801d37a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d37e:	441a      	add	r2, r3
 801d380:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d384:	3306      	adds	r3, #6
 801d386:	7812      	ldrb	r2, [r2, #0]
 801d388:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 801d38a:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801d38e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801d392:	4413      	add	r3, r2
 801d394:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d396:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 801d39a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d39e:	441a      	add	r2, r3
 801d3a0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d3a4:	3302      	adds	r3, #2
 801d3a6:	7812      	ldrb	r2, [r2, #0]
 801d3a8:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 801d3aa:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801d3ae:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801d3b2:	1ad3      	subs	r3, r2, r3
 801d3b4:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d3b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 801d3ba:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d3be:	441a      	add	r2, r3
 801d3c0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d3c4:	3305      	adds	r3, #5
 801d3c6:	7812      	ldrb	r2, [r2, #0]
 801d3c8:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 801d3ca:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801d3ce:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801d3d2:	4413      	add	r3, r2
 801d3d4:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d3d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 801d3da:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d3de:	441a      	add	r2, r3
 801d3e0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d3e4:	3304      	adds	r3, #4
 801d3e6:	7812      	ldrb	r2, [r2, #0]
 801d3e8:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 801d3ea:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801d3ee:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801d3f2:	1ad3      	subs	r3, r2, r3
 801d3f4:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801d3f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 801d3fa:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801d3fe:	441a      	add	r2, r3
 801d400:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801d404:	3303      	adds	r3, #3
 801d406:	7812      	ldrb	r2, [r2, #0]
 801d408:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 801d40a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801d40e:	3320      	adds	r3, #32
 801d410:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801d414:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d418:	3301      	adds	r3, #1
 801d41a:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801d41e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d422:	2b07      	cmp	r3, #7
 801d424:	f77f ae32 	ble.w	801d08c <jpeg_idct_ifast+0x464>
  }
}
 801d428:	bf00      	nop
 801d42a:	bf00      	nop
 801d42c:	f507 77bc 	add.w	r7, r7, #376	@ 0x178
 801d430:	46bd      	mov	sp, r7
 801d432:	bc90      	pop	{r4, r7}
 801d434:	4770      	bx	lr
	...

0801d438 <jpeg_idct_islow>:

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801d438:	b490      	push	{r4, r7}
 801d43a:	b0d8      	sub	sp, #352	@ 0x160
 801d43c:	af00      	add	r7, sp, #0
 801d43e:	f507 74b0 	add.w	r4, r7, #352	@ 0x160
 801d442:	f5a4 74aa 	sub.w	r4, r4, #340	@ 0x154
 801d446:	6020      	str	r0, [r4, #0]
 801d448:	f507 70b0 	add.w	r0, r7, #352	@ 0x160
 801d44c:	f5a0 70ac 	sub.w	r0, r0, #344	@ 0x158
 801d450:	6001      	str	r1, [r0, #0]
 801d452:	f507 71b0 	add.w	r1, r7, #352	@ 0x160
 801d456:	f5a1 71ae 	sub.w	r1, r1, #348	@ 0x15c
 801d45a:	600a      	str	r2, [r1, #0]
 801d45c:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
 801d460:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 801d464:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801d466:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801d46a:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801d46e:	681b      	ldr	r3, [r3, #0]
 801d470:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801d474:	3380      	adds	r3, #128	@ 0x80
 801d476:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 801d47a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801d47e:	f5a3 73ae 	sub.w	r3, r3, #348	@ 0x15c
 801d482:	681b      	ldr	r3, [r3, #0]
 801d484:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801d488:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801d48c:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801d490:	681b      	ldr	r3, [r3, #0]
 801d492:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d494:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
  wsptr = workspace;
 801d498:	f107 0314 	add.w	r3, r7, #20
 801d49c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801d4a0:	2308      	movs	r3, #8
 801d4a2:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801d4a6:	e238      	b.n	801d91a <jpeg_idct_islow+0x4e2>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801d4a8:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4ac:	3310      	adds	r3, #16
 801d4ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d4b2:	2b00      	cmp	r3, #0
 801d4b4:	d175      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
 801d4b6:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4ba:	3320      	adds	r3, #32
 801d4bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d4c0:	2b00      	cmp	r3, #0
 801d4c2:	d16e      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801d4c4:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4c8:	3330      	adds	r3, #48	@ 0x30
 801d4ca:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801d4ce:	2b00      	cmp	r3, #0
 801d4d0:	d167      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801d4d2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4d6:	3340      	adds	r3, #64	@ 0x40
 801d4d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d4dc:	2b00      	cmp	r3, #0
 801d4de:	d160      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801d4e0:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4e4:	3350      	adds	r3, #80	@ 0x50
 801d4e6:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801d4ea:	2b00      	cmp	r3, #0
 801d4ec:	d159      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801d4ee:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d4f2:	3360      	adds	r3, #96	@ 0x60
 801d4f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d4f8:	2b00      	cmp	r3, #0
 801d4fa:	d152      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*7] == 0) {
 801d4fc:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d500:	3370      	adds	r3, #112	@ 0x70
 801d502:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801d506:	2b00      	cmp	r3, #0
 801d508:	d14b      	bne.n	801d5a2 <jpeg_idct_islow+0x16a>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 801d50a:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d50e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d512:	461a      	mov	r2, r3
 801d514:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d518:	681b      	ldr	r3, [r3, #0]
 801d51a:	fb02 f303 	mul.w	r3, r2, r3
 801d51e:	009b      	lsls	r3, r3, #2
 801d520:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

      wsptr[DCTSIZE*0] = dcval;
 801d524:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d528:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d52c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801d52e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d532:	3320      	adds	r3, #32
 801d534:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d538:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801d53a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d53e:	3340      	adds	r3, #64	@ 0x40
 801d540:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d544:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801d546:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d54a:	3360      	adds	r3, #96	@ 0x60
 801d54c:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d550:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801d552:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d556:	3380      	adds	r3, #128	@ 0x80
 801d558:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d55c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801d55e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d562:	33a0      	adds	r3, #160	@ 0xa0
 801d564:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d568:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801d56a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d56e:	33c0      	adds	r3, #192	@ 0xc0
 801d570:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d574:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801d576:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d57a:	33e0      	adds	r3, #224	@ 0xe0
 801d57c:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801d580:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 801d582:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d586:	3302      	adds	r3, #2
 801d588:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
      quantptr++;
 801d58c:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d590:	3304      	adds	r3, #4
 801d592:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
      wsptr++;
 801d596:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d59a:	3304      	adds	r3, #4
 801d59c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
      continue;
 801d5a0:	e1b6      	b.n	801d910 <jpeg_idct_islow+0x4d8>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801d5a2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d5a6:	3320      	adds	r3, #32
 801d5a8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d5ac:	461a      	mov	r2, r3
 801d5ae:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d5b2:	3340      	adds	r3, #64	@ 0x40
 801d5b4:	681b      	ldr	r3, [r3, #0]
 801d5b6:	fb02 f303 	mul.w	r3, r2, r3
 801d5ba:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801d5be:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d5c2:	3360      	adds	r3, #96	@ 0x60
 801d5c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d5c8:	461a      	mov	r2, r3
 801d5ca:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d5ce:	33c0      	adds	r3, #192	@ 0xc0
 801d5d0:	681b      	ldr	r3, [r3, #0]
 801d5d2:	fb02 f303 	mul.w	r3, r2, r3
 801d5d6:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 801d5da:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d5de:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d5e2:	4413      	add	r3, r2
 801d5e4:	f241 1251 	movw	r2, #4433	@ 0x1151
 801d5e8:	fb02 f303 	mul.w	r3, r2, r3
 801d5ec:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801d5f0:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d5f4:	f641 027e 	movw	r2, #6270	@ 0x187e
 801d5f8:	fb02 f303 	mul.w	r3, r2, r3
 801d5fc:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d600:	4413      	add	r3, r2
 801d602:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 801d606:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d60a:	4aca      	ldr	r2, [pc, #808]	@ (801d934 <jpeg_idct_islow+0x4fc>)
 801d60c:	fb02 f303 	mul.w	r3, r2, r3
 801d610:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d614:	4413      	add	r3, r2
 801d616:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801d61a:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d61e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d622:	461a      	mov	r2, r3
 801d624:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d628:	681b      	ldr	r3, [r3, #0]
 801d62a:	fb02 f303 	mul.w	r3, r2, r3
 801d62e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801d632:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d636:	3340      	adds	r3, #64	@ 0x40
 801d638:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d63c:	461a      	mov	r2, r3
 801d63e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d642:	3380      	adds	r3, #128	@ 0x80
 801d644:	681b      	ldr	r3, [r3, #0]
 801d646:	fb02 f303 	mul.w	r3, r2, r3
 801d64a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 <<= CONST_BITS;
 801d64e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d652:	035b      	lsls	r3, r3, #13
 801d654:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 <<= CONST_BITS;
 801d658:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d65c:	035b      	lsls	r3, r3, #13
 801d65e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 801d662:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d666:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801d66a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp0 = z2 + z3;
 801d66e:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d672:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d676:	4413      	add	r3, r2
 801d678:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = z2 - z3;
 801d67c:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d680:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d684:	1ad3      	subs	r3, r2, r3
 801d686:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp10 = tmp0 + tmp2;
 801d68a:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801d68e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d692:	4413      	add	r3, r2
 801d694:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp13 = tmp0 - tmp2;
 801d698:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801d69c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d6a0:	1ad3      	subs	r3, r2, r3
 801d6a2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp11 = tmp1 + tmp3;
 801d6a6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801d6aa:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d6ae:	4413      	add	r3, r2
 801d6b0:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp12 = tmp1 - tmp3;
 801d6b4:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801d6b8:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d6bc:	1ad3      	subs	r3, r2, r3
 801d6be:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801d6c2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d6c6:	3370      	adds	r3, #112	@ 0x70
 801d6c8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d6cc:	461a      	mov	r2, r3
 801d6ce:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d6d2:	33e0      	adds	r3, #224	@ 0xe0
 801d6d4:	681b      	ldr	r3, [r3, #0]
 801d6d6:	fb02 f303 	mul.w	r3, r2, r3
 801d6da:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801d6de:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d6e2:	3350      	adds	r3, #80	@ 0x50
 801d6e4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d6e8:	461a      	mov	r2, r3
 801d6ea:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d6ee:	33a0      	adds	r3, #160	@ 0xa0
 801d6f0:	681b      	ldr	r3, [r3, #0]
 801d6f2:	fb02 f303 	mul.w	r3, r2, r3
 801d6f6:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801d6fa:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d6fe:	3330      	adds	r3, #48	@ 0x30
 801d700:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d704:	461a      	mov	r2, r3
 801d706:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d70a:	3360      	adds	r3, #96	@ 0x60
 801d70c:	681b      	ldr	r3, [r3, #0]
 801d70e:	fb02 f303 	mul.w	r3, r2, r3
 801d712:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801d716:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d71a:	3310      	adds	r3, #16
 801d71c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d720:	461a      	mov	r2, r3
 801d722:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d726:	3320      	adds	r3, #32
 801d728:	681b      	ldr	r3, [r3, #0]
 801d72a:	fb02 f303 	mul.w	r3, r2, r3
 801d72e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    
    z2 = tmp0 + tmp2;
 801d732:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801d736:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d73a:	4413      	add	r3, r2
 801d73c:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = tmp1 + tmp3;
 801d740:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801d744:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d748:	4413      	add	r3, r2
 801d74a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 801d74e:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d752:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d756:	4413      	add	r3, r2
 801d758:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 801d75c:	fb02 f303 	mul.w	r3, r2, r3
 801d760:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801d764:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d768:	4a73      	ldr	r2, [pc, #460]	@ (801d938 <jpeg_idct_islow+0x500>)
 801d76a:	fb02 f303 	mul.w	r3, r2, r3
 801d76e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801d772:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d776:	4a71      	ldr	r2, [pc, #452]	@ (801d93c <jpeg_idct_islow+0x504>)
 801d778:	fb02 f303 	mul.w	r3, r2, r3
 801d77c:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 += z1;
 801d780:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801d784:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801d788:	4413      	add	r3, r2
 801d78a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 += z1;
 801d78e:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801d792:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801d796:	4413      	add	r3, r2
 801d798:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 801d79c:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801d7a0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d7a4:	4413      	add	r3, r2
 801d7a6:	4a66      	ldr	r2, [pc, #408]	@ (801d940 <jpeg_idct_islow+0x508>)
 801d7a8:	fb02 f303 	mul.w	r3, r2, r3
 801d7ac:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 801d7b0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801d7b4:	f640 128e 	movw	r2, #2446	@ 0x98e
 801d7b8:	fb02 f303 	mul.w	r3, r2, r3
 801d7bc:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 801d7c0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d7c4:	f243 020b 	movw	r2, #12299	@ 0x300b
 801d7c8:	fb02 f303 	mul.w	r3, r2, r3
 801d7cc:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp0 += z1 + z2;
 801d7d0:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d7d4:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d7d8:	4413      	add	r3, r2
 801d7da:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801d7de:	4413      	add	r3, r2
 801d7e0:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 += z1 + z3;
 801d7e4:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d7e8:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d7ec:	4413      	add	r3, r2
 801d7ee:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801d7f2:	4413      	add	r3, r2
 801d7f4:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 801d7f8:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801d7fc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d800:	4413      	add	r3, r2
 801d802:	4a50      	ldr	r2, [pc, #320]	@ (801d944 <jpeg_idct_islow+0x50c>)
 801d804:	fb02 f303 	mul.w	r3, r2, r3
 801d808:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 801d80c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d810:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 801d814:	fb02 f303 	mul.w	r3, r2, r3
 801d818:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 801d81c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d820:	f246 2254 	movw	r2, #25172	@ 0x6254
 801d824:	fb02 f303 	mul.w	r3, r2, r3
 801d828:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp1 += z1 + z3;
 801d82c:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d830:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801d834:	4413      	add	r3, r2
 801d836:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801d83a:	4413      	add	r3, r2
 801d83c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 += z1 + z2;
 801d840:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801d844:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801d848:	4413      	add	r3, r2
 801d84a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801d84e:	4413      	add	r3, r2
 801d850:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 801d854:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801d858:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d85c:	4413      	add	r3, r2
 801d85e:	12da      	asrs	r2, r3, #11
 801d860:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d864:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 801d866:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801d86a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801d86e:	1ad2      	subs	r2, r2, r3
 801d870:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d874:	33e0      	adds	r3, #224	@ 0xe0
 801d876:	12d2      	asrs	r2, r2, #11
 801d878:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 801d87a:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801d87e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d882:	441a      	add	r2, r3
 801d884:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d888:	3320      	adds	r3, #32
 801d88a:	12d2      	asrs	r2, r2, #11
 801d88c:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 801d88e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801d892:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801d896:	1ad2      	subs	r2, r2, r3
 801d898:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d89c:	33c0      	adds	r3, #192	@ 0xc0
 801d89e:	12d2      	asrs	r2, r2, #11
 801d8a0:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 801d8a2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801d8a6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d8aa:	441a      	add	r2, r3
 801d8ac:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d8b0:	3340      	adds	r3, #64	@ 0x40
 801d8b2:	12d2      	asrs	r2, r2, #11
 801d8b4:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 801d8b6:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801d8ba:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801d8be:	1ad2      	subs	r2, r2, r3
 801d8c0:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d8c4:	33a0      	adds	r3, #160	@ 0xa0
 801d8c6:	12d2      	asrs	r2, r2, #11
 801d8c8:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 801d8ca:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801d8ce:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801d8d2:	441a      	add	r2, r3
 801d8d4:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d8d8:	3360      	adds	r3, #96	@ 0x60
 801d8da:	12d2      	asrs	r2, r2, #11
 801d8dc:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 801d8de:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801d8e2:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801d8e6:	1ad2      	subs	r2, r2, r3
 801d8e8:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d8ec:	3380      	adds	r3, #128	@ 0x80
 801d8ee:	12d2      	asrs	r2, r2, #11
 801d8f0:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 801d8f2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801d8f6:	3302      	adds	r3, #2
 801d8f8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    quantptr++;
 801d8fc:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801d900:	3304      	adds	r3, #4
 801d902:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    wsptr++;
 801d906:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d90a:	3304      	adds	r3, #4
 801d90c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801d910:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d914:	3b01      	subs	r3, #1
 801d916:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801d91a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d91e:	2b00      	cmp	r3, #0
 801d920:	f73f adc2 	bgt.w	801d4a8 <jpeg_idct_islow+0x70>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 801d924:	f107 0314 	add.w	r3, r7, #20
 801d928:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801d92c:	2300      	movs	r3, #0
 801d92e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801d932:	e21a      	b.n	801dd6a <jpeg_idct_islow+0x932>
 801d934:	ffffc4df 	.word	0xffffc4df
 801d938:	ffffc13b 	.word	0xffffc13b
 801d93c:	fffff384 	.word	0xfffff384
 801d940:	ffffe333 	.word	0xffffe333
 801d944:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 801d948:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801d94c:	009b      	lsls	r3, r3, #2
 801d94e:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
 801d952:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 801d956:	6812      	ldr	r2, [r2, #0]
 801d958:	4413      	add	r3, r2
 801d95a:	681a      	ldr	r2, [r3, #0]
 801d95c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801d960:	4413      	add	r3, r2
 801d962:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801d966:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d96a:	3304      	adds	r3, #4
 801d96c:	681b      	ldr	r3, [r3, #0]
 801d96e:	2b00      	cmp	r3, #0
 801d970:	d165      	bne.n	801da3e <jpeg_idct_islow+0x606>
 801d972:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d976:	3308      	adds	r3, #8
 801d978:	681b      	ldr	r3, [r3, #0]
 801d97a:	2b00      	cmp	r3, #0
 801d97c:	d15f      	bne.n	801da3e <jpeg_idct_islow+0x606>
 801d97e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d982:	330c      	adds	r3, #12
 801d984:	681b      	ldr	r3, [r3, #0]
 801d986:	2b00      	cmp	r3, #0
 801d988:	d159      	bne.n	801da3e <jpeg_idct_islow+0x606>
 801d98a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d98e:	3310      	adds	r3, #16
 801d990:	681b      	ldr	r3, [r3, #0]
 801d992:	2b00      	cmp	r3, #0
 801d994:	d153      	bne.n	801da3e <jpeg_idct_islow+0x606>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801d996:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d99a:	3314      	adds	r3, #20
 801d99c:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801d99e:	2b00      	cmp	r3, #0
 801d9a0:	d14d      	bne.n	801da3e <jpeg_idct_islow+0x606>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801d9a2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d9a6:	3318      	adds	r3, #24
 801d9a8:	681b      	ldr	r3, [r3, #0]
 801d9aa:	2b00      	cmp	r3, #0
 801d9ac:	d147      	bne.n	801da3e <jpeg_idct_islow+0x606>
 801d9ae:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d9b2:	331c      	adds	r3, #28
 801d9b4:	681b      	ldr	r3, [r3, #0]
 801d9b6:	2b00      	cmp	r3, #0
 801d9b8:	d141      	bne.n	801da3e <jpeg_idct_islow+0x606>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 801d9ba:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801d9be:	681b      	ldr	r3, [r3, #0]
 801d9c0:	3310      	adds	r3, #16
 801d9c2:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 801d9c4:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 801d9c8:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801d9cc:	4413      	add	r3, r2
 801d9ce:	781b      	ldrb	r3, [r3, #0]
 801d9d0:	f887 3147 	strb.w	r3, [r7, #327]	@ 0x147

      outptr[0] = dcval;
 801d9d4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801d9d8:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801d9dc:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 801d9de:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801d9e2:	3301      	adds	r3, #1
 801d9e4:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801d9e8:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 801d9ea:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801d9ee:	3302      	adds	r3, #2
 801d9f0:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801d9f4:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 801d9f6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801d9fa:	3303      	adds	r3, #3
 801d9fc:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801da00:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 801da02:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801da06:	3304      	adds	r3, #4
 801da08:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801da0c:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 801da0e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801da12:	3305      	adds	r3, #5
 801da14:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801da18:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 801da1a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801da1e:	3306      	adds	r3, #6
 801da20:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801da24:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 801da26:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801da2a:	3307      	adds	r3, #7
 801da2c:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801da30:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 801da32:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801da36:	3320      	adds	r3, #32
 801da38:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
      continue;
 801da3c:	e190      	b.n	801dd60 <jpeg_idct_islow+0x928>
#endif

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 801da3e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801da42:	3308      	adds	r3, #8
 801da44:	681b      	ldr	r3, [r3, #0]
 801da46:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = (INT32) wsptr[6];
 801da4a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801da4e:	3318      	adds	r3, #24
 801da50:	681b      	ldr	r3, [r3, #0]
 801da52:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 801da56:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801da5a:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801da5e:	4413      	add	r3, r2
 801da60:	f241 1251 	movw	r2, #4433	@ 0x1151
 801da64:	fb02 f303 	mul.w	r3, r2, r3
 801da68:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801da6c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801da70:	f641 027e 	movw	r2, #6270	@ 0x187e
 801da74:	fb02 f303 	mul.w	r3, r2, r3
 801da78:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801da7c:	4413      	add	r3, r2
 801da7e:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 801da82:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801da86:	4abf      	ldr	r2, [pc, #764]	@ (801dd84 <jpeg_idct_islow+0x94c>)
 801da88:	fb02 f303 	mul.w	r3, r2, r3
 801da8c:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801da90:	4413      	add	r3, r2
 801da92:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801da96:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801da9a:	681b      	ldr	r3, [r3, #0]
 801da9c:	3310      	adds	r3, #16
 801da9e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = (INT32) wsptr[4];
 801daa2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801daa6:	3310      	adds	r3, #16
 801daa8:	681b      	ldr	r3, [r3, #0]
 801daaa:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    tmp0 = (z2 + z3) << CONST_BITS;
 801daae:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801dab2:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801dab6:	4413      	add	r3, r2
 801dab8:	035b      	lsls	r3, r3, #13
 801daba:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = (z2 - z3) << CONST_BITS;
 801dabe:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801dac2:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801dac6:	1ad3      	subs	r3, r2, r3
 801dac8:	035b      	lsls	r3, r3, #13
 801daca:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    
    tmp10 = tmp0 + tmp2;
 801dace:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801dad2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dad6:	4413      	add	r3, r2
 801dad8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp13 = tmp0 - tmp2;
 801dadc:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801dae0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dae4:	1ad3      	subs	r3, r2, r3
 801dae6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp11 = tmp1 + tmp3;
 801daea:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801daee:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801daf2:	4413      	add	r3, r2
 801daf4:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp12 = tmp1 - tmp3;
 801daf8:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801dafc:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801db00:	1ad3      	subs	r3, r2, r3
 801db02:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 801db06:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801db0a:	331c      	adds	r3, #28
 801db0c:	681b      	ldr	r3, [r3, #0]
 801db0e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = (INT32) wsptr[5];
 801db12:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801db16:	3314      	adds	r3, #20
 801db18:	681b      	ldr	r3, [r3, #0]
 801db1a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = (INT32) wsptr[3];
 801db1e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801db22:	330c      	adds	r3, #12
 801db24:	681b      	ldr	r3, [r3, #0]
 801db26:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = (INT32) wsptr[1];
 801db2a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801db2e:	3304      	adds	r3, #4
 801db30:	681b      	ldr	r3, [r3, #0]
 801db32:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z2 = tmp0 + tmp2;
 801db36:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801db3a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801db3e:	4413      	add	r3, r2
 801db40:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = tmp1 + tmp3;
 801db44:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801db48:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801db4c:	4413      	add	r3, r2
 801db4e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 801db52:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801db56:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801db5a:	4413      	add	r3, r2
 801db5c:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 801db60:	fb02 f303 	mul.w	r3, r2, r3
 801db64:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801db68:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801db6c:	4a86      	ldr	r2, [pc, #536]	@ (801dd88 <jpeg_idct_islow+0x950>)
 801db6e:	fb02 f303 	mul.w	r3, r2, r3
 801db72:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801db76:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801db7a:	4a84      	ldr	r2, [pc, #528]	@ (801dd8c <jpeg_idct_islow+0x954>)
 801db7c:	fb02 f303 	mul.w	r3, r2, r3
 801db80:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 += z1;
 801db84:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801db88:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801db8c:	4413      	add	r3, r2
 801db8e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 += z1;
 801db92:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801db96:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801db9a:	4413      	add	r3, r2
 801db9c:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 801dba0:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801dba4:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801dba8:	4413      	add	r3, r2
 801dbaa:	4a79      	ldr	r2, [pc, #484]	@ (801dd90 <jpeg_idct_islow+0x958>)
 801dbac:	fb02 f303 	mul.w	r3, r2, r3
 801dbb0:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 801dbb4:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801dbb8:	f640 128e 	movw	r2, #2446	@ 0x98e
 801dbbc:	fb02 f303 	mul.w	r3, r2, r3
 801dbc0:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 801dbc4:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801dbc8:	f243 020b 	movw	r2, #12299	@ 0x300b
 801dbcc:	fb02 f303 	mul.w	r3, r2, r3
 801dbd0:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp0 += z1 + z2;
 801dbd4:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801dbd8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801dbdc:	4413      	add	r3, r2
 801dbde:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801dbe2:	4413      	add	r3, r2
 801dbe4:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 += z1 + z3;
 801dbe8:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801dbec:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801dbf0:	4413      	add	r3, r2
 801dbf2:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801dbf6:	4413      	add	r3, r2
 801dbf8:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 801dbfc:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801dc00:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dc04:	4413      	add	r3, r2
 801dc06:	4a63      	ldr	r2, [pc, #396]	@ (801dd94 <jpeg_idct_islow+0x95c>)
 801dc08:	fb02 f303 	mul.w	r3, r2, r3
 801dc0c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 801dc10:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801dc14:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 801dc18:	fb02 f303 	mul.w	r3, r2, r3
 801dc1c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 801dc20:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dc24:	f246 2254 	movw	r2, #25172	@ 0x6254
 801dc28:	fb02 f303 	mul.w	r3, r2, r3
 801dc2c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp1 += z1 + z3;
 801dc30:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801dc34:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801dc38:	4413      	add	r3, r2
 801dc3a:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801dc3e:	4413      	add	r3, r2
 801dc40:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 += z1 + z2;
 801dc44:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801dc48:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801dc4c:	4413      	add	r3, r2
 801dc4e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801dc52:	4413      	add	r3, r2
 801dc54:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 801dc58:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801dc5c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801dc60:	4413      	add	r3, r2
 801dc62:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dc64:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 801dc68:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dc6c:	4413      	add	r3, r2
 801dc6e:	781a      	ldrb	r2, [r3, #0]
 801dc70:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dc74:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 801dc76:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801dc7a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801dc7e:	1ad3      	subs	r3, r2, r3
 801dc80:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dc82:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 801dc86:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dc8a:	441a      	add	r2, r3
 801dc8c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dc90:	3307      	adds	r3, #7
 801dc92:	7812      	ldrb	r2, [r2, #0]
 801dc94:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 801dc96:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801dc9a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dc9e:	4413      	add	r3, r2
 801dca0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dca2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 801dca6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dcaa:	441a      	add	r2, r3
 801dcac:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dcb0:	3301      	adds	r3, #1
 801dcb2:	7812      	ldrb	r2, [r2, #0]
 801dcb4:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 801dcb6:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801dcba:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801dcbe:	1ad3      	subs	r3, r2, r3
 801dcc0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dcc2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 801dcc6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dcca:	441a      	add	r2, r3
 801dccc:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dcd0:	3306      	adds	r3, #6
 801dcd2:	7812      	ldrb	r2, [r2, #0]
 801dcd4:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 801dcd6:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801dcda:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801dcde:	4413      	add	r3, r2
 801dce0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dce2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 801dce6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dcea:	441a      	add	r2, r3
 801dcec:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dcf0:	3302      	adds	r3, #2
 801dcf2:	7812      	ldrb	r2, [r2, #0]
 801dcf4:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 801dcf6:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801dcfa:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801dcfe:	1ad3      	subs	r3, r2, r3
 801dd00:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dd02:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 801dd06:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dd0a:	441a      	add	r2, r3
 801dd0c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dd10:	3305      	adds	r3, #5
 801dd12:	7812      	ldrb	r2, [r2, #0]
 801dd14:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 801dd16:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801dd1a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801dd1e:	4413      	add	r3, r2
 801dd20:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dd22:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 801dd26:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dd2a:	441a      	add	r2, r3
 801dd2c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dd30:	3303      	adds	r3, #3
 801dd32:	7812      	ldrb	r2, [r2, #0]
 801dd34:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 801dd36:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801dd3a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801dd3e:	1ad3      	subs	r3, r2, r3
 801dd40:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801dd42:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 801dd46:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801dd4a:	441a      	add	r2, r3
 801dd4c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801dd50:	3304      	adds	r3, #4
 801dd52:	7812      	ldrb	r2, [r2, #0]
 801dd54:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 801dd56:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801dd5a:	3320      	adds	r3, #32
 801dd5c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801dd60:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801dd64:	3301      	adds	r3, #1
 801dd66:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801dd6a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801dd6e:	2b07      	cmp	r3, #7
 801dd70:	f77f adea 	ble.w	801d948 <jpeg_idct_islow+0x510>
  }
}
 801dd74:	bf00      	nop
 801dd76:	bf00      	nop
 801dd78:	f507 77b0 	add.w	r7, r7, #352	@ 0x160
 801dd7c:	46bd      	mov	sp, r7
 801dd7e:	bc90      	pop	{r4, r7}
 801dd80:	4770      	bx	lr
 801dd82:	bf00      	nop
 801dd84:	ffffc4df 	.word	0xffffc4df
 801dd88:	ffffc13b 	.word	0xffffc13b
 801dd8c:	fffff384 	.word	0xfffff384
 801dd90:	ffffe333 	.word	0xffffe333
 801dd94:	ffffadfd 	.word	0xffffadfd

0801dd98 <jpeg_idct_7x7>:

GLOBAL(void)
jpeg_idct_7x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801dd98:	b490      	push	{r4, r7}
 801dd9a:	b0c6      	sub	sp, #280	@ 0x118
 801dd9c:	af00      	add	r7, sp, #0
 801dd9e:	f507 748c 	add.w	r4, r7, #280	@ 0x118
 801dda2:	f5a4 7486 	sub.w	r4, r4, #268	@ 0x10c
 801dda6:	6020      	str	r0, [r4, #0]
 801dda8:	f507 708c 	add.w	r0, r7, #280	@ 0x118
 801ddac:	f5a0 7088 	sub.w	r0, r0, #272	@ 0x110
 801ddb0:	6001      	str	r1, [r0, #0]
 801ddb2:	f507 718c 	add.w	r1, r7, #280	@ 0x118
 801ddb6:	f5a1 718a 	sub.w	r1, r1, #276	@ 0x114
 801ddba:	600a      	str	r2, [r1, #0]
 801ddbc:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 801ddc0:	f5a2 728c 	sub.w	r2, r2, #280	@ 0x118
 801ddc4:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801ddc6:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801ddca:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 801ddce:	681b      	ldr	r3, [r3, #0]
 801ddd0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801ddd4:	3380      	adds	r3, #128	@ 0x80
 801ddd6:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
  int workspace[7*7];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801ddda:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801ddde:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801dde2:	681b      	ldr	r3, [r3, #0]
 801dde4:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801dde8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801ddec:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
 801ddf0:	681b      	ldr	r3, [r3, #0]
 801ddf2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801ddf4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  wsptr = workspace;
 801ddf8:	f107 0314 	add.w	r3, r7, #20
 801ddfc:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 801de00:	2300      	movs	r3, #0
 801de02:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 801de06:	e17a      	b.n	801e0fe <jpeg_idct_7x7+0x366>
    /* Even part */

    tmp13 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801de08:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801de0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801de10:	461a      	mov	r2, r3
 801de12:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801de16:	681b      	ldr	r3, [r3, #0]
 801de18:	fb02 f303 	mul.w	r3, r2, r3
 801de1c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp13 <<= CONST_BITS;
 801de20:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801de24:	035b      	lsls	r3, r3, #13
 801de26:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    /* Add fudge factor here for final descale. */
    tmp13 += ONE << (CONST_BITS-PASS1_BITS-1);
 801de2a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801de2e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801de32:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801de36:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801de3a:	3320      	adds	r3, #32
 801de3c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801de40:	461a      	mov	r2, r3
 801de42:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801de46:	3340      	adds	r3, #64	@ 0x40
 801de48:	681b      	ldr	r3, [r3, #0]
 801de4a:	fb02 f303 	mul.w	r3, r2, r3
 801de4e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801de52:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801de56:	3340      	adds	r3, #64	@ 0x40
 801de58:	f9b3 3000 	ldrsh.w	r3, [r3]
 801de5c:	461a      	mov	r2, r3
 801de5e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801de62:	3380      	adds	r3, #128	@ 0x80
 801de64:	681b      	ldr	r3, [r3, #0]
 801de66:	fb02 f303 	mul.w	r3, r2, r3
 801de6a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801de6e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801de72:	3360      	adds	r3, #96	@ 0x60
 801de74:	f9b3 3000 	ldrsh.w	r3, [r3]
 801de78:	461a      	mov	r2, r3
 801de7a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801de7e:	33c0      	adds	r3, #192	@ 0xc0
 801de80:	681b      	ldr	r3, [r3, #0]
 801de82:	fb02 f303 	mul.w	r3, r2, r3
 801de86:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 801de8a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801de8e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801de92:	1ad3      	subs	r3, r2, r3
 801de94:	f641 4237 	movw	r2, #7223	@ 0x1c37
 801de98:	fb02 f303 	mul.w	r3, r2, r3
 801de9c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 801dea0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801dea4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801dea8:	1ad3      	subs	r3, r2, r3
 801deaa:	f640 2212 	movw	r2, #2578	@ 0xa12
 801deae:	fb02 f303 	mul.w	r3, r2, r3
 801deb2:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 801deb6:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801deba:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801debe:	441a      	add	r2, r3
 801dec0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801dec4:	441a      	add	r2, r3
 801dec6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801deca:	4993      	ldr	r1, [pc, #588]	@ (801e118 <jpeg_idct_7x7+0x380>)
 801decc:	fb01 f303 	mul.w	r3, r1, r3
 801ded0:	4413      	add	r3, r2
 801ded2:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp0 = z1 + z3;
 801ded6:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801deda:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801dede:	4413      	add	r3, r2
 801dee0:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z2 -= tmp0;
 801dee4:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801dee8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801deec:	1ad3      	subs	r3, r2, r3
 801deee:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 801def2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801def6:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 801defa:	fb02 f303 	mul.w	r3, r2, r3
 801defe:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 801df02:	4413      	add	r3, r2
 801df04:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 801df08:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801df0c:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 801df10:	fb03 f202 	mul.w	r2, r3, r2
 801df14:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801df18:	4413      	add	r3, r2
 801df1a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801df1e:	4413      	add	r3, r2
 801df20:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 801df24:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801df28:	4a7c      	ldr	r2, [pc, #496]	@ (801e11c <jpeg_idct_7x7+0x384>)
 801df2a:	fb03 f202 	mul.w	r2, r3, r2
 801df2e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801df32:	4413      	add	r3, r2
 801df34:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801df38:	4413      	add	r3, r2
 801df3a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 801df3e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801df42:	f642 5241 	movw	r2, #11585	@ 0x2d41
 801df46:	fb02 f303 	mul.w	r3, r2, r3
 801df4a:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 801df4e:	4413      	add	r3, r2
 801df50:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801df54:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801df58:	3310      	adds	r3, #16
 801df5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801df5e:	461a      	mov	r2, r3
 801df60:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801df64:	3320      	adds	r3, #32
 801df66:	681b      	ldr	r3, [r3, #0]
 801df68:	fb02 f303 	mul.w	r3, r2, r3
 801df6c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801df70:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801df74:	3330      	adds	r3, #48	@ 0x30
 801df76:	f9b3 3000 	ldrsh.w	r3, [r3]
 801df7a:	461a      	mov	r2, r3
 801df7c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801df80:	3360      	adds	r3, #96	@ 0x60
 801df82:	681b      	ldr	r3, [r3, #0]
 801df84:	fb02 f303 	mul.w	r3, r2, r3
 801df88:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801df8c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801df90:	3350      	adds	r3, #80	@ 0x50
 801df92:	f9b3 3000 	ldrsh.w	r3, [r3]
 801df96:	461a      	mov	r2, r3
 801df98:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801df9c:	33a0      	adds	r3, #160	@ 0xa0
 801df9e:	681b      	ldr	r3, [r3, #0]
 801dfa0:	fb02 f303 	mul.w	r3, r2, r3
 801dfa4:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 801dfa8:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801dfac:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801dfb0:	4413      	add	r3, r2
 801dfb2:	f641 52ef 	movw	r2, #7663	@ 0x1def
 801dfb6:	fb02 f303 	mul.w	r3, r2, r3
 801dfba:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 801dfbe:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801dfc2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801dfc6:	1ad3      	subs	r3, r2, r3
 801dfc8:	f240 5273 	movw	r2, #1395	@ 0x573
 801dfcc:	fb02 f303 	mul.w	r3, r2, r3
 801dfd0:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp0 = tmp1 - tmp2;
 801dfd4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801dfd8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801dfdc:	1ad3      	subs	r3, r2, r3
 801dfde:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp1 += tmp2;
 801dfe2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801dfe6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801dfea:	4413      	add	r3, r2
 801dfec:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 801dff0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801dff4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801dff8:	4413      	add	r3, r2
 801dffa:	4a49      	ldr	r2, [pc, #292]	@ (801e120 <jpeg_idct_7x7+0x388>)
 801dffc:	fb02 f303 	mul.w	r3, r2, r3
 801e000:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp1 += tmp2;
 801e004:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801e008:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e00c:	4413      	add	r3, r2
 801e00e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 801e012:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e016:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e01a:	4413      	add	r3, r2
 801e01c:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 801e020:	fb02 f303 	mul.w	r3, r2, r3
 801e024:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 += z2;
 801e028:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 801e02c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e030:	4413      	add	r3, r2
 801e032:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 801e036:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e03a:	f643 32de 	movw	r2, #15326	@ 0x3bde
 801e03e:	fb03 f202 	mul.w	r2, r3, r2
 801e042:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e046:	4413      	add	r3, r2
 801e048:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 801e04c:	4413      	add	r3, r2
 801e04e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    wsptr[7*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801e052:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e056:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e05a:	4413      	add	r3, r2
 801e05c:	12da      	asrs	r2, r3, #11
 801e05e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e062:	601a      	str	r2, [r3, #0]
    wsptr[7*6] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801e064:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e068:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e06c:	1ad2      	subs	r2, r2, r3
 801e06e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e072:	33a8      	adds	r3, #168	@ 0xa8
 801e074:	12d2      	asrs	r2, r2, #11
 801e076:	601a      	str	r2, [r3, #0]
    wsptr[7*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 801e078:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801e07c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e080:	441a      	add	r2, r3
 801e082:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e086:	331c      	adds	r3, #28
 801e088:	12d2      	asrs	r2, r2, #11
 801e08a:	601a      	str	r2, [r3, #0]
    wsptr[7*5] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 801e08c:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801e090:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e094:	1ad2      	subs	r2, r2, r3
 801e096:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e09a:	338c      	adds	r3, #140	@ 0x8c
 801e09c:	12d2      	asrs	r2, r2, #11
 801e09e:	601a      	str	r2, [r3, #0]
    wsptr[7*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 801e0a0:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801e0a4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e0a8:	441a      	add	r2, r3
 801e0aa:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e0ae:	3338      	adds	r3, #56	@ 0x38
 801e0b0:	12d2      	asrs	r2, r2, #11
 801e0b2:	601a      	str	r2, [r3, #0]
    wsptr[7*4] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 801e0b4:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801e0b8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e0bc:	1ad2      	subs	r2, r2, r3
 801e0be:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e0c2:	3370      	adds	r3, #112	@ 0x70
 801e0c4:	12d2      	asrs	r2, r2, #11
 801e0c6:	601a      	str	r2, [r3, #0]
    wsptr[7*3] = (int) RIGHT_SHIFT(tmp13, CONST_BITS-PASS1_BITS);
 801e0c8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e0cc:	3354      	adds	r3, #84	@ 0x54
 801e0ce:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 801e0d2:	12d2      	asrs	r2, r2, #11
 801e0d4:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 801e0d6:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801e0da:	3301      	adds	r3, #1
 801e0dc:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 801e0e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801e0e4:	3302      	adds	r3, #2
 801e0e6:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 801e0ea:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801e0ee:	3304      	adds	r3, #4
 801e0f0:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 801e0f4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e0f8:	3304      	adds	r3, #4
 801e0fa:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 801e0fe:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801e102:	2b06      	cmp	r3, #6
 801e104:	f77f ae80 	ble.w	801de08 <jpeg_idct_7x7+0x70>
  }

  /* Pass 2: process 7 rows from work array, store into output array. */

  wsptr = workspace;
 801e108:	f107 0314 	add.w	r3, r7, #20
 801e10c:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 801e110:	2300      	movs	r3, #0
 801e112:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 801e116:	e173      	b.n	801e400 <jpeg_idct_7x7+0x668>
 801e118:	ffffc515 	.word	0xffffc515
 801e11c:	ffffb0f1 	.word	0xffffb0f1
 801e120:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 801e124:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801e128:	009b      	lsls	r3, r3, #2
 801e12a:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 801e12e:	f5a2 728c 	sub.w	r2, r2, #280	@ 0x118
 801e132:	6812      	ldr	r2, [r2, #0]
 801e134:	4413      	add	r3, r2
 801e136:	681a      	ldr	r2, [r3, #0]
 801e138:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801e13c:	4413      	add	r3, r2
 801e13e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp13 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801e142:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e146:	681b      	ldr	r3, [r3, #0]
 801e148:	3310      	adds	r3, #16
 801e14a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp13 <<= CONST_BITS;
 801e14e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801e152:	035b      	lsls	r3, r3, #13
 801e154:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    z1 = (INT32) wsptr[2];
 801e158:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e15c:	3308      	adds	r3, #8
 801e15e:	681b      	ldr	r3, [r3, #0]
 801e160:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = (INT32) wsptr[4];
 801e164:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e168:	3310      	adds	r3, #16
 801e16a:	681b      	ldr	r3, [r3, #0]
 801e16c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = (INT32) wsptr[6];
 801e170:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e174:	3318      	adds	r3, #24
 801e176:	681b      	ldr	r3, [r3, #0]
 801e178:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 801e17c:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801e180:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e184:	1ad3      	subs	r3, r2, r3
 801e186:	f641 4237 	movw	r2, #7223	@ 0x1c37
 801e18a:	fb02 f303 	mul.w	r3, r2, r3
 801e18e:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 801e192:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e196:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e19a:	1ad3      	subs	r3, r2, r3
 801e19c:	f640 2212 	movw	r2, #2578	@ 0xa12
 801e1a0:	fb02 f303 	mul.w	r3, r2, r3
 801e1a4:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 801e1a8:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e1ac:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801e1b0:	441a      	add	r2, r3
 801e1b2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801e1b6:	441a      	add	r2, r3
 801e1b8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e1bc:	4996      	ldr	r1, [pc, #600]	@ (801e418 <jpeg_idct_7x7+0x680>)
 801e1be:	fb01 f303 	mul.w	r3, r1, r3
 801e1c2:	4413      	add	r3, r2
 801e1c4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp0 = z1 + z3;
 801e1c8:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e1cc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e1d0:	4413      	add	r3, r2
 801e1d2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z2 -= tmp0;
 801e1d6:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801e1da:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e1de:	1ad3      	subs	r3, r2, r3
 801e1e0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 801e1e4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e1e8:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 801e1ec:	fb02 f303 	mul.w	r3, r2, r3
 801e1f0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 801e1f4:	4413      	add	r3, r2
 801e1f6:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 801e1fa:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e1fe:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 801e202:	fb03 f202 	mul.w	r2, r3, r2
 801e206:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e20a:	4413      	add	r3, r2
 801e20c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e210:	4413      	add	r3, r2
 801e212:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 801e216:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801e21a:	4a80      	ldr	r2, [pc, #512]	@ (801e41c <jpeg_idct_7x7+0x684>)
 801e21c:	fb03 f202 	mul.w	r2, r3, r2
 801e220:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e224:	4413      	add	r3, r2
 801e226:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801e22a:	4413      	add	r3, r2
 801e22c:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 801e230:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e234:	f642 5241 	movw	r2, #11585	@ 0x2d41
 801e238:	fb02 f303 	mul.w	r3, r2, r3
 801e23c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 801e240:	4413      	add	r3, r2
 801e242:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801e246:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e24a:	3304      	adds	r3, #4
 801e24c:	681b      	ldr	r3, [r3, #0]
 801e24e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = (INT32) wsptr[3];
 801e252:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e256:	330c      	adds	r3, #12
 801e258:	681b      	ldr	r3, [r3, #0]
 801e25a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = (INT32) wsptr[5];
 801e25e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e262:	3314      	adds	r3, #20
 801e264:	681b      	ldr	r3, [r3, #0]
 801e266:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 801e26a:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e26e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e272:	4413      	add	r3, r2
 801e274:	f641 52ef 	movw	r2, #7663	@ 0x1def
 801e278:	fb02 f303 	mul.w	r3, r2, r3
 801e27c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 801e280:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e284:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e288:	1ad3      	subs	r3, r2, r3
 801e28a:	f240 5273 	movw	r2, #1395	@ 0x573
 801e28e:	fb02 f303 	mul.w	r3, r2, r3
 801e292:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp0 = tmp1 - tmp2;
 801e296:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801e29a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e29e:	1ad3      	subs	r3, r2, r3
 801e2a0:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp1 += tmp2;
 801e2a4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801e2a8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e2ac:	4413      	add	r3, r2
 801e2ae:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 801e2b2:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 801e2b6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e2ba:	4413      	add	r3, r2
 801e2bc:	4a58      	ldr	r2, [pc, #352]	@ (801e420 <jpeg_idct_7x7+0x688>)
 801e2be:	fb02 f303 	mul.w	r3, r2, r3
 801e2c2:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp1 += tmp2;
 801e2c6:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 801e2ca:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e2ce:	4413      	add	r3, r2
 801e2d0:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 801e2d4:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801e2d8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e2dc:	4413      	add	r3, r2
 801e2de:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 801e2e2:	fb02 f303 	mul.w	r3, r2, r3
 801e2e6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 += z2;
 801e2ea:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 801e2ee:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e2f2:	4413      	add	r3, r2
 801e2f4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 801e2f8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801e2fc:	f643 32de 	movw	r2, #15326	@ 0x3bde
 801e300:	fb03 f202 	mul.w	r2, r3, r2
 801e304:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801e308:	4413      	add	r3, r2
 801e30a:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 801e30e:	4413      	add	r3, r2
 801e310:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801e314:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e318:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e31c:	4413      	add	r3, r2
 801e31e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e320:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801e324:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e328:	4413      	add	r3, r2
 801e32a:	781a      	ldrb	r2, [r3, #0]
 801e32c:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e330:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801e332:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 801e336:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801e33a:	1ad3      	subs	r3, r2, r3
 801e33c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e33e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801e342:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e346:	441a      	add	r2, r3
 801e348:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e34c:	3306      	adds	r3, #6
 801e34e:	7812      	ldrb	r2, [r2, #0]
 801e350:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801e352:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801e356:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e35a:	4413      	add	r3, r2
 801e35c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e35e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801e362:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e366:	441a      	add	r2, r3
 801e368:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e36c:	3301      	adds	r3, #1
 801e36e:	7812      	ldrb	r2, [r2, #0]
 801e370:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801e372:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801e376:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e37a:	1ad3      	subs	r3, r2, r3
 801e37c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e37e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801e382:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e386:	441a      	add	r2, r3
 801e388:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e38c:	3305      	adds	r3, #5
 801e38e:	7812      	ldrb	r2, [r2, #0]
 801e390:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801e392:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801e396:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e39a:	4413      	add	r3, r2
 801e39c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e39e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801e3a2:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e3a6:	441a      	add	r2, r3
 801e3a8:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e3ac:	3302      	adds	r3, #2
 801e3ae:	7812      	ldrb	r2, [r2, #0]
 801e3b0:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801e3b2:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801e3b6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e3ba:	1ad3      	subs	r3, r2, r3
 801e3bc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e3be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801e3c2:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e3c6:	441a      	add	r2, r3
 801e3c8:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e3cc:	3304      	adds	r3, #4
 801e3ce:	7812      	ldrb	r2, [r2, #0]
 801e3d0:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 801e3d2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 801e3d6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e3d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 801e3dc:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801e3e0:	441a      	add	r2, r3
 801e3e2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 801e3e6:	3303      	adds	r3, #3
 801e3e8:	7812      	ldrb	r2, [r2, #0]
 801e3ea:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 801e3ec:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801e3f0:	331c      	adds	r3, #28
 801e3f2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 801e3f6:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801e3fa:	3301      	adds	r3, #1
 801e3fc:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 801e400:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801e404:	2b06      	cmp	r3, #6
 801e406:	f77f ae8d 	ble.w	801e124 <jpeg_idct_7x7+0x38c>
  }
}
 801e40a:	bf00      	nop
 801e40c:	bf00      	nop
 801e40e:	f507 778c 	add.w	r7, r7, #280	@ 0x118
 801e412:	46bd      	mov	sp, r7
 801e414:	bc90      	pop	{r4, r7}
 801e416:	4770      	bx	lr
 801e418:	ffffc515 	.word	0xffffc515
 801e41c:	ffffb0f1 	.word	0xffffb0f1
 801e420:	ffffd3e1 	.word	0xffffd3e1

0801e424 <jpeg_idct_6x6>:

GLOBAL(void)
jpeg_idct_6x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801e424:	b480      	push	{r7}
 801e426:	b0b9      	sub	sp, #228	@ 0xe4
 801e428:	af00      	add	r7, sp, #0
 801e42a:	60f8      	str	r0, [r7, #12]
 801e42c:	60b9      	str	r1, [r7, #8]
 801e42e:	607a      	str	r2, [r7, #4]
 801e430:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801e432:	68fb      	ldr	r3, [r7, #12]
 801e434:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801e438:	3380      	adds	r3, #128	@ 0x80
 801e43a:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  int workspace[6*6];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801e43e:	687b      	ldr	r3, [r7, #4]
 801e440:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801e444:	68bb      	ldr	r3, [r7, #8]
 801e446:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801e448:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  wsptr = workspace;
 801e44c:	f107 0314 	add.w	r3, r7, #20
 801e450:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 801e454:	2300      	movs	r3, #0
 801e456:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801e45a:	e105      	b.n	801e668 <jpeg_idct_6x6+0x244>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801e45c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e460:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e464:	461a      	mov	r2, r3
 801e466:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e46a:	681b      	ldr	r3, [r3, #0]
 801e46c:	fb02 f303 	mul.w	r3, r2, r3
 801e470:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp0 <<= CONST_BITS;
 801e474:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e478:	035b      	lsls	r3, r3, #13
 801e47a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801e47e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e482:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801e486:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801e48a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e48e:	3340      	adds	r3, #64	@ 0x40
 801e490:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e494:	461a      	mov	r2, r3
 801e496:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e49a:	3380      	adds	r3, #128	@ 0x80
 801e49c:	681b      	ldr	r3, [r3, #0]
 801e49e:	fb02 f303 	mul.w	r3, r2, r3
 801e4a2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 801e4a6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e4aa:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801e4ae:	fb02 f303 	mul.w	r3, r2, r3
 801e4b2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = tmp0 + tmp10;
 801e4b6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 801e4ba:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e4be:	4413      	add	r3, r2
 801e4c0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 801e4c4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 801e4c8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e4cc:	1ad2      	subs	r2, r2, r3
 801e4ce:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e4d2:	1ad3      	subs	r3, r2, r3
 801e4d4:	12db      	asrs	r3, r3, #11
 801e4d6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801e4da:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e4de:	3320      	adds	r3, #32
 801e4e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e4e4:	461a      	mov	r2, r3
 801e4e6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e4ea:	3340      	adds	r3, #64	@ 0x40
 801e4ec:	681b      	ldr	r3, [r3, #0]
 801e4ee:	fb02 f303 	mul.w	r3, r2, r3
 801e4f2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 801e4f6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e4fa:	f242 7231 	movw	r2, #10033	@ 0x2731
 801e4fe:	fb02 f303 	mul.w	r3, r2, r3
 801e502:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp10 = tmp1 + tmp0;
 801e506:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e50a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e50e:	4413      	add	r3, r2
 801e510:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp12 = tmp1 - tmp0;
 801e514:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e518:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e51c:	1ad3      	subs	r3, r2, r3
 801e51e:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801e522:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e526:	3310      	adds	r3, #16
 801e528:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e52c:	461a      	mov	r2, r3
 801e52e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e532:	3320      	adds	r3, #32
 801e534:	681b      	ldr	r3, [r3, #0]
 801e536:	fb02 f303 	mul.w	r3, r2, r3
 801e53a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801e53e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e542:	3330      	adds	r3, #48	@ 0x30
 801e544:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e548:	461a      	mov	r2, r3
 801e54a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e54e:	3360      	adds	r3, #96	@ 0x60
 801e550:	681b      	ldr	r3, [r3, #0]
 801e552:	fb02 f303 	mul.w	r3, r2, r3
 801e556:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801e55a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e55e:	3350      	adds	r3, #80	@ 0x50
 801e560:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e564:	461a      	mov	r2, r3
 801e566:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e56a:	33a0      	adds	r3, #160	@ 0xa0
 801e56c:	681b      	ldr	r3, [r3, #0]
 801e56e:	fb02 f303 	mul.w	r3, r2, r3
 801e572:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 801e576:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e57a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801e57e:	4413      	add	r3, r2
 801e580:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 801e584:	fb02 f303 	mul.w	r3, r2, r3
 801e588:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 801e58c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e590:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e594:	4413      	add	r3, r2
 801e596:	035b      	lsls	r3, r3, #13
 801e598:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e59c:	4413      	add	r3, r2
 801e59e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 801e5a2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 801e5a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e5aa:	1ad3      	subs	r3, r2, r3
 801e5ac:	035b      	lsls	r3, r3, #13
 801e5ae:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e5b2:	4413      	add	r3, r2
 801e5b4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 801e5b8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e5bc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e5c0:	1ad2      	subs	r2, r2, r3
 801e5c2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801e5c6:	1ad3      	subs	r3, r2, r3
 801e5c8:	009b      	lsls	r3, r3, #2
 801e5ca:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801e5ce:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801e5d2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e5d6:	4413      	add	r3, r2
 801e5d8:	12da      	asrs	r2, r3, #11
 801e5da:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e5de:	601a      	str	r2, [r3, #0]
    wsptr[6*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801e5e0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801e5e4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e5e8:	1ad2      	subs	r2, r2, r3
 801e5ea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e5ee:	3378      	adds	r3, #120	@ 0x78
 801e5f0:	12d2      	asrs	r2, r2, #11
 801e5f2:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) (tmp11 + tmp1);
 801e5f4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e5f8:	3318      	adds	r3, #24
 801e5fa:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 801e5fe:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e602:	440a      	add	r2, r1
 801e604:	601a      	str	r2, [r3, #0]
    wsptr[6*4] = (int) (tmp11 - tmp1);
 801e606:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e60a:	3360      	adds	r3, #96	@ 0x60
 801e60c:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 801e610:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e614:	1a8a      	subs	r2, r1, r2
 801e616:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 801e618:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801e61c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e620:	441a      	add	r2, r3
 801e622:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e626:	3330      	adds	r3, #48	@ 0x30
 801e628:	12d2      	asrs	r2, r2, #11
 801e62a:	601a      	str	r2, [r3, #0]
    wsptr[6*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 801e62c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801e630:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e634:	1ad2      	subs	r2, r2, r3
 801e636:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e63a:	3348      	adds	r3, #72	@ 0x48
 801e63c:	12d2      	asrs	r2, r2, #11
 801e63e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 801e640:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801e644:	3301      	adds	r3, #1
 801e646:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801e64a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801e64e:	3302      	adds	r3, #2
 801e650:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 801e654:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801e658:	3304      	adds	r3, #4
 801e65a:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 801e65e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e662:	3304      	adds	r3, #4
 801e664:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 801e668:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801e66c:	2b05      	cmp	r3, #5
 801e66e:	f77f aef5 	ble.w	801e45c <jpeg_idct_6x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array. */

  wsptr = workspace;
 801e672:	f107 0314 	add.w	r3, r7, #20
 801e676:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 801e67a:	2300      	movs	r3, #0
 801e67c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801e680:	e0f7      	b.n	801e872 <jpeg_idct_6x6+0x44e>
    outptr = output_buf[ctr] + output_col;
 801e682:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801e686:	009b      	lsls	r3, r3, #2
 801e688:	683a      	ldr	r2, [r7, #0]
 801e68a:	4413      	add	r3, r2
 801e68c:	681a      	ldr	r2, [r3, #0]
 801e68e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801e692:	4413      	add	r3, r2
 801e694:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801e698:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e69c:	681b      	ldr	r3, [r3, #0]
 801e69e:	3310      	adds	r3, #16
 801e6a0:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp0 <<= CONST_BITS;
 801e6a4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e6a8:	035b      	lsls	r3, r3, #13
 801e6aa:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = (INT32) wsptr[4];
 801e6ae:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e6b2:	3310      	adds	r3, #16
 801e6b4:	681b      	ldr	r3, [r3, #0]
 801e6b6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 801e6ba:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e6be:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801e6c2:	fb02 f303 	mul.w	r3, r2, r3
 801e6c6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = tmp0 + tmp10;
 801e6ca:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 801e6ce:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e6d2:	4413      	add	r3, r2
 801e6d4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp11 = tmp0 - tmp10 - tmp10;
 801e6d8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 801e6dc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e6e0:	1ad2      	subs	r2, r2, r3
 801e6e2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e6e6:	1ad3      	subs	r3, r2, r3
 801e6e8:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp10 = (INT32) wsptr[2];
 801e6ec:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e6f0:	3308      	adds	r3, #8
 801e6f2:	681b      	ldr	r3, [r3, #0]
 801e6f4:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 801e6f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801e6fc:	f242 7231 	movw	r2, #10033	@ 0x2731
 801e700:	fb02 f303 	mul.w	r3, r2, r3
 801e704:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp10 = tmp1 + tmp0;
 801e708:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e70c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e710:	4413      	add	r3, r2
 801e712:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp12 = tmp1 - tmp0;
 801e716:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e71a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e71e:	1ad3      	subs	r3, r2, r3
 801e720:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801e724:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e728:	3304      	adds	r3, #4
 801e72a:	681b      	ldr	r3, [r3, #0]
 801e72c:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z2 = (INT32) wsptr[3];
 801e730:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e734:	330c      	adds	r3, #12
 801e736:	681b      	ldr	r3, [r3, #0]
 801e738:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z3 = (INT32) wsptr[5];
 801e73c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e740:	3314      	adds	r3, #20
 801e742:	681b      	ldr	r3, [r3, #0]
 801e744:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 801e748:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e74c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801e750:	4413      	add	r3, r2
 801e752:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 801e756:	fb02 f303 	mul.w	r3, r2, r3
 801e75a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 801e75e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e762:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e766:	4413      	add	r3, r2
 801e768:	035b      	lsls	r3, r3, #13
 801e76a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e76e:	4413      	add	r3, r2
 801e770:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 801e774:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 801e778:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e77c:	1ad3      	subs	r3, r2, r3
 801e77e:	035b      	lsls	r3, r3, #13
 801e780:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801e784:	4413      	add	r3, r2
 801e786:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 801e78a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801e78e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e792:	1ad2      	subs	r2, r2, r3
 801e794:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801e798:	1ad3      	subs	r3, r2, r3
 801e79a:	035b      	lsls	r3, r3, #13
 801e79c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801e7a0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801e7a4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e7a8:	4413      	add	r3, r2
 801e7aa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e7ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801e7b0:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e7b4:	4413      	add	r3, r2
 801e7b6:	781a      	ldrb	r2, [r3, #0]
 801e7b8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e7bc:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801e7be:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801e7c2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801e7c6:	1ad3      	subs	r3, r2, r3
 801e7c8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e7ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801e7ce:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e7d2:	441a      	add	r2, r3
 801e7d4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e7d8:	3305      	adds	r3, #5
 801e7da:	7812      	ldrb	r2, [r2, #0]
 801e7dc:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801e7de:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801e7e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801e7e6:	4413      	add	r3, r2
 801e7e8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e7ea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801e7ee:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e7f2:	441a      	add	r2, r3
 801e7f4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e7f8:	3301      	adds	r3, #1
 801e7fa:	7812      	ldrb	r2, [r2, #0]
 801e7fc:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801e7fe:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801e802:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801e806:	1ad3      	subs	r3, r2, r3
 801e808:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e80a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801e80e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e812:	441a      	add	r2, r3
 801e814:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e818:	3304      	adds	r3, #4
 801e81a:	7812      	ldrb	r2, [r2, #0]
 801e81c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801e81e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801e822:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e826:	4413      	add	r3, r2
 801e828:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e82a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801e82e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e832:	441a      	add	r2, r3
 801e834:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e838:	3302      	adds	r3, #2
 801e83a:	7812      	ldrb	r2, [r2, #0]
 801e83c:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801e83e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801e842:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801e846:	1ad3      	subs	r3, r2, r3
 801e848:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801e84a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801e84e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801e852:	441a      	add	r2, r3
 801e854:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801e858:	3303      	adds	r3, #3
 801e85a:	7812      	ldrb	r2, [r2, #0]
 801e85c:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 801e85e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801e862:	3318      	adds	r3, #24
 801e864:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 801e868:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801e86c:	3301      	adds	r3, #1
 801e86e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801e872:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801e876:	2b05      	cmp	r3, #5
 801e878:	f77f af03 	ble.w	801e682 <jpeg_idct_6x6+0x25e>
  }
}
 801e87c:	bf00      	nop
 801e87e:	bf00      	nop
 801e880:	37e4      	adds	r7, #228	@ 0xe4
 801e882:	46bd      	mov	sp, r7
 801e884:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e888:	4770      	bx	lr
	...

0801e88c <jpeg_idct_5x5>:

GLOBAL(void)
jpeg_idct_5x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801e88c:	b480      	push	{r7}
 801e88e:	b0ad      	sub	sp, #180	@ 0xb4
 801e890:	af00      	add	r7, sp, #0
 801e892:	60f8      	str	r0, [r7, #12]
 801e894:	60b9      	str	r1, [r7, #8]
 801e896:	607a      	str	r2, [r7, #4]
 801e898:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801e89a:	68fb      	ldr	r3, [r7, #12]
 801e89c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801e8a0:	3380      	adds	r3, #128	@ 0x80
 801e8a2:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  int workspace[5*5];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801e8a6:	687b      	ldr	r3, [r7, #4]
 801e8a8:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801e8ac:	68bb      	ldr	r3, [r7, #8]
 801e8ae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801e8b0:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  wsptr = workspace;
 801e8b4:	f107 0314 	add.w	r3, r7, #20
 801e8b8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 801e8bc:	2300      	movs	r3, #0
 801e8be:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801e8c2:	e0dd      	b.n	801ea80 <jpeg_idct_5x5+0x1f4>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801e8c4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e8c8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e8cc:	461a      	mov	r2, r3
 801e8ce:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e8d2:	681b      	ldr	r3, [r3, #0]
 801e8d4:	fb02 f303 	mul.w	r3, r2, r3
 801e8d8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp12 <<= CONST_BITS;
 801e8dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801e8e0:	035b      	lsls	r3, r3, #13
 801e8e2:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 801e8e6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801e8ea:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801e8ee:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801e8f2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e8f6:	3320      	adds	r3, #32
 801e8f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e8fc:	461a      	mov	r2, r3
 801e8fe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e902:	3340      	adds	r3, #64	@ 0x40
 801e904:	681b      	ldr	r3, [r3, #0]
 801e906:	fb02 f303 	mul.w	r3, r2, r3
 801e90a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801e90e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e912:	3340      	adds	r3, #64	@ 0x40
 801e914:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e918:	461a      	mov	r2, r3
 801e91a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e91e:	3380      	adds	r3, #128	@ 0x80
 801e920:	681b      	ldr	r3, [r3, #0]
 801e922:	fb02 f303 	mul.w	r3, r2, r3
 801e926:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 801e92a:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801e92e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801e932:	4413      	add	r3, r2
 801e934:	f641 124c 	movw	r2, #6476	@ 0x194c
 801e938:	fb02 f303 	mul.w	r3, r2, r3
 801e93c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 801e940:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801e944:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801e948:	1ad3      	subs	r3, r2, r3
 801e94a:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 801e94e:	fb02 f303 	mul.w	r3, r2, r3
 801e952:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = tmp12 + z2;
 801e956:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801e95a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801e95e:	4413      	add	r3, r2
 801e960:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    tmp10 = z3 + z1;
 801e964:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801e968:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801e96c:	4413      	add	r3, r2
 801e96e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp11 = z3 - z1;
 801e970:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801e974:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801e978:	1ad3      	subs	r3, r2, r3
 801e97a:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 -= z2 << 2;
 801e97c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801e980:	009b      	lsls	r3, r3, #2
 801e982:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801e986:	1ad3      	subs	r3, r2, r3
 801e988:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801e98c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e990:	3310      	adds	r3, #16
 801e992:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e996:	461a      	mov	r2, r3
 801e998:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e99c:	3320      	adds	r3, #32
 801e99e:	681b      	ldr	r3, [r3, #0]
 801e9a0:	fb02 f303 	mul.w	r3, r2, r3
 801e9a4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801e9a8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e9ac:	3330      	adds	r3, #48	@ 0x30
 801e9ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e9b2:	461a      	mov	r2, r3
 801e9b4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801e9b8:	3360      	adds	r3, #96	@ 0x60
 801e9ba:	681b      	ldr	r3, [r3, #0]
 801e9bc:	fb02 f303 	mul.w	r3, r2, r3
 801e9c0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 801e9c4:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801e9c8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801e9cc:	4413      	add	r3, r2
 801e9ce:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 801e9d2:	fb02 f303 	mul.w	r3, r2, r3
 801e9d6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 801e9da:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801e9de:	f241 0271 	movw	r2, #4209	@ 0x1071
 801e9e2:	fb02 f303 	mul.w	r3, r2, r3
 801e9e6:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801e9ea:	4413      	add	r3, r2
 801e9ec:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 801e9f0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801e9f4:	4a97      	ldr	r2, [pc, #604]	@ (801ec54 <jpeg_idct_5x5+0x3c8>)
 801e9f6:	fb02 f303 	mul.w	r3, r2, r3
 801e9fa:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801e9fe:	4413      	add	r3, r2
 801ea00:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801ea04:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801ea06:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ea0a:	4413      	add	r3, r2
 801ea0c:	12da      	asrs	r2, r3, #11
 801ea0e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea12:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801ea14:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801ea16:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ea1a:	1ad2      	subs	r2, r2, r3
 801ea1c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea20:	3350      	adds	r3, #80	@ 0x50
 801ea22:	12d2      	asrs	r2, r2, #11
 801ea24:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 801ea26:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801ea28:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ea2c:	441a      	add	r2, r3
 801ea2e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea32:	3314      	adds	r3, #20
 801ea34:	12d2      	asrs	r2, r2, #11
 801ea36:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 801ea38:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801ea3a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ea3e:	1ad2      	subs	r2, r2, r3
 801ea40:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea44:	333c      	adds	r3, #60	@ 0x3c
 801ea46:	12d2      	asrs	r2, r2, #11
 801ea48:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 801ea4a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea4e:	3328      	adds	r3, #40	@ 0x28
 801ea50:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801ea54:	12d2      	asrs	r2, r2, #11
 801ea56:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 801ea58:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801ea5c:	3301      	adds	r3, #1
 801ea5e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801ea62:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801ea66:	3302      	adds	r3, #2
 801ea68:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 801ea6c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801ea70:	3304      	adds	r3, #4
 801ea72:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 801ea76:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ea7a:	3304      	adds	r3, #4
 801ea7c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 801ea80:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801ea84:	2b04      	cmp	r3, #4
 801ea86:	f77f af1d 	ble.w	801e8c4 <jpeg_idct_5x5+0x38>
  }

  /* Pass 2: process 5 rows from work array, store into output array. */

  wsptr = workspace;
 801ea8a:	f107 0314 	add.w	r3, r7, #20
 801ea8e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 801ea92:	2300      	movs	r3, #0
 801ea94:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801ea98:	e0d0      	b.n	801ec3c <jpeg_idct_5x5+0x3b0>
    outptr = output_buf[ctr] + output_col;
 801ea9a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801ea9e:	009b      	lsls	r3, r3, #2
 801eaa0:	683a      	ldr	r2, [r7, #0]
 801eaa2:	4413      	add	r3, r2
 801eaa4:	681a      	ldr	r2, [r3, #0]
 801eaa6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801eaaa:	4413      	add	r3, r2
 801eaac:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801eab0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801eab4:	681b      	ldr	r3, [r3, #0]
 801eab6:	3310      	adds	r3, #16
 801eab8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp12 <<= CONST_BITS;
 801eabc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801eac0:	035b      	lsls	r3, r3, #13
 801eac2:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp0 = (INT32) wsptr[2];
 801eac6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801eaca:	3308      	adds	r3, #8
 801eacc:	681b      	ldr	r3, [r3, #0]
 801eace:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = (INT32) wsptr[4];
 801ead2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ead6:	3310      	adds	r3, #16
 801ead8:	681b      	ldr	r3, [r3, #0]
 801eada:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 801eade:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801eae2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801eae6:	4413      	add	r3, r2
 801eae8:	f641 124c 	movw	r2, #6476	@ 0x194c
 801eaec:	fb02 f303 	mul.w	r3, r2, r3
 801eaf0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 801eaf4:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801eaf8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801eafc:	1ad3      	subs	r3, r2, r3
 801eafe:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 801eb02:	fb02 f303 	mul.w	r3, r2, r3
 801eb06:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = tmp12 + z2;
 801eb0a:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801eb0e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801eb12:	4413      	add	r3, r2
 801eb14:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    tmp10 = z3 + z1;
 801eb18:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801eb1c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801eb20:	4413      	add	r3, r2
 801eb22:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp11 = z3 - z1;
 801eb24:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801eb28:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801eb2c:	1ad3      	subs	r3, r2, r3
 801eb2e:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 -= z2 << 2;
 801eb30:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801eb34:	009b      	lsls	r3, r3, #2
 801eb36:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801eb3a:	1ad3      	subs	r3, r2, r3
 801eb3c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */

    z2 = (INT32) wsptr[1];
 801eb40:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801eb44:	3304      	adds	r3, #4
 801eb46:	681b      	ldr	r3, [r3, #0]
 801eb48:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = (INT32) wsptr[3];
 801eb4c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801eb50:	330c      	adds	r3, #12
 801eb52:	681b      	ldr	r3, [r3, #0]
 801eb54:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 801eb58:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801eb5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801eb60:	4413      	add	r3, r2
 801eb62:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 801eb66:	fb02 f303 	mul.w	r3, r2, r3
 801eb6a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 801eb6e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801eb72:	f241 0271 	movw	r2, #4209	@ 0x1071
 801eb76:	fb02 f303 	mul.w	r3, r2, r3
 801eb7a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801eb7e:	4413      	add	r3, r2
 801eb80:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 801eb84:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801eb88:	4a32      	ldr	r2, [pc, #200]	@ (801ec54 <jpeg_idct_5x5+0x3c8>)
 801eb8a:	fb02 f303 	mul.w	r3, r2, r3
 801eb8e:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801eb92:	4413      	add	r3, r2
 801eb94:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801eb98:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801eb9a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801eb9e:	4413      	add	r3, r2
 801eba0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801eba2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801eba6:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801ebaa:	4413      	add	r3, r2
 801ebac:	781a      	ldrb	r2, [r3, #0]
 801ebae:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ebb2:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801ebb4:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801ebb6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ebba:	1ad3      	subs	r3, r2, r3
 801ebbc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ebbe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801ebc2:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801ebc6:	441a      	add	r2, r3
 801ebc8:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ebcc:	3304      	adds	r3, #4
 801ebce:	7812      	ldrb	r2, [r2, #0]
 801ebd0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801ebd2:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801ebd4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ebd8:	4413      	add	r3, r2
 801ebda:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ebdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801ebe0:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801ebe4:	441a      	add	r2, r3
 801ebe6:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ebea:	3301      	adds	r3, #1
 801ebec:	7812      	ldrb	r2, [r2, #0]
 801ebee:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801ebf0:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801ebf2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ebf6:	1ad3      	subs	r3, r2, r3
 801ebf8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ebfa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801ebfe:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801ec02:	441a      	add	r2, r3
 801ec04:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ec08:	3303      	adds	r3, #3
 801ec0a:	7812      	ldrb	r2, [r2, #0]
 801ec0c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 801ec0e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ec12:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ec14:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 801ec18:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801ec1c:	441a      	add	r2, r3
 801ec1e:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ec22:	3302      	adds	r3, #2
 801ec24:	7812      	ldrb	r2, [r2, #0]
 801ec26:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 801ec28:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ec2c:	3314      	adds	r3, #20
 801ec2e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 801ec32:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801ec36:	3301      	adds	r3, #1
 801ec38:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801ec3c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801ec40:	2b04      	cmp	r3, #4
 801ec42:	f77f af2a 	ble.w	801ea9a <jpeg_idct_5x5+0x20e>
  }
}
 801ec46:	bf00      	nop
 801ec48:	bf00      	nop
 801ec4a:	37b4      	adds	r7, #180	@ 0xb4
 801ec4c:	46bd      	mov	sp, r7
 801ec4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ec52:	4770      	bx	lr
 801ec54:	ffffba5c 	.word	0xffffba5c

0801ec58 <jpeg_idct_4x4>:

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801ec58:	b480      	push	{r7}
 801ec5a:	b0a3      	sub	sp, #140	@ 0x8c
 801ec5c:	af00      	add	r7, sp, #0
 801ec5e:	60f8      	str	r0, [r7, #12]
 801ec60:	60b9      	str	r1, [r7, #8]
 801ec62:	607a      	str	r2, [r7, #4]
 801ec64:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801ec66:	68fb      	ldr	r3, [r7, #12]
 801ec68:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801ec6c:	3380      	adds	r3, #128	@ 0x80
 801ec6e:	677b      	str	r3, [r7, #116]	@ 0x74
  int workspace[4*4];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801ec70:	687b      	ldr	r3, [r7, #4]
 801ec72:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801ec76:	68bb      	ldr	r3, [r7, #8]
 801ec78:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801ec7a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  wsptr = workspace;
 801ec7e:	f107 0314 	add.w	r3, r7, #20
 801ec82:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 801ec84:	2300      	movs	r3, #0
 801ec86:	67bb      	str	r3, [r7, #120]	@ 0x78
 801ec88:	e07f      	b.n	801ed8a <jpeg_idct_4x4+0x132>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801ec8a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ec8e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ec92:	461a      	mov	r2, r3
 801ec94:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ec98:	681b      	ldr	r3, [r3, #0]
 801ec9a:	fb02 f303 	mul.w	r3, r2, r3
 801ec9e:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801eca0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801eca4:	3320      	adds	r3, #32
 801eca6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ecaa:	461a      	mov	r2, r3
 801ecac:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ecb0:	3340      	adds	r3, #64	@ 0x40
 801ecb2:	681b      	ldr	r3, [r3, #0]
 801ecb4:	fb02 f303 	mul.w	r3, r2, r3
 801ecb8:	66bb      	str	r3, [r7, #104]	@ 0x68
    
    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 801ecba:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801ecbc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ecbe:	4413      	add	r3, r2
 801ecc0:	009b      	lsls	r3, r3, #2
 801ecc2:	667b      	str	r3, [r7, #100]	@ 0x64
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 801ecc4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801ecc6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ecc8:	1ad3      	subs	r3, r2, r3
 801ecca:	009b      	lsls	r3, r3, #2
 801eccc:	663b      	str	r3, [r7, #96]	@ 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ecce:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ecd2:	3310      	adds	r3, #16
 801ecd4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ecd8:	461a      	mov	r2, r3
 801ecda:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ecde:	3320      	adds	r3, #32
 801ece0:	681b      	ldr	r3, [r3, #0]
 801ece2:	fb02 f303 	mul.w	r3, r2, r3
 801ece6:	65fb      	str	r3, [r7, #92]	@ 0x5c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801ece8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ecec:	3330      	adds	r3, #48	@ 0x30
 801ecee:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ecf2:	461a      	mov	r2, r3
 801ecf4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ecf8:	3360      	adds	r3, #96	@ 0x60
 801ecfa:	681b      	ldr	r3, [r3, #0]
 801ecfc:	fb02 f303 	mul.w	r3, r2, r3
 801ed00:	65bb      	str	r3, [r7, #88]	@ 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 801ed02:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801ed04:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ed06:	4413      	add	r3, r2
 801ed08:	f241 1251 	movw	r2, #4433	@ 0x1151
 801ed0c:	fb02 f303 	mul.w	r3, r2, r3
 801ed10:	657b      	str	r3, [r7, #84]	@ 0x54
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 801ed12:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ed14:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801ed18:	657b      	str	r3, [r7, #84]	@ 0x54
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 801ed1a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ed1c:	f641 027e 	movw	r2, #6270	@ 0x187e
 801ed20:	fb03 f202 	mul.w	r2, r3, r2
 801ed24:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ed26:	4413      	add	r3, r2
 801ed28:	12db      	asrs	r3, r3, #11
 801ed2a:	66fb      	str	r3, [r7, #108]	@ 0x6c
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 801ed2c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ed2e:	4a58      	ldr	r2, [pc, #352]	@ (801ee90 <jpeg_idct_4x4+0x238>)
 801ed30:	fb03 f202 	mul.w	r2, r3, r2
 801ed34:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ed36:	4413      	add	r3, r2
 801ed38:	12db      	asrs	r3, r3, #11
 801ed3a:	66bb      	str	r3, [r7, #104]	@ 0x68
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[4*0] = (int) (tmp10 + tmp0);
 801ed3c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801ed3e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ed40:	441a      	add	r2, r3
 801ed42:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ed44:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) (tmp10 - tmp0);
 801ed46:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ed48:	3330      	adds	r3, #48	@ 0x30
 801ed4a:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 801ed4c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801ed4e:	1a8a      	subs	r2, r1, r2
 801ed50:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) (tmp12 + tmp2);
 801ed52:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ed54:	3310      	adds	r3, #16
 801ed56:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 801ed58:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 801ed5a:	440a      	add	r2, r1
 801ed5c:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) (tmp12 - tmp2);
 801ed5e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ed60:	3320      	adds	r3, #32
 801ed62:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 801ed64:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 801ed66:	1a8a      	subs	r2, r1, r2
 801ed68:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 801ed6a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ed6c:	3301      	adds	r3, #1
 801ed6e:	67bb      	str	r3, [r7, #120]	@ 0x78
 801ed70:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ed74:	3302      	adds	r3, #2
 801ed76:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 801ed7a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ed7e:	3304      	adds	r3, #4
 801ed80:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 801ed84:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ed86:	3304      	adds	r3, #4
 801ed88:	67fb      	str	r3, [r7, #124]	@ 0x7c
 801ed8a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ed8c:	2b03      	cmp	r3, #3
 801ed8e:	f77f af7c 	ble.w	801ec8a <jpeg_idct_4x4+0x32>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 801ed92:	f107 0314 	add.w	r3, r7, #20
 801ed96:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 801ed98:	2300      	movs	r3, #0
 801ed9a:	67bb      	str	r3, [r7, #120]	@ 0x78
 801ed9c:	e06e      	b.n	801ee7c <jpeg_idct_4x4+0x224>
    outptr = output_buf[ctr] + output_col;
 801ed9e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801eda0:	009b      	lsls	r3, r3, #2
 801eda2:	683a      	ldr	r2, [r7, #0]
 801eda4:	4413      	add	r3, r2
 801eda6:	681a      	ldr	r2, [r3, #0]
 801eda8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801edac:	4413      	add	r3, r2
 801edae:	673b      	str	r3, [r7, #112]	@ 0x70

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801edb0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801edb2:	681b      	ldr	r3, [r3, #0]
 801edb4:	3310      	adds	r3, #16
 801edb6:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = (INT32) wsptr[2];
 801edb8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801edba:	3308      	adds	r3, #8
 801edbc:	681b      	ldr	r3, [r3, #0]
 801edbe:	66bb      	str	r3, [r7, #104]	@ 0x68

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 801edc0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801edc2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801edc4:	4413      	add	r3, r2
 801edc6:	035b      	lsls	r3, r3, #13
 801edc8:	667b      	str	r3, [r7, #100]	@ 0x64
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 801edca:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801edcc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801edce:	1ad3      	subs	r3, r2, r3
 801edd0:	035b      	lsls	r3, r3, #13
 801edd2:	663b      	str	r3, [r7, #96]	@ 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 801edd4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801edd6:	3304      	adds	r3, #4
 801edd8:	681b      	ldr	r3, [r3, #0]
 801edda:	65fb      	str	r3, [r7, #92]	@ 0x5c
    z3 = (INT32) wsptr[3];
 801eddc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801edde:	330c      	adds	r3, #12
 801ede0:	681b      	ldr	r3, [r3, #0]
 801ede2:	65bb      	str	r3, [r7, #88]	@ 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 801ede4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801ede6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ede8:	4413      	add	r3, r2
 801edea:	f241 1251 	movw	r2, #4433	@ 0x1151
 801edee:	fb02 f303 	mul.w	r3, r2, r3
 801edf2:	657b      	str	r3, [r7, #84]	@ 0x54
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 801edf4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801edf6:	f641 027e 	movw	r2, #6270	@ 0x187e
 801edfa:	fb02 f303 	mul.w	r3, r2, r3
 801edfe:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801ee00:	4413      	add	r3, r2
 801ee02:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 801ee04:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ee06:	4a22      	ldr	r2, [pc, #136]	@ (801ee90 <jpeg_idct_4x4+0x238>)
 801ee08:	fb02 f303 	mul.w	r3, r2, r3
 801ee0c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801ee0e:	4413      	add	r3, r2
 801ee10:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801ee12:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801ee14:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ee16:	4413      	add	r3, r2
 801ee18:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ee1a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801ee1e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801ee20:	4413      	add	r3, r2
 801ee22:	781a      	ldrb	r2, [r3, #0]
 801ee24:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ee26:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801ee28:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801ee2a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ee2c:	1ad3      	subs	r3, r2, r3
 801ee2e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ee30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801ee34:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801ee36:	441a      	add	r2, r3
 801ee38:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ee3a:	3303      	adds	r3, #3
 801ee3c:	7812      	ldrb	r2, [r2, #0]
 801ee3e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801ee40:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801ee42:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ee44:	4413      	add	r3, r2
 801ee46:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ee48:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801ee4c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801ee4e:	441a      	add	r2, r3
 801ee50:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ee52:	3301      	adds	r3, #1
 801ee54:	7812      	ldrb	r2, [r2, #0]
 801ee56:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801ee58:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801ee5a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ee5c:	1ad3      	subs	r3, r2, r3
 801ee5e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ee60:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801ee64:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801ee66:	441a      	add	r2, r3
 801ee68:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ee6a:	3302      	adds	r3, #2
 801ee6c:	7812      	ldrb	r2, [r2, #0]
 801ee6e:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 801ee70:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ee72:	3310      	adds	r3, #16
 801ee74:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 801ee76:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ee78:	3301      	adds	r3, #1
 801ee7a:	67bb      	str	r3, [r7, #120]	@ 0x78
 801ee7c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ee7e:	2b03      	cmp	r3, #3
 801ee80:	dd8d      	ble.n	801ed9e <jpeg_idct_4x4+0x146>
  }
}
 801ee82:	bf00      	nop
 801ee84:	bf00      	nop
 801ee86:	378c      	adds	r7, #140	@ 0x8c
 801ee88:	46bd      	mov	sp, r7
 801ee8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ee8e:	4770      	bx	lr
 801ee90:	ffffc4df 	.word	0xffffc4df

0801ee94 <jpeg_idct_3x3>:

GLOBAL(void)
jpeg_idct_3x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801ee94:	b480      	push	{r7}
 801ee96:	b099      	sub	sp, #100	@ 0x64
 801ee98:	af00      	add	r7, sp, #0
 801ee9a:	60f8      	str	r0, [r7, #12]
 801ee9c:	60b9      	str	r1, [r7, #8]
 801ee9e:	607a      	str	r2, [r7, #4]
 801eea0:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp2, tmp10, tmp12;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801eea2:	68fb      	ldr	r3, [r7, #12]
 801eea4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801eea8:	3380      	adds	r3, #128	@ 0x80
 801eeaa:	64fb      	str	r3, [r7, #76]	@ 0x4c
  int workspace[3*3];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801eeac:	687b      	ldr	r3, [r7, #4]
 801eeae:	65fb      	str	r3, [r7, #92]	@ 0x5c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801eeb0:	68bb      	ldr	r3, [r7, #8]
 801eeb2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801eeb4:	65bb      	str	r3, [r7, #88]	@ 0x58
  wsptr = workspace;
 801eeb6:	f107 0314 	add.w	r3, r7, #20
 801eeba:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 801eebc:	2300      	movs	r3, #0
 801eebe:	653b      	str	r3, [r7, #80]	@ 0x50
 801eec0:	e059      	b.n	801ef76 <jpeg_idct_3x3+0xe2>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801eec2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801eec4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801eec8:	461a      	mov	r2, r3
 801eeca:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801eecc:	681b      	ldr	r3, [r3, #0]
 801eece:	fb02 f303 	mul.w	r3, r2, r3
 801eed2:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp0 <<= CONST_BITS;
 801eed4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801eed6:	035b      	lsls	r3, r3, #13
 801eed8:	647b      	str	r3, [r7, #68]	@ 0x44
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801eeda:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801eedc:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801eee0:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801eee2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801eee4:	3320      	adds	r3, #32
 801eee6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801eeea:	461a      	mov	r2, r3
 801eeec:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801eeee:	3340      	adds	r3, #64	@ 0x40
 801eef0:	681b      	ldr	r3, [r3, #0]
 801eef2:	fb02 f303 	mul.w	r3, r2, r3
 801eef6:	643b      	str	r3, [r7, #64]	@ 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 801eef8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801eefa:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801eefe:	fb02 f303 	mul.w	r3, r2, r3
 801ef02:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp10 = tmp0 + tmp12;
 801ef04:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801ef06:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ef08:	4413      	add	r3, r2
 801ef0a:	63bb      	str	r3, [r7, #56]	@ 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 801ef0c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801ef0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ef10:	1ad2      	subs	r2, r2, r3
 801ef12:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ef14:	1ad3      	subs	r3, r2, r3
 801ef16:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ef18:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ef1a:	3310      	adds	r3, #16
 801ef1c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ef20:	461a      	mov	r2, r3
 801ef22:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ef24:	3320      	adds	r3, #32
 801ef26:	681b      	ldr	r3, [r3, #0]
 801ef28:	fb02 f303 	mul.w	r3, r2, r3
 801ef2c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 801ef2e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ef30:	f242 7231 	movw	r2, #10033	@ 0x2731
 801ef34:	fb02 f303 	mul.w	r3, r2, r3
 801ef38:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801ef3a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801ef3c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ef3e:	4413      	add	r3, r2
 801ef40:	12da      	asrs	r2, r3, #11
 801ef42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef44:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801ef46:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801ef48:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ef4a:	1ad2      	subs	r2, r2, r3
 801ef4c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef4e:	3318      	adds	r3, #24
 801ef50:	12d2      	asrs	r2, r2, #11
 801ef52:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 801ef54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef56:	330c      	adds	r3, #12
 801ef58:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801ef5a:	12d2      	asrs	r2, r2, #11
 801ef5c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 801ef5e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef60:	3301      	adds	r3, #1
 801ef62:	653b      	str	r3, [r7, #80]	@ 0x50
 801ef64:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ef66:	3302      	adds	r3, #2
 801ef68:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801ef6a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ef6c:	3304      	adds	r3, #4
 801ef6e:	65bb      	str	r3, [r7, #88]	@ 0x58
 801ef70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef72:	3304      	adds	r3, #4
 801ef74:	657b      	str	r3, [r7, #84]	@ 0x54
 801ef76:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef78:	2b02      	cmp	r3, #2
 801ef7a:	dda2      	ble.n	801eec2 <jpeg_idct_3x3+0x2e>
  }

  /* Pass 2: process 3 rows from work array, store into output array. */

  wsptr = workspace;
 801ef7c:	f107 0314 	add.w	r3, r7, #20
 801ef80:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 801ef82:	2300      	movs	r3, #0
 801ef84:	653b      	str	r3, [r7, #80]	@ 0x50
 801ef86:	e053      	b.n	801f030 <jpeg_idct_3x3+0x19c>
    outptr = output_buf[ctr] + output_col;
 801ef88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef8a:	009b      	lsls	r3, r3, #2
 801ef8c:	683a      	ldr	r2, [r7, #0]
 801ef8e:	4413      	add	r3, r2
 801ef90:	681a      	ldr	r2, [r3, #0]
 801ef92:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ef94:	4413      	add	r3, r2
 801ef96:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801ef98:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef9a:	681b      	ldr	r3, [r3, #0]
 801ef9c:	3310      	adds	r3, #16
 801ef9e:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp0 <<= CONST_BITS;
 801efa0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801efa2:	035b      	lsls	r3, r3, #13
 801efa4:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp2 = (INT32) wsptr[2];
 801efa6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801efa8:	3308      	adds	r3, #8
 801efaa:	681b      	ldr	r3, [r3, #0]
 801efac:	643b      	str	r3, [r7, #64]	@ 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 801efae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801efb0:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801efb4:	fb02 f303 	mul.w	r3, r2, r3
 801efb8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp10 = tmp0 + tmp12;
 801efba:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801efbc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801efbe:	4413      	add	r3, r2
 801efc0:	63bb      	str	r3, [r7, #56]	@ 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 801efc2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801efc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801efc6:	1ad2      	subs	r2, r2, r3
 801efc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801efca:	1ad3      	subs	r3, r2, r3
 801efcc:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 801efce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801efd0:	3304      	adds	r3, #4
 801efd2:	681b      	ldr	r3, [r3, #0]
 801efd4:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 801efd6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801efd8:	f242 7231 	movw	r2, #10033	@ 0x2731
 801efdc:	fb02 f303 	mul.w	r3, r2, r3
 801efe0:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801efe2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801efe4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801efe6:	4413      	add	r3, r2
 801efe8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801efea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801efee:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801eff0:	4413      	add	r3, r2
 801eff2:	781a      	ldrb	r2, [r3, #0]
 801eff4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801eff6:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801eff8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801effa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801effc:	1ad3      	subs	r3, r2, r3
 801effe:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f000:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801f004:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801f006:	441a      	add	r2, r3
 801f008:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f00a:	3302      	adds	r3, #2
 801f00c:	7812      	ldrb	r2, [r2, #0]
 801f00e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 801f010:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f012:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f014:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 801f018:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801f01a:	441a      	add	r2, r3
 801f01c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f01e:	3301      	adds	r3, #1
 801f020:	7812      	ldrb	r2, [r2, #0]
 801f022:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 801f024:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f026:	330c      	adds	r3, #12
 801f028:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 801f02a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f02c:	3301      	adds	r3, #1
 801f02e:	653b      	str	r3, [r7, #80]	@ 0x50
 801f030:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f032:	2b02      	cmp	r3, #2
 801f034:	dda8      	ble.n	801ef88 <jpeg_idct_3x3+0xf4>
  }
}
 801f036:	bf00      	nop
 801f038:	bf00      	nop
 801f03a:	3764      	adds	r7, #100	@ 0x64
 801f03c:	46bd      	mov	sp, r7
 801f03e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f042:	4770      	bx	lr

0801f044 <jpeg_idct_2x2>:

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f044:	b480      	push	{r7}
 801f046:	b08f      	sub	sp, #60	@ 0x3c
 801f048:	af00      	add	r7, sp, #0
 801f04a:	60f8      	str	r0, [r7, #12]
 801f04c:	60b9      	str	r1, [r7, #8]
 801f04e:	607a      	str	r2, [r7, #4]
 801f050:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f052:	68fb      	ldr	r3, [r7, #12]
 801f054:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f058:	3380      	adds	r3, #128	@ 0x80
 801f05a:	637b      	str	r3, [r7, #52]	@ 0x34
  SHIFT_TEMPS

  /* Pass 1: process columns from input. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f05c:	68bb      	ldr	r3, [r7, #8]
 801f05e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f060:	633b      	str	r3, [r7, #48]	@ 0x30

  /* Column 0 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f062:	687b      	ldr	r3, [r7, #4]
 801f064:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f068:	461a      	mov	r2, r3
 801f06a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f06c:	681b      	ldr	r3, [r3, #0]
 801f06e:	fb02 f303 	mul.w	r3, r2, r3
 801f072:	62fb      	str	r3, [r7, #44]	@ 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801f074:	687b      	ldr	r3, [r7, #4]
 801f076:	3310      	adds	r3, #16
 801f078:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f07c:	461a      	mov	r2, r3
 801f07e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f080:	3320      	adds	r3, #32
 801f082:	681b      	ldr	r3, [r3, #0]
 801f084:	fb02 f303 	mul.w	r3, r2, r3
 801f088:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* Add fudge factor here for final descale. */
  tmp4 += ONE << 2;
 801f08a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f08c:	3304      	adds	r3, #4
 801f08e:	62fb      	str	r3, [r7, #44]	@ 0x2c

  tmp0 = tmp4 + tmp5;
 801f090:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f092:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f094:	4413      	add	r3, r2
 801f096:	627b      	str	r3, [r7, #36]	@ 0x24
  tmp2 = tmp4 - tmp5;
 801f098:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f09a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f09c:	1ad3      	subs	r3, r2, r3
 801f09e:	623b      	str	r3, [r7, #32]

  /* Column 1 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0+1], quantptr[DCTSIZE*0+1]);
 801f0a0:	687b      	ldr	r3, [r7, #4]
 801f0a2:	3302      	adds	r3, #2
 801f0a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0a8:	461a      	mov	r2, r3
 801f0aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f0ac:	3304      	adds	r3, #4
 801f0ae:	681b      	ldr	r3, [r3, #0]
 801f0b0:	fb02 f303 	mul.w	r3, r2, r3
 801f0b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1+1], quantptr[DCTSIZE*1+1]);
 801f0b6:	687b      	ldr	r3, [r7, #4]
 801f0b8:	3312      	adds	r3, #18
 801f0ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0be:	461a      	mov	r2, r3
 801f0c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f0c2:	3324      	adds	r3, #36	@ 0x24
 801f0c4:	681b      	ldr	r3, [r3, #0]
 801f0c6:	fb02 f303 	mul.w	r3, r2, r3
 801f0ca:	62bb      	str	r3, [r7, #40]	@ 0x28

  tmp1 = tmp4 + tmp5;
 801f0cc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f0ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f0d0:	4413      	add	r3, r2
 801f0d2:	61fb      	str	r3, [r7, #28]
  tmp3 = tmp4 - tmp5;
 801f0d4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f0d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f0d8:	1ad3      	subs	r3, r2, r3
 801f0da:	61bb      	str	r3, [r7, #24]

  /* Pass 2: process 2 rows, store into output array. */

  /* Row 0 */
  outptr = output_buf[0] + output_col;
 801f0dc:	683b      	ldr	r3, [r7, #0]
 801f0de:	681a      	ldr	r2, [r3, #0]
 801f0e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f0e2:	4413      	add	r3, r2
 801f0e4:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3) & RANGE_MASK];
 801f0e6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f0e8:	69fb      	ldr	r3, [r7, #28]
 801f0ea:	4413      	add	r3, r2
 801f0ec:	10db      	asrs	r3, r3, #3
 801f0ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f0f2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f0f4:	4413      	add	r3, r2
 801f0f6:	781a      	ldrb	r2, [r3, #0]
 801f0f8:	697b      	ldr	r3, [r7, #20]
 801f0fa:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3) & RANGE_MASK];
 801f0fc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f0fe:	69fb      	ldr	r3, [r7, #28]
 801f100:	1ad3      	subs	r3, r2, r3
 801f102:	10db      	asrs	r3, r3, #3
 801f104:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f108:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f10a:	441a      	add	r2, r3
 801f10c:	697b      	ldr	r3, [r7, #20]
 801f10e:	3301      	adds	r3, #1
 801f110:	7812      	ldrb	r2, [r2, #0]
 801f112:	701a      	strb	r2, [r3, #0]

  /* Row 1 */
  outptr = output_buf[1] + output_col;
 801f114:	683b      	ldr	r3, [r7, #0]
 801f116:	3304      	adds	r3, #4
 801f118:	681a      	ldr	r2, [r3, #0]
 801f11a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f11c:	4413      	add	r3, r2
 801f11e:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp2 + tmp3, 3) & RANGE_MASK];
 801f120:	6a3a      	ldr	r2, [r7, #32]
 801f122:	69bb      	ldr	r3, [r7, #24]
 801f124:	4413      	add	r3, r2
 801f126:	10db      	asrs	r3, r3, #3
 801f128:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f12c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f12e:	4413      	add	r3, r2
 801f130:	781a      	ldrb	r2, [r3, #0]
 801f132:	697b      	ldr	r3, [r7, #20]
 801f134:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2 - tmp3, 3) & RANGE_MASK];
 801f136:	6a3a      	ldr	r2, [r7, #32]
 801f138:	69bb      	ldr	r3, [r7, #24]
 801f13a:	1ad3      	subs	r3, r2, r3
 801f13c:	10db      	asrs	r3, r3, #3
 801f13e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f142:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f144:	441a      	add	r2, r3
 801f146:	697b      	ldr	r3, [r7, #20]
 801f148:	3301      	adds	r3, #1
 801f14a:	7812      	ldrb	r2, [r2, #0]
 801f14c:	701a      	strb	r2, [r3, #0]
}
 801f14e:	bf00      	nop
 801f150:	373c      	adds	r7, #60	@ 0x3c
 801f152:	46bd      	mov	sp, r7
 801f154:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f158:	4770      	bx	lr

0801f15a <jpeg_idct_1x1>:

GLOBAL(void)
jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f15a:	b480      	push	{r7}
 801f15c:	b089      	sub	sp, #36	@ 0x24
 801f15e:	af00      	add	r7, sp, #0
 801f160:	60f8      	str	r0, [r7, #12]
 801f162:	60b9      	str	r1, [r7, #8]
 801f164:	607a      	str	r2, [r7, #4]
 801f166:	603b      	str	r3, [r7, #0]
  int dcval;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f168:	68fb      	ldr	r3, [r7, #12]
 801f16a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f16e:	3380      	adds	r3, #128	@ 0x80
 801f170:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* 1x1 is trivial: just take the DC coefficient divided by 8. */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f172:	68bb      	ldr	r3, [r7, #8]
 801f174:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f176:	61bb      	str	r3, [r7, #24]
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
 801f178:	687b      	ldr	r3, [r7, #4]
 801f17a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f17e:	461a      	mov	r2, r3
 801f180:	69bb      	ldr	r3, [r7, #24]
 801f182:	681b      	ldr	r3, [r3, #0]
 801f184:	fb02 f303 	mul.w	r3, r2, r3
 801f188:	617b      	str	r3, [r7, #20]
  dcval = (int) DESCALE((INT32) dcval, 3);
 801f18a:	697b      	ldr	r3, [r7, #20]
 801f18c:	3304      	adds	r3, #4
 801f18e:	10db      	asrs	r3, r3, #3
 801f190:	617b      	str	r3, [r7, #20]

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
 801f192:	697b      	ldr	r3, [r7, #20]
 801f194:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f198:	69fa      	ldr	r2, [r7, #28]
 801f19a:	441a      	add	r2, r3
 801f19c:	683b      	ldr	r3, [r7, #0]
 801f19e:	6819      	ldr	r1, [r3, #0]
 801f1a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f1a2:	440b      	add	r3, r1
 801f1a4:	7812      	ldrb	r2, [r2, #0]
 801f1a6:	701a      	strb	r2, [r3, #0]
}
 801f1a8:	bf00      	nop
 801f1aa:	3724      	adds	r7, #36	@ 0x24
 801f1ac:	46bd      	mov	sp, r7
 801f1ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1b2:	4770      	bx	lr

0801f1b4 <jpeg_idct_9x9>:

GLOBAL(void)
jpeg_idct_9x9 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f1b4:	b490      	push	{r4, r7}
 801f1b6:	b0e0      	sub	sp, #384	@ 0x180
 801f1b8:	af00      	add	r7, sp, #0
 801f1ba:	f507 74c0 	add.w	r4, r7, #384	@ 0x180
 801f1be:	f5a4 74ba 	sub.w	r4, r4, #372	@ 0x174
 801f1c2:	6020      	str	r0, [r4, #0]
 801f1c4:	f507 70c0 	add.w	r0, r7, #384	@ 0x180
 801f1c8:	f5a0 70bc 	sub.w	r0, r0, #376	@ 0x178
 801f1cc:	6001      	str	r1, [r0, #0]
 801f1ce:	f507 71c0 	add.w	r1, r7, #384	@ 0x180
 801f1d2:	f5a1 71be 	sub.w	r1, r1, #380	@ 0x17c
 801f1d6:	600a      	str	r2, [r1, #0]
 801f1d8:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 801f1dc:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 801f1e0:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f1e2:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 801f1e6:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 801f1ea:	681b      	ldr	r3, [r3, #0]
 801f1ec:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f1f0:	3380      	adds	r3, #128	@ 0x80
 801f1f2:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  int workspace[8*9];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801f1f6:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 801f1fa:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 801f1fe:	681b      	ldr	r3, [r3, #0]
 801f200:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f204:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 801f208:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 801f20c:	681b      	ldr	r3, [r3, #0]
 801f20e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f210:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
  wsptr = workspace;
 801f214:	f107 0314 	add.w	r3, r7, #20
 801f218:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801f21c:	2300      	movs	r3, #0
 801f21e:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 801f222:	e1a5      	b.n	801f570 <jpeg_idct_9x9+0x3bc>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f224:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f228:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f22c:	461a      	mov	r2, r3
 801f22e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f232:	681b      	ldr	r3, [r3, #0]
 801f234:	fb02 f303 	mul.w	r3, r2, r3
 801f238:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 801f23c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f240:	035b      	lsls	r3, r3, #13
 801f242:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801f246:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f24a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801f24e:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801f252:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f256:	3320      	adds	r3, #32
 801f258:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f25c:	461a      	mov	r2, r3
 801f25e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f262:	3340      	adds	r3, #64	@ 0x40
 801f264:	681b      	ldr	r3, [r3, #0]
 801f266:	fb02 f303 	mul.w	r3, r2, r3
 801f26a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801f26e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f272:	3340      	adds	r3, #64	@ 0x40
 801f274:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f278:	461a      	mov	r2, r3
 801f27a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f27e:	3380      	adds	r3, #128	@ 0x80
 801f280:	681b      	ldr	r3, [r3, #0]
 801f282:	fb02 f303 	mul.w	r3, r2, r3
 801f286:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801f28a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f28e:	3360      	adds	r3, #96	@ 0x60
 801f290:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f294:	461a      	mov	r2, r3
 801f296:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f29a:	33c0      	adds	r3, #192	@ 0xc0
 801f29c:	681b      	ldr	r3, [r3, #0]
 801f29e:	fb02 f303 	mul.w	r3, r2, r3
 801f2a2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 801f2a6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f2aa:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801f2ae:	fb02 f303 	mul.w	r3, r2, r3
 801f2b2:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = tmp0 + tmp3;
 801f2b6:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f2ba:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f2be:	4413      	add	r3, r2
 801f2c0:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 801f2c4:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f2c8:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f2cc:	1ad2      	subs	r2, r2, r3
 801f2ce:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f2d2:	1ad3      	subs	r3, r2, r3
 801f2d4:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 801f2d8:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f2dc:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f2e0:	1ad3      	subs	r3, r2, r3
 801f2e2:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801f2e6:	fb02 f303 	mul.w	r3, r2, r3
 801f2ea:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp2 + tmp0;
 801f2ee:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f2f2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f2f6:	4413      	add	r3, r2
 801f2f8:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 801f2fc:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f300:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f304:	1ad2      	subs	r2, r2, r3
 801f306:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f30a:	1ad3      	subs	r3, r2, r3
 801f30c:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 801f310:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f314:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f318:	4413      	add	r3, r2
 801f31a:	f642 2287 	movw	r2, #10887	@ 0x2a87
 801f31e:	fb02 f303 	mul.w	r3, r2, r3
 801f322:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 801f326:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f32a:	f242 22ab 	movw	r2, #8875	@ 0x22ab
 801f32e:	fb02 f303 	mul.w	r3, r2, r3
 801f332:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 801f336:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f33a:	f240 72dc 	movw	r2, #2012	@ 0x7dc
 801f33e:	fb02 f303 	mul.w	r3, r2, r3
 801f342:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 801f346:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f34a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f34e:	441a      	add	r2, r3
 801f350:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f354:	1ad3      	subs	r3, r2, r3
 801f356:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 801f35a:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f35e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f362:	1ad3      	subs	r3, r2, r3
 801f364:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f368:	4413      	add	r3, r2
 801f36a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 801f36e:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f372:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f376:	1ad3      	subs	r3, r2, r3
 801f378:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f37c:	4413      	add	r3, r2
 801f37e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801f382:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f386:	3310      	adds	r3, #16
 801f388:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f38c:	461a      	mov	r2, r3
 801f38e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f392:	3320      	adds	r3, #32
 801f394:	681b      	ldr	r3, [r3, #0]
 801f396:	fb02 f303 	mul.w	r3, r2, r3
 801f39a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801f39e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f3a2:	3330      	adds	r3, #48	@ 0x30
 801f3a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f3a8:	461a      	mov	r2, r3
 801f3aa:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f3ae:	3360      	adds	r3, #96	@ 0x60
 801f3b0:	681b      	ldr	r3, [r3, #0]
 801f3b2:	fb02 f303 	mul.w	r3, r2, r3
 801f3b6:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801f3ba:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f3be:	3350      	adds	r3, #80	@ 0x50
 801f3c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f3c4:	461a      	mov	r2, r3
 801f3c6:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f3ca:	33a0      	adds	r3, #160	@ 0xa0
 801f3cc:	681b      	ldr	r3, [r3, #0]
 801f3ce:	fb02 f303 	mul.w	r3, r2, r3
 801f3d2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801f3d6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f3da:	3370      	adds	r3, #112	@ 0x70
 801f3dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f3e0:	461a      	mov	r2, r3
 801f3e2:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f3e6:	33e0      	adds	r3, #224	@ 0xe0
 801f3e8:	681b      	ldr	r3, [r3, #0]
 801f3ea:	fb02 f303 	mul.w	r3, r2, r3
 801f3ee:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 801f3f2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f3f6:	4a65      	ldr	r2, [pc, #404]	@ (801f58c <jpeg_idct_9x9+0x3d8>)
 801f3f8:	fb02 f303 	mul.w	r3, r2, r3
 801f3fc:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 801f400:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f404:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f408:	4413      	add	r3, r2
 801f40a:	f641 5217 	movw	r2, #7447	@ 0x1d17
 801f40e:	fb02 f303 	mul.w	r3, r2, r3
 801f412:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 801f416:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f41a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f41e:	4413      	add	r3, r2
 801f420:	f640 727a 	movw	r2, #3962	@ 0xf7a
 801f424:	fb02 f303 	mul.w	r3, r2, r3
 801f428:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp0 = tmp2 + tmp3 - z2;
 801f42c:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f430:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f434:	441a      	add	r2, r3
 801f436:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f43a:	1ad3      	subs	r3, r2, r3
 801f43c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 801f440:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f444:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f448:	1ad3      	subs	r3, r2, r3
 801f44a:	f642 4291 	movw	r2, #11409	@ 0x2c91
 801f44e:	fb02 f303 	mul.w	r3, r2, r3
 801f452:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 += z2 - tmp1;
 801f456:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801f45a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f45e:	1ad3      	subs	r3, r2, r3
 801f460:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f464:	4413      	add	r3, r2
 801f466:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 += z2 + tmp1;
 801f46a:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801f46e:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f472:	4413      	add	r3, r2
 801f474:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f478:	4413      	add	r3, r2
 801f47a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 801f47e:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f482:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f486:	1ad2      	subs	r2, r2, r3
 801f488:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f48c:	1ad3      	subs	r3, r2, r3
 801f48e:	f242 7231 	movw	r2, #10033	@ 0x2731
 801f492:	fb02 f303 	mul.w	r3, r2, r3
 801f496:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801f49a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f49e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f4a2:	4413      	add	r3, r2
 801f4a4:	12da      	asrs	r2, r3, #11
 801f4a6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f4aa:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801f4ac:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f4b0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f4b4:	1ad2      	subs	r2, r2, r3
 801f4b6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f4ba:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801f4be:	12d2      	asrs	r2, r2, #11
 801f4c0:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 801f4c2:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f4c6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f4ca:	441a      	add	r2, r3
 801f4cc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f4d0:	3320      	adds	r3, #32
 801f4d2:	12d2      	asrs	r2, r2, #11
 801f4d4:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 801f4d6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f4da:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f4de:	1ad2      	subs	r2, r2, r3
 801f4e0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f4e4:	33e0      	adds	r3, #224	@ 0xe0
 801f4e6:	12d2      	asrs	r2, r2, #11
 801f4e8:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 801f4ea:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f4ee:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f4f2:	441a      	add	r2, r3
 801f4f4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f4f8:	3340      	adds	r3, #64	@ 0x40
 801f4fa:	12d2      	asrs	r2, r2, #11
 801f4fc:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 801f4fe:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f502:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f506:	1ad2      	subs	r2, r2, r3
 801f508:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f50c:	33c0      	adds	r3, #192	@ 0xc0
 801f50e:	12d2      	asrs	r2, r2, #11
 801f510:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS-PASS1_BITS);
 801f512:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f516:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f51a:	441a      	add	r2, r3
 801f51c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f520:	3360      	adds	r3, #96	@ 0x60
 801f522:	12d2      	asrs	r2, r2, #11
 801f524:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS-PASS1_BITS);
 801f526:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f52a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f52e:	1ad2      	subs	r2, r2, r3
 801f530:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f534:	33a0      	adds	r3, #160	@ 0xa0
 801f536:	12d2      	asrs	r2, r2, #11
 801f538:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp14, CONST_BITS-PASS1_BITS);
 801f53a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f53e:	3380      	adds	r3, #128	@ 0x80
 801f540:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801f544:	12d2      	asrs	r2, r2, #11
 801f546:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801f548:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f54c:	3301      	adds	r3, #1
 801f54e:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 801f552:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801f556:	3302      	adds	r3, #2
 801f558:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
 801f55c:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801f560:	3304      	adds	r3, #4
 801f562:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 801f566:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f56a:	3304      	adds	r3, #4
 801f56c:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
 801f570:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f574:	2b07      	cmp	r3, #7
 801f576:	f77f ae55 	ble.w	801f224 <jpeg_idct_9x9+0x70>
  }

  /* Pass 2: process 9 rows from work array, store into output array. */

  wsptr = workspace;
 801f57a:	f107 0314 	add.w	r3, r7, #20
 801f57e:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 801f582:	2300      	movs	r3, #0
 801f584:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 801f588:	e19e      	b.n	801f8c8 <jpeg_idct_9x9+0x714>
 801f58a:	bf00      	nop
 801f58c:	ffffd8cf 	.word	0xffffd8cf
    outptr = output_buf[ctr] + output_col;
 801f590:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f594:	009b      	lsls	r3, r3, #2
 801f596:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 801f59a:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 801f59e:	6812      	ldr	r2, [r2, #0]
 801f5a0:	4413      	add	r3, r2
 801f5a2:	681a      	ldr	r2, [r3, #0]
 801f5a4:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801f5a8:	4413      	add	r3, r2
 801f5aa:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801f5ae:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f5b2:	681b      	ldr	r3, [r3, #0]
 801f5b4:	3310      	adds	r3, #16
 801f5b6:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 801f5ba:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f5be:	035b      	lsls	r3, r3, #13
 801f5c0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = (INT32) wsptr[2];
 801f5c4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f5c8:	3308      	adds	r3, #8
 801f5ca:	681b      	ldr	r3, [r3, #0]
 801f5cc:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[4];
 801f5d0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f5d4:	3310      	adds	r3, #16
 801f5d6:	681b      	ldr	r3, [r3, #0]
 801f5d8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = (INT32) wsptr[6];
 801f5dc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f5e0:	3318      	adds	r3, #24
 801f5e2:	681b      	ldr	r3, [r3, #0]
 801f5e4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 801f5e8:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f5ec:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801f5f0:	fb02 f303 	mul.w	r3, r2, r3
 801f5f4:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = tmp0 + tmp3;
 801f5f8:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f5fc:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f600:	4413      	add	r3, r2
 801f602:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 801f606:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f60a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f60e:	1ad2      	subs	r2, r2, r3
 801f610:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f614:	1ad3      	subs	r3, r2, r3
 801f616:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 801f61a:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f61e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f622:	1ad3      	subs	r3, r2, r3
 801f624:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 801f628:	fb02 f303 	mul.w	r3, r2, r3
 801f62c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp2 + tmp0;
 801f630:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f634:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f638:	4413      	add	r3, r2
 801f63a:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 801f63e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f642:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f646:	1ad2      	subs	r2, r2, r3
 801f648:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f64c:	1ad3      	subs	r3, r2, r3
 801f64e:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 801f652:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f656:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f65a:	4413      	add	r3, r2
 801f65c:	f642 2287 	movw	r2, #10887	@ 0x2a87
 801f660:	fb02 f303 	mul.w	r3, r2, r3
 801f664:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 801f668:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f66c:	f242 22ab 	movw	r2, #8875	@ 0x22ab
 801f670:	fb02 f303 	mul.w	r3, r2, r3
 801f674:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 801f678:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f67c:	f240 72dc 	movw	r2, #2012	@ 0x7dc
 801f680:	fb02 f303 	mul.w	r3, r2, r3
 801f684:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 801f688:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f68c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f690:	441a      	add	r2, r3
 801f692:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f696:	1ad3      	subs	r3, r2, r3
 801f698:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 801f69c:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f6a0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f6a4:	1ad3      	subs	r3, r2, r3
 801f6a6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f6aa:	4413      	add	r3, r2
 801f6ac:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 801f6b0:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 801f6b4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f6b8:	1ad3      	subs	r3, r2, r3
 801f6ba:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f6be:	4413      	add	r3, r2
 801f6c0:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801f6c4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f6c8:	3304      	adds	r3, #4
 801f6ca:	681b      	ldr	r3, [r3, #0]
 801f6cc:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[3];
 801f6d0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f6d4:	330c      	adds	r3, #12
 801f6d6:	681b      	ldr	r3, [r3, #0]
 801f6d8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = (INT32) wsptr[5];
 801f6dc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f6e0:	3314      	adds	r3, #20
 801f6e2:	681b      	ldr	r3, [r3, #0]
 801f6e4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z4 = (INT32) wsptr[7];
 801f6e8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f6ec:	331c      	adds	r3, #28
 801f6ee:	681b      	ldr	r3, [r3, #0]
 801f6f0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 801f6f4:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f6f8:	4a79      	ldr	r2, [pc, #484]	@ (801f8e0 <jpeg_idct_9x9+0x72c>)
 801f6fa:	fb02 f303 	mul.w	r3, r2, r3
 801f6fe:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 801f702:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f706:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f70a:	4413      	add	r3, r2
 801f70c:	f641 5217 	movw	r2, #7447	@ 0x1d17
 801f710:	fb02 f303 	mul.w	r3, r2, r3
 801f714:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 801f718:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f71c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f720:	4413      	add	r3, r2
 801f722:	f640 727a 	movw	r2, #3962	@ 0xf7a
 801f726:	fb02 f303 	mul.w	r3, r2, r3
 801f72a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp0 = tmp2 + tmp3 - z2;
 801f72e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f732:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f736:	441a      	add	r2, r3
 801f738:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f73c:	1ad3      	subs	r3, r2, r3
 801f73e:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 801f742:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f746:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f74a:	1ad3      	subs	r3, r2, r3
 801f74c:	f642 4291 	movw	r2, #11409	@ 0x2c91
 801f750:	fb02 f303 	mul.w	r3, r2, r3
 801f754:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 += z2 - tmp1;
 801f758:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801f75c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f760:	1ad3      	subs	r3, r2, r3
 801f762:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f766:	4413      	add	r3, r2
 801f768:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 += z2 + tmp1;
 801f76c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801f770:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f774:	4413      	add	r3, r2
 801f776:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f77a:	4413      	add	r3, r2
 801f77c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 801f780:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801f784:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f788:	1ad2      	subs	r2, r2, r3
 801f78a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f78e:	1ad3      	subs	r3, r2, r3
 801f790:	f242 7231 	movw	r2, #10033	@ 0x2731
 801f794:	fb02 f303 	mul.w	r3, r2, r3
 801f798:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801f79c:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f7a0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f7a4:	4413      	add	r3, r2
 801f7a6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f7a8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801f7ac:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f7b0:	4413      	add	r3, r2
 801f7b2:	781a      	ldrb	r2, [r3, #0]
 801f7b4:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f7b8:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801f7ba:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f7be:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801f7c2:	1ad3      	subs	r3, r2, r3
 801f7c4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f7c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801f7ca:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f7ce:	441a      	add	r2, r3
 801f7d0:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f7d4:	3308      	adds	r3, #8
 801f7d6:	7812      	ldrb	r2, [r2, #0]
 801f7d8:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801f7da:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f7de:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f7e2:	4413      	add	r3, r2
 801f7e4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f7e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801f7ea:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f7ee:	441a      	add	r2, r3
 801f7f0:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f7f4:	3301      	adds	r3, #1
 801f7f6:	7812      	ldrb	r2, [r2, #0]
 801f7f8:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801f7fa:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f7fe:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f802:	1ad3      	subs	r3, r2, r3
 801f804:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f806:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801f80a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f80e:	441a      	add	r2, r3
 801f810:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f814:	3307      	adds	r3, #7
 801f816:	7812      	ldrb	r2, [r2, #0]
 801f818:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801f81a:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f81e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f822:	4413      	add	r3, r2
 801f824:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f826:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801f82a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f82e:	441a      	add	r2, r3
 801f830:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f834:	3302      	adds	r3, #2
 801f836:	7812      	ldrb	r2, [r2, #0]
 801f838:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801f83a:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f83e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f842:	1ad3      	subs	r3, r2, r3
 801f844:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f846:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801f84a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f84e:	441a      	add	r2, r3
 801f850:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f854:	3306      	adds	r3, #6
 801f856:	7812      	ldrb	r2, [r2, #0]
 801f858:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 801f85a:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f85e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f862:	4413      	add	r3, r2
 801f864:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f866:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 801f86a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f86e:	441a      	add	r2, r3
 801f870:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f874:	3303      	adds	r3, #3
 801f876:	7812      	ldrb	r2, [r2, #0]
 801f878:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 801f87a:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f87e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f882:	1ad3      	subs	r3, r2, r3
 801f884:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f886:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 801f88a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f88e:	441a      	add	r2, r3
 801f890:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f894:	3305      	adds	r3, #5
 801f896:	7812      	ldrb	r2, [r2, #0]
 801f898:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 801f89a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801f89e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801f8a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 801f8a4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 801f8a8:	441a      	add	r2, r3
 801f8aa:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f8ae:	3304      	adds	r3, #4
 801f8b0:	7812      	ldrb	r2, [r2, #0]
 801f8b2:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801f8b4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f8b8:	3320      	adds	r3, #32
 801f8ba:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 801f8be:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f8c2:	3301      	adds	r3, #1
 801f8c4:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 801f8c8:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f8cc:	2b08      	cmp	r3, #8
 801f8ce:	f77f ae5f 	ble.w	801f590 <jpeg_idct_9x9+0x3dc>
  }
}
 801f8d2:	bf00      	nop
 801f8d4:	bf00      	nop
 801f8d6:	f507 77c0 	add.w	r7, r7, #384	@ 0x180
 801f8da:	46bd      	mov	sp, r7
 801f8dc:	bc90      	pop	{r4, r7}
 801f8de:	4770      	bx	lr
 801f8e0:	ffffd8cf 	.word	0xffffd8cf

0801f8e4 <jpeg_idct_10x10>:

GLOBAL(void)
jpeg_idct_10x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f8e4:	b490      	push	{r4, r7}
 801f8e6:	b0ea      	sub	sp, #424	@ 0x1a8
 801f8e8:	af00      	add	r7, sp, #0
 801f8ea:	f507 74d4 	add.w	r4, r7, #424	@ 0x1a8
 801f8ee:	f5a4 74ce 	sub.w	r4, r4, #412	@ 0x19c
 801f8f2:	6020      	str	r0, [r4, #0]
 801f8f4:	f507 70d4 	add.w	r0, r7, #424	@ 0x1a8
 801f8f8:	f5a0 70d0 	sub.w	r0, r0, #416	@ 0x1a0
 801f8fc:	6001      	str	r1, [r0, #0]
 801f8fe:	f507 71d4 	add.w	r1, r7, #424	@ 0x1a8
 801f902:	f5a1 71d2 	sub.w	r1, r1, #420	@ 0x1a4
 801f906:	600a      	str	r2, [r1, #0]
 801f908:	f507 72d4 	add.w	r2, r7, #424	@ 0x1a8
 801f90c:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 801f910:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f912:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 801f916:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
 801f91a:	681b      	ldr	r3, [r3, #0]
 801f91c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f920:	3380      	adds	r3, #128	@ 0x80
 801f922:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
  int workspace[8*10];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801f926:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 801f92a:	f5a3 73d2 	sub.w	r3, r3, #420	@ 0x1a4
 801f92e:	681b      	ldr	r3, [r3, #0]
 801f930:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f934:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 801f938:	f5a3 73d0 	sub.w	r3, r3, #416	@ 0x1a0
 801f93c:	681b      	ldr	r3, [r3, #0]
 801f93e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f940:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  wsptr = workspace;
 801f944:	f107 0314 	add.w	r3, r7, #20
 801f948:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801f94c:	2300      	movs	r3, #0
 801f94e:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 801f952:	e1d5      	b.n	801fd00 <jpeg_idct_10x10+0x41c>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f954:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801f958:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f95c:	461a      	mov	r2, r3
 801f95e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801f962:	681b      	ldr	r3, [r3, #0]
 801f964:	fb02 f303 	mul.w	r3, r2, r3
 801f968:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 801f96c:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801f970:	035b      	lsls	r3, r3, #13
 801f972:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 801f976:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801f97a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801f97e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801f982:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801f986:	3340      	adds	r3, #64	@ 0x40
 801f988:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f98c:	461a      	mov	r2, r3
 801f98e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801f992:	3380      	adds	r3, #128	@ 0x80
 801f994:	681b      	ldr	r3, [r3, #0]
 801f996:	fb02 f303 	mul.w	r3, r2, r3
 801f99a:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 801f99e:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801f9a2:	f242 429d 	movw	r2, #9373	@ 0x249d
 801f9a6:	fb02 f303 	mul.w	r3, r2, r3
 801f9aa:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 801f9ae:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801f9b2:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 801f9b6:	fb02 f303 	mul.w	r3, r2, r3
 801f9ba:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp10 = z3 + z1;
 801f9be:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801f9c2:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801f9c6:	4413      	add	r3, r2
 801f9c8:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = z3 - z2;
 801f9cc:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801f9d0:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801f9d4:	1ad3      	subs	r3, r2, r3
 801f9d6:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 801f9da:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801f9de:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801f9e2:	1ad3      	subs	r3, r2, r3
 801f9e4:	005b      	lsls	r3, r3, #1
 801f9e6:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801f9ea:	1ad3      	subs	r3, r2, r3
 801f9ec:	12db      	asrs	r3, r3, #11
 801f9ee:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801f9f2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801f9f6:	3320      	adds	r3, #32
 801f9f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f9fc:	461a      	mov	r2, r3
 801f9fe:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801fa02:	3340      	adds	r3, #64	@ 0x40
 801fa04:	681b      	ldr	r3, [r3, #0]
 801fa06:	fb02 f303 	mul.w	r3, r2, r3
 801fa0a:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801fa0e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801fa12:	3360      	adds	r3, #96	@ 0x60
 801fa14:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fa18:	461a      	mov	r2, r3
 801fa1a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801fa1e:	33c0      	adds	r3, #192	@ 0xc0
 801fa20:	681b      	ldr	r3, [r3, #0]
 801fa22:	fb02 f303 	mul.w	r3, r2, r3
 801fa26:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 801fa2a:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fa2e:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fa32:	4413      	add	r3, r2
 801fa34:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 801fa38:	fb02 f303 	mul.w	r3, r2, r3
 801fa3c:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 801fa40:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fa44:	f241 0271 	movw	r2, #4209	@ 0x1071
 801fa48:	fb02 f303 	mul.w	r3, r2, r3
 801fa4c:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fa50:	4413      	add	r3, r2
 801fa52:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 801fa56:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fa5a:	4ab0      	ldr	r2, [pc, #704]	@ (801fd1c <jpeg_idct_10x10+0x438>)
 801fa5c:	fb02 f303 	mul.w	r3, r2, r3
 801fa60:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fa64:	4413      	add	r3, r2
 801fa66:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp20 = tmp10 + tmp12;
 801fa6a:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 801fa6e:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fa72:	4413      	add	r3, r2
 801fa74:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp24 = tmp10 - tmp12;
 801fa78:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 801fa7c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fa80:	1ad3      	subs	r3, r2, r3
 801fa82:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp21 = tmp11 + tmp13;
 801fa86:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 801fa8a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fa8e:	4413      	add	r3, r2
 801fa90:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp23 = tmp11 - tmp13;
 801fa94:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 801fa98:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fa9c:	1ad3      	subs	r3, r2, r3
 801fa9e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801faa2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801faa6:	3310      	adds	r3, #16
 801faa8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801faac:	461a      	mov	r2, r3
 801faae:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801fab2:	3320      	adds	r3, #32
 801fab4:	681b      	ldr	r3, [r3, #0]
 801fab6:	fb02 f303 	mul.w	r3, r2, r3
 801faba:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801fabe:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801fac2:	3330      	adds	r3, #48	@ 0x30
 801fac4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fac8:	461a      	mov	r2, r3
 801faca:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801face:	3360      	adds	r3, #96	@ 0x60
 801fad0:	681b      	ldr	r3, [r3, #0]
 801fad2:	fb02 f303 	mul.w	r3, r2, r3
 801fad6:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801fada:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801fade:	3350      	adds	r3, #80	@ 0x50
 801fae0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fae4:	461a      	mov	r2, r3
 801fae6:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801faea:	33a0      	adds	r3, #160	@ 0xa0
 801faec:	681b      	ldr	r3, [r3, #0]
 801faee:	fb02 f303 	mul.w	r3, r2, r3
 801faf2:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801faf6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801fafa:	3370      	adds	r3, #112	@ 0x70
 801fafc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fb00:	461a      	mov	r2, r3
 801fb02:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801fb06:	33e0      	adds	r3, #224	@ 0xe0
 801fb08:	681b      	ldr	r3, [r3, #0]
 801fb0a:	fb02 f303 	mul.w	r3, r2, r3
 801fb0e:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp11 = z2 + z4;
 801fb12:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fb16:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fb1a:	4413      	add	r3, r2
 801fb1c:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = z2 - z4;
 801fb20:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fb24:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fb28:	1ad3      	subs	r3, r2, r3
 801fb2a:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 801fb2e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fb32:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 801fb36:	fb02 f303 	mul.w	r3, r2, r3
 801fb3a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    z5 = z3 << CONST_BITS;
 801fb3e:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fb42:	035b      	lsls	r3, r3, #13
 801fb44:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 801fb48:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801fb4c:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 801fb50:	fb02 f303 	mul.w	r3, r2, r3
 801fb54:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z5 + tmp12;
 801fb58:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801fb5c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fb60:	4413      	add	r3, r2
 801fb62:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 801fb66:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fb6a:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 801fb6e:	fb03 f202 	mul.w	r2, r3, r2
 801fb72:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fb76:	4413      	add	r3, r2
 801fb78:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801fb7c:	4413      	add	r3, r2
 801fb7e:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 801fb82:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fb86:	f240 7214 	movw	r2, #1812	@ 0x714
 801fb8a:	fb03 f202 	mul.w	r2, r3, r2
 801fb8e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fb92:	1ad3      	subs	r3, r2, r3
 801fb94:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801fb98:	4413      	add	r3, r2
 801fb9a:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 801fb9e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801fba2:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 801fba6:	fb02 f303 	mul.w	r3, r2, r3
 801fbaa:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 801fbae:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801fbb2:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fbb6:	1ad2      	subs	r2, r2, r3
 801fbb8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fbbc:	031b      	lsls	r3, r3, #12
 801fbbe:	1ad3      	subs	r3, r2, r3
 801fbc0:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 801fbc4:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fbc8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fbcc:	1ad2      	subs	r2, r2, r3
 801fbce:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fbd2:	1ad3      	subs	r3, r2, r3
 801fbd4:	009b      	lsls	r3, r3, #2
 801fbd6:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 801fbda:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fbde:	f642 0253 	movw	r2, #10323	@ 0x2853
 801fbe2:	fb03 f202 	mul.w	r2, r3, r2
 801fbe6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fbea:	1ad2      	subs	r2, r2, r3
 801fbec:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fbf0:	1ad3      	subs	r3, r2, r3
 801fbf2:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 801fbf6:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fbfa:	f241 428c 	movw	r2, #5260	@ 0x148c
 801fbfe:	fb03 f202 	mul.w	r2, r3, r2
 801fc02:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fc06:	1ad3      	subs	r3, r2, r3
 801fc08:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801fc0c:	4413      	add	r3, r2
 801fc0e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801fc12:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 801fc16:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801fc1a:	4413      	add	r3, r2
 801fc1c:	12da      	asrs	r2, r3, #11
 801fc1e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc22:	601a      	str	r2, [r3, #0]
    wsptr[8*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801fc24:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 801fc28:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801fc2c:	1ad2      	subs	r2, r2, r3
 801fc2e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc32:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 801fc36:	12d2      	asrs	r2, r2, #11
 801fc38:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801fc3a:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801fc3e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801fc42:	441a      	add	r2, r3
 801fc44:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc48:	3320      	adds	r3, #32
 801fc4a:	12d2      	asrs	r2, r2, #11
 801fc4c:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801fc4e:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801fc52:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801fc56:	1ad2      	subs	r2, r2, r3
 801fc58:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc5c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801fc60:	12d2      	asrs	r2, r2, #11
 801fc62:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp22 + tmp12);
 801fc64:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc68:	3340      	adds	r3, #64	@ 0x40
 801fc6a:	f8d7 1174 	ldr.w	r1, [r7, #372]	@ 0x174
 801fc6e:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
 801fc72:	440a      	add	r2, r1
 801fc74:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) (tmp22 - tmp12);
 801fc76:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc7a:	33e0      	adds	r3, #224	@ 0xe0
 801fc7c:	f8d7 1174 	ldr.w	r1, [r7, #372]	@ 0x174
 801fc80:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
 801fc84:	1a8a      	subs	r2, r1, r2
 801fc86:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801fc88:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801fc8c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fc90:	441a      	add	r2, r3
 801fc92:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fc96:	3360      	adds	r3, #96	@ 0x60
 801fc98:	12d2      	asrs	r2, r2, #11
 801fc9a:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801fc9c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801fca0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fca4:	1ad2      	subs	r2, r2, r3
 801fca6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fcaa:	33c0      	adds	r3, #192	@ 0xc0
 801fcac:	12d2      	asrs	r2, r2, #11
 801fcae:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801fcb0:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801fcb4:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fcb8:	441a      	add	r2, r3
 801fcba:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fcbe:	3380      	adds	r3, #128	@ 0x80
 801fcc0:	12d2      	asrs	r2, r2, #11
 801fcc2:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801fcc4:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801fcc8:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fccc:	1ad2      	subs	r2, r2, r3
 801fcce:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fcd2:	33a0      	adds	r3, #160	@ 0xa0
 801fcd4:	12d2      	asrs	r2, r2, #11
 801fcd6:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801fcd8:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 801fcdc:	3301      	adds	r3, #1
 801fcde:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 801fce2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 801fce6:	3302      	adds	r3, #2
 801fce8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
 801fcec:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 801fcf0:	3304      	adds	r3, #4
 801fcf2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
 801fcf6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fcfa:	3304      	adds	r3, #4
 801fcfc:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
 801fd00:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 801fd04:	2b07      	cmp	r3, #7
 801fd06:	f77f ae25 	ble.w	801f954 <jpeg_idct_10x10+0x70>
  }

  /* Pass 2: process 10 rows from work array, store into output array. */

  wsptr = workspace;
 801fd0a:	f107 0314 	add.w	r3, r7, #20
 801fd0e:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 801fd12:	2300      	movs	r3, #0
 801fd14:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 801fd18:	e1d4      	b.n	80200c4 <jpeg_idct_10x10+0x7e0>
 801fd1a:	bf00      	nop
 801fd1c:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 801fd20:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 801fd24:	009b      	lsls	r3, r3, #2
 801fd26:	f507 72d4 	add.w	r2, r7, #424	@ 0x1a8
 801fd2a:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 801fd2e:	6812      	ldr	r2, [r2, #0]
 801fd30:	4413      	add	r3, r2
 801fd32:	681a      	ldr	r2, [r3, #0]
 801fd34:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 801fd38:	4413      	add	r3, r2
 801fd3a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801fd3e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fd42:	681b      	ldr	r3, [r3, #0]
 801fd44:	3310      	adds	r3, #16
 801fd46:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 801fd4a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fd4e:	035b      	lsls	r3, r3, #13
 801fd50:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = (INT32) wsptr[4];
 801fd54:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fd58:	3310      	adds	r3, #16
 801fd5a:	681b      	ldr	r3, [r3, #0]
 801fd5c:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 801fd60:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fd64:	f242 429d 	movw	r2, #9373	@ 0x249d
 801fd68:	fb02 f303 	mul.w	r3, r2, r3
 801fd6c:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 801fd70:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fd74:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 801fd78:	fb02 f303 	mul.w	r3, r2, r3
 801fd7c:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp10 = z3 + z1;
 801fd80:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801fd84:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fd88:	4413      	add	r3, r2
 801fd8a:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = z3 - z2;
 801fd8e:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801fd92:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fd96:	1ad3      	subs	r3, r2, r3
 801fd98:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 801fd9c:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fda0:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fda4:	1ad3      	subs	r3, r2, r3
 801fda6:	005b      	lsls	r3, r3, #1
 801fda8:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801fdac:	1ad3      	subs	r3, r2, r3
 801fdae:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174

    z2 = (INT32) wsptr[2];
 801fdb2:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fdb6:	3308      	adds	r3, #8
 801fdb8:	681b      	ldr	r3, [r3, #0]
 801fdba:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = (INT32) wsptr[6];
 801fdbe:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fdc2:	3318      	adds	r3, #24
 801fdc4:	681b      	ldr	r3, [r3, #0]
 801fdc6:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 801fdca:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fdce:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fdd2:	4413      	add	r3, r2
 801fdd4:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 801fdd8:	fb02 f303 	mul.w	r3, r2, r3
 801fddc:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 801fde0:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fde4:	f241 0271 	movw	r2, #4209	@ 0x1071
 801fde8:	fb02 f303 	mul.w	r3, r2, r3
 801fdec:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fdf0:	4413      	add	r3, r2
 801fdf2:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 801fdf6:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fdfa:	4ab8      	ldr	r2, [pc, #736]	@ (80200dc <jpeg_idct_10x10+0x7f8>)
 801fdfc:	fb02 f303 	mul.w	r3, r2, r3
 801fe00:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801fe04:	4413      	add	r3, r2
 801fe06:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp20 = tmp10 + tmp12;
 801fe0a:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 801fe0e:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fe12:	4413      	add	r3, r2
 801fe14:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp24 = tmp10 - tmp12;
 801fe18:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 801fe1c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fe20:	1ad3      	subs	r3, r2, r3
 801fe22:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp21 = tmp11 + tmp13;
 801fe26:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 801fe2a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fe2e:	4413      	add	r3, r2
 801fe30:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp23 = tmp11 - tmp13;
 801fe34:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 801fe38:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fe3c:	1ad3      	subs	r3, r2, r3
 801fe3e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801fe42:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fe46:	3304      	adds	r3, #4
 801fe48:	681b      	ldr	r3, [r3, #0]
 801fe4a:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = (INT32) wsptr[3];
 801fe4e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fe52:	330c      	adds	r3, #12
 801fe54:	681b      	ldr	r3, [r3, #0]
 801fe56:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = (INT32) wsptr[5];
 801fe5a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fe5e:	3314      	adds	r3, #20
 801fe60:	681b      	ldr	r3, [r3, #0]
 801fe62:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 801fe66:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801fe6a:	035b      	lsls	r3, r3, #13
 801fe6c:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = (INT32) wsptr[7];
 801fe70:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 801fe74:	331c      	adds	r3, #28
 801fe76:	681b      	ldr	r3, [r3, #0]
 801fe78:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp11 = z2 + z4;
 801fe7c:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fe80:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fe84:	4413      	add	r3, r2
 801fe86:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = z2 - z4;
 801fe8a:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 801fe8e:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801fe92:	1ad3      	subs	r3, r2, r3
 801fe94:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 801fe98:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801fe9c:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 801fea0:	fb02 f303 	mul.w	r3, r2, r3
 801fea4:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 801fea8:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801feac:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 801feb0:	fb02 f303 	mul.w	r3, r2, r3
 801feb4:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z3 + tmp12;
 801feb8:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801febc:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fec0:	4413      	add	r3, r2
 801fec2:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 801fec6:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801feca:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 801fece:	fb03 f202 	mul.w	r2, r3, r2
 801fed2:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fed6:	4413      	add	r3, r2
 801fed8:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801fedc:	4413      	add	r3, r2
 801fede:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 801fee2:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801fee6:	f240 7214 	movw	r2, #1812	@ 0x714
 801feea:	fb03 f202 	mul.w	r2, r3, r2
 801feee:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801fef2:	1ad3      	subs	r3, r2, r3
 801fef4:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801fef8:	4413      	add	r3, r2
 801fefa:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 801fefe:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801ff02:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 801ff06:	fb02 f303 	mul.w	r3, r2, r3
 801ff0a:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 801ff0e:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 801ff12:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801ff16:	1ad2      	subs	r2, r2, r3
 801ff18:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ff1c:	031b      	lsls	r3, r3, #12
 801ff1e:	1ad3      	subs	r3, r2, r3
 801ff20:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 801ff24:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 801ff28:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ff2c:	1ad3      	subs	r3, r2, r3
 801ff2e:	035a      	lsls	r2, r3, #13
 801ff30:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 801ff34:	1ad3      	subs	r3, r2, r3
 801ff36:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 801ff3a:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801ff3e:	f642 0253 	movw	r2, #10323	@ 0x2853
 801ff42:	fb03 f202 	mul.w	r2, r3, r2
 801ff46:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801ff4a:	1ad2      	subs	r2, r2, r3
 801ff4c:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 801ff50:	1ad3      	subs	r3, r2, r3
 801ff52:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 801ff56:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 801ff5a:	f241 428c 	movw	r2, #5260	@ 0x148c
 801ff5e:	fb03 f202 	mul.w	r2, r3, r2
 801ff62:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801ff66:	1ad3      	subs	r3, r2, r3
 801ff68:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801ff6c:	4413      	add	r3, r2
 801ff6e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ff72:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 801ff76:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801ff7a:	4413      	add	r3, r2
 801ff7c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ff7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ff82:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 801ff86:	4413      	add	r3, r2
 801ff88:	781a      	ldrb	r2, [r3, #0]
 801ff8a:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 801ff8e:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ff90:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 801ff94:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 801ff98:	1ad3      	subs	r3, r2, r3
 801ff9a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ff9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ffa0:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 801ffa4:	441a      	add	r2, r3
 801ffa6:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 801ffaa:	3309      	adds	r3, #9
 801ffac:	7812      	ldrb	r2, [r2, #0]
 801ffae:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801ffb0:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801ffb4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801ffb8:	4413      	add	r3, r2
 801ffba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ffbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801ffc0:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 801ffc4:	441a      	add	r2, r3
 801ffc6:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 801ffca:	3301      	adds	r3, #1
 801ffcc:	7812      	ldrb	r2, [r2, #0]
 801ffce:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801ffd0:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 801ffd4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801ffd8:	1ad3      	subs	r3, r2, r3
 801ffda:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801ffdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801ffe0:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 801ffe4:	441a      	add	r2, r3
 801ffe6:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 801ffea:	3308      	adds	r3, #8
 801ffec:	7812      	ldrb	r2, [r2, #0]
 801ffee:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801fff0:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 801fff4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801fff8:	4413      	add	r3, r2
 801fffa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801fffc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8020000:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020004:	441a      	add	r2, r3
 8020006:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802000a:	3302      	adds	r3, #2
 802000c:	7812      	ldrb	r2, [r2, #0]
 802000e:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8020010:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 8020014:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8020018:	1ad3      	subs	r3, r2, r3
 802001a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802001c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8020020:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020024:	441a      	add	r2, r3
 8020026:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802002a:	3307      	adds	r3, #7
 802002c:	7812      	ldrb	r2, [r2, #0]
 802002e:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020030:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8020034:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8020038:	4413      	add	r3, r2
 802003a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802003c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020040:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020044:	441a      	add	r2, r3
 8020046:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802004a:	3303      	adds	r3, #3
 802004c:	7812      	ldrb	r2, [r2, #0]
 802004e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020050:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8020054:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8020058:	1ad3      	subs	r3, r2, r3
 802005a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802005c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020060:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020064:	441a      	add	r2, r3
 8020066:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802006a:	3306      	adds	r3, #6
 802006c:	7812      	ldrb	r2, [r2, #0]
 802006e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020070:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8020074:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8020078:	4413      	add	r3, r2
 802007a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802007c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020080:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020084:	441a      	add	r2, r3
 8020086:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802008a:	3304      	adds	r3, #4
 802008c:	7812      	ldrb	r2, [r2, #0]
 802008e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020090:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8020094:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8020098:	1ad3      	subs	r3, r2, r3
 802009a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802009c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80200a0:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80200a4:	441a      	add	r2, r3
 80200a6:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80200aa:	3305      	adds	r3, #5
 80200ac:	7812      	ldrb	r2, [r2, #0]
 80200ae:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80200b0:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 80200b4:	3320      	adds	r3, #32
 80200b6:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 80200ba:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80200be:	3301      	adds	r3, #1
 80200c0:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 80200c4:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80200c8:	2b09      	cmp	r3, #9
 80200ca:	f77f ae29 	ble.w	801fd20 <jpeg_idct_10x10+0x43c>
  }
}
 80200ce:	bf00      	nop
 80200d0:	bf00      	nop
 80200d2:	f507 77d4 	add.w	r7, r7, #424	@ 0x1a8
 80200d6:	46bd      	mov	sp, r7
 80200d8:	bc90      	pop	{r4, r7}
 80200da:	4770      	bx	lr
 80200dc:	ffffba5c 	.word	0xffffba5c

080200e0 <jpeg_idct_11x11>:

GLOBAL(void)
jpeg_idct_11x11 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80200e0:	b490      	push	{r4, r7}
 80200e2:	b0f2      	sub	sp, #456	@ 0x1c8
 80200e4:	af00      	add	r7, sp, #0
 80200e6:	f507 74e4 	add.w	r4, r7, #456	@ 0x1c8
 80200ea:	f5a4 74de 	sub.w	r4, r4, #444	@ 0x1bc
 80200ee:	6020      	str	r0, [r4, #0]
 80200f0:	f507 70e4 	add.w	r0, r7, #456	@ 0x1c8
 80200f4:	f5a0 70e0 	sub.w	r0, r0, #448	@ 0x1c0
 80200f8:	6001      	str	r1, [r0, #0]
 80200fa:	f507 71e4 	add.w	r1, r7, #456	@ 0x1c8
 80200fe:	f5a1 71e2 	sub.w	r1, r1, #452	@ 0x1c4
 8020102:	600a      	str	r2, [r1, #0]
 8020104:	f507 72e4 	add.w	r2, r7, #456	@ 0x1c8
 8020108:	f5a2 72e4 	sub.w	r2, r2, #456	@ 0x1c8
 802010c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802010e:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 8020112:	f5a3 73de 	sub.w	r3, r3, #444	@ 0x1bc
 8020116:	681b      	ldr	r3, [r3, #0]
 8020118:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802011c:	3380      	adds	r3, #128	@ 0x80
 802011e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
  int workspace[8*11];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8020122:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 8020126:	f5a3 73e2 	sub.w	r3, r3, #452	@ 0x1c4
 802012a:	681b      	ldr	r3, [r3, #0]
 802012c:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8020130:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 8020134:	f5a3 73e0 	sub.w	r3, r3, #448	@ 0x1c0
 8020138:	681b      	ldr	r3, [r3, #0]
 802013a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802013c:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
  wsptr = workspace;
 8020140:	f107 0314 	add.w	r3, r7, #20
 8020144:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020148:	2300      	movs	r3, #0
 802014a:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 802014e:	e22b      	b.n	80205a8 <jpeg_idct_11x11+0x4c8>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8020150:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020154:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020158:	461a      	mov	r2, r3
 802015a:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802015e:	681b      	ldr	r3, [r3, #0]
 8020160:	fb02 f303 	mul.w	r3, r2, r3
 8020164:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp10 <<= CONST_BITS;
 8020168:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802016c:	035b      	lsls	r3, r3, #13
 802016e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 8020172:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8020176:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802017a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802017e:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020182:	3320      	adds	r3, #32
 8020184:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020188:	461a      	mov	r2, r3
 802018a:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802018e:	3340      	adds	r3, #64	@ 0x40
 8020190:	681b      	ldr	r3, [r3, #0]
 8020192:	fb02 f303 	mul.w	r3, r2, r3
 8020196:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802019a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802019e:	3340      	adds	r3, #64	@ 0x40
 80201a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80201a4:	461a      	mov	r2, r3
 80201a6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80201aa:	3380      	adds	r3, #128	@ 0x80
 80201ac:	681b      	ldr	r3, [r3, #0]
 80201ae:	fb02 f303 	mul.w	r3, r2, r3
 80201b2:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80201b6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80201ba:	3360      	adds	r3, #96	@ 0x60
 80201bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80201c0:	461a      	mov	r2, r3
 80201c2:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80201c6:	33c0      	adds	r3, #192	@ 0xc0
 80201c8:	681b      	ldr	r3, [r3, #0]
 80201ca:	fb02 f303 	mul.w	r3, r2, r3
 80201ce:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 80201d2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80201d6:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80201da:	1ad3      	subs	r3, r2, r3
 80201dc:	f245 127e 	movw	r2, #20862	@ 0x517e
 80201e0:	fb02 f303 	mul.w	r3, r2, r3
 80201e4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 80201e8:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80201ec:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80201f0:	1ad3      	subs	r3, r2, r3
 80201f2:	f640 52c9 	movw	r2, #3529	@ 0xdc9
 80201f6:	fb02 f303 	mul.w	r3, r2, r3
 80201fa:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z4 = z1 + z3;
 80201fe:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020202:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020206:	4413      	add	r3, r2
 8020208:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 802020c:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020210:	4aec      	ldr	r2, [pc, #944]	@ (80205c4 <jpeg_idct_11x11+0x4e4>)
 8020212:	fb02 f303 	mul.w	r3, r2, r3
 8020216:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    z4 -= z2;
 802021a:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 802021e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020222:	1ad3      	subs	r3, r2, r3
 8020224:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 8020228:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802022c:	f642 326c 	movw	r2, #11116	@ 0x2b6c
 8020230:	fb02 f303 	mul.w	r3, r2, r3
 8020234:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8020238:	4413      	add	r3, r2
 802023a:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 802023e:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8020242:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8020246:	441a      	add	r2, r3
 8020248:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 802024c:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 802024e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020252:	49dd      	ldr	r1, [pc, #884]	@ (80205c8 <jpeg_idct_11x11+0x4e8>)
 8020254:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 8020258:	4413      	add	r3, r2
 802025a:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 802025e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020262:	f244 32b5 	movw	r2, #17333	@ 0x43b5
 8020266:	fb03 f202 	mul.w	r2, r3, r2
 802026a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 802026e:	4413      	add	r3, r2
 8020270:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8020274:	4413      	add	r3, r2
 8020276:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 802027a:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802027e:	4ad3      	ldr	r2, [pc, #844]	@ (80205cc <jpeg_idct_11x11+0x4ec>)
 8020280:	fb03 f202 	mul.w	r2, r3, r2
 8020284:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8020288:	4413      	add	r3, r2
 802028a:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 802028e:	4413      	add	r3, r2
 8020290:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    tmp24 += tmp25;
 8020294:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020298:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 802029c:	4413      	add	r3, r2
 802029e:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 80202a2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80202a6:	4aca      	ldr	r2, [pc, #808]	@ (80205d0 <jpeg_idct_11x11+0x4f0>)
 80202a8:	fb02 f303 	mul.w	r3, r2, r3
 80202ac:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 80202b0:	4413      	add	r3, r2
 80202b2:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 80202b6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80202ba:	f643 6239 	movw	r2, #15929	@ 0x3e39
 80202be:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 80202c2:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80202c6:	49c3      	ldr	r1, [pc, #780]	@ (80205d4 <jpeg_idct_11x11+0x4f4>)
 80202c8:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 80202cc:	4413      	add	r3, r2
 80202ce:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 80202d2:	4413      	add	r3, r2
 80202d4:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 80202d8:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80202dc:	f46f 5235 	mvn.w	r2, #11584	@ 0x2d40
 80202e0:	fb02 f303 	mul.w	r3, r2, r3
 80202e4:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80202e8:	4413      	add	r3, r2
 80202ea:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80202ee:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80202f2:	3310      	adds	r3, #16
 80202f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80202f8:	461a      	mov	r2, r3
 80202fa:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80202fe:	3320      	adds	r3, #32
 8020300:	681b      	ldr	r3, [r3, #0]
 8020302:	fb02 f303 	mul.w	r3, r2, r3
 8020306:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802030a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802030e:	3330      	adds	r3, #48	@ 0x30
 8020310:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020314:	461a      	mov	r2, r3
 8020316:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802031a:	3360      	adds	r3, #96	@ 0x60
 802031c:	681b      	ldr	r3, [r3, #0]
 802031e:	fb02 f303 	mul.w	r3, r2, r3
 8020322:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8020326:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802032a:	3350      	adds	r3, #80	@ 0x50
 802032c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020330:	461a      	mov	r2, r3
 8020332:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020336:	33a0      	adds	r3, #160	@ 0xa0
 8020338:	681b      	ldr	r3, [r3, #0]
 802033a:	fb02 f303 	mul.w	r3, r2, r3
 802033e:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8020342:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020346:	3370      	adds	r3, #112	@ 0x70
 8020348:	f9b3 3000 	ldrsh.w	r3, [r3]
 802034c:	461a      	mov	r2, r3
 802034e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020352:	33e0      	adds	r3, #224	@ 0xe0
 8020354:	681b      	ldr	r3, [r3, #0]
 8020356:	fb02 f303 	mul.w	r3, r2, r3
 802035a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    tmp11 = z1 + z2;
 802035e:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020362:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020366:	4413      	add	r3, r2
 8020368:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 802036c:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8020370:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020374:	441a      	add	r2, r3
 8020376:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802037a:	4413      	add	r3, r2
 802037c:	f44f 624c 	mov.w	r2, #3264	@ 0xcc0
 8020380:	fb02 f303 	mul.w	r3, r2, r3
 8020384:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 8020388:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802038c:	f641 426a 	movw	r2, #7274	@ 0x1c6a
 8020390:	fb02 f303 	mul.w	r3, r2, r3
 8020394:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 8020398:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 802039c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80203a0:	4413      	add	r3, r2
 80203a2:	f241 5274 	movw	r2, #5492	@ 0x1574
 80203a6:	fb02 f303 	mul.w	r3, r2, r3
 80203aa:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 80203ae:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80203b2:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80203b6:	4413      	add	r3, r2
 80203b8:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80203bc:	fb02 f303 	mul.w	r3, r2, r3
 80203c0:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80203c4:	4413      	add	r3, r2
 80203c6:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 80203ca:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 80203ce:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80203d2:	441a      	add	r2, r3
 80203d4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80203d8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 80203da:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80203de:	497e      	ldr	r1, [pc, #504]	@ (80205d8 <jpeg_idct_11x11+0x4f8>)
 80203e0:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 80203e4:	4413      	add	r3, r2
 80203e6:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 80203ea:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80203ee:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80203f2:	4413      	add	r3, r2
 80203f4:	4a79      	ldr	r2, [pc, #484]	@ (80205dc <jpeg_idct_11x11+0x4fc>)
 80203f6:	fb02 f303 	mul.w	r3, r2, r3
 80203fa:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80203fe:	4413      	add	r3, r2
 8020400:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 8020404:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020408:	f244 2258 	movw	r2, #16984	@ 0x4258
 802040c:	fb03 f202 	mul.w	r2, r3, r2
 8020410:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8020414:	4413      	add	r3, r2
 8020416:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 802041a:	4413      	add	r3, r2
 802041c:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 8020420:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020424:	4a6e      	ldr	r2, [pc, #440]	@ (80205e0 <jpeg_idct_11x11+0x500>)
 8020426:	fb03 f202 	mul.w	r2, r3, r2
 802042a:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802042e:	4413      	add	r3, r2
 8020430:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8020434:	4413      	add	r3, r2
 8020436:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 802043a:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802043e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020442:	4413      	add	r3, r2
 8020444:	4a67      	ldr	r2, [pc, #412]	@ (80205e4 <jpeg_idct_11x11+0x504>)
 8020446:	fb02 f303 	mul.w	r3, r2, r3
 802044a:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1;
 802044e:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8020452:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8020456:	4413      	add	r3, r2
 8020458:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 802045c:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020460:	f244 3247 	movw	r2, #17223	@ 0x4347
 8020464:	fb03 f202 	mul.w	r2, r3, r2
 8020468:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802046c:	4413      	add	r3, r2
 802046e:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 8020472:	4413      	add	r3, r2
 8020474:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8020478:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 802047c:	4a5a      	ldr	r2, [pc, #360]	@ (80205e8 <jpeg_idct_11x11+0x508>)
 802047e:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 8020482:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020486:	f242 010b 	movw	r1, #8203	@ 0x200b
 802048a:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 802048e:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 8020490:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020494:	4955      	ldr	r1, [pc, #340]	@ (80205ec <jpeg_idct_11x11+0x50c>)
 8020496:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 802049a:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 802049c:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80204a0:	4413      	add	r3, r2
 80204a2:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80204a6:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80204aa:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80204ae:	4413      	add	r3, r2
 80204b0:	12da      	asrs	r2, r3, #11
 80204b2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80204b6:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80204b8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80204bc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80204c0:	1ad2      	subs	r2, r2, r3
 80204c2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80204c6:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 80204ca:	12d2      	asrs	r2, r2, #11
 80204cc:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80204ce:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80204d2:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80204d6:	441a      	add	r2, r3
 80204d8:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80204dc:	3320      	adds	r3, #32
 80204de:	12d2      	asrs	r2, r2, #11
 80204e0:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 80204e2:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80204e6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80204ea:	1ad2      	subs	r2, r2, r3
 80204ec:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80204f0:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80204f4:	12d2      	asrs	r2, r2, #11
 80204f6:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 80204f8:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 80204fc:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8020500:	441a      	add	r2, r3
 8020502:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020506:	3340      	adds	r3, #64	@ 0x40
 8020508:	12d2      	asrs	r2, r2, #11
 802050a:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802050c:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8020510:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8020514:	1ad2      	subs	r2, r2, r3
 8020516:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802051a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 802051e:	12d2      	asrs	r2, r2, #11
 8020520:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8020522:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8020526:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802052a:	441a      	add	r2, r3
 802052c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020530:	3360      	adds	r3, #96	@ 0x60
 8020532:	12d2      	asrs	r2, r2, #11
 8020534:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8020536:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 802053a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802053e:	1ad2      	subs	r2, r2, r3
 8020540:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020544:	33e0      	adds	r3, #224	@ 0xe0
 8020546:	12d2      	asrs	r2, r2, #11
 8020548:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 802054a:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802054e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8020552:	441a      	add	r2, r3
 8020554:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020558:	3380      	adds	r3, #128	@ 0x80
 802055a:	12d2      	asrs	r2, r2, #11
 802055c:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802055e:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020562:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8020566:	1ad2      	subs	r2, r2, r3
 8020568:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802056c:	33c0      	adds	r3, #192	@ 0xc0
 802056e:	12d2      	asrs	r2, r2, #11
 8020570:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25, CONST_BITS-PASS1_BITS);
 8020572:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020576:	33a0      	adds	r3, #160	@ 0xa0
 8020578:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 802057c:	12d2      	asrs	r2, r2, #11
 802057e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020580:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020584:	3301      	adds	r3, #1
 8020586:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 802058a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802058e:	3302      	adds	r3, #2
 8020590:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
 8020594:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020598:	3304      	adds	r3, #4
 802059a:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
 802059e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80205a2:	3304      	adds	r3, #4
 80205a4:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
 80205a8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80205ac:	2b07      	cmp	r3, #7
 80205ae:	f77f adcf 	ble.w	8020150 <jpeg_idct_11x11+0x70>
  }

  /* Pass 2: process 11 rows from work array, store into output array. */

  wsptr = workspace;
 80205b2:	f107 0314 	add.w	r3, r7, #20
 80205b6:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 80205ba:	2300      	movs	r3, #0
 80205bc:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 80205c0:	e25a      	b.n	8020a78 <jpeg_idct_11x11+0x998>
 80205c2:	bf00      	nop
 80205c4:	ffffdb05 	.word	0xffffdb05
 80205c8:	ffffc5b4 	.word	0xffffc5b4
 80205cc:	ffffcf91 	.word	0xffffcf91
 80205d0:	ffffe6c3 	.word	0xffffe6c3
 80205d4:	ffffd37d 	.word	0xffffd37d
 80205d8:	ffffe276 	.word	0xffffe276
 80205dc:	ffffdac9 	.word	0xffffdac9
 80205e0:	ffffd9da 	.word	0xffffd9da
 80205e4:	ffffc675 	.word	0xffffc675
 80205e8:	ffffd10d 	.word	0xffffd10d
 80205ec:	ffffca16 	.word	0xffffca16
    outptr = output_buf[ctr] + output_col;
 80205f0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80205f4:	009b      	lsls	r3, r3, #2
 80205f6:	f507 72e4 	add.w	r2, r7, #456	@ 0x1c8
 80205fa:	f5a2 72e4 	sub.w	r2, r2, #456	@ 0x1c8
 80205fe:	6812      	ldr	r2, [r2, #0]
 8020600:	4413      	add	r3, r2
 8020602:	681a      	ldr	r2, [r3, #0]
 8020604:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8020608:	4413      	add	r3, r2
 802060a:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802060e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020612:	681b      	ldr	r3, [r3, #0]
 8020614:	3310      	adds	r3, #16
 8020616:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp10 <<= CONST_BITS;
 802061a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802061e:	035b      	lsls	r3, r3, #13
 8020620:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    z1 = (INT32) wsptr[2];
 8020624:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020628:	3308      	adds	r3, #8
 802062a:	681b      	ldr	r3, [r3, #0]
 802062c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = (INT32) wsptr[4];
 8020630:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020634:	3310      	adds	r3, #16
 8020636:	681b      	ldr	r3, [r3, #0]
 8020638:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = (INT32) wsptr[6];
 802063c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020640:	3318      	adds	r3, #24
 8020642:	681b      	ldr	r3, [r3, #0]
 8020644:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 8020648:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802064c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020650:	1ad3      	subs	r3, r2, r3
 8020652:	f245 127e 	movw	r2, #20862	@ 0x517e
 8020656:	fb02 f303 	mul.w	r3, r2, r3
 802065a:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 802065e:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8020662:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8020666:	1ad3      	subs	r3, r2, r3
 8020668:	f640 52c9 	movw	r2, #3529	@ 0xdc9
 802066c:	fb02 f303 	mul.w	r3, r2, r3
 8020670:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z4 = z1 + z3;
 8020674:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020678:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 802067c:	4413      	add	r3, r2
 802067e:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 8020682:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020686:	4af1      	ldr	r2, [pc, #964]	@ (8020a4c <jpeg_idct_11x11+0x96c>)
 8020688:	fb02 f303 	mul.w	r3, r2, r3
 802068c:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    z4 -= z2;
 8020690:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020694:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020698:	1ad3      	subs	r3, r2, r3
 802069a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 802069e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80206a2:	f642 326c 	movw	r2, #11116	@ 0x2b6c
 80206a6:	fb02 f303 	mul.w	r3, r2, r3
 80206aa:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80206ae:	4413      	add	r3, r2
 80206b0:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 80206b4:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80206b8:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80206bc:	441a      	add	r2, r3
 80206be:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 80206c2:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 80206c4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80206c8:	49e1      	ldr	r1, [pc, #900]	@ (8020a50 <jpeg_idct_11x11+0x970>)
 80206ca:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 80206ce:	4413      	add	r3, r2
 80206d0:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 80206d4:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80206d8:	f244 32b5 	movw	r2, #17333	@ 0x43b5
 80206dc:	fb03 f202 	mul.w	r2, r3, r2
 80206e0:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 80206e4:	4413      	add	r3, r2
 80206e6:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80206ea:	4413      	add	r3, r2
 80206ec:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 80206f0:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80206f4:	4ad7      	ldr	r2, [pc, #860]	@ (8020a54 <jpeg_idct_11x11+0x974>)
 80206f6:	fb03 f202 	mul.w	r2, r3, r2
 80206fa:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 80206fe:	4413      	add	r3, r2
 8020700:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8020704:	4413      	add	r3, r2
 8020706:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    tmp24 += tmp25;
 802070a:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802070e:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8020712:	4413      	add	r3, r2
 8020714:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 8020718:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 802071c:	4ace      	ldr	r2, [pc, #824]	@ (8020a58 <jpeg_idct_11x11+0x978>)
 802071e:	fb02 f303 	mul.w	r3, r2, r3
 8020722:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020726:	4413      	add	r3, r2
 8020728:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 802072c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8020730:	f643 6239 	movw	r2, #15929	@ 0x3e39
 8020734:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 8020738:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802073c:	49c7      	ldr	r1, [pc, #796]	@ (8020a5c <jpeg_idct_11x11+0x97c>)
 802073e:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 8020742:	4413      	add	r3, r2
 8020744:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020748:	4413      	add	r3, r2
 802074a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 802074e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020752:	f46f 5235 	mvn.w	r2, #11584	@ 0x2d40
 8020756:	fb02 f303 	mul.w	r3, r2, r3
 802075a:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 802075e:	4413      	add	r3, r2
 8020760:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8020764:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020768:	3304      	adds	r3, #4
 802076a:	681b      	ldr	r3, [r3, #0]
 802076c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = (INT32) wsptr[3];
 8020770:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020774:	330c      	adds	r3, #12
 8020776:	681b      	ldr	r3, [r3, #0]
 8020778:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = (INT32) wsptr[5];
 802077c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020780:	3314      	adds	r3, #20
 8020782:	681b      	ldr	r3, [r3, #0]
 8020784:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    z4 = (INT32) wsptr[7];
 8020788:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802078c:	331c      	adds	r3, #28
 802078e:	681b      	ldr	r3, [r3, #0]
 8020790:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    tmp11 = z1 + z2;
 8020794:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020798:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 802079c:	4413      	add	r3, r2
 802079e:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 80207a2:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 80207a6:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80207aa:	441a      	add	r2, r3
 80207ac:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80207b0:	4413      	add	r3, r2
 80207b2:	f44f 624c 	mov.w	r2, #3264	@ 0xcc0
 80207b6:	fb02 f303 	mul.w	r3, r2, r3
 80207ba:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 80207be:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80207c2:	f641 426a 	movw	r2, #7274	@ 0x1c6a
 80207c6:	fb02 f303 	mul.w	r3, r2, r3
 80207ca:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 80207ce:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80207d2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80207d6:	4413      	add	r3, r2
 80207d8:	f241 5274 	movw	r2, #5492	@ 0x1574
 80207dc:	fb02 f303 	mul.w	r3, r2, r3
 80207e0:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 80207e4:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80207e8:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80207ec:	4413      	add	r3, r2
 80207ee:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 80207f2:	fb02 f303 	mul.w	r3, r2, r3
 80207f6:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80207fa:	4413      	add	r3, r2
 80207fc:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 8020800:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8020804:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8020808:	441a      	add	r2, r3
 802080a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802080e:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 8020810:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8020814:	4992      	ldr	r1, [pc, #584]	@ (8020a60 <jpeg_idct_11x11+0x980>)
 8020816:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 802081a:	4413      	add	r3, r2
 802081c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 8020820:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8020824:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8020828:	4413      	add	r3, r2
 802082a:	4a8e      	ldr	r2, [pc, #568]	@ (8020a64 <jpeg_idct_11x11+0x984>)
 802082c:	fb02 f303 	mul.w	r3, r2, r3
 8020830:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8020834:	4413      	add	r3, r2
 8020836:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 802083a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 802083e:	f244 2258 	movw	r2, #16984	@ 0x4258
 8020842:	fb03 f202 	mul.w	r2, r3, r2
 8020846:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802084a:	4413      	add	r3, r2
 802084c:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8020850:	4413      	add	r3, r2
 8020852:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 8020856:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 802085a:	4a83      	ldr	r2, [pc, #524]	@ (8020a68 <jpeg_idct_11x11+0x988>)
 802085c:	fb03 f202 	mul.w	r2, r3, r2
 8020860:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8020864:	4413      	add	r3, r2
 8020866:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 802086a:	4413      	add	r3, r2
 802086c:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 8020870:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8020874:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020878:	4413      	add	r3, r2
 802087a:	4a7c      	ldr	r2, [pc, #496]	@ (8020a6c <jpeg_idct_11x11+0x98c>)
 802087c:	fb02 f303 	mul.w	r3, r2, r3
 8020880:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1;
 8020884:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8020888:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802088c:	4413      	add	r3, r2
 802088e:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 8020892:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020896:	f244 3247 	movw	r2, #17223	@ 0x4347
 802089a:	fb03 f202 	mul.w	r2, r3, r2
 802089e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80208a2:	4413      	add	r3, r2
 80208a4:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80208a8:	4413      	add	r3, r2
 80208aa:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 80208ae:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80208b2:	4a6f      	ldr	r2, [pc, #444]	@ (8020a70 <jpeg_idct_11x11+0x990>)
 80208b4:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 80208b8:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80208bc:	f242 010b 	movw	r1, #8203	@ 0x200b
 80208c0:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 80208c4:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 80208c6:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80208ca:	496a      	ldr	r1, [pc, #424]	@ (8020a74 <jpeg_idct_11x11+0x994>)
 80208cc:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 80208d0:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 80208d2:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80208d6:	4413      	add	r3, r2
 80208d8:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80208dc:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80208e0:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80208e4:	4413      	add	r3, r2
 80208e6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80208e8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80208ec:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80208f0:	4413      	add	r3, r2
 80208f2:	781a      	ldrb	r2, [r3, #0]
 80208f4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80208f8:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80208fa:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80208fe:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8020902:	1ad3      	subs	r3, r2, r3
 8020904:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020906:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802090a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802090e:	441a      	add	r2, r3
 8020910:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020914:	330a      	adds	r3, #10
 8020916:	7812      	ldrb	r2, [r2, #0]
 8020918:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802091a:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 802091e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8020922:	4413      	add	r3, r2
 8020924:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020926:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802092a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802092e:	441a      	add	r2, r3
 8020930:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020934:	3301      	adds	r3, #1
 8020936:	7812      	ldrb	r2, [r2, #0]
 8020938:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802093a:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 802093e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8020942:	1ad3      	subs	r3, r2, r3
 8020944:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020946:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802094a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802094e:	441a      	add	r2, r3
 8020950:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020954:	3309      	adds	r3, #9
 8020956:	7812      	ldrb	r2, [r2, #0]
 8020958:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802095a:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 802095e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8020962:	4413      	add	r3, r2
 8020964:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020966:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802096a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802096e:	441a      	add	r2, r3
 8020970:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020974:	3302      	adds	r3, #2
 8020976:	7812      	ldrb	r2, [r2, #0]
 8020978:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802097a:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 802097e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8020982:	1ad3      	subs	r3, r2, r3
 8020984:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020986:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802098a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802098e:	441a      	add	r2, r3
 8020990:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020994:	3308      	adds	r3, #8
 8020996:	7812      	ldrb	r2, [r2, #0]
 8020998:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802099a:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 802099e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80209a2:	4413      	add	r3, r2
 80209a4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80209a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80209aa:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80209ae:	441a      	add	r2, r3
 80209b0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80209b4:	3303      	adds	r3, #3
 80209b6:	7812      	ldrb	r2, [r2, #0]
 80209b8:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80209ba:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 80209be:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80209c2:	1ad3      	subs	r3, r2, r3
 80209c4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80209c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80209ca:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80209ce:	441a      	add	r2, r3
 80209d0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80209d4:	3307      	adds	r3, #7
 80209d6:	7812      	ldrb	r2, [r2, #0]
 80209d8:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80209da:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 80209de:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80209e2:	4413      	add	r3, r2
 80209e4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80209e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80209ea:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80209ee:	441a      	add	r2, r3
 80209f0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80209f4:	3304      	adds	r3, #4
 80209f6:	7812      	ldrb	r2, [r2, #0]
 80209f8:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80209fa:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 80209fe:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8020a02:	1ad3      	subs	r3, r2, r3
 8020a04:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020a06:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020a0a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8020a0e:	441a      	add	r2, r3
 8020a10:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020a14:	3306      	adds	r3, #6
 8020a16:	7812      	ldrb	r2, [r2, #0]
 8020a18:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 8020a1a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8020a1e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020a20:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 8020a24:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8020a28:	441a      	add	r2, r3
 8020a2a:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8020a2e:	3305      	adds	r3, #5
 8020a30:	7812      	ldrb	r2, [r2, #0]
 8020a32:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8020a34:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020a38:	3320      	adds	r3, #32
 8020a3a:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 8020a3e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020a42:	3301      	adds	r3, #1
 8020a44:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 8020a48:	e016      	b.n	8020a78 <jpeg_idct_11x11+0x998>
 8020a4a:	bf00      	nop
 8020a4c:	ffffdb05 	.word	0xffffdb05
 8020a50:	ffffc5b4 	.word	0xffffc5b4
 8020a54:	ffffcf91 	.word	0xffffcf91
 8020a58:	ffffe6c3 	.word	0xffffe6c3
 8020a5c:	ffffd37d 	.word	0xffffd37d
 8020a60:	ffffe276 	.word	0xffffe276
 8020a64:	ffffdac9 	.word	0xffffdac9
 8020a68:	ffffd9da 	.word	0xffffd9da
 8020a6c:	ffffc675 	.word	0xffffc675
 8020a70:	ffffd10d 	.word	0xffffd10d
 8020a74:	ffffca16 	.word	0xffffca16
 8020a78:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020a7c:	2b0a      	cmp	r3, #10
 8020a7e:	f77f adb7 	ble.w	80205f0 <jpeg_idct_11x11+0x510>
  }
}
 8020a82:	bf00      	nop
 8020a84:	bf00      	nop
 8020a86:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
 8020a8a:	46bd      	mov	sp, r7
 8020a8c:	bc90      	pop	{r4, r7}
 8020a8e:	4770      	bx	lr

08020a90 <jpeg_idct_12x12>:

GLOBAL(void)
jpeg_idct_12x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8020a90:	b490      	push	{r4, r7}
 8020a92:	b0fa      	sub	sp, #488	@ 0x1e8
 8020a94:	af00      	add	r7, sp, #0
 8020a96:	f507 74f4 	add.w	r4, r7, #488	@ 0x1e8
 8020a9a:	f5a4 74ee 	sub.w	r4, r4, #476	@ 0x1dc
 8020a9e:	6020      	str	r0, [r4, #0]
 8020aa0:	f507 70f4 	add.w	r0, r7, #488	@ 0x1e8
 8020aa4:	f5a0 70f0 	sub.w	r0, r0, #480	@ 0x1e0
 8020aa8:	6001      	str	r1, [r0, #0]
 8020aaa:	f507 71f4 	add.w	r1, r7, #488	@ 0x1e8
 8020aae:	f5a1 71f2 	sub.w	r1, r1, #484	@ 0x1e4
 8020ab2:	600a      	str	r2, [r1, #0]
 8020ab4:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
 8020ab8:	f5a2 72f4 	sub.w	r2, r2, #488	@ 0x1e8
 8020abc:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8020abe:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8020ac2:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 8020ac6:	681b      	ldr	r3, [r3, #0]
 8020ac8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8020acc:	3380      	adds	r3, #128	@ 0x80
 8020ace:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
  int workspace[8*12];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8020ad2:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8020ad6:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
 8020ada:	681b      	ldr	r3, [r3, #0]
 8020adc:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8020ae0:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8020ae4:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
 8020ae8:	681b      	ldr	r3, [r3, #0]
 8020aea:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8020aec:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
  wsptr = workspace;
 8020af0:	f107 0310 	add.w	r3, r7, #16
 8020af4:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020af8:	2300      	movs	r3, #0
 8020afa:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 8020afe:	e218      	b.n	8020f32 <jpeg_idct_12x12+0x4a2>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8020b00:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020b04:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020b08:	461a      	mov	r2, r3
 8020b0a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020b0e:	681b      	ldr	r3, [r3, #0]
 8020b10:	fb02 f303 	mul.w	r3, r2, r3
 8020b14:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z3 <<= CONST_BITS;
 8020b18:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020b1c:	035b      	lsls	r3, r3, #13
 8020b1e:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 8020b22:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020b26:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8020b2a:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8020b2e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020b32:	3340      	adds	r3, #64	@ 0x40
 8020b34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020b38:	461a      	mov	r2, r3
 8020b3a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020b3e:	3380      	adds	r3, #128	@ 0x80
 8020b40:	681b      	ldr	r3, [r3, #0]
 8020b42:	fb02 f303 	mul.w	r3, r2, r3
 8020b46:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8020b4a:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020b4e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8020b52:	fb02 f303 	mul.w	r3, r2, r3
 8020b56:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp10 = z3 + z4;
 8020b5a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020b5e:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020b62:	4413      	add	r3, r2
 8020b64:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp11 = z3 - z4;
 8020b68:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020b6c:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020b70:	1ad3      	subs	r3, r2, r3
 8020b72:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8020b76:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020b7a:	3320      	adds	r3, #32
 8020b7c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020b80:	461a      	mov	r2, r3
 8020b82:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020b86:	3340      	adds	r3, #64	@ 0x40
 8020b88:	681b      	ldr	r3, [r3, #0]
 8020b8a:	fb02 f303 	mul.w	r3, r2, r3
 8020b8e:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8020b92:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020b96:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 8020b9a:	fb02 f303 	mul.w	r3, r2, r3
 8020b9e:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z1 <<= CONST_BITS;
 8020ba2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020ba6:	035b      	lsls	r3, r3, #13
 8020ba8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8020bac:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020bb0:	3360      	adds	r3, #96	@ 0x60
 8020bb2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020bb6:	461a      	mov	r2, r3
 8020bb8:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020bbc:	33c0      	adds	r3, #192	@ 0xc0
 8020bbe:	681b      	ldr	r3, [r3, #0]
 8020bc0:	fb02 f303 	mul.w	r3, r2, r3
 8020bc4:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z2 <<= CONST_BITS;
 8020bc8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020bcc:	035b      	lsls	r3, r3, #13
 8020bce:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp12 = z1 - z2;
 8020bd2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8020bd6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020bda:	1ad3      	subs	r3, r2, r3
 8020bdc:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp21 = z3 + tmp12;
 8020be0:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020be4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020be8:	4413      	add	r3, r2
 8020bea:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp24 = z3 - tmp12;
 8020bee:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020bf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020bf6:	1ad3      	subs	r3, r2, r3
 8020bf8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    tmp12 = z4 + z2;
 8020bfc:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8020c00:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020c04:	4413      	add	r3, r2
 8020c06:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp20 = tmp10 + tmp12;
 8020c0a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8020c0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020c12:	4413      	add	r3, r2
 8020c14:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp25 = tmp10 - tmp12;
 8020c18:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8020c1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020c20:	1ad3      	subs	r3, r2, r3
 8020c22:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

    tmp12 = z4 - z1 - z2;
 8020c26:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8020c2a:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020c2e:	1ad2      	subs	r2, r2, r3
 8020c30:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020c34:	1ad3      	subs	r3, r2, r3
 8020c36:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp22 = tmp11 + tmp12;
 8020c3a:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8020c3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020c42:	4413      	add	r3, r2
 8020c44:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp23 = tmp11 - tmp12;
 8020c48:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8020c4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020c50:	1ad3      	subs	r3, r2, r3
 8020c52:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8020c56:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020c5a:	3310      	adds	r3, #16
 8020c5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020c60:	461a      	mov	r2, r3
 8020c62:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020c66:	3320      	adds	r3, #32
 8020c68:	681b      	ldr	r3, [r3, #0]
 8020c6a:	fb02 f303 	mul.w	r3, r2, r3
 8020c6e:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8020c72:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020c76:	3330      	adds	r3, #48	@ 0x30
 8020c78:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020c7c:	461a      	mov	r2, r3
 8020c7e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020c82:	3360      	adds	r3, #96	@ 0x60
 8020c84:	681b      	ldr	r3, [r3, #0]
 8020c86:	fb02 f303 	mul.w	r3, r2, r3
 8020c8a:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8020c8e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020c92:	3350      	adds	r3, #80	@ 0x50
 8020c94:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020c98:	461a      	mov	r2, r3
 8020c9a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020c9e:	33a0      	adds	r3, #160	@ 0xa0
 8020ca0:	681b      	ldr	r3, [r3, #0]
 8020ca2:	fb02 f303 	mul.w	r3, r2, r3
 8020ca6:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8020caa:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020cae:	3370      	adds	r3, #112	@ 0x70
 8020cb0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020cb4:	461a      	mov	r2, r3
 8020cb6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020cba:	33e0      	adds	r3, #224	@ 0xe0
 8020cbc:	681b      	ldr	r3, [r3, #0]
 8020cbe:	fb02 f303 	mul.w	r3, r2, r3
 8020cc2:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 8020cc6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020cca:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8020cce:	fb02 f303 	mul.w	r3, r2, r3
 8020cd2:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 8020cd6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020cda:	4a9c      	ldr	r2, [pc, #624]	@ (8020f4c <jpeg_idct_12x12+0x4bc>)
 8020cdc:	fb02 f303 	mul.w	r3, r2, r3
 8020ce0:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    tmp10 = z1 + z3;
 8020ce4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8020ce8:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020cec:	4413      	add	r3, r2
 8020cee:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 8020cf2:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8020cf6:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020cfa:	4413      	add	r3, r2
 8020cfc:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 8020d00:	fb02 f303 	mul.w	r3, r2, r3
 8020d04:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 8020d08:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020d0c:	f640 025b 	movw	r2, #2139	@ 0x85b
 8020d10:	fb02 f303 	mul.w	r3, r2, r3
 8020d14:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020d18:	4413      	add	r3, r2
 8020d1a:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 8020d1e:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8020d22:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020d26:	18d1      	adds	r1, r2, r3
 8020d28:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8020d2c:	4613      	mov	r3, r2
 8020d2e:	00db      	lsls	r3, r3, #3
 8020d30:	4413      	add	r3, r2
 8020d32:	021a      	lsls	r2, r3, #8
 8020d34:	1ad3      	subs	r3, r2, r3
 8020d36:	440b      	add	r3, r1
 8020d38:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8020d3c:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020d40:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020d44:	4413      	add	r3, r2
 8020d46:	4a82      	ldr	r2, [pc, #520]	@ (8020f50 <jpeg_idct_12x12+0x4c0>)
 8020d48:	fb02 f303 	mul.w	r3, r2, r3
 8020d4c:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8020d50:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020d54:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8020d58:	441a      	add	r2, r3
 8020d5a:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020d5e:	497d      	ldr	r1, [pc, #500]	@ (8020f54 <jpeg_idct_12x12+0x4c4>)
 8020d60:	fb01 f303 	mul.w	r3, r1, r3
 8020d64:	4413      	add	r3, r2
 8020d66:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8020d6a:	4413      	add	r3, r2
 8020d6c:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8020d70:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020d74:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020d78:	1ad2      	subs	r2, r2, r3
 8020d7a:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020d7e:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 8020d82:	fb01 f303 	mul.w	r3, r1, r3
 8020d86:	4413      	add	r3, r2
 8020d88:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8020d8c:	4413      	add	r3, r2
 8020d8e:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8020d92:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020d96:	4a70      	ldr	r2, [pc, #448]	@ (8020f58 <jpeg_idct_12x12+0x4c8>)
 8020d98:	fb03 f202 	mul.w	r2, r3, r2
 8020d9c:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8020da0:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8020da2:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020da6:	496d      	ldr	r1, [pc, #436]	@ (8020f5c <jpeg_idct_12x12+0x4cc>)
 8020da8:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8020dac:	4413      	add	r3, r2
 8020dae:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8020db2:	4413      	add	r3, r2
 8020db4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    z1 -= z4;
 8020db8:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8020dbc:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020dc0:	1ad3      	subs	r3, r2, r3
 8020dc2:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 -= z3;
 8020dc6:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8020dca:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020dce:	1ad3      	subs	r3, r2, r3
 8020dd0:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8020dd4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8020dd8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020ddc:	4413      	add	r3, r2
 8020dde:	f241 1251 	movw	r2, #4433	@ 0x1151
 8020de2:	fb02 f303 	mul.w	r3, r2, r3
 8020de6:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 8020dea:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020dee:	f641 027e 	movw	r2, #6270	@ 0x187e
 8020df2:	fb02 f303 	mul.w	r3, r2, r3
 8020df6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020dfa:	4413      	add	r3, r2
 8020dfc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 8020e00:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8020e04:	4a56      	ldr	r2, [pc, #344]	@ (8020f60 <jpeg_idct_12x12+0x4d0>)
 8020e06:	fb02 f303 	mul.w	r3, r2, r3
 8020e0a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020e0e:	4413      	add	r3, r2
 8020e10:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8020e14:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020e18:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020e1c:	4413      	add	r3, r2
 8020e1e:	12da      	asrs	r2, r3, #11
 8020e20:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e24:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8020e26:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8020e2a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8020e2e:	1ad2      	subs	r2, r2, r3
 8020e30:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e34:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8020e38:	12d2      	asrs	r2, r2, #11
 8020e3a:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8020e3c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8020e40:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020e44:	441a      	add	r2, r3
 8020e46:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e4a:	3320      	adds	r3, #32
 8020e4c:	12d2      	asrs	r2, r2, #11
 8020e4e:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8020e50:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8020e54:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8020e58:	1ad2      	subs	r2, r2, r3
 8020e5a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e5e:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8020e62:	12d2      	asrs	r2, r2, #11
 8020e64:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8020e66:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8020e6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020e6e:	441a      	add	r2, r3
 8020e70:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e74:	3340      	adds	r3, #64	@ 0x40
 8020e76:	12d2      	asrs	r2, r2, #11
 8020e78:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8020e7a:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8020e7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8020e82:	1ad2      	subs	r2, r2, r3
 8020e84:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e88:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8020e8c:	12d2      	asrs	r2, r2, #11
 8020e8e:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8020e90:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8020e94:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8020e98:	441a      	add	r2, r3
 8020e9a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020e9e:	3360      	adds	r3, #96	@ 0x60
 8020ea0:	12d2      	asrs	r2, r2, #11
 8020ea2:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8020ea4:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8020ea8:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8020eac:	1ad2      	subs	r2, r2, r3
 8020eae:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020eb2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8020eb6:	12d2      	asrs	r2, r2, #11
 8020eb8:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8020eba:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8020ebe:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8020ec2:	441a      	add	r2, r3
 8020ec4:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020ec8:	3380      	adds	r3, #128	@ 0x80
 8020eca:	12d2      	asrs	r2, r2, #11
 8020ecc:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8020ece:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8020ed2:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8020ed6:	1ad2      	subs	r2, r2, r3
 8020ed8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020edc:	33e0      	adds	r3, #224	@ 0xe0
 8020ede:	12d2      	asrs	r2, r2, #11
 8020ee0:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8020ee2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8020ee6:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020eea:	441a      	add	r2, r3
 8020eec:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020ef0:	33a0      	adds	r3, #160	@ 0xa0
 8020ef2:	12d2      	asrs	r2, r2, #11
 8020ef4:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8020ef6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8020efa:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8020efe:	1ad2      	subs	r2, r2, r3
 8020f00:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020f04:	33c0      	adds	r3, #192	@ 0xc0
 8020f06:	12d2      	asrs	r2, r2, #11
 8020f08:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020f0a:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8020f0e:	3301      	adds	r3, #1
 8020f10:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 8020f14:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8020f18:	3302      	adds	r3, #2
 8020f1a:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
 8020f1e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8020f22:	3304      	adds	r3, #4
 8020f24:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
 8020f28:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020f2c:	3304      	adds	r3, #4
 8020f2e:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
 8020f32:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8020f36:	2b07      	cmp	r3, #7
 8020f38:	f77f ade2 	ble.w	8020b00 <jpeg_idct_12x12+0x70>
  }

  /* Pass 2: process 12 rows from work array, store into output array. */

  wsptr = workspace;
 8020f3c:	f107 0310 	add.w	r3, r7, #16
 8020f40:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 8020f44:	2300      	movs	r3, #0
 8020f46:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 8020f4a:	e229      	b.n	80213a0 <jpeg_idct_12x12+0x910>
 8020f4c:	ffffeeaf 	.word	0xffffeeaf
 8020f50:	ffffde8b 	.word	0xffffde8b
 8020f54:	ffffd0b0 	.word	0xffffd0b0
 8020f58:	ffffea5c 	.word	0xffffea5c
 8020f5c:	ffffc08c 	.word	0xffffc08c
 8020f60:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 8020f64:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8020f68:	009b      	lsls	r3, r3, #2
 8020f6a:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
 8020f6e:	f5a2 72f4 	sub.w	r2, r2, #488	@ 0x1e8
 8020f72:	6812      	ldr	r2, [r2, #0]
 8020f74:	4413      	add	r3, r2
 8020f76:	681a      	ldr	r2, [r3, #0]
 8020f78:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8020f7c:	4413      	add	r3, r2
 8020f7e:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8020f82:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020f86:	681b      	ldr	r3, [r3, #0]
 8020f88:	3310      	adds	r3, #16
 8020f8a:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z3 <<= CONST_BITS;
 8020f8e:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8020f92:	035b      	lsls	r3, r3, #13
 8020f94:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

    z4 = (INT32) wsptr[4];
 8020f98:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020f9c:	3310      	adds	r3, #16
 8020f9e:	681b      	ldr	r3, [r3, #0]
 8020fa0:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8020fa4:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020fa8:	f242 7231 	movw	r2, #10033	@ 0x2731
 8020fac:	fb02 f303 	mul.w	r3, r2, r3
 8020fb0:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp10 = z3 + z4;
 8020fb4:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020fb8:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020fbc:	4413      	add	r3, r2
 8020fbe:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp11 = z3 - z4;
 8020fc2:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8020fc6:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8020fca:	1ad3      	subs	r3, r2, r3
 8020fcc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    z1 = (INT32) wsptr[2];
 8020fd0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020fd4:	3308      	adds	r3, #8
 8020fd6:	681b      	ldr	r3, [r3, #0]
 8020fd8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8020fdc:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020fe0:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 8020fe4:	fb02 f303 	mul.w	r3, r2, r3
 8020fe8:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z1 <<= CONST_BITS;
 8020fec:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8020ff0:	035b      	lsls	r3, r3, #13
 8020ff2:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = (INT32) wsptr[6];
 8020ff6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8020ffa:	3318      	adds	r3, #24
 8020ffc:	681b      	ldr	r3, [r3, #0]
 8020ffe:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z2 <<= CONST_BITS;
 8021002:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021006:	035b      	lsls	r3, r3, #13
 8021008:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp12 = z1 - z2;
 802100c:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8021010:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021014:	1ad3      	subs	r3, r2, r3
 8021016:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp21 = z3 + tmp12;
 802101a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802101e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021022:	4413      	add	r3, r2
 8021024:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp24 = z3 - tmp12;
 8021028:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802102c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021030:	1ad3      	subs	r3, r2, r3
 8021032:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    tmp12 = z4 + z2;
 8021036:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 802103a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802103e:	4413      	add	r3, r2
 8021040:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp20 = tmp10 + tmp12;
 8021044:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8021048:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802104c:	4413      	add	r3, r2
 802104e:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp25 = tmp10 - tmp12;
 8021052:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8021056:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802105a:	1ad3      	subs	r3, r2, r3
 802105c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

    tmp12 = z4 - z1 - z2;
 8021060:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8021064:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8021068:	1ad2      	subs	r2, r2, r3
 802106a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802106e:	1ad3      	subs	r3, r2, r3
 8021070:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp22 = tmp11 + tmp12;
 8021074:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8021078:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802107c:	4413      	add	r3, r2
 802107e:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp23 = tmp11 - tmp12;
 8021082:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8021086:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802108a:	1ad3      	subs	r3, r2, r3
 802108c:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8021090:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021094:	3304      	adds	r3, #4
 8021096:	681b      	ldr	r3, [r3, #0]
 8021098:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = (INT32) wsptr[3];
 802109c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80210a0:	330c      	adds	r3, #12
 80210a2:	681b      	ldr	r3, [r3, #0]
 80210a4:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = (INT32) wsptr[5];
 80210a8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80210ac:	3314      	adds	r3, #20
 80210ae:	681b      	ldr	r3, [r3, #0]
 80210b0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z4 = (INT32) wsptr[7];
 80210b4:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80210b8:	331c      	adds	r3, #28
 80210ba:	681b      	ldr	r3, [r3, #0]
 80210bc:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 80210c0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80210c4:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 80210c8:	fb02 f303 	mul.w	r3, r2, r3
 80210cc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 80210d0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80210d4:	4ab8      	ldr	r2, [pc, #736]	@ (80213b8 <jpeg_idct_12x12+0x928>)
 80210d6:	fb02 f303 	mul.w	r3, r2, r3
 80210da:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    tmp10 = z1 + z3;
 80210de:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80210e2:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80210e6:	4413      	add	r3, r2
 80210e8:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 80210ec:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80210f0:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80210f4:	4413      	add	r3, r2
 80210f6:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 80210fa:	fb02 f303 	mul.w	r3, r2, r3
 80210fe:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 8021102:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8021106:	f640 025b 	movw	r2, #2139	@ 0x85b
 802110a:	fb02 f303 	mul.w	r3, r2, r3
 802110e:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8021112:	4413      	add	r3, r2
 8021114:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 8021118:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 802111c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8021120:	18d1      	adds	r1, r2, r3
 8021122:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8021126:	4613      	mov	r3, r2
 8021128:	00db      	lsls	r3, r3, #3
 802112a:	4413      	add	r3, r2
 802112c:	021a      	lsls	r2, r3, #8
 802112e:	1ad3      	subs	r3, r2, r3
 8021130:	440b      	add	r3, r1
 8021132:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8021136:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802113a:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802113e:	4413      	add	r3, r2
 8021140:	4a9e      	ldr	r2, [pc, #632]	@ (80213bc <jpeg_idct_12x12+0x92c>)
 8021142:	fb02 f303 	mul.w	r3, r2, r3
 8021146:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 802114a:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802114e:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8021152:	441a      	add	r2, r3
 8021154:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8021158:	4999      	ldr	r1, [pc, #612]	@ (80213c0 <jpeg_idct_12x12+0x930>)
 802115a:	fb01 f303 	mul.w	r3, r1, r3
 802115e:	4413      	add	r3, r2
 8021160:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8021164:	4413      	add	r3, r2
 8021166:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 802116a:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 802116e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8021172:	1ad2      	subs	r2, r2, r3
 8021174:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8021178:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 802117c:	fb01 f303 	mul.w	r3, r1, r3
 8021180:	4413      	add	r3, r2
 8021182:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8021186:	4413      	add	r3, r2
 8021188:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802118c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8021190:	4a8c      	ldr	r2, [pc, #560]	@ (80213c4 <jpeg_idct_12x12+0x934>)
 8021192:	fb03 f202 	mul.w	r2, r3, r2
 8021196:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802119a:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 802119c:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80211a0:	4989      	ldr	r1, [pc, #548]	@ (80213c8 <jpeg_idct_12x12+0x938>)
 80211a2:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 80211a6:	4413      	add	r3, r2
 80211a8:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80211ac:	4413      	add	r3, r2
 80211ae:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    z1 -= z4;
 80211b2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80211b6:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80211ba:	1ad3      	subs	r3, r2, r3
 80211bc:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 -= z3;
 80211c0:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80211c4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80211c8:	1ad3      	subs	r3, r2, r3
 80211ca:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 80211ce:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80211d2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80211d6:	4413      	add	r3, r2
 80211d8:	f241 1251 	movw	r2, #4433	@ 0x1151
 80211dc:	fb02 f303 	mul.w	r3, r2, r3
 80211e0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 80211e4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80211e8:	f641 027e 	movw	r2, #6270	@ 0x187e
 80211ec:	fb02 f303 	mul.w	r3, r2, r3
 80211f0:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80211f4:	4413      	add	r3, r2
 80211f6:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 80211fa:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80211fe:	4a73      	ldr	r2, [pc, #460]	@ (80213cc <jpeg_idct_12x12+0x93c>)
 8021200:	fb02 f303 	mul.w	r3, r2, r3
 8021204:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8021208:	4413      	add	r3, r2
 802120a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802120e:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8021212:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8021216:	4413      	add	r3, r2
 8021218:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802121a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802121e:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021222:	4413      	add	r3, r2
 8021224:	781a      	ldrb	r2, [r3, #0]
 8021226:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802122a:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802122c:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8021230:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8021234:	1ad3      	subs	r3, r2, r3
 8021236:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021238:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802123c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021240:	441a      	add	r2, r3
 8021242:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021246:	330b      	adds	r3, #11
 8021248:	7812      	ldrb	r2, [r2, #0]
 802124a:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802124c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8021250:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8021254:	4413      	add	r3, r2
 8021256:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021258:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802125c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021260:	441a      	add	r2, r3
 8021262:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021266:	3301      	adds	r3, #1
 8021268:	7812      	ldrb	r2, [r2, #0]
 802126a:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802126c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8021270:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8021274:	1ad3      	subs	r3, r2, r3
 8021276:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021278:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802127c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021280:	441a      	add	r2, r3
 8021282:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021286:	330a      	adds	r3, #10
 8021288:	7812      	ldrb	r2, [r2, #0]
 802128a:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802128c:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8021290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021294:	4413      	add	r3, r2
 8021296:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021298:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802129c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80212a0:	441a      	add	r2, r3
 80212a2:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80212a6:	3302      	adds	r3, #2
 80212a8:	7812      	ldrb	r2, [r2, #0]
 80212aa:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80212ac:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 80212b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80212b4:	1ad3      	subs	r3, r2, r3
 80212b6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80212b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80212bc:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80212c0:	441a      	add	r2, r3
 80212c2:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80212c6:	3309      	adds	r3, #9
 80212c8:	7812      	ldrb	r2, [r2, #0]
 80212ca:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80212cc:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80212d0:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80212d4:	4413      	add	r3, r2
 80212d6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80212d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80212dc:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80212e0:	441a      	add	r2, r3
 80212e2:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80212e6:	3303      	adds	r3, #3
 80212e8:	7812      	ldrb	r2, [r2, #0]
 80212ea:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80212ec:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80212f0:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80212f4:	1ad3      	subs	r3, r2, r3
 80212f6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80212f8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80212fc:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021300:	441a      	add	r2, r3
 8021302:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021306:	3308      	adds	r3, #8
 8021308:	7812      	ldrb	r2, [r2, #0]
 802130a:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802130c:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8021310:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8021314:	4413      	add	r3, r2
 8021316:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021318:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802131c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021320:	441a      	add	r2, r3
 8021322:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021326:	3304      	adds	r3, #4
 8021328:	7812      	ldrb	r2, [r2, #0]
 802132a:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802132c:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8021330:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8021334:	1ad3      	subs	r3, r2, r3
 8021336:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021338:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802133c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021340:	441a      	add	r2, r3
 8021342:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021346:	3307      	adds	r3, #7
 8021348:	7812      	ldrb	r2, [r2, #0]
 802134a:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 802134c:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8021350:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8021354:	4413      	add	r3, r2
 8021356:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021358:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 802135c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021360:	441a      	add	r2, r3
 8021362:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021366:	3305      	adds	r3, #5
 8021368:	7812      	ldrb	r2, [r2, #0]
 802136a:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 802136c:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8021370:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8021374:	1ad3      	subs	r3, r2, r3
 8021376:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021378:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 802137c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021380:	441a      	add	r2, r3
 8021382:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8021386:	3306      	adds	r3, #6
 8021388:	7812      	ldrb	r2, [r2, #0]
 802138a:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 802138c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021390:	3320      	adds	r3, #32
 8021392:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 8021396:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 802139a:	3301      	adds	r3, #1
 802139c:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 80213a0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80213a4:	2b0b      	cmp	r3, #11
 80213a6:	f77f addd 	ble.w	8020f64 <jpeg_idct_12x12+0x4d4>
  }
}
 80213aa:	bf00      	nop
 80213ac:	bf00      	nop
 80213ae:	f507 77f4 	add.w	r7, r7, #488	@ 0x1e8
 80213b2:	46bd      	mov	sp, r7
 80213b4:	bc90      	pop	{r4, r7}
 80213b6:	4770      	bx	lr
 80213b8:	ffffeeaf 	.word	0xffffeeaf
 80213bc:	ffffde8b 	.word	0xffffde8b
 80213c0:	ffffd0b0 	.word	0xffffd0b0
 80213c4:	ffffea5c 	.word	0xffffea5c
 80213c8:	ffffc08c 	.word	0xffffc08c
 80213cc:	ffffc4df 	.word	0xffffc4df

080213d0 <jpeg_idct_13x13>:

GLOBAL(void)
jpeg_idct_13x13 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80213d0:	b490      	push	{r4, r7}
 80213d2:	f5ad 7d04 	sub.w	sp, sp, #528	@ 0x210
 80213d6:	af00      	add	r7, sp, #0
 80213d8:	f507 7404 	add.w	r4, r7, #528	@ 0x210
 80213dc:	f5a4 7401 	sub.w	r4, r4, #516	@ 0x204
 80213e0:	6020      	str	r0, [r4, #0]
 80213e2:	f507 7004 	add.w	r0, r7, #528	@ 0x210
 80213e6:	f5a0 7002 	sub.w	r0, r0, #520	@ 0x208
 80213ea:	6001      	str	r1, [r0, #0]
 80213ec:	f507 7104 	add.w	r1, r7, #528	@ 0x210
 80213f0:	f5a1 7103 	sub.w	r1, r1, #524	@ 0x20c
 80213f4:	600a      	str	r2, [r1, #0]
 80213f6:	f507 7204 	add.w	r2, r7, #528	@ 0x210
 80213fa:	f5a2 7204 	sub.w	r2, r2, #528	@ 0x210
 80213fe:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021400:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8021404:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 8021408:	681b      	ldr	r3, [r3, #0]
 802140a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802140e:	3380      	adds	r3, #128	@ 0x80
 8021410:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
  int workspace[8*13];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8021414:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8021418:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 802141c:	681b      	ldr	r3, [r3, #0]
 802141e:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021422:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8021426:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
 802142a:	681b      	ldr	r3, [r3, #0]
 802142c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802142e:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
  wsptr = workspace;
 8021432:	f107 0314 	add.w	r3, r7, #20
 8021436:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802143a:	2300      	movs	r3, #0
 802143c:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 8021440:	e299      	b.n	8021976 <jpeg_idct_13x13+0x5a6>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021442:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021446:	f9b3 3000 	ldrsh.w	r3, [r3]
 802144a:	461a      	mov	r2, r3
 802144c:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021450:	681b      	ldr	r3, [r3, #0]
 8021452:	fb02 f303 	mul.w	r3, r2, r3
 8021456:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z1 <<= CONST_BITS;
 802145a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802145e:	035b      	lsls	r3, r3, #13
 8021460:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021464:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021468:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802146c:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8021470:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021474:	3320      	adds	r3, #32
 8021476:	f9b3 3000 	ldrsh.w	r3, [r3]
 802147a:	461a      	mov	r2, r3
 802147c:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021480:	3340      	adds	r3, #64	@ 0x40
 8021482:	681b      	ldr	r3, [r3, #0]
 8021484:	fb02 f303 	mul.w	r3, r2, r3
 8021488:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802148c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021490:	3340      	adds	r3, #64	@ 0x40
 8021492:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021496:	461a      	mov	r2, r3
 8021498:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802149c:	3380      	adds	r3, #128	@ 0x80
 802149e:	681b      	ldr	r3, [r3, #0]
 80214a0:	fb02 f303 	mul.w	r3, r2, r3
 80214a4:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80214a8:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80214ac:	3360      	adds	r3, #96	@ 0x60
 80214ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 80214b2:	461a      	mov	r2, r3
 80214b4:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80214b8:	33c0      	adds	r3, #192	@ 0xc0
 80214ba:	681b      	ldr	r3, [r3, #0]
 80214bc:	fb02 f303 	mul.w	r3, r2, r3
 80214c0:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp10 = z3 + z4;
 80214c4:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80214c8:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80214cc:	4413      	add	r3, r2
 80214ce:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp11 = z3 - z4;
 80214d2:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80214d6:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80214da:	1ad3      	subs	r3, r2, r3
 80214dc:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 80214e0:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 80214e4:	f242 42f9 	movw	r2, #9465	@ 0x24f9
 80214e8:	fb02 f303 	mul.w	r3, r2, r3
 80214ec:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 80214f0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 80214f4:	f240 3219 	movw	r2, #793	@ 0x319
 80214f8:	fb02 f303 	mul.w	r3, r2, r3
 80214fc:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021500:	4413      	add	r3, r2
 8021502:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 8021506:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802150a:	f642 32f1 	movw	r2, #11249	@ 0x2bf1
 802150e:	fb03 f202 	mul.w	r2, r3, r2
 8021512:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021516:	4413      	add	r3, r2
 8021518:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802151c:	4413      	add	r3, r2
 802151e:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 8021522:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021526:	f241 020c 	movw	r2, #4108	@ 0x100c
 802152a:	fb03 f202 	mul.w	r2, r3, r2
 802152e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021532:	1ad3      	subs	r3, r2, r3
 8021534:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021538:	4413      	add	r3, r2
 802153a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 802153e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021542:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
 8021546:	fb02 f303 	mul.w	r3, r2, r3
 802154a:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 802154e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021552:	f640 7295 	movw	r2, #3989	@ 0xf95
 8021556:	fb02 f303 	mul.w	r3, r2, r3
 802155a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802155e:	4413      	add	r3, r2
 8021560:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 8021564:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021568:	f242 12e0 	movw	r2, #8672	@ 0x21e0
 802156c:	fb03 f202 	mul.w	r2, r3, r2
 8021570:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021574:	1ad3      	subs	r3, r2, r3
 8021576:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802157a:	4413      	add	r3, r2
 802157c:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 8021580:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021584:	4af0      	ldr	r2, [pc, #960]	@ (8021948 <jpeg_idct_13x13+0x578>)
 8021586:	fb03 f202 	mul.w	r2, r3, r2
 802158a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802158e:	4413      	add	r3, r2
 8021590:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021594:	4413      	add	r3, r2
 8021596:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 802159a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802159e:	f640 52f2 	movw	r2, #3570	@ 0xdf2
 80215a2:	fb02 f303 	mul.w	r3, r2, r3
 80215a6:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 80215aa:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 80215ae:	f641 52fe 	movw	r2, #7678	@ 0x1dfe
 80215b2:	fb03 f202 	mul.w	r2, r3, r2
 80215b6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80215ba:	1ad3      	subs	r3, r2, r3
 80215bc:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 80215c0:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80215c4:	4ae1      	ldr	r2, [pc, #900]	@ (802194c <jpeg_idct_13x13+0x57c>)
 80215c6:	fb03 f202 	mul.w	r2, r3, r2
 80215ca:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80215ce:	1ad2      	subs	r2, r2, r3
 80215d0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80215d4:	1ad3      	subs	r3, r2, r3
 80215d6:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 80215da:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80215de:	4adc      	ldr	r2, [pc, #880]	@ (8021950 <jpeg_idct_13x13+0x580>)
 80215e0:	fb03 f202 	mul.w	r2, r3, r2
 80215e4:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80215e8:	441a      	add	r2, r3
 80215ea:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80215ee:	1ad3      	subs	r3, r2, r3
 80215f0:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 80215f4:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80215f8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80215fc:	1ad3      	subs	r3, r2, r3
 80215fe:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8021602:	fb02 f303 	mul.w	r3, r2, r3
 8021606:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802160a:	4413      	add	r3, r2
 802160c:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8021610:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021614:	3310      	adds	r3, #16
 8021616:	f9b3 3000 	ldrsh.w	r3, [r3]
 802161a:	461a      	mov	r2, r3
 802161c:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021620:	3320      	adds	r3, #32
 8021622:	681b      	ldr	r3, [r3, #0]
 8021624:	fb02 f303 	mul.w	r3, r2, r3
 8021628:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802162c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021630:	3330      	adds	r3, #48	@ 0x30
 8021632:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021636:	461a      	mov	r2, r3
 8021638:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802163c:	3360      	adds	r3, #96	@ 0x60
 802163e:	681b      	ldr	r3, [r3, #0]
 8021640:	fb02 f303 	mul.w	r3, r2, r3
 8021644:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8021648:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802164c:	3350      	adds	r3, #80	@ 0x50
 802164e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021652:	461a      	mov	r2, r3
 8021654:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021658:	33a0      	adds	r3, #160	@ 0xa0
 802165a:	681b      	ldr	r3, [r3, #0]
 802165c:	fb02 f303 	mul.w	r3, r2, r3
 8021660:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8021664:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021668:	3370      	adds	r3, #112	@ 0x70
 802166a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802166e:	461a      	mov	r2, r3
 8021670:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021674:	33e0      	adds	r3, #224	@ 0xe0
 8021676:	681b      	ldr	r3, [r3, #0]
 8021678:	fb02 f303 	mul.w	r3, r2, r3
 802167c:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 8021680:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021684:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021688:	4413      	add	r3, r2
 802168a:	f642 2250 	movw	r2, #10832	@ 0x2a50
 802168e:	fb02 f303 	mul.w	r3, r2, r3
 8021692:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 8021696:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802169a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802169e:	4413      	add	r3, r2
 80216a0:	f242 523e 	movw	r2, #9534	@ 0x253e
 80216a4:	fb02 f303 	mul.w	r3, r2, r3
 80216a8:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp15 = z1 + z4;
 80216ac:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 80216b0:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80216b4:	4413      	add	r3, r2
 80216b6:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 80216ba:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80216be:	f641 6202 	movw	r2, #7682	@ 0x1e02
 80216c2:	fb02 f303 	mul.w	r3, r2, r3
 80216c6:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 80216ca:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80216ce:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80216d2:	441a      	add	r2, r3
 80216d4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80216d8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 80216da:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80216de:	499d      	ldr	r1, [pc, #628]	@ (8021954 <jpeg_idct_13x13+0x584>)
 80216e0:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 80216e4:	4413      	add	r3, r2
 80216e6:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 80216ea:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 80216ee:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80216f2:	4413      	add	r3, r2
 80216f4:	4a98      	ldr	r2, [pc, #608]	@ (8021958 <jpeg_idct_13x13+0x588>)
 80216f6:	fb02 f303 	mul.w	r3, r2, r3
 80216fa:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 80216fe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021702:	f641 22cb 	movw	r2, #6859	@ 0x1acb
 8021706:	fb03 f202 	mul.w	r2, r3, r2
 802170a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802170e:	4413      	add	r3, r2
 8021710:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8021714:	4413      	add	r3, r2
 8021716:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 802171a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802171e:	4a8f      	ldr	r2, [pc, #572]	@ (802195c <jpeg_idct_13x13+0x58c>)
 8021720:	fb03 f202 	mul.w	r2, r3, r2
 8021724:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021728:	4413      	add	r3, r2
 802172a:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 802172e:	4413      	add	r3, r2
 8021730:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 8021734:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8021738:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802173c:	4413      	add	r3, r2
 802173e:	4a88      	ldr	r2, [pc, #544]	@ (8021960 <jpeg_idct_13x13+0x590>)
 8021740:	fb02 f303 	mul.w	r3, r2, r3
 8021744:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14;
 8021748:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 802174c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021750:	4413      	add	r3, r2
 8021752:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 8021756:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802175a:	f244 6294 	movw	r2, #18068	@ 0x4694
 802175e:	fb03 f202 	mul.w	r2, r3, r2
 8021762:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021766:	4413      	add	r3, r2
 8021768:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802176c:	4413      	add	r3, r2
 802176e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 8021772:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8021776:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802177a:	4413      	add	r3, r2
 802177c:	4a79      	ldr	r2, [pc, #484]	@ (8021964 <jpeg_idct_13x13+0x594>)
 802177e:	fb02 f303 	mul.w	r3, r2, r3
 8021782:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp12 += tmp14;
 8021786:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 802178a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802178e:	4413      	add	r3, r2
 8021790:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 += tmp14;
 8021794:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021798:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802179c:	4413      	add	r3, r2
 802179e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 80217a2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80217a6:	f640 22d5 	movw	r2, #2773	@ 0xad5
 80217aa:	fb02 f303 	mul.w	r3, r2, r3
 80217ae:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 80217b2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80217b6:	f640 2233 	movw	r2, #2611	@ 0xa33
 80217ba:	fb03 f202 	mul.w	r2, r3, r2
 80217be:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80217c2:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 80217c4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80217c8:	4967      	ldr	r1, [pc, #412]	@ (8021968 <jpeg_idct_13x13+0x598>)
 80217ca:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 80217ce:	4413      	add	r3, r2
 80217d0:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 80217d4:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80217d8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80217dc:	1ad3      	subs	r3, r2, r3
 80217de:	f641 6202 	movw	r2, #7682	@ 0x1e02
 80217e2:	fb02 f303 	mul.w	r3, r2, r3
 80217e6:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += z1;
 80217ea:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80217ee:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80217f2:	4413      	add	r3, r2
 80217f4:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 80217f8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80217fc:	f640 424e 	movw	r2, #3150	@ 0xc4e
 8021800:	fb03 f202 	mul.w	r2, r3, r2
 8021804:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021808:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 802180a:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802180e:	f46f 515f 	mvn.w	r1, #14272	@ 0x37c0
 8021812:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 8021816:	4413      	add	r3, r2
 8021818:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 802181c:	4413      	add	r3, r2
 802181e:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8021822:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021826:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802182a:	4413      	add	r3, r2
 802182c:	12da      	asrs	r2, r3, #11
 802182e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021832:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8021834:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021838:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802183c:	1ad2      	subs	r2, r2, r3
 802183e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021842:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8021846:	12d2      	asrs	r2, r2, #11
 8021848:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 802184a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802184e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021852:	441a      	add	r2, r3
 8021854:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021858:	3320      	adds	r3, #32
 802185a:	12d2      	asrs	r2, r2, #11
 802185c:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802185e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8021862:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021866:	1ad2      	subs	r2, r2, r3
 8021868:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 802186c:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8021870:	12d2      	asrs	r2, r2, #11
 8021872:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8021874:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8021878:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802187c:	441a      	add	r2, r3
 802187e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021882:	3340      	adds	r3, #64	@ 0x40
 8021884:	12d2      	asrs	r2, r2, #11
 8021886:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8021888:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 802188c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021890:	1ad2      	subs	r2, r2, r3
 8021892:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021896:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 802189a:	12d2      	asrs	r2, r2, #11
 802189c:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802189e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80218a2:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80218a6:	441a      	add	r2, r3
 80218a8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80218ac:	3360      	adds	r3, #96	@ 0x60
 80218ae:	12d2      	asrs	r2, r2, #11
 80218b0:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 80218b2:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80218b6:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80218ba:	1ad2      	subs	r2, r2, r3
 80218bc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80218c0:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80218c4:	12d2      	asrs	r2, r2, #11
 80218c6:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 80218c8:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 80218cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80218d0:	441a      	add	r2, r3
 80218d2:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80218d6:	3380      	adds	r3, #128	@ 0x80
 80218d8:	12d2      	asrs	r2, r2, #11
 80218da:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 80218dc:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 80218e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80218e4:	1ad2      	subs	r2, r2, r3
 80218e6:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80218ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80218ee:	12d2      	asrs	r2, r2, #11
 80218f0:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 80218f2:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 80218f6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80218fa:	441a      	add	r2, r3
 80218fc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021900:	33a0      	adds	r3, #160	@ 0xa0
 8021902:	12d2      	asrs	r2, r2, #11
 8021904:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8021906:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 802190a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802190e:	1ad2      	subs	r2, r2, r3
 8021910:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021914:	33e0      	adds	r3, #224	@ 0xe0
 8021916:	12d2      	asrs	r2, r2, #11
 8021918:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26, CONST_BITS-PASS1_BITS);
 802191a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 802191e:	33c0      	adds	r3, #192	@ 0xc0
 8021920:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8021924:	12d2      	asrs	r2, r2, #11
 8021926:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021928:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 802192c:	3301      	adds	r3, #1
 802192e:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 8021932:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021936:	3302      	adds	r3, #2
 8021938:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
 802193c:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021940:	3304      	adds	r3, #4
 8021942:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
 8021946:	e011      	b.n	802196c <jpeg_idct_13x13+0x59c>
 8021948:	ffffd7ee 	.word	0xffffd7ee
 802194c:	fffffa8c 	.word	0xfffffa8c
 8021950:	ffffe64b 	.word	0xffffe64b
 8021954:	ffffbf5b 	.word	0xffffbf5b
 8021958:	fffff52b 	.word	0xfffff52b
 802195c:	ffffcdb1 	.word	0xffffcdb1
 8021960:	ffffdac2 	.word	0xffffdac2
 8021964:	ffffeaf8 	.word	0xffffeaf8
 8021968:	fffff116 	.word	0xfffff116
 802196c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021970:	3304      	adds	r3, #4
 8021972:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
 8021976:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 802197a:	2b07      	cmp	r3, #7
 802197c:	f77f ad61 	ble.w	8021442 <jpeg_idct_13x13+0x72>
  }

  /* Pass 2: process 13 rows from work array, store into output array. */

  wsptr = workspace;
 8021980:	f107 0314 	add.w	r3, r7, #20
 8021984:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 8021988:	2300      	movs	r3, #0
 802198a:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 802198e:	e2a4      	b.n	8021eda <jpeg_idct_13x13+0xb0a>
    outptr = output_buf[ctr] + output_col;
 8021990:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8021994:	009b      	lsls	r3, r3, #2
 8021996:	f507 7204 	add.w	r2, r7, #528	@ 0x210
 802199a:	f5a2 7204 	sub.w	r2, r2, #528	@ 0x210
 802199e:	6812      	ldr	r2, [r2, #0]
 80219a0:	4413      	add	r3, r2
 80219a2:	681a      	ldr	r2, [r3, #0]
 80219a4:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80219a8:	4413      	add	r3, r2
 80219aa:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80219ae:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80219b2:	681b      	ldr	r3, [r3, #0]
 80219b4:	3310      	adds	r3, #16
 80219b6:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z1 <<= CONST_BITS;
 80219ba:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80219be:	035b      	lsls	r3, r3, #13
 80219c0:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    z2 = (INT32) wsptr[2];
 80219c4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80219c8:	3308      	adds	r3, #8
 80219ca:	681b      	ldr	r3, [r3, #0]
 80219cc:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = (INT32) wsptr[4];
 80219d0:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80219d4:	3310      	adds	r3, #16
 80219d6:	681b      	ldr	r3, [r3, #0]
 80219d8:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = (INT32) wsptr[6];
 80219dc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80219e0:	3318      	adds	r3, #24
 80219e2:	681b      	ldr	r3, [r3, #0]
 80219e4:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp10 = z3 + z4;
 80219e8:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80219ec:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80219f0:	4413      	add	r3, r2
 80219f2:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp11 = z3 - z4;
 80219f6:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80219fa:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80219fe:	1ad3      	subs	r3, r2, r3
 8021a00:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 8021a04:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021a08:	f242 42f9 	movw	r2, #9465	@ 0x24f9
 8021a0c:	fb02 f303 	mul.w	r3, r2, r3
 8021a10:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 8021a14:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021a18:	f240 3219 	movw	r2, #793	@ 0x319
 8021a1c:	fb02 f303 	mul.w	r3, r2, r3
 8021a20:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021a24:	4413      	add	r3, r2
 8021a26:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 8021a2a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021a2e:	f642 32f1 	movw	r2, #11249	@ 0x2bf1
 8021a32:	fb03 f202 	mul.w	r2, r3, r2
 8021a36:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021a3a:	4413      	add	r3, r2
 8021a3c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021a40:	4413      	add	r3, r2
 8021a42:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 8021a46:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021a4a:	f241 020c 	movw	r2, #4108	@ 0x100c
 8021a4e:	fb03 f202 	mul.w	r2, r3, r2
 8021a52:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021a56:	1ad3      	subs	r3, r2, r3
 8021a58:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021a5c:	4413      	add	r3, r2
 8021a5e:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 8021a62:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021a66:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
 8021a6a:	fb02 f303 	mul.w	r3, r2, r3
 8021a6e:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 8021a72:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021a76:	f640 7295 	movw	r2, #3989	@ 0xf95
 8021a7a:	fb02 f303 	mul.w	r3, r2, r3
 8021a7e:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021a82:	4413      	add	r3, r2
 8021a84:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 8021a88:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021a8c:	f242 12e0 	movw	r2, #8672	@ 0x21e0
 8021a90:	fb03 f202 	mul.w	r2, r3, r2
 8021a94:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021a98:	1ad3      	subs	r3, r2, r3
 8021a9a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021a9e:	4413      	add	r3, r2
 8021aa0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 8021aa4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021aa8:	4af2      	ldr	r2, [pc, #968]	@ (8021e74 <jpeg_idct_13x13+0xaa4>)
 8021aaa:	fb03 f202 	mul.w	r2, r3, r2
 8021aae:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021ab2:	4413      	add	r3, r2
 8021ab4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021ab8:	4413      	add	r3, r2
 8021aba:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 8021abe:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021ac2:	f640 52f2 	movw	r2, #3570	@ 0xdf2
 8021ac6:	fb02 f303 	mul.w	r3, r2, r3
 8021aca:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 8021ace:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021ad2:	f641 52fe 	movw	r2, #7678	@ 0x1dfe
 8021ad6:	fb03 f202 	mul.w	r2, r3, r2
 8021ada:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021ade:	1ad3      	subs	r3, r2, r3
 8021ae0:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 8021ae4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021ae8:	4ae3      	ldr	r2, [pc, #908]	@ (8021e78 <jpeg_idct_13x13+0xaa8>)
 8021aea:	fb03 f202 	mul.w	r2, r3, r2
 8021aee:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021af2:	1ad2      	subs	r2, r2, r3
 8021af4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8021af8:	1ad3      	subs	r3, r2, r3
 8021afa:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 8021afe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021b02:	4ade      	ldr	r2, [pc, #888]	@ (8021e7c <jpeg_idct_13x13+0xaac>)
 8021b04:	fb03 f202 	mul.w	r2, r3, r2
 8021b08:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021b0c:	441a      	add	r2, r3
 8021b0e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8021b12:	1ad3      	subs	r3, r2, r3
 8021b14:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 8021b18:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8021b1c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021b20:	1ad3      	subs	r3, r2, r3
 8021b22:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8021b26:	fb02 f303 	mul.w	r3, r2, r3
 8021b2a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021b2e:	4413      	add	r3, r2
 8021b30:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8021b34:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021b38:	3304      	adds	r3, #4
 8021b3a:	681b      	ldr	r3, [r3, #0]
 8021b3c:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z2 = (INT32) wsptr[3];
 8021b40:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021b44:	330c      	adds	r3, #12
 8021b46:	681b      	ldr	r3, [r3, #0]
 8021b48:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = (INT32) wsptr[5];
 8021b4c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021b50:	3314      	adds	r3, #20
 8021b52:	681b      	ldr	r3, [r3, #0]
 8021b54:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = (INT32) wsptr[7];
 8021b58:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021b5c:	331c      	adds	r3, #28
 8021b5e:	681b      	ldr	r3, [r3, #0]
 8021b60:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 8021b64:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021b68:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021b6c:	4413      	add	r3, r2
 8021b6e:	f642 2250 	movw	r2, #10832	@ 0x2a50
 8021b72:	fb02 f303 	mul.w	r3, r2, r3
 8021b76:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 8021b7a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021b7e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8021b82:	4413      	add	r3, r2
 8021b84:	f242 523e 	movw	r2, #9534	@ 0x253e
 8021b88:	fb02 f303 	mul.w	r3, r2, r3
 8021b8c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp15 = z1 + z4;
 8021b90:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8021b94:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8021b98:	4413      	add	r3, r2
 8021b9a:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 8021b9e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021ba2:	f641 6202 	movw	r2, #7682	@ 0x1e02
 8021ba6:	fb02 f303 	mul.w	r3, r2, r3
 8021baa:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 8021bae:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8021bb2:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021bb6:	441a      	add	r2, r3
 8021bb8:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8021bbc:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 8021bbe:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021bc2:	49af      	ldr	r1, [pc, #700]	@ (8021e80 <jpeg_idct_13x13+0xab0>)
 8021bc4:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 8021bc8:	4413      	add	r3, r2
 8021bca:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 8021bce:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8021bd2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8021bd6:	4413      	add	r3, r2
 8021bd8:	4aaa      	ldr	r2, [pc, #680]	@ (8021e84 <jpeg_idct_13x13+0xab4>)
 8021bda:	fb02 f303 	mul.w	r3, r2, r3
 8021bde:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 8021be2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021be6:	f641 22cb 	movw	r2, #6859	@ 0x1acb
 8021bea:	fb03 f202 	mul.w	r2, r3, r2
 8021bee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021bf2:	4413      	add	r3, r2
 8021bf4:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8021bf8:	4413      	add	r3, r2
 8021bfa:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 8021bfe:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8021c02:	4aa1      	ldr	r2, [pc, #644]	@ (8021e88 <jpeg_idct_13x13+0xab8>)
 8021c04:	fb03 f202 	mul.w	r2, r3, r2
 8021c08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021c0c:	4413      	add	r3, r2
 8021c0e:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8021c12:	4413      	add	r3, r2
 8021c14:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 8021c18:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8021c1c:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8021c20:	4413      	add	r3, r2
 8021c22:	4a9a      	ldr	r2, [pc, #616]	@ (8021e8c <jpeg_idct_13x13+0xabc>)
 8021c24:	fb02 f303 	mul.w	r3, r2, r3
 8021c28:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14;
 8021c2c:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8021c30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021c34:	4413      	add	r3, r2
 8021c36:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 8021c3a:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8021c3e:	f244 6294 	movw	r2, #18068	@ 0x4694
 8021c42:	fb03 f202 	mul.w	r2, r3, r2
 8021c46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021c4a:	4413      	add	r3, r2
 8021c4c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021c50:	4413      	add	r3, r2
 8021c52:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 8021c56:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8021c5a:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8021c5e:	4413      	add	r3, r2
 8021c60:	4a8b      	ldr	r2, [pc, #556]	@ (8021e90 <jpeg_idct_13x13+0xac0>)
 8021c62:	fb02 f303 	mul.w	r3, r2, r3
 8021c66:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp12 += tmp14;
 8021c6a:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8021c6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021c72:	4413      	add	r3, r2
 8021c74:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 += tmp14;
 8021c78:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8021c7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021c80:	4413      	add	r3, r2
 8021c82:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 8021c86:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021c8a:	f640 22d5 	movw	r2, #2773	@ 0xad5
 8021c8e:	fb02 f303 	mul.w	r3, r2, r3
 8021c92:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 8021c96:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021c9a:	f640 2233 	movw	r2, #2611	@ 0xa33
 8021c9e:	fb03 f202 	mul.w	r2, r3, r2
 8021ca2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021ca6:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 8021ca8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021cac:	4979      	ldr	r1, [pc, #484]	@ (8021e94 <jpeg_idct_13x13+0xac4>)
 8021cae:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 8021cb2:	4413      	add	r3, r2
 8021cb4:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 8021cb8:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8021cbc:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8021cc0:	1ad3      	subs	r3, r2, r3
 8021cc2:	f641 6202 	movw	r2, #7682	@ 0x1e02
 8021cc6:	fb02 f303 	mul.w	r3, r2, r3
 8021cca:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += z1;
 8021cce:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8021cd2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021cd6:	4413      	add	r3, r2
 8021cd8:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 8021cdc:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8021ce0:	f640 424e 	movw	r2, #3150	@ 0xc4e
 8021ce4:	fb03 f202 	mul.w	r2, r3, r2
 8021ce8:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8021cec:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 8021cee:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8021cf2:	f46f 515f 	mvn.w	r1, #14272	@ 0x37c0
 8021cf6:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 8021cfa:	4413      	add	r3, r2
 8021cfc:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8021d00:	4413      	add	r3, r2
 8021d02:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8021d06:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021d0a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021d0e:	4413      	add	r3, r2
 8021d10:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021d12:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8021d16:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021d1a:	4413      	add	r3, r2
 8021d1c:	781a      	ldrb	r2, [r3, #0]
 8021d1e:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021d22:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8021d24:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8021d28:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8021d2c:	1ad3      	subs	r3, r2, r3
 8021d2e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021d30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8021d34:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021d38:	441a      	add	r2, r3
 8021d3a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021d3e:	330c      	adds	r3, #12
 8021d40:	7812      	ldrb	r2, [r2, #0]
 8021d42:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8021d44:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8021d48:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021d4c:	4413      	add	r3, r2
 8021d4e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021d50:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8021d54:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021d58:	441a      	add	r2, r3
 8021d5a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021d5e:	3301      	adds	r3, #1
 8021d60:	7812      	ldrb	r2, [r2, #0]
 8021d62:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8021d64:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8021d68:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8021d6c:	1ad3      	subs	r3, r2, r3
 8021d6e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021d70:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8021d74:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021d78:	441a      	add	r2, r3
 8021d7a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021d7e:	330b      	adds	r3, #11
 8021d80:	7812      	ldrb	r2, [r2, #0]
 8021d82:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8021d84:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8021d88:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021d8c:	4413      	add	r3, r2
 8021d8e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021d90:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8021d94:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021d98:	441a      	add	r2, r3
 8021d9a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021d9e:	3302      	adds	r3, #2
 8021da0:	7812      	ldrb	r2, [r2, #0]
 8021da2:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8021da4:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8021da8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8021dac:	1ad3      	subs	r3, r2, r3
 8021dae:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021db0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8021db4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021db8:	441a      	add	r2, r3
 8021dba:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021dbe:	330a      	adds	r3, #10
 8021dc0:	7812      	ldrb	r2, [r2, #0]
 8021dc2:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8021dc4:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8021dc8:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8021dcc:	4413      	add	r3, r2
 8021dce:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021dd0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8021dd4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021dd8:	441a      	add	r2, r3
 8021dda:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021dde:	3303      	adds	r3, #3
 8021de0:	7812      	ldrb	r2, [r2, #0]
 8021de2:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8021de4:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8021de8:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8021dec:	1ad3      	subs	r3, r2, r3
 8021dee:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021df0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8021df4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021df8:	441a      	add	r2, r3
 8021dfa:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021dfe:	3309      	adds	r3, #9
 8021e00:	7812      	ldrb	r2, [r2, #0]
 8021e02:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8021e04:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8021e08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021e0c:	4413      	add	r3, r2
 8021e0e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021e10:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8021e14:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021e18:	441a      	add	r2, r3
 8021e1a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021e1e:	3304      	adds	r3, #4
 8021e20:	7812      	ldrb	r2, [r2, #0]
 8021e22:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8021e24:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8021e28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8021e2c:	1ad3      	subs	r3, r2, r3
 8021e2e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021e30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8021e34:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021e38:	441a      	add	r2, r3
 8021e3a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021e3e:	3308      	adds	r3, #8
 8021e40:	7812      	ldrb	r2, [r2, #0]
 8021e42:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8021e44:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8021e48:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021e4c:	4413      	add	r3, r2
 8021e4e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021e50:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8021e54:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021e58:	441a      	add	r2, r3
 8021e5a:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021e5e:	3305      	adds	r3, #5
 8021e60:	7812      	ldrb	r2, [r2, #0]
 8021e62:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8021e64:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8021e68:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8021e6c:	1ad3      	subs	r3, r2, r3
 8021e6e:	149b      	asrs	r3, r3, #18
 8021e70:	e012      	b.n	8021e98 <jpeg_idct_13x13+0xac8>
 8021e72:	bf00      	nop
 8021e74:	ffffd7ee 	.word	0xffffd7ee
 8021e78:	fffffa8c 	.word	0xfffffa8c
 8021e7c:	ffffe64b 	.word	0xffffe64b
 8021e80:	ffffbf5b 	.word	0xffffbf5b
 8021e84:	fffff52b 	.word	0xfffff52b
 8021e88:	ffffcdb1 	.word	0xffffcdb1
 8021e8c:	ffffdac2 	.word	0xffffdac2
 8021e90:	ffffeaf8 	.word	0xffffeaf8
 8021e94:	fffff116 	.word	0xfffff116
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021e98:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8021e9c:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021ea0:	441a      	add	r2, r3
 8021ea2:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021ea6:	3307      	adds	r3, #7
 8021ea8:	7812      	ldrb	r2, [r2, #0]
 8021eaa:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 8021eac:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8021eb0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8021eb2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 8021eb6:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8021eba:	441a      	add	r2, r3
 8021ebc:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8021ec0:	3306      	adds	r3, #6
 8021ec2:	7812      	ldrb	r2, [r2, #0]
 8021ec4:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8021ec6:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8021eca:	3320      	adds	r3, #32
 8021ecc:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 8021ed0:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8021ed4:	3301      	adds	r3, #1
 8021ed6:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 8021eda:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8021ede:	2b0c      	cmp	r3, #12
 8021ee0:	f77f ad56 	ble.w	8021990 <jpeg_idct_13x13+0x5c0>
  }
}
 8021ee4:	bf00      	nop
 8021ee6:	bf00      	nop
 8021ee8:	f507 7704 	add.w	r7, r7, #528	@ 0x210
 8021eec:	46bd      	mov	sp, r7
 8021eee:	bc90      	pop	{r4, r7}
 8021ef0:	4770      	bx	lr
 8021ef2:	bf00      	nop

08021ef4 <jpeg_idct_14x14>:

GLOBAL(void)
jpeg_idct_14x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021ef4:	b490      	push	{r4, r7}
 8021ef6:	f5ad 7d0c 	sub.w	sp, sp, #560	@ 0x230
 8021efa:	af00      	add	r7, sp, #0
 8021efc:	f507 740c 	add.w	r4, r7, #560	@ 0x230
 8021f00:	f5a4 7409 	sub.w	r4, r4, #548	@ 0x224
 8021f04:	6020      	str	r0, [r4, #0]
 8021f06:	f507 700c 	add.w	r0, r7, #560	@ 0x230
 8021f0a:	f5a0 700a 	sub.w	r0, r0, #552	@ 0x228
 8021f0e:	6001      	str	r1, [r0, #0]
 8021f10:	f507 710c 	add.w	r1, r7, #560	@ 0x230
 8021f14:	f5a1 710b 	sub.w	r1, r1, #556	@ 0x22c
 8021f18:	600a      	str	r2, [r1, #0]
 8021f1a:	f507 720c 	add.w	r2, r7, #560	@ 0x230
 8021f1e:	f5a2 720c 	sub.w	r2, r2, #560	@ 0x230
 8021f22:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021f24:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8021f28:	f5a3 7309 	sub.w	r3, r3, #548	@ 0x224
 8021f2c:	681b      	ldr	r3, [r3, #0]
 8021f2e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8021f32:	3380      	adds	r3, #128	@ 0x80
 8021f34:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
  int workspace[8*14];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8021f38:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8021f3c:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8021f40:	681b      	ldr	r3, [r3, #0]
 8021f42:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021f46:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8021f4a:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8021f4e:	681b      	ldr	r3, [r3, #0]
 8021f50:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021f52:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
  wsptr = workspace;
 8021f56:	f107 0310 	add.w	r3, r7, #16
 8021f5a:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021f5e:	2300      	movs	r3, #0
 8021f60:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 8021f64:	e278      	b.n	8022458 <jpeg_idct_14x14+0x564>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021f66:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8021f6a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f6e:	461a      	mov	r2, r3
 8021f70:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8021f74:	681b      	ldr	r3, [r3, #0]
 8021f76:	fb02 f303 	mul.w	r3, r2, r3
 8021f7a:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z1 <<= CONST_BITS;
 8021f7e:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8021f82:	035b      	lsls	r3, r3, #13
 8021f84:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021f88:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8021f8c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8021f90:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8021f94:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8021f98:	3340      	adds	r3, #64	@ 0x40
 8021f9a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f9e:	461a      	mov	r2, r3
 8021fa0:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8021fa4:	3380      	adds	r3, #128	@ 0x80
 8021fa6:	681b      	ldr	r3, [r3, #0]
 8021fa8:	fb02 f303 	mul.w	r3, r2, r3
 8021fac:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 8021fb0:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8021fb4:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8021fb8:	fb02 f303 	mul.w	r3, r2, r3
 8021fbc:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 8021fc0:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8021fc4:	f640 2212 	movw	r2, #2578	@ 0xa12
 8021fc8:	fb02 f303 	mul.w	r3, r2, r3
 8021fcc:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 8021fd0:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8021fd4:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8021fd8:	fb02 f303 	mul.w	r3, r2, r3
 8021fdc:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = z1 + z2;
 8021fe0:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8021fe4:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8021fe8:	4413      	add	r3, r2
 8021fea:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp11 = z1 + z3;
 8021fee:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8021ff2:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8021ff6:	4413      	add	r3, r2
 8021ff8:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = z1 - z4;
 8021ffc:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022000:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022004:	1ad3      	subs	r3, r2, r3
 8022006:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 802200a:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 802200e:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8022012:	441a      	add	r2, r3
 8022014:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022018:	1ad3      	subs	r3, r2, r3
 802201a:	005b      	lsls	r3, r3, #1
 802201c:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022020:	1ad3      	subs	r3, r2, r3
 8022022:	12db      	asrs	r3, r3, #11
 8022024:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8022028:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802202c:	3320      	adds	r3, #32
 802202e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022032:	461a      	mov	r2, r3
 8022034:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022038:	3340      	adds	r3, #64	@ 0x40
 802203a:	681b      	ldr	r3, [r3, #0]
 802203c:	fb02 f303 	mul.w	r3, r2, r3
 8022040:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8022044:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022048:	3360      	adds	r3, #96	@ 0x60
 802204a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802204e:	461a      	mov	r2, r3
 8022050:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022054:	33c0      	adds	r3, #192	@ 0xc0
 8022056:	681b      	ldr	r3, [r3, #0]
 8022058:	fb02 f303 	mul.w	r3, r2, r3
 802205c:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 8022060:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022064:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022068:	4413      	add	r3, r2
 802206a:	f242 3262 	movw	r2, #9058	@ 0x2362
 802206e:	fb02 f303 	mul.w	r3, r2, r3
 8022072:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8022076:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802207a:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 802207e:	fb02 f303 	mul.w	r3, r2, r3
 8022082:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022086:	4413      	add	r3, r2
 8022088:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 802208c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022090:	4aea      	ldr	r2, [pc, #936]	@ (802243c <jpeg_idct_14x14+0x548>)
 8022092:	fb02 f303 	mul.w	r3, r2, r3
 8022096:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 802209a:	4413      	add	r3, r2
 802209c:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80220a0:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80220a4:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 80220a8:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 80220ac:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80220b0:	49e3      	ldr	r1, [pc, #908]	@ (8022440 <jpeg_idct_14x14+0x54c>)
 80220b2:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80220b6:	4413      	add	r3, r2
 80220b8:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp20 = tmp10 + tmp13;
 80220bc:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80220c0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80220c4:	4413      	add	r3, r2
 80220c6:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
    tmp26 = tmp10 - tmp13;
 80220ca:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80220ce:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80220d2:	1ad3      	subs	r3, r2, r3
 80220d4:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp21 = tmp11 + tmp14;
 80220d8:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80220dc:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80220e0:	4413      	add	r3, r2
 80220e2:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp25 = tmp11 - tmp14;
 80220e6:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80220ea:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80220ee:	1ad3      	subs	r3, r2, r3
 80220f0:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp22 = tmp12 + tmp15;
 80220f4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80220f8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80220fc:	4413      	add	r3, r2
 80220fe:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp24 = tmp12 - tmp15;
 8022102:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8022106:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802210a:	1ad3      	subs	r3, r2, r3
 802210c:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8022110:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022114:	3310      	adds	r3, #16
 8022116:	f9b3 3000 	ldrsh.w	r3, [r3]
 802211a:	461a      	mov	r2, r3
 802211c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022120:	3320      	adds	r3, #32
 8022122:	681b      	ldr	r3, [r3, #0]
 8022124:	fb02 f303 	mul.w	r3, r2, r3
 8022128:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802212c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022130:	3330      	adds	r3, #48	@ 0x30
 8022132:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022136:	461a      	mov	r2, r3
 8022138:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802213c:	3360      	adds	r3, #96	@ 0x60
 802213e:	681b      	ldr	r3, [r3, #0]
 8022140:	fb02 f303 	mul.w	r3, r2, r3
 8022144:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8022148:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802214c:	3350      	adds	r3, #80	@ 0x50
 802214e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022152:	461a      	mov	r2, r3
 8022154:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022158:	33a0      	adds	r3, #160	@ 0xa0
 802215a:	681b      	ldr	r3, [r3, #0]
 802215c:	fb02 f303 	mul.w	r3, r2, r3
 8022160:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8022164:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022168:	3370      	adds	r3, #112	@ 0x70
 802216a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802216e:	461a      	mov	r2, r3
 8022170:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022174:	33e0      	adds	r3, #224	@ 0xe0
 8022176:	681b      	ldr	r3, [r3, #0]
 8022178:	fb02 f303 	mul.w	r3, r2, r3
 802217c:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp13 = z4 << CONST_BITS;
 8022180:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022184:	035b      	lsls	r3, r3, #13
 8022186:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    tmp14 = z1 + z3;
 802218a:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802218e:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8022192:	4413      	add	r3, r2
 8022194:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8022198:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802219c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80221a0:	4413      	add	r3, r2
 80221a2:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 80221a6:	fb02 f303 	mul.w	r3, r2, r3
 80221aa:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 80221ae:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80221b2:	f242 6252 	movw	r2, #9810	@ 0x2652
 80221b6:	fb02 f303 	mul.w	r3, r2, r3
 80221ba:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 80221be:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80221c2:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80221c6:	441a      	add	r2, r3
 80221c8:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80221cc:	441a      	add	r2, r3
 80221ce:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80221d2:	499c      	ldr	r1, [pc, #624]	@ (8022444 <jpeg_idct_14x14+0x550>)
 80221d4:	fb01 f303 	mul.w	r3, r1, r3
 80221d8:	4413      	add	r3, r2
 80221da:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80221de:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80221e2:	f641 0214 	movw	r2, #6164	@ 0x1814
 80221e6:	fb02 f303 	mul.w	r3, r2, r3
 80221ea:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80221ee:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80221f2:	4a95      	ldr	r2, [pc, #596]	@ (8022448 <jpeg_idct_14x14+0x554>)
 80221f4:	fb02 f303 	mul.w	r3, r2, r3
 80221f8:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 80221fc:	4413      	add	r3, r2
 80221fe:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    -= z2;
 8022202:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022206:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802220a:	1ad3      	subs	r3, r2, r3
 802220c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 8022210:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8022214:	f640 62f2 	movw	r2, #3826	@ 0xef2
 8022218:	fb03 f202 	mul.w	r2, r3, r2
 802221c:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022220:	1ad3      	subs	r3, r2, r3
 8022222:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    tmp16 += tmp15;
 8022226:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 802222a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802222e:	4413      	add	r3, r2
 8022230:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    += z4;
 8022234:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022238:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 802223c:	4413      	add	r3, r2
 802223e:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 8022242:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8022246:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802224a:	4413      	add	r3, r2
 802224c:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 8022250:	fb03 f202 	mul.w	r2, r3, r2
 8022254:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022258:	1ad3      	subs	r3, r2, r3
 802225a:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 802225e:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022262:	4a7a      	ldr	r2, [pc, #488]	@ (802244c <jpeg_idct_14x14+0x558>)
 8022264:	fb03 f202 	mul.w	r2, r3, r2
 8022268:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 802226c:	4413      	add	r3, r2
 802226e:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8022272:	4413      	add	r3, r2
 8022274:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 8022278:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802227c:	4a74      	ldr	r2, [pc, #464]	@ (8022450 <jpeg_idct_14x14+0x55c>)
 802227e:	fb03 f202 	mul.w	r2, r3, r2
 8022282:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022286:	4413      	add	r3, r2
 8022288:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802228c:	4413      	add	r3, r2
 802228e:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8022292:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022296:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802229a:	1ad3      	subs	r3, r2, r3
 802229c:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 80222a0:	fb02 f303 	mul.w	r3, r2, r3
 80222a4:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 80222a8:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 80222ac:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80222b0:	441a      	add	r2, r3
 80222b2:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80222b6:	4967      	ldr	r1, [pc, #412]	@ (8022454 <jpeg_idct_14x14+0x560>)
 80222b8:	fb01 f303 	mul.w	r3, r1, r3
 80222bc:	4413      	add	r3, r2
 80222be:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 80222c2:	4413      	add	r3, r2
 80222c4:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 80222c8:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80222cc:	f241 5299 	movw	r2, #5529	@ 0x1599
 80222d0:	fb03 f202 	mul.w	r2, r3, r2
 80222d4:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80222d8:	4413      	add	r3, r2
 80222da:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80222de:	4413      	add	r3, r2
 80222e0:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp13 = (z1 - z3) << PASS1_BITS;
 80222e4:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80222e8:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80222ec:	1ad3      	subs	r3, r2, r3
 80222ee:	009b      	lsls	r3, r3, #2
 80222f0:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80222f4:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 80222f8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80222fc:	4413      	add	r3, r2
 80222fe:	12da      	asrs	r2, r3, #11
 8022300:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022304:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8022306:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 802230a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 802230e:	1ad2      	subs	r2, r2, r3
 8022310:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022314:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8022318:	12d2      	asrs	r2, r2, #11
 802231a:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 802231c:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8022320:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8022324:	441a      	add	r2, r3
 8022326:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802232a:	3320      	adds	r3, #32
 802232c:	12d2      	asrs	r2, r2, #11
 802232e:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8022330:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8022334:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8022338:	1ad2      	subs	r2, r2, r3
 802233a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802233e:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8022342:	12d2      	asrs	r2, r2, #11
 8022344:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8022346:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802234a:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802234e:	441a      	add	r2, r3
 8022350:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022354:	3340      	adds	r3, #64	@ 0x40
 8022356:	12d2      	asrs	r2, r2, #11
 8022358:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802235a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802235e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022362:	1ad2      	subs	r2, r2, r3
 8022364:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022368:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 802236c:	12d2      	asrs	r2, r2, #11
 802236e:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) (tmp23 + tmp13);
 8022370:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022374:	3360      	adds	r3, #96	@ 0x60
 8022376:	f8d7 11f8 	ldr.w	r1, [r7, #504]	@ 0x1f8
 802237a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802237e:	440a      	add	r2, r1
 8022380:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) (tmp23 - tmp13);
 8022382:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022386:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 802238a:	f8d7 11f8 	ldr.w	r1, [r7, #504]	@ 0x1f8
 802238e:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8022392:	1a8a      	subs	r2, r1, r2
 8022394:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8022396:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802239a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802239e:	441a      	add	r2, r3
 80223a0:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80223a4:	3380      	adds	r3, #128	@ 0x80
 80223a6:	12d2      	asrs	r2, r2, #11
 80223a8:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 80223aa:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80223ae:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80223b2:	1ad2      	subs	r2, r2, r3
 80223b4:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80223b8:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80223bc:	12d2      	asrs	r2, r2, #11
 80223be:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 80223c0:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80223c4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80223c8:	441a      	add	r2, r3
 80223ca:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80223ce:	33a0      	adds	r3, #160	@ 0xa0
 80223d0:	12d2      	asrs	r2, r2, #11
 80223d2:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 80223d4:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80223d8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80223dc:	1ad2      	subs	r2, r2, r3
 80223de:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80223e2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80223e6:	12d2      	asrs	r2, r2, #11
 80223e8:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 80223ea:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 80223ee:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80223f2:	441a      	add	r2, r3
 80223f4:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80223f8:	33c0      	adds	r3, #192	@ 0xc0
 80223fa:	12d2      	asrs	r2, r2, #11
 80223fc:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 80223fe:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8022402:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8022406:	1ad2      	subs	r2, r2, r3
 8022408:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802240c:	33e0      	adds	r3, #224	@ 0xe0
 802240e:	12d2      	asrs	r2, r2, #11
 8022410:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8022412:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022416:	3301      	adds	r3, #1
 8022418:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 802241c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022420:	3302      	adds	r3, #2
 8022422:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 8022426:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802242a:	3304      	adds	r3, #4
 802242c:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
 8022430:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022434:	3304      	adds	r3, #4
 8022436:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
 802243a:	e00d      	b.n	8022458 <jpeg_idct_14x14+0x564>
 802243c:	ffffc8fc 	.word	0xffffc8fc
 8022440:	ffffd3e1 	.word	0xffffd3e1
 8022444:	ffffdbf0 	.word	0xffffdbf0
 8022448:	ffffde0b 	.word	0xffffde0b
 802244c:	fffff26e 	.word	0xfffff26e
 8022450:	ffffb409 	.word	0xffffb409
 8022454:	ffffc9e6 	.word	0xffffc9e6
 8022458:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802245c:	2b07      	cmp	r3, #7
 802245e:	f77f ad82 	ble.w	8021f66 <jpeg_idct_14x14+0x72>
  }

  /* Pass 2: process 14 rows from work array, store into output array. */

  wsptr = workspace;
 8022462:	f107 0310 	add.w	r3, r7, #16
 8022466:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 802246a:	2300      	movs	r3, #0
 802246c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 8022470:	e284      	b.n	802297c <jpeg_idct_14x14+0xa88>
    outptr = output_buf[ctr] + output_col;
 8022472:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022476:	009b      	lsls	r3, r3, #2
 8022478:	f507 720c 	add.w	r2, r7, #560	@ 0x230
 802247c:	f5a2 720c 	sub.w	r2, r2, #560	@ 0x230
 8022480:	6812      	ldr	r2, [r2, #0]
 8022482:	4413      	add	r3, r2
 8022484:	681a      	ldr	r2, [r3, #0]
 8022486:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802248a:	4413      	add	r3, r2
 802248c:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8022490:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022494:	681b      	ldr	r3, [r3, #0]
 8022496:	3310      	adds	r3, #16
 8022498:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z1 <<= CONST_BITS;
 802249c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80224a0:	035b      	lsls	r3, r3, #13
 80224a2:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4 = (INT32) wsptr[4];
 80224a6:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80224aa:	3310      	adds	r3, #16
 80224ac:	681b      	ldr	r3, [r3, #0]
 80224ae:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 80224b2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80224b6:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 80224ba:	fb02 f303 	mul.w	r3, r2, r3
 80224be:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 80224c2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80224c6:	f640 2212 	movw	r2, #2578	@ 0xa12
 80224ca:	fb02 f303 	mul.w	r3, r2, r3
 80224ce:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80224d2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80224d6:	f641 4237 	movw	r2, #7223	@ 0x1c37
 80224da:	fb02 f303 	mul.w	r3, r2, r3
 80224de:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = z1 + z2;
 80224e2:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80224e6:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80224ea:	4413      	add	r3, r2
 80224ec:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp11 = z1 + z3;
 80224f0:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80224f4:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80224f8:	4413      	add	r3, r2
 80224fa:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = z1 - z4;
 80224fe:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022502:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022506:	1ad3      	subs	r3, r2, r3
 8022508:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 802250c:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8022510:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8022514:	441a      	add	r2, r3
 8022516:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 802251a:	1ad3      	subs	r3, r2, r3
 802251c:	005b      	lsls	r3, r3, #1
 802251e:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022522:	1ad3      	subs	r3, r2, r3
 8022524:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    z1 = (INT32) wsptr[2];
 8022528:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802252c:	3308      	adds	r3, #8
 802252e:	681b      	ldr	r3, [r3, #0]
 8022530:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = (INT32) wsptr[6];
 8022534:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022538:	3318      	adds	r3, #24
 802253a:	681b      	ldr	r3, [r3, #0]
 802253c:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 8022540:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022544:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022548:	4413      	add	r3, r2
 802254a:	f242 3262 	movw	r2, #9058	@ 0x2362
 802254e:	fb02 f303 	mul.w	r3, r2, r3
 8022552:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8022556:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802255a:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 802255e:	fb02 f303 	mul.w	r3, r2, r3
 8022562:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022566:	4413      	add	r3, r2
 8022568:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 802256c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022570:	4af1      	ldr	r2, [pc, #964]	@ (8022938 <jpeg_idct_14x14+0xa44>)
 8022572:	fb02 f303 	mul.w	r3, r2, r3
 8022576:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 802257a:	4413      	add	r3, r2
 802257c:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8022580:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8022584:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8022588:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 802258c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022590:	49ea      	ldr	r1, [pc, #936]	@ (802293c <jpeg_idct_14x14+0xa48>)
 8022592:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8022596:	4413      	add	r3, r2
 8022598:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp20 = tmp10 + tmp13;
 802259c:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80225a0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80225a4:	4413      	add	r3, r2
 80225a6:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
    tmp26 = tmp10 - tmp13;
 80225aa:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80225ae:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80225b2:	1ad3      	subs	r3, r2, r3
 80225b4:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp21 = tmp11 + tmp14;
 80225b8:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80225bc:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80225c0:	4413      	add	r3, r2
 80225c2:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp25 = tmp11 - tmp14;
 80225c6:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80225ca:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80225ce:	1ad3      	subs	r3, r2, r3
 80225d0:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp22 = tmp12 + tmp15;
 80225d4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80225d8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80225dc:	4413      	add	r3, r2
 80225de:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp24 = tmp12 - tmp15;
 80225e2:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80225e6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80225ea:	1ad3      	subs	r3, r2, r3
 80225ec:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80225f0:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80225f4:	3304      	adds	r3, #4
 80225f6:	681b      	ldr	r3, [r3, #0]
 80225f8:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = (INT32) wsptr[3];
 80225fc:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022600:	330c      	adds	r3, #12
 8022602:	681b      	ldr	r3, [r3, #0]
 8022604:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = (INT32) wsptr[5];
 8022608:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802260c:	3314      	adds	r3, #20
 802260e:	681b      	ldr	r3, [r3, #0]
 8022610:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = (INT32) wsptr[7];
 8022614:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022618:	331c      	adds	r3, #28
 802261a:	681b      	ldr	r3, [r3, #0]
 802261c:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z4 <<= CONST_BITS;
 8022620:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022624:	035b      	lsls	r3, r3, #13
 8022626:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp14 = z1 + z3;
 802262a:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802262e:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8022632:	4413      	add	r3, r2
 8022634:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8022638:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802263c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8022640:	4413      	add	r3, r2
 8022642:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8022646:	fb02 f303 	mul.w	r3, r2, r3
 802264a:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 802264e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8022652:	f242 6252 	movw	r2, #9810	@ 0x2652
 8022656:	fb02 f303 	mul.w	r3, r2, r3
 802265a:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 802265e:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8022662:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022666:	441a      	add	r2, r3
 8022668:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 802266c:	441a      	add	r2, r3
 802266e:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8022672:	49b3      	ldr	r1, [pc, #716]	@ (8022940 <jpeg_idct_14x14+0xa4c>)
 8022674:	fb01 f303 	mul.w	r3, r1, r3
 8022678:	4413      	add	r3, r2
 802267a:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 802267e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8022682:	f641 0214 	movw	r2, #6164	@ 0x1814
 8022686:	fb02 f303 	mul.w	r3, r2, r3
 802268a:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 802268e:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8022692:	4aac      	ldr	r2, [pc, #688]	@ (8022944 <jpeg_idct_14x14+0xa50>)
 8022694:	fb02 f303 	mul.w	r3, r2, r3
 8022698:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 802269c:	4413      	add	r3, r2
 802269e:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    -= z2;
 80226a2:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80226a6:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80226aa:	1ad3      	subs	r3, r2, r3
 80226ac:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 80226b0:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80226b4:	f640 62f2 	movw	r2, #3826	@ 0xef2
 80226b8:	fb03 f202 	mul.w	r2, r3, r2
 80226bc:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80226c0:	1ad3      	subs	r3, r2, r3
 80226c2:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    tmp16 += tmp15;
 80226c6:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 80226ca:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80226ce:	4413      	add	r3, r2
 80226d0:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 80226d4:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80226d8:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80226dc:	4413      	add	r3, r2
 80226de:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 80226e2:	fb03 f202 	mul.w	r2, r3, r2
 80226e6:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80226ea:	1ad3      	subs	r3, r2, r3
 80226ec:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 80226f0:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80226f4:	4a94      	ldr	r2, [pc, #592]	@ (8022948 <jpeg_idct_14x14+0xa54>)
 80226f6:	fb03 f202 	mul.w	r2, r3, r2
 80226fa:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80226fe:	4413      	add	r3, r2
 8022700:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8022704:	4413      	add	r3, r2
 8022706:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 802270a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802270e:	4a8f      	ldr	r2, [pc, #572]	@ (802294c <jpeg_idct_14x14+0xa58>)
 8022710:	fb03 f202 	mul.w	r2, r3, r2
 8022714:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022718:	4413      	add	r3, r2
 802271a:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802271e:	4413      	add	r3, r2
 8022720:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8022724:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022728:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802272c:	1ad3      	subs	r3, r2, r3
 802272e:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 8022732:	fb02 f303 	mul.w	r3, r2, r3
 8022736:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 802273a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802273e:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8022742:	441a      	add	r2, r3
 8022744:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8022748:	4981      	ldr	r1, [pc, #516]	@ (8022950 <jpeg_idct_14x14+0xa5c>)
 802274a:	fb01 f303 	mul.w	r3, r1, r3
 802274e:	4413      	add	r3, r2
 8022750:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8022754:	4413      	add	r3, r2
 8022756:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 802275a:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802275e:	f241 5299 	movw	r2, #5529	@ 0x1599
 8022762:	fb03 f202 	mul.w	r2, r3, r2
 8022766:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802276a:	4413      	add	r3, r2
 802276c:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8022770:	4413      	add	r3, r2
 8022772:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 8022776:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802277a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802277e:	1ad3      	subs	r3, r2, r3
 8022780:	035b      	lsls	r3, r3, #13
 8022782:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8022786:	4413      	add	r3, r2
 8022788:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802278c:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 8022790:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8022794:	4413      	add	r3, r2
 8022796:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022798:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802279c:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80227a0:	4413      	add	r3, r2
 80227a2:	781a      	ldrb	r2, [r3, #0]
 80227a4:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80227a8:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80227aa:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 80227ae:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80227b2:	1ad3      	subs	r3, r2, r3
 80227b4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80227b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80227ba:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80227be:	441a      	add	r2, r3
 80227c0:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80227c4:	330d      	adds	r3, #13
 80227c6:	7812      	ldrb	r2, [r2, #0]
 80227c8:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80227ca:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80227ce:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 80227d2:	4413      	add	r3, r2
 80227d4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80227d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80227da:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80227de:	441a      	add	r2, r3
 80227e0:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80227e4:	3301      	adds	r3, #1
 80227e6:	7812      	ldrb	r2, [r2, #0]
 80227e8:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80227ea:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80227ee:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 80227f2:	1ad3      	subs	r3, r2, r3
 80227f4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80227f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80227fa:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80227fe:	441a      	add	r2, r3
 8022800:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022804:	330c      	adds	r3, #12
 8022806:	7812      	ldrb	r2, [r2, #0]
 8022808:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802280a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802280e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022812:	4413      	add	r3, r2
 8022814:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022816:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802281a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802281e:	441a      	add	r2, r3
 8022820:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022824:	3302      	adds	r3, #2
 8022826:	7812      	ldrb	r2, [r2, #0]
 8022828:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802282a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802282e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022832:	1ad3      	subs	r3, r2, r3
 8022834:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022836:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802283a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802283e:	441a      	add	r2, r3
 8022840:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022844:	330b      	adds	r3, #11
 8022846:	7812      	ldrb	r2, [r2, #0]
 8022848:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802284a:	f8d7 21f8 	ldr.w	r2, [r7, #504]	@ 0x1f8
 802284e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022852:	4413      	add	r3, r2
 8022854:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022856:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802285a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802285e:	441a      	add	r2, r3
 8022860:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022864:	3303      	adds	r3, #3
 8022866:	7812      	ldrb	r2, [r2, #0]
 8022868:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802286a:	f8d7 21f8 	ldr.w	r2, [r7, #504]	@ 0x1f8
 802286e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022872:	1ad3      	subs	r3, r2, r3
 8022874:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022876:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802287a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802287e:	441a      	add	r2, r3
 8022880:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022884:	330a      	adds	r3, #10
 8022886:	7812      	ldrb	r2, [r2, #0]
 8022888:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802288a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802288e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8022892:	4413      	add	r3, r2
 8022894:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022896:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802289a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802289e:	441a      	add	r2, r3
 80228a0:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80228a4:	3304      	adds	r3, #4
 80228a6:	7812      	ldrb	r2, [r2, #0]
 80228a8:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80228aa:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80228ae:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80228b2:	1ad3      	subs	r3, r2, r3
 80228b4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80228b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80228ba:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80228be:	441a      	add	r2, r3
 80228c0:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80228c4:	3309      	adds	r3, #9
 80228c6:	7812      	ldrb	r2, [r2, #0]
 80228c8:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80228ca:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80228ce:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80228d2:	4413      	add	r3, r2
 80228d4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80228d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80228da:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80228de:	441a      	add	r2, r3
 80228e0:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 80228e4:	3305      	adds	r3, #5
 80228e6:	7812      	ldrb	r2, [r2, #0]
 80228e8:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80228ea:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80228ee:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80228f2:	1ad3      	subs	r3, r2, r3
 80228f4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80228f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80228fa:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80228fe:	441a      	add	r2, r3
 8022900:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022904:	3308      	adds	r3, #8
 8022906:	7812      	ldrb	r2, [r2, #0]
 8022908:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 802290a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802290e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8022912:	4413      	add	r3, r2
 8022914:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022916:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 802291a:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802291e:	441a      	add	r2, r3
 8022920:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022924:	3306      	adds	r3, #6
 8022926:	7812      	ldrb	r2, [r2, #0]
 8022928:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 802292a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802292e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8022932:	1ad3      	subs	r3, r2, r3
 8022934:	149b      	asrs	r3, r3, #18
 8022936:	e00d      	b.n	8022954 <jpeg_idct_14x14+0xa60>
 8022938:	ffffc8fc 	.word	0xffffc8fc
 802293c:	ffffd3e1 	.word	0xffffd3e1
 8022940:	ffffdbf0 	.word	0xffffdbf0
 8022944:	ffffde0b 	.word	0xffffde0b
 8022948:	fffff26e 	.word	0xfffff26e
 802294c:	ffffb409 	.word	0xffffb409
 8022950:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022954:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8022958:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 802295c:	441a      	add	r2, r3
 802295e:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8022962:	3307      	adds	r3, #7
 8022964:	7812      	ldrb	r2, [r2, #0]
 8022966:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8022968:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802296c:	3320      	adds	r3, #32
 802296e:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 8022972:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022976:	3301      	adds	r3, #1
 8022978:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 802297c:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022980:	2b0d      	cmp	r3, #13
 8022982:	f77f ad76 	ble.w	8022472 <jpeg_idct_14x14+0x57e>
  }
}
 8022986:	bf00      	nop
 8022988:	bf00      	nop
 802298a:	f507 770c 	add.w	r7, r7, #560	@ 0x230
 802298e:	46bd      	mov	sp, r7
 8022990:	bc90      	pop	{r4, r7}
 8022992:	4770      	bx	lr

08022994 <jpeg_idct_15x15>:

GLOBAL(void)
jpeg_idct_15x15 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8022994:	b490      	push	{r4, r7}
 8022996:	f5ad 7d16 	sub.w	sp, sp, #600	@ 0x258
 802299a:	af00      	add	r7, sp, #0
 802299c:	f507 7416 	add.w	r4, r7, #600	@ 0x258
 80229a0:	f5a4 7413 	sub.w	r4, r4, #588	@ 0x24c
 80229a4:	6020      	str	r0, [r4, #0]
 80229a6:	f507 7016 	add.w	r0, r7, #600	@ 0x258
 80229aa:	f5a0 7014 	sub.w	r0, r0, #592	@ 0x250
 80229ae:	6001      	str	r1, [r0, #0]
 80229b0:	f507 7116 	add.w	r1, r7, #600	@ 0x258
 80229b4:	f5a1 7115 	sub.w	r1, r1, #596	@ 0x254
 80229b8:	600a      	str	r2, [r1, #0]
 80229ba:	f507 7216 	add.w	r2, r7, #600	@ 0x258
 80229be:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 80229c2:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80229c4:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 80229c8:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 80229cc:	681b      	ldr	r3, [r3, #0]
 80229ce:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80229d2:	3380      	adds	r3, #128	@ 0x80
 80229d4:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  int workspace[8*15];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80229d8:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 80229dc:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 80229e0:	681b      	ldr	r3, [r3, #0]
 80229e2:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80229e6:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 80229ea:	f5a3 7314 	sub.w	r3, r3, #592	@ 0x250
 80229ee:	681b      	ldr	r3, [r3, #0]
 80229f0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80229f2:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
  wsptr = workspace;
 80229f6:	f107 0314 	add.w	r3, r7, #20
 80229fa:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80229fe:	2300      	movs	r3, #0
 8022a00:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8022a04:	e28d      	b.n	8022f22 <jpeg_idct_15x15+0x58e>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8022a06:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022a0a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022a0e:	461a      	mov	r2, r3
 8022a10:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022a14:	681b      	ldr	r3, [r3, #0]
 8022a16:	fb02 f303 	mul.w	r3, r2, r3
 8022a1a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1 <<= CONST_BITS;
 8022a1e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022a22:	035b      	lsls	r3, r3, #13
 8022a24:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8022a28:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022a2c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8022a30:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8022a34:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022a38:	3320      	adds	r3, #32
 8022a3a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022a3e:	461a      	mov	r2, r3
 8022a40:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022a44:	3340      	adds	r3, #64	@ 0x40
 8022a46:	681b      	ldr	r3, [r3, #0]
 8022a48:	fb02 f303 	mul.w	r3, r2, r3
 8022a4c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8022a50:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022a54:	3340      	adds	r3, #64	@ 0x40
 8022a56:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022a5a:	461a      	mov	r2, r3
 8022a5c:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022a60:	3380      	adds	r3, #128	@ 0x80
 8022a62:	681b      	ldr	r3, [r3, #0]
 8022a64:	fb02 f303 	mul.w	r3, r2, r3
 8022a68:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8022a6c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022a70:	3360      	adds	r3, #96	@ 0x60
 8022a72:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022a76:	461a      	mov	r2, r3
 8022a78:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022a7c:	33c0      	adds	r3, #192	@ 0xc0
 8022a7e:	681b      	ldr	r3, [r3, #0]
 8022a80:	fb02 f303 	mul.w	r3, r2, r3
 8022a84:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 8022a88:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022a8c:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8022a90:	fb02 f303 	mul.w	r3, r2, r3
 8022a94:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 8022a98:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022a9c:	f242 429d 	movw	r2, #9373	@ 0x249d
 8022aa0:	fb02 f303 	mul.w	r3, r2, r3
 8022aa4:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp12 = z1 - tmp10;
 8022aa8:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022aac:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022ab0:	1ad3      	subs	r3, r2, r3
 8022ab2:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp13 = z1 + tmp11;
 8022ab6:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022aba:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022abe:	4413      	add	r3, r2
 8022ac0:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 8022ac4:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8022ac8:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022acc:	1ad3      	subs	r3, r2, r3
 8022ace:	005b      	lsls	r3, r3, #1
 8022ad0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022ad4:	1ad3      	subs	r3, r2, r3
 8022ad6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z4 = z2 - z3;
 8022ada:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8022ade:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022ae2:	1ad3      	subs	r3, r2, r3
 8022ae4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 += z2;
 8022ae8:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8022aec:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022af0:	4413      	add	r3, r2
 8022af2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 8022af6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022afa:	f642 22ce 	movw	r2, #10958	@ 0x2ace
 8022afe:	fb02 f303 	mul.w	r3, r2, r3
 8022b02:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 8022b06:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022b0a:	f44f 72bb 	mov.w	r2, #374	@ 0x176
 8022b0e:	fb02 f303 	mul.w	r3, r2, r3
 8022b12:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 8022b16:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022b1a:	f642 6213 	movw	r2, #11795	@ 0x2e13
 8022b1e:	fb02 f303 	mul.w	r3, r2, r3
 8022b22:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 8022b26:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8022b2a:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022b2e:	4413      	add	r3, r2
 8022b30:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8022b34:	4413      	add	r3, r2
 8022b36:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 8022b3a:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8022b3e:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022b42:	1ad2      	subs	r2, r2, r3
 8022b44:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022b48:	4413      	add	r3, r2
 8022b4a:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8022b4e:	4413      	add	r3, r2
 8022b50:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 8022b54:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022b58:	f241 1282 	movw	r2, #4482	@ 0x1182
 8022b5c:	fb02 f303 	mul.w	r3, r2, r3
 8022b60:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 8022b64:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022b68:	f640 42c7 	movw	r2, #3271	@ 0xcc7
 8022b6c:	fb02 f303 	mul.w	r3, r2, r3
 8022b70:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 8022b74:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8022b78:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022b7c:	1ad2      	subs	r2, r2, r3
 8022b7e:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022b82:	1ad3      	subs	r3, r2, r3
 8022b84:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 8022b88:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8022b8c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022b90:	441a      	add	r2, r3
 8022b92:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022b96:	1ad2      	subs	r2, r2, r3
 8022b98:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022b9c:	1ad3      	subs	r3, r2, r3
 8022b9e:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 8022ba2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022ba6:	f641 124c 	movw	r2, #6476	@ 0x194c
 8022baa:	fb02 f303 	mul.w	r3, r2, r3
 8022bae:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 8022bb2:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022bb6:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8022bba:	fb02 f303 	mul.w	r3, r2, r3
 8022bbe:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 8022bc2:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8022bc6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022bca:	4413      	add	r3, r2
 8022bcc:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8022bd0:	4413      	add	r3, r2
 8022bd2:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 8022bd6:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8022bda:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022bde:	1ad3      	subs	r3, r2, r3
 8022be0:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8022be4:	4413      	add	r3, r2
 8022be6:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    tmp11 += tmp11;
 8022bea:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022bee:	005b      	lsls	r3, r3, #1
 8022bf0:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 8022bf4:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022bf8:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022bfc:	4413      	add	r3, r2
 8022bfe:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 8022c02:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022c06:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022c0a:	1ad2      	subs	r2, r2, r3
 8022c0c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022c10:	1ad3      	subs	r3, r2, r3
 8022c12:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8022c16:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022c1a:	3310      	adds	r3, #16
 8022c1c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022c20:	461a      	mov	r2, r3
 8022c22:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022c26:	3320      	adds	r3, #32
 8022c28:	681b      	ldr	r3, [r3, #0]
 8022c2a:	fb02 f303 	mul.w	r3, r2, r3
 8022c2e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8022c32:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022c36:	3330      	adds	r3, #48	@ 0x30
 8022c38:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022c3c:	461a      	mov	r2, r3
 8022c3e:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022c42:	3360      	adds	r3, #96	@ 0x60
 8022c44:	681b      	ldr	r3, [r3, #0]
 8022c46:	fb02 f303 	mul.w	r3, r2, r3
 8022c4a:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8022c4e:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022c52:	3350      	adds	r3, #80	@ 0x50
 8022c54:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022c58:	461a      	mov	r2, r3
 8022c5a:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022c5e:	33a0      	adds	r3, #160	@ 0xa0
 8022c60:	681b      	ldr	r3, [r3, #0]
 8022c62:	fb02 f303 	mul.w	r3, r2, r3
 8022c66:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 8022c6a:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022c6e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8022c72:	fb02 f303 	mul.w	r3, r2, r3
 8022c76:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8022c7a:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022c7e:	3370      	adds	r3, #112	@ 0x70
 8022c80:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022c84:	461a      	mov	r2, r3
 8022c86:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022c8a:	33e0      	adds	r3, #224	@ 0xe0
 8022c8c:	681b      	ldr	r3, [r3, #0]
 8022c8e:	fb02 f303 	mul.w	r3, r2, r3
 8022c92:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp13 = z2 - z4;
 8022c96:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8022c9a:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022c9e:	1ad3      	subs	r3, r2, r3
 8022ca0:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 8022ca4:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022ca8:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022cac:	4413      	add	r3, r2
 8022cae:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8022cb2:	fb02 f303 	mul.w	r3, r2, r3
 8022cb6:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 8022cba:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022cbe:	f241 0271 	movw	r2, #4209	@ 0x1071
 8022cc2:	fb02 f303 	mul.w	r3, r2, r3
 8022cc6:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8022cca:	4413      	add	r3, r2
 8022ccc:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 8022cd0:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022cd4:	4a99      	ldr	r2, [pc, #612]	@ (8022f3c <jpeg_idct_15x15+0x5a8>)
 8022cd6:	fb02 f303 	mul.w	r3, r2, r3
 8022cda:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8022cde:	4413      	add	r3, r2
 8022ce0:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 8022ce4:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022ce8:	4a95      	ldr	r2, [pc, #596]	@ (8022f40 <jpeg_idct_15x15+0x5ac>)
 8022cea:	fb02 f303 	mul.w	r3, r2, r3
 8022cee:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 8022cf2:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022cf6:	4a93      	ldr	r2, [pc, #588]	@ (8022f44 <jpeg_idct_15x15+0x5b0>)
 8022cf8:	fb02 f303 	mul.w	r3, r2, r3
 8022cfc:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z2 = z1 - z4;
 8022d00:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022d04:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022d08:	1ad3      	subs	r3, r2, r3
 8022d0a:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 8022d0e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022d12:	f642 5202 	movw	r2, #11522	@ 0x2d02
 8022d16:	fb02 f303 	mul.w	r3, r2, r3
 8022d1a:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8022d1e:	4413      	add	r3, r2
 8022d20:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 8022d24:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022d28:	f644 62a3 	movw	r2, #20131	@ 0x4ea3
 8022d2c:	fb03 f202 	mul.w	r2, r3, r2
 8022d30:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022d34:	441a      	add	r2, r3
 8022d36:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022d3a:	1ad3      	subs	r3, r2, r3
 8022d3c:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 8022d40:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022d44:	4a80      	ldr	r2, [pc, #512]	@ (8022f48 <jpeg_idct_15x15+0x5b4>)
 8022d46:	fb03 f202 	mul.w	r2, r3, r2
 8022d4a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022d4e:	4413      	add	r3, r2
 8022d50:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8022d54:	4413      	add	r3, r2
 8022d56:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 8022d5a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022d5e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8022d62:	fb03 f202 	mul.w	r2, r3, r2
 8022d66:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022d6a:	1ad3      	subs	r3, r2, r3
 8022d6c:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 8022d70:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022d74:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022d78:	4413      	add	r3, r2
 8022d7a:	f241 2268 	movw	r2, #4712	@ 0x1268
 8022d7e:	fb02 f303 	mul.w	r3, r2, r3
 8022d82:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 8022d86:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022d8a:	f640 7239 	movw	r2, #3897	@ 0xf39
 8022d8e:	fb03 f202 	mul.w	r2, r3, r2
 8022d92:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022d96:	441a      	add	r2, r3
 8022d98:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022d9c:	1ad3      	subs	r3, r2, r3
 8022d9e:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8022da2:	4413      	add	r3, r2
 8022da4:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 8022da8:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022dac:	4a67      	ldr	r2, [pc, #412]	@ (8022f4c <jpeg_idct_15x15+0x5b8>)
 8022dae:	fb03 f202 	mul.w	r2, r3, r2
 8022db2:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8022db6:	441a      	add	r2, r3
 8022db8:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8022dbc:	4413      	add	r3, r2
 8022dbe:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8022dc2:	4413      	add	r3, r2
 8022dc4:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8022dc8:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8022dcc:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022dd0:	4413      	add	r3, r2
 8022dd2:	12da      	asrs	r2, r3, #11
 8022dd4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022dd8:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8022dda:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8022dde:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022de2:	1ad2      	subs	r2, r2, r3
 8022de4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022de8:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 8022dec:	12d2      	asrs	r2, r2, #11
 8022dee:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8022df0:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8022df4:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022df8:	441a      	add	r2, r3
 8022dfa:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022dfe:	3320      	adds	r3, #32
 8022e00:	12d2      	asrs	r2, r2, #11
 8022e02:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8022e04:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8022e08:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022e0c:	1ad2      	subs	r2, r2, r3
 8022e0e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e12:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8022e16:	12d2      	asrs	r2, r2, #11
 8022e18:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8022e1a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 8022e1e:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022e22:	441a      	add	r2, r3
 8022e24:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e28:	3340      	adds	r3, #64	@ 0x40
 8022e2a:	12d2      	asrs	r2, r2, #11
 8022e2c:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8022e2e:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 8022e32:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8022e36:	1ad2      	subs	r2, r2, r3
 8022e38:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e3c:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8022e40:	12d2      	asrs	r2, r2, #11
 8022e42:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8022e44:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8022e48:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022e4c:	441a      	add	r2, r3
 8022e4e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e52:	3360      	adds	r3, #96	@ 0x60
 8022e54:	12d2      	asrs	r2, r2, #11
 8022e56:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8022e58:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8022e5c:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8022e60:	1ad2      	subs	r2, r2, r3
 8022e62:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e66:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8022e6a:	12d2      	asrs	r2, r2, #11
 8022e6c:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8022e6e:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022e72:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8022e76:	441a      	add	r2, r3
 8022e78:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e7c:	3380      	adds	r3, #128	@ 0x80
 8022e7e:	12d2      	asrs	r2, r2, #11
 8022e80:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8022e82:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8022e86:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8022e8a:	1ad2      	subs	r2, r2, r3
 8022e8c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022e90:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8022e94:	12d2      	asrs	r2, r2, #11
 8022e96:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8022e98:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022e9c:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022ea0:	441a      	add	r2, r3
 8022ea2:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022ea6:	33a0      	adds	r3, #160	@ 0xa0
 8022ea8:	12d2      	asrs	r2, r2, #11
 8022eaa:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8022eac:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8022eb0:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8022eb4:	1ad2      	subs	r2, r2, r3
 8022eb6:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022eba:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8022ebe:	12d2      	asrs	r2, r2, #11
 8022ec0:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 8022ec2:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8022ec6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022eca:	441a      	add	r2, r3
 8022ecc:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022ed0:	33c0      	adds	r3, #192	@ 0xc0
 8022ed2:	12d2      	asrs	r2, r2, #11
 8022ed4:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 8022ed6:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8022eda:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8022ede:	1ad2      	subs	r2, r2, r3
 8022ee0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022ee4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8022ee8:	12d2      	asrs	r2, r2, #11
 8022eea:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27, CONST_BITS-PASS1_BITS);
 8022eec:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022ef0:	33e0      	adds	r3, #224	@ 0xe0
 8022ef2:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8022ef6:	12d2      	asrs	r2, r2, #11
 8022ef8:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8022efa:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8022efe:	3301      	adds	r3, #1
 8022f00:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8022f04:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8022f08:	3302      	adds	r3, #2
 8022f0a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 8022f0e:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8022f12:	3304      	adds	r3, #4
 8022f14:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
 8022f18:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022f1c:	3304      	adds	r3, #4
 8022f1e:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
 8022f22:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8022f26:	2b07      	cmp	r3, #7
 8022f28:	f77f ad6d 	ble.w	8022a06 <jpeg_idct_15x15+0x72>
  }

  /* Pass 2: process 15 rows from work array, store into output array. */

  wsptr = workspace;
 8022f2c:	f107 0314 	add.w	r3, r7, #20
 8022f30:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 8022f34:	2300      	movs	r3, #0
 8022f36:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8022f3a:	e2ab      	b.n	8023494 <jpeg_idct_15x15+0xb00>
 8022f3c:	ffffba5c 	.word	0xffffba5c
 8022f40:	ffffe566 	.word	0xffffe566
 8022f44:	ffffd4f6 	.word	0xffffd4f6
 8022f48:	ffffdc67 	.word	0xffffdc67
 8022f4c:	ffffe42f 	.word	0xffffe42f
    outptr = output_buf[ctr] + output_col;
 8022f50:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8022f54:	009b      	lsls	r3, r3, #2
 8022f56:	f507 7216 	add.w	r2, r7, #600	@ 0x258
 8022f5a:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 8022f5e:	6812      	ldr	r2, [r2, #0]
 8022f60:	4413      	add	r3, r2
 8022f62:	681a      	ldr	r2, [r3, #0]
 8022f64:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8022f68:	4413      	add	r3, r2
 8022f6a:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8022f6e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022f72:	681b      	ldr	r3, [r3, #0]
 8022f74:	3310      	adds	r3, #16
 8022f76:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1 <<= CONST_BITS;
 8022f7a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8022f7e:	035b      	lsls	r3, r3, #13
 8022f80:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z2 = (INT32) wsptr[2];
 8022f84:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022f88:	3308      	adds	r3, #8
 8022f8a:	681b      	ldr	r3, [r3, #0]
 8022f8c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z3 = (INT32) wsptr[4];
 8022f90:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022f94:	3310      	adds	r3, #16
 8022f96:	681b      	ldr	r3, [r3, #0]
 8022f98:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = (INT32) wsptr[6];
 8022f9c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8022fa0:	3318      	adds	r3, #24
 8022fa2:	681b      	ldr	r3, [r3, #0]
 8022fa4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 8022fa8:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022fac:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8022fb0:	fb02 f303 	mul.w	r3, r2, r3
 8022fb4:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 8022fb8:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8022fbc:	f242 429d 	movw	r2, #9373	@ 0x249d
 8022fc0:	fb02 f303 	mul.w	r3, r2, r3
 8022fc4:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp12 = z1 - tmp10;
 8022fc8:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022fcc:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022fd0:	1ad3      	subs	r3, r2, r3
 8022fd2:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp13 = z1 + tmp11;
 8022fd6:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022fda:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8022fde:	4413      	add	r3, r2
 8022fe0:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 8022fe4:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8022fe8:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8022fec:	1ad3      	subs	r3, r2, r3
 8022fee:	005b      	lsls	r3, r3, #1
 8022ff0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8022ff4:	1ad3      	subs	r3, r2, r3
 8022ff6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z4 = z2 - z3;
 8022ffa:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8022ffe:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023002:	1ad3      	subs	r3, r2, r3
 8023004:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 += z2;
 8023008:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802300c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023010:	4413      	add	r3, r2
 8023012:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 8023016:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802301a:	f642 22ce 	movw	r2, #10958	@ 0x2ace
 802301e:	fb02 f303 	mul.w	r3, r2, r3
 8023022:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 8023026:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802302a:	f44f 72bb 	mov.w	r2, #374	@ 0x176
 802302e:	fb02 f303 	mul.w	r3, r2, r3
 8023032:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 8023036:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802303a:	f642 6213 	movw	r2, #11795	@ 0x2e13
 802303e:	fb02 f303 	mul.w	r3, r2, r3
 8023042:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 8023046:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 802304a:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802304e:	4413      	add	r3, r2
 8023050:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8023054:	4413      	add	r3, r2
 8023056:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 802305a:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 802305e:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8023062:	1ad2      	subs	r2, r2, r3
 8023064:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8023068:	4413      	add	r3, r2
 802306a:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802306e:	4413      	add	r3, r2
 8023070:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 8023074:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023078:	f241 1282 	movw	r2, #4482	@ 0x1182
 802307c:	fb02 f303 	mul.w	r3, r2, r3
 8023080:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 8023084:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023088:	f640 42c7 	movw	r2, #3271	@ 0xcc7
 802308c:	fb02 f303 	mul.w	r3, r2, r3
 8023090:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 8023094:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8023098:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802309c:	1ad2      	subs	r2, r2, r3
 802309e:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80230a2:	1ad3      	subs	r3, r2, r3
 80230a4:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 80230a8:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80230ac:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80230b0:	441a      	add	r2, r3
 80230b2:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80230b6:	1ad2      	subs	r2, r2, r3
 80230b8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80230bc:	1ad3      	subs	r3, r2, r3
 80230be:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 80230c2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80230c6:	f641 124c 	movw	r2, #6476	@ 0x194c
 80230ca:	fb02 f303 	mul.w	r3, r2, r3
 80230ce:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 80230d2:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80230d6:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 80230da:	fb02 f303 	mul.w	r3, r2, r3
 80230de:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 80230e2:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80230e6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80230ea:	4413      	add	r3, r2
 80230ec:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80230f0:	4413      	add	r3, r2
 80230f2:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 80230f6:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80230fa:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80230fe:	1ad3      	subs	r3, r2, r3
 8023100:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8023104:	4413      	add	r3, r2
 8023106:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    tmp11 += tmp11;
 802310a:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802310e:	005b      	lsls	r3, r3, #1
 8023110:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 8023114:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023118:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802311c:	4413      	add	r3, r2
 802311e:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 8023122:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023126:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802312a:	1ad2      	subs	r2, r2, r3
 802312c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8023130:	1ad3      	subs	r3, r2, r3
 8023132:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8023136:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802313a:	3304      	adds	r3, #4
 802313c:	681b      	ldr	r3, [r3, #0]
 802313e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z2 = (INT32) wsptr[3];
 8023142:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8023146:	330c      	adds	r3, #12
 8023148:	681b      	ldr	r3, [r3, #0]
 802314a:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = (INT32) wsptr[5];
 802314e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8023152:	3314      	adds	r3, #20
 8023154:	681b      	ldr	r3, [r3, #0]
 8023156:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 802315a:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802315e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8023162:	fb02 f303 	mul.w	r3, r2, r3
 8023166:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = (INT32) wsptr[7];
 802316a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802316e:	331c      	adds	r3, #28
 8023170:	681b      	ldr	r3, [r3, #0]
 8023172:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp13 = z2 - z4;
 8023176:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802317a:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802317e:	1ad3      	subs	r3, r2, r3
 8023180:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 8023184:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023188:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802318c:	4413      	add	r3, r2
 802318e:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8023192:	fb02 f303 	mul.w	r3, r2, r3
 8023196:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 802319a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802319e:	f241 0271 	movw	r2, #4209	@ 0x1071
 80231a2:	fb02 f303 	mul.w	r3, r2, r3
 80231a6:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80231aa:	4413      	add	r3, r2
 80231ac:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 80231b0:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 80231b4:	4abd      	ldr	r2, [pc, #756]	@ (80234ac <jpeg_idct_15x15+0xb18>)
 80231b6:	fb02 f303 	mul.w	r3, r2, r3
 80231ba:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80231be:	4413      	add	r3, r2
 80231c0:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 80231c4:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80231c8:	4ab9      	ldr	r2, [pc, #740]	@ (80234b0 <jpeg_idct_15x15+0xb1c>)
 80231ca:	fb02 f303 	mul.w	r3, r2, r3
 80231ce:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 80231d2:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80231d6:	4ab7      	ldr	r2, [pc, #732]	@ (80234b4 <jpeg_idct_15x15+0xb20>)
 80231d8:	fb02 f303 	mul.w	r3, r2, r3
 80231dc:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z2 = z1 - z4;
 80231e0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80231e4:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80231e8:	1ad3      	subs	r3, r2, r3
 80231ea:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 80231ee:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80231f2:	f642 5202 	movw	r2, #11522	@ 0x2d02
 80231f6:	fb02 f303 	mul.w	r3, r2, r3
 80231fa:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80231fe:	4413      	add	r3, r2
 8023200:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 8023204:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023208:	f644 62a3 	movw	r2, #20131	@ 0x4ea3
 802320c:	fb03 f202 	mul.w	r2, r3, r2
 8023210:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8023214:	441a      	add	r2, r3
 8023216:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802321a:	1ad3      	subs	r3, r2, r3
 802321c:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 8023220:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023224:	4aa4      	ldr	r2, [pc, #656]	@ (80234b8 <jpeg_idct_15x15+0xb24>)
 8023226:	fb03 f202 	mul.w	r2, r3, r2
 802322a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802322e:	4413      	add	r3, r2
 8023230:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8023234:	4413      	add	r3, r2
 8023236:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 802323a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802323e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8023242:	fb03 f202 	mul.w	r2, r3, r2
 8023246:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802324a:	1ad3      	subs	r3, r2, r3
 802324c:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 8023250:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023254:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023258:	4413      	add	r3, r2
 802325a:	f241 2268 	movw	r2, #4712	@ 0x1268
 802325e:	fb02 f303 	mul.w	r3, r2, r3
 8023262:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 8023266:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802326a:	f640 7239 	movw	r2, #3897	@ 0xf39
 802326e:	fb03 f202 	mul.w	r2, r3, r2
 8023272:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023276:	441a      	add	r2, r3
 8023278:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802327c:	1ad3      	subs	r3, r2, r3
 802327e:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8023282:	4413      	add	r3, r2
 8023284:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 8023288:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802328c:	4a8b      	ldr	r2, [pc, #556]	@ (80234bc <jpeg_idct_15x15+0xb28>)
 802328e:	fb03 f202 	mul.w	r2, r3, r2
 8023292:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023296:	441a      	add	r2, r3
 8023298:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802329c:	4413      	add	r3, r2
 802329e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80232a2:	4413      	add	r3, r2
 80232a4:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80232a8:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80232ac:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80232b0:	4413      	add	r3, r2
 80232b2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80232b4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80232b8:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80232bc:	4413      	add	r3, r2
 80232be:	781a      	ldrb	r2, [r3, #0]
 80232c0:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80232c4:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80232c6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80232ca:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80232ce:	1ad3      	subs	r3, r2, r3
 80232d0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80232d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80232d6:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80232da:	441a      	add	r2, r3
 80232dc:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80232e0:	330e      	adds	r3, #14
 80232e2:	7812      	ldrb	r2, [r2, #0]
 80232e4:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80232e6:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80232ea:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80232ee:	4413      	add	r3, r2
 80232f0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80232f2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80232f6:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80232fa:	441a      	add	r2, r3
 80232fc:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023300:	3301      	adds	r3, #1
 8023302:	7812      	ldrb	r2, [r2, #0]
 8023304:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8023306:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 802330a:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802330e:	1ad3      	subs	r3, r2, r3
 8023310:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023312:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8023316:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802331a:	441a      	add	r2, r3
 802331c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023320:	330d      	adds	r3, #13
 8023322:	7812      	ldrb	r2, [r2, #0]
 8023324:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8023326:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802332a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802332e:	4413      	add	r3, r2
 8023330:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023332:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8023336:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802333a:	441a      	add	r2, r3
 802333c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023340:	3302      	adds	r3, #2
 8023342:	7812      	ldrb	r2, [r2, #0]
 8023344:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8023346:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802334a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802334e:	1ad3      	subs	r3, r2, r3
 8023350:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023352:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8023356:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802335a:	441a      	add	r2, r3
 802335c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023360:	330c      	adds	r3, #12
 8023362:	7812      	ldrb	r2, [r2, #0]
 8023364:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8023366:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 802336a:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802336e:	4413      	add	r3, r2
 8023370:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023372:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8023376:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802337a:	441a      	add	r2, r3
 802337c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023380:	3303      	adds	r3, #3
 8023382:	7812      	ldrb	r2, [r2, #0]
 8023384:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8023386:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 802338a:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802338e:	1ad3      	subs	r3, r2, r3
 8023390:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023392:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8023396:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802339a:	441a      	add	r2, r3
 802339c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80233a0:	330b      	adds	r3, #11
 80233a2:	7812      	ldrb	r2, [r2, #0]
 80233a4:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80233a6:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 80233aa:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80233ae:	4413      	add	r3, r2
 80233b0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80233b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80233b6:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80233ba:	441a      	add	r2, r3
 80233bc:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80233c0:	3304      	adds	r3, #4
 80233c2:	7812      	ldrb	r2, [r2, #0]
 80233c4:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80233c6:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 80233ca:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80233ce:	1ad3      	subs	r3, r2, r3
 80233d0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80233d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80233d6:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80233da:	441a      	add	r2, r3
 80233dc:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80233e0:	330a      	adds	r3, #10
 80233e2:	7812      	ldrb	r2, [r2, #0]
 80233e4:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80233e6:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80233ea:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80233ee:	4413      	add	r3, r2
 80233f0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80233f2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80233f6:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80233fa:	441a      	add	r2, r3
 80233fc:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023400:	3305      	adds	r3, #5
 8023402:	7812      	ldrb	r2, [r2, #0]
 8023404:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8023406:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802340a:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802340e:	1ad3      	subs	r3, r2, r3
 8023410:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023412:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8023416:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802341a:	441a      	add	r2, r3
 802341c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023420:	3309      	adds	r3, #9
 8023422:	7812      	ldrb	r2, [r2, #0]
 8023424:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8023426:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 802342a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802342e:	4413      	add	r3, r2
 8023430:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023432:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8023436:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802343a:	441a      	add	r2, r3
 802343c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023440:	3306      	adds	r3, #6
 8023442:	7812      	ldrb	r2, [r2, #0]
 8023444:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8023446:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 802344a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802344e:	1ad3      	subs	r3, r2, r3
 8023450:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023452:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8023456:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802345a:	441a      	add	r2, r3
 802345c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023460:	3308      	adds	r3, #8
 8023462:	7812      	ldrb	r2, [r2, #0]
 8023464:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 8023466:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 802346a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802346c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 8023470:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023474:	441a      	add	r2, r3
 8023476:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802347a:	3307      	adds	r3, #7
 802347c:	7812      	ldrb	r2, [r2, #0]
 802347e:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8023480:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8023484:	3320      	adds	r3, #32
 8023486:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 802348a:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 802348e:	3301      	adds	r3, #1
 8023490:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8023494:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023498:	2b0e      	cmp	r3, #14
 802349a:	f77f ad59 	ble.w	8022f50 <jpeg_idct_15x15+0x5bc>
  }
}
 802349e:	bf00      	nop
 80234a0:	bf00      	nop
 80234a2:	f507 7716 	add.w	r7, r7, #600	@ 0x258
 80234a6:	46bd      	mov	sp, r7
 80234a8:	bc90      	pop	{r4, r7}
 80234aa:	4770      	bx	lr
 80234ac:	ffffba5c 	.word	0xffffba5c
 80234b0:	ffffe566 	.word	0xffffe566
 80234b4:	ffffd4f6 	.word	0xffffd4f6
 80234b8:	ffffdc67 	.word	0xffffdc67
 80234bc:	ffffe42f 	.word	0xffffe42f

080234c0 <jpeg_idct_16x16>:

GLOBAL(void)
jpeg_idct_16x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80234c0:	b490      	push	{r4, r7}
 80234c2:	f5ad 7d1e 	sub.w	sp, sp, #632	@ 0x278
 80234c6:	af00      	add	r7, sp, #0
 80234c8:	f507 741e 	add.w	r4, r7, #632	@ 0x278
 80234cc:	f5a4 741b 	sub.w	r4, r4, #620	@ 0x26c
 80234d0:	6020      	str	r0, [r4, #0]
 80234d2:	f507 701e 	add.w	r0, r7, #632	@ 0x278
 80234d6:	f5a0 701c 	sub.w	r0, r0, #624	@ 0x270
 80234da:	6001      	str	r1, [r0, #0]
 80234dc:	f507 711e 	add.w	r1, r7, #632	@ 0x278
 80234e0:	f5a1 711d 	sub.w	r1, r1, #628	@ 0x274
 80234e4:	600a      	str	r2, [r1, #0]
 80234e6:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 80234ea:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 80234ee:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80234f0:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80234f4:	f5a3 731b 	sub.w	r3, r3, #620	@ 0x26c
 80234f8:	681b      	ldr	r3, [r3, #0]
 80234fa:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80234fe:	3380      	adds	r3, #128	@ 0x80
 8023500:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
  int workspace[8*16];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8023504:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 8023508:	f5a3 731d 	sub.w	r3, r3, #628	@ 0x274
 802350c:	681b      	ldr	r3, [r3, #0]
 802350e:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8023512:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 8023516:	f5a3 731c 	sub.w	r3, r3, #624	@ 0x270
 802351a:	681b      	ldr	r3, [r3, #0]
 802351c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802351e:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
  wsptr = workspace;
 8023522:	f107 0310 	add.w	r3, r7, #16
 8023526:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802352a:	2300      	movs	r3, #0
 802352c:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8023530:	e30a      	b.n	8023b48 <jpeg_idct_16x16+0x688>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8023532:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8023536:	f9b3 3000 	ldrsh.w	r3, [r3]
 802353a:	461a      	mov	r2, r3
 802353c:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023540:	681b      	ldr	r3, [r3, #0]
 8023542:	fb02 f303 	mul.w	r3, r2, r3
 8023546:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp0 <<= CONST_BITS;
 802354a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802354e:	035b      	lsls	r3, r3, #13
 8023550:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    /* Add fudge factor here for final descale. */
    tmp0 += 1 << (CONST_BITS-PASS1_BITS-1);
 8023554:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023558:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802355c:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8023560:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8023564:	3340      	adds	r3, #64	@ 0x40
 8023566:	f9b3 3000 	ldrsh.w	r3, [r3]
 802356a:	461a      	mov	r2, r3
 802356c:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023570:	3380      	adds	r3, #128	@ 0x80
 8023572:	681b      	ldr	r3, [r3, #0]
 8023574:	fb02 f303 	mul.w	r3, r2, r3
 8023578:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 802357c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023580:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8023584:	fb02 f303 	mul.w	r3, r2, r3
 8023588:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 802358c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023590:	f241 1251 	movw	r2, #4433	@ 0x1151
 8023594:	fb02 f303 	mul.w	r3, r2, r3
 8023598:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 802359c:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80235a0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80235a4:	4413      	add	r3, r2
 80235a6:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = tmp0 - tmp1;
 80235aa:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80235ae:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80235b2:	1ad3      	subs	r3, r2, r3
 80235b4:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = tmp0 + tmp2;
 80235b8:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80235bc:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80235c0:	4413      	add	r3, r2
 80235c2:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp13 = tmp0 - tmp2;
 80235c6:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80235ca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80235ce:	1ad3      	subs	r3, r2, r3
 80235d0:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80235d4:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80235d8:	3320      	adds	r3, #32
 80235da:	f9b3 3000 	ldrsh.w	r3, [r3]
 80235de:	461a      	mov	r2, r3
 80235e0:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80235e4:	3340      	adds	r3, #64	@ 0x40
 80235e6:	681b      	ldr	r3, [r3, #0]
 80235e8:	fb02 f303 	mul.w	r3, r2, r3
 80235ec:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80235f0:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80235f4:	3360      	adds	r3, #96	@ 0x60
 80235f6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80235fa:	461a      	mov	r2, r3
 80235fc:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023600:	33c0      	adds	r3, #192	@ 0xc0
 8023602:	681b      	ldr	r3, [r3, #0]
 8023604:	fb02 f303 	mul.w	r3, r2, r3
 8023608:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = z1 - z2;
 802360c:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023610:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023614:	1ad3      	subs	r3, r2, r3
 8023616:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 802361a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802361e:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 8023622:	fb02 f303 	mul.w	r3, r2, r3
 8023626:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 802362a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802362e:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8023632:	fb02 f303 	mul.w	r3, r2, r3
 8023636:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 802363a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802363e:	f245 2203 	movw	r2, #20995	@ 0x5203
 8023642:	fb02 f303 	mul.w	r3, r2, r3
 8023646:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802364a:	4413      	add	r3, r2
 802364c:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8023650:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023654:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8023658:	fb02 f303 	mul.w	r3, r2, r3
 802365c:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8023660:	4413      	add	r3, r2
 8023662:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8023666:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802366a:	4af4      	ldr	r2, [pc, #976]	@ (8023a3c <jpeg_idct_16x16+0x57c>)
 802366c:	fb02 f303 	mul.w	r3, r2, r3
 8023670:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023674:	4413      	add	r3, r2
 8023676:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 802367a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802367e:	4af0      	ldr	r2, [pc, #960]	@ (8023a40 <jpeg_idct_16x16+0x580>)
 8023680:	fb02 f303 	mul.w	r3, r2, r3
 8023684:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8023688:	4413      	add	r3, r2
 802368a:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp20 = tmp10 + tmp0;
 802368e:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023692:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023696:	4413      	add	r3, r2
 8023698:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 802369c:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 80236a0:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80236a4:	1ad3      	subs	r3, r2, r3
 80236a6:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 80236aa:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80236ae:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80236b2:	4413      	add	r3, r2
 80236b4:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 80236b8:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80236bc:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80236c0:	1ad3      	subs	r3, r2, r3
 80236c2:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 80236c6:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80236ca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80236ce:	4413      	add	r3, r2
 80236d0:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 80236d4:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80236d8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80236dc:	1ad3      	subs	r3, r2, r3
 80236de:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 80236e2:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80236e6:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80236ea:	4413      	add	r3, r2
 80236ec:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 80236f0:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80236f4:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80236f8:	1ad3      	subs	r3, r2, r3
 80236fa:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80236fe:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8023702:	3310      	adds	r3, #16
 8023704:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023708:	461a      	mov	r2, r3
 802370a:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802370e:	3320      	adds	r3, #32
 8023710:	681b      	ldr	r3, [r3, #0]
 8023712:	fb02 f303 	mul.w	r3, r2, r3
 8023716:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802371a:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 802371e:	3330      	adds	r3, #48	@ 0x30
 8023720:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023724:	461a      	mov	r2, r3
 8023726:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802372a:	3360      	adds	r3, #96	@ 0x60
 802372c:	681b      	ldr	r3, [r3, #0]
 802372e:	fb02 f303 	mul.w	r3, r2, r3
 8023732:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8023736:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 802373a:	3350      	adds	r3, #80	@ 0x50
 802373c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023740:	461a      	mov	r2, r3
 8023742:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023746:	33a0      	adds	r3, #160	@ 0xa0
 8023748:	681b      	ldr	r3, [r3, #0]
 802374a:	fb02 f303 	mul.w	r3, r2, r3
 802374e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8023752:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8023756:	3370      	adds	r3, #112	@ 0x70
 8023758:	f9b3 3000 	ldrsh.w	r3, [r3]
 802375c:	461a      	mov	r2, r3
 802375e:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023762:	33e0      	adds	r3, #224	@ 0xe0
 8023764:	681b      	ldr	r3, [r3, #0]
 8023766:	fb02 f303 	mul.w	r3, r2, r3
 802376a:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234

    tmp11 = z1 + z3;
 802376e:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023772:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023776:	4413      	add	r3, r2
 8023778:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 802377c:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023780:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023784:	4413      	add	r3, r2
 8023786:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 802378a:	fb02 f303 	mul.w	r3, r2, r3
 802378e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8023792:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023796:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 802379a:	fb02 f303 	mul.w	r3, r2, r3
 802379e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 80237a2:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80237a6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80237aa:	4413      	add	r3, r2
 80237ac:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 80237b0:	fb02 f303 	mul.w	r3, r2, r3
 80237b4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 80237b8:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80237bc:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80237c0:	1ad3      	subs	r3, r2, r3
 80237c2:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 80237c6:	fb02 f303 	mul.w	r3, r2, r3
 80237ca:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 80237ce:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80237d2:	f241 5255 	movw	r2, #5461	@ 0x1555
 80237d6:	fb02 f303 	mul.w	r3, r2, r3
 80237da:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 80237de:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80237e2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80237e6:	1ad3      	subs	r3, r2, r3
 80237e8:	f640 5223 	movw	r2, #3363	@ 0xd23
 80237ec:	fb02 f303 	mul.w	r3, r2, r3
 80237f0:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 80237f4:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80237f8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80237fc:	441a      	add	r2, r3
 80237fe:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023802:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8023804:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023808:	498e      	ldr	r1, [pc, #568]	@ (8023a44 <jpeg_idct_16x16+0x584>)
 802380a:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 802380e:	4413      	add	r3, r2
 8023810:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 8023814:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023818:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 802381c:	441a      	add	r2, r3
 802381e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8023822:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8023824:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023828:	4987      	ldr	r1, [pc, #540]	@ (8023a48 <jpeg_idct_16x16+0x588>)
 802382a:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 802382e:	4413      	add	r3, r2
 8023830:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8023834:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023838:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802383c:	4413      	add	r3, r2
 802383e:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 8023842:	fb02 f303 	mul.w	r3, r2, r3
 8023846:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 802384a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802384e:	f240 224d 	movw	r2, #589	@ 0x24d
 8023852:	fb03 f202 	mul.w	r2, r3, r2
 8023856:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802385a:	4413      	add	r3, r2
 802385c:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8023860:	4413      	add	r3, r2
 8023862:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8023866:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802386a:	4a78      	ldr	r2, [pc, #480]	@ (8023a4c <jpeg_idct_16x16+0x58c>)
 802386c:	fb03 f202 	mul.w	r2, r3, r2
 8023870:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023874:	4413      	add	r3, r2
 8023876:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 802387a:	4413      	add	r3, r2
 802387c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8023880:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023884:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023888:	1ad3      	subs	r3, r2, r3
 802388a:	f642 5209 	movw	r2, #11529	@ 0x2d09
 802388e:	fb02 f303 	mul.w	r3, r2, r3
 8023892:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8023896:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802389a:	4a6d      	ldr	r2, [pc, #436]	@ (8023a50 <jpeg_idct_16x16+0x590>)
 802389c:	fb03 f202 	mul.w	r2, r3, r2
 80238a0:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80238a4:	4413      	add	r3, r2
 80238a6:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80238aa:	4413      	add	r3, r2
 80238ac:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 80238b0:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80238b4:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 80238b8:	fb03 f202 	mul.w	r2, r3, r2
 80238bc:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80238c0:	4413      	add	r3, r2
 80238c2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80238c6:	4413      	add	r3, r2
 80238c8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    += z4;
 80238cc:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80238d0:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80238d4:	4413      	add	r3, r2
 80238d6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 80238da:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80238de:	4a5d      	ldr	r2, [pc, #372]	@ (8023a54 <jpeg_idct_16x16+0x594>)
 80238e0:	fb02 f303 	mul.w	r3, r2, r3
 80238e4:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1;
 80238e8:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80238ec:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80238f0:	4413      	add	r3, r2
 80238f2:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 80238f6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80238fa:	f242 2218 	movw	r2, #8728	@ 0x2218
 80238fe:	fb03 f202 	mul.w	r2, r3, r2
 8023902:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023906:	4413      	add	r3, r2
 8023908:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802390c:	4413      	add	r3, r2
 802390e:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8023912:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023916:	4a50      	ldr	r2, [pc, #320]	@ (8023a58 <jpeg_idct_16x16+0x598>)
 8023918:	fb02 f303 	mul.w	r3, r2, r3
 802391c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8023920:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023924:	f246 4285 	movw	r2, #25733	@ 0x6485
 8023928:	fb03 f202 	mul.w	r2, r3, r2
 802392c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023930:	4413      	add	r3, r2
 8023932:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023936:	4413      	add	r3, r2
 8023938:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp12 += z2;
 802393c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023940:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023944:	4413      	add	r3, r2
 8023946:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 802394a:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802394e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023952:	4413      	add	r3, r2
 8023954:	4a41      	ldr	r2, [pc, #260]	@ (8023a5c <jpeg_idct_16x16+0x59c>)
 8023956:	fb02 f303 	mul.w	r3, r2, r3
 802395a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp2  += z2;
 802395e:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8023962:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023966:	4413      	add	r3, r2
 8023968:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 802396c:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8023970:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023974:	4413      	add	r3, r2
 8023976:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 802397a:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802397e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023982:	1ad3      	subs	r3, r2, r3
 8023984:	f640 5223 	movw	r2, #3363	@ 0xd23
 8023988:	fb02 f303 	mul.w	r3, r2, r3
 802398c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2;
 8023990:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023994:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023998:	4413      	add	r3, r2
 802399a:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 += z2;
 802399e:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80239a2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80239a6:	4413      	add	r3, r2
 80239a8:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 80239ac:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 80239b0:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80239b4:	4413      	add	r3, r2
 80239b6:	12da      	asrs	r2, r3, #11
 80239b8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80239bc:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 80239be:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 80239c2:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80239c6:	1ad2      	subs	r2, r2, r3
 80239c8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80239cc:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
 80239d0:	12d2      	asrs	r2, r2, #11
 80239d2:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 80239d4:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80239d8:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80239dc:	441a      	add	r2, r3
 80239de:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80239e2:	3320      	adds	r3, #32
 80239e4:	12d2      	asrs	r2, r2, #11
 80239e6:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 80239e8:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80239ec:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80239f0:	1ad2      	subs	r2, r2, r3
 80239f2:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80239f6:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80239fa:	12d2      	asrs	r2, r2, #11
 80239fc:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 80239fe:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8023a02:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023a06:	441a      	add	r2, r3
 8023a08:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a0c:	3340      	adds	r3, #64	@ 0x40
 8023a0e:	12d2      	asrs	r2, r2, #11
 8023a10:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 8023a12:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8023a16:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023a1a:	1ad2      	subs	r2, r2, r3
 8023a1c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a20:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8023a24:	12d2      	asrs	r2, r2, #11
 8023a26:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 8023a28:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8023a2c:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023a30:	441a      	add	r2, r3
 8023a32:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a36:	3360      	adds	r3, #96	@ 0x60
 8023a38:	12d2      	asrs	r2, r2, #11
 8023a3a:	e011      	b.n	8023a60 <jpeg_idct_16x16+0x5a0>
 8023a3c:	ffffecc2 	.word	0xffffecc2
 8023a40:	ffffefb0 	.word	0xffffefb0
 8023a44:	ffffb6d6 	.word	0xffffb6d6
 8023a48:	ffffc542 	.word	0xffffc542
 8023a4c:	ffffdbfa 	.word	0xffffdbfa
 8023a50:	ffffe77a 	.word	0xffffe77a
 8023a54:	ffffeaab 	.word	0xffffeaab
 8023a58:	ffffd817 	.word	0xffffd817
 8023a5c:	ffffd4b2 	.word	0xffffd4b2
 8023a60:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 8023a62:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8023a66:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023a6a:	1ad2      	subs	r2, r2, r3
 8023a6c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a70:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8023a74:	12d2      	asrs	r2, r2, #11
 8023a76:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 8023a78:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8023a7c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8023a80:	441a      	add	r2, r3
 8023a82:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a86:	3380      	adds	r3, #128	@ 0x80
 8023a88:	12d2      	asrs	r2, r2, #11
 8023a8a:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 8023a8c:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8023a90:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8023a94:	1ad2      	subs	r2, r2, r3
 8023a96:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023a9a:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8023a9e:	12d2      	asrs	r2, r2, #11
 8023aa0:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 8023aa2:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8023aa6:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023aaa:	441a      	add	r2, r3
 8023aac:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023ab0:	33a0      	adds	r3, #160	@ 0xa0
 8023ab2:	12d2      	asrs	r2, r2, #11
 8023ab4:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 8023ab6:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8023aba:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023abe:	1ad2      	subs	r2, r2, r3
 8023ac0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023ac4:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8023ac8:	12d2      	asrs	r2, r2, #11
 8023aca:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 8023acc:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8023ad0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8023ad4:	441a      	add	r2, r3
 8023ad6:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023ada:	33c0      	adds	r3, #192	@ 0xc0
 8023adc:	12d2      	asrs	r2, r2, #11
 8023ade:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 8023ae0:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8023ae4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8023ae8:	1ad2      	subs	r2, r2, r3
 8023aea:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023aee:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8023af2:	12d2      	asrs	r2, r2, #11
 8023af4:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 8023af6:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8023afa:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023afe:	441a      	add	r2, r3
 8023b00:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023b04:	33e0      	adds	r3, #224	@ 0xe0
 8023b06:	12d2      	asrs	r2, r2, #11
 8023b08:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 8023b0a:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8023b0e:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8023b12:	1ad2      	subs	r2, r2, r3
 8023b14:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023b18:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8023b1c:	12d2      	asrs	r2, r2, #11
 8023b1e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8023b20:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8023b24:	3301      	adds	r3, #1
 8023b26:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8023b2a:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8023b2e:	3302      	adds	r3, #2
 8023b30:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
 8023b34:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8023b38:	3304      	adds	r3, #4
 8023b3a:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
 8023b3e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023b42:	3304      	adds	r3, #4
 8023b44:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
 8023b48:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8023b4c:	2b07      	cmp	r3, #7
 8023b4e:	f77f acf0 	ble.w	8023532 <jpeg_idct_16x16+0x72>
  }

  /* Pass 2: process 16 rows from work array, store into output array. */

  wsptr = workspace;
 8023b52:	f107 0310 	add.w	r3, r7, #16
 8023b56:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 8023b5a:	2300      	movs	r3, #0
 8023b5c:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8023b60:	e324      	b.n	80241ac <jpeg_idct_16x16+0xcec>
    outptr = output_buf[ctr] + output_col;
 8023b62:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8023b66:	009b      	lsls	r3, r3, #2
 8023b68:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 8023b6c:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 8023b70:	6812      	ldr	r2, [r2, #0]
 8023b72:	4413      	add	r3, r2
 8023b74:	681a      	ldr	r2, [r3, #0]
 8023b76:	f8d7 3280 	ldr.w	r3, [r7, #640]	@ 0x280
 8023b7a:	4413      	add	r3, r2
 8023b7c:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8023b80:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023b84:	681b      	ldr	r3, [r3, #0]
 8023b86:	3310      	adds	r3, #16
 8023b88:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp0 <<= CONST_BITS;
 8023b8c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023b90:	035b      	lsls	r3, r3, #13
 8023b92:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c

    z1 = (INT32) wsptr[4];
 8023b96:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023b9a:	3310      	adds	r3, #16
 8023b9c:	681b      	ldr	r3, [r3, #0]
 8023b9e:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8023ba2:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023ba6:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8023baa:	fb02 f303 	mul.w	r3, r2, r3
 8023bae:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8023bb2:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023bb6:	f241 1251 	movw	r2, #4433	@ 0x1151
 8023bba:	fb02 f303 	mul.w	r3, r2, r3
 8023bbe:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 8023bc2:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8023bc6:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023bca:	4413      	add	r3, r2
 8023bcc:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = tmp0 - tmp1;
 8023bd0:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8023bd4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023bd8:	1ad3      	subs	r3, r2, r3
 8023bda:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = tmp0 + tmp2;
 8023bde:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8023be2:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023be6:	4413      	add	r3, r2
 8023be8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp13 = tmp0 - tmp2;
 8023bec:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8023bf0:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023bf4:	1ad3      	subs	r3, r2, r3
 8023bf6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    z1 = (INT32) wsptr[2];
 8023bfa:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023bfe:	3308      	adds	r3, #8
 8023c00:	681b      	ldr	r3, [r3, #0]
 8023c02:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = (INT32) wsptr[6];
 8023c06:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023c0a:	3318      	adds	r3, #24
 8023c0c:	681b      	ldr	r3, [r3, #0]
 8023c0e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = z1 - z2;
 8023c12:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023c16:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023c1a:	1ad3      	subs	r3, r2, r3
 8023c1c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8023c20:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023c24:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 8023c28:	fb02 f303 	mul.w	r3, r2, r3
 8023c2c:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8023c30:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023c34:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8023c38:	fb02 f303 	mul.w	r3, r2, r3
 8023c3c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8023c40:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023c44:	f245 2203 	movw	r2, #20995	@ 0x5203
 8023c48:	fb02 f303 	mul.w	r3, r2, r3
 8023c4c:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023c50:	4413      	add	r3, r2
 8023c52:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8023c56:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023c5a:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8023c5e:	fb02 f303 	mul.w	r3, r2, r3
 8023c62:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8023c66:	4413      	add	r3, r2
 8023c68:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8023c6c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023c70:	4af4      	ldr	r2, [pc, #976]	@ (8024044 <jpeg_idct_16x16+0xb84>)
 8023c72:	fb02 f303 	mul.w	r3, r2, r3
 8023c76:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023c7a:	4413      	add	r3, r2
 8023c7c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8023c80:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023c84:	4af0      	ldr	r2, [pc, #960]	@ (8024048 <jpeg_idct_16x16+0xb88>)
 8023c86:	fb02 f303 	mul.w	r3, r2, r3
 8023c8a:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8023c8e:	4413      	add	r3, r2
 8023c90:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp20 = tmp10 + tmp0;
 8023c94:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023c98:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023c9c:	4413      	add	r3, r2
 8023c9e:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 8023ca2:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023ca6:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023caa:	1ad3      	subs	r3, r2, r3
 8023cac:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 8023cb0:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023cb4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023cb8:	4413      	add	r3, r2
 8023cba:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 8023cbe:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023cc2:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023cc6:	1ad3      	subs	r3, r2, r3
 8023cc8:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 8023ccc:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8023cd0:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023cd4:	4413      	add	r3, r2
 8023cd6:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 8023cda:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8023cde:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023ce2:	1ad3      	subs	r3, r2, r3
 8023ce4:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 8023ce8:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8023cec:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023cf0:	4413      	add	r3, r2
 8023cf2:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 8023cf6:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8023cfa:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023cfe:	1ad3      	subs	r3, r2, r3
 8023d00:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8023d04:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023d08:	3304      	adds	r3, #4
 8023d0a:	681b      	ldr	r3, [r3, #0]
 8023d0c:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = (INT32) wsptr[3];
 8023d10:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023d14:	330c      	adds	r3, #12
 8023d16:	681b      	ldr	r3, [r3, #0]
 8023d18:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = (INT32) wsptr[5];
 8023d1c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023d20:	3314      	adds	r3, #20
 8023d22:	681b      	ldr	r3, [r3, #0]
 8023d24:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = (INT32) wsptr[7];
 8023d28:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8023d2c:	331c      	adds	r3, #28
 8023d2e:	681b      	ldr	r3, [r3, #0]
 8023d30:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234

    tmp11 = z1 + z3;
 8023d34:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023d38:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023d3c:	4413      	add	r3, r2
 8023d3e:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8023d42:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023d46:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023d4a:	4413      	add	r3, r2
 8023d4c:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 8023d50:	fb02 f303 	mul.w	r3, r2, r3
 8023d54:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8023d58:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023d5c:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 8023d60:	fb02 f303 	mul.w	r3, r2, r3
 8023d64:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8023d68:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023d6c:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023d70:	4413      	add	r3, r2
 8023d72:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 8023d76:	fb02 f303 	mul.w	r3, r2, r3
 8023d7a:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8023d7e:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023d82:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023d86:	1ad3      	subs	r3, r2, r3
 8023d88:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 8023d8c:	fb02 f303 	mul.w	r3, r2, r3
 8023d90:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8023d94:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023d98:	f241 5255 	movw	r2, #5461	@ 0x1555
 8023d9c:	fb02 f303 	mul.w	r3, r2, r3
 8023da0:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8023da4:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8023da8:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023dac:	1ad3      	subs	r3, r2, r3
 8023dae:	f640 5223 	movw	r2, #3363	@ 0xd23
 8023db2:	fb02 f303 	mul.w	r3, r2, r3
 8023db6:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 8023dba:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8023dbe:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023dc2:	441a      	add	r2, r3
 8023dc4:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8023dc8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8023dca:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023dce:	499f      	ldr	r1, [pc, #636]	@ (802404c <jpeg_idct_16x16+0xb8c>)
 8023dd0:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 8023dd4:	4413      	add	r3, r2
 8023dd6:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 8023dda:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023dde:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8023de2:	441a      	add	r2, r3
 8023de4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8023de8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8023dea:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023dee:	4998      	ldr	r1, [pc, #608]	@ (8024050 <jpeg_idct_16x16+0xb90>)
 8023df0:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 8023df4:	4413      	add	r3, r2
 8023df6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8023dfa:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023dfe:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023e02:	4413      	add	r3, r2
 8023e04:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 8023e08:	fb02 f303 	mul.w	r3, r2, r3
 8023e0c:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8023e10:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023e14:	f240 224d 	movw	r2, #589	@ 0x24d
 8023e18:	fb03 f202 	mul.w	r2, r3, r2
 8023e1c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023e20:	4413      	add	r3, r2
 8023e22:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8023e26:	4413      	add	r3, r2
 8023e28:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8023e2c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023e30:	4a88      	ldr	r2, [pc, #544]	@ (8024054 <jpeg_idct_16x16+0xb94>)
 8023e32:	fb03 f202 	mul.w	r2, r3, r2
 8023e36:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023e3a:	4413      	add	r3, r2
 8023e3c:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8023e40:	4413      	add	r3, r2
 8023e42:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8023e46:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023e4a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023e4e:	1ad3      	subs	r3, r2, r3
 8023e50:	f642 5209 	movw	r2, #11529	@ 0x2d09
 8023e54:	fb02 f303 	mul.w	r3, r2, r3
 8023e58:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8023e5c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023e60:	4a7d      	ldr	r2, [pc, #500]	@ (8024058 <jpeg_idct_16x16+0xb98>)
 8023e62:	fb03 f202 	mul.w	r2, r3, r2
 8023e66:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023e6a:	4413      	add	r3, r2
 8023e6c:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8023e70:	4413      	add	r3, r2
 8023e72:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 8023e76:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023e7a:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 8023e7e:	fb03 f202 	mul.w	r2, r3, r2
 8023e82:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023e86:	4413      	add	r3, r2
 8023e88:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023e8c:	4413      	add	r3, r2
 8023e8e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    += z4;
 8023e92:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8023e96:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023e9a:	4413      	add	r3, r2
 8023e9c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 8023ea0:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023ea4:	4a6d      	ldr	r2, [pc, #436]	@ (802405c <jpeg_idct_16x16+0xb9c>)
 8023ea6:	fb02 f303 	mul.w	r3, r2, r3
 8023eaa:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1;
 8023eae:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8023eb2:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023eb6:	4413      	add	r3, r2
 8023eb8:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8023ebc:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023ec0:	f242 2218 	movw	r2, #8728	@ 0x2218
 8023ec4:	fb03 f202 	mul.w	r2, r3, r2
 8023ec8:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8023ecc:	4413      	add	r3, r2
 8023ece:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8023ed2:	4413      	add	r3, r2
 8023ed4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8023ed8:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023edc:	4a60      	ldr	r2, [pc, #384]	@ (8024060 <jpeg_idct_16x16+0xba0>)
 8023ede:	fb02 f303 	mul.w	r3, r2, r3
 8023ee2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8023ee6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023eea:	f246 4285 	movw	r2, #25733	@ 0x6485
 8023eee:	fb03 f202 	mul.w	r2, r3, r2
 8023ef2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023ef6:	4413      	add	r3, r2
 8023ef8:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023efc:	4413      	add	r3, r2
 8023efe:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp12 += z2;
 8023f02:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8023f06:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023f0a:	4413      	add	r3, r2
 8023f0c:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8023f10:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8023f14:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8023f18:	4413      	add	r3, r2
 8023f1a:	4a52      	ldr	r2, [pc, #328]	@ (8024064 <jpeg_idct_16x16+0xba4>)
 8023f1c:	fb02 f303 	mul.w	r3, r2, r3
 8023f20:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp2  += z2;
 8023f24:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8023f28:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023f2c:	4413      	add	r3, r2
 8023f2e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 8023f32:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8023f36:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023f3a:	4413      	add	r3, r2
 8023f3c:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8023f40:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8023f44:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8023f48:	1ad3      	subs	r3, r2, r3
 8023f4a:	f640 5223 	movw	r2, #3363	@ 0xd23
 8023f4e:	fb02 f303 	mul.w	r3, r2, r3
 8023f52:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2;
 8023f56:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8023f5a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023f5e:	4413      	add	r3, r2
 8023f60:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 += z2;
 8023f64:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8023f68:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8023f6c:	4413      	add	r3, r2
 8023f6e:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8023f72:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8023f76:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023f7a:	4413      	add	r3, r2
 8023f7c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023f7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8023f82:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8023f86:	4413      	add	r3, r2
 8023f88:	781a      	ldrb	r2, [r3, #0]
 8023f8a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8023f8e:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8023f90:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8023f94:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8023f98:	1ad3      	subs	r3, r2, r3
 8023f9a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023f9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8023fa0:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8023fa4:	441a      	add	r2, r3
 8023fa6:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8023faa:	330f      	adds	r3, #15
 8023fac:	7812      	ldrb	r2, [r2, #0]
 8023fae:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8023fb0:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8023fb4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023fb8:	4413      	add	r3, r2
 8023fba:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023fbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8023fc0:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8023fc4:	441a      	add	r2, r3
 8023fc6:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8023fca:	3301      	adds	r3, #1
 8023fcc:	7812      	ldrb	r2, [r2, #0]
 8023fce:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8023fd0:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8023fd4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8023fd8:	1ad3      	subs	r3, r2, r3
 8023fda:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023fdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8023fe0:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8023fe4:	441a      	add	r2, r3
 8023fe6:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8023fea:	330e      	adds	r3, #14
 8023fec:	7812      	ldrb	r2, [r2, #0]
 8023fee:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8023ff0:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8023ff4:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8023ff8:	4413      	add	r3, r2
 8023ffa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023ffc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8024000:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8024004:	441a      	add	r2, r3
 8024006:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802400a:	3302      	adds	r3, #2
 802400c:	7812      	ldrb	r2, [r2, #0]
 802400e:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8024010:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024014:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8024018:	1ad3      	subs	r3, r2, r3
 802401a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802401c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8024020:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8024024:	441a      	add	r2, r3
 8024026:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802402a:	330d      	adds	r3, #13
 802402c:	7812      	ldrb	r2, [r2, #0]
 802402e:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8024030:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024034:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024038:	4413      	add	r3, r2
 802403a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802403c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8024040:	e012      	b.n	8024068 <jpeg_idct_16x16+0xba8>
 8024042:	bf00      	nop
 8024044:	ffffecc2 	.word	0xffffecc2
 8024048:	ffffefb0 	.word	0xffffefb0
 802404c:	ffffb6d6 	.word	0xffffb6d6
 8024050:	ffffc542 	.word	0xffffc542
 8024054:	ffffdbfa 	.word	0xffffdbfa
 8024058:	ffffe77a 	.word	0xffffe77a
 802405c:	ffffeaab 	.word	0xffffeaab
 8024060:	ffffd817 	.word	0xffffd817
 8024064:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8024068:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802406c:	441a      	add	r2, r3
 802406e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024072:	3303      	adds	r3, #3
 8024074:	7812      	ldrb	r2, [r2, #0]
 8024076:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8024078:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802407c:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024080:	1ad3      	subs	r3, r2, r3
 8024082:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024084:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8024088:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802408c:	441a      	add	r2, r3
 802408e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024092:	330c      	adds	r3, #12
 8024094:	7812      	ldrb	r2, [r2, #0]
 8024096:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8024098:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 802409c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80240a0:	4413      	add	r3, r2
 80240a2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80240a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 80240a8:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80240ac:	441a      	add	r2, r3
 80240ae:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80240b2:	3304      	adds	r3, #4
 80240b4:	7812      	ldrb	r2, [r2, #0]
 80240b6:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 80240b8:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 80240bc:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80240c0:	1ad3      	subs	r3, r2, r3
 80240c2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80240c4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 80240c8:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80240cc:	441a      	add	r2, r3
 80240ce:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80240d2:	330b      	adds	r3, #11
 80240d4:	7812      	ldrb	r2, [r2, #0]
 80240d6:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 80240d8:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80240dc:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80240e0:	4413      	add	r3, r2
 80240e2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80240e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 80240e8:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80240ec:	441a      	add	r2, r3
 80240ee:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80240f2:	3305      	adds	r3, #5
 80240f4:	7812      	ldrb	r2, [r2, #0]
 80240f6:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 80240f8:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80240fc:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8024100:	1ad3      	subs	r3, r2, r3
 8024102:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024104:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 8024108:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802410c:	441a      	add	r2, r3
 802410e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024112:	330a      	adds	r3, #10
 8024114:	7812      	ldrb	r2, [r2, #0]
 8024116:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8024118:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 802411c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8024120:	4413      	add	r3, r2
 8024122:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024124:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8024128:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802412c:	441a      	add	r2, r3
 802412e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024132:	3306      	adds	r3, #6
 8024134:	7812      	ldrb	r2, [r2, #0]
 8024136:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8024138:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 802413c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8024140:	1ad3      	subs	r3, r2, r3
 8024142:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024144:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8024148:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802414c:	441a      	add	r2, r3
 802414e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024152:	3309      	adds	r3, #9
 8024154:	7812      	ldrb	r2, [r2, #0]
 8024156:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8024158:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 802415c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8024160:	4413      	add	r3, r2
 8024162:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024164:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8024168:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802416c:	441a      	add	r2, r3
 802416e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024172:	3307      	adds	r3, #7
 8024174:	7812      	ldrb	r2, [r2, #0]
 8024176:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8024178:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 802417c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8024180:	1ad3      	subs	r3, r2, r3
 8024182:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024184:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8024188:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802418c:	441a      	add	r2, r3
 802418e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8024192:	3308      	adds	r3, #8
 8024194:	7812      	ldrb	r2, [r2, #0]
 8024196:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8024198:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802419c:	3320      	adds	r3, #32
 802419e:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 80241a2:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 80241a6:	3301      	adds	r3, #1
 80241a8:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 80241ac:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 80241b0:	2b0f      	cmp	r3, #15
 80241b2:	f77f acd6 	ble.w	8023b62 <jpeg_idct_16x16+0x6a2>
  }
}
 80241b6:	bf00      	nop
 80241b8:	bf00      	nop
 80241ba:	f507 771e 	add.w	r7, r7, #632	@ 0x278
 80241be:	46bd      	mov	sp, r7
 80241c0:	bc90      	pop	{r4, r7}
 80241c2:	4770      	bx	lr

080241c4 <jpeg_idct_16x8>:

GLOBAL(void)
jpeg_idct_16x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80241c4:	b490      	push	{r4, r7}
 80241c6:	b0e0      	sub	sp, #384	@ 0x180
 80241c8:	af00      	add	r7, sp, #0
 80241ca:	f507 74c0 	add.w	r4, r7, #384	@ 0x180
 80241ce:	f5a4 74ba 	sub.w	r4, r4, #372	@ 0x174
 80241d2:	6020      	str	r0, [r4, #0]
 80241d4:	f507 70c0 	add.w	r0, r7, #384	@ 0x180
 80241d8:	f5a0 70bc 	sub.w	r0, r0, #376	@ 0x178
 80241dc:	6001      	str	r1, [r0, #0]
 80241de:	f507 71c0 	add.w	r1, r7, #384	@ 0x180
 80241e2:	f5a1 71be 	sub.w	r1, r1, #380	@ 0x17c
 80241e6:	600a      	str	r2, [r1, #0]
 80241e8:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 80241ec:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 80241f0:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80241f2:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80241f6:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 80241fa:	681b      	ldr	r3, [r3, #0]
 80241fc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8024200:	3380      	adds	r3, #128	@ 0x80
 8024202:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 8024206:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 802420a:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 802420e:	681b      	ldr	r3, [r3, #0]
 8024210:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024214:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 8024218:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 802421c:	681b      	ldr	r3, [r3, #0]
 802421e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8024220:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
  wsptr = workspace;
 8024224:	f107 0314 	add.w	r3, r7, #20
 8024228:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 802422c:	2308      	movs	r3, #8
 802422e:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8024232:	e238      	b.n	80246a6 <jpeg_idct_16x8+0x4e2>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8024234:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024238:	3310      	adds	r3, #16
 802423a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802423e:	2b00      	cmp	r3, #0
 8024240:	d175      	bne.n	802432e <jpeg_idct_16x8+0x16a>
 8024242:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024246:	3320      	adds	r3, #32
 8024248:	f9b3 3000 	ldrsh.w	r3, [r3]
 802424c:	2b00      	cmp	r3, #0
 802424e:	d16e      	bne.n	802432e <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8024250:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024254:	3330      	adds	r3, #48	@ 0x30
 8024256:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 802425a:	2b00      	cmp	r3, #0
 802425c:	d167      	bne.n	802432e <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802425e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024262:	3340      	adds	r3, #64	@ 0x40
 8024264:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024268:	2b00      	cmp	r3, #0
 802426a:	d160      	bne.n	802432e <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802426c:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024270:	3350      	adds	r3, #80	@ 0x50
 8024272:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8024276:	2b00      	cmp	r3, #0
 8024278:	d159      	bne.n	802432e <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802427a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802427e:	3360      	adds	r3, #96	@ 0x60
 8024280:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024284:	2b00      	cmp	r3, #0
 8024286:	d152      	bne.n	802432e <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*7] == 0) {
 8024288:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802428c:	3370      	adds	r3, #112	@ 0x70
 802428e:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8024292:	2b00      	cmp	r3, #0
 8024294:	d14b      	bne.n	802432e <jpeg_idct_16x8+0x16a>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 8024296:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802429a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802429e:	461a      	mov	r2, r3
 80242a0:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80242a4:	681b      	ldr	r3, [r3, #0]
 80242a6:	fb02 f303 	mul.w	r3, r2, r3
 80242aa:	009b      	lsls	r3, r3, #2
 80242ac:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      
      wsptr[DCTSIZE*0] = dcval;
 80242b0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242b4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242b8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 80242ba:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242be:	3320      	adds	r3, #32
 80242c0:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242c4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 80242c6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242ca:	3340      	adds	r3, #64	@ 0x40
 80242cc:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242d0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 80242d2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242d6:	3360      	adds	r3, #96	@ 0x60
 80242d8:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242dc:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 80242de:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242e2:	3380      	adds	r3, #128	@ 0x80
 80242e4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242e8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 80242ea:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242ee:	33a0      	adds	r3, #160	@ 0xa0
 80242f0:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80242f4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 80242f6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80242fa:	33c0      	adds	r3, #192	@ 0xc0
 80242fc:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8024300:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 8024302:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024306:	33e0      	adds	r3, #224	@ 0xe0
 8024308:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802430c:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 802430e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024312:	3302      	adds	r3, #2
 8024314:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
      quantptr++;
 8024318:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802431c:	3304      	adds	r3, #4
 802431e:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
      wsptr++;
 8024322:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024326:	3304      	adds	r3, #4
 8024328:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
      continue;
 802432c:	e1b6      	b.n	802469c <jpeg_idct_16x8+0x4d8>
    }
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802432e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024332:	3320      	adds	r3, #32
 8024334:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024338:	461a      	mov	r2, r3
 802433a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802433e:	3340      	adds	r3, #64	@ 0x40
 8024340:	681b      	ldr	r3, [r3, #0]
 8024342:	fb02 f303 	mul.w	r3, r2, r3
 8024346:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802434a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802434e:	3360      	adds	r3, #96	@ 0x60
 8024350:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024354:	461a      	mov	r2, r3
 8024356:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802435a:	33c0      	adds	r3, #192	@ 0xc0
 802435c:	681b      	ldr	r3, [r3, #0]
 802435e:	fb02 f303 	mul.w	r3, r2, r3
 8024362:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8024366:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 802436a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 802436e:	4413      	add	r3, r2
 8024370:	f241 1251 	movw	r2, #4433	@ 0x1151
 8024374:	fb02 f303 	mul.w	r3, r2, r3
 8024378:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 802437c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024380:	f641 027e 	movw	r2, #6270	@ 0x187e
 8024384:	fb02 f303 	mul.w	r3, r2, r3
 8024388:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802438c:	4413      	add	r3, r2
 802438e:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 8024392:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024396:	4aca      	ldr	r2, [pc, #808]	@ (80246c0 <jpeg_idct_16x8+0x4fc>)
 8024398:	fb02 f303 	mul.w	r3, r2, r3
 802439c:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80243a0:	4413      	add	r3, r2
 80243a2:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80243a6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80243aa:	f9b3 3000 	ldrsh.w	r3, [r3]
 80243ae:	461a      	mov	r2, r3
 80243b0:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80243b4:	681b      	ldr	r3, [r3, #0]
 80243b6:	fb02 f303 	mul.w	r3, r2, r3
 80243ba:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80243be:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80243c2:	3340      	adds	r3, #64	@ 0x40
 80243c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80243c8:	461a      	mov	r2, r3
 80243ca:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80243ce:	3380      	adds	r3, #128	@ 0x80
 80243d0:	681b      	ldr	r3, [r3, #0]
 80243d2:	fb02 f303 	mul.w	r3, r2, r3
 80243d6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z2 <<= CONST_BITS;
 80243da:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80243de:	035b      	lsls	r3, r3, #13
 80243e0:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 <<= CONST_BITS;
 80243e4:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80243e8:	035b      	lsls	r3, r3, #13
 80243ea:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 80243ee:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80243f2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80243f6:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = z2 + z3;
 80243fa:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80243fe:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024402:	4413      	add	r3, r2
 8024404:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = z2 - z3;
 8024408:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 802440c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024410:	1ad3      	subs	r3, r2, r3
 8024412:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    
    tmp10 = tmp0 + tmp2;
 8024416:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802441a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 802441e:	4413      	add	r3, r2
 8024420:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp13 = tmp0 - tmp2;
 8024424:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8024428:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 802442c:	1ad3      	subs	r3, r2, r3
 802442e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp11 = tmp1 + tmp3;
 8024432:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024436:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802443a:	4413      	add	r3, r2
 802443c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = tmp1 - tmp3;
 8024440:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024444:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024448:	1ad3      	subs	r3, r2, r3
 802444a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802444e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024452:	3370      	adds	r3, #112	@ 0x70
 8024454:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024458:	461a      	mov	r2, r3
 802445a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802445e:	33e0      	adds	r3, #224	@ 0xe0
 8024460:	681b      	ldr	r3, [r3, #0]
 8024462:	fb02 f303 	mul.w	r3, r2, r3
 8024466:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802446a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802446e:	3350      	adds	r3, #80	@ 0x50
 8024470:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024474:	461a      	mov	r2, r3
 8024476:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802447a:	33a0      	adds	r3, #160	@ 0xa0
 802447c:	681b      	ldr	r3, [r3, #0]
 802447e:	fb02 f303 	mul.w	r3, r2, r3
 8024482:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8024486:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802448a:	3330      	adds	r3, #48	@ 0x30
 802448c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024490:	461a      	mov	r2, r3
 8024492:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8024496:	3360      	adds	r3, #96	@ 0x60
 8024498:	681b      	ldr	r3, [r3, #0]
 802449a:	fb02 f303 	mul.w	r3, r2, r3
 802449e:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80244a2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80244a6:	3310      	adds	r3, #16
 80244a8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80244ac:	461a      	mov	r2, r3
 80244ae:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80244b2:	3320      	adds	r3, #32
 80244b4:	681b      	ldr	r3, [r3, #0]
 80244b6:	fb02 f303 	mul.w	r3, r2, r3
 80244ba:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    
    z2 = tmp0 + tmp2;
 80244be:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80244c2:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80244c6:	4413      	add	r3, r2
 80244c8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = tmp1 + tmp3;
 80244cc:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 80244d0:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80244d4:	4413      	add	r3, r2
 80244d6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 80244da:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80244de:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80244e2:	4413      	add	r3, r2
 80244e4:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 80244e8:	fb02 f303 	mul.w	r3, r2, r3
 80244ec:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80244f0:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80244f4:	4a73      	ldr	r2, [pc, #460]	@ (80246c4 <jpeg_idct_16x8+0x500>)
 80244f6:	fb02 f303 	mul.w	r3, r2, r3
 80244fa:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 80244fe:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024502:	4a71      	ldr	r2, [pc, #452]	@ (80246c8 <jpeg_idct_16x8+0x504>)
 8024504:	fb02 f303 	mul.w	r3, r2, r3
 8024508:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z2 += z1;
 802450c:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8024510:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024514:	4413      	add	r3, r2
 8024516:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 += z1;
 802451a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 802451e:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024522:	4413      	add	r3, r2
 8024524:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 8024528:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802452c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024530:	4413      	add	r3, r2
 8024532:	4a66      	ldr	r2, [pc, #408]	@ (80246cc <jpeg_idct_16x8+0x508>)
 8024534:	fb02 f303 	mul.w	r3, r2, r3
 8024538:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 802453c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8024540:	f640 128e 	movw	r2, #2446	@ 0x98e
 8024544:	fb02 f303 	mul.w	r3, r2, r3
 8024548:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 802454c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024550:	f243 020b 	movw	r2, #12299	@ 0x300b
 8024554:	fb02 f303 	mul.w	r3, r2, r3
 8024558:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 += z1 + z2;
 802455c:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8024560:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024564:	4413      	add	r3, r2
 8024566:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802456a:	4413      	add	r3, r2
 802456c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp3 += z1 + z3;
 8024570:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8024574:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024578:	4413      	add	r3, r2
 802457a:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 802457e:	4413      	add	r3, r2
 8024580:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8024584:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024588:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 802458c:	4413      	add	r3, r2
 802458e:	4a50      	ldr	r2, [pc, #320]	@ (80246d0 <jpeg_idct_16x8+0x50c>)
 8024590:	fb02 f303 	mul.w	r3, r2, r3
 8024594:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8024598:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 802459c:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 80245a0:	fb02 f303 	mul.w	r3, r2, r3
 80245a4:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 80245a8:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80245ac:	f246 2254 	movw	r2, #25172	@ 0x6254
 80245b0:	fb02 f303 	mul.w	r3, r2, r3
 80245b4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp1 += z1 + z3;
 80245b8:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80245bc:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80245c0:	4413      	add	r3, r2
 80245c2:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 80245c6:	4413      	add	r3, r2
 80245c8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 += z1 + z2;
 80245cc:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80245d0:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80245d4:	4413      	add	r3, r2
 80245d6:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 80245da:	4413      	add	r3, r2
 80245dc:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 80245e0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80245e4:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80245e8:	4413      	add	r3, r2
 80245ea:	12da      	asrs	r2, r3, #11
 80245ec:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80245f0:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 80245f2:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80245f6:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80245fa:	1ad2      	subs	r2, r2, r3
 80245fc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024600:	33e0      	adds	r3, #224	@ 0xe0
 8024602:	12d2      	asrs	r2, r2, #11
 8024604:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 8024606:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802460a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 802460e:	441a      	add	r2, r3
 8024610:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024614:	3320      	adds	r3, #32
 8024616:	12d2      	asrs	r2, r2, #11
 8024618:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 802461a:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802461e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024622:	1ad2      	subs	r2, r2, r3
 8024624:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024628:	33c0      	adds	r3, #192	@ 0xc0
 802462a:	12d2      	asrs	r2, r2, #11
 802462c:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 802462e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8024632:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8024636:	441a      	add	r2, r3
 8024638:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802463c:	3340      	adds	r3, #64	@ 0x40
 802463e:	12d2      	asrs	r2, r2, #11
 8024640:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 8024642:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8024646:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 802464a:	1ad2      	subs	r2, r2, r3
 802464c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024650:	33a0      	adds	r3, #160	@ 0xa0
 8024652:	12d2      	asrs	r2, r2, #11
 8024654:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 8024656:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 802465a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802465e:	441a      	add	r2, r3
 8024660:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024664:	3360      	adds	r3, #96	@ 0x60
 8024666:	12d2      	asrs	r2, r2, #11
 8024668:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 802466a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 802466e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8024672:	1ad2      	subs	r2, r2, r3
 8024674:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024678:	3380      	adds	r3, #128	@ 0x80
 802467a:	12d2      	asrs	r2, r2, #11
 802467c:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 802467e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8024682:	3302      	adds	r3, #2
 8024684:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    quantptr++;
 8024688:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802468c:	3304      	adds	r3, #4
 802468e:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    wsptr++;
 8024692:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024696:	3304      	adds	r3, #4
 8024698:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 802469c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80246a0:	3b01      	subs	r3, #1
 80246a2:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 80246a6:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80246aa:	2b00      	cmp	r3, #0
 80246ac:	f73f adc2 	bgt.w	8024234 <jpeg_idct_16x8+0x70>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  wsptr = workspace;
 80246b0:	f107 0314 	add.w	r3, r7, #20
 80246b4:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 80246b8:	2300      	movs	r3, #0
 80246ba:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 80246be:	e32d      	b.n	8024d1c <jpeg_idct_16x8+0xb58>
 80246c0:	ffffc4df 	.word	0xffffc4df
 80246c4:	ffffc13b 	.word	0xffffc13b
 80246c8:	fffff384 	.word	0xfffff384
 80246cc:	ffffe333 	.word	0xffffe333
 80246d0:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 80246d4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80246d8:	009b      	lsls	r3, r3, #2
 80246da:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 80246de:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 80246e2:	6812      	ldr	r2, [r2, #0]
 80246e4:	4413      	add	r3, r2
 80246e6:	681a      	ldr	r2, [r3, #0]
 80246e8:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 80246ec:	4413      	add	r3, r2
 80246ee:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80246f2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80246f6:	681b      	ldr	r3, [r3, #0]
 80246f8:	3310      	adds	r3, #16
 80246fa:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 80246fe:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8024702:	035b      	lsls	r3, r3, #13
 8024704:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = (INT32) wsptr[4];
 8024708:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802470c:	3310      	adds	r3, #16
 802470e:	681b      	ldr	r3, [r3, #0]
 8024710:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8024714:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024718:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 802471c:	fb02 f303 	mul.w	r3, r2, r3
 8024720:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8024724:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024728:	f241 1251 	movw	r2, #4433	@ 0x1151
 802472c:	fb02 f303 	mul.w	r3, r2, r3
 8024730:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp10 = tmp0 + tmp1;
 8024734:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8024738:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 802473c:	4413      	add	r3, r2
 802473e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 = tmp0 - tmp1;
 8024742:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8024746:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 802474a:	1ad3      	subs	r3, r2, r3
 802474c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = tmp0 + tmp2;
 8024750:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8024754:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024758:	4413      	add	r3, r2
 802475a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp13 = tmp0 - tmp2;
 802475e:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8024762:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024766:	1ad3      	subs	r3, r2, r3
 8024768:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    z1 = (INT32) wsptr[2];
 802476c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024770:	3308      	adds	r3, #8
 8024772:	681b      	ldr	r3, [r3, #0]
 8024774:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[6];
 8024778:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802477c:	3318      	adds	r3, #24
 802477e:	681b      	ldr	r3, [r3, #0]
 8024780:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = z1 - z2;
 8024784:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8024788:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802478c:	1ad3      	subs	r3, r2, r3
 802478e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8024792:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024796:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 802479a:	fb02 f303 	mul.w	r3, r2, r3
 802479e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 80247a2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80247a6:	f642 4263 	movw	r2, #11363	@ 0x2c63
 80247aa:	fb02 f303 	mul.w	r3, r2, r3
 80247ae:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 80247b2:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80247b6:	f245 2203 	movw	r2, #20995	@ 0x5203
 80247ba:	fb02 f303 	mul.w	r3, r2, r3
 80247be:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80247c2:	4413      	add	r3, r2
 80247c4:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 80247c8:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80247cc:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 80247d0:	fb02 f303 	mul.w	r3, r2, r3
 80247d4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80247d8:	4413      	add	r3, r2
 80247da:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 80247de:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80247e2:	4af4      	ldr	r2, [pc, #976]	@ (8024bb4 <jpeg_idct_16x8+0x9f0>)
 80247e4:	fb02 f303 	mul.w	r3, r2, r3
 80247e8:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80247ec:	4413      	add	r3, r2
 80247ee:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 80247f2:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80247f6:	4af0      	ldr	r2, [pc, #960]	@ (8024bb8 <jpeg_idct_16x8+0x9f4>)
 80247f8:	fb02 f303 	mul.w	r3, r2, r3
 80247fc:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8024800:	4413      	add	r3, r2
 8024802:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    tmp20 = tmp10 + tmp0;
 8024806:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802480a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802480e:	4413      	add	r3, r2
 8024810:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp27 = tmp10 - tmp0;
 8024814:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8024818:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802481c:	1ad3      	subs	r3, r2, r3
 802481e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp21 = tmp12 + tmp1;
 8024822:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8024826:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 802482a:	4413      	add	r3, r2
 802482c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp26 = tmp12 - tmp1;
 8024830:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8024834:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8024838:	1ad3      	subs	r3, r2, r3
 802483a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp22 = tmp13 + tmp2;
 802483e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8024842:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024846:	4413      	add	r3, r2
 8024848:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp25 = tmp13 - tmp2;
 802484c:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8024850:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024854:	1ad3      	subs	r3, r2, r3
 8024856:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp23 = tmp11 + tmp3;
 802485a:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802485e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024862:	4413      	add	r3, r2
 8024864:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp24 = tmp11 - tmp3;
 8024868:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802486c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024870:	1ad3      	subs	r3, r2, r3
 8024872:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8024876:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802487a:	3304      	adds	r3, #4
 802487c:	681b      	ldr	r3, [r3, #0]
 802487e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[3];
 8024882:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024886:	330c      	adds	r3, #12
 8024888:	681b      	ldr	r3, [r3, #0]
 802488a:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = (INT32) wsptr[5];
 802488e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024892:	3314      	adds	r3, #20
 8024894:	681b      	ldr	r3, [r3, #0]
 8024896:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z4 = (INT32) wsptr[7];
 802489a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802489e:	331c      	adds	r3, #28
 80248a0:	681b      	ldr	r3, [r3, #0]
 80248a2:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    tmp11 = z1 + z3;
 80248a6:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80248aa:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80248ae:	4413      	add	r3, r2
 80248b0:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 80248b4:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80248b8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80248bc:	4413      	add	r3, r2
 80248be:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 80248c2:	fb02 f303 	mul.w	r3, r2, r3
 80248c6:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 80248ca:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80248ce:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 80248d2:	fb02 f303 	mul.w	r3, r2, r3
 80248d6:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 80248da:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80248de:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80248e2:	4413      	add	r3, r2
 80248e4:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 80248e8:	fb02 f303 	mul.w	r3, r2, r3
 80248ec:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 80248f0:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80248f4:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80248f8:	1ad3      	subs	r3, r2, r3
 80248fa:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 80248fe:	fb02 f303 	mul.w	r3, r2, r3
 8024902:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8024906:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802490a:	f241 5255 	movw	r2, #5461	@ 0x1555
 802490e:	fb02 f303 	mul.w	r3, r2, r3
 8024912:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8024916:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802491a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802491e:	1ad3      	subs	r3, r2, r3
 8024920:	f640 5223 	movw	r2, #3363	@ 0xd23
 8024924:	fb02 f303 	mul.w	r3, r2, r3
 8024928:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp0  = tmp1 + tmp2 + tmp3 -
 802492c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024930:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024934:	441a      	add	r2, r3
 8024936:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802493a:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 802493c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024940:	499e      	ldr	r1, [pc, #632]	@ (8024bbc <jpeg_idct_16x8+0x9f8>)
 8024942:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 8024946:	4413      	add	r3, r2
 8024948:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp13 = tmp10 + tmp11 + tmp12 -
 802494c:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8024950:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8024954:	441a      	add	r2, r3
 8024956:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802495a:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 802495c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024960:	4997      	ldr	r1, [pc, #604]	@ (8024bc0 <jpeg_idct_16x8+0x9fc>)
 8024962:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 8024966:	4413      	add	r3, r2
 8024968:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 802496c:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8024970:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024974:	4413      	add	r3, r2
 8024976:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 802497a:	fb02 f303 	mul.w	r3, r2, r3
 802497e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8024982:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024986:	f240 224d 	movw	r2, #589	@ 0x24d
 802498a:	fb03 f202 	mul.w	r2, r3, r2
 802498e:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024992:	4413      	add	r3, r2
 8024994:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024998:	4413      	add	r3, r2
 802499a:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 802499e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80249a2:	4a88      	ldr	r2, [pc, #544]	@ (8024bc4 <jpeg_idct_16x8+0xa00>)
 80249a4:	fb03 f202 	mul.w	r2, r3, r2
 80249a8:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80249ac:	4413      	add	r3, r2
 80249ae:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 80249b2:	4413      	add	r3, r2
 80249b4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 80249b8:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80249bc:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80249c0:	1ad3      	subs	r3, r2, r3
 80249c2:	f642 5209 	movw	r2, #11529	@ 0x2d09
 80249c6:	fb02 f303 	mul.w	r3, r2, r3
 80249ca:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 80249ce:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80249d2:	4a7d      	ldr	r2, [pc, #500]	@ (8024bc8 <jpeg_idct_16x8+0xa04>)
 80249d4:	fb03 f202 	mul.w	r2, r3, r2
 80249d8:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80249dc:	4413      	add	r3, r2
 80249de:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 80249e2:	4413      	add	r3, r2
 80249e4:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 80249e8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80249ec:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 80249f0:	fb03 f202 	mul.w	r2, r3, r2
 80249f4:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80249f8:	4413      	add	r3, r2
 80249fa:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80249fe:	4413      	add	r3, r2
 8024a00:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z2    += z4;
 8024a04:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8024a08:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8024a0c:	4413      	add	r3, r2
 8024a0e:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 8024a12:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024a16:	4a6d      	ldr	r2, [pc, #436]	@ (8024bcc <jpeg_idct_16x8+0xa08>)
 8024a18:	fb02 f303 	mul.w	r3, r2, r3
 8024a1c:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1  += z1;
 8024a20:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8024a24:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024a28:	4413      	add	r3, r2
 8024a2a:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8024a2e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8024a32:	f242 2218 	movw	r2, #8728	@ 0x2218
 8024a36:	fb03 f202 	mul.w	r2, r3, r2
 8024a3a:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8024a3e:	4413      	add	r3, r2
 8024a40:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8024a44:	4413      	add	r3, r2
 8024a46:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8024a4a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024a4e:	4a60      	ldr	r2, [pc, #384]	@ (8024bd0 <jpeg_idct_16x8+0xa0c>)
 8024a50:	fb02 f303 	mul.w	r3, r2, r3
 8024a54:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8024a58:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8024a5c:	f246 4285 	movw	r2, #25733	@ 0x6485
 8024a60:	fb03 f202 	mul.w	r2, r3, r2
 8024a64:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024a68:	4413      	add	r3, r2
 8024a6a:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8024a6e:	4413      	add	r3, r2
 8024a70:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp12 += z2;
 8024a74:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8024a78:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024a7c:	4413      	add	r3, r2
 8024a7e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8024a82:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8024a86:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8024a8a:	4413      	add	r3, r2
 8024a8c:	4a51      	ldr	r2, [pc, #324]	@ (8024bd4 <jpeg_idct_16x8+0xa10>)
 8024a8e:	fb02 f303 	mul.w	r3, r2, r3
 8024a92:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp2  += z2;
 8024a96:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8024a9a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024a9e:	4413      	add	r3, r2
 8024aa0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3  += z2;
 8024aa4:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8024aa8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024aac:	4413      	add	r3, r2
 8024aae:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8024ab2:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8024ab6:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8024aba:	1ad3      	subs	r3, r2, r3
 8024abc:	f640 5223 	movw	r2, #3363	@ 0xd23
 8024ac0:	fb02 f303 	mul.w	r3, r2, r3
 8024ac4:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp10 += z2;
 8024ac8:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8024acc:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024ad0:	4413      	add	r3, r2
 8024ad2:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 += z2;
 8024ad6:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8024ada:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024ade:	4413      	add	r3, r2
 8024ae0:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8024ae4:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024ae8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8024aec:	4413      	add	r3, r2
 8024aee:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024af0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8024af4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024af8:	4413      	add	r3, r2
 8024afa:	781a      	ldrb	r2, [r3, #0]
 8024afc:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b00:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8024b02:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024b06:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8024b0a:	1ad3      	subs	r3, r2, r3
 8024b0c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b0e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8024b12:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024b16:	441a      	add	r2, r3
 8024b18:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b1c:	330f      	adds	r3, #15
 8024b1e:	7812      	ldrb	r2, [r2, #0]
 8024b20:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8024b22:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8024b26:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8024b2a:	4413      	add	r3, r2
 8024b2c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b2e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8024b32:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024b36:	441a      	add	r2, r3
 8024b38:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b3c:	3301      	adds	r3, #1
 8024b3e:	7812      	ldrb	r2, [r2, #0]
 8024b40:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8024b42:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8024b46:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8024b4a:	1ad3      	subs	r3, r2, r3
 8024b4c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8024b52:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024b56:	441a      	add	r2, r3
 8024b58:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b5c:	330e      	adds	r3, #14
 8024b5e:	7812      	ldrb	r2, [r2, #0]
 8024b60:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8024b62:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8024b66:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024b6a:	4413      	add	r3, r2
 8024b6c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8024b72:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024b76:	441a      	add	r2, r3
 8024b78:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b7c:	3302      	adds	r3, #2
 8024b7e:	7812      	ldrb	r2, [r2, #0]
 8024b80:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8024b82:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8024b86:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8024b8a:	1ad3      	subs	r3, r2, r3
 8024b8c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8024b92:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024b96:	441a      	add	r2, r3
 8024b98:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024b9c:	330d      	adds	r3, #13
 8024b9e:	7812      	ldrb	r2, [r2, #0]
 8024ba0:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8024ba2:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8024ba6:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024baa:	4413      	add	r3, r2
 8024bac:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024bae:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8024bb2:	e011      	b.n	8024bd8 <jpeg_idct_16x8+0xa14>
 8024bb4:	ffffecc2 	.word	0xffffecc2
 8024bb8:	ffffefb0 	.word	0xffffefb0
 8024bbc:	ffffb6d6 	.word	0xffffb6d6
 8024bc0:	ffffc542 	.word	0xffffc542
 8024bc4:	ffffdbfa 	.word	0xffffdbfa
 8024bc8:	ffffe77a 	.word	0xffffe77a
 8024bcc:	ffffeaab 	.word	0xffffeaab
 8024bd0:	ffffd817 	.word	0xffffd817
 8024bd4:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8024bd8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024bdc:	441a      	add	r2, r3
 8024bde:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024be2:	3303      	adds	r3, #3
 8024be4:	7812      	ldrb	r2, [r2, #0]
 8024be6:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8024be8:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8024bec:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8024bf0:	1ad3      	subs	r3, r2, r3
 8024bf2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024bf4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8024bf8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024bfc:	441a      	add	r2, r3
 8024bfe:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024c02:	330c      	adds	r3, #12
 8024c04:	7812      	ldrb	r2, [r2, #0]
 8024c06:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8024c08:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8024c0c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8024c10:	4413      	add	r3, r2
 8024c12:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c14:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8024c18:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024c1c:	441a      	add	r2, r3
 8024c1e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024c22:	3304      	adds	r3, #4
 8024c24:	7812      	ldrb	r2, [r2, #0]
 8024c26:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 8024c28:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8024c2c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8024c30:	1ad3      	subs	r3, r2, r3
 8024c32:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c34:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 8024c38:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024c3c:	441a      	add	r2, r3
 8024c3e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024c42:	330b      	adds	r3, #11
 8024c44:	7812      	ldrb	r2, [r2, #0]
 8024c46:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 8024c48:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8024c4c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8024c50:	4413      	add	r3, r2
 8024c52:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c54:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 8024c58:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024c5c:	441a      	add	r2, r3
 8024c5e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024c62:	3305      	adds	r3, #5
 8024c64:	7812      	ldrb	r2, [r2, #0]
 8024c66:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 8024c68:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8024c6c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8024c70:	1ad3      	subs	r3, r2, r3
 8024c72:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c74:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 8024c78:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024c7c:	441a      	add	r2, r3
 8024c7e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024c82:	330a      	adds	r3, #10
 8024c84:	7812      	ldrb	r2, [r2, #0]
 8024c86:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8024c88:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8024c8c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024c90:	4413      	add	r3, r2
 8024c92:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c94:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8024c98:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024c9c:	441a      	add	r2, r3
 8024c9e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024ca2:	3306      	adds	r3, #6
 8024ca4:	7812      	ldrb	r2, [r2, #0]
 8024ca6:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8024ca8:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8024cac:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024cb0:	1ad3      	subs	r3, r2, r3
 8024cb2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cb4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8024cb8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024cbc:	441a      	add	r2, r3
 8024cbe:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024cc2:	3309      	adds	r3, #9
 8024cc4:	7812      	ldrb	r2, [r2, #0]
 8024cc6:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8024cc8:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8024ccc:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024cd0:	4413      	add	r3, r2
 8024cd2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cd4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8024cd8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024cdc:	441a      	add	r2, r3
 8024cde:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024ce2:	3307      	adds	r3, #7
 8024ce4:	7812      	ldrb	r2, [r2, #0]
 8024ce6:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8024ce8:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8024cec:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024cf0:	1ad3      	subs	r3, r2, r3
 8024cf2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cf4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8024cf8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8024cfc:	441a      	add	r2, r3
 8024cfe:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8024d02:	3308      	adds	r3, #8
 8024d04:	7812      	ldrb	r2, [r2, #0]
 8024d06:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8024d08:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8024d0c:	3320      	adds	r3, #32
 8024d0e:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 8024d12:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8024d16:	3301      	adds	r3, #1
 8024d18:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8024d1c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8024d20:	2b07      	cmp	r3, #7
 8024d22:	f77f acd7 	ble.w	80246d4 <jpeg_idct_16x8+0x510>
  }
}
 8024d26:	bf00      	nop
 8024d28:	bf00      	nop
 8024d2a:	f507 77c0 	add.w	r7, r7, #384	@ 0x180
 8024d2e:	46bd      	mov	sp, r7
 8024d30:	bc90      	pop	{r4, r7}
 8024d32:	4770      	bx	lr

08024d34 <jpeg_idct_14x7>:

GLOBAL(void)
jpeg_idct_14x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8024d34:	b490      	push	{r4, r7}
 8024d36:	b0d4      	sub	sp, #336	@ 0x150
 8024d38:	af00      	add	r7, sp, #0
 8024d3a:	f507 74a8 	add.w	r4, r7, #336	@ 0x150
 8024d3e:	f5a4 74a2 	sub.w	r4, r4, #324	@ 0x144
 8024d42:	6020      	str	r0, [r4, #0]
 8024d44:	f507 70a8 	add.w	r0, r7, #336	@ 0x150
 8024d48:	f5a0 70a4 	sub.w	r0, r0, #328	@ 0x148
 8024d4c:	6001      	str	r1, [r0, #0]
 8024d4e:	f507 71a8 	add.w	r1, r7, #336	@ 0x150
 8024d52:	f5a1 71a6 	sub.w	r1, r1, #332	@ 0x14c
 8024d56:	600a      	str	r2, [r1, #0]
 8024d58:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 8024d5c:	f5a2 72a8 	sub.w	r2, r2, #336	@ 0x150
 8024d60:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8024d62:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8024d66:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8024d6a:	681b      	ldr	r3, [r3, #0]
 8024d6c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8024d70:	3380      	adds	r3, #128	@ 0x80
 8024d72:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  inptr = coef_block;
 8024d76:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8024d7a:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 8024d7e:	681b      	ldr	r3, [r3, #0]
 8024d80:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024d84:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8024d88:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 8024d8c:	681b      	ldr	r3, [r3, #0]
 8024d8e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8024d90:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
  wsptr = workspace;
 8024d94:	f107 0310 	add.w	r3, r7, #16
 8024d98:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8024d9c:	2300      	movs	r3, #0
 8024d9e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8024da2:	e17a      	b.n	802509a <jpeg_idct_14x7+0x366>
    /* Even part */

    tmp23 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024da4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024da8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024dac:	461a      	mov	r2, r3
 8024dae:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024db2:	681b      	ldr	r3, [r3, #0]
 8024db4:	fb02 f303 	mul.w	r3, r2, r3
 8024db8:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    tmp23 <<= CONST_BITS;
 8024dbc:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8024dc0:	035b      	lsls	r3, r3, #13
 8024dc2:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    /* Add fudge factor here for final descale. */
    tmp23 += ONE << (CONST_BITS-PASS1_BITS-1);
 8024dc6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8024dca:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8024dce:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8024dd2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024dd6:	3320      	adds	r3, #32
 8024dd8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024ddc:	461a      	mov	r2, r3
 8024dde:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024de2:	3340      	adds	r3, #64	@ 0x40
 8024de4:	681b      	ldr	r3, [r3, #0]
 8024de6:	fb02 f303 	mul.w	r3, r2, r3
 8024dea:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8024dee:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024df2:	3340      	adds	r3, #64	@ 0x40
 8024df4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024df8:	461a      	mov	r2, r3
 8024dfa:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024dfe:	3380      	adds	r3, #128	@ 0x80
 8024e00:	681b      	ldr	r3, [r3, #0]
 8024e02:	fb02 f303 	mul.w	r3, r2, r3
 8024e06:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8024e0a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024e0e:	3360      	adds	r3, #96	@ 0x60
 8024e10:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024e14:	461a      	mov	r2, r3
 8024e16:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024e1a:	33c0      	adds	r3, #192	@ 0xc0
 8024e1c:	681b      	ldr	r3, [r3, #0]
 8024e1e:	fb02 f303 	mul.w	r3, r2, r3
 8024e22:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 8024e26:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8024e2a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024e2e:	1ad3      	subs	r3, r2, r3
 8024e30:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8024e34:	fb02 f303 	mul.w	r3, r2, r3
 8024e38:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 8024e3c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024e40:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024e44:	1ad3      	subs	r3, r2, r3
 8024e46:	f640 2212 	movw	r2, #2578	@ 0xa12
 8024e4a:	fb02 f303 	mul.w	r3, r2, r3
 8024e4e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 8024e52:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8024e56:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8024e5a:	441a      	add	r2, r3
 8024e5c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8024e60:	441a      	add	r2, r3
 8024e62:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024e66:	4993      	ldr	r1, [pc, #588]	@ (80250b4 <jpeg_idct_14x7+0x380>)
 8024e68:	fb01 f303 	mul.w	r3, r1, r3
 8024e6c:	4413      	add	r3, r2
 8024e6e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = z1 + z3;
 8024e72:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024e76:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024e7a:	4413      	add	r3, r2
 8024e7c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    z2 -= tmp10;
 8024e80:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8024e84:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8024e88:	1ad3      	subs	r3, r2, r3
 8024e8a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 8024e8e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8024e92:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8024e96:	fb02 f303 	mul.w	r3, r2, r3
 8024e9a:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8024e9e:	4413      	add	r3, r2
 8024ea0:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 8024ea4:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024ea8:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 8024eac:	fb03 f202 	mul.w	r2, r3, r2
 8024eb0:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8024eb4:	4413      	add	r3, r2
 8024eb6:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8024eba:	4413      	add	r3, r2
 8024ebc:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 8024ec0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8024ec4:	4a7c      	ldr	r2, [pc, #496]	@ (80250b8 <jpeg_idct_14x7+0x384>)
 8024ec6:	fb03 f202 	mul.w	r2, r3, r2
 8024eca:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8024ece:	4413      	add	r3, r2
 8024ed0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8024ed4:	4413      	add	r3, r2
 8024ed6:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 8024eda:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024ede:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8024ee2:	fb02 f303 	mul.w	r3, r2, r3
 8024ee6:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8024eea:	4413      	add	r3, r2
 8024eec:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8024ef0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024ef4:	3310      	adds	r3, #16
 8024ef6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024efa:	461a      	mov	r2, r3
 8024efc:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024f00:	3320      	adds	r3, #32
 8024f02:	681b      	ldr	r3, [r3, #0]
 8024f04:	fb02 f303 	mul.w	r3, r2, r3
 8024f08:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8024f0c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024f10:	3330      	adds	r3, #48	@ 0x30
 8024f12:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024f16:	461a      	mov	r2, r3
 8024f18:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024f1c:	3360      	adds	r3, #96	@ 0x60
 8024f1e:	681b      	ldr	r3, [r3, #0]
 8024f20:	fb02 f303 	mul.w	r3, r2, r3
 8024f24:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8024f28:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8024f2c:	3350      	adds	r3, #80	@ 0x50
 8024f2e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024f32:	461a      	mov	r2, r3
 8024f34:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8024f38:	33a0      	adds	r3, #160	@ 0xa0
 8024f3a:	681b      	ldr	r3, [r3, #0]
 8024f3c:	fb02 f303 	mul.w	r3, r2, r3
 8024f40:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 8024f44:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024f48:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024f4c:	4413      	add	r3, r2
 8024f4e:	f641 52ef 	movw	r2, #7663	@ 0x1def
 8024f52:	fb02 f303 	mul.w	r3, r2, r3
 8024f56:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 8024f5a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024f5e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024f62:	1ad3      	subs	r3, r2, r3
 8024f64:	f240 5273 	movw	r2, #1395	@ 0x573
 8024f68:	fb02 f303 	mul.w	r3, r2, r3
 8024f6c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp10 = tmp11 - tmp12;
 8024f70:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8024f74:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8024f78:	1ad3      	subs	r3, r2, r3
 8024f7a:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp11 += tmp12;
 8024f7e:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8024f82:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8024f86:	4413      	add	r3, r2
 8024f88:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 8024f8c:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8024f90:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024f94:	4413      	add	r3, r2
 8024f96:	4a49      	ldr	r2, [pc, #292]	@ (80250bc <jpeg_idct_14x7+0x388>)
 8024f98:	fb02 f303 	mul.w	r3, r2, r3
 8024f9c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp11 += tmp12;
 8024fa0:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8024fa4:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8024fa8:	4413      	add	r3, r2
 8024faa:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 8024fae:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8024fb2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024fb6:	4413      	add	r3, r2
 8024fb8:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8024fbc:	fb02 f303 	mul.w	r3, r2, r3
 8024fc0:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp10 += z2;
 8024fc4:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8024fc8:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024fcc:	4413      	add	r3, r2
 8024fce:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 8024fd2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8024fd6:	f643 32de 	movw	r2, #15326	@ 0x3bde
 8024fda:	fb03 f202 	mul.w	r2, r3, r2
 8024fde:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8024fe2:	4413      	add	r3, r2
 8024fe4:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8024fe8:	4413      	add	r3, r2
 8024fea:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8024fee:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8024ff2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8024ff6:	4413      	add	r3, r2
 8024ff8:	12da      	asrs	r2, r3, #11
 8024ffa:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8024ffe:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8025000:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8025004:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025008:	1ad2      	subs	r2, r2, r3
 802500a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802500e:	33c0      	adds	r3, #192	@ 0xc0
 8025010:	12d2      	asrs	r2, r2, #11
 8025012:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8025014:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8025018:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802501c:	441a      	add	r2, r3
 802501e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025022:	3320      	adds	r3, #32
 8025024:	12d2      	asrs	r2, r2, #11
 8025026:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8025028:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802502c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025030:	1ad2      	subs	r2, r2, r3
 8025032:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025036:	33a0      	adds	r3, #160	@ 0xa0
 8025038:	12d2      	asrs	r2, r2, #11
 802503a:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 802503c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8025040:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025044:	441a      	add	r2, r3
 8025046:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802504a:	3340      	adds	r3, #64	@ 0x40
 802504c:	12d2      	asrs	r2, r2, #11
 802504e:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8025050:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8025054:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025058:	1ad2      	subs	r2, r2, r3
 802505a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802505e:	3380      	adds	r3, #128	@ 0x80
 8025060:	12d2      	asrs	r2, r2, #11
 8025062:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23, CONST_BITS-PASS1_BITS);
 8025064:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025068:	3360      	adds	r3, #96	@ 0x60
 802506a:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 802506e:	12d2      	asrs	r2, r2, #11
 8025070:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025072:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8025076:	3301      	adds	r3, #1
 8025078:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 802507c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8025080:	3302      	adds	r3, #2
 8025082:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
 8025086:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802508a:	3304      	adds	r3, #4
 802508c:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 8025090:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025094:	3304      	adds	r3, #4
 8025096:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 802509a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 802509e:	2b07      	cmp	r3, #7
 80250a0:	f77f ae80 	ble.w	8024da4 <jpeg_idct_14x7+0x70>
  }

  /* Pass 2: process 7 rows from work array, store into output array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  wsptr = workspace;
 80250a4:	f107 0310 	add.w	r3, r7, #16
 80250a8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 80250ac:	2300      	movs	r3, #0
 80250ae:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 80250b2:	e28b      	b.n	80255cc <jpeg_idct_14x7+0x898>
 80250b4:	ffffc515 	.word	0xffffc515
 80250b8:	ffffb0f1 	.word	0xffffb0f1
 80250bc:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 80250c0:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80250c4:	009b      	lsls	r3, r3, #2
 80250c6:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 80250ca:	f5a2 72a8 	sub.w	r2, r2, #336	@ 0x150
 80250ce:	6812      	ldr	r2, [r2, #0]
 80250d0:	4413      	add	r3, r2
 80250d2:	681a      	ldr	r2, [r3, #0]
 80250d4:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80250d8:	4413      	add	r3, r2
 80250da:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80250de:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80250e2:	681b      	ldr	r3, [r3, #0]
 80250e4:	3310      	adds	r3, #16
 80250e6:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z1 <<= CONST_BITS;
 80250ea:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80250ee:	035b      	lsls	r3, r3, #13
 80250f0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z4 = (INT32) wsptr[4];
 80250f4:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80250f8:	3310      	adds	r3, #16
 80250fa:	681b      	ldr	r3, [r3, #0]
 80250fc:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 8025100:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025104:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8025108:	fb02 f303 	mul.w	r3, r2, r3
 802510c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 8025110:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025114:	f640 2212 	movw	r2, #2578	@ 0xa12
 8025118:	fb02 f303 	mul.w	r3, r2, r3
 802511c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 8025120:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025124:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8025128:	fb02 f303 	mul.w	r3, r2, r3
 802512c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    tmp10 = z1 + z2;
 8025130:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8025134:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8025138:	4413      	add	r3, r2
 802513a:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp11 = z1 + z3;
 802513e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8025142:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8025146:	4413      	add	r3, r2
 8025148:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = z1 - z4;
 802514c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8025150:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025154:	1ad3      	subs	r3, r2, r3
 8025156:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 802515a:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 802515e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8025162:	441a      	add	r2, r3
 8025164:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025168:	1ad3      	subs	r3, r2, r3
 802516a:	005b      	lsls	r3, r3, #1
 802516c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8025170:	1ad3      	subs	r3, r2, r3
 8025172:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    z1 = (INT32) wsptr[2];
 8025176:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802517a:	3308      	adds	r3, #8
 802517c:	681b      	ldr	r3, [r3, #0]
 802517e:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = (INT32) wsptr[6];
 8025182:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025186:	3318      	adds	r3, #24
 8025188:	681b      	ldr	r3, [r3, #0]
 802518a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 802518e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8025192:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8025196:	4413      	add	r3, r2
 8025198:	f242 3262 	movw	r2, #9058	@ 0x2362
 802519c:	fb02 f303 	mul.w	r3, r2, r3
 80251a0:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 80251a4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80251a8:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 80251ac:	fb02 f303 	mul.w	r3, r2, r3
 80251b0:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80251b4:	4413      	add	r3, r2
 80251b6:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 80251ba:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80251be:	4af2      	ldr	r2, [pc, #968]	@ (8025588 <jpeg_idct_14x7+0x854>)
 80251c0:	fb02 f303 	mul.w	r3, r2, r3
 80251c4:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80251c8:	4413      	add	r3, r2
 80251ca:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80251ce:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80251d2:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 80251d6:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 80251da:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80251de:	49eb      	ldr	r1, [pc, #940]	@ (802558c <jpeg_idct_14x7+0x858>)
 80251e0:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80251e4:	4413      	add	r3, r2
 80251e6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    tmp20 = tmp10 + tmp13;
 80251ea:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80251ee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80251f2:	4413      	add	r3, r2
 80251f4:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp26 = tmp10 - tmp13;
 80251f8:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80251fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8025200:	1ad3      	subs	r3, r2, r3
 8025202:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp21 = tmp11 + tmp14;
 8025206:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 802520a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802520e:	4413      	add	r3, r2
 8025210:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp25 = tmp11 - tmp14;
 8025214:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8025218:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802521c:	1ad3      	subs	r3, r2, r3
 802521e:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp22 = tmp12 + tmp15;
 8025222:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8025226:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802522a:	4413      	add	r3, r2
 802522c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp24 = tmp12 - tmp15;
 8025230:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8025234:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025238:	1ad3      	subs	r3, r2, r3
 802523a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802523e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025242:	3304      	adds	r3, #4
 8025244:	681b      	ldr	r3, [r3, #0]
 8025246:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = (INT32) wsptr[3];
 802524a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802524e:	330c      	adds	r3, #12
 8025250:	681b      	ldr	r3, [r3, #0]
 8025252:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = (INT32) wsptr[5];
 8025256:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802525a:	3314      	adds	r3, #20
 802525c:	681b      	ldr	r3, [r3, #0]
 802525e:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    z4 = (INT32) wsptr[7];
 8025262:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8025266:	331c      	adds	r3, #28
 8025268:	681b      	ldr	r3, [r3, #0]
 802526a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z4 <<= CONST_BITS;
 802526e:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025272:	035b      	lsls	r3, r3, #13
 8025274:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    tmp14 = z1 + z3;
 8025278:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802527c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8025280:	4413      	add	r3, r2
 8025282:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8025286:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802528a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802528e:	4413      	add	r3, r2
 8025290:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8025294:	fb02 f303 	mul.w	r3, r2, r3
 8025298:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 802529c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80252a0:	f242 6252 	movw	r2, #9810	@ 0x2652
 80252a4:	fb02 f303 	mul.w	r3, r2, r3
 80252a8:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 80252ac:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80252b0:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80252b4:	441a      	add	r2, r3
 80252b6:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80252ba:	441a      	add	r2, r3
 80252bc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80252c0:	49b3      	ldr	r1, [pc, #716]	@ (8025590 <jpeg_idct_14x7+0x85c>)
 80252c2:	fb01 f303 	mul.w	r3, r1, r3
 80252c6:	4413      	add	r3, r2
 80252c8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80252cc:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80252d0:	f641 0214 	movw	r2, #6164	@ 0x1814
 80252d4:	fb02 f303 	mul.w	r3, r2, r3
 80252d8:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80252dc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80252e0:	4aac      	ldr	r2, [pc, #688]	@ (8025594 <jpeg_idct_14x7+0x860>)
 80252e2:	fb02 f303 	mul.w	r3, r2, r3
 80252e6:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80252ea:	4413      	add	r3, r2
 80252ec:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    z1    -= z2;
 80252f0:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80252f4:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80252f8:	1ad3      	subs	r3, r2, r3
 80252fa:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 80252fe:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8025302:	f640 62f2 	movw	r2, #3826	@ 0xef2
 8025306:	fb03 f202 	mul.w	r2, r3, r2
 802530a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802530e:	1ad3      	subs	r3, r2, r3
 8025310:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp16 += tmp15;
 8025314:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8025318:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802531c:	4413      	add	r3, r2
 802531e:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 8025322:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8025326:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802532a:	4413      	add	r3, r2
 802532c:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 8025330:	fb03 f202 	mul.w	r2, r3, r2
 8025334:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025338:	1ad3      	subs	r3, r2, r3
 802533a:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 802533e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8025342:	4a95      	ldr	r2, [pc, #596]	@ (8025598 <jpeg_idct_14x7+0x864>)
 8025344:	fb03 f202 	mul.w	r2, r3, r2
 8025348:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802534c:	4413      	add	r3, r2
 802534e:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8025352:	4413      	add	r3, r2
 8025354:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 8025358:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802535c:	4a8f      	ldr	r2, [pc, #572]	@ (802559c <jpeg_idct_14x7+0x868>)
 802535e:	fb03 f202 	mul.w	r2, r3, r2
 8025362:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8025366:	4413      	add	r3, r2
 8025368:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802536c:	4413      	add	r3, r2
 802536e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8025372:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8025376:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802537a:	1ad3      	subs	r3, r2, r3
 802537c:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 8025380:	fb02 f303 	mul.w	r3, r2, r3
 8025384:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8025388:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802538c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025390:	441a      	add	r2, r3
 8025392:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8025396:	4982      	ldr	r1, [pc, #520]	@ (80255a0 <jpeg_idct_14x7+0x86c>)
 8025398:	fb01 f303 	mul.w	r3, r1, r3
 802539c:	4413      	add	r3, r2
 802539e:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80253a2:	4413      	add	r3, r2
 80253a4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 80253a8:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80253ac:	f241 5299 	movw	r2, #5529	@ 0x1599
 80253b0:	fb03 f202 	mul.w	r2, r3, r2
 80253b4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80253b8:	4413      	add	r3, r2
 80253ba:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 80253be:	4413      	add	r3, r2
 80253c0:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 80253c4:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80253c8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80253cc:	1ad3      	subs	r3, r2, r3
 80253ce:	035b      	lsls	r3, r3, #13
 80253d0:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80253d4:	4413      	add	r3, r2
 80253d6:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80253da:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80253de:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80253e2:	4413      	add	r3, r2
 80253e4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80253e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80253ea:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80253ee:	4413      	add	r3, r2
 80253f0:	781a      	ldrb	r2, [r3, #0]
 80253f2:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80253f6:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80253f8:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80253fc:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025400:	1ad3      	subs	r3, r2, r3
 8025402:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025404:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8025408:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802540c:	441a      	add	r2, r3
 802540e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025412:	330d      	adds	r3, #13
 8025414:	7812      	ldrb	r2, [r2, #0]
 8025416:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8025418:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802541c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025420:	4413      	add	r3, r2
 8025422:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025424:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8025428:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802542c:	441a      	add	r2, r3
 802542e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025432:	3301      	adds	r3, #1
 8025434:	7812      	ldrb	r2, [r2, #0]
 8025436:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8025438:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802543c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025440:	1ad3      	subs	r3, r2, r3
 8025442:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025444:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8025448:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802544c:	441a      	add	r2, r3
 802544e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025452:	330c      	adds	r3, #12
 8025454:	7812      	ldrb	r2, [r2, #0]
 8025456:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025458:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802545c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025460:	4413      	add	r3, r2
 8025462:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025464:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025468:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802546c:	441a      	add	r2, r3
 802546e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025472:	3302      	adds	r3, #2
 8025474:	7812      	ldrb	r2, [r2, #0]
 8025476:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025478:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802547c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025480:	1ad3      	subs	r3, r2, r3
 8025482:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025484:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025488:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802548c:	441a      	add	r2, r3
 802548e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025492:	330b      	adds	r3, #11
 8025494:	7812      	ldrb	r2, [r2, #0]
 8025496:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8025498:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 802549c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80254a0:	4413      	add	r3, r2
 80254a2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80254a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80254a8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80254ac:	441a      	add	r2, r3
 80254ae:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80254b2:	3303      	adds	r3, #3
 80254b4:	7812      	ldrb	r2, [r2, #0]
 80254b6:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80254b8:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 80254bc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80254c0:	1ad3      	subs	r3, r2, r3
 80254c2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80254c4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80254c8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80254cc:	441a      	add	r2, r3
 80254ce:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80254d2:	330a      	adds	r3, #10
 80254d4:	7812      	ldrb	r2, [r2, #0]
 80254d6:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80254d8:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80254dc:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80254e0:	4413      	add	r3, r2
 80254e2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80254e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80254e8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80254ec:	441a      	add	r2, r3
 80254ee:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80254f2:	3304      	adds	r3, #4
 80254f4:	7812      	ldrb	r2, [r2, #0]
 80254f6:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80254f8:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80254fc:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025500:	1ad3      	subs	r3, r2, r3
 8025502:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025504:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8025508:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802550c:	441a      	add	r2, r3
 802550e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025512:	3309      	adds	r3, #9
 8025514:	7812      	ldrb	r2, [r2, #0]
 8025516:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8025518:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802551c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025520:	4413      	add	r3, r2
 8025522:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025524:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8025528:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802552c:	441a      	add	r2, r3
 802552e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025532:	3305      	adds	r3, #5
 8025534:	7812      	ldrb	r2, [r2, #0]
 8025536:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8025538:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802553c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025540:	1ad3      	subs	r3, r2, r3
 8025542:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025544:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8025548:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802554c:	441a      	add	r2, r3
 802554e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025552:	3308      	adds	r3, #8
 8025554:	7812      	ldrb	r2, [r2, #0]
 8025556:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8025558:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802555c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8025560:	4413      	add	r3, r2
 8025562:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025564:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8025568:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802556c:	441a      	add	r2, r3
 802556e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8025572:	3306      	adds	r3, #6
 8025574:	7812      	ldrb	r2, [r2, #0]
 8025576:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8025578:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802557c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8025580:	1ad3      	subs	r3, r2, r3
 8025582:	149b      	asrs	r3, r3, #18
 8025584:	e00e      	b.n	80255a4 <jpeg_idct_14x7+0x870>
 8025586:	bf00      	nop
 8025588:	ffffc8fc 	.word	0xffffc8fc
 802558c:	ffffd3e1 	.word	0xffffd3e1
 8025590:	ffffdbf0 	.word	0xffffdbf0
 8025594:	ffffde0b 	.word	0xffffde0b
 8025598:	fffff26e 	.word	0xfffff26e
 802559c:	ffffb409 	.word	0xffffb409
 80255a0:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80255a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 80255a8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80255ac:	441a      	add	r2, r3
 80255ae:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80255b2:	3307      	adds	r3, #7
 80255b4:	7812      	ldrb	r2, [r2, #0]
 80255b6:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80255b8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80255bc:	3320      	adds	r3, #32
 80255be:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 80255c2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80255c6:	3301      	adds	r3, #1
 80255c8:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 80255cc:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80255d0:	2b06      	cmp	r3, #6
 80255d2:	f77f ad75 	ble.w	80250c0 <jpeg_idct_14x7+0x38c>
  }
}
 80255d6:	bf00      	nop
 80255d8:	bf00      	nop
 80255da:	f507 77a8 	add.w	r7, r7, #336	@ 0x150
 80255de:	46bd      	mov	sp, r7
 80255e0:	bc90      	pop	{r4, r7}
 80255e2:	4770      	bx	lr

080255e4 <jpeg_idct_12x6>:

GLOBAL(void)
jpeg_idct_12x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80255e4:	b490      	push	{r4, r7}
 80255e6:	b0ca      	sub	sp, #296	@ 0x128
 80255e8:	af00      	add	r7, sp, #0
 80255ea:	f507 7494 	add.w	r4, r7, #296	@ 0x128
 80255ee:	f5a4 748e 	sub.w	r4, r4, #284	@ 0x11c
 80255f2:	6020      	str	r0, [r4, #0]
 80255f4:	f507 7094 	add.w	r0, r7, #296	@ 0x128
 80255f8:	f5a0 7090 	sub.w	r0, r0, #288	@ 0x120
 80255fc:	6001      	str	r1, [r0, #0]
 80255fe:	f507 7194 	add.w	r1, r7, #296	@ 0x128
 8025602:	f5a1 7192 	sub.w	r1, r1, #292	@ 0x124
 8025606:	600a      	str	r2, [r1, #0]
 8025608:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 802560c:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 8025610:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8025612:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8025616:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 802561a:	681b      	ldr	r3, [r3, #0]
 802561c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8025620:	3380      	adds	r3, #128	@ 0x80
 8025622:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 8025626:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 802562a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 802562e:	681b      	ldr	r3, [r3, #0]
 8025630:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8025634:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8025638:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 802563c:	681b      	ldr	r3, [r3, #0]
 802563e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8025640:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  wsptr = workspace;
 8025644:	f107 0310 	add.w	r3, r7, #16
 8025648:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802564c:	2300      	movs	r3, #0
 802564e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8025652:	e105      	b.n	8025860 <jpeg_idct_12x6+0x27c>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8025654:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025658:	f9b3 3000 	ldrsh.w	r3, [r3]
 802565c:	461a      	mov	r2, r3
 802565e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025662:	681b      	ldr	r3, [r3, #0]
 8025664:	fb02 f303 	mul.w	r3, r2, r3
 8025668:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp10 <<= CONST_BITS;
 802566c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025670:	035b      	lsls	r3, r3, #13
 8025672:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 8025676:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802567a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802567e:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp12 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8025682:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025686:	3340      	adds	r3, #64	@ 0x40
 8025688:	f9b3 3000 	ldrsh.w	r3, [r3]
 802568c:	461a      	mov	r2, r3
 802568e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025692:	3380      	adds	r3, #128	@ 0x80
 8025694:	681b      	ldr	r3, [r3, #0]
 8025696:	fb02 f303 	mul.w	r3, r2, r3
 802569a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 802569e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80256a2:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 80256a6:	fb02 f303 	mul.w	r3, r2, r3
 80256aa:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp20;
 80256ae:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80256b2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80256b6:	4413      	add	r3, r2
 80256b8:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp21 = RIGHT_SHIFT(tmp10 - tmp20 - tmp20, CONST_BITS-PASS1_BITS);
 80256bc:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80256c0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80256c4:	1ad2      	subs	r2, r2, r3
 80256c6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80256ca:	1ad3      	subs	r3, r2, r3
 80256cc:	12db      	asrs	r3, r3, #11
 80256ce:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp20 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80256d2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80256d6:	3320      	adds	r3, #32
 80256d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80256dc:	461a      	mov	r2, r3
 80256de:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80256e2:	3340      	adds	r3, #64	@ 0x40
 80256e4:	681b      	ldr	r3, [r3, #0]
 80256e6:	fb02 f303 	mul.w	r3, r2, r3
 80256ea:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 80256ee:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80256f2:	f242 7231 	movw	r2, #10033	@ 0x2731
 80256f6:	fb02 f303 	mul.w	r3, r2, r3
 80256fa:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp20 = tmp11 + tmp10;
 80256fe:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8025702:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025706:	4413      	add	r3, r2
 8025708:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp22 = tmp11 - tmp10;
 802570c:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8025710:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025714:	1ad3      	subs	r3, r2, r3
 8025716:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802571a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802571e:	3310      	adds	r3, #16
 8025720:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025724:	461a      	mov	r2, r3
 8025726:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802572a:	3320      	adds	r3, #32
 802572c:	681b      	ldr	r3, [r3, #0]
 802572e:	fb02 f303 	mul.w	r3, r2, r3
 8025732:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8025736:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802573a:	3330      	adds	r3, #48	@ 0x30
 802573c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025740:	461a      	mov	r2, r3
 8025742:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025746:	3360      	adds	r3, #96	@ 0x60
 8025748:	681b      	ldr	r3, [r3, #0]
 802574a:	fb02 f303 	mul.w	r3, r2, r3
 802574e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8025752:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025756:	3350      	adds	r3, #80	@ 0x50
 8025758:	f9b3 3000 	ldrsh.w	r3, [r3]
 802575c:	461a      	mov	r2, r3
 802575e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025762:	33a0      	adds	r3, #160	@ 0xa0
 8025764:	681b      	ldr	r3, [r3, #0]
 8025766:	fb02 f303 	mul.w	r3, r2, r3
 802576a:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 802576e:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025772:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025776:	4413      	add	r3, r2
 8025778:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 802577c:	fb02 f303 	mul.w	r3, r2, r3
 8025780:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 8025784:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025788:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802578c:	4413      	add	r3, r2
 802578e:	035b      	lsls	r3, r3, #13
 8025790:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8025794:	4413      	add	r3, r2
 8025796:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 802579a:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 802579e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80257a2:	1ad3      	subs	r3, r2, r3
 80257a4:	035b      	lsls	r3, r3, #13
 80257a6:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 80257aa:	4413      	add	r3, r2
 80257ac:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp11 = (z1 - z2 - z3) << PASS1_BITS;
 80257b0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80257b4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80257b8:	1ad2      	subs	r2, r2, r3
 80257ba:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80257be:	1ad3      	subs	r3, r2, r3
 80257c0:	009b      	lsls	r3, r3, #2
 80257c2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80257c6:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 80257ca:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80257ce:	4413      	add	r3, r2
 80257d0:	12da      	asrs	r2, r3, #11
 80257d2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80257d6:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80257d8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 80257dc:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80257e0:	1ad2      	subs	r2, r2, r3
 80257e2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80257e6:	33a0      	adds	r3, #160	@ 0xa0
 80257e8:	12d2      	asrs	r2, r2, #11
 80257ea:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp21 + tmp11);
 80257ec:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80257f0:	3320      	adds	r3, #32
 80257f2:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 80257f6:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 80257fa:	440a      	add	r2, r1
 80257fc:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) (tmp21 - tmp11);
 80257fe:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025802:	3380      	adds	r3, #128	@ 0x80
 8025804:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 8025808:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802580c:	1a8a      	subs	r2, r1, r2
 802580e:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8025810:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8025814:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025818:	441a      	add	r2, r3
 802581a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 802581e:	3340      	adds	r3, #64	@ 0x40
 8025820:	12d2      	asrs	r2, r2, #11
 8025822:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8025824:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8025828:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802582c:	1ad2      	subs	r2, r2, r3
 802582e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025832:	3360      	adds	r3, #96	@ 0x60
 8025834:	12d2      	asrs	r2, r2, #11
 8025836:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025838:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802583c:	3301      	adds	r3, #1
 802583e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8025842:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8025846:	3302      	adds	r3, #2
 8025848:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 802584c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8025850:	3304      	adds	r3, #4
 8025852:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8025856:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 802585a:	3304      	adds	r3, #4
 802585c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8025860:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8025864:	2b07      	cmp	r3, #7
 8025866:	f77f aef5 	ble.w	8025654 <jpeg_idct_12x6+0x70>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  wsptr = workspace;
 802586a:	f107 0310 	add.w	r3, r7, #16
 802586e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 8025872:	2300      	movs	r3, #0
 8025874:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8025878:	e21d      	b.n	8025cb6 <jpeg_idct_12x6+0x6d2>
    outptr = output_buf[ctr] + output_col;
 802587a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802587e:	009b      	lsls	r3, r3, #2
 8025880:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8025884:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 8025888:	6812      	ldr	r2, [r2, #0]
 802588a:	4413      	add	r3, r2
 802588c:	681a      	ldr	r2, [r3, #0]
 802588e:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8025892:	4413      	add	r3, r2
 8025894:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8025898:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 802589c:	681b      	ldr	r3, [r3, #0]
 802589e:	3310      	adds	r3, #16
 80258a0:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z3 <<= CONST_BITS;
 80258a4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80258a8:	035b      	lsls	r3, r3, #13
 80258aa:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    z4 = (INT32) wsptr[4];
 80258ae:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80258b2:	3310      	adds	r3, #16
 80258b4:	681b      	ldr	r3, [r3, #0]
 80258b6:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 80258ba:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80258be:	f242 7231 	movw	r2, #10033	@ 0x2731
 80258c2:	fb02 f303 	mul.w	r3, r2, r3
 80258c6:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108

    tmp10 = z3 + z4;
 80258ca:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 80258ce:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80258d2:	4413      	add	r3, r2
 80258d4:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp11 = z3 - z4;
 80258d8:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 80258dc:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80258e0:	1ad3      	subs	r3, r2, r3
 80258e2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = (INT32) wsptr[2];
 80258e6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80258ea:	3308      	adds	r3, #8
 80258ec:	681b      	ldr	r3, [r3, #0]
 80258ee:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 80258f2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80258f6:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 80258fa:	fb02 f303 	mul.w	r3, r2, r3
 80258fe:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z1 <<= CONST_BITS;
 8025902:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025906:	035b      	lsls	r3, r3, #13
 8025908:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = (INT32) wsptr[6];
 802590c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025910:	3318      	adds	r3, #24
 8025912:	681b      	ldr	r3, [r3, #0]
 8025914:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 <<= CONST_BITS;
 8025918:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802591c:	035b      	lsls	r3, r3, #13
 802591e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

    tmp12 = z1 - z2;
 8025922:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025926:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802592a:	1ad3      	subs	r3, r2, r3
 802592c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp21 = z3 + tmp12;
 8025930:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8025934:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025938:	4413      	add	r3, r2
 802593a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp24 = z3 - tmp12;
 802593e:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8025942:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025946:	1ad3      	subs	r3, r2, r3
 8025948:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec

    tmp12 = z4 + z2;
 802594c:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8025950:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025954:	4413      	add	r3, r2
 8025956:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp20 = tmp10 + tmp12;
 802595a:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802595e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025962:	4413      	add	r3, r2
 8025964:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp25 = tmp10 - tmp12;
 8025968:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802596c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025970:	1ad3      	subs	r3, r2, r3
 8025972:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    tmp12 = z4 - z1 - z2;
 8025976:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802597a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 802597e:	1ad2      	subs	r2, r2, r3
 8025980:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025984:	1ad3      	subs	r3, r2, r3
 8025986:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp22 = tmp11 + tmp12;
 802598a:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802598e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025992:	4413      	add	r3, r2
 8025994:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp23 = tmp11 - tmp12;
 8025998:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802599c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80259a0:	1ad3      	subs	r3, r2, r3
 80259a2:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80259a6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80259aa:	3304      	adds	r3, #4
 80259ac:	681b      	ldr	r3, [r3, #0]
 80259ae:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = (INT32) wsptr[3];
 80259b2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80259b6:	330c      	adds	r3, #12
 80259b8:	681b      	ldr	r3, [r3, #0]
 80259ba:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = (INT32) wsptr[5];
 80259be:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80259c2:	3314      	adds	r3, #20
 80259c4:	681b      	ldr	r3, [r3, #0]
 80259c6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z4 = (INT32) wsptr[7];
 80259ca:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80259ce:	331c      	adds	r3, #28
 80259d0:	681b      	ldr	r3, [r3, #0]
 80259d2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 80259d6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80259da:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 80259de:	fb02 f303 	mul.w	r3, r2, r3
 80259e2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 80259e6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80259ea:	4ab9      	ldr	r2, [pc, #740]	@ (8025cd0 <jpeg_idct_12x6+0x6ec>)
 80259ec:	fb02 f303 	mul.w	r3, r2, r3
 80259f0:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    tmp10 = z1 + z3;
 80259f4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80259f8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80259fc:	4413      	add	r3, r2
 80259fe:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 8025a02:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8025a06:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025a0a:	4413      	add	r3, r2
 8025a0c:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 8025a10:	fb02 f303 	mul.w	r3, r2, r3
 8025a14:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 8025a18:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025a1c:	f640 025b 	movw	r2, #2139	@ 0x85b
 8025a20:	fb02 f303 	mul.w	r3, r2, r3
 8025a24:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025a28:	4413      	add	r3, r2
 8025a2a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 8025a2e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8025a32:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8025a36:	18d1      	adds	r1, r2, r3
 8025a38:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025a3c:	4613      	mov	r3, r2
 8025a3e:	00db      	lsls	r3, r3, #3
 8025a40:	4413      	add	r3, r2
 8025a42:	021a      	lsls	r2, r3, #8
 8025a44:	1ad3      	subs	r3, r2, r3
 8025a46:	440b      	add	r3, r1
 8025a48:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8025a4c:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8025a50:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025a54:	4413      	add	r3, r2
 8025a56:	4a9f      	ldr	r2, [pc, #636]	@ (8025cd4 <jpeg_idct_12x6+0x6f0>)
 8025a58:	fb02 f303 	mul.w	r3, r2, r3
 8025a5c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8025a60:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025a64:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025a68:	441a      	add	r2, r3
 8025a6a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025a6e:	499a      	ldr	r1, [pc, #616]	@ (8025cd8 <jpeg_idct_12x6+0x6f4>)
 8025a70:	fb01 f303 	mul.w	r3, r1, r3
 8025a74:	4413      	add	r3, r2
 8025a76:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8025a7a:	4413      	add	r3, r2
 8025a7c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8025a80:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025a84:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8025a88:	1ad2      	subs	r2, r2, r3
 8025a8a:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025a8e:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 8025a92:	fb01 f303 	mul.w	r3, r1, r3
 8025a96:	4413      	add	r3, r2
 8025a98:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025a9c:	4413      	add	r3, r2
 8025a9e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8025aa2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025aa6:	4a8d      	ldr	r2, [pc, #564]	@ (8025cdc <jpeg_idct_12x6+0x6f8>)
 8025aa8:	fb03 f202 	mul.w	r2, r3, r2
 8025aac:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025ab0:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8025ab2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025ab6:	498a      	ldr	r1, [pc, #552]	@ (8025ce0 <jpeg_idct_12x6+0x6fc>)
 8025ab8:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8025abc:	4413      	add	r3, r2
 8025abe:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025ac2:	4413      	add	r3, r2
 8025ac4:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

    z1 -= z4;
 8025ac8:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025acc:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025ad0:	1ad3      	subs	r3, r2, r3
 8025ad2:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 -= z3;
 8025ad6:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8025ada:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8025ade:	1ad3      	subs	r3, r2, r3
 8025ae0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8025ae4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8025ae8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025aec:	4413      	add	r3, r2
 8025aee:	f241 1251 	movw	r2, #4433	@ 0x1151
 8025af2:	fb02 f303 	mul.w	r3, r2, r3
 8025af6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 8025afa:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025afe:	f641 027e 	movw	r2, #6270	@ 0x187e
 8025b02:	fb02 f303 	mul.w	r3, r2, r3
 8025b06:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8025b0a:	4413      	add	r3, r2
 8025b0c:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 8025b10:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025b14:	4a73      	ldr	r2, [pc, #460]	@ (8025ce4 <jpeg_idct_12x6+0x700>)
 8025b16:	fb02 f303 	mul.w	r3, r2, r3
 8025b1a:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8025b1e:	4413      	add	r3, r2
 8025b20:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8025b24:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8025b28:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025b2c:	4413      	add	r3, r2
 8025b2e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025b30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8025b34:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025b38:	4413      	add	r3, r2
 8025b3a:	781a      	ldrb	r2, [r3, #0]
 8025b3c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025b40:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8025b42:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8025b46:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8025b4a:	1ad3      	subs	r3, r2, r3
 8025b4c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025b4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8025b52:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025b56:	441a      	add	r2, r3
 8025b58:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025b5c:	330b      	adds	r3, #11
 8025b5e:	7812      	ldrb	r2, [r2, #0]
 8025b60:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8025b62:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8025b66:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8025b6a:	4413      	add	r3, r2
 8025b6c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025b6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8025b72:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025b76:	441a      	add	r2, r3
 8025b78:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025b7c:	3301      	adds	r3, #1
 8025b7e:	7812      	ldrb	r2, [r2, #0]
 8025b80:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8025b82:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8025b86:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8025b8a:	1ad3      	subs	r3, r2, r3
 8025b8c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025b8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8025b92:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025b96:	441a      	add	r2, r3
 8025b98:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025b9c:	330a      	adds	r3, #10
 8025b9e:	7812      	ldrb	r2, [r2, #0]
 8025ba0:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025ba2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8025ba6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025baa:	4413      	add	r3, r2
 8025bac:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025bae:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025bb2:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025bb6:	441a      	add	r2, r3
 8025bb8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025bbc:	3302      	adds	r3, #2
 8025bbe:	7812      	ldrb	r2, [r2, #0]
 8025bc0:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025bc2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8025bc6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025bca:	1ad3      	subs	r3, r2, r3
 8025bcc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025bce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025bd2:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025bd6:	441a      	add	r2, r3
 8025bd8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025bdc:	3309      	adds	r3, #9
 8025bde:	7812      	ldrb	r2, [r2, #0]
 8025be0:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8025be2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025be6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025bea:	4413      	add	r3, r2
 8025bec:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025bee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8025bf2:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025bf6:	441a      	add	r2, r3
 8025bf8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025bfc:	3303      	adds	r3, #3
 8025bfe:	7812      	ldrb	r2, [r2, #0]
 8025c00:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8025c02:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025c06:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025c0a:	1ad3      	subs	r3, r2, r3
 8025c0c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025c0e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8025c12:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025c16:	441a      	add	r2, r3
 8025c18:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025c1c:	3308      	adds	r3, #8
 8025c1e:	7812      	ldrb	r2, [r2, #0]
 8025c20:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8025c22:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8025c26:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025c2a:	4413      	add	r3, r2
 8025c2c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025c2e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8025c32:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025c36:	441a      	add	r2, r3
 8025c38:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025c3c:	3304      	adds	r3, #4
 8025c3e:	7812      	ldrb	r2, [r2, #0]
 8025c40:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8025c42:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8025c46:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025c4a:	1ad3      	subs	r3, r2, r3
 8025c4c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025c4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8025c52:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025c56:	441a      	add	r2, r3
 8025c58:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025c5c:	3307      	adds	r3, #7
 8025c5e:	7812      	ldrb	r2, [r2, #0]
 8025c60:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8025c62:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025c66:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8025c6a:	4413      	add	r3, r2
 8025c6c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025c6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8025c72:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025c76:	441a      	add	r2, r3
 8025c78:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025c7c:	3305      	adds	r3, #5
 8025c7e:	7812      	ldrb	r2, [r2, #0]
 8025c80:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8025c82:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025c86:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8025c8a:	1ad3      	subs	r3, r2, r3
 8025c8c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025c8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8025c92:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8025c96:	441a      	add	r2, r3
 8025c98:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8025c9c:	3306      	adds	r3, #6
 8025c9e:	7812      	ldrb	r2, [r2, #0]
 8025ca0:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8025ca2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8025ca6:	3320      	adds	r3, #32
 8025ca8:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 8025cac:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8025cb0:	3301      	adds	r3, #1
 8025cb2:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8025cb6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8025cba:	2b05      	cmp	r3, #5
 8025cbc:	f77f addd 	ble.w	802587a <jpeg_idct_12x6+0x296>
  }
}
 8025cc0:	bf00      	nop
 8025cc2:	bf00      	nop
 8025cc4:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 8025cc8:	46bd      	mov	sp, r7
 8025cca:	bc90      	pop	{r4, r7}
 8025ccc:	4770      	bx	lr
 8025cce:	bf00      	nop
 8025cd0:	ffffeeaf 	.word	0xffffeeaf
 8025cd4:	ffffde8b 	.word	0xffffde8b
 8025cd8:	ffffd0b0 	.word	0xffffd0b0
 8025cdc:	ffffea5c 	.word	0xffffea5c
 8025ce0:	ffffc08c 	.word	0xffffc08c
 8025ce4:	ffffc4df 	.word	0xffffc4df

08025ce8 <jpeg_idct_10x5>:

GLOBAL(void)
jpeg_idct_10x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8025ce8:	b480      	push	{r7}
 8025cea:	b0c1      	sub	sp, #260	@ 0x104
 8025cec:	af00      	add	r7, sp, #0
 8025cee:	60f8      	str	r0, [r7, #12]
 8025cf0:	60b9      	str	r1, [r7, #8]
 8025cf2:	607a      	str	r2, [r7, #4]
 8025cf4:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 8025cf8:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 8025cfc:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8025cfe:	68fb      	ldr	r3, [r7, #12]
 8025d00:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8025d04:	3380      	adds	r3, #128	@ 0x80
 8025d06:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  inptr = coef_block;
 8025d0a:	687b      	ldr	r3, [r7, #4]
 8025d0c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8025d10:	68bb      	ldr	r3, [r7, #8]
 8025d12:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8025d14:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
  wsptr = workspace;
 8025d18:	f107 0310 	add.w	r3, r7, #16
 8025d1c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025d20:	2300      	movs	r3, #0
 8025d22:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8025d26:	e0e3      	b.n	8025ef0 <jpeg_idct_10x5+0x208>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8025d28:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025d2c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025d30:	461a      	mov	r2, r3
 8025d32:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025d36:	681b      	ldr	r3, [r3, #0]
 8025d38:	fb02 f303 	mul.w	r3, r2, r3
 8025d3c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp12 <<= CONST_BITS;
 8025d40:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025d44:	035b      	lsls	r3, r3, #13
 8025d46:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 8025d4a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025d4e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8025d52:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp13 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8025d56:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025d5a:	3320      	adds	r3, #32
 8025d5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025d60:	461a      	mov	r2, r3
 8025d62:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025d66:	3340      	adds	r3, #64	@ 0x40
 8025d68:	681b      	ldr	r3, [r3, #0]
 8025d6a:	fb02 f303 	mul.w	r3, r2, r3
 8025d6e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp14 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8025d72:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025d76:	3340      	adds	r3, #64	@ 0x40
 8025d78:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025d7c:	461a      	mov	r2, r3
 8025d7e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025d82:	3380      	adds	r3, #128	@ 0x80
 8025d84:	681b      	ldr	r3, [r3, #0]
 8025d86:	fb02 f303 	mul.w	r3, r2, r3
 8025d8a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 8025d8e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8025d92:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8025d96:	4413      	add	r3, r2
 8025d98:	f641 124c 	movw	r2, #6476	@ 0x194c
 8025d9c:	fb02 f303 	mul.w	r3, r2, r3
 8025da0:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 8025da4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8025da8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8025dac:	1ad3      	subs	r3, r2, r3
 8025dae:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8025db2:	fb02 f303 	mul.w	r3, r2, r3
 8025db6:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = tmp12 + z2;
 8025dba:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8025dbe:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025dc2:	4413      	add	r3, r2
 8025dc4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp10 = z3 + z1;
 8025dc8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025dcc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8025dd0:	4413      	add	r3, r2
 8025dd2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp11 = z3 - z1;
 8025dd6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025dda:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8025dde:	1ad3      	subs	r3, r2, r3
 8025de0:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp12 -= z2 << 2;
 8025de4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025de8:	009b      	lsls	r3, r3, #2
 8025dea:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8025dee:	1ad3      	subs	r3, r2, r3
 8025df0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8025df4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025df8:	3310      	adds	r3, #16
 8025dfa:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025dfe:	461a      	mov	r2, r3
 8025e00:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025e04:	3320      	adds	r3, #32
 8025e06:	681b      	ldr	r3, [r3, #0]
 8025e08:	fb02 f303 	mul.w	r3, r2, r3
 8025e0c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8025e10:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025e14:	3330      	adds	r3, #48	@ 0x30
 8025e16:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025e1a:	461a      	mov	r2, r3
 8025e1c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025e20:	3360      	adds	r3, #96	@ 0x60
 8025e22:	681b      	ldr	r3, [r3, #0]
 8025e24:	fb02 f303 	mul.w	r3, r2, r3
 8025e28:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 8025e2c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8025e30:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8025e34:	4413      	add	r3, r2
 8025e36:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8025e3a:	fb02 f303 	mul.w	r3, r2, r3
 8025e3e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 8025e42:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025e46:	f241 0271 	movw	r2, #4209	@ 0x1071
 8025e4a:	fb02 f303 	mul.w	r3, r2, r3
 8025e4e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025e52:	4413      	add	r3, r2
 8025e54:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 8025e58:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8025e5c:	4a2b      	ldr	r2, [pc, #172]	@ (8025f0c <jpeg_idct_10x5+0x224>)
 8025e5e:	fb02 f303 	mul.w	r3, r2, r3
 8025e62:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025e66:	4413      	add	r3, r2
 8025e68:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp13, CONST_BITS-PASS1_BITS);
 8025e6c:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025e70:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025e74:	4413      	add	r3, r2
 8025e76:	12da      	asrs	r2, r3, #11
 8025e78:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025e7c:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp10 - tmp13, CONST_BITS-PASS1_BITS);
 8025e7e:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025e82:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025e86:	1ad2      	subs	r2, r2, r3
 8025e88:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025e8c:	3380      	adds	r3, #128	@ 0x80
 8025e8e:	12d2      	asrs	r2, r2, #11
 8025e90:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp14, CONST_BITS-PASS1_BITS);
 8025e92:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025e96:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8025e9a:	441a      	add	r2, r3
 8025e9c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025ea0:	3320      	adds	r3, #32
 8025ea2:	12d2      	asrs	r2, r2, #11
 8025ea4:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp11 - tmp14, CONST_BITS-PASS1_BITS);
 8025ea6:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025eaa:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8025eae:	1ad2      	subs	r2, r2, r3
 8025eb0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025eb4:	3360      	adds	r3, #96	@ 0x60
 8025eb6:	12d2      	asrs	r2, r2, #11
 8025eb8:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 8025eba:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025ebe:	3340      	adds	r3, #64	@ 0x40
 8025ec0:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8025ec4:	12d2      	asrs	r2, r2, #11
 8025ec6:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025ec8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8025ecc:	3301      	adds	r3, #1
 8025ece:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8025ed2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8025ed6:	3302      	adds	r3, #2
 8025ed8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 8025edc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8025ee0:	3304      	adds	r3, #4
 8025ee2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8025ee6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025eea:	3304      	adds	r3, #4
 8025eec:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8025ef0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8025ef4:	2b07      	cmp	r3, #7
 8025ef6:	f77f af17 	ble.w	8025d28 <jpeg_idct_10x5+0x40>
  }

  /* Pass 2: process 5 rows from work array, store into output array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  wsptr = workspace;
 8025efa:	f107 0310 	add.w	r3, r7, #16
 8025efe:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 8025f02:	2300      	movs	r3, #0
 8025f04:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8025f08:	e1d4      	b.n	80262b4 <jpeg_idct_10x5+0x5cc>
 8025f0a:	bf00      	nop
 8025f0c:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 8025f10:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8025f14:	009b      	lsls	r3, r3, #2
 8025f16:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 8025f1a:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 8025f1e:	6812      	ldr	r2, [r2, #0]
 8025f20:	4413      	add	r3, r2
 8025f22:	681a      	ldr	r2, [r3, #0]
 8025f24:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8025f28:	4413      	add	r3, r2
 8025f2a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8025f2e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025f32:	681b      	ldr	r3, [r3, #0]
 8025f34:	3310      	adds	r3, #16
 8025f36:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z3 <<= CONST_BITS;
 8025f3a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8025f3e:	035b      	lsls	r3, r3, #13
 8025f40:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z4 = (INT32) wsptr[4];
 8025f44:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025f48:	3310      	adds	r3, #16
 8025f4a:	681b      	ldr	r3, [r3, #0]
 8025f4c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 8025f50:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8025f54:	f242 429d 	movw	r2, #9373	@ 0x249d
 8025f58:	fb02 f303 	mul.w	r3, r2, r3
 8025f5c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 8025f60:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8025f64:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8025f68:	fb02 f303 	mul.w	r3, r2, r3
 8025f6c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp10 = z3 + z1;
 8025f70:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025f74:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8025f78:	4413      	add	r3, r2
 8025f7a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp11 = z3 - z2;
 8025f7e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025f82:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025f86:	1ad3      	subs	r3, r2, r3
 8025f88:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 8025f8c:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025f90:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025f94:	1ad3      	subs	r3, r2, r3
 8025f96:	005b      	lsls	r3, r3, #1
 8025f98:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8025f9c:	1ad3      	subs	r3, r2, r3
 8025f9e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc

    z2 = (INT32) wsptr[2];
 8025fa2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025fa6:	3308      	adds	r3, #8
 8025fa8:	681b      	ldr	r3, [r3, #0]
 8025faa:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = (INT32) wsptr[6];
 8025fae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8025fb2:	3318      	adds	r3, #24
 8025fb4:	681b      	ldr	r3, [r3, #0]
 8025fb6:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8025fba:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8025fbe:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8025fc2:	4413      	add	r3, r2
 8025fc4:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8025fc8:	fb02 f303 	mul.w	r3, r2, r3
 8025fcc:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 8025fd0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8025fd4:	f241 0271 	movw	r2, #4209	@ 0x1071
 8025fd8:	fb02 f303 	mul.w	r3, r2, r3
 8025fdc:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025fe0:	4413      	add	r3, r2
 8025fe2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 8025fe6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8025fea:	4ab9      	ldr	r2, [pc, #740]	@ (80262d0 <jpeg_idct_10x5+0x5e8>)
 8025fec:	fb02 f303 	mul.w	r3, r2, r3
 8025ff0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8025ff4:	4413      	add	r3, r2
 8025ff6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    tmp20 = tmp10 + tmp12;
 8025ffa:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025ffe:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026002:	4413      	add	r3, r2
 8026004:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp24 = tmp10 - tmp12;
 8026008:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 802600c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026010:	1ad3      	subs	r3, r2, r3
 8026012:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp21 = tmp11 + tmp13;
 8026016:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 802601a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802601e:	4413      	add	r3, r2
 8026020:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp23 = tmp11 - tmp13;
 8026024:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8026028:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802602c:	1ad3      	subs	r3, r2, r3
 802602e:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8026032:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8026036:	3304      	adds	r3, #4
 8026038:	681b      	ldr	r3, [r3, #0]
 802603a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = (INT32) wsptr[3];
 802603e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8026042:	330c      	adds	r3, #12
 8026044:	681b      	ldr	r3, [r3, #0]
 8026046:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = (INT32) wsptr[5];
 802604a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802604e:	3314      	adds	r3, #20
 8026050:	681b      	ldr	r3, [r3, #0]
 8026052:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z3 <<= CONST_BITS;
 8026056:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 802605a:	035b      	lsls	r3, r3, #13
 802605c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z4 = (INT32) wsptr[7];
 8026060:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8026064:	331c      	adds	r3, #28
 8026066:	681b      	ldr	r3, [r3, #0]
 8026068:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp11 = z2 + z4;
 802606c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8026070:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8026074:	4413      	add	r3, r2
 8026076:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp13 = z2 - z4;
 802607a:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802607e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8026082:	1ad3      	subs	r3, r2, r3
 8026084:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 8026088:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802608c:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 8026090:	fb02 f303 	mul.w	r3, r2, r3
 8026094:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 8026098:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802609c:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 80260a0:	fb02 f303 	mul.w	r3, r2, r3
 80260a4:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z4 = z3 + tmp12;
 80260a8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80260ac:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80260b0:	4413      	add	r3, r2
 80260b2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 80260b6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80260ba:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 80260be:	fb03 f202 	mul.w	r2, r3, r2
 80260c2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80260c6:	4413      	add	r3, r2
 80260c8:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80260cc:	4413      	add	r3, r2
 80260ce:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 80260d2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80260d6:	f240 7214 	movw	r2, #1812	@ 0x714
 80260da:	fb03 f202 	mul.w	r2, r3, r2
 80260de:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80260e2:	1ad3      	subs	r3, r2, r3
 80260e4:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80260e8:	4413      	add	r3, r2
 80260ea:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 80260ee:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80260f2:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 80260f6:	fb02 f303 	mul.w	r3, r2, r3
 80260fa:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 80260fe:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8026102:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026106:	1ad2      	subs	r2, r2, r3
 8026108:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802610c:	031b      	lsls	r3, r3, #12
 802610e:	1ad3      	subs	r3, r2, r3
 8026110:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 8026114:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8026118:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802611c:	1ad3      	subs	r3, r2, r3
 802611e:	035a      	lsls	r2, r3, #13
 8026120:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8026124:	1ad3      	subs	r3, r2, r3
 8026126:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 802612a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802612e:	f642 0253 	movw	r2, #10323	@ 0x2853
 8026132:	fb03 f202 	mul.w	r2, r3, r2
 8026136:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802613a:	1ad2      	subs	r2, r2, r3
 802613c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8026140:	1ad3      	subs	r3, r2, r3
 8026142:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8026146:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802614a:	f241 428c 	movw	r2, #5260	@ 0x148c
 802614e:	fb03 f202 	mul.w	r2, r3, r2
 8026152:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8026156:	1ad3      	subs	r3, r2, r3
 8026158:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 802615c:	4413      	add	r3, r2
 802615e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8026162:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8026166:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802616a:	4413      	add	r3, r2
 802616c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802616e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8026172:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026176:	4413      	add	r3, r2
 8026178:	781a      	ldrb	r2, [r3, #0]
 802617a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802617e:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8026180:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8026184:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026188:	1ad3      	subs	r3, r2, r3
 802618a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802618c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8026190:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026194:	441a      	add	r2, r3
 8026196:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802619a:	3309      	adds	r3, #9
 802619c:	7812      	ldrb	r2, [r2, #0]
 802619e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80261a0:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80261a4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80261a8:	4413      	add	r3, r2
 80261aa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80261ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80261b0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80261b4:	441a      	add	r2, r3
 80261b6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80261ba:	3301      	adds	r3, #1
 80261bc:	7812      	ldrb	r2, [r2, #0]
 80261be:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80261c0:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80261c4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80261c8:	1ad3      	subs	r3, r2, r3
 80261ca:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80261cc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80261d0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80261d4:	441a      	add	r2, r3
 80261d6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80261da:	3308      	adds	r3, #8
 80261dc:	7812      	ldrb	r2, [r2, #0]
 80261de:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80261e0:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80261e4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80261e8:	4413      	add	r3, r2
 80261ea:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80261ec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80261f0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80261f4:	441a      	add	r2, r3
 80261f6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80261fa:	3302      	adds	r3, #2
 80261fc:	7812      	ldrb	r2, [r2, #0]
 80261fe:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8026200:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8026204:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026208:	1ad3      	subs	r3, r2, r3
 802620a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802620c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8026210:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026214:	441a      	add	r2, r3
 8026216:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802621a:	3307      	adds	r3, #7
 802621c:	7812      	ldrb	r2, [r2, #0]
 802621e:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8026220:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026224:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8026228:	4413      	add	r3, r2
 802622a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802622c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8026230:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026234:	441a      	add	r2, r3
 8026236:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802623a:	3303      	adds	r3, #3
 802623c:	7812      	ldrb	r2, [r2, #0]
 802623e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8026240:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026244:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8026248:	1ad3      	subs	r3, r2, r3
 802624a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802624c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8026250:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026254:	441a      	add	r2, r3
 8026256:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802625a:	3306      	adds	r3, #6
 802625c:	7812      	ldrb	r2, [r2, #0]
 802625e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8026260:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8026264:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026268:	4413      	add	r3, r2
 802626a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802626c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8026270:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026274:	441a      	add	r2, r3
 8026276:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802627a:	3304      	adds	r3, #4
 802627c:	7812      	ldrb	r2, [r2, #0]
 802627e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8026280:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8026284:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026288:	1ad3      	subs	r3, r2, r3
 802628a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802628c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8026290:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8026294:	441a      	add	r2, r3
 8026296:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802629a:	3305      	adds	r3, #5
 802629c:	7812      	ldrb	r2, [r2, #0]
 802629e:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80262a0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80262a4:	3320      	adds	r3, #32
 80262a6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 80262aa:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80262ae:	3301      	adds	r3, #1
 80262b0:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 80262b4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80262b8:	2b04      	cmp	r3, #4
 80262ba:	f77f ae29 	ble.w	8025f10 <jpeg_idct_10x5+0x228>
  }
}
 80262be:	bf00      	nop
 80262c0:	bf00      	nop
 80262c2:	f507 7782 	add.w	r7, r7, #260	@ 0x104
 80262c6:	46bd      	mov	sp, r7
 80262c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80262cc:	4770      	bx	lr
 80262ce:	bf00      	nop
 80262d0:	ffffba5c 	.word	0xffffba5c

080262d4 <jpeg_idct_8x4>:

GLOBAL(void)
jpeg_idct_8x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80262d4:	b480      	push	{r7}
 80262d6:	b0b7      	sub	sp, #220	@ 0xdc
 80262d8:	af00      	add	r7, sp, #0
 80262da:	60f8      	str	r0, [r7, #12]
 80262dc:	60b9      	str	r1, [r7, #8]
 80262de:	607a      	str	r2, [r7, #4]
 80262e0:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80262e2:	68fb      	ldr	r3, [r7, #12]
 80262e4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80262e8:	3380      	adds	r3, #128	@ 0x80
 80262ea:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  inptr = coef_block;
 80262ee:	687b      	ldr	r3, [r7, #4]
 80262f0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80262f4:	68bb      	ldr	r3, [r7, #8]
 80262f6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80262f8:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  wsptr = workspace;
 80262fc:	f107 0314 	add.w	r3, r7, #20
 8026300:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8026304:	2300      	movs	r3, #0
 8026306:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802630a:	e0a4      	b.n	8026456 <jpeg_idct_8x4+0x182>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802630c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026310:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026314:	461a      	mov	r2, r3
 8026316:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802631a:	681b      	ldr	r3, [r3, #0]
 802631c:	fb02 f303 	mul.w	r3, r2, r3
 8026320:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8026324:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026328:	3320      	adds	r3, #32
 802632a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802632e:	461a      	mov	r2, r3
 8026330:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8026334:	3340      	adds	r3, #64	@ 0x40
 8026336:	681b      	ldr	r3, [r3, #0]
 8026338:	fb02 f303 	mul.w	r3, r2, r3
 802633c:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 8026340:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8026344:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026348:	4413      	add	r3, r2
 802634a:	009b      	lsls	r3, r3, #2
 802634c:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 8026350:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8026354:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026358:	1ad3      	subs	r3, r2, r3
 802635a:	009b      	lsls	r3, r3, #2
 802635c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8026360:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026364:	3310      	adds	r3, #16
 8026366:	f9b3 3000 	ldrsh.w	r3, [r3]
 802636a:	461a      	mov	r2, r3
 802636c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8026370:	3320      	adds	r3, #32
 8026372:	681b      	ldr	r3, [r3, #0]
 8026374:	fb02 f303 	mul.w	r3, r2, r3
 8026378:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802637c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026380:	3330      	adds	r3, #48	@ 0x30
 8026382:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026386:	461a      	mov	r2, r3
 8026388:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802638c:	3360      	adds	r3, #96	@ 0x60
 802638e:	681b      	ldr	r3, [r3, #0]
 8026390:	fb02 f303 	mul.w	r3, r2, r3
 8026394:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 8026398:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802639c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80263a0:	4413      	add	r3, r2
 80263a2:	f241 1251 	movw	r2, #4433	@ 0x1151
 80263a6:	fb02 f303 	mul.w	r3, r2, r3
 80263aa:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 80263ae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80263b2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80263b6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 80263ba:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80263be:	f641 027e 	movw	r2, #6270	@ 0x187e
 80263c2:	fb03 f202 	mul.w	r2, r3, r2
 80263c6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80263ca:	4413      	add	r3, r2
 80263cc:	12db      	asrs	r3, r3, #11
 80263ce:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 80263d2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80263d6:	4a26      	ldr	r2, [pc, #152]	@ (8026470 <jpeg_idct_8x4+0x19c>)
 80263d8:	fb03 f202 	mul.w	r2, r3, r2
 80263dc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80263e0:	4413      	add	r3, r2
 80263e2:	12db      	asrs	r3, r3, #11
 80263e4:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[8*0] = (int) (tmp10 + tmp0);
 80263e8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 80263ec:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80263f0:	441a      	add	r2, r3
 80263f2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80263f6:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) (tmp10 - tmp0);
 80263f8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80263fc:	3360      	adds	r3, #96	@ 0x60
 80263fe:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 8026402:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8026406:	1a8a      	subs	r2, r1, r2
 8026408:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp12 + tmp2);
 802640a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802640e:	3320      	adds	r3, #32
 8026410:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 8026414:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8026418:	440a      	add	r2, r1
 802641a:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp12 - tmp2);
 802641c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8026420:	3340      	adds	r3, #64	@ 0x40
 8026422:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 8026426:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802642a:	1a8a      	subs	r2, r1, r2
 802642c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802642e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026432:	3301      	adds	r3, #1
 8026434:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8026438:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802643c:	3302      	adds	r3, #2
 802643e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8026442:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8026446:	3304      	adds	r3, #4
 8026448:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 802644c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8026450:	3304      	adds	r3, #4
 8026452:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8026456:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802645a:	2b07      	cmp	r3, #7
 802645c:	f77f af56 	ble.w	802630c <jpeg_idct_8x4+0x38>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 8026460:	f107 0314 	add.w	r3, r7, #20
 8026464:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 8026468:	2300      	movs	r3, #0
 802646a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802646e:	e1a2      	b.n	80267b6 <jpeg_idct_8x4+0x4e2>
 8026470:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 8026474:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026478:	009b      	lsls	r3, r3, #2
 802647a:	683a      	ldr	r2, [r7, #0]
 802647c:	4413      	add	r3, r2
 802647e:	681a      	ldr	r2, [r3, #0]
 8026480:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8026484:	4413      	add	r3, r2
 8026486:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = (INT32) wsptr[2];
 802648a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802648e:	3308      	adds	r3, #8
 8026490:	681b      	ldr	r3, [r3, #0]
 8026492:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = (INT32) wsptr[6];
 8026496:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802649a:	3318      	adds	r3, #24
 802649c:	681b      	ldr	r3, [r3, #0]
 802649e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 80264a2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80264a6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80264aa:	4413      	add	r3, r2
 80264ac:	f241 1251 	movw	r2, #4433	@ 0x1151
 80264b0:	fb02 f303 	mul.w	r3, r2, r3
 80264b4:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 80264b8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80264bc:	f641 027e 	movw	r2, #6270	@ 0x187e
 80264c0:	fb02 f303 	mul.w	r3, r2, r3
 80264c4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80264c8:	4413      	add	r3, r2
 80264ca:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 80264ce:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80264d2:	4abf      	ldr	r2, [pc, #764]	@ (80267d0 <jpeg_idct_8x4+0x4fc>)
 80264d4:	fb02 f303 	mul.w	r3, r2, r3
 80264d8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80264dc:	4413      	add	r3, r2
 80264de:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80264e2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80264e6:	681b      	ldr	r3, [r3, #0]
 80264e8:	3310      	adds	r3, #16
 80264ea:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = (INT32) wsptr[4];
 80264ee:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80264f2:	3310      	adds	r3, #16
 80264f4:	681b      	ldr	r3, [r3, #0]
 80264f6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    
    tmp0 = (z2 + z3) << CONST_BITS;
 80264fa:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80264fe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026502:	4413      	add	r3, r2
 8026504:	035b      	lsls	r3, r3, #13
 8026506:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp1 = (z2 - z3) << CONST_BITS;
 802650a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802650e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026512:	1ad3      	subs	r3, r2, r3
 8026514:	035b      	lsls	r3, r3, #13
 8026516:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    
    tmp10 = tmp0 + tmp2;
 802651a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 802651e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026522:	4413      	add	r3, r2
 8026524:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    tmp13 = tmp0 - tmp2;
 8026528:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 802652c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026530:	1ad3      	subs	r3, r2, r3
 8026532:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    tmp11 = tmp1 + tmp3;
 8026536:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802653a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802653e:	4413      	add	r3, r2
 8026540:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp12 = tmp1 - tmp3;
 8026544:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8026548:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802654c:	1ad3      	subs	r3, r2, r3
 802654e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 8026552:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8026556:	331c      	adds	r3, #28
 8026558:	681b      	ldr	r3, [r3, #0]
 802655a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp1 = (INT32) wsptr[5];
 802655e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8026562:	3314      	adds	r3, #20
 8026564:	681b      	ldr	r3, [r3, #0]
 8026566:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = (INT32) wsptr[3];
 802656a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802656e:	330c      	adds	r3, #12
 8026570:	681b      	ldr	r3, [r3, #0]
 8026572:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp3 = (INT32) wsptr[1];
 8026576:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802657a:	3304      	adds	r3, #4
 802657c:	681b      	ldr	r3, [r3, #0]
 802657e:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    z2 = tmp0 + tmp2;
 8026582:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8026586:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 802658a:	4413      	add	r3, r2
 802658c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = tmp1 + tmp3;
 8026590:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8026594:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8026598:	4413      	add	r3, r2
 802659a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 802659e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80265a2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80265a6:	4413      	add	r3, r2
 80265a8:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 80265ac:	fb02 f303 	mul.w	r3, r2, r3
 80265b0:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80265b4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80265b8:	4a86      	ldr	r2, [pc, #536]	@ (80267d4 <jpeg_idct_8x4+0x500>)
 80265ba:	fb02 f303 	mul.w	r3, r2, r3
 80265be:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 80265c2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80265c6:	4a84      	ldr	r2, [pc, #528]	@ (80267d8 <jpeg_idct_8x4+0x504>)
 80265c8:	fb02 f303 	mul.w	r3, r2, r3
 80265cc:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    z2 += z1;
 80265d0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80265d4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80265d8:	4413      	add	r3, r2
 80265da:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 += z1;
 80265de:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80265e2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80265e6:	4413      	add	r3, r2
 80265e8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80265ec:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80265f0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80265f4:	4413      	add	r3, r2
 80265f6:	4a79      	ldr	r2, [pc, #484]	@ (80267dc <jpeg_idct_8x4+0x508>)
 80265f8:	fb02 f303 	mul.w	r3, r2, r3
 80265fc:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8026600:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8026604:	f640 128e 	movw	r2, #2446	@ 0x98e
 8026608:	fb02 f303 	mul.w	r3, r2, r3
 802660c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8026610:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8026614:	f243 020b 	movw	r2, #12299	@ 0x300b
 8026618:	fb02 f303 	mul.w	r3, r2, r3
 802661c:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    tmp0 += z1 + z2;
 8026620:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026624:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8026628:	4413      	add	r3, r2
 802662a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 802662e:	4413      	add	r3, r2
 8026630:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp3 += z1 + z3;
 8026634:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026638:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802663c:	4413      	add	r3, r2
 802663e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8026642:	4413      	add	r3, r2
 8026644:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8026648:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802664c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026650:	4413      	add	r3, r2
 8026652:	4a63      	ldr	r2, [pc, #396]	@ (80267e0 <jpeg_idct_8x4+0x50c>)
 8026654:	fb02 f303 	mul.w	r3, r2, r3
 8026658:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 802665c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8026660:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 8026664:	fb02 f303 	mul.w	r3, r2, r3
 8026668:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 802666c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8026670:	f246 2254 	movw	r2, #25172	@ 0x6254
 8026674:	fb02 f303 	mul.w	r3, r2, r3
 8026678:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp1 += z1 + z3;
 802667c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026680:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026684:	4413      	add	r3, r2
 8026686:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802668a:	4413      	add	r3, r2
 802668c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 += z1 + z2;
 8026690:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8026694:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8026698:	4413      	add	r3, r2
 802669a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802669e:	4413      	add	r3, r2
 80266a0:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80266a4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 80266a8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80266ac:	4413      	add	r3, r2
 80266ae:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80266b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80266b4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80266b8:	4413      	add	r3, r2
 80266ba:	781a      	ldrb	r2, [r3, #0]
 80266bc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80266c0:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80266c2:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 80266c6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80266ca:	1ad3      	subs	r3, r2, r3
 80266cc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80266ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80266d2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80266d6:	441a      	add	r2, r3
 80266d8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80266dc:	3307      	adds	r3, #7
 80266de:	7812      	ldrb	r2, [r2, #0]
 80266e0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80266e2:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 80266e6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 80266ea:	4413      	add	r3, r2
 80266ec:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80266ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80266f2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80266f6:	441a      	add	r2, r3
 80266f8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80266fc:	3301      	adds	r3, #1
 80266fe:	7812      	ldrb	r2, [r2, #0]
 8026700:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8026702:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8026706:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 802670a:	1ad3      	subs	r3, r2, r3
 802670c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802670e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8026712:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8026716:	441a      	add	r2, r3
 8026718:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802671c:	3306      	adds	r3, #6
 802671e:	7812      	ldrb	r2, [r2, #0]
 8026720:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8026722:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8026726:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802672a:	4413      	add	r3, r2
 802672c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802672e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8026732:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8026736:	441a      	add	r2, r3
 8026738:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802673c:	3302      	adds	r3, #2
 802673e:	7812      	ldrb	r2, [r2, #0]
 8026740:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8026742:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8026746:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802674a:	1ad3      	subs	r3, r2, r3
 802674c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802674e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8026752:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8026756:	441a      	add	r2, r3
 8026758:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802675c:	3305      	adds	r3, #5
 802675e:	7812      	ldrb	r2, [r2, #0]
 8026760:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8026762:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8026766:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802676a:	4413      	add	r3, r2
 802676c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802676e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8026772:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8026776:	441a      	add	r2, r3
 8026778:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802677c:	3303      	adds	r3, #3
 802677e:	7812      	ldrb	r2, [r2, #0]
 8026780:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8026782:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8026786:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802678a:	1ad3      	subs	r3, r2, r3
 802678c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802678e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8026792:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8026796:	441a      	add	r2, r3
 8026798:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802679c:	3304      	adds	r3, #4
 802679e:	7812      	ldrb	r2, [r2, #0]
 80267a0:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 80267a2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80267a6:	3320      	adds	r3, #32
 80267a8:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 80267ac:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80267b0:	3301      	adds	r3, #1
 80267b2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80267b6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80267ba:	2b03      	cmp	r3, #3
 80267bc:	f77f ae5a 	ble.w	8026474 <jpeg_idct_8x4+0x1a0>
  }
}
 80267c0:	bf00      	nop
 80267c2:	bf00      	nop
 80267c4:	37dc      	adds	r7, #220	@ 0xdc
 80267c6:	46bd      	mov	sp, r7
 80267c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267cc:	4770      	bx	lr
 80267ce:	bf00      	nop
 80267d0:	ffffc4df 	.word	0xffffc4df
 80267d4:	ffffc13b 	.word	0xffffc13b
 80267d8:	fffff384 	.word	0xfffff384
 80267dc:	ffffe333 	.word	0xffffe333
 80267e0:	ffffadfd 	.word	0xffffadfd

080267e4 <jpeg_idct_6x3>:

GLOBAL(void)
jpeg_idct_6x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80267e4:	b480      	push	{r7}
 80267e6:	b0a7      	sub	sp, #156	@ 0x9c
 80267e8:	af00      	add	r7, sp, #0
 80267ea:	60f8      	str	r0, [r7, #12]
 80267ec:	60b9      	str	r1, [r7, #8]
 80267ee:	607a      	str	r2, [r7, #4]
 80267f0:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80267f2:	68fb      	ldr	r3, [r7, #12]
 80267f4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80267f8:	3380      	adds	r3, #128	@ 0x80
 80267fa:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  inptr = coef_block;
 80267fe:	687b      	ldr	r3, [r7, #4]
 8026800:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8026804:	68bb      	ldr	r3, [r7, #8]
 8026806:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026808:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  wsptr = workspace;
 802680c:	f107 0314 	add.w	r3, r7, #20
 8026810:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8026814:	2300      	movs	r3, #0
 8026816:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802681a:	e06a      	b.n	80268f2 <jpeg_idct_6x3+0x10e>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802681c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8026820:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026824:	461a      	mov	r2, r3
 8026826:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802682a:	681b      	ldr	r3, [r3, #0]
 802682c:	fb02 f303 	mul.w	r3, r2, r3
 8026830:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 8026832:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8026834:	035b      	lsls	r3, r3, #13
 8026836:	67fb      	str	r3, [r7, #124]	@ 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8026838:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802683a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802683e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8026840:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8026844:	3320      	adds	r3, #32
 8026846:	f9b3 3000 	ldrsh.w	r3, [r3]
 802684a:	461a      	mov	r2, r3
 802684c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8026850:	3340      	adds	r3, #64	@ 0x40
 8026852:	681b      	ldr	r3, [r3, #0]
 8026854:	fb02 f303 	mul.w	r3, r2, r3
 8026858:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802685a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802685c:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8026860:	fb02 f303 	mul.w	r3, r2, r3
 8026864:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp10 = tmp0 + tmp12;
 8026866:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8026868:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802686a:	4413      	add	r3, r2
 802686c:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp2 = tmp0 - tmp12 - tmp12;
 802686e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8026870:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8026872:	1ad2      	subs	r2, r2, r3
 8026874:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8026876:	1ad3      	subs	r3, r2, r3
 8026878:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802687a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802687e:	3310      	adds	r3, #16
 8026880:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026884:	461a      	mov	r2, r3
 8026886:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802688a:	3320      	adds	r3, #32
 802688c:	681b      	ldr	r3, [r3, #0]
 802688e:	fb02 f303 	mul.w	r3, r2, r3
 8026892:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 8026894:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8026896:	f242 7231 	movw	r2, #10033	@ 0x2731
 802689a:	fb02 f303 	mul.w	r3, r2, r3
 802689e:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 80268a0:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80268a2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80268a4:	4413      	add	r3, r2
 80268a6:	12da      	asrs	r2, r3, #11
 80268a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80268ac:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 80268ae:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80268b0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80268b2:	1ad2      	subs	r2, r2, r3
 80268b4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80268b8:	3330      	adds	r3, #48	@ 0x30
 80268ba:	12d2      	asrs	r2, r2, #11
 80268bc:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 80268be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80268c2:	3318      	adds	r3, #24
 80268c4:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 80268c6:	12d2      	asrs	r2, r2, #11
 80268c8:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 80268ca:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80268ce:	3301      	adds	r3, #1
 80268d0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 80268d4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80268d8:	3302      	adds	r3, #2
 80268da:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 80268de:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80268e2:	3304      	adds	r3, #4
 80268e4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80268e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80268ec:	3304      	adds	r3, #4
 80268ee:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 80268f2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80268f6:	2b05      	cmp	r3, #5
 80268f8:	dd90      	ble.n	802681c <jpeg_idct_6x3+0x38>
  }
  
  /* Pass 2: process 3 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 80268fa:	f107 0314 	add.w	r3, r7, #20
 80268fe:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8026902:	2300      	movs	r3, #0
 8026904:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8026908:	e0c3      	b.n	8026a92 <jpeg_idct_6x3+0x2ae>
    outptr = output_buf[ctr] + output_col;
 802690a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802690e:	009b      	lsls	r3, r3, #2
 8026910:	683a      	ldr	r2, [r7, #0]
 8026912:	4413      	add	r3, r2
 8026914:	681a      	ldr	r2, [r3, #0]
 8026916:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 802691a:	4413      	add	r3, r2
 802691c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8026920:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8026924:	681b      	ldr	r3, [r3, #0]
 8026926:	3310      	adds	r3, #16
 8026928:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 802692a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802692c:	035b      	lsls	r3, r3, #13
 802692e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = (INT32) wsptr[4];
 8026930:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8026934:	3310      	adds	r3, #16
 8026936:	681b      	ldr	r3, [r3, #0]
 8026938:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 802693a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802693c:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8026940:	fb02 f303 	mul.w	r3, r2, r3
 8026944:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp1 = tmp0 + tmp10;
 8026946:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8026948:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802694a:	4413      	add	r3, r2
 802694c:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp11 = tmp0 - tmp10 - tmp10;
 802694e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8026950:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8026952:	1ad2      	subs	r2, r2, r3
 8026954:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8026956:	1ad3      	subs	r3, r2, r3
 8026958:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp10 = (INT32) wsptr[2];
 802695a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802695e:	3308      	adds	r3, #8
 8026960:	681b      	ldr	r3, [r3, #0]
 8026962:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 8026964:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8026966:	f242 7231 	movw	r2, #10033	@ 0x2731
 802696a:	fb02 f303 	mul.w	r3, r2, r3
 802696e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp10 = tmp1 + tmp0;
 8026970:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8026972:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8026974:	4413      	add	r3, r2
 8026976:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp12 = tmp1 - tmp0;
 8026978:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 802697a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802697c:	1ad3      	subs	r3, r2, r3
 802697e:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8026980:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8026984:	3304      	adds	r3, #4
 8026986:	681b      	ldr	r3, [r3, #0]
 8026988:	667b      	str	r3, [r7, #100]	@ 0x64
    z2 = (INT32) wsptr[3];
 802698a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802698e:	330c      	adds	r3, #12
 8026990:	681b      	ldr	r3, [r3, #0]
 8026992:	663b      	str	r3, [r7, #96]	@ 0x60
    z3 = (INT32) wsptr[5];
 8026994:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8026998:	3314      	adds	r3, #20
 802699a:	681b      	ldr	r3, [r3, #0]
 802699c:	65fb      	str	r3, [r7, #92]	@ 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 802699e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80269a0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80269a2:	4413      	add	r3, r2
 80269a4:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 80269a8:	fb02 f303 	mul.w	r3, r2, r3
 80269ac:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 80269ae:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80269b0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80269b2:	4413      	add	r3, r2
 80269b4:	035b      	lsls	r3, r3, #13
 80269b6:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80269b8:	4413      	add	r3, r2
 80269ba:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 80269bc:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80269be:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80269c0:	1ad3      	subs	r3, r2, r3
 80269c2:	035b      	lsls	r3, r3, #13
 80269c4:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80269c6:	4413      	add	r3, r2
 80269c8:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 80269ca:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80269cc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80269ce:	1ad2      	subs	r2, r2, r3
 80269d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80269d2:	1ad3      	subs	r3, r2, r3
 80269d4:	035b      	lsls	r3, r3, #13
 80269d6:	673b      	str	r3, [r7, #112]	@ 0x70

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80269d8:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80269da:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80269dc:	4413      	add	r3, r2
 80269de:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80269e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80269e4:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 80269e8:	4413      	add	r3, r2
 80269ea:	781a      	ldrb	r2, [r3, #0]
 80269ec:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80269f0:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80269f2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80269f4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80269f6:	1ad3      	subs	r3, r2, r3
 80269f8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80269fa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80269fe:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8026a02:	441a      	add	r2, r3
 8026a04:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026a08:	3305      	adds	r3, #5
 8026a0a:	7812      	ldrb	r2, [r2, #0]
 8026a0c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8026a0e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8026a10:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8026a12:	4413      	add	r3, r2
 8026a14:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8026a16:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8026a1a:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8026a1e:	441a      	add	r2, r3
 8026a20:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026a24:	3301      	adds	r3, #1
 8026a26:	7812      	ldrb	r2, [r2, #0]
 8026a28:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8026a2a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8026a2c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8026a2e:	1ad3      	subs	r3, r2, r3
 8026a30:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8026a32:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8026a36:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8026a3a:	441a      	add	r2, r3
 8026a3c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026a40:	3304      	adds	r3, #4
 8026a42:	7812      	ldrb	r2, [r2, #0]
 8026a44:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8026a46:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8026a48:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8026a4a:	4413      	add	r3, r2
 8026a4c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8026a4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8026a52:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8026a56:	441a      	add	r2, r3
 8026a58:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026a5c:	3302      	adds	r3, #2
 8026a5e:	7812      	ldrb	r2, [r2, #0]
 8026a60:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8026a62:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8026a64:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8026a66:	1ad3      	subs	r3, r2, r3
 8026a68:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8026a6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8026a6e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8026a72:	441a      	add	r2, r3
 8026a74:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026a78:	3303      	adds	r3, #3
 8026a7a:	7812      	ldrb	r2, [r2, #0]
 8026a7c:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8026a7e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8026a82:	3318      	adds	r3, #24
 8026a84:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8026a88:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8026a8c:	3301      	adds	r3, #1
 8026a8e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8026a92:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8026a96:	2b02      	cmp	r3, #2
 8026a98:	f77f af37 	ble.w	802690a <jpeg_idct_6x3+0x126>
  }
}
 8026a9c:	bf00      	nop
 8026a9e:	bf00      	nop
 8026aa0:	379c      	adds	r7, #156	@ 0x9c
 8026aa2:	46bd      	mov	sp, r7
 8026aa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026aa8:	4770      	bx	lr
	...

08026aac <jpeg_idct_4x2>:

GLOBAL(void)
jpeg_idct_4x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8026aac:	b480      	push	{r7}
 8026aae:	b09b      	sub	sp, #108	@ 0x6c
 8026ab0:	af00      	add	r7, sp, #0
 8026ab2:	60f8      	str	r0, [r7, #12]
 8026ab4:	60b9      	str	r1, [r7, #8]
 8026ab6:	607a      	str	r2, [r7, #4]
 8026ab8:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8026aba:	68fb      	ldr	r3, [r7, #12]
 8026abc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8026ac0:	3380      	adds	r3, #128	@ 0x80
 8026ac2:	657b      	str	r3, [r7, #84]	@ 0x54
  INT32 workspace[4*2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8026ac4:	687b      	ldr	r3, [r7, #4]
 8026ac6:	667b      	str	r3, [r7, #100]	@ 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8026ac8:	68bb      	ldr	r3, [r7, #8]
 8026aca:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026acc:	663b      	str	r3, [r7, #96]	@ 0x60
  wsptr = workspace;
 8026ace:	f107 0314 	add.w	r3, r7, #20
 8026ad2:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8026ad4:	2300      	movs	r3, #0
 8026ad6:	65bb      	str	r3, [r7, #88]	@ 0x58
 8026ad8:	e02a      	b.n	8026b30 <jpeg_idct_4x2+0x84>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8026ada:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8026adc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026ae0:	461a      	mov	r2, r3
 8026ae2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8026ae4:	681b      	ldr	r3, [r3, #0]
 8026ae6:	fb02 f303 	mul.w	r3, r2, r3
 8026aea:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Odd part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8026aec:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8026aee:	3310      	adds	r3, #16
 8026af0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026af4:	461a      	mov	r2, r3
 8026af6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8026af8:	3320      	adds	r3, #32
 8026afa:	681b      	ldr	r3, [r3, #0]
 8026afc:	fb02 f303 	mul.w	r3, r2, r3
 8026b00:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Final output stage */

    wsptr[4*0] = tmp10 + tmp0;
 8026b02:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8026b04:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8026b06:	441a      	add	r2, r3
 8026b08:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b0a:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = tmp10 - tmp0;
 8026b0c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b0e:	3310      	adds	r3, #16
 8026b10:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 8026b12:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8026b14:	1a8a      	subs	r2, r1, r2
 8026b16:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8026b18:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026b1a:	3301      	adds	r3, #1
 8026b1c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8026b1e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8026b20:	3302      	adds	r3, #2
 8026b22:	667b      	str	r3, [r7, #100]	@ 0x64
 8026b24:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8026b26:	3304      	adds	r3, #4
 8026b28:	663b      	str	r3, [r7, #96]	@ 0x60
 8026b2a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b2c:	3304      	adds	r3, #4
 8026b2e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8026b30:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026b32:	2b03      	cmp	r3, #3
 8026b34:	ddd1      	ble.n	8026ada <jpeg_idct_4x2+0x2e>

  /* Pass 2: process 2 rows from work array, store into output array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  wsptr = workspace;
 8026b36:	f107 0314 	add.w	r3, r7, #20
 8026b3a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8026b3c:	2300      	movs	r3, #0
 8026b3e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8026b40:	e06a      	b.n	8026c18 <jpeg_idct_4x2+0x16c>
    outptr = output_buf[ctr] + output_col;
 8026b42:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026b44:	009b      	lsls	r3, r3, #2
 8026b46:	683a      	ldr	r2, [r7, #0]
 8026b48:	4413      	add	r3, r2
 8026b4a:	681a      	ldr	r2, [r3, #0]
 8026b4c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8026b4e:	4413      	add	r3, r2
 8026b50:	653b      	str	r3, [r7, #80]	@ 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = wsptr[0] + (ONE << 2);
 8026b52:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b54:	681b      	ldr	r3, [r3, #0]
 8026b56:	3304      	adds	r3, #4
 8026b58:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp2 = wsptr[2];
 8026b5a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b5c:	689b      	ldr	r3, [r3, #8]
 8026b5e:	64bb      	str	r3, [r7, #72]	@ 0x48

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 8026b60:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8026b62:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8026b64:	4413      	add	r3, r2
 8026b66:	035b      	lsls	r3, r3, #13
 8026b68:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8026b6a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8026b6c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8026b6e:	1ad3      	subs	r3, r2, r3
 8026b70:	035b      	lsls	r3, r3, #13
 8026b72:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = wsptr[1];
 8026b74:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b76:	685b      	ldr	r3, [r3, #4]
 8026b78:	63fb      	str	r3, [r7, #60]	@ 0x3c
    z3 = wsptr[3];
 8026b7a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026b7c:	68db      	ldr	r3, [r3, #12]
 8026b7e:	63bb      	str	r3, [r7, #56]	@ 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 8026b80:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8026b82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8026b84:	4413      	add	r3, r2
 8026b86:	f241 1251 	movw	r2, #4433	@ 0x1151
 8026b8a:	fb02 f303 	mul.w	r3, r2, r3
 8026b8e:	637b      	str	r3, [r7, #52]	@ 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8026b90:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8026b92:	f641 027e 	movw	r2, #6270	@ 0x187e
 8026b96:	fb02 f303 	mul.w	r3, r2, r3
 8026b9a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8026b9c:	4413      	add	r3, r2
 8026b9e:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 8026ba0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8026ba2:	4a22      	ldr	r2, [pc, #136]	@ (8026c2c <jpeg_idct_4x2+0x180>)
 8026ba4:	fb02 f303 	mul.w	r3, r2, r3
 8026ba8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8026baa:	4413      	add	r3, r2
 8026bac:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8026bae:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8026bb0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8026bb2:	4413      	add	r3, r2
 8026bb4:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8026bb6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8026bba:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8026bbc:	4413      	add	r3, r2
 8026bbe:	781a      	ldrb	r2, [r3, #0]
 8026bc0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8026bc2:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8026bc4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8026bc6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8026bc8:	1ad3      	subs	r3, r2, r3
 8026bca:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8026bcc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8026bd0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8026bd2:	441a      	add	r2, r3
 8026bd4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8026bd6:	3303      	adds	r3, #3
 8026bd8:	7812      	ldrb	r2, [r2, #0]
 8026bda:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8026bdc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8026bde:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8026be0:	4413      	add	r3, r2
 8026be2:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8026be4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8026be8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8026bea:	441a      	add	r2, r3
 8026bec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8026bee:	3301      	adds	r3, #1
 8026bf0:	7812      	ldrb	r2, [r2, #0]
 8026bf2:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8026bf4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8026bf6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8026bf8:	1ad3      	subs	r3, r2, r3
 8026bfa:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8026bfc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8026c00:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8026c02:	441a      	add	r2, r3
 8026c04:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8026c06:	3302      	adds	r3, #2
 8026c08:	7812      	ldrb	r2, [r2, #0]
 8026c0a:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 8026c0c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026c0e:	3310      	adds	r3, #16
 8026c10:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8026c12:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026c14:	3301      	adds	r3, #1
 8026c16:	65bb      	str	r3, [r7, #88]	@ 0x58
 8026c18:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026c1a:	2b01      	cmp	r3, #1
 8026c1c:	dd91      	ble.n	8026b42 <jpeg_idct_4x2+0x96>
  }
}
 8026c1e:	bf00      	nop
 8026c20:	bf00      	nop
 8026c22:	376c      	adds	r7, #108	@ 0x6c
 8026c24:	46bd      	mov	sp, r7
 8026c26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026c2a:	4770      	bx	lr
 8026c2c:	ffffc4df 	.word	0xffffc4df

08026c30 <jpeg_idct_2x1>:

GLOBAL(void)
jpeg_idct_2x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8026c30:	b480      	push	{r7}
 8026c32:	b08b      	sub	sp, #44	@ 0x2c
 8026c34:	af00      	add	r7, sp, #0
 8026c36:	60f8      	str	r0, [r7, #12]
 8026c38:	60b9      	str	r1, [r7, #8]
 8026c3a:	607a      	str	r2, [r7, #4]
 8026c3c:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8026c3e:	68fb      	ldr	r3, [r7, #12]
 8026c40:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8026c44:	3380      	adds	r3, #128	@ 0x80
 8026c46:	627b      	str	r3, [r7, #36]	@ 0x24

  /* Pass 1: empty. */

  /* Pass 2: process 1 row from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8026c48:	68bb      	ldr	r3, [r7, #8]
 8026c4a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026c4c:	623b      	str	r3, [r7, #32]
  outptr = output_buf[0] + output_col;
 8026c4e:	683b      	ldr	r3, [r7, #0]
 8026c50:	681a      	ldr	r2, [r3, #0]
 8026c52:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8026c54:	4413      	add	r3, r2
 8026c56:	61fb      	str	r3, [r7, #28]

  /* Even part */

  tmp10 = DEQUANTIZE(coef_block[0], quantptr[0]);
 8026c58:	687b      	ldr	r3, [r7, #4]
 8026c5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026c5e:	461a      	mov	r2, r3
 8026c60:	6a3b      	ldr	r3, [r7, #32]
 8026c62:	681b      	ldr	r3, [r3, #0]
 8026c64:	fb02 f303 	mul.w	r3, r2, r3
 8026c68:	61bb      	str	r3, [r7, #24]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 8026c6a:	69bb      	ldr	r3, [r7, #24]
 8026c6c:	3304      	adds	r3, #4
 8026c6e:	61bb      	str	r3, [r7, #24]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[1], quantptr[1]);
 8026c70:	687b      	ldr	r3, [r7, #4]
 8026c72:	3302      	adds	r3, #2
 8026c74:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026c78:	461a      	mov	r2, r3
 8026c7a:	6a3b      	ldr	r3, [r7, #32]
 8026c7c:	3304      	adds	r3, #4
 8026c7e:	681b      	ldr	r3, [r3, #0]
 8026c80:	fb02 f303 	mul.w	r3, r2, r3
 8026c84:	617b      	str	r3, [r7, #20]

  /* Final output stage */

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3) & RANGE_MASK];
 8026c86:	69ba      	ldr	r2, [r7, #24]
 8026c88:	697b      	ldr	r3, [r7, #20]
 8026c8a:	4413      	add	r3, r2
 8026c8c:	10db      	asrs	r3, r3, #3
 8026c8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8026c92:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8026c94:	4413      	add	r3, r2
 8026c96:	781a      	ldrb	r2, [r3, #0]
 8026c98:	69fb      	ldr	r3, [r7, #28]
 8026c9a:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3) & RANGE_MASK];
 8026c9c:	69ba      	ldr	r2, [r7, #24]
 8026c9e:	697b      	ldr	r3, [r7, #20]
 8026ca0:	1ad3      	subs	r3, r2, r3
 8026ca2:	10db      	asrs	r3, r3, #3
 8026ca4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8026ca8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8026caa:	441a      	add	r2, r3
 8026cac:	69fb      	ldr	r3, [r7, #28]
 8026cae:	3301      	adds	r3, #1
 8026cb0:	7812      	ldrb	r2, [r2, #0]
 8026cb2:	701a      	strb	r2, [r3, #0]
}
 8026cb4:	bf00      	nop
 8026cb6:	372c      	adds	r7, #44	@ 0x2c
 8026cb8:	46bd      	mov	sp, r7
 8026cba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026cbe:	4770      	bx	lr

08026cc0 <jpeg_idct_8x16>:

GLOBAL(void)
jpeg_idct_8x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8026cc0:	b490      	push	{r4, r7}
 8026cc2:	f5ad 7d1e 	sub.w	sp, sp, #632	@ 0x278
 8026cc6:	af00      	add	r7, sp, #0
 8026cc8:	f507 741e 	add.w	r4, r7, #632	@ 0x278
 8026ccc:	f5a4 741b 	sub.w	r4, r4, #620	@ 0x26c
 8026cd0:	6020      	str	r0, [r4, #0]
 8026cd2:	f507 701e 	add.w	r0, r7, #632	@ 0x278
 8026cd6:	f5a0 701c 	sub.w	r0, r0, #624	@ 0x270
 8026cda:	6001      	str	r1, [r0, #0]
 8026cdc:	f507 711e 	add.w	r1, r7, #632	@ 0x278
 8026ce0:	f5a1 711d 	sub.w	r1, r1, #628	@ 0x274
 8026ce4:	600a      	str	r2, [r1, #0]
 8026ce6:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 8026cea:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 8026cee:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8026cf0:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 8026cf4:	f5a3 731b 	sub.w	r3, r3, #620	@ 0x26c
 8026cf8:	681b      	ldr	r3, [r3, #0]
 8026cfa:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8026cfe:	3380      	adds	r3, #128	@ 0x80
 8026d00:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  inptr = coef_block;
 8026d04:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 8026d08:	f5a3 731d 	sub.w	r3, r3, #628	@ 0x274
 8026d0c:	681b      	ldr	r3, [r3, #0]
 8026d0e:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8026d12:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 8026d16:	f5a3 731c 	sub.w	r3, r3, #624	@ 0x270
 8026d1a:	681b      	ldr	r3, [r3, #0]
 8026d1c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026d1e:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
  wsptr = workspace;
 8026d22:	f107 0310 	add.w	r3, r7, #16
 8026d26:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8026d2a:	2300      	movs	r3, #0
 8026d2c:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8026d30:	e30a      	b.n	8027348 <jpeg_idct_8x16+0x688>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8026d32:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026d36:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026d3a:	461a      	mov	r2, r3
 8026d3c:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026d40:	681b      	ldr	r3, [r3, #0]
 8026d42:	fb02 f303 	mul.w	r3, r2, r3
 8026d46:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp0 <<= CONST_BITS;
 8026d4a:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026d4e:	035b      	lsls	r3, r3, #13
 8026d50:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8026d54:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026d58:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8026d5c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8026d60:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026d64:	3340      	adds	r3, #64	@ 0x40
 8026d66:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026d6a:	461a      	mov	r2, r3
 8026d6c:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026d70:	3380      	adds	r3, #128	@ 0x80
 8026d72:	681b      	ldr	r3, [r3, #0]
 8026d74:	fb02 f303 	mul.w	r3, r2, r3
 8026d78:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8026d7c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026d80:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8026d84:	fb02 f303 	mul.w	r3, r2, r3
 8026d88:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8026d8c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026d90:	f241 1251 	movw	r2, #4433	@ 0x1151
 8026d94:	fb02 f303 	mul.w	r3, r2, r3
 8026d98:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 8026d9c:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8026da0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8026da4:	4413      	add	r3, r2
 8026da6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 = tmp0 - tmp1;
 8026daa:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8026dae:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8026db2:	1ad3      	subs	r3, r2, r3
 8026db4:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = tmp0 + tmp2;
 8026db8:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8026dbc:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8026dc0:	4413      	add	r3, r2
 8026dc2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp13 = tmp0 - tmp2;
 8026dc6:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8026dca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8026dce:	1ad3      	subs	r3, r2, r3
 8026dd0:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8026dd4:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026dd8:	3320      	adds	r3, #32
 8026dda:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026dde:	461a      	mov	r2, r3
 8026de0:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026de4:	3340      	adds	r3, #64	@ 0x40
 8026de6:	681b      	ldr	r3, [r3, #0]
 8026de8:	fb02 f303 	mul.w	r3, r2, r3
 8026dec:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8026df0:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026df4:	3360      	adds	r3, #96	@ 0x60
 8026df6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026dfa:	461a      	mov	r2, r3
 8026dfc:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026e00:	33c0      	adds	r3, #192	@ 0xc0
 8026e02:	681b      	ldr	r3, [r3, #0]
 8026e04:	fb02 f303 	mul.w	r3, r2, r3
 8026e08:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = z1 - z2;
 8026e0c:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026e10:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026e14:	1ad3      	subs	r3, r2, r3
 8026e16:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8026e1a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026e1e:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 8026e22:	fb02 f303 	mul.w	r3, r2, r3
 8026e26:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8026e2a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026e2e:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8026e32:	fb02 f303 	mul.w	r3, r2, r3
 8026e36:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8026e3a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026e3e:	f245 2203 	movw	r2, #20995	@ 0x5203
 8026e42:	fb02 f303 	mul.w	r3, r2, r3
 8026e46:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026e4a:	4413      	add	r3, r2
 8026e4c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8026e50:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026e54:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8026e58:	fb02 f303 	mul.w	r3, r2, r3
 8026e5c:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8026e60:	4413      	add	r3, r2
 8026e62:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8026e66:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026e6a:	4af4      	ldr	r2, [pc, #976]	@ (802723c <jpeg_idct_8x16+0x57c>)
 8026e6c:	fb02 f303 	mul.w	r3, r2, r3
 8026e70:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026e74:	4413      	add	r3, r2
 8026e76:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8026e7a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026e7e:	4af0      	ldr	r2, [pc, #960]	@ (8027240 <jpeg_idct_8x16+0x580>)
 8026e80:	fb02 f303 	mul.w	r3, r2, r3
 8026e84:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8026e88:	4413      	add	r3, r2
 8026e8a:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c

    tmp20 = tmp10 + tmp0;
 8026e8e:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8026e92:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026e96:	4413      	add	r3, r2
 8026e98:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 8026e9c:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8026ea0:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026ea4:	1ad3      	subs	r3, r2, r3
 8026ea6:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 8026eaa:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8026eae:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8026eb2:	4413      	add	r3, r2
 8026eb4:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 8026eb8:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8026ebc:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8026ec0:	1ad3      	subs	r3, r2, r3
 8026ec2:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 8026ec6:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8026eca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8026ece:	4413      	add	r3, r2
 8026ed0:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 8026ed4:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8026ed8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8026edc:	1ad3      	subs	r3, r2, r3
 8026ede:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 8026ee2:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8026ee6:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8026eea:	4413      	add	r3, r2
 8026eec:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 8026ef0:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8026ef4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8026ef8:	1ad3      	subs	r3, r2, r3
 8026efa:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8026efe:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026f02:	3310      	adds	r3, #16
 8026f04:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026f08:	461a      	mov	r2, r3
 8026f0a:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026f0e:	3320      	adds	r3, #32
 8026f10:	681b      	ldr	r3, [r3, #0]
 8026f12:	fb02 f303 	mul.w	r3, r2, r3
 8026f16:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8026f1a:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026f1e:	3330      	adds	r3, #48	@ 0x30
 8026f20:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026f24:	461a      	mov	r2, r3
 8026f26:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026f2a:	3360      	adds	r3, #96	@ 0x60
 8026f2c:	681b      	ldr	r3, [r3, #0]
 8026f2e:	fb02 f303 	mul.w	r3, r2, r3
 8026f32:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8026f36:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026f3a:	3350      	adds	r3, #80	@ 0x50
 8026f3c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026f40:	461a      	mov	r2, r3
 8026f42:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026f46:	33a0      	adds	r3, #160	@ 0xa0
 8026f48:	681b      	ldr	r3, [r3, #0]
 8026f4a:	fb02 f303 	mul.w	r3, r2, r3
 8026f4e:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8026f52:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8026f56:	3370      	adds	r3, #112	@ 0x70
 8026f58:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026f5c:	461a      	mov	r2, r3
 8026f5e:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8026f62:	33e0      	adds	r3, #224	@ 0xe0
 8026f64:	681b      	ldr	r3, [r3, #0]
 8026f66:	fb02 f303 	mul.w	r3, r2, r3
 8026f6a:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp11 = z1 + z3;
 8026f6e:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026f72:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026f76:	4413      	add	r3, r2
 8026f78:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8026f7c:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026f80:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026f84:	4413      	add	r3, r2
 8026f86:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 8026f8a:	fb02 f303 	mul.w	r3, r2, r3
 8026f8e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8026f92:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026f96:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 8026f9a:	fb02 f303 	mul.w	r3, r2, r3
 8026f9e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8026fa2:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026fa6:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8026faa:	4413      	add	r3, r2
 8026fac:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 8026fb0:	fb02 f303 	mul.w	r3, r2, r3
 8026fb4:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8026fb8:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026fbc:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8026fc0:	1ad3      	subs	r3, r2, r3
 8026fc2:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 8026fc6:	fb02 f303 	mul.w	r3, r2, r3
 8026fca:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8026fce:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026fd2:	f241 5255 	movw	r2, #5461	@ 0x1555
 8026fd6:	fb02 f303 	mul.w	r3, r2, r3
 8026fda:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8026fde:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026fe2:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026fe6:	1ad3      	subs	r3, r2, r3
 8026fe8:	f640 5223 	movw	r2, #3363	@ 0xd23
 8026fec:	fb02 f303 	mul.w	r3, r2, r3
 8026ff0:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp0  = tmp1 + tmp2 + tmp3 -
 8026ff4:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8026ff8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8026ffc:	441a      	add	r2, r3
 8026ffe:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8027002:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8027004:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8027008:	498e      	ldr	r1, [pc, #568]	@ (8027244 <jpeg_idct_8x16+0x584>)
 802700a:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 802700e:	4413      	add	r3, r2
 8027010:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp13 = tmp10 + tmp11 + tmp12 -
 8027014:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8027018:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802701c:	441a      	add	r2, r3
 802701e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8027022:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8027024:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8027028:	4987      	ldr	r1, [pc, #540]	@ (8027248 <jpeg_idct_8x16+0x588>)
 802702a:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 802702e:	4413      	add	r3, r2
 8027030:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8027034:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8027038:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802703c:	4413      	add	r3, r2
 802703e:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 8027042:	fb02 f303 	mul.w	r3, r2, r3
 8027046:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 802704a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802704e:	f240 224d 	movw	r2, #589	@ 0x24d
 8027052:	fb03 f202 	mul.w	r2, r3, r2
 8027056:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802705a:	4413      	add	r3, r2
 802705c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8027060:	4413      	add	r3, r2
 8027062:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8027066:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802706a:	4a78      	ldr	r2, [pc, #480]	@ (802724c <jpeg_idct_8x16+0x58c>)
 802706c:	fb03 f202 	mul.w	r2, r3, r2
 8027070:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8027074:	4413      	add	r3, r2
 8027076:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 802707a:	4413      	add	r3, r2
 802707c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8027080:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8027084:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027088:	1ad3      	subs	r3, r2, r3
 802708a:	f642 5209 	movw	r2, #11529	@ 0x2d09
 802708e:	fb02 f303 	mul.w	r3, r2, r3
 8027092:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8027096:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802709a:	4a6d      	ldr	r2, [pc, #436]	@ (8027250 <jpeg_idct_8x16+0x590>)
 802709c:	fb03 f202 	mul.w	r2, r3, r2
 80270a0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80270a4:	4413      	add	r3, r2
 80270a6:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80270aa:	4413      	add	r3, r2
 80270ac:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 80270b0:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80270b4:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 80270b8:	fb03 f202 	mul.w	r2, r3, r2
 80270bc:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80270c0:	4413      	add	r3, r2
 80270c2:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80270c6:	4413      	add	r3, r2
 80270c8:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z2    += z4;
 80270cc:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80270d0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80270d4:	4413      	add	r3, r2
 80270d6:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 80270da:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80270de:	4a5d      	ldr	r2, [pc, #372]	@ (8027254 <jpeg_idct_8x16+0x594>)
 80270e0:	fb02 f303 	mul.w	r3, r2, r3
 80270e4:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1  += z1;
 80270e8:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80270ec:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80270f0:	4413      	add	r3, r2
 80270f2:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 80270f6:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80270fa:	f242 2218 	movw	r2, #8728	@ 0x2218
 80270fe:	fb03 f202 	mul.w	r2, r3, r2
 8027102:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8027106:	4413      	add	r3, r2
 8027108:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 802710c:	4413      	add	r3, r2
 802710e:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8027112:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027116:	4a50      	ldr	r2, [pc, #320]	@ (8027258 <jpeg_idct_8x16+0x598>)
 8027118:	fb02 f303 	mul.w	r3, r2, r3
 802711c:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8027120:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8027124:	f246 4285 	movw	r2, #25733	@ 0x6485
 8027128:	fb03 f202 	mul.w	r2, r3, r2
 802712c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027130:	4413      	add	r3, r2
 8027132:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8027136:	4413      	add	r3, r2
 8027138:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp12 += z2;
 802713c:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8027140:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027144:	4413      	add	r3, r2
 8027146:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 802714a:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 802714e:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8027152:	4413      	add	r3, r2
 8027154:	4a41      	ldr	r2, [pc, #260]	@ (802725c <jpeg_idct_8x16+0x59c>)
 8027156:	fb02 f303 	mul.w	r3, r2, r3
 802715a:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp2  += z2;
 802715e:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8027162:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027166:	4413      	add	r3, r2
 8027168:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 802716c:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8027170:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027174:	4413      	add	r3, r2
 8027176:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 802717a:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802717e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8027182:	1ad3      	subs	r3, r2, r3
 8027184:	f640 5223 	movw	r2, #3363	@ 0xd23
 8027188:	fb02 f303 	mul.w	r3, r2, r3
 802718c:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp10 += z2;
 8027190:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8027194:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8027198:	4413      	add	r3, r2
 802719a:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 += z2;
 802719e:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80271a2:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80271a6:	4413      	add	r3, r2
 80271a8:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 80271ac:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 80271b0:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80271b4:	4413      	add	r3, r2
 80271b6:	12da      	asrs	r2, r3, #11
 80271b8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80271bc:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 80271be:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 80271c2:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80271c6:	1ad2      	subs	r2, r2, r3
 80271c8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80271cc:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
 80271d0:	12d2      	asrs	r2, r2, #11
 80271d2:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 80271d4:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80271d8:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80271dc:	441a      	add	r2, r3
 80271de:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80271e2:	3320      	adds	r3, #32
 80271e4:	12d2      	asrs	r2, r2, #11
 80271e6:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 80271e8:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80271ec:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80271f0:	1ad2      	subs	r2, r2, r3
 80271f2:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80271f6:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80271fa:	12d2      	asrs	r2, r2, #11
 80271fc:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 80271fe:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8027202:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027206:	441a      	add	r2, r3
 8027208:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802720c:	3340      	adds	r3, #64	@ 0x40
 802720e:	12d2      	asrs	r2, r2, #11
 8027210:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 8027212:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8027216:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802721a:	1ad2      	subs	r2, r2, r3
 802721c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027220:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8027224:	12d2      	asrs	r2, r2, #11
 8027226:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 8027228:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802722c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8027230:	441a      	add	r2, r3
 8027232:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027236:	3360      	adds	r3, #96	@ 0x60
 8027238:	12d2      	asrs	r2, r2, #11
 802723a:	e011      	b.n	8027260 <jpeg_idct_8x16+0x5a0>
 802723c:	ffffecc2 	.word	0xffffecc2
 8027240:	ffffefb0 	.word	0xffffefb0
 8027244:	ffffb6d6 	.word	0xffffb6d6
 8027248:	ffffc542 	.word	0xffffc542
 802724c:	ffffdbfa 	.word	0xffffdbfa
 8027250:	ffffe77a 	.word	0xffffe77a
 8027254:	ffffeaab 	.word	0xffffeaab
 8027258:	ffffd817 	.word	0xffffd817
 802725c:	ffffd4b2 	.word	0xffffd4b2
 8027260:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 8027262:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8027266:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802726a:	1ad2      	subs	r2, r2, r3
 802726c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027270:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8027274:	12d2      	asrs	r2, r2, #11
 8027276:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 8027278:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 802727c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8027280:	441a      	add	r2, r3
 8027282:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027286:	3380      	adds	r3, #128	@ 0x80
 8027288:	12d2      	asrs	r2, r2, #11
 802728a:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 802728c:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8027290:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8027294:	1ad2      	subs	r2, r2, r3
 8027296:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802729a:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 802729e:	12d2      	asrs	r2, r2, #11
 80272a0:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 80272a2:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80272a6:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80272aa:	441a      	add	r2, r3
 80272ac:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80272b0:	33a0      	adds	r3, #160	@ 0xa0
 80272b2:	12d2      	asrs	r2, r2, #11
 80272b4:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 80272b6:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80272ba:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80272be:	1ad2      	subs	r2, r2, r3
 80272c0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80272c4:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 80272c8:	12d2      	asrs	r2, r2, #11
 80272ca:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 80272cc:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80272d0:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80272d4:	441a      	add	r2, r3
 80272d6:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80272da:	33c0      	adds	r3, #192	@ 0xc0
 80272dc:	12d2      	asrs	r2, r2, #11
 80272de:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 80272e0:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80272e4:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80272e8:	1ad2      	subs	r2, r2, r3
 80272ea:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80272ee:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80272f2:	12d2      	asrs	r2, r2, #11
 80272f4:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 80272f6:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80272fa:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80272fe:	441a      	add	r2, r3
 8027300:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027304:	33e0      	adds	r3, #224	@ 0xe0
 8027306:	12d2      	asrs	r2, r2, #11
 8027308:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 802730a:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 802730e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8027312:	1ad2      	subs	r2, r2, r3
 8027314:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027318:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 802731c:	12d2      	asrs	r2, r2, #11
 802731e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8027320:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8027324:	3301      	adds	r3, #1
 8027326:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 802732a:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 802732e:	3302      	adds	r3, #2
 8027330:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
 8027334:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8027338:	3304      	adds	r3, #4
 802733a:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
 802733e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027342:	3304      	adds	r3, #4
 8027344:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
 8027348:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 802734c:	2b07      	cmp	r3, #7
 802734e:	f77f acf0 	ble.w	8026d32 <jpeg_idct_8x16+0x72>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 8027352:	f107 0310 	add.w	r3, r7, #16
 8027356:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 802735a:	2300      	movs	r3, #0
 802735c:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8027360:	e1a4      	b.n	80276ac <jpeg_idct_8x16+0x9ec>
    outptr = output_buf[ctr] + output_col;
 8027362:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8027366:	009b      	lsls	r3, r3, #2
 8027368:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 802736c:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 8027370:	6812      	ldr	r2, [r2, #0]
 8027372:	4413      	add	r3, r2
 8027374:	681a      	ldr	r2, [r3, #0]
 8027376:	f8d7 3280 	ldr.w	r3, [r7, #640]	@ 0x280
 802737a:	4413      	add	r3, r2
 802737c:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 8027380:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027384:	3308      	adds	r3, #8
 8027386:	681b      	ldr	r3, [r3, #0]
 8027388:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = (INT32) wsptr[6];
 802738c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027390:	3318      	adds	r3, #24
 8027392:	681b      	ldr	r3, [r3, #0]
 8027394:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8027398:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 802739c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80273a0:	4413      	add	r3, r2
 80273a2:	f241 1251 	movw	r2, #4433	@ 0x1151
 80273a6:	fb02 f303 	mul.w	r3, r2, r3
 80273aa:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 80273ae:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80273b2:	f641 027e 	movw	r2, #6270	@ 0x187e
 80273b6:	fb02 f303 	mul.w	r3, r2, r3
 80273ba:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80273be:	4413      	add	r3, r2
 80273c0:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 80273c4:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80273c8:	4abe      	ldr	r2, [pc, #760]	@ (80276c4 <jpeg_idct_8x16+0xa04>)
 80273ca:	fb02 f303 	mul.w	r3, r2, r3
 80273ce:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80273d2:	4413      	add	r3, r2
 80273d4:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80273d8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80273dc:	681b      	ldr	r3, [r3, #0]
 80273de:	3310      	adds	r3, #16
 80273e0:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = (INT32) wsptr[4];
 80273e4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80273e8:	3310      	adds	r3, #16
 80273ea:	681b      	ldr	r3, [r3, #0]
 80273ec:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    
    tmp0 = (z2 + z3) << CONST_BITS;
 80273f0:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80273f4:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80273f8:	4413      	add	r3, r2
 80273fa:	035b      	lsls	r3, r3, #13
 80273fc:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = (z2 - z3) << CONST_BITS;
 8027400:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8027404:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8027408:	1ad3      	subs	r3, r2, r3
 802740a:	035b      	lsls	r3, r3, #13
 802740c:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    
    tmp10 = tmp0 + tmp2;
 8027410:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8027414:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027418:	4413      	add	r3, r2
 802741a:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp13 = tmp0 - tmp2;
 802741e:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8027422:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027426:	1ad3      	subs	r3, r2, r3
 8027428:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp11 = tmp1 + tmp3;
 802742c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8027430:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8027434:	4413      	add	r3, r2
 8027436:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = tmp1 - tmp3;
 802743a:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802743e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8027442:	1ad3      	subs	r3, r2, r3
 8027444:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = (INT32) wsptr[7];
 8027448:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802744c:	331c      	adds	r3, #28
 802744e:	681b      	ldr	r3, [r3, #0]
 8027450:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = (INT32) wsptr[5];
 8027454:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027458:	3314      	adds	r3, #20
 802745a:	681b      	ldr	r3, [r3, #0]
 802745c:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = (INT32) wsptr[3];
 8027460:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027464:	330c      	adds	r3, #12
 8027466:	681b      	ldr	r3, [r3, #0]
 8027468:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = (INT32) wsptr[1];
 802746c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8027470:	3304      	adds	r3, #4
 8027472:	681b      	ldr	r3, [r3, #0]
 8027474:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    
    z2 = tmp0 + tmp2;
 8027478:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 802747c:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027480:	4413      	add	r3, r2
 8027482:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = tmp1 + tmp3;
 8027486:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802748a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802748e:	4413      	add	r3, r2
 8027490:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8027494:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8027498:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802749c:	4413      	add	r3, r2
 802749e:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 80274a2:	fb02 f303 	mul.w	r3, r2, r3
 80274a6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80274aa:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80274ae:	4a86      	ldr	r2, [pc, #536]	@ (80276c8 <jpeg_idct_8x16+0xa08>)
 80274b0:	fb02 f303 	mul.w	r3, r2, r3
 80274b4:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 80274b8:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80274bc:	4a83      	ldr	r2, [pc, #524]	@ (80276cc <jpeg_idct_8x16+0xa0c>)
 80274be:	fb02 f303 	mul.w	r3, r2, r3
 80274c2:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 += z1;
 80274c6:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80274ca:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80274ce:	4413      	add	r3, r2
 80274d0:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 += z1;
 80274d4:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80274d8:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80274dc:	4413      	add	r3, r2
 80274de:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80274e2:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80274e6:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80274ea:	4413      	add	r3, r2
 80274ec:	4a78      	ldr	r2, [pc, #480]	@ (80276d0 <jpeg_idct_8x16+0xa10>)
 80274ee:	fb02 f303 	mul.w	r3, r2, r3
 80274f2:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 80274f6:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80274fa:	f640 128e 	movw	r2, #2446	@ 0x98e
 80274fe:	fb02 f303 	mul.w	r3, r2, r3
 8027502:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8027506:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802750a:	f243 020b 	movw	r2, #12299	@ 0x300b
 802750e:	fb02 f303 	mul.w	r3, r2, r3
 8027512:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp0 += z1 + z2;
 8027516:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802751a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802751e:	4413      	add	r3, r2
 8027520:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8027524:	4413      	add	r3, r2
 8027526:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp3 += z1 + z3;
 802752a:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802752e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8027532:	4413      	add	r3, r2
 8027534:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8027538:	4413      	add	r3, r2
 802753a:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 802753e:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8027542:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027546:	4413      	add	r3, r2
 8027548:	4a62      	ldr	r2, [pc, #392]	@ (80276d4 <jpeg_idct_8x16+0xa14>)
 802754a:	fb02 f303 	mul.w	r3, r2, r3
 802754e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8027552:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8027556:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 802755a:	fb02 f303 	mul.w	r3, r2, r3
 802755e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8027562:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027566:	f246 2254 	movw	r2, #25172	@ 0x6254
 802756a:	fb02 f303 	mul.w	r3, r2, r3
 802756e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp1 += z1 + z3;
 8027572:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8027576:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802757a:	4413      	add	r3, r2
 802757c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8027580:	4413      	add	r3, r2
 8027582:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 += z1 + z2;
 8027586:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802758a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802758e:	4413      	add	r3, r2
 8027590:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8027594:	4413      	add	r3, r2
 8027596:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 802759a:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 802759e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80275a2:	4413      	add	r3, r2
 80275a4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80275a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80275aa:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80275ae:	4413      	add	r3, r2
 80275b0:	781a      	ldrb	r2, [r3, #0]
 80275b2:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80275b6:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80275b8:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80275bc:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80275c0:	1ad3      	subs	r3, r2, r3
 80275c2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80275c4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80275c8:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80275cc:	441a      	add	r2, r3
 80275ce:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80275d2:	3307      	adds	r3, #7
 80275d4:	7812      	ldrb	r2, [r2, #0]
 80275d6:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80275d8:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80275dc:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80275e0:	4413      	add	r3, r2
 80275e2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80275e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80275e8:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80275ec:	441a      	add	r2, r3
 80275ee:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80275f2:	3301      	adds	r3, #1
 80275f4:	7812      	ldrb	r2, [r2, #0]
 80275f6:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 80275f8:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80275fc:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8027600:	1ad3      	subs	r3, r2, r3
 8027602:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027604:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8027608:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802760c:	441a      	add	r2, r3
 802760e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8027612:	3306      	adds	r3, #6
 8027614:	7812      	ldrb	r2, [r2, #0]
 8027616:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8027618:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802761c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8027620:	4413      	add	r3, r2
 8027622:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027624:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8027628:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802762c:	441a      	add	r2, r3
 802762e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8027632:	3302      	adds	r3, #2
 8027634:	7812      	ldrb	r2, [r2, #0]
 8027636:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8027638:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802763c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8027640:	1ad3      	subs	r3, r2, r3
 8027642:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027644:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8027648:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802764c:	441a      	add	r2, r3
 802764e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8027652:	3305      	adds	r3, #5
 8027654:	7812      	ldrb	r2, [r2, #0]
 8027656:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8027658:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 802765c:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8027660:	4413      	add	r3, r2
 8027662:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027664:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8027668:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802766c:	441a      	add	r2, r3
 802766e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8027672:	3303      	adds	r3, #3
 8027674:	7812      	ldrb	r2, [r2, #0]
 8027676:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8027678:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 802767c:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8027680:	1ad3      	subs	r3, r2, r3
 8027682:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027684:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8027688:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802768c:	441a      	add	r2, r3
 802768e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8027692:	3304      	adds	r3, #4
 8027694:	7812      	ldrb	r2, [r2, #0]
 8027696:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 8027698:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802769c:	3320      	adds	r3, #32
 802769e:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 80276a2:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 80276a6:	3301      	adds	r3, #1
 80276a8:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 80276ac:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 80276b0:	2b0f      	cmp	r3, #15
 80276b2:	f77f ae56 	ble.w	8027362 <jpeg_idct_8x16+0x6a2>
  }
}
 80276b6:	bf00      	nop
 80276b8:	bf00      	nop
 80276ba:	f507 771e 	add.w	r7, r7, #632	@ 0x278
 80276be:	46bd      	mov	sp, r7
 80276c0:	bc90      	pop	{r4, r7}
 80276c2:	4770      	bx	lr
 80276c4:	ffffc4df 	.word	0xffffc4df
 80276c8:	ffffc13b 	.word	0xffffc13b
 80276cc:	fffff384 	.word	0xfffff384
 80276d0:	ffffe333 	.word	0xffffe333
 80276d4:	ffffadfd 	.word	0xffffadfd

080276d8 <jpeg_idct_7x14>:

GLOBAL(void)
jpeg_idct_7x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80276d8:	b490      	push	{r4, r7}
 80276da:	b0fe      	sub	sp, #504	@ 0x1f8
 80276dc:	af00      	add	r7, sp, #0
 80276de:	f507 74fc 	add.w	r4, r7, #504	@ 0x1f8
 80276e2:	f5a4 74f6 	sub.w	r4, r4, #492	@ 0x1ec
 80276e6:	6020      	str	r0, [r4, #0]
 80276e8:	f507 70fc 	add.w	r0, r7, #504	@ 0x1f8
 80276ec:	f5a0 70f8 	sub.w	r0, r0, #496	@ 0x1f0
 80276f0:	6001      	str	r1, [r0, #0]
 80276f2:	f507 71fc 	add.w	r1, r7, #504	@ 0x1f8
 80276f6:	f5a1 71fa 	sub.w	r1, r1, #500	@ 0x1f4
 80276fa:	600a      	str	r2, [r1, #0]
 80276fc:	f507 72fc 	add.w	r2, r7, #504	@ 0x1f8
 8027700:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 8027704:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8027706:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 802770a:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 802770e:	681b      	ldr	r3, [r3, #0]
 8027710:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8027714:	3380      	adds	r3, #128	@ 0x80
 8027716:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  inptr = coef_block;
 802771a:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 802771e:	f5a3 73fa 	sub.w	r3, r3, #500	@ 0x1f4
 8027722:	681b      	ldr	r3, [r3, #0]
 8027724:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8027728:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 802772c:	f5a3 73f8 	sub.w	r3, r3, #496	@ 0x1f0
 8027730:	681b      	ldr	r3, [r3, #0]
 8027732:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8027734:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
  wsptr = workspace;
 8027738:	f107 0310 	add.w	r3, r7, #16
 802773c:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8027740:	2300      	movs	r3, #0
 8027742:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8027746:	e267      	b.n	8027c18 <jpeg_idct_7x14+0x540>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8027748:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802774c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027750:	461a      	mov	r2, r3
 8027752:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027756:	681b      	ldr	r3, [r3, #0]
 8027758:	fb02 f303 	mul.w	r3, r2, r3
 802775c:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z1 <<= CONST_BITS;
 8027760:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8027764:	035b      	lsls	r3, r3, #13
 8027766:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 802776a:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 802776e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8027772:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8027776:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802777a:	3340      	adds	r3, #64	@ 0x40
 802777c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027780:	461a      	mov	r2, r3
 8027782:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027786:	3380      	adds	r3, #128	@ 0x80
 8027788:	681b      	ldr	r3, [r3, #0]
 802778a:	fb02 f303 	mul.w	r3, r2, r3
 802778e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 8027792:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027796:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 802779a:	fb02 f303 	mul.w	r3, r2, r3
 802779e:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 80277a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80277a6:	f640 2212 	movw	r2, #2578	@ 0xa12
 80277aa:	fb02 f303 	mul.w	r3, r2, r3
 80277ae:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80277b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80277b6:	f641 4237 	movw	r2, #7223	@ 0x1c37
 80277ba:	fb02 f303 	mul.w	r3, r2, r3
 80277be:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp10 = z1 + z2;
 80277c2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 80277c6:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 80277ca:	4413      	add	r3, r2
 80277cc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp11 = z1 + z3;
 80277d0:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 80277d4:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80277d8:	4413      	add	r3, r2
 80277da:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = z1 - z4;
 80277de:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 80277e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80277e6:	1ad3      	subs	r3, r2, r3
 80277e8:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 80277ec:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80277f0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80277f4:	441a      	add	r2, r3
 80277f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80277fa:	1ad3      	subs	r3, r2, r3
 80277fc:	005b      	lsls	r3, r3, #1
 80277fe:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027802:	1ad3      	subs	r3, r2, r3
 8027804:	12db      	asrs	r3, r3, #11
 8027806:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802780a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802780e:	3320      	adds	r3, #32
 8027810:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027814:	461a      	mov	r2, r3
 8027816:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802781a:	3340      	adds	r3, #64	@ 0x40
 802781c:	681b      	ldr	r3, [r3, #0]
 802781e:	fb02 f303 	mul.w	r3, r2, r3
 8027822:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8027826:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802782a:	3360      	adds	r3, #96	@ 0x60
 802782c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027830:	461a      	mov	r2, r3
 8027832:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027836:	33c0      	adds	r3, #192	@ 0xc0
 8027838:	681b      	ldr	r3, [r3, #0]
 802783a:	fb02 f303 	mul.w	r3, r2, r3
 802783e:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 8027842:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027846:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802784a:	4413      	add	r3, r2
 802784c:	f242 3262 	movw	r2, #9058	@ 0x2362
 8027850:	fb02 f303 	mul.w	r3, r2, r3
 8027854:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8027858:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 802785c:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 8027860:	fb02 f303 	mul.w	r3, r2, r3
 8027864:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8027868:	4413      	add	r3, r2
 802786a:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 802786e:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027872:	4af0      	ldr	r2, [pc, #960]	@ (8027c34 <jpeg_idct_7x14+0x55c>)
 8027874:	fb02 f303 	mul.w	r3, r2, r3
 8027878:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 802787c:	4413      	add	r3, r2
 802787e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8027882:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8027886:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 802788a:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 802788e:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027892:	49e9      	ldr	r1, [pc, #932]	@ (8027c38 <jpeg_idct_7x14+0x560>)
 8027894:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8027898:	4413      	add	r3, r2
 802789a:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8

    tmp20 = tmp10 + tmp13;
 802789e:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 80278a2:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80278a6:	4413      	add	r3, r2
 80278a8:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp26 = tmp10 - tmp13;
 80278ac:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 80278b0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80278b4:	1ad3      	subs	r3, r2, r3
 80278b6:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    tmp21 = tmp11 + tmp14;
 80278ba:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80278be:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80278c2:	4413      	add	r3, r2
 80278c4:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp25 = tmp11 - tmp14;
 80278c8:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80278cc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80278d0:	1ad3      	subs	r3, r2, r3
 80278d2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp22 = tmp12 + tmp15;
 80278d6:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80278da:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80278de:	4413      	add	r3, r2
 80278e0:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp24 = tmp12 - tmp15;
 80278e4:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80278e8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80278ec:	1ad3      	subs	r3, r2, r3
 80278ee:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80278f2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80278f6:	3310      	adds	r3, #16
 80278f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80278fc:	461a      	mov	r2, r3
 80278fe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027902:	3320      	adds	r3, #32
 8027904:	681b      	ldr	r3, [r3, #0]
 8027906:	fb02 f303 	mul.w	r3, r2, r3
 802790a:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802790e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8027912:	3330      	adds	r3, #48	@ 0x30
 8027914:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027918:	461a      	mov	r2, r3
 802791a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802791e:	3360      	adds	r3, #96	@ 0x60
 8027920:	681b      	ldr	r3, [r3, #0]
 8027922:	fb02 f303 	mul.w	r3, r2, r3
 8027926:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802792a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802792e:	3350      	adds	r3, #80	@ 0x50
 8027930:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027934:	461a      	mov	r2, r3
 8027936:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802793a:	33a0      	adds	r3, #160	@ 0xa0
 802793c:	681b      	ldr	r3, [r3, #0]
 802793e:	fb02 f303 	mul.w	r3, r2, r3
 8027942:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8027946:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802794a:	3370      	adds	r3, #112	@ 0x70
 802794c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027950:	461a      	mov	r2, r3
 8027952:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027956:	33e0      	adds	r3, #224	@ 0xe0
 8027958:	681b      	ldr	r3, [r3, #0]
 802795a:	fb02 f303 	mul.w	r3, r2, r3
 802795e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 = z4 << CONST_BITS;
 8027962:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027966:	035b      	lsls	r3, r3, #13
 8027968:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    tmp14 = z1 + z3;
 802796c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027970:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027974:	4413      	add	r3, r2
 8027976:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 802797a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802797e:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027982:	4413      	add	r3, r2
 8027984:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8027988:	fb02 f303 	mul.w	r3, r2, r3
 802798c:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 8027990:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8027994:	f242 6252 	movw	r2, #9810	@ 0x2652
 8027998:	fb02 f303 	mul.w	r3, r2, r3
 802799c:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 80279a0:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80279a4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80279a8:	441a      	add	r2, r3
 80279aa:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 80279ae:	441a      	add	r2, r3
 80279b0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80279b4:	49a1      	ldr	r1, [pc, #644]	@ (8027c3c <jpeg_idct_7x14+0x564>)
 80279b6:	fb01 f303 	mul.w	r3, r1, r3
 80279ba:	4413      	add	r3, r2
 80279bc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80279c0:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80279c4:	f641 0214 	movw	r2, #6164	@ 0x1814
 80279c8:	fb02 f303 	mul.w	r3, r2, r3
 80279cc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80279d0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80279d4:	4a9a      	ldr	r2, [pc, #616]	@ (8027c40 <jpeg_idct_7x14+0x568>)
 80279d6:	fb02 f303 	mul.w	r3, r2, r3
 80279da:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80279de:	4413      	add	r3, r2
 80279e0:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z1    -= z2;
 80279e4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 80279e8:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 80279ec:	1ad3      	subs	r3, r2, r3
 80279ee:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 80279f2:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80279f6:	f640 62f2 	movw	r2, #3826	@ 0xef2
 80279fa:	fb03 f202 	mul.w	r2, r3, r2
 80279fe:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8027a02:	1ad3      	subs	r3, r2, r3
 8027a04:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp16 += tmp15;
 8027a08:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8027a0c:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8027a10:	4413      	add	r3, r2
 8027a12:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z1    += z4;
 8027a16:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027a1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027a1e:	4413      	add	r3, r2
 8027a20:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 8027a24:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8027a28:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027a2c:	4413      	add	r3, r2
 8027a2e:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 8027a32:	fb03 f202 	mul.w	r2, r3, r2
 8027a36:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8027a3a:	1ad3      	subs	r3, r2, r3
 8027a3c:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 8027a40:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027a44:	4a7f      	ldr	r2, [pc, #508]	@ (8027c44 <jpeg_idct_7x14+0x56c>)
 8027a46:	fb03 f202 	mul.w	r2, r3, r2
 8027a4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027a4e:	4413      	add	r3, r2
 8027a50:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8027a54:	4413      	add	r3, r2
 8027a56:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 8027a5a:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027a5e:	4a7a      	ldr	r2, [pc, #488]	@ (8027c48 <jpeg_idct_7x14+0x570>)
 8027a60:	fb03 f202 	mul.w	r2, r3, r2
 8027a64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027a68:	4413      	add	r3, r2
 8027a6a:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8027a6e:	4413      	add	r3, r2
 8027a70:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8027a74:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8027a78:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027a7c:	1ad3      	subs	r3, r2, r3
 8027a7e:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 8027a82:	fb02 f303 	mul.w	r3, r2, r3
 8027a86:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8027a8a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8027a8e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8027a92:	441a      	add	r2, r3
 8027a94:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027a98:	496c      	ldr	r1, [pc, #432]	@ (8027c4c <jpeg_idct_7x14+0x574>)
 8027a9a:	fb01 f303 	mul.w	r3, r1, r3
 8027a9e:	4413      	add	r3, r2
 8027aa0:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8027aa4:	4413      	add	r3, r2
 8027aa6:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 8027aaa:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027aae:	f241 5299 	movw	r2, #5529	@ 0x1599
 8027ab2:	fb03 f202 	mul.w	r2, r3, r2
 8027ab6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8027aba:	4413      	add	r3, r2
 8027abc:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8027ac0:	4413      	add	r3, r2
 8027ac2:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8

    tmp13 = (z1 - z3) << PASS1_BITS;
 8027ac6:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027aca:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027ace:	1ad3      	subs	r3, r2, r3
 8027ad0:	009b      	lsls	r3, r3, #2
 8027ad2:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    /* Final output stage */

    wsptr[7*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8027ad6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027ada:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027ade:	4413      	add	r3, r2
 8027ae0:	12da      	asrs	r2, r3, #11
 8027ae2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027ae6:	601a      	str	r2, [r3, #0]
    wsptr[7*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8027ae8:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027aec:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027af0:	1ad2      	subs	r2, r2, r3
 8027af2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027af6:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 8027afa:	12d2      	asrs	r2, r2, #11
 8027afc:	601a      	str	r2, [r3, #0]
    wsptr[7*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8027afe:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8027b02:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8027b06:	441a      	add	r2, r3
 8027b08:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b0c:	331c      	adds	r3, #28
 8027b0e:	12d2      	asrs	r2, r2, #11
 8027b10:	601a      	str	r2, [r3, #0]
    wsptr[7*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8027b12:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8027b16:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8027b1a:	1ad2      	subs	r2, r2, r3
 8027b1c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b20:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8027b24:	12d2      	asrs	r2, r2, #11
 8027b26:	601a      	str	r2, [r3, #0]
    wsptr[7*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8027b28:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8027b2c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027b30:	441a      	add	r2, r3
 8027b32:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b36:	3338      	adds	r3, #56	@ 0x38
 8027b38:	12d2      	asrs	r2, r2, #11
 8027b3a:	601a      	str	r2, [r3, #0]
    wsptr[7*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8027b3c:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8027b40:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027b44:	1ad2      	subs	r2, r2, r3
 8027b46:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b4a:	f503 739a 	add.w	r3, r3, #308	@ 0x134
 8027b4e:	12d2      	asrs	r2, r2, #11
 8027b50:	601a      	str	r2, [r3, #0]
    wsptr[7*3]  = (int) (tmp23 + tmp13);
 8027b52:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b56:	3354      	adds	r3, #84	@ 0x54
 8027b58:	f8d7 11dc 	ldr.w	r1, [r7, #476]	@ 0x1dc
 8027b5c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8027b60:	440a      	add	r2, r1
 8027b62:	601a      	str	r2, [r3, #0]
    wsptr[7*10] = (int) (tmp23 - tmp13);
 8027b64:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b68:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8027b6c:	f8d7 11dc 	ldr.w	r1, [r7, #476]	@ 0x1dc
 8027b70:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8027b74:	1a8a      	subs	r2, r1, r2
 8027b76:	601a      	str	r2, [r3, #0]
    wsptr[7*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8027b78:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8027b7c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8027b80:	441a      	add	r2, r3
 8027b82:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b86:	3370      	adds	r3, #112	@ 0x70
 8027b88:	12d2      	asrs	r2, r2, #11
 8027b8a:	601a      	str	r2, [r3, #0]
    wsptr[7*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8027b8c:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8027b90:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8027b94:	1ad2      	subs	r2, r2, r3
 8027b96:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027b9a:	33fc      	adds	r3, #252	@ 0xfc
 8027b9c:	12d2      	asrs	r2, r2, #11
 8027b9e:	601a      	str	r2, [r3, #0]
    wsptr[7*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8027ba0:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8027ba4:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8027ba8:	441a      	add	r2, r3
 8027baa:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027bae:	338c      	adds	r3, #140	@ 0x8c
 8027bb0:	12d2      	asrs	r2, r2, #11
 8027bb2:	601a      	str	r2, [r3, #0]
    wsptr[7*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8027bb4:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8027bb8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8027bbc:	1ad2      	subs	r2, r2, r3
 8027bbe:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027bc2:	33e0      	adds	r3, #224	@ 0xe0
 8027bc4:	12d2      	asrs	r2, r2, #11
 8027bc6:	601a      	str	r2, [r3, #0]
    wsptr[7*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 8027bc8:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8027bcc:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8027bd0:	441a      	add	r2, r3
 8027bd2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027bd6:	33a8      	adds	r3, #168	@ 0xa8
 8027bd8:	12d2      	asrs	r2, r2, #11
 8027bda:	601a      	str	r2, [r3, #0]
    wsptr[7*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 8027bdc:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8027be0:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8027be4:	1ad2      	subs	r2, r2, r3
 8027be6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027bea:	33c4      	adds	r3, #196	@ 0xc4
 8027bec:	12d2      	asrs	r2, r2, #11
 8027bee:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8027bf0:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8027bf4:	3301      	adds	r3, #1
 8027bf6:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8027bfa:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8027bfe:	3302      	adds	r3, #2
 8027c00:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
 8027c04:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8027c08:	3304      	adds	r3, #4
 8027c0a:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
 8027c0e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027c12:	3304      	adds	r3, #4
 8027c14:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
 8027c18:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8027c1c:	2b06      	cmp	r3, #6
 8027c1e:	f77f ad93 	ble.w	8027748 <jpeg_idct_7x14+0x70>
  }

  /* Pass 2: process 14 rows from work array, store into output array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  wsptr = workspace;
 8027c22:	f107 0310 	add.w	r3, r7, #16
 8027c26:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 8027c2a:	2300      	movs	r3, #0
 8027c2c:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8027c30:	e17c      	b.n	8027f2c <jpeg_idct_7x14+0x854>
 8027c32:	bf00      	nop
 8027c34:	ffffc8fc 	.word	0xffffc8fc
 8027c38:	ffffd3e1 	.word	0xffffd3e1
 8027c3c:	ffffdbf0 	.word	0xffffdbf0
 8027c40:	ffffde0b 	.word	0xffffde0b
 8027c44:	fffff26e 	.word	0xfffff26e
 8027c48:	ffffb409 	.word	0xffffb409
 8027c4c:	ffffc9e6 	.word	0xffffc9e6
    outptr = output_buf[ctr] + output_col;
 8027c50:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8027c54:	009b      	lsls	r3, r3, #2
 8027c56:	f507 72fc 	add.w	r2, r7, #504	@ 0x1f8
 8027c5a:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 8027c5e:	6812      	ldr	r2, [r2, #0]
 8027c60:	4413      	add	r3, r2
 8027c62:	681a      	ldr	r2, [r3, #0]
 8027c64:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8027c68:	4413      	add	r3, r2
 8027c6a:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp23 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8027c6e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027c72:	681b      	ldr	r3, [r3, #0]
 8027c74:	3310      	adds	r3, #16
 8027c76:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp23 <<= CONST_BITS;
 8027c7a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8027c7e:	035b      	lsls	r3, r3, #13
 8027c80:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc

    z1 = (INT32) wsptr[2];
 8027c84:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027c88:	3308      	adds	r3, #8
 8027c8a:	681b      	ldr	r3, [r3, #0]
 8027c8c:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = (INT32) wsptr[4];
 8027c90:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027c94:	3310      	adds	r3, #16
 8027c96:	681b      	ldr	r3, [r3, #0]
 8027c98:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = (INT32) wsptr[6];
 8027c9c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027ca0:	3318      	adds	r3, #24
 8027ca2:	681b      	ldr	r3, [r3, #0]
 8027ca4:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 8027ca8:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8027cac:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027cb0:	1ad3      	subs	r3, r2, r3
 8027cb2:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8027cb6:	fb02 f303 	mul.w	r3, r2, r3
 8027cba:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 8027cbe:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027cc2:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027cc6:	1ad3      	subs	r3, r2, r3
 8027cc8:	f640 2212 	movw	r2, #2578	@ 0xa12
 8027ccc:	fb02 f303 	mul.w	r3, r2, r3
 8027cd0:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 8027cd4:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027cd8:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8027cdc:	441a      	add	r2, r3
 8027cde:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8027ce2:	441a      	add	r2, r3
 8027ce4:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027ce8:	4996      	ldr	r1, [pc, #600]	@ (8027f44 <jpeg_idct_7x14+0x86c>)
 8027cea:	fb01 f303 	mul.w	r3, r1, r3
 8027cee:	4413      	add	r3, r2
 8027cf0:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp10 = z1 + z3;
 8027cf4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027cf8:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027cfc:	4413      	add	r3, r2
 8027cfe:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    z2 -= tmp10;
 8027d02:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8027d06:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027d0a:	1ad3      	subs	r3, r2, r3
 8027d0c:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 8027d10:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027d14:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8027d18:	fb02 f303 	mul.w	r3, r2, r3
 8027d1c:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8027d20:	4413      	add	r3, r2
 8027d22:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 8027d26:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027d2a:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 8027d2e:	fb03 f202 	mul.w	r2, r3, r2
 8027d32:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027d36:	4413      	add	r3, r2
 8027d38:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027d3c:	4413      	add	r3, r2
 8027d3e:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 8027d42:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8027d46:	4a80      	ldr	r2, [pc, #512]	@ (8027f48 <jpeg_idct_7x14+0x870>)
 8027d48:	fb03 f202 	mul.w	r2, r3, r2
 8027d4c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027d50:	4413      	add	r3, r2
 8027d52:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8027d56:	4413      	add	r3, r2
 8027d58:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 8027d5c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027d60:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8027d64:	fb02 f303 	mul.w	r3, r2, r3
 8027d68:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8027d6c:	4413      	add	r3, r2
 8027d6e:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8027d72:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027d76:	3304      	adds	r3, #4
 8027d78:	681b      	ldr	r3, [r3, #0]
 8027d7a:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = (INT32) wsptr[3];
 8027d7e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027d82:	330c      	adds	r3, #12
 8027d84:	681b      	ldr	r3, [r3, #0]
 8027d86:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = (INT32) wsptr[5];
 8027d8a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027d8e:	3314      	adds	r3, #20
 8027d90:	681b      	ldr	r3, [r3, #0]
 8027d92:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 8027d96:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027d9a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027d9e:	4413      	add	r3, r2
 8027da0:	f641 52ef 	movw	r2, #7663	@ 0x1def
 8027da4:	fb02 f303 	mul.w	r3, r2, r3
 8027da8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 8027dac:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027db0:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027db4:	1ad3      	subs	r3, r2, r3
 8027db6:	f240 5273 	movw	r2, #1395	@ 0x573
 8027dba:	fb02 f303 	mul.w	r3, r2, r3
 8027dbe:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp10 = tmp11 - tmp12;
 8027dc2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8027dc6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027dca:	1ad3      	subs	r3, r2, r3
 8027dcc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp11 += tmp12;
 8027dd0:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8027dd4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027dd8:	4413      	add	r3, r2
 8027dda:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 8027dde:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8027de2:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027de6:	4413      	add	r3, r2
 8027de8:	4a58      	ldr	r2, [pc, #352]	@ (8027f4c <jpeg_idct_7x14+0x874>)
 8027dea:	fb02 f303 	mul.w	r3, r2, r3
 8027dee:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp11 += tmp12;
 8027df2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8027df6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027dfa:	4413      	add	r3, r2
 8027dfc:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 8027e00:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8027e04:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027e08:	4413      	add	r3, r2
 8027e0a:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8027e0e:	fb02 f303 	mul.w	r3, r2, r3
 8027e12:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp10 += z2;
 8027e16:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8027e1a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027e1e:	4413      	add	r3, r2
 8027e20:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 8027e24:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8027e28:	f643 32de 	movw	r2, #15326	@ 0x3bde
 8027e2c:	fb03 f202 	mul.w	r2, r3, r2
 8027e30:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8027e34:	4413      	add	r3, r2
 8027e36:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8027e3a:	4413      	add	r3, r2
 8027e3c:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8027e40:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027e44:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027e48:	4413      	add	r3, r2
 8027e4a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027e4c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8027e50:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027e54:	4413      	add	r3, r2
 8027e56:	781a      	ldrb	r2, [r3, #0]
 8027e58:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027e5c:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8027e5e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8027e62:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8027e66:	1ad3      	subs	r3, r2, r3
 8027e68:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027e6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8027e6e:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027e72:	441a      	add	r2, r3
 8027e74:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027e78:	3306      	adds	r3, #6
 8027e7a:	7812      	ldrb	r2, [r2, #0]
 8027e7c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8027e7e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8027e82:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8027e86:	4413      	add	r3, r2
 8027e88:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027e8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8027e8e:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027e92:	441a      	add	r2, r3
 8027e94:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027e98:	3301      	adds	r3, #1
 8027e9a:	7812      	ldrb	r2, [r2, #0]
 8027e9c:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027e9e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8027ea2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8027ea6:	1ad3      	subs	r3, r2, r3
 8027ea8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027eaa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027eae:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027eb2:	441a      	add	r2, r3
 8027eb4:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027eb8:	3305      	adds	r3, #5
 8027eba:	7812      	ldrb	r2, [r2, #0]
 8027ebc:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027ebe:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8027ec2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027ec6:	4413      	add	r3, r2
 8027ec8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027eca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027ece:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027ed2:	441a      	add	r2, r3
 8027ed4:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027ed8:	3302      	adds	r3, #2
 8027eda:	7812      	ldrb	r2, [r2, #0]
 8027edc:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027ede:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8027ee2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8027ee6:	1ad3      	subs	r3, r2, r3
 8027ee8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027eea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027eee:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027ef2:	441a      	add	r2, r3
 8027ef4:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027ef8:	3304      	adds	r3, #4
 8027efa:	7812      	ldrb	r2, [r2, #0]
 8027efc:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 8027efe:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8027f02:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8027f04:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 8027f08:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8027f0c:	441a      	add	r2, r3
 8027f0e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8027f12:	3303      	adds	r3, #3
 8027f14:	7812      	ldrb	r2, [r2, #0]
 8027f16:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 8027f18:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8027f1c:	331c      	adds	r3, #28
 8027f1e:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 8027f22:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8027f26:	3301      	adds	r3, #1
 8027f28:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8027f2c:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8027f30:	2b0d      	cmp	r3, #13
 8027f32:	f77f ae8d 	ble.w	8027c50 <jpeg_idct_7x14+0x578>
  }
}
 8027f36:	bf00      	nop
 8027f38:	bf00      	nop
 8027f3a:	f507 77fc 	add.w	r7, r7, #504	@ 0x1f8
 8027f3e:	46bd      	mov	sp, r7
 8027f40:	bc90      	pop	{r4, r7}
 8027f42:	4770      	bx	lr
 8027f44:	ffffc515 	.word	0xffffc515
 8027f48:	ffffb0f1 	.word	0xffffb0f1
 8027f4c:	ffffd3e1 	.word	0xffffd3e1

08027f50 <jpeg_idct_6x12>:

GLOBAL(void)
jpeg_idct_6x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8027f50:	b490      	push	{r4, r7}
 8027f52:	b0e2      	sub	sp, #392	@ 0x188
 8027f54:	af00      	add	r7, sp, #0
 8027f56:	f507 74c4 	add.w	r4, r7, #392	@ 0x188
 8027f5a:	f5a4 74be 	sub.w	r4, r4, #380	@ 0x17c
 8027f5e:	6020      	str	r0, [r4, #0]
 8027f60:	f507 70c4 	add.w	r0, r7, #392	@ 0x188
 8027f64:	f5a0 70c0 	sub.w	r0, r0, #384	@ 0x180
 8027f68:	6001      	str	r1, [r0, #0]
 8027f6a:	f507 71c4 	add.w	r1, r7, #392	@ 0x188
 8027f6e:	f5a1 71c2 	sub.w	r1, r1, #388	@ 0x184
 8027f72:	600a      	str	r2, [r1, #0]
 8027f74:	f507 72c4 	add.w	r2, r7, #392	@ 0x188
 8027f78:	f5a2 72c4 	sub.w	r2, r2, #392	@ 0x188
 8027f7c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8027f7e:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 8027f82:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8027f86:	681b      	ldr	r3, [r3, #0]
 8027f88:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8027f8c:	3380      	adds	r3, #128	@ 0x80
 8027f8e:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  inptr = coef_block;
 8027f92:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 8027f96:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 8027f9a:	681b      	ldr	r3, [r3, #0]
 8027f9c:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8027fa0:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 8027fa4:	f5a3 73c0 	sub.w	r3, r3, #384	@ 0x180
 8027fa8:	681b      	ldr	r3, [r3, #0]
 8027faa:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8027fac:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
  wsptr = workspace;
 8027fb0:	f107 0310 	add.w	r3, r7, #16
 8027fb4:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8027fb8:	2300      	movs	r3, #0
 8027fba:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 8027fbe:	e215      	b.n	80283ec <jpeg_idct_6x12+0x49c>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8027fc0:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8027fc4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027fc8:	461a      	mov	r2, r3
 8027fca:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8027fce:	681b      	ldr	r3, [r3, #0]
 8027fd0:	fb02 f303 	mul.w	r3, r2, r3
 8027fd4:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z3 <<= CONST_BITS;
 8027fd8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8027fdc:	035b      	lsls	r3, r3, #13
 8027fde:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 8027fe2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8027fe6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8027fea:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8027fee:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8027ff2:	3340      	adds	r3, #64	@ 0x40
 8027ff4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027ff8:	461a      	mov	r2, r3
 8027ffa:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8027ffe:	3380      	adds	r3, #128	@ 0x80
 8028000:	681b      	ldr	r3, [r3, #0]
 8028002:	fb02 f303 	mul.w	r3, r2, r3
 8028006:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 802800a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802800e:	f242 7231 	movw	r2, #10033	@ 0x2731
 8028012:	fb02 f303 	mul.w	r3, r2, r3
 8028016:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    tmp10 = z3 + z4;
 802801a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802801e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8028022:	4413      	add	r3, r2
 8028024:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp11 = z3 - z4;
 8028028:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802802c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8028030:	1ad3      	subs	r3, r2, r3
 8028032:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8028036:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802803a:	3320      	adds	r3, #32
 802803c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028040:	461a      	mov	r2, r3
 8028042:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8028046:	3340      	adds	r3, #64	@ 0x40
 8028048:	681b      	ldr	r3, [r3, #0]
 802804a:	fb02 f303 	mul.w	r3, r2, r3
 802804e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8028052:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8028056:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 802805a:	fb02 f303 	mul.w	r3, r2, r3
 802805e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z1 <<= CONST_BITS;
 8028062:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8028066:	035b      	lsls	r3, r3, #13
 8028068:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802806c:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8028070:	3360      	adds	r3, #96	@ 0x60
 8028072:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028076:	461a      	mov	r2, r3
 8028078:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802807c:	33c0      	adds	r3, #192	@ 0xc0
 802807e:	681b      	ldr	r3, [r3, #0]
 8028080:	fb02 f303 	mul.w	r3, r2, r3
 8028084:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z2 <<= CONST_BITS;
 8028088:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802808c:	035b      	lsls	r3, r3, #13
 802808e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    tmp12 = z1 - z2;
 8028092:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8028096:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802809a:	1ad3      	subs	r3, r2, r3
 802809c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp21 = z3 + tmp12;
 80280a0:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80280a4:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80280a8:	4413      	add	r3, r2
 80280aa:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp24 = z3 - tmp12;
 80280ae:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80280b2:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80280b6:	1ad3      	subs	r3, r2, r3
 80280b8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp12 = z4 + z2;
 80280bc:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 80280c0:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80280c4:	4413      	add	r3, r2
 80280c6:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp20 = tmp10 + tmp12;
 80280ca:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80280ce:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80280d2:	4413      	add	r3, r2
 80280d4:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp25 = tmp10 - tmp12;
 80280d8:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80280dc:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80280e0:	1ad3      	subs	r3, r2, r3
 80280e2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp12 = z4 - z1 - z2;
 80280e6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 80280ea:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80280ee:	1ad2      	subs	r2, r2, r3
 80280f0:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80280f4:	1ad3      	subs	r3, r2, r3
 80280f6:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp22 = tmp11 + tmp12;
 80280fa:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80280fe:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8028102:	4413      	add	r3, r2
 8028104:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp23 = tmp11 - tmp12;
 8028108:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802810c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8028110:	1ad3      	subs	r3, r2, r3
 8028112:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8028116:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802811a:	3310      	adds	r3, #16
 802811c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028120:	461a      	mov	r2, r3
 8028122:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8028126:	3320      	adds	r3, #32
 8028128:	681b      	ldr	r3, [r3, #0]
 802812a:	fb02 f303 	mul.w	r3, r2, r3
 802812e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8028132:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8028136:	3330      	adds	r3, #48	@ 0x30
 8028138:	f9b3 3000 	ldrsh.w	r3, [r3]
 802813c:	461a      	mov	r2, r3
 802813e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8028142:	3360      	adds	r3, #96	@ 0x60
 8028144:	681b      	ldr	r3, [r3, #0]
 8028146:	fb02 f303 	mul.w	r3, r2, r3
 802814a:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802814e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8028152:	3350      	adds	r3, #80	@ 0x50
 8028154:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028158:	461a      	mov	r2, r3
 802815a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802815e:	33a0      	adds	r3, #160	@ 0xa0
 8028160:	681b      	ldr	r3, [r3, #0]
 8028162:	fb02 f303 	mul.w	r3, r2, r3
 8028166:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802816a:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802816e:	3370      	adds	r3, #112	@ 0x70
 8028170:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028174:	461a      	mov	r2, r3
 8028176:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802817a:	33e0      	adds	r3, #224	@ 0xe0
 802817c:	681b      	ldr	r3, [r3, #0]
 802817e:	fb02 f303 	mul.w	r3, r2, r3
 8028182:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 8028186:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802818a:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 802818e:	fb02 f303 	mul.w	r3, r2, r3
 8028192:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 8028196:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802819a:	4a9b      	ldr	r2, [pc, #620]	@ (8028408 <jpeg_idct_6x12+0x4b8>)
 802819c:	fb02 f303 	mul.w	r3, r2, r3
 80281a0:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    tmp10 = z1 + z3;
 80281a4:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80281a8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80281ac:	4413      	add	r3, r2
 80281ae:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 80281b2:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80281b6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80281ba:	4413      	add	r3, r2
 80281bc:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 80281c0:	fb02 f303 	mul.w	r3, r2, r3
 80281c4:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 80281c8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80281cc:	f640 025b 	movw	r2, #2139	@ 0x85b
 80281d0:	fb02 f303 	mul.w	r3, r2, r3
 80281d4:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80281d8:	4413      	add	r3, r2
 80281da:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 80281de:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 80281e2:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80281e6:	18d1      	adds	r1, r2, r3
 80281e8:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80281ec:	4613      	mov	r3, r2
 80281ee:	00db      	lsls	r3, r3, #3
 80281f0:	4413      	add	r3, r2
 80281f2:	021a      	lsls	r2, r3, #8
 80281f4:	1ad3      	subs	r3, r2, r3
 80281f6:	440b      	add	r3, r1
 80281f8:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 80281fc:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8028200:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8028204:	4413      	add	r3, r2
 8028206:	4a81      	ldr	r2, [pc, #516]	@ (802840c <jpeg_idct_6x12+0x4bc>)
 8028208:	fb02 f303 	mul.w	r3, r2, r3
 802820c:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8028210:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8028214:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8028218:	441a      	add	r2, r3
 802821a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802821e:	497c      	ldr	r1, [pc, #496]	@ (8028410 <jpeg_idct_6x12+0x4c0>)
 8028220:	fb01 f303 	mul.w	r3, r1, r3
 8028224:	4413      	add	r3, r2
 8028226:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 802822a:	4413      	add	r3, r2
 802822c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8028230:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8028234:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8028238:	1ad2      	subs	r2, r2, r3
 802823a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802823e:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 8028242:	fb01 f303 	mul.w	r3, r1, r3
 8028246:	4413      	add	r3, r2
 8028248:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 802824c:	4413      	add	r3, r2
 802824e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8028252:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8028256:	4a6f      	ldr	r2, [pc, #444]	@ (8028414 <jpeg_idct_6x12+0x4c4>)
 8028258:	fb03 f202 	mul.w	r2, r3, r2
 802825c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8028260:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8028262:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8028266:	496c      	ldr	r1, [pc, #432]	@ (8028418 <jpeg_idct_6x12+0x4c8>)
 8028268:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802826c:	4413      	add	r3, r2
 802826e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8028272:	4413      	add	r3, r2
 8028274:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z1 -= z4;
 8028278:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802827c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8028280:	1ad3      	subs	r3, r2, r3
 8028282:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 -= z3;
 8028286:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802828a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802828e:	1ad3      	subs	r3, r2, r3
 8028290:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8028294:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8028298:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802829c:	4413      	add	r3, r2
 802829e:	f241 1251 	movw	r2, #4433	@ 0x1151
 80282a2:	fb02 f303 	mul.w	r3, r2, r3
 80282a6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 80282aa:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80282ae:	f641 027e 	movw	r2, #6270	@ 0x187e
 80282b2:	fb02 f303 	mul.w	r3, r2, r3
 80282b6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80282ba:	4413      	add	r3, r2
 80282bc:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 80282c0:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80282c4:	4a55      	ldr	r2, [pc, #340]	@ (802841c <jpeg_idct_6x12+0x4cc>)
 80282c6:	fb02 f303 	mul.w	r3, r2, r3
 80282ca:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80282ce:	4413      	add	r3, r2
 80282d0:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Final output stage */

    wsptr[6*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80282d4:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80282d8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80282dc:	4413      	add	r3, r2
 80282de:	12da      	asrs	r2, r3, #11
 80282e0:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80282e4:	601a      	str	r2, [r3, #0]
    wsptr[6*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80282e6:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80282ea:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80282ee:	1ad2      	subs	r2, r2, r3
 80282f0:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80282f4:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80282f8:	12d2      	asrs	r2, r2, #11
 80282fa:	601a      	str	r2, [r3, #0]
    wsptr[6*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80282fc:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8028300:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8028304:	441a      	add	r2, r3
 8028306:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802830a:	3318      	adds	r3, #24
 802830c:	12d2      	asrs	r2, r2, #11
 802830e:	601a      	str	r2, [r3, #0]
    wsptr[6*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8028310:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8028314:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8028318:	1ad2      	subs	r2, r2, r3
 802831a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802831e:	33f0      	adds	r3, #240	@ 0xf0
 8028320:	12d2      	asrs	r2, r2, #11
 8028322:	601a      	str	r2, [r3, #0]
    wsptr[6*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8028324:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8028328:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802832c:	441a      	add	r2, r3
 802832e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028332:	3330      	adds	r3, #48	@ 0x30
 8028334:	12d2      	asrs	r2, r2, #11
 8028336:	601a      	str	r2, [r3, #0]
    wsptr[6*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8028338:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 802833c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8028340:	1ad2      	subs	r2, r2, r3
 8028342:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028346:	33d8      	adds	r3, #216	@ 0xd8
 8028348:	12d2      	asrs	r2, r2, #11
 802834a:	601a      	str	r2, [r3, #0]
    wsptr[6*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802834c:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8028350:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8028354:	441a      	add	r2, r3
 8028356:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802835a:	3348      	adds	r3, #72	@ 0x48
 802835c:	12d2      	asrs	r2, r2, #11
 802835e:	601a      	str	r2, [r3, #0]
    wsptr[6*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8028360:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8028364:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8028368:	1ad2      	subs	r2, r2, r3
 802836a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802836e:	33c0      	adds	r3, #192	@ 0xc0
 8028370:	12d2      	asrs	r2, r2, #11
 8028372:	601a      	str	r2, [r3, #0]
    wsptr[6*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8028374:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8028378:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802837c:	441a      	add	r2, r3
 802837e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028382:	3360      	adds	r3, #96	@ 0x60
 8028384:	12d2      	asrs	r2, r2, #11
 8028386:	601a      	str	r2, [r3, #0]
    wsptr[6*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8028388:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 802838c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8028390:	1ad2      	subs	r2, r2, r3
 8028392:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028396:	33a8      	adds	r3, #168	@ 0xa8
 8028398:	12d2      	asrs	r2, r2, #11
 802839a:	601a      	str	r2, [r3, #0]
    wsptr[6*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 802839c:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80283a0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80283a4:	441a      	add	r2, r3
 80283a6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80283aa:	3378      	adds	r3, #120	@ 0x78
 80283ac:	12d2      	asrs	r2, r2, #11
 80283ae:	601a      	str	r2, [r3, #0]
    wsptr[6*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 80283b0:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80283b4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80283b8:	1ad2      	subs	r2, r2, r3
 80283ba:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80283be:	3390      	adds	r3, #144	@ 0x90
 80283c0:	12d2      	asrs	r2, r2, #11
 80283c2:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 80283c4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80283c8:	3301      	adds	r3, #1
 80283ca:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 80283ce:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 80283d2:	3302      	adds	r3, #2
 80283d4:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
 80283d8:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80283dc:	3304      	adds	r3, #4
 80283de:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
 80283e2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80283e6:	3304      	adds	r3, #4
 80283e8:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
 80283ec:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80283f0:	2b05      	cmp	r3, #5
 80283f2:	f77f ade5 	ble.w	8027fc0 <jpeg_idct_6x12+0x70>
  }

  /* Pass 2: process 12 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 80283f6:	f107 0310 	add.w	r3, r7, #16
 80283fa:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 80283fe:	2300      	movs	r3, #0
 8028400:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 8028404:	e108      	b.n	8028618 <jpeg_idct_6x12+0x6c8>
 8028406:	bf00      	nop
 8028408:	ffffeeaf 	.word	0xffffeeaf
 802840c:	ffffde8b 	.word	0xffffde8b
 8028410:	ffffd0b0 	.word	0xffffd0b0
 8028414:	ffffea5c 	.word	0xffffea5c
 8028418:	ffffc08c 	.word	0xffffc08c
 802841c:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 8028420:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8028424:	009b      	lsls	r3, r3, #2
 8028426:	f507 72c4 	add.w	r2, r7, #392	@ 0x188
 802842a:	f5a2 72c4 	sub.w	r2, r2, #392	@ 0x188
 802842e:	6812      	ldr	r2, [r2, #0]
 8028430:	4413      	add	r3, r2
 8028432:	681a      	ldr	r2, [r3, #0]
 8028434:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8028438:	4413      	add	r3, r2
 802843a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802843e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028442:	681b      	ldr	r3, [r3, #0]
 8028444:	3310      	adds	r3, #16
 8028446:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp10 <<= CONST_BITS;
 802844a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802844e:	035b      	lsls	r3, r3, #13
 8028450:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp12 = (INT32) wsptr[4];
 8028454:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028458:	3310      	adds	r3, #16
 802845a:	681b      	ldr	r3, [r3, #0]
 802845c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 8028460:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8028464:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8028468:	fb02 f303 	mul.w	r3, r2, r3
 802846c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp10 + tmp20;
 8028470:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8028474:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8028478:	4413      	add	r3, r2
 802847a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp21 = tmp10 - tmp20 - tmp20;
 802847e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8028482:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8028486:	1ad2      	subs	r2, r2, r3
 8028488:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802848c:	1ad3      	subs	r3, r2, r3
 802848e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp20 = (INT32) wsptr[2];
 8028492:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028496:	3308      	adds	r3, #8
 8028498:	681b      	ldr	r3, [r3, #0]
 802849a:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 802849e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 80284a2:	f242 7231 	movw	r2, #10033	@ 0x2731
 80284a6:	fb02 f303 	mul.w	r3, r2, r3
 80284aa:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp20 = tmp11 + tmp10;
 80284ae:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80284b2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80284b6:	4413      	add	r3, r2
 80284b8:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp22 = tmp11 - tmp10;
 80284bc:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80284c0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80284c4:	1ad3      	subs	r3, r2, r3
 80284c6:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80284ca:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80284ce:	3304      	adds	r3, #4
 80284d0:	681b      	ldr	r3, [r3, #0]
 80284d2:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = (INT32) wsptr[3];
 80284d6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80284da:	330c      	adds	r3, #12
 80284dc:	681b      	ldr	r3, [r3, #0]
 80284de:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = (INT32) wsptr[5];
 80284e2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80284e6:	3314      	adds	r3, #20
 80284e8:	681b      	ldr	r3, [r3, #0]
 80284ea:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 80284ee:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80284f2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80284f6:	4413      	add	r3, r2
 80284f8:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 80284fc:	fb02 f303 	mul.w	r3, r2, r3
 8028500:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 8028504:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8028508:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802850c:	4413      	add	r3, r2
 802850e:	035b      	lsls	r3, r3, #13
 8028510:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8028514:	4413      	add	r3, r2
 8028516:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 802851a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802851e:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8028522:	1ad3      	subs	r3, r2, r3
 8028524:	035b      	lsls	r3, r3, #13
 8028526:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802852a:	4413      	add	r3, r2
 802852c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp11 = (z1 - z2 - z3) << CONST_BITS;
 8028530:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8028534:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8028538:	1ad2      	subs	r2, r2, r3
 802853a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802853e:	1ad3      	subs	r3, r2, r3
 8028540:	035b      	lsls	r3, r3, #13
 8028542:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8028546:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802854a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802854e:	4413      	add	r3, r2
 8028550:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028552:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8028556:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802855a:	4413      	add	r3, r2
 802855c:	781a      	ldrb	r2, [r3, #0]
 802855e:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8028562:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8028564:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8028568:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802856c:	1ad3      	subs	r3, r2, r3
 802856e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028570:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8028574:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 8028578:	441a      	add	r2, r3
 802857a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802857e:	3305      	adds	r3, #5
 8028580:	7812      	ldrb	r2, [r2, #0]
 8028582:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8028584:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8028588:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802858c:	4413      	add	r3, r2
 802858e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028590:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8028594:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 8028598:	441a      	add	r2, r3
 802859a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802859e:	3301      	adds	r3, #1
 80285a0:	7812      	ldrb	r2, [r2, #0]
 80285a2:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80285a4:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 80285a8:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80285ac:	1ad3      	subs	r3, r2, r3
 80285ae:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80285b4:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80285b8:	441a      	add	r2, r3
 80285ba:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80285be:	3304      	adds	r3, #4
 80285c0:	7812      	ldrb	r2, [r2, #0]
 80285c2:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80285c4:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 80285c8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80285cc:	4413      	add	r3, r2
 80285ce:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285d0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80285d4:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80285d8:	441a      	add	r2, r3
 80285da:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80285de:	3302      	adds	r3, #2
 80285e0:	7812      	ldrb	r2, [r2, #0]
 80285e2:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80285e4:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 80285e8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80285ec:	1ad3      	subs	r3, r2, r3
 80285ee:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80285f4:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80285f8:	441a      	add	r2, r3
 80285fa:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80285fe:	3303      	adds	r3, #3
 8028600:	7812      	ldrb	r2, [r2, #0]
 8028602:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8028604:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8028608:	3318      	adds	r3, #24
 802860a:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 802860e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8028612:	3301      	adds	r3, #1
 8028614:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 8028618:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802861c:	2b0b      	cmp	r3, #11
 802861e:	f77f aeff 	ble.w	8028420 <jpeg_idct_6x12+0x4d0>
  }
}
 8028622:	bf00      	nop
 8028624:	bf00      	nop
 8028626:	f507 77c4 	add.w	r7, r7, #392	@ 0x188
 802862a:	46bd      	mov	sp, r7
 802862c:	bc90      	pop	{r4, r7}
 802862e:	4770      	bx	lr

08028630 <jpeg_idct_5x10>:

GLOBAL(void)
jpeg_idct_5x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8028630:	b490      	push	{r4, r7}
 8028632:	b0cc      	sub	sp, #304	@ 0x130
 8028634:	af00      	add	r7, sp, #0
 8028636:	f507 7498 	add.w	r4, r7, #304	@ 0x130
 802863a:	f5a4 7492 	sub.w	r4, r4, #292	@ 0x124
 802863e:	6020      	str	r0, [r4, #0]
 8028640:	f507 7098 	add.w	r0, r7, #304	@ 0x130
 8028644:	f5a0 7094 	sub.w	r0, r0, #296	@ 0x128
 8028648:	6001      	str	r1, [r0, #0]
 802864a:	f507 7198 	add.w	r1, r7, #304	@ 0x130
 802864e:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 8028652:	600a      	str	r2, [r1, #0]
 8028654:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 8028658:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 802865c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802865e:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8028662:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8028666:	681b      	ldr	r3, [r3, #0]
 8028668:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802866c:	3380      	adds	r3, #128	@ 0x80
 802866e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  inptr = coef_block;
 8028672:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8028676:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 802867a:	681b      	ldr	r3, [r3, #0]
 802867c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8028680:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8028684:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8028688:	681b      	ldr	r3, [r3, #0]
 802868a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802868c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
  wsptr = workspace;
 8028690:	f107 0314 	add.w	r3, r7, #20
 8028694:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8028698:	2300      	movs	r3, #0
 802869a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 802869e:	e1d3      	b.n	8028a48 <jpeg_idct_5x10+0x418>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80286a0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80286a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80286a8:	461a      	mov	r2, r3
 80286aa:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80286ae:	681b      	ldr	r3, [r3, #0]
 80286b0:	fb02 f303 	mul.w	r3, r2, r3
 80286b4:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z3 <<= CONST_BITS;
 80286b8:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80286bc:	035b      	lsls	r3, r3, #13
 80286be:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 80286c2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80286c6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80286ca:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80286ce:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80286d2:	3340      	adds	r3, #64	@ 0x40
 80286d4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80286d8:	461a      	mov	r2, r3
 80286da:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80286de:	3380      	adds	r3, #128	@ 0x80
 80286e0:	681b      	ldr	r3, [r3, #0]
 80286e2:	fb02 f303 	mul.w	r3, r2, r3
 80286e6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 80286ea:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80286ee:	f242 429d 	movw	r2, #9373	@ 0x249d
 80286f2:	fb02 f303 	mul.w	r3, r2, r3
 80286f6:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 80286fa:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80286fe:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8028702:	fb02 f303 	mul.w	r3, r2, r3
 8028706:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp10 = z3 + z1;
 802870a:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802870e:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8028712:	4413      	add	r3, r2
 8028714:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp11 = z3 - z2;
 8028718:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802871c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028720:	1ad3      	subs	r3, r2, r3
 8028722:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 8028726:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802872a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802872e:	1ad3      	subs	r3, r2, r3
 8028730:	005b      	lsls	r3, r3, #1
 8028732:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8028736:	1ad3      	subs	r3, r2, r3
 8028738:	12db      	asrs	r3, r3, #11
 802873a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802873e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8028742:	3320      	adds	r3, #32
 8028744:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028748:	461a      	mov	r2, r3
 802874a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802874e:	3340      	adds	r3, #64	@ 0x40
 8028750:	681b      	ldr	r3, [r3, #0]
 8028752:	fb02 f303 	mul.w	r3, r2, r3
 8028756:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802875a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802875e:	3360      	adds	r3, #96	@ 0x60
 8028760:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028764:	461a      	mov	r2, r3
 8028766:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802876a:	33c0      	adds	r3, #192	@ 0xc0
 802876c:	681b      	ldr	r3, [r3, #0]
 802876e:	fb02 f303 	mul.w	r3, r2, r3
 8028772:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8028776:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802877a:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802877e:	4413      	add	r3, r2
 8028780:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8028784:	fb02 f303 	mul.w	r3, r2, r3
 8028788:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 802878c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028790:	f241 0271 	movw	r2, #4209	@ 0x1071
 8028794:	fb02 f303 	mul.w	r3, r2, r3
 8028798:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802879c:	4413      	add	r3, r2
 802879e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 80287a2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80287a6:	4aaf      	ldr	r2, [pc, #700]	@ (8028a64 <jpeg_idct_5x10+0x434>)
 80287a8:	fb02 f303 	mul.w	r3, r2, r3
 80287ac:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80287b0:	4413      	add	r3, r2
 80287b2:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    tmp20 = tmp10 + tmp12;
 80287b6:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80287ba:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80287be:	4413      	add	r3, r2
 80287c0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp24 = tmp10 - tmp12;
 80287c4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80287c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80287cc:	1ad3      	subs	r3, r2, r3
 80287ce:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp21 = tmp11 + tmp13;
 80287d2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80287d6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80287da:	4413      	add	r3, r2
 80287dc:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp23 = tmp11 - tmp13;
 80287e0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80287e4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80287e8:	1ad3      	subs	r3, r2, r3
 80287ea:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80287ee:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80287f2:	3310      	adds	r3, #16
 80287f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80287f8:	461a      	mov	r2, r3
 80287fa:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80287fe:	3320      	adds	r3, #32
 8028800:	681b      	ldr	r3, [r3, #0]
 8028802:	fb02 f303 	mul.w	r3, r2, r3
 8028806:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802880a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802880e:	3330      	adds	r3, #48	@ 0x30
 8028810:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028814:	461a      	mov	r2, r3
 8028816:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802881a:	3360      	adds	r3, #96	@ 0x60
 802881c:	681b      	ldr	r3, [r3, #0]
 802881e:	fb02 f303 	mul.w	r3, r2, r3
 8028822:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8028826:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802882a:	3350      	adds	r3, #80	@ 0x50
 802882c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028830:	461a      	mov	r2, r3
 8028832:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8028836:	33a0      	adds	r3, #160	@ 0xa0
 8028838:	681b      	ldr	r3, [r3, #0]
 802883a:	fb02 f303 	mul.w	r3, r2, r3
 802883e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8028842:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8028846:	3370      	adds	r3, #112	@ 0x70
 8028848:	f9b3 3000 	ldrsh.w	r3, [r3]
 802884c:	461a      	mov	r2, r3
 802884e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8028852:	33e0      	adds	r3, #224	@ 0xe0
 8028854:	681b      	ldr	r3, [r3, #0]
 8028856:	fb02 f303 	mul.w	r3, r2, r3
 802885a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp11 = z2 + z4;
 802885e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8028862:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028866:	4413      	add	r3, r2
 8028868:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp13 = z2 - z4;
 802886c:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8028870:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028874:	1ad3      	subs	r3, r2, r3
 8028876:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 802887a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802887e:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 8028882:	fb02 f303 	mul.w	r3, r2, r3
 8028886:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    z5 = z3 << CONST_BITS;
 802888a:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802888e:	035b      	lsls	r3, r3, #13
 8028890:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 8028894:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8028898:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 802889c:	fb02 f303 	mul.w	r3, r2, r3
 80288a0:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z4 = z5 + tmp12;
 80288a4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80288a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80288ac:	4413      	add	r3, r2
 80288ae:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 80288b2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80288b6:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 80288ba:	fb03 f202 	mul.w	r2, r3, r2
 80288be:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80288c2:	4413      	add	r3, r2
 80288c4:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80288c8:	4413      	add	r3, r2
 80288ca:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 80288ce:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80288d2:	f240 7214 	movw	r2, #1812	@ 0x714
 80288d6:	fb03 f202 	mul.w	r2, r3, r2
 80288da:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80288de:	1ad3      	subs	r3, r2, r3
 80288e0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80288e4:	4413      	add	r3, r2
 80288e6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 80288ea:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80288ee:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 80288f2:	fb02 f303 	mul.w	r3, r2, r3
 80288f6:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 80288fa:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80288fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8028902:	1ad2      	subs	r2, r2, r3
 8028904:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028908:	031b      	lsls	r3, r3, #12
 802890a:	1ad3      	subs	r3, r2, r3
 802890c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 8028910:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8028914:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028918:	1ad2      	subs	r2, r2, r3
 802891a:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802891e:	1ad3      	subs	r3, r2, r3
 8028920:	009b      	lsls	r3, r3, #2
 8028922:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 8028926:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802892a:	f642 0253 	movw	r2, #10323	@ 0x2853
 802892e:	fb03 f202 	mul.w	r2, r3, r2
 8028932:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028936:	1ad2      	subs	r2, r2, r3
 8028938:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802893c:	1ad3      	subs	r3, r2, r3
 802893e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8028942:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8028946:	f241 428c 	movw	r2, #5260	@ 0x148c
 802894a:	fb03 f202 	mul.w	r2, r3, r2
 802894e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028952:	1ad3      	subs	r3, r2, r3
 8028954:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8028958:	4413      	add	r3, r2
 802895a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 802895e:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028962:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8028966:	4413      	add	r3, r2
 8028968:	12da      	asrs	r2, r3, #11
 802896a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802896e:	601a      	str	r2, [r3, #0]
    wsptr[5*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8028970:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028974:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8028978:	1ad2      	subs	r2, r2, r3
 802897a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802897e:	33b4      	adds	r3, #180	@ 0xb4
 8028980:	12d2      	asrs	r2, r2, #11
 8028982:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8028984:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028988:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802898c:	441a      	add	r2, r3
 802898e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028992:	3314      	adds	r3, #20
 8028994:	12d2      	asrs	r2, r2, #11
 8028996:	601a      	str	r2, [r3, #0]
    wsptr[5*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8028998:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 802899c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80289a0:	1ad2      	subs	r2, r2, r3
 80289a2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80289a6:	33a0      	adds	r3, #160	@ 0xa0
 80289a8:	12d2      	asrs	r2, r2, #11
 80289aa:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) (tmp22 + tmp12);
 80289ac:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80289b0:	3328      	adds	r3, #40	@ 0x28
 80289b2:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 80289b6:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80289ba:	440a      	add	r2, r1
 80289bc:	601a      	str	r2, [r3, #0]
    wsptr[5*7] = (int) (tmp22 - tmp12);
 80289be:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80289c2:	338c      	adds	r3, #140	@ 0x8c
 80289c4:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 80289c8:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80289cc:	1a8a      	subs	r2, r1, r2
 80289ce:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 80289d0:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80289d4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80289d8:	441a      	add	r2, r3
 80289da:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80289de:	333c      	adds	r3, #60	@ 0x3c
 80289e0:	12d2      	asrs	r2, r2, #11
 80289e2:	601a      	str	r2, [r3, #0]
    wsptr[5*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 80289e4:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80289e8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80289ec:	1ad2      	subs	r2, r2, r3
 80289ee:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80289f2:	3378      	adds	r3, #120	@ 0x78
 80289f4:	12d2      	asrs	r2, r2, #11
 80289f6:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 80289f8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 80289fc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028a00:	441a      	add	r2, r3
 8028a02:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028a06:	3350      	adds	r3, #80	@ 0x50
 8028a08:	12d2      	asrs	r2, r2, #11
 8028a0a:	601a      	str	r2, [r3, #0]
    wsptr[5*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8028a0c:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8028a10:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028a14:	1ad2      	subs	r2, r2, r3
 8028a16:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028a1a:	3364      	adds	r3, #100	@ 0x64
 8028a1c:	12d2      	asrs	r2, r2, #11
 8028a1e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8028a20:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8028a24:	3301      	adds	r3, #1
 8028a26:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8028a2a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8028a2e:	3302      	adds	r3, #2
 8028a30:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 8028a34:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8028a38:	3304      	adds	r3, #4
 8028a3a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 8028a3e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028a42:	3304      	adds	r3, #4
 8028a44:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 8028a48:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8028a4c:	2b04      	cmp	r3, #4
 8028a4e:	f77f ae27 	ble.w	80286a0 <jpeg_idct_5x10+0x70>
  }

  /* Pass 2: process 10 rows from work array, store into output array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  wsptr = workspace;
 8028a52:	f107 0314 	add.w	r3, r7, #20
 8028a56:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 8028a5a:	2300      	movs	r3, #0
 8028a5c:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8028a60:	e0dd      	b.n	8028c1e <jpeg_idct_5x10+0x5ee>
 8028a62:	bf00      	nop
 8028a64:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 8028a68:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8028a6c:	009b      	lsls	r3, r3, #2
 8028a6e:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 8028a72:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 8028a76:	6812      	ldr	r2, [r2, #0]
 8028a78:	4413      	add	r3, r2
 8028a7a:	681a      	ldr	r2, [r3, #0]
 8028a7c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8028a80:	4413      	add	r3, r2
 8028a82:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8028a86:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028a8a:	681b      	ldr	r3, [r3, #0]
 8028a8c:	3310      	adds	r3, #16
 8028a8e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp12 <<= CONST_BITS;
 8028a92:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8028a96:	035b      	lsls	r3, r3, #13
 8028a98:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp13 = (INT32) wsptr[2];
 8028a9c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028aa0:	3308      	adds	r3, #8
 8028aa2:	681b      	ldr	r3, [r3, #0]
 8028aa4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp14 = (INT32) wsptr[4];
 8028aa8:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028aac:	3310      	adds	r3, #16
 8028aae:	681b      	ldr	r3, [r3, #0]
 8028ab0:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 8028ab4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8028ab8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028abc:	4413      	add	r3, r2
 8028abe:	f641 124c 	movw	r2, #6476	@ 0x194c
 8028ac2:	fb02 f303 	mul.w	r3, r2, r3
 8028ac6:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 8028aca:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8028ace:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028ad2:	1ad3      	subs	r3, r2, r3
 8028ad4:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8028ad8:	fb02 f303 	mul.w	r3, r2, r3
 8028adc:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = tmp12 + z2;
 8028ae0:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028ae4:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028ae8:	4413      	add	r3, r2
 8028aea:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = z3 + z1;
 8028aee:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8028af2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8028af6:	4413      	add	r3, r2
 8028af8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp11 = z3 - z1;
 8028afc:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8028b00:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8028b04:	1ad3      	subs	r3, r2, r3
 8028b06:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp12 -= z2 << 2;
 8028b0a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028b0e:	009b      	lsls	r3, r3, #2
 8028b10:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028b14:	1ad3      	subs	r3, r2, r3
 8028b16:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    /* Odd part */

    z2 = (INT32) wsptr[1];
 8028b1a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028b1e:	3304      	adds	r3, #4
 8028b20:	681b      	ldr	r3, [r3, #0]
 8028b22:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = (INT32) wsptr[3];
 8028b26:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028b2a:	330c      	adds	r3, #12
 8028b2c:	681b      	ldr	r3, [r3, #0]
 8028b2e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 8028b32:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8028b36:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8028b3a:	4413      	add	r3, r2
 8028b3c:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8028b40:	fb02 f303 	mul.w	r3, r2, r3
 8028b44:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 8028b48:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8028b4c:	f241 0271 	movw	r2, #4209	@ 0x1071
 8028b50:	fb02 f303 	mul.w	r3, r2, r3
 8028b54:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8028b58:	4413      	add	r3, r2
 8028b5a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 8028b5e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8028b62:	4a35      	ldr	r2, [pc, #212]	@ (8028c38 <jpeg_idct_5x10+0x608>)
 8028b64:	fb02 f303 	mul.w	r3, r2, r3
 8028b68:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8028b6c:	4413      	add	r3, r2
 8028b6e:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 8028b72:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8028b76:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028b7a:	4413      	add	r3, r2
 8028b7c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 8028b82:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8028b86:	4413      	add	r3, r2
 8028b88:	781a      	ldrb	r2, [r3, #0]
 8028b8a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028b8e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 8028b90:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8028b94:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028b98:	1ad3      	subs	r3, r2, r3
 8028b9a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 8028ba0:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8028ba4:	441a      	add	r2, r3
 8028ba6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028baa:	3304      	adds	r3, #4
 8028bac:	7812      	ldrb	r2, [r2, #0]
 8028bae:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 8028bb0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8028bb4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028bb8:	4413      	add	r3, r2
 8028bba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028bbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 8028bc0:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8028bc4:	441a      	add	r2, r3
 8028bc6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028bca:	3301      	adds	r3, #1
 8028bcc:	7812      	ldrb	r2, [r2, #0]
 8028bce:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 8028bd0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8028bd4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8028bd8:	1ad3      	subs	r3, r2, r3
 8028bda:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028bdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 8028be0:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8028be4:	441a      	add	r2, r3
 8028be6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028bea:	3303      	adds	r3, #3
 8028bec:	7812      	ldrb	r2, [r2, #0]
 8028bee:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8028bf0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8028bf4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028bf6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8028bfa:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8028bfe:	441a      	add	r2, r3
 8028c00:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028c04:	3302      	adds	r3, #2
 8028c06:	7812      	ldrb	r2, [r2, #0]
 8028c08:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 8028c0a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8028c0e:	3314      	adds	r3, #20
 8028c10:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 8028c14:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8028c18:	3301      	adds	r3, #1
 8028c1a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8028c1e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8028c22:	2b09      	cmp	r3, #9
 8028c24:	f77f af20 	ble.w	8028a68 <jpeg_idct_5x10+0x438>
  }
}
 8028c28:	bf00      	nop
 8028c2a:	bf00      	nop
 8028c2c:	f507 7798 	add.w	r7, r7, #304	@ 0x130
 8028c30:	46bd      	mov	sp, r7
 8028c32:	bc90      	pop	{r4, r7}
 8028c34:	4770      	bx	lr
 8028c36:	bf00      	nop
 8028c38:	ffffba5c 	.word	0xffffba5c

08028c3c <jpeg_idct_4x8>:

GLOBAL(void)
jpeg_idct_4x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8028c3c:	b480      	push	{r7}
 8028c3e:	b0b7      	sub	sp, #220	@ 0xdc
 8028c40:	af00      	add	r7, sp, #0
 8028c42:	60f8      	str	r0, [r7, #12]
 8028c44:	60b9      	str	r1, [r7, #8]
 8028c46:	607a      	str	r2, [r7, #4]
 8028c48:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8028c4a:	68fb      	ldr	r3, [r7, #12]
 8028c4c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8028c50:	3380      	adds	r3, #128	@ 0x80
 8028c52:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 8028c56:	687b      	ldr	r3, [r7, #4]
 8028c58:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8028c5c:	68bb      	ldr	r3, [r7, #8]
 8028c5e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8028c60:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  wsptr = workspace;
 8028c64:	f107 0310 	add.w	r3, r7, #16
 8028c68:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 8028c6c:	2304      	movs	r3, #4
 8028c6e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8028c72:	e238      	b.n	80290e6 <jpeg_idct_4x8+0x4aa>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8028c74:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028c78:	3310      	adds	r3, #16
 8028c7a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028c7e:	2b00      	cmp	r3, #0
 8028c80:	d175      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
 8028c82:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028c86:	3320      	adds	r3, #32
 8028c88:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028c8c:	2b00      	cmp	r3, #0
 8028c8e:	d16e      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8028c90:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028c94:	3330      	adds	r3, #48	@ 0x30
 8028c96:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8028c9a:	2b00      	cmp	r3, #0
 8028c9c:	d167      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8028c9e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028ca2:	3340      	adds	r3, #64	@ 0x40
 8028ca4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028ca8:	2b00      	cmp	r3, #0
 8028caa:	d160      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8028cac:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028cb0:	3350      	adds	r3, #80	@ 0x50
 8028cb2:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8028cb6:	2b00      	cmp	r3, #0
 8028cb8:	d159      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8028cba:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028cbe:	3360      	adds	r3, #96	@ 0x60
 8028cc0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028cc4:	2b00      	cmp	r3, #0
 8028cc6:	d152      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*7] == 0) {
 8028cc8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028ccc:	3370      	adds	r3, #112	@ 0x70
 8028cce:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8028cd2:	2b00      	cmp	r3, #0
 8028cd4:	d14b      	bne.n	8028d6e <jpeg_idct_4x8+0x132>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 8028cd6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028cda:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028cde:	461a      	mov	r2, r3
 8028ce0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028ce4:	681b      	ldr	r3, [r3, #0]
 8028ce6:	fb02 f303 	mul.w	r3, r2, r3
 8028cea:	009b      	lsls	r3, r3, #2
 8028cec:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0

      wsptr[4*0] = dcval;
 8028cf0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028cf4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028cf8:	601a      	str	r2, [r3, #0]
      wsptr[4*1] = dcval;
 8028cfa:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028cfe:	3310      	adds	r3, #16
 8028d00:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d04:	601a      	str	r2, [r3, #0]
      wsptr[4*2] = dcval;
 8028d06:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d0a:	3320      	adds	r3, #32
 8028d0c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d10:	601a      	str	r2, [r3, #0]
      wsptr[4*3] = dcval;
 8028d12:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d16:	3330      	adds	r3, #48	@ 0x30
 8028d18:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d1c:	601a      	str	r2, [r3, #0]
      wsptr[4*4] = dcval;
 8028d1e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d22:	3340      	adds	r3, #64	@ 0x40
 8028d24:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d28:	601a      	str	r2, [r3, #0]
      wsptr[4*5] = dcval;
 8028d2a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d2e:	3350      	adds	r3, #80	@ 0x50
 8028d30:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d34:	601a      	str	r2, [r3, #0]
      wsptr[4*6] = dcval;
 8028d36:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d3a:	3360      	adds	r3, #96	@ 0x60
 8028d3c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d40:	601a      	str	r2, [r3, #0]
      wsptr[4*7] = dcval;
 8028d42:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d46:	3370      	adds	r3, #112	@ 0x70
 8028d48:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028d4c:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 8028d4e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028d52:	3302      	adds	r3, #2
 8028d54:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      quantptr++;
 8028d58:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028d5c:	3304      	adds	r3, #4
 8028d5e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
      wsptr++;
 8028d62:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028d66:	3304      	adds	r3, #4
 8028d68:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
      continue;
 8028d6c:	e1b6      	b.n	80290dc <jpeg_idct_4x8+0x4a0>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8028d6e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028d72:	3320      	adds	r3, #32
 8028d74:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028d78:	461a      	mov	r2, r3
 8028d7a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028d7e:	3340      	adds	r3, #64	@ 0x40
 8028d80:	681b      	ldr	r3, [r3, #0]
 8028d82:	fb02 f303 	mul.w	r3, r2, r3
 8028d86:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8028d8a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028d8e:	3360      	adds	r3, #96	@ 0x60
 8028d90:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028d94:	461a      	mov	r2, r3
 8028d96:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028d9a:	33c0      	adds	r3, #192	@ 0xc0
 8028d9c:	681b      	ldr	r3, [r3, #0]
 8028d9e:	fb02 f303 	mul.w	r3, r2, r3
 8028da2:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8028da6:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028daa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028dae:	4413      	add	r3, r2
 8028db0:	f241 1251 	movw	r2, #4433	@ 0x1151
 8028db4:	fb02 f303 	mul.w	r3, r2, r3
 8028db8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 8028dbc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028dc0:	f641 027e 	movw	r2, #6270	@ 0x187e
 8028dc4:	fb02 f303 	mul.w	r3, r2, r3
 8028dc8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028dcc:	4413      	add	r3, r2
 8028dce:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 8028dd2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028dd6:	4aca      	ldr	r2, [pc, #808]	@ (8029100 <jpeg_idct_4x8+0x4c4>)
 8028dd8:	fb02 f303 	mul.w	r3, r2, r3
 8028ddc:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028de0:	4413      	add	r3, r2
 8028de2:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8028de6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028dea:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028dee:	461a      	mov	r2, r3
 8028df0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028df4:	681b      	ldr	r3, [r3, #0]
 8028df6:	fb02 f303 	mul.w	r3, r2, r3
 8028dfa:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8028dfe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028e02:	3340      	adds	r3, #64	@ 0x40
 8028e04:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028e08:	461a      	mov	r2, r3
 8028e0a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028e0e:	3380      	adds	r3, #128	@ 0x80
 8028e10:	681b      	ldr	r3, [r3, #0]
 8028e12:	fb02 f303 	mul.w	r3, r2, r3
 8028e16:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z2 <<= CONST_BITS;
 8028e1a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028e1e:	035b      	lsls	r3, r3, #13
 8028e20:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 <<= CONST_BITS;
 8028e24:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028e28:	035b      	lsls	r3, r3, #13
 8028e2a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 8028e2e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028e32:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8028e36:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    tmp0 = z2 + z3;
 8028e3a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028e3e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028e42:	4413      	add	r3, r2
 8028e44:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = z2 - z3;
 8028e48:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028e4c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028e50:	1ad3      	subs	r3, r2, r3
 8028e52:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    
    tmp10 = tmp0 + tmp2;
 8028e56:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028e5a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028e5e:	4413      	add	r3, r2
 8028e60:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp13 = tmp0 - tmp2;
 8028e64:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028e68:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028e6c:	1ad3      	subs	r3, r2, r3
 8028e6e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp11 = tmp1 + tmp3;
 8028e72:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028e76:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8028e7a:	4413      	add	r3, r2
 8028e7c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp12 = tmp1 - tmp3;
 8028e80:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028e84:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8028e88:	1ad3      	subs	r3, r2, r3
 8028e8a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8028e8e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028e92:	3370      	adds	r3, #112	@ 0x70
 8028e94:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028e98:	461a      	mov	r2, r3
 8028e9a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028e9e:	33e0      	adds	r3, #224	@ 0xe0
 8028ea0:	681b      	ldr	r3, [r3, #0]
 8028ea2:	fb02 f303 	mul.w	r3, r2, r3
 8028ea6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8028eaa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028eae:	3350      	adds	r3, #80	@ 0x50
 8028eb0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028eb4:	461a      	mov	r2, r3
 8028eb6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028eba:	33a0      	adds	r3, #160	@ 0xa0
 8028ebc:	681b      	ldr	r3, [r3, #0]
 8028ebe:	fb02 f303 	mul.w	r3, r2, r3
 8028ec2:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8028ec6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028eca:	3330      	adds	r3, #48	@ 0x30
 8028ecc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028ed0:	461a      	mov	r2, r3
 8028ed2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028ed6:	3360      	adds	r3, #96	@ 0x60
 8028ed8:	681b      	ldr	r3, [r3, #0]
 8028eda:	fb02 f303 	mul.w	r3, r2, r3
 8028ede:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8028ee2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028ee6:	3310      	adds	r3, #16
 8028ee8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028eec:	461a      	mov	r2, r3
 8028eee:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028ef2:	3320      	adds	r3, #32
 8028ef4:	681b      	ldr	r3, [r3, #0]
 8028ef6:	fb02 f303 	mul.w	r3, r2, r3
 8028efa:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

    z2 = tmp0 + tmp2;
 8028efe:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028f02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028f06:	4413      	add	r3, r2
 8028f08:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = tmp1 + tmp3;
 8028f0c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028f10:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8028f14:	4413      	add	r3, r2
 8028f16:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8028f1a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028f1e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028f22:	4413      	add	r3, r2
 8028f24:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 8028f28:	fb02 f303 	mul.w	r3, r2, r3
 8028f2c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 8028f30:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028f34:	4a73      	ldr	r2, [pc, #460]	@ (8029104 <jpeg_idct_4x8+0x4c8>)
 8028f36:	fb02 f303 	mul.w	r3, r2, r3
 8028f3a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 8028f3e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028f42:	4a71      	ldr	r2, [pc, #452]	@ (8029108 <jpeg_idct_4x8+0x4cc>)
 8028f44:	fb02 f303 	mul.w	r3, r2, r3
 8028f48:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z2 += z1;
 8028f4c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028f50:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8028f54:	4413      	add	r3, r2
 8028f56:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 += z1;
 8028f5a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028f5e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8028f62:	4413      	add	r3, r2
 8028f64:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 8028f68:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028f6c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8028f70:	4413      	add	r3, r2
 8028f72:	4a66      	ldr	r2, [pc, #408]	@ (802910c <jpeg_idct_4x8+0x4d0>)
 8028f74:	fb02 f303 	mul.w	r3, r2, r3
 8028f78:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8028f7c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8028f80:	f640 128e 	movw	r2, #2446	@ 0x98e
 8028f84:	fb02 f303 	mul.w	r3, r2, r3
 8028f88:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8028f8c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8028f90:	f243 020b 	movw	r2, #12299	@ 0x300b
 8028f94:	fb02 f303 	mul.w	r3, r2, r3
 8028f98:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    tmp0 += z1 + z2;
 8028f9c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028fa0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028fa4:	4413      	add	r3, r2
 8028fa6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028faa:	4413      	add	r3, r2
 8028fac:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp3 += z1 + z3;
 8028fb0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028fb4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028fb8:	4413      	add	r3, r2
 8028fba:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8028fbe:	4413      	add	r3, r2
 8028fc0:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8028fc4:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028fc8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028fcc:	4413      	add	r3, r2
 8028fce:	4a50      	ldr	r2, [pc, #320]	@ (8029110 <jpeg_idct_4x8+0x4d4>)
 8028fd0:	fb02 f303 	mul.w	r3, r2, r3
 8028fd4:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8028fd8:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8028fdc:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 8028fe0:	fb02 f303 	mul.w	r3, r2, r3
 8028fe4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8028fe8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028fec:	f246 2254 	movw	r2, #25172	@ 0x6254
 8028ff0:	fb02 f303 	mul.w	r3, r2, r3
 8028ff4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp1 += z1 + z3;
 8028ff8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028ffc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8029000:	4413      	add	r3, r2
 8029002:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8029006:	4413      	add	r3, r2
 8029008:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 += z1 + z2;
 802900c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8029010:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8029014:	4413      	add	r3, r2
 8029016:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 802901a:	4413      	add	r3, r2
 802901c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[4*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 8029020:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8029024:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8029028:	4413      	add	r3, r2
 802902a:	12da      	asrs	r2, r3, #11
 802902c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029030:	601a      	str	r2, [r3, #0]
    wsptr[4*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 8029032:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8029036:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802903a:	1ad2      	subs	r2, r2, r3
 802903c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029040:	3370      	adds	r3, #112	@ 0x70
 8029042:	12d2      	asrs	r2, r2, #11
 8029044:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 8029046:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 802904a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802904e:	441a      	add	r2, r3
 8029050:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029054:	3310      	adds	r3, #16
 8029056:	12d2      	asrs	r2, r2, #11
 8029058:	601a      	str	r2, [r3, #0]
    wsptr[4*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 802905a:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 802905e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8029062:	1ad2      	subs	r2, r2, r3
 8029064:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029068:	3360      	adds	r3, #96	@ 0x60
 802906a:	12d2      	asrs	r2, r2, #11
 802906c:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 802906e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8029072:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8029076:	441a      	add	r2, r3
 8029078:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802907c:	3320      	adds	r3, #32
 802907e:	12d2      	asrs	r2, r2, #11
 8029080:	601a      	str	r2, [r3, #0]
    wsptr[4*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 8029082:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8029086:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802908a:	1ad2      	subs	r2, r2, r3
 802908c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029090:	3350      	adds	r3, #80	@ 0x50
 8029092:	12d2      	asrs	r2, r2, #11
 8029094:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 8029096:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 802909a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802909e:	441a      	add	r2, r3
 80290a0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80290a4:	3330      	adds	r3, #48	@ 0x30
 80290a6:	12d2      	asrs	r2, r2, #11
 80290a8:	601a      	str	r2, [r3, #0]
    wsptr[4*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 80290aa:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 80290ae:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80290b2:	1ad2      	subs	r2, r2, r3
 80290b4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80290b8:	3340      	adds	r3, #64	@ 0x40
 80290ba:	12d2      	asrs	r2, r2, #11
 80290bc:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 80290be:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80290c2:	3302      	adds	r3, #2
 80290c4:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    quantptr++;
 80290c8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80290cc:	3304      	adds	r3, #4
 80290ce:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    wsptr++;
 80290d2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80290d6:	3304      	adds	r3, #4
 80290d8:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 80290dc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80290e0:	3b01      	subs	r3, #1
 80290e2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80290e6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80290ea:	2b00      	cmp	r3, #0
 80290ec:	f73f adc2 	bgt.w	8028c74 <jpeg_idct_4x8+0x38>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  wsptr = workspace;
 80290f0:	f107 0310 	add.w	r3, r7, #16
 80290f4:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 80290f8:	2300      	movs	r3, #0
 80290fa:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80290fe:	e0a5      	b.n	802924c <jpeg_idct_4x8+0x610>
 8029100:	ffffc4df 	.word	0xffffc4df
 8029104:	ffffc13b 	.word	0xffffc13b
 8029108:	fffff384 	.word	0xfffff384
 802910c:	ffffe333 	.word	0xffffe333
 8029110:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 8029114:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8029118:	009b      	lsls	r3, r3, #2
 802911a:	683a      	ldr	r2, [r7, #0]
 802911c:	4413      	add	r3, r2
 802911e:	681a      	ldr	r2, [r3, #0]
 8029120:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8029124:	4413      	add	r3, r2
 8029126:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802912a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802912e:	681b      	ldr	r3, [r3, #0]
 8029130:	3310      	adds	r3, #16
 8029132:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp2 = (INT32) wsptr[2];
 8029136:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802913a:	3308      	adds	r3, #8
 802913c:	681b      	ldr	r3, [r3, #0]
 802913e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 8029142:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8029146:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802914a:	4413      	add	r3, r2
 802914c:	035b      	lsls	r3, r3, #13
 802914e:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8029152:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8029156:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802915a:	1ad3      	subs	r3, r2, r3
 802915c:	035b      	lsls	r3, r3, #13
 802915e:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 8029162:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029166:	3304      	adds	r3, #4
 8029168:	681b      	ldr	r3, [r3, #0]
 802916a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = (INT32) wsptr[3];
 802916e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8029172:	330c      	adds	r3, #12
 8029174:	681b      	ldr	r3, [r3, #0]
 8029176:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 802917a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802917e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8029182:	4413      	add	r3, r2
 8029184:	f241 1251 	movw	r2, #4433	@ 0x1151
 8029188:	fb02 f303 	mul.w	r3, r2, r3
 802918c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8029190:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8029194:	f641 027e 	movw	r2, #6270	@ 0x187e
 8029198:	fb02 f303 	mul.w	r3, r2, r3
 802919c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80291a0:	4413      	add	r3, r2
 80291a2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 80291a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80291aa:	4a2e      	ldr	r2, [pc, #184]	@ (8029264 <jpeg_idct_4x8+0x628>)
 80291ac:	fb02 f303 	mul.w	r3, r2, r3
 80291b0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80291b4:	4413      	add	r3, r2
 80291b6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80291ba:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80291be:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80291c2:	4413      	add	r3, r2
 80291c4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80291c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80291ca:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80291ce:	4413      	add	r3, r2
 80291d0:	781a      	ldrb	r2, [r3, #0]
 80291d2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80291d6:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80291d8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80291dc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80291e0:	1ad3      	subs	r3, r2, r3
 80291e2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80291e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80291e8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80291ec:	441a      	add	r2, r3
 80291ee:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80291f2:	3303      	adds	r3, #3
 80291f4:	7812      	ldrb	r2, [r2, #0]
 80291f6:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 80291f8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80291fc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8029200:	4413      	add	r3, r2
 8029202:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029204:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8029208:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802920c:	441a      	add	r2, r3
 802920e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8029212:	3301      	adds	r3, #1
 8029214:	7812      	ldrb	r2, [r2, #0]
 8029216:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8029218:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802921c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8029220:	1ad3      	subs	r3, r2, r3
 8029222:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029224:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8029228:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802922c:	441a      	add	r2, r3
 802922e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8029232:	3302      	adds	r3, #2
 8029234:	7812      	ldrb	r2, [r2, #0]
 8029236:	701a      	strb	r2, [r3, #0]
    
    wsptr += 4;		/* advance pointer to next row */
 8029238:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802923c:	3310      	adds	r3, #16
 802923e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 8029242:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8029246:	3301      	adds	r3, #1
 8029248:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802924c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8029250:	2b07      	cmp	r3, #7
 8029252:	f77f af5f 	ble.w	8029114 <jpeg_idct_4x8+0x4d8>
  }
}
 8029256:	bf00      	nop
 8029258:	bf00      	nop
 802925a:	37dc      	adds	r7, #220	@ 0xdc
 802925c:	46bd      	mov	sp, r7
 802925e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029262:	4770      	bx	lr
 8029264:	ffffc4df 	.word	0xffffc4df

08029268 <jpeg_idct_3x6>:

GLOBAL(void)
jpeg_idct_3x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8029268:	b480      	push	{r7}
 802926a:	b0a7      	sub	sp, #156	@ 0x9c
 802926c:	af00      	add	r7, sp, #0
 802926e:	60f8      	str	r0, [r7, #12]
 8029270:	60b9      	str	r1, [r7, #8]
 8029272:	607a      	str	r2, [r7, #4]
 8029274:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8029276:	68fb      	ldr	r3, [r7, #12]
 8029278:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802927c:	3380      	adds	r3, #128	@ 0x80
 802927e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 8029282:	687b      	ldr	r3, [r7, #4]
 8029284:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8029288:	68bb      	ldr	r3, [r7, #8]
 802928a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802928c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  wsptr = workspace;
 8029290:	f107 0314 	add.w	r3, r7, #20
 8029294:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 8029298:	2300      	movs	r3, #0
 802929a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802929e:	e0cf      	b.n	8029440 <jpeg_idct_3x6+0x1d8>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80292a0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80292a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80292a8:	461a      	mov	r2, r3
 80292aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80292ae:	681b      	ldr	r3, [r3, #0]
 80292b0:	fb02 f303 	mul.w	r3, r2, r3
 80292b4:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 80292b6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80292b8:	035b      	lsls	r3, r3, #13
 80292ba:	67fb      	str	r3, [r7, #124]	@ 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 80292bc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80292be:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80292c2:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80292c4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80292c8:	3340      	adds	r3, #64	@ 0x40
 80292ca:	f9b3 3000 	ldrsh.w	r3, [r3]
 80292ce:	461a      	mov	r2, r3
 80292d0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80292d4:	3380      	adds	r3, #128	@ 0x80
 80292d6:	681b      	ldr	r3, [r3, #0]
 80292d8:	fb02 f303 	mul.w	r3, r2, r3
 80292dc:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 80292de:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80292e0:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 80292e4:	fb02 f303 	mul.w	r3, r2, r3
 80292e8:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp1 = tmp0 + tmp10;
 80292ea:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80292ec:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80292ee:	4413      	add	r3, r2
 80292f0:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 80292f2:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80292f4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80292f6:	1ad2      	subs	r2, r2, r3
 80292f8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80292fa:	1ad3      	subs	r3, r2, r3
 80292fc:	12db      	asrs	r3, r3, #11
 80292fe:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8029300:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8029304:	3320      	adds	r3, #32
 8029306:	f9b3 3000 	ldrsh.w	r3, [r3]
 802930a:	461a      	mov	r2, r3
 802930c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8029310:	3340      	adds	r3, #64	@ 0x40
 8029312:	681b      	ldr	r3, [r3, #0]
 8029314:	fb02 f303 	mul.w	r3, r2, r3
 8029318:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 802931a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802931c:	f242 7231 	movw	r2, #10033	@ 0x2731
 8029320:	fb02 f303 	mul.w	r3, r2, r3
 8029324:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp10 = tmp1 + tmp0;
 8029326:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8029328:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802932a:	4413      	add	r3, r2
 802932c:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp12 = tmp1 - tmp0;
 802932e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8029330:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8029332:	1ad3      	subs	r3, r2, r3
 8029334:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8029336:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802933a:	3310      	adds	r3, #16
 802933c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029340:	461a      	mov	r2, r3
 8029342:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8029346:	3320      	adds	r3, #32
 8029348:	681b      	ldr	r3, [r3, #0]
 802934a:	fb02 f303 	mul.w	r3, r2, r3
 802934e:	667b      	str	r3, [r7, #100]	@ 0x64
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8029350:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8029354:	3330      	adds	r3, #48	@ 0x30
 8029356:	f9b3 3000 	ldrsh.w	r3, [r3]
 802935a:	461a      	mov	r2, r3
 802935c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8029360:	3360      	adds	r3, #96	@ 0x60
 8029362:	681b      	ldr	r3, [r3, #0]
 8029364:	fb02 f303 	mul.w	r3, r2, r3
 8029368:	663b      	str	r3, [r7, #96]	@ 0x60
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802936a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802936e:	3350      	adds	r3, #80	@ 0x50
 8029370:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029374:	461a      	mov	r2, r3
 8029376:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802937a:	33a0      	adds	r3, #160	@ 0xa0
 802937c:	681b      	ldr	r3, [r3, #0]
 802937e:	fb02 f303 	mul.w	r3, r2, r3
 8029382:	65fb      	str	r3, [r7, #92]	@ 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8029384:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8029386:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029388:	4413      	add	r3, r2
 802938a:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 802938e:	fb02 f303 	mul.w	r3, r2, r3
 8029392:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 8029394:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8029396:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8029398:	4413      	add	r3, r2
 802939a:	035b      	lsls	r3, r3, #13
 802939c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802939e:	4413      	add	r3, r2
 80293a0:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 80293a2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80293a4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80293a6:	1ad3      	subs	r3, r2, r3
 80293a8:	035b      	lsls	r3, r3, #13
 80293aa:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80293ac:	4413      	add	r3, r2
 80293ae:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 80293b0:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80293b2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80293b4:	1ad2      	subs	r2, r2, r3
 80293b6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80293b8:	1ad3      	subs	r3, r2, r3
 80293ba:	009b      	lsls	r3, r3, #2
 80293bc:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 80293be:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80293c0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80293c2:	4413      	add	r3, r2
 80293c4:	12da      	asrs	r2, r3, #11
 80293c6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80293ca:	601a      	str	r2, [r3, #0]
    wsptr[3*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 80293cc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80293ce:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80293d0:	1ad2      	subs	r2, r2, r3
 80293d2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80293d6:	333c      	adds	r3, #60	@ 0x3c
 80293d8:	12d2      	asrs	r2, r2, #11
 80293da:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) (tmp11 + tmp1);
 80293dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80293e0:	330c      	adds	r3, #12
 80293e2:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80293e4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80293e6:	440a      	add	r2, r1
 80293e8:	601a      	str	r2, [r3, #0]
    wsptr[3*4] = (int) (tmp11 - tmp1);
 80293ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80293ee:	3330      	adds	r3, #48	@ 0x30
 80293f0:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80293f2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80293f4:	1a8a      	subs	r2, r1, r2
 80293f6:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 80293f8:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80293fa:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80293fc:	441a      	add	r2, r3
 80293fe:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8029402:	3318      	adds	r3, #24
 8029404:	12d2      	asrs	r2, r2, #11
 8029406:	601a      	str	r2, [r3, #0]
    wsptr[3*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 8029408:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802940a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802940c:	1ad2      	subs	r2, r2, r3
 802940e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8029412:	3324      	adds	r3, #36	@ 0x24
 8029414:	12d2      	asrs	r2, r2, #11
 8029416:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 8029418:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802941c:	3301      	adds	r3, #1
 802941e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8029422:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8029426:	3302      	adds	r3, #2
 8029428:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 802942c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8029430:	3304      	adds	r3, #4
 8029432:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8029436:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802943a:	3304      	adds	r3, #4
 802943c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8029440:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8029444:	2b02      	cmp	r3, #2
 8029446:	f77f af2b 	ble.w	80292a0 <jpeg_idct_3x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  wsptr = workspace;
 802944a:	f107 0314 	add.w	r3, r7, #20
 802944e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 8029452:	2300      	movs	r3, #0
 8029454:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8029458:	e063      	b.n	8029522 <jpeg_idct_3x6+0x2ba>
    outptr = output_buf[ctr] + output_col;
 802945a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802945e:	009b      	lsls	r3, r3, #2
 8029460:	683a      	ldr	r2, [r7, #0]
 8029462:	4413      	add	r3, r2
 8029464:	681a      	ldr	r2, [r3, #0]
 8029466:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 802946a:	4413      	add	r3, r2
 802946c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8029470:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8029474:	681b      	ldr	r3, [r3, #0]
 8029476:	3310      	adds	r3, #16
 8029478:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 802947a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802947c:	035b      	lsls	r3, r3, #13
 802947e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = (INT32) wsptr[2];
 8029480:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8029484:	3308      	adds	r3, #8
 8029486:	681b      	ldr	r3, [r3, #0]
 8029488:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802948a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802948c:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8029490:	fb02 f303 	mul.w	r3, r2, r3
 8029494:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp10 = tmp0 + tmp12;
 8029496:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8029498:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802949a:	4413      	add	r3, r2
 802949c:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp2 = tmp0 - tmp12 - tmp12;
 802949e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80294a0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80294a2:	1ad2      	subs	r2, r2, r3
 80294a4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80294a6:	1ad3      	subs	r3, r2, r3
 80294a8:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 80294aa:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80294ae:	3304      	adds	r3, #4
 80294b0:	681b      	ldr	r3, [r3, #0]
 80294b2:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 80294b4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80294b6:	f242 7231 	movw	r2, #10033	@ 0x2731
 80294ba:	fb02 f303 	mul.w	r3, r2, r3
 80294be:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80294c0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80294c2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80294c4:	4413      	add	r3, r2
 80294c6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80294c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80294cc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 80294d0:	4413      	add	r3, r2
 80294d2:	781a      	ldrb	r2, [r3, #0]
 80294d4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80294d8:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80294da:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80294dc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80294de:	1ad3      	subs	r3, r2, r3
 80294e0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80294e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80294e6:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 80294ea:	441a      	add	r2, r3
 80294ec:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80294f0:	3302      	adds	r3, #2
 80294f2:	7812      	ldrb	r2, [r2, #0]
 80294f4:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 80294f6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80294f8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80294fa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 80294fe:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8029502:	441a      	add	r2, r3
 8029504:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8029508:	3301      	adds	r3, #1
 802950a:	7812      	ldrb	r2, [r2, #0]
 802950c:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 802950e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8029512:	330c      	adds	r3, #12
 8029514:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 8029518:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802951c:	3301      	adds	r3, #1
 802951e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8029522:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8029526:	2b05      	cmp	r3, #5
 8029528:	dd97      	ble.n	802945a <jpeg_idct_3x6+0x1f2>
  }
}
 802952a:	bf00      	nop
 802952c:	bf00      	nop
 802952e:	379c      	adds	r7, #156	@ 0x9c
 8029530:	46bd      	mov	sp, r7
 8029532:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029536:	4770      	bx	lr

08029538 <jpeg_idct_2x4>:

GLOBAL(void)
jpeg_idct_2x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8029538:	b480      	push	{r7}
 802953a:	b09b      	sub	sp, #108	@ 0x6c
 802953c:	af00      	add	r7, sp, #0
 802953e:	60f8      	str	r0, [r7, #12]
 8029540:	60b9      	str	r1, [r7, #8]
 8029542:	607a      	str	r2, [r7, #4]
 8029544:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8029546:	68fb      	ldr	r3, [r7, #12]
 8029548:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802954c:	3380      	adds	r3, #128	@ 0x80
 802954e:	657b      	str	r3, [r7, #84]	@ 0x54

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  inptr = coef_block;
 8029550:	687b      	ldr	r3, [r7, #4]
 8029552:	667b      	str	r3, [r7, #100]	@ 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8029554:	68bb      	ldr	r3, [r7, #8]
 8029556:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8029558:	663b      	str	r3, [r7, #96]	@ 0x60
  wsptr = workspace;
 802955a:	f107 0314 	add.w	r3, r7, #20
 802955e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 8029560:	2300      	movs	r3, #0
 8029562:	65bb      	str	r3, [r7, #88]	@ 0x58
 8029564:	e06d      	b.n	8029642 <jpeg_idct_2x4+0x10a>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8029566:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8029568:	f9b3 3000 	ldrsh.w	r3, [r3]
 802956c:	461a      	mov	r2, r3
 802956e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8029570:	681b      	ldr	r3, [r3, #0]
 8029572:	fb02 f303 	mul.w	r3, r2, r3
 8029576:	64bb      	str	r3, [r7, #72]	@ 0x48
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8029578:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802957a:	3320      	adds	r3, #32
 802957c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029580:	461a      	mov	r2, r3
 8029582:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8029584:	3340      	adds	r3, #64	@ 0x40
 8029586:	681b      	ldr	r3, [r3, #0]
 8029588:	fb02 f303 	mul.w	r3, r2, r3
 802958c:	647b      	str	r3, [r7, #68]	@ 0x44

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 802958e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8029590:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8029592:	4413      	add	r3, r2
 8029594:	035b      	lsls	r3, r3, #13
 8029596:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8029598:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802959a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802959c:	1ad3      	subs	r3, r2, r3
 802959e:	035b      	lsls	r3, r3, #13
 80295a0:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80295a2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80295a4:	3310      	adds	r3, #16
 80295a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80295aa:	461a      	mov	r2, r3
 80295ac:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80295ae:	3320      	adds	r3, #32
 80295b0:	681b      	ldr	r3, [r3, #0]
 80295b2:	fb02 f303 	mul.w	r3, r2, r3
 80295b6:	63fb      	str	r3, [r7, #60]	@ 0x3c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80295b8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80295ba:	3330      	adds	r3, #48	@ 0x30
 80295bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80295c0:	461a      	mov	r2, r3
 80295c2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80295c4:	3360      	adds	r3, #96	@ 0x60
 80295c6:	681b      	ldr	r3, [r3, #0]
 80295c8:	fb02 f303 	mul.w	r3, r2, r3
 80295cc:	63bb      	str	r3, [r7, #56]	@ 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 80295ce:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80295d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80295d2:	4413      	add	r3, r2
 80295d4:	f241 1251 	movw	r2, #4433	@ 0x1151
 80295d8:	fb02 f303 	mul.w	r3, r2, r3
 80295dc:	637b      	str	r3, [r7, #52]	@ 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 80295de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80295e0:	f641 027e 	movw	r2, #6270	@ 0x187e
 80295e4:	fb02 f303 	mul.w	r3, r2, r3
 80295e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80295ea:	4413      	add	r3, r2
 80295ec:	64bb      	str	r3, [r7, #72]	@ 0x48
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 80295ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80295f0:	4a34      	ldr	r2, [pc, #208]	@ (80296c4 <jpeg_idct_2x4+0x18c>)
 80295f2:	fb02 f303 	mul.w	r3, r2, r3
 80295f6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80295f8:	4413      	add	r3, r2
 80295fa:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    wsptr[2*0] = tmp10 + tmp0;
 80295fc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80295fe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8029600:	441a      	add	r2, r3
 8029602:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029604:	601a      	str	r2, [r3, #0]
    wsptr[2*3] = tmp10 - tmp0;
 8029606:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029608:	3318      	adds	r3, #24
 802960a:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 802960c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802960e:	1a8a      	subs	r2, r1, r2
 8029610:	601a      	str	r2, [r3, #0]
    wsptr[2*1] = tmp12 + tmp2;
 8029612:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029614:	3308      	adds	r3, #8
 8029616:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8029618:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802961a:	440a      	add	r2, r1
 802961c:	601a      	str	r2, [r3, #0]
    wsptr[2*2] = tmp12 - tmp2;
 802961e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029620:	3310      	adds	r3, #16
 8029622:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8029624:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8029626:	1a8a      	subs	r2, r1, r2
 8029628:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 802962a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802962c:	3301      	adds	r3, #1
 802962e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8029630:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8029632:	3302      	adds	r3, #2
 8029634:	667b      	str	r3, [r7, #100]	@ 0x64
 8029636:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8029638:	3304      	adds	r3, #4
 802963a:	663b      	str	r3, [r7, #96]	@ 0x60
 802963c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802963e:	3304      	adds	r3, #4
 8029640:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8029642:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8029644:	2b01      	cmp	r3, #1
 8029646:	dd8e      	ble.n	8029566 <jpeg_idct_2x4+0x2e>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 8029648:	f107 0314 	add.w	r3, r7, #20
 802964c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 802964e:	2300      	movs	r3, #0
 8029650:	65bb      	str	r3, [r7, #88]	@ 0x58
 8029652:	e02c      	b.n	80296ae <jpeg_idct_2x4+0x176>
    outptr = output_buf[ctr] + output_col;
 8029654:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8029656:	009b      	lsls	r3, r3, #2
 8029658:	683a      	ldr	r2, [r7, #0]
 802965a:	4413      	add	r3, r2
 802965c:	681a      	ldr	r2, [r3, #0]
 802965e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8029660:	4413      	add	r3, r2
 8029662:	653b      	str	r3, [r7, #80]	@ 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = wsptr[0] + (ONE << (CONST_BITS+2));
 8029664:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029666:	681b      	ldr	r3, [r3, #0]
 8029668:	f503 4300 	add.w	r3, r3, #32768	@ 0x8000
 802966c:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Odd part */

    tmp0 = wsptr[1];
 802966e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8029670:	685b      	ldr	r3, [r3, #4]
 8029672:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 8029674:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8029676:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8029678:	4413      	add	r3, r2
 802967a:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 802967c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 8029680:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8029682:	4413      	add	r3, r2
 8029684:	781a      	ldrb	r2, [r3, #0]
 8029686:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8029688:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 802968a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802968c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802968e:	1ad3      	subs	r3, r2, r3
 8029690:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 8029692:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 8029696:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8029698:	441a      	add	r2, r3
 802969a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802969c:	3301      	adds	r3, #1
 802969e:	7812      	ldrb	r2, [r2, #0]
 80296a0:	701a      	strb	r2, [r3, #0]

    wsptr += 2;		/* advance pointer to next row */
 80296a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80296a4:	3308      	adds	r3, #8
 80296a6:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 80296a8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80296aa:	3301      	adds	r3, #1
 80296ac:	65bb      	str	r3, [r7, #88]	@ 0x58
 80296ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80296b0:	2b03      	cmp	r3, #3
 80296b2:	ddcf      	ble.n	8029654 <jpeg_idct_2x4+0x11c>
  }
}
 80296b4:	bf00      	nop
 80296b6:	bf00      	nop
 80296b8:	376c      	adds	r7, #108	@ 0x6c
 80296ba:	46bd      	mov	sp, r7
 80296bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80296c0:	4770      	bx	lr
 80296c2:	bf00      	nop
 80296c4:	ffffc4df 	.word	0xffffc4df

080296c8 <jpeg_idct_1x2>:

GLOBAL(void)
jpeg_idct_1x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80296c8:	b480      	push	{r7}
 80296ca:	b089      	sub	sp, #36	@ 0x24
 80296cc:	af00      	add	r7, sp, #0
 80296ce:	60f8      	str	r0, [r7, #12]
 80296d0:	60b9      	str	r1, [r7, #8]
 80296d2:	607a      	str	r2, [r7, #4]
 80296d4:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80296d6:	68fb      	ldr	r3, [r7, #12]
 80296d8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80296dc:	3380      	adds	r3, #128	@ 0x80
 80296de:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* Process 1 column from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80296e0:	68bb      	ldr	r3, [r7, #8]
 80296e2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80296e4:	61bb      	str	r3, [r7, #24]

  /* Even part */
    
  tmp10 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80296e6:	687b      	ldr	r3, [r7, #4]
 80296e8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80296ec:	461a      	mov	r2, r3
 80296ee:	69bb      	ldr	r3, [r7, #24]
 80296f0:	681b      	ldr	r3, [r3, #0]
 80296f2:	fb02 f303 	mul.w	r3, r2, r3
 80296f6:	617b      	str	r3, [r7, #20]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 80296f8:	697b      	ldr	r3, [r7, #20]
 80296fa:	3304      	adds	r3, #4
 80296fc:	617b      	str	r3, [r7, #20]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80296fe:	687b      	ldr	r3, [r7, #4]
 8029700:	3310      	adds	r3, #16
 8029702:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029706:	461a      	mov	r2, r3
 8029708:	69bb      	ldr	r3, [r7, #24]
 802970a:	3320      	adds	r3, #32
 802970c:	681b      	ldr	r3, [r3, #0]
 802970e:	fb02 f303 	mul.w	r3, r2, r3
 8029712:	613b      	str	r3, [r7, #16]

  /* Final output stage */

  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 8029714:	697a      	ldr	r2, [r7, #20]
 8029716:	693b      	ldr	r3, [r7, #16]
 8029718:	4413      	add	r3, r2
 802971a:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 802971c:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 8029720:	69fa      	ldr	r2, [r7, #28]
 8029722:	441a      	add	r2, r3
 8029724:	683b      	ldr	r3, [r7, #0]
 8029726:	6819      	ldr	r1, [r3, #0]
 8029728:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802972a:	440b      	add	r3, r1
 802972c:	7812      	ldrb	r2, [r2, #0]
 802972e:	701a      	strb	r2, [r3, #0]
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 8029730:	697a      	ldr	r2, [r7, #20]
 8029732:	693b      	ldr	r3, [r7, #16]
 8029734:	1ad3      	subs	r3, r2, r3
 8029736:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 8029738:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 802973c:	69fa      	ldr	r2, [r7, #28]
 802973e:	441a      	add	r2, r3
 8029740:	683b      	ldr	r3, [r7, #0]
 8029742:	3304      	adds	r3, #4
 8029744:	6819      	ldr	r1, [r3, #0]
 8029746:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8029748:	440b      	add	r3, r1
 802974a:	7812      	ldrb	r2, [r2, #0]
 802974c:	701a      	strb	r2, [r3, #0]
}
 802974e:	bf00      	nop
 8029750:	3724      	adds	r7, #36	@ 0x24
 8029752:	46bd      	mov	sp, r7
 8029754:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029758:	4770      	bx	lr

0802975a <out_of_memory>:

LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
 802975a:	b580      	push	{r7, lr}
 802975c:	b082      	sub	sp, #8
 802975e:	af00      	add	r7, sp, #0
 8029760:	6078      	str	r0, [r7, #4]
 8029762:	6039      	str	r1, [r7, #0]
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 8029764:	687b      	ldr	r3, [r7, #4]
 8029766:	681b      	ldr	r3, [r3, #0]
 8029768:	2238      	movs	r2, #56	@ 0x38
 802976a:	615a      	str	r2, [r3, #20]
 802976c:	687b      	ldr	r3, [r7, #4]
 802976e:	681b      	ldr	r3, [r3, #0]
 8029770:	683a      	ldr	r2, [r7, #0]
 8029772:	619a      	str	r2, [r3, #24]
 8029774:	687b      	ldr	r3, [r7, #4]
 8029776:	681b      	ldr	r3, [r3, #0]
 8029778:	681b      	ldr	r3, [r3, #0]
 802977a:	6878      	ldr	r0, [r7, #4]
 802977c:	4798      	blx	r3
}
 802977e:	bf00      	nop
 8029780:	3708      	adds	r7, #8
 8029782:	46bd      	mov	sp, r7
 8029784:	bd80      	pop	{r7, pc}
	...

08029788 <alloc_small>:


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
 8029788:	b580      	push	{r7, lr}
 802978a:	b08c      	sub	sp, #48	@ 0x30
 802978c:	af00      	add	r7, sp, #0
 802978e:	60f8      	str	r0, [r7, #12]
 8029790:	60b9      	str	r1, [r7, #8]
 8029792:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029794:	68fb      	ldr	r3, [r7, #12]
 8029796:	685b      	ldr	r3, [r3, #4]
 8029798:	623b      	str	r3, [r7, #32]
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
 802979a:	687b      	ldr	r3, [r7, #4]
 802979c:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 80297a0:	4293      	cmp	r3, r2
 80297a2:	d903      	bls.n	80297ac <alloc_small+0x24>
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 80297a4:	2101      	movs	r1, #1
 80297a6:	68f8      	ldr	r0, [r7, #12]
 80297a8:	f7ff ffd7 	bl	802975a <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 80297ac:	687b      	ldr	r3, [r7, #4]
 80297ae:	f003 0307 	and.w	r3, r3, #7
 80297b2:	61fb      	str	r3, [r7, #28]
  if (odd_bytes > 0)
 80297b4:	69fb      	ldr	r3, [r7, #28]
 80297b6:	2b00      	cmp	r3, #0
 80297b8:	d004      	beq.n	80297c4 <alloc_small+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 80297ba:	687a      	ldr	r2, [r7, #4]
 80297bc:	69fb      	ldr	r3, [r7, #28]
 80297be:	1ad3      	subs	r3, r2, r3
 80297c0:	3308      	adds	r3, #8
 80297c2:	607b      	str	r3, [r7, #4]

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 80297c4:	68bb      	ldr	r3, [r7, #8]
 80297c6:	2b00      	cmp	r3, #0
 80297c8:	db02      	blt.n	80297d0 <alloc_small+0x48>
 80297ca:	68bb      	ldr	r3, [r7, #8]
 80297cc:	2b01      	cmp	r3, #1
 80297ce:	dd0c      	ble.n	80297ea <alloc_small+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 80297d0:	68fb      	ldr	r3, [r7, #12]
 80297d2:	681b      	ldr	r3, [r3, #0]
 80297d4:	220f      	movs	r2, #15
 80297d6:	615a      	str	r2, [r3, #20]
 80297d8:	68fb      	ldr	r3, [r7, #12]
 80297da:	681b      	ldr	r3, [r3, #0]
 80297dc:	68ba      	ldr	r2, [r7, #8]
 80297de:	619a      	str	r2, [r3, #24]
 80297e0:	68fb      	ldr	r3, [r7, #12]
 80297e2:	681b      	ldr	r3, [r3, #0]
 80297e4:	681b      	ldr	r3, [r3, #0]
 80297e6:	68f8      	ldr	r0, [r7, #12]
 80297e8:	4798      	blx	r3
  prev_hdr_ptr = NULL;
 80297ea:	2300      	movs	r3, #0
 80297ec:	62bb      	str	r3, [r7, #40]	@ 0x28
  hdr_ptr = mem->small_list[pool_id];
 80297ee:	6a3a      	ldr	r2, [r7, #32]
 80297f0:	68bb      	ldr	r3, [r7, #8]
 80297f2:	330c      	adds	r3, #12
 80297f4:	009b      	lsls	r3, r3, #2
 80297f6:	4413      	add	r3, r2
 80297f8:	685b      	ldr	r3, [r3, #4]
 80297fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (hdr_ptr != NULL) {
 80297fc:	e009      	b.n	8029812 <alloc_small+0x8a>
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 80297fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8029800:	689b      	ldr	r3, [r3, #8]
 8029802:	687a      	ldr	r2, [r7, #4]
 8029804:	429a      	cmp	r2, r3
 8029806:	d908      	bls.n	802981a <alloc_small+0x92>
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
 8029808:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802980a:	62bb      	str	r3, [r7, #40]	@ 0x28
    hdr_ptr = hdr_ptr->hdr.next;
 802980c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802980e:	681b      	ldr	r3, [r3, #0]
 8029810:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (hdr_ptr != NULL) {
 8029812:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8029814:	2b00      	cmp	r3, #0
 8029816:	d1f2      	bne.n	80297fe <alloc_small+0x76>
 8029818:	e000      	b.n	802981c <alloc_small+0x94>
      break;			/* found pool with enough space */
 802981a:	bf00      	nop
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
 802981c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802981e:	2b00      	cmp	r3, #0
 8029820:	d154      	bne.n	80298cc <alloc_small+0x144>
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
 8029822:	687b      	ldr	r3, [r7, #4]
 8029824:	3310      	adds	r3, #16
 8029826:	61bb      	str	r3, [r7, #24]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 8029828:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802982a:	2b00      	cmp	r3, #0
 802982c:	d105      	bne.n	802983a <alloc_small+0xb2>
      slop = first_pool_slop[pool_id];
 802982e:	4a34      	ldr	r2, [pc, #208]	@ (8029900 <alloc_small+0x178>)
 8029830:	68bb      	ldr	r3, [r7, #8]
 8029832:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8029836:	627b      	str	r3, [r7, #36]	@ 0x24
 8029838:	e004      	b.n	8029844 <alloc_small+0xbc>
    else
      slop = extra_pool_slop[pool_id];
 802983a:	4a32      	ldr	r2, [pc, #200]	@ (8029904 <alloc_small+0x17c>)
 802983c:	68bb      	ldr	r3, [r7, #8]
 802983e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8029842:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
 8029844:	69bb      	ldr	r3, [r7, #24]
 8029846:	f5c3 3380 	rsb	r3, r3, #65536	@ 0x10000
 802984a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802984c:	429a      	cmp	r2, r3
 802984e:	d903      	bls.n	8029858 <alloc_small+0xd0>
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 8029850:	69bb      	ldr	r3, [r7, #24]
 8029852:	f5c3 3380 	rsb	r3, r3, #65536	@ 0x10000
 8029856:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 8029858:	69ba      	ldr	r2, [r7, #24]
 802985a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802985c:	4413      	add	r3, r2
 802985e:	4619      	mov	r1, r3
 8029860:	68f8      	ldr	r0, [r7, #12]
 8029862:	f000 feff 	bl	802a664 <jpeg_get_small>
 8029866:	62f8      	str	r0, [r7, #44]	@ 0x2c
      if (hdr_ptr != NULL)
 8029868:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802986a:	2b00      	cmp	r3, #0
 802986c:	d10a      	bne.n	8029884 <alloc_small+0xfc>
	break;
      slop /= 2;
 802986e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029870:	085b      	lsrs	r3, r3, #1
 8029872:	627b      	str	r3, [r7, #36]	@ 0x24
      if (slop < MIN_SLOP)	/* give up when it gets real small */
 8029874:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029876:	2b31      	cmp	r3, #49	@ 0x31
 8029878:	d8ee      	bhi.n	8029858 <alloc_small+0xd0>
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 802987a:	2102      	movs	r1, #2
 802987c:	68f8      	ldr	r0, [r7, #12]
 802987e:	f7ff ff6c 	bl	802975a <out_of_memory>
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 8029882:	e7e9      	b.n	8029858 <alloc_small+0xd0>
	break;
 8029884:	bf00      	nop
    }
    mem->total_space_allocated += min_request + slop;
 8029886:	6a3b      	ldr	r3, [r7, #32]
 8029888:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802988a:	4619      	mov	r1, r3
 802988c:	69ba      	ldr	r2, [r7, #24]
 802988e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029890:	4413      	add	r3, r2
 8029892:	440b      	add	r3, r1
 8029894:	461a      	mov	r2, r3
 8029896:	6a3b      	ldr	r3, [r7, #32]
 8029898:	64da      	str	r2, [r3, #76]	@ 0x4c
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
 802989a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802989c:	2200      	movs	r2, #0
 802989e:	601a      	str	r2, [r3, #0]
    hdr_ptr->hdr.bytes_used = 0;
 80298a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298a2:	2200      	movs	r2, #0
 80298a4:	605a      	str	r2, [r3, #4]
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
 80298a6:	687a      	ldr	r2, [r7, #4]
 80298a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80298aa:	441a      	add	r2, r3
 80298ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298ae:	609a      	str	r2, [r3, #8]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 80298b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80298b2:	2b00      	cmp	r3, #0
 80298b4:	d107      	bne.n	80298c6 <alloc_small+0x13e>
      mem->small_list[pool_id] = hdr_ptr;
 80298b6:	6a3a      	ldr	r2, [r7, #32]
 80298b8:	68bb      	ldr	r3, [r7, #8]
 80298ba:	330c      	adds	r3, #12
 80298bc:	009b      	lsls	r3, r3, #2
 80298be:	4413      	add	r3, r2
 80298c0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80298c2:	605a      	str	r2, [r3, #4]
 80298c4:	e002      	b.n	80298cc <alloc_small+0x144>
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
 80298c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80298c8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80298ca:	601a      	str	r2, [r3, #0]
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 80298cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298ce:	3310      	adds	r3, #16
 80298d0:	617b      	str	r3, [r7, #20]
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
 80298d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298d4:	685b      	ldr	r3, [r3, #4]
 80298d6:	697a      	ldr	r2, [r7, #20]
 80298d8:	4413      	add	r3, r2
 80298da:	617b      	str	r3, [r7, #20]
  hdr_ptr->hdr.bytes_used += sizeofobject;
 80298dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298de:	685a      	ldr	r2, [r3, #4]
 80298e0:	687b      	ldr	r3, [r7, #4]
 80298e2:	441a      	add	r2, r3
 80298e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298e6:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left -= sizeofobject;
 80298e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298ea:	689a      	ldr	r2, [r3, #8]
 80298ec:	687b      	ldr	r3, [r7, #4]
 80298ee:	1ad2      	subs	r2, r2, r3
 80298f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80298f2:	609a      	str	r2, [r3, #8]

  return (void *) data_ptr;
 80298f4:	697b      	ldr	r3, [r7, #20]
}
 80298f6:	4618      	mov	r0, r3
 80298f8:	3730      	adds	r7, #48	@ 0x30
 80298fa:	46bd      	mov	sp, r7
 80298fc:	bd80      	pop	{r7, pc}
 80298fe:	bf00      	nop
 8029900:	08030794 	.word	0x08030794
 8029904:	0803079c 	.word	0x0803079c

08029908 <alloc_large>:
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
 8029908:	b580      	push	{r7, lr}
 802990a:	b088      	sub	sp, #32
 802990c:	af00      	add	r7, sp, #0
 802990e:	60f8      	str	r0, [r7, #12]
 8029910:	60b9      	str	r1, [r7, #8]
 8029912:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029914:	68fb      	ldr	r3, [r7, #12]
 8029916:	685b      	ldr	r3, [r3, #4]
 8029918:	61fb      	str	r3, [r7, #28]
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
 802991a:	687b      	ldr	r3, [r7, #4]
 802991c:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 8029920:	4293      	cmp	r3, r2
 8029922:	d903      	bls.n	802992c <alloc_large+0x24>
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 8029924:	2103      	movs	r1, #3
 8029926:	68f8      	ldr	r0, [r7, #12]
 8029928:	f7ff ff17 	bl	802975a <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 802992c:	687b      	ldr	r3, [r7, #4]
 802992e:	f003 0307 	and.w	r3, r3, #7
 8029932:	61bb      	str	r3, [r7, #24]
  if (odd_bytes > 0)
 8029934:	69bb      	ldr	r3, [r7, #24]
 8029936:	2b00      	cmp	r3, #0
 8029938:	d004      	beq.n	8029944 <alloc_large+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 802993a:	687a      	ldr	r2, [r7, #4]
 802993c:	69bb      	ldr	r3, [r7, #24]
 802993e:	1ad3      	subs	r3, r2, r3
 8029940:	3308      	adds	r3, #8
 8029942:	607b      	str	r3, [r7, #4]

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 8029944:	68bb      	ldr	r3, [r7, #8]
 8029946:	2b00      	cmp	r3, #0
 8029948:	db02      	blt.n	8029950 <alloc_large+0x48>
 802994a:	68bb      	ldr	r3, [r7, #8]
 802994c:	2b01      	cmp	r3, #1
 802994e:	dd0c      	ble.n	802996a <alloc_large+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8029950:	68fb      	ldr	r3, [r7, #12]
 8029952:	681b      	ldr	r3, [r3, #0]
 8029954:	220f      	movs	r2, #15
 8029956:	615a      	str	r2, [r3, #20]
 8029958:	68fb      	ldr	r3, [r7, #12]
 802995a:	681b      	ldr	r3, [r3, #0]
 802995c:	68ba      	ldr	r2, [r7, #8]
 802995e:	619a      	str	r2, [r3, #24]
 8029960:	68fb      	ldr	r3, [r7, #12]
 8029962:	681b      	ldr	r3, [r3, #0]
 8029964:	681b      	ldr	r3, [r3, #0]
 8029966:	68f8      	ldr	r0, [r7, #12]
 8029968:	4798      	blx	r3

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 802996a:	687b      	ldr	r3, [r7, #4]
 802996c:	3310      	adds	r3, #16
 802996e:	4619      	mov	r1, r3
 8029970:	68f8      	ldr	r0, [r7, #12]
 8029972:	f000 fe91 	bl	802a698 <jpeg_get_large>
 8029976:	6178      	str	r0, [r7, #20]
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
 8029978:	697b      	ldr	r3, [r7, #20]
 802997a:	2b00      	cmp	r3, #0
 802997c:	d103      	bne.n	8029986 <alloc_large+0x7e>
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
 802997e:	2104      	movs	r1, #4
 8029980:	68f8      	ldr	r0, [r7, #12]
 8029982:	f7ff feea 	bl	802975a <out_of_memory>
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 8029986:	69fb      	ldr	r3, [r7, #28]
 8029988:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802998a:	461a      	mov	r2, r3
 802998c:	687b      	ldr	r3, [r7, #4]
 802998e:	4413      	add	r3, r2
 8029990:	3310      	adds	r3, #16
 8029992:	461a      	mov	r2, r3
 8029994:	69fb      	ldr	r3, [r7, #28]
 8029996:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
 8029998:	69fa      	ldr	r2, [r7, #28]
 802999a:	68bb      	ldr	r3, [r7, #8]
 802999c:	330e      	adds	r3, #14
 802999e:	009b      	lsls	r3, r3, #2
 80299a0:	4413      	add	r3, r2
 80299a2:	685a      	ldr	r2, [r3, #4]
 80299a4:	697b      	ldr	r3, [r7, #20]
 80299a6:	601a      	str	r2, [r3, #0]
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
 80299a8:	697b      	ldr	r3, [r7, #20]
 80299aa:	687a      	ldr	r2, [r7, #4]
 80299ac:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left = 0;
 80299ae:	697b      	ldr	r3, [r7, #20]
 80299b0:	2200      	movs	r2, #0
 80299b2:	609a      	str	r2, [r3, #8]
  mem->large_list[pool_id] = hdr_ptr;
 80299b4:	69fa      	ldr	r2, [r7, #28]
 80299b6:	68bb      	ldr	r3, [r7, #8]
 80299b8:	330e      	adds	r3, #14
 80299ba:	009b      	lsls	r3, r3, #2
 80299bc:	4413      	add	r3, r2
 80299be:	697a      	ldr	r2, [r7, #20]
 80299c0:	605a      	str	r2, [r3, #4]

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 80299c2:	697b      	ldr	r3, [r7, #20]
 80299c4:	3310      	adds	r3, #16
}
 80299c6:	4618      	mov	r0, r3
 80299c8:	3720      	adds	r7, #32
 80299ca:	46bd      	mov	sp, r7
 80299cc:	bd80      	pop	{r7, pc}

080299ce <alloc_sarray>:

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
 80299ce:	b580      	push	{r7, lr}
 80299d0:	b08c      	sub	sp, #48	@ 0x30
 80299d2:	af00      	add	r7, sp, #0
 80299d4:	60f8      	str	r0, [r7, #12]
 80299d6:	60b9      	str	r1, [r7, #8]
 80299d8:	607a      	str	r2, [r7, #4]
 80299da:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 80299dc:	68fb      	ldr	r3, [r7, #12]
 80299de:	685b      	ldr	r3, [r3, #4]
 80299e0:	61fb      	str	r3, [r7, #28]
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 80299e2:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 80299e6:	687b      	ldr	r3, [r7, #4]
 80299e8:	fbb2 f3f3 	udiv	r3, r2, r3
 80299ec:	61bb      	str	r3, [r7, #24]
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
 80299ee:	69bb      	ldr	r3, [r7, #24]
 80299f0:	2b00      	cmp	r3, #0
 80299f2:	dc08      	bgt.n	8029a06 <alloc_sarray+0x38>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 80299f4:	68fb      	ldr	r3, [r7, #12]
 80299f6:	681b      	ldr	r3, [r3, #0]
 80299f8:	2248      	movs	r2, #72	@ 0x48
 80299fa:	615a      	str	r2, [r3, #20]
 80299fc:	68fb      	ldr	r3, [r7, #12]
 80299fe:	681b      	ldr	r3, [r3, #0]
 8029a00:	681b      	ldr	r3, [r3, #0]
 8029a02:	68f8      	ldr	r0, [r7, #12]
 8029a04:	4798      	blx	r3
  if (ltemp < (long) numrows)
 8029a06:	683b      	ldr	r3, [r7, #0]
 8029a08:	69ba      	ldr	r2, [r7, #24]
 8029a0a:	429a      	cmp	r2, r3
 8029a0c:	da02      	bge.n	8029a14 <alloc_sarray+0x46>
    rowsperchunk = (JDIMENSION) ltemp;
 8029a0e:	69bb      	ldr	r3, [r7, #24]
 8029a10:	62bb      	str	r3, [r7, #40]	@ 0x28
 8029a12:	e001      	b.n	8029a18 <alloc_sarray+0x4a>
  else
    rowsperchunk = numrows;
 8029a14:	683b      	ldr	r3, [r7, #0]
 8029a16:	62bb      	str	r3, [r7, #40]	@ 0x28
  mem->last_rowsperchunk = rowsperchunk;
 8029a18:	69fb      	ldr	r3, [r7, #28]
 8029a1a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8029a1c:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 8029a1e:	683b      	ldr	r3, [r7, #0]
 8029a20:	009b      	lsls	r3, r3, #2
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
 8029a22:	461a      	mov	r2, r3
 8029a24:	68b9      	ldr	r1, [r7, #8]
 8029a26:	68f8      	ldr	r0, [r7, #12]
 8029a28:	f7ff feae 	bl	8029788 <alloc_small>
 8029a2c:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 8029a2e:	2300      	movs	r3, #0
 8029a30:	627b      	str	r3, [r7, #36]	@ 0x24
  while (currow < numrows) {
 8029a32:	e026      	b.n	8029a82 <alloc_sarray+0xb4>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 8029a34:	683a      	ldr	r2, [r7, #0]
 8029a36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029a38:	1ad3      	subs	r3, r2, r3
 8029a3a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8029a3c:	4293      	cmp	r3, r2
 8029a3e:	bf28      	it	cs
 8029a40:	4613      	movcs	r3, r2
 8029a42:	62bb      	str	r3, [r7, #40]	@ 0x28
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 8029a44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8029a46:	687a      	ldr	r2, [r7, #4]
 8029a48:	fb02 f303 	mul.w	r3, r2, r3
 8029a4c:	461a      	mov	r2, r3
 8029a4e:	68b9      	ldr	r1, [r7, #8]
 8029a50:	68f8      	ldr	r0, [r7, #12]
 8029a52:	f7ff ff59 	bl	8029908 <alloc_large>
 8029a56:	62f8      	str	r0, [r7, #44]	@ 0x2c
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
 8029a58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8029a5a:	623b      	str	r3, [r7, #32]
 8029a5c:	e00e      	b.n	8029a7c <alloc_sarray+0xae>
      result[currow++] = workspace;
 8029a5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029a60:	1c5a      	adds	r2, r3, #1
 8029a62:	627a      	str	r2, [r7, #36]	@ 0x24
 8029a64:	009b      	lsls	r3, r3, #2
 8029a66:	697a      	ldr	r2, [r7, #20]
 8029a68:	4413      	add	r3, r2
 8029a6a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8029a6c:	601a      	str	r2, [r3, #0]
      workspace += samplesperrow;
 8029a6e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8029a70:	687b      	ldr	r3, [r7, #4]
 8029a72:	4413      	add	r3, r2
 8029a74:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 8029a76:	6a3b      	ldr	r3, [r7, #32]
 8029a78:	3b01      	subs	r3, #1
 8029a7a:	623b      	str	r3, [r7, #32]
 8029a7c:	6a3b      	ldr	r3, [r7, #32]
 8029a7e:	2b00      	cmp	r3, #0
 8029a80:	d1ed      	bne.n	8029a5e <alloc_sarray+0x90>
  while (currow < numrows) {
 8029a82:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029a84:	683b      	ldr	r3, [r7, #0]
 8029a86:	429a      	cmp	r2, r3
 8029a88:	d3d4      	bcc.n	8029a34 <alloc_sarray+0x66>
    }
  }

  return result;
 8029a8a:	697b      	ldr	r3, [r7, #20]
}
 8029a8c:	4618      	mov	r0, r3
 8029a8e:	3730      	adds	r7, #48	@ 0x30
 8029a90:	46bd      	mov	sp, r7
 8029a92:	bd80      	pop	{r7, pc}

08029a94 <alloc_barray>:

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
 8029a94:	b580      	push	{r7, lr}
 8029a96:	b08c      	sub	sp, #48	@ 0x30
 8029a98:	af00      	add	r7, sp, #0
 8029a9a:	60f8      	str	r0, [r7, #12]
 8029a9c:	60b9      	str	r1, [r7, #8]
 8029a9e:	607a      	str	r2, [r7, #4]
 8029aa0:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029aa2:	68fb      	ldr	r3, [r7, #12]
 8029aa4:	685b      	ldr	r3, [r3, #4]
 8029aa6:	61fb      	str	r3, [r7, #28]
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
 8029aa8:	687b      	ldr	r3, [r7, #4]
 8029aaa:	01db      	lsls	r3, r3, #7
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 8029aac:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 8029ab0:	fbb2 f3f3 	udiv	r3, r2, r3
 8029ab4:	61bb      	str	r3, [r7, #24]
  if (ltemp <= 0)
 8029ab6:	69bb      	ldr	r3, [r7, #24]
 8029ab8:	2b00      	cmp	r3, #0
 8029aba:	dc08      	bgt.n	8029ace <alloc_barray+0x3a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 8029abc:	68fb      	ldr	r3, [r7, #12]
 8029abe:	681b      	ldr	r3, [r3, #0]
 8029ac0:	2248      	movs	r2, #72	@ 0x48
 8029ac2:	615a      	str	r2, [r3, #20]
 8029ac4:	68fb      	ldr	r3, [r7, #12]
 8029ac6:	681b      	ldr	r3, [r3, #0]
 8029ac8:	681b      	ldr	r3, [r3, #0]
 8029aca:	68f8      	ldr	r0, [r7, #12]
 8029acc:	4798      	blx	r3
  if (ltemp < (long) numrows)
 8029ace:	683b      	ldr	r3, [r7, #0]
 8029ad0:	69ba      	ldr	r2, [r7, #24]
 8029ad2:	429a      	cmp	r2, r3
 8029ad4:	da02      	bge.n	8029adc <alloc_barray+0x48>
    rowsperchunk = (JDIMENSION) ltemp;
 8029ad6:	69bb      	ldr	r3, [r7, #24]
 8029ad8:	62bb      	str	r3, [r7, #40]	@ 0x28
 8029ada:	e001      	b.n	8029ae0 <alloc_barray+0x4c>
  else
    rowsperchunk = numrows;
 8029adc:	683b      	ldr	r3, [r7, #0]
 8029ade:	62bb      	str	r3, [r7, #40]	@ 0x28
  mem->last_rowsperchunk = rowsperchunk;
 8029ae0:	69fb      	ldr	r3, [r7, #28]
 8029ae2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8029ae4:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 8029ae6:	683b      	ldr	r3, [r7, #0]
 8029ae8:	009b      	lsls	r3, r3, #2
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
 8029aea:	461a      	mov	r2, r3
 8029aec:	68b9      	ldr	r1, [r7, #8]
 8029aee:	68f8      	ldr	r0, [r7, #12]
 8029af0:	f7ff fe4a 	bl	8029788 <alloc_small>
 8029af4:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 8029af6:	2300      	movs	r3, #0
 8029af8:	627b      	str	r3, [r7, #36]	@ 0x24
  while (currow < numrows) {
 8029afa:	e028      	b.n	8029b4e <alloc_barray+0xba>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 8029afc:	683a      	ldr	r2, [r7, #0]
 8029afe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029b00:	1ad3      	subs	r3, r2, r3
 8029b02:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8029b04:	4293      	cmp	r3, r2
 8029b06:	bf28      	it	cs
 8029b08:	4613      	movcs	r3, r2
 8029b0a:	62bb      	str	r3, [r7, #40]	@ 0x28
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 8029b0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8029b0e:	687a      	ldr	r2, [r7, #4]
 8029b10:	fb02 f303 	mul.w	r3, r2, r3
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 8029b14:	01db      	lsls	r3, r3, #7
 8029b16:	461a      	mov	r2, r3
 8029b18:	68b9      	ldr	r1, [r7, #8]
 8029b1a:	68f8      	ldr	r0, [r7, #12]
 8029b1c:	f7ff fef4 	bl	8029908 <alloc_large>
 8029b20:	62f8      	str	r0, [r7, #44]	@ 0x2c
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
 8029b22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8029b24:	623b      	str	r3, [r7, #32]
 8029b26:	e00f      	b.n	8029b48 <alloc_barray+0xb4>
      result[currow++] = workspace;
 8029b28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029b2a:	1c5a      	adds	r2, r3, #1
 8029b2c:	627a      	str	r2, [r7, #36]	@ 0x24
 8029b2e:	009b      	lsls	r3, r3, #2
 8029b30:	697a      	ldr	r2, [r7, #20]
 8029b32:	4413      	add	r3, r2
 8029b34:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8029b36:	601a      	str	r2, [r3, #0]
      workspace += blocksperrow;
 8029b38:	687b      	ldr	r3, [r7, #4]
 8029b3a:	01db      	lsls	r3, r3, #7
 8029b3c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8029b3e:	4413      	add	r3, r2
 8029b40:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 8029b42:	6a3b      	ldr	r3, [r7, #32]
 8029b44:	3b01      	subs	r3, #1
 8029b46:	623b      	str	r3, [r7, #32]
 8029b48:	6a3b      	ldr	r3, [r7, #32]
 8029b4a:	2b00      	cmp	r3, #0
 8029b4c:	d1ec      	bne.n	8029b28 <alloc_barray+0x94>
  while (currow < numrows) {
 8029b4e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029b50:	683b      	ldr	r3, [r7, #0]
 8029b52:	429a      	cmp	r2, r3
 8029b54:	d3d2      	bcc.n	8029afc <alloc_barray+0x68>
    }
  }

  return result;
 8029b56:	697b      	ldr	r3, [r7, #20]
}
 8029b58:	4618      	mov	r0, r3
 8029b5a:	3730      	adds	r7, #48	@ 0x30
 8029b5c:	46bd      	mov	sp, r7
 8029b5e:	bd80      	pop	{r7, pc}

08029b60 <request_virt_sarray>:
METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
 8029b60:	b580      	push	{r7, lr}
 8029b62:	b086      	sub	sp, #24
 8029b64:	af00      	add	r7, sp, #0
 8029b66:	60f8      	str	r0, [r7, #12]
 8029b68:	60b9      	str	r1, [r7, #8]
 8029b6a:	607a      	str	r2, [r7, #4]
 8029b6c:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029b6e:	68fb      	ldr	r3, [r7, #12]
 8029b70:	685b      	ldr	r3, [r3, #4]
 8029b72:	617b      	str	r3, [r7, #20]
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 8029b74:	68bb      	ldr	r3, [r7, #8]
 8029b76:	2b01      	cmp	r3, #1
 8029b78:	d00c      	beq.n	8029b94 <request_virt_sarray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8029b7a:	68fb      	ldr	r3, [r7, #12]
 8029b7c:	681b      	ldr	r3, [r3, #0]
 8029b7e:	220f      	movs	r2, #15
 8029b80:	615a      	str	r2, [r3, #20]
 8029b82:	68fb      	ldr	r3, [r7, #12]
 8029b84:	681b      	ldr	r3, [r3, #0]
 8029b86:	68ba      	ldr	r2, [r7, #8]
 8029b88:	619a      	str	r2, [r3, #24]
 8029b8a:	68fb      	ldr	r3, [r7, #12]
 8029b8c:	681b      	ldr	r3, [r3, #0]
 8029b8e:	681b      	ldr	r3, [r3, #0]
 8029b90:	68f8      	ldr	r0, [r7, #12]
 8029b92:	4798      	blx	r3

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 8029b94:	223c      	movs	r2, #60	@ 0x3c
 8029b96:	68b9      	ldr	r1, [r7, #8]
 8029b98:	68f8      	ldr	r0, [r7, #12]
 8029b9a:	f7ff fdf5 	bl	8029788 <alloc_small>
 8029b9e:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 8029ba0:	693b      	ldr	r3, [r7, #16]
 8029ba2:	2200      	movs	r2, #0
 8029ba4:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 8029ba6:	693b      	ldr	r3, [r7, #16]
 8029ba8:	6a3a      	ldr	r2, [r7, #32]
 8029baa:	605a      	str	r2, [r3, #4]
  result->samplesperrow = samplesperrow;
 8029bac:	693b      	ldr	r3, [r7, #16]
 8029bae:	683a      	ldr	r2, [r7, #0]
 8029bb0:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 8029bb2:	693b      	ldr	r3, [r7, #16]
 8029bb4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029bb6:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 8029bb8:	693b      	ldr	r3, [r7, #16]
 8029bba:	687a      	ldr	r2, [r7, #4]
 8029bbc:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 8029bbe:	693b      	ldr	r3, [r7, #16]
 8029bc0:	2200      	movs	r2, #0
 8029bc2:	629a      	str	r2, [r3, #40]	@ 0x28
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
 8029bc4:	697b      	ldr	r3, [r7, #20]
 8029bc6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8029bc8:	693b      	ldr	r3, [r7, #16]
 8029bca:	62da      	str	r2, [r3, #44]	@ 0x2c
  mem->virt_sarray_list = result;
 8029bcc:	697b      	ldr	r3, [r7, #20]
 8029bce:	693a      	ldr	r2, [r7, #16]
 8029bd0:	645a      	str	r2, [r3, #68]	@ 0x44

  return result;
 8029bd2:	693b      	ldr	r3, [r7, #16]
}
 8029bd4:	4618      	mov	r0, r3
 8029bd6:	3718      	adds	r7, #24
 8029bd8:	46bd      	mov	sp, r7
 8029bda:	bd80      	pop	{r7, pc}

08029bdc <request_virt_barray>:
METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
 8029bdc:	b580      	push	{r7, lr}
 8029bde:	b086      	sub	sp, #24
 8029be0:	af00      	add	r7, sp, #0
 8029be2:	60f8      	str	r0, [r7, #12]
 8029be4:	60b9      	str	r1, [r7, #8]
 8029be6:	607a      	str	r2, [r7, #4]
 8029be8:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029bea:	68fb      	ldr	r3, [r7, #12]
 8029bec:	685b      	ldr	r3, [r3, #4]
 8029bee:	617b      	str	r3, [r7, #20]
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 8029bf0:	68bb      	ldr	r3, [r7, #8]
 8029bf2:	2b01      	cmp	r3, #1
 8029bf4:	d00c      	beq.n	8029c10 <request_virt_barray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8029bf6:	68fb      	ldr	r3, [r7, #12]
 8029bf8:	681b      	ldr	r3, [r3, #0]
 8029bfa:	220f      	movs	r2, #15
 8029bfc:	615a      	str	r2, [r3, #20]
 8029bfe:	68fb      	ldr	r3, [r7, #12]
 8029c00:	681b      	ldr	r3, [r3, #0]
 8029c02:	68ba      	ldr	r2, [r7, #8]
 8029c04:	619a      	str	r2, [r3, #24]
 8029c06:	68fb      	ldr	r3, [r7, #12]
 8029c08:	681b      	ldr	r3, [r3, #0]
 8029c0a:	681b      	ldr	r3, [r3, #0]
 8029c0c:	68f8      	ldr	r0, [r7, #12]
 8029c0e:	4798      	blx	r3

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 8029c10:	223c      	movs	r2, #60	@ 0x3c
 8029c12:	68b9      	ldr	r1, [r7, #8]
 8029c14:	68f8      	ldr	r0, [r7, #12]
 8029c16:	f7ff fdb7 	bl	8029788 <alloc_small>
 8029c1a:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 8029c1c:	693b      	ldr	r3, [r7, #16]
 8029c1e:	2200      	movs	r2, #0
 8029c20:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 8029c22:	693b      	ldr	r3, [r7, #16]
 8029c24:	6a3a      	ldr	r2, [r7, #32]
 8029c26:	605a      	str	r2, [r3, #4]
  result->blocksperrow = blocksperrow;
 8029c28:	693b      	ldr	r3, [r7, #16]
 8029c2a:	683a      	ldr	r2, [r7, #0]
 8029c2c:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 8029c2e:	693b      	ldr	r3, [r7, #16]
 8029c30:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029c32:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 8029c34:	693b      	ldr	r3, [r7, #16]
 8029c36:	687a      	ldr	r2, [r7, #4]
 8029c38:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 8029c3a:	693b      	ldr	r3, [r7, #16]
 8029c3c:	2200      	movs	r2, #0
 8029c3e:	629a      	str	r2, [r3, #40]	@ 0x28
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
 8029c40:	697b      	ldr	r3, [r7, #20]
 8029c42:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8029c44:	693b      	ldr	r3, [r7, #16]
 8029c46:	62da      	str	r2, [r3, #44]	@ 0x2c
  mem->virt_barray_list = result;
 8029c48:	697b      	ldr	r3, [r7, #20]
 8029c4a:	693a      	ldr	r2, [r7, #16]
 8029c4c:	649a      	str	r2, [r3, #72]	@ 0x48

  return result;
 8029c4e:	693b      	ldr	r3, [r7, #16]
}
 8029c50:	4618      	mov	r0, r3
 8029c52:	3718      	adds	r7, #24
 8029c54:	46bd      	mov	sp, r7
 8029c56:	bd80      	pop	{r7, pc}

08029c58 <realize_virt_arrays>:


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
 8029c58:	b580      	push	{r7, lr}
 8029c5a:	b08a      	sub	sp, #40	@ 0x28
 8029c5c:	af00      	add	r7, sp, #0
 8029c5e:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8029c60:	687b      	ldr	r3, [r7, #4]
 8029c62:	685b      	ldr	r3, [r3, #4]
 8029c64:	613b      	str	r3, [r7, #16]

  /* Compute the minimum space needed (maxaccess rows in each buffer)
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
 8029c66:	2300      	movs	r3, #0
 8029c68:	627b      	str	r3, [r7, #36]	@ 0x24
  maximum_space = 0;
 8029c6a:	2300      	movs	r3, #0
 8029c6c:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8029c6e:	693b      	ldr	r3, [r7, #16]
 8029c70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8029c72:	61bb      	str	r3, [r7, #24]
 8029c74:	e01c      	b.n	8029cb0 <realize_virt_arrays+0x58>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 8029c76:	69bb      	ldr	r3, [r7, #24]
 8029c78:	681b      	ldr	r3, [r3, #0]
 8029c7a:	2b00      	cmp	r3, #0
 8029c7c:	d115      	bne.n	8029caa <realize_virt_arrays+0x52>
      space_per_minheight += (long) sptr->maxaccess *
 8029c7e:	69bb      	ldr	r3, [r7, #24]
 8029c80:	68db      	ldr	r3, [r3, #12]
 8029c82:	461a      	mov	r2, r3
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8029c84:	69bb      	ldr	r3, [r7, #24]
 8029c86:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) sptr->maxaccess *
 8029c88:	fb02 f303 	mul.w	r3, r2, r3
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8029c8c:	461a      	mov	r2, r3
      space_per_minheight += (long) sptr->maxaccess *
 8029c8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029c90:	4413      	add	r3, r2
 8029c92:	627b      	str	r3, [r7, #36]	@ 0x24
      maximum_space += (long) sptr->rows_in_array *
 8029c94:	69bb      	ldr	r3, [r7, #24]
 8029c96:	685b      	ldr	r3, [r3, #4]
 8029c98:	461a      	mov	r2, r3
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8029c9a:	69bb      	ldr	r3, [r7, #24]
 8029c9c:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) sptr->rows_in_array *
 8029c9e:	fb02 f303 	mul.w	r3, r2, r3
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8029ca2:	461a      	mov	r2, r3
      maximum_space += (long) sptr->rows_in_array *
 8029ca4:	6a3b      	ldr	r3, [r7, #32]
 8029ca6:	4413      	add	r3, r2
 8029ca8:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8029caa:	69bb      	ldr	r3, [r7, #24]
 8029cac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8029cae:	61bb      	str	r3, [r7, #24]
 8029cb0:	69bb      	ldr	r3, [r7, #24]
 8029cb2:	2b00      	cmp	r3, #0
 8029cb4:	d1df      	bne.n	8029c76 <realize_virt_arrays+0x1e>
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8029cb6:	693b      	ldr	r3, [r7, #16]
 8029cb8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8029cba:	617b      	str	r3, [r7, #20]
 8029cbc:	e01c      	b.n	8029cf8 <realize_virt_arrays+0xa0>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 8029cbe:	697b      	ldr	r3, [r7, #20]
 8029cc0:	681b      	ldr	r3, [r3, #0]
 8029cc2:	2b00      	cmp	r3, #0
 8029cc4:	d115      	bne.n	8029cf2 <realize_virt_arrays+0x9a>
      space_per_minheight += (long) bptr->maxaccess *
 8029cc6:	697b      	ldr	r3, [r7, #20]
 8029cc8:	68db      	ldr	r3, [r3, #12]
 8029cca:	461a      	mov	r2, r3
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8029ccc:	697b      	ldr	r3, [r7, #20]
 8029cce:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) bptr->maxaccess *
 8029cd0:	fb02 f303 	mul.w	r3, r2, r3
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8029cd4:	01da      	lsls	r2, r3, #7
      space_per_minheight += (long) bptr->maxaccess *
 8029cd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029cd8:	4413      	add	r3, r2
 8029cda:	627b      	str	r3, [r7, #36]	@ 0x24
      maximum_space += (long) bptr->rows_in_array *
 8029cdc:	697b      	ldr	r3, [r7, #20]
 8029cde:	685b      	ldr	r3, [r3, #4]
 8029ce0:	461a      	mov	r2, r3
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8029ce2:	697b      	ldr	r3, [r7, #20]
 8029ce4:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) bptr->rows_in_array *
 8029ce6:	fb02 f303 	mul.w	r3, r2, r3
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8029cea:	01da      	lsls	r2, r3, #7
      maximum_space += (long) bptr->rows_in_array *
 8029cec:	6a3b      	ldr	r3, [r7, #32]
 8029cee:	4413      	add	r3, r2
 8029cf0:	623b      	str	r3, [r7, #32]
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8029cf2:	697b      	ldr	r3, [r7, #20]
 8029cf4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8029cf6:	617b      	str	r3, [r7, #20]
 8029cf8:	697b      	ldr	r3, [r7, #20]
 8029cfa:	2b00      	cmp	r3, #0
 8029cfc:	d1df      	bne.n	8029cbe <realize_virt_arrays+0x66>
    }
  }

  if (space_per_minheight <= 0)
 8029cfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029d00:	2b00      	cmp	r3, #0
 8029d02:	f340 80bd 	ble.w	8029e80 <realize_virt_arrays+0x228>
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
 8029d06:	693b      	ldr	r3, [r7, #16]
 8029d08:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8029d0a:	6a3a      	ldr	r2, [r7, #32]
 8029d0c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8029d0e:	6878      	ldr	r0, [r7, #4]
 8029d10:	f000 fcdc 	bl	802a6cc <jpeg_mem_available>
 8029d14:	60f8      	str	r0, [r7, #12]

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
 8029d16:	68fa      	ldr	r2, [r7, #12]
 8029d18:	6a3b      	ldr	r3, [r7, #32]
 8029d1a:	429a      	cmp	r2, r3
 8029d1c:	db02      	blt.n	8029d24 <realize_virt_arrays+0xcc>
    max_minheights = 1000000000L;
 8029d1e:	4b5a      	ldr	r3, [pc, #360]	@ (8029e88 <realize_virt_arrays+0x230>)
 8029d20:	61fb      	str	r3, [r7, #28]
 8029d22:	e009      	b.n	8029d38 <realize_virt_arrays+0xe0>
  else {
    max_minheights = avail_mem / space_per_minheight;
 8029d24:	68fa      	ldr	r2, [r7, #12]
 8029d26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029d28:	fb92 f3f3 	sdiv	r3, r2, r3
 8029d2c:	61fb      	str	r3, [r7, #28]
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
 8029d2e:	69fb      	ldr	r3, [r7, #28]
 8029d30:	2b00      	cmp	r3, #0
 8029d32:	dc01      	bgt.n	8029d38 <realize_virt_arrays+0xe0>
      max_minheights = 1;
 8029d34:	2301      	movs	r3, #1
 8029d36:	61fb      	str	r3, [r7, #28]
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8029d38:	693b      	ldr	r3, [r7, #16]
 8029d3a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8029d3c:	61bb      	str	r3, [r7, #24]
 8029d3e:	e049      	b.n	8029dd4 <realize_virt_arrays+0x17c>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 8029d40:	69bb      	ldr	r3, [r7, #24]
 8029d42:	681b      	ldr	r3, [r3, #0]
 8029d44:	2b00      	cmp	r3, #0
 8029d46:	d142      	bne.n	8029dce <realize_virt_arrays+0x176>
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
 8029d48:	69bb      	ldr	r3, [r7, #24]
 8029d4a:	685b      	ldr	r3, [r3, #4]
 8029d4c:	3b01      	subs	r3, #1
 8029d4e:	461a      	mov	r2, r3
 8029d50:	69bb      	ldr	r3, [r7, #24]
 8029d52:	68db      	ldr	r3, [r3, #12]
 8029d54:	fbb2 f3f3 	udiv	r3, r2, r3
 8029d58:	3301      	adds	r3, #1
 8029d5a:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 8029d5c:	68ba      	ldr	r2, [r7, #8]
 8029d5e:	69fb      	ldr	r3, [r7, #28]
 8029d60:	429a      	cmp	r2, r3
 8029d62:	dc04      	bgt.n	8029d6e <realize_virt_arrays+0x116>
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
 8029d64:	69bb      	ldr	r3, [r7, #24]
 8029d66:	685a      	ldr	r2, [r3, #4]
 8029d68:	69bb      	ldr	r3, [r7, #24]
 8029d6a:	611a      	str	r2, [r3, #16]
 8029d6c:	e017      	b.n	8029d9e <realize_virt_arrays+0x146>
      } else {
	/* It doesn't fit in memory, create backing store. */
	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
 8029d6e:	69bb      	ldr	r3, [r7, #24]
 8029d70:	68db      	ldr	r3, [r3, #12]
 8029d72:	69fa      	ldr	r2, [r7, #28]
 8029d74:	fb03 f202 	mul.w	r2, r3, r2
 8029d78:	69bb      	ldr	r3, [r7, #24]
 8029d7a:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 8029d7c:	69bb      	ldr	r3, [r7, #24]
 8029d7e:	f103 0130 	add.w	r1, r3, #48	@ 0x30
				(long) sptr->rows_in_array *
 8029d82:	69bb      	ldr	r3, [r7, #24]
 8029d84:	685b      	ldr	r3, [r3, #4]
 8029d86:	461a      	mov	r2, r3
				(long) sptr->samplesperrow *
 8029d88:	69bb      	ldr	r3, [r7, #24]
 8029d8a:	689b      	ldr	r3, [r3, #8]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 8029d8c:	fb02 f303 	mul.w	r3, r2, r3
 8029d90:	461a      	mov	r2, r3
 8029d92:	6878      	ldr	r0, [r7, #4]
 8029d94:	f000 fca8 	bl	802a6e8 <jpeg_open_backing_store>
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
 8029d98:	69bb      	ldr	r3, [r7, #24]
 8029d9a:	2201      	movs	r2, #1
 8029d9c:	629a      	str	r2, [r3, #40]	@ 0x28
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 8029d9e:	69bb      	ldr	r3, [r7, #24]
 8029da0:	689a      	ldr	r2, [r3, #8]
 8029da2:	69bb      	ldr	r3, [r7, #24]
 8029da4:	691b      	ldr	r3, [r3, #16]
 8029da6:	2101      	movs	r1, #1
 8029da8:	6878      	ldr	r0, [r7, #4]
 8029daa:	f7ff fe10 	bl	80299ce <alloc_sarray>
 8029dae:	4602      	mov	r2, r0
 8029db0:	69bb      	ldr	r3, [r7, #24]
 8029db2:	601a      	str	r2, [r3, #0]
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
 8029db4:	693b      	ldr	r3, [r7, #16]
 8029db6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8029db8:	69bb      	ldr	r3, [r7, #24]
 8029dba:	615a      	str	r2, [r3, #20]
      sptr->cur_start_row = 0;
 8029dbc:	69bb      	ldr	r3, [r7, #24]
 8029dbe:	2200      	movs	r2, #0
 8029dc0:	619a      	str	r2, [r3, #24]
      sptr->first_undef_row = 0;
 8029dc2:	69bb      	ldr	r3, [r7, #24]
 8029dc4:	2200      	movs	r2, #0
 8029dc6:	61da      	str	r2, [r3, #28]
      sptr->dirty = FALSE;
 8029dc8:	69bb      	ldr	r3, [r7, #24]
 8029dca:	2200      	movs	r2, #0
 8029dcc:	625a      	str	r2, [r3, #36]	@ 0x24
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8029dce:	69bb      	ldr	r3, [r7, #24]
 8029dd0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8029dd2:	61bb      	str	r3, [r7, #24]
 8029dd4:	69bb      	ldr	r3, [r7, #24]
 8029dd6:	2b00      	cmp	r3, #0
 8029dd8:	d1b2      	bne.n	8029d40 <realize_virt_arrays+0xe8>
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8029dda:	693b      	ldr	r3, [r7, #16]
 8029ddc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8029dde:	617b      	str	r3, [r7, #20]
 8029de0:	e04a      	b.n	8029e78 <realize_virt_arrays+0x220>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 8029de2:	697b      	ldr	r3, [r7, #20]
 8029de4:	681b      	ldr	r3, [r3, #0]
 8029de6:	2b00      	cmp	r3, #0
 8029de8:	d143      	bne.n	8029e72 <realize_virt_arrays+0x21a>
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
 8029dea:	697b      	ldr	r3, [r7, #20]
 8029dec:	685b      	ldr	r3, [r3, #4]
 8029dee:	3b01      	subs	r3, #1
 8029df0:	461a      	mov	r2, r3
 8029df2:	697b      	ldr	r3, [r7, #20]
 8029df4:	68db      	ldr	r3, [r3, #12]
 8029df6:	fbb2 f3f3 	udiv	r3, r2, r3
 8029dfa:	3301      	adds	r3, #1
 8029dfc:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 8029dfe:	68ba      	ldr	r2, [r7, #8]
 8029e00:	69fb      	ldr	r3, [r7, #28]
 8029e02:	429a      	cmp	r2, r3
 8029e04:	dc04      	bgt.n	8029e10 <realize_virt_arrays+0x1b8>
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
 8029e06:	697b      	ldr	r3, [r7, #20]
 8029e08:	685a      	ldr	r2, [r3, #4]
 8029e0a:	697b      	ldr	r3, [r7, #20]
 8029e0c:	611a      	str	r2, [r3, #16]
 8029e0e:	e018      	b.n	8029e42 <realize_virt_arrays+0x1ea>
      } else {
	/* It doesn't fit in memory, create backing store. */
	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
 8029e10:	697b      	ldr	r3, [r7, #20]
 8029e12:	68db      	ldr	r3, [r3, #12]
 8029e14:	69fa      	ldr	r2, [r7, #28]
 8029e16:	fb03 f202 	mul.w	r2, r3, r2
 8029e1a:	697b      	ldr	r3, [r7, #20]
 8029e1c:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 8029e1e:	697b      	ldr	r3, [r7, #20]
 8029e20:	f103 0130 	add.w	r1, r3, #48	@ 0x30
				(long) bptr->rows_in_array *
 8029e24:	697b      	ldr	r3, [r7, #20]
 8029e26:	685b      	ldr	r3, [r3, #4]
 8029e28:	461a      	mov	r2, r3
				(long) bptr->blocksperrow *
 8029e2a:	697b      	ldr	r3, [r7, #20]
 8029e2c:	689b      	ldr	r3, [r3, #8]
				(long) bptr->rows_in_array *
 8029e2e:	fb02 f303 	mul.w	r3, r2, r3
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 8029e32:	01db      	lsls	r3, r3, #7
 8029e34:	461a      	mov	r2, r3
 8029e36:	6878      	ldr	r0, [r7, #4]
 8029e38:	f000 fc56 	bl	802a6e8 <jpeg_open_backing_store>
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
 8029e3c:	697b      	ldr	r3, [r7, #20]
 8029e3e:	2201      	movs	r2, #1
 8029e40:	629a      	str	r2, [r3, #40]	@ 0x28
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 8029e42:	697b      	ldr	r3, [r7, #20]
 8029e44:	689a      	ldr	r2, [r3, #8]
 8029e46:	697b      	ldr	r3, [r7, #20]
 8029e48:	691b      	ldr	r3, [r3, #16]
 8029e4a:	2101      	movs	r1, #1
 8029e4c:	6878      	ldr	r0, [r7, #4]
 8029e4e:	f7ff fe21 	bl	8029a94 <alloc_barray>
 8029e52:	4602      	mov	r2, r0
 8029e54:	697b      	ldr	r3, [r7, #20]
 8029e56:	601a      	str	r2, [r3, #0]
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
 8029e58:	693b      	ldr	r3, [r7, #16]
 8029e5a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8029e5c:	697b      	ldr	r3, [r7, #20]
 8029e5e:	615a      	str	r2, [r3, #20]
      bptr->cur_start_row = 0;
 8029e60:	697b      	ldr	r3, [r7, #20]
 8029e62:	2200      	movs	r2, #0
 8029e64:	619a      	str	r2, [r3, #24]
      bptr->first_undef_row = 0;
 8029e66:	697b      	ldr	r3, [r7, #20]
 8029e68:	2200      	movs	r2, #0
 8029e6a:	61da      	str	r2, [r3, #28]
      bptr->dirty = FALSE;
 8029e6c:	697b      	ldr	r3, [r7, #20]
 8029e6e:	2200      	movs	r2, #0
 8029e70:	625a      	str	r2, [r3, #36]	@ 0x24
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8029e72:	697b      	ldr	r3, [r7, #20]
 8029e74:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8029e76:	617b      	str	r3, [r7, #20]
 8029e78:	697b      	ldr	r3, [r7, #20]
 8029e7a:	2b00      	cmp	r3, #0
 8029e7c:	d1b1      	bne.n	8029de2 <realize_virt_arrays+0x18a>
 8029e7e:	e000      	b.n	8029e82 <realize_virt_arrays+0x22a>
    return;			/* no unrealized arrays, no work */
 8029e80:	bf00      	nop
    }
  }
}
 8029e82:	3728      	adds	r7, #40	@ 0x28
 8029e84:	46bd      	mov	sp, r7
 8029e86:	bd80      	pop	{r7, pc}
 8029e88:	3b9aca00 	.word	0x3b9aca00

08029e8c <do_sarray_io>:


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
 8029e8c:	b590      	push	{r4, r7, lr}
 8029e8e:	b08d      	sub	sp, #52	@ 0x34
 8029e90:	af02      	add	r7, sp, #8
 8029e92:	60f8      	str	r0, [r7, #12]
 8029e94:	60b9      	str	r1, [r7, #8]
 8029e96:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
 8029e98:	68bb      	ldr	r3, [r7, #8]
 8029e9a:	689b      	ldr	r3, [r3, #8]
 8029e9c:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 8029e9e:	68bb      	ldr	r3, [r7, #8]
 8029ea0:	699b      	ldr	r3, [r3, #24]
 8029ea2:	69fa      	ldr	r2, [r7, #28]
 8029ea4:	fb02 f303 	mul.w	r3, r2, r3
 8029ea8:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8029eaa:	2300      	movs	r3, #0
 8029eac:	623b      	str	r3, [r7, #32]
 8029eae:	e059      	b.n	8029f64 <do_sarray_io+0xd8>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 8029eb0:	68bb      	ldr	r3, [r7, #8]
 8029eb2:	691b      	ldr	r3, [r3, #16]
 8029eb4:	461a      	mov	r2, r3
 8029eb6:	6a3b      	ldr	r3, [r7, #32]
 8029eb8:	1ad3      	subs	r3, r2, r3
 8029eba:	68ba      	ldr	r2, [r7, #8]
 8029ebc:	6952      	ldr	r2, [r2, #20]
 8029ebe:	4293      	cmp	r3, r2
 8029ec0:	bfa8      	it	ge
 8029ec2:	4613      	movge	r3, r2
 8029ec4:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 8029ec6:	68bb      	ldr	r3, [r7, #8]
 8029ec8:	699b      	ldr	r3, [r3, #24]
 8029eca:	461a      	mov	r2, r3
 8029ecc:	6a3b      	ldr	r3, [r7, #32]
 8029ece:	4413      	add	r3, r2
 8029ed0:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 8029ed2:	68bb      	ldr	r3, [r7, #8]
 8029ed4:	69db      	ldr	r3, [r3, #28]
 8029ed6:	461a      	mov	r2, r3
 8029ed8:	697b      	ldr	r3, [r7, #20]
 8029eda:	1ad3      	subs	r3, r2, r3
 8029edc:	69ba      	ldr	r2, [r7, #24]
 8029ede:	4293      	cmp	r3, r2
 8029ee0:	bfa8      	it	ge
 8029ee2:	4613      	movge	r3, r2
 8029ee4:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 8029ee6:	68bb      	ldr	r3, [r7, #8]
 8029ee8:	685b      	ldr	r3, [r3, #4]
 8029eea:	461a      	mov	r2, r3
 8029eec:	697b      	ldr	r3, [r7, #20]
 8029eee:	1ad3      	subs	r3, r2, r3
 8029ef0:	69ba      	ldr	r2, [r7, #24]
 8029ef2:	4293      	cmp	r3, r2
 8029ef4:	bfa8      	it	ge
 8029ef6:	4613      	movge	r3, r2
 8029ef8:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 8029efa:	69bb      	ldr	r3, [r7, #24]
 8029efc:	2b00      	cmp	r3, #0
 8029efe:	dd38      	ble.n	8029f72 <do_sarray_io+0xe6>
      break;
    byte_count = rows * bytesperrow;
 8029f00:	69bb      	ldr	r3, [r7, #24]
 8029f02:	69fa      	ldr	r2, [r7, #28]
 8029f04:	fb02 f303 	mul.w	r3, r2, r3
 8029f08:	613b      	str	r3, [r7, #16]
    if (writing)
 8029f0a:	687b      	ldr	r3, [r7, #4]
 8029f0c:	2b00      	cmp	r3, #0
 8029f0e:	d010      	beq.n	8029f32 <do_sarray_io+0xa6>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8029f10:	68bb      	ldr	r3, [r7, #8]
 8029f12:	6b5c      	ldr	r4, [r3, #52]	@ 0x34
 8029f14:	68bb      	ldr	r3, [r7, #8]
 8029f16:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					    (void FAR *) ptr->mem_buffer[i],
 8029f1a:	68bb      	ldr	r3, [r7, #8]
 8029f1c:	681a      	ldr	r2, [r3, #0]
 8029f1e:	6a3b      	ldr	r3, [r7, #32]
 8029f20:	009b      	lsls	r3, r3, #2
 8029f22:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8029f24:	681a      	ldr	r2, [r3, #0]
 8029f26:	693b      	ldr	r3, [r7, #16]
 8029f28:	9300      	str	r3, [sp, #0]
 8029f2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029f2c:	68f8      	ldr	r0, [r7, #12]
 8029f2e:	47a0      	blx	r4
 8029f30:	e00f      	b.n	8029f52 <do_sarray_io+0xc6>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8029f32:	68bb      	ldr	r3, [r7, #8]
 8029f34:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 8029f36:	68bb      	ldr	r3, [r7, #8]
 8029f38:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					   (void FAR *) ptr->mem_buffer[i],
 8029f3c:	68bb      	ldr	r3, [r7, #8]
 8029f3e:	681a      	ldr	r2, [r3, #0]
 8029f40:	6a3b      	ldr	r3, [r7, #32]
 8029f42:	009b      	lsls	r3, r3, #2
 8029f44:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8029f46:	681a      	ldr	r2, [r3, #0]
 8029f48:	693b      	ldr	r3, [r7, #16]
 8029f4a:	9300      	str	r3, [sp, #0]
 8029f4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8029f4e:	68f8      	ldr	r0, [r7, #12]
 8029f50:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 8029f52:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029f54:	693b      	ldr	r3, [r7, #16]
 8029f56:	4413      	add	r3, r2
 8029f58:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8029f5a:	68bb      	ldr	r3, [r7, #8]
 8029f5c:	695a      	ldr	r2, [r3, #20]
 8029f5e:	6a3b      	ldr	r3, [r7, #32]
 8029f60:	4413      	add	r3, r2
 8029f62:	623b      	str	r3, [r7, #32]
 8029f64:	68bb      	ldr	r3, [r7, #8]
 8029f66:	691b      	ldr	r3, [r3, #16]
 8029f68:	461a      	mov	r2, r3
 8029f6a:	6a3b      	ldr	r3, [r7, #32]
 8029f6c:	4293      	cmp	r3, r2
 8029f6e:	db9f      	blt.n	8029eb0 <do_sarray_io+0x24>
  }
}
 8029f70:	e000      	b.n	8029f74 <do_sarray_io+0xe8>
      break;
 8029f72:	bf00      	nop
}
 8029f74:	bf00      	nop
 8029f76:	372c      	adds	r7, #44	@ 0x2c
 8029f78:	46bd      	mov	sp, r7
 8029f7a:	bd90      	pop	{r4, r7, pc}

08029f7c <do_barray_io>:


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
 8029f7c:	b590      	push	{r4, r7, lr}
 8029f7e:	b08d      	sub	sp, #52	@ 0x34
 8029f80:	af02      	add	r7, sp, #8
 8029f82:	60f8      	str	r0, [r7, #12]
 8029f84:	60b9      	str	r1, [r7, #8]
 8029f86:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
 8029f88:	68bb      	ldr	r3, [r7, #8]
 8029f8a:	689b      	ldr	r3, [r3, #8]
 8029f8c:	01db      	lsls	r3, r3, #7
 8029f8e:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 8029f90:	68bb      	ldr	r3, [r7, #8]
 8029f92:	699b      	ldr	r3, [r3, #24]
 8029f94:	69fa      	ldr	r2, [r7, #28]
 8029f96:	fb02 f303 	mul.w	r3, r2, r3
 8029f9a:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8029f9c:	2300      	movs	r3, #0
 8029f9e:	623b      	str	r3, [r7, #32]
 8029fa0:	e059      	b.n	802a056 <do_barray_io+0xda>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 8029fa2:	68bb      	ldr	r3, [r7, #8]
 8029fa4:	691b      	ldr	r3, [r3, #16]
 8029fa6:	461a      	mov	r2, r3
 8029fa8:	6a3b      	ldr	r3, [r7, #32]
 8029faa:	1ad3      	subs	r3, r2, r3
 8029fac:	68ba      	ldr	r2, [r7, #8]
 8029fae:	6952      	ldr	r2, [r2, #20]
 8029fb0:	4293      	cmp	r3, r2
 8029fb2:	bfa8      	it	ge
 8029fb4:	4613      	movge	r3, r2
 8029fb6:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 8029fb8:	68bb      	ldr	r3, [r7, #8]
 8029fba:	699b      	ldr	r3, [r3, #24]
 8029fbc:	461a      	mov	r2, r3
 8029fbe:	6a3b      	ldr	r3, [r7, #32]
 8029fc0:	4413      	add	r3, r2
 8029fc2:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 8029fc4:	68bb      	ldr	r3, [r7, #8]
 8029fc6:	69db      	ldr	r3, [r3, #28]
 8029fc8:	461a      	mov	r2, r3
 8029fca:	697b      	ldr	r3, [r7, #20]
 8029fcc:	1ad3      	subs	r3, r2, r3
 8029fce:	69ba      	ldr	r2, [r7, #24]
 8029fd0:	4293      	cmp	r3, r2
 8029fd2:	bfa8      	it	ge
 8029fd4:	4613      	movge	r3, r2
 8029fd6:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 8029fd8:	68bb      	ldr	r3, [r7, #8]
 8029fda:	685b      	ldr	r3, [r3, #4]
 8029fdc:	461a      	mov	r2, r3
 8029fde:	697b      	ldr	r3, [r7, #20]
 8029fe0:	1ad3      	subs	r3, r2, r3
 8029fe2:	69ba      	ldr	r2, [r7, #24]
 8029fe4:	4293      	cmp	r3, r2
 8029fe6:	bfa8      	it	ge
 8029fe8:	4613      	movge	r3, r2
 8029fea:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 8029fec:	69bb      	ldr	r3, [r7, #24]
 8029fee:	2b00      	cmp	r3, #0
 8029ff0:	dd38      	ble.n	802a064 <do_barray_io+0xe8>
      break;
    byte_count = rows * bytesperrow;
 8029ff2:	69bb      	ldr	r3, [r7, #24]
 8029ff4:	69fa      	ldr	r2, [r7, #28]
 8029ff6:	fb02 f303 	mul.w	r3, r2, r3
 8029ffa:	613b      	str	r3, [r7, #16]
    if (writing)
 8029ffc:	687b      	ldr	r3, [r7, #4]
 8029ffe:	2b00      	cmp	r3, #0
 802a000:	d010      	beq.n	802a024 <do_barray_io+0xa8>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802a002:	68bb      	ldr	r3, [r7, #8]
 802a004:	6b5c      	ldr	r4, [r3, #52]	@ 0x34
 802a006:	68bb      	ldr	r3, [r7, #8]
 802a008:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					    (void FAR *) ptr->mem_buffer[i],
 802a00c:	68bb      	ldr	r3, [r7, #8]
 802a00e:	681a      	ldr	r2, [r3, #0]
 802a010:	6a3b      	ldr	r3, [r7, #32]
 802a012:	009b      	lsls	r3, r3, #2
 802a014:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802a016:	681a      	ldr	r2, [r3, #0]
 802a018:	693b      	ldr	r3, [r7, #16]
 802a01a:	9300      	str	r3, [sp, #0]
 802a01c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a01e:	68f8      	ldr	r0, [r7, #12]
 802a020:	47a0      	blx	r4
 802a022:	e00f      	b.n	802a044 <do_barray_io+0xc8>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802a024:	68bb      	ldr	r3, [r7, #8]
 802a026:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 802a028:	68bb      	ldr	r3, [r7, #8]
 802a02a:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					   (void FAR *) ptr->mem_buffer[i],
 802a02e:	68bb      	ldr	r3, [r7, #8]
 802a030:	681a      	ldr	r2, [r3, #0]
 802a032:	6a3b      	ldr	r3, [r7, #32]
 802a034:	009b      	lsls	r3, r3, #2
 802a036:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802a038:	681a      	ldr	r2, [r3, #0]
 802a03a:	693b      	ldr	r3, [r7, #16]
 802a03c:	9300      	str	r3, [sp, #0]
 802a03e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a040:	68f8      	ldr	r0, [r7, #12]
 802a042:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 802a044:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802a046:	693b      	ldr	r3, [r7, #16]
 802a048:	4413      	add	r3, r2
 802a04a:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 802a04c:	68bb      	ldr	r3, [r7, #8]
 802a04e:	695a      	ldr	r2, [r3, #20]
 802a050:	6a3b      	ldr	r3, [r7, #32]
 802a052:	4413      	add	r3, r2
 802a054:	623b      	str	r3, [r7, #32]
 802a056:	68bb      	ldr	r3, [r7, #8]
 802a058:	691b      	ldr	r3, [r3, #16]
 802a05a:	461a      	mov	r2, r3
 802a05c:	6a3b      	ldr	r3, [r7, #32]
 802a05e:	4293      	cmp	r3, r2
 802a060:	db9f      	blt.n	8029fa2 <do_barray_io+0x26>
  }
}
 802a062:	e000      	b.n	802a066 <do_barray_io+0xea>
      break;
 802a064:	bf00      	nop
}
 802a066:	bf00      	nop
 802a068:	372c      	adds	r7, #44	@ 0x2c
 802a06a:	46bd      	mov	sp, r7
 802a06c:	bd90      	pop	{r4, r7, pc}

0802a06e <access_virt_sarray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802a06e:	b580      	push	{r7, lr}
 802a070:	b088      	sub	sp, #32
 802a072:	af00      	add	r7, sp, #0
 802a074:	60f8      	str	r0, [r7, #12]
 802a076:	60b9      	str	r1, [r7, #8]
 802a078:	607a      	str	r2, [r7, #4]
 802a07a:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 802a07c:	687a      	ldr	r2, [r7, #4]
 802a07e:	683b      	ldr	r3, [r7, #0]
 802a080:	4413      	add	r3, r2
 802a082:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802a084:	68bb      	ldr	r3, [r7, #8]
 802a086:	685b      	ldr	r3, [r3, #4]
 802a088:	697a      	ldr	r2, [r7, #20]
 802a08a:	429a      	cmp	r2, r3
 802a08c:	d808      	bhi.n	802a0a0 <access_virt_sarray+0x32>
 802a08e:	68bb      	ldr	r3, [r7, #8]
 802a090:	68db      	ldr	r3, [r3, #12]
 802a092:	683a      	ldr	r2, [r7, #0]
 802a094:	429a      	cmp	r2, r3
 802a096:	d803      	bhi.n	802a0a0 <access_virt_sarray+0x32>
      ptr->mem_buffer == NULL)
 802a098:	68bb      	ldr	r3, [r7, #8]
 802a09a:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802a09c:	2b00      	cmp	r3, #0
 802a09e:	d108      	bne.n	802a0b2 <access_virt_sarray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a0a0:	68fb      	ldr	r3, [r7, #12]
 802a0a2:	681b      	ldr	r3, [r3, #0]
 802a0a4:	2217      	movs	r2, #23
 802a0a6:	615a      	str	r2, [r3, #20]
 802a0a8:	68fb      	ldr	r3, [r7, #12]
 802a0aa:	681b      	ldr	r3, [r3, #0]
 802a0ac:	681b      	ldr	r3, [r3, #0]
 802a0ae:	68f8      	ldr	r0, [r7, #12]
 802a0b0:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 802a0b2:	68bb      	ldr	r3, [r7, #8]
 802a0b4:	699b      	ldr	r3, [r3, #24]
 802a0b6:	687a      	ldr	r2, [r7, #4]
 802a0b8:	429a      	cmp	r2, r3
 802a0ba:	d307      	bcc.n	802a0cc <access_virt_sarray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 802a0bc:	68bb      	ldr	r3, [r7, #8]
 802a0be:	699a      	ldr	r2, [r3, #24]
 802a0c0:	68bb      	ldr	r3, [r7, #8]
 802a0c2:	691b      	ldr	r3, [r3, #16]
 802a0c4:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 802a0c6:	697a      	ldr	r2, [r7, #20]
 802a0c8:	429a      	cmp	r2, r3
 802a0ca:	d933      	bls.n	802a134 <access_virt_sarray+0xc6>
    if (! ptr->b_s_open)
 802a0cc:	68bb      	ldr	r3, [r7, #8]
 802a0ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802a0d0:	2b00      	cmp	r3, #0
 802a0d2:	d108      	bne.n	802a0e6 <access_virt_sarray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 802a0d4:	68fb      	ldr	r3, [r7, #12]
 802a0d6:	681b      	ldr	r3, [r3, #0]
 802a0d8:	2247      	movs	r2, #71	@ 0x47
 802a0da:	615a      	str	r2, [r3, #20]
 802a0dc:	68fb      	ldr	r3, [r7, #12]
 802a0de:	681b      	ldr	r3, [r3, #0]
 802a0e0:	681b      	ldr	r3, [r3, #0]
 802a0e2:	68f8      	ldr	r0, [r7, #12]
 802a0e4:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 802a0e6:	68bb      	ldr	r3, [r7, #8]
 802a0e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802a0ea:	2b00      	cmp	r3, #0
 802a0ec:	d007      	beq.n	802a0fe <access_virt_sarray+0x90>
      do_sarray_io(cinfo, ptr, TRUE);
 802a0ee:	2201      	movs	r2, #1
 802a0f0:	68b9      	ldr	r1, [r7, #8]
 802a0f2:	68f8      	ldr	r0, [r7, #12]
 802a0f4:	f7ff feca 	bl	8029e8c <do_sarray_io>
      ptr->dirty = FALSE;
 802a0f8:	68bb      	ldr	r3, [r7, #8]
 802a0fa:	2200      	movs	r2, #0
 802a0fc:	625a      	str	r2, [r3, #36]	@ 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802a0fe:	68bb      	ldr	r3, [r7, #8]
 802a100:	699b      	ldr	r3, [r3, #24]
 802a102:	687a      	ldr	r2, [r7, #4]
 802a104:	429a      	cmp	r2, r3
 802a106:	d903      	bls.n	802a110 <access_virt_sarray+0xa2>
      ptr->cur_start_row = start_row;
 802a108:	68bb      	ldr	r3, [r7, #8]
 802a10a:	687a      	ldr	r2, [r7, #4]
 802a10c:	619a      	str	r2, [r3, #24]
 802a10e:	e00c      	b.n	802a12a <access_virt_sarray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 802a110:	697b      	ldr	r3, [r7, #20]
 802a112:	68ba      	ldr	r2, [r7, #8]
 802a114:	6912      	ldr	r2, [r2, #16]
 802a116:	1a9b      	subs	r3, r3, r2
 802a118:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 802a11a:	69bb      	ldr	r3, [r7, #24]
 802a11c:	2b00      	cmp	r3, #0
 802a11e:	da01      	bge.n	802a124 <access_virt_sarray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 802a120:	2300      	movs	r3, #0
 802a122:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 802a124:	69ba      	ldr	r2, [r7, #24]
 802a126:	68bb      	ldr	r3, [r7, #8]
 802a128:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_sarray_io(cinfo, ptr, FALSE);
 802a12a:	2200      	movs	r2, #0
 802a12c:	68b9      	ldr	r1, [r7, #8]
 802a12e:	68f8      	ldr	r0, [r7, #12]
 802a130:	f7ff feac 	bl	8029e8c <do_sarray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 802a134:	68bb      	ldr	r3, [r7, #8]
 802a136:	69db      	ldr	r3, [r3, #28]
 802a138:	697a      	ldr	r2, [r7, #20]
 802a13a:	429a      	cmp	r2, r3
 802a13c:	d94d      	bls.n	802a1da <access_virt_sarray+0x16c>
    if (ptr->first_undef_row < start_row) {
 802a13e:	68bb      	ldr	r3, [r7, #8]
 802a140:	69db      	ldr	r3, [r3, #28]
 802a142:	687a      	ldr	r2, [r7, #4]
 802a144:	429a      	cmp	r2, r3
 802a146:	d90e      	bls.n	802a166 <access_virt_sarray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 802a148:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a14a:	2b00      	cmp	r3, #0
 802a14c:	d008      	beq.n	802a160 <access_virt_sarray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a14e:	68fb      	ldr	r3, [r7, #12]
 802a150:	681b      	ldr	r3, [r3, #0]
 802a152:	2217      	movs	r2, #23
 802a154:	615a      	str	r2, [r3, #20]
 802a156:	68fb      	ldr	r3, [r7, #12]
 802a158:	681b      	ldr	r3, [r3, #0]
 802a15a:	681b      	ldr	r3, [r3, #0]
 802a15c:	68f8      	ldr	r0, [r7, #12]
 802a15e:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 802a160:	687b      	ldr	r3, [r7, #4]
 802a162:	61fb      	str	r3, [r7, #28]
 802a164:	e002      	b.n	802a16c <access_virt_sarray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 802a166:	68bb      	ldr	r3, [r7, #8]
 802a168:	69db      	ldr	r3, [r3, #28]
 802a16a:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802a16c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a16e:	2b00      	cmp	r3, #0
 802a170:	d002      	beq.n	802a178 <access_virt_sarray+0x10a>
      ptr->first_undef_row = end_row;
 802a172:	68bb      	ldr	r3, [r7, #8]
 802a174:	697a      	ldr	r2, [r7, #20]
 802a176:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 802a178:	68bb      	ldr	r3, [r7, #8]
 802a17a:	6a1b      	ldr	r3, [r3, #32]
 802a17c:	2b00      	cmp	r3, #0
 802a17e:	d020      	beq.n	802a1c2 <access_virt_sarray+0x154>
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 802a180:	68bb      	ldr	r3, [r7, #8]
 802a182:	689b      	ldr	r3, [r3, #8]
 802a184:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 802a186:	68bb      	ldr	r3, [r7, #8]
 802a188:	699b      	ldr	r3, [r3, #24]
 802a18a:	69fa      	ldr	r2, [r7, #28]
 802a18c:	1ad3      	subs	r3, r2, r3
 802a18e:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 802a190:	68bb      	ldr	r3, [r7, #8]
 802a192:	699b      	ldr	r3, [r3, #24]
 802a194:	697a      	ldr	r2, [r7, #20]
 802a196:	1ad3      	subs	r3, r2, r3
 802a198:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 802a19a:	e00d      	b.n	802a1b8 <access_virt_sarray+0x14a>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 802a19c:	68bb      	ldr	r3, [r7, #8]
 802a19e:	681a      	ldr	r2, [r3, #0]
 802a1a0:	69fb      	ldr	r3, [r7, #28]
 802a1a2:	009b      	lsls	r3, r3, #2
 802a1a4:	4413      	add	r3, r2
 802a1a6:	681b      	ldr	r3, [r3, #0]
 802a1a8:	693a      	ldr	r2, [r7, #16]
 802a1aa:	2100      	movs	r1, #0
 802a1ac:	4618      	mov	r0, r3
 802a1ae:	f003 fb20 	bl	802d7f2 <memset>
	undef_row++;
 802a1b2:	69fb      	ldr	r3, [r7, #28]
 802a1b4:	3301      	adds	r3, #1
 802a1b6:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 802a1b8:	69fa      	ldr	r2, [r7, #28]
 802a1ba:	697b      	ldr	r3, [r7, #20]
 802a1bc:	429a      	cmp	r2, r3
 802a1be:	d3ed      	bcc.n	802a19c <access_virt_sarray+0x12e>
 802a1c0:	e00b      	b.n	802a1da <access_virt_sarray+0x16c>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 802a1c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a1c4:	2b00      	cmp	r3, #0
 802a1c6:	d108      	bne.n	802a1da <access_virt_sarray+0x16c>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a1c8:	68fb      	ldr	r3, [r7, #12]
 802a1ca:	681b      	ldr	r3, [r3, #0]
 802a1cc:	2217      	movs	r2, #23
 802a1ce:	615a      	str	r2, [r3, #20]
 802a1d0:	68fb      	ldr	r3, [r7, #12]
 802a1d2:	681b      	ldr	r3, [r3, #0]
 802a1d4:	681b      	ldr	r3, [r3, #0]
 802a1d6:	68f8      	ldr	r0, [r7, #12]
 802a1d8:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802a1da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a1dc:	2b00      	cmp	r3, #0
 802a1de:	d002      	beq.n	802a1e6 <access_virt_sarray+0x178>
    ptr->dirty = TRUE;
 802a1e0:	68bb      	ldr	r3, [r7, #8]
 802a1e2:	2201      	movs	r2, #1
 802a1e4:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 802a1e6:	68bb      	ldr	r3, [r7, #8]
 802a1e8:	681a      	ldr	r2, [r3, #0]
 802a1ea:	68bb      	ldr	r3, [r7, #8]
 802a1ec:	699b      	ldr	r3, [r3, #24]
 802a1ee:	6879      	ldr	r1, [r7, #4]
 802a1f0:	1acb      	subs	r3, r1, r3
 802a1f2:	009b      	lsls	r3, r3, #2
 802a1f4:	4413      	add	r3, r2
}
 802a1f6:	4618      	mov	r0, r3
 802a1f8:	3720      	adds	r7, #32
 802a1fa:	46bd      	mov	sp, r7
 802a1fc:	bd80      	pop	{r7, pc}

0802a1fe <access_virt_barray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802a1fe:	b580      	push	{r7, lr}
 802a200:	b088      	sub	sp, #32
 802a202:	af00      	add	r7, sp, #0
 802a204:	60f8      	str	r0, [r7, #12]
 802a206:	60b9      	str	r1, [r7, #8]
 802a208:	607a      	str	r2, [r7, #4]
 802a20a:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 802a20c:	687a      	ldr	r2, [r7, #4]
 802a20e:	683b      	ldr	r3, [r7, #0]
 802a210:	4413      	add	r3, r2
 802a212:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802a214:	68bb      	ldr	r3, [r7, #8]
 802a216:	685b      	ldr	r3, [r3, #4]
 802a218:	697a      	ldr	r2, [r7, #20]
 802a21a:	429a      	cmp	r2, r3
 802a21c:	d808      	bhi.n	802a230 <access_virt_barray+0x32>
 802a21e:	68bb      	ldr	r3, [r7, #8]
 802a220:	68db      	ldr	r3, [r3, #12]
 802a222:	683a      	ldr	r2, [r7, #0]
 802a224:	429a      	cmp	r2, r3
 802a226:	d803      	bhi.n	802a230 <access_virt_barray+0x32>
      ptr->mem_buffer == NULL)
 802a228:	68bb      	ldr	r3, [r7, #8]
 802a22a:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802a22c:	2b00      	cmp	r3, #0
 802a22e:	d108      	bne.n	802a242 <access_virt_barray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a230:	68fb      	ldr	r3, [r7, #12]
 802a232:	681b      	ldr	r3, [r3, #0]
 802a234:	2217      	movs	r2, #23
 802a236:	615a      	str	r2, [r3, #20]
 802a238:	68fb      	ldr	r3, [r7, #12]
 802a23a:	681b      	ldr	r3, [r3, #0]
 802a23c:	681b      	ldr	r3, [r3, #0]
 802a23e:	68f8      	ldr	r0, [r7, #12]
 802a240:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 802a242:	68bb      	ldr	r3, [r7, #8]
 802a244:	699b      	ldr	r3, [r3, #24]
 802a246:	687a      	ldr	r2, [r7, #4]
 802a248:	429a      	cmp	r2, r3
 802a24a:	d307      	bcc.n	802a25c <access_virt_barray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 802a24c:	68bb      	ldr	r3, [r7, #8]
 802a24e:	699a      	ldr	r2, [r3, #24]
 802a250:	68bb      	ldr	r3, [r7, #8]
 802a252:	691b      	ldr	r3, [r3, #16]
 802a254:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 802a256:	697a      	ldr	r2, [r7, #20]
 802a258:	429a      	cmp	r2, r3
 802a25a:	d933      	bls.n	802a2c4 <access_virt_barray+0xc6>
    if (! ptr->b_s_open)
 802a25c:	68bb      	ldr	r3, [r7, #8]
 802a25e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802a260:	2b00      	cmp	r3, #0
 802a262:	d108      	bne.n	802a276 <access_virt_barray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 802a264:	68fb      	ldr	r3, [r7, #12]
 802a266:	681b      	ldr	r3, [r3, #0]
 802a268:	2247      	movs	r2, #71	@ 0x47
 802a26a:	615a      	str	r2, [r3, #20]
 802a26c:	68fb      	ldr	r3, [r7, #12]
 802a26e:	681b      	ldr	r3, [r3, #0]
 802a270:	681b      	ldr	r3, [r3, #0]
 802a272:	68f8      	ldr	r0, [r7, #12]
 802a274:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 802a276:	68bb      	ldr	r3, [r7, #8]
 802a278:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802a27a:	2b00      	cmp	r3, #0
 802a27c:	d007      	beq.n	802a28e <access_virt_barray+0x90>
      do_barray_io(cinfo, ptr, TRUE);
 802a27e:	2201      	movs	r2, #1
 802a280:	68b9      	ldr	r1, [r7, #8]
 802a282:	68f8      	ldr	r0, [r7, #12]
 802a284:	f7ff fe7a 	bl	8029f7c <do_barray_io>
      ptr->dirty = FALSE;
 802a288:	68bb      	ldr	r3, [r7, #8]
 802a28a:	2200      	movs	r2, #0
 802a28c:	625a      	str	r2, [r3, #36]	@ 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802a28e:	68bb      	ldr	r3, [r7, #8]
 802a290:	699b      	ldr	r3, [r3, #24]
 802a292:	687a      	ldr	r2, [r7, #4]
 802a294:	429a      	cmp	r2, r3
 802a296:	d903      	bls.n	802a2a0 <access_virt_barray+0xa2>
      ptr->cur_start_row = start_row;
 802a298:	68bb      	ldr	r3, [r7, #8]
 802a29a:	687a      	ldr	r2, [r7, #4]
 802a29c:	619a      	str	r2, [r3, #24]
 802a29e:	e00c      	b.n	802a2ba <access_virt_barray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 802a2a0:	697b      	ldr	r3, [r7, #20]
 802a2a2:	68ba      	ldr	r2, [r7, #8]
 802a2a4:	6912      	ldr	r2, [r2, #16]
 802a2a6:	1a9b      	subs	r3, r3, r2
 802a2a8:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 802a2aa:	69bb      	ldr	r3, [r7, #24]
 802a2ac:	2b00      	cmp	r3, #0
 802a2ae:	da01      	bge.n	802a2b4 <access_virt_barray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 802a2b0:	2300      	movs	r3, #0
 802a2b2:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 802a2b4:	69ba      	ldr	r2, [r7, #24]
 802a2b6:	68bb      	ldr	r3, [r7, #8]
 802a2b8:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_barray_io(cinfo, ptr, FALSE);
 802a2ba:	2200      	movs	r2, #0
 802a2bc:	68b9      	ldr	r1, [r7, #8]
 802a2be:	68f8      	ldr	r0, [r7, #12]
 802a2c0:	f7ff fe5c 	bl	8029f7c <do_barray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 802a2c4:	68bb      	ldr	r3, [r7, #8]
 802a2c6:	69db      	ldr	r3, [r3, #28]
 802a2c8:	697a      	ldr	r2, [r7, #20]
 802a2ca:	429a      	cmp	r2, r3
 802a2cc:	d94e      	bls.n	802a36c <access_virt_barray+0x16e>
    if (ptr->first_undef_row < start_row) {
 802a2ce:	68bb      	ldr	r3, [r7, #8]
 802a2d0:	69db      	ldr	r3, [r3, #28]
 802a2d2:	687a      	ldr	r2, [r7, #4]
 802a2d4:	429a      	cmp	r2, r3
 802a2d6:	d90e      	bls.n	802a2f6 <access_virt_barray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 802a2d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a2da:	2b00      	cmp	r3, #0
 802a2dc:	d008      	beq.n	802a2f0 <access_virt_barray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a2de:	68fb      	ldr	r3, [r7, #12]
 802a2e0:	681b      	ldr	r3, [r3, #0]
 802a2e2:	2217      	movs	r2, #23
 802a2e4:	615a      	str	r2, [r3, #20]
 802a2e6:	68fb      	ldr	r3, [r7, #12]
 802a2e8:	681b      	ldr	r3, [r3, #0]
 802a2ea:	681b      	ldr	r3, [r3, #0]
 802a2ec:	68f8      	ldr	r0, [r7, #12]
 802a2ee:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 802a2f0:	687b      	ldr	r3, [r7, #4]
 802a2f2:	61fb      	str	r3, [r7, #28]
 802a2f4:	e002      	b.n	802a2fc <access_virt_barray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 802a2f6:	68bb      	ldr	r3, [r7, #8]
 802a2f8:	69db      	ldr	r3, [r3, #28]
 802a2fa:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802a2fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a2fe:	2b00      	cmp	r3, #0
 802a300:	d002      	beq.n	802a308 <access_virt_barray+0x10a>
      ptr->first_undef_row = end_row;
 802a302:	68bb      	ldr	r3, [r7, #8]
 802a304:	697a      	ldr	r2, [r7, #20]
 802a306:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 802a308:	68bb      	ldr	r3, [r7, #8]
 802a30a:	6a1b      	ldr	r3, [r3, #32]
 802a30c:	2b00      	cmp	r3, #0
 802a30e:	d021      	beq.n	802a354 <access_virt_barray+0x156>
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 802a310:	68bb      	ldr	r3, [r7, #8]
 802a312:	689b      	ldr	r3, [r3, #8]
 802a314:	01db      	lsls	r3, r3, #7
 802a316:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 802a318:	68bb      	ldr	r3, [r7, #8]
 802a31a:	699b      	ldr	r3, [r3, #24]
 802a31c:	69fa      	ldr	r2, [r7, #28]
 802a31e:	1ad3      	subs	r3, r2, r3
 802a320:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 802a322:	68bb      	ldr	r3, [r7, #8]
 802a324:	699b      	ldr	r3, [r3, #24]
 802a326:	697a      	ldr	r2, [r7, #20]
 802a328:	1ad3      	subs	r3, r2, r3
 802a32a:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 802a32c:	e00d      	b.n	802a34a <access_virt_barray+0x14c>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 802a32e:	68bb      	ldr	r3, [r7, #8]
 802a330:	681a      	ldr	r2, [r3, #0]
 802a332:	69fb      	ldr	r3, [r7, #28]
 802a334:	009b      	lsls	r3, r3, #2
 802a336:	4413      	add	r3, r2
 802a338:	681b      	ldr	r3, [r3, #0]
 802a33a:	693a      	ldr	r2, [r7, #16]
 802a33c:	2100      	movs	r1, #0
 802a33e:	4618      	mov	r0, r3
 802a340:	f003 fa57 	bl	802d7f2 <memset>
	undef_row++;
 802a344:	69fb      	ldr	r3, [r7, #28]
 802a346:	3301      	adds	r3, #1
 802a348:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 802a34a:	69fa      	ldr	r2, [r7, #28]
 802a34c:	697b      	ldr	r3, [r7, #20]
 802a34e:	429a      	cmp	r2, r3
 802a350:	d3ed      	bcc.n	802a32e <access_virt_barray+0x130>
 802a352:	e00b      	b.n	802a36c <access_virt_barray+0x16e>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 802a354:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a356:	2b00      	cmp	r3, #0
 802a358:	d108      	bne.n	802a36c <access_virt_barray+0x16e>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802a35a:	68fb      	ldr	r3, [r7, #12]
 802a35c:	681b      	ldr	r3, [r3, #0]
 802a35e:	2217      	movs	r2, #23
 802a360:	615a      	str	r2, [r3, #20]
 802a362:	68fb      	ldr	r3, [r7, #12]
 802a364:	681b      	ldr	r3, [r3, #0]
 802a366:	681b      	ldr	r3, [r3, #0]
 802a368:	68f8      	ldr	r0, [r7, #12]
 802a36a:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802a36c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a36e:	2b00      	cmp	r3, #0
 802a370:	d002      	beq.n	802a378 <access_virt_barray+0x17a>
    ptr->dirty = TRUE;
 802a372:	68bb      	ldr	r3, [r7, #8]
 802a374:	2201      	movs	r2, #1
 802a376:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 802a378:	68bb      	ldr	r3, [r7, #8]
 802a37a:	681a      	ldr	r2, [r3, #0]
 802a37c:	68bb      	ldr	r3, [r7, #8]
 802a37e:	699b      	ldr	r3, [r3, #24]
 802a380:	6879      	ldr	r1, [r7, #4]
 802a382:	1acb      	subs	r3, r1, r3
 802a384:	009b      	lsls	r3, r3, #2
 802a386:	4413      	add	r3, r2
}
 802a388:	4618      	mov	r0, r3
 802a38a:	3720      	adds	r7, #32
 802a38c:	46bd      	mov	sp, r7
 802a38e:	bd80      	pop	{r7, pc}

0802a390 <free_pool>:
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
 802a390:	b580      	push	{r7, lr}
 802a392:	b08a      	sub	sp, #40	@ 0x28
 802a394:	af00      	add	r7, sp, #0
 802a396:	6078      	str	r0, [r7, #4]
 802a398:	6039      	str	r1, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802a39a:	687b      	ldr	r3, [r7, #4]
 802a39c:	685b      	ldr	r3, [r3, #4]
 802a39e:	617b      	str	r3, [r7, #20]
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 802a3a0:	683b      	ldr	r3, [r7, #0]
 802a3a2:	2b00      	cmp	r3, #0
 802a3a4:	db02      	blt.n	802a3ac <free_pool+0x1c>
 802a3a6:	683b      	ldr	r3, [r7, #0]
 802a3a8:	2b01      	cmp	r3, #1
 802a3aa:	dd0c      	ble.n	802a3c6 <free_pool+0x36>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802a3ac:	687b      	ldr	r3, [r7, #4]
 802a3ae:	681b      	ldr	r3, [r3, #0]
 802a3b0:	220f      	movs	r2, #15
 802a3b2:	615a      	str	r2, [r3, #20]
 802a3b4:	687b      	ldr	r3, [r7, #4]
 802a3b6:	681b      	ldr	r3, [r3, #0]
 802a3b8:	683a      	ldr	r2, [r7, #0]
 802a3ba:	619a      	str	r2, [r3, #24]
 802a3bc:	687b      	ldr	r3, [r7, #4]
 802a3be:	681b      	ldr	r3, [r3, #0]
 802a3c0:	681b      	ldr	r3, [r3, #0]
 802a3c2:	6878      	ldr	r0, [r7, #4]
 802a3c4:	4798      	blx	r3
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
 802a3c6:	683b      	ldr	r3, [r7, #0]
 802a3c8:	2b01      	cmp	r3, #1
 802a3ca:	d135      	bne.n	802a438 <free_pool+0xa8>
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802a3cc:	697b      	ldr	r3, [r7, #20]
 802a3ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802a3d0:	61fb      	str	r3, [r7, #28]
 802a3d2:	e010      	b.n	802a3f6 <free_pool+0x66>
      if (sptr->b_s_open) {	/* there may be no backing store */
 802a3d4:	69fb      	ldr	r3, [r7, #28]
 802a3d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802a3d8:	2b00      	cmp	r3, #0
 802a3da:	d009      	beq.n	802a3f0 <free_pool+0x60>
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
 802a3dc:	69fb      	ldr	r3, [r7, #28]
 802a3de:	2200      	movs	r2, #0
 802a3e0:	629a      	str	r2, [r3, #40]	@ 0x28
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
 802a3e2:	69fb      	ldr	r3, [r7, #28]
 802a3e4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 802a3e6:	69fa      	ldr	r2, [r7, #28]
 802a3e8:	3230      	adds	r2, #48	@ 0x30
 802a3ea:	4611      	mov	r1, r2
 802a3ec:	6878      	ldr	r0, [r7, #4]
 802a3ee:	4798      	blx	r3
    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802a3f0:	69fb      	ldr	r3, [r7, #28]
 802a3f2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802a3f4:	61fb      	str	r3, [r7, #28]
 802a3f6:	69fb      	ldr	r3, [r7, #28]
 802a3f8:	2b00      	cmp	r3, #0
 802a3fa:	d1eb      	bne.n	802a3d4 <free_pool+0x44>
      }
    }
    mem->virt_sarray_list = NULL;
 802a3fc:	697b      	ldr	r3, [r7, #20]
 802a3fe:	2200      	movs	r2, #0
 802a400:	645a      	str	r2, [r3, #68]	@ 0x44
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802a402:	697b      	ldr	r3, [r7, #20]
 802a404:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 802a406:	61bb      	str	r3, [r7, #24]
 802a408:	e010      	b.n	802a42c <free_pool+0x9c>
      if (bptr->b_s_open) {	/* there may be no backing store */
 802a40a:	69bb      	ldr	r3, [r7, #24]
 802a40c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802a40e:	2b00      	cmp	r3, #0
 802a410:	d009      	beq.n	802a426 <free_pool+0x96>
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
 802a412:	69bb      	ldr	r3, [r7, #24]
 802a414:	2200      	movs	r2, #0
 802a416:	629a      	str	r2, [r3, #40]	@ 0x28
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
 802a418:	69bb      	ldr	r3, [r7, #24]
 802a41a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 802a41c:	69ba      	ldr	r2, [r7, #24]
 802a41e:	3230      	adds	r2, #48	@ 0x30
 802a420:	4611      	mov	r1, r2
 802a422:	6878      	ldr	r0, [r7, #4]
 802a424:	4798      	blx	r3
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802a426:	69bb      	ldr	r3, [r7, #24]
 802a428:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802a42a:	61bb      	str	r3, [r7, #24]
 802a42c:	69bb      	ldr	r3, [r7, #24]
 802a42e:	2b00      	cmp	r3, #0
 802a430:	d1eb      	bne.n	802a40a <free_pool+0x7a>
      }
    }
    mem->virt_barray_list = NULL;
 802a432:	697b      	ldr	r3, [r7, #20]
 802a434:	2200      	movs	r2, #0
 802a436:	649a      	str	r2, [r3, #72]	@ 0x48
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
 802a438:	697a      	ldr	r2, [r7, #20]
 802a43a:	683b      	ldr	r3, [r7, #0]
 802a43c:	330e      	adds	r3, #14
 802a43e:	009b      	lsls	r3, r3, #2
 802a440:	4413      	add	r3, r2
 802a442:	685b      	ldr	r3, [r3, #4]
 802a444:	623b      	str	r3, [r7, #32]
  mem->large_list[pool_id] = NULL;
 802a446:	697a      	ldr	r2, [r7, #20]
 802a448:	683b      	ldr	r3, [r7, #0]
 802a44a:	330e      	adds	r3, #14
 802a44c:	009b      	lsls	r3, r3, #2
 802a44e:	4413      	add	r3, r2
 802a450:	2200      	movs	r2, #0
 802a452:	605a      	str	r2, [r3, #4]

  while (lhdr_ptr != NULL) {
 802a454:	e018      	b.n	802a488 <free_pool+0xf8>
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 802a456:	6a3b      	ldr	r3, [r7, #32]
 802a458:	681b      	ldr	r3, [r3, #0]
 802a45a:	60bb      	str	r3, [r7, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 802a45c:	6a3b      	ldr	r3, [r7, #32]
 802a45e:	685a      	ldr	r2, [r3, #4]
		  lhdr_ptr->hdr.bytes_left +
 802a460:	6a3b      	ldr	r3, [r7, #32]
 802a462:	689b      	ldr	r3, [r3, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 802a464:	4413      	add	r3, r2
 802a466:	3310      	adds	r3, #16
 802a468:	60fb      	str	r3, [r7, #12]
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 802a46a:	68fa      	ldr	r2, [r7, #12]
 802a46c:	6a39      	ldr	r1, [r7, #32]
 802a46e:	6878      	ldr	r0, [r7, #4]
 802a470:	f000 f91f 	bl	802a6b2 <jpeg_free_large>
    mem->total_space_allocated -= space_freed;
 802a474:	697b      	ldr	r3, [r7, #20]
 802a476:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802a478:	461a      	mov	r2, r3
 802a47a:	68fb      	ldr	r3, [r7, #12]
 802a47c:	1ad3      	subs	r3, r2, r3
 802a47e:	461a      	mov	r2, r3
 802a480:	697b      	ldr	r3, [r7, #20]
 802a482:	64da      	str	r2, [r3, #76]	@ 0x4c
    lhdr_ptr = next_lhdr_ptr;
 802a484:	68bb      	ldr	r3, [r7, #8]
 802a486:	623b      	str	r3, [r7, #32]
  while (lhdr_ptr != NULL) {
 802a488:	6a3b      	ldr	r3, [r7, #32]
 802a48a:	2b00      	cmp	r3, #0
 802a48c:	d1e3      	bne.n	802a456 <free_pool+0xc6>
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
 802a48e:	697a      	ldr	r2, [r7, #20]
 802a490:	683b      	ldr	r3, [r7, #0]
 802a492:	330c      	adds	r3, #12
 802a494:	009b      	lsls	r3, r3, #2
 802a496:	4413      	add	r3, r2
 802a498:	685b      	ldr	r3, [r3, #4]
 802a49a:	627b      	str	r3, [r7, #36]	@ 0x24
  mem->small_list[pool_id] = NULL;
 802a49c:	697a      	ldr	r2, [r7, #20]
 802a49e:	683b      	ldr	r3, [r7, #0]
 802a4a0:	330c      	adds	r3, #12
 802a4a2:	009b      	lsls	r3, r3, #2
 802a4a4:	4413      	add	r3, r2
 802a4a6:	2200      	movs	r2, #0
 802a4a8:	605a      	str	r2, [r3, #4]

  while (shdr_ptr != NULL) {
 802a4aa:	e018      	b.n	802a4de <free_pool+0x14e>
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 802a4ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a4ae:	681b      	ldr	r3, [r3, #0]
 802a4b0:	613b      	str	r3, [r7, #16]
    space_freed = shdr_ptr->hdr.bytes_used +
 802a4b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a4b4:	685a      	ldr	r2, [r3, #4]
		  shdr_ptr->hdr.bytes_left +
 802a4b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a4b8:	689b      	ldr	r3, [r3, #8]
    space_freed = shdr_ptr->hdr.bytes_used +
 802a4ba:	4413      	add	r3, r2
 802a4bc:	3310      	adds	r3, #16
 802a4be:	60fb      	str	r3, [r7, #12]
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 802a4c0:	68fa      	ldr	r2, [r7, #12]
 802a4c2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802a4c4:	6878      	ldr	r0, [r7, #4]
 802a4c6:	f000 f8da 	bl	802a67e <jpeg_free_small>
    mem->total_space_allocated -= space_freed;
 802a4ca:	697b      	ldr	r3, [r7, #20]
 802a4cc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802a4ce:	461a      	mov	r2, r3
 802a4d0:	68fb      	ldr	r3, [r7, #12]
 802a4d2:	1ad3      	subs	r3, r2, r3
 802a4d4:	461a      	mov	r2, r3
 802a4d6:	697b      	ldr	r3, [r7, #20]
 802a4d8:	64da      	str	r2, [r3, #76]	@ 0x4c
    shdr_ptr = next_shdr_ptr;
 802a4da:	693b      	ldr	r3, [r7, #16]
 802a4dc:	627b      	str	r3, [r7, #36]	@ 0x24
  while (shdr_ptr != NULL) {
 802a4de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a4e0:	2b00      	cmp	r3, #0
 802a4e2:	d1e3      	bne.n	802a4ac <free_pool+0x11c>
  }
}
 802a4e4:	bf00      	nop
 802a4e6:	bf00      	nop
 802a4e8:	3728      	adds	r7, #40	@ 0x28
 802a4ea:	46bd      	mov	sp, r7
 802a4ec:	bd80      	pop	{r7, pc}

0802a4ee <self_destruct>:
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
 802a4ee:	b580      	push	{r7, lr}
 802a4f0:	b084      	sub	sp, #16
 802a4f2:	af00      	add	r7, sp, #0
 802a4f4:	6078      	str	r0, [r7, #4]

  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802a4f6:	2301      	movs	r3, #1
 802a4f8:	60fb      	str	r3, [r7, #12]
 802a4fa:	e006      	b.n	802a50a <self_destruct+0x1c>
    free_pool(cinfo, pool);
 802a4fc:	68f9      	ldr	r1, [r7, #12]
 802a4fe:	6878      	ldr	r0, [r7, #4]
 802a500:	f7ff ff46 	bl	802a390 <free_pool>
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802a504:	68fb      	ldr	r3, [r7, #12]
 802a506:	3b01      	subs	r3, #1
 802a508:	60fb      	str	r3, [r7, #12]
 802a50a:	68fb      	ldr	r3, [r7, #12]
 802a50c:	2b00      	cmp	r3, #0
 802a50e:	daf5      	bge.n	802a4fc <self_destruct+0xe>
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
 802a510:	687b      	ldr	r3, [r7, #4]
 802a512:	685b      	ldr	r3, [r3, #4]
 802a514:	2254      	movs	r2, #84	@ 0x54
 802a516:	4619      	mov	r1, r3
 802a518:	6878      	ldr	r0, [r7, #4]
 802a51a:	f000 f8b0 	bl	802a67e <jpeg_free_small>
  cinfo->mem = NULL;		/* ensures I will be called only once */
 802a51e:	687b      	ldr	r3, [r7, #4]
 802a520:	2200      	movs	r2, #0
 802a522:	605a      	str	r2, [r3, #4]

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
 802a524:	6878      	ldr	r0, [r7, #4]
 802a526:	f000 f8fd 	bl	802a724 <jpeg_mem_term>
}
 802a52a:	bf00      	nop
 802a52c:	3710      	adds	r7, #16
 802a52e:	46bd      	mov	sp, r7
 802a530:	bd80      	pop	{r7, pc}
	...

0802a534 <jinit_memory_mgr>:
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
 802a534:	b580      	push	{r7, lr}
 802a536:	b086      	sub	sp, #24
 802a538:	af00      	add	r7, sp, #0
 802a53a:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */
 802a53c:	687b      	ldr	r3, [r7, #4]
 802a53e:	2200      	movs	r2, #0
 802a540:	605a      	str	r2, [r3, #4]
  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   * a multiple of SIZEOF(ALIGN_TYPE).
   * Again, an "unreachable code" warning may be ignored here.
   * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   */
  test_mac = (size_t) MAX_ALLOC_CHUNK;
 802a542:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 802a546:	613b      	str	r3, [r7, #16]
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
 802a548:	693b      	ldr	r3, [r7, #16]
 802a54a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 802a54e:	d008      	beq.n	802a562 <jinit_memory_mgr+0x2e>
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
 802a550:	687b      	ldr	r3, [r7, #4]
 802a552:	681b      	ldr	r3, [r3, #0]
 802a554:	2202      	movs	r2, #2
 802a556:	615a      	str	r2, [r3, #20]
 802a558:	687b      	ldr	r3, [r7, #4]
 802a55a:	681b      	ldr	r3, [r3, #0]
 802a55c:	681b      	ldr	r3, [r3, #0]
 802a55e:	6878      	ldr	r0, [r7, #4]
 802a560:	4798      	blx	r3

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
 802a562:	6878      	ldr	r0, [r7, #4]
 802a564:	f000 f8d3 	bl	802a70e <jpeg_mem_init>
 802a568:	60f8      	str	r0, [r7, #12]

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
 802a56a:	2154      	movs	r1, #84	@ 0x54
 802a56c:	6878      	ldr	r0, [r7, #4]
 802a56e:	f000 f879 	bl	802a664 <jpeg_get_small>
 802a572:	60b8      	str	r0, [r7, #8]

  if (mem == NULL) {
 802a574:	68bb      	ldr	r3, [r7, #8]
 802a576:	2b00      	cmp	r3, #0
 802a578:	d10f      	bne.n	802a59a <jinit_memory_mgr+0x66>
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
 802a57a:	6878      	ldr	r0, [r7, #4]
 802a57c:	f000 f8d2 	bl	802a724 <jpeg_mem_term>
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
 802a580:	687b      	ldr	r3, [r7, #4]
 802a582:	681b      	ldr	r3, [r3, #0]
 802a584:	2238      	movs	r2, #56	@ 0x38
 802a586:	615a      	str	r2, [r3, #20]
 802a588:	687b      	ldr	r3, [r7, #4]
 802a58a:	681b      	ldr	r3, [r3, #0]
 802a58c:	2200      	movs	r2, #0
 802a58e:	619a      	str	r2, [r3, #24]
 802a590:	687b      	ldr	r3, [r7, #4]
 802a592:	681b      	ldr	r3, [r3, #0]
 802a594:	681b      	ldr	r3, [r3, #0]
 802a596:	6878      	ldr	r0, [r7, #4]
 802a598:	4798      	blx	r3
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
 802a59a:	68bb      	ldr	r3, [r7, #8]
 802a59c:	4a26      	ldr	r2, [pc, #152]	@ (802a638 <jinit_memory_mgr+0x104>)
 802a59e:	601a      	str	r2, [r3, #0]
  mem->pub.alloc_large = alloc_large;
 802a5a0:	68bb      	ldr	r3, [r7, #8]
 802a5a2:	4a26      	ldr	r2, [pc, #152]	@ (802a63c <jinit_memory_mgr+0x108>)
 802a5a4:	605a      	str	r2, [r3, #4]
  mem->pub.alloc_sarray = alloc_sarray;
 802a5a6:	68bb      	ldr	r3, [r7, #8]
 802a5a8:	4a25      	ldr	r2, [pc, #148]	@ (802a640 <jinit_memory_mgr+0x10c>)
 802a5aa:	609a      	str	r2, [r3, #8]
  mem->pub.alloc_barray = alloc_barray;
 802a5ac:	68bb      	ldr	r3, [r7, #8]
 802a5ae:	4a25      	ldr	r2, [pc, #148]	@ (802a644 <jinit_memory_mgr+0x110>)
 802a5b0:	60da      	str	r2, [r3, #12]
  mem->pub.request_virt_sarray = request_virt_sarray;
 802a5b2:	68bb      	ldr	r3, [r7, #8]
 802a5b4:	4a24      	ldr	r2, [pc, #144]	@ (802a648 <jinit_memory_mgr+0x114>)
 802a5b6:	611a      	str	r2, [r3, #16]
  mem->pub.request_virt_barray = request_virt_barray;
 802a5b8:	68bb      	ldr	r3, [r7, #8]
 802a5ba:	4a24      	ldr	r2, [pc, #144]	@ (802a64c <jinit_memory_mgr+0x118>)
 802a5bc:	615a      	str	r2, [r3, #20]
  mem->pub.realize_virt_arrays = realize_virt_arrays;
 802a5be:	68bb      	ldr	r3, [r7, #8]
 802a5c0:	4a23      	ldr	r2, [pc, #140]	@ (802a650 <jinit_memory_mgr+0x11c>)
 802a5c2:	619a      	str	r2, [r3, #24]
  mem->pub.access_virt_sarray = access_virt_sarray;
 802a5c4:	68bb      	ldr	r3, [r7, #8]
 802a5c6:	4a23      	ldr	r2, [pc, #140]	@ (802a654 <jinit_memory_mgr+0x120>)
 802a5c8:	61da      	str	r2, [r3, #28]
  mem->pub.access_virt_barray = access_virt_barray;
 802a5ca:	68bb      	ldr	r3, [r7, #8]
 802a5cc:	4a22      	ldr	r2, [pc, #136]	@ (802a658 <jinit_memory_mgr+0x124>)
 802a5ce:	621a      	str	r2, [r3, #32]
  mem->pub.free_pool = free_pool;
 802a5d0:	68bb      	ldr	r3, [r7, #8]
 802a5d2:	4a22      	ldr	r2, [pc, #136]	@ (802a65c <jinit_memory_mgr+0x128>)
 802a5d4:	625a      	str	r2, [r3, #36]	@ 0x24
  mem->pub.self_destruct = self_destruct;
 802a5d6:	68bb      	ldr	r3, [r7, #8]
 802a5d8:	4a21      	ldr	r2, [pc, #132]	@ (802a660 <jinit_memory_mgr+0x12c>)
 802a5da:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Make MAX_ALLOC_CHUNK accessible to other modules */
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
 802a5dc:	68bb      	ldr	r3, [r7, #8]
 802a5de:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 802a5e2:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;
 802a5e4:	68bb      	ldr	r3, [r7, #8]
 802a5e6:	68fa      	ldr	r2, [r7, #12]
 802a5e8:	62da      	str	r2, [r3, #44]	@ 0x2c

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802a5ea:	2301      	movs	r3, #1
 802a5ec:	617b      	str	r3, [r7, #20]
 802a5ee:	e010      	b.n	802a612 <jinit_memory_mgr+0xde>
    mem->small_list[pool] = NULL;
 802a5f0:	68ba      	ldr	r2, [r7, #8]
 802a5f2:	697b      	ldr	r3, [r7, #20]
 802a5f4:	330c      	adds	r3, #12
 802a5f6:	009b      	lsls	r3, r3, #2
 802a5f8:	4413      	add	r3, r2
 802a5fa:	2200      	movs	r2, #0
 802a5fc:	605a      	str	r2, [r3, #4]
    mem->large_list[pool] = NULL;
 802a5fe:	68ba      	ldr	r2, [r7, #8]
 802a600:	697b      	ldr	r3, [r7, #20]
 802a602:	330e      	adds	r3, #14
 802a604:	009b      	lsls	r3, r3, #2
 802a606:	4413      	add	r3, r2
 802a608:	2200      	movs	r2, #0
 802a60a:	605a      	str	r2, [r3, #4]
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802a60c:	697b      	ldr	r3, [r7, #20]
 802a60e:	3b01      	subs	r3, #1
 802a610:	617b      	str	r3, [r7, #20]
 802a612:	697b      	ldr	r3, [r7, #20]
 802a614:	2b00      	cmp	r3, #0
 802a616:	daeb      	bge.n	802a5f0 <jinit_memory_mgr+0xbc>
  }
  mem->virt_sarray_list = NULL;
 802a618:	68bb      	ldr	r3, [r7, #8]
 802a61a:	2200      	movs	r2, #0
 802a61c:	645a      	str	r2, [r3, #68]	@ 0x44
  mem->virt_barray_list = NULL;
 802a61e:	68bb      	ldr	r3, [r7, #8]
 802a620:	2200      	movs	r2, #0
 802a622:	649a      	str	r2, [r3, #72]	@ 0x48

  mem->total_space_allocated = SIZEOF(my_memory_mgr);
 802a624:	68bb      	ldr	r3, [r7, #8]
 802a626:	2254      	movs	r2, #84	@ 0x54
 802a628:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;
 802a62a:	68ba      	ldr	r2, [r7, #8]
 802a62c:	687b      	ldr	r3, [r7, #4]
 802a62e:	605a      	str	r2, [r3, #4]
      }
    }
  }
#endif

}
 802a630:	bf00      	nop
 802a632:	3718      	adds	r7, #24
 802a634:	46bd      	mov	sp, r7
 802a636:	bd80      	pop	{r7, pc}
 802a638:	08029789 	.word	0x08029789
 802a63c:	08029909 	.word	0x08029909
 802a640:	080299cf 	.word	0x080299cf
 802a644:	08029a95 	.word	0x08029a95
 802a648:	08029b61 	.word	0x08029b61
 802a64c:	08029bdd 	.word	0x08029bdd
 802a650:	08029c59 	.word	0x08029c59
 802a654:	0802a06f 	.word	0x0802a06f
 802a658:	0802a1ff 	.word	0x0802a1ff
 802a65c:	0802a391 	.word	0x0802a391
 802a660:	0802a4ef 	.word	0x0802a4ef

0802a664 <jpeg_get_small>:
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
 802a664:	b580      	push	{r7, lr}
 802a666:	b082      	sub	sp, #8
 802a668:	af00      	add	r7, sp, #0
 802a66a:	6078      	str	r0, [r7, #4]
 802a66c:	6039      	str	r1, [r7, #0]
  return (void *) JMALLOC(sizeofobject);
 802a66e:	6838      	ldr	r0, [r7, #0]
 802a670:	f002 feca 	bl	802d408 <malloc>
 802a674:	4603      	mov	r3, r0
}
 802a676:	4618      	mov	r0, r3
 802a678:	3708      	adds	r7, #8
 802a67a:	46bd      	mov	sp, r7
 802a67c:	bd80      	pop	{r7, pc}

0802a67e <jpeg_free_small>:

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
 802a67e:	b580      	push	{r7, lr}
 802a680:	b084      	sub	sp, #16
 802a682:	af00      	add	r7, sp, #0
 802a684:	60f8      	str	r0, [r7, #12]
 802a686:	60b9      	str	r1, [r7, #8]
 802a688:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802a68a:	68b8      	ldr	r0, [r7, #8]
 802a68c:	f002 fec4 	bl	802d418 <free>
}
 802a690:	bf00      	nop
 802a692:	3710      	adds	r7, #16
 802a694:	46bd      	mov	sp, r7
 802a696:	bd80      	pop	{r7, pc}

0802a698 <jpeg_get_large>:
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
 802a698:	b580      	push	{r7, lr}
 802a69a:	b082      	sub	sp, #8
 802a69c:	af00      	add	r7, sp, #0
 802a69e:	6078      	str	r0, [r7, #4]
 802a6a0:	6039      	str	r1, [r7, #0]
  return (void FAR *) JMALLOC(sizeofobject);
 802a6a2:	6838      	ldr	r0, [r7, #0]
 802a6a4:	f002 feb0 	bl	802d408 <malloc>
 802a6a8:	4603      	mov	r3, r0
}
 802a6aa:	4618      	mov	r0, r3
 802a6ac:	3708      	adds	r7, #8
 802a6ae:	46bd      	mov	sp, r7
 802a6b0:	bd80      	pop	{r7, pc}

0802a6b2 <jpeg_free_large>:

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
 802a6b2:	b580      	push	{r7, lr}
 802a6b4:	b084      	sub	sp, #16
 802a6b6:	af00      	add	r7, sp, #0
 802a6b8:	60f8      	str	r0, [r7, #12]
 802a6ba:	60b9      	str	r1, [r7, #8]
 802a6bc:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802a6be:	68b8      	ldr	r0, [r7, #8]
 802a6c0:	f002 feaa 	bl	802d418 <free>
}
 802a6c4:	bf00      	nop
 802a6c6:	3710      	adds	r7, #16
 802a6c8:	46bd      	mov	sp, r7
 802a6ca:	bd80      	pop	{r7, pc}

0802a6cc <jpeg_mem_available>:
 */

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
 802a6cc:	b480      	push	{r7}
 802a6ce:	b085      	sub	sp, #20
 802a6d0:	af00      	add	r7, sp, #0
 802a6d2:	60f8      	str	r0, [r7, #12]
 802a6d4:	60b9      	str	r1, [r7, #8]
 802a6d6:	607a      	str	r2, [r7, #4]
 802a6d8:	603b      	str	r3, [r7, #0]
  return max_bytes_needed;
 802a6da:	687b      	ldr	r3, [r7, #4]
}
 802a6dc:	4618      	mov	r0, r3
 802a6de:	3714      	adds	r7, #20
 802a6e0:	46bd      	mov	sp, r7
 802a6e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a6e6:	4770      	bx	lr

0802a6e8 <jpeg_open_backing_store>:
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
 802a6e8:	b580      	push	{r7, lr}
 802a6ea:	b084      	sub	sp, #16
 802a6ec:	af00      	add	r7, sp, #0
 802a6ee:	60f8      	str	r0, [r7, #12]
 802a6f0:	60b9      	str	r1, [r7, #8]
 802a6f2:	607a      	str	r2, [r7, #4]
  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
 802a6f4:	68fb      	ldr	r3, [r7, #12]
 802a6f6:	681b      	ldr	r3, [r3, #0]
 802a6f8:	2233      	movs	r2, #51	@ 0x33
 802a6fa:	615a      	str	r2, [r3, #20]
 802a6fc:	68fb      	ldr	r3, [r7, #12]
 802a6fe:	681b      	ldr	r3, [r3, #0]
 802a700:	681b      	ldr	r3, [r3, #0]
 802a702:	68f8      	ldr	r0, [r7, #12]
 802a704:	4798      	blx	r3
}
 802a706:	bf00      	nop
 802a708:	3710      	adds	r7, #16
 802a70a:	46bd      	mov	sp, r7
 802a70c:	bd80      	pop	{r7, pc}

0802a70e <jpeg_mem_init>:
 * cleanup required.  Here, there isn't any.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
 802a70e:	b480      	push	{r7}
 802a710:	b083      	sub	sp, #12
 802a712:	af00      	add	r7, sp, #0
 802a714:	6078      	str	r0, [r7, #4]
  return 0;			/* just set max_memory_to_use to 0 */
 802a716:	2300      	movs	r3, #0
}
 802a718:	4618      	mov	r0, r3
 802a71a:	370c      	adds	r7, #12
 802a71c:	46bd      	mov	sp, r7
 802a71e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a722:	4770      	bx	lr

0802a724 <jpeg_mem_term>:

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
 802a724:	b480      	push	{r7}
 802a726:	b083      	sub	sp, #12
 802a728:	af00      	add	r7, sp, #0
 802a72a:	6078      	str	r0, [r7, #4]
}
 802a72c:	bf00      	nop
 802a72e:	370c      	adds	r7, #12
 802a730:	46bd      	mov	sp, r7
 802a732:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a736:	4770      	bx	lr

0802a738 <select_ncolors>:
LOCAL(int)
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
 802a738:	b580      	push	{r7, lr}
 802a73a:	b08a      	sub	sp, #40	@ 0x28
 802a73c:	af00      	add	r7, sp, #0
 802a73e:	6078      	str	r0, [r7, #4]
 802a740:	6039      	str	r1, [r7, #0]
  int nc = cinfo->out_color_components; /* number of color components */
 802a742:	687b      	ldr	r3, [r7, #4]
 802a744:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802a746:	613b      	str	r3, [r7, #16]
  int max_colors = cinfo->desired_number_of_colors;
 802a748:	687b      	ldr	r3, [r7, #4]
 802a74a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802a74c:	60fb      	str	r3, [r7, #12]
  long temp;
  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
 802a74e:	2301      	movs	r3, #1
 802a750:	623b      	str	r3, [r7, #32]
  do {
    iroot++;
 802a752:	6a3b      	ldr	r3, [r7, #32]
 802a754:	3301      	adds	r3, #1
 802a756:	623b      	str	r3, [r7, #32]
    temp = iroot;		/* set temp = iroot ** nc */
 802a758:	6a3b      	ldr	r3, [r7, #32]
 802a75a:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 802a75c:	2301      	movs	r3, #1
 802a75e:	61fb      	str	r3, [r7, #28]
 802a760:	e007      	b.n	802a772 <select_ncolors+0x3a>
      temp *= iroot;
 802a762:	697b      	ldr	r3, [r7, #20]
 802a764:	6a3a      	ldr	r2, [r7, #32]
 802a766:	fb02 f303 	mul.w	r3, r2, r3
 802a76a:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 802a76c:	69fb      	ldr	r3, [r7, #28]
 802a76e:	3301      	adds	r3, #1
 802a770:	61fb      	str	r3, [r7, #28]
 802a772:	69fa      	ldr	r2, [r7, #28]
 802a774:	693b      	ldr	r3, [r7, #16]
 802a776:	429a      	cmp	r2, r3
 802a778:	dbf3      	blt.n	802a762 <select_ncolors+0x2a>
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
 802a77a:	697a      	ldr	r2, [r7, #20]
 802a77c:	68fb      	ldr	r3, [r7, #12]
 802a77e:	429a      	cmp	r2, r3
 802a780:	dde7      	ble.n	802a752 <select_ncolors+0x1a>
  iroot--;			/* now iroot = floor(root) */
 802a782:	6a3b      	ldr	r3, [r7, #32]
 802a784:	3b01      	subs	r3, #1
 802a786:	623b      	str	r3, [r7, #32]

  /* Must have at least 2 color values per component */
  if (iroot < 2)
 802a788:	6a3b      	ldr	r3, [r7, #32]
 802a78a:	2b01      	cmp	r3, #1
 802a78c:	dc0c      	bgt.n	802a7a8 <select_ncolors+0x70>
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
 802a78e:	687b      	ldr	r3, [r7, #4]
 802a790:	681b      	ldr	r3, [r3, #0]
 802a792:	223a      	movs	r2, #58	@ 0x3a
 802a794:	615a      	str	r2, [r3, #20]
 802a796:	687b      	ldr	r3, [r7, #4]
 802a798:	681b      	ldr	r3, [r3, #0]
 802a79a:	697a      	ldr	r2, [r7, #20]
 802a79c:	619a      	str	r2, [r3, #24]
 802a79e:	687b      	ldr	r3, [r7, #4]
 802a7a0:	681b      	ldr	r3, [r3, #0]
 802a7a2:	681b      	ldr	r3, [r3, #0]
 802a7a4:	6878      	ldr	r0, [r7, #4]
 802a7a6:	4798      	blx	r3

  /* Initialize to iroot color values for each component */
  total_colors = 1;
 802a7a8:	2301      	movs	r3, #1
 802a7aa:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < nc; i++) {
 802a7ac:	2300      	movs	r3, #0
 802a7ae:	61fb      	str	r3, [r7, #28]
 802a7b0:	e00d      	b.n	802a7ce <select_ncolors+0x96>
    Ncolors[i] = iroot;
 802a7b2:	69fb      	ldr	r3, [r7, #28]
 802a7b4:	009b      	lsls	r3, r3, #2
 802a7b6:	683a      	ldr	r2, [r7, #0]
 802a7b8:	4413      	add	r3, r2
 802a7ba:	6a3a      	ldr	r2, [r7, #32]
 802a7bc:	601a      	str	r2, [r3, #0]
    total_colors *= iroot;
 802a7be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802a7c0:	6a3a      	ldr	r2, [r7, #32]
 802a7c2:	fb02 f303 	mul.w	r3, r2, r3
 802a7c6:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < nc; i++) {
 802a7c8:	69fb      	ldr	r3, [r7, #28]
 802a7ca:	3301      	adds	r3, #1
 802a7cc:	61fb      	str	r3, [r7, #28]
 802a7ce:	69fa      	ldr	r2, [r7, #28]
 802a7d0:	693b      	ldr	r3, [r7, #16]
 802a7d2:	429a      	cmp	r2, r3
 802a7d4:	dbed      	blt.n	802a7b2 <select_ncolors+0x7a>
   * Sometimes, the first component can be incremented more than once!
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
 802a7d6:	2300      	movs	r3, #0
 802a7d8:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 802a7da:	2300      	movs	r3, #0
 802a7dc:	61fb      	str	r3, [r7, #28]
 802a7de:	e030      	b.n	802a842 <select_ncolors+0x10a>
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
 802a7e0:	687b      	ldr	r3, [r7, #4]
 802a7e2:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 802a7e6:	2b02      	cmp	r3, #2
 802a7e8:	d104      	bne.n	802a7f4 <select_ncolors+0xbc>
 802a7ea:	4a1d      	ldr	r2, [pc, #116]	@ (802a860 <select_ncolors+0x128>)
 802a7ec:	69fb      	ldr	r3, [r7, #28]
 802a7ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802a7f2:	e000      	b.n	802a7f6 <select_ncolors+0xbe>
 802a7f4:	69fb      	ldr	r3, [r7, #28]
 802a7f6:	60bb      	str	r3, [r7, #8]
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
 802a7f8:	68bb      	ldr	r3, [r7, #8]
 802a7fa:	009b      	lsls	r3, r3, #2
 802a7fc:	683a      	ldr	r2, [r7, #0]
 802a7fe:	4413      	add	r3, r2
 802a800:	681b      	ldr	r3, [r3, #0]
 802a802:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802a804:	fb92 f3f3 	sdiv	r3, r2, r3
 802a808:	617b      	str	r3, [r7, #20]
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
 802a80a:	68bb      	ldr	r3, [r7, #8]
 802a80c:	009b      	lsls	r3, r3, #2
 802a80e:	683a      	ldr	r2, [r7, #0]
 802a810:	4413      	add	r3, r2
 802a812:	681b      	ldr	r3, [r3, #0]
 802a814:	1c5a      	adds	r2, r3, #1
 802a816:	697b      	ldr	r3, [r7, #20]
 802a818:	fb02 f303 	mul.w	r3, r2, r3
 802a81c:	617b      	str	r3, [r7, #20]
      if (temp > (long) max_colors)
 802a81e:	697a      	ldr	r2, [r7, #20]
 802a820:	68fb      	ldr	r3, [r7, #12]
 802a822:	429a      	cmp	r2, r3
 802a824:	dc12      	bgt.n	802a84c <select_ncolors+0x114>
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
 802a826:	68bb      	ldr	r3, [r7, #8]
 802a828:	009b      	lsls	r3, r3, #2
 802a82a:	683a      	ldr	r2, [r7, #0]
 802a82c:	4413      	add	r3, r2
 802a82e:	681a      	ldr	r2, [r3, #0]
 802a830:	3201      	adds	r2, #1
 802a832:	601a      	str	r2, [r3, #0]
      total_colors = (int) temp;
 802a834:	697b      	ldr	r3, [r7, #20]
 802a836:	627b      	str	r3, [r7, #36]	@ 0x24
      changed = TRUE;
 802a838:	2301      	movs	r3, #1
 802a83a:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 802a83c:	69fb      	ldr	r3, [r7, #28]
 802a83e:	3301      	adds	r3, #1
 802a840:	61fb      	str	r3, [r7, #28]
 802a842:	69fa      	ldr	r2, [r7, #28]
 802a844:	693b      	ldr	r3, [r7, #16]
 802a846:	429a      	cmp	r2, r3
 802a848:	dbca      	blt.n	802a7e0 <select_ncolors+0xa8>
 802a84a:	e000      	b.n	802a84e <select_ncolors+0x116>
	break;			/* won't fit, done with this pass */
 802a84c:	bf00      	nop
    }
  } while (changed);
 802a84e:	69bb      	ldr	r3, [r7, #24]
 802a850:	2b00      	cmp	r3, #0
 802a852:	d1c0      	bne.n	802a7d6 <select_ncolors+0x9e>

  return total_colors;
 802a854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 802a856:	4618      	mov	r0, r3
 802a858:	3728      	adds	r7, #40	@ 0x28
 802a85a:	46bd      	mov	sp, r7
 802a85c:	bd80      	pop	{r7, pc}
 802a85e:	bf00      	nop
 802a860:	080308a4 	.word	0x080308a4

0802a864 <output_value>:

LOCAL(int)
output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
{
 802a864:	b480      	push	{r7}
 802a866:	b085      	sub	sp, #20
 802a868:	af00      	add	r7, sp, #0
 802a86a:	60f8      	str	r0, [r7, #12]
 802a86c:	60b9      	str	r1, [r7, #8]
 802a86e:	607a      	str	r2, [r7, #4]
 802a870:	603b      	str	r3, [r7, #0]
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
 802a872:	687a      	ldr	r2, [r7, #4]
 802a874:	4613      	mov	r3, r2
 802a876:	021b      	lsls	r3, r3, #8
 802a878:	1a9a      	subs	r2, r3, r2
 802a87a:	683b      	ldr	r3, [r7, #0]
 802a87c:	0fd9      	lsrs	r1, r3, #31
 802a87e:	440b      	add	r3, r1
 802a880:	105b      	asrs	r3, r3, #1
 802a882:	441a      	add	r2, r3
 802a884:	683b      	ldr	r3, [r7, #0]
 802a886:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802a88a:	4618      	mov	r0, r3
 802a88c:	3714      	adds	r7, #20
 802a88e:	46bd      	mov	sp, r7
 802a890:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a894:	4770      	bx	lr

0802a896 <largest_input_value>:

LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
 802a896:	b480      	push	{r7}
 802a898:	b085      	sub	sp, #20
 802a89a:	af00      	add	r7, sp, #0
 802a89c:	60f8      	str	r0, [r7, #12]
 802a89e:	60b9      	str	r1, [r7, #8]
 802a8a0:	607a      	str	r2, [r7, #4]
 802a8a2:	603b      	str	r3, [r7, #0]
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
 802a8a4:	687b      	ldr	r3, [r7, #4]
 802a8a6:	005b      	lsls	r3, r3, #1
 802a8a8:	1c5a      	adds	r2, r3, #1
 802a8aa:	4613      	mov	r3, r2
 802a8ac:	021b      	lsls	r3, r3, #8
 802a8ae:	1a9a      	subs	r2, r3, r2
 802a8b0:	683b      	ldr	r3, [r7, #0]
 802a8b2:	441a      	add	r2, r3
 802a8b4:	683b      	ldr	r3, [r7, #0]
 802a8b6:	005b      	lsls	r3, r3, #1
 802a8b8:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802a8bc:	4618      	mov	r0, r3
 802a8be:	3714      	adds	r7, #20
 802a8c0:	46bd      	mov	sp, r7
 802a8c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a8c6:	4770      	bx	lr

0802a8c8 <create_colormap>:
 * Create the colormap.
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
 802a8c8:	b590      	push	{r4, r7, lr}
 802a8ca:	b08f      	sub	sp, #60	@ 0x3c
 802a8cc:	af00      	add	r7, sp, #0
 802a8ce:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802a8d0:	687b      	ldr	r3, [r7, #4]
 802a8d2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802a8d6:	623b      	str	r3, [r7, #32]
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
 802a8d8:	6a3b      	ldr	r3, [r7, #32]
 802a8da:	3320      	adds	r3, #32
 802a8dc:	4619      	mov	r1, r3
 802a8de:	6878      	ldr	r0, [r7, #4]
 802a8e0:	f7ff ff2a 	bl	802a738 <select_ncolors>
 802a8e4:	61f8      	str	r0, [r7, #28]

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
 802a8e6:	687b      	ldr	r3, [r7, #4]
 802a8e8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802a8ea:	2b03      	cmp	r3, #3
 802a8ec:	d120      	bne.n	802a930 <create_colormap+0x68>
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
 802a8ee:	687b      	ldr	r3, [r7, #4]
 802a8f0:	681b      	ldr	r3, [r3, #0]
 802a8f2:	3318      	adds	r3, #24
 802a8f4:	61bb      	str	r3, [r7, #24]
 802a8f6:	69bb      	ldr	r3, [r7, #24]
 802a8f8:	69fa      	ldr	r2, [r7, #28]
 802a8fa:	601a      	str	r2, [r3, #0]
 802a8fc:	69bb      	ldr	r3, [r7, #24]
 802a8fe:	3304      	adds	r3, #4
 802a900:	6a3a      	ldr	r2, [r7, #32]
 802a902:	6a12      	ldr	r2, [r2, #32]
 802a904:	601a      	str	r2, [r3, #0]
 802a906:	69bb      	ldr	r3, [r7, #24]
 802a908:	3308      	adds	r3, #8
 802a90a:	6a3a      	ldr	r2, [r7, #32]
 802a90c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 802a90e:	601a      	str	r2, [r3, #0]
 802a910:	69bb      	ldr	r3, [r7, #24]
 802a912:	330c      	adds	r3, #12
 802a914:	6a3a      	ldr	r2, [r7, #32]
 802a916:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 802a918:	601a      	str	r2, [r3, #0]
 802a91a:	687b      	ldr	r3, [r7, #4]
 802a91c:	681b      	ldr	r3, [r3, #0]
 802a91e:	2260      	movs	r2, #96	@ 0x60
 802a920:	615a      	str	r2, [r3, #20]
 802a922:	687b      	ldr	r3, [r7, #4]
 802a924:	681b      	ldr	r3, [r3, #0]
 802a926:	685b      	ldr	r3, [r3, #4]
 802a928:	2101      	movs	r1, #1
 802a92a:	6878      	ldr	r0, [r7, #4]
 802a92c:	4798      	blx	r3
 802a92e:	e00d      	b.n	802a94c <create_colormap+0x84>
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
 802a930:	687b      	ldr	r3, [r7, #4]
 802a932:	681b      	ldr	r3, [r3, #0]
 802a934:	2261      	movs	r2, #97	@ 0x61
 802a936:	615a      	str	r2, [r3, #20]
 802a938:	687b      	ldr	r3, [r7, #4]
 802a93a:	681b      	ldr	r3, [r3, #0]
 802a93c:	69fa      	ldr	r2, [r7, #28]
 802a93e:	619a      	str	r2, [r3, #24]
 802a940:	687b      	ldr	r3, [r7, #4]
 802a942:	681b      	ldr	r3, [r3, #0]
 802a944:	685b      	ldr	r3, [r3, #4]
 802a946:	2101      	movs	r1, #1
 802a948:	6878      	ldr	r0, [r7, #4]
 802a94a:	4798      	blx	r3

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
 802a94c:	687b      	ldr	r3, [r7, #4]
 802a94e:	685b      	ldr	r3, [r3, #4]
 802a950:	689c      	ldr	r4, [r3, #8]
 802a952:	69fa      	ldr	r2, [r7, #28]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
 802a954:	687b      	ldr	r3, [r7, #4]
 802a956:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
  colormap = (*cinfo->mem->alloc_sarray)
 802a958:	2101      	movs	r1, #1
 802a95a:	6878      	ldr	r0, [r7, #4]
 802a95c:	47a0      	blx	r4
 802a95e:	6178      	str	r0, [r7, #20]

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;
 802a960:	69fb      	ldr	r3, [r7, #28]
 802a962:	62bb      	str	r3, [r7, #40]	@ 0x28

  for (i = 0; i < cinfo->out_color_components; i++) {
 802a964:	2300      	movs	r3, #0
 802a966:	637b      	str	r3, [r7, #52]	@ 0x34
 802a968:	e045      	b.n	802a9f6 <create_colormap+0x12e>
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802a96a:	6a3b      	ldr	r3, [r7, #32]
 802a96c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802a96e:	3208      	adds	r2, #8
 802a970:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a974:	613b      	str	r3, [r7, #16]
    blksize = blkdist / nci;
 802a976:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802a978:	693b      	ldr	r3, [r7, #16]
 802a97a:	fb92 f3f3 	sdiv	r3, r2, r3
 802a97e:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < nci; j++) {
 802a980:	2300      	movs	r3, #0
 802a982:	633b      	str	r3, [r7, #48]	@ 0x30
 802a984:	e02e      	b.n	802a9e4 <create_colormap+0x11c>
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
 802a986:	693b      	ldr	r3, [r7, #16]
 802a988:	3b01      	subs	r3, #1
 802a98a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802a98c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 802a98e:	6878      	ldr	r0, [r7, #4]
 802a990:	f7ff ff68 	bl	802a864 <output_value>
 802a994:	60b8      	str	r0, [r7, #8]
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 802a996:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802a998:	68fa      	ldr	r2, [r7, #12]
 802a99a:	fb02 f303 	mul.w	r3, r2, r3
 802a99e:	627b      	str	r3, [r7, #36]	@ 0x24
 802a9a0:	e019      	b.n	802a9d6 <create_colormap+0x10e>
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
 802a9a2:	2300      	movs	r3, #0
 802a9a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802a9a6:	e00e      	b.n	802a9c6 <create_colormap+0xfe>
	  colormap[i][ptr+k] = (JSAMPLE) val;
 802a9a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802a9aa:	009b      	lsls	r3, r3, #2
 802a9ac:	697a      	ldr	r2, [r7, #20]
 802a9ae:	4413      	add	r3, r2
 802a9b0:	681b      	ldr	r3, [r3, #0]
 802a9b2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802a9b4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802a9b6:	440a      	add	r2, r1
 802a9b8:	4413      	add	r3, r2
 802a9ba:	68ba      	ldr	r2, [r7, #8]
 802a9bc:	b2d2      	uxtb	r2, r2
 802a9be:	701a      	strb	r2, [r3, #0]
	for (k = 0; k < blksize; k++)
 802a9c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802a9c2:	3301      	adds	r3, #1
 802a9c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802a9c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802a9c8:	68fb      	ldr	r3, [r7, #12]
 802a9ca:	429a      	cmp	r2, r3
 802a9cc:	dbec      	blt.n	802a9a8 <create_colormap+0xe0>
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 802a9ce:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802a9d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802a9d2:	4413      	add	r3, r2
 802a9d4:	627b      	str	r3, [r7, #36]	@ 0x24
 802a9d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802a9d8:	69fb      	ldr	r3, [r7, #28]
 802a9da:	429a      	cmp	r2, r3
 802a9dc:	dbe1      	blt.n	802a9a2 <create_colormap+0xda>
    for (j = 0; j < nci; j++) {
 802a9de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802a9e0:	3301      	adds	r3, #1
 802a9e2:	633b      	str	r3, [r7, #48]	@ 0x30
 802a9e4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802a9e6:	693b      	ldr	r3, [r7, #16]
 802a9e8:	429a      	cmp	r2, r3
 802a9ea:	dbcc      	blt.n	802a986 <create_colormap+0xbe>
      }
    }
    blkdist = blksize;		/* blksize of this color is blkdist of next */
 802a9ec:	68fb      	ldr	r3, [r7, #12]
 802a9ee:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = 0; i < cinfo->out_color_components; i++) {
 802a9f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802a9f2:	3301      	adds	r3, #1
 802a9f4:	637b      	str	r3, [r7, #52]	@ 0x34
 802a9f6:	687b      	ldr	r3, [r7, #4]
 802a9f8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802a9fa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802a9fc:	429a      	cmp	r2, r3
 802a9fe:	dbb4      	blt.n	802a96a <create_colormap+0xa2>
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
 802aa00:	6a3b      	ldr	r3, [r7, #32]
 802aa02:	697a      	ldr	r2, [r7, #20]
 802aa04:	611a      	str	r2, [r3, #16]
  cquantize->sv_actual = total_colors;
 802aa06:	6a3b      	ldr	r3, [r7, #32]
 802aa08:	69fa      	ldr	r2, [r7, #28]
 802aa0a:	615a      	str	r2, [r3, #20]
}
 802aa0c:	bf00      	nop
 802aa0e:	373c      	adds	r7, #60	@ 0x3c
 802aa10:	46bd      	mov	sp, r7
 802aa12:	bd90      	pop	{r4, r7, pc}

0802aa14 <create_colorindex>:
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
 802aa14:	b590      	push	{r4, r7, lr}
 802aa16:	b08d      	sub	sp, #52	@ 0x34
 802aa18:	af00      	add	r7, sp, #0
 802aa1a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802aa1c:	687b      	ldr	r3, [r7, #4]
 802aa1e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802aa22:	617b      	str	r3, [r7, #20]
  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
 802aa24:	687b      	ldr	r3, [r7, #4]
 802aa26:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802aa2a:	2b01      	cmp	r3, #1
 802aa2c:	d106      	bne.n	802aa3c <create_colorindex+0x28>
    pad = MAXJSAMPLE*2;
 802aa2e:	f44f 73ff 	mov.w	r3, #510	@ 0x1fe
 802aa32:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = TRUE;
 802aa34:	697b      	ldr	r3, [r7, #20]
 802aa36:	2201      	movs	r2, #1
 802aa38:	61da      	str	r2, [r3, #28]
 802aa3a:	e004      	b.n	802aa46 <create_colorindex+0x32>
  } else {
    pad = 0;
 802aa3c:	2300      	movs	r3, #0
 802aa3e:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = FALSE;
 802aa40:	697b      	ldr	r3, [r7, #20]
 802aa42:	2200      	movs	r2, #0
 802aa44:	61da      	str	r2, [r3, #28]
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802aa46:	687b      	ldr	r3, [r7, #4]
 802aa48:	685b      	ldr	r3, [r3, #4]
 802aa4a:	689c      	ldr	r4, [r3, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
 802aa4c:	69bb      	ldr	r3, [r7, #24]
 802aa4e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802aa52:	461a      	mov	r2, r3
     (JDIMENSION) cinfo->out_color_components);
 802aa54:	687b      	ldr	r3, [r7, #4]
 802aa56:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802aa58:	2101      	movs	r1, #1
 802aa5a:	6878      	ldr	r0, [r7, #4]
 802aa5c:	47a0      	blx	r4
 802aa5e:	4602      	mov	r2, r0
 802aa60:	697b      	ldr	r3, [r7, #20]
 802aa62:	619a      	str	r2, [r3, #24]

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;
 802aa64:	697b      	ldr	r3, [r7, #20]
 802aa66:	695b      	ldr	r3, [r3, #20]
 802aa68:	623b      	str	r3, [r7, #32]

  for (i = 0; i < cinfo->out_color_components; i++) {
 802aa6a:	2300      	movs	r3, #0
 802aa6c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802aa6e:	e06e      	b.n	802ab4e <create_colorindex+0x13a>
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802aa70:	697b      	ldr	r3, [r7, #20]
 802aa72:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802aa74:	3208      	adds	r2, #8
 802aa76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802aa7a:	613b      	str	r3, [r7, #16]
    blksize = blksize / nci;
 802aa7c:	6a3a      	ldr	r2, [r7, #32]
 802aa7e:	693b      	ldr	r3, [r7, #16]
 802aa80:	fb92 f3f3 	sdiv	r3, r2, r3
 802aa84:	623b      	str	r3, [r7, #32]

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
 802aa86:	69bb      	ldr	r3, [r7, #24]
 802aa88:	2b00      	cmp	r3, #0
 802aa8a:	d00c      	beq.n	802aaa6 <create_colorindex+0x92>
      cquantize->colorindex[i] += MAXJSAMPLE;
 802aa8c:	697b      	ldr	r3, [r7, #20]
 802aa8e:	699a      	ldr	r2, [r3, #24]
 802aa90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802aa92:	009b      	lsls	r3, r3, #2
 802aa94:	4413      	add	r3, r2
 802aa96:	681a      	ldr	r2, [r3, #0]
 802aa98:	697b      	ldr	r3, [r7, #20]
 802aa9a:	6999      	ldr	r1, [r3, #24]
 802aa9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802aa9e:	009b      	lsls	r3, r3, #2
 802aaa0:	440b      	add	r3, r1
 802aaa2:	32ff      	adds	r2, #255	@ 0xff
 802aaa4:	601a      	str	r2, [r3, #0]

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
 802aaa6:	697b      	ldr	r3, [r7, #20]
 802aaa8:	699a      	ldr	r2, [r3, #24]
 802aaaa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802aaac:	009b      	lsls	r3, r3, #2
 802aaae:	4413      	add	r3, r2
 802aab0:	681b      	ldr	r3, [r3, #0]
 802aab2:	60fb      	str	r3, [r7, #12]
    val = 0;
 802aab4:	2300      	movs	r3, #0
 802aab6:	61fb      	str	r3, [r7, #28]
    k = largest_input_value(cinfo, i, 0, nci-1);
 802aab8:	693b      	ldr	r3, [r7, #16]
 802aaba:	3b01      	subs	r3, #1
 802aabc:	2200      	movs	r2, #0
 802aabe:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802aac0:	6878      	ldr	r0, [r7, #4]
 802aac2:	f7ff fee8 	bl	802a896 <largest_input_value>
 802aac6:	6278      	str	r0, [r7, #36]	@ 0x24
    for (j = 0; j <= MAXJSAMPLE; j++) {
 802aac8:	2300      	movs	r3, #0
 802aaca:	62bb      	str	r3, [r7, #40]	@ 0x28
 802aacc:	e01c      	b.n	802ab08 <create_colorindex+0xf4>
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
 802aace:	69fb      	ldr	r3, [r7, #28]
 802aad0:	3301      	adds	r3, #1
 802aad2:	61fb      	str	r3, [r7, #28]
 802aad4:	693b      	ldr	r3, [r7, #16]
 802aad6:	3b01      	subs	r3, #1
 802aad8:	69fa      	ldr	r2, [r7, #28]
 802aada:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802aadc:	6878      	ldr	r0, [r7, #4]
 802aade:	f7ff feda 	bl	802a896 <largest_input_value>
 802aae2:	6278      	str	r0, [r7, #36]	@ 0x24
      while (j > k)		/* advance val if past boundary */
 802aae4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802aae6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802aae8:	429a      	cmp	r2, r3
 802aaea:	dcf0      	bgt.n	802aace <create_colorindex+0xba>
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
 802aaec:	69fb      	ldr	r3, [r7, #28]
 802aaee:	b2d9      	uxtb	r1, r3
 802aaf0:	6a3b      	ldr	r3, [r7, #32]
 802aaf2:	b2da      	uxtb	r2, r3
 802aaf4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802aaf6:	68f8      	ldr	r0, [r7, #12]
 802aaf8:	4403      	add	r3, r0
 802aafa:	fb11 f202 	smulbb	r2, r1, r2
 802aafe:	b2d2      	uxtb	r2, r2
 802ab00:	701a      	strb	r2, [r3, #0]
    for (j = 0; j <= MAXJSAMPLE; j++) {
 802ab02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab04:	3301      	adds	r3, #1
 802ab06:	62bb      	str	r3, [r7, #40]	@ 0x28
 802ab08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab0a:	2bff      	cmp	r3, #255	@ 0xff
 802ab0c:	ddea      	ble.n	802aae4 <create_colorindex+0xd0>
    }
    /* Pad at both ends if necessary */
    if (pad)
 802ab0e:	69bb      	ldr	r3, [r7, #24]
 802ab10:	2b00      	cmp	r3, #0
 802ab12:	d019      	beq.n	802ab48 <create_colorindex+0x134>
      for (j = 1; j <= MAXJSAMPLE; j++) {
 802ab14:	2301      	movs	r3, #1
 802ab16:	62bb      	str	r3, [r7, #40]	@ 0x28
 802ab18:	e013      	b.n	802ab42 <create_colorindex+0x12e>
	indexptr[-j] = indexptr[0];
 802ab1a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab1c:	425b      	negs	r3, r3
 802ab1e:	461a      	mov	r2, r3
 802ab20:	68fb      	ldr	r3, [r7, #12]
 802ab22:	4413      	add	r3, r2
 802ab24:	68fa      	ldr	r2, [r7, #12]
 802ab26:	7812      	ldrb	r2, [r2, #0]
 802ab28:	701a      	strb	r2, [r3, #0]
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
 802ab2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab2c:	33ff      	adds	r3, #255	@ 0xff
 802ab2e:	461a      	mov	r2, r3
 802ab30:	68fb      	ldr	r3, [r7, #12]
 802ab32:	4413      	add	r3, r2
 802ab34:	68fa      	ldr	r2, [r7, #12]
 802ab36:	f892 20ff 	ldrb.w	r2, [r2, #255]	@ 0xff
 802ab3a:	701a      	strb	r2, [r3, #0]
      for (j = 1; j <= MAXJSAMPLE; j++) {
 802ab3c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab3e:	3301      	adds	r3, #1
 802ab40:	62bb      	str	r3, [r7, #40]	@ 0x28
 802ab42:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ab44:	2bff      	cmp	r3, #255	@ 0xff
 802ab46:	dde8      	ble.n	802ab1a <create_colorindex+0x106>
  for (i = 0; i < cinfo->out_color_components; i++) {
 802ab48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ab4a:	3301      	adds	r3, #1
 802ab4c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802ab4e:	687b      	ldr	r3, [r7, #4]
 802ab50:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802ab52:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802ab54:	429a      	cmp	r2, r3
 802ab56:	db8b      	blt.n	802aa70 <create_colorindex+0x5c>
      }
  }
}
 802ab58:	bf00      	nop
 802ab5a:	bf00      	nop
 802ab5c:	3734      	adds	r7, #52	@ 0x34
 802ab5e:	46bd      	mov	sp, r7
 802ab60:	bd90      	pop	{r4, r7, pc}
	...

0802ab64 <make_odither_array>:
 * distinct output values.
 */

LOCAL(ODITHER_MATRIX_PTR)
make_odither_array (j_decompress_ptr cinfo, int ncolors)
{
 802ab64:	b580      	push	{r7, lr}
 802ab66:	b088      	sub	sp, #32
 802ab68:	af00      	add	r7, sp, #0
 802ab6a:	6078      	str	r0, [r7, #4]
 802ab6c:	6039      	str	r1, [r7, #0]
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802ab6e:	687b      	ldr	r3, [r7, #4]
 802ab70:	685b      	ldr	r3, [r3, #4]
 802ab72:	681b      	ldr	r3, [r3, #0]
 802ab74:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 802ab78:	2101      	movs	r1, #1
 802ab7a:	6878      	ldr	r0, [r7, #4]
 802ab7c:	4798      	blx	r3
 802ab7e:	6178      	str	r0, [r7, #20]
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
 802ab80:	683b      	ldr	r3, [r7, #0]
 802ab82:	3b01      	subs	r3, #1
 802ab84:	025b      	lsls	r3, r3, #9
 802ab86:	613b      	str	r3, [r7, #16]
  for (j = 0; j < ODITHER_SIZE; j++) {
 802ab88:	2300      	movs	r3, #0
 802ab8a:	61fb      	str	r3, [r7, #28]
 802ab8c:	e02e      	b.n	802abec <make_odither_array+0x88>
    for (k = 0; k < ODITHER_SIZE; k++) {
 802ab8e:	2300      	movs	r3, #0
 802ab90:	61bb      	str	r3, [r7, #24]
 802ab92:	e025      	b.n	802abe0 <make_odither_array+0x7c>
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
 802ab94:	4a19      	ldr	r2, [pc, #100]	@ (802abfc <make_odither_array+0x98>)
 802ab96:	69fb      	ldr	r3, [r7, #28]
 802ab98:	011b      	lsls	r3, r3, #4
 802ab9a:	441a      	add	r2, r3
 802ab9c:	69bb      	ldr	r3, [r7, #24]
 802ab9e:	4413      	add	r3, r2
 802aba0:	781b      	ldrb	r3, [r3, #0]
 802aba2:	005b      	lsls	r3, r3, #1
 802aba4:	f1c3 02ff 	rsb	r2, r3, #255	@ 0xff
 802aba8:	4613      	mov	r3, r2
 802abaa:	021b      	lsls	r3, r3, #8
 802abac:	1a9b      	subs	r3, r3, r2
 802abae:	60fb      	str	r3, [r7, #12]
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
 802abb0:	68fb      	ldr	r3, [r7, #12]
 802abb2:	2b00      	cmp	r3, #0
 802abb4:	da06      	bge.n	802abc4 <make_odither_array+0x60>
 802abb6:	68fb      	ldr	r3, [r7, #12]
 802abb8:	425a      	negs	r2, r3
 802abba:	693b      	ldr	r3, [r7, #16]
 802abbc:	fb92 f3f3 	sdiv	r3, r2, r3
 802abc0:	425b      	negs	r3, r3
 802abc2:	e003      	b.n	802abcc <make_odither_array+0x68>
 802abc4:	68fa      	ldr	r2, [r7, #12]
 802abc6:	693b      	ldr	r3, [r7, #16]
 802abc8:	fb92 f3f3 	sdiv	r3, r2, r3
 802abcc:	69fa      	ldr	r2, [r7, #28]
 802abce:	0192      	lsls	r2, r2, #6
 802abd0:	6979      	ldr	r1, [r7, #20]
 802abd2:	440a      	add	r2, r1
 802abd4:	69b9      	ldr	r1, [r7, #24]
 802abd6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    for (k = 0; k < ODITHER_SIZE; k++) {
 802abda:	69bb      	ldr	r3, [r7, #24]
 802abdc:	3301      	adds	r3, #1
 802abde:	61bb      	str	r3, [r7, #24]
 802abe0:	69bb      	ldr	r3, [r7, #24]
 802abe2:	2b0f      	cmp	r3, #15
 802abe4:	ddd6      	ble.n	802ab94 <make_odither_array+0x30>
  for (j = 0; j < ODITHER_SIZE; j++) {
 802abe6:	69fb      	ldr	r3, [r7, #28]
 802abe8:	3301      	adds	r3, #1
 802abea:	61fb      	str	r3, [r7, #28]
 802abec:	69fb      	ldr	r3, [r7, #28]
 802abee:	2b0f      	cmp	r3, #15
 802abf0:	ddcd      	ble.n	802ab8e <make_odither_array+0x2a>
    }
  }
  return odither;
 802abf2:	697b      	ldr	r3, [r7, #20]
}
 802abf4:	4618      	mov	r0, r3
 802abf6:	3720      	adds	r7, #32
 802abf8:	46bd      	mov	sp, r7
 802abfa:	bd80      	pop	{r7, pc}
 802abfc:	080307a4 	.word	0x080307a4

0802ac00 <create_odither_tables>:
 * share a dither table.
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
 802ac00:	b580      	push	{r7, lr}
 802ac02:	b088      	sub	sp, #32
 802ac04:	af00      	add	r7, sp, #0
 802ac06:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ac08:	687b      	ldr	r3, [r7, #4]
 802ac0a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ac0e:	613b      	str	r3, [r7, #16]
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
 802ac10:	2300      	movs	r3, #0
 802ac12:	61bb      	str	r3, [r7, #24]
 802ac14:	e033      	b.n	802ac7e <create_odither_tables+0x7e>
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802ac16:	693b      	ldr	r3, [r7, #16]
 802ac18:	69ba      	ldr	r2, [r7, #24]
 802ac1a:	3208      	adds	r2, #8
 802ac1c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802ac20:	60fb      	str	r3, [r7, #12]
    odither = NULL;		/* search for matching prior component */
 802ac22:	2300      	movs	r3, #0
 802ac24:	61fb      	str	r3, [r7, #28]
    for (j = 0; j < i; j++) {
 802ac26:	2300      	movs	r3, #0
 802ac28:	617b      	str	r3, [r7, #20]
 802ac2a:	e012      	b.n	802ac52 <create_odither_tables+0x52>
      if (nci == cquantize->Ncolors[j]) {
 802ac2c:	693b      	ldr	r3, [r7, #16]
 802ac2e:	697a      	ldr	r2, [r7, #20]
 802ac30:	3208      	adds	r2, #8
 802ac32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802ac36:	68fa      	ldr	r2, [r7, #12]
 802ac38:	429a      	cmp	r2, r3
 802ac3a:	d107      	bne.n	802ac4c <create_odither_tables+0x4c>
	odither = cquantize->odither[j];
 802ac3c:	693a      	ldr	r2, [r7, #16]
 802ac3e:	697b      	ldr	r3, [r7, #20]
 802ac40:	330c      	adds	r3, #12
 802ac42:	009b      	lsls	r3, r3, #2
 802ac44:	4413      	add	r3, r2
 802ac46:	685b      	ldr	r3, [r3, #4]
 802ac48:	61fb      	str	r3, [r7, #28]
	break;
 802ac4a:	e006      	b.n	802ac5a <create_odither_tables+0x5a>
    for (j = 0; j < i; j++) {
 802ac4c:	697b      	ldr	r3, [r7, #20]
 802ac4e:	3301      	adds	r3, #1
 802ac50:	617b      	str	r3, [r7, #20]
 802ac52:	697a      	ldr	r2, [r7, #20]
 802ac54:	69bb      	ldr	r3, [r7, #24]
 802ac56:	429a      	cmp	r2, r3
 802ac58:	dbe8      	blt.n	802ac2c <create_odither_tables+0x2c>
      }
    }
    if (odither == NULL)	/* need a new table? */
 802ac5a:	69fb      	ldr	r3, [r7, #28]
 802ac5c:	2b00      	cmp	r3, #0
 802ac5e:	d104      	bne.n	802ac6a <create_odither_tables+0x6a>
      odither = make_odither_array(cinfo, nci);
 802ac60:	68f9      	ldr	r1, [r7, #12]
 802ac62:	6878      	ldr	r0, [r7, #4]
 802ac64:	f7ff ff7e 	bl	802ab64 <make_odither_array>
 802ac68:	61f8      	str	r0, [r7, #28]
    cquantize->odither[i] = odither;
 802ac6a:	693a      	ldr	r2, [r7, #16]
 802ac6c:	69bb      	ldr	r3, [r7, #24]
 802ac6e:	330c      	adds	r3, #12
 802ac70:	009b      	lsls	r3, r3, #2
 802ac72:	4413      	add	r3, r2
 802ac74:	69fa      	ldr	r2, [r7, #28]
 802ac76:	605a      	str	r2, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802ac78:	69bb      	ldr	r3, [r7, #24]
 802ac7a:	3301      	adds	r3, #1
 802ac7c:	61bb      	str	r3, [r7, #24]
 802ac7e:	687b      	ldr	r3, [r7, #4]
 802ac80:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802ac82:	69ba      	ldr	r2, [r7, #24]
 802ac84:	429a      	cmp	r2, r3
 802ac86:	dbc6      	blt.n	802ac16 <create_odither_tables+0x16>
  }
}
 802ac88:	bf00      	nop
 802ac8a:	bf00      	nop
 802ac8c:	3720      	adds	r7, #32
 802ac8e:	46bd      	mov	sp, r7
 802ac90:	bd80      	pop	{r7, pc}

0802ac92 <color_quantize>:

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
 802ac92:	b4f0      	push	{r4, r5, r6, r7}
 802ac94:	b08a      	sub	sp, #40	@ 0x28
 802ac96:	af00      	add	r7, sp, #0
 802ac98:	60f8      	str	r0, [r7, #12]
 802ac9a:	60b9      	str	r1, [r7, #8]
 802ac9c:	607a      	str	r2, [r7, #4]
 802ac9e:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802aca0:	68fb      	ldr	r3, [r7, #12]
 802aca2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802aca6:	61fb      	str	r3, [r7, #28]
  JSAMPARRAY colorindex = cquantize->colorindex;
 802aca8:	69fb      	ldr	r3, [r7, #28]
 802acaa:	699b      	ldr	r3, [r3, #24]
 802acac:	61bb      	str	r3, [r7, #24]
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802acae:	68fb      	ldr	r3, [r7, #12]
 802acb0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802acb2:	617b      	str	r3, [r7, #20]
  register int nc = cinfo->out_color_components;
 802acb4:	68fb      	ldr	r3, [r7, #12]
 802acb6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802acb8:	4618      	mov	r0, r3

  for (row = 0; row < num_rows; row++) {
 802acba:	2300      	movs	r3, #0
 802acbc:	627b      	str	r3, [r7, #36]	@ 0x24
 802acbe:	e02d      	b.n	802ad1c <color_quantize+0x8a>
    ptrin = input_buf[row];
 802acc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802acc2:	009b      	lsls	r3, r3, #2
 802acc4:	68ba      	ldr	r2, [r7, #8]
 802acc6:	4413      	add	r3, r2
 802acc8:	681e      	ldr	r6, [r3, #0]
    ptrout = output_buf[row];
 802acca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802accc:	009b      	lsls	r3, r3, #2
 802acce:	687a      	ldr	r2, [r7, #4]
 802acd0:	4413      	add	r3, r2
 802acd2:	681b      	ldr	r3, [r3, #0]
 802acd4:	4619      	mov	r1, r3
    for (col = width; col > 0; col--) {
 802acd6:	697b      	ldr	r3, [r7, #20]
 802acd8:	623b      	str	r3, [r7, #32]
 802acda:	e019      	b.n	802ad10 <color_quantize+0x7e>
      pixcode = 0;
 802acdc:	2500      	movs	r5, #0
      for (ci = 0; ci < nc; ci++) {
 802acde:	2400      	movs	r4, #0
 802ace0:	e00b      	b.n	802acfa <color_quantize+0x68>
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
 802ace2:	4623      	mov	r3, r4
 802ace4:	009b      	lsls	r3, r3, #2
 802ace6:	69ba      	ldr	r2, [r7, #24]
 802ace8:	4413      	add	r3, r2
 802acea:	681a      	ldr	r2, [r3, #0]
 802acec:	4633      	mov	r3, r6
 802acee:	1c5e      	adds	r6, r3, #1
 802acf0:	781b      	ldrb	r3, [r3, #0]
 802acf2:	4413      	add	r3, r2
 802acf4:	781b      	ldrb	r3, [r3, #0]
 802acf6:	441d      	add	r5, r3
      for (ci = 0; ci < nc; ci++) {
 802acf8:	3401      	adds	r4, #1
 802acfa:	4603      	mov	r3, r0
 802acfc:	429c      	cmp	r4, r3
 802acfe:	dbf0      	blt.n	802ace2 <color_quantize+0x50>
      }
      *ptrout++ = (JSAMPLE) pixcode;
 802ad00:	460b      	mov	r3, r1
 802ad02:	1c5a      	adds	r2, r3, #1
 802ad04:	4611      	mov	r1, r2
 802ad06:	b2ea      	uxtb	r2, r5
 802ad08:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802ad0a:	6a3b      	ldr	r3, [r7, #32]
 802ad0c:	3b01      	subs	r3, #1
 802ad0e:	623b      	str	r3, [r7, #32]
 802ad10:	6a3b      	ldr	r3, [r7, #32]
 802ad12:	2b00      	cmp	r3, #0
 802ad14:	d1e2      	bne.n	802acdc <color_quantize+0x4a>
  for (row = 0; row < num_rows; row++) {
 802ad16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ad18:	3301      	adds	r3, #1
 802ad1a:	627b      	str	r3, [r7, #36]	@ 0x24
 802ad1c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802ad1e:	683b      	ldr	r3, [r7, #0]
 802ad20:	429a      	cmp	r2, r3
 802ad22:	dbcd      	blt.n	802acc0 <color_quantize+0x2e>
    }
  }
}
 802ad24:	bf00      	nop
 802ad26:	bf00      	nop
 802ad28:	3728      	adds	r7, #40	@ 0x28
 802ad2a:	46bd      	mov	sp, r7
 802ad2c:	bcf0      	pop	{r4, r5, r6, r7}
 802ad2e:	4770      	bx	lr

0802ad30 <color_quantize3>:

METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
 802ad30:	b4f0      	push	{r4, r5, r6, r7}
 802ad32:	b08c      	sub	sp, #48	@ 0x30
 802ad34:	af00      	add	r7, sp, #0
 802ad36:	60f8      	str	r0, [r7, #12]
 802ad38:	60b9      	str	r1, [r7, #8]
 802ad3a:	607a      	str	r2, [r7, #4]
 802ad3c:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ad3e:	68fb      	ldr	r3, [r7, #12]
 802ad40:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ad44:	627b      	str	r3, [r7, #36]	@ 0x24
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 802ad46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ad48:	699b      	ldr	r3, [r3, #24]
 802ad4a:	681b      	ldr	r3, [r3, #0]
 802ad4c:	623b      	str	r3, [r7, #32]
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 802ad4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ad50:	699b      	ldr	r3, [r3, #24]
 802ad52:	685b      	ldr	r3, [r3, #4]
 802ad54:	61fb      	str	r3, [r7, #28]
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 802ad56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ad58:	699b      	ldr	r3, [r3, #24]
 802ad5a:	689b      	ldr	r3, [r3, #8]
 802ad5c:	61bb      	str	r3, [r7, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802ad5e:	68fb      	ldr	r3, [r7, #12]
 802ad60:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802ad62:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 802ad64:	2300      	movs	r3, #0
 802ad66:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802ad68:	e031      	b.n	802adce <color_quantize3+0x9e>
    ptrin = input_buf[row];
 802ad6a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ad6c:	009b      	lsls	r3, r3, #2
 802ad6e:	68ba      	ldr	r2, [r7, #8]
 802ad70:	4413      	add	r3, r2
 802ad72:	681c      	ldr	r4, [r3, #0]
    ptrout = output_buf[row];
 802ad74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ad76:	009b      	lsls	r3, r3, #2
 802ad78:	687a      	ldr	r2, [r7, #4]
 802ad7a:	4413      	add	r3, r2
 802ad7c:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 802ad7e:	697b      	ldr	r3, [r7, #20]
 802ad80:	62bb      	str	r3, [r7, #40]	@ 0x28
 802ad82:	e01e      	b.n	802adc2 <color_quantize3+0x92>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
 802ad84:	4623      	mov	r3, r4
 802ad86:	1c5c      	adds	r4, r3, #1
 802ad88:	781b      	ldrb	r3, [r3, #0]
 802ad8a:	461a      	mov	r2, r3
 802ad8c:	6a3b      	ldr	r3, [r7, #32]
 802ad8e:	4413      	add	r3, r2
 802ad90:	781b      	ldrb	r3, [r3, #0]
 802ad92:	461d      	mov	r5, r3
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
 802ad94:	4623      	mov	r3, r4
 802ad96:	1c5c      	adds	r4, r3, #1
 802ad98:	781b      	ldrb	r3, [r3, #0]
 802ad9a:	461a      	mov	r2, r3
 802ad9c:	69fb      	ldr	r3, [r7, #28]
 802ad9e:	4413      	add	r3, r2
 802ada0:	781b      	ldrb	r3, [r3, #0]
 802ada2:	441d      	add	r5, r3
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
 802ada4:	4623      	mov	r3, r4
 802ada6:	1c5c      	adds	r4, r3, #1
 802ada8:	781b      	ldrb	r3, [r3, #0]
 802adaa:	461a      	mov	r2, r3
 802adac:	69bb      	ldr	r3, [r7, #24]
 802adae:	4413      	add	r3, r2
 802adb0:	781b      	ldrb	r3, [r3, #0]
 802adb2:	441d      	add	r5, r3
      *ptrout++ = (JSAMPLE) pixcode;
 802adb4:	4633      	mov	r3, r6
 802adb6:	1c5e      	adds	r6, r3, #1
 802adb8:	b2ea      	uxtb	r2, r5
 802adba:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802adbc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802adbe:	3b01      	subs	r3, #1
 802adc0:	62bb      	str	r3, [r7, #40]	@ 0x28
 802adc2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802adc4:	2b00      	cmp	r3, #0
 802adc6:	d1dd      	bne.n	802ad84 <color_quantize3+0x54>
  for (row = 0; row < num_rows; row++) {
 802adc8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802adca:	3301      	adds	r3, #1
 802adcc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802adce:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802add0:	683b      	ldr	r3, [r7, #0]
 802add2:	429a      	cmp	r2, r3
 802add4:	dbc9      	blt.n	802ad6a <color_quantize3+0x3a>
    }
  }
}
 802add6:	bf00      	nop
 802add8:	bf00      	nop
 802adda:	3730      	adds	r7, #48	@ 0x30
 802addc:	46bd      	mov	sp, r7
 802adde:	bcf0      	pop	{r4, r5, r6, r7}
 802ade0:	4770      	bx	lr

0802ade2 <quantize_ord_dither>:

METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
 802ade2:	b5b0      	push	{r4, r5, r7, lr}
 802ade4:	b08e      	sub	sp, #56	@ 0x38
 802ade6:	af00      	add	r7, sp, #0
 802ade8:	60f8      	str	r0, [r7, #12]
 802adea:	60b9      	str	r1, [r7, #8]
 802adec:	607a      	str	r2, [r7, #4]
 802adee:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802adf0:	68fb      	ldr	r3, [r7, #12]
 802adf2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802adf6:	627b      	str	r3, [r7, #36]	@ 0x24
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
 802adf8:	68fb      	ldr	r3, [r7, #12]
 802adfa:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802adfc:	623b      	str	r3, [r7, #32]
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802adfe:	68fb      	ldr	r3, [r7, #12]
 802ae00:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802ae02:	61fb      	str	r3, [r7, #28]

  for (row = 0; row < num_rows; row++) {
 802ae04:	2300      	movs	r3, #0
 802ae06:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802ae08:	e061      	b.n	802aece <quantize_ord_dither+0xec>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 802ae0a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ae0c:	009b      	lsls	r3, r3, #2
 802ae0e:	687a      	ldr	r2, [r7, #4]
 802ae10:	4413      	add	r3, r2
 802ae12:	681b      	ldr	r3, [r3, #0]
 802ae14:	69fa      	ldr	r2, [r7, #28]
 802ae16:	2100      	movs	r1, #0
 802ae18:	4618      	mov	r0, r3
 802ae1a:	f002 fcea 	bl	802d7f2 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
 802ae1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ae20:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802ae22:	61bb      	str	r3, [r7, #24]
    for (ci = 0; ci < nc; ci++) {
 802ae24:	2300      	movs	r3, #0
 802ae26:	633b      	str	r3, [r7, #48]	@ 0x30
 802ae28:	e042      	b.n	802aeb0 <quantize_ord_dither+0xce>
      input_ptr = input_buf[row] + ci;
 802ae2a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ae2c:	009b      	lsls	r3, r3, #2
 802ae2e:	68ba      	ldr	r2, [r7, #8]
 802ae30:	4413      	add	r3, r2
 802ae32:	681a      	ldr	r2, [r3, #0]
 802ae34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802ae36:	18d5      	adds	r5, r2, r3
      output_ptr = output_buf[row];
 802ae38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ae3a:	009b      	lsls	r3, r3, #2
 802ae3c:	687a      	ldr	r2, [r7, #4]
 802ae3e:	4413      	add	r3, r2
 802ae40:	681c      	ldr	r4, [r3, #0]
      colorindex_ci = cquantize->colorindex[ci];
 802ae42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ae44:	699a      	ldr	r2, [r3, #24]
 802ae46:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802ae48:	009b      	lsls	r3, r3, #2
 802ae4a:	4413      	add	r3, r2
 802ae4c:	681b      	ldr	r3, [r3, #0]
 802ae4e:	617b      	str	r3, [r7, #20]
      dither = cquantize->odither[ci][row_index];
 802ae50:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802ae52:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802ae54:	330c      	adds	r3, #12
 802ae56:	009b      	lsls	r3, r3, #2
 802ae58:	4413      	add	r3, r2
 802ae5a:	685a      	ldr	r2, [r3, #4]
 802ae5c:	69bb      	ldr	r3, [r7, #24]
 802ae5e:	019b      	lsls	r3, r3, #6
 802ae60:	4413      	add	r3, r2
 802ae62:	613b      	str	r3, [r7, #16]
      col_index = 0;
 802ae64:	2300      	movs	r3, #0
 802ae66:	637b      	str	r3, [r7, #52]	@ 0x34

      for (col = width; col > 0; col--) {
 802ae68:	69fb      	ldr	r3, [r7, #28]
 802ae6a:	62bb      	str	r3, [r7, #40]	@ 0x28
 802ae6c:	e01a      	b.n	802aea4 <quantize_ord_dither+0xc2>
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
 802ae6e:	7822      	ldrb	r2, [r4, #0]
 802ae70:	782b      	ldrb	r3, [r5, #0]
 802ae72:	4618      	mov	r0, r3
 802ae74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ae76:	009b      	lsls	r3, r3, #2
 802ae78:	6939      	ldr	r1, [r7, #16]
 802ae7a:	440b      	add	r3, r1
 802ae7c:	681b      	ldr	r3, [r3, #0]
 802ae7e:	4403      	add	r3, r0
 802ae80:	4619      	mov	r1, r3
 802ae82:	697b      	ldr	r3, [r7, #20]
 802ae84:	440b      	add	r3, r1
 802ae86:	781b      	ldrb	r3, [r3, #0]
 802ae88:	4413      	add	r3, r2
 802ae8a:	b2db      	uxtb	r3, r3
 802ae8c:	7023      	strb	r3, [r4, #0]
	input_ptr += nc;
 802ae8e:	6a3b      	ldr	r3, [r7, #32]
 802ae90:	441d      	add	r5, r3
	output_ptr++;
 802ae92:	3401      	adds	r4, #1
	col_index = (col_index + 1) & ODITHER_MASK;
 802ae94:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ae96:	3301      	adds	r3, #1
 802ae98:	f003 030f 	and.w	r3, r3, #15
 802ae9c:	637b      	str	r3, [r7, #52]	@ 0x34
      for (col = width; col > 0; col--) {
 802ae9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802aea0:	3b01      	subs	r3, #1
 802aea2:	62bb      	str	r3, [r7, #40]	@ 0x28
 802aea4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802aea6:	2b00      	cmp	r3, #0
 802aea8:	d1e1      	bne.n	802ae6e <quantize_ord_dither+0x8c>
    for (ci = 0; ci < nc; ci++) {
 802aeaa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802aeac:	3301      	adds	r3, #1
 802aeae:	633b      	str	r3, [r7, #48]	@ 0x30
 802aeb0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802aeb2:	6a3b      	ldr	r3, [r7, #32]
 802aeb4:	429a      	cmp	r2, r3
 802aeb6:	dbb8      	blt.n	802ae2a <quantize_ord_dither+0x48>
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
 802aeb8:	69bb      	ldr	r3, [r7, #24]
 802aeba:	3301      	adds	r3, #1
 802aebc:	f003 030f 	and.w	r3, r3, #15
 802aec0:	61bb      	str	r3, [r7, #24]
    cquantize->row_index = row_index;
 802aec2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802aec4:	69ba      	ldr	r2, [r7, #24]
 802aec6:	631a      	str	r2, [r3, #48]	@ 0x30
  for (row = 0; row < num_rows; row++) {
 802aec8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802aeca:	3301      	adds	r3, #1
 802aecc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802aece:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802aed0:	683b      	ldr	r3, [r7, #0]
 802aed2:	429a      	cmp	r2, r3
 802aed4:	db99      	blt.n	802ae0a <quantize_ord_dither+0x28>
  }
}
 802aed6:	bf00      	nop
 802aed8:	bf00      	nop
 802aeda:	3738      	adds	r7, #56	@ 0x38
 802aedc:	46bd      	mov	sp, r7
 802aede:	bdb0      	pop	{r4, r5, r7, pc}

0802aee0 <quantize3_ord_dither>:

METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
 802aee0:	b4f0      	push	{r4, r5, r6, r7}
 802aee2:	b090      	sub	sp, #64	@ 0x40
 802aee4:	af00      	add	r7, sp, #0
 802aee6:	60f8      	str	r0, [r7, #12]
 802aee8:	60b9      	str	r1, [r7, #8]
 802aeea:	607a      	str	r2, [r7, #4]
 802aeec:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802aeee:	68fb      	ldr	r3, [r7, #12]
 802aef0:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802aef4:	633b      	str	r3, [r7, #48]	@ 0x30
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 802aef6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802aef8:	699b      	ldr	r3, [r3, #24]
 802aefa:	681b      	ldr	r3, [r3, #0]
 802aefc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 802aefe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af00:	699b      	ldr	r3, [r3, #24]
 802af02:	685b      	ldr	r3, [r3, #4]
 802af04:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 802af06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af08:	699b      	ldr	r3, [r3, #24]
 802af0a:	689b      	ldr	r3, [r3, #8]
 802af0c:	627b      	str	r3, [r7, #36]	@ 0x24
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802af0e:	68fb      	ldr	r3, [r7, #12]
 802af10:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802af12:	623b      	str	r3, [r7, #32]

  for (row = 0; row < num_rows; row++) {
 802af14:	2300      	movs	r3, #0
 802af16:	63bb      	str	r3, [r7, #56]	@ 0x38
 802af18:	e06a      	b.n	802aff0 <quantize3_ord_dither+0x110>
    row_index = cquantize->row_index;
 802af1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af1c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802af1e:	61fb      	str	r3, [r7, #28]
    input_ptr = input_buf[row];
 802af20:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802af22:	009b      	lsls	r3, r3, #2
 802af24:	68ba      	ldr	r2, [r7, #8]
 802af26:	4413      	add	r3, r2
 802af28:	681c      	ldr	r4, [r3, #0]
    output_ptr = output_buf[row];
 802af2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802af2c:	009b      	lsls	r3, r3, #2
 802af2e:	687a      	ldr	r2, [r7, #4]
 802af30:	4413      	add	r3, r2
 802af32:	681e      	ldr	r6, [r3, #0]
    dither0 = cquantize->odither[0][row_index];
 802af34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af36:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 802af38:	69fb      	ldr	r3, [r7, #28]
 802af3a:	019b      	lsls	r3, r3, #6
 802af3c:	4413      	add	r3, r2
 802af3e:	61bb      	str	r3, [r7, #24]
    dither1 = cquantize->odither[1][row_index];
 802af40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af42:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 802af44:	69fb      	ldr	r3, [r7, #28]
 802af46:	019b      	lsls	r3, r3, #6
 802af48:	4413      	add	r3, r2
 802af4a:	617b      	str	r3, [r7, #20]
    dither2 = cquantize->odither[2][row_index];
 802af4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802af4e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 802af50:	69fb      	ldr	r3, [r7, #28]
 802af52:	019b      	lsls	r3, r3, #6
 802af54:	4413      	add	r3, r2
 802af56:	613b      	str	r3, [r7, #16]
    col_index = 0;
 802af58:	2300      	movs	r3, #0
 802af5a:	63fb      	str	r3, [r7, #60]	@ 0x3c

    for (col = width; col > 0; col--) {
 802af5c:	6a3b      	ldr	r3, [r7, #32]
 802af5e:	637b      	str	r3, [r7, #52]	@ 0x34
 802af60:	e038      	b.n	802afd4 <quantize3_ord_dither+0xf4>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
 802af62:	4623      	mov	r3, r4
 802af64:	1c5c      	adds	r4, r3, #1
 802af66:	781b      	ldrb	r3, [r3, #0]
 802af68:	4619      	mov	r1, r3
 802af6a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802af6c:	009b      	lsls	r3, r3, #2
 802af6e:	69ba      	ldr	r2, [r7, #24]
 802af70:	4413      	add	r3, r2
 802af72:	681b      	ldr	r3, [r3, #0]
 802af74:	440b      	add	r3, r1
 802af76:	461a      	mov	r2, r3
 802af78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802af7a:	4413      	add	r3, r2
 802af7c:	781b      	ldrb	r3, [r3, #0]
 802af7e:	461d      	mov	r5, r3
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
 802af80:	4623      	mov	r3, r4
 802af82:	1c5c      	adds	r4, r3, #1
 802af84:	781b      	ldrb	r3, [r3, #0]
 802af86:	4619      	mov	r1, r3
 802af88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802af8a:	009b      	lsls	r3, r3, #2
 802af8c:	697a      	ldr	r2, [r7, #20]
 802af8e:	4413      	add	r3, r2
 802af90:	681b      	ldr	r3, [r3, #0]
 802af92:	440b      	add	r3, r1
 802af94:	461a      	mov	r2, r3
 802af96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802af98:	4413      	add	r3, r2
 802af9a:	781b      	ldrb	r3, [r3, #0]
 802af9c:	441d      	add	r5, r3
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
 802af9e:	4623      	mov	r3, r4
 802afa0:	1c5c      	adds	r4, r3, #1
 802afa2:	781b      	ldrb	r3, [r3, #0]
 802afa4:	4619      	mov	r1, r3
 802afa6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802afa8:	009b      	lsls	r3, r3, #2
 802afaa:	693a      	ldr	r2, [r7, #16]
 802afac:	4413      	add	r3, r2
 802afae:	681b      	ldr	r3, [r3, #0]
 802afb0:	440b      	add	r3, r1
 802afb2:	461a      	mov	r2, r3
 802afb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802afb6:	4413      	add	r3, r2
 802afb8:	781b      	ldrb	r3, [r3, #0]
 802afba:	441d      	add	r5, r3
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
 802afbc:	4633      	mov	r3, r6
 802afbe:	1c5e      	adds	r6, r3, #1
 802afc0:	b2ea      	uxtb	r2, r5
 802afc2:	701a      	strb	r2, [r3, #0]
      col_index = (col_index + 1) & ODITHER_MASK;
 802afc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802afc6:	3301      	adds	r3, #1
 802afc8:	f003 030f 	and.w	r3, r3, #15
 802afcc:	63fb      	str	r3, [r7, #60]	@ 0x3c
    for (col = width; col > 0; col--) {
 802afce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802afd0:	3b01      	subs	r3, #1
 802afd2:	637b      	str	r3, [r7, #52]	@ 0x34
 802afd4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802afd6:	2b00      	cmp	r3, #0
 802afd8:	d1c3      	bne.n	802af62 <quantize3_ord_dither+0x82>
    }
    row_index = (row_index + 1) & ODITHER_MASK;
 802afda:	69fb      	ldr	r3, [r7, #28]
 802afdc:	3301      	adds	r3, #1
 802afde:	f003 030f 	and.w	r3, r3, #15
 802afe2:	61fb      	str	r3, [r7, #28]
    cquantize->row_index = row_index;
 802afe4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802afe6:	69fa      	ldr	r2, [r7, #28]
 802afe8:	631a      	str	r2, [r3, #48]	@ 0x30
  for (row = 0; row < num_rows; row++) {
 802afea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802afec:	3301      	adds	r3, #1
 802afee:	63bb      	str	r3, [r7, #56]	@ 0x38
 802aff0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802aff2:	683b      	ldr	r3, [r7, #0]
 802aff4:	429a      	cmp	r2, r3
 802aff6:	db90      	blt.n	802af1a <quantize3_ord_dither+0x3a>
  }
}
 802aff8:	bf00      	nop
 802affa:	bf00      	nop
 802affc:	3740      	adds	r7, #64	@ 0x40
 802affe:	46bd      	mov	sp, r7
 802b000:	bcf0      	pop	{r4, r5, r6, r7}
 802b002:	4770      	bx	lr

0802b004 <quantize_fs_dither>:

METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
 802b004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802b008:	b094      	sub	sp, #80	@ 0x50
 802b00a:	af00      	add	r7, sp, #0
 802b00c:	60f8      	str	r0, [r7, #12]
 802b00e:	60b9      	str	r1, [r7, #8]
 802b010:	607a      	str	r2, [r7, #4]
 802b012:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802b014:	68fb      	ldr	r3, [r7, #12]
 802b016:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802b01a:	633b      	str	r3, [r7, #48]	@ 0x30
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
 802b01c:	68fb      	ldr	r3, [r7, #12]
 802b01e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b020:	62fb      	str	r3, [r7, #44]	@ 0x2c
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802b022:	68fb      	ldr	r3, [r7, #12]
 802b024:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802b026:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 802b028:	68fb      	ldr	r3, [r7, #12]
 802b02a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802b02e:	627b      	str	r3, [r7, #36]	@ 0x24
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 802b030:	2300      	movs	r3, #0
 802b032:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b034:	e0b1      	b.n	802b19a <quantize_fs_dither+0x196>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 802b036:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b038:	009b      	lsls	r3, r3, #2
 802b03a:	687a      	ldr	r2, [r7, #4]
 802b03c:	4413      	add	r3, r2
 802b03e:	681b      	ldr	r3, [r3, #0]
 802b040:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802b042:	2100      	movs	r1, #0
 802b044:	4618      	mov	r0, r3
 802b046:	f002 fbd4 	bl	802d7f2 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
 802b04a:	2300      	movs	r3, #0
 802b04c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b04e:	e092      	b.n	802b176 <quantize_fs_dither+0x172>
      input_ptr = input_buf[row] + ci;
 802b050:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b052:	009b      	lsls	r3, r3, #2
 802b054:	68ba      	ldr	r2, [r7, #8]
 802b056:	4413      	add	r3, r2
 802b058:	681a      	ldr	r2, [r3, #0]
 802b05a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b05c:	eb02 0803 	add.w	r8, r2, r3
      output_ptr = output_buf[row];
 802b060:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b062:	009b      	lsls	r3, r3, #2
 802b064:	687a      	ldr	r2, [r7, #4]
 802b066:	4413      	add	r3, r2
 802b068:	681e      	ldr	r6, [r3, #0]
      if (cquantize->on_odd_row) {
 802b06a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b06c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802b06e:	2b00      	cmp	r3, #0
 802b070:	d019      	beq.n	802b0a6 <quantize_fs_dither+0xa2>
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
 802b072:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b074:	3b01      	subs	r3, #1
 802b076:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802b078:	fb02 f303 	mul.w	r3, r2, r3
 802b07c:	4498      	add	r8, r3
	output_ptr += width-1;
 802b07e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b080:	3b01      	subs	r3, #1
 802b082:	441e      	add	r6, r3
	dir = -1;
 802b084:	f04f 33ff 	mov.w	r3, #4294967295
 802b088:	647b      	str	r3, [r7, #68]	@ 0x44
	dirnc = -nc;
 802b08a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b08c:	425b      	negs	r3, r3
 802b08e:	643b      	str	r3, [r7, #64]	@ 0x40
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
 802b090:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b092:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b094:	3310      	adds	r3, #16
 802b096:	009b      	lsls	r3, r3, #2
 802b098:	4413      	add	r3, r2
 802b09a:	685a      	ldr	r2, [r3, #4]
 802b09c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b09e:	3301      	adds	r3, #1
 802b0a0:	005b      	lsls	r3, r3, #1
 802b0a2:	18d5      	adds	r5, r2, r3
 802b0a4:	e009      	b.n	802b0ba <quantize_fs_dither+0xb6>
      } else {
	/* work left to right in this row */
	dir = 1;
 802b0a6:	2301      	movs	r3, #1
 802b0a8:	647b      	str	r3, [r7, #68]	@ 0x44
	dirnc = nc;
 802b0aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b0ac:	643b      	str	r3, [r7, #64]	@ 0x40
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
 802b0ae:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b0b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b0b2:	3310      	adds	r3, #16
 802b0b4:	009b      	lsls	r3, r3, #2
 802b0b6:	4413      	add	r3, r2
 802b0b8:	685d      	ldr	r5, [r3, #4]
      }
      colorindex_ci = cquantize->colorindex[ci];
 802b0ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b0bc:	699a      	ldr	r2, [r3, #24]
 802b0be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b0c0:	009b      	lsls	r3, r3, #2
 802b0c2:	4413      	add	r3, r2
 802b0c4:	681b      	ldr	r3, [r3, #0]
 802b0c6:	623b      	str	r3, [r7, #32]
      colormap_ci = cquantize->sv_colormap[ci];
 802b0c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b0ca:	691a      	ldr	r2, [r3, #16]
 802b0cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b0ce:	009b      	lsls	r3, r3, #2
 802b0d0:	4413      	add	r3, r2
 802b0d2:	681b      	ldr	r3, [r3, #0]
 802b0d4:	61fb      	str	r3, [r7, #28]
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
 802b0d6:	2400      	movs	r4, #0
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;
 802b0d8:	2300      	movs	r3, #0
 802b0da:	64bb      	str	r3, [r7, #72]	@ 0x48
 802b0dc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802b0de:	64fb      	str	r3, [r7, #76]	@ 0x4c

      for (col = width; col > 0; col--) {
 802b0e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b0e2:	637b      	str	r3, [r7, #52]	@ 0x34
 802b0e4:	e03e      	b.n	802b164 <quantize_fs_dither+0x160>
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
 802b0e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b0e8:	005b      	lsls	r3, r3, #1
 802b0ea:	442b      	add	r3, r5
 802b0ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b0f0:	4423      	add	r3, r4
 802b0f2:	3308      	adds	r3, #8
 802b0f4:	111c      	asrs	r4, r3, #4
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
 802b0f6:	f898 3000 	ldrb.w	r3, [r8]
 802b0fa:	441c      	add	r4, r3
	cur = GETJSAMPLE(range_limit[cur]);
 802b0fc:	4622      	mov	r2, r4
 802b0fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b100:	4413      	add	r3, r2
 802b102:	781b      	ldrb	r3, [r3, #0]
 802b104:	461c      	mov	r4, r3
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
 802b106:	4622      	mov	r2, r4
 802b108:	6a3b      	ldr	r3, [r7, #32]
 802b10a:	4413      	add	r3, r2
 802b10c:	781b      	ldrb	r3, [r3, #0]
 802b10e:	61bb      	str	r3, [r7, #24]
	*output_ptr += (JSAMPLE) pixcode;
 802b110:	7832      	ldrb	r2, [r6, #0]
 802b112:	69bb      	ldr	r3, [r7, #24]
 802b114:	b2db      	uxtb	r3, r3
 802b116:	4413      	add	r3, r2
 802b118:	b2db      	uxtb	r3, r3
 802b11a:	7033      	strb	r3, [r6, #0]
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
 802b11c:	69bb      	ldr	r3, [r7, #24]
 802b11e:	69fa      	ldr	r2, [r7, #28]
 802b120:	4413      	add	r3, r2
 802b122:	781b      	ldrb	r3, [r3, #0]
 802b124:	1ae4      	subs	r4, r4, r3
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
 802b126:	617c      	str	r4, [r7, #20]
	delta = cur * 2;
 802b128:	0063      	lsls	r3, r4, #1
 802b12a:	613b      	str	r3, [r7, #16]
	cur += delta;		/* form error * 3 */
 802b12c:	693b      	ldr	r3, [r7, #16]
 802b12e:	441c      	add	r4, r3
	errorptr[0] = (FSERROR) (bpreverr + cur);
 802b130:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802b132:	b29a      	uxth	r2, r3
 802b134:	b2a3      	uxth	r3, r4
 802b136:	4413      	add	r3, r2
 802b138:	b29b      	uxth	r3, r3
 802b13a:	b21b      	sxth	r3, r3
 802b13c:	802b      	strh	r3, [r5, #0]
	cur += delta;		/* form error * 5 */
 802b13e:	693b      	ldr	r3, [r7, #16]
 802b140:	441c      	add	r4, r3
	bpreverr = belowerr + cur;
 802b142:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802b144:	4423      	add	r3, r4
 802b146:	64bb      	str	r3, [r7, #72]	@ 0x48
	belowerr = bnexterr;
 802b148:	697b      	ldr	r3, [r7, #20]
 802b14a:	64fb      	str	r3, [r7, #76]	@ 0x4c
	cur += delta;		/* form error * 7 */
 802b14c:	693b      	ldr	r3, [r7, #16]
 802b14e:	441c      	add	r4, r3
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
 802b150:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b152:	4498      	add	r8, r3
	output_ptr += dir;	/* advance output ptr to next column */
 802b154:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b156:	441e      	add	r6, r3
	errorptr += dir;	/* advance errorptr to current column */
 802b158:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b15a:	005b      	lsls	r3, r3, #1
 802b15c:	441d      	add	r5, r3
      for (col = width; col > 0; col--) {
 802b15e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b160:	3b01      	subs	r3, #1
 802b162:	637b      	str	r3, [r7, #52]	@ 0x34
 802b164:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b166:	2b00      	cmp	r3, #0
 802b168:	d1bd      	bne.n	802b0e6 <quantize_fs_dither+0xe2>
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
 802b16a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802b16c:	b21b      	sxth	r3, r3
 802b16e:	802b      	strh	r3, [r5, #0]
    for (ci = 0; ci < nc; ci++) {
 802b170:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b172:	3301      	adds	r3, #1
 802b174:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b176:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b178:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b17a:	429a      	cmp	r2, r3
 802b17c:	f6ff af68 	blt.w	802b050 <quantize_fs_dither+0x4c>
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
 802b180:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b182:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802b184:	2b00      	cmp	r3, #0
 802b186:	bf0c      	ite	eq
 802b188:	2301      	moveq	r3, #1
 802b18a:	2300      	movne	r3, #0
 802b18c:	b2db      	uxtb	r3, r3
 802b18e:	461a      	mov	r2, r3
 802b190:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b192:	655a      	str	r2, [r3, #84]	@ 0x54
  for (row = 0; row < num_rows; row++) {
 802b194:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b196:	3301      	adds	r3, #1
 802b198:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b19a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b19c:	683b      	ldr	r3, [r7, #0]
 802b19e:	429a      	cmp	r2, r3
 802b1a0:	f6ff af49 	blt.w	802b036 <quantize_fs_dither+0x32>
  }
}
 802b1a4:	bf00      	nop
 802b1a6:	bf00      	nop
 802b1a8:	3750      	adds	r7, #80	@ 0x50
 802b1aa:	46bd      	mov	sp, r7
 802b1ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802b1b0 <alloc_fs_workspace>:
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
 802b1b0:	b580      	push	{r7, lr}
 802b1b2:	b086      	sub	sp, #24
 802b1b4:	af00      	add	r7, sp, #0
 802b1b6:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802b1b8:	687b      	ldr	r3, [r7, #4]
 802b1ba:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802b1be:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 802b1c0:	687b      	ldr	r3, [r7, #4]
 802b1c2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802b1c4:	3302      	adds	r3, #2
 802b1c6:	005b      	lsls	r3, r3, #1
 802b1c8:	60fb      	str	r3, [r7, #12]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802b1ca:	2300      	movs	r3, #0
 802b1cc:	617b      	str	r3, [r7, #20]
 802b1ce:	e010      	b.n	802b1f2 <alloc_fs_workspace+0x42>
    cquantize->fserrors[i] = (FSERRPTR)
      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
 802b1d0:	687b      	ldr	r3, [r7, #4]
 802b1d2:	685b      	ldr	r3, [r3, #4]
 802b1d4:	685b      	ldr	r3, [r3, #4]
 802b1d6:	68fa      	ldr	r2, [r7, #12]
 802b1d8:	2101      	movs	r1, #1
 802b1da:	6878      	ldr	r0, [r7, #4]
 802b1dc:	4798      	blx	r3
 802b1de:	4601      	mov	r1, r0
    cquantize->fserrors[i] = (FSERRPTR)
 802b1e0:	693a      	ldr	r2, [r7, #16]
 802b1e2:	697b      	ldr	r3, [r7, #20]
 802b1e4:	3310      	adds	r3, #16
 802b1e6:	009b      	lsls	r3, r3, #2
 802b1e8:	4413      	add	r3, r2
 802b1ea:	6059      	str	r1, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802b1ec:	697b      	ldr	r3, [r7, #20]
 802b1ee:	3301      	adds	r3, #1
 802b1f0:	617b      	str	r3, [r7, #20]
 802b1f2:	687b      	ldr	r3, [r7, #4]
 802b1f4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b1f6:	697a      	ldr	r2, [r7, #20]
 802b1f8:	429a      	cmp	r2, r3
 802b1fa:	dbe9      	blt.n	802b1d0 <alloc_fs_workspace+0x20>
  }
}
 802b1fc:	bf00      	nop
 802b1fe:	bf00      	nop
 802b200:	3718      	adds	r7, #24
 802b202:	46bd      	mov	sp, r7
 802b204:	bd80      	pop	{r7, pc}
	...

0802b208 <start_pass_1_quant>:
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 802b208:	b580      	push	{r7, lr}
 802b20a:	b086      	sub	sp, #24
 802b20c:	af00      	add	r7, sp, #0
 802b20e:	6078      	str	r0, [r7, #4]
 802b210:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802b212:	687b      	ldr	r3, [r7, #4]
 802b214:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802b218:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
 802b21a:	693b      	ldr	r3, [r7, #16]
 802b21c:	691a      	ldr	r2, [r3, #16]
 802b21e:	687b      	ldr	r3, [r7, #4]
 802b220:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  cinfo->actual_number_of_colors = cquantize->sv_actual;
 802b224:	693b      	ldr	r3, [r7, #16]
 802b226:	695a      	ldr	r2, [r3, #20]
 802b228:	687b      	ldr	r3, [r7, #4]
 802b22a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
 802b22e:	687b      	ldr	r3, [r7, #4]
 802b230:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802b234:	2b02      	cmp	r3, #2
 802b236:	d02f      	beq.n	802b298 <start_pass_1_quant+0x90>
 802b238:	2b02      	cmp	r3, #2
 802b23a:	dc56      	bgt.n	802b2ea <start_pass_1_quant+0xe2>
 802b23c:	2b00      	cmp	r3, #0
 802b23e:	d002      	beq.n	802b246 <start_pass_1_quant+0x3e>
 802b240:	2b01      	cmp	r3, #1
 802b242:	d00c      	beq.n	802b25e <start_pass_1_quant+0x56>
 802b244:	e051      	b.n	802b2ea <start_pass_1_quant+0xe2>
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
 802b246:	687b      	ldr	r3, [r7, #4]
 802b248:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b24a:	2b03      	cmp	r3, #3
 802b24c:	d103      	bne.n	802b256 <start_pass_1_quant+0x4e>
      cquantize->pub.color_quantize = color_quantize3;
 802b24e:	693b      	ldr	r3, [r7, #16]
 802b250:	4a2d      	ldr	r2, [pc, #180]	@ (802b308 <start_pass_1_quant+0x100>)
 802b252:	605a      	str	r2, [r3, #4]
    else
      cquantize->pub.color_quantize = color_quantize;
    break;
 802b254:	e054      	b.n	802b300 <start_pass_1_quant+0xf8>
      cquantize->pub.color_quantize = color_quantize;
 802b256:	693b      	ldr	r3, [r7, #16]
 802b258:	4a2c      	ldr	r2, [pc, #176]	@ (802b30c <start_pass_1_quant+0x104>)
 802b25a:	605a      	str	r2, [r3, #4]
    break;
 802b25c:	e050      	b.n	802b300 <start_pass_1_quant+0xf8>
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
 802b25e:	687b      	ldr	r3, [r7, #4]
 802b260:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b262:	2b03      	cmp	r3, #3
 802b264:	d103      	bne.n	802b26e <start_pass_1_quant+0x66>
      cquantize->pub.color_quantize = quantize3_ord_dither;
 802b266:	693b      	ldr	r3, [r7, #16]
 802b268:	4a29      	ldr	r2, [pc, #164]	@ (802b310 <start_pass_1_quant+0x108>)
 802b26a:	605a      	str	r2, [r3, #4]
 802b26c:	e002      	b.n	802b274 <start_pass_1_quant+0x6c>
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
 802b26e:	693b      	ldr	r3, [r7, #16]
 802b270:	4a28      	ldr	r2, [pc, #160]	@ (802b314 <start_pass_1_quant+0x10c>)
 802b272:	605a      	str	r2, [r3, #4]
    cquantize->row_index = 0;	/* initialize state for ordered dither */
 802b274:	693b      	ldr	r3, [r7, #16]
 802b276:	2200      	movs	r2, #0
 802b278:	631a      	str	r2, [r3, #48]	@ 0x30
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
 802b27a:	693b      	ldr	r3, [r7, #16]
 802b27c:	69db      	ldr	r3, [r3, #28]
 802b27e:	2b00      	cmp	r3, #0
 802b280:	d102      	bne.n	802b288 <start_pass_1_quant+0x80>
      create_colorindex(cinfo);
 802b282:	6878      	ldr	r0, [r7, #4]
 802b284:	f7ff fbc6 	bl	802aa14 <create_colorindex>
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
 802b288:	693b      	ldr	r3, [r7, #16]
 802b28a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 802b28c:	2b00      	cmp	r3, #0
 802b28e:	d136      	bne.n	802b2fe <start_pass_1_quant+0xf6>
      create_odither_tables(cinfo);
 802b290:	6878      	ldr	r0, [r7, #4]
 802b292:	f7ff fcb5 	bl	802ac00 <create_odither_tables>
    break;
 802b296:	e032      	b.n	802b2fe <start_pass_1_quant+0xf6>
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
 802b298:	693b      	ldr	r3, [r7, #16]
 802b29a:	4a1f      	ldr	r2, [pc, #124]	@ (802b318 <start_pass_1_quant+0x110>)
 802b29c:	605a      	str	r2, [r3, #4]
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
 802b29e:	693b      	ldr	r3, [r7, #16]
 802b2a0:	2200      	movs	r2, #0
 802b2a2:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
 802b2a4:	693b      	ldr	r3, [r7, #16]
 802b2a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802b2a8:	2b00      	cmp	r3, #0
 802b2aa:	d102      	bne.n	802b2b2 <start_pass_1_quant+0xaa>
      alloc_fs_workspace(cinfo);
 802b2ac:	6878      	ldr	r0, [r7, #4]
 802b2ae:	f7ff ff7f 	bl	802b1b0 <alloc_fs_workspace>
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 802b2b2:	687b      	ldr	r3, [r7, #4]
 802b2b4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802b2b6:	3302      	adds	r3, #2
 802b2b8:	005b      	lsls	r3, r3, #1
 802b2ba:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < cinfo->out_color_components; i++)
 802b2bc:	2300      	movs	r3, #0
 802b2be:	617b      	str	r3, [r7, #20]
 802b2c0:	e00d      	b.n	802b2de <start_pass_1_quant+0xd6>
      FMEMZERO((void FAR *) cquantize->fserrors[i], arraysize);
 802b2c2:	693a      	ldr	r2, [r7, #16]
 802b2c4:	697b      	ldr	r3, [r7, #20]
 802b2c6:	3310      	adds	r3, #16
 802b2c8:	009b      	lsls	r3, r3, #2
 802b2ca:	4413      	add	r3, r2
 802b2cc:	685b      	ldr	r3, [r3, #4]
 802b2ce:	68fa      	ldr	r2, [r7, #12]
 802b2d0:	2100      	movs	r1, #0
 802b2d2:	4618      	mov	r0, r3
 802b2d4:	f002 fa8d 	bl	802d7f2 <memset>
    for (i = 0; i < cinfo->out_color_components; i++)
 802b2d8:	697b      	ldr	r3, [r7, #20]
 802b2da:	3301      	adds	r3, #1
 802b2dc:	617b      	str	r3, [r7, #20]
 802b2de:	687b      	ldr	r3, [r7, #4]
 802b2e0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b2e2:	697a      	ldr	r2, [r7, #20]
 802b2e4:	429a      	cmp	r2, r3
 802b2e6:	dbec      	blt.n	802b2c2 <start_pass_1_quant+0xba>
    break;
 802b2e8:	e00a      	b.n	802b300 <start_pass_1_quant+0xf8>
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
 802b2ea:	687b      	ldr	r3, [r7, #4]
 802b2ec:	681b      	ldr	r3, [r3, #0]
 802b2ee:	2231      	movs	r2, #49	@ 0x31
 802b2f0:	615a      	str	r2, [r3, #20]
 802b2f2:	687b      	ldr	r3, [r7, #4]
 802b2f4:	681b      	ldr	r3, [r3, #0]
 802b2f6:	681b      	ldr	r3, [r3, #0]
 802b2f8:	6878      	ldr	r0, [r7, #4]
 802b2fa:	4798      	blx	r3
    break;
 802b2fc:	e000      	b.n	802b300 <start_pass_1_quant+0xf8>
    break;
 802b2fe:	bf00      	nop
  }
}
 802b300:	bf00      	nop
 802b302:	3718      	adds	r7, #24
 802b304:	46bd      	mov	sp, r7
 802b306:	bd80      	pop	{r7, pc}
 802b308:	0802ad31 	.word	0x0802ad31
 802b30c:	0802ac93 	.word	0x0802ac93
 802b310:	0802aee1 	.word	0x0802aee1
 802b314:	0802ade3 	.word	0x0802ade3
 802b318:	0802b005 	.word	0x0802b005

0802b31c <finish_pass_1_quant>:
 * Finish up at the end of the pass.
 */

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
 802b31c:	b480      	push	{r7}
 802b31e:	b083      	sub	sp, #12
 802b320:	af00      	add	r7, sp, #0
 802b322:	6078      	str	r0, [r7, #4]
  /* no work in 1-pass case */
}
 802b324:	bf00      	nop
 802b326:	370c      	adds	r7, #12
 802b328:	46bd      	mov	sp, r7
 802b32a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b32e:	4770      	bx	lr

0802b330 <new_color_map_1_quant>:
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
 802b330:	b580      	push	{r7, lr}
 802b332:	b082      	sub	sp, #8
 802b334:	af00      	add	r7, sp, #0
 802b336:	6078      	str	r0, [r7, #4]
  ERREXIT(cinfo, JERR_MODE_CHANGE);
 802b338:	687b      	ldr	r3, [r7, #4]
 802b33a:	681b      	ldr	r3, [r3, #0]
 802b33c:	222f      	movs	r2, #47	@ 0x2f
 802b33e:	615a      	str	r2, [r3, #20]
 802b340:	687b      	ldr	r3, [r7, #4]
 802b342:	681b      	ldr	r3, [r3, #0]
 802b344:	681b      	ldr	r3, [r3, #0]
 802b346:	6878      	ldr	r0, [r7, #4]
 802b348:	4798      	blx	r3
}
 802b34a:	bf00      	nop
 802b34c:	3708      	adds	r7, #8
 802b34e:	46bd      	mov	sp, r7
 802b350:	bd80      	pop	{r7, pc}
	...

0802b354 <jinit_1pass_quantizer>:
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
 802b354:	b580      	push	{r7, lr}
 802b356:	b084      	sub	sp, #16
 802b358:	af00      	add	r7, sp, #0
 802b35a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802b35c:	687b      	ldr	r3, [r7, #4]
 802b35e:	685b      	ldr	r3, [r3, #4]
 802b360:	681b      	ldr	r3, [r3, #0]
 802b362:	2258      	movs	r2, #88	@ 0x58
 802b364:	2101      	movs	r1, #1
 802b366:	6878      	ldr	r0, [r7, #4]
 802b368:	4798      	blx	r3
 802b36a:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 802b36c:	687b      	ldr	r3, [r7, #4]
 802b36e:	68fa      	ldr	r2, [r7, #12]
 802b370:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
  cquantize->pub.start_pass = start_pass_1_quant;
 802b374:	68fb      	ldr	r3, [r7, #12]
 802b376:	4a22      	ldr	r2, [pc, #136]	@ (802b400 <jinit_1pass_quantizer+0xac>)
 802b378:	601a      	str	r2, [r3, #0]
  cquantize->pub.finish_pass = finish_pass_1_quant;
 802b37a:	68fb      	ldr	r3, [r7, #12]
 802b37c:	4a21      	ldr	r2, [pc, #132]	@ (802b404 <jinit_1pass_quantizer+0xb0>)
 802b37e:	609a      	str	r2, [r3, #8]
  cquantize->pub.new_color_map = new_color_map_1_quant;
 802b380:	68fb      	ldr	r3, [r7, #12]
 802b382:	4a21      	ldr	r2, [pc, #132]	@ (802b408 <jinit_1pass_quantizer+0xb4>)
 802b384:	60da      	str	r2, [r3, #12]
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
 802b386:	68fb      	ldr	r3, [r7, #12]
 802b388:	2200      	movs	r2, #0
 802b38a:	645a      	str	r2, [r3, #68]	@ 0x44
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
 802b38c:	68fb      	ldr	r3, [r7, #12]
 802b38e:	2200      	movs	r2, #0
 802b390:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
 802b392:	687b      	ldr	r3, [r7, #4]
 802b394:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802b396:	2b04      	cmp	r3, #4
 802b398:	dd0c      	ble.n	802b3b4 <jinit_1pass_quantizer+0x60>
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
 802b39a:	687b      	ldr	r3, [r7, #4]
 802b39c:	681b      	ldr	r3, [r3, #0]
 802b39e:	2239      	movs	r2, #57	@ 0x39
 802b3a0:	615a      	str	r2, [r3, #20]
 802b3a2:	687b      	ldr	r3, [r7, #4]
 802b3a4:	681b      	ldr	r3, [r3, #0]
 802b3a6:	2204      	movs	r2, #4
 802b3a8:	619a      	str	r2, [r3, #24]
 802b3aa:	687b      	ldr	r3, [r7, #4]
 802b3ac:	681b      	ldr	r3, [r3, #0]
 802b3ae:	681b      	ldr	r3, [r3, #0]
 802b3b0:	6878      	ldr	r0, [r7, #4]
 802b3b2:	4798      	blx	r3
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
 802b3b4:	687b      	ldr	r3, [r7, #4]
 802b3b6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802b3b8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802b3bc:	dd0d      	ble.n	802b3da <jinit_1pass_quantizer+0x86>
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
 802b3be:	687b      	ldr	r3, [r7, #4]
 802b3c0:	681b      	ldr	r3, [r3, #0]
 802b3c2:	223b      	movs	r2, #59	@ 0x3b
 802b3c4:	615a      	str	r2, [r3, #20]
 802b3c6:	687b      	ldr	r3, [r7, #4]
 802b3c8:	681b      	ldr	r3, [r3, #0]
 802b3ca:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802b3ce:	619a      	str	r2, [r3, #24]
 802b3d0:	687b      	ldr	r3, [r7, #4]
 802b3d2:	681b      	ldr	r3, [r3, #0]
 802b3d4:	681b      	ldr	r3, [r3, #0]
 802b3d6:	6878      	ldr	r0, [r7, #4]
 802b3d8:	4798      	blx	r3

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
 802b3da:	6878      	ldr	r0, [r7, #4]
 802b3dc:	f7ff fa74 	bl	802a8c8 <create_colormap>
  create_colorindex(cinfo);
 802b3e0:	6878      	ldr	r0, [r7, #4]
 802b3e2:	f7ff fb17 	bl	802aa14 <create_colorindex>
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
 802b3e6:	687b      	ldr	r3, [r7, #4]
 802b3e8:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802b3ec:	2b02      	cmp	r3, #2
 802b3ee:	d102      	bne.n	802b3f6 <jinit_1pass_quantizer+0xa2>
    alloc_fs_workspace(cinfo);
 802b3f0:	6878      	ldr	r0, [r7, #4]
 802b3f2:	f7ff fedd 	bl	802b1b0 <alloc_fs_workspace>
}
 802b3f6:	bf00      	nop
 802b3f8:	3710      	adds	r7, #16
 802b3fa:	46bd      	mov	sp, r7
 802b3fc:	bd80      	pop	{r7, pc}
 802b3fe:	bf00      	nop
 802b400:	0802b209 	.word	0x0802b209
 802b404:	0802b31d 	.word	0x0802b31d
 802b408:	0802b331 	.word	0x0802b331

0802b40c <prescan_quantize>:
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
 802b40c:	b4f0      	push	{r4, r5, r6, r7}
 802b40e:	b088      	sub	sp, #32
 802b410:	af00      	add	r7, sp, #0
 802b412:	60f8      	str	r0, [r7, #12]
 802b414:	60b9      	str	r1, [r7, #8]
 802b416:	607a      	str	r2, [r7, #4]
 802b418:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802b41a:	68fb      	ldr	r3, [r7, #12]
 802b41c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802b420:	617b      	str	r3, [r7, #20]
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
 802b422:	697b      	ldr	r3, [r7, #20]
 802b424:	699e      	ldr	r6, [r3, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802b426:	68fb      	ldr	r3, [r7, #12]
 802b428:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802b42a:	613b      	str	r3, [r7, #16]

  for (row = 0; row < num_rows; row++) {
 802b42c:	2300      	movs	r3, #0
 802b42e:	61fb      	str	r3, [r7, #28]
 802b430:	e02e      	b.n	802b490 <prescan_quantize+0x84>
    ptr = input_buf[row];
 802b432:	69fb      	ldr	r3, [r7, #28]
 802b434:	009b      	lsls	r3, r3, #2
 802b436:	68ba      	ldr	r2, [r7, #8]
 802b438:	4413      	add	r3, r2
 802b43a:	681c      	ldr	r4, [r3, #0]
    for (col = width; col > 0; col--) {
 802b43c:	693b      	ldr	r3, [r7, #16]
 802b43e:	61bb      	str	r3, [r7, #24]
 802b440:	e020      	b.n	802b484 <prescan_quantize+0x78>
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 802b442:	7823      	ldrb	r3, [r4, #0]
 802b444:	08db      	lsrs	r3, r3, #3
 802b446:	b2db      	uxtb	r3, r3
 802b448:	009b      	lsls	r3, r3, #2
 802b44a:	4433      	add	r3, r6
 802b44c:	681a      	ldr	r2, [r3, #0]
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
 802b44e:	1c63      	adds	r3, r4, #1
 802b450:	781b      	ldrb	r3, [r3, #0]
 802b452:	089b      	lsrs	r3, r3, #2
 802b454:	b2db      	uxtb	r3, r3
 802b456:	019b      	lsls	r3, r3, #6
 802b458:	441a      	add	r2, r3
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
 802b45a:	1ca3      	adds	r3, r4, #2
 802b45c:	781b      	ldrb	r3, [r3, #0]
 802b45e:	08db      	lsrs	r3, r3, #3
 802b460:	b2db      	uxtb	r3, r3
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 802b462:	005b      	lsls	r3, r3, #1
 802b464:	18d5      	adds	r5, r2, r3
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
 802b466:	882b      	ldrh	r3, [r5, #0]
 802b468:	3301      	adds	r3, #1
 802b46a:	b29b      	uxth	r3, r3
 802b46c:	802b      	strh	r3, [r5, #0]
 802b46e:	882b      	ldrh	r3, [r5, #0]
 802b470:	2b00      	cmp	r3, #0
 802b472:	d103      	bne.n	802b47c <prescan_quantize+0x70>
	(*histp)--;
 802b474:	882b      	ldrh	r3, [r5, #0]
 802b476:	3b01      	subs	r3, #1
 802b478:	b29b      	uxth	r3, r3
 802b47a:	802b      	strh	r3, [r5, #0]
      ptr += 3;
 802b47c:	3403      	adds	r4, #3
    for (col = width; col > 0; col--) {
 802b47e:	69bb      	ldr	r3, [r7, #24]
 802b480:	3b01      	subs	r3, #1
 802b482:	61bb      	str	r3, [r7, #24]
 802b484:	69bb      	ldr	r3, [r7, #24]
 802b486:	2b00      	cmp	r3, #0
 802b488:	d1db      	bne.n	802b442 <prescan_quantize+0x36>
  for (row = 0; row < num_rows; row++) {
 802b48a:	69fb      	ldr	r3, [r7, #28]
 802b48c:	3301      	adds	r3, #1
 802b48e:	61fb      	str	r3, [r7, #28]
 802b490:	69fa      	ldr	r2, [r7, #28]
 802b492:	683b      	ldr	r3, [r7, #0]
 802b494:	429a      	cmp	r2, r3
 802b496:	dbcc      	blt.n	802b432 <prescan_quantize+0x26>
    }
  }
}
 802b498:	bf00      	nop
 802b49a:	bf00      	nop
 802b49c:	3720      	adds	r7, #32
 802b49e:	46bd      	mov	sp, r7
 802b4a0:	bcf0      	pop	{r4, r5, r6, r7}
 802b4a2:	4770      	bx	lr

0802b4a4 <find_biggest_color_pop>:

LOCAL(boxptr)
find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
 802b4a4:	b4f0      	push	{r4, r5, r6, r7}
 802b4a6:	b084      	sub	sp, #16
 802b4a8:	af00      	add	r7, sp, #0
 802b4aa:	6078      	str	r0, [r7, #4]
 802b4ac:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register long maxc = 0;
 802b4ae:	2600      	movs	r6, #0
  boxptr which = NULL;
 802b4b0:	2300      	movs	r3, #0
 802b4b2:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802b4b4:	2500      	movs	r5, #0
 802b4b6:	687c      	ldr	r4, [r7, #4]
 802b4b8:	e009      	b.n	802b4ce <find_biggest_color_pop+0x2a>
    if (boxp->colorcount > maxc && boxp->volume > 0) {
 802b4ba:	69e3      	ldr	r3, [r4, #28]
 802b4bc:	429e      	cmp	r6, r3
 802b4be:	da04      	bge.n	802b4ca <find_biggest_color_pop+0x26>
 802b4c0:	69a3      	ldr	r3, [r4, #24]
 802b4c2:	2b00      	cmp	r3, #0
 802b4c4:	dd01      	ble.n	802b4ca <find_biggest_color_pop+0x26>
      which = boxp;
 802b4c6:	60fc      	str	r4, [r7, #12]
      maxc = boxp->colorcount;
 802b4c8:	69e6      	ldr	r6, [r4, #28]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802b4ca:	3501      	adds	r5, #1
 802b4cc:	3420      	adds	r4, #32
 802b4ce:	683b      	ldr	r3, [r7, #0]
 802b4d0:	429d      	cmp	r5, r3
 802b4d2:	dbf2      	blt.n	802b4ba <find_biggest_color_pop+0x16>
    }
  }
  return which;
 802b4d4:	68fb      	ldr	r3, [r7, #12]
}
 802b4d6:	4618      	mov	r0, r3
 802b4d8:	3710      	adds	r7, #16
 802b4da:	46bd      	mov	sp, r7
 802b4dc:	bcf0      	pop	{r4, r5, r6, r7}
 802b4de:	4770      	bx	lr

0802b4e0 <find_biggest_volume>:

LOCAL(boxptr)
find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
 802b4e0:	b4f0      	push	{r4, r5, r6, r7}
 802b4e2:	b084      	sub	sp, #16
 802b4e4:	af00      	add	r7, sp, #0
 802b4e6:	6078      	str	r0, [r7, #4]
 802b4e8:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
 802b4ea:	2600      	movs	r6, #0
  boxptr which = NULL;
 802b4ec:	2300      	movs	r3, #0
 802b4ee:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802b4f0:	2500      	movs	r5, #0
 802b4f2:	687c      	ldr	r4, [r7, #4]
 802b4f4:	e006      	b.n	802b504 <find_biggest_volume+0x24>
    if (boxp->volume > maxv) {
 802b4f6:	69a3      	ldr	r3, [r4, #24]
 802b4f8:	429e      	cmp	r6, r3
 802b4fa:	da01      	bge.n	802b500 <find_biggest_volume+0x20>
      which = boxp;
 802b4fc:	60fc      	str	r4, [r7, #12]
      maxv = boxp->volume;
 802b4fe:	69a6      	ldr	r6, [r4, #24]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802b500:	3501      	adds	r5, #1
 802b502:	3420      	adds	r4, #32
 802b504:	683b      	ldr	r3, [r7, #0]
 802b506:	429d      	cmp	r5, r3
 802b508:	dbf5      	blt.n	802b4f6 <find_biggest_volume+0x16>
    }
  }
  return which;
 802b50a:	68fb      	ldr	r3, [r7, #12]
}
 802b50c:	4618      	mov	r0, r3
 802b50e:	3710      	adds	r7, #16
 802b510:	46bd      	mov	sp, r7
 802b512:	bcf0      	pop	{r4, r5, r6, r7}
 802b514:	4770      	bx	lr

0802b516 <update_box>:

LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
 802b516:	b480      	push	{r7}
 802b518:	b093      	sub	sp, #76	@ 0x4c
 802b51a:	af00      	add	r7, sp, #0
 802b51c:	6078      	str	r0, [r7, #4]
 802b51e:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802b520:	687b      	ldr	r3, [r7, #4]
 802b522:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802b526:	61bb      	str	r3, [r7, #24]
  hist3d histogram = cquantize->histogram;
 802b528:	69bb      	ldr	r3, [r7, #24]
 802b52a:	699b      	ldr	r3, [r3, #24]
 802b52c:	617b      	str	r3, [r7, #20]
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 802b52e:	683b      	ldr	r3, [r7, #0]
 802b530:	681b      	ldr	r3, [r3, #0]
 802b532:	637b      	str	r3, [r7, #52]	@ 0x34
 802b534:	683b      	ldr	r3, [r7, #0]
 802b536:	685b      	ldr	r3, [r3, #4]
 802b538:	633b      	str	r3, [r7, #48]	@ 0x30
  c1min = boxp->c1min;  c1max = boxp->c1max;
 802b53a:	683b      	ldr	r3, [r7, #0]
 802b53c:	689b      	ldr	r3, [r3, #8]
 802b53e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802b540:	683b      	ldr	r3, [r7, #0]
 802b542:	68db      	ldr	r3, [r3, #12]
 802b544:	62bb      	str	r3, [r7, #40]	@ 0x28
  c2min = boxp->c2min;  c2max = boxp->c2max;
 802b546:	683b      	ldr	r3, [r7, #0]
 802b548:	691b      	ldr	r3, [r3, #16]
 802b54a:	627b      	str	r3, [r7, #36]	@ 0x24
 802b54c:	683b      	ldr	r3, [r7, #0]
 802b54e:	695b      	ldr	r3, [r3, #20]
 802b550:	623b      	str	r3, [r7, #32]
  
  if (c0max > c0min)
 802b552:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b554:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b556:	429a      	cmp	r2, r3
 802b558:	dd35      	ble.n	802b5c6 <update_box+0xb0>
    for (c0 = c0min; c0 <= c0max; c0++)
 802b55a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b55c:	643b      	str	r3, [r7, #64]	@ 0x40
 802b55e:	e02e      	b.n	802b5be <update_box+0xa8>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802b560:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b562:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b564:	e024      	b.n	802b5b0 <update_box+0x9a>
	histp = & histogram[c0][c1][c2min];
 802b566:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b568:	009b      	lsls	r3, r3, #2
 802b56a:	697a      	ldr	r2, [r7, #20]
 802b56c:	4413      	add	r3, r2
 802b56e:	681a      	ldr	r2, [r3, #0]
 802b570:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b572:	019b      	lsls	r3, r3, #6
 802b574:	441a      	add	r2, r3
 802b576:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b578:	005b      	lsls	r3, r3, #1
 802b57a:	4413      	add	r3, r2
 802b57c:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802b57e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b580:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b582:	e00e      	b.n	802b5a2 <update_box+0x8c>
	  if (*histp++ != 0) {
 802b584:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b586:	1c9a      	adds	r2, r3, #2
 802b588:	647a      	str	r2, [r7, #68]	@ 0x44
 802b58a:	881b      	ldrh	r3, [r3, #0]
 802b58c:	2b00      	cmp	r3, #0
 802b58e:	d005      	beq.n	802b59c <update_box+0x86>
	    boxp->c0min = c0min = c0;
 802b590:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b592:	637b      	str	r3, [r7, #52]	@ 0x34
 802b594:	683b      	ldr	r3, [r7, #0]
 802b596:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802b598:	601a      	str	r2, [r3, #0]
	    goto have_c0min;
 802b59a:	e015      	b.n	802b5c8 <update_box+0xb2>
	for (c2 = c2min; c2 <= c2max; c2++)
 802b59c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b59e:	3301      	adds	r3, #1
 802b5a0:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b5a2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b5a4:	6a3b      	ldr	r3, [r7, #32]
 802b5a6:	429a      	cmp	r2, r3
 802b5a8:	ddec      	ble.n	802b584 <update_box+0x6e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802b5aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b5ac:	3301      	adds	r3, #1
 802b5ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b5b0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b5b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b5b4:	429a      	cmp	r2, r3
 802b5b6:	ddd6      	ble.n	802b566 <update_box+0x50>
    for (c0 = c0min; c0 <= c0max; c0++)
 802b5b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b5ba:	3301      	adds	r3, #1
 802b5bc:	643b      	str	r3, [r7, #64]	@ 0x40
 802b5be:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b5c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b5c2:	429a      	cmp	r2, r3
 802b5c4:	ddcc      	ble.n	802b560 <update_box+0x4a>
	  }
      }
 have_c0min:
 802b5c6:	bf00      	nop
  if (c0max > c0min)
 802b5c8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b5ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b5cc:	429a      	cmp	r2, r3
 802b5ce:	dd35      	ble.n	802b63c <update_box+0x126>
    for (c0 = c0max; c0 >= c0min; c0--)
 802b5d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b5d2:	643b      	str	r3, [r7, #64]	@ 0x40
 802b5d4:	e02e      	b.n	802b634 <update_box+0x11e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802b5d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b5d8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b5da:	e024      	b.n	802b626 <update_box+0x110>
	histp = & histogram[c0][c1][c2min];
 802b5dc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b5de:	009b      	lsls	r3, r3, #2
 802b5e0:	697a      	ldr	r2, [r7, #20]
 802b5e2:	4413      	add	r3, r2
 802b5e4:	681a      	ldr	r2, [r3, #0]
 802b5e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b5e8:	019b      	lsls	r3, r3, #6
 802b5ea:	441a      	add	r2, r3
 802b5ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b5ee:	005b      	lsls	r3, r3, #1
 802b5f0:	4413      	add	r3, r2
 802b5f2:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802b5f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b5f6:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b5f8:	e00e      	b.n	802b618 <update_box+0x102>
	  if (*histp++ != 0) {
 802b5fa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b5fc:	1c9a      	adds	r2, r3, #2
 802b5fe:	647a      	str	r2, [r7, #68]	@ 0x44
 802b600:	881b      	ldrh	r3, [r3, #0]
 802b602:	2b00      	cmp	r3, #0
 802b604:	d005      	beq.n	802b612 <update_box+0xfc>
	    boxp->c0max = c0max = c0;
 802b606:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b608:	633b      	str	r3, [r7, #48]	@ 0x30
 802b60a:	683b      	ldr	r3, [r7, #0]
 802b60c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b60e:	605a      	str	r2, [r3, #4]
	    goto have_c0max;
 802b610:	e015      	b.n	802b63e <update_box+0x128>
	for (c2 = c2min; c2 <= c2max; c2++)
 802b612:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b614:	3301      	adds	r3, #1
 802b616:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b618:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b61a:	6a3b      	ldr	r3, [r7, #32]
 802b61c:	429a      	cmp	r2, r3
 802b61e:	ddec      	ble.n	802b5fa <update_box+0xe4>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802b620:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b622:	3301      	adds	r3, #1
 802b624:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b626:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b628:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b62a:	429a      	cmp	r2, r3
 802b62c:	ddd6      	ble.n	802b5dc <update_box+0xc6>
    for (c0 = c0max; c0 >= c0min; c0--)
 802b62e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b630:	3b01      	subs	r3, #1
 802b632:	643b      	str	r3, [r7, #64]	@ 0x40
 802b634:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b636:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b638:	429a      	cmp	r2, r3
 802b63a:	dacc      	bge.n	802b5d6 <update_box+0xc0>
	  }
      }
 have_c0max:
 802b63c:	bf00      	nop
  if (c1max > c1min)
 802b63e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802b640:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b642:	429a      	cmp	r2, r3
 802b644:	dd35      	ble.n	802b6b2 <update_box+0x19c>
    for (c1 = c1min; c1 <= c1max; c1++)
 802b646:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b648:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b64a:	e02e      	b.n	802b6aa <update_box+0x194>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b64c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b64e:	643b      	str	r3, [r7, #64]	@ 0x40
 802b650:	e024      	b.n	802b69c <update_box+0x186>
	histp = & histogram[c0][c1][c2min];
 802b652:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b654:	009b      	lsls	r3, r3, #2
 802b656:	697a      	ldr	r2, [r7, #20]
 802b658:	4413      	add	r3, r2
 802b65a:	681a      	ldr	r2, [r3, #0]
 802b65c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b65e:	019b      	lsls	r3, r3, #6
 802b660:	441a      	add	r2, r3
 802b662:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b664:	005b      	lsls	r3, r3, #1
 802b666:	4413      	add	r3, r2
 802b668:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802b66a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b66c:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b66e:	e00e      	b.n	802b68e <update_box+0x178>
	  if (*histp++ != 0) {
 802b670:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b672:	1c9a      	adds	r2, r3, #2
 802b674:	647a      	str	r2, [r7, #68]	@ 0x44
 802b676:	881b      	ldrh	r3, [r3, #0]
 802b678:	2b00      	cmp	r3, #0
 802b67a:	d005      	beq.n	802b688 <update_box+0x172>
	    boxp->c1min = c1min = c1;
 802b67c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b67e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802b680:	683b      	ldr	r3, [r7, #0]
 802b682:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802b684:	609a      	str	r2, [r3, #8]
	    goto have_c1min;
 802b686:	e015      	b.n	802b6b4 <update_box+0x19e>
	for (c2 = c2min; c2 <= c2max; c2++)
 802b688:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b68a:	3301      	adds	r3, #1
 802b68c:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b68e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b690:	6a3b      	ldr	r3, [r7, #32]
 802b692:	429a      	cmp	r2, r3
 802b694:	ddec      	ble.n	802b670 <update_box+0x15a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b696:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b698:	3301      	adds	r3, #1
 802b69a:	643b      	str	r3, [r7, #64]	@ 0x40
 802b69c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b69e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b6a0:	429a      	cmp	r2, r3
 802b6a2:	ddd6      	ble.n	802b652 <update_box+0x13c>
    for (c1 = c1min; c1 <= c1max; c1++)
 802b6a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b6a6:	3301      	adds	r3, #1
 802b6a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b6aa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b6ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b6ae:	429a      	cmp	r2, r3
 802b6b0:	ddcc      	ble.n	802b64c <update_box+0x136>
	  }
      }
 have_c1min:
 802b6b2:	bf00      	nop
  if (c1max > c1min)
 802b6b4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802b6b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b6b8:	429a      	cmp	r2, r3
 802b6ba:	dd35      	ble.n	802b728 <update_box+0x212>
    for (c1 = c1max; c1 >= c1min; c1--)
 802b6bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b6be:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b6c0:	e02e      	b.n	802b720 <update_box+0x20a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b6c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b6c4:	643b      	str	r3, [r7, #64]	@ 0x40
 802b6c6:	e024      	b.n	802b712 <update_box+0x1fc>
	histp = & histogram[c0][c1][c2min];
 802b6c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b6ca:	009b      	lsls	r3, r3, #2
 802b6cc:	697a      	ldr	r2, [r7, #20]
 802b6ce:	4413      	add	r3, r2
 802b6d0:	681a      	ldr	r2, [r3, #0]
 802b6d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b6d4:	019b      	lsls	r3, r3, #6
 802b6d6:	441a      	add	r2, r3
 802b6d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b6da:	005b      	lsls	r3, r3, #1
 802b6dc:	4413      	add	r3, r2
 802b6de:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802b6e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b6e2:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b6e4:	e00e      	b.n	802b704 <update_box+0x1ee>
	  if (*histp++ != 0) {
 802b6e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b6e8:	1c9a      	adds	r2, r3, #2
 802b6ea:	647a      	str	r2, [r7, #68]	@ 0x44
 802b6ec:	881b      	ldrh	r3, [r3, #0]
 802b6ee:	2b00      	cmp	r3, #0
 802b6f0:	d005      	beq.n	802b6fe <update_box+0x1e8>
	    boxp->c1max = c1max = c1;
 802b6f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b6f4:	62bb      	str	r3, [r7, #40]	@ 0x28
 802b6f6:	683b      	ldr	r3, [r7, #0]
 802b6f8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802b6fa:	60da      	str	r2, [r3, #12]
	    goto have_c1max;
 802b6fc:	e015      	b.n	802b72a <update_box+0x214>
	for (c2 = c2min; c2 <= c2max; c2++)
 802b6fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b700:	3301      	adds	r3, #1
 802b702:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b704:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b706:	6a3b      	ldr	r3, [r7, #32]
 802b708:	429a      	cmp	r2, r3
 802b70a:	ddec      	ble.n	802b6e6 <update_box+0x1d0>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b70c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b70e:	3301      	adds	r3, #1
 802b710:	643b      	str	r3, [r7, #64]	@ 0x40
 802b712:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b714:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b716:	429a      	cmp	r2, r3
 802b718:	ddd6      	ble.n	802b6c8 <update_box+0x1b2>
    for (c1 = c1max; c1 >= c1min; c1--)
 802b71a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b71c:	3b01      	subs	r3, #1
 802b71e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b720:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b722:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b724:	429a      	cmp	r2, r3
 802b726:	dacc      	bge.n	802b6c2 <update_box+0x1ac>
	  }
      }
 have_c1max:
 802b728:	bf00      	nop
  if (c2max > c2min)
 802b72a:	6a3a      	ldr	r2, [r7, #32]
 802b72c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b72e:	429a      	cmp	r2, r3
 802b730:	dd36      	ble.n	802b7a0 <update_box+0x28a>
    for (c2 = c2min; c2 <= c2max; c2++)
 802b732:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b734:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b736:	e02f      	b.n	802b798 <update_box+0x282>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b738:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b73a:	643b      	str	r3, [r7, #64]	@ 0x40
 802b73c:	e025      	b.n	802b78a <update_box+0x274>
	histp = & histogram[c0][c1min][c2];
 802b73e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b740:	009b      	lsls	r3, r3, #2
 802b742:	697a      	ldr	r2, [r7, #20]
 802b744:	4413      	add	r3, r2
 802b746:	681a      	ldr	r2, [r3, #0]
 802b748:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b74a:	019b      	lsls	r3, r3, #6
 802b74c:	441a      	add	r2, r3
 802b74e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b750:	005b      	lsls	r3, r3, #1
 802b752:	4413      	add	r3, r2
 802b754:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802b756:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b758:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b75a:	e00f      	b.n	802b77c <update_box+0x266>
	  if (*histp != 0) {
 802b75c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b75e:	881b      	ldrh	r3, [r3, #0]
 802b760:	2b00      	cmp	r3, #0
 802b762:	d005      	beq.n	802b770 <update_box+0x25a>
	    boxp->c2min = c2min = c2;
 802b764:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b766:	627b      	str	r3, [r7, #36]	@ 0x24
 802b768:	683b      	ldr	r3, [r7, #0]
 802b76a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802b76c:	611a      	str	r2, [r3, #16]
	    goto have_c2min;
 802b76e:	e018      	b.n	802b7a2 <update_box+0x28c>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802b770:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b772:	3301      	adds	r3, #1
 802b774:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b776:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b778:	3340      	adds	r3, #64	@ 0x40
 802b77a:	647b      	str	r3, [r7, #68]	@ 0x44
 802b77c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b77e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b780:	429a      	cmp	r2, r3
 802b782:	ddeb      	ble.n	802b75c <update_box+0x246>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b784:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b786:	3301      	adds	r3, #1
 802b788:	643b      	str	r3, [r7, #64]	@ 0x40
 802b78a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b78c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b78e:	429a      	cmp	r2, r3
 802b790:	ddd5      	ble.n	802b73e <update_box+0x228>
    for (c2 = c2min; c2 <= c2max; c2++)
 802b792:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b794:	3301      	adds	r3, #1
 802b796:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b798:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b79a:	6a3b      	ldr	r3, [r7, #32]
 802b79c:	429a      	cmp	r2, r3
 802b79e:	ddcb      	ble.n	802b738 <update_box+0x222>
	  }
      }
 have_c2min:
 802b7a0:	bf00      	nop
  if (c2max > c2min)
 802b7a2:	6a3a      	ldr	r2, [r7, #32]
 802b7a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b7a6:	429a      	cmp	r2, r3
 802b7a8:	dd36      	ble.n	802b818 <update_box+0x302>
    for (c2 = c2max; c2 >= c2min; c2--)
 802b7aa:	6a3b      	ldr	r3, [r7, #32]
 802b7ac:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b7ae:	e02f      	b.n	802b810 <update_box+0x2fa>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b7b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b7b2:	643b      	str	r3, [r7, #64]	@ 0x40
 802b7b4:	e025      	b.n	802b802 <update_box+0x2ec>
	histp = & histogram[c0][c1min][c2];
 802b7b6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b7b8:	009b      	lsls	r3, r3, #2
 802b7ba:	697a      	ldr	r2, [r7, #20]
 802b7bc:	4413      	add	r3, r2
 802b7be:	681a      	ldr	r2, [r3, #0]
 802b7c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b7c2:	019b      	lsls	r3, r3, #6
 802b7c4:	441a      	add	r2, r3
 802b7c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b7c8:	005b      	lsls	r3, r3, #1
 802b7ca:	4413      	add	r3, r2
 802b7cc:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802b7ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b7d0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b7d2:	e00f      	b.n	802b7f4 <update_box+0x2de>
	  if (*histp != 0) {
 802b7d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b7d6:	881b      	ldrh	r3, [r3, #0]
 802b7d8:	2b00      	cmp	r3, #0
 802b7da:	d005      	beq.n	802b7e8 <update_box+0x2d2>
	    boxp->c2max = c2max = c2;
 802b7dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b7de:	623b      	str	r3, [r7, #32]
 802b7e0:	683b      	ldr	r3, [r7, #0]
 802b7e2:	6a3a      	ldr	r2, [r7, #32]
 802b7e4:	615a      	str	r2, [r3, #20]
	    goto have_c2max;
 802b7e6:	e018      	b.n	802b81a <update_box+0x304>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802b7e8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b7ea:	3301      	adds	r3, #1
 802b7ec:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b7ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b7f0:	3340      	adds	r3, #64	@ 0x40
 802b7f2:	647b      	str	r3, [r7, #68]	@ 0x44
 802b7f4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b7f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b7f8:	429a      	cmp	r2, r3
 802b7fa:	ddeb      	ble.n	802b7d4 <update_box+0x2be>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802b7fc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b7fe:	3301      	adds	r3, #1
 802b800:	643b      	str	r3, [r7, #64]	@ 0x40
 802b802:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b804:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b806:	429a      	cmp	r2, r3
 802b808:	ddd5      	ble.n	802b7b6 <update_box+0x2a0>
    for (c2 = c2max; c2 >= c2min; c2--)
 802b80a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b80c:	3b01      	subs	r3, #1
 802b80e:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b810:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b812:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b814:	429a      	cmp	r2, r3
 802b816:	dacb      	bge.n	802b7b0 <update_box+0x29a>
	  }
      }
 have_c2max:
 802b818:	bf00      	nop
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
 802b81a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802b81c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b81e:	1ad3      	subs	r3, r2, r3
 802b820:	00db      	lsls	r3, r3, #3
 802b822:	005b      	lsls	r3, r3, #1
 802b824:	613b      	str	r3, [r7, #16]
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
 802b826:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802b828:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b82a:	1ad3      	subs	r3, r2, r3
 802b82c:	009a      	lsls	r2, r3, #2
 802b82e:	4613      	mov	r3, r2
 802b830:	005b      	lsls	r3, r3, #1
 802b832:	4413      	add	r3, r2
 802b834:	60fb      	str	r3, [r7, #12]
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
 802b836:	6a3a      	ldr	r2, [r7, #32]
 802b838:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b83a:	1ad3      	subs	r3, r2, r3
 802b83c:	00db      	lsls	r3, r3, #3
 802b83e:	60bb      	str	r3, [r7, #8]
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
 802b840:	693b      	ldr	r3, [r7, #16]
 802b842:	fb03 f203 	mul.w	r2, r3, r3
 802b846:	68fb      	ldr	r3, [r7, #12]
 802b848:	fb03 f303 	mul.w	r3, r3, r3
 802b84c:	441a      	add	r2, r3
 802b84e:	68bb      	ldr	r3, [r7, #8]
 802b850:	fb03 f303 	mul.w	r3, r3, r3
 802b854:	441a      	add	r2, r3
 802b856:	683b      	ldr	r3, [r7, #0]
 802b858:	619a      	str	r2, [r3, #24]
  
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
 802b85a:	2300      	movs	r3, #0
 802b85c:	61fb      	str	r3, [r7, #28]
  for (c0 = c0min; c0 <= c0max; c0++)
 802b85e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802b860:	643b      	str	r3, [r7, #64]	@ 0x40
 802b862:	e02c      	b.n	802b8be <update_box+0x3a8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802b864:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802b866:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b868:	e022      	b.n	802b8b0 <update_box+0x39a>
      histp = & histogram[c0][c1][c2min];
 802b86a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b86c:	009b      	lsls	r3, r3, #2
 802b86e:	697a      	ldr	r2, [r7, #20]
 802b870:	4413      	add	r3, r2
 802b872:	681a      	ldr	r2, [r3, #0]
 802b874:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b876:	019b      	lsls	r3, r3, #6
 802b878:	441a      	add	r2, r3
 802b87a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b87c:	005b      	lsls	r3, r3, #1
 802b87e:	4413      	add	r3, r2
 802b880:	647b      	str	r3, [r7, #68]	@ 0x44
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 802b882:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b884:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b886:	e00c      	b.n	802b8a2 <update_box+0x38c>
	if (*histp != 0) {
 802b888:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b88a:	881b      	ldrh	r3, [r3, #0]
 802b88c:	2b00      	cmp	r3, #0
 802b88e:	d002      	beq.n	802b896 <update_box+0x380>
	  ccount++;
 802b890:	69fb      	ldr	r3, [r7, #28]
 802b892:	3301      	adds	r3, #1
 802b894:	61fb      	str	r3, [r7, #28]
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 802b896:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b898:	3301      	adds	r3, #1
 802b89a:	63bb      	str	r3, [r7, #56]	@ 0x38
 802b89c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b89e:	3302      	adds	r3, #2
 802b8a0:	647b      	str	r3, [r7, #68]	@ 0x44
 802b8a2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802b8a4:	6a3b      	ldr	r3, [r7, #32]
 802b8a6:	429a      	cmp	r2, r3
 802b8a8:	ddee      	ble.n	802b888 <update_box+0x372>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802b8aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b8ac:	3301      	adds	r3, #1
 802b8ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802b8b0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b8b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802b8b4:	429a      	cmp	r2, r3
 802b8b6:	ddd8      	ble.n	802b86a <update_box+0x354>
  for (c0 = c0min; c0 <= c0max; c0++)
 802b8b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802b8ba:	3301      	adds	r3, #1
 802b8bc:	643b      	str	r3, [r7, #64]	@ 0x40
 802b8be:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802b8c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802b8c2:	429a      	cmp	r2, r3
 802b8c4:	ddce      	ble.n	802b864 <update_box+0x34e>
	}
    }
  boxp->colorcount = ccount;
 802b8c6:	683b      	ldr	r3, [r7, #0]
 802b8c8:	69fa      	ldr	r2, [r7, #28]
 802b8ca:	61da      	str	r2, [r3, #28]
}
 802b8cc:	bf00      	nop
 802b8ce:	374c      	adds	r7, #76	@ 0x4c
 802b8d0:	46bd      	mov	sp, r7
 802b8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b8d6:	4770      	bx	lr

0802b8d8 <median_cut>:

LOCAL(int)
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
/* Repeatedly select and split the largest box until we have enough boxes */
{
 802b8d8:	b5b0      	push	{r4, r5, r7, lr}
 802b8da:	b08a      	sub	sp, #40	@ 0x28
 802b8dc:	af00      	add	r7, sp, #0
 802b8de:	60f8      	str	r0, [r7, #12]
 802b8e0:	60b9      	str	r1, [r7, #8]
 802b8e2:	607a      	str	r2, [r7, #4]
 802b8e4:	603b      	str	r3, [r7, #0]
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
 802b8e6:	e085      	b.n	802b9f4 <median_cut+0x11c>
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
 802b8e8:	687b      	ldr	r3, [r7, #4]
 802b8ea:	005b      	lsls	r3, r3, #1
 802b8ec:	683a      	ldr	r2, [r7, #0]
 802b8ee:	429a      	cmp	r2, r3
 802b8f0:	db05      	blt.n	802b8fe <median_cut+0x26>
      b1 = find_biggest_color_pop(boxlist, numboxes);
 802b8f2:	6879      	ldr	r1, [r7, #4]
 802b8f4:	68b8      	ldr	r0, [r7, #8]
 802b8f6:	f7ff fdd5 	bl	802b4a4 <find_biggest_color_pop>
 802b8fa:	4604      	mov	r4, r0
 802b8fc:	e004      	b.n	802b908 <median_cut+0x30>
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
 802b8fe:	6879      	ldr	r1, [r7, #4]
 802b900:	68b8      	ldr	r0, [r7, #8]
 802b902:	f7ff fded 	bl	802b4e0 <find_biggest_volume>
 802b906:	4604      	mov	r4, r0
    }
    if (b1 == NULL)		/* no splittable boxes left! */
 802b908:	2c00      	cmp	r4, #0
 802b90a:	d079      	beq.n	802ba00 <median_cut+0x128>
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
 802b90c:	687b      	ldr	r3, [r7, #4]
 802b90e:	015b      	lsls	r3, r3, #5
 802b910:	68ba      	ldr	r2, [r7, #8]
 802b912:	18d5      	adds	r5, r2, r3
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
 802b914:	6863      	ldr	r3, [r4, #4]
 802b916:	606b      	str	r3, [r5, #4]
 802b918:	68e3      	ldr	r3, [r4, #12]
 802b91a:	60eb      	str	r3, [r5, #12]
 802b91c:	6963      	ldr	r3, [r4, #20]
 802b91e:	616b      	str	r3, [r5, #20]
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
 802b920:	6823      	ldr	r3, [r4, #0]
 802b922:	602b      	str	r3, [r5, #0]
 802b924:	68a3      	ldr	r3, [r4, #8]
 802b926:	60ab      	str	r3, [r5, #8]
 802b928:	6923      	ldr	r3, [r4, #16]
 802b92a:	612b      	str	r3, [r5, #16]
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
 802b92c:	6862      	ldr	r2, [r4, #4]
 802b92e:	6823      	ldr	r3, [r4, #0]
 802b930:	1ad3      	subs	r3, r2, r3
 802b932:	00db      	lsls	r3, r3, #3
 802b934:	005b      	lsls	r3, r3, #1
 802b936:	61fb      	str	r3, [r7, #28]
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
 802b938:	68e2      	ldr	r2, [r4, #12]
 802b93a:	68a3      	ldr	r3, [r4, #8]
 802b93c:	1ad3      	subs	r3, r2, r3
 802b93e:	009a      	lsls	r2, r3, #2
 802b940:	4613      	mov	r3, r2
 802b942:	005b      	lsls	r3, r3, #1
 802b944:	4413      	add	r3, r2
 802b946:	61bb      	str	r3, [r7, #24]
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
 802b948:	6962      	ldr	r2, [r4, #20]
 802b94a:	6923      	ldr	r3, [r4, #16]
 802b94c:	1ad3      	subs	r3, r2, r3
 802b94e:	00db      	lsls	r3, r3, #3
 802b950:	617b      	str	r3, [r7, #20]
    /* We want to break any ties in favor of green, then red, blue last.
     * This code does the right thing for R,G,B or B,G,R color orders only.
     */
#if RGB_RED == 0
    cmax = c1; n = 1;
 802b952:	69bb      	ldr	r3, [r7, #24]
 802b954:	623b      	str	r3, [r7, #32]
 802b956:	2301      	movs	r3, #1
 802b958:	627b      	str	r3, [r7, #36]	@ 0x24
    if (c0 > cmax) { cmax = c0; n = 0; }
 802b95a:	69fa      	ldr	r2, [r7, #28]
 802b95c:	6a3b      	ldr	r3, [r7, #32]
 802b95e:	429a      	cmp	r2, r3
 802b960:	dd03      	ble.n	802b96a <median_cut+0x92>
 802b962:	69fb      	ldr	r3, [r7, #28]
 802b964:	623b      	str	r3, [r7, #32]
 802b966:	2300      	movs	r3, #0
 802b968:	627b      	str	r3, [r7, #36]	@ 0x24
    if (c2 > cmax) { n = 2; }
 802b96a:	697a      	ldr	r2, [r7, #20]
 802b96c:	6a3b      	ldr	r3, [r7, #32]
 802b96e:	429a      	cmp	r2, r3
 802b970:	dd01      	ble.n	802b976 <median_cut+0x9e>
 802b972:	2302      	movs	r3, #2
 802b974:	627b      	str	r3, [r7, #36]	@ 0x24
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
 802b976:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b978:	2b02      	cmp	r3, #2
 802b97a:	d023      	beq.n	802b9c4 <median_cut+0xec>
 802b97c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b97e:	2b02      	cmp	r3, #2
 802b980:	dc2d      	bgt.n	802b9de <median_cut+0x106>
 802b982:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b984:	2b00      	cmp	r3, #0
 802b986:	d003      	beq.n	802b990 <median_cut+0xb8>
 802b988:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802b98a:	2b01      	cmp	r3, #1
 802b98c:	d00d      	beq.n	802b9aa <median_cut+0xd2>
 802b98e:	e026      	b.n	802b9de <median_cut+0x106>
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
 802b990:	6862      	ldr	r2, [r4, #4]
 802b992:	6823      	ldr	r3, [r4, #0]
 802b994:	4413      	add	r3, r2
 802b996:	0fda      	lsrs	r2, r3, #31
 802b998:	4413      	add	r3, r2
 802b99a:	105b      	asrs	r3, r3, #1
 802b99c:	613b      	str	r3, [r7, #16]
      b1->c0max = lb;
 802b99e:	693b      	ldr	r3, [r7, #16]
 802b9a0:	6063      	str	r3, [r4, #4]
      b2->c0min = lb+1;
 802b9a2:	693b      	ldr	r3, [r7, #16]
 802b9a4:	3301      	adds	r3, #1
 802b9a6:	602b      	str	r3, [r5, #0]
      break;
 802b9a8:	e019      	b.n	802b9de <median_cut+0x106>
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
 802b9aa:	68e2      	ldr	r2, [r4, #12]
 802b9ac:	68a3      	ldr	r3, [r4, #8]
 802b9ae:	4413      	add	r3, r2
 802b9b0:	0fda      	lsrs	r2, r3, #31
 802b9b2:	4413      	add	r3, r2
 802b9b4:	105b      	asrs	r3, r3, #1
 802b9b6:	613b      	str	r3, [r7, #16]
      b1->c1max = lb;
 802b9b8:	693b      	ldr	r3, [r7, #16]
 802b9ba:	60e3      	str	r3, [r4, #12]
      b2->c1min = lb+1;
 802b9bc:	693b      	ldr	r3, [r7, #16]
 802b9be:	3301      	adds	r3, #1
 802b9c0:	60ab      	str	r3, [r5, #8]
      break;
 802b9c2:	e00c      	b.n	802b9de <median_cut+0x106>
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
 802b9c4:	6962      	ldr	r2, [r4, #20]
 802b9c6:	6923      	ldr	r3, [r4, #16]
 802b9c8:	4413      	add	r3, r2
 802b9ca:	0fda      	lsrs	r2, r3, #31
 802b9cc:	4413      	add	r3, r2
 802b9ce:	105b      	asrs	r3, r3, #1
 802b9d0:	613b      	str	r3, [r7, #16]
      b1->c2max = lb;
 802b9d2:	693b      	ldr	r3, [r7, #16]
 802b9d4:	6163      	str	r3, [r4, #20]
      b2->c2min = lb+1;
 802b9d6:	693b      	ldr	r3, [r7, #16]
 802b9d8:	3301      	adds	r3, #1
 802b9da:	612b      	str	r3, [r5, #16]
      break;
 802b9dc:	bf00      	nop
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
 802b9de:	4621      	mov	r1, r4
 802b9e0:	68f8      	ldr	r0, [r7, #12]
 802b9e2:	f7ff fd98 	bl	802b516 <update_box>
    update_box(cinfo, b2);
 802b9e6:	4629      	mov	r1, r5
 802b9e8:	68f8      	ldr	r0, [r7, #12]
 802b9ea:	f7ff fd94 	bl	802b516 <update_box>
    numboxes++;
 802b9ee:	687b      	ldr	r3, [r7, #4]
 802b9f0:	3301      	adds	r3, #1
 802b9f2:	607b      	str	r3, [r7, #4]
  while (numboxes < desired_colors) {
 802b9f4:	687a      	ldr	r2, [r7, #4]
 802b9f6:	683b      	ldr	r3, [r7, #0]
 802b9f8:	429a      	cmp	r2, r3
 802b9fa:	f6ff af75 	blt.w	802b8e8 <median_cut+0x10>
 802b9fe:	e000      	b.n	802ba02 <median_cut+0x12a>
      break;
 802ba00:	bf00      	nop
  }
  return numboxes;
 802ba02:	687b      	ldr	r3, [r7, #4]
}
 802ba04:	4618      	mov	r0, r3
 802ba06:	3728      	adds	r7, #40	@ 0x28
 802ba08:	46bd      	mov	sp, r7
 802ba0a:	bdb0      	pop	{r4, r5, r7, pc}

0802ba0c <compute_color>:


LOCAL(void)
compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
 802ba0c:	b480      	push	{r7}
 802ba0e:	b097      	sub	sp, #92	@ 0x5c
 802ba10:	af00      	add	r7, sp, #0
 802ba12:	60f8      	str	r0, [r7, #12]
 802ba14:	60b9      	str	r1, [r7, #8]
 802ba16:	607a      	str	r2, [r7, #4]
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ba18:	68fb      	ldr	r3, [r7, #12]
 802ba1a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ba1e:	637b      	str	r3, [r7, #52]	@ 0x34
  hist3d histogram = cquantize->histogram;
 802ba20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ba22:	699b      	ldr	r3, [r3, #24]
 802ba24:	633b      	str	r3, [r7, #48]	@ 0x30
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  long count;
  long total = 0;
 802ba26:	2300      	movs	r3, #0
 802ba28:	647b      	str	r3, [r7, #68]	@ 0x44
  long c0total = 0;
 802ba2a:	2300      	movs	r3, #0
 802ba2c:	643b      	str	r3, [r7, #64]	@ 0x40
  long c1total = 0;
 802ba2e:	2300      	movs	r3, #0
 802ba30:	63fb      	str	r3, [r7, #60]	@ 0x3c
  long c2total = 0;
 802ba32:	2300      	movs	r3, #0
 802ba34:	63bb      	str	r3, [r7, #56]	@ 0x38
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 802ba36:	68bb      	ldr	r3, [r7, #8]
 802ba38:	681b      	ldr	r3, [r3, #0]
 802ba3a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802ba3c:	68bb      	ldr	r3, [r7, #8]
 802ba3e:	685b      	ldr	r3, [r3, #4]
 802ba40:	62bb      	str	r3, [r7, #40]	@ 0x28
  c1min = boxp->c1min;  c1max = boxp->c1max;
 802ba42:	68bb      	ldr	r3, [r7, #8]
 802ba44:	689b      	ldr	r3, [r3, #8]
 802ba46:	627b      	str	r3, [r7, #36]	@ 0x24
 802ba48:	68bb      	ldr	r3, [r7, #8]
 802ba4a:	68db      	ldr	r3, [r3, #12]
 802ba4c:	623b      	str	r3, [r7, #32]
  c2min = boxp->c2min;  c2max = boxp->c2max;
 802ba4e:	68bb      	ldr	r3, [r7, #8]
 802ba50:	691b      	ldr	r3, [r3, #16]
 802ba52:	61fb      	str	r3, [r7, #28]
 802ba54:	68bb      	ldr	r3, [r7, #8]
 802ba56:	695b      	ldr	r3, [r3, #20]
 802ba58:	61bb      	str	r3, [r7, #24]
  
  for (c0 = c0min; c0 <= c0max; c0++)
 802ba5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ba5c:	653b      	str	r3, [r7, #80]	@ 0x50
 802ba5e:	e049      	b.n	802baf4 <compute_color+0xe8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802ba60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802ba62:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802ba64:	e03f      	b.n	802bae6 <compute_color+0xda>
      histp = & histogram[c0][c1][c2min];
 802ba66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802ba68:	009b      	lsls	r3, r3, #2
 802ba6a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802ba6c:	4413      	add	r3, r2
 802ba6e:	681a      	ldr	r2, [r3, #0]
 802ba70:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802ba72:	019b      	lsls	r3, r3, #6
 802ba74:	441a      	add	r2, r3
 802ba76:	69fb      	ldr	r3, [r7, #28]
 802ba78:	005b      	lsls	r3, r3, #1
 802ba7a:	4413      	add	r3, r2
 802ba7c:	657b      	str	r3, [r7, #84]	@ 0x54
      for (c2 = c2min; c2 <= c2max; c2++) {
 802ba7e:	69fb      	ldr	r3, [r7, #28]
 802ba80:	64bb      	str	r3, [r7, #72]	@ 0x48
 802ba82:	e029      	b.n	802bad8 <compute_color+0xcc>
	if ((count = *histp++) != 0) {
 802ba84:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802ba86:	1c9a      	adds	r2, r3, #2
 802ba88:	657a      	str	r2, [r7, #84]	@ 0x54
 802ba8a:	881b      	ldrh	r3, [r3, #0]
 802ba8c:	617b      	str	r3, [r7, #20]
 802ba8e:	697b      	ldr	r3, [r7, #20]
 802ba90:	2b00      	cmp	r3, #0
 802ba92:	d01e      	beq.n	802bad2 <compute_color+0xc6>
	  total += count;
 802ba94:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802ba96:	697b      	ldr	r3, [r7, #20]
 802ba98:	4413      	add	r3, r2
 802ba9a:	647b      	str	r3, [r7, #68]	@ 0x44
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
 802ba9c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802ba9e:	00db      	lsls	r3, r3, #3
 802baa0:	3304      	adds	r3, #4
 802baa2:	697a      	ldr	r2, [r7, #20]
 802baa4:	fb02 f303 	mul.w	r3, r2, r3
 802baa8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802baaa:	4413      	add	r3, r2
 802baac:	643b      	str	r3, [r7, #64]	@ 0x40
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
 802baae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802bab0:	009b      	lsls	r3, r3, #2
 802bab2:	3302      	adds	r3, #2
 802bab4:	697a      	ldr	r2, [r7, #20]
 802bab6:	fb02 f303 	mul.w	r3, r2, r3
 802baba:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802babc:	4413      	add	r3, r2
 802babe:	63fb      	str	r3, [r7, #60]	@ 0x3c
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
 802bac0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802bac2:	00db      	lsls	r3, r3, #3
 802bac4:	3304      	adds	r3, #4
 802bac6:	697a      	ldr	r2, [r7, #20]
 802bac8:	fb02 f303 	mul.w	r3, r2, r3
 802bacc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802bace:	4413      	add	r3, r2
 802bad0:	63bb      	str	r3, [r7, #56]	@ 0x38
      for (c2 = c2min; c2 <= c2max; c2++) {
 802bad2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802bad4:	3301      	adds	r3, #1
 802bad6:	64bb      	str	r3, [r7, #72]	@ 0x48
 802bad8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802bada:	69bb      	ldr	r3, [r7, #24]
 802badc:	429a      	cmp	r2, r3
 802bade:	ddd1      	ble.n	802ba84 <compute_color+0x78>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802bae0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802bae2:	3301      	adds	r3, #1
 802bae4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802bae6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802bae8:	6a3b      	ldr	r3, [r7, #32]
 802baea:	429a      	cmp	r2, r3
 802baec:	ddbb      	ble.n	802ba66 <compute_color+0x5a>
  for (c0 = c0min; c0 <= c0max; c0++)
 802baee:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802baf0:	3301      	adds	r3, #1
 802baf2:	653b      	str	r3, [r7, #80]	@ 0x50
 802baf4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802baf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802baf8:	429a      	cmp	r2, r3
 802bafa:	ddb1      	ble.n	802ba60 <compute_color+0x54>
	}
      }
    }
  
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
 802bafc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bafe:	105a      	asrs	r2, r3, #1
 802bb00:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802bb02:	441a      	add	r2, r3
 802bb04:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bb06:	fb92 f1f3 	sdiv	r1, r2, r3
 802bb0a:	68fb      	ldr	r3, [r7, #12]
 802bb0c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bb10:	681a      	ldr	r2, [r3, #0]
 802bb12:	687b      	ldr	r3, [r7, #4]
 802bb14:	4413      	add	r3, r2
 802bb16:	b2ca      	uxtb	r2, r1
 802bb18:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
 802bb1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bb1c:	105a      	asrs	r2, r3, #1
 802bb1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802bb20:	441a      	add	r2, r3
 802bb22:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bb24:	fb92 f1f3 	sdiv	r1, r2, r3
 802bb28:	68fb      	ldr	r3, [r7, #12]
 802bb2a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bb2e:	3304      	adds	r3, #4
 802bb30:	681a      	ldr	r2, [r3, #0]
 802bb32:	687b      	ldr	r3, [r7, #4]
 802bb34:	4413      	add	r3, r2
 802bb36:	b2ca      	uxtb	r2, r1
 802bb38:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
 802bb3a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bb3c:	105a      	asrs	r2, r3, #1
 802bb3e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802bb40:	441a      	add	r2, r3
 802bb42:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802bb44:	fb92 f1f3 	sdiv	r1, r2, r3
 802bb48:	68fb      	ldr	r3, [r7, #12]
 802bb4a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bb4e:	3308      	adds	r3, #8
 802bb50:	681a      	ldr	r2, [r3, #0]
 802bb52:	687b      	ldr	r3, [r7, #4]
 802bb54:	4413      	add	r3, r2
 802bb56:	b2ca      	uxtb	r2, r1
 802bb58:	701a      	strb	r2, [r3, #0]
}
 802bb5a:	bf00      	nop
 802bb5c:	375c      	adds	r7, #92	@ 0x5c
 802bb5e:	46bd      	mov	sp, r7
 802bb60:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bb64:	4770      	bx	lr

0802bb66 <select_colors>:


LOCAL(void)
select_colors (j_decompress_ptr cinfo, int desired_colors)
/* Master routine for color selection */
{
 802bb66:	b580      	push	{r7, lr}
 802bb68:	b086      	sub	sp, #24
 802bb6a:	af00      	add	r7, sp, #0
 802bb6c:	6078      	str	r0, [r7, #4]
 802bb6e:	6039      	str	r1, [r7, #0]
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
 802bb70:	687b      	ldr	r3, [r7, #4]
 802bb72:	685b      	ldr	r3, [r3, #4]
 802bb74:	681b      	ldr	r3, [r3, #0]
 802bb76:	683a      	ldr	r2, [r7, #0]
 802bb78:	0152      	lsls	r2, r2, #5
 802bb7a:	2101      	movs	r1, #1
 802bb7c:	6878      	ldr	r0, [r7, #4]
 802bb7e:	4798      	blx	r3
 802bb80:	6138      	str	r0, [r7, #16]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
 802bb82:	2301      	movs	r3, #1
 802bb84:	60fb      	str	r3, [r7, #12]
  boxlist[0].c0min = 0;
 802bb86:	693b      	ldr	r3, [r7, #16]
 802bb88:	2200      	movs	r2, #0
 802bb8a:	601a      	str	r2, [r3, #0]
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
 802bb8c:	693b      	ldr	r3, [r7, #16]
 802bb8e:	221f      	movs	r2, #31
 802bb90:	605a      	str	r2, [r3, #4]
  boxlist[0].c1min = 0;
 802bb92:	693b      	ldr	r3, [r7, #16]
 802bb94:	2200      	movs	r2, #0
 802bb96:	609a      	str	r2, [r3, #8]
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
 802bb98:	693b      	ldr	r3, [r7, #16]
 802bb9a:	223f      	movs	r2, #63	@ 0x3f
 802bb9c:	60da      	str	r2, [r3, #12]
  boxlist[0].c2min = 0;
 802bb9e:	693b      	ldr	r3, [r7, #16]
 802bba0:	2200      	movs	r2, #0
 802bba2:	611a      	str	r2, [r3, #16]
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
 802bba4:	693b      	ldr	r3, [r7, #16]
 802bba6:	221f      	movs	r2, #31
 802bba8:	615a      	str	r2, [r3, #20]
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
 802bbaa:	6939      	ldr	r1, [r7, #16]
 802bbac:	6878      	ldr	r0, [r7, #4]
 802bbae:	f7ff fcb2 	bl	802b516 <update_box>
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
 802bbb2:	683b      	ldr	r3, [r7, #0]
 802bbb4:	68fa      	ldr	r2, [r7, #12]
 802bbb6:	6939      	ldr	r1, [r7, #16]
 802bbb8:	6878      	ldr	r0, [r7, #4]
 802bbba:	f7ff fe8d 	bl	802b8d8 <median_cut>
 802bbbe:	60f8      	str	r0, [r7, #12]
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
 802bbc0:	2300      	movs	r3, #0
 802bbc2:	617b      	str	r3, [r7, #20]
 802bbc4:	e00b      	b.n	802bbde <select_colors+0x78>
    compute_color(cinfo, & boxlist[i], i);
 802bbc6:	697b      	ldr	r3, [r7, #20]
 802bbc8:	015b      	lsls	r3, r3, #5
 802bbca:	693a      	ldr	r2, [r7, #16]
 802bbcc:	4413      	add	r3, r2
 802bbce:	697a      	ldr	r2, [r7, #20]
 802bbd0:	4619      	mov	r1, r3
 802bbd2:	6878      	ldr	r0, [r7, #4]
 802bbd4:	f7ff ff1a 	bl	802ba0c <compute_color>
  for (i = 0; i < numboxes; i++)
 802bbd8:	697b      	ldr	r3, [r7, #20]
 802bbda:	3301      	adds	r3, #1
 802bbdc:	617b      	str	r3, [r7, #20]
 802bbde:	697a      	ldr	r2, [r7, #20]
 802bbe0:	68fb      	ldr	r3, [r7, #12]
 802bbe2:	429a      	cmp	r2, r3
 802bbe4:	dbef      	blt.n	802bbc6 <select_colors+0x60>
  cinfo->actual_number_of_colors = numboxes;
 802bbe6:	687b      	ldr	r3, [r7, #4]
 802bbe8:	68fa      	ldr	r2, [r7, #12]
 802bbea:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
 802bbee:	687b      	ldr	r3, [r7, #4]
 802bbf0:	681b      	ldr	r3, [r3, #0]
 802bbf2:	2262      	movs	r2, #98	@ 0x62
 802bbf4:	615a      	str	r2, [r3, #20]
 802bbf6:	687b      	ldr	r3, [r7, #4]
 802bbf8:	681b      	ldr	r3, [r3, #0]
 802bbfa:	68fa      	ldr	r2, [r7, #12]
 802bbfc:	619a      	str	r2, [r3, #24]
 802bbfe:	687b      	ldr	r3, [r7, #4]
 802bc00:	681b      	ldr	r3, [r3, #0]
 802bc02:	685b      	ldr	r3, [r3, #4]
 802bc04:	2101      	movs	r1, #1
 802bc06:	6878      	ldr	r0, [r7, #4]
 802bc08:	4798      	blx	r3
}
 802bc0a:	bf00      	nop
 802bc0c:	3718      	adds	r7, #24
 802bc0e:	46bd      	mov	sp, r7
 802bc10:	bd80      	pop	{r7, pc}

0802bc12 <find_nearby_colors>:
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
 802bc12:	b490      	push	{r4, r7}
 802bc14:	f5ad 6d89 	sub.w	sp, sp, #1096	@ 0x448
 802bc18:	af00      	add	r7, sp, #0
 802bc1a:	f507 6489 	add.w	r4, r7, #1096	@ 0x448
 802bc1e:	f2a4 443c 	subw	r4, r4, #1084	@ 0x43c
 802bc22:	6020      	str	r0, [r4, #0]
 802bc24:	f507 6089 	add.w	r0, r7, #1096	@ 0x448
 802bc28:	f5a0 6088 	sub.w	r0, r0, #1088	@ 0x440
 802bc2c:	6001      	str	r1, [r0, #0]
 802bc2e:	f507 6189 	add.w	r1, r7, #1096	@ 0x448
 802bc32:	f2a1 4144 	subw	r1, r1, #1092	@ 0x444
 802bc36:	600a      	str	r2, [r1, #0]
 802bc38:	f507 6289 	add.w	r2, r7, #1096	@ 0x448
 802bc3c:	f5a2 6289 	sub.w	r2, r2, #1096	@ 0x448
 802bc40:	6013      	str	r3, [r2, #0]
  int numcolors = cinfo->actual_number_of_colors;
 802bc42:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bc46:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802bc4a:	681b      	ldr	r3, [r3, #0]
 802bc4c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 802bc50:	f8c7 3430 	str.w	r3, [r7, #1072]	@ 0x430
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
 802bc54:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bc58:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bc5c:	681b      	ldr	r3, [r3, #0]
 802bc5e:	3318      	adds	r3, #24
 802bc60:	f8c7 342c 	str.w	r3, [r7, #1068]	@ 0x42c
  centerc0 = (minc0 + maxc0) >> 1;
 802bc64:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bc68:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bc6c:	681a      	ldr	r2, [r3, #0]
 802bc6e:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802bc72:	4413      	add	r3, r2
 802bc74:	105b      	asrs	r3, r3, #1
 802bc76:	f8c7 3428 	str.w	r3, [r7, #1064]	@ 0x428
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
 802bc7a:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bc7e:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802bc82:	681b      	ldr	r3, [r3, #0]
 802bc84:	331c      	adds	r3, #28
 802bc86:	f8c7 3424 	str.w	r3, [r7, #1060]	@ 0x424
  centerc1 = (minc1 + maxc1) >> 1;
 802bc8a:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bc8e:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802bc92:	681a      	ldr	r2, [r3, #0]
 802bc94:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802bc98:	4413      	add	r3, r2
 802bc9a:	105b      	asrs	r3, r3, #1
 802bc9c:	f8c7 3420 	str.w	r3, [r7, #1056]	@ 0x420
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
 802bca0:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bca4:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802bca8:	681b      	ldr	r3, [r3, #0]
 802bcaa:	3318      	adds	r3, #24
 802bcac:	f8c7 341c 	str.w	r3, [r7, #1052]	@ 0x41c
  centerc2 = (minc2 + maxc2) >> 1;
 802bcb0:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bcb4:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802bcb8:	681a      	ldr	r2, [r3, #0]
 802bcba:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802bcbe:	4413      	add	r3, r2
 802bcc0:	105b      	asrs	r3, r3, #1
 802bcc2:	f8c7 3418 	str.w	r3, [r7, #1048]	@ 0x418
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;
 802bcc6:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 802bcca:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c

  for (i = 0; i < numcolors; i++) {
 802bcce:	2300      	movs	r3, #0
 802bcd0:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802bcd4:	e1d0      	b.n	802c078 <find_nearby_colors+0x466>
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
 802bcd6:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bcda:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802bcde:	681b      	ldr	r3, [r3, #0]
 802bce0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bce4:	681a      	ldr	r2, [r3, #0]
 802bce6:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802bcea:	4413      	add	r3, r2
 802bcec:	781b      	ldrb	r3, [r3, #0]
 802bcee:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc0) {
 802bcf2:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bcf6:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bcfa:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bcfe:	681b      	ldr	r3, [r3, #0]
 802bd00:	429a      	cmp	r2, r3
 802bd02:	da1f      	bge.n	802bd44 <find_nearby_colors+0x132>
      tdist = (x - minc0) * C0_SCALE;
 802bd04:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bd08:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bd0c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd10:	681b      	ldr	r3, [r3, #0]
 802bd12:	1ad3      	subs	r3, r2, r3
 802bd14:	005b      	lsls	r3, r3, #1
 802bd16:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist = tdist*tdist;
 802bd1a:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bd1e:	fb03 f303 	mul.w	r3, r3, r3
 802bd22:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc0) * C0_SCALE;
 802bd26:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd2a:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802bd2e:	1ad3      	subs	r3, r2, r3
 802bd30:	005b      	lsls	r3, r3, #1
 802bd32:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist = tdist*tdist;
 802bd36:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bd3a:	fb03 f303 	mul.w	r3, r3, r3
 802bd3e:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bd42:	e04e      	b.n	802bde2 <find_nearby_colors+0x1d0>
    } else if (x > maxc0) {
 802bd44:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd48:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802bd4c:	429a      	cmp	r2, r3
 802bd4e:	dd1f      	ble.n	802bd90 <find_nearby_colors+0x17e>
      tdist = (x - maxc0) * C0_SCALE;
 802bd50:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd54:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802bd58:	1ad3      	subs	r3, r2, r3
 802bd5a:	005b      	lsls	r3, r3, #1
 802bd5c:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist = tdist*tdist;
 802bd60:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bd64:	fb03 f303 	mul.w	r3, r3, r3
 802bd68:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc0) * C0_SCALE;
 802bd6c:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bd70:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bd74:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd78:	681b      	ldr	r3, [r3, #0]
 802bd7a:	1ad3      	subs	r3, r2, r3
 802bd7c:	005b      	lsls	r3, r3, #1
 802bd7e:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist = tdist*tdist;
 802bd82:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bd86:	fb03 f303 	mul.w	r3, r3, r3
 802bd8a:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bd8e:	e028      	b.n	802bde2 <find_nearby_colors+0x1d0>
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
 802bd90:	2300      	movs	r3, #0
 802bd92:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      if (x <= centerc0) {
 802bd96:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bd9a:	f8d7 3428 	ldr.w	r3, [r7, #1064]	@ 0x428
 802bd9e:	429a      	cmp	r2, r3
 802bda0:	dc0e      	bgt.n	802bdc0 <find_nearby_colors+0x1ae>
	tdist = (x - maxc0) * C0_SCALE;
 802bda2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bda6:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802bdaa:	1ad3      	subs	r3, r2, r3
 802bdac:	005b      	lsls	r3, r3, #1
 802bdae:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist = tdist*tdist;
 802bdb2:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bdb6:	fb03 f303 	mul.w	r3, r3, r3
 802bdba:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bdbe:	e010      	b.n	802bde2 <find_nearby_colors+0x1d0>
      } else {
	tdist = (x - minc0) * C0_SCALE;
 802bdc0:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bdc4:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802bdc8:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bdcc:	681b      	ldr	r3, [r3, #0]
 802bdce:	1ad3      	subs	r3, r2, r3
 802bdd0:	005b      	lsls	r3, r3, #1
 802bdd2:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist = tdist*tdist;
 802bdd6:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bdda:	fb03 f303 	mul.w	r3, r3, r3
 802bdde:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
 802bde2:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bde6:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802bdea:	681b      	ldr	r3, [r3, #0]
 802bdec:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bdf0:	3304      	adds	r3, #4
 802bdf2:	681a      	ldr	r2, [r3, #0]
 802bdf4:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802bdf8:	4413      	add	r3, r2
 802bdfa:	781b      	ldrb	r3, [r3, #0]
 802bdfc:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc1) {
 802be00:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802be04:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802be08:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802be0c:	681b      	ldr	r3, [r3, #0]
 802be0e:	429a      	cmp	r2, r3
 802be10:	da29      	bge.n	802be66 <find_nearby_colors+0x254>
      tdist = (x - minc1) * C1_SCALE;
 802be12:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802be16:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802be1a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802be1e:	681b      	ldr	r3, [r3, #0]
 802be20:	1ad2      	subs	r2, r2, r3
 802be22:	4613      	mov	r3, r2
 802be24:	005b      	lsls	r3, r3, #1
 802be26:	4413      	add	r3, r2
 802be28:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802be2c:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802be30:	fb03 f303 	mul.w	r3, r3, r3
 802be34:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802be38:	4413      	add	r3, r2
 802be3a:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc1) * C1_SCALE;
 802be3e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802be42:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802be46:	1ad2      	subs	r2, r2, r3
 802be48:	4613      	mov	r3, r2
 802be4a:	005b      	lsls	r3, r3, #1
 802be4c:	4413      	add	r3, r2
 802be4e:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802be52:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802be56:	fb03 f303 	mul.w	r3, r3, r3
 802be5a:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802be5e:	4413      	add	r3, r2
 802be60:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802be64:	e05f      	b.n	802bf26 <find_nearby_colors+0x314>
    } else if (x > maxc1) {
 802be66:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802be6a:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802be6e:	429a      	cmp	r2, r3
 802be70:	dd29      	ble.n	802bec6 <find_nearby_colors+0x2b4>
      tdist = (x - maxc1) * C1_SCALE;
 802be72:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802be76:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802be7a:	1ad2      	subs	r2, r2, r3
 802be7c:	4613      	mov	r3, r2
 802be7e:	005b      	lsls	r3, r3, #1
 802be80:	4413      	add	r3, r2
 802be82:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802be86:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802be8a:	fb03 f303 	mul.w	r3, r3, r3
 802be8e:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802be92:	4413      	add	r3, r2
 802be94:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc1) * C1_SCALE;
 802be98:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802be9c:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802bea0:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bea4:	681b      	ldr	r3, [r3, #0]
 802bea6:	1ad2      	subs	r2, r2, r3
 802bea8:	4613      	mov	r3, r2
 802beaa:	005b      	lsls	r3, r3, #1
 802beac:	4413      	add	r3, r2
 802beae:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802beb2:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802beb6:	fb03 f303 	mul.w	r3, r3, r3
 802beba:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802bebe:	4413      	add	r3, r2
 802bec0:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bec4:	e02f      	b.n	802bf26 <find_nearby_colors+0x314>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
 802bec6:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802beca:	f8d7 3420 	ldr.w	r3, [r7, #1056]	@ 0x420
 802bece:	429a      	cmp	r2, r3
 802bed0:	dc13      	bgt.n	802befa <find_nearby_colors+0x2e8>
	tdist = (x - maxc1) * C1_SCALE;
 802bed2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bed6:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802beda:	1ad2      	subs	r2, r2, r3
 802bedc:	4613      	mov	r3, r2
 802bede:	005b      	lsls	r3, r3, #1
 802bee0:	4413      	add	r3, r2
 802bee2:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802bee6:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802beea:	fb03 f303 	mul.w	r3, r3, r3
 802beee:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802bef2:	4413      	add	r3, r2
 802bef4:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bef8:	e015      	b.n	802bf26 <find_nearby_colors+0x314>
      } else {
	tdist = (x - minc1) * C1_SCALE;
 802befa:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802befe:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802bf02:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bf06:	681b      	ldr	r3, [r3, #0]
 802bf08:	1ad2      	subs	r2, r2, r3
 802bf0a:	4613      	mov	r3, r2
 802bf0c:	005b      	lsls	r3, r3, #1
 802bf0e:	4413      	add	r3, r2
 802bf10:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802bf14:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bf18:	fb03 f303 	mul.w	r3, r3, r3
 802bf1c:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802bf20:	4413      	add	r3, r2
 802bf22:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
 802bf26:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bf2a:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802bf2e:	681b      	ldr	r3, [r3, #0]
 802bf30:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802bf34:	3308      	adds	r3, #8
 802bf36:	681a      	ldr	r2, [r3, #0]
 802bf38:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802bf3c:	4413      	add	r3, r2
 802bf3e:	781b      	ldrb	r3, [r3, #0]
 802bf40:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc2) {
 802bf44:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bf48:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802bf4c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bf50:	681b      	ldr	r3, [r3, #0]
 802bf52:	429a      	cmp	r2, r3
 802bf54:	da23      	bge.n	802bf9e <find_nearby_colors+0x38c>
      tdist = (x - minc2) * C2_SCALE;
 802bf56:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bf5a:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802bf5e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bf62:	681b      	ldr	r3, [r3, #0]
 802bf64:	1ad3      	subs	r3, r2, r3
 802bf66:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802bf6a:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bf6e:	fb03 f303 	mul.w	r3, r3, r3
 802bf72:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802bf76:	4413      	add	r3, r2
 802bf78:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc2) * C2_SCALE;
 802bf7c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bf80:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802bf84:	1ad3      	subs	r3, r2, r3
 802bf86:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802bf8a:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bf8e:	fb03 f303 	mul.w	r3, r3, r3
 802bf92:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802bf96:	4413      	add	r3, r2
 802bf98:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bf9c:	e053      	b.n	802c046 <find_nearby_colors+0x434>
    } else if (x > maxc2) {
 802bf9e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bfa2:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802bfa6:	429a      	cmp	r2, r3
 802bfa8:	dd23      	ble.n	802bff2 <find_nearby_colors+0x3e0>
      tdist = (x - maxc2) * C2_SCALE;
 802bfaa:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bfae:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802bfb2:	1ad3      	subs	r3, r2, r3
 802bfb4:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802bfb8:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bfbc:	fb03 f303 	mul.w	r3, r3, r3
 802bfc0:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802bfc4:	4413      	add	r3, r2
 802bfc6:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc2) * C2_SCALE;
 802bfca:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802bfce:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802bfd2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bfd6:	681b      	ldr	r3, [r3, #0]
 802bfd8:	1ad3      	subs	r3, r2, r3
 802bfda:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802bfde:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802bfe2:	fb03 f303 	mul.w	r3, r3, r3
 802bfe6:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802bfea:	4413      	add	r3, r2
 802bfec:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802bff0:	e029      	b.n	802c046 <find_nearby_colors+0x434>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
 802bff2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802bff6:	f8d7 3418 	ldr.w	r3, [r7, #1048]	@ 0x418
 802bffa:	429a      	cmp	r2, r3
 802bffc:	dc10      	bgt.n	802c020 <find_nearby_colors+0x40e>
	tdist = (x - maxc2) * C2_SCALE;
 802bffe:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802c002:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802c006:	1ad3      	subs	r3, r2, r3
 802c008:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802c00c:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802c010:	fb03 f303 	mul.w	r3, r3, r3
 802c014:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802c018:	4413      	add	r3, r2
 802c01a:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802c01e:	e012      	b.n	802c046 <find_nearby_colors+0x434>
      } else {
	tdist = (x - minc2) * C2_SCALE;
 802c020:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802c024:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802c028:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802c02c:	681b      	ldr	r3, [r3, #0]
 802c02e:	1ad3      	subs	r3, r2, r3
 802c030:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802c034:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802c038:	fb03 f303 	mul.w	r3, r3, r3
 802c03c:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802c040:	4413      	add	r3, r2
 802c042:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    mindist[i] = min_dist;	/* save away the results */
 802c046:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802c04a:	f5a3 6387 	sub.w	r3, r3, #1080	@ 0x438
 802c04e:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802c052:	f8d7 1438 	ldr.w	r1, [r7, #1080]	@ 0x438
 802c056:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    if (max_dist < minmaxdist)
 802c05a:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802c05e:	f8d7 343c 	ldr.w	r3, [r7, #1084]	@ 0x43c
 802c062:	429a      	cmp	r2, r3
 802c064:	da03      	bge.n	802c06e <find_nearby_colors+0x45c>
      minmaxdist = max_dist;
 802c066:	f8d7 3434 	ldr.w	r3, [r7, #1076]	@ 0x434
 802c06a:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c
  for (i = 0; i < numcolors; i++) {
 802c06e:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802c072:	3301      	adds	r3, #1
 802c074:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802c078:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802c07c:	f8d7 3430 	ldr.w	r3, [r7, #1072]	@ 0x430
 802c080:	429a      	cmp	r2, r3
 802c082:	f6ff ae28 	blt.w	802bcd6 <find_nearby_colors+0xc4>

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
 802c086:	2300      	movs	r3, #0
 802c088:	f8c7 3440 	str.w	r3, [r7, #1088]	@ 0x440
  for (i = 0; i < numcolors; i++) {
 802c08c:	2300      	movs	r3, #0
 802c08e:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802c092:	e01d      	b.n	802c0d0 <find_nearby_colors+0x4be>
    if (mindist[i] <= minmaxdist)
 802c094:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802c098:	f5a3 6387 	sub.w	r3, r3, #1080	@ 0x438
 802c09c:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802c0a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802c0a4:	f8d7 243c 	ldr.w	r2, [r7, #1084]	@ 0x43c
 802c0a8:	429a      	cmp	r2, r3
 802c0aa:	db0c      	blt.n	802c0c6 <find_nearby_colors+0x4b4>
      colorlist[ncolors++] = (JSAMPLE) i;
 802c0ac:	f8d7 3440 	ldr.w	r3, [r7, #1088]	@ 0x440
 802c0b0:	1c5a      	adds	r2, r3, #1
 802c0b2:	f8c7 2440 	str.w	r2, [r7, #1088]	@ 0x440
 802c0b6:	461a      	mov	r2, r3
 802c0b8:	f8d7 3450 	ldr.w	r3, [r7, #1104]	@ 0x450
 802c0bc:	4413      	add	r3, r2
 802c0be:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802c0c2:	b2d2      	uxtb	r2, r2
 802c0c4:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numcolors; i++) {
 802c0c6:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802c0ca:	3301      	adds	r3, #1
 802c0cc:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802c0d0:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802c0d4:	f8d7 3430 	ldr.w	r3, [r7, #1072]	@ 0x430
 802c0d8:	429a      	cmp	r2, r3
 802c0da:	dbdb      	blt.n	802c094 <find_nearby_colors+0x482>
  }
  return ncolors;
 802c0dc:	f8d7 3440 	ldr.w	r3, [r7, #1088]	@ 0x440
}
 802c0e0:	4618      	mov	r0, r3
 802c0e2:	f507 6789 	add.w	r7, r7, #1096	@ 0x448
 802c0e6:	46bd      	mov	sp, r7
 802c0e8:	bc90      	pop	{r4, r7}
 802c0ea:	4770      	bx	lr

0802c0ec <find_best_colors>:
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
 802c0ec:	b4f0      	push	{r4, r5, r6, r7}
 802c0ee:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 802c0f2:	af00      	add	r7, sp, #0
 802c0f4:	f507 7412 	add.w	r4, r7, #584	@ 0x248
 802c0f8:	f5a4 740f 	sub.w	r4, r4, #572	@ 0x23c
 802c0fc:	6020      	str	r0, [r4, #0]
 802c0fe:	f507 7012 	add.w	r0, r7, #584	@ 0x248
 802c102:	f5a0 7010 	sub.w	r0, r0, #576	@ 0x240
 802c106:	6001      	str	r1, [r0, #0]
 802c108:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 802c10c:	f5a1 7111 	sub.w	r1, r1, #580	@ 0x244
 802c110:	600a      	str	r2, [r1, #0]
 802c112:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 802c116:	f5a2 7212 	sub.w	r2, r2, #584	@ 0x248
 802c11a:	6013      	str	r3, [r2, #0]
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
 802c11c:	f107 0414 	add.w	r4, r7, #20
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 802c120:	237f      	movs	r3, #127	@ 0x7f
 802c122:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802c126:	e009      	b.n	802c13c <find_best_colors+0x50>
    *bptr++ = 0x7FFFFFFFL;
 802c128:	4623      	mov	r3, r4
 802c12a:	1d1c      	adds	r4, r3, #4
 802c12c:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 802c130:	601a      	str	r2, [r3, #0]
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 802c132:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802c136:	3b01      	subs	r3, #1
 802c138:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802c13c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802c140:	2b00      	cmp	r3, #0
 802c142:	daf1      	bge.n	802c128 <find_best_colors+0x3c>
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
 802c144:	2300      	movs	r3, #0
 802c146:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802c14a:	e0e7      	b.n	802c31c <find_best_colors+0x230>
    icolor = GETJSAMPLE(colorlist[i]);
 802c14c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802c150:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 802c154:	4413      	add	r3, r2
 802c156:	781b      	ldrb	r3, [r3, #0]
 802c158:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
 802c15c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c160:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802c164:	681b      	ldr	r3, [r3, #0]
 802c166:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c16a:	681a      	ldr	r2, [r3, #0]
 802c16c:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802c170:	4413      	add	r3, r2
 802c172:	781b      	ldrb	r3, [r3, #0]
 802c174:	461a      	mov	r2, r3
 802c176:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c17a:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 802c17e:	681b      	ldr	r3, [r3, #0]
 802c180:	1a9b      	subs	r3, r3, r2
 802c182:	005b      	lsls	r3, r3, #1
 802c184:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    dist0 = inc0*inc0;
 802c188:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802c18c:	fb03 f303 	mul.w	r3, r3, r3
 802c190:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
 802c194:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c198:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802c19c:	681b      	ldr	r3, [r3, #0]
 802c19e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c1a2:	3304      	adds	r3, #4
 802c1a4:	681a      	ldr	r2, [r3, #0]
 802c1a6:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802c1aa:	4413      	add	r3, r2
 802c1ac:	781b      	ldrb	r3, [r3, #0]
 802c1ae:	461a      	mov	r2, r3
 802c1b0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c1b4:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 802c1b8:	681b      	ldr	r3, [r3, #0]
 802c1ba:	1a9a      	subs	r2, r3, r2
 802c1bc:	4613      	mov	r3, r2
 802c1be:	005b      	lsls	r3, r3, #1
 802c1c0:	4413      	add	r3, r2
 802c1c2:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    dist0 += inc1*inc1;
 802c1c6:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 802c1ca:	fb03 f303 	mul.w	r3, r3, r3
 802c1ce:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802c1d2:	4413      	add	r3, r2
 802c1d4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
 802c1d8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c1dc:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802c1e0:	681b      	ldr	r3, [r3, #0]
 802c1e2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c1e6:	3308      	adds	r3, #8
 802c1e8:	681a      	ldr	r2, [r3, #0]
 802c1ea:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802c1ee:	4413      	add	r3, r2
 802c1f0:	781b      	ldrb	r3, [r3, #0]
 802c1f2:	461a      	mov	r2, r3
 802c1f4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802c1f8:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 802c1fc:	681b      	ldr	r3, [r3, #0]
 802c1fe:	1a9b      	subs	r3, r3, r2
 802c200:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    dist0 += inc2*inc2;
 802c204:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802c208:	fb03 f303 	mul.w	r3, r3, r3
 802c20c:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802c210:	4413      	add	r3, r2
 802c212:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
 802c216:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802c21a:	3308      	adds	r3, #8
 802c21c:	015b      	lsls	r3, r3, #5
 802c21e:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
 802c222:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 802c226:	4613      	mov	r3, r2
 802c228:	005b      	lsls	r3, r3, #1
 802c22a:	4413      	add	r3, r2
 802c22c:	00db      	lsls	r3, r3, #3
 802c22e:	3390      	adds	r3, #144	@ 0x90
 802c230:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
 802c234:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802c238:	3304      	adds	r3, #4
 802c23a:	011b      	lsls	r3, r3, #4
 802c23c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
 802c240:	f107 0414 	add.w	r4, r7, #20
    cptr = bestcolor;
 802c244:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802c248:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    xx0 = inc0;
 802c24c:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802c250:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 802c254:	2303      	movs	r3, #3
 802c256:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
 802c25a:	e056      	b.n	802c30a <find_best_colors+0x21e>
      dist1 = dist0;
 802c25c:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802c260:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
      xx1 = inc1;
 802c264:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 802c268:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 802c26c:	2307      	movs	r3, #7
 802c26e:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
 802c272:	e034      	b.n	802c2de <find_best_colors+0x1f2>
	dist2 = dist1;
 802c274:	f8d7 522c 	ldr.w	r5, [r7, #556]	@ 0x22c
	xx2 = inc2;
 802c278:	f8d7 6214 	ldr.w	r6, [r7, #532]	@ 0x214
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 802c27c:	2303      	movs	r3, #3
 802c27e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
 802c282:	e016      	b.n	802c2b2 <find_best_colors+0x1c6>
	  if (dist2 < *bptr) {
 802c284:	6823      	ldr	r3, [r4, #0]
 802c286:	429d      	cmp	r5, r3
 802c288:	da06      	bge.n	802c298 <find_best_colors+0x1ac>
	    *bptr = dist2;
 802c28a:	6025      	str	r5, [r4, #0]
	    *cptr = (JSAMPLE) icolor;
 802c28c:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802c290:	b2da      	uxtb	r2, r3
 802c292:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802c296:	701a      	strb	r2, [r3, #0]
	  }
	  dist2 += xx2;
 802c298:	4435      	add	r5, r6
	  xx2 += 2 * STEP_C2 * STEP_C2;
 802c29a:	3680      	adds	r6, #128	@ 0x80
	  bptr++;
 802c29c:	3404      	adds	r4, #4
	  cptr++;
 802c29e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802c2a2:	3301      	adds	r3, #1
 802c2a4:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 802c2a8:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802c2ac:	3b01      	subs	r3, #1
 802c2ae:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
 802c2b2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802c2b6:	2b00      	cmp	r3, #0
 802c2b8:	dae4      	bge.n	802c284 <find_best_colors+0x198>
	}
	dist1 += xx1;
 802c2ba:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 802c2be:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802c2c2:	4413      	add	r3, r2
 802c2c4:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
	xx1 += 2 * STEP_C1 * STEP_C1;
 802c2c8:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802c2cc:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 802c2d0:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 802c2d4:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802c2d8:	3b01      	subs	r3, #1
 802c2da:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
 802c2de:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802c2e2:	2b00      	cmp	r3, #0
 802c2e4:	dac6      	bge.n	802c274 <find_best_colors+0x188>
      }
      dist0 += xx0;
 802c2e6:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802c2ea:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802c2ee:	4413      	add	r3, r2
 802c2f0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
      xx0 += 2 * STEP_C0 * STEP_C0;
 802c2f4:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802c2f8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 802c2fc:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 802c300:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802c304:	3b01      	subs	r3, #1
 802c306:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
 802c30a:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802c30e:	2b00      	cmp	r3, #0
 802c310:	daa4      	bge.n	802c25c <find_best_colors+0x170>
  for (i = 0; i < numcolors; i++) {
 802c312:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802c316:	3301      	adds	r3, #1
 802c318:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802c31c:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802c320:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802c324:	429a      	cmp	r2, r3
 802c326:	f6ff af11 	blt.w	802c14c <find_best_colors+0x60>
    }
  }
}
 802c32a:	bf00      	nop
 802c32c:	bf00      	nop
 802c32e:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 802c332:	46bd      	mov	sp, r7
 802c334:	bcf0      	pop	{r4, r5, r6, r7}
 802c336:	4770      	bx	lr

0802c338 <fill_inverse_cmap>:
LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
 802c338:	b5b0      	push	{r4, r5, r7, lr}
 802c33a:	b0f2      	sub	sp, #456	@ 0x1c8
 802c33c:	af04      	add	r7, sp, #16
 802c33e:	f507 74dc 	add.w	r4, r7, #440	@ 0x1b8
 802c342:	f5a4 74d6 	sub.w	r4, r4, #428	@ 0x1ac
 802c346:	6020      	str	r0, [r4, #0]
 802c348:	f507 70dc 	add.w	r0, r7, #440	@ 0x1b8
 802c34c:	f5a0 70d8 	sub.w	r0, r0, #432	@ 0x1b0
 802c350:	6001      	str	r1, [r0, #0]
 802c352:	f507 71dc 	add.w	r1, r7, #440	@ 0x1b8
 802c356:	f5a1 71da 	sub.w	r1, r1, #436	@ 0x1b4
 802c35a:	600a      	str	r2, [r1, #0]
 802c35c:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c360:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802c364:	6013      	str	r3, [r2, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c366:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c36a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
 802c36e:	681b      	ldr	r3, [r3, #0]
 802c370:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c374:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
  hist3d histogram = cquantize->histogram;
 802c378:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802c37c:	699b      	ldr	r3, [r3, #24]
 802c37e:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
 802c382:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c386:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802c38a:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c38e:	f5a2 72d8 	sub.w	r2, r2, #432	@ 0x1b0
 802c392:	6812      	ldr	r2, [r2, #0]
 802c394:	1092      	asrs	r2, r2, #2
 802c396:	601a      	str	r2, [r3, #0]
  c1 >>= BOX_C1_LOG;
 802c398:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c39c:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802c3a0:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c3a4:	f5a2 72da 	sub.w	r2, r2, #436	@ 0x1b4
 802c3a8:	6812      	ldr	r2, [r2, #0]
 802c3aa:	10d2      	asrs	r2, r2, #3
 802c3ac:	601a      	str	r2, [r3, #0]
  c2 >>= BOX_C2_LOG;
 802c3ae:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c3b2:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802c3b6:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c3ba:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802c3be:	6812      	ldr	r2, [r2, #0]
 802c3c0:	1092      	asrs	r2, r2, #2
 802c3c2:	601a      	str	r2, [r3, #0]

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
 802c3c4:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c3c8:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802c3cc:	681b      	ldr	r3, [r3, #0]
 802c3ce:	015b      	lsls	r3, r3, #5
 802c3d0:	3304      	adds	r3, #4
 802c3d2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
 802c3d6:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c3da:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802c3de:	681b      	ldr	r3, [r3, #0]
 802c3e0:	015b      	lsls	r3, r3, #5
 802c3e2:	3302      	adds	r3, #2
 802c3e4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
 802c3e8:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c3ec:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802c3f0:	681b      	ldr	r3, [r3, #0]
 802c3f2:	015b      	lsls	r3, r3, #5
 802c3f4:	3304      	adds	r3, #4
 802c3f6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
 802c3fa:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c3fe:	f5a3 70d6 	sub.w	r0, r3, #428	@ 0x1ac
 802c402:	f107 0394 	add.w	r3, r7, #148	@ 0x94
 802c406:	9300      	str	r3, [sp, #0]
 802c408:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802c40c:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 802c410:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 802c414:	6800      	ldr	r0, [r0, #0]
 802c416:	f7ff fbfc 	bl	802bc12 <find_nearby_colors>
 802c41a:	f8c7 0194 	str.w	r0, [r7, #404]	@ 0x194

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
 802c41e:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c422:	f5a3 70d6 	sub.w	r0, r3, #428	@ 0x1ac
 802c426:	f107 0314 	add.w	r3, r7, #20
 802c42a:	9302      	str	r3, [sp, #8]
 802c42c:	f107 0394 	add.w	r3, r7, #148	@ 0x94
 802c430:	9301      	str	r3, [sp, #4]
 802c432:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802c436:	9300      	str	r3, [sp, #0]
 802c438:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802c43c:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 802c440:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 802c444:	6800      	ldr	r0, [r0, #0]
 802c446:	f7ff fe51 	bl	802c0ec <find_best_colors>
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
 802c44a:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c44e:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802c452:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c456:	f5a2 72d8 	sub.w	r2, r2, #432	@ 0x1b0
 802c45a:	6812      	ldr	r2, [r2, #0]
 802c45c:	0092      	lsls	r2, r2, #2
 802c45e:	601a      	str	r2, [r3, #0]
  c1 <<= BOX_C1_LOG;
 802c460:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c464:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802c468:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c46c:	f5a2 72da 	sub.w	r2, r2, #436	@ 0x1b4
 802c470:	6812      	ldr	r2, [r2, #0]
 802c472:	00d2      	lsls	r2, r2, #3
 802c474:	601a      	str	r2, [r3, #0]
  c2 <<= BOX_C2_LOG;
 802c476:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c47a:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802c47e:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802c482:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802c486:	6812      	ldr	r2, [r2, #0]
 802c488:	0092      	lsls	r2, r2, #2
 802c48a:	601a      	str	r2, [r3, #0]
  cptr = bestcolor;
 802c48c:	f107 0414 	add.w	r4, r7, #20
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 802c490:	2300      	movs	r3, #0
 802c492:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 802c496:	e045      	b.n	802c524 <fill_inverse_cmap+0x1ec>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802c498:	2300      	movs	r3, #0
 802c49a:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
 802c49e:	e038      	b.n	802c512 <fill_inverse_cmap+0x1da>
      cachep = & histogram[c0+ic0][c1+ic1][c2];
 802c4a0:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c4a4:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802c4a8:	681a      	ldr	r2, [r3, #0]
 802c4aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802c4ae:	4413      	add	r3, r2
 802c4b0:	009b      	lsls	r3, r3, #2
 802c4b2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802c4b6:	4413      	add	r3, r2
 802c4b8:	681a      	ldr	r2, [r3, #0]
 802c4ba:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c4be:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802c4c2:	6819      	ldr	r1, [r3, #0]
 802c4c4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802c4c8:	440b      	add	r3, r1
 802c4ca:	019b      	lsls	r3, r3, #6
 802c4cc:	441a      	add	r2, r3
 802c4ce:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802c4d2:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802c4d6:	681b      	ldr	r3, [r3, #0]
 802c4d8:	005b      	lsls	r3, r3, #1
 802c4da:	18d5      	adds	r5, r2, r3
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 802c4dc:	2300      	movs	r3, #0
 802c4de:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
 802c4e2:	e00d      	b.n	802c500 <fill_inverse_cmap+0x1c8>
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
 802c4e4:	4623      	mov	r3, r4
 802c4e6:	1c5c      	adds	r4, r3, #1
 802c4e8:	781b      	ldrb	r3, [r3, #0]
 802c4ea:	461a      	mov	r2, r3
 802c4ec:	462b      	mov	r3, r5
 802c4ee:	1c9d      	adds	r5, r3, #2
 802c4f0:	3201      	adds	r2, #1
 802c4f2:	b292      	uxth	r2, r2
 802c4f4:	801a      	strh	r2, [r3, #0]
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 802c4f6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802c4fa:	3301      	adds	r3, #1
 802c4fc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
 802c500:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802c504:	2b03      	cmp	r3, #3
 802c506:	dded      	ble.n	802c4e4 <fill_inverse_cmap+0x1ac>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802c508:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802c50c:	3301      	adds	r3, #1
 802c50e:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
 802c512:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802c516:	2b07      	cmp	r3, #7
 802c518:	ddc2      	ble.n	802c4a0 <fill_inverse_cmap+0x168>
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 802c51a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802c51e:	3301      	adds	r3, #1
 802c520:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 802c524:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802c528:	2b03      	cmp	r3, #3
 802c52a:	ddb5      	ble.n	802c498 <fill_inverse_cmap+0x160>
      }
    }
  }
}
 802c52c:	bf00      	nop
 802c52e:	bf00      	nop
 802c530:	f507 77dc 	add.w	r7, r7, #440	@ 0x1b8
 802c534:	46bd      	mov	sp, r7
 802c536:	bdb0      	pop	{r4, r5, r7, pc}

0802c538 <pass2_no_dither>:

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
 802c538:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802c53c:	b08a      	sub	sp, #40	@ 0x28
 802c53e:	af00      	add	r7, sp, #0
 802c540:	60f8      	str	r0, [r7, #12]
 802c542:	60b9      	str	r1, [r7, #8]
 802c544:	607a      	str	r2, [r7, #4]
 802c546:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c548:	68fb      	ldr	r3, [r7, #12]
 802c54a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c54e:	61fb      	str	r3, [r7, #28]
  hist3d histogram = cquantize->histogram;
 802c550:	69fb      	ldr	r3, [r7, #28]
 802c552:	699b      	ldr	r3, [r3, #24]
 802c554:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802c556:	68fb      	ldr	r3, [r7, #12]
 802c558:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802c55a:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 802c55c:	2300      	movs	r3, #0
 802c55e:	627b      	str	r3, [r7, #36]	@ 0x24
 802c560:	e042      	b.n	802c5e8 <pass2_no_dither+0xb0>
    inptr = input_buf[row];
 802c562:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c564:	009b      	lsls	r3, r3, #2
 802c566:	68ba      	ldr	r2, [r7, #8]
 802c568:	4413      	add	r3, r2
 802c56a:	681c      	ldr	r4, [r3, #0]
    outptr = output_buf[row];
 802c56c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c56e:	009b      	lsls	r3, r3, #2
 802c570:	687a      	ldr	r2, [r7, #4]
 802c572:	4413      	add	r3, r2
 802c574:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 802c576:	697b      	ldr	r3, [r7, #20]
 802c578:	623b      	str	r3, [r7, #32]
 802c57a:	e02f      	b.n	802c5dc <pass2_no_dither+0xa4>
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
 802c57c:	4623      	mov	r3, r4
 802c57e:	1c5c      	adds	r4, r3, #1
 802c580:	781b      	ldrb	r3, [r3, #0]
 802c582:	08db      	lsrs	r3, r3, #3
 802c584:	b2db      	uxtb	r3, r3
 802c586:	4699      	mov	r9, r3
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
 802c588:	4623      	mov	r3, r4
 802c58a:	1c5c      	adds	r4, r3, #1
 802c58c:	781b      	ldrb	r3, [r3, #0]
 802c58e:	089b      	lsrs	r3, r3, #2
 802c590:	b2db      	uxtb	r3, r3
 802c592:	469a      	mov	sl, r3
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
 802c594:	4623      	mov	r3, r4
 802c596:	1c5c      	adds	r4, r3, #1
 802c598:	781b      	ldrb	r3, [r3, #0]
 802c59a:	08db      	lsrs	r3, r3, #3
 802c59c:	b2db      	uxtb	r3, r3
 802c59e:	4698      	mov	r8, r3
      cachep = & histogram[c0][c1][c2];
 802c5a0:	464b      	mov	r3, r9
 802c5a2:	009b      	lsls	r3, r3, #2
 802c5a4:	69ba      	ldr	r2, [r7, #24]
 802c5a6:	4413      	add	r3, r2
 802c5a8:	681a      	ldr	r2, [r3, #0]
 802c5aa:	4653      	mov	r3, sl
 802c5ac:	019b      	lsls	r3, r3, #6
 802c5ae:	441a      	add	r2, r3
 802c5b0:	ea4f 0348 	mov.w	r3, r8, lsl #1
 802c5b4:	18d5      	adds	r5, r2, r3
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
 802c5b6:	882b      	ldrh	r3, [r5, #0]
 802c5b8:	2b00      	cmp	r3, #0
 802c5ba:	d105      	bne.n	802c5c8 <pass2_no_dither+0x90>
	fill_inverse_cmap(cinfo, c0,c1,c2);
 802c5bc:	4643      	mov	r3, r8
 802c5be:	4652      	mov	r2, sl
 802c5c0:	4649      	mov	r1, r9
 802c5c2:	68f8      	ldr	r0, [r7, #12]
 802c5c4:	f7ff feb8 	bl	802c338 <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
 802c5c8:	882b      	ldrh	r3, [r5, #0]
 802c5ca:	b2da      	uxtb	r2, r3
 802c5cc:	4633      	mov	r3, r6
 802c5ce:	1c5e      	adds	r6, r3, #1
 802c5d0:	3a01      	subs	r2, #1
 802c5d2:	b2d2      	uxtb	r2, r2
 802c5d4:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802c5d6:	6a3b      	ldr	r3, [r7, #32]
 802c5d8:	3b01      	subs	r3, #1
 802c5da:	623b      	str	r3, [r7, #32]
 802c5dc:	6a3b      	ldr	r3, [r7, #32]
 802c5de:	2b00      	cmp	r3, #0
 802c5e0:	d1cc      	bne.n	802c57c <pass2_no_dither+0x44>
  for (row = 0; row < num_rows; row++) {
 802c5e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c5e4:	3301      	adds	r3, #1
 802c5e6:	627b      	str	r3, [r7, #36]	@ 0x24
 802c5e8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802c5ea:	683b      	ldr	r3, [r7, #0]
 802c5ec:	429a      	cmp	r2, r3
 802c5ee:	dbb8      	blt.n	802c562 <pass2_no_dither+0x2a>
    }
  }
}
 802c5f0:	bf00      	nop
 802c5f2:	bf00      	nop
 802c5f4:	3728      	adds	r7, #40	@ 0x28
 802c5f6:	46bd      	mov	sp, r7
 802c5f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802c5fc <pass2_fs_dither>:

METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
 802c5fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802c600:	b09c      	sub	sp, #112	@ 0x70
 802c602:	af00      	add	r7, sp, #0
 802c604:	6178      	str	r0, [r7, #20]
 802c606:	6139      	str	r1, [r7, #16]
 802c608:	60fa      	str	r2, [r7, #12]
 802c60a:	60bb      	str	r3, [r7, #8]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c60c:	697b      	ldr	r3, [r7, #20]
 802c60e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c612:	63fb      	str	r3, [r7, #60]	@ 0x3c
  hist3d histogram = cquantize->histogram;
 802c614:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c616:	699b      	ldr	r3, [r3, #24]
 802c618:	63bb      	str	r3, [r7, #56]	@ 0x38
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802c61a:	697b      	ldr	r3, [r7, #20]
 802c61c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802c61e:	637b      	str	r3, [r7, #52]	@ 0x34
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 802c620:	697b      	ldr	r3, [r7, #20]
 802c622:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802c626:	633b      	str	r3, [r7, #48]	@ 0x30
  int *error_limit = cquantize->error_limiter;
 802c628:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c62a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802c62c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  JSAMPROW colormap0 = cinfo->colormap[0];
 802c62e:	697b      	ldr	r3, [r7, #20]
 802c630:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c634:	681b      	ldr	r3, [r3, #0]
 802c636:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPROW colormap1 = cinfo->colormap[1];
 802c638:	697b      	ldr	r3, [r7, #20]
 802c63a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c63e:	685b      	ldr	r3, [r3, #4]
 802c640:	627b      	str	r3, [r7, #36]	@ 0x24
  JSAMPROW colormap2 = cinfo->colormap[2];
 802c642:	697b      	ldr	r3, [r7, #20]
 802c644:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802c648:	689b      	ldr	r3, [r3, #8]
 802c64a:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 802c64c:	2300      	movs	r3, #0
 802c64e:	647b      	str	r3, [r7, #68]	@ 0x44
 802c650:	e115      	b.n	802c87e <pass2_fs_dither+0x282>
    inptr = input_buf[row];
 802c652:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802c654:	009b      	lsls	r3, r3, #2
 802c656:	693a      	ldr	r2, [r7, #16]
 802c658:	4413      	add	r3, r2
 802c65a:	681b      	ldr	r3, [r3, #0]
 802c65c:	657b      	str	r3, [r7, #84]	@ 0x54
    outptr = output_buf[row];
 802c65e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802c660:	009b      	lsls	r3, r3, #2
 802c662:	68fa      	ldr	r2, [r7, #12]
 802c664:	4413      	add	r3, r2
 802c666:	681b      	ldr	r3, [r3, #0]
 802c668:	653b      	str	r3, [r7, #80]	@ 0x50
    if (cquantize->on_odd_row) {
 802c66a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c66c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802c66e:	2b00      	cmp	r3, #0
 802c670:	d020      	beq.n	802c6b4 <pass2_fs_dither+0xb8>
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
 802c672:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802c674:	4613      	mov	r3, r2
 802c676:	005b      	lsls	r3, r3, #1
 802c678:	4413      	add	r3, r2
 802c67a:	3b03      	subs	r3, #3
 802c67c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802c67e:	4413      	add	r3, r2
 802c680:	657b      	str	r3, [r7, #84]	@ 0x54
      outptr += width-1;
 802c682:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802c684:	3b01      	subs	r3, #1
 802c686:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802c688:	4413      	add	r3, r2
 802c68a:	653b      	str	r3, [r7, #80]	@ 0x50
      dir = -1;
 802c68c:	f04f 33ff 	mov.w	r3, #4294967295
 802c690:	64fb      	str	r3, [r7, #76]	@ 0x4c
      dir3 = -3;
 802c692:	f06f 0302 	mvn.w	r3, #2
 802c696:	64bb      	str	r3, [r7, #72]	@ 0x48
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
 802c698:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c69a:	6a19      	ldr	r1, [r3, #32]
 802c69c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802c69e:	1c5a      	adds	r2, r3, #1
 802c6a0:	4613      	mov	r3, r2
 802c6a2:	005b      	lsls	r3, r3, #1
 802c6a4:	4413      	add	r3, r2
 802c6a6:	005b      	lsls	r3, r3, #1
 802c6a8:	18cb      	adds	r3, r1, r3
 802c6aa:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = FALSE; /* flip for next time */
 802c6ac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c6ae:	2200      	movs	r2, #0
 802c6b0:	625a      	str	r2, [r3, #36]	@ 0x24
 802c6b2:	e009      	b.n	802c6c8 <pass2_fs_dither+0xcc>
    } else {
      /* work left to right in this row */
      dir = 1;
 802c6b4:	2301      	movs	r3, #1
 802c6b6:	64fb      	str	r3, [r7, #76]	@ 0x4c
      dir3 = 3;
 802c6b8:	2303      	movs	r3, #3
 802c6ba:	64bb      	str	r3, [r7, #72]	@ 0x48
      errorptr = cquantize->fserrors; /* => entry before first real column */
 802c6bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c6be:	6a1b      	ldr	r3, [r3, #32]
 802c6c0:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = TRUE; /* flip for next time */
 802c6c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802c6c4:	2201      	movs	r2, #1
 802c6c6:	625a      	str	r2, [r3, #36]	@ 0x24
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
 802c6c8:	2400      	movs	r4, #0
 802c6ca:	4625      	mov	r5, r4
 802c6cc:	462e      	mov	r6, r5
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
 802c6ce:	2300      	movs	r3, #0
 802c6d0:	667b      	str	r3, [r7, #100]	@ 0x64
 802c6d2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802c6d4:	66bb      	str	r3, [r7, #104]	@ 0x68
 802c6d6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802c6d8:	66fb      	str	r3, [r7, #108]	@ 0x6c
    bpreverr0 = bpreverr1 = bpreverr2 = 0;
 802c6da:	2300      	movs	r3, #0
 802c6dc:	65bb      	str	r3, [r7, #88]	@ 0x58
 802c6de:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802c6e0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802c6e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802c6e4:	663b      	str	r3, [r7, #96]	@ 0x60

    for (col = width; col > 0; col--) {
 802c6e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802c6e8:	643b      	str	r3, [r7, #64]	@ 0x40
 802c6ea:	e0b5      	b.n	802c858 <pass2_fs_dither+0x25c>
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
 802c6ec:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802c6ee:	005b      	lsls	r3, r3, #1
 802c6f0:	687a      	ldr	r2, [r7, #4]
 802c6f2:	4413      	add	r3, r2
 802c6f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 802c6f8:	4433      	add	r3, r6
 802c6fa:	3308      	adds	r3, #8
 802c6fc:	111e      	asrs	r6, r3, #4
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
 802c6fe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802c700:	3301      	adds	r3, #1
 802c702:	005b      	lsls	r3, r3, #1
 802c704:	4413      	add	r3, r2
 802c706:	f9b3 3000 	ldrsh.w	r3, [r3]
 802c70a:	442b      	add	r3, r5
 802c70c:	3308      	adds	r3, #8
 802c70e:	111d      	asrs	r5, r3, #4
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
 802c710:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802c712:	3302      	adds	r3, #2
 802c714:	005b      	lsls	r3, r3, #1
 802c716:	4413      	add	r3, r2
 802c718:	f9b3 3000 	ldrsh.w	r3, [r3]
 802c71c:	4423      	add	r3, r4
 802c71e:	3308      	adds	r3, #8
 802c720:	111c      	asrs	r4, r3, #4
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
 802c722:	4633      	mov	r3, r6
 802c724:	009b      	lsls	r3, r3, #2
 802c726:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802c728:	4413      	add	r3, r2
 802c72a:	681e      	ldr	r6, [r3, #0]
      cur1 = error_limit[cur1];
 802c72c:	462b      	mov	r3, r5
 802c72e:	009b      	lsls	r3, r3, #2
 802c730:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802c732:	4413      	add	r3, r2
 802c734:	681d      	ldr	r5, [r3, #0]
      cur2 = error_limit[cur2];
 802c736:	4623      	mov	r3, r4
 802c738:	009b      	lsls	r3, r3, #2
 802c73a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802c73c:	4413      	add	r3, r2
 802c73e:	681c      	ldr	r4, [r3, #0]
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
 802c740:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802c742:	781b      	ldrb	r3, [r3, #0]
 802c744:	441e      	add	r6, r3
      cur1 += GETJSAMPLE(inptr[1]);
 802c746:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802c748:	3301      	adds	r3, #1
 802c74a:	781b      	ldrb	r3, [r3, #0]
 802c74c:	441d      	add	r5, r3
      cur2 += GETJSAMPLE(inptr[2]);
 802c74e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802c750:	3302      	adds	r3, #2
 802c752:	781b      	ldrb	r3, [r3, #0]
 802c754:	441c      	add	r4, r3
      cur0 = GETJSAMPLE(range_limit[cur0]);
 802c756:	4632      	mov	r2, r6
 802c758:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802c75a:	4413      	add	r3, r2
 802c75c:	781b      	ldrb	r3, [r3, #0]
 802c75e:	461e      	mov	r6, r3
      cur1 = GETJSAMPLE(range_limit[cur1]);
 802c760:	462a      	mov	r2, r5
 802c762:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802c764:	4413      	add	r3, r2
 802c766:	781b      	ldrb	r3, [r3, #0]
 802c768:	461d      	mov	r5, r3
      cur2 = GETJSAMPLE(range_limit[cur2]);
 802c76a:	4622      	mov	r2, r4
 802c76c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802c76e:	4413      	add	r3, r2
 802c770:	781b      	ldrb	r3, [r3, #0]
 802c772:	461c      	mov	r4, r3
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
 802c774:	10f3      	asrs	r3, r6, #3
 802c776:	009b      	lsls	r3, r3, #2
 802c778:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802c77a:	4413      	add	r3, r2
 802c77c:	681a      	ldr	r2, [r3, #0]
 802c77e:	10ab      	asrs	r3, r5, #2
 802c780:	019b      	lsls	r3, r3, #6
 802c782:	441a      	add	r2, r3
 802c784:	10e3      	asrs	r3, r4, #3
 802c786:	005b      	lsls	r3, r3, #1
 802c788:	4413      	add	r3, r2
 802c78a:	61fb      	str	r3, [r7, #28]
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
 802c78c:	69fb      	ldr	r3, [r7, #28]
 802c78e:	881b      	ldrh	r3, [r3, #0]
 802c790:	2b00      	cmp	r3, #0
 802c792:	d105      	bne.n	802c7a0 <pass2_fs_dither+0x1a4>
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
 802c794:	10f1      	asrs	r1, r6, #3
 802c796:	10aa      	asrs	r2, r5, #2
 802c798:	10e3      	asrs	r3, r4, #3
 802c79a:	6978      	ldr	r0, [r7, #20]
 802c79c:	f7ff fdcc 	bl	802c338 <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
 802c7a0:	69fb      	ldr	r3, [r7, #28]
 802c7a2:	881b      	ldrh	r3, [r3, #0]
 802c7a4:	f103 38ff 	add.w	r8, r3, #4294967295
	*outptr = (JSAMPLE) pixcode;
 802c7a8:	fa5f f288 	uxtb.w	r2, r8
 802c7ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802c7ae:	701a      	strb	r2, [r3, #0]
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
 802c7b0:	4642      	mov	r2, r8
 802c7b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c7b4:	4413      	add	r3, r2
 802c7b6:	781b      	ldrb	r3, [r3, #0]
 802c7b8:	1af6      	subs	r6, r6, r3
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
 802c7ba:	4642      	mov	r2, r8
 802c7bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c7be:	4413      	add	r3, r2
 802c7c0:	781b      	ldrb	r3, [r3, #0]
 802c7c2:	1aed      	subs	r5, r5, r3
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
 802c7c4:	4642      	mov	r2, r8
 802c7c6:	6a3b      	ldr	r3, [r7, #32]
 802c7c8:	4413      	add	r3, r2
 802c7ca:	781b      	ldrb	r3, [r3, #0]
 802c7cc:	1ae4      	subs	r4, r4, r3
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
 802c7ce:	4630      	mov	r0, r6
	delta = cur0 * 2;
 802c7d0:	ea4f 0846 	mov.w	r8, r6, lsl #1
	cur0 += delta;		/* form error * 3 */
 802c7d4:	4446      	add	r6, r8
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
 802c7d6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802c7d8:	b29a      	uxth	r2, r3
 802c7da:	b2b3      	uxth	r3, r6
 802c7dc:	4413      	add	r3, r2
 802c7de:	b29b      	uxth	r3, r3
 802c7e0:	b21b      	sxth	r3, r3
 802c7e2:	6879      	ldr	r1, [r7, #4]
 802c7e4:	800b      	strh	r3, [r1, #0]
	cur0 += delta;		/* form error * 5 */
 802c7e6:	4446      	add	r6, r8
	bpreverr0 = belowerr0 + cur0;
 802c7e8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802c7ea:	4433      	add	r3, r6
 802c7ec:	663b      	str	r3, [r7, #96]	@ 0x60
	belowerr0 = bnexterr;
 802c7ee:	66f8      	str	r0, [r7, #108]	@ 0x6c
	cur0 += delta;		/* form error * 7 */
 802c7f0:	4446      	add	r6, r8
	bnexterr = cur1;	/* Process component 1 */
 802c7f2:	4628      	mov	r0, r5
	delta = cur1 * 2;
 802c7f4:	ea4f 0845 	mov.w	r8, r5, lsl #1
	cur1 += delta;		/* form error * 3 */
 802c7f8:	4445      	add	r5, r8
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
 802c7fa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802c7fc:	b29a      	uxth	r2, r3
 802c7fe:	b2ab      	uxth	r3, r5
 802c800:	4413      	add	r3, r2
 802c802:	b29a      	uxth	r2, r3
 802c804:	1c8b      	adds	r3, r1, #2
 802c806:	b212      	sxth	r2, r2
 802c808:	801a      	strh	r2, [r3, #0]
	cur1 += delta;		/* form error * 5 */
 802c80a:	4445      	add	r5, r8
	bpreverr1 = belowerr1 + cur1;
 802c80c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802c80e:	442b      	add	r3, r5
 802c810:	65fb      	str	r3, [r7, #92]	@ 0x5c
	belowerr1 = bnexterr;
 802c812:	66b8      	str	r0, [r7, #104]	@ 0x68
	cur1 += delta;		/* form error * 7 */
 802c814:	4445      	add	r5, r8
	bnexterr = cur2;	/* Process component 2 */
 802c816:	4620      	mov	r0, r4
	delta = cur2 * 2;
 802c818:	ea4f 0844 	mov.w	r8, r4, lsl #1
	cur2 += delta;		/* form error * 3 */
 802c81c:	4444      	add	r4, r8
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
 802c81e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802c820:	b29a      	uxth	r2, r3
 802c822:	b2a3      	uxth	r3, r4
 802c824:	4413      	add	r3, r2
 802c826:	b29a      	uxth	r2, r3
 802c828:	1d0b      	adds	r3, r1, #4
 802c82a:	b212      	sxth	r2, r2
 802c82c:	801a      	strh	r2, [r3, #0]
	cur2 += delta;		/* form error * 5 */
 802c82e:	4444      	add	r4, r8
	bpreverr2 = belowerr2 + cur2;
 802c830:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802c832:	4423      	add	r3, r4
 802c834:	65bb      	str	r3, [r7, #88]	@ 0x58
	belowerr2 = bnexterr;
 802c836:	6678      	str	r0, [r7, #100]	@ 0x64
	cur2 += delta;		/* form error * 7 */
 802c838:	4444      	add	r4, r8
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
 802c83a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802c83c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802c83e:	4413      	add	r3, r2
 802c840:	657b      	str	r3, [r7, #84]	@ 0x54
      outptr += dir;
 802c842:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802c844:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802c846:	4413      	add	r3, r2
 802c848:	653b      	str	r3, [r7, #80]	@ 0x50
      errorptr += dir3;		/* advance errorptr to current column */
 802c84a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802c84c:	005b      	lsls	r3, r3, #1
 802c84e:	18cb      	adds	r3, r1, r3
 802c850:	607b      	str	r3, [r7, #4]
    for (col = width; col > 0; col--) {
 802c852:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802c854:	3b01      	subs	r3, #1
 802c856:	643b      	str	r3, [r7, #64]	@ 0x40
 802c858:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802c85a:	2b00      	cmp	r3, #0
 802c85c:	f47f af46 	bne.w	802c6ec <pass2_fs_dither+0xf0>
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
 802c860:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802c862:	b21b      	sxth	r3, r3
 802c864:	6879      	ldr	r1, [r7, #4]
 802c866:	800b      	strh	r3, [r1, #0]
    errorptr[1] = (FSERROR) bpreverr1;
 802c868:	1c8b      	adds	r3, r1, #2
 802c86a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802c86c:	b212      	sxth	r2, r2
 802c86e:	801a      	strh	r2, [r3, #0]
    errorptr[2] = (FSERROR) bpreverr2;
 802c870:	1d0b      	adds	r3, r1, #4
 802c872:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 802c874:	b212      	sxth	r2, r2
 802c876:	801a      	strh	r2, [r3, #0]
  for (row = 0; row < num_rows; row++) {
 802c878:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802c87a:	3301      	adds	r3, #1
 802c87c:	647b      	str	r3, [r7, #68]	@ 0x44
 802c87e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802c880:	68bb      	ldr	r3, [r7, #8]
 802c882:	429a      	cmp	r2, r3
 802c884:	f6ff aee5 	blt.w	802c652 <pass2_fs_dither+0x56>
  }
}
 802c888:	bf00      	nop
 802c88a:	bf00      	nop
 802c88c:	3770      	adds	r7, #112	@ 0x70
 802c88e:	46bd      	mov	sp, r7
 802c890:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802c894 <init_error_limit>:
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
 802c894:	b580      	push	{r7, lr}
 802c896:	b086      	sub	sp, #24
 802c898:	af00      	add	r7, sp, #0
 802c89a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c89c:	687b      	ldr	r3, [r7, #4]
 802c89e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c8a2:	60fb      	str	r3, [r7, #12]
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
 802c8a4:	687b      	ldr	r3, [r7, #4]
 802c8a6:	685b      	ldr	r3, [r3, #4]
 802c8a8:	681b      	ldr	r3, [r3, #0]
 802c8aa:	f240 72fc 	movw	r2, #2044	@ 0x7fc
 802c8ae:	2101      	movs	r1, #1
 802c8b0:	6878      	ldr	r0, [r7, #4]
 802c8b2:	4798      	blx	r3
 802c8b4:	60b8      	str	r0, [r7, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
 802c8b6:	68bb      	ldr	r3, [r7, #8]
 802c8b8:	f503 737f 	add.w	r3, r3, #1020	@ 0x3fc
 802c8bc:	60bb      	str	r3, [r7, #8]
  cquantize->error_limiter = table;
 802c8be:	68fb      	ldr	r3, [r7, #12]
 802c8c0:	68ba      	ldr	r2, [r7, #8]
 802c8c2:	629a      	str	r2, [r3, #40]	@ 0x28

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
 802c8c4:	2300      	movs	r3, #0
 802c8c6:	613b      	str	r3, [r7, #16]
  for (in = 0; in < STEPSIZE; in++, out++) {
 802c8c8:	2300      	movs	r3, #0
 802c8ca:	617b      	str	r3, [r7, #20]
 802c8cc:	e016      	b.n	802c8fc <init_error_limit+0x68>
    table[in] = out; table[-in] = -out;
 802c8ce:	697b      	ldr	r3, [r7, #20]
 802c8d0:	009b      	lsls	r3, r3, #2
 802c8d2:	68ba      	ldr	r2, [r7, #8]
 802c8d4:	4413      	add	r3, r2
 802c8d6:	693a      	ldr	r2, [r7, #16]
 802c8d8:	601a      	str	r2, [r3, #0]
 802c8da:	697a      	ldr	r2, [r7, #20]
 802c8dc:	4613      	mov	r3, r2
 802c8de:	079b      	lsls	r3, r3, #30
 802c8e0:	1a9b      	subs	r3, r3, r2
 802c8e2:	009b      	lsls	r3, r3, #2
 802c8e4:	461a      	mov	r2, r3
 802c8e6:	68bb      	ldr	r3, [r7, #8]
 802c8e8:	4413      	add	r3, r2
 802c8ea:	693a      	ldr	r2, [r7, #16]
 802c8ec:	4252      	negs	r2, r2
 802c8ee:	601a      	str	r2, [r3, #0]
  for (in = 0; in < STEPSIZE; in++, out++) {
 802c8f0:	697b      	ldr	r3, [r7, #20]
 802c8f2:	3301      	adds	r3, #1
 802c8f4:	617b      	str	r3, [r7, #20]
 802c8f6:	693b      	ldr	r3, [r7, #16]
 802c8f8:	3301      	adds	r3, #1
 802c8fa:	613b      	str	r3, [r7, #16]
 802c8fc:	697b      	ldr	r3, [r7, #20]
 802c8fe:	2b0f      	cmp	r3, #15
 802c900:	dde5      	ble.n	802c8ce <init_error_limit+0x3a>
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 802c902:	e01f      	b.n	802c944 <init_error_limit+0xb0>
    table[in] = out; table[-in] = -out;
 802c904:	697b      	ldr	r3, [r7, #20]
 802c906:	009b      	lsls	r3, r3, #2
 802c908:	68ba      	ldr	r2, [r7, #8]
 802c90a:	4413      	add	r3, r2
 802c90c:	693a      	ldr	r2, [r7, #16]
 802c90e:	601a      	str	r2, [r3, #0]
 802c910:	697a      	ldr	r2, [r7, #20]
 802c912:	4613      	mov	r3, r2
 802c914:	079b      	lsls	r3, r3, #30
 802c916:	1a9b      	subs	r3, r3, r2
 802c918:	009b      	lsls	r3, r3, #2
 802c91a:	461a      	mov	r2, r3
 802c91c:	68bb      	ldr	r3, [r7, #8]
 802c91e:	4413      	add	r3, r2
 802c920:	693a      	ldr	r2, [r7, #16]
 802c922:	4252      	negs	r2, r2
 802c924:	601a      	str	r2, [r3, #0]
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 802c926:	697b      	ldr	r3, [r7, #20]
 802c928:	3301      	adds	r3, #1
 802c92a:	617b      	str	r3, [r7, #20]
 802c92c:	697b      	ldr	r3, [r7, #20]
 802c92e:	f003 0301 	and.w	r3, r3, #1
 802c932:	2b00      	cmp	r3, #0
 802c934:	bf0c      	ite	eq
 802c936:	2301      	moveq	r3, #1
 802c938:	2300      	movne	r3, #0
 802c93a:	b2db      	uxtb	r3, r3
 802c93c:	461a      	mov	r2, r3
 802c93e:	693b      	ldr	r3, [r7, #16]
 802c940:	4413      	add	r3, r2
 802c942:	613b      	str	r3, [r7, #16]
 802c944:	697b      	ldr	r3, [r7, #20]
 802c946:	2b2f      	cmp	r3, #47	@ 0x2f
 802c948:	dddc      	ble.n	802c904 <init_error_limit+0x70>
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
 802c94a:	e013      	b.n	802c974 <init_error_limit+0xe0>
    table[in] = out; table[-in] = -out;
 802c94c:	697b      	ldr	r3, [r7, #20]
 802c94e:	009b      	lsls	r3, r3, #2
 802c950:	68ba      	ldr	r2, [r7, #8]
 802c952:	4413      	add	r3, r2
 802c954:	693a      	ldr	r2, [r7, #16]
 802c956:	601a      	str	r2, [r3, #0]
 802c958:	697a      	ldr	r2, [r7, #20]
 802c95a:	4613      	mov	r3, r2
 802c95c:	079b      	lsls	r3, r3, #30
 802c95e:	1a9b      	subs	r3, r3, r2
 802c960:	009b      	lsls	r3, r3, #2
 802c962:	461a      	mov	r2, r3
 802c964:	68bb      	ldr	r3, [r7, #8]
 802c966:	4413      	add	r3, r2
 802c968:	693a      	ldr	r2, [r7, #16]
 802c96a:	4252      	negs	r2, r2
 802c96c:	601a      	str	r2, [r3, #0]
  for (; in <= MAXJSAMPLE; in++) {
 802c96e:	697b      	ldr	r3, [r7, #20]
 802c970:	3301      	adds	r3, #1
 802c972:	617b      	str	r3, [r7, #20]
 802c974:	697b      	ldr	r3, [r7, #20]
 802c976:	2bff      	cmp	r3, #255	@ 0xff
 802c978:	dde8      	ble.n	802c94c <init_error_limit+0xb8>
  }
#undef STEPSIZE
}
 802c97a:	bf00      	nop
 802c97c:	bf00      	nop
 802c97e:	3718      	adds	r7, #24
 802c980:	46bd      	mov	sp, r7
 802c982:	bd80      	pop	{r7, pc}

0802c984 <finish_pass1>:
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
 802c984:	b580      	push	{r7, lr}
 802c986:	b084      	sub	sp, #16
 802c988:	af00      	add	r7, sp, #0
 802c98a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c98c:	687b      	ldr	r3, [r7, #4]
 802c98e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c992:	60fb      	str	r3, [r7, #12]

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
 802c994:	68fb      	ldr	r3, [r7, #12]
 802c996:	691a      	ldr	r2, [r3, #16]
 802c998:	687b      	ldr	r3, [r7, #4]
 802c99a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  select_colors(cinfo, cquantize->desired);
 802c99e:	68fb      	ldr	r3, [r7, #12]
 802c9a0:	695b      	ldr	r3, [r3, #20]
 802c9a2:	4619      	mov	r1, r3
 802c9a4:	6878      	ldr	r0, [r7, #4]
 802c9a6:	f7ff f8de 	bl	802bb66 <select_colors>
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
 802c9aa:	68fb      	ldr	r3, [r7, #12]
 802c9ac:	2201      	movs	r2, #1
 802c9ae:	61da      	str	r2, [r3, #28]
}
 802c9b0:	bf00      	nop
 802c9b2:	3710      	adds	r7, #16
 802c9b4:	46bd      	mov	sp, r7
 802c9b6:	bd80      	pop	{r7, pc}

0802c9b8 <finish_pass2>:


METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
 802c9b8:	b480      	push	{r7}
 802c9ba:	b083      	sub	sp, #12
 802c9bc:	af00      	add	r7, sp, #0
 802c9be:	6078      	str	r0, [r7, #4]
  /* no work */
}
 802c9c0:	bf00      	nop
 802c9c2:	370c      	adds	r7, #12
 802c9c4:	46bd      	mov	sp, r7
 802c9c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c9ca:	4770      	bx	lr

0802c9cc <start_pass_2_quant>:
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 802c9cc:	b580      	push	{r7, lr}
 802c9ce:	b086      	sub	sp, #24
 802c9d0:	af00      	add	r7, sp, #0
 802c9d2:	6078      	str	r0, [r7, #4]
 802c9d4:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802c9d6:	687b      	ldr	r3, [r7, #4]
 802c9d8:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802c9dc:	613b      	str	r3, [r7, #16]
  hist3d histogram = cquantize->histogram;
 802c9de:	693b      	ldr	r3, [r7, #16]
 802c9e0:	699b      	ldr	r3, [r3, #24]
 802c9e2:	60fb      	str	r3, [r7, #12]
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 802c9e4:	687b      	ldr	r3, [r7, #4]
 802c9e6:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802c9ea:	2b00      	cmp	r3, #0
 802c9ec:	d003      	beq.n	802c9f6 <start_pass_2_quant+0x2a>
    cinfo->dither_mode = JDITHER_FS;
 802c9ee:	687b      	ldr	r3, [r7, #4]
 802c9f0:	2202      	movs	r2, #2
 802c9f2:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58

  if (is_pre_scan) {
 802c9f6:	683b      	ldr	r3, [r7, #0]
 802c9f8:	2b00      	cmp	r3, #0
 802c9fa:	d009      	beq.n	802ca10 <start_pass_2_quant+0x44>
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
 802c9fc:	693b      	ldr	r3, [r7, #16]
 802c9fe:	4a44      	ldr	r2, [pc, #272]	@ (802cb10 <start_pass_2_quant+0x144>)
 802ca00:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass1;
 802ca02:	693b      	ldr	r3, [r7, #16]
 802ca04:	4a43      	ldr	r2, [pc, #268]	@ (802cb14 <start_pass_2_quant+0x148>)
 802ca06:	609a      	str	r2, [r3, #8]
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
 802ca08:	693b      	ldr	r3, [r7, #16]
 802ca0a:	2201      	movs	r2, #1
 802ca0c:	61da      	str	r2, [r3, #28]
 802ca0e:	e060      	b.n	802cad2 <start_pass_2_quant+0x106>
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
 802ca10:	687b      	ldr	r3, [r7, #4]
 802ca12:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802ca16:	2b02      	cmp	r3, #2
 802ca18:	d103      	bne.n	802ca22 <start_pass_2_quant+0x56>
      cquantize->pub.color_quantize = pass2_fs_dither;
 802ca1a:	693b      	ldr	r3, [r7, #16]
 802ca1c:	4a3e      	ldr	r2, [pc, #248]	@ (802cb18 <start_pass_2_quant+0x14c>)
 802ca1e:	605a      	str	r2, [r3, #4]
 802ca20:	e002      	b.n	802ca28 <start_pass_2_quant+0x5c>
    else
      cquantize->pub.color_quantize = pass2_no_dither;
 802ca22:	693b      	ldr	r3, [r7, #16]
 802ca24:	4a3d      	ldr	r2, [pc, #244]	@ (802cb1c <start_pass_2_quant+0x150>)
 802ca26:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass2;
 802ca28:	693b      	ldr	r3, [r7, #16]
 802ca2a:	4a3d      	ldr	r2, [pc, #244]	@ (802cb20 <start_pass_2_quant+0x154>)
 802ca2c:	609a      	str	r2, [r3, #8]

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
 802ca2e:	687b      	ldr	r3, [r7, #4]
 802ca30:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 802ca34:	617b      	str	r3, [r7, #20]
    if (i < 1)
 802ca36:	697b      	ldr	r3, [r7, #20]
 802ca38:	2b00      	cmp	r3, #0
 802ca3a:	dc0c      	bgt.n	802ca56 <start_pass_2_quant+0x8a>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
 802ca3c:	687b      	ldr	r3, [r7, #4]
 802ca3e:	681b      	ldr	r3, [r3, #0]
 802ca40:	223a      	movs	r2, #58	@ 0x3a
 802ca42:	615a      	str	r2, [r3, #20]
 802ca44:	687b      	ldr	r3, [r7, #4]
 802ca46:	681b      	ldr	r3, [r3, #0]
 802ca48:	2201      	movs	r2, #1
 802ca4a:	619a      	str	r2, [r3, #24]
 802ca4c:	687b      	ldr	r3, [r7, #4]
 802ca4e:	681b      	ldr	r3, [r3, #0]
 802ca50:	681b      	ldr	r3, [r3, #0]
 802ca52:	6878      	ldr	r0, [r7, #4]
 802ca54:	4798      	blx	r3
    if (i > MAXNUMCOLORS)
 802ca56:	697b      	ldr	r3, [r7, #20]
 802ca58:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802ca5c:	dd0d      	ble.n	802ca7a <start_pass_2_quant+0xae>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 802ca5e:	687b      	ldr	r3, [r7, #4]
 802ca60:	681b      	ldr	r3, [r3, #0]
 802ca62:	223b      	movs	r2, #59	@ 0x3b
 802ca64:	615a      	str	r2, [r3, #20]
 802ca66:	687b      	ldr	r3, [r7, #4]
 802ca68:	681b      	ldr	r3, [r3, #0]
 802ca6a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802ca6e:	619a      	str	r2, [r3, #24]
 802ca70:	687b      	ldr	r3, [r7, #4]
 802ca72:	681b      	ldr	r3, [r3, #0]
 802ca74:	681b      	ldr	r3, [r3, #0]
 802ca76:	6878      	ldr	r0, [r7, #4]
 802ca78:	4798      	blx	r3

    if (cinfo->dither_mode == JDITHER_FS) {
 802ca7a:	687b      	ldr	r3, [r7, #4]
 802ca7c:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802ca80:	2b02      	cmp	r3, #2
 802ca82:	d126      	bne.n	802cad2 <start_pass_2_quant+0x106>
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
 802ca84:	687b      	ldr	r3, [r7, #4]
 802ca86:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 802ca88:	4613      	mov	r3, r2
 802ca8a:	005b      	lsls	r3, r3, #1
 802ca8c:	4413      	add	r3, r2
 802ca8e:	005b      	lsls	r3, r3, #1
 802ca90:	330c      	adds	r3, #12
 802ca92:	60bb      	str	r3, [r7, #8]
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
 802ca94:	693b      	ldr	r3, [r7, #16]
 802ca96:	6a1b      	ldr	r3, [r3, #32]
 802ca98:	2b00      	cmp	r3, #0
 802ca9a:	d109      	bne.n	802cab0 <start_pass_2_quant+0xe4>
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802ca9c:	687b      	ldr	r3, [r7, #4]
 802ca9e:	685b      	ldr	r3, [r3, #4]
 802caa0:	685b      	ldr	r3, [r3, #4]
 802caa2:	68ba      	ldr	r2, [r7, #8]
 802caa4:	2101      	movs	r1, #1
 802caa6:	6878      	ldr	r0, [r7, #4]
 802caa8:	4798      	blx	r3
 802caaa:	4602      	mov	r2, r0
 802caac:	693b      	ldr	r3, [r7, #16]
 802caae:	621a      	str	r2, [r3, #32]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      FMEMZERO((void FAR *) cquantize->fserrors, arraysize);
 802cab0:	693b      	ldr	r3, [r7, #16]
 802cab2:	6a1b      	ldr	r3, [r3, #32]
 802cab4:	68ba      	ldr	r2, [r7, #8]
 802cab6:	2100      	movs	r1, #0
 802cab8:	4618      	mov	r0, r3
 802caba:	f000 fe9a 	bl	802d7f2 <memset>
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
 802cabe:	693b      	ldr	r3, [r7, #16]
 802cac0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802cac2:	2b00      	cmp	r3, #0
 802cac4:	d102      	bne.n	802cacc <start_pass_2_quant+0x100>
	init_error_limit(cinfo);
 802cac6:	6878      	ldr	r0, [r7, #4]
 802cac8:	f7ff fee4 	bl	802c894 <init_error_limit>
      cquantize->on_odd_row = FALSE;
 802cacc:	693b      	ldr	r3, [r7, #16]
 802cace:	2200      	movs	r2, #0
 802cad0:	625a      	str	r2, [r3, #36]	@ 0x24
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
 802cad2:	693b      	ldr	r3, [r7, #16]
 802cad4:	69db      	ldr	r3, [r3, #28]
 802cad6:	2b00      	cmp	r3, #0
 802cad8:	d016      	beq.n	802cb08 <start_pass_2_quant+0x13c>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 802cada:	2300      	movs	r3, #0
 802cadc:	617b      	str	r3, [r7, #20]
 802cade:	e00d      	b.n	802cafc <start_pass_2_quant+0x130>
      FMEMZERO((void FAR *) histogram[i],
 802cae0:	697b      	ldr	r3, [r7, #20]
 802cae2:	009b      	lsls	r3, r3, #2
 802cae4:	68fa      	ldr	r2, [r7, #12]
 802cae6:	4413      	add	r3, r2
 802cae8:	681b      	ldr	r3, [r3, #0]
 802caea:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 802caee:	2100      	movs	r1, #0
 802caf0:	4618      	mov	r0, r3
 802caf2:	f000 fe7e 	bl	802d7f2 <memset>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 802caf6:	697b      	ldr	r3, [r7, #20]
 802caf8:	3301      	adds	r3, #1
 802cafa:	617b      	str	r3, [r7, #20]
 802cafc:	697b      	ldr	r3, [r7, #20]
 802cafe:	2b1f      	cmp	r3, #31
 802cb00:	ddee      	ble.n	802cae0 <start_pass_2_quant+0x114>
	       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
 802cb02:	693b      	ldr	r3, [r7, #16]
 802cb04:	2200      	movs	r2, #0
 802cb06:	61da      	str	r2, [r3, #28]
  }
}
 802cb08:	bf00      	nop
 802cb0a:	3718      	adds	r7, #24
 802cb0c:	46bd      	mov	sp, r7
 802cb0e:	bd80      	pop	{r7, pc}
 802cb10:	0802b40d 	.word	0x0802b40d
 802cb14:	0802c985 	.word	0x0802c985
 802cb18:	0802c5fd 	.word	0x0802c5fd
 802cb1c:	0802c539 	.word	0x0802c539
 802cb20:	0802c9b9 	.word	0x0802c9b9

0802cb24 <new_color_map_2_quant>:
 * Switch to a new external colormap between output passes.
 */

METHODDEF(void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
 802cb24:	b480      	push	{r7}
 802cb26:	b085      	sub	sp, #20
 802cb28:	af00      	add	r7, sp, #0
 802cb2a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802cb2c:	687b      	ldr	r3, [r7, #4]
 802cb2e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802cb32:	60fb      	str	r3, [r7, #12]

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
 802cb34:	68fb      	ldr	r3, [r7, #12]
 802cb36:	2201      	movs	r2, #1
 802cb38:	61da      	str	r2, [r3, #28]
}
 802cb3a:	bf00      	nop
 802cb3c:	3714      	adds	r7, #20
 802cb3e:	46bd      	mov	sp, r7
 802cb40:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cb44:	4770      	bx	lr
	...

0802cb48 <jinit_2pass_quantizer>:
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
 802cb48:	b590      	push	{r4, r7, lr}
 802cb4a:	b087      	sub	sp, #28
 802cb4c:	af00      	add	r7, sp, #0
 802cb4e:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802cb50:	687b      	ldr	r3, [r7, #4]
 802cb52:	685b      	ldr	r3, [r3, #4]
 802cb54:	681b      	ldr	r3, [r3, #0]
 802cb56:	222c      	movs	r2, #44	@ 0x2c
 802cb58:	2101      	movs	r1, #1
 802cb5a:	6878      	ldr	r0, [r7, #4]
 802cb5c:	4798      	blx	r3
 802cb5e:	6138      	str	r0, [r7, #16]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 802cb60:	687b      	ldr	r3, [r7, #4]
 802cb62:	693a      	ldr	r2, [r7, #16]
 802cb64:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
  cquantize->pub.start_pass = start_pass_2_quant;
 802cb68:	693b      	ldr	r3, [r7, #16]
 802cb6a:	4a4f      	ldr	r2, [pc, #316]	@ (802cca8 <jinit_2pass_quantizer+0x160>)
 802cb6c:	601a      	str	r2, [r3, #0]
  cquantize->pub.new_color_map = new_color_map_2_quant;
 802cb6e:	693b      	ldr	r3, [r7, #16]
 802cb70:	4a4e      	ldr	r2, [pc, #312]	@ (802ccac <jinit_2pass_quantizer+0x164>)
 802cb72:	60da      	str	r2, [r3, #12]
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
 802cb74:	693b      	ldr	r3, [r7, #16]
 802cb76:	2200      	movs	r2, #0
 802cb78:	621a      	str	r2, [r3, #32]
  cquantize->error_limiter = NULL;
 802cb7a:	693b      	ldr	r3, [r7, #16]
 802cb7c:	2200      	movs	r2, #0
 802cb7e:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
 802cb80:	687b      	ldr	r3, [r7, #4]
 802cb82:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802cb84:	2b03      	cmp	r3, #3
 802cb86:	d008      	beq.n	802cb9a <jinit_2pass_quantizer+0x52>
    ERREXIT(cinfo, JERR_NOTIMPL);
 802cb88:	687b      	ldr	r3, [r7, #4]
 802cb8a:	681b      	ldr	r3, [r3, #0]
 802cb8c:	2230      	movs	r2, #48	@ 0x30
 802cb8e:	615a      	str	r2, [r3, #20]
 802cb90:	687b      	ldr	r3, [r7, #4]
 802cb92:	681b      	ldr	r3, [r3, #0]
 802cb94:	681b      	ldr	r3, [r3, #0]
 802cb96:	6878      	ldr	r0, [r7, #4]
 802cb98:	4798      	blx	r3

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
 802cb9a:	687b      	ldr	r3, [r7, #4]
 802cb9c:	685b      	ldr	r3, [r3, #4]
 802cb9e:	681b      	ldr	r3, [r3, #0]
 802cba0:	2280      	movs	r2, #128	@ 0x80
 802cba2:	2101      	movs	r1, #1
 802cba4:	6878      	ldr	r0, [r7, #4]
 802cba6:	4798      	blx	r3
 802cba8:	4602      	mov	r2, r0
 802cbaa:	693b      	ldr	r3, [r7, #16]
 802cbac:	619a      	str	r2, [r3, #24]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 802cbae:	2300      	movs	r3, #0
 802cbb0:	617b      	str	r3, [r7, #20]
 802cbb2:	e011      	b.n	802cbd8 <jinit_2pass_quantizer+0x90>
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
 802cbb4:	687b      	ldr	r3, [r7, #4]
 802cbb6:	685b      	ldr	r3, [r3, #4]
 802cbb8:	685b      	ldr	r3, [r3, #4]
 802cbba:	693a      	ldr	r2, [r7, #16]
 802cbbc:	6991      	ldr	r1, [r2, #24]
 802cbbe:	697a      	ldr	r2, [r7, #20]
 802cbc0:	0092      	lsls	r2, r2, #2
 802cbc2:	188c      	adds	r4, r1, r2
 802cbc4:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 802cbc8:	2101      	movs	r1, #1
 802cbca:	6878      	ldr	r0, [r7, #4]
 802cbcc:	4798      	blx	r3
 802cbce:	4603      	mov	r3, r0
 802cbd0:	6023      	str	r3, [r4, #0]
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 802cbd2:	697b      	ldr	r3, [r7, #20]
 802cbd4:	3301      	adds	r3, #1
 802cbd6:	617b      	str	r3, [r7, #20]
 802cbd8:	697b      	ldr	r3, [r7, #20]
 802cbda:	2b1f      	cmp	r3, #31
 802cbdc:	ddea      	ble.n	802cbb4 <jinit_2pass_quantizer+0x6c>
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
 802cbde:	693b      	ldr	r3, [r7, #16]
 802cbe0:	2201      	movs	r2, #1
 802cbe2:	61da      	str	r2, [r3, #28]

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
 802cbe4:	687b      	ldr	r3, [r7, #4]
 802cbe6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 802cbe8:	2b00      	cmp	r3, #0
 802cbea:	d033      	beq.n	802cc54 <jinit_2pass_quantizer+0x10c>
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
 802cbec:	687b      	ldr	r3, [r7, #4]
 802cbee:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802cbf0:	60fb      	str	r3, [r7, #12]
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
 802cbf2:	68fb      	ldr	r3, [r7, #12]
 802cbf4:	2b07      	cmp	r3, #7
 802cbf6:	dc0c      	bgt.n	802cc12 <jinit_2pass_quantizer+0xca>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
 802cbf8:	687b      	ldr	r3, [r7, #4]
 802cbfa:	681b      	ldr	r3, [r3, #0]
 802cbfc:	223a      	movs	r2, #58	@ 0x3a
 802cbfe:	615a      	str	r2, [r3, #20]
 802cc00:	687b      	ldr	r3, [r7, #4]
 802cc02:	681b      	ldr	r3, [r3, #0]
 802cc04:	2208      	movs	r2, #8
 802cc06:	619a      	str	r2, [r3, #24]
 802cc08:	687b      	ldr	r3, [r7, #4]
 802cc0a:	681b      	ldr	r3, [r3, #0]
 802cc0c:	681b      	ldr	r3, [r3, #0]
 802cc0e:	6878      	ldr	r0, [r7, #4]
 802cc10:	4798      	blx	r3
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
 802cc12:	68fb      	ldr	r3, [r7, #12]
 802cc14:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802cc18:	dd0d      	ble.n	802cc36 <jinit_2pass_quantizer+0xee>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 802cc1a:	687b      	ldr	r3, [r7, #4]
 802cc1c:	681b      	ldr	r3, [r3, #0]
 802cc1e:	223b      	movs	r2, #59	@ 0x3b
 802cc20:	615a      	str	r2, [r3, #20]
 802cc22:	687b      	ldr	r3, [r7, #4]
 802cc24:	681b      	ldr	r3, [r3, #0]
 802cc26:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802cc2a:	619a      	str	r2, [r3, #24]
 802cc2c:	687b      	ldr	r3, [r7, #4]
 802cc2e:	681b      	ldr	r3, [r3, #0]
 802cc30:	681b      	ldr	r3, [r3, #0]
 802cc32:	6878      	ldr	r0, [r7, #4]
 802cc34:	4798      	blx	r3
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
 802cc36:	687b      	ldr	r3, [r7, #4]
 802cc38:	685b      	ldr	r3, [r3, #4]
 802cc3a:	689c      	ldr	r4, [r3, #8]
 802cc3c:	68fa      	ldr	r2, [r7, #12]
 802cc3e:	2303      	movs	r3, #3
 802cc40:	2101      	movs	r1, #1
 802cc42:	6878      	ldr	r0, [r7, #4]
 802cc44:	47a0      	blx	r4
 802cc46:	4602      	mov	r2, r0
 802cc48:	693b      	ldr	r3, [r7, #16]
 802cc4a:	611a      	str	r2, [r3, #16]
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
 802cc4c:	693b      	ldr	r3, [r7, #16]
 802cc4e:	68fa      	ldr	r2, [r7, #12]
 802cc50:	615a      	str	r2, [r3, #20]
 802cc52:	e002      	b.n	802cc5a <jinit_2pass_quantizer+0x112>
  } else
    cquantize->sv_colormap = NULL;
 802cc54:	693b      	ldr	r3, [r7, #16]
 802cc56:	2200      	movs	r2, #0
 802cc58:	611a      	str	r2, [r3, #16]

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 802cc5a:	687b      	ldr	r3, [r7, #4]
 802cc5c:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802cc60:	2b00      	cmp	r3, #0
 802cc62:	d003      	beq.n	802cc6c <jinit_2pass_quantizer+0x124>
    cinfo->dither_mode = JDITHER_FS;
 802cc64:	687b      	ldr	r3, [r7, #4]
 802cc66:	2202      	movs	r2, #2
 802cc68:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
 802cc6c:	687b      	ldr	r3, [r7, #4]
 802cc6e:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802cc72:	2b02      	cmp	r3, #2
 802cc74:	d113      	bne.n	802cc9e <jinit_2pass_quantizer+0x156>
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802cc76:	687b      	ldr	r3, [r7, #4]
 802cc78:	685b      	ldr	r3, [r3, #4]
 802cc7a:	685c      	ldr	r4, [r3, #4]
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 802cc7c:	687b      	ldr	r3, [r7, #4]
 802cc7e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802cc80:	4613      	mov	r3, r2
 802cc82:	005b      	lsls	r3, r3, #1
 802cc84:	4413      	add	r3, r2
 802cc86:	005b      	lsls	r3, r3, #1
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 802cc88:	330c      	adds	r3, #12
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802cc8a:	461a      	mov	r2, r3
 802cc8c:	2101      	movs	r1, #1
 802cc8e:	6878      	ldr	r0, [r7, #4]
 802cc90:	47a0      	blx	r4
 802cc92:	4602      	mov	r2, r0
 802cc94:	693b      	ldr	r3, [r7, #16]
 802cc96:	621a      	str	r2, [r3, #32]
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
 802cc98:	6878      	ldr	r0, [r7, #4]
 802cc9a:	f7ff fdfb 	bl	802c894 <init_error_limit>
  }
}
 802cc9e:	bf00      	nop
 802cca0:	371c      	adds	r7, #28
 802cca2:	46bd      	mov	sp, r7
 802cca4:	bd90      	pop	{r4, r7, pc}
 802cca6:	bf00      	nop
 802cca8:	0802c9cd 	.word	0x0802c9cd
 802ccac:	0802cb25 	.word	0x0802cb25

0802ccb0 <jdiv_round_up>:

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
 802ccb0:	b480      	push	{r7}
 802ccb2:	b083      	sub	sp, #12
 802ccb4:	af00      	add	r7, sp, #0
 802ccb6:	6078      	str	r0, [r7, #4]
 802ccb8:	6039      	str	r1, [r7, #0]
  return (a + b - 1L) / b;
 802ccba:	687a      	ldr	r2, [r7, #4]
 802ccbc:	683b      	ldr	r3, [r7, #0]
 802ccbe:	4413      	add	r3, r2
 802ccc0:	1e5a      	subs	r2, r3, #1
 802ccc2:	683b      	ldr	r3, [r7, #0]
 802ccc4:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802ccc8:	4618      	mov	r0, r3
 802ccca:	370c      	adds	r7, #12
 802cccc:	46bd      	mov	sp, r7
 802ccce:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ccd2:	4770      	bx	lr

0802ccd4 <jround_up>:

GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
 802ccd4:	b480      	push	{r7}
 802ccd6:	b083      	sub	sp, #12
 802ccd8:	af00      	add	r7, sp, #0
 802ccda:	6078      	str	r0, [r7, #4]
 802ccdc:	6039      	str	r1, [r7, #0]
  a += b - 1L;
 802ccde:	683b      	ldr	r3, [r7, #0]
 802cce0:	3b01      	subs	r3, #1
 802cce2:	687a      	ldr	r2, [r7, #4]
 802cce4:	4413      	add	r3, r2
 802cce6:	607b      	str	r3, [r7, #4]
  return a - (a % b);
 802cce8:	687b      	ldr	r3, [r7, #4]
 802ccea:	683a      	ldr	r2, [r7, #0]
 802ccec:	fb93 f2f2 	sdiv	r2, r3, r2
 802ccf0:	6839      	ldr	r1, [r7, #0]
 802ccf2:	fb01 f202 	mul.w	r2, r1, r2
 802ccf6:	1a9b      	subs	r3, r3, r2
 802ccf8:	687a      	ldr	r2, [r7, #4]
 802ccfa:	1ad3      	subs	r3, r2, r3
}
 802ccfc:	4618      	mov	r0, r3
 802ccfe:	370c      	adds	r7, #12
 802cd00:	46bd      	mov	sp, r7
 802cd02:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cd06:	4770      	bx	lr

0802cd08 <jcopy_sample_rows>:
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
 802cd08:	b5f0      	push	{r4, r5, r6, r7, lr}
 802cd0a:	b085      	sub	sp, #20
 802cd0c:	af00      	add	r7, sp, #0
 802cd0e:	60f8      	str	r0, [r7, #12]
 802cd10:	60b9      	str	r1, [r7, #8]
 802cd12:	607a      	str	r2, [r7, #4]
 802cd14:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
 802cd16:	6afd      	ldr	r5, [r7, #44]	@ 0x2c
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
 802cd18:	68bb      	ldr	r3, [r7, #8]
 802cd1a:	009b      	lsls	r3, r3, #2
 802cd1c:	68fa      	ldr	r2, [r7, #12]
 802cd1e:	4413      	add	r3, r2
 802cd20:	60fb      	str	r3, [r7, #12]
  output_array += dest_row;
 802cd22:	683b      	ldr	r3, [r7, #0]
 802cd24:	009b      	lsls	r3, r3, #2
 802cd26:	687a      	ldr	r2, [r7, #4]
 802cd28:	4413      	add	r3, r2
 802cd2a:	607b      	str	r3, [r7, #4]

  for (row = num_rows; row > 0; row--) {
 802cd2c:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 802cd2e:	e00c      	b.n	802cd4a <jcopy_sample_rows+0x42>
    inptr = *input_array++;
 802cd30:	68fb      	ldr	r3, [r7, #12]
 802cd32:	1d1a      	adds	r2, r3, #4
 802cd34:	60fa      	str	r2, [r7, #12]
 802cd36:	6819      	ldr	r1, [r3, #0]
    outptr = *output_array++;
 802cd38:	687b      	ldr	r3, [r7, #4]
 802cd3a:	1d1a      	adds	r2, r3, #4
 802cd3c:	607a      	str	r2, [r7, #4]
 802cd3e:	681e      	ldr	r6, [r3, #0]
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
 802cd40:	462a      	mov	r2, r5
 802cd42:	4630      	mov	r0, r6
 802cd44:	f000 fde1 	bl	802d90a <memcpy>
  for (row = num_rows; row > 0; row--) {
 802cd48:	3c01      	subs	r4, #1
 802cd4a:	2c00      	cmp	r4, #0
 802cd4c:	dcf0      	bgt.n	802cd30 <jcopy_sample_rows+0x28>
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
#endif
  }
}
 802cd4e:	bf00      	nop
 802cd50:	bf00      	nop
 802cd52:	3714      	adds	r7, #20
 802cd54:	46bd      	mov	sp, r7
 802cd56:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802cd58 <jcopy_block_row>:

GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
 802cd58:	b580      	push	{r7, lr}
 802cd5a:	b084      	sub	sp, #16
 802cd5c:	af00      	add	r7, sp, #0
 802cd5e:	60f8      	str	r0, [r7, #12]
 802cd60:	60b9      	str	r1, [r7, #8]
 802cd62:	607a      	str	r2, [r7, #4]
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
 802cd64:	687b      	ldr	r3, [r7, #4]
 802cd66:	01db      	lsls	r3, r3, #7
 802cd68:	461a      	mov	r2, r3
 802cd6a:	68f9      	ldr	r1, [r7, #12]
 802cd6c:	68b8      	ldr	r0, [r7, #8]
 802cd6e:	f000 fdcc 	bl	802d90a <memcpy>
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}
 802cd72:	bf00      	nop
 802cd74:	3710      	adds	r7, #16
 802cd76:	46bd      	mov	sp, r7
 802cd78:	bd80      	pop	{r7, pc}
	...

0802cd7c <MX_USB_HOST_Init>:
/**
  * Init USB host library, add supported class and start the library
  * @retval None
  */
void MX_USB_HOST_Init(void)
{
 802cd7c:	b580      	push	{r7, lr}
 802cd7e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_HOST_Init_PreTreatment */

  /* USER CODE END USB_HOST_Init_PreTreatment */

  /* Init host Library, add supported class and start the library. */
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 802cd80:	2201      	movs	r2, #1
 802cd82:	490e      	ldr	r1, [pc, #56]	@ (802cdbc <MX_USB_HOST_Init+0x40>)
 802cd84:	480e      	ldr	r0, [pc, #56]	@ (802cdc0 <MX_USB_HOST_Init+0x44>)
 802cd86:	f7df f95c 	bl	800c042 <USBH_Init>
 802cd8a:	4603      	mov	r3, r0
 802cd8c:	2b00      	cmp	r3, #0
 802cd8e:	d001      	beq.n	802cd94 <MX_USB_HOST_Init+0x18>
  {
    Error_Handler();
 802cd90:	f7d4 fbf0 	bl	8001574 <Error_Handler>
  }
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MSC_CLASS) != USBH_OK)
 802cd94:	490b      	ldr	r1, [pc, #44]	@ (802cdc4 <MX_USB_HOST_Init+0x48>)
 802cd96:	480a      	ldr	r0, [pc, #40]	@ (802cdc0 <MX_USB_HOST_Init+0x44>)
 802cd98:	f7df fa00 	bl	800c19c <USBH_RegisterClass>
 802cd9c:	4603      	mov	r3, r0
 802cd9e:	2b00      	cmp	r3, #0
 802cda0:	d001      	beq.n	802cda6 <MX_USB_HOST_Init+0x2a>
  {
    Error_Handler();
 802cda2:	f7d4 fbe7 	bl	8001574 <Error_Handler>
  }
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 802cda6:	4806      	ldr	r0, [pc, #24]	@ (802cdc0 <MX_USB_HOST_Init+0x44>)
 802cda8:	f7df fa84 	bl	800c2b4 <USBH_Start>
 802cdac:	4603      	mov	r3, r0
 802cdae:	2b00      	cmp	r3, #0
 802cdb0:	d001      	beq.n	802cdb6 <MX_USB_HOST_Init+0x3a>
  {
    Error_Handler();
 802cdb2:	f7d4 fbdf 	bl	8001574 <Error_Handler>
  }
  /* USER CODE BEGIN USB_HOST_Init_PostTreatment */

  /* USER CODE END USB_HOST_Init_PostTreatment */
}
 802cdb6:	bf00      	nop
 802cdb8:	bd80      	pop	{r7, pc}
 802cdba:	bf00      	nop
 802cdbc:	0802cddd 	.word	0x0802cddd
 802cdc0:	20002920 	.word	0x20002920
 802cdc4:	2000000c 	.word	0x2000000c

0802cdc8 <MX_USB_HOST_Process>:

/*
 * Background task
 */
void MX_USB_HOST_Process(void)
{
 802cdc8:	b580      	push	{r7, lr}
 802cdca:	af00      	add	r7, sp, #0
  /* USB Host Background task */
  USBH_Process(&hUsbHostFS);
 802cdcc:	4802      	ldr	r0, [pc, #8]	@ (802cdd8 <MX_USB_HOST_Process+0x10>)
 802cdce:	f7df fa81 	bl	800c2d4 <USBH_Process>
}
 802cdd2:	bf00      	nop
 802cdd4:	bd80      	pop	{r7, pc}
 802cdd6:	bf00      	nop
 802cdd8:	20002920 	.word	0x20002920

0802cddc <USBH_UserProcess>:
/*
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
 802cddc:	b580      	push	{r7, lr}
 802cdde:	b082      	sub	sp, #8
 802cde0:	af00      	add	r7, sp, #0
 802cde2:	6078      	str	r0, [r7, #4]
 802cde4:	460b      	mov	r3, r1
 802cde6:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
 802cde8:	78fb      	ldrb	r3, [r7, #3]
 802cdea:	3b01      	subs	r3, #1
 802cdec:	2b04      	cmp	r3, #4
 802cdee:	d829      	bhi.n	802ce44 <USBH_UserProcess+0x68>
 802cdf0:	a201      	add	r2, pc, #4	@ (adr r2, 802cdf8 <USBH_UserProcess+0x1c>)
 802cdf2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802cdf6:	bf00      	nop
 802cdf8:	0802ce45 	.word	0x0802ce45
 802cdfc:	0802ce1f 	.word	0x0802ce1f
 802ce00:	0802ce45 	.word	0x0802ce45
 802ce04:	0802ce3d 	.word	0x0802ce3d
 802ce08:	0802ce0d 	.word	0x0802ce0d
  {
  case HOST_USER_SELECT_CONFIGURATION:
  break;

  case HOST_USER_DISCONNECTION:
  Appli_state = APPLICATION_DISCONNECT;
 802ce0c:	4b10      	ldr	r3, [pc, #64]	@ (802ce50 <USBH_UserProcess+0x74>)
 802ce0e:	2203      	movs	r2, #3
 802ce10:	701a      	strb	r2, [r3, #0]
  f_mount(&fs, USBHPath, 0);
 802ce12:	2200      	movs	r2, #0
 802ce14:	490f      	ldr	r1, [pc, #60]	@ (802ce54 <USBH_UserProcess+0x78>)
 802ce16:	4810      	ldr	r0, [pc, #64]	@ (802ce58 <USBH_UserProcess+0x7c>)
 802ce18:	f7e2 fc66 	bl	800f6e8 <f_mount>
  break;
 802ce1c:	e013      	b.n	802ce46 <USBH_UserProcess+0x6a>

  case HOST_USER_CLASS_ACTIVE:
  Appli_state = APPLICATION_READY;
 802ce1e:	4b0c      	ldr	r3, [pc, #48]	@ (802ce50 <USBH_UserProcess+0x74>)
 802ce20:	2202      	movs	r2, #2
 802ce22:	701a      	strb	r2, [r3, #0]
  f_mount(&fs, USBHPath, 1);
 802ce24:	2201      	movs	r2, #1
 802ce26:	490b      	ldr	r1, [pc, #44]	@ (802ce54 <USBH_UserProcess+0x78>)
 802ce28:	480b      	ldr	r0, [pc, #44]	@ (802ce58 <USBH_UserProcess+0x7c>)
 802ce2a:	f7e2 fc5d 	bl	800f6e8 <f_mount>
  f_mkdir("0:/Video");
 802ce2e:	480b      	ldr	r0, [pc, #44]	@ (802ce5c <USBH_UserProcess+0x80>)
 802ce30:	f7e3 fcd2 	bl	80107d8 <f_mkdir>
  begin_rec = 1;
 802ce34:	4b0a      	ldr	r3, [pc, #40]	@ (802ce60 <USBH_UserProcess+0x84>)
 802ce36:	2201      	movs	r2, #1
 802ce38:	701a      	strb	r2, [r3, #0]
  break;
 802ce3a:	e004      	b.n	802ce46 <USBH_UserProcess+0x6a>

  case HOST_USER_CONNECTION:
  Appli_state = APPLICATION_START;
 802ce3c:	4b04      	ldr	r3, [pc, #16]	@ (802ce50 <USBH_UserProcess+0x74>)
 802ce3e:	2201      	movs	r2, #1
 802ce40:	701a      	strb	r2, [r3, #0]
  break;
 802ce42:	e000      	b.n	802ce46 <USBH_UserProcess+0x6a>

  default:
  break;
 802ce44:	bf00      	nop
  }
  /* USER CODE END CALL_BACK_1 */
}
 802ce46:	bf00      	nop
 802ce48:	3708      	adds	r7, #8
 802ce4a:	46bd      	mov	sp, r7
 802ce4c:	bd80      	pop	{r7, pc}
 802ce4e:	bf00      	nop
 802ce50:	20002cf8 	.word	0x20002cf8
 802ce54:	200028e8 	.word	0x200028e8
 802ce58:	2000017c 	.word	0x2000017c
 802ce5c:	0802fad4 	.word	0x0802fad4
 802ce60:	200021e4 	.word	0x200021e4

0802ce64 <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
 802ce64:	b580      	push	{r7, lr}
 802ce66:	b086      	sub	sp, #24
 802ce68:	af00      	add	r7, sp, #0
 802ce6a:	6078      	str	r0, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct = {0};
 802ce6c:	f107 0308 	add.w	r3, r7, #8
 802ce70:	2200      	movs	r2, #0
 802ce72:	601a      	str	r2, [r3, #0]
 802ce74:	605a      	str	r2, [r3, #4]
 802ce76:	609a      	str	r2, [r3, #8]
 802ce78:	60da      	str	r2, [r3, #12]
  if(hcdHandle->Instance==USB_OTG_FS)
 802ce7a:	687b      	ldr	r3, [r7, #4]
 802ce7c:	681b      	ldr	r3, [r3, #0]
 802ce7e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 802ce82:	d13b      	bne.n	802cefc <HAL_HCD_MspInit+0x98>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    RCC->AHB1ENR.bit.gpioaen = SET;
 802ce84:	4a1f      	ldr	r2, [pc, #124]	@ (802cf04 <HAL_HCD_MspInit+0xa0>)
 802ce86:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 802ce88:	f043 0301 	orr.w	r3, r3, #1
 802ce8c:	6313      	str	r3, [r2, #48]	@ 0x30
    /**USB_OTG_FS GPIO Configuration
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.pGPIOx = GPIOA;
 802ce8e:	4b1e      	ldr	r3, [pc, #120]	@ (802cf08 <HAL_HCD_MspInit+0xa4>)
 802ce90:	60bb      	str	r3, [r7, #8]
    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_9;
 802ce92:	2309      	movs	r3, #9
 802ce94:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_INPUT;
 802ce96:	2300      	movs	r3, #0
 802ce98:	743b      	strb	r3, [r7, #16]
    GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 802ce9a:	2300      	movs	r3, #0
 802ce9c:	74bb      	strb	r3, [r7, #18]
    GPIO_Init(&GPIO_InitStruct);
 802ce9e:	f107 0308 	add.w	r3, r7, #8
 802cea2:	4618      	mov	r0, r3
 802cea4:	f7dc faca 	bl	800943c <GPIO_Init>

    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_11;
 802cea8:	230b      	movs	r3, #11
 802ceaa:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 802ceac:	2302      	movs	r3, #2
 802ceae:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 802ceb0:	2300      	movs	r3, #0
 802ceb2:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 802ceb4:	2300      	movs	r3, #0
 802ceb6:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_HIGH;
 802ceb8:	2303      	movs	r3, #3
 802ceba:	747b      	strb	r3, [r7, #17]
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0xA;
 802cebc:	230a      	movs	r3, #10
 802cebe:	753b      	strb	r3, [r7, #20]
    GPIO_Init(&GPIO_InitStruct);
 802cec0:	f107 0308 	add.w	r3, r7, #8
 802cec4:	4618      	mov	r0, r3
 802cec6:	f7dc fab9 	bl	800943c <GPIO_Init>

    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_12;
 802ceca:	230c      	movs	r3, #12
 802cecc:	60fb      	str	r3, [r7, #12]
    GPIO_Init(&GPIO_InitStruct);
 802cece:	f107 0308 	add.w	r3, r7, #8
 802ced2:	4618      	mov	r0, r3
 802ced4:	f7dc fab2 	bl	800943c <GPIO_Init>

    /* Peripheral clock enable */
    RCC->AHB2ENR.bit.otgfsen = SET;
 802ced8:	4a0a      	ldr	r2, [pc, #40]	@ (802cf04 <HAL_HCD_MspInit+0xa0>)
 802ceda:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 802cedc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802cee0:	6353      	str	r3, [r2, #52]	@ 0x34
    RCC->APB2ENR.bit.syscfgen = SET;
 802cee2:	4a08      	ldr	r2, [pc, #32]	@ (802cf04 <HAL_HCD_MspInit+0xa0>)
 802cee4:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 802cee6:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 802ceea:	6453      	str	r3, [r2, #68]	@ 0x44

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 802ceec:	2200      	movs	r2, #0
 802ceee:	2100      	movs	r1, #0
 802cef0:	2043      	movs	r0, #67	@ 0x43
 802cef2:	f7d4 ff76 	bl	8001de2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 802cef6:	2043      	movs	r0, #67	@ 0x43
 802cef8:	f7d4 ff8f 	bl	8001e1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 802cefc:	bf00      	nop
 802cefe:	3718      	adds	r7, #24
 802cf00:	46bd      	mov	sp, r7
 802cf02:	bd80      	pop	{r7, pc}
 802cf04:	40023800 	.word	0x40023800
 802cf08:	40020000 	.word	0x40020000

0802cf0c <HAL_HCD_SOF_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
 802cf0c:	b580      	push	{r7, lr}
 802cf0e:	b082      	sub	sp, #8
 802cf10:	af00      	add	r7, sp, #0
 802cf12:	6078      	str	r0, [r7, #4]
  USBH_LL_IncTimer(hhcd->pData);
 802cf14:	687b      	ldr	r3, [r7, #4]
 802cf16:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802cf1a:	4618      	mov	r0, r3
 802cf1c:	f7df fdb1 	bl	800ca82 <USBH_LL_IncTimer>
}
 802cf20:	bf00      	nop
 802cf22:	3708      	adds	r7, #8
 802cf24:	46bd      	mov	sp, r7
 802cf26:	bd80      	pop	{r7, pc}

0802cf28 <HAL_HCD_Connect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
 802cf28:	b580      	push	{r7, lr}
 802cf2a:	b082      	sub	sp, #8
 802cf2c:	af00      	add	r7, sp, #0
 802cf2e:	6078      	str	r0, [r7, #4]
  USBH_LL_Connect(hhcd->pData);
 802cf30:	687b      	ldr	r3, [r7, #4]
 802cf32:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802cf36:	4618      	mov	r0, r3
 802cf38:	f7df fde9 	bl	800cb0e <USBH_LL_Connect>
}
 802cf3c:	bf00      	nop
 802cf3e:	3708      	adds	r7, #8
 802cf40:	46bd      	mov	sp, r7
 802cf42:	bd80      	pop	{r7, pc}

0802cf44 <HAL_HCD_Disconnect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
 802cf44:	b580      	push	{r7, lr}
 802cf46:	b082      	sub	sp, #8
 802cf48:	af00      	add	r7, sp, #0
 802cf4a:	6078      	str	r0, [r7, #4]
  USBH_LL_Disconnect(hhcd->pData);
 802cf4c:	687b      	ldr	r3, [r7, #4]
 802cf4e:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802cf52:	4618      	mov	r0, r3
 802cf54:	f7df fdf2 	bl	800cb3c <USBH_LL_Disconnect>
}
 802cf58:	bf00      	nop
 802cf5a:	3708      	adds	r7, #8
 802cf5c:	46bd      	mov	sp, r7
 802cf5e:	bd80      	pop	{r7, pc}

0802cf60 <HAL_HCD_HC_NotifyURBChange_Callback>:
  * @param  chnum: channel number
  * @param  urb_state: state
  * @retval None
  */
void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
 802cf60:	b480      	push	{r7}
 802cf62:	b083      	sub	sp, #12
 802cf64:	af00      	add	r7, sp, #0
 802cf66:	6078      	str	r0, [r7, #4]
 802cf68:	460b      	mov	r3, r1
 802cf6a:	70fb      	strb	r3, [r7, #3]
 802cf6c:	4613      	mov	r3, r2
 802cf6e:	70bb      	strb	r3, [r7, #2]
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 802cf70:	bf00      	nop
 802cf72:	370c      	adds	r7, #12
 802cf74:	46bd      	mov	sp, r7
 802cf76:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cf7a:	4770      	bx	lr

0802cf7c <HAL_HCD_PortEnabled_Callback>:
* @brief  Port Port Enabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
 802cf7c:	b580      	push	{r7, lr}
 802cf7e:	b082      	sub	sp, #8
 802cf80:	af00      	add	r7, sp, #0
 802cf82:	6078      	str	r0, [r7, #4]
  USBH_LL_PortEnabled(hhcd->pData);
 802cf84:	687b      	ldr	r3, [r7, #4]
 802cf86:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802cf8a:	4618      	mov	r0, r3
 802cf8c:	f7df fda3 	bl	800cad6 <USBH_LL_PortEnabled>
}
 802cf90:	bf00      	nop
 802cf92:	3708      	adds	r7, #8
 802cf94:	46bd      	mov	sp, r7
 802cf96:	bd80      	pop	{r7, pc}

0802cf98 <HAL_HCD_PortDisabled_Callback>:
  * @brief  Port Port Disabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
 802cf98:	b580      	push	{r7, lr}
 802cf9a:	b082      	sub	sp, #8
 802cf9c:	af00      	add	r7, sp, #0
 802cf9e:	6078      	str	r0, [r7, #4]
  USBH_LL_PortDisabled(hhcd->pData);
 802cfa0:	687b      	ldr	r3, [r7, #4]
 802cfa2:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802cfa6:	4618      	mov	r0, r3
 802cfa8:	f7df fda3 	bl	800caf2 <USBH_LL_PortDisabled>
}
 802cfac:	bf00      	nop
 802cfae:	3708      	adds	r7, #8
 802cfb0:	46bd      	mov	sp, r7
 802cfb2:	bd80      	pop	{r7, pc}

0802cfb4 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
 802cfb4:	b580      	push	{r7, lr}
 802cfb6:	b082      	sub	sp, #8
 802cfb8:	af00      	add	r7, sp, #0
 802cfba:	6078      	str	r0, [r7, #4]
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
 802cfbc:	687b      	ldr	r3, [r7, #4]
 802cfbe:	f893 33cc 	ldrb.w	r3, [r3, #972]	@ 0x3cc
 802cfc2:	2b01      	cmp	r3, #1
 802cfc4:	d12a      	bne.n	802d01c <USBH_LL_Init+0x68>
  /* Link the driver to the stack. */
  hhcd_USB_OTG_FS.pData = phost;
 802cfc6:	4a18      	ldr	r2, [pc, #96]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfc8:	687b      	ldr	r3, [r7, #4]
 802cfca:	f8c2 33dc 	str.w	r3, [r2, #988]	@ 0x3dc
  phost->pData = &hhcd_USB_OTG_FS;
 802cfce:	687b      	ldr	r3, [r7, #4]
 802cfd0:	4a15      	ldr	r2, [pc, #84]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfd2:	f8c3 23d0 	str.w	r2, [r3, #976]	@ 0x3d0

  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 802cfd6:	4b14      	ldr	r3, [pc, #80]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfd8:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 802cfdc:	601a      	str	r2, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 8;
 802cfde:	4b12      	ldr	r3, [pc, #72]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfe0:	2208      	movs	r2, #8
 802cfe2:	715a      	strb	r2, [r3, #5]
  hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
 802cfe4:	4b10      	ldr	r3, [pc, #64]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfe6:	2201      	movs	r2, #1
 802cfe8:	71da      	strb	r2, [r3, #7]
  hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 802cfea:	4b0f      	ldr	r3, [pc, #60]	@ (802d028 <USBH_LL_Init+0x74>)
 802cfec:	2200      	movs	r2, #0
 802cfee:	719a      	strb	r2, [r3, #6]
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 802cff0:	4b0d      	ldr	r3, [pc, #52]	@ (802d028 <USBH_LL_Init+0x74>)
 802cff2:	2202      	movs	r2, #2
 802cff4:	725a      	strb	r2, [r3, #9]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 802cff6:	4b0c      	ldr	r3, [pc, #48]	@ (802d028 <USBH_LL_Init+0x74>)
 802cff8:	2200      	movs	r2, #0
 802cffa:	729a      	strb	r2, [r3, #10]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 802cffc:	480a      	ldr	r0, [pc, #40]	@ (802d028 <USBH_LL_Init+0x74>)
 802cffe:	f7d6 ff6d 	bl	8003edc <HAL_HCD_Init>
 802d002:	4603      	mov	r3, r0
 802d004:	2b00      	cmp	r3, #0
 802d006:	d001      	beq.n	802d00c <USBH_LL_Init+0x58>
  {
    Error_Handler( );
 802d008:	f7d4 fab4 	bl	8001574 <Error_Handler>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
 802d00c:	4806      	ldr	r0, [pc, #24]	@ (802d028 <USBH_LL_Init+0x74>)
 802d00e:	f7d7 fbcd 	bl	80047ac <HAL_HCD_GetCurrentFrame>
 802d012:	4603      	mov	r3, r0
 802d014:	4619      	mov	r1, r3
 802d016:	6878      	ldr	r0, [r7, #4]
 802d018:	f7df fd24 	bl	800ca64 <USBH_LL_SetTimer>
  }
  return USBH_OK;
 802d01c:	2300      	movs	r3, #0
}
 802d01e:	4618      	mov	r0, r3
 802d020:	3708      	adds	r7, #8
 802d022:	46bd      	mov	sp, r7
 802d024:	bd80      	pop	{r7, pc}
 802d026:	bf00      	nop
 802d028:	20002cfc 	.word	0x20002cfc

0802d02c <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 802d02c:	b580      	push	{r7, lr}
 802d02e:	b084      	sub	sp, #16
 802d030:	af00      	add	r7, sp, #0
 802d032:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d034:	2300      	movs	r3, #0
 802d036:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d038:	2300      	movs	r3, #0
 802d03a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Start(phost->pData);
 802d03c:	687b      	ldr	r3, [r7, #4]
 802d03e:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d042:	4618      	mov	r0, r3
 802d044:	f7d7 fb3a 	bl	80046bc <HAL_HCD_Start>
 802d048:	4603      	mov	r3, r0
 802d04a:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802d04c:	7bfb      	ldrb	r3, [r7, #15]
 802d04e:	4618      	mov	r0, r3
 802d050:	f000 f992 	bl	802d378 <USBH_Get_USB_Status>
 802d054:	4603      	mov	r3, r0
 802d056:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d058:	7bbb      	ldrb	r3, [r7, #14]
}
 802d05a:	4618      	mov	r0, r3
 802d05c:	3710      	adds	r7, #16
 802d05e:	46bd      	mov	sp, r7
 802d060:	bd80      	pop	{r7, pc}

0802d062 <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 802d062:	b580      	push	{r7, lr}
 802d064:	b084      	sub	sp, #16
 802d066:	af00      	add	r7, sp, #0
 802d068:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d06a:	2300      	movs	r3, #0
 802d06c:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d06e:	2300      	movs	r3, #0
 802d070:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Stop(phost->pData);
 802d072:	687b      	ldr	r3, [r7, #4]
 802d074:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d078:	4618      	mov	r0, r3
 802d07a:	f7d7 fb42 	bl	8004702 <HAL_HCD_Stop>
 802d07e:	4603      	mov	r3, r0
 802d080:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802d082:	7bfb      	ldrb	r3, [r7, #15]
 802d084:	4618      	mov	r0, r3
 802d086:	f000 f977 	bl	802d378 <USBH_Get_USB_Status>
 802d08a:	4603      	mov	r3, r0
 802d08c:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d08e:	7bbb      	ldrb	r3, [r7, #14]
}
 802d090:	4618      	mov	r0, r3
 802d092:	3710      	adds	r7, #16
 802d094:	46bd      	mov	sp, r7
 802d096:	bd80      	pop	{r7, pc}

0802d098 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 802d098:	b580      	push	{r7, lr}
 802d09a:	b084      	sub	sp, #16
 802d09c:	af00      	add	r7, sp, #0
 802d09e:	6078      	str	r0, [r7, #4]
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
 802d0a0:	2301      	movs	r3, #1
 802d0a2:	73fb      	strb	r3, [r7, #15]

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 802d0a4:	687b      	ldr	r3, [r7, #4]
 802d0a6:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d0aa:	4618      	mov	r0, r3
 802d0ac:	f7d7 fb8c 	bl	80047c8 <HAL_HCD_GetCurrentSpeed>
 802d0b0:	4603      	mov	r3, r0
 802d0b2:	2b02      	cmp	r3, #2
 802d0b4:	d00c      	beq.n	802d0d0 <USBH_LL_GetSpeed+0x38>
 802d0b6:	2b02      	cmp	r3, #2
 802d0b8:	d80d      	bhi.n	802d0d6 <USBH_LL_GetSpeed+0x3e>
 802d0ba:	2b00      	cmp	r3, #0
 802d0bc:	d002      	beq.n	802d0c4 <USBH_LL_GetSpeed+0x2c>
 802d0be:	2b01      	cmp	r3, #1
 802d0c0:	d003      	beq.n	802d0ca <USBH_LL_GetSpeed+0x32>
 802d0c2:	e008      	b.n	802d0d6 <USBH_LL_GetSpeed+0x3e>
  {
  case 0 :
    speed = USBH_SPEED_HIGH;
 802d0c4:	2300      	movs	r3, #0
 802d0c6:	73fb      	strb	r3, [r7, #15]
    break;
 802d0c8:	e008      	b.n	802d0dc <USBH_LL_GetSpeed+0x44>

  case 1 :
    speed = USBH_SPEED_FULL;
 802d0ca:	2301      	movs	r3, #1
 802d0cc:	73fb      	strb	r3, [r7, #15]
    break;
 802d0ce:	e005      	b.n	802d0dc <USBH_LL_GetSpeed+0x44>

  case 2 :
    speed = USBH_SPEED_LOW;
 802d0d0:	2302      	movs	r3, #2
 802d0d2:	73fb      	strb	r3, [r7, #15]
    break;
 802d0d4:	e002      	b.n	802d0dc <USBH_LL_GetSpeed+0x44>

  default:
   speed = USBH_SPEED_FULL;
 802d0d6:	2301      	movs	r3, #1
 802d0d8:	73fb      	strb	r3, [r7, #15]
    break;
 802d0da:	bf00      	nop
  }
  return  speed;
 802d0dc:	7bfb      	ldrb	r3, [r7, #15]
}
 802d0de:	4618      	mov	r0, r3
 802d0e0:	3710      	adds	r7, #16
 802d0e2:	46bd      	mov	sp, r7
 802d0e4:	bd80      	pop	{r7, pc}

0802d0e6 <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
 802d0e6:	b580      	push	{r7, lr}
 802d0e8:	b084      	sub	sp, #16
 802d0ea:	af00      	add	r7, sp, #0
 802d0ec:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d0ee:	2300      	movs	r3, #0
 802d0f0:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d0f2:	2300      	movs	r3, #0
 802d0f4:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_ResetPort(phost->pData);
 802d0f6:	687b      	ldr	r3, [r7, #4]
 802d0f8:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d0fc:	4618      	mov	r0, r3
 802d0fe:	f7d7 fb1d 	bl	800473c <HAL_HCD_ResetPort>
 802d102:	4603      	mov	r3, r0
 802d104:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802d106:	7bfb      	ldrb	r3, [r7, #15]
 802d108:	4618      	mov	r0, r3
 802d10a:	f000 f935 	bl	802d378 <USBH_Get_USB_Status>
 802d10e:	4603      	mov	r3, r0
 802d110:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d112:	7bbb      	ldrb	r3, [r7, #14]
}
 802d114:	4618      	mov	r0, r3
 802d116:	3710      	adds	r7, #16
 802d118:	46bd      	mov	sp, r7
 802d11a:	bd80      	pop	{r7, pc}

0802d11c <USBH_LL_GetLastXferSize>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802d11c:	b580      	push	{r7, lr}
 802d11e:	b082      	sub	sp, #8
 802d120:	af00      	add	r7, sp, #0
 802d122:	6078      	str	r0, [r7, #4]
 802d124:	460b      	mov	r3, r1
 802d126:	70fb      	strb	r3, [r7, #3]
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 802d128:	687b      	ldr	r3, [r7, #4]
 802d12a:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d12e:	78fa      	ldrb	r2, [r7, #3]
 802d130:	4611      	mov	r1, r2
 802d132:	4618      	mov	r0, r3
 802d134:	f7d7 fb25 	bl	8004782 <HAL_HCD_HC_GetXferCount>
 802d138:	4603      	mov	r3, r0
}
 802d13a:	4618      	mov	r0, r3
 802d13c:	3708      	adds	r7, #8
 802d13e:	46bd      	mov	sp, r7
 802d140:	bd80      	pop	{r7, pc}

0802d142 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 802d142:	b590      	push	{r4, r7, lr}
 802d144:	b089      	sub	sp, #36	@ 0x24
 802d146:	af04      	add	r7, sp, #16
 802d148:	6078      	str	r0, [r7, #4]
 802d14a:	4608      	mov	r0, r1
 802d14c:	4611      	mov	r1, r2
 802d14e:	461a      	mov	r2, r3
 802d150:	4603      	mov	r3, r0
 802d152:	70fb      	strb	r3, [r7, #3]
 802d154:	460b      	mov	r3, r1
 802d156:	70bb      	strb	r3, [r7, #2]
 802d158:	4613      	mov	r3, r2
 802d15a:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d15c:	2300      	movs	r3, #0
 802d15e:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d160:	2300      	movs	r3, #0
 802d162:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 802d164:	687b      	ldr	r3, [r7, #4]
 802d166:	f8d3 03d0 	ldr.w	r0, [r3, #976]	@ 0x3d0
 802d16a:	787c      	ldrb	r4, [r7, #1]
 802d16c:	78ba      	ldrb	r2, [r7, #2]
 802d16e:	78f9      	ldrb	r1, [r7, #3]
 802d170:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 802d172:	9302      	str	r3, [sp, #8]
 802d174:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 802d178:	9301      	str	r3, [sp, #4]
 802d17a:	f897 3020 	ldrb.w	r3, [r7, #32]
 802d17e:	9300      	str	r3, [sp, #0]
 802d180:	4623      	mov	r3, r4
 802d182:	f7d6 ff12 	bl	8003faa <HAL_HCD_HC_Init>
 802d186:	4603      	mov	r3, r0
 802d188:	73fb      	strb	r3, [r7, #15]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
 802d18a:	7bfb      	ldrb	r3, [r7, #15]
 802d18c:	4618      	mov	r0, r3
 802d18e:	f000 f8f3 	bl	802d378 <USBH_Get_USB_Status>
 802d192:	4603      	mov	r3, r0
 802d194:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d196:	7bbb      	ldrb	r3, [r7, #14]
}
 802d198:	4618      	mov	r0, r3
 802d19a:	3714      	adds	r7, #20
 802d19c:	46bd      	mov	sp, r7
 802d19e:	bd90      	pop	{r4, r7, pc}

0802d1a0 <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802d1a0:	b580      	push	{r7, lr}
 802d1a2:	b084      	sub	sp, #16
 802d1a4:	af00      	add	r7, sp, #0
 802d1a6:	6078      	str	r0, [r7, #4]
 802d1a8:	460b      	mov	r3, r1
 802d1aa:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d1ac:	2300      	movs	r3, #0
 802d1ae:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d1b0:	2300      	movs	r3, #0
 802d1b2:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 802d1b4:	687b      	ldr	r3, [r7, #4]
 802d1b6:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d1ba:	78fa      	ldrb	r2, [r7, #3]
 802d1bc:	4611      	mov	r1, r2
 802d1be:	4618      	mov	r0, r3
 802d1c0:	f7d6 ffab 	bl	800411a <HAL_HCD_HC_Halt>
 802d1c4:	4603      	mov	r3, r0
 802d1c6:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802d1c8:	7bfb      	ldrb	r3, [r7, #15]
 802d1ca:	4618      	mov	r0, r3
 802d1cc:	f000 f8d4 	bl	802d378 <USBH_Get_USB_Status>
 802d1d0:	4603      	mov	r3, r0
 802d1d2:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d1d4:	7bbb      	ldrb	r3, [r7, #14]
}
 802d1d6:	4618      	mov	r0, r3
 802d1d8:	3710      	adds	r7, #16
 802d1da:	46bd      	mov	sp, r7
 802d1dc:	bd80      	pop	{r7, pc}

0802d1de <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
 802d1de:	b590      	push	{r4, r7, lr}
 802d1e0:	b089      	sub	sp, #36	@ 0x24
 802d1e2:	af04      	add	r7, sp, #16
 802d1e4:	6078      	str	r0, [r7, #4]
 802d1e6:	4608      	mov	r0, r1
 802d1e8:	4611      	mov	r1, r2
 802d1ea:	461a      	mov	r2, r3
 802d1ec:	4603      	mov	r3, r0
 802d1ee:	70fb      	strb	r3, [r7, #3]
 802d1f0:	460b      	mov	r3, r1
 802d1f2:	70bb      	strb	r3, [r7, #2]
 802d1f4:	4613      	mov	r3, r2
 802d1f6:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802d1f8:	2300      	movs	r3, #0
 802d1fa:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d1fc:	2300      	movs	r3, #0
 802d1fe:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 802d200:	687b      	ldr	r3, [r7, #4]
 802d202:	f8d3 03d0 	ldr.w	r0, [r3, #976]	@ 0x3d0
 802d206:	787c      	ldrb	r4, [r7, #1]
 802d208:	78ba      	ldrb	r2, [r7, #2]
 802d20a:	78f9      	ldrb	r1, [r7, #3]
 802d20c:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 802d210:	9303      	str	r3, [sp, #12]
 802d212:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 802d214:	9302      	str	r3, [sp, #8]
 802d216:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d218:	9301      	str	r3, [sp, #4]
 802d21a:	f897 3020 	ldrb.w	r3, [r7, #32]
 802d21e:	9300      	str	r3, [sp, #0]
 802d220:	4623      	mov	r3, r4
 802d222:	f7d6 ff9d 	bl	8004160 <HAL_HCD_HC_SubmitRequest>
 802d226:	4603      	mov	r3, r0
 802d228:	73fb      	strb	r3, [r7, #15]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
 802d22a:	7bfb      	ldrb	r3, [r7, #15]
 802d22c:	4618      	mov	r0, r3
 802d22e:	f000 f8a3 	bl	802d378 <USBH_Get_USB_Status>
 802d232:	4603      	mov	r3, r0
 802d234:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802d236:	7bbb      	ldrb	r3, [r7, #14]
}
 802d238:	4618      	mov	r0, r3
 802d23a:	3714      	adds	r7, #20
 802d23c:	46bd      	mov	sp, r7
 802d23e:	bd90      	pop	{r4, r7, pc}

0802d240 <USBH_LL_GetURBState>:
  *            @arg URB_NYET
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802d240:	b580      	push	{r7, lr}
 802d242:	b082      	sub	sp, #8
 802d244:	af00      	add	r7, sp, #0
 802d246:	6078      	str	r0, [r7, #4]
 802d248:	460b      	mov	r3, r1
 802d24a:	70fb      	strb	r3, [r7, #3]
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 802d24c:	687b      	ldr	r3, [r7, #4]
 802d24e:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d252:	78fa      	ldrb	r2, [r7, #3]
 802d254:	4611      	mov	r1, r2
 802d256:	4618      	mov	r0, r3
 802d258:	f7d7 fa7e 	bl	8004758 <HAL_HCD_HC_GetURBState>
 802d25c:	4603      	mov	r3, r0
}
 802d25e:	4618      	mov	r0, r3
 802d260:	3708      	adds	r7, #8
 802d262:	46bd      	mov	sp, r7
 802d264:	bd80      	pop	{r7, pc}

0802d266 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Inactive
  *           1 : VBUS Active
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 802d266:	b580      	push	{r7, lr}
 802d268:	b082      	sub	sp, #8
 802d26a:	af00      	add	r7, sp, #0
 802d26c:	6078      	str	r0, [r7, #4]
 802d26e:	460b      	mov	r3, r1
 802d270:	70fb      	strb	r3, [r7, #3]
  if (phost->id == HOST_FS) {
 802d272:	687b      	ldr	r3, [r7, #4]
 802d274:	f893 33cc 	ldrb.w	r3, [r3, #972]	@ 0x3cc
 802d278:	2b01      	cmp	r3, #1
 802d27a:	d103      	bne.n	802d284 <USBH_LL_DriverVBUS+0x1e>
    MX_DriverVbusFS(state);
 802d27c:	78fb      	ldrb	r3, [r7, #3]
 802d27e:	4618      	mov	r0, r3
 802d280:	f000 f8a6 	bl	802d3d0 <MX_DriverVbusFS>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
 802d284:	20c8      	movs	r0, #200	@ 0xc8
 802d286:	f7d4 fcad 	bl	8001be4 <HAL_Delay>
  return USBH_OK;
 802d28a:	2300      	movs	r3, #0
}
 802d28c:	4618      	mov	r0, r3
 802d28e:	3708      	adds	r7, #8
 802d290:	46bd      	mov	sp, r7
 802d292:	bd80      	pop	{r7, pc}

0802d294 <USBH_LL_SetToggle>:
  * @param  pipe: Pipe index
  * @param  toggle: toggle (0/1)
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
 802d294:	b480      	push	{r7}
 802d296:	b085      	sub	sp, #20
 802d298:	af00      	add	r7, sp, #0
 802d29a:	6078      	str	r0, [r7, #4]
 802d29c:	460b      	mov	r3, r1
 802d29e:	70fb      	strb	r3, [r7, #3]
 802d2a0:	4613      	mov	r3, r2
 802d2a2:	70bb      	strb	r3, [r7, #2]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 802d2a4:	687b      	ldr	r3, [r7, #4]
 802d2a6:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d2aa:	60fb      	str	r3, [r7, #12]

  if(pHandle->hc[pipe].ep_is_in)
 802d2ac:	78fa      	ldrb	r2, [r7, #3]
 802d2ae:	68f9      	ldr	r1, [r7, #12]
 802d2b0:	4613      	mov	r3, r2
 802d2b2:	011b      	lsls	r3, r3, #4
 802d2b4:	1a9b      	subs	r3, r3, r2
 802d2b6:	009b      	lsls	r3, r3, #2
 802d2b8:	440b      	add	r3, r1
 802d2ba:	3317      	adds	r3, #23
 802d2bc:	781b      	ldrb	r3, [r3, #0]
 802d2be:	2b00      	cmp	r3, #0
 802d2c0:	d00a      	beq.n	802d2d8 <USBH_LL_SetToggle+0x44>
  {
    pHandle->hc[pipe].toggle_in = toggle;
 802d2c2:	78fa      	ldrb	r2, [r7, #3]
 802d2c4:	68f9      	ldr	r1, [r7, #12]
 802d2c6:	4613      	mov	r3, r2
 802d2c8:	011b      	lsls	r3, r3, #4
 802d2ca:	1a9b      	subs	r3, r3, r2
 802d2cc:	009b      	lsls	r3, r3, #2
 802d2ce:	440b      	add	r3, r1
 802d2d0:	333c      	adds	r3, #60	@ 0x3c
 802d2d2:	78ba      	ldrb	r2, [r7, #2]
 802d2d4:	701a      	strb	r2, [r3, #0]
 802d2d6:	e009      	b.n	802d2ec <USBH_LL_SetToggle+0x58>
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
 802d2d8:	78fa      	ldrb	r2, [r7, #3]
 802d2da:	68f9      	ldr	r1, [r7, #12]
 802d2dc:	4613      	mov	r3, r2
 802d2de:	011b      	lsls	r3, r3, #4
 802d2e0:	1a9b      	subs	r3, r3, r2
 802d2e2:	009b      	lsls	r3, r3, #2
 802d2e4:	440b      	add	r3, r1
 802d2e6:	333d      	adds	r3, #61	@ 0x3d
 802d2e8:	78ba      	ldrb	r2, [r7, #2]
 802d2ea:	701a      	strb	r2, [r3, #0]
  }

  return USBH_OK;
 802d2ec:	2300      	movs	r3, #0
}
 802d2ee:	4618      	mov	r0, r3
 802d2f0:	3714      	adds	r7, #20
 802d2f2:	46bd      	mov	sp, r7
 802d2f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d2f8:	4770      	bx	lr

0802d2fa <USBH_LL_GetToggle>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval toggle (0/1)
  */
uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802d2fa:	b480      	push	{r7}
 802d2fc:	b085      	sub	sp, #20
 802d2fe:	af00      	add	r7, sp, #0
 802d300:	6078      	str	r0, [r7, #4]
 802d302:	460b      	mov	r3, r1
 802d304:	70fb      	strb	r3, [r7, #3]
  uint8_t toggle = 0;
 802d306:	2300      	movs	r3, #0
 802d308:	73fb      	strb	r3, [r7, #15]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 802d30a:	687b      	ldr	r3, [r7, #4]
 802d30c:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802d310:	60bb      	str	r3, [r7, #8]

  if(pHandle->hc[pipe].ep_is_in)
 802d312:	78fa      	ldrb	r2, [r7, #3]
 802d314:	68b9      	ldr	r1, [r7, #8]
 802d316:	4613      	mov	r3, r2
 802d318:	011b      	lsls	r3, r3, #4
 802d31a:	1a9b      	subs	r3, r3, r2
 802d31c:	009b      	lsls	r3, r3, #2
 802d31e:	440b      	add	r3, r1
 802d320:	3317      	adds	r3, #23
 802d322:	781b      	ldrb	r3, [r3, #0]
 802d324:	2b00      	cmp	r3, #0
 802d326:	d00a      	beq.n	802d33e <USBH_LL_GetToggle+0x44>
  {
    toggle = pHandle->hc[pipe].toggle_in;
 802d328:	78fa      	ldrb	r2, [r7, #3]
 802d32a:	68b9      	ldr	r1, [r7, #8]
 802d32c:	4613      	mov	r3, r2
 802d32e:	011b      	lsls	r3, r3, #4
 802d330:	1a9b      	subs	r3, r3, r2
 802d332:	009b      	lsls	r3, r3, #2
 802d334:	440b      	add	r3, r1
 802d336:	333c      	adds	r3, #60	@ 0x3c
 802d338:	781b      	ldrb	r3, [r3, #0]
 802d33a:	73fb      	strb	r3, [r7, #15]
 802d33c:	e009      	b.n	802d352 <USBH_LL_GetToggle+0x58>
  }
  else
  {
    toggle = pHandle->hc[pipe].toggle_out;
 802d33e:	78fa      	ldrb	r2, [r7, #3]
 802d340:	68b9      	ldr	r1, [r7, #8]
 802d342:	4613      	mov	r3, r2
 802d344:	011b      	lsls	r3, r3, #4
 802d346:	1a9b      	subs	r3, r3, r2
 802d348:	009b      	lsls	r3, r3, #2
 802d34a:	440b      	add	r3, r1
 802d34c:	333d      	adds	r3, #61	@ 0x3d
 802d34e:	781b      	ldrb	r3, [r3, #0]
 802d350:	73fb      	strb	r3, [r7, #15]
  }
  return toggle;
 802d352:	7bfb      	ldrb	r3, [r7, #15]
}
 802d354:	4618      	mov	r0, r3
 802d356:	3714      	adds	r7, #20
 802d358:	46bd      	mov	sp, r7
 802d35a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d35e:	4770      	bx	lr

0802d360 <USBH_Delay>:
  * @brief  Delay routine for the USB Host Library
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
 802d360:	b580      	push	{r7, lr}
 802d362:	b082      	sub	sp, #8
 802d364:	af00      	add	r7, sp, #0
 802d366:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
 802d368:	6878      	ldr	r0, [r7, #4]
 802d36a:	f7d4 fc3b 	bl	8001be4 <HAL_Delay>
}
 802d36e:	bf00      	nop
 802d370:	3708      	adds	r7, #8
 802d372:	46bd      	mov	sp, r7
 802d374:	bd80      	pop	{r7, pc}
	...

0802d378 <USBH_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBH_StatusTypeDef USBH_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 802d378:	b480      	push	{r7}
 802d37a:	b085      	sub	sp, #20
 802d37c:	af00      	add	r7, sp, #0
 802d37e:	4603      	mov	r3, r0
 802d380:	71fb      	strb	r3, [r7, #7]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802d382:	2300      	movs	r3, #0
 802d384:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 802d386:	79fb      	ldrb	r3, [r7, #7]
 802d388:	2b03      	cmp	r3, #3
 802d38a:	d817      	bhi.n	802d3bc <USBH_Get_USB_Status+0x44>
 802d38c:	a201      	add	r2, pc, #4	@ (adr r2, 802d394 <USBH_Get_USB_Status+0x1c>)
 802d38e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802d392:	bf00      	nop
 802d394:	0802d3a5 	.word	0x0802d3a5
 802d398:	0802d3ab 	.word	0x0802d3ab
 802d39c:	0802d3b1 	.word	0x0802d3b1
 802d3a0:	0802d3b7 	.word	0x0802d3b7
  {
    case HAL_OK :
      usb_status = USBH_OK;
 802d3a4:	2300      	movs	r3, #0
 802d3a6:	73fb      	strb	r3, [r7, #15]
    break;
 802d3a8:	e00b      	b.n	802d3c2 <USBH_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBH_FAIL;
 802d3aa:	2302      	movs	r3, #2
 802d3ac:	73fb      	strb	r3, [r7, #15]
    break;
 802d3ae:	e008      	b.n	802d3c2 <USBH_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBH_BUSY;
 802d3b0:	2301      	movs	r3, #1
 802d3b2:	73fb      	strb	r3, [r7, #15]
    break;
 802d3b4:	e005      	b.n	802d3c2 <USBH_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBH_FAIL;
 802d3b6:	2302      	movs	r3, #2
 802d3b8:	73fb      	strb	r3, [r7, #15]
    break;
 802d3ba:	e002      	b.n	802d3c2 <USBH_Get_USB_Status+0x4a>
    default :
      usb_status = USBH_FAIL;
 802d3bc:	2302      	movs	r3, #2
 802d3be:	73fb      	strb	r3, [r7, #15]
    break;
 802d3c0:	bf00      	nop
  }
  return usb_status;
 802d3c2:	7bfb      	ldrb	r3, [r7, #15]
}
 802d3c4:	4618      	mov	r0, r3
 802d3c6:	3714      	adds	r7, #20
 802d3c8:	46bd      	mov	sp, r7
 802d3ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d3ce:	4770      	bx	lr

0802d3d0 <MX_DriverVbusFS>:
  *          This parameter can be one of the these values:
  *           - 1 : VBUS Active
  *           - 0 : VBUS Inactive
  */
void MX_DriverVbusFS(uint8_t state)
{
 802d3d0:	b580      	push	{r7, lr}
 802d3d2:	b084      	sub	sp, #16
 802d3d4:	af00      	add	r7, sp, #0
 802d3d6:	4603      	mov	r3, r0
 802d3d8:	71fb      	strb	r3, [r7, #7]
  uint8_t data = state;
 802d3da:	79fb      	ldrb	r3, [r7, #7]
 802d3dc:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN PREPARE_GPIO_DATA_VBUS_FS */
  if(state == 0)
 802d3de:	79fb      	ldrb	r3, [r7, #7]
 802d3e0:	2b00      	cmp	r3, #0
 802d3e2:	d102      	bne.n	802d3ea <MX_DriverVbusFS+0x1a>
  {
    /* Drive high Charge pump */
    data = RESET;
 802d3e4:	2300      	movs	r3, #0
 802d3e6:	73fb      	strb	r3, [r7, #15]
 802d3e8:	e001      	b.n	802d3ee <MX_DriverVbusFS+0x1e>
  }
  else
  {
    /* Drive low Charge pump */
    data = SET;
 802d3ea:	2301      	movs	r3, #1
 802d3ec:	73fb      	strb	r3, [r7, #15]
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  GPIO_WritePin(GPIOC,GPIO_PIN_0,(FlagStatus)data);
 802d3ee:	7bfb      	ldrb	r3, [r7, #15]
 802d3f0:	461a      	mov	r2, r3
 802d3f2:	2100      	movs	r1, #0
 802d3f4:	4803      	ldr	r0, [pc, #12]	@ (802d404 <MX_DriverVbusFS+0x34>)
 802d3f6:	f7dc fa49 	bl	800988c <GPIO_WritePin>
}
 802d3fa:	bf00      	nop
 802d3fc:	3710      	adds	r7, #16
 802d3fe:	46bd      	mov	sp, r7
 802d400:	bd80      	pop	{r7, pc}
 802d402:	bf00      	nop
 802d404:	40020800 	.word	0x40020800

0802d408 <malloc>:
 802d408:	4b02      	ldr	r3, [pc, #8]	@ (802d414 <malloc+0xc>)
 802d40a:	4601      	mov	r1, r0
 802d40c:	6818      	ldr	r0, [r3, #0]
 802d40e:	f000 b82d 	b.w	802d46c <_malloc_r>
 802d412:	bf00      	nop
 802d414:	20000038 	.word	0x20000038

0802d418 <free>:
 802d418:	4b02      	ldr	r3, [pc, #8]	@ (802d424 <free+0xc>)
 802d41a:	4601      	mov	r1, r0
 802d41c:	6818      	ldr	r0, [r3, #0]
 802d41e:	f000 ba83 	b.w	802d928 <_free_r>
 802d422:	bf00      	nop
 802d424:	20000038 	.word	0x20000038

0802d428 <sbrk_aligned>:
 802d428:	b570      	push	{r4, r5, r6, lr}
 802d42a:	4e0f      	ldr	r6, [pc, #60]	@ (802d468 <sbrk_aligned+0x40>)
 802d42c:	460c      	mov	r4, r1
 802d42e:	6831      	ldr	r1, [r6, #0]
 802d430:	4605      	mov	r5, r0
 802d432:	b911      	cbnz	r1, 802d43a <sbrk_aligned+0x12>
 802d434:	f000 fa1a 	bl	802d86c <_sbrk_r>
 802d438:	6030      	str	r0, [r6, #0]
 802d43a:	4621      	mov	r1, r4
 802d43c:	4628      	mov	r0, r5
 802d43e:	f000 fa15 	bl	802d86c <_sbrk_r>
 802d442:	1c43      	adds	r3, r0, #1
 802d444:	d103      	bne.n	802d44e <sbrk_aligned+0x26>
 802d446:	f04f 34ff 	mov.w	r4, #4294967295
 802d44a:	4620      	mov	r0, r4
 802d44c:	bd70      	pop	{r4, r5, r6, pc}
 802d44e:	1cc4      	adds	r4, r0, #3
 802d450:	f024 0403 	bic.w	r4, r4, #3
 802d454:	42a0      	cmp	r0, r4
 802d456:	d0f8      	beq.n	802d44a <sbrk_aligned+0x22>
 802d458:	1a21      	subs	r1, r4, r0
 802d45a:	4628      	mov	r0, r5
 802d45c:	f000 fa06 	bl	802d86c <_sbrk_r>
 802d460:	3001      	adds	r0, #1
 802d462:	d1f2      	bne.n	802d44a <sbrk_aligned+0x22>
 802d464:	e7ef      	b.n	802d446 <sbrk_aligned+0x1e>
 802d466:	bf00      	nop
 802d468:	200030dc 	.word	0x200030dc

0802d46c <_malloc_r>:
 802d46c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802d470:	1ccd      	adds	r5, r1, #3
 802d472:	f025 0503 	bic.w	r5, r5, #3
 802d476:	3508      	adds	r5, #8
 802d478:	2d0c      	cmp	r5, #12
 802d47a:	bf38      	it	cc
 802d47c:	250c      	movcc	r5, #12
 802d47e:	2d00      	cmp	r5, #0
 802d480:	4606      	mov	r6, r0
 802d482:	db01      	blt.n	802d488 <_malloc_r+0x1c>
 802d484:	42a9      	cmp	r1, r5
 802d486:	d904      	bls.n	802d492 <_malloc_r+0x26>
 802d488:	230c      	movs	r3, #12
 802d48a:	6033      	str	r3, [r6, #0]
 802d48c:	2000      	movs	r0, #0
 802d48e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802d492:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 802d568 <_malloc_r+0xfc>
 802d496:	f000 f869 	bl	802d56c <__malloc_lock>
 802d49a:	f8d8 3000 	ldr.w	r3, [r8]
 802d49e:	461c      	mov	r4, r3
 802d4a0:	bb44      	cbnz	r4, 802d4f4 <_malloc_r+0x88>
 802d4a2:	4629      	mov	r1, r5
 802d4a4:	4630      	mov	r0, r6
 802d4a6:	f7ff ffbf 	bl	802d428 <sbrk_aligned>
 802d4aa:	1c43      	adds	r3, r0, #1
 802d4ac:	4604      	mov	r4, r0
 802d4ae:	d158      	bne.n	802d562 <_malloc_r+0xf6>
 802d4b0:	f8d8 4000 	ldr.w	r4, [r8]
 802d4b4:	4627      	mov	r7, r4
 802d4b6:	2f00      	cmp	r7, #0
 802d4b8:	d143      	bne.n	802d542 <_malloc_r+0xd6>
 802d4ba:	2c00      	cmp	r4, #0
 802d4bc:	d04b      	beq.n	802d556 <_malloc_r+0xea>
 802d4be:	6823      	ldr	r3, [r4, #0]
 802d4c0:	4639      	mov	r1, r7
 802d4c2:	4630      	mov	r0, r6
 802d4c4:	eb04 0903 	add.w	r9, r4, r3
 802d4c8:	f000 f9d0 	bl	802d86c <_sbrk_r>
 802d4cc:	4581      	cmp	r9, r0
 802d4ce:	d142      	bne.n	802d556 <_malloc_r+0xea>
 802d4d0:	6821      	ldr	r1, [r4, #0]
 802d4d2:	1a6d      	subs	r5, r5, r1
 802d4d4:	4629      	mov	r1, r5
 802d4d6:	4630      	mov	r0, r6
 802d4d8:	f7ff ffa6 	bl	802d428 <sbrk_aligned>
 802d4dc:	3001      	adds	r0, #1
 802d4de:	d03a      	beq.n	802d556 <_malloc_r+0xea>
 802d4e0:	6823      	ldr	r3, [r4, #0]
 802d4e2:	442b      	add	r3, r5
 802d4e4:	6023      	str	r3, [r4, #0]
 802d4e6:	f8d8 3000 	ldr.w	r3, [r8]
 802d4ea:	685a      	ldr	r2, [r3, #4]
 802d4ec:	bb62      	cbnz	r2, 802d548 <_malloc_r+0xdc>
 802d4ee:	f8c8 7000 	str.w	r7, [r8]
 802d4f2:	e00f      	b.n	802d514 <_malloc_r+0xa8>
 802d4f4:	6822      	ldr	r2, [r4, #0]
 802d4f6:	1b52      	subs	r2, r2, r5
 802d4f8:	d420      	bmi.n	802d53c <_malloc_r+0xd0>
 802d4fa:	2a0b      	cmp	r2, #11
 802d4fc:	d917      	bls.n	802d52e <_malloc_r+0xc2>
 802d4fe:	1961      	adds	r1, r4, r5
 802d500:	42a3      	cmp	r3, r4
 802d502:	6025      	str	r5, [r4, #0]
 802d504:	bf18      	it	ne
 802d506:	6059      	strne	r1, [r3, #4]
 802d508:	6863      	ldr	r3, [r4, #4]
 802d50a:	bf08      	it	eq
 802d50c:	f8c8 1000 	streq.w	r1, [r8]
 802d510:	5162      	str	r2, [r4, r5]
 802d512:	604b      	str	r3, [r1, #4]
 802d514:	4630      	mov	r0, r6
 802d516:	f000 f82f 	bl	802d578 <__malloc_unlock>
 802d51a:	f104 000b 	add.w	r0, r4, #11
 802d51e:	1d23      	adds	r3, r4, #4
 802d520:	f020 0007 	bic.w	r0, r0, #7
 802d524:	1ac2      	subs	r2, r0, r3
 802d526:	bf1c      	itt	ne
 802d528:	1a1b      	subne	r3, r3, r0
 802d52a:	50a3      	strne	r3, [r4, r2]
 802d52c:	e7af      	b.n	802d48e <_malloc_r+0x22>
 802d52e:	6862      	ldr	r2, [r4, #4]
 802d530:	42a3      	cmp	r3, r4
 802d532:	bf0c      	ite	eq
 802d534:	f8c8 2000 	streq.w	r2, [r8]
 802d538:	605a      	strne	r2, [r3, #4]
 802d53a:	e7eb      	b.n	802d514 <_malloc_r+0xa8>
 802d53c:	4623      	mov	r3, r4
 802d53e:	6864      	ldr	r4, [r4, #4]
 802d540:	e7ae      	b.n	802d4a0 <_malloc_r+0x34>
 802d542:	463c      	mov	r4, r7
 802d544:	687f      	ldr	r7, [r7, #4]
 802d546:	e7b6      	b.n	802d4b6 <_malloc_r+0x4a>
 802d548:	461a      	mov	r2, r3
 802d54a:	685b      	ldr	r3, [r3, #4]
 802d54c:	42a3      	cmp	r3, r4
 802d54e:	d1fb      	bne.n	802d548 <_malloc_r+0xdc>
 802d550:	2300      	movs	r3, #0
 802d552:	6053      	str	r3, [r2, #4]
 802d554:	e7de      	b.n	802d514 <_malloc_r+0xa8>
 802d556:	230c      	movs	r3, #12
 802d558:	6033      	str	r3, [r6, #0]
 802d55a:	4630      	mov	r0, r6
 802d55c:	f000 f80c 	bl	802d578 <__malloc_unlock>
 802d560:	e794      	b.n	802d48c <_malloc_r+0x20>
 802d562:	6005      	str	r5, [r0, #0]
 802d564:	e7d6      	b.n	802d514 <_malloc_r+0xa8>
 802d566:	bf00      	nop
 802d568:	200030e0 	.word	0x200030e0

0802d56c <__malloc_lock>:
 802d56c:	4801      	ldr	r0, [pc, #4]	@ (802d574 <__malloc_lock+0x8>)
 802d56e:	f000 b9ca 	b.w	802d906 <__retarget_lock_acquire_recursive>
 802d572:	bf00      	nop
 802d574:	20003224 	.word	0x20003224

0802d578 <__malloc_unlock>:
 802d578:	4801      	ldr	r0, [pc, #4]	@ (802d580 <__malloc_unlock+0x8>)
 802d57a:	f000 b9c5 	b.w	802d908 <__retarget_lock_release_recursive>
 802d57e:	bf00      	nop
 802d580:	20003224 	.word	0x20003224

0802d584 <std>:
 802d584:	2300      	movs	r3, #0
 802d586:	b510      	push	{r4, lr}
 802d588:	4604      	mov	r4, r0
 802d58a:	e9c0 3300 	strd	r3, r3, [r0]
 802d58e:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802d592:	6083      	str	r3, [r0, #8]
 802d594:	8181      	strh	r1, [r0, #12]
 802d596:	6643      	str	r3, [r0, #100]	@ 0x64
 802d598:	81c2      	strh	r2, [r0, #14]
 802d59a:	6183      	str	r3, [r0, #24]
 802d59c:	4619      	mov	r1, r3
 802d59e:	2208      	movs	r2, #8
 802d5a0:	305c      	adds	r0, #92	@ 0x5c
 802d5a2:	f000 f926 	bl	802d7f2 <memset>
 802d5a6:	4b0d      	ldr	r3, [pc, #52]	@ (802d5dc <std+0x58>)
 802d5a8:	6263      	str	r3, [r4, #36]	@ 0x24
 802d5aa:	4b0d      	ldr	r3, [pc, #52]	@ (802d5e0 <std+0x5c>)
 802d5ac:	62a3      	str	r3, [r4, #40]	@ 0x28
 802d5ae:	4b0d      	ldr	r3, [pc, #52]	@ (802d5e4 <std+0x60>)
 802d5b0:	62e3      	str	r3, [r4, #44]	@ 0x2c
 802d5b2:	4b0d      	ldr	r3, [pc, #52]	@ (802d5e8 <std+0x64>)
 802d5b4:	6323      	str	r3, [r4, #48]	@ 0x30
 802d5b6:	4b0d      	ldr	r3, [pc, #52]	@ (802d5ec <std+0x68>)
 802d5b8:	6224      	str	r4, [r4, #32]
 802d5ba:	429c      	cmp	r4, r3
 802d5bc:	d006      	beq.n	802d5cc <std+0x48>
 802d5be:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 802d5c2:	4294      	cmp	r4, r2
 802d5c4:	d002      	beq.n	802d5cc <std+0x48>
 802d5c6:	33d0      	adds	r3, #208	@ 0xd0
 802d5c8:	429c      	cmp	r4, r3
 802d5ca:	d105      	bne.n	802d5d8 <std+0x54>
 802d5cc:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 802d5d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802d5d4:	f000 b996 	b.w	802d904 <__retarget_lock_init_recursive>
 802d5d8:	bd10      	pop	{r4, pc}
 802d5da:	bf00      	nop
 802d5dc:	0802d76d 	.word	0x0802d76d
 802d5e0:	0802d78f 	.word	0x0802d78f
 802d5e4:	0802d7c7 	.word	0x0802d7c7
 802d5e8:	0802d7eb 	.word	0x0802d7eb
 802d5ec:	200030e4 	.word	0x200030e4

0802d5f0 <stdio_exit_handler>:
 802d5f0:	4a02      	ldr	r2, [pc, #8]	@ (802d5fc <stdio_exit_handler+0xc>)
 802d5f2:	4903      	ldr	r1, [pc, #12]	@ (802d600 <stdio_exit_handler+0x10>)
 802d5f4:	4803      	ldr	r0, [pc, #12]	@ (802d604 <stdio_exit_handler+0x14>)
 802d5f6:	f000 b869 	b.w	802d6cc <_fwalk_sglue>
 802d5fa:	bf00      	nop
 802d5fc:	2000002c 	.word	0x2000002c
 802d600:	0802e315 	.word	0x0802e315
 802d604:	2000003c 	.word	0x2000003c

0802d608 <cleanup_stdio>:
 802d608:	6841      	ldr	r1, [r0, #4]
 802d60a:	4b0c      	ldr	r3, [pc, #48]	@ (802d63c <cleanup_stdio+0x34>)
 802d60c:	4299      	cmp	r1, r3
 802d60e:	b510      	push	{r4, lr}
 802d610:	4604      	mov	r4, r0
 802d612:	d001      	beq.n	802d618 <cleanup_stdio+0x10>
 802d614:	f000 fe7e 	bl	802e314 <_fflush_r>
 802d618:	68a1      	ldr	r1, [r4, #8]
 802d61a:	4b09      	ldr	r3, [pc, #36]	@ (802d640 <cleanup_stdio+0x38>)
 802d61c:	4299      	cmp	r1, r3
 802d61e:	d002      	beq.n	802d626 <cleanup_stdio+0x1e>
 802d620:	4620      	mov	r0, r4
 802d622:	f000 fe77 	bl	802e314 <_fflush_r>
 802d626:	68e1      	ldr	r1, [r4, #12]
 802d628:	4b06      	ldr	r3, [pc, #24]	@ (802d644 <cleanup_stdio+0x3c>)
 802d62a:	4299      	cmp	r1, r3
 802d62c:	d004      	beq.n	802d638 <cleanup_stdio+0x30>
 802d62e:	4620      	mov	r0, r4
 802d630:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802d634:	f000 be6e 	b.w	802e314 <_fflush_r>
 802d638:	bd10      	pop	{r4, pc}
 802d63a:	bf00      	nop
 802d63c:	200030e4 	.word	0x200030e4
 802d640:	2000314c 	.word	0x2000314c
 802d644:	200031b4 	.word	0x200031b4

0802d648 <global_stdio_init.part.0>:
 802d648:	b510      	push	{r4, lr}
 802d64a:	4b0b      	ldr	r3, [pc, #44]	@ (802d678 <global_stdio_init.part.0+0x30>)
 802d64c:	4c0b      	ldr	r4, [pc, #44]	@ (802d67c <global_stdio_init.part.0+0x34>)
 802d64e:	4a0c      	ldr	r2, [pc, #48]	@ (802d680 <global_stdio_init.part.0+0x38>)
 802d650:	601a      	str	r2, [r3, #0]
 802d652:	4620      	mov	r0, r4
 802d654:	2200      	movs	r2, #0
 802d656:	2104      	movs	r1, #4
 802d658:	f7ff ff94 	bl	802d584 <std>
 802d65c:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 802d660:	2201      	movs	r2, #1
 802d662:	2109      	movs	r1, #9
 802d664:	f7ff ff8e 	bl	802d584 <std>
 802d668:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 802d66c:	2202      	movs	r2, #2
 802d66e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802d672:	2112      	movs	r1, #18
 802d674:	f7ff bf86 	b.w	802d584 <std>
 802d678:	2000321c 	.word	0x2000321c
 802d67c:	200030e4 	.word	0x200030e4
 802d680:	0802d5f1 	.word	0x0802d5f1

0802d684 <__sfp_lock_acquire>:
 802d684:	4801      	ldr	r0, [pc, #4]	@ (802d68c <__sfp_lock_acquire+0x8>)
 802d686:	f000 b93e 	b.w	802d906 <__retarget_lock_acquire_recursive>
 802d68a:	bf00      	nop
 802d68c:	20003225 	.word	0x20003225

0802d690 <__sfp_lock_release>:
 802d690:	4801      	ldr	r0, [pc, #4]	@ (802d698 <__sfp_lock_release+0x8>)
 802d692:	f000 b939 	b.w	802d908 <__retarget_lock_release_recursive>
 802d696:	bf00      	nop
 802d698:	20003225 	.word	0x20003225

0802d69c <__sinit>:
 802d69c:	b510      	push	{r4, lr}
 802d69e:	4604      	mov	r4, r0
 802d6a0:	f7ff fff0 	bl	802d684 <__sfp_lock_acquire>
 802d6a4:	6a23      	ldr	r3, [r4, #32]
 802d6a6:	b11b      	cbz	r3, 802d6b0 <__sinit+0x14>
 802d6a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802d6ac:	f7ff bff0 	b.w	802d690 <__sfp_lock_release>
 802d6b0:	4b04      	ldr	r3, [pc, #16]	@ (802d6c4 <__sinit+0x28>)
 802d6b2:	6223      	str	r3, [r4, #32]
 802d6b4:	4b04      	ldr	r3, [pc, #16]	@ (802d6c8 <__sinit+0x2c>)
 802d6b6:	681b      	ldr	r3, [r3, #0]
 802d6b8:	2b00      	cmp	r3, #0
 802d6ba:	d1f5      	bne.n	802d6a8 <__sinit+0xc>
 802d6bc:	f7ff ffc4 	bl	802d648 <global_stdio_init.part.0>
 802d6c0:	e7f2      	b.n	802d6a8 <__sinit+0xc>
 802d6c2:	bf00      	nop
 802d6c4:	0802d609 	.word	0x0802d609
 802d6c8:	2000321c 	.word	0x2000321c

0802d6cc <_fwalk_sglue>:
 802d6cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802d6d0:	4607      	mov	r7, r0
 802d6d2:	4688      	mov	r8, r1
 802d6d4:	4614      	mov	r4, r2
 802d6d6:	2600      	movs	r6, #0
 802d6d8:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 802d6dc:	f1b9 0901 	subs.w	r9, r9, #1
 802d6e0:	d505      	bpl.n	802d6ee <_fwalk_sglue+0x22>
 802d6e2:	6824      	ldr	r4, [r4, #0]
 802d6e4:	2c00      	cmp	r4, #0
 802d6e6:	d1f7      	bne.n	802d6d8 <_fwalk_sglue+0xc>
 802d6e8:	4630      	mov	r0, r6
 802d6ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802d6ee:	89ab      	ldrh	r3, [r5, #12]
 802d6f0:	2b01      	cmp	r3, #1
 802d6f2:	d907      	bls.n	802d704 <_fwalk_sglue+0x38>
 802d6f4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 802d6f8:	3301      	adds	r3, #1
 802d6fa:	d003      	beq.n	802d704 <_fwalk_sglue+0x38>
 802d6fc:	4629      	mov	r1, r5
 802d6fe:	4638      	mov	r0, r7
 802d700:	47c0      	blx	r8
 802d702:	4306      	orrs	r6, r0
 802d704:	3568      	adds	r5, #104	@ 0x68
 802d706:	e7e9      	b.n	802d6dc <_fwalk_sglue+0x10>

0802d708 <iprintf>:
 802d708:	b40f      	push	{r0, r1, r2, r3}
 802d70a:	b507      	push	{r0, r1, r2, lr}
 802d70c:	4906      	ldr	r1, [pc, #24]	@ (802d728 <iprintf+0x20>)
 802d70e:	ab04      	add	r3, sp, #16
 802d710:	6808      	ldr	r0, [r1, #0]
 802d712:	f853 2b04 	ldr.w	r2, [r3], #4
 802d716:	6881      	ldr	r1, [r0, #8]
 802d718:	9301      	str	r3, [sp, #4]
 802d71a:	f000 fad1 	bl	802dcc0 <_vfiprintf_r>
 802d71e:	b003      	add	sp, #12
 802d720:	f85d eb04 	ldr.w	lr, [sp], #4
 802d724:	b004      	add	sp, #16
 802d726:	4770      	bx	lr
 802d728:	20000038 	.word	0x20000038

0802d72c <siprintf>:
 802d72c:	b40e      	push	{r1, r2, r3}
 802d72e:	b500      	push	{lr}
 802d730:	b09c      	sub	sp, #112	@ 0x70
 802d732:	ab1d      	add	r3, sp, #116	@ 0x74
 802d734:	9002      	str	r0, [sp, #8]
 802d736:	9006      	str	r0, [sp, #24]
 802d738:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 802d73c:	4809      	ldr	r0, [pc, #36]	@ (802d764 <siprintf+0x38>)
 802d73e:	9107      	str	r1, [sp, #28]
 802d740:	9104      	str	r1, [sp, #16]
 802d742:	4909      	ldr	r1, [pc, #36]	@ (802d768 <siprintf+0x3c>)
 802d744:	f853 2b04 	ldr.w	r2, [r3], #4
 802d748:	9105      	str	r1, [sp, #20]
 802d74a:	6800      	ldr	r0, [r0, #0]
 802d74c:	9301      	str	r3, [sp, #4]
 802d74e:	a902      	add	r1, sp, #8
 802d750:	f000 f990 	bl	802da74 <_svfiprintf_r>
 802d754:	9b02      	ldr	r3, [sp, #8]
 802d756:	2200      	movs	r2, #0
 802d758:	701a      	strb	r2, [r3, #0]
 802d75a:	b01c      	add	sp, #112	@ 0x70
 802d75c:	f85d eb04 	ldr.w	lr, [sp], #4
 802d760:	b003      	add	sp, #12
 802d762:	4770      	bx	lr
 802d764:	20000038 	.word	0x20000038
 802d768:	ffff0208 	.word	0xffff0208

0802d76c <__sread>:
 802d76c:	b510      	push	{r4, lr}
 802d76e:	460c      	mov	r4, r1
 802d770:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802d774:	f000 f868 	bl	802d848 <_read_r>
 802d778:	2800      	cmp	r0, #0
 802d77a:	bfab      	itete	ge
 802d77c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 802d77e:	89a3      	ldrhlt	r3, [r4, #12]
 802d780:	181b      	addge	r3, r3, r0
 802d782:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 802d786:	bfac      	ite	ge
 802d788:	6563      	strge	r3, [r4, #84]	@ 0x54
 802d78a:	81a3      	strhlt	r3, [r4, #12]
 802d78c:	bd10      	pop	{r4, pc}

0802d78e <__swrite>:
 802d78e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d792:	461f      	mov	r7, r3
 802d794:	898b      	ldrh	r3, [r1, #12]
 802d796:	05db      	lsls	r3, r3, #23
 802d798:	4605      	mov	r5, r0
 802d79a:	460c      	mov	r4, r1
 802d79c:	4616      	mov	r6, r2
 802d79e:	d505      	bpl.n	802d7ac <__swrite+0x1e>
 802d7a0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802d7a4:	2302      	movs	r3, #2
 802d7a6:	2200      	movs	r2, #0
 802d7a8:	f000 f83c 	bl	802d824 <_lseek_r>
 802d7ac:	89a3      	ldrh	r3, [r4, #12]
 802d7ae:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802d7b2:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 802d7b6:	81a3      	strh	r3, [r4, #12]
 802d7b8:	4632      	mov	r2, r6
 802d7ba:	463b      	mov	r3, r7
 802d7bc:	4628      	mov	r0, r5
 802d7be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802d7c2:	f000 b863 	b.w	802d88c <_write_r>

0802d7c6 <__sseek>:
 802d7c6:	b510      	push	{r4, lr}
 802d7c8:	460c      	mov	r4, r1
 802d7ca:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802d7ce:	f000 f829 	bl	802d824 <_lseek_r>
 802d7d2:	1c43      	adds	r3, r0, #1
 802d7d4:	89a3      	ldrh	r3, [r4, #12]
 802d7d6:	bf15      	itete	ne
 802d7d8:	6560      	strne	r0, [r4, #84]	@ 0x54
 802d7da:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 802d7de:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 802d7e2:	81a3      	strheq	r3, [r4, #12]
 802d7e4:	bf18      	it	ne
 802d7e6:	81a3      	strhne	r3, [r4, #12]
 802d7e8:	bd10      	pop	{r4, pc}

0802d7ea <__sclose>:
 802d7ea:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802d7ee:	f000 b809 	b.w	802d804 <_close_r>

0802d7f2 <memset>:
 802d7f2:	4402      	add	r2, r0
 802d7f4:	4603      	mov	r3, r0
 802d7f6:	4293      	cmp	r3, r2
 802d7f8:	d100      	bne.n	802d7fc <memset+0xa>
 802d7fa:	4770      	bx	lr
 802d7fc:	f803 1b01 	strb.w	r1, [r3], #1
 802d800:	e7f9      	b.n	802d7f6 <memset+0x4>
	...

0802d804 <_close_r>:
 802d804:	b538      	push	{r3, r4, r5, lr}
 802d806:	4d06      	ldr	r5, [pc, #24]	@ (802d820 <_close_r+0x1c>)
 802d808:	2300      	movs	r3, #0
 802d80a:	4604      	mov	r4, r0
 802d80c:	4608      	mov	r0, r1
 802d80e:	602b      	str	r3, [r5, #0]
 802d810:	f7d4 f8cf 	bl	80019b2 <_close>
 802d814:	1c43      	adds	r3, r0, #1
 802d816:	d102      	bne.n	802d81e <_close_r+0x1a>
 802d818:	682b      	ldr	r3, [r5, #0]
 802d81a:	b103      	cbz	r3, 802d81e <_close_r+0x1a>
 802d81c:	6023      	str	r3, [r4, #0]
 802d81e:	bd38      	pop	{r3, r4, r5, pc}
 802d820:	20003220 	.word	0x20003220

0802d824 <_lseek_r>:
 802d824:	b538      	push	{r3, r4, r5, lr}
 802d826:	4d07      	ldr	r5, [pc, #28]	@ (802d844 <_lseek_r+0x20>)
 802d828:	4604      	mov	r4, r0
 802d82a:	4608      	mov	r0, r1
 802d82c:	4611      	mov	r1, r2
 802d82e:	2200      	movs	r2, #0
 802d830:	602a      	str	r2, [r5, #0]
 802d832:	461a      	mov	r2, r3
 802d834:	f7d4 f8e4 	bl	8001a00 <_lseek>
 802d838:	1c43      	adds	r3, r0, #1
 802d83a:	d102      	bne.n	802d842 <_lseek_r+0x1e>
 802d83c:	682b      	ldr	r3, [r5, #0]
 802d83e:	b103      	cbz	r3, 802d842 <_lseek_r+0x1e>
 802d840:	6023      	str	r3, [r4, #0]
 802d842:	bd38      	pop	{r3, r4, r5, pc}
 802d844:	20003220 	.word	0x20003220

0802d848 <_read_r>:
 802d848:	b538      	push	{r3, r4, r5, lr}
 802d84a:	4d07      	ldr	r5, [pc, #28]	@ (802d868 <_read_r+0x20>)
 802d84c:	4604      	mov	r4, r0
 802d84e:	4608      	mov	r0, r1
 802d850:	4611      	mov	r1, r2
 802d852:	2200      	movs	r2, #0
 802d854:	602a      	str	r2, [r5, #0]
 802d856:	461a      	mov	r2, r3
 802d858:	f7d4 f872 	bl	8001940 <_read>
 802d85c:	1c43      	adds	r3, r0, #1
 802d85e:	d102      	bne.n	802d866 <_read_r+0x1e>
 802d860:	682b      	ldr	r3, [r5, #0]
 802d862:	b103      	cbz	r3, 802d866 <_read_r+0x1e>
 802d864:	6023      	str	r3, [r4, #0]
 802d866:	bd38      	pop	{r3, r4, r5, pc}
 802d868:	20003220 	.word	0x20003220

0802d86c <_sbrk_r>:
 802d86c:	b538      	push	{r3, r4, r5, lr}
 802d86e:	4d06      	ldr	r5, [pc, #24]	@ (802d888 <_sbrk_r+0x1c>)
 802d870:	2300      	movs	r3, #0
 802d872:	4604      	mov	r4, r0
 802d874:	4608      	mov	r0, r1
 802d876:	602b      	str	r3, [r5, #0]
 802d878:	f7d4 f8d0 	bl	8001a1c <_sbrk>
 802d87c:	1c43      	adds	r3, r0, #1
 802d87e:	d102      	bne.n	802d886 <_sbrk_r+0x1a>
 802d880:	682b      	ldr	r3, [r5, #0]
 802d882:	b103      	cbz	r3, 802d886 <_sbrk_r+0x1a>
 802d884:	6023      	str	r3, [r4, #0]
 802d886:	bd38      	pop	{r3, r4, r5, pc}
 802d888:	20003220 	.word	0x20003220

0802d88c <_write_r>:
 802d88c:	b538      	push	{r3, r4, r5, lr}
 802d88e:	4d07      	ldr	r5, [pc, #28]	@ (802d8ac <_write_r+0x20>)
 802d890:	4604      	mov	r4, r0
 802d892:	4608      	mov	r0, r1
 802d894:	4611      	mov	r1, r2
 802d896:	2200      	movs	r2, #0
 802d898:	602a      	str	r2, [r5, #0]
 802d89a:	461a      	mov	r2, r3
 802d89c:	f7d4 f86d 	bl	800197a <_write>
 802d8a0:	1c43      	adds	r3, r0, #1
 802d8a2:	d102      	bne.n	802d8aa <_write_r+0x1e>
 802d8a4:	682b      	ldr	r3, [r5, #0]
 802d8a6:	b103      	cbz	r3, 802d8aa <_write_r+0x1e>
 802d8a8:	6023      	str	r3, [r4, #0]
 802d8aa:	bd38      	pop	{r3, r4, r5, pc}
 802d8ac:	20003220 	.word	0x20003220

0802d8b0 <__errno>:
 802d8b0:	4b01      	ldr	r3, [pc, #4]	@ (802d8b8 <__errno+0x8>)
 802d8b2:	6818      	ldr	r0, [r3, #0]
 802d8b4:	4770      	bx	lr
 802d8b6:	bf00      	nop
 802d8b8:	20000038 	.word	0x20000038

0802d8bc <__libc_init_array>:
 802d8bc:	b570      	push	{r4, r5, r6, lr}
 802d8be:	4d0d      	ldr	r5, [pc, #52]	@ (802d8f4 <__libc_init_array+0x38>)
 802d8c0:	4c0d      	ldr	r4, [pc, #52]	@ (802d8f8 <__libc_init_array+0x3c>)
 802d8c2:	1b64      	subs	r4, r4, r5
 802d8c4:	10a4      	asrs	r4, r4, #2
 802d8c6:	2600      	movs	r6, #0
 802d8c8:	42a6      	cmp	r6, r4
 802d8ca:	d109      	bne.n	802d8e0 <__libc_init_array+0x24>
 802d8cc:	4d0b      	ldr	r5, [pc, #44]	@ (802d8fc <__libc_init_array+0x40>)
 802d8ce:	4c0c      	ldr	r4, [pc, #48]	@ (802d900 <__libc_init_array+0x44>)
 802d8d0:	f000 feb0 	bl	802e634 <_init>
 802d8d4:	1b64      	subs	r4, r4, r5
 802d8d6:	10a4      	asrs	r4, r4, #2
 802d8d8:	2600      	movs	r6, #0
 802d8da:	42a6      	cmp	r6, r4
 802d8dc:	d105      	bne.n	802d8ea <__libc_init_array+0x2e>
 802d8de:	bd70      	pop	{r4, r5, r6, pc}
 802d8e0:	f855 3b04 	ldr.w	r3, [r5], #4
 802d8e4:	4798      	blx	r3
 802d8e6:	3601      	adds	r6, #1
 802d8e8:	e7ee      	b.n	802d8c8 <__libc_init_array+0xc>
 802d8ea:	f855 3b04 	ldr.w	r3, [r5], #4
 802d8ee:	4798      	blx	r3
 802d8f0:	3601      	adds	r6, #1
 802d8f2:	e7f2      	b.n	802d8da <__libc_init_array+0x1e>
 802d8f4:	08030dd8 	.word	0x08030dd8
 802d8f8:	08030dd8 	.word	0x08030dd8
 802d8fc:	08030dd8 	.word	0x08030dd8
 802d900:	08030ddc 	.word	0x08030ddc

0802d904 <__retarget_lock_init_recursive>:
 802d904:	4770      	bx	lr

0802d906 <__retarget_lock_acquire_recursive>:
 802d906:	4770      	bx	lr

0802d908 <__retarget_lock_release_recursive>:
 802d908:	4770      	bx	lr

0802d90a <memcpy>:
 802d90a:	440a      	add	r2, r1
 802d90c:	4291      	cmp	r1, r2
 802d90e:	f100 33ff 	add.w	r3, r0, #4294967295
 802d912:	d100      	bne.n	802d916 <memcpy+0xc>
 802d914:	4770      	bx	lr
 802d916:	b510      	push	{r4, lr}
 802d918:	f811 4b01 	ldrb.w	r4, [r1], #1
 802d91c:	f803 4f01 	strb.w	r4, [r3, #1]!
 802d920:	4291      	cmp	r1, r2
 802d922:	d1f9      	bne.n	802d918 <memcpy+0xe>
 802d924:	bd10      	pop	{r4, pc}
	...

0802d928 <_free_r>:
 802d928:	b538      	push	{r3, r4, r5, lr}
 802d92a:	4605      	mov	r5, r0
 802d92c:	2900      	cmp	r1, #0
 802d92e:	d041      	beq.n	802d9b4 <_free_r+0x8c>
 802d930:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802d934:	1f0c      	subs	r4, r1, #4
 802d936:	2b00      	cmp	r3, #0
 802d938:	bfb8      	it	lt
 802d93a:	18e4      	addlt	r4, r4, r3
 802d93c:	f7ff fe16 	bl	802d56c <__malloc_lock>
 802d940:	4a1d      	ldr	r2, [pc, #116]	@ (802d9b8 <_free_r+0x90>)
 802d942:	6813      	ldr	r3, [r2, #0]
 802d944:	b933      	cbnz	r3, 802d954 <_free_r+0x2c>
 802d946:	6063      	str	r3, [r4, #4]
 802d948:	6014      	str	r4, [r2, #0]
 802d94a:	4628      	mov	r0, r5
 802d94c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802d950:	f7ff be12 	b.w	802d578 <__malloc_unlock>
 802d954:	42a3      	cmp	r3, r4
 802d956:	d908      	bls.n	802d96a <_free_r+0x42>
 802d958:	6820      	ldr	r0, [r4, #0]
 802d95a:	1821      	adds	r1, r4, r0
 802d95c:	428b      	cmp	r3, r1
 802d95e:	bf01      	itttt	eq
 802d960:	6819      	ldreq	r1, [r3, #0]
 802d962:	685b      	ldreq	r3, [r3, #4]
 802d964:	1809      	addeq	r1, r1, r0
 802d966:	6021      	streq	r1, [r4, #0]
 802d968:	e7ed      	b.n	802d946 <_free_r+0x1e>
 802d96a:	461a      	mov	r2, r3
 802d96c:	685b      	ldr	r3, [r3, #4]
 802d96e:	b10b      	cbz	r3, 802d974 <_free_r+0x4c>
 802d970:	42a3      	cmp	r3, r4
 802d972:	d9fa      	bls.n	802d96a <_free_r+0x42>
 802d974:	6811      	ldr	r1, [r2, #0]
 802d976:	1850      	adds	r0, r2, r1
 802d978:	42a0      	cmp	r0, r4
 802d97a:	d10b      	bne.n	802d994 <_free_r+0x6c>
 802d97c:	6820      	ldr	r0, [r4, #0]
 802d97e:	4401      	add	r1, r0
 802d980:	1850      	adds	r0, r2, r1
 802d982:	4283      	cmp	r3, r0
 802d984:	6011      	str	r1, [r2, #0]
 802d986:	d1e0      	bne.n	802d94a <_free_r+0x22>
 802d988:	6818      	ldr	r0, [r3, #0]
 802d98a:	685b      	ldr	r3, [r3, #4]
 802d98c:	6053      	str	r3, [r2, #4]
 802d98e:	4408      	add	r0, r1
 802d990:	6010      	str	r0, [r2, #0]
 802d992:	e7da      	b.n	802d94a <_free_r+0x22>
 802d994:	d902      	bls.n	802d99c <_free_r+0x74>
 802d996:	230c      	movs	r3, #12
 802d998:	602b      	str	r3, [r5, #0]
 802d99a:	e7d6      	b.n	802d94a <_free_r+0x22>
 802d99c:	6820      	ldr	r0, [r4, #0]
 802d99e:	1821      	adds	r1, r4, r0
 802d9a0:	428b      	cmp	r3, r1
 802d9a2:	bf04      	itt	eq
 802d9a4:	6819      	ldreq	r1, [r3, #0]
 802d9a6:	685b      	ldreq	r3, [r3, #4]
 802d9a8:	6063      	str	r3, [r4, #4]
 802d9aa:	bf04      	itt	eq
 802d9ac:	1809      	addeq	r1, r1, r0
 802d9ae:	6021      	streq	r1, [r4, #0]
 802d9b0:	6054      	str	r4, [r2, #4]
 802d9b2:	e7ca      	b.n	802d94a <_free_r+0x22>
 802d9b4:	bd38      	pop	{r3, r4, r5, pc}
 802d9b6:	bf00      	nop
 802d9b8:	200030e0 	.word	0x200030e0

0802d9bc <__ssputs_r>:
 802d9bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802d9c0:	688e      	ldr	r6, [r1, #8]
 802d9c2:	461f      	mov	r7, r3
 802d9c4:	42be      	cmp	r6, r7
 802d9c6:	680b      	ldr	r3, [r1, #0]
 802d9c8:	4682      	mov	sl, r0
 802d9ca:	460c      	mov	r4, r1
 802d9cc:	4690      	mov	r8, r2
 802d9ce:	d82d      	bhi.n	802da2c <__ssputs_r+0x70>
 802d9d0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802d9d4:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 802d9d8:	d026      	beq.n	802da28 <__ssputs_r+0x6c>
 802d9da:	6965      	ldr	r5, [r4, #20]
 802d9dc:	6909      	ldr	r1, [r1, #16]
 802d9de:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802d9e2:	eba3 0901 	sub.w	r9, r3, r1
 802d9e6:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802d9ea:	1c7b      	adds	r3, r7, #1
 802d9ec:	444b      	add	r3, r9
 802d9ee:	106d      	asrs	r5, r5, #1
 802d9f0:	429d      	cmp	r5, r3
 802d9f2:	bf38      	it	cc
 802d9f4:	461d      	movcc	r5, r3
 802d9f6:	0553      	lsls	r3, r2, #21
 802d9f8:	d527      	bpl.n	802da4a <__ssputs_r+0x8e>
 802d9fa:	4629      	mov	r1, r5
 802d9fc:	f7ff fd36 	bl	802d46c <_malloc_r>
 802da00:	4606      	mov	r6, r0
 802da02:	b360      	cbz	r0, 802da5e <__ssputs_r+0xa2>
 802da04:	6921      	ldr	r1, [r4, #16]
 802da06:	464a      	mov	r2, r9
 802da08:	f7ff ff7f 	bl	802d90a <memcpy>
 802da0c:	89a3      	ldrh	r3, [r4, #12]
 802da0e:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 802da12:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802da16:	81a3      	strh	r3, [r4, #12]
 802da18:	6126      	str	r6, [r4, #16]
 802da1a:	6165      	str	r5, [r4, #20]
 802da1c:	444e      	add	r6, r9
 802da1e:	eba5 0509 	sub.w	r5, r5, r9
 802da22:	6026      	str	r6, [r4, #0]
 802da24:	60a5      	str	r5, [r4, #8]
 802da26:	463e      	mov	r6, r7
 802da28:	42be      	cmp	r6, r7
 802da2a:	d900      	bls.n	802da2e <__ssputs_r+0x72>
 802da2c:	463e      	mov	r6, r7
 802da2e:	6820      	ldr	r0, [r4, #0]
 802da30:	4632      	mov	r2, r6
 802da32:	4641      	mov	r1, r8
 802da34:	f000 fd2a 	bl	802e48c <memmove>
 802da38:	68a3      	ldr	r3, [r4, #8]
 802da3a:	1b9b      	subs	r3, r3, r6
 802da3c:	60a3      	str	r3, [r4, #8]
 802da3e:	6823      	ldr	r3, [r4, #0]
 802da40:	4433      	add	r3, r6
 802da42:	6023      	str	r3, [r4, #0]
 802da44:	2000      	movs	r0, #0
 802da46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802da4a:	462a      	mov	r2, r5
 802da4c:	f000 fd38 	bl	802e4c0 <_realloc_r>
 802da50:	4606      	mov	r6, r0
 802da52:	2800      	cmp	r0, #0
 802da54:	d1e0      	bne.n	802da18 <__ssputs_r+0x5c>
 802da56:	6921      	ldr	r1, [r4, #16]
 802da58:	4650      	mov	r0, sl
 802da5a:	f7ff ff65 	bl	802d928 <_free_r>
 802da5e:	230c      	movs	r3, #12
 802da60:	f8ca 3000 	str.w	r3, [sl]
 802da64:	89a3      	ldrh	r3, [r4, #12]
 802da66:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802da6a:	81a3      	strh	r3, [r4, #12]
 802da6c:	f04f 30ff 	mov.w	r0, #4294967295
 802da70:	e7e9      	b.n	802da46 <__ssputs_r+0x8a>
	...

0802da74 <_svfiprintf_r>:
 802da74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802da78:	4698      	mov	r8, r3
 802da7a:	898b      	ldrh	r3, [r1, #12]
 802da7c:	061b      	lsls	r3, r3, #24
 802da7e:	b09d      	sub	sp, #116	@ 0x74
 802da80:	4607      	mov	r7, r0
 802da82:	460d      	mov	r5, r1
 802da84:	4614      	mov	r4, r2
 802da86:	d510      	bpl.n	802daaa <_svfiprintf_r+0x36>
 802da88:	690b      	ldr	r3, [r1, #16]
 802da8a:	b973      	cbnz	r3, 802daaa <_svfiprintf_r+0x36>
 802da8c:	2140      	movs	r1, #64	@ 0x40
 802da8e:	f7ff fced 	bl	802d46c <_malloc_r>
 802da92:	6028      	str	r0, [r5, #0]
 802da94:	6128      	str	r0, [r5, #16]
 802da96:	b930      	cbnz	r0, 802daa6 <_svfiprintf_r+0x32>
 802da98:	230c      	movs	r3, #12
 802da9a:	603b      	str	r3, [r7, #0]
 802da9c:	f04f 30ff 	mov.w	r0, #4294967295
 802daa0:	b01d      	add	sp, #116	@ 0x74
 802daa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802daa6:	2340      	movs	r3, #64	@ 0x40
 802daa8:	616b      	str	r3, [r5, #20]
 802daaa:	2300      	movs	r3, #0
 802daac:	9309      	str	r3, [sp, #36]	@ 0x24
 802daae:	2320      	movs	r3, #32
 802dab0:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802dab4:	f8cd 800c 	str.w	r8, [sp, #12]
 802dab8:	2330      	movs	r3, #48	@ 0x30
 802daba:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 802dc58 <_svfiprintf_r+0x1e4>
 802dabe:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 802dac2:	f04f 0901 	mov.w	r9, #1
 802dac6:	4623      	mov	r3, r4
 802dac8:	469a      	mov	sl, r3
 802daca:	f813 2b01 	ldrb.w	r2, [r3], #1
 802dace:	b10a      	cbz	r2, 802dad4 <_svfiprintf_r+0x60>
 802dad0:	2a25      	cmp	r2, #37	@ 0x25
 802dad2:	d1f9      	bne.n	802dac8 <_svfiprintf_r+0x54>
 802dad4:	ebba 0b04 	subs.w	fp, sl, r4
 802dad8:	d00b      	beq.n	802daf2 <_svfiprintf_r+0x7e>
 802dada:	465b      	mov	r3, fp
 802dadc:	4622      	mov	r2, r4
 802dade:	4629      	mov	r1, r5
 802dae0:	4638      	mov	r0, r7
 802dae2:	f7ff ff6b 	bl	802d9bc <__ssputs_r>
 802dae6:	3001      	adds	r0, #1
 802dae8:	f000 80a7 	beq.w	802dc3a <_svfiprintf_r+0x1c6>
 802daec:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802daee:	445a      	add	r2, fp
 802daf0:	9209      	str	r2, [sp, #36]	@ 0x24
 802daf2:	f89a 3000 	ldrb.w	r3, [sl]
 802daf6:	2b00      	cmp	r3, #0
 802daf8:	f000 809f 	beq.w	802dc3a <_svfiprintf_r+0x1c6>
 802dafc:	2300      	movs	r3, #0
 802dafe:	f04f 32ff 	mov.w	r2, #4294967295
 802db02:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802db06:	f10a 0a01 	add.w	sl, sl, #1
 802db0a:	9304      	str	r3, [sp, #16]
 802db0c:	9307      	str	r3, [sp, #28]
 802db0e:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 802db12:	931a      	str	r3, [sp, #104]	@ 0x68
 802db14:	4654      	mov	r4, sl
 802db16:	2205      	movs	r2, #5
 802db18:	f814 1b01 	ldrb.w	r1, [r4], #1
 802db1c:	484e      	ldr	r0, [pc, #312]	@ (802dc58 <_svfiprintf_r+0x1e4>)
 802db1e:	f7d2 fb57 	bl	80001d0 <memchr>
 802db22:	9a04      	ldr	r2, [sp, #16]
 802db24:	b9d8      	cbnz	r0, 802db5e <_svfiprintf_r+0xea>
 802db26:	06d0      	lsls	r0, r2, #27
 802db28:	bf44      	itt	mi
 802db2a:	2320      	movmi	r3, #32
 802db2c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802db30:	0711      	lsls	r1, r2, #28
 802db32:	bf44      	itt	mi
 802db34:	232b      	movmi	r3, #43	@ 0x2b
 802db36:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802db3a:	f89a 3000 	ldrb.w	r3, [sl]
 802db3e:	2b2a      	cmp	r3, #42	@ 0x2a
 802db40:	d015      	beq.n	802db6e <_svfiprintf_r+0xfa>
 802db42:	9a07      	ldr	r2, [sp, #28]
 802db44:	4654      	mov	r4, sl
 802db46:	2000      	movs	r0, #0
 802db48:	f04f 0c0a 	mov.w	ip, #10
 802db4c:	4621      	mov	r1, r4
 802db4e:	f811 3b01 	ldrb.w	r3, [r1], #1
 802db52:	3b30      	subs	r3, #48	@ 0x30
 802db54:	2b09      	cmp	r3, #9
 802db56:	d94b      	bls.n	802dbf0 <_svfiprintf_r+0x17c>
 802db58:	b1b0      	cbz	r0, 802db88 <_svfiprintf_r+0x114>
 802db5a:	9207      	str	r2, [sp, #28]
 802db5c:	e014      	b.n	802db88 <_svfiprintf_r+0x114>
 802db5e:	eba0 0308 	sub.w	r3, r0, r8
 802db62:	fa09 f303 	lsl.w	r3, r9, r3
 802db66:	4313      	orrs	r3, r2
 802db68:	9304      	str	r3, [sp, #16]
 802db6a:	46a2      	mov	sl, r4
 802db6c:	e7d2      	b.n	802db14 <_svfiprintf_r+0xa0>
 802db6e:	9b03      	ldr	r3, [sp, #12]
 802db70:	1d19      	adds	r1, r3, #4
 802db72:	681b      	ldr	r3, [r3, #0]
 802db74:	9103      	str	r1, [sp, #12]
 802db76:	2b00      	cmp	r3, #0
 802db78:	bfbb      	ittet	lt
 802db7a:	425b      	neglt	r3, r3
 802db7c:	f042 0202 	orrlt.w	r2, r2, #2
 802db80:	9307      	strge	r3, [sp, #28]
 802db82:	9307      	strlt	r3, [sp, #28]
 802db84:	bfb8      	it	lt
 802db86:	9204      	strlt	r2, [sp, #16]
 802db88:	7823      	ldrb	r3, [r4, #0]
 802db8a:	2b2e      	cmp	r3, #46	@ 0x2e
 802db8c:	d10a      	bne.n	802dba4 <_svfiprintf_r+0x130>
 802db8e:	7863      	ldrb	r3, [r4, #1]
 802db90:	2b2a      	cmp	r3, #42	@ 0x2a
 802db92:	d132      	bne.n	802dbfa <_svfiprintf_r+0x186>
 802db94:	9b03      	ldr	r3, [sp, #12]
 802db96:	1d1a      	adds	r2, r3, #4
 802db98:	681b      	ldr	r3, [r3, #0]
 802db9a:	9203      	str	r2, [sp, #12]
 802db9c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802dba0:	3402      	adds	r4, #2
 802dba2:	9305      	str	r3, [sp, #20]
 802dba4:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 802dc68 <_svfiprintf_r+0x1f4>
 802dba8:	7821      	ldrb	r1, [r4, #0]
 802dbaa:	2203      	movs	r2, #3
 802dbac:	4650      	mov	r0, sl
 802dbae:	f7d2 fb0f 	bl	80001d0 <memchr>
 802dbb2:	b138      	cbz	r0, 802dbc4 <_svfiprintf_r+0x150>
 802dbb4:	9b04      	ldr	r3, [sp, #16]
 802dbb6:	eba0 000a 	sub.w	r0, r0, sl
 802dbba:	2240      	movs	r2, #64	@ 0x40
 802dbbc:	4082      	lsls	r2, r0
 802dbbe:	4313      	orrs	r3, r2
 802dbc0:	3401      	adds	r4, #1
 802dbc2:	9304      	str	r3, [sp, #16]
 802dbc4:	f814 1b01 	ldrb.w	r1, [r4], #1
 802dbc8:	4824      	ldr	r0, [pc, #144]	@ (802dc5c <_svfiprintf_r+0x1e8>)
 802dbca:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802dbce:	2206      	movs	r2, #6
 802dbd0:	f7d2 fafe 	bl	80001d0 <memchr>
 802dbd4:	2800      	cmp	r0, #0
 802dbd6:	d036      	beq.n	802dc46 <_svfiprintf_r+0x1d2>
 802dbd8:	4b21      	ldr	r3, [pc, #132]	@ (802dc60 <_svfiprintf_r+0x1ec>)
 802dbda:	bb1b      	cbnz	r3, 802dc24 <_svfiprintf_r+0x1b0>
 802dbdc:	9b03      	ldr	r3, [sp, #12]
 802dbde:	3307      	adds	r3, #7
 802dbe0:	f023 0307 	bic.w	r3, r3, #7
 802dbe4:	3308      	adds	r3, #8
 802dbe6:	9303      	str	r3, [sp, #12]
 802dbe8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802dbea:	4433      	add	r3, r6
 802dbec:	9309      	str	r3, [sp, #36]	@ 0x24
 802dbee:	e76a      	b.n	802dac6 <_svfiprintf_r+0x52>
 802dbf0:	fb0c 3202 	mla	r2, ip, r2, r3
 802dbf4:	460c      	mov	r4, r1
 802dbf6:	2001      	movs	r0, #1
 802dbf8:	e7a8      	b.n	802db4c <_svfiprintf_r+0xd8>
 802dbfa:	2300      	movs	r3, #0
 802dbfc:	3401      	adds	r4, #1
 802dbfe:	9305      	str	r3, [sp, #20]
 802dc00:	4619      	mov	r1, r3
 802dc02:	f04f 0c0a 	mov.w	ip, #10
 802dc06:	4620      	mov	r0, r4
 802dc08:	f810 2b01 	ldrb.w	r2, [r0], #1
 802dc0c:	3a30      	subs	r2, #48	@ 0x30
 802dc0e:	2a09      	cmp	r2, #9
 802dc10:	d903      	bls.n	802dc1a <_svfiprintf_r+0x1a6>
 802dc12:	2b00      	cmp	r3, #0
 802dc14:	d0c6      	beq.n	802dba4 <_svfiprintf_r+0x130>
 802dc16:	9105      	str	r1, [sp, #20]
 802dc18:	e7c4      	b.n	802dba4 <_svfiprintf_r+0x130>
 802dc1a:	fb0c 2101 	mla	r1, ip, r1, r2
 802dc1e:	4604      	mov	r4, r0
 802dc20:	2301      	movs	r3, #1
 802dc22:	e7f0      	b.n	802dc06 <_svfiprintf_r+0x192>
 802dc24:	ab03      	add	r3, sp, #12
 802dc26:	9300      	str	r3, [sp, #0]
 802dc28:	462a      	mov	r2, r5
 802dc2a:	4b0e      	ldr	r3, [pc, #56]	@ (802dc64 <_svfiprintf_r+0x1f0>)
 802dc2c:	a904      	add	r1, sp, #16
 802dc2e:	4638      	mov	r0, r7
 802dc30:	f3af 8000 	nop.w
 802dc34:	1c42      	adds	r2, r0, #1
 802dc36:	4606      	mov	r6, r0
 802dc38:	d1d6      	bne.n	802dbe8 <_svfiprintf_r+0x174>
 802dc3a:	89ab      	ldrh	r3, [r5, #12]
 802dc3c:	065b      	lsls	r3, r3, #25
 802dc3e:	f53f af2d 	bmi.w	802da9c <_svfiprintf_r+0x28>
 802dc42:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802dc44:	e72c      	b.n	802daa0 <_svfiprintf_r+0x2c>
 802dc46:	ab03      	add	r3, sp, #12
 802dc48:	9300      	str	r3, [sp, #0]
 802dc4a:	462a      	mov	r2, r5
 802dc4c:	4b05      	ldr	r3, [pc, #20]	@ (802dc64 <_svfiprintf_r+0x1f0>)
 802dc4e:	a904      	add	r1, sp, #16
 802dc50:	4638      	mov	r0, r7
 802dc52:	f000 f9bb 	bl	802dfcc <_printf_i>
 802dc56:	e7ed      	b.n	802dc34 <_svfiprintf_r+0x1c0>
 802dc58:	08030d9c 	.word	0x08030d9c
 802dc5c:	08030da6 	.word	0x08030da6
 802dc60:	00000000 	.word	0x00000000
 802dc64:	0802d9bd 	.word	0x0802d9bd
 802dc68:	08030da2 	.word	0x08030da2

0802dc6c <__sfputc_r>:
 802dc6c:	6893      	ldr	r3, [r2, #8]
 802dc6e:	3b01      	subs	r3, #1
 802dc70:	2b00      	cmp	r3, #0
 802dc72:	b410      	push	{r4}
 802dc74:	6093      	str	r3, [r2, #8]
 802dc76:	da08      	bge.n	802dc8a <__sfputc_r+0x1e>
 802dc78:	6994      	ldr	r4, [r2, #24]
 802dc7a:	42a3      	cmp	r3, r4
 802dc7c:	db01      	blt.n	802dc82 <__sfputc_r+0x16>
 802dc7e:	290a      	cmp	r1, #10
 802dc80:	d103      	bne.n	802dc8a <__sfputc_r+0x1e>
 802dc82:	f85d 4b04 	ldr.w	r4, [sp], #4
 802dc86:	f000 bb6d 	b.w	802e364 <__swbuf_r>
 802dc8a:	6813      	ldr	r3, [r2, #0]
 802dc8c:	1c58      	adds	r0, r3, #1
 802dc8e:	6010      	str	r0, [r2, #0]
 802dc90:	7019      	strb	r1, [r3, #0]
 802dc92:	4608      	mov	r0, r1
 802dc94:	f85d 4b04 	ldr.w	r4, [sp], #4
 802dc98:	4770      	bx	lr

0802dc9a <__sfputs_r>:
 802dc9a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802dc9c:	4606      	mov	r6, r0
 802dc9e:	460f      	mov	r7, r1
 802dca0:	4614      	mov	r4, r2
 802dca2:	18d5      	adds	r5, r2, r3
 802dca4:	42ac      	cmp	r4, r5
 802dca6:	d101      	bne.n	802dcac <__sfputs_r+0x12>
 802dca8:	2000      	movs	r0, #0
 802dcaa:	e007      	b.n	802dcbc <__sfputs_r+0x22>
 802dcac:	f814 1b01 	ldrb.w	r1, [r4], #1
 802dcb0:	463a      	mov	r2, r7
 802dcb2:	4630      	mov	r0, r6
 802dcb4:	f7ff ffda 	bl	802dc6c <__sfputc_r>
 802dcb8:	1c43      	adds	r3, r0, #1
 802dcba:	d1f3      	bne.n	802dca4 <__sfputs_r+0xa>
 802dcbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0802dcc0 <_vfiprintf_r>:
 802dcc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802dcc4:	460d      	mov	r5, r1
 802dcc6:	b09d      	sub	sp, #116	@ 0x74
 802dcc8:	4614      	mov	r4, r2
 802dcca:	4698      	mov	r8, r3
 802dccc:	4606      	mov	r6, r0
 802dcce:	b118      	cbz	r0, 802dcd8 <_vfiprintf_r+0x18>
 802dcd0:	6a03      	ldr	r3, [r0, #32]
 802dcd2:	b90b      	cbnz	r3, 802dcd8 <_vfiprintf_r+0x18>
 802dcd4:	f7ff fce2 	bl	802d69c <__sinit>
 802dcd8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802dcda:	07d9      	lsls	r1, r3, #31
 802dcdc:	d405      	bmi.n	802dcea <_vfiprintf_r+0x2a>
 802dcde:	89ab      	ldrh	r3, [r5, #12]
 802dce0:	059a      	lsls	r2, r3, #22
 802dce2:	d402      	bmi.n	802dcea <_vfiprintf_r+0x2a>
 802dce4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802dce6:	f7ff fe0e 	bl	802d906 <__retarget_lock_acquire_recursive>
 802dcea:	89ab      	ldrh	r3, [r5, #12]
 802dcec:	071b      	lsls	r3, r3, #28
 802dcee:	d501      	bpl.n	802dcf4 <_vfiprintf_r+0x34>
 802dcf0:	692b      	ldr	r3, [r5, #16]
 802dcf2:	b99b      	cbnz	r3, 802dd1c <_vfiprintf_r+0x5c>
 802dcf4:	4629      	mov	r1, r5
 802dcf6:	4630      	mov	r0, r6
 802dcf8:	f000 fb72 	bl	802e3e0 <__swsetup_r>
 802dcfc:	b170      	cbz	r0, 802dd1c <_vfiprintf_r+0x5c>
 802dcfe:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802dd00:	07dc      	lsls	r4, r3, #31
 802dd02:	d504      	bpl.n	802dd0e <_vfiprintf_r+0x4e>
 802dd04:	f04f 30ff 	mov.w	r0, #4294967295
 802dd08:	b01d      	add	sp, #116	@ 0x74
 802dd0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802dd0e:	89ab      	ldrh	r3, [r5, #12]
 802dd10:	0598      	lsls	r0, r3, #22
 802dd12:	d4f7      	bmi.n	802dd04 <_vfiprintf_r+0x44>
 802dd14:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802dd16:	f7ff fdf7 	bl	802d908 <__retarget_lock_release_recursive>
 802dd1a:	e7f3      	b.n	802dd04 <_vfiprintf_r+0x44>
 802dd1c:	2300      	movs	r3, #0
 802dd1e:	9309      	str	r3, [sp, #36]	@ 0x24
 802dd20:	2320      	movs	r3, #32
 802dd22:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802dd26:	f8cd 800c 	str.w	r8, [sp, #12]
 802dd2a:	2330      	movs	r3, #48	@ 0x30
 802dd2c:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 802dedc <_vfiprintf_r+0x21c>
 802dd30:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 802dd34:	f04f 0901 	mov.w	r9, #1
 802dd38:	4623      	mov	r3, r4
 802dd3a:	469a      	mov	sl, r3
 802dd3c:	f813 2b01 	ldrb.w	r2, [r3], #1
 802dd40:	b10a      	cbz	r2, 802dd46 <_vfiprintf_r+0x86>
 802dd42:	2a25      	cmp	r2, #37	@ 0x25
 802dd44:	d1f9      	bne.n	802dd3a <_vfiprintf_r+0x7a>
 802dd46:	ebba 0b04 	subs.w	fp, sl, r4
 802dd4a:	d00b      	beq.n	802dd64 <_vfiprintf_r+0xa4>
 802dd4c:	465b      	mov	r3, fp
 802dd4e:	4622      	mov	r2, r4
 802dd50:	4629      	mov	r1, r5
 802dd52:	4630      	mov	r0, r6
 802dd54:	f7ff ffa1 	bl	802dc9a <__sfputs_r>
 802dd58:	3001      	adds	r0, #1
 802dd5a:	f000 80a7 	beq.w	802deac <_vfiprintf_r+0x1ec>
 802dd5e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802dd60:	445a      	add	r2, fp
 802dd62:	9209      	str	r2, [sp, #36]	@ 0x24
 802dd64:	f89a 3000 	ldrb.w	r3, [sl]
 802dd68:	2b00      	cmp	r3, #0
 802dd6a:	f000 809f 	beq.w	802deac <_vfiprintf_r+0x1ec>
 802dd6e:	2300      	movs	r3, #0
 802dd70:	f04f 32ff 	mov.w	r2, #4294967295
 802dd74:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802dd78:	f10a 0a01 	add.w	sl, sl, #1
 802dd7c:	9304      	str	r3, [sp, #16]
 802dd7e:	9307      	str	r3, [sp, #28]
 802dd80:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 802dd84:	931a      	str	r3, [sp, #104]	@ 0x68
 802dd86:	4654      	mov	r4, sl
 802dd88:	2205      	movs	r2, #5
 802dd8a:	f814 1b01 	ldrb.w	r1, [r4], #1
 802dd8e:	4853      	ldr	r0, [pc, #332]	@ (802dedc <_vfiprintf_r+0x21c>)
 802dd90:	f7d2 fa1e 	bl	80001d0 <memchr>
 802dd94:	9a04      	ldr	r2, [sp, #16]
 802dd96:	b9d8      	cbnz	r0, 802ddd0 <_vfiprintf_r+0x110>
 802dd98:	06d1      	lsls	r1, r2, #27
 802dd9a:	bf44      	itt	mi
 802dd9c:	2320      	movmi	r3, #32
 802dd9e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802dda2:	0713      	lsls	r3, r2, #28
 802dda4:	bf44      	itt	mi
 802dda6:	232b      	movmi	r3, #43	@ 0x2b
 802dda8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802ddac:	f89a 3000 	ldrb.w	r3, [sl]
 802ddb0:	2b2a      	cmp	r3, #42	@ 0x2a
 802ddb2:	d015      	beq.n	802dde0 <_vfiprintf_r+0x120>
 802ddb4:	9a07      	ldr	r2, [sp, #28]
 802ddb6:	4654      	mov	r4, sl
 802ddb8:	2000      	movs	r0, #0
 802ddba:	f04f 0c0a 	mov.w	ip, #10
 802ddbe:	4621      	mov	r1, r4
 802ddc0:	f811 3b01 	ldrb.w	r3, [r1], #1
 802ddc4:	3b30      	subs	r3, #48	@ 0x30
 802ddc6:	2b09      	cmp	r3, #9
 802ddc8:	d94b      	bls.n	802de62 <_vfiprintf_r+0x1a2>
 802ddca:	b1b0      	cbz	r0, 802ddfa <_vfiprintf_r+0x13a>
 802ddcc:	9207      	str	r2, [sp, #28]
 802ddce:	e014      	b.n	802ddfa <_vfiprintf_r+0x13a>
 802ddd0:	eba0 0308 	sub.w	r3, r0, r8
 802ddd4:	fa09 f303 	lsl.w	r3, r9, r3
 802ddd8:	4313      	orrs	r3, r2
 802ddda:	9304      	str	r3, [sp, #16]
 802dddc:	46a2      	mov	sl, r4
 802ddde:	e7d2      	b.n	802dd86 <_vfiprintf_r+0xc6>
 802dde0:	9b03      	ldr	r3, [sp, #12]
 802dde2:	1d19      	adds	r1, r3, #4
 802dde4:	681b      	ldr	r3, [r3, #0]
 802dde6:	9103      	str	r1, [sp, #12]
 802dde8:	2b00      	cmp	r3, #0
 802ddea:	bfbb      	ittet	lt
 802ddec:	425b      	neglt	r3, r3
 802ddee:	f042 0202 	orrlt.w	r2, r2, #2
 802ddf2:	9307      	strge	r3, [sp, #28]
 802ddf4:	9307      	strlt	r3, [sp, #28]
 802ddf6:	bfb8      	it	lt
 802ddf8:	9204      	strlt	r2, [sp, #16]
 802ddfa:	7823      	ldrb	r3, [r4, #0]
 802ddfc:	2b2e      	cmp	r3, #46	@ 0x2e
 802ddfe:	d10a      	bne.n	802de16 <_vfiprintf_r+0x156>
 802de00:	7863      	ldrb	r3, [r4, #1]
 802de02:	2b2a      	cmp	r3, #42	@ 0x2a
 802de04:	d132      	bne.n	802de6c <_vfiprintf_r+0x1ac>
 802de06:	9b03      	ldr	r3, [sp, #12]
 802de08:	1d1a      	adds	r2, r3, #4
 802de0a:	681b      	ldr	r3, [r3, #0]
 802de0c:	9203      	str	r2, [sp, #12]
 802de0e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802de12:	3402      	adds	r4, #2
 802de14:	9305      	str	r3, [sp, #20]
 802de16:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 802deec <_vfiprintf_r+0x22c>
 802de1a:	7821      	ldrb	r1, [r4, #0]
 802de1c:	2203      	movs	r2, #3
 802de1e:	4650      	mov	r0, sl
 802de20:	f7d2 f9d6 	bl	80001d0 <memchr>
 802de24:	b138      	cbz	r0, 802de36 <_vfiprintf_r+0x176>
 802de26:	9b04      	ldr	r3, [sp, #16]
 802de28:	eba0 000a 	sub.w	r0, r0, sl
 802de2c:	2240      	movs	r2, #64	@ 0x40
 802de2e:	4082      	lsls	r2, r0
 802de30:	4313      	orrs	r3, r2
 802de32:	3401      	adds	r4, #1
 802de34:	9304      	str	r3, [sp, #16]
 802de36:	f814 1b01 	ldrb.w	r1, [r4], #1
 802de3a:	4829      	ldr	r0, [pc, #164]	@ (802dee0 <_vfiprintf_r+0x220>)
 802de3c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802de40:	2206      	movs	r2, #6
 802de42:	f7d2 f9c5 	bl	80001d0 <memchr>
 802de46:	2800      	cmp	r0, #0
 802de48:	d03f      	beq.n	802deca <_vfiprintf_r+0x20a>
 802de4a:	4b26      	ldr	r3, [pc, #152]	@ (802dee4 <_vfiprintf_r+0x224>)
 802de4c:	bb1b      	cbnz	r3, 802de96 <_vfiprintf_r+0x1d6>
 802de4e:	9b03      	ldr	r3, [sp, #12]
 802de50:	3307      	adds	r3, #7
 802de52:	f023 0307 	bic.w	r3, r3, #7
 802de56:	3308      	adds	r3, #8
 802de58:	9303      	str	r3, [sp, #12]
 802de5a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802de5c:	443b      	add	r3, r7
 802de5e:	9309      	str	r3, [sp, #36]	@ 0x24
 802de60:	e76a      	b.n	802dd38 <_vfiprintf_r+0x78>
 802de62:	fb0c 3202 	mla	r2, ip, r2, r3
 802de66:	460c      	mov	r4, r1
 802de68:	2001      	movs	r0, #1
 802de6a:	e7a8      	b.n	802ddbe <_vfiprintf_r+0xfe>
 802de6c:	2300      	movs	r3, #0
 802de6e:	3401      	adds	r4, #1
 802de70:	9305      	str	r3, [sp, #20]
 802de72:	4619      	mov	r1, r3
 802de74:	f04f 0c0a 	mov.w	ip, #10
 802de78:	4620      	mov	r0, r4
 802de7a:	f810 2b01 	ldrb.w	r2, [r0], #1
 802de7e:	3a30      	subs	r2, #48	@ 0x30
 802de80:	2a09      	cmp	r2, #9
 802de82:	d903      	bls.n	802de8c <_vfiprintf_r+0x1cc>
 802de84:	2b00      	cmp	r3, #0
 802de86:	d0c6      	beq.n	802de16 <_vfiprintf_r+0x156>
 802de88:	9105      	str	r1, [sp, #20]
 802de8a:	e7c4      	b.n	802de16 <_vfiprintf_r+0x156>
 802de8c:	fb0c 2101 	mla	r1, ip, r1, r2
 802de90:	4604      	mov	r4, r0
 802de92:	2301      	movs	r3, #1
 802de94:	e7f0      	b.n	802de78 <_vfiprintf_r+0x1b8>
 802de96:	ab03      	add	r3, sp, #12
 802de98:	9300      	str	r3, [sp, #0]
 802de9a:	462a      	mov	r2, r5
 802de9c:	4b12      	ldr	r3, [pc, #72]	@ (802dee8 <_vfiprintf_r+0x228>)
 802de9e:	a904      	add	r1, sp, #16
 802dea0:	4630      	mov	r0, r6
 802dea2:	f3af 8000 	nop.w
 802dea6:	4607      	mov	r7, r0
 802dea8:	1c78      	adds	r0, r7, #1
 802deaa:	d1d6      	bne.n	802de5a <_vfiprintf_r+0x19a>
 802deac:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802deae:	07d9      	lsls	r1, r3, #31
 802deb0:	d405      	bmi.n	802debe <_vfiprintf_r+0x1fe>
 802deb2:	89ab      	ldrh	r3, [r5, #12]
 802deb4:	059a      	lsls	r2, r3, #22
 802deb6:	d402      	bmi.n	802debe <_vfiprintf_r+0x1fe>
 802deb8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802deba:	f7ff fd25 	bl	802d908 <__retarget_lock_release_recursive>
 802debe:	89ab      	ldrh	r3, [r5, #12]
 802dec0:	065b      	lsls	r3, r3, #25
 802dec2:	f53f af1f 	bmi.w	802dd04 <_vfiprintf_r+0x44>
 802dec6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802dec8:	e71e      	b.n	802dd08 <_vfiprintf_r+0x48>
 802deca:	ab03      	add	r3, sp, #12
 802decc:	9300      	str	r3, [sp, #0]
 802dece:	462a      	mov	r2, r5
 802ded0:	4b05      	ldr	r3, [pc, #20]	@ (802dee8 <_vfiprintf_r+0x228>)
 802ded2:	a904      	add	r1, sp, #16
 802ded4:	4630      	mov	r0, r6
 802ded6:	f000 f879 	bl	802dfcc <_printf_i>
 802deda:	e7e4      	b.n	802dea6 <_vfiprintf_r+0x1e6>
 802dedc:	08030d9c 	.word	0x08030d9c
 802dee0:	08030da6 	.word	0x08030da6
 802dee4:	00000000 	.word	0x00000000
 802dee8:	0802dc9b 	.word	0x0802dc9b
 802deec:	08030da2 	.word	0x08030da2

0802def0 <_printf_common>:
 802def0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802def4:	4616      	mov	r6, r2
 802def6:	4698      	mov	r8, r3
 802def8:	688a      	ldr	r2, [r1, #8]
 802defa:	690b      	ldr	r3, [r1, #16]
 802defc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802df00:	4293      	cmp	r3, r2
 802df02:	bfb8      	it	lt
 802df04:	4613      	movlt	r3, r2
 802df06:	6033      	str	r3, [r6, #0]
 802df08:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 802df0c:	4607      	mov	r7, r0
 802df0e:	460c      	mov	r4, r1
 802df10:	b10a      	cbz	r2, 802df16 <_printf_common+0x26>
 802df12:	3301      	adds	r3, #1
 802df14:	6033      	str	r3, [r6, #0]
 802df16:	6823      	ldr	r3, [r4, #0]
 802df18:	0699      	lsls	r1, r3, #26
 802df1a:	bf42      	ittt	mi
 802df1c:	6833      	ldrmi	r3, [r6, #0]
 802df1e:	3302      	addmi	r3, #2
 802df20:	6033      	strmi	r3, [r6, #0]
 802df22:	6825      	ldr	r5, [r4, #0]
 802df24:	f015 0506 	ands.w	r5, r5, #6
 802df28:	d106      	bne.n	802df38 <_printf_common+0x48>
 802df2a:	f104 0a19 	add.w	sl, r4, #25
 802df2e:	68e3      	ldr	r3, [r4, #12]
 802df30:	6832      	ldr	r2, [r6, #0]
 802df32:	1a9b      	subs	r3, r3, r2
 802df34:	42ab      	cmp	r3, r5
 802df36:	dc26      	bgt.n	802df86 <_printf_common+0x96>
 802df38:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 802df3c:	6822      	ldr	r2, [r4, #0]
 802df3e:	3b00      	subs	r3, #0
 802df40:	bf18      	it	ne
 802df42:	2301      	movne	r3, #1
 802df44:	0692      	lsls	r2, r2, #26
 802df46:	d42b      	bmi.n	802dfa0 <_printf_common+0xb0>
 802df48:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 802df4c:	4641      	mov	r1, r8
 802df4e:	4638      	mov	r0, r7
 802df50:	47c8      	blx	r9
 802df52:	3001      	adds	r0, #1
 802df54:	d01e      	beq.n	802df94 <_printf_common+0xa4>
 802df56:	6823      	ldr	r3, [r4, #0]
 802df58:	6922      	ldr	r2, [r4, #16]
 802df5a:	f003 0306 	and.w	r3, r3, #6
 802df5e:	2b04      	cmp	r3, #4
 802df60:	bf02      	ittt	eq
 802df62:	68e5      	ldreq	r5, [r4, #12]
 802df64:	6833      	ldreq	r3, [r6, #0]
 802df66:	1aed      	subeq	r5, r5, r3
 802df68:	68a3      	ldr	r3, [r4, #8]
 802df6a:	bf0c      	ite	eq
 802df6c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802df70:	2500      	movne	r5, #0
 802df72:	4293      	cmp	r3, r2
 802df74:	bfc4      	itt	gt
 802df76:	1a9b      	subgt	r3, r3, r2
 802df78:	18ed      	addgt	r5, r5, r3
 802df7a:	2600      	movs	r6, #0
 802df7c:	341a      	adds	r4, #26
 802df7e:	42b5      	cmp	r5, r6
 802df80:	d11a      	bne.n	802dfb8 <_printf_common+0xc8>
 802df82:	2000      	movs	r0, #0
 802df84:	e008      	b.n	802df98 <_printf_common+0xa8>
 802df86:	2301      	movs	r3, #1
 802df88:	4652      	mov	r2, sl
 802df8a:	4641      	mov	r1, r8
 802df8c:	4638      	mov	r0, r7
 802df8e:	47c8      	blx	r9
 802df90:	3001      	adds	r0, #1
 802df92:	d103      	bne.n	802df9c <_printf_common+0xac>
 802df94:	f04f 30ff 	mov.w	r0, #4294967295
 802df98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802df9c:	3501      	adds	r5, #1
 802df9e:	e7c6      	b.n	802df2e <_printf_common+0x3e>
 802dfa0:	18e1      	adds	r1, r4, r3
 802dfa2:	1c5a      	adds	r2, r3, #1
 802dfa4:	2030      	movs	r0, #48	@ 0x30
 802dfa6:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 802dfaa:	4422      	add	r2, r4
 802dfac:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 802dfb0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 802dfb4:	3302      	adds	r3, #2
 802dfb6:	e7c7      	b.n	802df48 <_printf_common+0x58>
 802dfb8:	2301      	movs	r3, #1
 802dfba:	4622      	mov	r2, r4
 802dfbc:	4641      	mov	r1, r8
 802dfbe:	4638      	mov	r0, r7
 802dfc0:	47c8      	blx	r9
 802dfc2:	3001      	adds	r0, #1
 802dfc4:	d0e6      	beq.n	802df94 <_printf_common+0xa4>
 802dfc6:	3601      	adds	r6, #1
 802dfc8:	e7d9      	b.n	802df7e <_printf_common+0x8e>
	...

0802dfcc <_printf_i>:
 802dfcc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802dfd0:	7e0f      	ldrb	r7, [r1, #24]
 802dfd2:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 802dfd4:	2f78      	cmp	r7, #120	@ 0x78
 802dfd6:	4691      	mov	r9, r2
 802dfd8:	4680      	mov	r8, r0
 802dfda:	460c      	mov	r4, r1
 802dfdc:	469a      	mov	sl, r3
 802dfde:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802dfe2:	d807      	bhi.n	802dff4 <_printf_i+0x28>
 802dfe4:	2f62      	cmp	r7, #98	@ 0x62
 802dfe6:	d80a      	bhi.n	802dffe <_printf_i+0x32>
 802dfe8:	2f00      	cmp	r7, #0
 802dfea:	f000 80d2 	beq.w	802e192 <_printf_i+0x1c6>
 802dfee:	2f58      	cmp	r7, #88	@ 0x58
 802dff0:	f000 80b9 	beq.w	802e166 <_printf_i+0x19a>
 802dff4:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802dff8:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 802dffc:	e03a      	b.n	802e074 <_printf_i+0xa8>
 802dffe:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802e002:	2b15      	cmp	r3, #21
 802e004:	d8f6      	bhi.n	802dff4 <_printf_i+0x28>
 802e006:	a101      	add	r1, pc, #4	@ (adr r1, 802e00c <_printf_i+0x40>)
 802e008:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 802e00c:	0802e065 	.word	0x0802e065
 802e010:	0802e079 	.word	0x0802e079
 802e014:	0802dff5 	.word	0x0802dff5
 802e018:	0802dff5 	.word	0x0802dff5
 802e01c:	0802dff5 	.word	0x0802dff5
 802e020:	0802dff5 	.word	0x0802dff5
 802e024:	0802e079 	.word	0x0802e079
 802e028:	0802dff5 	.word	0x0802dff5
 802e02c:	0802dff5 	.word	0x0802dff5
 802e030:	0802dff5 	.word	0x0802dff5
 802e034:	0802dff5 	.word	0x0802dff5
 802e038:	0802e179 	.word	0x0802e179
 802e03c:	0802e0a3 	.word	0x0802e0a3
 802e040:	0802e133 	.word	0x0802e133
 802e044:	0802dff5 	.word	0x0802dff5
 802e048:	0802dff5 	.word	0x0802dff5
 802e04c:	0802e19b 	.word	0x0802e19b
 802e050:	0802dff5 	.word	0x0802dff5
 802e054:	0802e0a3 	.word	0x0802e0a3
 802e058:	0802dff5 	.word	0x0802dff5
 802e05c:	0802dff5 	.word	0x0802dff5
 802e060:	0802e13b 	.word	0x0802e13b
 802e064:	6833      	ldr	r3, [r6, #0]
 802e066:	1d1a      	adds	r2, r3, #4
 802e068:	681b      	ldr	r3, [r3, #0]
 802e06a:	6032      	str	r2, [r6, #0]
 802e06c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802e070:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 802e074:	2301      	movs	r3, #1
 802e076:	e09d      	b.n	802e1b4 <_printf_i+0x1e8>
 802e078:	6833      	ldr	r3, [r6, #0]
 802e07a:	6820      	ldr	r0, [r4, #0]
 802e07c:	1d19      	adds	r1, r3, #4
 802e07e:	6031      	str	r1, [r6, #0]
 802e080:	0606      	lsls	r6, r0, #24
 802e082:	d501      	bpl.n	802e088 <_printf_i+0xbc>
 802e084:	681d      	ldr	r5, [r3, #0]
 802e086:	e003      	b.n	802e090 <_printf_i+0xc4>
 802e088:	0645      	lsls	r5, r0, #25
 802e08a:	d5fb      	bpl.n	802e084 <_printf_i+0xb8>
 802e08c:	f9b3 5000 	ldrsh.w	r5, [r3]
 802e090:	2d00      	cmp	r5, #0
 802e092:	da03      	bge.n	802e09c <_printf_i+0xd0>
 802e094:	232d      	movs	r3, #45	@ 0x2d
 802e096:	426d      	negs	r5, r5
 802e098:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 802e09c:	4859      	ldr	r0, [pc, #356]	@ (802e204 <_printf_i+0x238>)
 802e09e:	230a      	movs	r3, #10
 802e0a0:	e011      	b.n	802e0c6 <_printf_i+0xfa>
 802e0a2:	6821      	ldr	r1, [r4, #0]
 802e0a4:	6833      	ldr	r3, [r6, #0]
 802e0a6:	0608      	lsls	r0, r1, #24
 802e0a8:	f853 5b04 	ldr.w	r5, [r3], #4
 802e0ac:	d402      	bmi.n	802e0b4 <_printf_i+0xe8>
 802e0ae:	0649      	lsls	r1, r1, #25
 802e0b0:	bf48      	it	mi
 802e0b2:	b2ad      	uxthmi	r5, r5
 802e0b4:	2f6f      	cmp	r7, #111	@ 0x6f
 802e0b6:	4853      	ldr	r0, [pc, #332]	@ (802e204 <_printf_i+0x238>)
 802e0b8:	6033      	str	r3, [r6, #0]
 802e0ba:	bf14      	ite	ne
 802e0bc:	230a      	movne	r3, #10
 802e0be:	2308      	moveq	r3, #8
 802e0c0:	2100      	movs	r1, #0
 802e0c2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 802e0c6:	6866      	ldr	r6, [r4, #4]
 802e0c8:	60a6      	str	r6, [r4, #8]
 802e0ca:	2e00      	cmp	r6, #0
 802e0cc:	bfa2      	ittt	ge
 802e0ce:	6821      	ldrge	r1, [r4, #0]
 802e0d0:	f021 0104 	bicge.w	r1, r1, #4
 802e0d4:	6021      	strge	r1, [r4, #0]
 802e0d6:	b90d      	cbnz	r5, 802e0dc <_printf_i+0x110>
 802e0d8:	2e00      	cmp	r6, #0
 802e0da:	d04b      	beq.n	802e174 <_printf_i+0x1a8>
 802e0dc:	4616      	mov	r6, r2
 802e0de:	fbb5 f1f3 	udiv	r1, r5, r3
 802e0e2:	fb03 5711 	mls	r7, r3, r1, r5
 802e0e6:	5dc7      	ldrb	r7, [r0, r7]
 802e0e8:	f806 7d01 	strb.w	r7, [r6, #-1]!
 802e0ec:	462f      	mov	r7, r5
 802e0ee:	42bb      	cmp	r3, r7
 802e0f0:	460d      	mov	r5, r1
 802e0f2:	d9f4      	bls.n	802e0de <_printf_i+0x112>
 802e0f4:	2b08      	cmp	r3, #8
 802e0f6:	d10b      	bne.n	802e110 <_printf_i+0x144>
 802e0f8:	6823      	ldr	r3, [r4, #0]
 802e0fa:	07df      	lsls	r7, r3, #31
 802e0fc:	d508      	bpl.n	802e110 <_printf_i+0x144>
 802e0fe:	6923      	ldr	r3, [r4, #16]
 802e100:	6861      	ldr	r1, [r4, #4]
 802e102:	4299      	cmp	r1, r3
 802e104:	bfde      	ittt	le
 802e106:	2330      	movle	r3, #48	@ 0x30
 802e108:	f806 3c01 	strble.w	r3, [r6, #-1]
 802e10c:	f106 36ff 	addle.w	r6, r6, #4294967295
 802e110:	1b92      	subs	r2, r2, r6
 802e112:	6122      	str	r2, [r4, #16]
 802e114:	f8cd a000 	str.w	sl, [sp]
 802e118:	464b      	mov	r3, r9
 802e11a:	aa03      	add	r2, sp, #12
 802e11c:	4621      	mov	r1, r4
 802e11e:	4640      	mov	r0, r8
 802e120:	f7ff fee6 	bl	802def0 <_printf_common>
 802e124:	3001      	adds	r0, #1
 802e126:	d14a      	bne.n	802e1be <_printf_i+0x1f2>
 802e128:	f04f 30ff 	mov.w	r0, #4294967295
 802e12c:	b004      	add	sp, #16
 802e12e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802e132:	6823      	ldr	r3, [r4, #0]
 802e134:	f043 0320 	orr.w	r3, r3, #32
 802e138:	6023      	str	r3, [r4, #0]
 802e13a:	4833      	ldr	r0, [pc, #204]	@ (802e208 <_printf_i+0x23c>)
 802e13c:	2778      	movs	r7, #120	@ 0x78
 802e13e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 802e142:	6823      	ldr	r3, [r4, #0]
 802e144:	6831      	ldr	r1, [r6, #0]
 802e146:	061f      	lsls	r7, r3, #24
 802e148:	f851 5b04 	ldr.w	r5, [r1], #4
 802e14c:	d402      	bmi.n	802e154 <_printf_i+0x188>
 802e14e:	065f      	lsls	r7, r3, #25
 802e150:	bf48      	it	mi
 802e152:	b2ad      	uxthmi	r5, r5
 802e154:	6031      	str	r1, [r6, #0]
 802e156:	07d9      	lsls	r1, r3, #31
 802e158:	bf44      	itt	mi
 802e15a:	f043 0320 	orrmi.w	r3, r3, #32
 802e15e:	6023      	strmi	r3, [r4, #0]
 802e160:	b11d      	cbz	r5, 802e16a <_printf_i+0x19e>
 802e162:	2310      	movs	r3, #16
 802e164:	e7ac      	b.n	802e0c0 <_printf_i+0xf4>
 802e166:	4827      	ldr	r0, [pc, #156]	@ (802e204 <_printf_i+0x238>)
 802e168:	e7e9      	b.n	802e13e <_printf_i+0x172>
 802e16a:	6823      	ldr	r3, [r4, #0]
 802e16c:	f023 0320 	bic.w	r3, r3, #32
 802e170:	6023      	str	r3, [r4, #0]
 802e172:	e7f6      	b.n	802e162 <_printf_i+0x196>
 802e174:	4616      	mov	r6, r2
 802e176:	e7bd      	b.n	802e0f4 <_printf_i+0x128>
 802e178:	6833      	ldr	r3, [r6, #0]
 802e17a:	6825      	ldr	r5, [r4, #0]
 802e17c:	6961      	ldr	r1, [r4, #20]
 802e17e:	1d18      	adds	r0, r3, #4
 802e180:	6030      	str	r0, [r6, #0]
 802e182:	062e      	lsls	r6, r5, #24
 802e184:	681b      	ldr	r3, [r3, #0]
 802e186:	d501      	bpl.n	802e18c <_printf_i+0x1c0>
 802e188:	6019      	str	r1, [r3, #0]
 802e18a:	e002      	b.n	802e192 <_printf_i+0x1c6>
 802e18c:	0668      	lsls	r0, r5, #25
 802e18e:	d5fb      	bpl.n	802e188 <_printf_i+0x1bc>
 802e190:	8019      	strh	r1, [r3, #0]
 802e192:	2300      	movs	r3, #0
 802e194:	6123      	str	r3, [r4, #16]
 802e196:	4616      	mov	r6, r2
 802e198:	e7bc      	b.n	802e114 <_printf_i+0x148>
 802e19a:	6833      	ldr	r3, [r6, #0]
 802e19c:	1d1a      	adds	r2, r3, #4
 802e19e:	6032      	str	r2, [r6, #0]
 802e1a0:	681e      	ldr	r6, [r3, #0]
 802e1a2:	6862      	ldr	r2, [r4, #4]
 802e1a4:	2100      	movs	r1, #0
 802e1a6:	4630      	mov	r0, r6
 802e1a8:	f7d2 f812 	bl	80001d0 <memchr>
 802e1ac:	b108      	cbz	r0, 802e1b2 <_printf_i+0x1e6>
 802e1ae:	1b80      	subs	r0, r0, r6
 802e1b0:	6060      	str	r0, [r4, #4]
 802e1b2:	6863      	ldr	r3, [r4, #4]
 802e1b4:	6123      	str	r3, [r4, #16]
 802e1b6:	2300      	movs	r3, #0
 802e1b8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 802e1bc:	e7aa      	b.n	802e114 <_printf_i+0x148>
 802e1be:	6923      	ldr	r3, [r4, #16]
 802e1c0:	4632      	mov	r2, r6
 802e1c2:	4649      	mov	r1, r9
 802e1c4:	4640      	mov	r0, r8
 802e1c6:	47d0      	blx	sl
 802e1c8:	3001      	adds	r0, #1
 802e1ca:	d0ad      	beq.n	802e128 <_printf_i+0x15c>
 802e1cc:	6823      	ldr	r3, [r4, #0]
 802e1ce:	079b      	lsls	r3, r3, #30
 802e1d0:	d413      	bmi.n	802e1fa <_printf_i+0x22e>
 802e1d2:	68e0      	ldr	r0, [r4, #12]
 802e1d4:	9b03      	ldr	r3, [sp, #12]
 802e1d6:	4298      	cmp	r0, r3
 802e1d8:	bfb8      	it	lt
 802e1da:	4618      	movlt	r0, r3
 802e1dc:	e7a6      	b.n	802e12c <_printf_i+0x160>
 802e1de:	2301      	movs	r3, #1
 802e1e0:	4632      	mov	r2, r6
 802e1e2:	4649      	mov	r1, r9
 802e1e4:	4640      	mov	r0, r8
 802e1e6:	47d0      	blx	sl
 802e1e8:	3001      	adds	r0, #1
 802e1ea:	d09d      	beq.n	802e128 <_printf_i+0x15c>
 802e1ec:	3501      	adds	r5, #1
 802e1ee:	68e3      	ldr	r3, [r4, #12]
 802e1f0:	9903      	ldr	r1, [sp, #12]
 802e1f2:	1a5b      	subs	r3, r3, r1
 802e1f4:	42ab      	cmp	r3, r5
 802e1f6:	dcf2      	bgt.n	802e1de <_printf_i+0x212>
 802e1f8:	e7eb      	b.n	802e1d2 <_printf_i+0x206>
 802e1fa:	2500      	movs	r5, #0
 802e1fc:	f104 0619 	add.w	r6, r4, #25
 802e200:	e7f5      	b.n	802e1ee <_printf_i+0x222>
 802e202:	bf00      	nop
 802e204:	08030dad 	.word	0x08030dad
 802e208:	08030dbe 	.word	0x08030dbe

0802e20c <__sflush_r>:
 802e20c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802e210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e214:	0716      	lsls	r6, r2, #28
 802e216:	4605      	mov	r5, r0
 802e218:	460c      	mov	r4, r1
 802e21a:	d454      	bmi.n	802e2c6 <__sflush_r+0xba>
 802e21c:	684b      	ldr	r3, [r1, #4]
 802e21e:	2b00      	cmp	r3, #0
 802e220:	dc02      	bgt.n	802e228 <__sflush_r+0x1c>
 802e222:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 802e224:	2b00      	cmp	r3, #0
 802e226:	dd48      	ble.n	802e2ba <__sflush_r+0xae>
 802e228:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 802e22a:	2e00      	cmp	r6, #0
 802e22c:	d045      	beq.n	802e2ba <__sflush_r+0xae>
 802e22e:	2300      	movs	r3, #0
 802e230:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 802e234:	682f      	ldr	r7, [r5, #0]
 802e236:	6a21      	ldr	r1, [r4, #32]
 802e238:	602b      	str	r3, [r5, #0]
 802e23a:	d030      	beq.n	802e29e <__sflush_r+0x92>
 802e23c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 802e23e:	89a3      	ldrh	r3, [r4, #12]
 802e240:	0759      	lsls	r1, r3, #29
 802e242:	d505      	bpl.n	802e250 <__sflush_r+0x44>
 802e244:	6863      	ldr	r3, [r4, #4]
 802e246:	1ad2      	subs	r2, r2, r3
 802e248:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 802e24a:	b10b      	cbz	r3, 802e250 <__sflush_r+0x44>
 802e24c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802e24e:	1ad2      	subs	r2, r2, r3
 802e250:	2300      	movs	r3, #0
 802e252:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 802e254:	6a21      	ldr	r1, [r4, #32]
 802e256:	4628      	mov	r0, r5
 802e258:	47b0      	blx	r6
 802e25a:	1c43      	adds	r3, r0, #1
 802e25c:	89a3      	ldrh	r3, [r4, #12]
 802e25e:	d106      	bne.n	802e26e <__sflush_r+0x62>
 802e260:	6829      	ldr	r1, [r5, #0]
 802e262:	291d      	cmp	r1, #29
 802e264:	d82b      	bhi.n	802e2be <__sflush_r+0xb2>
 802e266:	4a2a      	ldr	r2, [pc, #168]	@ (802e310 <__sflush_r+0x104>)
 802e268:	410a      	asrs	r2, r1
 802e26a:	07d6      	lsls	r6, r2, #31
 802e26c:	d427      	bmi.n	802e2be <__sflush_r+0xb2>
 802e26e:	2200      	movs	r2, #0
 802e270:	6062      	str	r2, [r4, #4]
 802e272:	04d9      	lsls	r1, r3, #19
 802e274:	6922      	ldr	r2, [r4, #16]
 802e276:	6022      	str	r2, [r4, #0]
 802e278:	d504      	bpl.n	802e284 <__sflush_r+0x78>
 802e27a:	1c42      	adds	r2, r0, #1
 802e27c:	d101      	bne.n	802e282 <__sflush_r+0x76>
 802e27e:	682b      	ldr	r3, [r5, #0]
 802e280:	b903      	cbnz	r3, 802e284 <__sflush_r+0x78>
 802e282:	6560      	str	r0, [r4, #84]	@ 0x54
 802e284:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802e286:	602f      	str	r7, [r5, #0]
 802e288:	b1b9      	cbz	r1, 802e2ba <__sflush_r+0xae>
 802e28a:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 802e28e:	4299      	cmp	r1, r3
 802e290:	d002      	beq.n	802e298 <__sflush_r+0x8c>
 802e292:	4628      	mov	r0, r5
 802e294:	f7ff fb48 	bl	802d928 <_free_r>
 802e298:	2300      	movs	r3, #0
 802e29a:	6363      	str	r3, [r4, #52]	@ 0x34
 802e29c:	e00d      	b.n	802e2ba <__sflush_r+0xae>
 802e29e:	2301      	movs	r3, #1
 802e2a0:	4628      	mov	r0, r5
 802e2a2:	47b0      	blx	r6
 802e2a4:	4602      	mov	r2, r0
 802e2a6:	1c50      	adds	r0, r2, #1
 802e2a8:	d1c9      	bne.n	802e23e <__sflush_r+0x32>
 802e2aa:	682b      	ldr	r3, [r5, #0]
 802e2ac:	2b00      	cmp	r3, #0
 802e2ae:	d0c6      	beq.n	802e23e <__sflush_r+0x32>
 802e2b0:	2b1d      	cmp	r3, #29
 802e2b2:	d001      	beq.n	802e2b8 <__sflush_r+0xac>
 802e2b4:	2b16      	cmp	r3, #22
 802e2b6:	d11e      	bne.n	802e2f6 <__sflush_r+0xea>
 802e2b8:	602f      	str	r7, [r5, #0]
 802e2ba:	2000      	movs	r0, #0
 802e2bc:	e022      	b.n	802e304 <__sflush_r+0xf8>
 802e2be:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802e2c2:	b21b      	sxth	r3, r3
 802e2c4:	e01b      	b.n	802e2fe <__sflush_r+0xf2>
 802e2c6:	690f      	ldr	r7, [r1, #16]
 802e2c8:	2f00      	cmp	r7, #0
 802e2ca:	d0f6      	beq.n	802e2ba <__sflush_r+0xae>
 802e2cc:	0793      	lsls	r3, r2, #30
 802e2ce:	680e      	ldr	r6, [r1, #0]
 802e2d0:	bf08      	it	eq
 802e2d2:	694b      	ldreq	r3, [r1, #20]
 802e2d4:	600f      	str	r7, [r1, #0]
 802e2d6:	bf18      	it	ne
 802e2d8:	2300      	movne	r3, #0
 802e2da:	eba6 0807 	sub.w	r8, r6, r7
 802e2de:	608b      	str	r3, [r1, #8]
 802e2e0:	f1b8 0f00 	cmp.w	r8, #0
 802e2e4:	dde9      	ble.n	802e2ba <__sflush_r+0xae>
 802e2e6:	6a21      	ldr	r1, [r4, #32]
 802e2e8:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 802e2ea:	4643      	mov	r3, r8
 802e2ec:	463a      	mov	r2, r7
 802e2ee:	4628      	mov	r0, r5
 802e2f0:	47b0      	blx	r6
 802e2f2:	2800      	cmp	r0, #0
 802e2f4:	dc08      	bgt.n	802e308 <__sflush_r+0xfc>
 802e2f6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802e2fa:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802e2fe:	81a3      	strh	r3, [r4, #12]
 802e300:	f04f 30ff 	mov.w	r0, #4294967295
 802e304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e308:	4407      	add	r7, r0
 802e30a:	eba8 0800 	sub.w	r8, r8, r0
 802e30e:	e7e7      	b.n	802e2e0 <__sflush_r+0xd4>
 802e310:	dfbffffe 	.word	0xdfbffffe

0802e314 <_fflush_r>:
 802e314:	b538      	push	{r3, r4, r5, lr}
 802e316:	690b      	ldr	r3, [r1, #16]
 802e318:	4605      	mov	r5, r0
 802e31a:	460c      	mov	r4, r1
 802e31c:	b913      	cbnz	r3, 802e324 <_fflush_r+0x10>
 802e31e:	2500      	movs	r5, #0
 802e320:	4628      	mov	r0, r5
 802e322:	bd38      	pop	{r3, r4, r5, pc}
 802e324:	b118      	cbz	r0, 802e32e <_fflush_r+0x1a>
 802e326:	6a03      	ldr	r3, [r0, #32]
 802e328:	b90b      	cbnz	r3, 802e32e <_fflush_r+0x1a>
 802e32a:	f7ff f9b7 	bl	802d69c <__sinit>
 802e32e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802e332:	2b00      	cmp	r3, #0
 802e334:	d0f3      	beq.n	802e31e <_fflush_r+0xa>
 802e336:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 802e338:	07d0      	lsls	r0, r2, #31
 802e33a:	d404      	bmi.n	802e346 <_fflush_r+0x32>
 802e33c:	0599      	lsls	r1, r3, #22
 802e33e:	d402      	bmi.n	802e346 <_fflush_r+0x32>
 802e340:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 802e342:	f7ff fae0 	bl	802d906 <__retarget_lock_acquire_recursive>
 802e346:	4628      	mov	r0, r5
 802e348:	4621      	mov	r1, r4
 802e34a:	f7ff ff5f 	bl	802e20c <__sflush_r>
 802e34e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 802e350:	07da      	lsls	r2, r3, #31
 802e352:	4605      	mov	r5, r0
 802e354:	d4e4      	bmi.n	802e320 <_fflush_r+0xc>
 802e356:	89a3      	ldrh	r3, [r4, #12]
 802e358:	059b      	lsls	r3, r3, #22
 802e35a:	d4e1      	bmi.n	802e320 <_fflush_r+0xc>
 802e35c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 802e35e:	f7ff fad3 	bl	802d908 <__retarget_lock_release_recursive>
 802e362:	e7dd      	b.n	802e320 <_fflush_r+0xc>

0802e364 <__swbuf_r>:
 802e364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e366:	460e      	mov	r6, r1
 802e368:	4614      	mov	r4, r2
 802e36a:	4605      	mov	r5, r0
 802e36c:	b118      	cbz	r0, 802e376 <__swbuf_r+0x12>
 802e36e:	6a03      	ldr	r3, [r0, #32]
 802e370:	b90b      	cbnz	r3, 802e376 <__swbuf_r+0x12>
 802e372:	f7ff f993 	bl	802d69c <__sinit>
 802e376:	69a3      	ldr	r3, [r4, #24]
 802e378:	60a3      	str	r3, [r4, #8]
 802e37a:	89a3      	ldrh	r3, [r4, #12]
 802e37c:	071a      	lsls	r2, r3, #28
 802e37e:	d501      	bpl.n	802e384 <__swbuf_r+0x20>
 802e380:	6923      	ldr	r3, [r4, #16]
 802e382:	b943      	cbnz	r3, 802e396 <__swbuf_r+0x32>
 802e384:	4621      	mov	r1, r4
 802e386:	4628      	mov	r0, r5
 802e388:	f000 f82a 	bl	802e3e0 <__swsetup_r>
 802e38c:	b118      	cbz	r0, 802e396 <__swbuf_r+0x32>
 802e38e:	f04f 37ff 	mov.w	r7, #4294967295
 802e392:	4638      	mov	r0, r7
 802e394:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802e396:	6823      	ldr	r3, [r4, #0]
 802e398:	6922      	ldr	r2, [r4, #16]
 802e39a:	1a98      	subs	r0, r3, r2
 802e39c:	6963      	ldr	r3, [r4, #20]
 802e39e:	b2f6      	uxtb	r6, r6
 802e3a0:	4283      	cmp	r3, r0
 802e3a2:	4637      	mov	r7, r6
 802e3a4:	dc05      	bgt.n	802e3b2 <__swbuf_r+0x4e>
 802e3a6:	4621      	mov	r1, r4
 802e3a8:	4628      	mov	r0, r5
 802e3aa:	f7ff ffb3 	bl	802e314 <_fflush_r>
 802e3ae:	2800      	cmp	r0, #0
 802e3b0:	d1ed      	bne.n	802e38e <__swbuf_r+0x2a>
 802e3b2:	68a3      	ldr	r3, [r4, #8]
 802e3b4:	3b01      	subs	r3, #1
 802e3b6:	60a3      	str	r3, [r4, #8]
 802e3b8:	6823      	ldr	r3, [r4, #0]
 802e3ba:	1c5a      	adds	r2, r3, #1
 802e3bc:	6022      	str	r2, [r4, #0]
 802e3be:	701e      	strb	r6, [r3, #0]
 802e3c0:	6962      	ldr	r2, [r4, #20]
 802e3c2:	1c43      	adds	r3, r0, #1
 802e3c4:	429a      	cmp	r2, r3
 802e3c6:	d004      	beq.n	802e3d2 <__swbuf_r+0x6e>
 802e3c8:	89a3      	ldrh	r3, [r4, #12]
 802e3ca:	07db      	lsls	r3, r3, #31
 802e3cc:	d5e1      	bpl.n	802e392 <__swbuf_r+0x2e>
 802e3ce:	2e0a      	cmp	r6, #10
 802e3d0:	d1df      	bne.n	802e392 <__swbuf_r+0x2e>
 802e3d2:	4621      	mov	r1, r4
 802e3d4:	4628      	mov	r0, r5
 802e3d6:	f7ff ff9d 	bl	802e314 <_fflush_r>
 802e3da:	2800      	cmp	r0, #0
 802e3dc:	d0d9      	beq.n	802e392 <__swbuf_r+0x2e>
 802e3de:	e7d6      	b.n	802e38e <__swbuf_r+0x2a>

0802e3e0 <__swsetup_r>:
 802e3e0:	b538      	push	{r3, r4, r5, lr}
 802e3e2:	4b29      	ldr	r3, [pc, #164]	@ (802e488 <__swsetup_r+0xa8>)
 802e3e4:	4605      	mov	r5, r0
 802e3e6:	6818      	ldr	r0, [r3, #0]
 802e3e8:	460c      	mov	r4, r1
 802e3ea:	b118      	cbz	r0, 802e3f4 <__swsetup_r+0x14>
 802e3ec:	6a03      	ldr	r3, [r0, #32]
 802e3ee:	b90b      	cbnz	r3, 802e3f4 <__swsetup_r+0x14>
 802e3f0:	f7ff f954 	bl	802d69c <__sinit>
 802e3f4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802e3f8:	0719      	lsls	r1, r3, #28
 802e3fa:	d422      	bmi.n	802e442 <__swsetup_r+0x62>
 802e3fc:	06da      	lsls	r2, r3, #27
 802e3fe:	d407      	bmi.n	802e410 <__swsetup_r+0x30>
 802e400:	2209      	movs	r2, #9
 802e402:	602a      	str	r2, [r5, #0]
 802e404:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802e408:	81a3      	strh	r3, [r4, #12]
 802e40a:	f04f 30ff 	mov.w	r0, #4294967295
 802e40e:	e033      	b.n	802e478 <__swsetup_r+0x98>
 802e410:	0758      	lsls	r0, r3, #29
 802e412:	d512      	bpl.n	802e43a <__swsetup_r+0x5a>
 802e414:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802e416:	b141      	cbz	r1, 802e42a <__swsetup_r+0x4a>
 802e418:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 802e41c:	4299      	cmp	r1, r3
 802e41e:	d002      	beq.n	802e426 <__swsetup_r+0x46>
 802e420:	4628      	mov	r0, r5
 802e422:	f7ff fa81 	bl	802d928 <_free_r>
 802e426:	2300      	movs	r3, #0
 802e428:	6363      	str	r3, [r4, #52]	@ 0x34
 802e42a:	89a3      	ldrh	r3, [r4, #12]
 802e42c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 802e430:	81a3      	strh	r3, [r4, #12]
 802e432:	2300      	movs	r3, #0
 802e434:	6063      	str	r3, [r4, #4]
 802e436:	6923      	ldr	r3, [r4, #16]
 802e438:	6023      	str	r3, [r4, #0]
 802e43a:	89a3      	ldrh	r3, [r4, #12]
 802e43c:	f043 0308 	orr.w	r3, r3, #8
 802e440:	81a3      	strh	r3, [r4, #12]
 802e442:	6923      	ldr	r3, [r4, #16]
 802e444:	b94b      	cbnz	r3, 802e45a <__swsetup_r+0x7a>
 802e446:	89a3      	ldrh	r3, [r4, #12]
 802e448:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 802e44c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 802e450:	d003      	beq.n	802e45a <__swsetup_r+0x7a>
 802e452:	4621      	mov	r1, r4
 802e454:	4628      	mov	r0, r5
 802e456:	f000 f887 	bl	802e568 <__smakebuf_r>
 802e45a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802e45e:	f013 0201 	ands.w	r2, r3, #1
 802e462:	d00a      	beq.n	802e47a <__swsetup_r+0x9a>
 802e464:	2200      	movs	r2, #0
 802e466:	60a2      	str	r2, [r4, #8]
 802e468:	6962      	ldr	r2, [r4, #20]
 802e46a:	4252      	negs	r2, r2
 802e46c:	61a2      	str	r2, [r4, #24]
 802e46e:	6922      	ldr	r2, [r4, #16]
 802e470:	b942      	cbnz	r2, 802e484 <__swsetup_r+0xa4>
 802e472:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 802e476:	d1c5      	bne.n	802e404 <__swsetup_r+0x24>
 802e478:	bd38      	pop	{r3, r4, r5, pc}
 802e47a:	0799      	lsls	r1, r3, #30
 802e47c:	bf58      	it	pl
 802e47e:	6962      	ldrpl	r2, [r4, #20]
 802e480:	60a2      	str	r2, [r4, #8]
 802e482:	e7f4      	b.n	802e46e <__swsetup_r+0x8e>
 802e484:	2000      	movs	r0, #0
 802e486:	e7f7      	b.n	802e478 <__swsetup_r+0x98>
 802e488:	20000038 	.word	0x20000038

0802e48c <memmove>:
 802e48c:	4288      	cmp	r0, r1
 802e48e:	b510      	push	{r4, lr}
 802e490:	eb01 0402 	add.w	r4, r1, r2
 802e494:	d902      	bls.n	802e49c <memmove+0x10>
 802e496:	4284      	cmp	r4, r0
 802e498:	4623      	mov	r3, r4
 802e49a:	d807      	bhi.n	802e4ac <memmove+0x20>
 802e49c:	1e43      	subs	r3, r0, #1
 802e49e:	42a1      	cmp	r1, r4
 802e4a0:	d008      	beq.n	802e4b4 <memmove+0x28>
 802e4a2:	f811 2b01 	ldrb.w	r2, [r1], #1
 802e4a6:	f803 2f01 	strb.w	r2, [r3, #1]!
 802e4aa:	e7f8      	b.n	802e49e <memmove+0x12>
 802e4ac:	4402      	add	r2, r0
 802e4ae:	4601      	mov	r1, r0
 802e4b0:	428a      	cmp	r2, r1
 802e4b2:	d100      	bne.n	802e4b6 <memmove+0x2a>
 802e4b4:	bd10      	pop	{r4, pc}
 802e4b6:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802e4ba:	f802 4d01 	strb.w	r4, [r2, #-1]!
 802e4be:	e7f7      	b.n	802e4b0 <memmove+0x24>

0802e4c0 <_realloc_r>:
 802e4c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e4c4:	4680      	mov	r8, r0
 802e4c6:	4615      	mov	r5, r2
 802e4c8:	460c      	mov	r4, r1
 802e4ca:	b921      	cbnz	r1, 802e4d6 <_realloc_r+0x16>
 802e4cc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802e4d0:	4611      	mov	r1, r2
 802e4d2:	f7fe bfcb 	b.w	802d46c <_malloc_r>
 802e4d6:	b92a      	cbnz	r2, 802e4e4 <_realloc_r+0x24>
 802e4d8:	f7ff fa26 	bl	802d928 <_free_r>
 802e4dc:	2400      	movs	r4, #0
 802e4de:	4620      	mov	r0, r4
 802e4e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e4e4:	f000 f89e 	bl	802e624 <_malloc_usable_size_r>
 802e4e8:	4285      	cmp	r5, r0
 802e4ea:	4606      	mov	r6, r0
 802e4ec:	d802      	bhi.n	802e4f4 <_realloc_r+0x34>
 802e4ee:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 802e4f2:	d8f4      	bhi.n	802e4de <_realloc_r+0x1e>
 802e4f4:	4629      	mov	r1, r5
 802e4f6:	4640      	mov	r0, r8
 802e4f8:	f7fe ffb8 	bl	802d46c <_malloc_r>
 802e4fc:	4607      	mov	r7, r0
 802e4fe:	2800      	cmp	r0, #0
 802e500:	d0ec      	beq.n	802e4dc <_realloc_r+0x1c>
 802e502:	42b5      	cmp	r5, r6
 802e504:	462a      	mov	r2, r5
 802e506:	4621      	mov	r1, r4
 802e508:	bf28      	it	cs
 802e50a:	4632      	movcs	r2, r6
 802e50c:	f7ff f9fd 	bl	802d90a <memcpy>
 802e510:	4621      	mov	r1, r4
 802e512:	4640      	mov	r0, r8
 802e514:	f7ff fa08 	bl	802d928 <_free_r>
 802e518:	463c      	mov	r4, r7
 802e51a:	e7e0      	b.n	802e4de <_realloc_r+0x1e>

0802e51c <__swhatbuf_r>:
 802e51c:	b570      	push	{r4, r5, r6, lr}
 802e51e:	460c      	mov	r4, r1
 802e520:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802e524:	2900      	cmp	r1, #0
 802e526:	b096      	sub	sp, #88	@ 0x58
 802e528:	4615      	mov	r5, r2
 802e52a:	461e      	mov	r6, r3
 802e52c:	da0d      	bge.n	802e54a <__swhatbuf_r+0x2e>
 802e52e:	89a3      	ldrh	r3, [r4, #12]
 802e530:	f013 0f80 	tst.w	r3, #128	@ 0x80
 802e534:	f04f 0100 	mov.w	r1, #0
 802e538:	bf14      	ite	ne
 802e53a:	2340      	movne	r3, #64	@ 0x40
 802e53c:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 802e540:	2000      	movs	r0, #0
 802e542:	6031      	str	r1, [r6, #0]
 802e544:	602b      	str	r3, [r5, #0]
 802e546:	b016      	add	sp, #88	@ 0x58
 802e548:	bd70      	pop	{r4, r5, r6, pc}
 802e54a:	466a      	mov	r2, sp
 802e54c:	f000 f848 	bl	802e5e0 <_fstat_r>
 802e550:	2800      	cmp	r0, #0
 802e552:	dbec      	blt.n	802e52e <__swhatbuf_r+0x12>
 802e554:	9901      	ldr	r1, [sp, #4]
 802e556:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 802e55a:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 802e55e:	4259      	negs	r1, r3
 802e560:	4159      	adcs	r1, r3
 802e562:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 802e566:	e7eb      	b.n	802e540 <__swhatbuf_r+0x24>

0802e568 <__smakebuf_r>:
 802e568:	898b      	ldrh	r3, [r1, #12]
 802e56a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802e56c:	079d      	lsls	r5, r3, #30
 802e56e:	4606      	mov	r6, r0
 802e570:	460c      	mov	r4, r1
 802e572:	d507      	bpl.n	802e584 <__smakebuf_r+0x1c>
 802e574:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 802e578:	6023      	str	r3, [r4, #0]
 802e57a:	6123      	str	r3, [r4, #16]
 802e57c:	2301      	movs	r3, #1
 802e57e:	6163      	str	r3, [r4, #20]
 802e580:	b003      	add	sp, #12
 802e582:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802e584:	ab01      	add	r3, sp, #4
 802e586:	466a      	mov	r2, sp
 802e588:	f7ff ffc8 	bl	802e51c <__swhatbuf_r>
 802e58c:	9f00      	ldr	r7, [sp, #0]
 802e58e:	4605      	mov	r5, r0
 802e590:	4639      	mov	r1, r7
 802e592:	4630      	mov	r0, r6
 802e594:	f7fe ff6a 	bl	802d46c <_malloc_r>
 802e598:	b948      	cbnz	r0, 802e5ae <__smakebuf_r+0x46>
 802e59a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802e59e:	059a      	lsls	r2, r3, #22
 802e5a0:	d4ee      	bmi.n	802e580 <__smakebuf_r+0x18>
 802e5a2:	f023 0303 	bic.w	r3, r3, #3
 802e5a6:	f043 0302 	orr.w	r3, r3, #2
 802e5aa:	81a3      	strh	r3, [r4, #12]
 802e5ac:	e7e2      	b.n	802e574 <__smakebuf_r+0xc>
 802e5ae:	89a3      	ldrh	r3, [r4, #12]
 802e5b0:	6020      	str	r0, [r4, #0]
 802e5b2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802e5b6:	81a3      	strh	r3, [r4, #12]
 802e5b8:	9b01      	ldr	r3, [sp, #4]
 802e5ba:	e9c4 0704 	strd	r0, r7, [r4, #16]
 802e5be:	b15b      	cbz	r3, 802e5d8 <__smakebuf_r+0x70>
 802e5c0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802e5c4:	4630      	mov	r0, r6
 802e5c6:	f000 f81d 	bl	802e604 <_isatty_r>
 802e5ca:	b128      	cbz	r0, 802e5d8 <__smakebuf_r+0x70>
 802e5cc:	89a3      	ldrh	r3, [r4, #12]
 802e5ce:	f023 0303 	bic.w	r3, r3, #3
 802e5d2:	f043 0301 	orr.w	r3, r3, #1
 802e5d6:	81a3      	strh	r3, [r4, #12]
 802e5d8:	89a3      	ldrh	r3, [r4, #12]
 802e5da:	431d      	orrs	r5, r3
 802e5dc:	81a5      	strh	r5, [r4, #12]
 802e5de:	e7cf      	b.n	802e580 <__smakebuf_r+0x18>

0802e5e0 <_fstat_r>:
 802e5e0:	b538      	push	{r3, r4, r5, lr}
 802e5e2:	4d07      	ldr	r5, [pc, #28]	@ (802e600 <_fstat_r+0x20>)
 802e5e4:	2300      	movs	r3, #0
 802e5e6:	4604      	mov	r4, r0
 802e5e8:	4608      	mov	r0, r1
 802e5ea:	4611      	mov	r1, r2
 802e5ec:	602b      	str	r3, [r5, #0]
 802e5ee:	f7d3 f9ec 	bl	80019ca <_fstat>
 802e5f2:	1c43      	adds	r3, r0, #1
 802e5f4:	d102      	bne.n	802e5fc <_fstat_r+0x1c>
 802e5f6:	682b      	ldr	r3, [r5, #0]
 802e5f8:	b103      	cbz	r3, 802e5fc <_fstat_r+0x1c>
 802e5fa:	6023      	str	r3, [r4, #0]
 802e5fc:	bd38      	pop	{r3, r4, r5, pc}
 802e5fe:	bf00      	nop
 802e600:	20003220 	.word	0x20003220

0802e604 <_isatty_r>:
 802e604:	b538      	push	{r3, r4, r5, lr}
 802e606:	4d06      	ldr	r5, [pc, #24]	@ (802e620 <_isatty_r+0x1c>)
 802e608:	2300      	movs	r3, #0
 802e60a:	4604      	mov	r4, r0
 802e60c:	4608      	mov	r0, r1
 802e60e:	602b      	str	r3, [r5, #0]
 802e610:	f7d3 f9eb 	bl	80019ea <_isatty>
 802e614:	1c43      	adds	r3, r0, #1
 802e616:	d102      	bne.n	802e61e <_isatty_r+0x1a>
 802e618:	682b      	ldr	r3, [r5, #0]
 802e61a:	b103      	cbz	r3, 802e61e <_isatty_r+0x1a>
 802e61c:	6023      	str	r3, [r4, #0]
 802e61e:	bd38      	pop	{r3, r4, r5, pc}
 802e620:	20003220 	.word	0x20003220

0802e624 <_malloc_usable_size_r>:
 802e624:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802e628:	1f18      	subs	r0, r3, #4
 802e62a:	2b00      	cmp	r3, #0
 802e62c:	bfbc      	itt	lt
 802e62e:	580b      	ldrlt	r3, [r1, r0]
 802e630:	18c0      	addlt	r0, r0, r3
 802e632:	4770      	bx	lr

0802e634 <_init>:
 802e634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e636:	bf00      	nop
 802e638:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802e63a:	bc08      	pop	{r3}
 802e63c:	469e      	mov	lr, r3
 802e63e:	4770      	bx	lr

0802e640 <_fini>:
 802e640:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e642:	bf00      	nop
 802e644:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802e646:	bc08      	pop	{r3}
 802e648:	469e      	mov	lr, r3
 802e64a:	4770      	bx	lr
