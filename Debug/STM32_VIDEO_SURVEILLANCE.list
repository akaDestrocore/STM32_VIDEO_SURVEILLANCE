
STM32_VIDEO_SURVEILLANCE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002ffcc  08000190  08000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002b10  08030160  08030160  00031160  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08032c70  08032c70  0003407c  2**0
                  CONTENTS
  4 .ARM          00000008  08032c70  08032c70  00033c70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08032c78  08032c78  0003407c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08032c78  08032c78  00033c78  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08032c7c  08032c7c  00033c7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000007c  20000000  08032c80  00034000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  0003407c  2**0
                  CONTENTS
 10 .bss          00003614  20000080  20000080  00034080  2**3
                  ALLOC
 11 ._user_heap_stack 00000604  20003694  20003694  00034080  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  0003407c  2**0
                  CONTENTS, READONLY
 13 .debug_info   00066095  00000000  00000000  000340ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00009acc  00000000  00000000  0009a141  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001d48  00000000  00000000  000a3c10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00001640  00000000  00000000  000a5958  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00029022  00000000  00000000  000a6f98  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0004a8f2  00000000  00000000  000cffba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00087df6  00000000  00000000  0011a8ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  001a26a2  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000079bc  00000000  00000000  001a26e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000075  00000000  00000000  001aa0a4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	@ (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	@ (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000080 	.word	0x20000080
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08030144 	.word	0x08030144

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	@ (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	@ (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	@ (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000084 	.word	0x20000084
 80001cc:	08030144 	.word	0x08030144

080001d0 <memchr>:
 80001d0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80001d4:	2a10      	cmp	r2, #16
 80001d6:	db2b      	blt.n	8000230 <memchr+0x60>
 80001d8:	f010 0f07 	tst.w	r0, #7
 80001dc:	d008      	beq.n	80001f0 <memchr+0x20>
 80001de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001e2:	3a01      	subs	r2, #1
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d02d      	beq.n	8000244 <memchr+0x74>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	b342      	cbz	r2, 8000240 <memchr+0x70>
 80001ee:	d1f6      	bne.n	80001de <memchr+0xe>
 80001f0:	b4f0      	push	{r4, r5, r6, r7}
 80001f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001fa:	f022 0407 	bic.w	r4, r2, #7
 80001fe:	f07f 0700 	mvns.w	r7, #0
 8000202:	2300      	movs	r3, #0
 8000204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000208:	3c08      	subs	r4, #8
 800020a:	ea85 0501 	eor.w	r5, r5, r1
 800020e:	ea86 0601 	eor.w	r6, r6, r1
 8000212:	fa85 f547 	uadd8	r5, r5, r7
 8000216:	faa3 f587 	sel	r5, r3, r7
 800021a:	fa86 f647 	uadd8	r6, r6, r7
 800021e:	faa5 f687 	sel	r6, r5, r7
 8000222:	b98e      	cbnz	r6, 8000248 <memchr+0x78>
 8000224:	d1ee      	bne.n	8000204 <memchr+0x34>
 8000226:	bcf0      	pop	{r4, r5, r6, r7}
 8000228:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800022c:	f002 0207 	and.w	r2, r2, #7
 8000230:	b132      	cbz	r2, 8000240 <memchr+0x70>
 8000232:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000236:	3a01      	subs	r2, #1
 8000238:	ea83 0301 	eor.w	r3, r3, r1
 800023c:	b113      	cbz	r3, 8000244 <memchr+0x74>
 800023e:	d1f8      	bne.n	8000232 <memchr+0x62>
 8000240:	2000      	movs	r0, #0
 8000242:	4770      	bx	lr
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr
 8000248:	2d00      	cmp	r5, #0
 800024a:	bf06      	itte	eq
 800024c:	4635      	moveq	r5, r6
 800024e:	3803      	subeq	r0, #3
 8000250:	3807      	subne	r0, #7
 8000252:	f015 0f01 	tst.w	r5, #1
 8000256:	d107      	bne.n	8000268 <memchr+0x98>
 8000258:	3001      	adds	r0, #1
 800025a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800025e:	bf02      	ittt	eq
 8000260:	3001      	addeq	r0, #1
 8000262:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000266:	3001      	addeq	r0, #1
 8000268:	bcf0      	pop	{r4, r5, r6, r7}
 800026a:	3801      	subs	r0, #1
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop

08000270 <__aeabi_drsub>:
 8000270:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000274:	e002      	b.n	800027c <__adddf3>
 8000276:	bf00      	nop

08000278 <__aeabi_dsub>:
 8000278:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800027c <__adddf3>:
 800027c:	b530      	push	{r4, r5, lr}
 800027e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000282:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000286:	ea94 0f05 	teq	r4, r5
 800028a:	bf08      	it	eq
 800028c:	ea90 0f02 	teqeq	r0, r2
 8000290:	bf1f      	itttt	ne
 8000292:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000296:	ea55 0c02 	orrsne.w	ip, r5, r2
 800029a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800029e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002a2:	f000 80e2 	beq.w	800046a <__adddf3+0x1ee>
 80002a6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002aa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ae:	bfb8      	it	lt
 80002b0:	426d      	neglt	r5, r5
 80002b2:	dd0c      	ble.n	80002ce <__adddf3+0x52>
 80002b4:	442c      	add	r4, r5
 80002b6:	ea80 0202 	eor.w	r2, r0, r2
 80002ba:	ea81 0303 	eor.w	r3, r1, r3
 80002be:	ea82 0000 	eor.w	r0, r2, r0
 80002c2:	ea83 0101 	eor.w	r1, r3, r1
 80002c6:	ea80 0202 	eor.w	r2, r0, r2
 80002ca:	ea81 0303 	eor.w	r3, r1, r3
 80002ce:	2d36      	cmp	r5, #54	@ 0x36
 80002d0:	bf88      	it	hi
 80002d2:	bd30      	pophi	{r4, r5, pc}
 80002d4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80002d8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002dc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80002e0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002e4:	d002      	beq.n	80002ec <__adddf3+0x70>
 80002e6:	4240      	negs	r0, r0
 80002e8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002ec:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80002f0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002f4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002f8:	d002      	beq.n	8000300 <__adddf3+0x84>
 80002fa:	4252      	negs	r2, r2
 80002fc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000300:	ea94 0f05 	teq	r4, r5
 8000304:	f000 80a7 	beq.w	8000456 <__adddf3+0x1da>
 8000308:	f1a4 0401 	sub.w	r4, r4, #1
 800030c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000310:	db0d      	blt.n	800032e <__adddf3+0xb2>
 8000312:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000316:	fa22 f205 	lsr.w	r2, r2, r5
 800031a:	1880      	adds	r0, r0, r2
 800031c:	f141 0100 	adc.w	r1, r1, #0
 8000320:	fa03 f20e 	lsl.w	r2, r3, lr
 8000324:	1880      	adds	r0, r0, r2
 8000326:	fa43 f305 	asr.w	r3, r3, r5
 800032a:	4159      	adcs	r1, r3
 800032c:	e00e      	b.n	800034c <__adddf3+0xd0>
 800032e:	f1a5 0520 	sub.w	r5, r5, #32
 8000332:	f10e 0e20 	add.w	lr, lr, #32
 8000336:	2a01      	cmp	r2, #1
 8000338:	fa03 fc0e 	lsl.w	ip, r3, lr
 800033c:	bf28      	it	cs
 800033e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000342:	fa43 f305 	asr.w	r3, r3, r5
 8000346:	18c0      	adds	r0, r0, r3
 8000348:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800034c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000350:	d507      	bpl.n	8000362 <__adddf3+0xe6>
 8000352:	f04f 0e00 	mov.w	lr, #0
 8000356:	f1dc 0c00 	rsbs	ip, ip, #0
 800035a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800035e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000362:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000366:	d31b      	bcc.n	80003a0 <__adddf3+0x124>
 8000368:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800036c:	d30c      	bcc.n	8000388 <__adddf3+0x10c>
 800036e:	0849      	lsrs	r1, r1, #1
 8000370:	ea5f 0030 	movs.w	r0, r0, rrx
 8000374:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000378:	f104 0401 	add.w	r4, r4, #1
 800037c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000380:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8000384:	f080 809a 	bcs.w	80004bc <__adddf3+0x240>
 8000388:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800038c:	bf08      	it	eq
 800038e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000392:	f150 0000 	adcs.w	r0, r0, #0
 8000396:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800039a:	ea41 0105 	orr.w	r1, r1, r5
 800039e:	bd30      	pop	{r4, r5, pc}
 80003a0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003a4:	4140      	adcs	r0, r0
 80003a6:	eb41 0101 	adc.w	r1, r1, r1
 80003aa:	3c01      	subs	r4, #1
 80003ac:	bf28      	it	cs
 80003ae:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80003b2:	d2e9      	bcs.n	8000388 <__adddf3+0x10c>
 80003b4:	f091 0f00 	teq	r1, #0
 80003b8:	bf04      	itt	eq
 80003ba:	4601      	moveq	r1, r0
 80003bc:	2000      	moveq	r0, #0
 80003be:	fab1 f381 	clz	r3, r1
 80003c2:	bf08      	it	eq
 80003c4:	3320      	addeq	r3, #32
 80003c6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ca:	f1b3 0220 	subs.w	r2, r3, #32
 80003ce:	da0c      	bge.n	80003ea <__adddf3+0x16e>
 80003d0:	320c      	adds	r2, #12
 80003d2:	dd08      	ble.n	80003e6 <__adddf3+0x16a>
 80003d4:	f102 0c14 	add.w	ip, r2, #20
 80003d8:	f1c2 020c 	rsb	r2, r2, #12
 80003dc:	fa01 f00c 	lsl.w	r0, r1, ip
 80003e0:	fa21 f102 	lsr.w	r1, r1, r2
 80003e4:	e00c      	b.n	8000400 <__adddf3+0x184>
 80003e6:	f102 0214 	add.w	r2, r2, #20
 80003ea:	bfd8      	it	le
 80003ec:	f1c2 0c20 	rsble	ip, r2, #32
 80003f0:	fa01 f102 	lsl.w	r1, r1, r2
 80003f4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003f8:	bfdc      	itt	le
 80003fa:	ea41 010c 	orrle.w	r1, r1, ip
 80003fe:	4090      	lslle	r0, r2
 8000400:	1ae4      	subs	r4, r4, r3
 8000402:	bfa2      	ittt	ge
 8000404:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000408:	4329      	orrge	r1, r5
 800040a:	bd30      	popge	{r4, r5, pc}
 800040c:	ea6f 0404 	mvn.w	r4, r4
 8000410:	3c1f      	subs	r4, #31
 8000412:	da1c      	bge.n	800044e <__adddf3+0x1d2>
 8000414:	340c      	adds	r4, #12
 8000416:	dc0e      	bgt.n	8000436 <__adddf3+0x1ba>
 8000418:	f104 0414 	add.w	r4, r4, #20
 800041c:	f1c4 0220 	rsb	r2, r4, #32
 8000420:	fa20 f004 	lsr.w	r0, r0, r4
 8000424:	fa01 f302 	lsl.w	r3, r1, r2
 8000428:	ea40 0003 	orr.w	r0, r0, r3
 800042c:	fa21 f304 	lsr.w	r3, r1, r4
 8000430:	ea45 0103 	orr.w	r1, r5, r3
 8000434:	bd30      	pop	{r4, r5, pc}
 8000436:	f1c4 040c 	rsb	r4, r4, #12
 800043a:	f1c4 0220 	rsb	r2, r4, #32
 800043e:	fa20 f002 	lsr.w	r0, r0, r2
 8000442:	fa01 f304 	lsl.w	r3, r1, r4
 8000446:	ea40 0003 	orr.w	r0, r0, r3
 800044a:	4629      	mov	r1, r5
 800044c:	bd30      	pop	{r4, r5, pc}
 800044e:	fa21 f004 	lsr.w	r0, r1, r4
 8000452:	4629      	mov	r1, r5
 8000454:	bd30      	pop	{r4, r5, pc}
 8000456:	f094 0f00 	teq	r4, #0
 800045a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800045e:	bf06      	itte	eq
 8000460:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000464:	3401      	addeq	r4, #1
 8000466:	3d01      	subne	r5, #1
 8000468:	e74e      	b.n	8000308 <__adddf3+0x8c>
 800046a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800046e:	bf18      	it	ne
 8000470:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000474:	d029      	beq.n	80004ca <__adddf3+0x24e>
 8000476:	ea94 0f05 	teq	r4, r5
 800047a:	bf08      	it	eq
 800047c:	ea90 0f02 	teqeq	r0, r2
 8000480:	d005      	beq.n	800048e <__adddf3+0x212>
 8000482:	ea54 0c00 	orrs.w	ip, r4, r0
 8000486:	bf04      	itt	eq
 8000488:	4619      	moveq	r1, r3
 800048a:	4610      	moveq	r0, r2
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	ea91 0f03 	teq	r1, r3
 8000492:	bf1e      	ittt	ne
 8000494:	2100      	movne	r1, #0
 8000496:	2000      	movne	r0, #0
 8000498:	bd30      	popne	{r4, r5, pc}
 800049a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800049e:	d105      	bne.n	80004ac <__adddf3+0x230>
 80004a0:	0040      	lsls	r0, r0, #1
 80004a2:	4149      	adcs	r1, r1
 80004a4:	bf28      	it	cs
 80004a6:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80004aa:	bd30      	pop	{r4, r5, pc}
 80004ac:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80004b0:	bf3c      	itt	cc
 80004b2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80004b6:	bd30      	popcc	{r4, r5, pc}
 80004b8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004bc:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80004c0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80004c4:	f04f 0000 	mov.w	r0, #0
 80004c8:	bd30      	pop	{r4, r5, pc}
 80004ca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ce:	bf1a      	itte	ne
 80004d0:	4619      	movne	r1, r3
 80004d2:	4610      	movne	r0, r2
 80004d4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004d8:	bf1c      	itt	ne
 80004da:	460b      	movne	r3, r1
 80004dc:	4602      	movne	r2, r0
 80004de:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004e2:	bf06      	itte	eq
 80004e4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004e8:	ea91 0f03 	teqeq	r1, r3
 80004ec:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80004f0:	bd30      	pop	{r4, r5, pc}
 80004f2:	bf00      	nop

080004f4 <__aeabi_ui2d>:
 80004f4:	f090 0f00 	teq	r0, #0
 80004f8:	bf04      	itt	eq
 80004fa:	2100      	moveq	r1, #0
 80004fc:	4770      	bxeq	lr
 80004fe:	b530      	push	{r4, r5, lr}
 8000500:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000504:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000508:	f04f 0500 	mov.w	r5, #0
 800050c:	f04f 0100 	mov.w	r1, #0
 8000510:	e750      	b.n	80003b4 <__adddf3+0x138>
 8000512:	bf00      	nop

08000514 <__aeabi_i2d>:
 8000514:	f090 0f00 	teq	r0, #0
 8000518:	bf04      	itt	eq
 800051a:	2100      	moveq	r1, #0
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000524:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000528:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 800052c:	bf48      	it	mi
 800052e:	4240      	negmi	r0, r0
 8000530:	f04f 0100 	mov.w	r1, #0
 8000534:	e73e      	b.n	80003b4 <__adddf3+0x138>
 8000536:	bf00      	nop

08000538 <__aeabi_f2d>:
 8000538:	0042      	lsls	r2, r0, #1
 800053a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800053e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000542:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000546:	bf1f      	itttt	ne
 8000548:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 800054c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000550:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000554:	4770      	bxne	lr
 8000556:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800055a:	bf08      	it	eq
 800055c:	4770      	bxeq	lr
 800055e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000562:	bf04      	itt	eq
 8000564:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000568:	4770      	bxeq	lr
 800056a:	b530      	push	{r4, r5, lr}
 800056c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000570:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000574:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000578:	e71c      	b.n	80003b4 <__adddf3+0x138>
 800057a:	bf00      	nop

0800057c <__aeabi_ul2d>:
 800057c:	ea50 0201 	orrs.w	r2, r0, r1
 8000580:	bf08      	it	eq
 8000582:	4770      	bxeq	lr
 8000584:	b530      	push	{r4, r5, lr}
 8000586:	f04f 0500 	mov.w	r5, #0
 800058a:	e00a      	b.n	80005a2 <__aeabi_l2d+0x16>

0800058c <__aeabi_l2d>:
 800058c:	ea50 0201 	orrs.w	r2, r0, r1
 8000590:	bf08      	it	eq
 8000592:	4770      	bxeq	lr
 8000594:	b530      	push	{r4, r5, lr}
 8000596:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 800059a:	d502      	bpl.n	80005a2 <__aeabi_l2d+0x16>
 800059c:	4240      	negs	r0, r0
 800059e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005a2:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005a6:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005aa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ae:	f43f aed8 	beq.w	8000362 <__adddf3+0xe6>
 80005b2:	f04f 0203 	mov.w	r2, #3
 80005b6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ba:	bf18      	it	ne
 80005bc:	3203      	addne	r2, #3
 80005be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005c2:	bf18      	it	ne
 80005c4:	3203      	addne	r2, #3
 80005c6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005ca:	f1c2 0320 	rsb	r3, r2, #32
 80005ce:	fa00 fc03 	lsl.w	ip, r0, r3
 80005d2:	fa20 f002 	lsr.w	r0, r0, r2
 80005d6:	fa01 fe03 	lsl.w	lr, r1, r3
 80005da:	ea40 000e 	orr.w	r0, r0, lr
 80005de:	fa21 f102 	lsr.w	r1, r1, r2
 80005e2:	4414      	add	r4, r2
 80005e4:	e6bd      	b.n	8000362 <__adddf3+0xe6>
 80005e6:	bf00      	nop

080005e8 <__aeabi_dmul>:
 80005e8:	b570      	push	{r4, r5, r6, lr}
 80005ea:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80005ee:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80005f2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005f6:	bf1d      	ittte	ne
 80005f8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005fc:	ea94 0f0c 	teqne	r4, ip
 8000600:	ea95 0f0c 	teqne	r5, ip
 8000604:	f000 f8de 	bleq	80007c4 <__aeabi_dmul+0x1dc>
 8000608:	442c      	add	r4, r5
 800060a:	ea81 0603 	eor.w	r6, r1, r3
 800060e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000612:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000616:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800061a:	bf18      	it	ne
 800061c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000620:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000624:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000628:	d038      	beq.n	800069c <__aeabi_dmul+0xb4>
 800062a:	fba0 ce02 	umull	ip, lr, r0, r2
 800062e:	f04f 0500 	mov.w	r5, #0
 8000632:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000636:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 800063a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800063e:	f04f 0600 	mov.w	r6, #0
 8000642:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000646:	f09c 0f00 	teq	ip, #0
 800064a:	bf18      	it	ne
 800064c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000650:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000654:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000658:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 800065c:	d204      	bcs.n	8000668 <__aeabi_dmul+0x80>
 800065e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000662:	416d      	adcs	r5, r5
 8000664:	eb46 0606 	adc.w	r6, r6, r6
 8000668:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800066c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000670:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000674:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000678:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800067c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8000680:	bf88      	it	hi
 8000682:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000686:	d81e      	bhi.n	80006c6 <__aeabi_dmul+0xde>
 8000688:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 800068c:	bf08      	it	eq
 800068e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000692:	f150 0000 	adcs.w	r0, r0, #0
 8000696:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800069a:	bd70      	pop	{r4, r5, r6, pc}
 800069c:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 80006a0:	ea46 0101 	orr.w	r1, r6, r1
 80006a4:	ea40 0002 	orr.w	r0, r0, r2
 80006a8:	ea81 0103 	eor.w	r1, r1, r3
 80006ac:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006b0:	bfc2      	ittt	gt
 80006b2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006b6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006ba:	bd70      	popgt	{r4, r5, r6, pc}
 80006bc:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80006c0:	f04f 0e00 	mov.w	lr, #0
 80006c4:	3c01      	subs	r4, #1
 80006c6:	f300 80ab 	bgt.w	8000820 <__aeabi_dmul+0x238>
 80006ca:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80006ce:	bfde      	ittt	le
 80006d0:	2000      	movle	r0, #0
 80006d2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80006d6:	bd70      	pople	{r4, r5, r6, pc}
 80006d8:	f1c4 0400 	rsb	r4, r4, #0
 80006dc:	3c20      	subs	r4, #32
 80006de:	da35      	bge.n	800074c <__aeabi_dmul+0x164>
 80006e0:	340c      	adds	r4, #12
 80006e2:	dc1b      	bgt.n	800071c <__aeabi_dmul+0x134>
 80006e4:	f104 0414 	add.w	r4, r4, #20
 80006e8:	f1c4 0520 	rsb	r5, r4, #32
 80006ec:	fa00 f305 	lsl.w	r3, r0, r5
 80006f0:	fa20 f004 	lsr.w	r0, r0, r4
 80006f4:	fa01 f205 	lsl.w	r2, r1, r5
 80006f8:	ea40 0002 	orr.w	r0, r0, r2
 80006fc:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000700:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000704:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000708:	fa21 f604 	lsr.w	r6, r1, r4
 800070c:	eb42 0106 	adc.w	r1, r2, r6
 8000710:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000714:	bf08      	it	eq
 8000716:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800071a:	bd70      	pop	{r4, r5, r6, pc}
 800071c:	f1c4 040c 	rsb	r4, r4, #12
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f304 	lsl.w	r3, r0, r4
 8000728:	fa20 f005 	lsr.w	r0, r0, r5
 800072c:	fa01 f204 	lsl.w	r2, r1, r4
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000738:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800073c:	f141 0100 	adc.w	r1, r1, #0
 8000740:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000744:	bf08      	it	eq
 8000746:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800074a:	bd70      	pop	{r4, r5, r6, pc}
 800074c:	f1c4 0520 	rsb	r5, r4, #32
 8000750:	fa00 f205 	lsl.w	r2, r0, r5
 8000754:	ea4e 0e02 	orr.w	lr, lr, r2
 8000758:	fa20 f304 	lsr.w	r3, r0, r4
 800075c:	fa01 f205 	lsl.w	r2, r1, r5
 8000760:	ea43 0302 	orr.w	r3, r3, r2
 8000764:	fa21 f004 	lsr.w	r0, r1, r4
 8000768:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800076c:	fa21 f204 	lsr.w	r2, r1, r4
 8000770:	ea20 0002 	bic.w	r0, r0, r2
 8000774:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f094 0f00 	teq	r4, #0
 8000788:	d10f      	bne.n	80007aa <__aeabi_dmul+0x1c2>
 800078a:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 800078e:	0040      	lsls	r0, r0, #1
 8000790:	eb41 0101 	adc.w	r1, r1, r1
 8000794:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000798:	bf08      	it	eq
 800079a:	3c01      	subeq	r4, #1
 800079c:	d0f7      	beq.n	800078e <__aeabi_dmul+0x1a6>
 800079e:	ea41 0106 	orr.w	r1, r1, r6
 80007a2:	f095 0f00 	teq	r5, #0
 80007a6:	bf18      	it	ne
 80007a8:	4770      	bxne	lr
 80007aa:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 80007ae:	0052      	lsls	r2, r2, #1
 80007b0:	eb43 0303 	adc.w	r3, r3, r3
 80007b4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80007b8:	bf08      	it	eq
 80007ba:	3d01      	subeq	r5, #1
 80007bc:	d0f7      	beq.n	80007ae <__aeabi_dmul+0x1c6>
 80007be:	ea43 0306 	orr.w	r3, r3, r6
 80007c2:	4770      	bx	lr
 80007c4:	ea94 0f0c 	teq	r4, ip
 80007c8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007cc:	bf18      	it	ne
 80007ce:	ea95 0f0c 	teqne	r5, ip
 80007d2:	d00c      	beq.n	80007ee <__aeabi_dmul+0x206>
 80007d4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007d8:	bf18      	it	ne
 80007da:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007de:	d1d1      	bne.n	8000784 <__aeabi_dmul+0x19c>
 80007e0:	ea81 0103 	eor.w	r1, r1, r3
 80007e4:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80007e8:	f04f 0000 	mov.w	r0, #0
 80007ec:	bd70      	pop	{r4, r5, r6, pc}
 80007ee:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007f2:	bf06      	itte	eq
 80007f4:	4610      	moveq	r0, r2
 80007f6:	4619      	moveq	r1, r3
 80007f8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007fc:	d019      	beq.n	8000832 <__aeabi_dmul+0x24a>
 80007fe:	ea94 0f0c 	teq	r4, ip
 8000802:	d102      	bne.n	800080a <__aeabi_dmul+0x222>
 8000804:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000808:	d113      	bne.n	8000832 <__aeabi_dmul+0x24a>
 800080a:	ea95 0f0c 	teq	r5, ip
 800080e:	d105      	bne.n	800081c <__aeabi_dmul+0x234>
 8000810:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000814:	bf1c      	itt	ne
 8000816:	4610      	movne	r0, r2
 8000818:	4619      	movne	r1, r3
 800081a:	d10a      	bne.n	8000832 <__aeabi_dmul+0x24a>
 800081c:	ea81 0103 	eor.w	r1, r1, r3
 8000820:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000824:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000828:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800082c:	f04f 0000 	mov.w	r0, #0
 8000830:	bd70      	pop	{r4, r5, r6, pc}
 8000832:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000836:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 800083a:	bd70      	pop	{r4, r5, r6, pc}

0800083c <__aeabi_ddiv>:
 800083c:	b570      	push	{r4, r5, r6, lr}
 800083e:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000842:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000846:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800084a:	bf1d      	ittte	ne
 800084c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000850:	ea94 0f0c 	teqne	r4, ip
 8000854:	ea95 0f0c 	teqne	r5, ip
 8000858:	f000 f8a7 	bleq	80009aa <__aeabi_ddiv+0x16e>
 800085c:	eba4 0405 	sub.w	r4, r4, r5
 8000860:	ea81 0e03 	eor.w	lr, r1, r3
 8000864:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000868:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800086c:	f000 8088 	beq.w	8000980 <__aeabi_ddiv+0x144>
 8000870:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000874:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8000878:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800087c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000880:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000884:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000888:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800088c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000890:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 8000894:	429d      	cmp	r5, r3
 8000896:	bf08      	it	eq
 8000898:	4296      	cmpeq	r6, r2
 800089a:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 800089e:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 80008a2:	d202      	bcs.n	80008aa <__aeabi_ddiv+0x6e>
 80008a4:	085b      	lsrs	r3, r3, #1
 80008a6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008aa:	1ab6      	subs	r6, r6, r2
 80008ac:	eb65 0503 	sbc.w	r5, r5, r3
 80008b0:	085b      	lsrs	r3, r3, #1
 80008b2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008b6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80008ba:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80008be:	ebb6 0e02 	subs.w	lr, r6, r2
 80008c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008c6:	bf22      	ittt	cs
 80008c8:	1ab6      	subcs	r6, r6, r2
 80008ca:	4675      	movcs	r5, lr
 80008cc:	ea40 000c 	orrcs.w	r0, r0, ip
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008de:	bf22      	ittt	cs
 80008e0:	1ab6      	subcs	r6, r6, r2
 80008e2:	4675      	movcs	r5, lr
 80008e4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f6:	bf22      	ittt	cs
 80008f8:	1ab6      	subcs	r6, r6, r2
 80008fa:	4675      	movcs	r5, lr
 80008fc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	ebb6 0e02 	subs.w	lr, r6, r2
 800090a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800090e:	bf22      	ittt	cs
 8000910:	1ab6      	subcs	r6, r6, r2
 8000912:	4675      	movcs	r5, lr
 8000914:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000918:	ea55 0e06 	orrs.w	lr, r5, r6
 800091c:	d018      	beq.n	8000950 <__aeabi_ddiv+0x114>
 800091e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000922:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000926:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800092a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800092e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000932:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000936:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800093a:	d1c0      	bne.n	80008be <__aeabi_ddiv+0x82>
 800093c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000940:	d10b      	bne.n	800095a <__aeabi_ddiv+0x11e>
 8000942:	ea41 0100 	orr.w	r1, r1, r0
 8000946:	f04f 0000 	mov.w	r0, #0
 800094a:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 800094e:	e7b6      	b.n	80008be <__aeabi_ddiv+0x82>
 8000950:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000954:	bf04      	itt	eq
 8000956:	4301      	orreq	r1, r0
 8000958:	2000      	moveq	r0, #0
 800095a:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 800095e:	bf88      	it	hi
 8000960:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000964:	f63f aeaf 	bhi.w	80006c6 <__aeabi_dmul+0xde>
 8000968:	ebb5 0c03 	subs.w	ip, r5, r3
 800096c:	bf04      	itt	eq
 800096e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000972:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000976:	f150 0000 	adcs.w	r0, r0, #0
 800097a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800097e:	bd70      	pop	{r4, r5, r6, pc}
 8000980:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 8000984:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000988:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800098c:	bfc2      	ittt	gt
 800098e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000992:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000996:	bd70      	popgt	{r4, r5, r6, pc}
 8000998:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 800099c:	f04f 0e00 	mov.w	lr, #0
 80009a0:	3c01      	subs	r4, #1
 80009a2:	e690      	b.n	80006c6 <__aeabi_dmul+0xde>
 80009a4:	ea45 0e06 	orr.w	lr, r5, r6
 80009a8:	e68d      	b.n	80006c6 <__aeabi_dmul+0xde>
 80009aa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009ae:	ea94 0f0c 	teq	r4, ip
 80009b2:	bf08      	it	eq
 80009b4:	ea95 0f0c 	teqeq	r5, ip
 80009b8:	f43f af3b 	beq.w	8000832 <__aeabi_dmul+0x24a>
 80009bc:	ea94 0f0c 	teq	r4, ip
 80009c0:	d10a      	bne.n	80009d8 <__aeabi_ddiv+0x19c>
 80009c2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009c6:	f47f af34 	bne.w	8000832 <__aeabi_dmul+0x24a>
 80009ca:	ea95 0f0c 	teq	r5, ip
 80009ce:	f47f af25 	bne.w	800081c <__aeabi_dmul+0x234>
 80009d2:	4610      	mov	r0, r2
 80009d4:	4619      	mov	r1, r3
 80009d6:	e72c      	b.n	8000832 <__aeabi_dmul+0x24a>
 80009d8:	ea95 0f0c 	teq	r5, ip
 80009dc:	d106      	bne.n	80009ec <__aeabi_ddiv+0x1b0>
 80009de:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009e2:	f43f aefd 	beq.w	80007e0 <__aeabi_dmul+0x1f8>
 80009e6:	4610      	mov	r0, r2
 80009e8:	4619      	mov	r1, r3
 80009ea:	e722      	b.n	8000832 <__aeabi_dmul+0x24a>
 80009ec:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009f0:	bf18      	it	ne
 80009f2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009f6:	f47f aec5 	bne.w	8000784 <__aeabi_dmul+0x19c>
 80009fa:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009fe:	f47f af0d 	bne.w	800081c <__aeabi_dmul+0x234>
 8000a02:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a06:	f47f aeeb 	bne.w	80007e0 <__aeabi_dmul+0x1f8>
 8000a0a:	e712      	b.n	8000832 <__aeabi_dmul+0x24a>

08000a0c <__aeabi_d2f>:
 8000a0c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a10:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000a14:	bf24      	itt	cs
 8000a16:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000a1a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000a1e:	d90d      	bls.n	8000a3c <__aeabi_d2f+0x30>
 8000a20:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000a24:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a28:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a2c:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000a30:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a34:	bf08      	it	eq
 8000a36:	f020 0001 	biceq.w	r0, r0, #1
 8000a3a:	4770      	bx	lr
 8000a3c:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000a40:	d121      	bne.n	8000a86 <__aeabi_d2f+0x7a>
 8000a42:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000a46:	bfbc      	itt	lt
 8000a48:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000a4c:	4770      	bxlt	lr
 8000a4e:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000a52:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a56:	f1c2 0218 	rsb	r2, r2, #24
 8000a5a:	f1c2 0c20 	rsb	ip, r2, #32
 8000a5e:	fa10 f30c 	lsls.w	r3, r0, ip
 8000a62:	fa20 f002 	lsr.w	r0, r0, r2
 8000a66:	bf18      	it	ne
 8000a68:	f040 0001 	orrne.w	r0, r0, #1
 8000a6c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a70:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000a74:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000a78:	ea40 000c 	orr.w	r0, r0, ip
 8000a7c:	fa23 f302 	lsr.w	r3, r3, r2
 8000a80:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000a84:	e7cc      	b.n	8000a20 <__aeabi_d2f+0x14>
 8000a86:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000a8a:	d107      	bne.n	8000a9c <__aeabi_d2f+0x90>
 8000a8c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000a90:	bf1e      	ittt	ne
 8000a92:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000a96:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000a9a:	4770      	bxne	lr
 8000a9c:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000aa0:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000aa4:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000aa8:	4770      	bx	lr
 8000aaa:	bf00      	nop

08000aac <__aeabi_uldivmod>:
 8000aac:	b953      	cbnz	r3, 8000ac4 <__aeabi_uldivmod+0x18>
 8000aae:	b94a      	cbnz	r2, 8000ac4 <__aeabi_uldivmod+0x18>
 8000ab0:	2900      	cmp	r1, #0
 8000ab2:	bf08      	it	eq
 8000ab4:	2800      	cmpeq	r0, #0
 8000ab6:	bf1c      	itt	ne
 8000ab8:	f04f 31ff 	movne.w	r1, #4294967295
 8000abc:	f04f 30ff 	movne.w	r0, #4294967295
 8000ac0:	f000 b96a 	b.w	8000d98 <__aeabi_idiv0>
 8000ac4:	f1ad 0c08 	sub.w	ip, sp, #8
 8000ac8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000acc:	f000 f806 	bl	8000adc <__udivmoddi4>
 8000ad0:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000ad4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ad8:	b004      	add	sp, #16
 8000ada:	4770      	bx	lr

08000adc <__udivmoddi4>:
 8000adc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000ae0:	9d08      	ldr	r5, [sp, #32]
 8000ae2:	460c      	mov	r4, r1
 8000ae4:	2b00      	cmp	r3, #0
 8000ae6:	d14e      	bne.n	8000b86 <__udivmoddi4+0xaa>
 8000ae8:	4694      	mov	ip, r2
 8000aea:	458c      	cmp	ip, r1
 8000aec:	4686      	mov	lr, r0
 8000aee:	fab2 f282 	clz	r2, r2
 8000af2:	d962      	bls.n	8000bba <__udivmoddi4+0xde>
 8000af4:	b14a      	cbz	r2, 8000b0a <__udivmoddi4+0x2e>
 8000af6:	f1c2 0320 	rsb	r3, r2, #32
 8000afa:	4091      	lsls	r1, r2
 8000afc:	fa20 f303 	lsr.w	r3, r0, r3
 8000b00:	fa0c fc02 	lsl.w	ip, ip, r2
 8000b04:	4319      	orrs	r1, r3
 8000b06:	fa00 fe02 	lsl.w	lr, r0, r2
 8000b0a:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000b0e:	fa1f f68c 	uxth.w	r6, ip
 8000b12:	fbb1 f4f7 	udiv	r4, r1, r7
 8000b16:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000b1a:	fb07 1114 	mls	r1, r7, r4, r1
 8000b1e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b22:	fb04 f106 	mul.w	r1, r4, r6
 8000b26:	4299      	cmp	r1, r3
 8000b28:	d90a      	bls.n	8000b40 <__udivmoddi4+0x64>
 8000b2a:	eb1c 0303 	adds.w	r3, ip, r3
 8000b2e:	f104 30ff 	add.w	r0, r4, #4294967295
 8000b32:	f080 8112 	bcs.w	8000d5a <__udivmoddi4+0x27e>
 8000b36:	4299      	cmp	r1, r3
 8000b38:	f240 810f 	bls.w	8000d5a <__udivmoddi4+0x27e>
 8000b3c:	3c02      	subs	r4, #2
 8000b3e:	4463      	add	r3, ip
 8000b40:	1a59      	subs	r1, r3, r1
 8000b42:	fa1f f38e 	uxth.w	r3, lr
 8000b46:	fbb1 f0f7 	udiv	r0, r1, r7
 8000b4a:	fb07 1110 	mls	r1, r7, r0, r1
 8000b4e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b52:	fb00 f606 	mul.w	r6, r0, r6
 8000b56:	429e      	cmp	r6, r3
 8000b58:	d90a      	bls.n	8000b70 <__udivmoddi4+0x94>
 8000b5a:	eb1c 0303 	adds.w	r3, ip, r3
 8000b5e:	f100 31ff 	add.w	r1, r0, #4294967295
 8000b62:	f080 80fc 	bcs.w	8000d5e <__udivmoddi4+0x282>
 8000b66:	429e      	cmp	r6, r3
 8000b68:	f240 80f9 	bls.w	8000d5e <__udivmoddi4+0x282>
 8000b6c:	4463      	add	r3, ip
 8000b6e:	3802      	subs	r0, #2
 8000b70:	1b9b      	subs	r3, r3, r6
 8000b72:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000b76:	2100      	movs	r1, #0
 8000b78:	b11d      	cbz	r5, 8000b82 <__udivmoddi4+0xa6>
 8000b7a:	40d3      	lsrs	r3, r2
 8000b7c:	2200      	movs	r2, #0
 8000b7e:	e9c5 3200 	strd	r3, r2, [r5]
 8000b82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b86:	428b      	cmp	r3, r1
 8000b88:	d905      	bls.n	8000b96 <__udivmoddi4+0xba>
 8000b8a:	b10d      	cbz	r5, 8000b90 <__udivmoddi4+0xb4>
 8000b8c:	e9c5 0100 	strd	r0, r1, [r5]
 8000b90:	2100      	movs	r1, #0
 8000b92:	4608      	mov	r0, r1
 8000b94:	e7f5      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000b96:	fab3 f183 	clz	r1, r3
 8000b9a:	2900      	cmp	r1, #0
 8000b9c:	d146      	bne.n	8000c2c <__udivmoddi4+0x150>
 8000b9e:	42a3      	cmp	r3, r4
 8000ba0:	d302      	bcc.n	8000ba8 <__udivmoddi4+0xcc>
 8000ba2:	4290      	cmp	r0, r2
 8000ba4:	f0c0 80f0 	bcc.w	8000d88 <__udivmoddi4+0x2ac>
 8000ba8:	1a86      	subs	r6, r0, r2
 8000baa:	eb64 0303 	sbc.w	r3, r4, r3
 8000bae:	2001      	movs	r0, #1
 8000bb0:	2d00      	cmp	r5, #0
 8000bb2:	d0e6      	beq.n	8000b82 <__udivmoddi4+0xa6>
 8000bb4:	e9c5 6300 	strd	r6, r3, [r5]
 8000bb8:	e7e3      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000bba:	2a00      	cmp	r2, #0
 8000bbc:	f040 8090 	bne.w	8000ce0 <__udivmoddi4+0x204>
 8000bc0:	eba1 040c 	sub.w	r4, r1, ip
 8000bc4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000bc8:	fa1f f78c 	uxth.w	r7, ip
 8000bcc:	2101      	movs	r1, #1
 8000bce:	fbb4 f6f8 	udiv	r6, r4, r8
 8000bd2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000bd6:	fb08 4416 	mls	r4, r8, r6, r4
 8000bda:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000bde:	fb07 f006 	mul.w	r0, r7, r6
 8000be2:	4298      	cmp	r0, r3
 8000be4:	d908      	bls.n	8000bf8 <__udivmoddi4+0x11c>
 8000be6:	eb1c 0303 	adds.w	r3, ip, r3
 8000bea:	f106 34ff 	add.w	r4, r6, #4294967295
 8000bee:	d202      	bcs.n	8000bf6 <__udivmoddi4+0x11a>
 8000bf0:	4298      	cmp	r0, r3
 8000bf2:	f200 80cd 	bhi.w	8000d90 <__udivmoddi4+0x2b4>
 8000bf6:	4626      	mov	r6, r4
 8000bf8:	1a1c      	subs	r4, r3, r0
 8000bfa:	fa1f f38e 	uxth.w	r3, lr
 8000bfe:	fbb4 f0f8 	udiv	r0, r4, r8
 8000c02:	fb08 4410 	mls	r4, r8, r0, r4
 8000c06:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000c0a:	fb00 f707 	mul.w	r7, r0, r7
 8000c0e:	429f      	cmp	r7, r3
 8000c10:	d908      	bls.n	8000c24 <__udivmoddi4+0x148>
 8000c12:	eb1c 0303 	adds.w	r3, ip, r3
 8000c16:	f100 34ff 	add.w	r4, r0, #4294967295
 8000c1a:	d202      	bcs.n	8000c22 <__udivmoddi4+0x146>
 8000c1c:	429f      	cmp	r7, r3
 8000c1e:	f200 80b0 	bhi.w	8000d82 <__udivmoddi4+0x2a6>
 8000c22:	4620      	mov	r0, r4
 8000c24:	1bdb      	subs	r3, r3, r7
 8000c26:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000c2a:	e7a5      	b.n	8000b78 <__udivmoddi4+0x9c>
 8000c2c:	f1c1 0620 	rsb	r6, r1, #32
 8000c30:	408b      	lsls	r3, r1
 8000c32:	fa22 f706 	lsr.w	r7, r2, r6
 8000c36:	431f      	orrs	r7, r3
 8000c38:	fa20 fc06 	lsr.w	ip, r0, r6
 8000c3c:	fa04 f301 	lsl.w	r3, r4, r1
 8000c40:	ea43 030c 	orr.w	r3, r3, ip
 8000c44:	40f4      	lsrs	r4, r6
 8000c46:	fa00 f801 	lsl.w	r8, r0, r1
 8000c4a:	0c38      	lsrs	r0, r7, #16
 8000c4c:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000c50:	fbb4 fef0 	udiv	lr, r4, r0
 8000c54:	fa1f fc87 	uxth.w	ip, r7
 8000c58:	fb00 441e 	mls	r4, r0, lr, r4
 8000c5c:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000c60:	fb0e f90c 	mul.w	r9, lr, ip
 8000c64:	45a1      	cmp	r9, r4
 8000c66:	fa02 f201 	lsl.w	r2, r2, r1
 8000c6a:	d90a      	bls.n	8000c82 <__udivmoddi4+0x1a6>
 8000c6c:	193c      	adds	r4, r7, r4
 8000c6e:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000c72:	f080 8084 	bcs.w	8000d7e <__udivmoddi4+0x2a2>
 8000c76:	45a1      	cmp	r9, r4
 8000c78:	f240 8081 	bls.w	8000d7e <__udivmoddi4+0x2a2>
 8000c7c:	f1ae 0e02 	sub.w	lr, lr, #2
 8000c80:	443c      	add	r4, r7
 8000c82:	eba4 0409 	sub.w	r4, r4, r9
 8000c86:	fa1f f983 	uxth.w	r9, r3
 8000c8a:	fbb4 f3f0 	udiv	r3, r4, r0
 8000c8e:	fb00 4413 	mls	r4, r0, r3, r4
 8000c92:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000c96:	fb03 fc0c 	mul.w	ip, r3, ip
 8000c9a:	45a4      	cmp	ip, r4
 8000c9c:	d907      	bls.n	8000cae <__udivmoddi4+0x1d2>
 8000c9e:	193c      	adds	r4, r7, r4
 8000ca0:	f103 30ff 	add.w	r0, r3, #4294967295
 8000ca4:	d267      	bcs.n	8000d76 <__udivmoddi4+0x29a>
 8000ca6:	45a4      	cmp	ip, r4
 8000ca8:	d965      	bls.n	8000d76 <__udivmoddi4+0x29a>
 8000caa:	3b02      	subs	r3, #2
 8000cac:	443c      	add	r4, r7
 8000cae:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000cb2:	fba0 9302 	umull	r9, r3, r0, r2
 8000cb6:	eba4 040c 	sub.w	r4, r4, ip
 8000cba:	429c      	cmp	r4, r3
 8000cbc:	46ce      	mov	lr, r9
 8000cbe:	469c      	mov	ip, r3
 8000cc0:	d351      	bcc.n	8000d66 <__udivmoddi4+0x28a>
 8000cc2:	d04e      	beq.n	8000d62 <__udivmoddi4+0x286>
 8000cc4:	b155      	cbz	r5, 8000cdc <__udivmoddi4+0x200>
 8000cc6:	ebb8 030e 	subs.w	r3, r8, lr
 8000cca:	eb64 040c 	sbc.w	r4, r4, ip
 8000cce:	fa04 f606 	lsl.w	r6, r4, r6
 8000cd2:	40cb      	lsrs	r3, r1
 8000cd4:	431e      	orrs	r6, r3
 8000cd6:	40cc      	lsrs	r4, r1
 8000cd8:	e9c5 6400 	strd	r6, r4, [r5]
 8000cdc:	2100      	movs	r1, #0
 8000cde:	e750      	b.n	8000b82 <__udivmoddi4+0xa6>
 8000ce0:	f1c2 0320 	rsb	r3, r2, #32
 8000ce4:	fa20 f103 	lsr.w	r1, r0, r3
 8000ce8:	fa0c fc02 	lsl.w	ip, ip, r2
 8000cec:	fa24 f303 	lsr.w	r3, r4, r3
 8000cf0:	4094      	lsls	r4, r2
 8000cf2:	430c      	orrs	r4, r1
 8000cf4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000cf8:	fa00 fe02 	lsl.w	lr, r0, r2
 8000cfc:	fa1f f78c 	uxth.w	r7, ip
 8000d00:	fbb3 f0f8 	udiv	r0, r3, r8
 8000d04:	fb08 3110 	mls	r1, r8, r0, r3
 8000d08:	0c23      	lsrs	r3, r4, #16
 8000d0a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000d0e:	fb00 f107 	mul.w	r1, r0, r7
 8000d12:	4299      	cmp	r1, r3
 8000d14:	d908      	bls.n	8000d28 <__udivmoddi4+0x24c>
 8000d16:	eb1c 0303 	adds.w	r3, ip, r3
 8000d1a:	f100 36ff 	add.w	r6, r0, #4294967295
 8000d1e:	d22c      	bcs.n	8000d7a <__udivmoddi4+0x29e>
 8000d20:	4299      	cmp	r1, r3
 8000d22:	d92a      	bls.n	8000d7a <__udivmoddi4+0x29e>
 8000d24:	3802      	subs	r0, #2
 8000d26:	4463      	add	r3, ip
 8000d28:	1a5b      	subs	r3, r3, r1
 8000d2a:	b2a4      	uxth	r4, r4
 8000d2c:	fbb3 f1f8 	udiv	r1, r3, r8
 8000d30:	fb08 3311 	mls	r3, r8, r1, r3
 8000d34:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000d38:	fb01 f307 	mul.w	r3, r1, r7
 8000d3c:	42a3      	cmp	r3, r4
 8000d3e:	d908      	bls.n	8000d52 <__udivmoddi4+0x276>
 8000d40:	eb1c 0404 	adds.w	r4, ip, r4
 8000d44:	f101 36ff 	add.w	r6, r1, #4294967295
 8000d48:	d213      	bcs.n	8000d72 <__udivmoddi4+0x296>
 8000d4a:	42a3      	cmp	r3, r4
 8000d4c:	d911      	bls.n	8000d72 <__udivmoddi4+0x296>
 8000d4e:	3902      	subs	r1, #2
 8000d50:	4464      	add	r4, ip
 8000d52:	1ae4      	subs	r4, r4, r3
 8000d54:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000d58:	e739      	b.n	8000bce <__udivmoddi4+0xf2>
 8000d5a:	4604      	mov	r4, r0
 8000d5c:	e6f0      	b.n	8000b40 <__udivmoddi4+0x64>
 8000d5e:	4608      	mov	r0, r1
 8000d60:	e706      	b.n	8000b70 <__udivmoddi4+0x94>
 8000d62:	45c8      	cmp	r8, r9
 8000d64:	d2ae      	bcs.n	8000cc4 <__udivmoddi4+0x1e8>
 8000d66:	ebb9 0e02 	subs.w	lr, r9, r2
 8000d6a:	eb63 0c07 	sbc.w	ip, r3, r7
 8000d6e:	3801      	subs	r0, #1
 8000d70:	e7a8      	b.n	8000cc4 <__udivmoddi4+0x1e8>
 8000d72:	4631      	mov	r1, r6
 8000d74:	e7ed      	b.n	8000d52 <__udivmoddi4+0x276>
 8000d76:	4603      	mov	r3, r0
 8000d78:	e799      	b.n	8000cae <__udivmoddi4+0x1d2>
 8000d7a:	4630      	mov	r0, r6
 8000d7c:	e7d4      	b.n	8000d28 <__udivmoddi4+0x24c>
 8000d7e:	46d6      	mov	lr, sl
 8000d80:	e77f      	b.n	8000c82 <__udivmoddi4+0x1a6>
 8000d82:	4463      	add	r3, ip
 8000d84:	3802      	subs	r0, #2
 8000d86:	e74d      	b.n	8000c24 <__udivmoddi4+0x148>
 8000d88:	4606      	mov	r6, r0
 8000d8a:	4623      	mov	r3, r4
 8000d8c:	4608      	mov	r0, r1
 8000d8e:	e70f      	b.n	8000bb0 <__udivmoddi4+0xd4>
 8000d90:	3e02      	subs	r6, #2
 8000d92:	4463      	add	r3, ip
 8000d94:	e730      	b.n	8000bf8 <__udivmoddi4+0x11c>
 8000d96:	bf00      	nop

08000d98 <__aeabi_idiv0>:
 8000d98:	4770      	bx	lr
 8000d9a:	bf00      	nop

08000d9c <compare_timestamp>:
/*                         second of the two timestamps. It returns as soon as a difference is found    */
/********************************************************************************************************/

int compare_timestamp(const Current_Date_t* ts1_date, const Current_Time_t* ts1_time,
                      const Current_Date_t* ts2_date, const Current_Time_t* ts2_time)
{
 8000d9c:	b480      	push	{r7}
 8000d9e:	b085      	sub	sp, #20
 8000da0:	af00      	add	r7, sp, #0
 8000da2:	60f8      	str	r0, [r7, #12]
 8000da4:	60b9      	str	r1, [r7, #8]
 8000da6:	607a      	str	r2, [r7, #4]
 8000da8:	603b      	str	r3, [r7, #0]
    if (ts1_date->year != ts2_date->year)
 8000daa:	68fb      	ldr	r3, [r7, #12]
 8000dac:	781a      	ldrb	r2, [r3, #0]
 8000dae:	687b      	ldr	r3, [r7, #4]
 8000db0:	781b      	ldrb	r3, [r3, #0]
 8000db2:	429a      	cmp	r2, r3
 8000db4:	d006      	beq.n	8000dc4 <compare_timestamp+0x28>
    {
        return ts1_date->year - ts2_date->year;
 8000db6:	68fb      	ldr	r3, [r7, #12]
 8000db8:	781b      	ldrb	r3, [r3, #0]
 8000dba:	461a      	mov	r2, r3
 8000dbc:	687b      	ldr	r3, [r7, #4]
 8000dbe:	781b      	ldrb	r3, [r3, #0]
 8000dc0:	1ad3      	subs	r3, r2, r3
 8000dc2:	e039      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_date->month != ts2_date->month)
 8000dc4:	68fb      	ldr	r3, [r7, #12]
 8000dc6:	785a      	ldrb	r2, [r3, #1]
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	785b      	ldrb	r3, [r3, #1]
 8000dcc:	429a      	cmp	r2, r3
 8000dce:	d006      	beq.n	8000dde <compare_timestamp+0x42>
    {
        return ts1_date->month - ts2_date->month;
 8000dd0:	68fb      	ldr	r3, [r7, #12]
 8000dd2:	785b      	ldrb	r3, [r3, #1]
 8000dd4:	461a      	mov	r2, r3
 8000dd6:	687b      	ldr	r3, [r7, #4]
 8000dd8:	785b      	ldrb	r3, [r3, #1]
 8000dda:	1ad3      	subs	r3, r2, r3
 8000ddc:	e02c      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_date->date != ts2_date->date)
 8000dde:	68fb      	ldr	r3, [r7, #12]
 8000de0:	789a      	ldrb	r2, [r3, #2]
 8000de2:	687b      	ldr	r3, [r7, #4]
 8000de4:	789b      	ldrb	r3, [r3, #2]
 8000de6:	429a      	cmp	r2, r3
 8000de8:	d006      	beq.n	8000df8 <compare_timestamp+0x5c>
    {
        return ts1_date->date - ts2_date->date;
 8000dea:	68fb      	ldr	r3, [r7, #12]
 8000dec:	789b      	ldrb	r3, [r3, #2]
 8000dee:	461a      	mov	r2, r3
 8000df0:	687b      	ldr	r3, [r7, #4]
 8000df2:	789b      	ldrb	r3, [r3, #2]
 8000df4:	1ad3      	subs	r3, r2, r3
 8000df6:	e01f      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_time->hour != ts2_time->hour)
 8000df8:	68bb      	ldr	r3, [r7, #8]
 8000dfa:	781a      	ldrb	r2, [r3, #0]
 8000dfc:	683b      	ldr	r3, [r7, #0]
 8000dfe:	781b      	ldrb	r3, [r3, #0]
 8000e00:	429a      	cmp	r2, r3
 8000e02:	d006      	beq.n	8000e12 <compare_timestamp+0x76>
    {
        return ts1_time->hour - ts2_time->hour;
 8000e04:	68bb      	ldr	r3, [r7, #8]
 8000e06:	781b      	ldrb	r3, [r3, #0]
 8000e08:	461a      	mov	r2, r3
 8000e0a:	683b      	ldr	r3, [r7, #0]
 8000e0c:	781b      	ldrb	r3, [r3, #0]
 8000e0e:	1ad3      	subs	r3, r2, r3
 8000e10:	e012      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    if (ts1_time->minute != ts2_time->minute)
 8000e12:	68bb      	ldr	r3, [r7, #8]
 8000e14:	785a      	ldrb	r2, [r3, #1]
 8000e16:	683b      	ldr	r3, [r7, #0]
 8000e18:	785b      	ldrb	r3, [r3, #1]
 8000e1a:	429a      	cmp	r2, r3
 8000e1c:	d006      	beq.n	8000e2c <compare_timestamp+0x90>
    {
        return ts1_time->minute - ts2_time->minute;
 8000e1e:	68bb      	ldr	r3, [r7, #8]
 8000e20:	785b      	ldrb	r3, [r3, #1]
 8000e22:	461a      	mov	r2, r3
 8000e24:	683b      	ldr	r3, [r7, #0]
 8000e26:	785b      	ldrb	r3, [r3, #1]
 8000e28:	1ad3      	subs	r3, r2, r3
 8000e2a:	e005      	b.n	8000e38 <compare_timestamp+0x9c>
    }
    return ts1_time->second - ts2_time->second;
 8000e2c:	68bb      	ldr	r3, [r7, #8]
 8000e2e:	789b      	ldrb	r3, [r3, #2]
 8000e30:	461a      	mov	r2, r3
 8000e32:	683b      	ldr	r3, [r7, #0]
 8000e34:	789b      	ldrb	r3, [r3, #2]
 8000e36:	1ad3      	subs	r3, r2, r3
}
 8000e38:	4618      	mov	r0, r3
 8000e3a:	3714      	adds	r7, #20
 8000e3c:	46bd      	mov	sp, r7
 8000e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e42:	4770      	bx	lr

08000e44 <add_video_timestamp>:
/* @Note                 - The function stores the date and time of a video into separate arrays. It    */
/*                         increments the video count as long as it does not exceed the maximum number  */
/*                         of allowed videos.                                                           */
/********************************************************************************************************/
void add_video_timestamp(const Current_Date_t* date, const Current_Time_t* time)
{
 8000e44:	b480      	push	{r7}
 8000e46:	b083      	sub	sp, #12
 8000e48:	af00      	add	r7, sp, #0
 8000e4a:	6078      	str	r0, [r7, #4]
 8000e4c:	6039      	str	r1, [r7, #0]
    if (video_count < MAX_VIDEOS)
 8000e4e:	4b0f      	ldr	r3, [pc, #60]	@ (8000e8c <add_video_timestamp+0x48>)
 8000e50:	681b      	ldr	r3, [r3, #0]
 8000e52:	2b03      	cmp	r3, #3
 8000e54:	dc14      	bgt.n	8000e80 <add_video_timestamp+0x3c>
    {
        memcpy(&video_dates[video_count], date, sizeof(Current_Date_t));
 8000e56:	4b0d      	ldr	r3, [pc, #52]	@ (8000e8c <add_video_timestamp+0x48>)
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	009b      	lsls	r3, r3, #2
 8000e5c:	4a0c      	ldr	r2, [pc, #48]	@ (8000e90 <add_video_timestamp+0x4c>)
 8000e5e:	4413      	add	r3, r2
 8000e60:	687a      	ldr	r2, [r7, #4]
 8000e62:	6812      	ldr	r2, [r2, #0]
 8000e64:	601a      	str	r2, [r3, #0]
        memcpy(&video_times[video_count], time, sizeof(Current_Time_t));
 8000e66:	4b09      	ldr	r3, [pc, #36]	@ (8000e8c <add_video_timestamp+0x48>)
 8000e68:	681b      	ldr	r3, [r3, #0]
 8000e6a:	009b      	lsls	r3, r3, #2
 8000e6c:	4a09      	ldr	r2, [pc, #36]	@ (8000e94 <add_video_timestamp+0x50>)
 8000e6e:	4413      	add	r3, r2
 8000e70:	683a      	ldr	r2, [r7, #0]
 8000e72:	6812      	ldr	r2, [r2, #0]
 8000e74:	601a      	str	r2, [r3, #0]
        video_count++;
 8000e76:	4b05      	ldr	r3, [pc, #20]	@ (8000e8c <add_video_timestamp+0x48>)
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	3301      	adds	r3, #1
 8000e7c:	4a03      	ldr	r2, [pc, #12]	@ (8000e8c <add_video_timestamp+0x48>)
 8000e7e:	6013      	str	r3, [r2, #0]
    }
}
 8000e80:	bf00      	nop
 8000e82:	370c      	adds	r7, #12
 8000e84:	46bd      	mov	sp, r7
 8000e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e8a:	4770      	bx	lr
 8000e8c:	2000225c 	.word	0x2000225c
 8000e90:	2000220c 	.word	0x2000220c
 8000e94:	20002234 	.word	0x20002234

08000e98 <delete_oldest_video>:
/*                         the filename based on the date and time, deletes the file from the filesystem*/
/*                         and then removes the timestamp from the tracking arrays. It decrements the   */
/*                         video count to reflect the deletion.                                         */
/********************************************************************************************************/
void delete_oldest_video(void)
{
 8000e98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e9a:	b0b9      	sub	sp, #228	@ 0xe4
 8000e9c:	af04      	add	r7, sp, #16
    if (video_count > 0)
 8000e9e:	4b52      	ldr	r3, [pc, #328]	@ (8000fe8 <delete_oldest_video+0x150>)
 8000ea0:	681b      	ldr	r3, [r3, #0]
 8000ea2:	2b00      	cmp	r3, #0
 8000ea4:	f340 809c 	ble.w	8000fe0 <delete_oldest_video+0x148>
    {
        int oldest_index = 0;
 8000ea8:	2300      	movs	r3, #0
 8000eaa:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        for (int i = 1; i < video_count; ++i)
 8000eae:	2301      	movs	r3, #1
 8000eb0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8000eb4:	e021      	b.n	8000efa <delete_oldest_video+0x62>
        {
            if (compare_timestamp(&video_dates[i], &video_times[i],
 8000eb6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000eba:	009b      	lsls	r3, r3, #2
 8000ebc:	4a4b      	ldr	r2, [pc, #300]	@ (8000fec <delete_oldest_video+0x154>)
 8000ebe:	1898      	adds	r0, r3, r2
 8000ec0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000ec4:	009b      	lsls	r3, r3, #2
 8000ec6:	4a4a      	ldr	r2, [pc, #296]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000ec8:	1899      	adds	r1, r3, r2
                                  &video_dates[oldest_index], &video_times[oldest_index]) < 0)
 8000eca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000ece:	009b      	lsls	r3, r3, #2
 8000ed0:	4a46      	ldr	r2, [pc, #280]	@ (8000fec <delete_oldest_video+0x154>)
 8000ed2:	441a      	add	r2, r3
 8000ed4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000ed8:	009b      	lsls	r3, r3, #2
 8000eda:	4c45      	ldr	r4, [pc, #276]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000edc:	4423      	add	r3, r4
            if (compare_timestamp(&video_dates[i], &video_times[i],
 8000ede:	f7ff ff5d 	bl	8000d9c <compare_timestamp>
 8000ee2:	4603      	mov	r3, r0
 8000ee4:	2b00      	cmp	r3, #0
 8000ee6:	da03      	bge.n	8000ef0 <delete_oldest_video+0x58>
            {
                oldest_index = i;
 8000ee8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000eec:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        for (int i = 1; i < video_count; ++i)
 8000ef0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8000ef4:	3301      	adds	r3, #1
 8000ef6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8000efa:	4b3b      	ldr	r3, [pc, #236]	@ (8000fe8 <delete_oldest_video+0x150>)
 8000efc:	681b      	ldr	r3, [r3, #0]
 8000efe:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8000f02:	429a      	cmp	r2, r3
 8000f04:	dbd7      	blt.n	8000eb6 <delete_oldest_video+0x1e>
        }

        // Delete the oldest video file
        char filename[64];
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f06:	4a39      	ldr	r2, [pc, #228]	@ (8000fec <delete_oldest_video+0x154>)
 8000f08:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f0c:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f10:	461e      	mov	r6, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f12:	4a36      	ldr	r2, [pc, #216]	@ (8000fec <delete_oldest_video+0x154>)
 8000f14:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f18:	009b      	lsls	r3, r3, #2
 8000f1a:	4413      	add	r3, r2
 8000f1c:	785b      	ldrb	r3, [r3, #1]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f1e:	469c      	mov	ip, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f20:	4a32      	ldr	r2, [pc, #200]	@ (8000fec <delete_oldest_video+0x154>)
 8000f22:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f26:	009b      	lsls	r3, r3, #2
 8000f28:	4413      	add	r3, r2
 8000f2a:	789b      	ldrb	r3, [r3, #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f2c:	4619      	mov	r1, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f2e:	4a30      	ldr	r2, [pc, #192]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000f30:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f34:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f38:	461c      	mov	r4, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f3a:	4a2d      	ldr	r2, [pc, #180]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000f3c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f40:	009b      	lsls	r3, r3, #2
 8000f42:	4413      	add	r3, r2
 8000f44:	785b      	ldrb	r3, [r3, #1]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f46:	461d      	mov	r5, r3
        		video_dates[oldest_index].year, video_dates[oldest_index].month, video_dates[oldest_index].date,video_times[oldest_index].hour, video_times[oldest_index].minute, video_times[oldest_index].second);
 8000f48:	4a29      	ldr	r2, [pc, #164]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000f4a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f4e:	009b      	lsls	r3, r3, #2
 8000f50:	4413      	add	r3, r2
 8000f52:	789b      	ldrb	r3, [r3, #2]
        sprintf(filename, "%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8000f54:	1d38      	adds	r0, r7, #4
 8000f56:	9303      	str	r3, [sp, #12]
 8000f58:	9502      	str	r5, [sp, #8]
 8000f5a:	9401      	str	r4, [sp, #4]
 8000f5c:	9100      	str	r1, [sp, #0]
 8000f5e:	4663      	mov	r3, ip
 8000f60:	4632      	mov	r2, r6
 8000f62:	4924      	ldr	r1, [pc, #144]	@ (8000ff4 <delete_oldest_video+0x15c>)
 8000f64:	f02e fcfc 	bl	802f960 <siprintf>
        char filepath[128];
        sprintf(filepath, "/VIDEO/%s", filename);
 8000f68:	1d3a      	adds	r2, r7, #4
 8000f6a:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8000f6e:	4922      	ldr	r1, [pc, #136]	@ (8000ff8 <delete_oldest_video+0x160>)
 8000f70:	4618      	mov	r0, r3
 8000f72:	f02e fcf5 	bl	802f960 <siprintf>
        f_unlink(filepath);
 8000f76:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 8000f7a:	4618      	mov	r0, r3
 8000f7c:	f011 fc2f 	bl	80127de <f_unlink>

        // Remove the oldest timestamp from the list
        for (int i = oldest_index; i < video_count - 1; ++i)
 8000f80:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8000f84:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8000f88:	e01e      	b.n	8000fc8 <delete_oldest_video+0x130>
        {
            memcpy(&video_dates[i], &video_dates[i + 1], sizeof(Current_Time_t));
 8000f8a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8000f8e:	009b      	lsls	r3, r3, #2
 8000f90:	4a16      	ldr	r2, [pc, #88]	@ (8000fec <delete_oldest_video+0x154>)
 8000f92:	4413      	add	r3, r2
 8000f94:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8000f98:	3201      	adds	r2, #1
 8000f9a:	0092      	lsls	r2, r2, #2
 8000f9c:	4913      	ldr	r1, [pc, #76]	@ (8000fec <delete_oldest_video+0x154>)
 8000f9e:	440a      	add	r2, r1
 8000fa0:	6812      	ldr	r2, [r2, #0]
 8000fa2:	601a      	str	r2, [r3, #0]
            memcpy(&video_times[i], &video_times[i + 1], sizeof(Current_Time_t));
 8000fa4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8000fa8:	009b      	lsls	r3, r3, #2
 8000faa:	4a11      	ldr	r2, [pc, #68]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000fac:	4413      	add	r3, r2
 8000fae:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8000fb2:	3201      	adds	r2, #1
 8000fb4:	0092      	lsls	r2, r2, #2
 8000fb6:	490e      	ldr	r1, [pc, #56]	@ (8000ff0 <delete_oldest_video+0x158>)
 8000fb8:	440a      	add	r2, r1
 8000fba:	6812      	ldr	r2, [r2, #0]
 8000fbc:	601a      	str	r2, [r3, #0]
        for (int i = oldest_index; i < video_count - 1; ++i)
 8000fbe:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8000fc2:	3301      	adds	r3, #1
 8000fc4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8000fc8:	4b07      	ldr	r3, [pc, #28]	@ (8000fe8 <delete_oldest_video+0x150>)
 8000fca:	681b      	ldr	r3, [r3, #0]
 8000fcc:	3b01      	subs	r3, #1
 8000fce:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8000fd2:	429a      	cmp	r2, r3
 8000fd4:	dbd9      	blt.n	8000f8a <delete_oldest_video+0xf2>
        }
        video_count--;
 8000fd6:	4b04      	ldr	r3, [pc, #16]	@ (8000fe8 <delete_oldest_video+0x150>)
 8000fd8:	681b      	ldr	r3, [r3, #0]
 8000fda:	3b01      	subs	r3, #1
 8000fdc:	4a02      	ldr	r2, [pc, #8]	@ (8000fe8 <delete_oldest_video+0x150>)
 8000fde:	6013      	str	r3, [r2, #0]
    }
}
 8000fe0:	bf00      	nop
 8000fe2:	37d4      	adds	r7, #212	@ 0xd4
 8000fe4:	46bd      	mov	sp, r7
 8000fe6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000fe8:	2000225c 	.word	0x2000225c
 8000fec:	2000220c 	.word	0x2000220c
 8000ff0:	20002234 	.word	0x20002234
 8000ff4:	08030160 	.word	0x08030160
 8000ff8:	08030188 	.word	0x08030188

08000ffc <check_delete_oldest_video>:
/* @Note                 - This function is a safeguard to prevent exceeding the maximum number of      */
/*                         videos allowed. It calls the function to delete the oldest video when the    */
/*                         video count surpasses the maximum threshold.                                 */
/********************************************************************************************************/
void check_delete_oldest_video(void)
{
 8000ffc:	b580      	push	{r7, lr}
 8000ffe:	af00      	add	r7, sp, #0
    if (video_count >= MAX_VIDEOS)
 8001000:	4b03      	ldr	r3, [pc, #12]	@ (8001010 <check_delete_oldest_video+0x14>)
 8001002:	681b      	ldr	r3, [r3, #0]
 8001004:	2b03      	cmp	r3, #3
 8001006:	dd01      	ble.n	800100c <check_delete_oldest_video+0x10>
    {
        delete_oldest_video();
 8001008:	f7ff ff46 	bl	8000e98 <delete_oldest_video>
    }
}
 800100c:	bf00      	nop
 800100e:	bd80      	pop	{r7, pc}
 8001010:	2000225c 	.word	0x2000225c

08001014 <rec_begin>:
/*                         list of recorded videos, checks and deletes the oldest video if necessary,   */
/*                         and then starts the recording process by creating a new AVI file named with  */
/*                         the current timestamp and beginning the MJPEG AVI output.                    */
/********************************************************************************************************/
void rec_begin(void)
{
 8001014:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001016:	b097      	sub	sp, #92	@ 0x5c
 8001018:	af04      	add	r7, sp, #16

	Current_Date_Handle_t sCurrent;
    RTC_GetTime(&hrtc, &sCurrent);
 800101a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800101e:	4619      	mov	r1, r3
 8001020:	4825      	ldr	r0, [pc, #148]	@ (80010b8 <rec_begin+0xa4>)
 8001022:	f008 fff1 	bl	800a008 <RTC_GetTime>
    RTC_GetDate(&hrtc, &sCurrent);
 8001026:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800102a:	4619      	mov	r1, r3
 800102c:	4822      	ldr	r0, [pc, #136]	@ (80010b8 <rec_begin+0xa4>)
 800102e:	f009 f841 	bl	800a0b4 <RTC_GetDate>

    // Add the timestamp to the list
    add_video_timestamp(&sCurrent.Date, &sCurrent.Time);
 8001032:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 8001036:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800103a:	3304      	adds	r3, #4
 800103c:	4611      	mov	r1, r2
 800103e:	4618      	mov	r0, r3
 8001040:	f7ff ff00 	bl	8000e44 <add_video_timestamp>

    // Delete the oldest video if there are already 10 videos recorded
    check_delete_oldest_video();
 8001044:	f7ff ffda 	bl	8000ffc <check_delete_oldest_video>

	char fn[64];
	memset(fn, 0, 64);
 8001048:	463b      	mov	r3, r7
 800104a:	2240      	movs	r2, #64	@ 0x40
 800104c:	2100      	movs	r1, #0
 800104e:	4618      	mov	r0, r3
 8001050:	f02e fca6 	bl	802f9a0 <memset>

	sprintf(fn, "0:/VIDEO/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 8001054:	f897 3044 	ldrb.w	r3, [r7, #68]	@ 0x44
	sprintf(fn, "0:/VIDEO/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8001058:	461d      	mov	r5, r3
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 800105a:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
	sprintf(fn, "0:/VIDEO/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 800105e:	461e      	mov	r6, r3
			sCurrent.Date.year, sCurrent.Date.month, sCurrent.Date.date, sCurrent.Time.hour, sCurrent.Time.minute, sCurrent.Time.second);
 8001060:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 8001064:	f897 2040 	ldrb.w	r2, [r7, #64]	@ 0x40
 8001068:	f897 1041 	ldrb.w	r1, [r7, #65]	@ 0x41
 800106c:	f897 0042 	ldrb.w	r0, [r7, #66]	@ 0x42
	sprintf(fn, "0:/VIDEO/%02dy%02dm%02dd_REC_%02d_%02d_%02d.avi",
 8001070:	4604      	mov	r4, r0
 8001072:	4638      	mov	r0, r7
 8001074:	9403      	str	r4, [sp, #12]
 8001076:	9102      	str	r1, [sp, #8]
 8001078:	9201      	str	r2, [sp, #4]
 800107a:	9300      	str	r3, [sp, #0]
 800107c:	4633      	mov	r3, r6
 800107e:	462a      	mov	r2, r5
 8001080:	490e      	ldr	r1, [pc, #56]	@ (80010bc <rec_begin+0xa8>)
 8001082:	f02e fc6d 	bl	802f960 <siprintf>
	res = f_open(&file, fn, FA_CREATE_ALWAYS|FA_WRITE);
 8001086:	463b      	mov	r3, r7
 8001088:	220a      	movs	r2, #10
 800108a:	4619      	mov	r1, r3
 800108c:	480c      	ldr	r0, [pc, #48]	@ (80010c0 <rec_begin+0xac>)
 800108e:	f010 f835 	bl	80110fc <f_open>
 8001092:	4603      	mov	r3, r0
 8001094:	461a      	mov	r2, r3
 8001096:	4b0b      	ldr	r3, [pc, #44]	@ (80010c4 <rec_begin+0xb0>)
 8001098:	701a      	strb	r2, [r3, #0]
	if (res==FR_OK)
 800109a:	4b0a      	ldr	r3, [pc, #40]	@ (80010c4 <rec_begin+0xb0>)
 800109c:	781b      	ldrb	r3, [r3, #0]
 800109e:	2b00      	cmp	r3, #0
 80010a0:	d105      	bne.n	80010ae <rec_begin+0x9a>
	{
	  start_output_mjpeg_avi(&file, &hdcmi, (uint8_t)3, (uint8_t)1);
 80010a2:	2301      	movs	r3, #1
 80010a4:	2203      	movs	r2, #3
 80010a6:	4908      	ldr	r1, [pc, #32]	@ (80010c8 <rec_begin+0xb4>)
 80010a8:	4805      	ldr	r0, [pc, #20]	@ (80010c0 <rec_begin+0xac>)
 80010aa:	f007 fa93 	bl	80085d4 <start_output_mjpeg_avi>
	}
}
 80010ae:	bf00      	nop
 80010b0:	374c      	adds	r7, #76	@ 0x4c
 80010b2:	46bd      	mov	sp, r7
 80010b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80010b6:	bf00      	nop
 80010b8:	20000164 	.word	0x20000164
 80010bc:	08030194 	.word	0x08030194
 80010c0:	200011b0 	.word	0x200011b0
 80010c4:	200011ac 	.word	0x200011ac
 80010c8:	2000009c 	.word	0x2000009c

080010cc <main>:
/*                         clock, peripheral common clocks, and various peripherals. It then enters an  */
/*                         infinite loop where it checks and handles the recording status, and processes*/
/*                         USB host related tasks.                                                      */
/********************************************************************************************************/
int main(void)
{
 80010cc:	b580      	push	{r7, lr}
 80010ce:	af00      	add	r7, sp, #0

	HAL_Init();
 80010d0:	f000 fc38 	bl	8001944 <HAL_Init>

	// configure the system clock
	SystemClock_Config();
 80010d4:	f000 f836 	bl	8001144 <SystemClock_Config>

	// configure the peripherals common clocks */
	PeriphCommonClock_Config();
 80010d8:	f000 f892 	bl	8001200 <PeriphCommonClock_Config>

	// peripheral initialization
	TIM1_Config();
 80010dc:	f009 f98c 	bl	800a3f8 <TIM1_Config>
	MX_USB_HOST_Init();
 80010e0:	f02e f83a 	bl	802f158 <MX_USB_HOST_Init>
	GPIO_Config();
 80010e4:	f000 f8e4 	bl	80012b0 <GPIO_Config>
	DMA_Config();
 80010e8:	f000 f8ce 	bl	8001288 <DMA_Config>
	MX_FATFS_Init();
 80010ec:	f009 f9dc 	bl	800a4a8 <MX_FATFS_Init>
	DCMI_Config();
 80010f0:	f000 f8a2 	bl	8001238 <DCMI_Config>
	I2C_Config();
 80010f4:	f000 f958 	bl	80013a8 <I2C_Config>
	MX_LIBJPEG_Init();
 80010f8:	f009 fb00 	bl	800a6fc <MX_LIBJPEG_Init>
	RTC_Config();
 80010fc:	f000 f99a 	bl	8001434 <RTC_Config>

	// turn on USB powering
	MX_DriverVbusFS(0);
 8001100:	2000      	movs	r0, #0
 8001102:	f02e fb53 	bl	802f7ac <MX_DriverVbusFS>

	while (1)
	{
		if((begin_rec != 0) && (read_avi_output_status() == AVI_READY))
 8001106:	4b0d      	ldr	r3, [pc, #52]	@ (800113c <main+0x70>)
 8001108:	781b      	ldrb	r3, [r3, #0]
 800110a:	b2db      	uxtb	r3, r3
 800110c:	2b00      	cmp	r3, #0
 800110e:	d009      	beq.n	8001124 <main+0x58>
 8001110:	f006 fe8a 	bl	8007e28 <read_avi_output_status>
 8001114:	4603      	mov	r3, r0
 8001116:	2b00      	cmp	r3, #0
 8001118:	d104      	bne.n	8001124 <main+0x58>
		{
			HAL_DCMI_Stop(&hdcmi);
 800111a:	4809      	ldr	r0, [pc, #36]	@ (8001140 <main+0x74>)
 800111c:	f000 fe5a 	bl	8001dd4 <HAL_DCMI_Stop>
			rec_begin();
 8001120:	f7ff ff78 	bl	8001014 <rec_begin>
		}
		if (read_avi_output_status() == AVI_CLOSED_OUT) //output finished
 8001124:	f006 fe80 	bl	8007e28 <read_avi_output_status>
 8001128:	4603      	mov	r3, r0
 800112a:	2b03      	cmp	r3, #3
 800112c:	d102      	bne.n	8001134 <main+0x68>
		{
		  set_avi_output_status(AVI_READY);
 800112e:	2000      	movs	r0, #0
 8001130:	f006 fe6a 	bl	8007e08 <set_avi_output_status>
		}
		MX_USB_HOST_Process();
 8001134:	f02e f836 	bl	802f1a4 <MX_USB_HOST_Process>
		if((begin_rec != 0) && (read_avi_output_status() == AVI_READY))
 8001138:	e7e5      	b.n	8001106 <main+0x3a>
 800113a:	bf00      	nop
 800113c:	20002208 	.word	0x20002208
 8001140:	2000009c 	.word	0x2000009c

08001144 <SystemClock_Config>:
/*                         the RCC oscillators with specified parameters, and configures the CPU, AHB,  */
/*                         and APB buses clocks. It also handles potential errors during configuration  */
/*                         and sets up the MCU output clock (MCO).                         				*/
/********************************************************************************************************/
void SystemClock_Config(void)
{
 8001144:	b580      	push	{r7, lr}
 8001146:	b092      	sub	sp, #72	@ 0x48
 8001148:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800114a:	f107 0318 	add.w	r3, r7, #24
 800114e:	2230      	movs	r2, #48	@ 0x30
 8001150:	2100      	movs	r1, #0
 8001152:	4618      	mov	r0, r3
 8001154:	f02e fc24 	bl	802f9a0 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001158:	1d3b      	adds	r3, r7, #4
 800115a:	2200      	movs	r2, #0
 800115c:	601a      	str	r2, [r3, #0]
 800115e:	605a      	str	r2, [r3, #4]
 8001160:	609a      	str	r2, [r3, #8]
 8001162:	60da      	str	r2, [r3, #12]
 8001164:	611a      	str	r2, [r3, #16]

	/** Configure the main internal regulator output voltage
	*/
	RCC->APB1ENR.bit.pwren = SET;
 8001166:	4a24      	ldr	r2, [pc, #144]	@ (80011f8 <SystemClock_Config+0xb4>)
 8001168:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 800116a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800116e:	6413      	str	r3, [r2, #64]	@ 0x40
	PWR->CR.bit.vos = 1;
 8001170:	4a22      	ldr	r2, [pc, #136]	@ (80011fc <SystemClock_Config+0xb8>)
 8001172:	6813      	ldr	r3, [r2, #0]
 8001174:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001178:	6013      	str	r3, [r2, #0]

	/** Initializes the RCC Oscillators according to the specified parameters
	* in the RCC_OscInitTypeDef structure.
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 800117a:	2309      	movs	r3, #9
 800117c:	61bb      	str	r3, [r7, #24]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800117e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8001182:	61fb      	str	r3, [r7, #28]
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8001184:	2301      	movs	r3, #1
 8001186:	62fb      	str	r3, [r7, #44]	@ 0x2c
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001188:	2302      	movs	r3, #2
 800118a:	633b      	str	r3, [r7, #48]	@ 0x30
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800118c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8001190:	637b      	str	r3, [r7, #52]	@ 0x34
	RCC_OscInitStruct.PLL.PLLM = 4;
 8001192:	2304      	movs	r3, #4
 8001194:	63bb      	str	r3, [r7, #56]	@ 0x38
	RCC_OscInitStruct.PLL.PLLN = 168;
 8001196:	23a8      	movs	r3, #168	@ 0xa8
 8001198:	63fb      	str	r3, [r7, #60]	@ 0x3c
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800119a:	2302      	movs	r3, #2
 800119c:	643b      	str	r3, [r7, #64]	@ 0x40
	RCC_OscInitStruct.PLL.PLLQ = 7;
 800119e:	2307      	movs	r3, #7
 80011a0:	647b      	str	r3, [r7, #68]	@ 0x44
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80011a2:	f107 0318 	add.w	r3, r7, #24
 80011a6:	4618      	mov	r0, r3
 80011a8:	f004 fed4 	bl	8005f54 <HAL_RCC_OscConfig>
 80011ac:	4603      	mov	r3, r0
 80011ae:	2b00      	cmp	r3, #0
 80011b0:	d001      	beq.n	80011b6 <SystemClock_Config+0x72>
	{
		Error_Handler();
 80011b2:	f000 f997 	bl	80014e4 <Error_Handler>
	}

	/** Initializes the CPU, AHB and APB buses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80011b6:	230f      	movs	r3, #15
 80011b8:	607b      	str	r3, [r7, #4]
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80011ba:	2302      	movs	r3, #2
 80011bc:	60bb      	str	r3, [r7, #8]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80011be:	2300      	movs	r3, #0
 80011c0:	60fb      	str	r3, [r7, #12]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80011c2:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 80011c6:	613b      	str	r3, [r7, #16]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80011c8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80011cc:	617b      	str	r3, [r7, #20]

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80011ce:	1d3b      	adds	r3, r7, #4
 80011d0:	2105      	movs	r1, #5
 80011d2:	4618      	mov	r0, r3
 80011d4:	f005 f91e 	bl	8006414 <HAL_RCC_ClockConfig>
 80011d8:	4603      	mov	r3, r0
 80011da:	2b00      	cmp	r3, #0
 80011dc:	d001      	beq.n	80011e2 <SystemClock_Config+0x9e>
	{
		Error_Handler();
 80011de:	f000 f981 	bl	80014e4 <Error_Handler>
	}
	HAL_RCC_MCOConfig(RCC_MCO2, RCC_MCO2SOURCE_PLLI2SCLK, RCC_MCODIV_4);
 80011e2:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
 80011e6:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 80011ea:	2001      	movs	r0, #1
 80011ec:	f005 f9f8 	bl	80065e0 <HAL_RCC_MCOConfig>
}
 80011f0:	bf00      	nop
 80011f2:	3748      	adds	r7, #72	@ 0x48
 80011f4:	46bd      	mov	sp, r7
 80011f6:	bd80      	pop	{r7, pc}
 80011f8:	40023800 	.word	0x40023800
 80011fc:	40007000 	.word	0x40007000

08001200 <PeriphCommonClock_Config>:
/*                         HAL_RCCEx_PeriphCLKConfig function. If the configuration is not successful,  */
/*                         the Error_Handler function is called.                                        */
/********************************************************************************************************/

void PeriphCommonClock_Config(void)
{
 8001200:	b580      	push	{r7, lr}
 8001202:	b084      	sub	sp, #16
 8001204:	af00      	add	r7, sp, #0
	RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001206:	463b      	mov	r3, r7
 8001208:	2200      	movs	r2, #0
 800120a:	601a      	str	r2, [r3, #0]
 800120c:	605a      	str	r2, [r3, #4]
 800120e:	609a      	str	r2, [r3, #8]
 8001210:	60da      	str	r2, [r3, #12]

	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_PLLI2S;
 8001212:	2304      	movs	r3, #4
 8001214:	603b      	str	r3, [r7, #0]
	PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 8001216:	23c0      	movs	r3, #192	@ 0xc0
 8001218:	607b      	str	r3, [r7, #4]
	PeriphClkInitStruct.PLLI2S.PLLI2SR = 4;
 800121a:	2304      	movs	r3, #4
 800121c:	60bb      	str	r3, [r7, #8]
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800121e:	463b      	mov	r3, r7
 8001220:	4618      	mov	r0, r3
 8001222:	f005 fb79 	bl	8006918 <HAL_RCCEx_PeriphCLKConfig>
 8001226:	4603      	mov	r3, r0
 8001228:	2b00      	cmp	r3, #0
 800122a:	d001      	beq.n	8001230 <PeriphCommonClock_Config+0x30>
	{
		Error_Handler();
 800122c:	f000 f95a 	bl	80014e4 <Error_Handler>
	}
}
 8001230:	bf00      	nop
 8001232:	3710      	adds	r7, #16
 8001234:	46bd      	mov	sp, r7
 8001236:	bd80      	pop	{r7, pc}

08001238 <DCMI_Config>:
/* @Note                 - This function initializes the DCMI peripheral with specific synchronization, */
/*                         polarity, capture rate, data mode, and JPEG mode settings. If the            */
/*                         initialization fails, it calls the Error_Handler function.                   */
/********************************************************************************************************/
static void DCMI_Config(void)
{
 8001238:	b580      	push	{r7, lr}
 800123a:	af00      	add	r7, sp, #0
	hdcmi.Instance = DCMI;
 800123c:	4b10      	ldr	r3, [pc, #64]	@ (8001280 <DCMI_Config+0x48>)
 800123e:	4a11      	ldr	r2, [pc, #68]	@ (8001284 <DCMI_Config+0x4c>)
 8001240:	601a      	str	r2, [r3, #0]
	hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
 8001242:	4b0f      	ldr	r3, [pc, #60]	@ (8001280 <DCMI_Config+0x48>)
 8001244:	2200      	movs	r2, #0
 8001246:	605a      	str	r2, [r3, #4]
	hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
 8001248:	4b0d      	ldr	r3, [pc, #52]	@ (8001280 <DCMI_Config+0x48>)
 800124a:	2220      	movs	r2, #32
 800124c:	609a      	str	r2, [r3, #8]
	hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
 800124e:	4b0c      	ldr	r3, [pc, #48]	@ (8001280 <DCMI_Config+0x48>)
 8001250:	2200      	movs	r2, #0
 8001252:	60da      	str	r2, [r3, #12]
	hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
 8001254:	4b0a      	ldr	r3, [pc, #40]	@ (8001280 <DCMI_Config+0x48>)
 8001256:	2200      	movs	r2, #0
 8001258:	611a      	str	r2, [r3, #16]
	hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
 800125a:	4b09      	ldr	r3, [pc, #36]	@ (8001280 <DCMI_Config+0x48>)
 800125c:	2200      	movs	r2, #0
 800125e:	615a      	str	r2, [r3, #20]
	hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
 8001260:	4b07      	ldr	r3, [pc, #28]	@ (8001280 <DCMI_Config+0x48>)
 8001262:	2200      	movs	r2, #0
 8001264:	619a      	str	r2, [r3, #24]
	hdcmi.Init.JPEGMode = DCMI_JPEG_ENABLE;
 8001266:	4b06      	ldr	r3, [pc, #24]	@ (8001280 <DCMI_Config+0x48>)
 8001268:	2208      	movs	r2, #8
 800126a:	621a      	str	r2, [r3, #32]
	if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
 800126c:	4804      	ldr	r0, [pc, #16]	@ (8001280 <DCMI_Config+0x48>)
 800126e:	f000 ff5f 	bl	8002130 <HAL_DCMI_Init>
 8001272:	4603      	mov	r3, r0
 8001274:	2b00      	cmp	r3, #0
 8001276:	d001      	beq.n	800127c <DCMI_Config+0x44>
	{
	Error_Handler();
 8001278:	f000 f934 	bl	80014e4 <Error_Handler>
	}
}
 800127c:	bf00      	nop
 800127e:	bd80      	pop	{r7, pc}
 8001280:	2000009c 	.word	0x2000009c
 8001284:	50050000 	.word	0x50050000

08001288 <DMA_Config>:
/* @Note                 - This function enables the clock for DMA2 and initializes the DMA2_Stream1    */
/*                         interrupt with priority settings. This stream is configured for use with the */
/*                         Digital Camera Interface (DCMI) for image data transfer.                     */
/********************************************************************************************************/
static void DMA_Config(void)
{
 8001288:	b580      	push	{r7, lr}
 800128a:	af00      	add	r7, sp, #0
	// enable DMA2 clock
	RCC->AHB1ENR.bit.dma2en = SET;
 800128c:	4a07      	ldr	r2, [pc, #28]	@ (80012ac <DMA_Config+0x24>)
 800128e:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001290:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8001294:	6313      	str	r3, [r2, #48]	@ 0x30

	// initialize DMA2_Stream1 interrupt which is used for DCMI
	HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0);
 8001296:	2200      	movs	r2, #0
 8001298:	2100      	movs	r1, #0
 800129a:	2039      	movs	r0, #57	@ 0x39
 800129c:	f000 fcc3 	bl	8001c26 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 80012a0:	2039      	movs	r0, #57	@ 0x39
 80012a2:	f000 fcdc 	bl	8001c5e <HAL_NVIC_EnableIRQ>
}
 80012a6:	bf00      	nop
 80012a8:	bd80      	pop	{r7, pc}
 80012aa:	bf00      	nop
 80012ac:	40023800 	.word	0x40023800

080012b0 <GPIO_Config>:
/*                         set to desired states, and configures various pins for their intended        */
/*                         functions such as output, input, alternate function, and external interrupts.*/
/*                         It also sets the priority and enables interrupts for EXTI line 0.            */
/********************************************************************************************************/
static void GPIO_Config(void)
{
 80012b0:	b580      	push	{r7, lr}
 80012b2:	b086      	sub	sp, #24
 80012b4:	af00      	add	r7, sp, #0
	GPIO_Handle_t GPIO_InitStruct = {0};
 80012b6:	f107 0308 	add.w	r3, r7, #8
 80012ba:	2200      	movs	r2, #0
 80012bc:	601a      	str	r2, [r3, #0]
 80012be:	605a      	str	r2, [r3, #4]
 80012c0:	609a      	str	r2, [r3, #8]
 80012c2:	60da      	str	r2, [r3, #12]

	// enable all necessary GPIO clocks
	RCC_AHB1ENR_Reg_t AHB1ENR_temp;
	AHB1ENR_temp.reg = RCC->AHB1ENR.reg;
 80012c4:	4b35      	ldr	r3, [pc, #212]	@ (800139c <GPIO_Config+0xec>)
 80012c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80012c8:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioeen = SET;
 80012ca:	687b      	ldr	r3, [r7, #4]
 80012cc:	f043 0310 	orr.w	r3, r3, #16
 80012d0:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpiohen = SET;
 80012d2:	687b      	ldr	r3, [r7, #4]
 80012d4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80012d8:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpiocen = SET;
 80012da:	687b      	ldr	r3, [r7, #4]
 80012dc:	f043 0304 	orr.w	r3, r3, #4
 80012e0:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioaen = SET;
 80012e2:	687b      	ldr	r3, [r7, #4]
 80012e4:	f043 0301 	orr.w	r3, r3, #1
 80012e8:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioden = SET;
 80012ea:	687b      	ldr	r3, [r7, #4]
 80012ec:	f043 0308 	orr.w	r3, r3, #8
 80012f0:	607b      	str	r3, [r7, #4]
	AHB1ENR_temp.bit.gpioben = SET;
 80012f2:	687b      	ldr	r3, [r7, #4]
 80012f4:	f043 0302 	orr.w	r3, r3, #2
 80012f8:	607b      	str	r3, [r7, #4]
	RCC->AHB1ENR.reg = AHB1ENR_temp.reg;
 80012fa:	4a28      	ldr	r2, [pc, #160]	@ (800139c <GPIO_Config+0xec>)
 80012fc:	687b      	ldr	r3, [r7, #4]
 80012fe:	6313      	str	r3, [r2, #48]	@ 0x30

	// make sure PC0 is low; this pin is used for Drive_VBUS_FS
	GPIO_WritePin(GPIOC, GPIO_PIN_0, RESET);
 8001300:	2200      	movs	r2, #0
 8001302:	2100      	movs	r1, #0
 8001304:	4826      	ldr	r0, [pc, #152]	@ (80013a0 <GPIO_Config+0xf0>)
 8001306:	f008 fa07 	bl	8009718 <GPIO_WritePin>

	// default PWDN pin state when camera is working; you may connect camera's PWDN pin to GND as well
	GPIO_WritePin(GPIOC, CAMERA_PWDN_Pin, RESET);
 800130a:	2200      	movs	r2, #0
 800130c:	210c      	movs	r1, #12
 800130e:	4824      	ldr	r0, [pc, #144]	@ (80013a0 <GPIO_Config+0xf0>)
 8001310:	f008 fa02 	bl	8009718 <GPIO_WritePin>

	// Drive_VBUS_FS pin configuration
	GPIO_InitStruct.pGPIOx = GPIOC;
 8001314:	4b22      	ldr	r3, [pc, #136]	@ (80013a0 <GPIO_Config+0xf0>)
 8001316:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_0;
 8001318:	2300      	movs	r3, #0
 800131a:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_OUTPUT;
 800131c:	2301      	movs	r3, #1
 800131e:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 8001320:	2300      	movs	r3, #0
 8001322:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8001324:	2300      	movs	r3, #0
 8001326:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001328:	2300      	movs	r3, #0
 800132a:	747b      	strb	r3, [r7, #17]
	GPIO_Init(&GPIO_InitStruct);
 800132c:	f107 0308 	add.w	r3, r7, #8
 8001330:	4618      	mov	r0, r3
 8001332:	f007 ffc9 	bl	80092c8 <GPIO_Init>

	// PWDN pin configuration
	GPIO_InitStruct.GPIO_Config.PinNumber = CAMERA_PWDN_Pin;
 8001336:	230c      	movs	r3, #12
 8001338:	60fb      	str	r3, [r7, #12]
	GPIO_Init(&GPIO_InitStruct);
 800133a:	f107 0308 	add.w	r3, r7, #8
 800133e:	4618      	mov	r0, r3
 8001340:	f007 ffc2 	bl	80092c8 <GPIO_Init>

	// configure USER_Btn to be used as EXTI; or use any other EXTI you want
	GPIO_InitStruct.pGPIOx = USER_Btn_GPIO_Port;
 8001344:	4b17      	ldr	r3, [pc, #92]	@ (80013a4 <GPIO_Config+0xf4>)
 8001346:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = USER_Btn_Pin;
 8001348:	2300      	movs	r3, #0
 800134a:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_IT_RT;
 800134c:	2305      	movs	r3, #5
 800134e:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_PULL_DOWN;
 8001350:	2302      	movs	r3, #2
 8001352:	74bb      	strb	r3, [r7, #18]
	GPIO_Init(&GPIO_InitStruct);
 8001354:	f107 0308 	add.w	r3, r7, #8
 8001358:	4618      	mov	r0, r3
 800135a:	f007 ffb5 	bl	80092c8 <GPIO_Init>

	// configure DCMI_XCLX_Pin
	GPIO_InitStruct.pGPIOx = DCMI_XCLX_GPIO_Port;
 800135e:	4b10      	ldr	r3, [pc, #64]	@ (80013a0 <GPIO_Config+0xf0>)
 8001360:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.GPIO_Config.PinNumber = DCMI_XCLX_Pin;
 8001362:	2309      	movs	r3, #9
 8001364:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8001366:	2302      	movs	r3, #2
 8001368:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800136a:	2300      	movs	r3, #0
 800136c:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 800136e:	2300      	movs	r3, #0
 8001370:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001372:	2300      	movs	r3, #0
 8001374:	747b      	strb	r3, [r7, #17]
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 8001376:	2300      	movs	r3, #0
 8001378:	753b      	strb	r3, [r7, #20]
	GPIO_Init(&GPIO_InitStruct);
 800137a:	f107 0308 	add.w	r3, r7, #8
 800137e:	4618      	mov	r0, r3
 8001380:	f007 ffa2 	bl	80092c8 <GPIO_Init>

	HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
 8001384:	2200      	movs	r2, #0
 8001386:	2101      	movs	r1, #1
 8001388:	2006      	movs	r0, #6
 800138a:	f000 fc4c 	bl	8001c26 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 800138e:	2006      	movs	r0, #6
 8001390:	f000 fc65 	bl	8001c5e <HAL_NVIC_EnableIRQ>
}
 8001394:	bf00      	nop
 8001396:	3718      	adds	r7, #24
 8001398:	46bd      	mov	sp, r7
 800139a:	bd80      	pop	{r7, pc}
 800139c:	40023800 	.word	0x40023800
 80013a0:	40020800 	.word	0x40020800
 80013a4:	40020000 	.word	0x40020000

080013a8 <I2C_Config>:
/*                         acknowledgments, and sets the duty cycle. It also configures the GPIO pins   */
/*                         PB8 and PB9 for I2C SCL and SDA functions, respectively, and enables the I2C1*/
/*                         clock in the RCC peripheral clock enable register.                           */
/********************************************************************************************************/
static void I2C_Config(void)
{
 80013a8:	b580      	push	{r7, lr}
 80013aa:	b084      	sub	sp, #16
 80013ac:	af00      	add	r7, sp, #0
	GPIO_Handle_t sI2C_GPIO = {0};
 80013ae:	463b      	mov	r3, r7
 80013b0:	2200      	movs	r2, #0
 80013b2:	601a      	str	r2, [r3, #0]
 80013b4:	605a      	str	r2, [r3, #4]
 80013b6:	609a      	str	r2, [r3, #8]
 80013b8:	60da      	str	r2, [r3, #12]

	hi2c1.pI2Cx = I2C1;
 80013ba:	4b19      	ldr	r3, [pc, #100]	@ (8001420 <I2C_Config+0x78>)
 80013bc:	4a19      	ldr	r2, [pc, #100]	@ (8001424 <I2C_Config+0x7c>)
 80013be:	601a      	str	r2, [r3, #0]
	hi2c1.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_STANDARD;
 80013c0:	4b17      	ldr	r3, [pc, #92]	@ (8001420 <I2C_Config+0x78>)
 80013c2:	4a19      	ldr	r2, [pc, #100]	@ (8001428 <I2C_Config+0x80>)
 80013c4:	605a      	str	r2, [r3, #4]
	hi2c1.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
 80013c6:	4b16      	ldr	r3, [pc, #88]	@ (8001420 <I2C_Config+0x78>)
 80013c8:	2200      	movs	r2, #0
 80013ca:	729a      	strb	r2, [r3, #10]
	hi2c1.I2C_Config.I2C_DeviceAddress = 0;
 80013cc:	4b14      	ldr	r3, [pc, #80]	@ (8001420 <I2C_Config+0x78>)
 80013ce:	2200      	movs	r2, #0
 80013d0:	721a      	strb	r2, [r3, #8]
	hi2c1.I2C_Config.I2C_AckControl = I2C_ACK_DISABLE;
 80013d2:	4b13      	ldr	r3, [pc, #76]	@ (8001420 <I2C_Config+0x78>)
 80013d4:	2200      	movs	r2, #0
 80013d6:	725a      	strb	r2, [r3, #9]
	I2C_Init(&hi2c1);
 80013d8:	4811      	ldr	r0, [pc, #68]	@ (8001420 <I2C_Config+0x78>)
 80013da:	f008 fa6b 	bl	80098b4 <I2C_Init>

	//I2C1 GPIO Configuration
	// PB8 --> I2C1_SCL
	// PB9 --> I2C1_SDA

	sI2C_GPIO.pGPIOx = GPIOB;
 80013de:	4b13      	ldr	r3, [pc, #76]	@ (800142c <I2C_Config+0x84>)
 80013e0:	603b      	str	r3, [r7, #0]
	sI2C_GPIO.GPIO_Config.PinNumber = GPIO_PIN_8;
 80013e2:	2308      	movs	r3, #8
 80013e4:	607b      	str	r3, [r7, #4]
	sI2C_GPIO.GPIO_Config.PinMode = GPIO_MODE_AF;
 80013e6:	2302      	movs	r3, #2
 80013e8:	723b      	strb	r3, [r7, #8]
	sI2C_GPIO.GPIO_Config.PinOPType = GPIO_OUTPUT_OD;
 80013ea:	2301      	movs	r3, #1
 80013ec:	72fb      	strb	r3, [r7, #11]
	sI2C_GPIO.GPIO_Config.PinPuPdControl = GPIO_PIN_PULL_UP;
 80013ee:	2301      	movs	r3, #1
 80013f0:	72bb      	strb	r3, [r7, #10]
	sI2C_GPIO.GPIO_Config.PinSpeed = GPIO_SPEED_HIGH;
 80013f2:	2303      	movs	r3, #3
 80013f4:	727b      	strb	r3, [r7, #9]
	sI2C_GPIO.GPIO_Config.PinAltFuncMode = 4;
 80013f6:	2304      	movs	r3, #4
 80013f8:	733b      	strb	r3, [r7, #12]
	GPIO_Init(&sI2C_GPIO);
 80013fa:	463b      	mov	r3, r7
 80013fc:	4618      	mov	r0, r3
 80013fe:	f007 ff63 	bl	80092c8 <GPIO_Init>

	sI2C_GPIO.GPIO_Config.PinNumber = GPIO_PIN_9;
 8001402:	2309      	movs	r3, #9
 8001404:	607b      	str	r3, [r7, #4]
	GPIO_Init(&sI2C_GPIO);
 8001406:	463b      	mov	r3, r7
 8001408:	4618      	mov	r0, r3
 800140a:	f007 ff5d 	bl	80092c8 <GPIO_Init>

	RCC->APB1ENR.bit.i2c1en = SET;
 800140e:	4a08      	ldr	r2, [pc, #32]	@ (8001430 <I2C_Config+0x88>)
 8001410:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8001412:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8001416:	6413      	str	r3, [r2, #64]	@ 0x40
}
 8001418:	bf00      	nop
 800141a:	3710      	adds	r7, #16
 800141c:	46bd      	mov	sp, r7
 800141e:	bd80      	pop	{r7, pc}
 8001420:	2000013c 	.word	0x2000013c
 8001424:	40005400 	.word	0x40005400
 8001428:	000186a0 	.word	0x000186a0
 800142c:	40020400 	.word	0x40020400
 8001430:	40023800 	.word	0x40023800

08001434 <RTC_Config>:
/*                         predefined prescalers, sets the current time and date, configures an alarm   */
/*                         with specific mask settings, and enables the RTC alarm interrupt with priority*/
/*                         settings. It also unlocks the RTC write protection for further configurations*/
/********************************************************************************************************/
static void RTC_Config(void)
{
 8001434:	b580      	push	{r7, lr}
 8001436:	b082      	sub	sp, #8
 8001438:	af00      	add	r7, sp, #0
	RTC_Alarm_t sAlarm = {0};
 800143a:	463b      	mov	r3, r7
 800143c:	2200      	movs	r2, #0
 800143e:	601a      	str	r2, [r3, #0]
 8001440:	f8c3 2003 	str.w	r2, [r3, #3]

	// initialize RTC working mode
	hrtc.RTC_Config.RTC_HourFormat = RTC_HOURFORMAT_24;
 8001444:	4b25      	ldr	r3, [pc, #148]	@ (80014dc <RTC_Config+0xa8>)
 8001446:	2200      	movs	r2, #0
 8001448:	701a      	strb	r2, [r3, #0]
	hrtc.RTC_Config.RTC_AsynchPrediv = 128;
 800144a:	4b24      	ldr	r3, [pc, #144]	@ (80014dc <RTC_Config+0xa8>)
 800144c:	2280      	movs	r2, #128	@ 0x80
 800144e:	705a      	strb	r2, [r3, #1]
	hrtc.RTC_Config.RTC_SynchPrediv = 256;
 8001450:	4b22      	ldr	r3, [pc, #136]	@ (80014dc <RTC_Config+0xa8>)
 8001452:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001456:	805a      	strh	r2, [r3, #2]

	// set RTC time
	hrtc.Time.hour = 11;
 8001458:	4b20      	ldr	r3, [pc, #128]	@ (80014dc <RTC_Config+0xa8>)
 800145a:	220b      	movs	r2, #11
 800145c:	711a      	strb	r2, [r3, #4]
	hrtc.Time.minute = 22;
 800145e:	4b1f      	ldr	r3, [pc, #124]	@ (80014dc <RTC_Config+0xa8>)
 8001460:	2216      	movs	r2, #22
 8001462:	715a      	strb	r2, [r3, #5]
	hrtc.Time.second = 33;
 8001464:	4b1d      	ldr	r3, [pc, #116]	@ (80014dc <RTC_Config+0xa8>)
 8001466:	2221      	movs	r2, #33	@ 0x21
 8001468:	719a      	strb	r2, [r3, #6]

	// set RTC date
	hrtc.Date.weekDay = WEDNESDAY;
 800146a:	4b1c      	ldr	r3, [pc, #112]	@ (80014dc <RTC_Config+0xa8>)
 800146c:	2203      	movs	r2, #3
 800146e:	72da      	strb	r2, [r3, #11]
	hrtc.Date.month = JANUARY;
 8001470:	4b1a      	ldr	r3, [pc, #104]	@ (80014dc <RTC_Config+0xa8>)
 8001472:	2201      	movs	r2, #1
 8001474:	725a      	strb	r2, [r3, #9]
	hrtc.Date.date = 0x1;
 8001476:	4b19      	ldr	r3, [pc, #100]	@ (80014dc <RTC_Config+0xa8>)
 8001478:	2201      	movs	r2, #1
 800147a:	729a      	strb	r2, [r3, #10]
	hrtc.Date.year = 0x25;
 800147c:	4b17      	ldr	r3, [pc, #92]	@ (80014dc <RTC_Config+0xa8>)
 800147e:	2225      	movs	r2, #37	@ 0x25
 8001480:	721a      	strb	r2, [r3, #8]
	RTC_Init(&hrtc);
 8001482:	4816      	ldr	r0, [pc, #88]	@ (80014dc <RTC_Config+0xa8>)
 8001484:	f008 fc74 	bl	8009d70 <RTC_Init>

	// alarm A configuration
	sAlarm.hour = 00;
 8001488:	2300      	movs	r3, #0
 800148a:	703b      	strb	r3, [r7, #0]
	sAlarm.minute = 00;
 800148c:	2300      	movs	r3, #0
 800148e:	707b      	strb	r3, [r7, #1]
	sAlarm.second = 00;
 8001490:	2300      	movs	r3, #0
 8001492:	70bb      	strb	r3, [r7, #2]
	sAlarm.sec_msk = RTC_ALARM_MASK_UNMASKED;
 8001494:	2300      	movs	r3, #0
 8001496:	70fb      	strb	r3, [r7, #3]
	sAlarm.min_msk = RTC_ALARM_MASK_MINUTES;
 8001498:	2301      	movs	r3, #1
 800149a:	713b      	strb	r3, [r7, #4]
	sAlarm.hour_msk = RTC_ALARM_MASK_HOURS;
 800149c:	2301      	movs	r3, #1
 800149e:	717b      	strb	r3, [r7, #5]
	sAlarm.dateweek_msk = RTC_ALARM_MASK_DATEWEEKDAY;
 80014a0:	2301      	movs	r3, #1
 80014a2:	71bb      	strb	r3, [r7, #6]
	RTC_SetAlarm_IT(&hrtc, RTC_ALARM_A, &sAlarm);
 80014a4:	463b      	mov	r3, r7
 80014a6:	461a      	mov	r2, r3
 80014a8:	2100      	movs	r1, #0
 80014aa:	480c      	ldr	r0, [pc, #48]	@ (80014dc <RTC_Config+0xa8>)
 80014ac:	f008 fe74 	bl	800a198 <RTC_SetAlarm_IT>

	EXTI->IMR.bit.mr17 = SET;
 80014b0:	4a0b      	ldr	r2, [pc, #44]	@ (80014e0 <RTC_Config+0xac>)
 80014b2:	6813      	ldr	r3, [r2, #0]
 80014b4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80014b8:	6013      	str	r3, [r2, #0]
	EXTI->RTSR.bit.tr17 = SET;
 80014ba:	4a09      	ldr	r2, [pc, #36]	@ (80014e0 <RTC_Config+0xac>)
 80014bc:	6893      	ldr	r3, [r2, #8]
 80014be:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80014c2:	6093      	str	r3, [r2, #8]


	HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 80014c4:	2200      	movs	r2, #0
 80014c6:	2100      	movs	r1, #0
 80014c8:	2029      	movs	r0, #41	@ 0x29
 80014ca:	f000 fbac 	bl	8001c26 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 80014ce:	2029      	movs	r0, #41	@ 0x29
 80014d0:	f000 fbc5 	bl	8001c5e <HAL_NVIC_EnableIRQ>

}
 80014d4:	bf00      	nop
 80014d6:	3708      	adds	r7, #8
 80014d8:	46bd      	mov	sp, r7
 80014da:	bd80      	pop	{r7, pc}
 80014dc:	20000164 	.word	0x20000164
 80014e0:	40013c00 	.word	0x40013c00

080014e4 <Error_Handler>:

void Error_Handler(void)
{
 80014e4:	b480      	push	{r7}
 80014e6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014e8:	b672      	cpsid	i
}
 80014ea:	bf00      	nop
	__disable_irq();
	while (1)
 80014ec:	bf00      	nop
 80014ee:	e7fd      	b.n	80014ec <Error_Handler+0x8>

080014f0 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80014f0:	b480      	push	{r7}
 80014f2:	af00      	add	r7, sp, #0

  RCC->APB2ENR.bit.syscfgen = SET;
 80014f4:	4a07      	ldr	r2, [pc, #28]	@ (8001514 <HAL_MspInit+0x24>)
 80014f6:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 80014f8:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80014fc:	6453      	str	r3, [r2, #68]	@ 0x44
  RCC->APB1ENR.bit.pwren = SET;
 80014fe:	4a05      	ldr	r2, [pc, #20]	@ (8001514 <HAL_MspInit+0x24>)
 8001500:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8001502:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8001506:	6413      	str	r3, [r2, #64]	@ 0x40

}
 8001508:	bf00      	nop
 800150a:	46bd      	mov	sp, r7
 800150c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001510:	4770      	bx	lr
 8001512:	bf00      	nop
 8001514:	40023800 	.word	0x40023800

08001518 <HAL_DCMI_MspInit>:
* This function configures the hardware resources used in this example
* @param hdcmi: DCMI handle pointer
* @retval None
*/
void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi)
{
 8001518:	b580      	push	{r7, lr}
 800151a:	b086      	sub	sp, #24
 800151c:	af00      	add	r7, sp, #0
 800151e:	6078      	str	r0, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct = {0};
 8001520:	f107 0308 	add.w	r3, r7, #8
 8001524:	2200      	movs	r2, #0
 8001526:	601a      	str	r2, [r3, #0]
 8001528:	605a      	str	r2, [r3, #4]
 800152a:	609a      	str	r2, [r3, #8]
 800152c:	60da      	str	r2, [r3, #12]
  if(hdcmi->Instance==DCMI)
 800152e:	687b      	ldr	r3, [r7, #4]
 8001530:	681b      	ldr	r3, [r3, #0]
 8001532:	4a70      	ldr	r2, [pc, #448]	@ (80016f4 <HAL_DCMI_MspInit+0x1dc>)
 8001534:	4293      	cmp	r3, r2
 8001536:	f040 80d9 	bne.w	80016ec <HAL_DCMI_MspInit+0x1d4>
  {

    /* Peripheral clock enable */
	  RCC->AHB2ENR.bit.dcmien = SET;
 800153a:	4a6f      	ldr	r2, [pc, #444]	@ (80016f8 <HAL_DCMI_MspInit+0x1e0>)
 800153c:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 800153e:	f043 0301 	orr.w	r3, r3, #1
 8001542:	6353      	str	r3, [r2, #52]	@ 0x34

	  RCC->AHB1ENR.bit.gpioeen = SET;
 8001544:	4a6c      	ldr	r2, [pc, #432]	@ (80016f8 <HAL_DCMI_MspInit+0x1e0>)
 8001546:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001548:	f043 0310 	orr.w	r3, r3, #16
 800154c:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpioaen = SET;
 800154e:	4a6a      	ldr	r2, [pc, #424]	@ (80016f8 <HAL_DCMI_MspInit+0x1e0>)
 8001550:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001552:	f043 0301 	orr.w	r3, r3, #1
 8001556:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpiocen = SET;
 8001558:	4a67      	ldr	r2, [pc, #412]	@ (80016f8 <HAL_DCMI_MspInit+0x1e0>)
 800155a:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 800155c:	f043 0304 	orr.w	r3, r3, #4
 8001560:	6313      	str	r3, [r2, #48]	@ 0x30
	  RCC->AHB1ENR.bit.gpioben = SET;
 8001562:	4a65      	ldr	r2, [pc, #404]	@ (80016f8 <HAL_DCMI_MspInit+0x1e0>)
 8001564:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001566:	f043 0302 	orr.w	r3, r3, #2
 800156a:	6313      	str	r3, [r2, #48]	@ 0x30
    PC8     ------> DCMI_D2
    PB6     ------> DCMI_D5
    PB7     ------> DCMI_VSYNC
    PE1     ------> DCMI_D3
    */
	  GPIO_InitStruct.pGPIOx = GPIOE;
 800156c:	4b63      	ldr	r3, [pc, #396]	@ (80016fc <HAL_DCMI_MspInit+0x1e4>)
 800156e:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_4;
 8001570:	2304      	movs	r3, #4
 8001572:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8001574:	2302      	movs	r3, #2
 8001576:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 8001578:	2300      	movs	r3, #0
 800157a:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 800157c:	2300      	movs	r3, #0
 800157e:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001580:	2300      	movs	r3, #0
 8001582:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 8001584:	230d      	movs	r3, #13
 8001586:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 8001588:	f107 0308 	add.w	r3, r7, #8
 800158c:	4618      	mov	r0, r3
 800158e:	f007 fe9b 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_5;
 8001592:	2305      	movs	r3, #5
 8001594:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001596:	f107 0308 	add.w	r3, r7, #8
 800159a:	4618      	mov	r0, r3
 800159c:	f007 fe94 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 80015a0:	2306      	movs	r3, #6
 80015a2:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80015a4:	f107 0308 	add.w	r3, r7, #8
 80015a8:	4618      	mov	r0, r3
 80015aa:	f007 fe8d 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_1;
 80015ae:	2301      	movs	r3, #1
 80015b0:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80015b2:	f107 0308 	add.w	r3, r7, #8
 80015b6:	4618      	mov	r0, r3
 80015b8:	f007 fe86 	bl	80092c8 <GPIO_Init>


	  GPIO_InitStruct.pGPIOx = GPIOA;
 80015bc:	4b50      	ldr	r3, [pc, #320]	@ (8001700 <HAL_DCMI_MspInit+0x1e8>)
 80015be:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_4;
 80015c0:	2304      	movs	r3, #4
 80015c2:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 80015c4:	2302      	movs	r3, #2
 80015c6:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 80015c8:	2300      	movs	r3, #0
 80015ca:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 80015cc:	2300      	movs	r3, #0
 80015ce:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 80015d0:	2300      	movs	r3, #0
 80015d2:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 80015d4:	230d      	movs	r3, #13
 80015d6:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 80015d8:	f107 0308 	add.w	r3, r7, #8
 80015dc:	4618      	mov	r0, r3
 80015de:	f007 fe73 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 80015e2:	2306      	movs	r3, #6
 80015e4:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 80015e6:	f107 0308 	add.w	r3, r7, #8
 80015ea:	4618      	mov	r0, r3
 80015ec:	f007 fe6c 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.pGPIOx = GPIOC;
 80015f0:	4b44      	ldr	r3, [pc, #272]	@ (8001704 <HAL_DCMI_MspInit+0x1ec>)
 80015f2:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 80015f4:	2306      	movs	r3, #6
 80015f6:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 80015f8:	2302      	movs	r3, #2
 80015fa:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 80015fc:	2300      	movs	r3, #0
 80015fe:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8001600:	2300      	movs	r3, #0
 8001602:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001604:	2300      	movs	r3, #0
 8001606:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 8001608:	230d      	movs	r3, #13
 800160a:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 800160c:	f107 0308 	add.w	r3, r7, #8
 8001610:	4618      	mov	r0, r3
 8001612:	f007 fe59 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_7;
 8001616:	2307      	movs	r3, #7
 8001618:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 800161a:	f107 0308 	add.w	r3, r7, #8
 800161e:	4618      	mov	r0, r3
 8001620:	f007 fe52 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_8;
 8001624:	2308      	movs	r3, #8
 8001626:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 8001628:	f107 0308 	add.w	r3, r7, #8
 800162c:	4618      	mov	r0, r3
 800162e:	f007 fe4b 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.pGPIOx = GPIOB;
 8001632:	4b35      	ldr	r3, [pc, #212]	@ (8001708 <HAL_DCMI_MspInit+0x1f0>)
 8001634:	60bb      	str	r3, [r7, #8]
	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_6;
 8001636:	2306      	movs	r3, #6
 8001638:	60fb      	str	r3, [r7, #12]
	  GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 800163a:	2302      	movs	r3, #2
 800163c:	743b      	strb	r3, [r7, #16]
	  GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800163e:	2300      	movs	r3, #0
 8001640:	74fb      	strb	r3, [r7, #19]
	  GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8001642:	2300      	movs	r3, #0
 8001644:	74bb      	strb	r3, [r7, #18]
	  GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_LOW;
 8001646:	2300      	movs	r3, #0
 8001648:	747b      	strb	r3, [r7, #17]
	  GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 13;
 800164a:	230d      	movs	r3, #13
 800164c:	753b      	strb	r3, [r7, #20]
	  GPIO_Init(&GPIO_InitStruct);
 800164e:	f107 0308 	add.w	r3, r7, #8
 8001652:	4618      	mov	r0, r3
 8001654:	f007 fe38 	bl	80092c8 <GPIO_Init>

	  GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_7;
 8001658:	2307      	movs	r3, #7
 800165a:	60fb      	str	r3, [r7, #12]
	  GPIO_Init(&GPIO_InitStruct);
 800165c:	f107 0308 	add.w	r3, r7, #8
 8001660:	4618      	mov	r0, r3
 8001662:	f007 fe31 	bl	80092c8 <GPIO_Init>


    /* DCMI DMA Init */
    /* DCMI Init */
    hdma_dcmi.Instance = DMA2_Stream1;
 8001666:	4b29      	ldr	r3, [pc, #164]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 8001668:	4a29      	ldr	r2, [pc, #164]	@ (8001710 <HAL_DCMI_MspInit+0x1f8>)
 800166a:	601a      	str	r2, [r3, #0]
    hdma_dcmi.Init.Channel = DMA_CHANNEL_1;
 800166c:	4b27      	ldr	r3, [pc, #156]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 800166e:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 8001672:	605a      	str	r2, [r3, #4]
    hdma_dcmi.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001674:	4b25      	ldr	r3, [pc, #148]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 8001676:	2200      	movs	r2, #0
 8001678:	609a      	str	r2, [r3, #8]
    hdma_dcmi.Init.PeriphInc = DMA_PINC_DISABLE;
 800167a:	4b24      	ldr	r3, [pc, #144]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 800167c:	2200      	movs	r2, #0
 800167e:	60da      	str	r2, [r3, #12]
    hdma_dcmi.Init.MemInc = DMA_MINC_ENABLE;
 8001680:	4b22      	ldr	r3, [pc, #136]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 8001682:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8001686:	611a      	str	r2, [r3, #16]
    hdma_dcmi.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8001688:	4b20      	ldr	r3, [pc, #128]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 800168a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 800168e:	615a      	str	r2, [r3, #20]
    hdma_dcmi.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8001690:	4b1e      	ldr	r3, [pc, #120]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 8001692:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8001696:	619a      	str	r2, [r3, #24]
    hdma_dcmi.Init.Mode = DMA_CIRCULAR;
 8001698:	4b1c      	ldr	r3, [pc, #112]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 800169a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800169e:	61da      	str	r2, [r3, #28]
    hdma_dcmi.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80016a0:	4b1a      	ldr	r3, [pc, #104]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016a2:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 80016a6:	621a      	str	r2, [r3, #32]
    hdma_dcmi.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80016a8:	4b18      	ldr	r3, [pc, #96]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016aa:	2204      	movs	r2, #4
 80016ac:	625a      	str	r2, [r3, #36]	@ 0x24
    hdma_dcmi.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 80016ae:	4b17      	ldr	r3, [pc, #92]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016b0:	2203      	movs	r2, #3
 80016b2:	629a      	str	r2, [r3, #40]	@ 0x28
    hdma_dcmi.Init.MemBurst = DMA_MBURST_SINGLE;
 80016b4:	4b15      	ldr	r3, [pc, #84]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016b6:	2200      	movs	r2, #0
 80016b8:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdma_dcmi.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80016ba:	4b14      	ldr	r3, [pc, #80]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016bc:	2200      	movs	r2, #0
 80016be:	631a      	str	r2, [r3, #48]	@ 0x30
    if (HAL_DMA_Init(&hdma_dcmi) != HAL_OK)
 80016c0:	4812      	ldr	r0, [pc, #72]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016c2:	f000 fda3 	bl	800220c <HAL_DMA_Init>
 80016c6:	4603      	mov	r3, r0
 80016c8:	2b00      	cmp	r3, #0
 80016ca:	d001      	beq.n	80016d0 <HAL_DCMI_MspInit+0x1b8>
    {
      Error_Handler();
 80016cc:	f7ff ff0a 	bl	80014e4 <Error_Handler>
    }

    __HAL_LINKDMA(hdcmi,DMA_Handle,hdma_dcmi);
 80016d0:	687b      	ldr	r3, [r7, #4]
 80016d2:	4a0e      	ldr	r2, [pc, #56]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016d4:	639a      	str	r2, [r3, #56]	@ 0x38
 80016d6:	4a0d      	ldr	r2, [pc, #52]	@ (800170c <HAL_DCMI_MspInit+0x1f4>)
 80016d8:	687b      	ldr	r3, [r7, #4]
 80016da:	6393      	str	r3, [r2, #56]	@ 0x38

    /* DCMI interrupt Init */
    HAL_NVIC_SetPriority(DCMI_IRQn, 0, 0);
 80016dc:	2200      	movs	r2, #0
 80016de:	2100      	movs	r1, #0
 80016e0:	204e      	movs	r0, #78	@ 0x4e
 80016e2:	f000 faa0 	bl	8001c26 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMI_IRQn);
 80016e6:	204e      	movs	r0, #78	@ 0x4e
 80016e8:	f000 fab9 	bl	8001c5e <HAL_NVIC_EnableIRQ>

  }

}
 80016ec:	bf00      	nop
 80016ee:	3718      	adds	r7, #24
 80016f0:	46bd      	mov	sp, r7
 80016f2:	bd80      	pop	{r7, pc}
 80016f4:	50050000 	.word	0x50050000
 80016f8:	40023800 	.word	0x40023800
 80016fc:	40021000 	.word	0x40021000
 8001700:	40020000 	.word	0x40020000
 8001704:	40020800 	.word	0x40020800
 8001708:	40020400 	.word	0x40020400
 800170c:	200000dc 	.word	0x200000dc
 8001710:	40026428 	.word	0x40026428

08001714 <EXTI0_IRQHandler>:
extern DMA_HandleTypeDef hdma_dcmi;
extern DCMI_HandleTypeDef hdcmi;


void EXTI0_IRQHandler(void)
{
 8001714:	b580      	push	{r7, lr}
 8001716:	b082      	sub	sp, #8
 8001718:	af00      	add	r7, sp, #0
	static uint32_t last_time = 0;
	uint32_t current_time = HAL_GetTick();
 800171a:	f000 f979 	bl	8001a10 <HAL_GetTick>
 800171e:	6078      	str	r0, [r7, #4]
	 if((current_time - last_time) > 300)	//debouncing
 8001720:	4b0e      	ldr	r3, [pc, #56]	@ (800175c <EXTI0_IRQHandler+0x48>)
 8001722:	681b      	ldr	r3, [r3, #0]
 8001724:	687a      	ldr	r2, [r7, #4]
 8001726:	1ad3      	subs	r3, r2, r3
 8001728:	f5b3 7f96 	cmp.w	r3, #300	@ 0x12c
 800172c:	d90d      	bls.n	800174a <EXTI0_IRQHandler+0x36>
	 {
		 begin_rec = 1;
 800172e:	4b0c      	ldr	r3, [pc, #48]	@ (8001760 <EXTI0_IRQHandler+0x4c>)
 8001730:	2201      	movs	r2, #1
 8001732:	701a      	strb	r2, [r3, #0]
		 if(read_avi_output_status() == AVI_FINISH)
 8001734:	f006 fb78 	bl	8007e28 <read_avi_output_status>
 8001738:	4603      	mov	r3, r0
 800173a:	2b04      	cmp	r3, #4
 800173c:	d102      	bne.n	8001744 <EXTI0_IRQHandler+0x30>
		 {
			 set_avi_output_status(AVI_READY);
 800173e:	2000      	movs	r0, #0
 8001740:	f006 fb62 	bl	8007e08 <set_avi_output_status>
		 }
		 last_time = current_time; // Update the last_time
 8001744:	4a05      	ldr	r2, [pc, #20]	@ (800175c <EXTI0_IRQHandler+0x48>)
 8001746:	687b      	ldr	r3, [r7, #4]
 8001748:	6013      	str	r3, [r2, #0]
	 }
	 EXTI->PR.bit.pr0 = SET;	 // clear interrupt pending bit for EXTI Line 0
 800174a:	4a06      	ldr	r2, [pc, #24]	@ (8001764 <EXTI0_IRQHandler+0x50>)
 800174c:	6953      	ldr	r3, [r2, #20]
 800174e:	f043 0301 	orr.w	r3, r3, #1
 8001752:	6153      	str	r3, [r2, #20]
}
 8001754:	bf00      	nop
 8001756:	3708      	adds	r7, #8
 8001758:	46bd      	mov	sp, r7
 800175a:	bd80      	pop	{r7, pc}
 800175c:	20002260 	.word	0x20002260
 8001760:	20002208 	.word	0x20002208
 8001764:	40013c00 	.word	0x40013c00

08001768 <RTC_Alarm_IRQHandler>:

void RTC_Alarm_IRQHandler(void)
{
 8001768:	b580      	push	{r7, lr}
 800176a:	af00      	add	r7, sp, #0
	EXTI->PR.bit.pr17 = SET;
 800176c:	4a12      	ldr	r2, [pc, #72]	@ (80017b8 <RTC_Alarm_IRQHandler+0x50>)
 800176e:	6953      	ldr	r3, [r2, #20]
 8001770:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001774:	6153      	str	r3, [r2, #20]

	if(SET == RTC->CR.bit.alraie)
 8001776:	4b11      	ldr	r3, [pc, #68]	@ (80017bc <RTC_Alarm_IRQHandler+0x54>)
 8001778:	689b      	ldr	r3, [r3, #8]
 800177a:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800177e:	b2db      	uxtb	r3, r3
 8001780:	2b01      	cmp	r3, #1
 8001782:	d116      	bne.n	80017b2 <RTC_Alarm_IRQHandler+0x4a>
	{
		if(SET == RTC->ISR.bit.alraf)
 8001784:	4b0d      	ldr	r3, [pc, #52]	@ (80017bc <RTC_Alarm_IRQHandler+0x54>)
 8001786:	68db      	ldr	r3, [r3, #12]
 8001788:	f3c3 2300 	ubfx	r3, r3, #8, #1
 800178c:	b2db      	uxtb	r3, r3
 800178e:	2b01      	cmp	r3, #1
 8001790:	d10f      	bne.n	80017b2 <RTC_Alarm_IRQHandler+0x4a>
		{
			RTC->ISR.bit.alraf = RESET;
 8001792:	4a0a      	ldr	r2, [pc, #40]	@ (80017bc <RTC_Alarm_IRQHandler+0x54>)
 8001794:	68d3      	ldr	r3, [r2, #12]
 8001796:	f36f 2308 	bfc	r3, #8, #1
 800179a:	60d3      	str	r3, [r2, #12]
			begin_rec = 1;
 800179c:	4b08      	ldr	r3, [pc, #32]	@ (80017c0 <RTC_Alarm_IRQHandler+0x58>)
 800179e:	2201      	movs	r2, #1
 80017a0:	701a      	strb	r2, [r3, #0]
			if (read_avi_output_status() == AVI_START)
 80017a2:	f006 fb41 	bl	8007e28 <read_avi_output_status>
 80017a6:	4603      	mov	r3, r0
 80017a8:	2b01      	cmp	r3, #1
 80017aa:	d102      	bne.n	80017b2 <RTC_Alarm_IRQHandler+0x4a>
			{
				set_avi_output_status(AVI_PENDING); // stop recording
 80017ac:	2002      	movs	r0, #2
 80017ae:	f006 fb2b 	bl	8007e08 <set_avi_output_status>
			}
		}
	}
}
 80017b2:	bf00      	nop
 80017b4:	bd80      	pop	{r7, pc}
 80017b6:	bf00      	nop
 80017b8:	40013c00 	.word	0x40013c00
 80017bc:	40002800 	.word	0x40002800
 80017c0:	20002208 	.word	0x20002208

080017c4 <NMI_Handler>:

void NMI_Handler(void)
{
 80017c4:	b480      	push	{r7}
 80017c6:	af00      	add	r7, sp, #0
   while (1)
 80017c8:	bf00      	nop
 80017ca:	e7fd      	b.n	80017c8 <NMI_Handler+0x4>

080017cc <HardFault_Handler>:
  }

}

void HardFault_Handler(void)
{
 80017cc:	b480      	push	{r7}
 80017ce:	af00      	add	r7, sp, #0

  while (1)
 80017d0:	bf00      	nop
 80017d2:	e7fd      	b.n	80017d0 <HardFault_Handler+0x4>

080017d4 <MemManage_Handler>:

  }
}

void MemManage_Handler(void)
{
 80017d4:	b480      	push	{r7}
 80017d6:	af00      	add	r7, sp, #0

  while (1)
 80017d8:	bf00      	nop
 80017da:	e7fd      	b.n	80017d8 <MemManage_Handler+0x4>

080017dc <BusFault_Handler>:

  }
}

void BusFault_Handler(void)
{
 80017dc:	b480      	push	{r7}
 80017de:	af00      	add	r7, sp, #0

  while (1)
 80017e0:	bf00      	nop
 80017e2:	e7fd      	b.n	80017e0 <BusFault_Handler+0x4>

080017e4 <UsageFault_Handler>:
  }
}


void UsageFault_Handler(void)
{
 80017e4:	b480      	push	{r7}
 80017e6:	af00      	add	r7, sp, #0

  while (1)
 80017e8:	bf00      	nop
 80017ea:	e7fd      	b.n	80017e8 <UsageFault_Handler+0x4>

080017ec <SVC_Handler>:

  }
}

void SVC_Handler(void)
{
 80017ec:	b480      	push	{r7}
 80017ee:	af00      	add	r7, sp, #0

}
 80017f0:	bf00      	nop
 80017f2:	46bd      	mov	sp, r7
 80017f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017f8:	4770      	bx	lr

080017fa <DebugMon_Handler>:

void DebugMon_Handler(void)
{
 80017fa:	b480      	push	{r7}
 80017fc:	af00      	add	r7, sp, #0

}
 80017fe:	bf00      	nop
 8001800:	46bd      	mov	sp, r7
 8001802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001806:	4770      	bx	lr

08001808 <PendSV_Handler>:

void PendSV_Handler(void)
{
 8001808:	b480      	push	{r7}
 800180a:	af00      	add	r7, sp, #0

}
 800180c:	bf00      	nop
 800180e:	46bd      	mov	sp, r7
 8001810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001814:	4770      	bx	lr

08001816 <SysTick_Handler>:


void SysTick_Handler(void)
{
 8001816:	b580      	push	{r7, lr}
 8001818:	af00      	add	r7, sp, #0
	HAL_IncTick();
 800181a:	f000 f8e5 	bl	80019e8 <HAL_IncTick>
}
 800181e:	bf00      	nop
 8001820:	bd80      	pop	{r7, pc}
	...

08001824 <DMA2_Stream1_IRQHandler>:


void DMA2_Stream1_IRQHandler(void)
{
 8001824:	b580      	push	{r7, lr}
 8001826:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_dcmi);
 8001828:	4802      	ldr	r0, [pc, #8]	@ (8001834 <DMA2_Stream1_IRQHandler+0x10>)
 800182a:	f000 fe87 	bl	800253c <HAL_DMA_IRQHandler>
}
 800182e:	bf00      	nop
 8001830:	bd80      	pop	{r7, pc}
 8001832:	bf00      	nop
 8001834:	200000dc 	.word	0x200000dc

08001838 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001838:	b580      	push	{r7, lr}
 800183a:	af00      	add	r7, sp, #0

  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 800183c:	4802      	ldr	r0, [pc, #8]	@ (8001848 <OTG_FS_IRQHandler+0x10>)
 800183e:	f002 fd4f 	bl	80042e0 <HAL_HCD_IRQHandler>
}
 8001842:	bf00      	nop
 8001844:	bd80      	pop	{r7, pc}
 8001846:	bf00      	nop
 8001848:	2000316c 	.word	0x2000316c

0800184c <DCMI_IRQHandler>:


void DCMI_IRQHandler(void)
{
 800184c:	b580      	push	{r7, lr}
 800184e:	af00      	add	r7, sp, #0

  HAL_DCMI_IRQHandler(&hdcmi);
 8001850:	4802      	ldr	r0, [pc, #8]	@ (800185c <DCMI_IRQHandler+0x10>)
 8001852:	f000 fb1b 	bl	8001e8c <HAL_DCMI_IRQHandler>

}
 8001856:	bf00      	nop
 8001858:	bd80      	pop	{r7, pc}
 800185a:	bf00      	nop
 800185c:	2000009c 	.word	0x2000009c

08001860 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001860:	b580      	push	{r7, lr}
 8001862:	b086      	sub	sp, #24
 8001864:	af00      	add	r7, sp, #0
 8001866:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001868:	4a14      	ldr	r2, [pc, #80]	@ (80018bc <_sbrk+0x5c>)
 800186a:	4b15      	ldr	r3, [pc, #84]	@ (80018c0 <_sbrk+0x60>)
 800186c:	1ad3      	subs	r3, r2, r3
 800186e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001870:	697b      	ldr	r3, [r7, #20]
 8001872:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001874:	4b13      	ldr	r3, [pc, #76]	@ (80018c4 <_sbrk+0x64>)
 8001876:	681b      	ldr	r3, [r3, #0]
 8001878:	2b00      	cmp	r3, #0
 800187a:	d102      	bne.n	8001882 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800187c:	4b11      	ldr	r3, [pc, #68]	@ (80018c4 <_sbrk+0x64>)
 800187e:	4a12      	ldr	r2, [pc, #72]	@ (80018c8 <_sbrk+0x68>)
 8001880:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001882:	4b10      	ldr	r3, [pc, #64]	@ (80018c4 <_sbrk+0x64>)
 8001884:	681a      	ldr	r2, [r3, #0]
 8001886:	687b      	ldr	r3, [r7, #4]
 8001888:	4413      	add	r3, r2
 800188a:	693a      	ldr	r2, [r7, #16]
 800188c:	429a      	cmp	r2, r3
 800188e:	d207      	bcs.n	80018a0 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001890:	f02e f89e 	bl	802f9d0 <__errno>
 8001894:	4603      	mov	r3, r0
 8001896:	220c      	movs	r2, #12
 8001898:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800189a:	f04f 33ff 	mov.w	r3, #4294967295
 800189e:	e009      	b.n	80018b4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80018a0:	4b08      	ldr	r3, [pc, #32]	@ (80018c4 <_sbrk+0x64>)
 80018a2:	681b      	ldr	r3, [r3, #0]
 80018a4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80018a6:	4b07      	ldr	r3, [pc, #28]	@ (80018c4 <_sbrk+0x64>)
 80018a8:	681a      	ldr	r2, [r3, #0]
 80018aa:	687b      	ldr	r3, [r7, #4]
 80018ac:	4413      	add	r3, r2
 80018ae:	4a05      	ldr	r2, [pc, #20]	@ (80018c4 <_sbrk+0x64>)
 80018b0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80018b2:	68fb      	ldr	r3, [r7, #12]
}
 80018b4:	4618      	mov	r0, r3
 80018b6:	3718      	adds	r7, #24
 80018b8:	46bd      	mov	sp, r7
 80018ba:	bd80      	pop	{r7, pc}
 80018bc:	20020000 	.word	0x20020000
 80018c0:	00000400 	.word	0x00000400
 80018c4:	20002264 	.word	0x20002264
 80018c8:	20003698 	.word	0x20003698

080018cc <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80018cc:	b480      	push	{r7}
 80018ce:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80018d0:	4b06      	ldr	r3, [pc, #24]	@ (80018ec <SystemInit+0x20>)
 80018d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80018d6:	4a05      	ldr	r2, [pc, #20]	@ (80018ec <SystemInit+0x20>)
 80018d8:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 80018dc:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80018e0:	bf00      	nop
 80018e2:	46bd      	mov	sp, r7
 80018e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018e8:	4770      	bx	lr
 80018ea:	bf00      	nop
 80018ec:	e000ed00 	.word	0xe000ed00

080018f0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80018f0:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001928 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 80018f4:	f7ff ffea 	bl	80018cc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 80018f8:	480c      	ldr	r0, [pc, #48]	@ (800192c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 80018fa:	490d      	ldr	r1, [pc, #52]	@ (8001930 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 80018fc:	4a0d      	ldr	r2, [pc, #52]	@ (8001934 <LoopFillZerobss+0x1a>)
  movs r3, #0
 80018fe:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001900:	e002      	b.n	8001908 <LoopCopyDataInit>

08001902 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001902:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001904:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001906:	3304      	adds	r3, #4

08001908 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001908:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800190a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800190c:	d3f9      	bcc.n	8001902 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800190e:	4a0a      	ldr	r2, [pc, #40]	@ (8001938 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001910:	4c0a      	ldr	r4, [pc, #40]	@ (800193c <LoopFillZerobss+0x22>)
  movs r3, #0
 8001912:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001914:	e001      	b.n	800191a <LoopFillZerobss>

08001916 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001916:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001918:	3204      	adds	r2, #4

0800191a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800191a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800191c:	d3fb      	bcc.n	8001916 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800191e:	f02e f85d 	bl	802f9dc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001922:	f7ff fbd3 	bl	80010cc <main>
  bx  lr    
 8001926:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8001928:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800192c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001930:	2000007c 	.word	0x2000007c
  ldr r2, =_sidata
 8001934:	08032c80 	.word	0x08032c80
  ldr r2, =_sbss
 8001938:	20000080 	.word	0x20000080
  ldr r4, =_ebss
 800193c:	20003694 	.word	0x20003694

08001940 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001940:	e7fe      	b.n	8001940 <ADC_IRQHandler>
	...

08001944 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001944:	b580      	push	{r7, lr}
 8001946:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001948:	4b0e      	ldr	r3, [pc, #56]	@ (8001984 <HAL_Init+0x40>)
 800194a:	681b      	ldr	r3, [r3, #0]
 800194c:	4a0d      	ldr	r2, [pc, #52]	@ (8001984 <HAL_Init+0x40>)
 800194e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001952:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001954:	4b0b      	ldr	r3, [pc, #44]	@ (8001984 <HAL_Init+0x40>)
 8001956:	681b      	ldr	r3, [r3, #0]
 8001958:	4a0a      	ldr	r2, [pc, #40]	@ (8001984 <HAL_Init+0x40>)
 800195a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800195e:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001960:	4b08      	ldr	r3, [pc, #32]	@ (8001984 <HAL_Init+0x40>)
 8001962:	681b      	ldr	r3, [r3, #0]
 8001964:	4a07      	ldr	r2, [pc, #28]	@ (8001984 <HAL_Init+0x40>)
 8001966:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800196a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800196c:	2003      	movs	r0, #3
 800196e:	f000 f94f 	bl	8001c10 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001972:	200f      	movs	r0, #15
 8001974:	f000 f808 	bl	8001988 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001978:	f7ff fdba 	bl	80014f0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800197c:	2300      	movs	r3, #0
}
 800197e:	4618      	mov	r0, r3
 8001980:	bd80      	pop	{r7, pc}
 8001982:	bf00      	nop
 8001984:	40023c00 	.word	0x40023c00

08001988 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001988:	b580      	push	{r7, lr}
 800198a:	b082      	sub	sp, #8
 800198c:	af00      	add	r7, sp, #0
 800198e:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001990:	4b12      	ldr	r3, [pc, #72]	@ (80019dc <HAL_InitTick+0x54>)
 8001992:	681a      	ldr	r2, [r3, #0]
 8001994:	4b12      	ldr	r3, [pc, #72]	@ (80019e0 <HAL_InitTick+0x58>)
 8001996:	781b      	ldrb	r3, [r3, #0]
 8001998:	4619      	mov	r1, r3
 800199a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800199e:	fbb3 f3f1 	udiv	r3, r3, r1
 80019a2:	fbb2 f3f3 	udiv	r3, r2, r3
 80019a6:	4618      	mov	r0, r3
 80019a8:	f000 f967 	bl	8001c7a <HAL_SYSTICK_Config>
 80019ac:	4603      	mov	r3, r0
 80019ae:	2b00      	cmp	r3, #0
 80019b0:	d001      	beq.n	80019b6 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 80019b2:	2301      	movs	r3, #1
 80019b4:	e00e      	b.n	80019d4 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80019b6:	687b      	ldr	r3, [r7, #4]
 80019b8:	2b0f      	cmp	r3, #15
 80019ba:	d80a      	bhi.n	80019d2 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80019bc:	2200      	movs	r2, #0
 80019be:	6879      	ldr	r1, [r7, #4]
 80019c0:	f04f 30ff 	mov.w	r0, #4294967295
 80019c4:	f000 f92f 	bl	8001c26 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80019c8:	4a06      	ldr	r2, [pc, #24]	@ (80019e4 <HAL_InitTick+0x5c>)
 80019ca:	687b      	ldr	r3, [r7, #4]
 80019cc:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 80019ce:	2300      	movs	r3, #0
 80019d0:	e000      	b.n	80019d4 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 80019d2:	2301      	movs	r3, #1
}
 80019d4:	4618      	mov	r0, r3
 80019d6:	3708      	adds	r7, #8
 80019d8:	46bd      	mov	sp, r7
 80019da:	bd80      	pop	{r7, pc}
 80019dc:	20000000 	.word	0x20000000
 80019e0:	20000008 	.word	0x20000008
 80019e4:	20000004 	.word	0x20000004

080019e8 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80019e8:	b480      	push	{r7}
 80019ea:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 80019ec:	4b06      	ldr	r3, [pc, #24]	@ (8001a08 <HAL_IncTick+0x20>)
 80019ee:	781b      	ldrb	r3, [r3, #0]
 80019f0:	461a      	mov	r2, r3
 80019f2:	4b06      	ldr	r3, [pc, #24]	@ (8001a0c <HAL_IncTick+0x24>)
 80019f4:	681b      	ldr	r3, [r3, #0]
 80019f6:	4413      	add	r3, r2
 80019f8:	4a04      	ldr	r2, [pc, #16]	@ (8001a0c <HAL_IncTick+0x24>)
 80019fa:	6013      	str	r3, [r2, #0]
}
 80019fc:	bf00      	nop
 80019fe:	46bd      	mov	sp, r7
 8001a00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a04:	4770      	bx	lr
 8001a06:	bf00      	nop
 8001a08:	20000008 	.word	0x20000008
 8001a0c:	20002268 	.word	0x20002268

08001a10 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001a10:	b480      	push	{r7}
 8001a12:	af00      	add	r7, sp, #0
  return uwTick;
 8001a14:	4b03      	ldr	r3, [pc, #12]	@ (8001a24 <HAL_GetTick+0x14>)
 8001a16:	681b      	ldr	r3, [r3, #0]
}
 8001a18:	4618      	mov	r0, r3
 8001a1a:	46bd      	mov	sp, r7
 8001a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a20:	4770      	bx	lr
 8001a22:	bf00      	nop
 8001a24:	20002268 	.word	0x20002268

08001a28 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001a28:	b580      	push	{r7, lr}
 8001a2a:	b084      	sub	sp, #16
 8001a2c:	af00      	add	r7, sp, #0
 8001a2e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001a30:	f7ff ffee 	bl	8001a10 <HAL_GetTick>
 8001a34:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001a36:	687b      	ldr	r3, [r7, #4]
 8001a38:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001a3a:	68fb      	ldr	r3, [r7, #12]
 8001a3c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001a40:	d005      	beq.n	8001a4e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001a42:	4b0a      	ldr	r3, [pc, #40]	@ (8001a6c <HAL_Delay+0x44>)
 8001a44:	781b      	ldrb	r3, [r3, #0]
 8001a46:	461a      	mov	r2, r3
 8001a48:	68fb      	ldr	r3, [r7, #12]
 8001a4a:	4413      	add	r3, r2
 8001a4c:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001a4e:	bf00      	nop
 8001a50:	f7ff ffde 	bl	8001a10 <HAL_GetTick>
 8001a54:	4602      	mov	r2, r0
 8001a56:	68bb      	ldr	r3, [r7, #8]
 8001a58:	1ad3      	subs	r3, r2, r3
 8001a5a:	68fa      	ldr	r2, [r7, #12]
 8001a5c:	429a      	cmp	r2, r3
 8001a5e:	d8f7      	bhi.n	8001a50 <HAL_Delay+0x28>
  {
  }
}
 8001a60:	bf00      	nop
 8001a62:	bf00      	nop
 8001a64:	3710      	adds	r7, #16
 8001a66:	46bd      	mov	sp, r7
 8001a68:	bd80      	pop	{r7, pc}
 8001a6a:	bf00      	nop
 8001a6c:	20000008 	.word	0x20000008

08001a70 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
static inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001a70:	b480      	push	{r7}
 8001a72:	b085      	sub	sp, #20
 8001a74:	af00      	add	r7, sp, #0
 8001a76:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001a78:	687b      	ldr	r3, [r7, #4]
 8001a7a:	f003 0307 	and.w	r3, r3, #7
 8001a7e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001a80:	4b0c      	ldr	r3, [pc, #48]	@ (8001ab4 <__NVIC_SetPriorityGrouping+0x44>)
 8001a82:	68db      	ldr	r3, [r3, #12]
 8001a84:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001a86:	68ba      	ldr	r2, [r7, #8]
 8001a88:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8001a8c:	4013      	ands	r3, r2
 8001a8e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001a90:	68fb      	ldr	r3, [r7, #12]
 8001a92:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001a94:	68bb      	ldr	r3, [r7, #8]
 8001a96:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001a98:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001a9c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001aa0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001aa2:	4a04      	ldr	r2, [pc, #16]	@ (8001ab4 <__NVIC_SetPriorityGrouping+0x44>)
 8001aa4:	68bb      	ldr	r3, [r7, #8]
 8001aa6:	60d3      	str	r3, [r2, #12]
}
 8001aa8:	bf00      	nop
 8001aaa:	3714      	adds	r7, #20
 8001aac:	46bd      	mov	sp, r7
 8001aae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ab2:	4770      	bx	lr
 8001ab4:	e000ed00 	.word	0xe000ed00

08001ab8 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
static inline uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001ab8:	b480      	push	{r7}
 8001aba:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001abc:	4b04      	ldr	r3, [pc, #16]	@ (8001ad0 <__NVIC_GetPriorityGrouping+0x18>)
 8001abe:	68db      	ldr	r3, [r3, #12]
 8001ac0:	0a1b      	lsrs	r3, r3, #8
 8001ac2:	f003 0307 	and.w	r3, r3, #7
}
 8001ac6:	4618      	mov	r0, r3
 8001ac8:	46bd      	mov	sp, r7
 8001aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ace:	4770      	bx	lr
 8001ad0:	e000ed00 	.word	0xe000ed00

08001ad4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001ad4:	b480      	push	{r7}
 8001ad6:	b083      	sub	sp, #12
 8001ad8:	af00      	add	r7, sp, #0
 8001ada:	4603      	mov	r3, r0
 8001adc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001ade:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001ae2:	2b00      	cmp	r3, #0
 8001ae4:	db0b      	blt.n	8001afe <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001ae6:	79fb      	ldrb	r3, [r7, #7]
 8001ae8:	f003 021f 	and.w	r2, r3, #31
 8001aec:	4907      	ldr	r1, [pc, #28]	@ (8001b0c <__NVIC_EnableIRQ+0x38>)
 8001aee:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001af2:	095b      	lsrs	r3, r3, #5
 8001af4:	2001      	movs	r0, #1
 8001af6:	fa00 f202 	lsl.w	r2, r0, r2
 8001afa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001afe:	bf00      	nop
 8001b00:	370c      	adds	r7, #12
 8001b02:	46bd      	mov	sp, r7
 8001b04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b08:	4770      	bx	lr
 8001b0a:	bf00      	nop
 8001b0c:	e000e100 	.word	0xe000e100

08001b10 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
static inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001b10:	b480      	push	{r7}
 8001b12:	b083      	sub	sp, #12
 8001b14:	af00      	add	r7, sp, #0
 8001b16:	4603      	mov	r3, r0
 8001b18:	6039      	str	r1, [r7, #0]
 8001b1a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001b1c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001b20:	2b00      	cmp	r3, #0
 8001b22:	db0a      	blt.n	8001b3a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b24:	683b      	ldr	r3, [r7, #0]
 8001b26:	b2da      	uxtb	r2, r3
 8001b28:	490c      	ldr	r1, [pc, #48]	@ (8001b5c <__NVIC_SetPriority+0x4c>)
 8001b2a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001b2e:	0112      	lsls	r2, r2, #4
 8001b30:	b2d2      	uxtb	r2, r2
 8001b32:	440b      	add	r3, r1
 8001b34:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001b38:	e00a      	b.n	8001b50 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b3a:	683b      	ldr	r3, [r7, #0]
 8001b3c:	b2da      	uxtb	r2, r3
 8001b3e:	4908      	ldr	r1, [pc, #32]	@ (8001b60 <__NVIC_SetPriority+0x50>)
 8001b40:	79fb      	ldrb	r3, [r7, #7]
 8001b42:	f003 030f 	and.w	r3, r3, #15
 8001b46:	3b04      	subs	r3, #4
 8001b48:	0112      	lsls	r2, r2, #4
 8001b4a:	b2d2      	uxtb	r2, r2
 8001b4c:	440b      	add	r3, r1
 8001b4e:	761a      	strb	r2, [r3, #24]
}
 8001b50:	bf00      	nop
 8001b52:	370c      	adds	r7, #12
 8001b54:	46bd      	mov	sp, r7
 8001b56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b5a:	4770      	bx	lr
 8001b5c:	e000e100 	.word	0xe000e100
 8001b60:	e000ed00 	.word	0xe000ed00

08001b64 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
static inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001b64:	b480      	push	{r7}
 8001b66:	b089      	sub	sp, #36	@ 0x24
 8001b68:	af00      	add	r7, sp, #0
 8001b6a:	60f8      	str	r0, [r7, #12]
 8001b6c:	60b9      	str	r1, [r7, #8]
 8001b6e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001b70:	68fb      	ldr	r3, [r7, #12]
 8001b72:	f003 0307 	and.w	r3, r3, #7
 8001b76:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001b78:	69fb      	ldr	r3, [r7, #28]
 8001b7a:	f1c3 0307 	rsb	r3, r3, #7
 8001b7e:	2b04      	cmp	r3, #4
 8001b80:	bf28      	it	cs
 8001b82:	2304      	movcs	r3, #4
 8001b84:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001b86:	69fb      	ldr	r3, [r7, #28]
 8001b88:	3304      	adds	r3, #4
 8001b8a:	2b06      	cmp	r3, #6
 8001b8c:	d902      	bls.n	8001b94 <NVIC_EncodePriority+0x30>
 8001b8e:	69fb      	ldr	r3, [r7, #28]
 8001b90:	3b03      	subs	r3, #3
 8001b92:	e000      	b.n	8001b96 <NVIC_EncodePriority+0x32>
 8001b94:	2300      	movs	r3, #0
 8001b96:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001b98:	f04f 32ff 	mov.w	r2, #4294967295
 8001b9c:	69bb      	ldr	r3, [r7, #24]
 8001b9e:	fa02 f303 	lsl.w	r3, r2, r3
 8001ba2:	43da      	mvns	r2, r3
 8001ba4:	68bb      	ldr	r3, [r7, #8]
 8001ba6:	401a      	ands	r2, r3
 8001ba8:	697b      	ldr	r3, [r7, #20]
 8001baa:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001bac:	f04f 31ff 	mov.w	r1, #4294967295
 8001bb0:	697b      	ldr	r3, [r7, #20]
 8001bb2:	fa01 f303 	lsl.w	r3, r1, r3
 8001bb6:	43d9      	mvns	r1, r3
 8001bb8:	687b      	ldr	r3, [r7, #4]
 8001bba:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001bbc:	4313      	orrs	r3, r2
         );
}
 8001bbe:	4618      	mov	r0, r3
 8001bc0:	3724      	adds	r7, #36	@ 0x24
 8001bc2:	46bd      	mov	sp, r7
 8001bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bc8:	4770      	bx	lr
	...

08001bcc <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
static inline uint32_t SysTick_Config(uint32_t ticks)
{
 8001bcc:	b580      	push	{r7, lr}
 8001bce:	b082      	sub	sp, #8
 8001bd0:	af00      	add	r7, sp, #0
 8001bd2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001bd4:	687b      	ldr	r3, [r7, #4]
 8001bd6:	3b01      	subs	r3, #1
 8001bd8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8001bdc:	d301      	bcc.n	8001be2 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001bde:	2301      	movs	r3, #1
 8001be0:	e00f      	b.n	8001c02 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001be2:	4a0a      	ldr	r2, [pc, #40]	@ (8001c0c <SysTick_Config+0x40>)
 8001be4:	687b      	ldr	r3, [r7, #4]
 8001be6:	3b01      	subs	r3, #1
 8001be8:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001bea:	210f      	movs	r1, #15
 8001bec:	f04f 30ff 	mov.w	r0, #4294967295
 8001bf0:	f7ff ff8e 	bl	8001b10 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001bf4:	4b05      	ldr	r3, [pc, #20]	@ (8001c0c <SysTick_Config+0x40>)
 8001bf6:	2200      	movs	r2, #0
 8001bf8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001bfa:	4b04      	ldr	r3, [pc, #16]	@ (8001c0c <SysTick_Config+0x40>)
 8001bfc:	2207      	movs	r2, #7
 8001bfe:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001c00:	2300      	movs	r3, #0
}
 8001c02:	4618      	mov	r0, r3
 8001c04:	3708      	adds	r7, #8
 8001c06:	46bd      	mov	sp, r7
 8001c08:	bd80      	pop	{r7, pc}
 8001c0a:	bf00      	nop
 8001c0c:	e000e010 	.word	0xe000e010

08001c10 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001c10:	b580      	push	{r7, lr}
 8001c12:	b082      	sub	sp, #8
 8001c14:	af00      	add	r7, sp, #0
 8001c16:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001c18:	6878      	ldr	r0, [r7, #4]
 8001c1a:	f7ff ff29 	bl	8001a70 <__NVIC_SetPriorityGrouping>
}
 8001c1e:	bf00      	nop
 8001c20:	3708      	adds	r7, #8
 8001c22:	46bd      	mov	sp, r7
 8001c24:	bd80      	pop	{r7, pc}

08001c26 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001c26:	b580      	push	{r7, lr}
 8001c28:	b086      	sub	sp, #24
 8001c2a:	af00      	add	r7, sp, #0
 8001c2c:	4603      	mov	r3, r0
 8001c2e:	60b9      	str	r1, [r7, #8]
 8001c30:	607a      	str	r2, [r7, #4]
 8001c32:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001c34:	2300      	movs	r3, #0
 8001c36:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8001c38:	f7ff ff3e 	bl	8001ab8 <__NVIC_GetPriorityGrouping>
 8001c3c:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001c3e:	687a      	ldr	r2, [r7, #4]
 8001c40:	68b9      	ldr	r1, [r7, #8]
 8001c42:	6978      	ldr	r0, [r7, #20]
 8001c44:	f7ff ff8e 	bl	8001b64 <NVIC_EncodePriority>
 8001c48:	4602      	mov	r2, r0
 8001c4a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001c4e:	4611      	mov	r1, r2
 8001c50:	4618      	mov	r0, r3
 8001c52:	f7ff ff5d 	bl	8001b10 <__NVIC_SetPriority>
}
 8001c56:	bf00      	nop
 8001c58:	3718      	adds	r7, #24
 8001c5a:	46bd      	mov	sp, r7
 8001c5c:	bd80      	pop	{r7, pc}

08001c5e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001c5e:	b580      	push	{r7, lr}
 8001c60:	b082      	sub	sp, #8
 8001c62:	af00      	add	r7, sp, #0
 8001c64:	4603      	mov	r3, r0
 8001c66:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001c68:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c6c:	4618      	mov	r0, r3
 8001c6e:	f7ff ff31 	bl	8001ad4 <__NVIC_EnableIRQ>
}
 8001c72:	bf00      	nop
 8001c74:	3708      	adds	r7, #8
 8001c76:	46bd      	mov	sp, r7
 8001c78:	bd80      	pop	{r7, pc}

08001c7a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8001c7a:	b580      	push	{r7, lr}
 8001c7c:	b082      	sub	sp, #8
 8001c7e:	af00      	add	r7, sp, #0
 8001c80:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8001c82:	6878      	ldr	r0, [r7, #4]
 8001c84:	f7ff ffa2 	bl	8001bcc <SysTick_Config>
 8001c88:	4603      	mov	r3, r0
}
 8001c8a:	4618      	mov	r0, r3
 8001c8c:	3708      	adds	r7, #8
 8001c8e:	46bd      	mov	sp, r7
 8001c90:	bd80      	pop	{r7, pc}
	...

08001c94 <HAL_DCMI_Start_DMA>:
  * @param  pData     The destination memory Buffer address (LCD Frame buffer).
  * @param  Length    The length of capture to be transferred.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Start_DMA(DCMI_HandleTypeDef* hdcmi, uint32_t DCMI_Mode, uint32_t pData, uint32_t Length)
{
 8001c94:	b580      	push	{r7, lr}
 8001c96:	b088      	sub	sp, #32
 8001c98:	af02      	add	r7, sp, #8
 8001c9a:	60f8      	str	r0, [r7, #12]
 8001c9c:	60b9      	str	r1, [r7, #8]
 8001c9e:	607a      	str	r2, [r7, #4]
 8001ca0:	603b      	str	r3, [r7, #0]
  /* Initialize the second memory address */
  uint32_t SecondMemAddress = 0U;
 8001ca2:	2300      	movs	r3, #0
 8001ca4:	617b      	str	r3, [r7, #20]

  /* Check function parameters */
  assert_param(IS_DCMI_CAPTURE_MODE(DCMI_Mode));

  /* Process Locked */
  __HAL_LOCK(hdcmi);
 8001ca6:	68fb      	ldr	r3, [r7, #12]
 8001ca8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8001cac:	2b01      	cmp	r3, #1
 8001cae:	d101      	bne.n	8001cb4 <HAL_DCMI_Start_DMA+0x20>
 8001cb0:	2302      	movs	r3, #2
 8001cb2:	e086      	b.n	8001dc2 <HAL_DCMI_Start_DMA+0x12e>
 8001cb4:	68fb      	ldr	r3, [r7, #12]
 8001cb6:	2201      	movs	r2, #1
 8001cb8:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Lock the DCMI peripheral state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8001cbc:	68fb      	ldr	r3, [r7, #12]
 8001cbe:	2202      	movs	r2, #2
 8001cc0:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  
  /* Enable DCMI by setting DCMIEN bit */
  __HAL_DCMI_ENABLE(hdcmi);
 8001cc4:	68fb      	ldr	r3, [r7, #12]
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	681a      	ldr	r2, [r3, #0]
 8001cca:	68fb      	ldr	r3, [r7, #12]
 8001ccc:	681b      	ldr	r3, [r3, #0]
 8001cce:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8001cd2:	601a      	str	r2, [r3, #0]

  /* Configure the DCMI Mode */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_CM);
 8001cd4:	68fb      	ldr	r3, [r7, #12]
 8001cd6:	681b      	ldr	r3, [r3, #0]
 8001cd8:	681a      	ldr	r2, [r3, #0]
 8001cda:	68fb      	ldr	r3, [r7, #12]
 8001cdc:	681b      	ldr	r3, [r3, #0]
 8001cde:	f022 0202 	bic.w	r2, r2, #2
 8001ce2:	601a      	str	r2, [r3, #0]
  hdcmi->Instance->CR.reg |=  (uint32_t)(DCMI_Mode);
 8001ce4:	68fb      	ldr	r3, [r7, #12]
 8001ce6:	681b      	ldr	r3, [r3, #0]
 8001ce8:	6819      	ldr	r1, [r3, #0]
 8001cea:	68fb      	ldr	r3, [r7, #12]
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	68ba      	ldr	r2, [r7, #8]
 8001cf0:	430a      	orrs	r2, r1
 8001cf2:	601a      	str	r2, [r3, #0]

  /* Set the DMA memory0 conversion complete callback */
  hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
 8001cf4:	68fb      	ldr	r3, [r7, #12]
 8001cf6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001cf8:	4a34      	ldr	r2, [pc, #208]	@ (8001dcc <HAL_DCMI_Start_DMA+0x138>)
 8001cfa:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Set the DMA error callback */
  hdcmi->DMA_Handle->XferErrorCallback = DCMI_DMAError;
 8001cfc:	68fb      	ldr	r3, [r7, #12]
 8001cfe:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001d00:	4a33      	ldr	r2, [pc, #204]	@ (8001dd0 <HAL_DCMI_Start_DMA+0x13c>)
 8001d02:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Set the dma abort callback */
  hdcmi->DMA_Handle->XferAbortCallback = NULL;
 8001d04:	68fb      	ldr	r3, [r7, #12]
 8001d06:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001d08:	2200      	movs	r2, #0
 8001d0a:	651a      	str	r2, [r3, #80]	@ 0x50
  
  /* Reset transfer counters value */ 
  hdcmi->XferCount = 0U;
 8001d0c:	68fb      	ldr	r3, [r7, #12]
 8001d0e:	2200      	movs	r2, #0
 8001d10:	629a      	str	r2, [r3, #40]	@ 0x28
  hdcmi->XferTransferNumber = 0U;
 8001d12:	68fb      	ldr	r3, [r7, #12]
 8001d14:	2200      	movs	r2, #0
 8001d16:	631a      	str	r2, [r3, #48]	@ 0x30

  if(Length <= 0xFFFFU)
 8001d18:	683b      	ldr	r3, [r7, #0]
 8001d1a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001d1e:	d20a      	bcs.n	8001d36 <HAL_DCMI_Start_DMA+0xa2>
  {
    /* Enable the DMA Stream */
    HAL_DMA_Start_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, Length);
 8001d20:	68fb      	ldr	r3, [r7, #12]
 8001d22:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001d24:	68fb      	ldr	r3, [r7, #12]
 8001d26:	681b      	ldr	r3, [r3, #0]
 8001d28:	3328      	adds	r3, #40	@ 0x28
 8001d2a:	4619      	mov	r1, r3
 8001d2c:	683b      	ldr	r3, [r7, #0]
 8001d2e:	687a      	ldr	r2, [r7, #4]
 8001d30:	f000 fb1a 	bl	8002368 <HAL_DMA_Start_IT>
 8001d34:	e038      	b.n	8001da8 <HAL_DCMI_Start_DMA+0x114>
  }
  else /* DCMI_DOUBLE_BUFFER Mode */
  {
    /* Set the DMA memory1 conversion complete callback */
    hdcmi->DMA_Handle->XferM1CpltCallback = DCMI_DMAXferCplt;
 8001d36:	68fb      	ldr	r3, [r7, #12]
 8001d38:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001d3a:	4a24      	ldr	r2, [pc, #144]	@ (8001dcc <HAL_DCMI_Start_DMA+0x138>)
 8001d3c:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Initialize transfer parameters */
    hdcmi->XferCount = 1U;
 8001d3e:	68fb      	ldr	r3, [r7, #12]
 8001d40:	2201      	movs	r2, #1
 8001d42:	629a      	str	r2, [r3, #40]	@ 0x28
    hdcmi->XferSize = Length;
 8001d44:	68fb      	ldr	r3, [r7, #12]
 8001d46:	683a      	ldr	r2, [r7, #0]
 8001d48:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdcmi->pBuffPtr = pData;
 8001d4a:	68fb      	ldr	r3, [r7, #12]
 8001d4c:	687a      	ldr	r2, [r7, #4]
 8001d4e:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Get the number of buffer */
    while(hdcmi->XferSize > 0xFFFFU)
 8001d50:	e009      	b.n	8001d66 <HAL_DCMI_Start_DMA+0xd2>
    {
      hdcmi->XferSize = (hdcmi->XferSize/2U);
 8001d52:	68fb      	ldr	r3, [r7, #12]
 8001d54:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d56:	085a      	lsrs	r2, r3, #1
 8001d58:	68fb      	ldr	r3, [r7, #12]
 8001d5a:	62da      	str	r2, [r3, #44]	@ 0x2c
      hdcmi->XferCount = hdcmi->XferCount*2U;
 8001d5c:	68fb      	ldr	r3, [r7, #12]
 8001d5e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001d60:	005a      	lsls	r2, r3, #1
 8001d62:	68fb      	ldr	r3, [r7, #12]
 8001d64:	629a      	str	r2, [r3, #40]	@ 0x28
    while(hdcmi->XferSize > 0xFFFFU)
 8001d66:	68fb      	ldr	r3, [r7, #12]
 8001d68:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d6a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001d6e:	d2f0      	bcs.n	8001d52 <HAL_DCMI_Start_DMA+0xbe>
    }

    /* Update DCMI counter  and transfer number*/
    hdcmi->XferCount = (hdcmi->XferCount - 2U);
 8001d70:	68fb      	ldr	r3, [r7, #12]
 8001d72:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001d74:	1e9a      	subs	r2, r3, #2
 8001d76:	68fb      	ldr	r3, [r7, #12]
 8001d78:	629a      	str	r2, [r3, #40]	@ 0x28
    hdcmi->XferTransferNumber = hdcmi->XferCount;
 8001d7a:	68fb      	ldr	r3, [r7, #12]
 8001d7c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d7e:	68fb      	ldr	r3, [r7, #12]
 8001d80:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Update second memory address */
    SecondMemAddress = (uint32_t)(pData + (4U*hdcmi->XferSize));
 8001d82:	68fb      	ldr	r3, [r7, #12]
 8001d84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d86:	009b      	lsls	r3, r3, #2
 8001d88:	687a      	ldr	r2, [r7, #4]
 8001d8a:	4413      	add	r3, r2
 8001d8c:	617b      	str	r3, [r7, #20]

    /* Start DMA multi buffer transfer */
    HAL_DMAEx_MultiBufferStart_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, SecondMemAddress, hdcmi->XferSize);
 8001d8e:	68fb      	ldr	r3, [r7, #12]
 8001d90:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001d92:	68fb      	ldr	r3, [r7, #12]
 8001d94:	681b      	ldr	r3, [r3, #0]
 8001d96:	3328      	adds	r3, #40	@ 0x28
 8001d98:	4619      	mov	r1, r3
 8001d9a:	68fb      	ldr	r3, [r7, #12]
 8001d9c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001d9e:	9300      	str	r3, [sp, #0]
 8001da0:	697b      	ldr	r3, [r7, #20]
 8001da2:	687a      	ldr	r2, [r7, #4]
 8001da4:	f000 fe34 	bl	8002a10 <HAL_DMAEx_MultiBufferStart_IT>
  }

  /* Enable Capture */
  hdcmi->Instance->CR.reg |= DCMI_CR_CAPTURE;
 8001da8:	68fb      	ldr	r3, [r7, #12]
 8001daa:	681b      	ldr	r3, [r3, #0]
 8001dac:	681a      	ldr	r2, [r3, #0]
 8001dae:	68fb      	ldr	r3, [r7, #12]
 8001db0:	681b      	ldr	r3, [r3, #0]
 8001db2:	f042 0201 	orr.w	r2, r2, #1
 8001db6:	601a      	str	r2, [r3, #0]

  /* Release Lock */
  __HAL_UNLOCK(hdcmi);
 8001db8:	68fb      	ldr	r3, [r7, #12]
 8001dba:	2200      	movs	r2, #0
 8001dbc:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Return function status */
  return HAL_OK;
 8001dc0:	2300      	movs	r3, #0
}
 8001dc2:	4618      	mov	r0, r3
 8001dc4:	3718      	adds	r7, #24
 8001dc6:	46bd      	mov	sp, r7
 8001dc8:	bd80      	pop	{r7, pc}
 8001dca:	bf00      	nop
 8001dcc:	08001fd9 	.word	0x08001fd9
 8001dd0:	08002103 	.word	0x08002103

08001dd4 <HAL_DCMI_Stop>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Stop(DCMI_HandleTypeDef* hdcmi)
{
 8001dd4:	b580      	push	{r7, lr}
 8001dd6:	b084      	sub	sp, #16
 8001dd8:	af00      	add	r7, sp, #0
 8001dda:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = SystemCoreClock / HAL_TIMEOUT_DCMI_STOP;
 8001ddc:	4b29      	ldr	r3, [pc, #164]	@ (8001e84 <HAL_DCMI_Stop+0xb0>)
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	085b      	lsrs	r3, r3, #1
 8001de2:	4a29      	ldr	r2, [pc, #164]	@ (8001e88 <HAL_DCMI_Stop+0xb4>)
 8001de4:	fba2 2303 	umull	r2, r3, r2, r3
 8001de8:	089b      	lsrs	r3, r3, #2
 8001dea:	60bb      	str	r3, [r7, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8001dec:	2300      	movs	r3, #0
 8001dee:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hdcmi);
 8001df0:	687b      	ldr	r3, [r7, #4]
 8001df2:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8001df6:	2b01      	cmp	r3, #1
 8001df8:	d101      	bne.n	8001dfe <HAL_DCMI_Stop+0x2a>
 8001dfa:	2302      	movs	r3, #2
 8001dfc:	e03e      	b.n	8001e7c <HAL_DCMI_Stop+0xa8>
 8001dfe:	687b      	ldr	r3, [r7, #4]
 8001e00:	2201      	movs	r2, #1
 8001e02:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  
  /* Lock the DCMI peripheral state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8001e06:	687b      	ldr	r3, [r7, #4]
 8001e08:	2202      	movs	r2, #2
 8001e0a:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  /* Disable Capture */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_CAPTURE);
 8001e0e:	687b      	ldr	r3, [r7, #4]
 8001e10:	681b      	ldr	r3, [r3, #0]
 8001e12:	681a      	ldr	r2, [r3, #0]
 8001e14:	687b      	ldr	r3, [r7, #4]
 8001e16:	681b      	ldr	r3, [r3, #0]
 8001e18:	f022 0201 	bic.w	r2, r2, #1
 8001e1c:	601a      	str	r2, [r3, #0]

  /* Check if the DCMI capture effectively disabled */
  do
  {
    if (count-- == 0U)
 8001e1e:	68bb      	ldr	r3, [r7, #8]
 8001e20:	1e5a      	subs	r2, r3, #1
 8001e22:	60ba      	str	r2, [r7, #8]
 8001e24:	2b00      	cmp	r3, #0
 8001e26:	d108      	bne.n	8001e3a <HAL_DCMI_Stop+0x66>
    {
      /* Update error code */
      hdcmi->ErrorCode |= HAL_DCMI_ERROR_TIMEOUT;
 8001e28:	687b      	ldr	r3, [r7, #4]
 8001e2a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001e2c:	f043 0220 	orr.w	r2, r3, #32
 8001e30:	687b      	ldr	r3, [r7, #4]
 8001e32:	63da      	str	r2, [r3, #60]	@ 0x3c

      status = HAL_TIMEOUT;
 8001e34:	2303      	movs	r3, #3
 8001e36:	73fb      	strb	r3, [r7, #15]
      break;
 8001e38:	e006      	b.n	8001e48 <HAL_DCMI_Stop+0x74>
    }
  }
  while((hdcmi->Instance->CR.reg & DCMI_CR_CAPTURE) != 0U);
 8001e3a:	687b      	ldr	r3, [r7, #4]
 8001e3c:	681b      	ldr	r3, [r3, #0]
 8001e3e:	681b      	ldr	r3, [r3, #0]
 8001e40:	f003 0301 	and.w	r3, r3, #1
 8001e44:	2b00      	cmp	r3, #0
 8001e46:	d1ea      	bne.n	8001e1e <HAL_DCMI_Stop+0x4a>

  /* Disable the DCMI */
  __HAL_DCMI_DISABLE(hdcmi);
 8001e48:	687b      	ldr	r3, [r7, #4]
 8001e4a:	681b      	ldr	r3, [r3, #0]
 8001e4c:	681a      	ldr	r2, [r3, #0]
 8001e4e:	687b      	ldr	r3, [r7, #4]
 8001e50:	681b      	ldr	r3, [r3, #0]
 8001e52:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8001e56:	601a      	str	r2, [r3, #0]

  /* Disable the DMA */
  HAL_DMA_Abort(hdcmi->DMA_Handle);
 8001e58:	687b      	ldr	r3, [r7, #4]
 8001e5a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001e5c:	4618      	mov	r0, r3
 8001e5e:	f000 fadb 	bl	8002418 <HAL_DMA_Abort>

  /* Update error code */
  hdcmi->ErrorCode |= HAL_DCMI_ERROR_NONE;
 8001e62:	687b      	ldr	r3, [r7, #4]
 8001e64:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Change DCMI state */
  hdcmi->State = HAL_DCMI_STATE_READY;
 8001e6a:	687b      	ldr	r3, [r7, #4]
 8001e6c:	2201      	movs	r2, #1
 8001e6e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  /* Process Unlocked */
  __HAL_UNLOCK(hdcmi);
 8001e72:	687b      	ldr	r3, [r7, #4]
 8001e74:	2200      	movs	r2, #0
 8001e76:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  /* Return function status */
  return status;
 8001e7a:	7bfb      	ldrb	r3, [r7, #15]
}
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	3710      	adds	r7, #16
 8001e80:	46bd      	mov	sp, r7
 8001e82:	bd80      	pop	{r7, pc}
 8001e84:	20000000 	.word	0x20000000
 8001e88:	92492493 	.word	0x92492493

08001e8c <HAL_DCMI_IRQHandler>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for the DCMI.
  * @retval None
  */
void HAL_DCMI_IRQHandler(DCMI_HandleTypeDef *hdcmi)
{
 8001e8c:	b580      	push	{r7, lr}
 8001e8e:	b084      	sub	sp, #16
 8001e90:	af00      	add	r7, sp, #0
 8001e92:	6078      	str	r0, [r7, #4]
  uint32_t isr_value = READ_REG(hdcmi->Instance->MIS.reg);
 8001e94:	687b      	ldr	r3, [r7, #4]
 8001e96:	681b      	ldr	r3, [r3, #0]
 8001e98:	691b      	ldr	r3, [r3, #16]
 8001e9a:	60fb      	str	r3, [r7, #12]

  /* Synchronization error interrupt management *******************************/
  if((isr_value & DCMI_FLAG_ERRRI) == DCMI_FLAG_ERRRI)
 8001e9c:	68fb      	ldr	r3, [r7, #12]
 8001e9e:	f003 0304 	and.w	r3, r3, #4
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	d016      	beq.n	8001ed4 <HAL_DCMI_IRQHandler+0x48>
  {
    /* Clear the Synchronization error flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_ERRRI);
 8001ea6:	687b      	ldr	r3, [r7, #4]
 8001ea8:	681b      	ldr	r3, [r3, #0]
 8001eaa:	2204      	movs	r2, #4
 8001eac:	615a      	str	r2, [r3, #20]

    /* Update error code */
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_SYNC;
 8001eae:	687b      	ldr	r3, [r7, #4]
 8001eb0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001eb2:	f043 0202 	orr.w	r2, r3, #2
 8001eb6:	687b      	ldr	r3, [r7, #4]
 8001eb8:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Change DCMI state */
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 8001eba:	687b      	ldr	r3, [r7, #4]
 8001ebc:	2204      	movs	r2, #4
 8001ebe:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    
    /* Set the synchronization error callback */
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 8001ec2:	687b      	ldr	r3, [r7, #4]
 8001ec4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ec6:	4a2f      	ldr	r2, [pc, #188]	@ (8001f84 <HAL_DCMI_IRQHandler+0xf8>)
 8001ec8:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Abort the DMA Transfer */
    HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
 8001eca:	687b      	ldr	r3, [r7, #4]
 8001ecc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ece:	4618      	mov	r0, r3
 8001ed0:	f000 fb12 	bl	80024f8 <HAL_DMA_Abort_IT>
  }
  /* Overflow interrupt management ********************************************/
  if((isr_value & DCMI_FLAG_OVRRI) == DCMI_FLAG_OVRRI)
 8001ed4:	68fb      	ldr	r3, [r7, #12]
 8001ed6:	f003 0302 	and.w	r3, r3, #2
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d016      	beq.n	8001f0c <HAL_DCMI_IRQHandler+0x80>
  {
    /* Clear the Overflow flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_OVRRI);
 8001ede:	687b      	ldr	r3, [r7, #4]
 8001ee0:	681b      	ldr	r3, [r3, #0]
 8001ee2:	2202      	movs	r2, #2
 8001ee4:	615a      	str	r2, [r3, #20]

    /* Update error code */
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_OVR;
 8001ee6:	687b      	ldr	r3, [r7, #4]
 8001ee8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001eea:	f043 0201 	orr.w	r2, r3, #1
 8001eee:	687b      	ldr	r3, [r7, #4]
 8001ef0:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Change DCMI state */
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 8001ef2:	687b      	ldr	r3, [r7, #4]
 8001ef4:	2204      	movs	r2, #4
 8001ef6:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    
    /* Set the overflow callback */
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 8001efa:	687b      	ldr	r3, [r7, #4]
 8001efc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001efe:	4a21      	ldr	r2, [pc, #132]	@ (8001f84 <HAL_DCMI_IRQHandler+0xf8>)
 8001f00:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Abort the DMA Transfer */
    HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
 8001f02:	687b      	ldr	r3, [r7, #4]
 8001f04:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001f06:	4618      	mov	r0, r3
 8001f08:	f000 faf6 	bl	80024f8 <HAL_DMA_Abort_IT>
  }
  /* Line Interrupt management ************************************************/
  if((isr_value & DCMI_FLAG_LINERI) == DCMI_FLAG_LINERI)
 8001f0c:	68fb      	ldr	r3, [r7, #12]
 8001f0e:	f003 0310 	and.w	r3, r3, #16
 8001f12:	2b00      	cmp	r3, #0
 8001f14:	d006      	beq.n	8001f24 <HAL_DCMI_IRQHandler+0x98>
  {
    /* Clear the Line interrupt flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_LINERI);
 8001f16:	687b      	ldr	r3, [r7, #4]
 8001f18:	681b      	ldr	r3, [r3, #0]
 8001f1a:	2210      	movs	r2, #16
 8001f1c:	615a      	str	r2, [r3, #20]
    /* Line interrupt Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI line event callback*/
    hdcmi->LineEventCallback(hdcmi);
#else  
    HAL_DCMI_LineEventCallback(hdcmi);
 8001f1e:	6878      	ldr	r0, [r7, #4]
 8001f20:	f000 f83c 	bl	8001f9c <HAL_DCMI_LineEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */     
  }
  /* VSYNC interrupt management ***********************************************/
  if((isr_value & DCMI_FLAG_VSYNCRI) == DCMI_FLAG_VSYNCRI)
 8001f24:	68fb      	ldr	r3, [r7, #12]
 8001f26:	f003 0308 	and.w	r3, r3, #8
 8001f2a:	2b00      	cmp	r3, #0
 8001f2c:	d006      	beq.n	8001f3c <HAL_DCMI_IRQHandler+0xb0>
  {
    /* Clear the VSYNC flag */
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_VSYNCRI);
 8001f2e:	687b      	ldr	r3, [r7, #4]
 8001f30:	681b      	ldr	r3, [r3, #0]
 8001f32:	2208      	movs	r2, #8
 8001f34:	615a      	str	r2, [r3, #20]
    /* VSYNC Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI vsync event callback*/
    hdcmi->VsyncEventCallback(hdcmi);
#else  
    HAL_DCMI_VsyncEventCallback(hdcmi);
 8001f36:	6878      	ldr	r0, [r7, #4]
 8001f38:	f000 f83a 	bl	8001fb0 <HAL_DCMI_VsyncEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */ 
  }
  /* FRAME interrupt management ***********************************************/
  if((isr_value & DCMI_FLAG_FRAMERI) == DCMI_FLAG_FRAMERI)
 8001f3c:	68fb      	ldr	r3, [r7, #12]
 8001f3e:	f003 0301 	and.w	r3, r3, #1
 8001f42:	2b00      	cmp	r3, #0
 8001f44:	d019      	beq.n	8001f7a <HAL_DCMI_IRQHandler+0xee>
  {
    /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
    if((hdcmi->Instance->CR.reg & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 8001f46:	687b      	ldr	r3, [r7, #4]
 8001f48:	681b      	ldr	r3, [r3, #0]
 8001f4a:	681b      	ldr	r3, [r3, #0]
 8001f4c:	f003 0302 	and.w	r3, r3, #2
 8001f50:	2b00      	cmp	r3, #0
 8001f52:	d007      	beq.n	8001f64 <HAL_DCMI_IRQHandler+0xd8>
    { 
      /* Disable the Line, Vsync, Error and Overrun interrupts */
      __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8001f54:	687b      	ldr	r3, [r7, #4]
 8001f56:	681b      	ldr	r3, [r3, #0]
 8001f58:	68da      	ldr	r2, [r3, #12]
 8001f5a:	687b      	ldr	r3, [r7, #4]
 8001f5c:	681b      	ldr	r3, [r3, #0]
 8001f5e:	f022 021e 	bic.w	r2, r2, #30
 8001f62:	60da      	str	r2, [r3, #12]
    }

    /* Disable the Frame interrupt */
    __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_FRAME);
 8001f64:	687b      	ldr	r3, [r7, #4]
 8001f66:	681b      	ldr	r3, [r3, #0]
 8001f68:	68da      	ldr	r2, [r3, #12]
 8001f6a:	687b      	ldr	r3, [r7, #4]
 8001f6c:	681b      	ldr	r3, [r3, #0]
 8001f6e:	f022 0201 	bic.w	r2, r2, #1
 8001f72:	60da      	str	r2, [r3, #12]
    /* Frame Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI frame event callback*/
    hdcmi->FrameEventCallback(hdcmi);
#else  
    HAL_DCMI_FrameEventCallback(hdcmi);
 8001f74:	6878      	ldr	r0, [r7, #4]
 8001f76:	f000 f825 	bl	8001fc4 <HAL_DCMI_FrameEventCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */      
  }
}
 8001f7a:	bf00      	nop
 8001f7c:	3710      	adds	r7, #16
 8001f7e:	46bd      	mov	sp, r7
 8001f80:	bd80      	pop	{r7, pc}
 8001f82:	bf00      	nop
 8001f84:	08002103 	.word	0x08002103

08001f88 <HAL_DCMI_ErrorCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi)
{
 8001f88:	b480      	push	{r7}
 8001f8a:	b083      	sub	sp, #12
 8001f8c:	af00      	add	r7, sp, #0
 8001f8e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_ErrorCallback could be implemented in the user file
   */
}
 8001f90:	bf00      	nop
 8001f92:	370c      	adds	r7, #12
 8001f94:	46bd      	mov	sp, r7
 8001f96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f9a:	4770      	bx	lr

08001f9c <HAL_DCMI_LineEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 8001f9c:	b480      	push	{r7}
 8001f9e:	b083      	sub	sp, #12
 8001fa0:	af00      	add	r7, sp, #0
 8001fa2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_LineEventCallback could be implemented in the user file
   */
}
 8001fa4:	bf00      	nop
 8001fa6:	370c      	adds	r7, #12
 8001fa8:	46bd      	mov	sp, r7
 8001faa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fae:	4770      	bx	lr

08001fb0 <HAL_DCMI_VsyncEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 8001fb0:	b480      	push	{r7}
 8001fb2:	b083      	sub	sp, #12
 8001fb4:	af00      	add	r7, sp, #0
 8001fb6:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_VsyncEventCallback could be implemented in the user file
   */
}
 8001fb8:	bf00      	nop
 8001fba:	370c      	adds	r7, #12
 8001fbc:	46bd      	mov	sp, r7
 8001fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fc2:	4770      	bx	lr

08001fc4 <HAL_DCMI_FrameEventCallback>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  */
__weak void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi)
{
 8001fc4:	b480      	push	{r7}
 8001fc6:	b083      	sub	sp, #12
 8001fc8:	af00      	add	r7, sp, #0
 8001fca:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmi);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_FrameEventCallback could be implemented in the user file
   */
}
 8001fcc:	bf00      	nop
 8001fce:	370c      	adds	r7, #12
 8001fd0:	46bd      	mov	sp, r7
 8001fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fd6:	4770      	bx	lr

08001fd8 <DCMI_DMAXferCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAXferCplt(DMA_HandleTypeDef *hdma)
{
 8001fd8:	b580      	push	{r7, lr}
 8001fda:	b084      	sub	sp, #16
 8001fdc:	af00      	add	r7, sp, #0
 8001fde:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 8001fe0:	2300      	movs	r3, #0
 8001fe2:	60fb      	str	r3, [r7, #12]
 
  DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8001fe4:	687b      	ldr	r3, [r7, #4]
 8001fe6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001fe8:	60bb      	str	r3, [r7, #8]
  
  if(hdcmi->XferCount != 0U)
 8001fea:	68bb      	ldr	r3, [r7, #8]
 8001fec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fee:	2b00      	cmp	r3, #0
 8001ff0:	d043      	beq.n	800207a <DCMI_DMAXferCplt+0xa2>
  {
    /* Update memory 0 address location */
    tmp = ((hdcmi->DMA_Handle->Instance->CR.reg) & DMA_SxCR_CT);
 8001ff2:	68bb      	ldr	r3, [r7, #8]
 8001ff4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8001ff6:	681b      	ldr	r3, [r3, #0]
 8001ff8:	681b      	ldr	r3, [r3, #0]
 8001ffa:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8001ffe:	60fb      	str	r3, [r7, #12]
    if(((hdcmi->XferCount % 2U) == 0U) && (tmp != 0U))
 8002000:	68bb      	ldr	r3, [r7, #8]
 8002002:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002004:	f003 0301 	and.w	r3, r3, #1
 8002008:	2b00      	cmp	r3, #0
 800200a:	d118      	bne.n	800203e <DCMI_DMAXferCplt+0x66>
 800200c:	68fb      	ldr	r3, [r7, #12]
 800200e:	2b00      	cmp	r3, #0
 8002010:	d015      	beq.n	800203e <DCMI_DMAXferCplt+0x66>
    {
      tmp = hdcmi->DMA_Handle->Instance->M0AR;
 8002012:	68bb      	ldr	r3, [r7, #8]
 8002014:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002016:	681b      	ldr	r3, [r3, #0]
 8002018:	68db      	ldr	r3, [r3, #12]
 800201a:	60fb      	str	r3, [r7, #12]
      HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY0);
 800201c:	68bb      	ldr	r3, [r7, #8]
 800201e:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8002020:	68bb      	ldr	r3, [r7, #8]
 8002022:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002024:	00da      	lsls	r2, r3, #3
 8002026:	68fb      	ldr	r3, [r7, #12]
 8002028:	4413      	add	r3, r2
 800202a:	2200      	movs	r2, #0
 800202c:	4619      	mov	r1, r3
 800202e:	f001 fe37 	bl	8003ca0 <HAL_DMAEx_ChangeMemory>
      hdcmi->XferCount--;
 8002032:	68bb      	ldr	r3, [r7, #8]
 8002034:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002036:	1e5a      	subs	r2, r3, #1
 8002038:	68bb      	ldr	r3, [r7, #8]
 800203a:	629a      	str	r2, [r3, #40]	@ 0x28
 800203c:	e044      	b.n	80020c8 <DCMI_DMAXferCplt+0xf0>
    }
    /* Update memory 1 address location */
    else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) == 0U)
 800203e:	68bb      	ldr	r3, [r7, #8]
 8002040:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	681b      	ldr	r3, [r3, #0]
 8002046:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800204a:	2b00      	cmp	r3, #0
 800204c:	d13c      	bne.n	80020c8 <DCMI_DMAXferCplt+0xf0>
    {
      tmp = hdcmi->DMA_Handle->Instance->M1AR;
 800204e:	68bb      	ldr	r3, [r7, #8]
 8002050:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002052:	681b      	ldr	r3, [r3, #0]
 8002054:	691b      	ldr	r3, [r3, #16]
 8002056:	60fb      	str	r3, [r7, #12]
      HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY1);
 8002058:	68bb      	ldr	r3, [r7, #8]
 800205a:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 800205c:	68bb      	ldr	r3, [r7, #8]
 800205e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002060:	00da      	lsls	r2, r3, #3
 8002062:	68fb      	ldr	r3, [r7, #12]
 8002064:	4413      	add	r3, r2
 8002066:	2201      	movs	r2, #1
 8002068:	4619      	mov	r1, r3
 800206a:	f001 fe19 	bl	8003ca0 <HAL_DMAEx_ChangeMemory>
      hdcmi->XferCount--;
 800206e:	68bb      	ldr	r3, [r7, #8]
 8002070:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002072:	1e5a      	subs	r2, r3, #1
 8002074:	68bb      	ldr	r3, [r7, #8]
 8002076:	629a      	str	r2, [r3, #40]	@ 0x28
 8002078:	e026      	b.n	80020c8 <DCMI_DMAXferCplt+0xf0>
    }
  }
  /* Update memory 0 address location */
  else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) != 0U)
 800207a:	68bb      	ldr	r3, [r7, #8]
 800207c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800207e:	681b      	ldr	r3, [r3, #0]
 8002080:	681b      	ldr	r3, [r3, #0]
 8002082:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002086:	2b00      	cmp	r3, #0
 8002088:	d006      	beq.n	8002098 <DCMI_DMAXferCplt+0xc0>
  {
    hdcmi->DMA_Handle->Instance->M0AR = hdcmi->pBuffPtr;
 800208a:	68bb      	ldr	r3, [r7, #8]
 800208c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	68ba      	ldr	r2, [r7, #8]
 8002092:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 8002094:	60da      	str	r2, [r3, #12]
 8002096:	e017      	b.n	80020c8 <DCMI_DMAXferCplt+0xf0>
  }
  /* Update memory 1 address location */
  else if((hdcmi->DMA_Handle->Instance->CR.reg & DMA_SxCR_CT) == 0U)
 8002098:	68bb      	ldr	r3, [r7, #8]
 800209a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	681b      	ldr	r3, [r3, #0]
 80020a0:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80020a4:	2b00      	cmp	r3, #0
 80020a6:	d10f      	bne.n	80020c8 <DCMI_DMAXferCplt+0xf0>
  {
    tmp = hdcmi->pBuffPtr;
 80020a8:	68bb      	ldr	r3, [r7, #8]
 80020aa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80020ac:	60fb      	str	r3, [r7, #12]
    hdcmi->DMA_Handle->Instance->M1AR = (tmp + (4U*hdcmi->XferSize));
 80020ae:	68bb      	ldr	r3, [r7, #8]
 80020b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80020b2:	0099      	lsls	r1, r3, #2
 80020b4:	68bb      	ldr	r3, [r7, #8]
 80020b6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80020b8:	681b      	ldr	r3, [r3, #0]
 80020ba:	68fa      	ldr	r2, [r7, #12]
 80020bc:	440a      	add	r2, r1
 80020be:	611a      	str	r2, [r3, #16]
    hdcmi->XferCount = hdcmi->XferTransferNumber;
 80020c0:	68bb      	ldr	r3, [r7, #8]
 80020c2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80020c4:	68bb      	ldr	r3, [r7, #8]
 80020c6:	629a      	str	r2, [r3, #40]	@ 0x28
  }
  
  /* Check if the frame is transferred */
  if(hdcmi->XferCount == hdcmi->XferTransferNumber)
 80020c8:	68bb      	ldr	r3, [r7, #8]
 80020ca:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80020cc:	68bb      	ldr	r3, [r7, #8]
 80020ce:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80020d0:	429a      	cmp	r2, r3
 80020d2:	d112      	bne.n	80020fa <DCMI_DMAXferCplt+0x122>
  {
    /* Enable the Frame interrupt */
    __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_FRAME);
 80020d4:	68bb      	ldr	r3, [r7, #8]
 80020d6:	681b      	ldr	r3, [r3, #0]
 80020d8:	68da      	ldr	r2, [r3, #12]
 80020da:	68bb      	ldr	r3, [r7, #8]
 80020dc:	681b      	ldr	r3, [r3, #0]
 80020de:	f042 0201 	orr.w	r2, r2, #1
 80020e2:	60da      	str	r2, [r3, #12]
    
    /* When snapshot mode, set dcmi state to ready */
    if((hdcmi->Instance->CR.reg & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 80020e4:	68bb      	ldr	r3, [r7, #8]
 80020e6:	681b      	ldr	r3, [r3, #0]
 80020e8:	681b      	ldr	r3, [r3, #0]
 80020ea:	f003 0302 	and.w	r3, r3, #2
 80020ee:	2b00      	cmp	r3, #0
 80020f0:	d003      	beq.n	80020fa <DCMI_DMAXferCplt+0x122>
    {  
      hdcmi->State= HAL_DCMI_STATE_READY;
 80020f2:	68bb      	ldr	r3, [r7, #8]
 80020f4:	2201      	movs	r2, #1
 80020f6:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
    }
  }
}
 80020fa:	bf00      	nop
 80020fc:	3710      	adds	r7, #16
 80020fe:	46bd      	mov	sp, r7
 8002100:	bd80      	pop	{r7, pc}

08002102 <DCMI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAError(DMA_HandleTypeDef *hdma)
{
 8002102:	b580      	push	{r7, lr}
 8002104:	b084      	sub	sp, #16
 8002106:	af00      	add	r7, sp, #0
 8002108:	6078      	str	r0, [r7, #4]
  DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800210a:	687b      	ldr	r3, [r7, #4]
 800210c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800210e:	60fb      	str	r3, [r7, #12]
  
  if(hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
 8002110:	68fb      	ldr	r3, [r7, #12]
 8002112:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002114:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002116:	2b02      	cmp	r3, #2
 8002118:	d003      	beq.n	8002122 <DCMI_DMAError+0x20>
  {
    /* Initialize the DCMI state*/
    hdcmi->State = HAL_DCMI_STATE_READY;
 800211a:	68fb      	ldr	r3, [r7, #12]
 800211c:	2201      	movs	r2, #1
 800211e:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  /* DCMI error Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
    /*Call registered DCMI error callback*/
    hdcmi->ErrorCallback(hdcmi);
#else  
  HAL_DCMI_ErrorCallback(hdcmi);
 8002122:	68f8      	ldr	r0, [r7, #12]
 8002124:	f7ff ff30 	bl	8001f88 <HAL_DCMI_ErrorCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */   

}
 8002128:	bf00      	nop
 800212a:	3710      	adds	r7, #16
 800212c:	46bd      	mov	sp, r7
 800212e:	bd80      	pop	{r7, pc}

08002130 <HAL_DCMI_Init>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Init(DCMI_HandleTypeDef *hdcmi)
{
 8002130:	b580      	push	{r7, lr}
 8002132:	b082      	sub	sp, #8
 8002134:	af00      	add	r7, sp, #0
 8002136:	6078      	str	r0, [r7, #4]
  /* Check the DCMI peripheral state */
  if(hdcmi == NULL)
 8002138:	687b      	ldr	r3, [r7, #4]
 800213a:	2b00      	cmp	r3, #0
 800213c:	d101      	bne.n	8002142 <HAL_DCMI_Init+0x12>
  {
     return HAL_ERROR;
 800213e:	2301      	movs	r3, #1
 8002140:	e05f      	b.n	8002202 <HAL_DCMI_Init+0xd2>
  assert_param(IS_DCMI_BYTE_SELECT_MODE(hdcmi->Init.ByteSelectMode));
  assert_param(IS_DCMI_BYTE_SELECT_START(hdcmi->Init.ByteSelectStart));
  assert_param(IS_DCMI_LINE_SELECT_MODE(hdcmi->Init.LineSelectMode));
  assert_param(IS_DCMI_LINE_SELECT_START(hdcmi->Init.LineSelectStart));
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
  if(hdcmi->State == HAL_DCMI_STATE_RESET)
 8002142:	687b      	ldr	r3, [r7, #4]
 8002144:	f893 3025 	ldrb.w	r3, [r3, #37]	@ 0x25
 8002148:	b2db      	uxtb	r3, r3
 800214a:	2b00      	cmp	r3, #0
 800214c:	d109      	bne.n	8002162 <HAL_DCMI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hdcmi->Lock = HAL_UNLOCKED;
 800214e:	687b      	ldr	r3, [r7, #4]
 8002150:	2200      	movs	r2, #0
 8002152:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    }
    /* Initialize the low level hardware (MSP) */
    hdcmi->MspInitCallback(hdcmi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMI_MspInit(hdcmi);
 8002156:	6878      	ldr	r0, [r7, #4]
 8002158:	f7ff f9de 	bl	8001518 <HAL_DCMI_MspInit>
#endif /* (USE_HAL_DCMI_REGISTER_CALLBACKS) */
    HAL_DCMI_MspInit(hdcmi);
 800215c:	6878      	ldr	r0, [r7, #4]
 800215e:	f7ff f9db 	bl	8001518 <HAL_DCMI_MspInit>
  }

  /* Change the DCMI state */
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8002162:	687b      	ldr	r3, [r7, #4]
 8002164:	2202      	movs	r2, #2
 8002166:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
                          /* Configures the HS, VS, DE and PC polarity */
  hdcmi->Instance->CR.reg &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 |\
 800216a:	687b      	ldr	r3, [r7, #4]
 800216c:	681b      	ldr	r3, [r3, #0]
 800216e:	681b      	ldr	r3, [r3, #0]
 8002170:	687a      	ldr	r2, [r7, #4]
 8002172:	6812      	ldr	r2, [r2, #0]
 8002174:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 8002178:	f023 0308 	bic.w	r3, r3, #8
 800217c:	6013      	str	r3, [r2, #0]
#if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
                           | DCMI_CR_BSM_0 | DCMI_CR_BSM_1 | DCMI_CR_OEBS |\
                           DCMI_CR_LSM | DCMI_CR_OELS
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
                           );
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 800217e:	687b      	ldr	r3, [r7, #4]
 8002180:	681b      	ldr	r3, [r3, #0]
 8002182:	6819      	ldr	r1, [r3, #0]
 8002184:	687b      	ldr	r3, [r7, #4]
 8002186:	685a      	ldr	r2, [r3, #4]
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	695b      	ldr	r3, [r3, #20]
 800218c:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 800218e:	687b      	ldr	r3, [r7, #4]
 8002190:	68db      	ldr	r3, [r3, #12]
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 8002192:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 8002194:	687b      	ldr	r3, [r7, #4]
 8002196:	691b      	ldr	r3, [r3, #16]
 8002198:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 800219a:	687b      	ldr	r3, [r7, #4]
 800219c:	689b      	ldr	r3, [r3, #8]
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 800219e:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 80021a0:	687b      	ldr	r3, [r7, #4]
 80021a2:	699b      	ldr	r3, [r3, #24]
 80021a4:	431a      	orrs	r2, r3
                                     hdcmi->Init.JPEGMode
 80021a6:	687b      	ldr	r3, [r7, #4]
 80021a8:	6a1b      	ldr	r3, [r3, #32]
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 80021aa:	431a      	orrs	r2, r3
  hdcmi->Instance->CR.reg |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 80021ac:	687b      	ldr	r3, [r7, #4]
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	430a      	orrs	r2, r1
 80021b2:	601a      	str	r2, [r3, #0]
                                     | hdcmi->Init.ByteSelectMode |\
                                     hdcmi->Init.ByteSelectStart | hdcmi->Init.LineSelectMode |\
                                     hdcmi->Init.LineSelectStart
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
                                     );
  if(hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
 80021b4:	687b      	ldr	r3, [r7, #4]
 80021b6:	685b      	ldr	r3, [r3, #4]
 80021b8:	2b10      	cmp	r3, #16
 80021ba:	d112      	bne.n	80021e2 <HAL_DCMI_Init+0xb2>
  {
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 80021bc:	687b      	ldr	r3, [r7, #4]
 80021be:	7f1b      	ldrb	r3, [r3, #28]
 80021c0:	461a      	mov	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_POSITION_ESCR_LSC)|
 80021c2:	687b      	ldr	r3, [r7, #4]
 80021c4:	7f5b      	ldrb	r3, [r3, #29]
 80021c6:	021b      	lsls	r3, r3, #8
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 80021c8:	431a      	orrs	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_POSITION_ESCR_LEC) |
 80021ca:	687b      	ldr	r3, [r7, #4]
 80021cc:	7f9b      	ldrb	r3, [r3, #30]
 80021ce:	041b      	lsls	r3, r3, #16
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_POSITION_ESCR_LSC)|
 80021d0:	ea42 0103 	orr.w	r1, r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.FrameEndCode << DCMI_POSITION_ESCR_FEC));
 80021d4:	687b      	ldr	r3, [r7, #4]
 80021d6:	7fdb      	ldrb	r3, [r3, #31]
 80021d8:	061a      	lsls	r2, r3, #24
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 80021da:	687b      	ldr	r3, [r7, #4]
 80021dc:	681b      	ldr	r3, [r3, #0]
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_POSITION_ESCR_LEC) |
 80021de:	430a      	orrs	r2, r1
    hdcmi->Instance->ESCR.reg = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
 80021e0:	619a      	str	r2, [r3, #24]

  }

  /* Enable the Line, Vsync, Error and Overrun interrupts */
  __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 80021e2:	687b      	ldr	r3, [r7, #4]
 80021e4:	681b      	ldr	r3, [r3, #0]
 80021e6:	68da      	ldr	r2, [r3, #12]
 80021e8:	687b      	ldr	r3, [r7, #4]
 80021ea:	681b      	ldr	r3, [r3, #0]
 80021ec:	f042 021e 	orr.w	r2, r2, #30
 80021f0:	60da      	str	r2, [r3, #12]

  /* Update error code */
  hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
 80021f2:	687b      	ldr	r3, [r7, #4]
 80021f4:	2200      	movs	r2, #0
 80021f6:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Initialize the DCMI state*/
  hdcmi->State  = HAL_DCMI_STATE_READY;
 80021f8:	687b      	ldr	r3, [r7, #4]
 80021fa:	2201      	movs	r2, #1
 80021fc:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  return HAL_OK;
 8002200:	2300      	movs	r3, #0
}
 8002202:	4618      	mov	r0, r3
 8002204:	3708      	adds	r7, #8
 8002206:	46bd      	mov	sp, r7
 8002208:	bd80      	pop	{r7, pc}
	...

0800220c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800220c:	b580      	push	{r7, lr}
 800220e:	b086      	sub	sp, #24
 8002210:	af00      	add	r7, sp, #0
 8002212:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 8002214:	2300      	movs	r3, #0
 8002216:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 8002218:	f7ff fbfa 	bl	8001a10 <HAL_GetTick>
 800221c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800221e:	687b      	ldr	r3, [r7, #4]
 8002220:	2b00      	cmp	r3, #0
 8002222:	d101      	bne.n	8002228 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 8002224:	2301      	movs	r3, #1
 8002226:	e099      	b.n	800235c <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8002228:	687b      	ldr	r3, [r7, #4]
 800222a:	2202      	movs	r2, #2
 800222c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 8002230:	687b      	ldr	r3, [r7, #4]
 8002232:	2200      	movs	r2, #0
 8002234:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8002238:	687b      	ldr	r3, [r7, #4]
 800223a:	681b      	ldr	r3, [r3, #0]
 800223c:	681a      	ldr	r2, [r3, #0]
 800223e:	687b      	ldr	r3, [r7, #4]
 8002240:	681b      	ldr	r3, [r3, #0]
 8002242:	f022 0201 	bic.w	r2, r2, #1
 8002246:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 8002248:	e00f      	b.n	800226a <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800224a:	f7ff fbe1 	bl	8001a10 <HAL_GetTick>
 800224e:	4602      	mov	r2, r0
 8002250:	693b      	ldr	r3, [r7, #16]
 8002252:	1ad3      	subs	r3, r2, r3
 8002254:	2b05      	cmp	r3, #5
 8002256:	d908      	bls.n	800226a <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	2220      	movs	r2, #32
 800225c:	655a      	str	r2, [r3, #84]	@ 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800225e:	687b      	ldr	r3, [r7, #4]
 8002260:	2203      	movs	r2, #3
 8002262:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
      
      return HAL_TIMEOUT;
 8002266:	2303      	movs	r3, #3
 8002268:	e078      	b.n	800235c <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 800226a:	687b      	ldr	r3, [r7, #4]
 800226c:	681b      	ldr	r3, [r3, #0]
 800226e:	681b      	ldr	r3, [r3, #0]
 8002270:	f003 0301 	and.w	r3, r3, #1
 8002274:	2b00      	cmp	r3, #0
 8002276:	d1e8      	bne.n	800224a <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR.reg;
 8002278:	687b      	ldr	r3, [r7, #4]
 800227a:	681b      	ldr	r3, [r3, #0]
 800227c:	681b      	ldr	r3, [r3, #0]
 800227e:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002280:	697a      	ldr	r2, [r7, #20]
 8002282:	4b38      	ldr	r3, [pc, #224]	@ (8002364 <HAL_DMA_Init+0x158>)
 8002284:	4013      	ands	r3, r2
 8002286:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002288:	687b      	ldr	r3, [r7, #4]
 800228a:	685a      	ldr	r2, [r3, #4]
 800228c:	687b      	ldr	r3, [r7, #4]
 800228e:	689b      	ldr	r3, [r3, #8]
 8002290:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002292:	687b      	ldr	r3, [r7, #4]
 8002294:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002296:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002298:	687b      	ldr	r3, [r7, #4]
 800229a:	691b      	ldr	r3, [r3, #16]
 800229c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800229e:	687b      	ldr	r3, [r7, #4]
 80022a0:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80022a2:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80022a4:	687b      	ldr	r3, [r7, #4]
 80022a6:	699b      	ldr	r3, [r3, #24]
 80022a8:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80022aa:	687b      	ldr	r3, [r7, #4]
 80022ac:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80022ae:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80022b0:	687b      	ldr	r3, [r7, #4]
 80022b2:	6a1b      	ldr	r3, [r3, #32]
 80022b4:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80022b6:	697a      	ldr	r2, [r7, #20]
 80022b8:	4313      	orrs	r3, r2
 80022ba:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80022bc:	687b      	ldr	r3, [r7, #4]
 80022be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80022c0:	2b04      	cmp	r3, #4
 80022c2:	d107      	bne.n	80022d4 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80022c4:	687b      	ldr	r3, [r7, #4]
 80022c6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80022c8:	687b      	ldr	r3, [r7, #4]
 80022ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80022cc:	4313      	orrs	r3, r2
 80022ce:	697a      	ldr	r2, [r7, #20]
 80022d0:	4313      	orrs	r3, r2
 80022d2:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR.reg = tmp;
 80022d4:	687b      	ldr	r3, [r7, #4]
 80022d6:	681b      	ldr	r3, [r3, #0]
 80022d8:	697a      	ldr	r2, [r7, #20]
 80022da:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR.reg;
 80022dc:	687b      	ldr	r3, [r7, #4]
 80022de:	681b      	ldr	r3, [r3, #0]
 80022e0:	695b      	ldr	r3, [r3, #20]
 80022e2:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80022e4:	697b      	ldr	r3, [r7, #20]
 80022e6:	f023 0307 	bic.w	r3, r3, #7
 80022ea:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 80022ec:	687b      	ldr	r3, [r7, #4]
 80022ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80022f0:	697a      	ldr	r2, [r7, #20]
 80022f2:	4313      	orrs	r3, r2
 80022f4:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80022f6:	687b      	ldr	r3, [r7, #4]
 80022f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80022fa:	2b04      	cmp	r3, #4
 80022fc:	d117      	bne.n	800232e <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 80022fe:	687b      	ldr	r3, [r7, #4]
 8002300:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002302:	697a      	ldr	r2, [r7, #20]
 8002304:	4313      	orrs	r3, r2
 8002306:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8002308:	687b      	ldr	r3, [r7, #4]
 800230a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800230c:	2b00      	cmp	r3, #0
 800230e:	d00e      	beq.n	800232e <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8002310:	6878      	ldr	r0, [r7, #4]
 8002312:	f000 fb01 	bl	8002918 <DMA_CheckFifoParam>
 8002316:	4603      	mov	r3, r0
 8002318:	2b00      	cmp	r3, #0
 800231a:	d008      	beq.n	800232e <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800231c:	687b      	ldr	r3, [r7, #4]
 800231e:	2240      	movs	r2, #64	@ 0x40
 8002320:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 8002322:	687b      	ldr	r3, [r7, #4]
 8002324:	2201      	movs	r2, #1
 8002326:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        return HAL_ERROR; 
 800232a:	2301      	movs	r3, #1
 800232c:	e016      	b.n	800235c <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR.reg = tmp;
 800232e:	687b      	ldr	r3, [r7, #4]
 8002330:	681b      	ldr	r3, [r3, #0]
 8002332:	697a      	ldr	r2, [r7, #20]
 8002334:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8002336:	6878      	ldr	r0, [r7, #4]
 8002338:	f000 fab8 	bl	80028ac <DMA_CalcBaseAndBitshift>
 800233c:	4603      	mov	r3, r0
 800233e:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002340:	687b      	ldr	r3, [r7, #4]
 8002342:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002344:	223f      	movs	r2, #63	@ 0x3f
 8002346:	409a      	lsls	r2, r3
 8002348:	68fb      	ldr	r3, [r7, #12]
 800234a:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800234c:	687b      	ldr	r3, [r7, #4]
 800234e:	2200      	movs	r2, #0
 8002350:	655a      	str	r2, [r3, #84]	@ 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8002352:	687b      	ldr	r3, [r7, #4]
 8002354:	2201      	movs	r2, #1
 8002356:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  return HAL_OK;
 800235a:	2300      	movs	r3, #0
}
 800235c:	4618      	mov	r0, r3
 800235e:	3718      	adds	r7, #24
 8002360:	46bd      	mov	sp, r7
 8002362:	bd80      	pop	{r7, pc}
 8002364:	f010803f 	.word	0xf010803f

08002368 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8002368:	b580      	push	{r7, lr}
 800236a:	b086      	sub	sp, #24
 800236c:	af00      	add	r7, sp, #0
 800236e:	60f8      	str	r0, [r7, #12]
 8002370:	60b9      	str	r1, [r7, #8]
 8002372:	607a      	str	r2, [r7, #4]
 8002374:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002376:	2300      	movs	r3, #0
 8002378:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800237a:	68fb      	ldr	r3, [r7, #12]
 800237c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800237e:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 8002380:	68fb      	ldr	r3, [r7, #12]
 8002382:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8002386:	2b01      	cmp	r3, #1
 8002388:	d101      	bne.n	800238e <HAL_DMA_Start_IT+0x26>
 800238a:	2302      	movs	r3, #2
 800238c:	e040      	b.n	8002410 <HAL_DMA_Start_IT+0xa8>
 800238e:	68fb      	ldr	r3, [r7, #12]
 8002390:	2201      	movs	r2, #1
 8002392:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8002396:	68fb      	ldr	r3, [r7, #12]
 8002398:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800239c:	b2db      	uxtb	r3, r3
 800239e:	2b01      	cmp	r3, #1
 80023a0:	d12f      	bne.n	8002402 <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80023a2:	68fb      	ldr	r3, [r7, #12]
 80023a4:	2202      	movs	r2, #2
 80023a6:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80023aa:	68fb      	ldr	r3, [r7, #12]
 80023ac:	2200      	movs	r2, #0
 80023ae:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80023b0:	683b      	ldr	r3, [r7, #0]
 80023b2:	687a      	ldr	r2, [r7, #4]
 80023b4:	68b9      	ldr	r1, [r7, #8]
 80023b6:	68f8      	ldr	r0, [r7, #12]
 80023b8:	f000 fa4a 	bl	8002850 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80023bc:	68fb      	ldr	r3, [r7, #12]
 80023be:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80023c0:	223f      	movs	r2, #63	@ 0x3f
 80023c2:	409a      	lsls	r2, r3
 80023c4:	693b      	ldr	r3, [r7, #16]
 80023c6:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR.reg  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80023c8:	68fb      	ldr	r3, [r7, #12]
 80023ca:	681b      	ldr	r3, [r3, #0]
 80023cc:	681a      	ldr	r2, [r3, #0]
 80023ce:	68fb      	ldr	r3, [r7, #12]
 80023d0:	681b      	ldr	r3, [r3, #0]
 80023d2:	f042 0216 	orr.w	r2, r2, #22
 80023d6:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 80023d8:	68fb      	ldr	r3, [r7, #12]
 80023da:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80023dc:	2b00      	cmp	r3, #0
 80023de:	d007      	beq.n	80023f0 <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR.reg  |= DMA_IT_HT;
 80023e0:	68fb      	ldr	r3, [r7, #12]
 80023e2:	681b      	ldr	r3, [r3, #0]
 80023e4:	681a      	ldr	r2, [r3, #0]
 80023e6:	68fb      	ldr	r3, [r7, #12]
 80023e8:	681b      	ldr	r3, [r3, #0]
 80023ea:	f042 0208 	orr.w	r2, r2, #8
 80023ee:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 80023f0:	68fb      	ldr	r3, [r7, #12]
 80023f2:	681b      	ldr	r3, [r3, #0]
 80023f4:	681a      	ldr	r2, [r3, #0]
 80023f6:	68fb      	ldr	r3, [r7, #12]
 80023f8:	681b      	ldr	r3, [r3, #0]
 80023fa:	f042 0201 	orr.w	r2, r2, #1
 80023fe:	601a      	str	r2, [r3, #0]
 8002400:	e005      	b.n	800240e <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8002402:	68fb      	ldr	r3, [r7, #12]
 8002404:	2200      	movs	r2, #0
 8002406:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 800240a:	2302      	movs	r3, #2
 800240c:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 800240e:	7dfb      	ldrb	r3, [r7, #23]
}
 8002410:	4618      	mov	r0, r3
 8002412:	3718      	adds	r7, #24
 8002414:	46bd      	mov	sp, r7
 8002416:	bd80      	pop	{r7, pc}

08002418 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8002418:	b580      	push	{r7, lr}
 800241a:	b084      	sub	sp, #16
 800241c:	af00      	add	r7, sp, #0
 800241e:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002420:	687b      	ldr	r3, [r7, #4]
 8002422:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002424:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
 8002426:	f7ff faf3 	bl	8001a10 <HAL_GetTick>
 800242a:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800242c:	687b      	ldr	r3, [r7, #4]
 800242e:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8002432:	b2db      	uxtb	r3, r3
 8002434:	2b02      	cmp	r3, #2
 8002436:	d008      	beq.n	800244a <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8002438:	687b      	ldr	r3, [r7, #4]
 800243a:	2280      	movs	r2, #128	@ 0x80
 800243c:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800243e:	687b      	ldr	r3, [r7, #4]
 8002440:	2200      	movs	r2, #0
 8002442:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    return HAL_ERROR;
 8002446:	2301      	movs	r3, #1
 8002448:	e052      	b.n	80024f0 <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR.reg  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800244a:	687b      	ldr	r3, [r7, #4]
 800244c:	681b      	ldr	r3, [r3, #0]
 800244e:	681a      	ldr	r2, [r3, #0]
 8002450:	687b      	ldr	r3, [r7, #4]
 8002452:	681b      	ldr	r3, [r3, #0]
 8002454:	f022 0216 	bic.w	r2, r2, #22
 8002458:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR.reg &= ~(DMA_IT_FE);
 800245a:	687b      	ldr	r3, [r7, #4]
 800245c:	681b      	ldr	r3, [r3, #0]
 800245e:	695a      	ldr	r2, [r3, #20]
 8002460:	687b      	ldr	r3, [r7, #4]
 8002462:	681b      	ldr	r3, [r3, #0]
 8002464:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8002468:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800246a:	687b      	ldr	r3, [r7, #4]
 800246c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800246e:	2b00      	cmp	r3, #0
 8002470:	d103      	bne.n	800247a <HAL_DMA_Abort+0x62>
 8002472:	687b      	ldr	r3, [r7, #4]
 8002474:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002476:	2b00      	cmp	r3, #0
 8002478:	d007      	beq.n	800248a <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 800247a:	687b      	ldr	r3, [r7, #4]
 800247c:	681b      	ldr	r3, [r3, #0]
 800247e:	681a      	ldr	r2, [r3, #0]
 8002480:	687b      	ldr	r3, [r7, #4]
 8002482:	681b      	ldr	r3, [r3, #0]
 8002484:	f022 0208 	bic.w	r2, r2, #8
 8002488:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 800248a:	687b      	ldr	r3, [r7, #4]
 800248c:	681b      	ldr	r3, [r3, #0]
 800248e:	681a      	ldr	r2, [r3, #0]
 8002490:	687b      	ldr	r3, [r7, #4]
 8002492:	681b      	ldr	r3, [r3, #0]
 8002494:	f022 0201 	bic.w	r2, r2, #1
 8002498:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 800249a:	e013      	b.n	80024c4 <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800249c:	f7ff fab8 	bl	8001a10 <HAL_GetTick>
 80024a0:	4602      	mov	r2, r0
 80024a2:	68bb      	ldr	r3, [r7, #8]
 80024a4:	1ad3      	subs	r3, r2, r3
 80024a6:	2b05      	cmp	r3, #5
 80024a8:	d90c      	bls.n	80024c4 <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80024aa:	687b      	ldr	r3, [r7, #4]
 80024ac:	2220      	movs	r2, #32
 80024ae:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 80024b0:	687b      	ldr	r3, [r7, #4]
 80024b2:	2203      	movs	r2, #3
 80024b4:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80024b8:	687b      	ldr	r3, [r7, #4]
 80024ba:	2200      	movs	r2, #0
 80024bc:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        
        return HAL_TIMEOUT;
 80024c0:	2303      	movs	r3, #3
 80024c2:	e015      	b.n	80024f0 <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET)
 80024c4:	687b      	ldr	r3, [r7, #4]
 80024c6:	681b      	ldr	r3, [r3, #0]
 80024c8:	681b      	ldr	r3, [r3, #0]
 80024ca:	f003 0301 	and.w	r3, r3, #1
 80024ce:	2b00      	cmp	r3, #0
 80024d0:	d1e4      	bne.n	800249c <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80024d2:	687b      	ldr	r3, [r7, #4]
 80024d4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80024d6:	223f      	movs	r2, #63	@ 0x3f
 80024d8:	409a      	lsls	r2, r3
 80024da:	68fb      	ldr	r3, [r7, #12]
 80024dc:	609a      	str	r2, [r3, #8]
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
 80024de:	687b      	ldr	r3, [r7, #4]
 80024e0:	2201      	movs	r2, #1
 80024e2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80024e6:	687b      	ldr	r3, [r7, #4]
 80024e8:	2200      	movs	r2, #0
 80024ea:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  }
  return HAL_OK;
 80024ee:	2300      	movs	r3, #0
}
 80024f0:	4618      	mov	r0, r3
 80024f2:	3710      	adds	r7, #16
 80024f4:	46bd      	mov	sp, r7
 80024f6:	bd80      	pop	{r7, pc}

080024f8 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 80024f8:	b480      	push	{r7}
 80024fa:	b083      	sub	sp, #12
 80024fc:	af00      	add	r7, sp, #0
 80024fe:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8002500:	687b      	ldr	r3, [r7, #4]
 8002502:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8002506:	b2db      	uxtb	r3, r3
 8002508:	2b02      	cmp	r3, #2
 800250a:	d004      	beq.n	8002516 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800250c:	687b      	ldr	r3, [r7, #4]
 800250e:	2280      	movs	r2, #128	@ 0x80
 8002510:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 8002512:	2301      	movs	r3, #1
 8002514:	e00c      	b.n	8002530 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8002516:	687b      	ldr	r3, [r7, #4]
 8002518:	2205      	movs	r2, #5
 800251a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 800251e:	687b      	ldr	r3, [r7, #4]
 8002520:	681b      	ldr	r3, [r3, #0]
 8002522:	681a      	ldr	r2, [r3, #0]
 8002524:	687b      	ldr	r3, [r7, #4]
 8002526:	681b      	ldr	r3, [r3, #0]
 8002528:	f022 0201 	bic.w	r2, r2, #1
 800252c:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 800252e:	2300      	movs	r3, #0
}
 8002530:	4618      	mov	r0, r3
 8002532:	370c      	adds	r7, #12
 8002534:	46bd      	mov	sp, r7
 8002536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800253a:	4770      	bx	lr

0800253c <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800253c:	b580      	push	{r7, lr}
 800253e:	b086      	sub	sp, #24
 8002540:	af00      	add	r7, sp, #0
 8002542:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  volatile uint32_t count = 0U;
 8002544:	2300      	movs	r3, #0
 8002546:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 8002548:	4b8e      	ldr	r3, [pc, #568]	@ (8002784 <HAL_DMA_IRQHandler+0x248>)
 800254a:	681b      	ldr	r3, [r3, #0]
 800254c:	4a8e      	ldr	r2, [pc, #568]	@ (8002788 <HAL_DMA_IRQHandler+0x24c>)
 800254e:	fba2 2303 	umull	r2, r3, r2, r3
 8002552:	0a9b      	lsrs	r3, r3, #10
 8002554:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002556:	687b      	ldr	r3, [r7, #4]
 8002558:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800255a:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 800255c:	693b      	ldr	r3, [r7, #16]
 800255e:	681b      	ldr	r3, [r3, #0]
 8002560:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8002562:	687b      	ldr	r3, [r7, #4]
 8002564:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002566:	2208      	movs	r2, #8
 8002568:	409a      	lsls	r2, r3
 800256a:	68fb      	ldr	r3, [r7, #12]
 800256c:	4013      	ands	r3, r2
 800256e:	2b00      	cmp	r3, #0
 8002570:	d01a      	beq.n	80025a8 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8002572:	687b      	ldr	r3, [r7, #4]
 8002574:	681b      	ldr	r3, [r3, #0]
 8002576:	681b      	ldr	r3, [r3, #0]
 8002578:	f003 0304 	and.w	r3, r3, #4
 800257c:	2b00      	cmp	r3, #0
 800257e:	d013      	beq.n	80025a8 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR.reg  &= ~(DMA_IT_TE);
 8002580:	687b      	ldr	r3, [r7, #4]
 8002582:	681b      	ldr	r3, [r3, #0]
 8002584:	681a      	ldr	r2, [r3, #0]
 8002586:	687b      	ldr	r3, [r7, #4]
 8002588:	681b      	ldr	r3, [r3, #0]
 800258a:	f022 0204 	bic.w	r2, r2, #4
 800258e:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8002590:	687b      	ldr	r3, [r7, #4]
 8002592:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002594:	2208      	movs	r2, #8
 8002596:	409a      	lsls	r2, r3
 8002598:	693b      	ldr	r3, [r7, #16]
 800259a:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800259c:	687b      	ldr	r3, [r7, #4]
 800259e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80025a0:	f043 0201 	orr.w	r2, r3, #1
 80025a4:	687b      	ldr	r3, [r7, #4]
 80025a6:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 80025a8:	687b      	ldr	r3, [r7, #4]
 80025aa:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80025ac:	2201      	movs	r2, #1
 80025ae:	409a      	lsls	r2, r3
 80025b0:	68fb      	ldr	r3, [r7, #12]
 80025b2:	4013      	ands	r3, r2
 80025b4:	2b00      	cmp	r3, #0
 80025b6:	d012      	beq.n	80025de <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	681b      	ldr	r3, [r3, #0]
 80025bc:	695b      	ldr	r3, [r3, #20]
 80025be:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80025c2:	2b00      	cmp	r3, #0
 80025c4:	d00b      	beq.n	80025de <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 80025c6:	687b      	ldr	r3, [r7, #4]
 80025c8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80025ca:	2201      	movs	r2, #1
 80025cc:	409a      	lsls	r2, r3
 80025ce:	693b      	ldr	r3, [r7, #16]
 80025d0:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80025d2:	687b      	ldr	r3, [r7, #4]
 80025d4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80025d6:	f043 0202 	orr.w	r2, r3, #2
 80025da:	687b      	ldr	r3, [r7, #4]
 80025dc:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80025de:	687b      	ldr	r3, [r7, #4]
 80025e0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80025e2:	2204      	movs	r2, #4
 80025e4:	409a      	lsls	r2, r3
 80025e6:	68fb      	ldr	r3, [r7, #12]
 80025e8:	4013      	ands	r3, r2
 80025ea:	2b00      	cmp	r3, #0
 80025ec:	d012      	beq.n	8002614 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80025ee:	687b      	ldr	r3, [r7, #4]
 80025f0:	681b      	ldr	r3, [r3, #0]
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	f003 0302 	and.w	r3, r3, #2
 80025f8:	2b00      	cmp	r3, #0
 80025fa:	d00b      	beq.n	8002614 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002600:	2204      	movs	r2, #4
 8002602:	409a      	lsls	r2, r3
 8002604:	693b      	ldr	r3, [r7, #16]
 8002606:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8002608:	687b      	ldr	r3, [r7, #4]
 800260a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800260c:	f043 0204 	orr.w	r2, r3, #4
 8002610:	687b      	ldr	r3, [r7, #4]
 8002612:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8002614:	687b      	ldr	r3, [r7, #4]
 8002616:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002618:	2210      	movs	r2, #16
 800261a:	409a      	lsls	r2, r3
 800261c:	68fb      	ldr	r3, [r7, #12]
 800261e:	4013      	ands	r3, r2
 8002620:	2b00      	cmp	r3, #0
 8002622:	d043      	beq.n	80026ac <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8002624:	687b      	ldr	r3, [r7, #4]
 8002626:	681b      	ldr	r3, [r3, #0]
 8002628:	681b      	ldr	r3, [r3, #0]
 800262a:	f003 0308 	and.w	r3, r3, #8
 800262e:	2b00      	cmp	r3, #0
 8002630:	d03c      	beq.n	80026ac <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002636:	2210      	movs	r2, #16
 8002638:	409a      	lsls	r2, r3
 800263a:	693b      	ldr	r3, [r7, #16]
 800263c:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR.reg) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	681b      	ldr	r3, [r3, #0]
 8002642:	681b      	ldr	r3, [r3, #0]
 8002644:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8002648:	2b00      	cmp	r3, #0
 800264a:	d018      	beq.n	800267e <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR.reg & DMA_SxCR_CT) == RESET)
 800264c:	687b      	ldr	r3, [r7, #4]
 800264e:	681b      	ldr	r3, [r3, #0]
 8002650:	681b      	ldr	r3, [r3, #0]
 8002652:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002656:	2b00      	cmp	r3, #0
 8002658:	d108      	bne.n	800266c <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 800265a:	687b      	ldr	r3, [r7, #4]
 800265c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800265e:	2b00      	cmp	r3, #0
 8002660:	d024      	beq.n	80026ac <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 8002662:	687b      	ldr	r3, [r7, #4]
 8002664:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002666:	6878      	ldr	r0, [r7, #4]
 8002668:	4798      	blx	r3
 800266a:	e01f      	b.n	80026ac <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 800266c:	687b      	ldr	r3, [r7, #4]
 800266e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002670:	2b00      	cmp	r3, #0
 8002672:	d01b      	beq.n	80026ac <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 8002674:	687b      	ldr	r3, [r7, #4]
 8002676:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002678:	6878      	ldr	r0, [r7, #4]
 800267a:	4798      	blx	r3
 800267c:	e016      	b.n	80026ac <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR.reg & DMA_SxCR_CIRC) == RESET)
 800267e:	687b      	ldr	r3, [r7, #4]
 8002680:	681b      	ldr	r3, [r3, #0]
 8002682:	681b      	ldr	r3, [r3, #0]
 8002684:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002688:	2b00      	cmp	r3, #0
 800268a:	d107      	bne.n	800269c <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 800268c:	687b      	ldr	r3, [r7, #4]
 800268e:	681b      	ldr	r3, [r3, #0]
 8002690:	681a      	ldr	r2, [r3, #0]
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	681b      	ldr	r3, [r3, #0]
 8002696:	f022 0208 	bic.w	r2, r2, #8
 800269a:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 800269c:	687b      	ldr	r3, [r7, #4]
 800269e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80026a0:	2b00      	cmp	r3, #0
 80026a2:	d003      	beq.n	80026ac <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 80026a4:	687b      	ldr	r3, [r7, #4]
 80026a6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80026a8:	6878      	ldr	r0, [r7, #4]
 80026aa:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80026b0:	2220      	movs	r2, #32
 80026b2:	409a      	lsls	r2, r3
 80026b4:	68fb      	ldr	r3, [r7, #12]
 80026b6:	4013      	ands	r3, r2
 80026b8:	2b00      	cmp	r3, #0
 80026ba:	f000 808f 	beq.w	80027dc <HAL_DMA_IRQHandler+0x2a0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80026be:	687b      	ldr	r3, [r7, #4]
 80026c0:	681b      	ldr	r3, [r3, #0]
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	f003 0310 	and.w	r3, r3, #16
 80026c8:	2b00      	cmp	r3, #0
 80026ca:	f000 8087 	beq.w	80027dc <HAL_DMA_IRQHandler+0x2a0>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80026ce:	687b      	ldr	r3, [r7, #4]
 80026d0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80026d2:	2220      	movs	r2, #32
 80026d4:	409a      	lsls	r2, r3
 80026d6:	693b      	ldr	r3, [r7, #16]
 80026d8:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80026e0:	b2db      	uxtb	r3, r3
 80026e2:	2b05      	cmp	r3, #5
 80026e4:	d136      	bne.n	8002754 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR.reg  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	681a      	ldr	r2, [r3, #0]
 80026ec:	687b      	ldr	r3, [r7, #4]
 80026ee:	681b      	ldr	r3, [r3, #0]
 80026f0:	f022 0216 	bic.w	r2, r2, #22
 80026f4:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR.reg &= ~(DMA_IT_FE);
 80026f6:	687b      	ldr	r3, [r7, #4]
 80026f8:	681b      	ldr	r3, [r3, #0]
 80026fa:	695a      	ldr	r2, [r3, #20]
 80026fc:	687b      	ldr	r3, [r7, #4]
 80026fe:	681b      	ldr	r3, [r3, #0]
 8002700:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8002704:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8002706:	687b      	ldr	r3, [r7, #4]
 8002708:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800270a:	2b00      	cmp	r3, #0
 800270c:	d103      	bne.n	8002716 <HAL_DMA_IRQHandler+0x1da>
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002712:	2b00      	cmp	r3, #0
 8002714:	d007      	beq.n	8002726 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR.reg  &= ~(DMA_IT_HT);
 8002716:	687b      	ldr	r3, [r7, #4]
 8002718:	681b      	ldr	r3, [r3, #0]
 800271a:	681a      	ldr	r2, [r3, #0]
 800271c:	687b      	ldr	r3, [r7, #4]
 800271e:	681b      	ldr	r3, [r3, #0]
 8002720:	f022 0208 	bic.w	r2, r2, #8
 8002724:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800272a:	223f      	movs	r2, #63	@ 0x3f
 800272c:	409a      	lsls	r2, r3
 800272e:	693b      	ldr	r3, [r7, #16]
 8002730:	609a      	str	r2, [r3, #8]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	2201      	movs	r2, #1
 8002736:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	2200      	movs	r2, #0
 800273e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

        if(hdma->XferAbortCallback != NULL)
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8002746:	2b00      	cmp	r3, #0
 8002748:	d07e      	beq.n	8002848 <HAL_DMA_IRQHandler+0x30c>
        {
          hdma->XferAbortCallback(hdma);
 800274a:	687b      	ldr	r3, [r7, #4]
 800274c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800274e:	6878      	ldr	r0, [r7, #4]
 8002750:	4798      	blx	r3
        }
        return;
 8002752:	e079      	b.n	8002848 <HAL_DMA_IRQHandler+0x30c>
      }

      if(((hdma->Instance->CR.reg) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002754:	687b      	ldr	r3, [r7, #4]
 8002756:	681b      	ldr	r3, [r3, #0]
 8002758:	681b      	ldr	r3, [r3, #0]
 800275a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800275e:	2b00      	cmp	r3, #0
 8002760:	d01d      	beq.n	800279e <HAL_DMA_IRQHandler+0x262>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR.reg & DMA_SxCR_CT) == RESET)
 8002762:	687b      	ldr	r3, [r7, #4]
 8002764:	681b      	ldr	r3, [r3, #0]
 8002766:	681b      	ldr	r3, [r3, #0]
 8002768:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800276c:	2b00      	cmp	r3, #0
 800276e:	d10d      	bne.n	800278c <HAL_DMA_IRQHandler+0x250>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8002770:	687b      	ldr	r3, [r7, #4]
 8002772:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002774:	2b00      	cmp	r3, #0
 8002776:	d031      	beq.n	80027dc <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8002778:	687b      	ldr	r3, [r7, #4]
 800277a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800277c:	6878      	ldr	r0, [r7, #4]
 800277e:	4798      	blx	r3
 8002780:	e02c      	b.n	80027dc <HAL_DMA_IRQHandler+0x2a0>
 8002782:	bf00      	nop
 8002784:	20000000 	.word	0x20000000
 8002788:	1b4e81b5 	.word	0x1b4e81b5
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 800278c:	687b      	ldr	r3, [r7, #4]
 800278e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002790:	2b00      	cmp	r3, #0
 8002792:	d023      	beq.n	80027dc <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8002794:	687b      	ldr	r3, [r7, #4]
 8002796:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002798:	6878      	ldr	r0, [r7, #4]
 800279a:	4798      	blx	r3
 800279c:	e01e      	b.n	80027dc <HAL_DMA_IRQHandler+0x2a0>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR.reg & DMA_SxCR_CIRC) == RESET)
 800279e:	687b      	ldr	r3, [r7, #4]
 80027a0:	681b      	ldr	r3, [r3, #0]
 80027a2:	681b      	ldr	r3, [r3, #0]
 80027a4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80027a8:	2b00      	cmp	r3, #0
 80027aa:	d10f      	bne.n	80027cc <HAL_DMA_IRQHandler+0x290>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR.reg  &= ~(DMA_IT_TC);
 80027ac:	687b      	ldr	r3, [r7, #4]
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	681a      	ldr	r2, [r3, #0]
 80027b2:	687b      	ldr	r3, [r7, #4]
 80027b4:	681b      	ldr	r3, [r3, #0]
 80027b6:	f022 0210 	bic.w	r2, r2, #16
 80027ba:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 80027bc:	687b      	ldr	r3, [r7, #4]
 80027be:	2201      	movs	r2, #1
 80027c0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 80027c4:	687b      	ldr	r3, [r7, #4]
 80027c6:	2200      	movs	r2, #0
 80027c8:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 80027cc:	687b      	ldr	r3, [r7, #4]
 80027ce:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80027d0:	2b00      	cmp	r3, #0
 80027d2:	d003      	beq.n	80027dc <HAL_DMA_IRQHandler+0x2a0>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80027d8:	6878      	ldr	r0, [r7, #4]
 80027da:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 80027dc:	687b      	ldr	r3, [r7, #4]
 80027de:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80027e0:	2b00      	cmp	r3, #0
 80027e2:	d032      	beq.n	800284a <HAL_DMA_IRQHandler+0x30e>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 80027e4:	687b      	ldr	r3, [r7, #4]
 80027e6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80027e8:	f003 0301 	and.w	r3, r3, #1
 80027ec:	2b00      	cmp	r3, #0
 80027ee:	d022      	beq.n	8002836 <HAL_DMA_IRQHandler+0x2fa>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 80027f0:	687b      	ldr	r3, [r7, #4]
 80027f2:	2205      	movs	r2, #5
 80027f4:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 80027f8:	687b      	ldr	r3, [r7, #4]
 80027fa:	681b      	ldr	r3, [r3, #0]
 80027fc:	681a      	ldr	r2, [r3, #0]
 80027fe:	687b      	ldr	r3, [r7, #4]
 8002800:	681b      	ldr	r3, [r3, #0]
 8002802:	f022 0201 	bic.w	r2, r2, #1
 8002806:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 8002808:	68bb      	ldr	r3, [r7, #8]
 800280a:	3301      	adds	r3, #1
 800280c:	60bb      	str	r3, [r7, #8]
 800280e:	697a      	ldr	r2, [r7, #20]
 8002810:	429a      	cmp	r2, r3
 8002812:	d307      	bcc.n	8002824 <HAL_DMA_IRQHandler+0x2e8>
        {
          break;
        }
      }
      while((hdma->Instance->CR.reg & DMA_SxCR_EN) != RESET);
 8002814:	687b      	ldr	r3, [r7, #4]
 8002816:	681b      	ldr	r3, [r3, #0]
 8002818:	681b      	ldr	r3, [r3, #0]
 800281a:	f003 0301 	and.w	r3, r3, #1
 800281e:	2b00      	cmp	r3, #0
 8002820:	d1f2      	bne.n	8002808 <HAL_DMA_IRQHandler+0x2cc>
 8002822:	e000      	b.n	8002826 <HAL_DMA_IRQHandler+0x2ea>
          break;
 8002824:	bf00      	nop

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	2201      	movs	r2, #1
 800282a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800282e:	687b      	ldr	r3, [r7, #4]
 8002830:	2200      	movs	r2, #0
 8002832:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    }

    if(hdma->XferErrorCallback != NULL)
 8002836:	687b      	ldr	r3, [r7, #4]
 8002838:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800283a:	2b00      	cmp	r3, #0
 800283c:	d005      	beq.n	800284a <HAL_DMA_IRQHandler+0x30e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800283e:	687b      	ldr	r3, [r7, #4]
 8002840:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002842:	6878      	ldr	r0, [r7, #4]
 8002844:	4798      	blx	r3
 8002846:	e000      	b.n	800284a <HAL_DMA_IRQHandler+0x30e>
        return;
 8002848:	bf00      	nop
    }
  }
}
 800284a:	3718      	adds	r7, #24
 800284c:	46bd      	mov	sp, r7
 800284e:	bd80      	pop	{r7, pc}

08002850 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8002850:	b480      	push	{r7}
 8002852:	b085      	sub	sp, #20
 8002854:	af00      	add	r7, sp, #0
 8002856:	60f8      	str	r0, [r7, #12]
 8002858:	60b9      	str	r1, [r7, #8]
 800285a:	607a      	str	r2, [r7, #4]
 800285c:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR.reg &= (uint32_t)(~DMA_SxCR_DBM);
 800285e:	68fb      	ldr	r3, [r7, #12]
 8002860:	681b      	ldr	r3, [r3, #0]
 8002862:	681a      	ldr	r2, [r3, #0]
 8002864:	68fb      	ldr	r3, [r7, #12]
 8002866:	681b      	ldr	r3, [r3, #0]
 8002868:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800286c:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR.reg = DataLength;
 800286e:	68fb      	ldr	r3, [r7, #12]
 8002870:	681b      	ldr	r3, [r3, #0]
 8002872:	683a      	ldr	r2, [r7, #0]
 8002874:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8002876:	68fb      	ldr	r3, [r7, #12]
 8002878:	689b      	ldr	r3, [r3, #8]
 800287a:	2b40      	cmp	r3, #64	@ 0x40
 800287c:	d108      	bne.n	8002890 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 800287e:	68fb      	ldr	r3, [r7, #12]
 8002880:	681b      	ldr	r3, [r3, #0]
 8002882:	687a      	ldr	r2, [r7, #4]
 8002884:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8002886:	68fb      	ldr	r3, [r7, #12]
 8002888:	681b      	ldr	r3, [r3, #0]
 800288a:	68ba      	ldr	r2, [r7, #8]
 800288c:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 800288e:	e007      	b.n	80028a0 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 8002890:	68fb      	ldr	r3, [r7, #12]
 8002892:	681b      	ldr	r3, [r3, #0]
 8002894:	68ba      	ldr	r2, [r7, #8]
 8002896:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 8002898:	68fb      	ldr	r3, [r7, #12]
 800289a:	681b      	ldr	r3, [r3, #0]
 800289c:	687a      	ldr	r2, [r7, #4]
 800289e:	60da      	str	r2, [r3, #12]
}
 80028a0:	bf00      	nop
 80028a2:	3714      	adds	r7, #20
 80028a4:	46bd      	mov	sp, r7
 80028a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028aa:	4770      	bx	lr

080028ac <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80028ac:	b480      	push	{r7}
 80028ae:	b085      	sub	sp, #20
 80028b0:	af00      	add	r7, sp, #0
 80028b2:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80028b4:	687b      	ldr	r3, [r7, #4]
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	b2db      	uxtb	r3, r3
 80028ba:	3b10      	subs	r3, #16
 80028bc:	4a14      	ldr	r2, [pc, #80]	@ (8002910 <DMA_CalcBaseAndBitshift+0x64>)
 80028be:	fba2 2303 	umull	r2, r3, r2, r3
 80028c2:	091b      	lsrs	r3, r3, #4
 80028c4:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80028c6:	4a13      	ldr	r2, [pc, #76]	@ (8002914 <DMA_CalcBaseAndBitshift+0x68>)
 80028c8:	68fb      	ldr	r3, [r7, #12]
 80028ca:	4413      	add	r3, r2
 80028cc:	781b      	ldrb	r3, [r3, #0]
 80028ce:	461a      	mov	r2, r3
 80028d0:	687b      	ldr	r3, [r7, #4]
 80028d2:	65da      	str	r2, [r3, #92]	@ 0x5c
  
  if (stream_number > 3U)
 80028d4:	68fb      	ldr	r3, [r7, #12]
 80028d6:	2b03      	cmp	r3, #3
 80028d8:	d909      	bls.n	80028ee <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80028da:	687b      	ldr	r3, [r7, #4]
 80028dc:	681b      	ldr	r3, [r3, #0]
 80028de:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 80028e2:	f023 0303 	bic.w	r3, r3, #3
 80028e6:	1d1a      	adds	r2, r3, #4
 80028e8:	687b      	ldr	r3, [r7, #4]
 80028ea:	659a      	str	r2, [r3, #88]	@ 0x58
 80028ec:	e007      	b.n	80028fe <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	681b      	ldr	r3, [r3, #0]
 80028f2:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 80028f6:	f023 0303 	bic.w	r3, r3, #3
 80028fa:	687a      	ldr	r2, [r7, #4]
 80028fc:	6593      	str	r3, [r2, #88]	@ 0x58
  }
  
  return hdma->StreamBaseAddress;
 80028fe:	687b      	ldr	r3, [r7, #4]
 8002900:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
 8002902:	4618      	mov	r0, r3
 8002904:	3714      	adds	r7, #20
 8002906:	46bd      	mov	sp, r7
 8002908:	f85d 7b04 	ldr.w	r7, [sp], #4
 800290c:	4770      	bx	lr
 800290e:	bf00      	nop
 8002910:	aaaaaaab 	.word	0xaaaaaaab
 8002914:	080315d8 	.word	0x080315d8

08002918 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 8002918:	b480      	push	{r7}
 800291a:	b085      	sub	sp, #20
 800291c:	af00      	add	r7, sp, #0
 800291e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002920:	2300      	movs	r3, #0
 8002922:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 8002924:	687b      	ldr	r3, [r7, #4]
 8002926:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002928:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800292a:	687b      	ldr	r3, [r7, #4]
 800292c:	699b      	ldr	r3, [r3, #24]
 800292e:	2b00      	cmp	r3, #0
 8002930:	d11f      	bne.n	8002972 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 8002932:	68bb      	ldr	r3, [r7, #8]
 8002934:	2b03      	cmp	r3, #3
 8002936:	d856      	bhi.n	80029e6 <DMA_CheckFifoParam+0xce>
 8002938:	a201      	add	r2, pc, #4	@ (adr r2, 8002940 <DMA_CheckFifoParam+0x28>)
 800293a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800293e:	bf00      	nop
 8002940:	08002951 	.word	0x08002951
 8002944:	08002963 	.word	0x08002963
 8002948:	08002951 	.word	0x08002951
 800294c:	080029e7 	.word	0x080029e7
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8002950:	687b      	ldr	r3, [r7, #4]
 8002952:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002954:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8002958:	2b00      	cmp	r3, #0
 800295a:	d046      	beq.n	80029ea <DMA_CheckFifoParam+0xd2>
      {
        status = HAL_ERROR;
 800295c:	2301      	movs	r3, #1
 800295e:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8002960:	e043      	b.n	80029ea <DMA_CheckFifoParam+0xd2>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8002962:	687b      	ldr	r3, [r7, #4]
 8002964:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002966:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 800296a:	d140      	bne.n	80029ee <DMA_CheckFifoParam+0xd6>
      {
        status = HAL_ERROR;
 800296c:	2301      	movs	r3, #1
 800296e:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8002970:	e03d      	b.n	80029ee <DMA_CheckFifoParam+0xd6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8002972:	687b      	ldr	r3, [r7, #4]
 8002974:	699b      	ldr	r3, [r3, #24]
 8002976:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800297a:	d121      	bne.n	80029c0 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 800297c:	68bb      	ldr	r3, [r7, #8]
 800297e:	2b03      	cmp	r3, #3
 8002980:	d837      	bhi.n	80029f2 <DMA_CheckFifoParam+0xda>
 8002982:	a201      	add	r2, pc, #4	@ (adr r2, 8002988 <DMA_CheckFifoParam+0x70>)
 8002984:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002988:	08002999 	.word	0x08002999
 800298c:	0800299f 	.word	0x0800299f
 8002990:	08002999 	.word	0x08002999
 8002994:	080029b1 	.word	0x080029b1
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 8002998:	2301      	movs	r3, #1
 800299a:	73fb      	strb	r3, [r7, #15]
      break;
 800299c:	e030      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800299e:	687b      	ldr	r3, [r7, #4]
 80029a0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029a2:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80029a6:	2b00      	cmp	r3, #0
 80029a8:	d025      	beq.n	80029f6 <DMA_CheckFifoParam+0xde>
      {
        status = HAL_ERROR;
 80029aa:	2301      	movs	r3, #1
 80029ac:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80029ae:	e022      	b.n	80029f6 <DMA_CheckFifoParam+0xde>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80029b0:	687b      	ldr	r3, [r7, #4]
 80029b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029b4:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 80029b8:	d11f      	bne.n	80029fa <DMA_CheckFifoParam+0xe2>
      {
        status = HAL_ERROR;
 80029ba:	2301      	movs	r3, #1
 80029bc:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 80029be:	e01c      	b.n	80029fa <DMA_CheckFifoParam+0xe2>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 80029c0:	68bb      	ldr	r3, [r7, #8]
 80029c2:	2b02      	cmp	r3, #2
 80029c4:	d903      	bls.n	80029ce <DMA_CheckFifoParam+0xb6>
 80029c6:	68bb      	ldr	r3, [r7, #8]
 80029c8:	2b03      	cmp	r3, #3
 80029ca:	d003      	beq.n	80029d4 <DMA_CheckFifoParam+0xbc>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 80029cc:	e018      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      status = HAL_ERROR;
 80029ce:	2301      	movs	r3, #1
 80029d0:	73fb      	strb	r3, [r7, #15]
      break;
 80029d2:	e015      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029d8:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80029dc:	2b00      	cmp	r3, #0
 80029de:	d00e      	beq.n	80029fe <DMA_CheckFifoParam+0xe6>
        status = HAL_ERROR;
 80029e0:	2301      	movs	r3, #1
 80029e2:	73fb      	strb	r3, [r7, #15]
      break;
 80029e4:	e00b      	b.n	80029fe <DMA_CheckFifoParam+0xe6>
      break;
 80029e6:	bf00      	nop
 80029e8:	e00a      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;
 80029ea:	bf00      	nop
 80029ec:	e008      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;
 80029ee:	bf00      	nop
 80029f0:	e006      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;
 80029f2:	bf00      	nop
 80029f4:	e004      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;
 80029f6:	bf00      	nop
 80029f8:	e002      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;   
 80029fa:	bf00      	nop
 80029fc:	e000      	b.n	8002a00 <DMA_CheckFifoParam+0xe8>
      break;
 80029fe:	bf00      	nop
    }
  } 
  
  return status; 
 8002a00:	7bfb      	ldrb	r3, [r7, #15]
}
 8002a02:	4618      	mov	r0, r3
 8002a04:	3714      	adds	r7, #20
 8002a06:	46bd      	mov	sp, r7
 8002a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a0c:	4770      	bx	lr
 8002a0e:	bf00      	nop

08002a10 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
 8002a10:	b580      	push	{r7, lr}
 8002a12:	b086      	sub	sp, #24
 8002a14:	af00      	add	r7, sp, #0
 8002a16:	60f8      	str	r0, [r7, #12]
 8002a18:	60b9      	str	r1, [r7, #8]
 8002a1a:	607a      	str	r2, [r7, #4]
 8002a1c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8002a1e:	2300      	movs	r3, #0
 8002a20:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8002a22:	68fb      	ldr	r3, [r7, #12]
 8002a24:	689b      	ldr	r3, [r3, #8]
 8002a26:	2b80      	cmp	r3, #128	@ 0x80
 8002a28:	d106      	bne.n	8002a38 <HAL_DMAEx_MultiBufferStart_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 8002a2a:	68fb      	ldr	r3, [r7, #12]
 8002a2c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8002a30:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 8002a32:	2301      	movs	r3, #1
 8002a34:	f001 b911 	b.w	8003c5a <HAL_DMAEx_MultiBufferStart_IT+0x124a>
  }
  
  /* Check callback functions */
  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))
 8002a38:	68fb      	ldr	r3, [r7, #12]
 8002a3a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8002a3c:	2b00      	cmp	r3, #0
 8002a3e:	d007      	beq.n	8002a50 <HAL_DMAEx_MultiBufferStart_IT+0x40>
 8002a40:	68fb      	ldr	r3, [r7, #12]
 8002a42:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002a44:	2b00      	cmp	r3, #0
 8002a46:	d003      	beq.n	8002a50 <HAL_DMAEx_MultiBufferStart_IT+0x40>
 8002a48:	68fb      	ldr	r3, [r7, #12]
 8002a4a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002a4c:	2b00      	cmp	r3, #0
 8002a4e:	d105      	bne.n	8002a5c <HAL_DMAEx_MultiBufferStart_IT+0x4c>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002a50:	68fb      	ldr	r3, [r7, #12]
 8002a52:	2240      	movs	r2, #64	@ 0x40
 8002a54:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 8002a56:	2301      	movs	r3, #1
 8002a58:	f001 b8ff 	b.w	8003c5a <HAL_DMAEx_MultiBufferStart_IT+0x124a>
  }
  
  /* Process locked */
  __HAL_LOCK(hdma);
 8002a5c:	68fb      	ldr	r3, [r7, #12]
 8002a5e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8002a62:	2b01      	cmp	r3, #1
 8002a64:	d102      	bne.n	8002a6c <HAL_DMAEx_MultiBufferStart_IT+0x5c>
 8002a66:	2302      	movs	r3, #2
 8002a68:	f001 b8f7 	b.w	8003c5a <HAL_DMAEx_MultiBufferStart_IT+0x124a>
 8002a6c:	68fb      	ldr	r3, [r7, #12]
 8002a6e:	2201      	movs	r2, #1
 8002a70:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8002a74:	68fb      	ldr	r3, [r7, #12]
 8002a76:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8002a7a:	b2db      	uxtb	r3, r3
 8002a7c:	2b01      	cmp	r3, #1
 8002a7e:	f041 80e5 	bne.w	8003c4c <HAL_DMAEx_MultiBufferStart_IT+0x123c>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8002a82:	68fb      	ldr	r3, [r7, #12]
 8002a84:	2202      	movs	r2, #2
 8002a86:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002a8a:	68fb      	ldr	r3, [r7, #12]
 8002a8c:	2200      	movs	r2, #0
 8002a8e:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Enable the Double buffer mode */
    hdma->Instance->CR.reg |= (uint32_t)DMA_SxCR_DBM;
 8002a90:	68fb      	ldr	r3, [r7, #12]
 8002a92:	681b      	ldr	r3, [r3, #0]
 8002a94:	681a      	ldr	r2, [r3, #0]
 8002a96:	68fb      	ldr	r3, [r7, #12]
 8002a98:	681b      	ldr	r3, [r3, #0]
 8002a9a:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8002a9e:	601a      	str	r2, [r3, #0]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M1AR = SecondMemAddress;
 8002aa0:	68fb      	ldr	r3, [r7, #12]
 8002aa2:	681b      	ldr	r3, [r3, #0]
 8002aa4:	683a      	ldr	r2, [r7, #0]
 8002aa6:	611a      	str	r2, [r3, #16]
    
    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
 8002aa8:	6a3b      	ldr	r3, [r7, #32]
 8002aaa:	687a      	ldr	r2, [r7, #4]
 8002aac:	68b9      	ldr	r1, [r7, #8]
 8002aae:	68f8      	ldr	r0, [r7, #12]
 8002ab0:	f001 f910 	bl	8003cd4 <DMA_MultiBufferSetConfig>
    
    /* Clear all flags */
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8002ab4:	68fb      	ldr	r3, [r7, #12]
 8002ab6:	681b      	ldr	r3, [r3, #0]
 8002ab8:	461a      	mov	r2, r3
 8002aba:	4b8d      	ldr	r3, [pc, #564]	@ (8002cf0 <HAL_DMAEx_MultiBufferStart_IT+0x2e0>)
 8002abc:	429a      	cmp	r2, r3
 8002abe:	d960      	bls.n	8002b82 <HAL_DMAEx_MultiBufferStart_IT+0x172>
 8002ac0:	68fb      	ldr	r3, [r7, #12]
 8002ac2:	681b      	ldr	r3, [r3, #0]
 8002ac4:	4a8b      	ldr	r2, [pc, #556]	@ (8002cf4 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002ac6:	4293      	cmp	r3, r2
 8002ac8:	d057      	beq.n	8002b7a <HAL_DMAEx_MultiBufferStart_IT+0x16a>
 8002aca:	68fb      	ldr	r3, [r7, #12]
 8002acc:	681b      	ldr	r3, [r3, #0]
 8002ace:	4a8a      	ldr	r2, [pc, #552]	@ (8002cf8 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002ad0:	4293      	cmp	r3, r2
 8002ad2:	d050      	beq.n	8002b76 <HAL_DMAEx_MultiBufferStart_IT+0x166>
 8002ad4:	68fb      	ldr	r3, [r7, #12]
 8002ad6:	681b      	ldr	r3, [r3, #0]
 8002ad8:	4a88      	ldr	r2, [pc, #544]	@ (8002cfc <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002ada:	4293      	cmp	r3, r2
 8002adc:	d049      	beq.n	8002b72 <HAL_DMAEx_MultiBufferStart_IT+0x162>
 8002ade:	68fb      	ldr	r3, [r7, #12]
 8002ae0:	681b      	ldr	r3, [r3, #0]
 8002ae2:	4a87      	ldr	r2, [pc, #540]	@ (8002d00 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002ae4:	4293      	cmp	r3, r2
 8002ae6:	d042      	beq.n	8002b6e <HAL_DMAEx_MultiBufferStart_IT+0x15e>
 8002ae8:	68fb      	ldr	r3, [r7, #12]
 8002aea:	681b      	ldr	r3, [r3, #0]
 8002aec:	4a85      	ldr	r2, [pc, #532]	@ (8002d04 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002aee:	4293      	cmp	r3, r2
 8002af0:	d03a      	beq.n	8002b68 <HAL_DMAEx_MultiBufferStart_IT+0x158>
 8002af2:	68fb      	ldr	r3, [r7, #12]
 8002af4:	681b      	ldr	r3, [r3, #0]
 8002af6:	4a84      	ldr	r2, [pc, #528]	@ (8002d08 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002af8:	4293      	cmp	r3, r2
 8002afa:	d032      	beq.n	8002b62 <HAL_DMAEx_MultiBufferStart_IT+0x152>
 8002afc:	68fb      	ldr	r3, [r7, #12]
 8002afe:	681b      	ldr	r3, [r3, #0]
 8002b00:	4a82      	ldr	r2, [pc, #520]	@ (8002d0c <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002b02:	4293      	cmp	r3, r2
 8002b04:	d02a      	beq.n	8002b5c <HAL_DMAEx_MultiBufferStart_IT+0x14c>
 8002b06:	68fb      	ldr	r3, [r7, #12]
 8002b08:	681b      	ldr	r3, [r3, #0]
 8002b0a:	4a81      	ldr	r2, [pc, #516]	@ (8002d10 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002b0c:	4293      	cmp	r3, r2
 8002b0e:	d022      	beq.n	8002b56 <HAL_DMAEx_MultiBufferStart_IT+0x146>
 8002b10:	68fb      	ldr	r3, [r7, #12]
 8002b12:	681b      	ldr	r3, [r3, #0]
 8002b14:	4a7f      	ldr	r2, [pc, #508]	@ (8002d14 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002b16:	4293      	cmp	r3, r2
 8002b18:	d01a      	beq.n	8002b50 <HAL_DMAEx_MultiBufferStart_IT+0x140>
 8002b1a:	68fb      	ldr	r3, [r7, #12]
 8002b1c:	681b      	ldr	r3, [r3, #0]
 8002b1e:	4a7e      	ldr	r2, [pc, #504]	@ (8002d18 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002b20:	4293      	cmp	r3, r2
 8002b22:	d012      	beq.n	8002b4a <HAL_DMAEx_MultiBufferStart_IT+0x13a>
 8002b24:	68fb      	ldr	r3, [r7, #12]
 8002b26:	681b      	ldr	r3, [r3, #0]
 8002b28:	4a7c      	ldr	r2, [pc, #496]	@ (8002d1c <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002b2a:	4293      	cmp	r3, r2
 8002b2c:	d00a      	beq.n	8002b44 <HAL_DMAEx_MultiBufferStart_IT+0x134>
 8002b2e:	68fb      	ldr	r3, [r7, #12]
 8002b30:	681b      	ldr	r3, [r3, #0]
 8002b32:	4a7b      	ldr	r2, [pc, #492]	@ (8002d20 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002b34:	4293      	cmp	r3, r2
 8002b36:	d102      	bne.n	8002b3e <HAL_DMAEx_MultiBufferStart_IT+0x12e>
 8002b38:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002b3c:	e01e      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b3e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002b42:	e01b      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b44:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002b48:	e018      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b4a:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002b4e:	e015      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b50:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002b54:	e012      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b56:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002b5a:	e00f      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b5c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002b60:	e00c      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b62:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002b66:	e009      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b68:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002b6c:	e006      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b6e:	2320      	movs	r3, #32
 8002b70:	e004      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b72:	2320      	movs	r3, #32
 8002b74:	e002      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b76:	2320      	movs	r3, #32
 8002b78:	e000      	b.n	8002b7c <HAL_DMAEx_MultiBufferStart_IT+0x16c>
 8002b7a:	2320      	movs	r3, #32
 8002b7c:	4a69      	ldr	r2, [pc, #420]	@ (8002d24 <HAL_DMAEx_MultiBufferStart_IT+0x314>)
 8002b7e:	60d3      	str	r3, [r2, #12]
 8002b80:	e14f      	b.n	8002e22 <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002b82:	68fb      	ldr	r3, [r7, #12]
 8002b84:	681b      	ldr	r3, [r3, #0]
 8002b86:	461a      	mov	r2, r3
 8002b88:	4b67      	ldr	r3, [pc, #412]	@ (8002d28 <HAL_DMAEx_MultiBufferStart_IT+0x318>)
 8002b8a:	429a      	cmp	r2, r3
 8002b8c:	d960      	bls.n	8002c50 <HAL_DMAEx_MultiBufferStart_IT+0x240>
 8002b8e:	68fb      	ldr	r3, [r7, #12]
 8002b90:	681b      	ldr	r3, [r3, #0]
 8002b92:	4a58      	ldr	r2, [pc, #352]	@ (8002cf4 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002b94:	4293      	cmp	r3, r2
 8002b96:	d057      	beq.n	8002c48 <HAL_DMAEx_MultiBufferStart_IT+0x238>
 8002b98:	68fb      	ldr	r3, [r7, #12]
 8002b9a:	681b      	ldr	r3, [r3, #0]
 8002b9c:	4a56      	ldr	r2, [pc, #344]	@ (8002cf8 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002b9e:	4293      	cmp	r3, r2
 8002ba0:	d050      	beq.n	8002c44 <HAL_DMAEx_MultiBufferStart_IT+0x234>
 8002ba2:	68fb      	ldr	r3, [r7, #12]
 8002ba4:	681b      	ldr	r3, [r3, #0]
 8002ba6:	4a55      	ldr	r2, [pc, #340]	@ (8002cfc <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002ba8:	4293      	cmp	r3, r2
 8002baa:	d049      	beq.n	8002c40 <HAL_DMAEx_MultiBufferStart_IT+0x230>
 8002bac:	68fb      	ldr	r3, [r7, #12]
 8002bae:	681b      	ldr	r3, [r3, #0]
 8002bb0:	4a53      	ldr	r2, [pc, #332]	@ (8002d00 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002bb2:	4293      	cmp	r3, r2
 8002bb4:	d042      	beq.n	8002c3c <HAL_DMAEx_MultiBufferStart_IT+0x22c>
 8002bb6:	68fb      	ldr	r3, [r7, #12]
 8002bb8:	681b      	ldr	r3, [r3, #0]
 8002bba:	4a52      	ldr	r2, [pc, #328]	@ (8002d04 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002bbc:	4293      	cmp	r3, r2
 8002bbe:	d03a      	beq.n	8002c36 <HAL_DMAEx_MultiBufferStart_IT+0x226>
 8002bc0:	68fb      	ldr	r3, [r7, #12]
 8002bc2:	681b      	ldr	r3, [r3, #0]
 8002bc4:	4a50      	ldr	r2, [pc, #320]	@ (8002d08 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002bc6:	4293      	cmp	r3, r2
 8002bc8:	d032      	beq.n	8002c30 <HAL_DMAEx_MultiBufferStart_IT+0x220>
 8002bca:	68fb      	ldr	r3, [r7, #12]
 8002bcc:	681b      	ldr	r3, [r3, #0]
 8002bce:	4a4f      	ldr	r2, [pc, #316]	@ (8002d0c <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002bd0:	4293      	cmp	r3, r2
 8002bd2:	d02a      	beq.n	8002c2a <HAL_DMAEx_MultiBufferStart_IT+0x21a>
 8002bd4:	68fb      	ldr	r3, [r7, #12]
 8002bd6:	681b      	ldr	r3, [r3, #0]
 8002bd8:	4a4d      	ldr	r2, [pc, #308]	@ (8002d10 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002bda:	4293      	cmp	r3, r2
 8002bdc:	d022      	beq.n	8002c24 <HAL_DMAEx_MultiBufferStart_IT+0x214>
 8002bde:	68fb      	ldr	r3, [r7, #12]
 8002be0:	681b      	ldr	r3, [r3, #0]
 8002be2:	4a4c      	ldr	r2, [pc, #304]	@ (8002d14 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002be4:	4293      	cmp	r3, r2
 8002be6:	d01a      	beq.n	8002c1e <HAL_DMAEx_MultiBufferStart_IT+0x20e>
 8002be8:	68fb      	ldr	r3, [r7, #12]
 8002bea:	681b      	ldr	r3, [r3, #0]
 8002bec:	4a4a      	ldr	r2, [pc, #296]	@ (8002d18 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002bee:	4293      	cmp	r3, r2
 8002bf0:	d012      	beq.n	8002c18 <HAL_DMAEx_MultiBufferStart_IT+0x208>
 8002bf2:	68fb      	ldr	r3, [r7, #12]
 8002bf4:	681b      	ldr	r3, [r3, #0]
 8002bf6:	4a49      	ldr	r2, [pc, #292]	@ (8002d1c <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002bf8:	4293      	cmp	r3, r2
 8002bfa:	d00a      	beq.n	8002c12 <HAL_DMAEx_MultiBufferStart_IT+0x202>
 8002bfc:	68fb      	ldr	r3, [r7, #12]
 8002bfe:	681b      	ldr	r3, [r3, #0]
 8002c00:	4a47      	ldr	r2, [pc, #284]	@ (8002d20 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002c02:	4293      	cmp	r3, r2
 8002c04:	d102      	bne.n	8002c0c <HAL_DMAEx_MultiBufferStart_IT+0x1fc>
 8002c06:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002c0a:	e01e      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c0c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002c10:	e01b      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c12:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002c16:	e018      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c18:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002c1c:	e015      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c1e:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002c22:	e012      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c24:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002c28:	e00f      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c2a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002c2e:	e00c      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c30:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002c34:	e009      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c36:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002c3a:	e006      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c3c:	2320      	movs	r3, #32
 8002c3e:	e004      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c40:	2320      	movs	r3, #32
 8002c42:	e002      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c44:	2320      	movs	r3, #32
 8002c46:	e000      	b.n	8002c4a <HAL_DMAEx_MultiBufferStart_IT+0x23a>
 8002c48:	2320      	movs	r3, #32
 8002c4a:	4a36      	ldr	r2, [pc, #216]	@ (8002d24 <HAL_DMAEx_MultiBufferStart_IT+0x314>)
 8002c4c:	6093      	str	r3, [r2, #8]
 8002c4e:	e0e8      	b.n	8002e22 <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002c50:	68fb      	ldr	r3, [r7, #12]
 8002c52:	681b      	ldr	r3, [r3, #0]
 8002c54:	461a      	mov	r2, r3
 8002c56:	4b35      	ldr	r3, [pc, #212]	@ (8002d2c <HAL_DMAEx_MultiBufferStart_IT+0x31c>)
 8002c58:	429a      	cmp	r2, r3
 8002c5a:	f240 8082 	bls.w	8002d62 <HAL_DMAEx_MultiBufferStart_IT+0x352>
 8002c5e:	68fb      	ldr	r3, [r7, #12]
 8002c60:	681b      	ldr	r3, [r3, #0]
 8002c62:	4a24      	ldr	r2, [pc, #144]	@ (8002cf4 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>)
 8002c64:	4293      	cmp	r3, r2
 8002c66:	d078      	beq.n	8002d5a <HAL_DMAEx_MultiBufferStart_IT+0x34a>
 8002c68:	68fb      	ldr	r3, [r7, #12]
 8002c6a:	681b      	ldr	r3, [r3, #0]
 8002c6c:	4a22      	ldr	r2, [pc, #136]	@ (8002cf8 <HAL_DMAEx_MultiBufferStart_IT+0x2e8>)
 8002c6e:	4293      	cmp	r3, r2
 8002c70:	d071      	beq.n	8002d56 <HAL_DMAEx_MultiBufferStart_IT+0x346>
 8002c72:	68fb      	ldr	r3, [r7, #12]
 8002c74:	681b      	ldr	r3, [r3, #0]
 8002c76:	4a21      	ldr	r2, [pc, #132]	@ (8002cfc <HAL_DMAEx_MultiBufferStart_IT+0x2ec>)
 8002c78:	4293      	cmp	r3, r2
 8002c7a:	d06a      	beq.n	8002d52 <HAL_DMAEx_MultiBufferStart_IT+0x342>
 8002c7c:	68fb      	ldr	r3, [r7, #12]
 8002c7e:	681b      	ldr	r3, [r3, #0]
 8002c80:	4a1f      	ldr	r2, [pc, #124]	@ (8002d00 <HAL_DMAEx_MultiBufferStart_IT+0x2f0>)
 8002c82:	4293      	cmp	r3, r2
 8002c84:	d063      	beq.n	8002d4e <HAL_DMAEx_MultiBufferStart_IT+0x33e>
 8002c86:	68fb      	ldr	r3, [r7, #12]
 8002c88:	681b      	ldr	r3, [r3, #0]
 8002c8a:	4a1e      	ldr	r2, [pc, #120]	@ (8002d04 <HAL_DMAEx_MultiBufferStart_IT+0x2f4>)
 8002c8c:	4293      	cmp	r3, r2
 8002c8e:	d05b      	beq.n	8002d48 <HAL_DMAEx_MultiBufferStart_IT+0x338>
 8002c90:	68fb      	ldr	r3, [r7, #12]
 8002c92:	681b      	ldr	r3, [r3, #0]
 8002c94:	4a1c      	ldr	r2, [pc, #112]	@ (8002d08 <HAL_DMAEx_MultiBufferStart_IT+0x2f8>)
 8002c96:	4293      	cmp	r3, r2
 8002c98:	d053      	beq.n	8002d42 <HAL_DMAEx_MultiBufferStart_IT+0x332>
 8002c9a:	68fb      	ldr	r3, [r7, #12]
 8002c9c:	681b      	ldr	r3, [r3, #0]
 8002c9e:	4a1b      	ldr	r2, [pc, #108]	@ (8002d0c <HAL_DMAEx_MultiBufferStart_IT+0x2fc>)
 8002ca0:	4293      	cmp	r3, r2
 8002ca2:	d04b      	beq.n	8002d3c <HAL_DMAEx_MultiBufferStart_IT+0x32c>
 8002ca4:	68fb      	ldr	r3, [r7, #12]
 8002ca6:	681b      	ldr	r3, [r3, #0]
 8002ca8:	4a19      	ldr	r2, [pc, #100]	@ (8002d10 <HAL_DMAEx_MultiBufferStart_IT+0x300>)
 8002caa:	4293      	cmp	r3, r2
 8002cac:	d043      	beq.n	8002d36 <HAL_DMAEx_MultiBufferStart_IT+0x326>
 8002cae:	68fb      	ldr	r3, [r7, #12]
 8002cb0:	681b      	ldr	r3, [r3, #0]
 8002cb2:	4a18      	ldr	r2, [pc, #96]	@ (8002d14 <HAL_DMAEx_MultiBufferStart_IT+0x304>)
 8002cb4:	4293      	cmp	r3, r2
 8002cb6:	d03b      	beq.n	8002d30 <HAL_DMAEx_MultiBufferStart_IT+0x320>
 8002cb8:	68fb      	ldr	r3, [r7, #12]
 8002cba:	681b      	ldr	r3, [r3, #0]
 8002cbc:	4a16      	ldr	r2, [pc, #88]	@ (8002d18 <HAL_DMAEx_MultiBufferStart_IT+0x308>)
 8002cbe:	4293      	cmp	r3, r2
 8002cc0:	d012      	beq.n	8002ce8 <HAL_DMAEx_MultiBufferStart_IT+0x2d8>
 8002cc2:	68fb      	ldr	r3, [r7, #12]
 8002cc4:	681b      	ldr	r3, [r3, #0]
 8002cc6:	4a15      	ldr	r2, [pc, #84]	@ (8002d1c <HAL_DMAEx_MultiBufferStart_IT+0x30c>)
 8002cc8:	4293      	cmp	r3, r2
 8002cca:	d00a      	beq.n	8002ce2 <HAL_DMAEx_MultiBufferStart_IT+0x2d2>
 8002ccc:	68fb      	ldr	r3, [r7, #12]
 8002cce:	681b      	ldr	r3, [r3, #0]
 8002cd0:	4a13      	ldr	r2, [pc, #76]	@ (8002d20 <HAL_DMAEx_MultiBufferStart_IT+0x310>)
 8002cd2:	4293      	cmp	r3, r2
 8002cd4:	d102      	bne.n	8002cdc <HAL_DMAEx_MultiBufferStart_IT+0x2cc>
 8002cd6:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002cda:	e03f      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002cdc:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002ce0:	e03c      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002ce2:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002ce6:	e039      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002ce8:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002cec:	e036      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002cee:	bf00      	nop
 8002cf0:	40026458 	.word	0x40026458
 8002cf4:	40026010 	.word	0x40026010
 8002cf8:	40026410 	.word	0x40026410
 8002cfc:	40026070 	.word	0x40026070
 8002d00:	40026470 	.word	0x40026470
 8002d04:	40026028 	.word	0x40026028
 8002d08:	40026428 	.word	0x40026428
 8002d0c:	40026088 	.word	0x40026088
 8002d10:	40026488 	.word	0x40026488
 8002d14:	40026040 	.word	0x40026040
 8002d18:	40026440 	.word	0x40026440
 8002d1c:	400260a0 	.word	0x400260a0
 8002d20:	400264a0 	.word	0x400264a0
 8002d24:	40026400 	.word	0x40026400
 8002d28:	400260b8 	.word	0x400260b8
 8002d2c:	40026058 	.word	0x40026058
 8002d30:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002d34:	e012      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d36:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d3a:	e00f      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d3c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d40:	e00c      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d42:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d46:	e009      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d48:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002d4c:	e006      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d4e:	2320      	movs	r3, #32
 8002d50:	e004      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d52:	2320      	movs	r3, #32
 8002d54:	e002      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d56:	2320      	movs	r3, #32
 8002d58:	e000      	b.n	8002d5c <HAL_DMAEx_MultiBufferStart_IT+0x34c>
 8002d5a:	2320      	movs	r3, #32
 8002d5c:	4a8c      	ldr	r2, [pc, #560]	@ (8002f90 <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8002d5e:	60d3      	str	r3, [r2, #12]
 8002d60:	e05f      	b.n	8002e22 <HAL_DMAEx_MultiBufferStart_IT+0x412>
 8002d62:	68fb      	ldr	r3, [r7, #12]
 8002d64:	681b      	ldr	r3, [r3, #0]
 8002d66:	4a8b      	ldr	r2, [pc, #556]	@ (8002f94 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8002d68:	4293      	cmp	r3, r2
 8002d6a:	d057      	beq.n	8002e1c <HAL_DMAEx_MultiBufferStart_IT+0x40c>
 8002d6c:	68fb      	ldr	r3, [r7, #12]
 8002d6e:	681b      	ldr	r3, [r3, #0]
 8002d70:	4a89      	ldr	r2, [pc, #548]	@ (8002f98 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8002d72:	4293      	cmp	r3, r2
 8002d74:	d050      	beq.n	8002e18 <HAL_DMAEx_MultiBufferStart_IT+0x408>
 8002d76:	68fb      	ldr	r3, [r7, #12]
 8002d78:	681b      	ldr	r3, [r3, #0]
 8002d7a:	4a88      	ldr	r2, [pc, #544]	@ (8002f9c <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8002d7c:	4293      	cmp	r3, r2
 8002d7e:	d049      	beq.n	8002e14 <HAL_DMAEx_MultiBufferStart_IT+0x404>
 8002d80:	68fb      	ldr	r3, [r7, #12]
 8002d82:	681b      	ldr	r3, [r3, #0]
 8002d84:	4a86      	ldr	r2, [pc, #536]	@ (8002fa0 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 8002d86:	4293      	cmp	r3, r2
 8002d88:	d042      	beq.n	8002e10 <HAL_DMAEx_MultiBufferStart_IT+0x400>
 8002d8a:	68fb      	ldr	r3, [r7, #12]
 8002d8c:	681b      	ldr	r3, [r3, #0]
 8002d8e:	4a85      	ldr	r2, [pc, #532]	@ (8002fa4 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8002d90:	4293      	cmp	r3, r2
 8002d92:	d03a      	beq.n	8002e0a <HAL_DMAEx_MultiBufferStart_IT+0x3fa>
 8002d94:	68fb      	ldr	r3, [r7, #12]
 8002d96:	681b      	ldr	r3, [r3, #0]
 8002d98:	4a83      	ldr	r2, [pc, #524]	@ (8002fa8 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8002d9a:	4293      	cmp	r3, r2
 8002d9c:	d032      	beq.n	8002e04 <HAL_DMAEx_MultiBufferStart_IT+0x3f4>
 8002d9e:	68fb      	ldr	r3, [r7, #12]
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	4a82      	ldr	r2, [pc, #520]	@ (8002fac <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8002da4:	4293      	cmp	r3, r2
 8002da6:	d02a      	beq.n	8002dfe <HAL_DMAEx_MultiBufferStart_IT+0x3ee>
 8002da8:	68fb      	ldr	r3, [r7, #12]
 8002daa:	681b      	ldr	r3, [r3, #0]
 8002dac:	4a80      	ldr	r2, [pc, #512]	@ (8002fb0 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8002dae:	4293      	cmp	r3, r2
 8002db0:	d022      	beq.n	8002df8 <HAL_DMAEx_MultiBufferStart_IT+0x3e8>
 8002db2:	68fb      	ldr	r3, [r7, #12]
 8002db4:	681b      	ldr	r3, [r3, #0]
 8002db6:	4a7f      	ldr	r2, [pc, #508]	@ (8002fb4 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8002db8:	4293      	cmp	r3, r2
 8002dba:	d01a      	beq.n	8002df2 <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
 8002dbc:	68fb      	ldr	r3, [r7, #12]
 8002dbe:	681b      	ldr	r3, [r3, #0]
 8002dc0:	4a7d      	ldr	r2, [pc, #500]	@ (8002fb8 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 8002dc2:	4293      	cmp	r3, r2
 8002dc4:	d012      	beq.n	8002dec <HAL_DMAEx_MultiBufferStart_IT+0x3dc>
 8002dc6:	68fb      	ldr	r3, [r7, #12]
 8002dc8:	681b      	ldr	r3, [r3, #0]
 8002dca:	4a7c      	ldr	r2, [pc, #496]	@ (8002fbc <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8002dcc:	4293      	cmp	r3, r2
 8002dce:	d00a      	beq.n	8002de6 <HAL_DMAEx_MultiBufferStart_IT+0x3d6>
 8002dd0:	68fb      	ldr	r3, [r7, #12]
 8002dd2:	681b      	ldr	r3, [r3, #0]
 8002dd4:	4a7a      	ldr	r2, [pc, #488]	@ (8002fc0 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 8002dd6:	4293      	cmp	r3, r2
 8002dd8:	d102      	bne.n	8002de0 <HAL_DMAEx_MultiBufferStart_IT+0x3d0>
 8002dda:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dde:	e01e      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002de0:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8002de4:	e01b      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002de6:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002dea:	e018      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002dec:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002df0:	e015      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002df2:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002df6:	e012      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002df8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002dfc:	e00f      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002dfe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002e02:	e00c      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e04:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002e08:	e009      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e0a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002e0e:	e006      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e10:	2320      	movs	r3, #32
 8002e12:	e004      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e14:	2320      	movs	r3, #32
 8002e16:	e002      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e18:	2320      	movs	r3, #32
 8002e1a:	e000      	b.n	8002e1e <HAL_DMAEx_MultiBufferStart_IT+0x40e>
 8002e1c:	2320      	movs	r3, #32
 8002e1e:	4a5c      	ldr	r2, [pc, #368]	@ (8002f90 <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8002e20:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8002e22:	68fb      	ldr	r3, [r7, #12]
 8002e24:	681b      	ldr	r3, [r3, #0]
 8002e26:	461a      	mov	r2, r3
 8002e28:	4b66      	ldr	r3, [pc, #408]	@ (8002fc4 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 8002e2a:	429a      	cmp	r2, r3
 8002e2c:	d960      	bls.n	8002ef0 <HAL_DMAEx_MultiBufferStart_IT+0x4e0>
 8002e2e:	68fb      	ldr	r3, [r7, #12]
 8002e30:	681b      	ldr	r3, [r3, #0]
 8002e32:	4a58      	ldr	r2, [pc, #352]	@ (8002f94 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8002e34:	4293      	cmp	r3, r2
 8002e36:	d057      	beq.n	8002ee8 <HAL_DMAEx_MultiBufferStart_IT+0x4d8>
 8002e38:	68fb      	ldr	r3, [r7, #12]
 8002e3a:	681b      	ldr	r3, [r3, #0]
 8002e3c:	4a56      	ldr	r2, [pc, #344]	@ (8002f98 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8002e3e:	4293      	cmp	r3, r2
 8002e40:	d050      	beq.n	8002ee4 <HAL_DMAEx_MultiBufferStart_IT+0x4d4>
 8002e42:	68fb      	ldr	r3, [r7, #12]
 8002e44:	681b      	ldr	r3, [r3, #0]
 8002e46:	4a55      	ldr	r2, [pc, #340]	@ (8002f9c <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8002e48:	4293      	cmp	r3, r2
 8002e4a:	d049      	beq.n	8002ee0 <HAL_DMAEx_MultiBufferStart_IT+0x4d0>
 8002e4c:	68fb      	ldr	r3, [r7, #12]
 8002e4e:	681b      	ldr	r3, [r3, #0]
 8002e50:	4a53      	ldr	r2, [pc, #332]	@ (8002fa0 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 8002e52:	4293      	cmp	r3, r2
 8002e54:	d042      	beq.n	8002edc <HAL_DMAEx_MultiBufferStart_IT+0x4cc>
 8002e56:	68fb      	ldr	r3, [r7, #12]
 8002e58:	681b      	ldr	r3, [r3, #0]
 8002e5a:	4a52      	ldr	r2, [pc, #328]	@ (8002fa4 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8002e5c:	4293      	cmp	r3, r2
 8002e5e:	d03a      	beq.n	8002ed6 <HAL_DMAEx_MultiBufferStart_IT+0x4c6>
 8002e60:	68fb      	ldr	r3, [r7, #12]
 8002e62:	681b      	ldr	r3, [r3, #0]
 8002e64:	4a50      	ldr	r2, [pc, #320]	@ (8002fa8 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8002e66:	4293      	cmp	r3, r2
 8002e68:	d032      	beq.n	8002ed0 <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 8002e6a:	68fb      	ldr	r3, [r7, #12]
 8002e6c:	681b      	ldr	r3, [r3, #0]
 8002e6e:	4a4f      	ldr	r2, [pc, #316]	@ (8002fac <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8002e70:	4293      	cmp	r3, r2
 8002e72:	d02a      	beq.n	8002eca <HAL_DMAEx_MultiBufferStart_IT+0x4ba>
 8002e74:	68fb      	ldr	r3, [r7, #12]
 8002e76:	681b      	ldr	r3, [r3, #0]
 8002e78:	4a4d      	ldr	r2, [pc, #308]	@ (8002fb0 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8002e7a:	4293      	cmp	r3, r2
 8002e7c:	d022      	beq.n	8002ec4 <HAL_DMAEx_MultiBufferStart_IT+0x4b4>
 8002e7e:	68fb      	ldr	r3, [r7, #12]
 8002e80:	681b      	ldr	r3, [r3, #0]
 8002e82:	4a4c      	ldr	r2, [pc, #304]	@ (8002fb4 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8002e84:	4293      	cmp	r3, r2
 8002e86:	d01a      	beq.n	8002ebe <HAL_DMAEx_MultiBufferStart_IT+0x4ae>
 8002e88:	68fb      	ldr	r3, [r7, #12]
 8002e8a:	681b      	ldr	r3, [r3, #0]
 8002e8c:	4a4a      	ldr	r2, [pc, #296]	@ (8002fb8 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 8002e8e:	4293      	cmp	r3, r2
 8002e90:	d012      	beq.n	8002eb8 <HAL_DMAEx_MultiBufferStart_IT+0x4a8>
 8002e92:	68fb      	ldr	r3, [r7, #12]
 8002e94:	681b      	ldr	r3, [r3, #0]
 8002e96:	4a49      	ldr	r2, [pc, #292]	@ (8002fbc <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8002e98:	4293      	cmp	r3, r2
 8002e9a:	d00a      	beq.n	8002eb2 <HAL_DMAEx_MultiBufferStart_IT+0x4a2>
 8002e9c:	68fb      	ldr	r3, [r7, #12]
 8002e9e:	681b      	ldr	r3, [r3, #0]
 8002ea0:	4a47      	ldr	r2, [pc, #284]	@ (8002fc0 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 8002ea2:	4293      	cmp	r3, r2
 8002ea4:	d102      	bne.n	8002eac <HAL_DMAEx_MultiBufferStart_IT+0x49c>
 8002ea6:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002eaa:	e01e      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002eac:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8002eb0:	e01b      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002eb2:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002eb6:	e018      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002eb8:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002ebc:	e015      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ebe:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002ec2:	e012      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ec4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002ec8:	e00f      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002eca:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002ece:	e00c      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ed0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002ed4:	e009      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ed6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002eda:	e006      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002edc:	2310      	movs	r3, #16
 8002ede:	e004      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ee0:	2310      	movs	r3, #16
 8002ee2:	e002      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ee4:	2310      	movs	r3, #16
 8002ee6:	e000      	b.n	8002eea <HAL_DMAEx_MultiBufferStart_IT+0x4da>
 8002ee8:	2310      	movs	r3, #16
 8002eea:	4a37      	ldr	r2, [pc, #220]	@ (8002fc8 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>)
 8002eec:	60d3      	str	r3, [r2, #12]
 8002eee:	e14f      	b.n	8003190 <HAL_DMAEx_MultiBufferStart_IT+0x780>
 8002ef0:	68fb      	ldr	r3, [r7, #12]
 8002ef2:	681b      	ldr	r3, [r3, #0]
 8002ef4:	461a      	mov	r2, r3
 8002ef6:	4b35      	ldr	r3, [pc, #212]	@ (8002fcc <HAL_DMAEx_MultiBufferStart_IT+0x5bc>)
 8002ef8:	429a      	cmp	r2, r3
 8002efa:	f240 8082 	bls.w	8003002 <HAL_DMAEx_MultiBufferStart_IT+0x5f2>
 8002efe:	68fb      	ldr	r3, [r7, #12]
 8002f00:	681b      	ldr	r3, [r3, #0]
 8002f02:	4a24      	ldr	r2, [pc, #144]	@ (8002f94 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8002f04:	4293      	cmp	r3, r2
 8002f06:	d078      	beq.n	8002ffa <HAL_DMAEx_MultiBufferStart_IT+0x5ea>
 8002f08:	68fb      	ldr	r3, [r7, #12]
 8002f0a:	681b      	ldr	r3, [r3, #0]
 8002f0c:	4a22      	ldr	r2, [pc, #136]	@ (8002f98 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8002f0e:	4293      	cmp	r3, r2
 8002f10:	d071      	beq.n	8002ff6 <HAL_DMAEx_MultiBufferStart_IT+0x5e6>
 8002f12:	68fb      	ldr	r3, [r7, #12]
 8002f14:	681b      	ldr	r3, [r3, #0]
 8002f16:	4a21      	ldr	r2, [pc, #132]	@ (8002f9c <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8002f18:	4293      	cmp	r3, r2
 8002f1a:	d06a      	beq.n	8002ff2 <HAL_DMAEx_MultiBufferStart_IT+0x5e2>
 8002f1c:	68fb      	ldr	r3, [r7, #12]
 8002f1e:	681b      	ldr	r3, [r3, #0]
 8002f20:	4a1f      	ldr	r2, [pc, #124]	@ (8002fa0 <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 8002f22:	4293      	cmp	r3, r2
 8002f24:	d063      	beq.n	8002fee <HAL_DMAEx_MultiBufferStart_IT+0x5de>
 8002f26:	68fb      	ldr	r3, [r7, #12]
 8002f28:	681b      	ldr	r3, [r3, #0]
 8002f2a:	4a1e      	ldr	r2, [pc, #120]	@ (8002fa4 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8002f2c:	4293      	cmp	r3, r2
 8002f2e:	d05b      	beq.n	8002fe8 <HAL_DMAEx_MultiBufferStart_IT+0x5d8>
 8002f30:	68fb      	ldr	r3, [r7, #12]
 8002f32:	681b      	ldr	r3, [r3, #0]
 8002f34:	4a1c      	ldr	r2, [pc, #112]	@ (8002fa8 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8002f36:	4293      	cmp	r3, r2
 8002f38:	d053      	beq.n	8002fe2 <HAL_DMAEx_MultiBufferStart_IT+0x5d2>
 8002f3a:	68fb      	ldr	r3, [r7, #12]
 8002f3c:	681b      	ldr	r3, [r3, #0]
 8002f3e:	4a1b      	ldr	r2, [pc, #108]	@ (8002fac <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8002f40:	4293      	cmp	r3, r2
 8002f42:	d04b      	beq.n	8002fdc <HAL_DMAEx_MultiBufferStart_IT+0x5cc>
 8002f44:	68fb      	ldr	r3, [r7, #12]
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	4a19      	ldr	r2, [pc, #100]	@ (8002fb0 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8002f4a:	4293      	cmp	r3, r2
 8002f4c:	d043      	beq.n	8002fd6 <HAL_DMAEx_MultiBufferStart_IT+0x5c6>
 8002f4e:	68fb      	ldr	r3, [r7, #12]
 8002f50:	681b      	ldr	r3, [r3, #0]
 8002f52:	4a18      	ldr	r2, [pc, #96]	@ (8002fb4 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8002f54:	4293      	cmp	r3, r2
 8002f56:	d03b      	beq.n	8002fd0 <HAL_DMAEx_MultiBufferStart_IT+0x5c0>
 8002f58:	68fb      	ldr	r3, [r7, #12]
 8002f5a:	681b      	ldr	r3, [r3, #0]
 8002f5c:	4a16      	ldr	r2, [pc, #88]	@ (8002fb8 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
 8002f5e:	4293      	cmp	r3, r2
 8002f60:	d012      	beq.n	8002f88 <HAL_DMAEx_MultiBufferStart_IT+0x578>
 8002f62:	68fb      	ldr	r3, [r7, #12]
 8002f64:	681b      	ldr	r3, [r3, #0]
 8002f66:	4a15      	ldr	r2, [pc, #84]	@ (8002fbc <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
 8002f68:	4293      	cmp	r3, r2
 8002f6a:	d00a      	beq.n	8002f82 <HAL_DMAEx_MultiBufferStart_IT+0x572>
 8002f6c:	68fb      	ldr	r3, [r7, #12]
 8002f6e:	681b      	ldr	r3, [r3, #0]
 8002f70:	4a13      	ldr	r2, [pc, #76]	@ (8002fc0 <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 8002f72:	4293      	cmp	r3, r2
 8002f74:	d102      	bne.n	8002f7c <HAL_DMAEx_MultiBufferStart_IT+0x56c>
 8002f76:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002f7a:	e03f      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002f7c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8002f80:	e03c      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002f82:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002f86:	e039      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002f88:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002f8c:	e036      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002f8e:	bf00      	nop
 8002f90:	40026000 	.word	0x40026000
 8002f94:	40026010 	.word	0x40026010
 8002f98:	40026410 	.word	0x40026410
 8002f9c:	40026070 	.word	0x40026070
 8002fa0:	40026470 	.word	0x40026470
 8002fa4:	40026028 	.word	0x40026028
 8002fa8:	40026428 	.word	0x40026428
 8002fac:	40026088 	.word	0x40026088
 8002fb0:	40026488 	.word	0x40026488
 8002fb4:	40026040 	.word	0x40026040
 8002fb8:	40026440 	.word	0x40026440
 8002fbc:	400260a0 	.word	0x400260a0
 8002fc0:	400264a0 	.word	0x400264a0
 8002fc4:	40026458 	.word	0x40026458
 8002fc8:	40026400 	.word	0x40026400
 8002fcc:	400260b8 	.word	0x400260b8
 8002fd0:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002fd4:	e012      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002fd6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002fda:	e00f      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002fdc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002fe0:	e00c      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002fe2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002fe6:	e009      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002fe8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8002fec:	e006      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002fee:	2310      	movs	r3, #16
 8002ff0:	e004      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002ff2:	2310      	movs	r3, #16
 8002ff4:	e002      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002ff6:	2310      	movs	r3, #16
 8002ff8:	e000      	b.n	8002ffc <HAL_DMAEx_MultiBufferStart_IT+0x5ec>
 8002ffa:	2310      	movs	r3, #16
 8002ffc:	4a8c      	ldr	r2, [pc, #560]	@ (8003230 <HAL_DMAEx_MultiBufferStart_IT+0x820>)
 8002ffe:	6093      	str	r3, [r2, #8]
 8003000:	e0c6      	b.n	8003190 <HAL_DMAEx_MultiBufferStart_IT+0x780>
 8003002:	68fb      	ldr	r3, [r7, #12]
 8003004:	681b      	ldr	r3, [r3, #0]
 8003006:	461a      	mov	r2, r3
 8003008:	4b8a      	ldr	r3, [pc, #552]	@ (8003234 <HAL_DMAEx_MultiBufferStart_IT+0x824>)
 800300a:	429a      	cmp	r2, r3
 800300c:	d960      	bls.n	80030d0 <HAL_DMAEx_MultiBufferStart_IT+0x6c0>
 800300e:	68fb      	ldr	r3, [r7, #12]
 8003010:	681b      	ldr	r3, [r3, #0]
 8003012:	4a89      	ldr	r2, [pc, #548]	@ (8003238 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 8003014:	4293      	cmp	r3, r2
 8003016:	d057      	beq.n	80030c8 <HAL_DMAEx_MultiBufferStart_IT+0x6b8>
 8003018:	68fb      	ldr	r3, [r7, #12]
 800301a:	681b      	ldr	r3, [r3, #0]
 800301c:	4a87      	ldr	r2, [pc, #540]	@ (800323c <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 800301e:	4293      	cmp	r3, r2
 8003020:	d050      	beq.n	80030c4 <HAL_DMAEx_MultiBufferStart_IT+0x6b4>
 8003022:	68fb      	ldr	r3, [r7, #12]
 8003024:	681b      	ldr	r3, [r3, #0]
 8003026:	4a86      	ldr	r2, [pc, #536]	@ (8003240 <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 8003028:	4293      	cmp	r3, r2
 800302a:	d049      	beq.n	80030c0 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>
 800302c:	68fb      	ldr	r3, [r7, #12]
 800302e:	681b      	ldr	r3, [r3, #0]
 8003030:	4a84      	ldr	r2, [pc, #528]	@ (8003244 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 8003032:	4293      	cmp	r3, r2
 8003034:	d042      	beq.n	80030bc <HAL_DMAEx_MultiBufferStart_IT+0x6ac>
 8003036:	68fb      	ldr	r3, [r7, #12]
 8003038:	681b      	ldr	r3, [r3, #0]
 800303a:	4a83      	ldr	r2, [pc, #524]	@ (8003248 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 800303c:	4293      	cmp	r3, r2
 800303e:	d03a      	beq.n	80030b6 <HAL_DMAEx_MultiBufferStart_IT+0x6a6>
 8003040:	68fb      	ldr	r3, [r7, #12]
 8003042:	681b      	ldr	r3, [r3, #0]
 8003044:	4a81      	ldr	r2, [pc, #516]	@ (800324c <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 8003046:	4293      	cmp	r3, r2
 8003048:	d032      	beq.n	80030b0 <HAL_DMAEx_MultiBufferStart_IT+0x6a0>
 800304a:	68fb      	ldr	r3, [r7, #12]
 800304c:	681b      	ldr	r3, [r3, #0]
 800304e:	4a80      	ldr	r2, [pc, #512]	@ (8003250 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 8003050:	4293      	cmp	r3, r2
 8003052:	d02a      	beq.n	80030aa <HAL_DMAEx_MultiBufferStart_IT+0x69a>
 8003054:	68fb      	ldr	r3, [r7, #12]
 8003056:	681b      	ldr	r3, [r3, #0]
 8003058:	4a7e      	ldr	r2, [pc, #504]	@ (8003254 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 800305a:	4293      	cmp	r3, r2
 800305c:	d022      	beq.n	80030a4 <HAL_DMAEx_MultiBufferStart_IT+0x694>
 800305e:	68fb      	ldr	r3, [r7, #12]
 8003060:	681b      	ldr	r3, [r3, #0]
 8003062:	4a7d      	ldr	r2, [pc, #500]	@ (8003258 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 8003064:	4293      	cmp	r3, r2
 8003066:	d01a      	beq.n	800309e <HAL_DMAEx_MultiBufferStart_IT+0x68e>
 8003068:	68fb      	ldr	r3, [r7, #12]
 800306a:	681b      	ldr	r3, [r3, #0]
 800306c:	4a7b      	ldr	r2, [pc, #492]	@ (800325c <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 800306e:	4293      	cmp	r3, r2
 8003070:	d012      	beq.n	8003098 <HAL_DMAEx_MultiBufferStart_IT+0x688>
 8003072:	68fb      	ldr	r3, [r7, #12]
 8003074:	681b      	ldr	r3, [r3, #0]
 8003076:	4a7a      	ldr	r2, [pc, #488]	@ (8003260 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 8003078:	4293      	cmp	r3, r2
 800307a:	d00a      	beq.n	8003092 <HAL_DMAEx_MultiBufferStart_IT+0x682>
 800307c:	68fb      	ldr	r3, [r7, #12]
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	4a78      	ldr	r2, [pc, #480]	@ (8003264 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 8003082:	4293      	cmp	r3, r2
 8003084:	d102      	bne.n	800308c <HAL_DMAEx_MultiBufferStart_IT+0x67c>
 8003086:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800308a:	e01e      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800308c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8003090:	e01b      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003092:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003096:	e018      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 8003098:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800309c:	e015      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 800309e:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 80030a2:	e012      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030a4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80030a8:	e00f      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030aa:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80030ae:	e00c      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030b0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80030b4:	e009      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030b6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80030ba:	e006      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030bc:	2310      	movs	r3, #16
 80030be:	e004      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030c0:	2310      	movs	r3, #16
 80030c2:	e002      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030c4:	2310      	movs	r3, #16
 80030c6:	e000      	b.n	80030ca <HAL_DMAEx_MultiBufferStart_IT+0x6ba>
 80030c8:	2310      	movs	r3, #16
 80030ca:	4a67      	ldr	r2, [pc, #412]	@ (8003268 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
 80030cc:	60d3      	str	r3, [r2, #12]
 80030ce:	e05f      	b.n	8003190 <HAL_DMAEx_MultiBufferStart_IT+0x780>
 80030d0:	68fb      	ldr	r3, [r7, #12]
 80030d2:	681b      	ldr	r3, [r3, #0]
 80030d4:	4a58      	ldr	r2, [pc, #352]	@ (8003238 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 80030d6:	4293      	cmp	r3, r2
 80030d8:	d057      	beq.n	800318a <HAL_DMAEx_MultiBufferStart_IT+0x77a>
 80030da:	68fb      	ldr	r3, [r7, #12]
 80030dc:	681b      	ldr	r3, [r3, #0]
 80030de:	4a57      	ldr	r2, [pc, #348]	@ (800323c <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 80030e0:	4293      	cmp	r3, r2
 80030e2:	d050      	beq.n	8003186 <HAL_DMAEx_MultiBufferStart_IT+0x776>
 80030e4:	68fb      	ldr	r3, [r7, #12]
 80030e6:	681b      	ldr	r3, [r3, #0]
 80030e8:	4a55      	ldr	r2, [pc, #340]	@ (8003240 <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 80030ea:	4293      	cmp	r3, r2
 80030ec:	d049      	beq.n	8003182 <HAL_DMAEx_MultiBufferStart_IT+0x772>
 80030ee:	68fb      	ldr	r3, [r7, #12]
 80030f0:	681b      	ldr	r3, [r3, #0]
 80030f2:	4a54      	ldr	r2, [pc, #336]	@ (8003244 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 80030f4:	4293      	cmp	r3, r2
 80030f6:	d042      	beq.n	800317e <HAL_DMAEx_MultiBufferStart_IT+0x76e>
 80030f8:	68fb      	ldr	r3, [r7, #12]
 80030fa:	681b      	ldr	r3, [r3, #0]
 80030fc:	4a52      	ldr	r2, [pc, #328]	@ (8003248 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 80030fe:	4293      	cmp	r3, r2
 8003100:	d03a      	beq.n	8003178 <HAL_DMAEx_MultiBufferStart_IT+0x768>
 8003102:	68fb      	ldr	r3, [r7, #12]
 8003104:	681b      	ldr	r3, [r3, #0]
 8003106:	4a51      	ldr	r2, [pc, #324]	@ (800324c <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 8003108:	4293      	cmp	r3, r2
 800310a:	d032      	beq.n	8003172 <HAL_DMAEx_MultiBufferStart_IT+0x762>
 800310c:	68fb      	ldr	r3, [r7, #12]
 800310e:	681b      	ldr	r3, [r3, #0]
 8003110:	4a4f      	ldr	r2, [pc, #316]	@ (8003250 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 8003112:	4293      	cmp	r3, r2
 8003114:	d02a      	beq.n	800316c <HAL_DMAEx_MultiBufferStart_IT+0x75c>
 8003116:	68fb      	ldr	r3, [r7, #12]
 8003118:	681b      	ldr	r3, [r3, #0]
 800311a:	4a4e      	ldr	r2, [pc, #312]	@ (8003254 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 800311c:	4293      	cmp	r3, r2
 800311e:	d022      	beq.n	8003166 <HAL_DMAEx_MultiBufferStart_IT+0x756>
 8003120:	68fb      	ldr	r3, [r7, #12]
 8003122:	681b      	ldr	r3, [r3, #0]
 8003124:	4a4c      	ldr	r2, [pc, #304]	@ (8003258 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 8003126:	4293      	cmp	r3, r2
 8003128:	d01a      	beq.n	8003160 <HAL_DMAEx_MultiBufferStart_IT+0x750>
 800312a:	68fb      	ldr	r3, [r7, #12]
 800312c:	681b      	ldr	r3, [r3, #0]
 800312e:	4a4b      	ldr	r2, [pc, #300]	@ (800325c <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 8003130:	4293      	cmp	r3, r2
 8003132:	d012      	beq.n	800315a <HAL_DMAEx_MultiBufferStart_IT+0x74a>
 8003134:	68fb      	ldr	r3, [r7, #12]
 8003136:	681b      	ldr	r3, [r3, #0]
 8003138:	4a49      	ldr	r2, [pc, #292]	@ (8003260 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 800313a:	4293      	cmp	r3, r2
 800313c:	d00a      	beq.n	8003154 <HAL_DMAEx_MultiBufferStart_IT+0x744>
 800313e:	68fb      	ldr	r3, [r7, #12]
 8003140:	681b      	ldr	r3, [r3, #0]
 8003142:	4a48      	ldr	r2, [pc, #288]	@ (8003264 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 8003144:	4293      	cmp	r3, r2
 8003146:	d102      	bne.n	800314e <HAL_DMAEx_MultiBufferStart_IT+0x73e>
 8003148:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800314c:	e01e      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800314e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8003152:	e01b      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003154:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003158:	e018      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800315a:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 800315e:	e015      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003160:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8003164:	e012      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003166:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800316a:	e00f      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800316c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003170:	e00c      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003172:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8003176:	e009      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003178:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800317c:	e006      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800317e:	2310      	movs	r3, #16
 8003180:	e004      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003182:	2310      	movs	r3, #16
 8003184:	e002      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 8003186:	2310      	movs	r3, #16
 8003188:	e000      	b.n	800318c <HAL_DMAEx_MultiBufferStart_IT+0x77c>
 800318a:	2310      	movs	r3, #16
 800318c:	4a36      	ldr	r2, [pc, #216]	@ (8003268 <HAL_DMAEx_MultiBufferStart_IT+0x858>)
 800318e:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003190:	68fb      	ldr	r3, [r7, #12]
 8003192:	681b      	ldr	r3, [r3, #0]
 8003194:	461a      	mov	r2, r3
 8003196:	4b35      	ldr	r3, [pc, #212]	@ (800326c <HAL_DMAEx_MultiBufferStart_IT+0x85c>)
 8003198:	429a      	cmp	r2, r3
 800319a:	f240 8082 	bls.w	80032a2 <HAL_DMAEx_MultiBufferStart_IT+0x892>
 800319e:	68fb      	ldr	r3, [r7, #12]
 80031a0:	681b      	ldr	r3, [r3, #0]
 80031a2:	4a25      	ldr	r2, [pc, #148]	@ (8003238 <HAL_DMAEx_MultiBufferStart_IT+0x828>)
 80031a4:	4293      	cmp	r3, r2
 80031a6:	d078      	beq.n	800329a <HAL_DMAEx_MultiBufferStart_IT+0x88a>
 80031a8:	68fb      	ldr	r3, [r7, #12]
 80031aa:	681b      	ldr	r3, [r3, #0]
 80031ac:	4a23      	ldr	r2, [pc, #140]	@ (800323c <HAL_DMAEx_MultiBufferStart_IT+0x82c>)
 80031ae:	4293      	cmp	r3, r2
 80031b0:	d071      	beq.n	8003296 <HAL_DMAEx_MultiBufferStart_IT+0x886>
 80031b2:	68fb      	ldr	r3, [r7, #12]
 80031b4:	681b      	ldr	r3, [r3, #0]
 80031b6:	4a22      	ldr	r2, [pc, #136]	@ (8003240 <HAL_DMAEx_MultiBufferStart_IT+0x830>)
 80031b8:	4293      	cmp	r3, r2
 80031ba:	d06a      	beq.n	8003292 <HAL_DMAEx_MultiBufferStart_IT+0x882>
 80031bc:	68fb      	ldr	r3, [r7, #12]
 80031be:	681b      	ldr	r3, [r3, #0]
 80031c0:	4a20      	ldr	r2, [pc, #128]	@ (8003244 <HAL_DMAEx_MultiBufferStart_IT+0x834>)
 80031c2:	4293      	cmp	r3, r2
 80031c4:	d063      	beq.n	800328e <HAL_DMAEx_MultiBufferStart_IT+0x87e>
 80031c6:	68fb      	ldr	r3, [r7, #12]
 80031c8:	681b      	ldr	r3, [r3, #0]
 80031ca:	4a1f      	ldr	r2, [pc, #124]	@ (8003248 <HAL_DMAEx_MultiBufferStart_IT+0x838>)
 80031cc:	4293      	cmp	r3, r2
 80031ce:	d05b      	beq.n	8003288 <HAL_DMAEx_MultiBufferStart_IT+0x878>
 80031d0:	68fb      	ldr	r3, [r7, #12]
 80031d2:	681b      	ldr	r3, [r3, #0]
 80031d4:	4a1d      	ldr	r2, [pc, #116]	@ (800324c <HAL_DMAEx_MultiBufferStart_IT+0x83c>)
 80031d6:	4293      	cmp	r3, r2
 80031d8:	d053      	beq.n	8003282 <HAL_DMAEx_MultiBufferStart_IT+0x872>
 80031da:	68fb      	ldr	r3, [r7, #12]
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	4a1c      	ldr	r2, [pc, #112]	@ (8003250 <HAL_DMAEx_MultiBufferStart_IT+0x840>)
 80031e0:	4293      	cmp	r3, r2
 80031e2:	d04b      	beq.n	800327c <HAL_DMAEx_MultiBufferStart_IT+0x86c>
 80031e4:	68fb      	ldr	r3, [r7, #12]
 80031e6:	681b      	ldr	r3, [r3, #0]
 80031e8:	4a1a      	ldr	r2, [pc, #104]	@ (8003254 <HAL_DMAEx_MultiBufferStart_IT+0x844>)
 80031ea:	4293      	cmp	r3, r2
 80031ec:	d043      	beq.n	8003276 <HAL_DMAEx_MultiBufferStart_IT+0x866>
 80031ee:	68fb      	ldr	r3, [r7, #12]
 80031f0:	681b      	ldr	r3, [r3, #0]
 80031f2:	4a19      	ldr	r2, [pc, #100]	@ (8003258 <HAL_DMAEx_MultiBufferStart_IT+0x848>)
 80031f4:	4293      	cmp	r3, r2
 80031f6:	d03b      	beq.n	8003270 <HAL_DMAEx_MultiBufferStart_IT+0x860>
 80031f8:	68fb      	ldr	r3, [r7, #12]
 80031fa:	681b      	ldr	r3, [r3, #0]
 80031fc:	4a17      	ldr	r2, [pc, #92]	@ (800325c <HAL_DMAEx_MultiBufferStart_IT+0x84c>)
 80031fe:	4293      	cmp	r3, r2
 8003200:	d012      	beq.n	8003228 <HAL_DMAEx_MultiBufferStart_IT+0x818>
 8003202:	68fb      	ldr	r3, [r7, #12]
 8003204:	681b      	ldr	r3, [r3, #0]
 8003206:	4a16      	ldr	r2, [pc, #88]	@ (8003260 <HAL_DMAEx_MultiBufferStart_IT+0x850>)
 8003208:	4293      	cmp	r3, r2
 800320a:	d00a      	beq.n	8003222 <HAL_DMAEx_MultiBufferStart_IT+0x812>
 800320c:	68fb      	ldr	r3, [r7, #12]
 800320e:	681b      	ldr	r3, [r3, #0]
 8003210:	4a14      	ldr	r2, [pc, #80]	@ (8003264 <HAL_DMAEx_MultiBufferStart_IT+0x854>)
 8003212:	4293      	cmp	r3, r2
 8003214:	d102      	bne.n	800321c <HAL_DMAEx_MultiBufferStart_IT+0x80c>
 8003216:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 800321a:	e03f      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800321c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8003220:	e03c      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003222:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003226:	e039      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003228:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 800322c:	e036      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800322e:	bf00      	nop
 8003230:	40026400 	.word	0x40026400
 8003234:	40026058 	.word	0x40026058
 8003238:	40026010 	.word	0x40026010
 800323c:	40026410 	.word	0x40026410
 8003240:	40026070 	.word	0x40026070
 8003244:	40026470 	.word	0x40026470
 8003248:	40026028 	.word	0x40026028
 800324c:	40026428 	.word	0x40026428
 8003250:	40026088 	.word	0x40026088
 8003254:	40026488 	.word	0x40026488
 8003258:	40026040 	.word	0x40026040
 800325c:	40026440 	.word	0x40026440
 8003260:	400260a0 	.word	0x400260a0
 8003264:	400264a0 	.word	0x400264a0
 8003268:	40026000 	.word	0x40026000
 800326c:	40026458 	.word	0x40026458
 8003270:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003274:	e012      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003276:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800327a:	e00f      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800327c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003280:	e00c      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003282:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003286:	e009      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003288:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800328c:	e006      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800328e:	2308      	movs	r3, #8
 8003290:	e004      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003292:	2308      	movs	r3, #8
 8003294:	e002      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 8003296:	2308      	movs	r3, #8
 8003298:	e000      	b.n	800329c <HAL_DMAEx_MultiBufferStart_IT+0x88c>
 800329a:	2308      	movs	r3, #8
 800329c:	4a8c      	ldr	r2, [pc, #560]	@ (80034d0 <HAL_DMAEx_MultiBufferStart_IT+0xac0>)
 800329e:	60d3      	str	r3, [r2, #12]
 80032a0:	e14e      	b.n	8003540 <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 80032a2:	68fb      	ldr	r3, [r7, #12]
 80032a4:	681b      	ldr	r3, [r3, #0]
 80032a6:	461a      	mov	r2, r3
 80032a8:	4b8a      	ldr	r3, [pc, #552]	@ (80034d4 <HAL_DMAEx_MultiBufferStart_IT+0xac4>)
 80032aa:	429a      	cmp	r2, r3
 80032ac:	d960      	bls.n	8003370 <HAL_DMAEx_MultiBufferStart_IT+0x960>
 80032ae:	68fb      	ldr	r3, [r7, #12]
 80032b0:	681b      	ldr	r3, [r3, #0]
 80032b2:	4a89      	ldr	r2, [pc, #548]	@ (80034d8 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 80032b4:	4293      	cmp	r3, r2
 80032b6:	d057      	beq.n	8003368 <HAL_DMAEx_MultiBufferStart_IT+0x958>
 80032b8:	68fb      	ldr	r3, [r7, #12]
 80032ba:	681b      	ldr	r3, [r3, #0]
 80032bc:	4a87      	ldr	r2, [pc, #540]	@ (80034dc <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 80032be:	4293      	cmp	r3, r2
 80032c0:	d050      	beq.n	8003364 <HAL_DMAEx_MultiBufferStart_IT+0x954>
 80032c2:	68fb      	ldr	r3, [r7, #12]
 80032c4:	681b      	ldr	r3, [r3, #0]
 80032c6:	4a86      	ldr	r2, [pc, #536]	@ (80034e0 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 80032c8:	4293      	cmp	r3, r2
 80032ca:	d049      	beq.n	8003360 <HAL_DMAEx_MultiBufferStart_IT+0x950>
 80032cc:	68fb      	ldr	r3, [r7, #12]
 80032ce:	681b      	ldr	r3, [r3, #0]
 80032d0:	4a84      	ldr	r2, [pc, #528]	@ (80034e4 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 80032d2:	4293      	cmp	r3, r2
 80032d4:	d042      	beq.n	800335c <HAL_DMAEx_MultiBufferStart_IT+0x94c>
 80032d6:	68fb      	ldr	r3, [r7, #12]
 80032d8:	681b      	ldr	r3, [r3, #0]
 80032da:	4a83      	ldr	r2, [pc, #524]	@ (80034e8 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 80032dc:	4293      	cmp	r3, r2
 80032de:	d03a      	beq.n	8003356 <HAL_DMAEx_MultiBufferStart_IT+0x946>
 80032e0:	68fb      	ldr	r3, [r7, #12]
 80032e2:	681b      	ldr	r3, [r3, #0]
 80032e4:	4a81      	ldr	r2, [pc, #516]	@ (80034ec <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 80032e6:	4293      	cmp	r3, r2
 80032e8:	d032      	beq.n	8003350 <HAL_DMAEx_MultiBufferStart_IT+0x940>
 80032ea:	68fb      	ldr	r3, [r7, #12]
 80032ec:	681b      	ldr	r3, [r3, #0]
 80032ee:	4a80      	ldr	r2, [pc, #512]	@ (80034f0 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 80032f0:	4293      	cmp	r3, r2
 80032f2:	d02a      	beq.n	800334a <HAL_DMAEx_MultiBufferStart_IT+0x93a>
 80032f4:	68fb      	ldr	r3, [r7, #12]
 80032f6:	681b      	ldr	r3, [r3, #0]
 80032f8:	4a7e      	ldr	r2, [pc, #504]	@ (80034f4 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 80032fa:	4293      	cmp	r3, r2
 80032fc:	d022      	beq.n	8003344 <HAL_DMAEx_MultiBufferStart_IT+0x934>
 80032fe:	68fb      	ldr	r3, [r7, #12]
 8003300:	681b      	ldr	r3, [r3, #0]
 8003302:	4a7d      	ldr	r2, [pc, #500]	@ (80034f8 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 8003304:	4293      	cmp	r3, r2
 8003306:	d01a      	beq.n	800333e <HAL_DMAEx_MultiBufferStart_IT+0x92e>
 8003308:	68fb      	ldr	r3, [r7, #12]
 800330a:	681b      	ldr	r3, [r3, #0]
 800330c:	4a7b      	ldr	r2, [pc, #492]	@ (80034fc <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 800330e:	4293      	cmp	r3, r2
 8003310:	d012      	beq.n	8003338 <HAL_DMAEx_MultiBufferStart_IT+0x928>
 8003312:	68fb      	ldr	r3, [r7, #12]
 8003314:	681b      	ldr	r3, [r3, #0]
 8003316:	4a7a      	ldr	r2, [pc, #488]	@ (8003500 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 8003318:	4293      	cmp	r3, r2
 800331a:	d00a      	beq.n	8003332 <HAL_DMAEx_MultiBufferStart_IT+0x922>
 800331c:	68fb      	ldr	r3, [r7, #12]
 800331e:	681b      	ldr	r3, [r3, #0]
 8003320:	4a78      	ldr	r2, [pc, #480]	@ (8003504 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 8003322:	4293      	cmp	r3, r2
 8003324:	d102      	bne.n	800332c <HAL_DMAEx_MultiBufferStart_IT+0x91c>
 8003326:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 800332a:	e01e      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800332c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8003330:	e01b      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003332:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003336:	e018      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003338:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 800333c:	e015      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800333e:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003342:	e012      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003344:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003348:	e00f      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800334a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800334e:	e00c      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003350:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003354:	e009      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003356:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800335a:	e006      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 800335c:	2308      	movs	r3, #8
 800335e:	e004      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003360:	2308      	movs	r3, #8
 8003362:	e002      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003364:	2308      	movs	r3, #8
 8003366:	e000      	b.n	800336a <HAL_DMAEx_MultiBufferStart_IT+0x95a>
 8003368:	2308      	movs	r3, #8
 800336a:	4a59      	ldr	r2, [pc, #356]	@ (80034d0 <HAL_DMAEx_MultiBufferStart_IT+0xac0>)
 800336c:	6093      	str	r3, [r2, #8]
 800336e:	e0e7      	b.n	8003540 <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 8003370:	68fb      	ldr	r3, [r7, #12]
 8003372:	681b      	ldr	r3, [r3, #0]
 8003374:	461a      	mov	r2, r3
 8003376:	4b64      	ldr	r3, [pc, #400]	@ (8003508 <HAL_DMAEx_MultiBufferStart_IT+0xaf8>)
 8003378:	429a      	cmp	r2, r3
 800337a:	d960      	bls.n	800343e <HAL_DMAEx_MultiBufferStart_IT+0xa2e>
 800337c:	68fb      	ldr	r3, [r7, #12]
 800337e:	681b      	ldr	r3, [r3, #0]
 8003380:	4a55      	ldr	r2, [pc, #340]	@ (80034d8 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 8003382:	4293      	cmp	r3, r2
 8003384:	d057      	beq.n	8003436 <HAL_DMAEx_MultiBufferStart_IT+0xa26>
 8003386:	68fb      	ldr	r3, [r7, #12]
 8003388:	681b      	ldr	r3, [r3, #0]
 800338a:	4a54      	ldr	r2, [pc, #336]	@ (80034dc <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 800338c:	4293      	cmp	r3, r2
 800338e:	d050      	beq.n	8003432 <HAL_DMAEx_MultiBufferStart_IT+0xa22>
 8003390:	68fb      	ldr	r3, [r7, #12]
 8003392:	681b      	ldr	r3, [r3, #0]
 8003394:	4a52      	ldr	r2, [pc, #328]	@ (80034e0 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 8003396:	4293      	cmp	r3, r2
 8003398:	d049      	beq.n	800342e <HAL_DMAEx_MultiBufferStart_IT+0xa1e>
 800339a:	68fb      	ldr	r3, [r7, #12]
 800339c:	681b      	ldr	r3, [r3, #0]
 800339e:	4a51      	ldr	r2, [pc, #324]	@ (80034e4 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 80033a0:	4293      	cmp	r3, r2
 80033a2:	d042      	beq.n	800342a <HAL_DMAEx_MultiBufferStart_IT+0xa1a>
 80033a4:	68fb      	ldr	r3, [r7, #12]
 80033a6:	681b      	ldr	r3, [r3, #0]
 80033a8:	4a4f      	ldr	r2, [pc, #316]	@ (80034e8 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 80033aa:	4293      	cmp	r3, r2
 80033ac:	d03a      	beq.n	8003424 <HAL_DMAEx_MultiBufferStart_IT+0xa14>
 80033ae:	68fb      	ldr	r3, [r7, #12]
 80033b0:	681b      	ldr	r3, [r3, #0]
 80033b2:	4a4e      	ldr	r2, [pc, #312]	@ (80034ec <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 80033b4:	4293      	cmp	r3, r2
 80033b6:	d032      	beq.n	800341e <HAL_DMAEx_MultiBufferStart_IT+0xa0e>
 80033b8:	68fb      	ldr	r3, [r7, #12]
 80033ba:	681b      	ldr	r3, [r3, #0]
 80033bc:	4a4c      	ldr	r2, [pc, #304]	@ (80034f0 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 80033be:	4293      	cmp	r3, r2
 80033c0:	d02a      	beq.n	8003418 <HAL_DMAEx_MultiBufferStart_IT+0xa08>
 80033c2:	68fb      	ldr	r3, [r7, #12]
 80033c4:	681b      	ldr	r3, [r3, #0]
 80033c6:	4a4b      	ldr	r2, [pc, #300]	@ (80034f4 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 80033c8:	4293      	cmp	r3, r2
 80033ca:	d022      	beq.n	8003412 <HAL_DMAEx_MultiBufferStart_IT+0xa02>
 80033cc:	68fb      	ldr	r3, [r7, #12]
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	4a49      	ldr	r2, [pc, #292]	@ (80034f8 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 80033d2:	4293      	cmp	r3, r2
 80033d4:	d01a      	beq.n	800340c <HAL_DMAEx_MultiBufferStart_IT+0x9fc>
 80033d6:	68fb      	ldr	r3, [r7, #12]
 80033d8:	681b      	ldr	r3, [r3, #0]
 80033da:	4a48      	ldr	r2, [pc, #288]	@ (80034fc <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 80033dc:	4293      	cmp	r3, r2
 80033de:	d012      	beq.n	8003406 <HAL_DMAEx_MultiBufferStart_IT+0x9f6>
 80033e0:	68fb      	ldr	r3, [r7, #12]
 80033e2:	681b      	ldr	r3, [r3, #0]
 80033e4:	4a46      	ldr	r2, [pc, #280]	@ (8003500 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 80033e6:	4293      	cmp	r3, r2
 80033e8:	d00a      	beq.n	8003400 <HAL_DMAEx_MultiBufferStart_IT+0x9f0>
 80033ea:	68fb      	ldr	r3, [r7, #12]
 80033ec:	681b      	ldr	r3, [r3, #0]
 80033ee:	4a45      	ldr	r2, [pc, #276]	@ (8003504 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 80033f0:	4293      	cmp	r3, r2
 80033f2:	d102      	bne.n	80033fa <HAL_DMAEx_MultiBufferStart_IT+0x9ea>
 80033f4:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80033f8:	e01e      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 80033fa:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80033fe:	e01b      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003400:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003404:	e018      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003406:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 800340a:	e015      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 800340c:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003410:	e012      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003412:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003416:	e00f      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003418:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800341c:	e00c      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 800341e:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003422:	e009      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003424:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003428:	e006      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 800342a:	2308      	movs	r3, #8
 800342c:	e004      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 800342e:	2308      	movs	r3, #8
 8003430:	e002      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003432:	2308      	movs	r3, #8
 8003434:	e000      	b.n	8003438 <HAL_DMAEx_MultiBufferStart_IT+0xa28>
 8003436:	2308      	movs	r3, #8
 8003438:	4a34      	ldr	r2, [pc, #208]	@ (800350c <HAL_DMAEx_MultiBufferStart_IT+0xafc>)
 800343a:	60d3      	str	r3, [r2, #12]
 800343c:	e080      	b.n	8003540 <HAL_DMAEx_MultiBufferStart_IT+0xb30>
 800343e:	68fb      	ldr	r3, [r7, #12]
 8003440:	681b      	ldr	r3, [r3, #0]
 8003442:	4a25      	ldr	r2, [pc, #148]	@ (80034d8 <HAL_DMAEx_MultiBufferStart_IT+0xac8>)
 8003444:	4293      	cmp	r3, r2
 8003446:	d078      	beq.n	800353a <HAL_DMAEx_MultiBufferStart_IT+0xb2a>
 8003448:	68fb      	ldr	r3, [r7, #12]
 800344a:	681b      	ldr	r3, [r3, #0]
 800344c:	4a23      	ldr	r2, [pc, #140]	@ (80034dc <HAL_DMAEx_MultiBufferStart_IT+0xacc>)
 800344e:	4293      	cmp	r3, r2
 8003450:	d071      	beq.n	8003536 <HAL_DMAEx_MultiBufferStart_IT+0xb26>
 8003452:	68fb      	ldr	r3, [r7, #12]
 8003454:	681b      	ldr	r3, [r3, #0]
 8003456:	4a22      	ldr	r2, [pc, #136]	@ (80034e0 <HAL_DMAEx_MultiBufferStart_IT+0xad0>)
 8003458:	4293      	cmp	r3, r2
 800345a:	d06a      	beq.n	8003532 <HAL_DMAEx_MultiBufferStart_IT+0xb22>
 800345c:	68fb      	ldr	r3, [r7, #12]
 800345e:	681b      	ldr	r3, [r3, #0]
 8003460:	4a20      	ldr	r2, [pc, #128]	@ (80034e4 <HAL_DMAEx_MultiBufferStart_IT+0xad4>)
 8003462:	4293      	cmp	r3, r2
 8003464:	d063      	beq.n	800352e <HAL_DMAEx_MultiBufferStart_IT+0xb1e>
 8003466:	68fb      	ldr	r3, [r7, #12]
 8003468:	681b      	ldr	r3, [r3, #0]
 800346a:	4a1f      	ldr	r2, [pc, #124]	@ (80034e8 <HAL_DMAEx_MultiBufferStart_IT+0xad8>)
 800346c:	4293      	cmp	r3, r2
 800346e:	d05b      	beq.n	8003528 <HAL_DMAEx_MultiBufferStart_IT+0xb18>
 8003470:	68fb      	ldr	r3, [r7, #12]
 8003472:	681b      	ldr	r3, [r3, #0]
 8003474:	4a1d      	ldr	r2, [pc, #116]	@ (80034ec <HAL_DMAEx_MultiBufferStart_IT+0xadc>)
 8003476:	4293      	cmp	r3, r2
 8003478:	d053      	beq.n	8003522 <HAL_DMAEx_MultiBufferStart_IT+0xb12>
 800347a:	68fb      	ldr	r3, [r7, #12]
 800347c:	681b      	ldr	r3, [r3, #0]
 800347e:	4a1c      	ldr	r2, [pc, #112]	@ (80034f0 <HAL_DMAEx_MultiBufferStart_IT+0xae0>)
 8003480:	4293      	cmp	r3, r2
 8003482:	d04b      	beq.n	800351c <HAL_DMAEx_MultiBufferStart_IT+0xb0c>
 8003484:	68fb      	ldr	r3, [r7, #12]
 8003486:	681b      	ldr	r3, [r3, #0]
 8003488:	4a1a      	ldr	r2, [pc, #104]	@ (80034f4 <HAL_DMAEx_MultiBufferStart_IT+0xae4>)
 800348a:	4293      	cmp	r3, r2
 800348c:	d043      	beq.n	8003516 <HAL_DMAEx_MultiBufferStart_IT+0xb06>
 800348e:	68fb      	ldr	r3, [r7, #12]
 8003490:	681b      	ldr	r3, [r3, #0]
 8003492:	4a19      	ldr	r2, [pc, #100]	@ (80034f8 <HAL_DMAEx_MultiBufferStart_IT+0xae8>)
 8003494:	4293      	cmp	r3, r2
 8003496:	d03b      	beq.n	8003510 <HAL_DMAEx_MultiBufferStart_IT+0xb00>
 8003498:	68fb      	ldr	r3, [r7, #12]
 800349a:	681b      	ldr	r3, [r3, #0]
 800349c:	4a17      	ldr	r2, [pc, #92]	@ (80034fc <HAL_DMAEx_MultiBufferStart_IT+0xaec>)
 800349e:	4293      	cmp	r3, r2
 80034a0:	d012      	beq.n	80034c8 <HAL_DMAEx_MultiBufferStart_IT+0xab8>
 80034a2:	68fb      	ldr	r3, [r7, #12]
 80034a4:	681b      	ldr	r3, [r3, #0]
 80034a6:	4a16      	ldr	r2, [pc, #88]	@ (8003500 <HAL_DMAEx_MultiBufferStart_IT+0xaf0>)
 80034a8:	4293      	cmp	r3, r2
 80034aa:	d00a      	beq.n	80034c2 <HAL_DMAEx_MultiBufferStart_IT+0xab2>
 80034ac:	68fb      	ldr	r3, [r7, #12]
 80034ae:	681b      	ldr	r3, [r3, #0]
 80034b0:	4a14      	ldr	r2, [pc, #80]	@ (8003504 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>)
 80034b2:	4293      	cmp	r3, r2
 80034b4:	d102      	bne.n	80034bc <HAL_DMAEx_MultiBufferStart_IT+0xaac>
 80034b6:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034ba:	e03f      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80034bc:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80034c0:	e03c      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80034c2:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034c6:	e039      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80034c8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80034cc:	e036      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 80034ce:	bf00      	nop
 80034d0:	40026400 	.word	0x40026400
 80034d4:	400260b8 	.word	0x400260b8
 80034d8:	40026010 	.word	0x40026010
 80034dc:	40026410 	.word	0x40026410
 80034e0:	40026070 	.word	0x40026070
 80034e4:	40026470 	.word	0x40026470
 80034e8:	40026028 	.word	0x40026028
 80034ec:	40026428 	.word	0x40026428
 80034f0:	40026088 	.word	0x40026088
 80034f4:	40026488 	.word	0x40026488
 80034f8:	40026040 	.word	0x40026040
 80034fc:	40026440 	.word	0x40026440
 8003500:	400260a0 	.word	0x400260a0
 8003504:	400264a0 	.word	0x400264a0
 8003508:	40026058 	.word	0x40026058
 800350c:	40026000 	.word	0x40026000
 8003510:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8003514:	e012      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003516:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800351a:	e00f      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 800351c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003520:	e00c      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003522:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8003526:	e009      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003528:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800352c:	e006      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 800352e:	2308      	movs	r3, #8
 8003530:	e004      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003532:	2308      	movs	r3, #8
 8003534:	e002      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 8003536:	2308      	movs	r3, #8
 8003538:	e000      	b.n	800353c <HAL_DMAEx_MultiBufferStart_IT+0xb2c>
 800353a:	2308      	movs	r3, #8
 800353c:	4a8a      	ldr	r2, [pc, #552]	@ (8003768 <HAL_DMAEx_MultiBufferStart_IT+0xd58>)
 800353e:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8003540:	68fb      	ldr	r3, [r7, #12]
 8003542:	681b      	ldr	r3, [r3, #0]
 8003544:	461a      	mov	r2, r3
 8003546:	4b89      	ldr	r3, [pc, #548]	@ (800376c <HAL_DMAEx_MultiBufferStart_IT+0xd5c>)
 8003548:	429a      	cmp	r2, r3
 800354a:	d960      	bls.n	800360e <HAL_DMAEx_MultiBufferStart_IT+0xbfe>
 800354c:	68fb      	ldr	r3, [r7, #12]
 800354e:	681b      	ldr	r3, [r3, #0]
 8003550:	4a87      	ldr	r2, [pc, #540]	@ (8003770 <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 8003552:	4293      	cmp	r3, r2
 8003554:	d057      	beq.n	8003606 <HAL_DMAEx_MultiBufferStart_IT+0xbf6>
 8003556:	68fb      	ldr	r3, [r7, #12]
 8003558:	681b      	ldr	r3, [r3, #0]
 800355a:	4a86      	ldr	r2, [pc, #536]	@ (8003774 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 800355c:	4293      	cmp	r3, r2
 800355e:	d050      	beq.n	8003602 <HAL_DMAEx_MultiBufferStart_IT+0xbf2>
 8003560:	68fb      	ldr	r3, [r7, #12]
 8003562:	681b      	ldr	r3, [r3, #0]
 8003564:	4a84      	ldr	r2, [pc, #528]	@ (8003778 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 8003566:	4293      	cmp	r3, r2
 8003568:	d049      	beq.n	80035fe <HAL_DMAEx_MultiBufferStart_IT+0xbee>
 800356a:	68fb      	ldr	r3, [r7, #12]
 800356c:	681b      	ldr	r3, [r3, #0]
 800356e:	4a83      	ldr	r2, [pc, #524]	@ (800377c <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 8003570:	4293      	cmp	r3, r2
 8003572:	d042      	beq.n	80035fa <HAL_DMAEx_MultiBufferStart_IT+0xbea>
 8003574:	68fb      	ldr	r3, [r7, #12]
 8003576:	681b      	ldr	r3, [r3, #0]
 8003578:	4a81      	ldr	r2, [pc, #516]	@ (8003780 <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 800357a:	4293      	cmp	r3, r2
 800357c:	d03a      	beq.n	80035f4 <HAL_DMAEx_MultiBufferStart_IT+0xbe4>
 800357e:	68fb      	ldr	r3, [r7, #12]
 8003580:	681b      	ldr	r3, [r3, #0]
 8003582:	4a80      	ldr	r2, [pc, #512]	@ (8003784 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8003584:	4293      	cmp	r3, r2
 8003586:	d032      	beq.n	80035ee <HAL_DMAEx_MultiBufferStart_IT+0xbde>
 8003588:	68fb      	ldr	r3, [r7, #12]
 800358a:	681b      	ldr	r3, [r3, #0]
 800358c:	4a7e      	ldr	r2, [pc, #504]	@ (8003788 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 800358e:	4293      	cmp	r3, r2
 8003590:	d02a      	beq.n	80035e8 <HAL_DMAEx_MultiBufferStart_IT+0xbd8>
 8003592:	68fb      	ldr	r3, [r7, #12]
 8003594:	681b      	ldr	r3, [r3, #0]
 8003596:	4a7d      	ldr	r2, [pc, #500]	@ (800378c <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8003598:	4293      	cmp	r3, r2
 800359a:	d022      	beq.n	80035e2 <HAL_DMAEx_MultiBufferStart_IT+0xbd2>
 800359c:	68fb      	ldr	r3, [r7, #12]
 800359e:	681b      	ldr	r3, [r3, #0]
 80035a0:	4a7b      	ldr	r2, [pc, #492]	@ (8003790 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 80035a2:	4293      	cmp	r3, r2
 80035a4:	d01a      	beq.n	80035dc <HAL_DMAEx_MultiBufferStart_IT+0xbcc>
 80035a6:	68fb      	ldr	r3, [r7, #12]
 80035a8:	681b      	ldr	r3, [r3, #0]
 80035aa:	4a7a      	ldr	r2, [pc, #488]	@ (8003794 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 80035ac:	4293      	cmp	r3, r2
 80035ae:	d012      	beq.n	80035d6 <HAL_DMAEx_MultiBufferStart_IT+0xbc6>
 80035b0:	68fb      	ldr	r3, [r7, #12]
 80035b2:	681b      	ldr	r3, [r3, #0]
 80035b4:	4a78      	ldr	r2, [pc, #480]	@ (8003798 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 80035b6:	4293      	cmp	r3, r2
 80035b8:	d00a      	beq.n	80035d0 <HAL_DMAEx_MultiBufferStart_IT+0xbc0>
 80035ba:	68fb      	ldr	r3, [r7, #12]
 80035bc:	681b      	ldr	r3, [r3, #0]
 80035be:	4a77      	ldr	r2, [pc, #476]	@ (800379c <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 80035c0:	4293      	cmp	r3, r2
 80035c2:	d102      	bne.n	80035ca <HAL_DMAEx_MultiBufferStart_IT+0xbba>
 80035c4:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80035c8:	e01e      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035ca:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80035ce:	e01b      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035d0:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80035d4:	e018      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035d6:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80035da:	e015      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035dc:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80035e0:	e012      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035e2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80035e6:	e00f      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035e8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80035ec:	e00c      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035ee:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80035f2:	e009      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035f4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80035f8:	e006      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035fa:	2304      	movs	r3, #4
 80035fc:	e004      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 80035fe:	2304      	movs	r3, #4
 8003600:	e002      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 8003602:	2304      	movs	r3, #4
 8003604:	e000      	b.n	8003608 <HAL_DMAEx_MultiBufferStart_IT+0xbf8>
 8003606:	2304      	movs	r3, #4
 8003608:	4a65      	ldr	r2, [pc, #404]	@ (80037a0 <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
 800360a:	60d3      	str	r3, [r2, #12]
 800360c:	e150      	b.n	80038b0 <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 800360e:	68fb      	ldr	r3, [r7, #12]
 8003610:	681b      	ldr	r3, [r3, #0]
 8003612:	461a      	mov	r2, r3
 8003614:	4b63      	ldr	r3, [pc, #396]	@ (80037a4 <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
 8003616:	429a      	cmp	r2, r3
 8003618:	d960      	bls.n	80036dc <HAL_DMAEx_MultiBufferStart_IT+0xccc>
 800361a:	68fb      	ldr	r3, [r7, #12]
 800361c:	681b      	ldr	r3, [r3, #0]
 800361e:	4a54      	ldr	r2, [pc, #336]	@ (8003770 <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 8003620:	4293      	cmp	r3, r2
 8003622:	d057      	beq.n	80036d4 <HAL_DMAEx_MultiBufferStart_IT+0xcc4>
 8003624:	68fb      	ldr	r3, [r7, #12]
 8003626:	681b      	ldr	r3, [r3, #0]
 8003628:	4a52      	ldr	r2, [pc, #328]	@ (8003774 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 800362a:	4293      	cmp	r3, r2
 800362c:	d050      	beq.n	80036d0 <HAL_DMAEx_MultiBufferStart_IT+0xcc0>
 800362e:	68fb      	ldr	r3, [r7, #12]
 8003630:	681b      	ldr	r3, [r3, #0]
 8003632:	4a51      	ldr	r2, [pc, #324]	@ (8003778 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 8003634:	4293      	cmp	r3, r2
 8003636:	d049      	beq.n	80036cc <HAL_DMAEx_MultiBufferStart_IT+0xcbc>
 8003638:	68fb      	ldr	r3, [r7, #12]
 800363a:	681b      	ldr	r3, [r3, #0]
 800363c:	4a4f      	ldr	r2, [pc, #316]	@ (800377c <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 800363e:	4293      	cmp	r3, r2
 8003640:	d042      	beq.n	80036c8 <HAL_DMAEx_MultiBufferStart_IT+0xcb8>
 8003642:	68fb      	ldr	r3, [r7, #12]
 8003644:	681b      	ldr	r3, [r3, #0]
 8003646:	4a4e      	ldr	r2, [pc, #312]	@ (8003780 <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 8003648:	4293      	cmp	r3, r2
 800364a:	d03a      	beq.n	80036c2 <HAL_DMAEx_MultiBufferStart_IT+0xcb2>
 800364c:	68fb      	ldr	r3, [r7, #12]
 800364e:	681b      	ldr	r3, [r3, #0]
 8003650:	4a4c      	ldr	r2, [pc, #304]	@ (8003784 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8003652:	4293      	cmp	r3, r2
 8003654:	d032      	beq.n	80036bc <HAL_DMAEx_MultiBufferStart_IT+0xcac>
 8003656:	68fb      	ldr	r3, [r7, #12]
 8003658:	681b      	ldr	r3, [r3, #0]
 800365a:	4a4b      	ldr	r2, [pc, #300]	@ (8003788 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 800365c:	4293      	cmp	r3, r2
 800365e:	d02a      	beq.n	80036b6 <HAL_DMAEx_MultiBufferStart_IT+0xca6>
 8003660:	68fb      	ldr	r3, [r7, #12]
 8003662:	681b      	ldr	r3, [r3, #0]
 8003664:	4a49      	ldr	r2, [pc, #292]	@ (800378c <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8003666:	4293      	cmp	r3, r2
 8003668:	d022      	beq.n	80036b0 <HAL_DMAEx_MultiBufferStart_IT+0xca0>
 800366a:	68fb      	ldr	r3, [r7, #12]
 800366c:	681b      	ldr	r3, [r3, #0]
 800366e:	4a48      	ldr	r2, [pc, #288]	@ (8003790 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 8003670:	4293      	cmp	r3, r2
 8003672:	d01a      	beq.n	80036aa <HAL_DMAEx_MultiBufferStart_IT+0xc9a>
 8003674:	68fb      	ldr	r3, [r7, #12]
 8003676:	681b      	ldr	r3, [r3, #0]
 8003678:	4a46      	ldr	r2, [pc, #280]	@ (8003794 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 800367a:	4293      	cmp	r3, r2
 800367c:	d012      	beq.n	80036a4 <HAL_DMAEx_MultiBufferStart_IT+0xc94>
 800367e:	68fb      	ldr	r3, [r7, #12]
 8003680:	681b      	ldr	r3, [r3, #0]
 8003682:	4a45      	ldr	r2, [pc, #276]	@ (8003798 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8003684:	4293      	cmp	r3, r2
 8003686:	d00a      	beq.n	800369e <HAL_DMAEx_MultiBufferStart_IT+0xc8e>
 8003688:	68fb      	ldr	r3, [r7, #12]
 800368a:	681b      	ldr	r3, [r3, #0]
 800368c:	4a43      	ldr	r2, [pc, #268]	@ (800379c <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 800368e:	4293      	cmp	r3, r2
 8003690:	d102      	bne.n	8003698 <HAL_DMAEx_MultiBufferStart_IT+0xc88>
 8003692:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003696:	e01e      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 8003698:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 800369c:	e01b      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 800369e:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80036a2:	e018      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036a4:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80036a8:	e015      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036aa:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80036ae:	e012      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036b0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80036b4:	e00f      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036b6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80036ba:	e00c      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036bc:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80036c0:	e009      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036c2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80036c6:	e006      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036c8:	2304      	movs	r3, #4
 80036ca:	e004      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036cc:	2304      	movs	r3, #4
 80036ce:	e002      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036d0:	2304      	movs	r3, #4
 80036d2:	e000      	b.n	80036d6 <HAL_DMAEx_MultiBufferStart_IT+0xcc6>
 80036d4:	2304      	movs	r3, #4
 80036d6:	4a32      	ldr	r2, [pc, #200]	@ (80037a0 <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
 80036d8:	6093      	str	r3, [r2, #8]
 80036da:	e0e9      	b.n	80038b0 <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 80036dc:	68fb      	ldr	r3, [r7, #12]
 80036de:	681b      	ldr	r3, [r3, #0]
 80036e0:	461a      	mov	r2, r3
 80036e2:	4b31      	ldr	r3, [pc, #196]	@ (80037a8 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
 80036e4:	429a      	cmp	r2, r3
 80036e6:	f240 8083 	bls.w	80037f0 <HAL_DMAEx_MultiBufferStart_IT+0xde0>
 80036ea:	68fb      	ldr	r3, [r7, #12]
 80036ec:	681b      	ldr	r3, [r3, #0]
 80036ee:	4a20      	ldr	r2, [pc, #128]	@ (8003770 <HAL_DMAEx_MultiBufferStart_IT+0xd60>)
 80036f0:	4293      	cmp	r3, r2
 80036f2:	d079      	beq.n	80037e8 <HAL_DMAEx_MultiBufferStart_IT+0xdd8>
 80036f4:	68fb      	ldr	r3, [r7, #12]
 80036f6:	681b      	ldr	r3, [r3, #0]
 80036f8:	4a1e      	ldr	r2, [pc, #120]	@ (8003774 <HAL_DMAEx_MultiBufferStart_IT+0xd64>)
 80036fa:	4293      	cmp	r3, r2
 80036fc:	d072      	beq.n	80037e4 <HAL_DMAEx_MultiBufferStart_IT+0xdd4>
 80036fe:	68fb      	ldr	r3, [r7, #12]
 8003700:	681b      	ldr	r3, [r3, #0]
 8003702:	4a1d      	ldr	r2, [pc, #116]	@ (8003778 <HAL_DMAEx_MultiBufferStart_IT+0xd68>)
 8003704:	4293      	cmp	r3, r2
 8003706:	d06b      	beq.n	80037e0 <HAL_DMAEx_MultiBufferStart_IT+0xdd0>
 8003708:	68fb      	ldr	r3, [r7, #12]
 800370a:	681b      	ldr	r3, [r3, #0]
 800370c:	4a1b      	ldr	r2, [pc, #108]	@ (800377c <HAL_DMAEx_MultiBufferStart_IT+0xd6c>)
 800370e:	4293      	cmp	r3, r2
 8003710:	d064      	beq.n	80037dc <HAL_DMAEx_MultiBufferStart_IT+0xdcc>
 8003712:	68fb      	ldr	r3, [r7, #12]
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	4a1a      	ldr	r2, [pc, #104]	@ (8003780 <HAL_DMAEx_MultiBufferStart_IT+0xd70>)
 8003718:	4293      	cmp	r3, r2
 800371a:	d05c      	beq.n	80037d6 <HAL_DMAEx_MultiBufferStart_IT+0xdc6>
 800371c:	68fb      	ldr	r3, [r7, #12]
 800371e:	681b      	ldr	r3, [r3, #0]
 8003720:	4a18      	ldr	r2, [pc, #96]	@ (8003784 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8003722:	4293      	cmp	r3, r2
 8003724:	d054      	beq.n	80037d0 <HAL_DMAEx_MultiBufferStart_IT+0xdc0>
 8003726:	68fb      	ldr	r3, [r7, #12]
 8003728:	681b      	ldr	r3, [r3, #0]
 800372a:	4a17      	ldr	r2, [pc, #92]	@ (8003788 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 800372c:	4293      	cmp	r3, r2
 800372e:	d04c      	beq.n	80037ca <HAL_DMAEx_MultiBufferStart_IT+0xdba>
 8003730:	68fb      	ldr	r3, [r7, #12]
 8003732:	681b      	ldr	r3, [r3, #0]
 8003734:	4a15      	ldr	r2, [pc, #84]	@ (800378c <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8003736:	4293      	cmp	r3, r2
 8003738:	d044      	beq.n	80037c4 <HAL_DMAEx_MultiBufferStart_IT+0xdb4>
 800373a:	68fb      	ldr	r3, [r7, #12]
 800373c:	681b      	ldr	r3, [r3, #0]
 800373e:	4a14      	ldr	r2, [pc, #80]	@ (8003790 <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 8003740:	4293      	cmp	r3, r2
 8003742:	d03c      	beq.n	80037be <HAL_DMAEx_MultiBufferStart_IT+0xdae>
 8003744:	68fb      	ldr	r3, [r7, #12]
 8003746:	681b      	ldr	r3, [r3, #0]
 8003748:	4a12      	ldr	r2, [pc, #72]	@ (8003794 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 800374a:	4293      	cmp	r3, r2
 800374c:	d034      	beq.n	80037b8 <HAL_DMAEx_MultiBufferStart_IT+0xda8>
 800374e:	68fb      	ldr	r3, [r7, #12]
 8003750:	681b      	ldr	r3, [r3, #0]
 8003752:	4a11      	ldr	r2, [pc, #68]	@ (8003798 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8003754:	4293      	cmp	r3, r2
 8003756:	d02c      	beq.n	80037b2 <HAL_DMAEx_MultiBufferStart_IT+0xda2>
 8003758:	68fb      	ldr	r3, [r7, #12]
 800375a:	681b      	ldr	r3, [r3, #0]
 800375c:	4a0f      	ldr	r2, [pc, #60]	@ (800379c <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 800375e:	4293      	cmp	r3, r2
 8003760:	d124      	bne.n	80037ac <HAL_DMAEx_MultiBufferStart_IT+0xd9c>
 8003762:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003766:	e040      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 8003768:	40026000 	.word	0x40026000
 800376c:	40026458 	.word	0x40026458
 8003770:	40026010 	.word	0x40026010
 8003774:	40026410 	.word	0x40026410
 8003778:	40026070 	.word	0x40026070
 800377c:	40026470 	.word	0x40026470
 8003780:	40026028 	.word	0x40026028
 8003784:	40026428 	.word	0x40026428
 8003788:	40026088 	.word	0x40026088
 800378c:	40026488 	.word	0x40026488
 8003790:	40026040 	.word	0x40026040
 8003794:	40026440 	.word	0x40026440
 8003798:	400260a0 	.word	0x400260a0
 800379c:	400264a0 	.word	0x400264a0
 80037a0:	40026400 	.word	0x40026400
 80037a4:	400260b8 	.word	0x400260b8
 80037a8:	40026058 	.word	0x40026058
 80037ac:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80037b0:	e01b      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037b2:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80037b6:	e018      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037b8:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80037bc:	e015      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037be:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80037c2:	e012      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037c4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037c8:	e00f      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037ca:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037ce:	e00c      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037d0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037d4:	e009      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037d6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80037da:	e006      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037dc:	2304      	movs	r3, #4
 80037de:	e004      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037e0:	2304      	movs	r3, #4
 80037e2:	e002      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037e4:	2304      	movs	r3, #4
 80037e6:	e000      	b.n	80037ea <HAL_DMAEx_MultiBufferStart_IT+0xdda>
 80037e8:	2304      	movs	r3, #4
 80037ea:	4a8b      	ldr	r2, [pc, #556]	@ (8003a18 <HAL_DMAEx_MultiBufferStart_IT+0x1008>)
 80037ec:	60d3      	str	r3, [r2, #12]
 80037ee:	e05f      	b.n	80038b0 <HAL_DMAEx_MultiBufferStart_IT+0xea0>
 80037f0:	68fb      	ldr	r3, [r7, #12]
 80037f2:	681b      	ldr	r3, [r3, #0]
 80037f4:	4a89      	ldr	r2, [pc, #548]	@ (8003a1c <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 80037f6:	4293      	cmp	r3, r2
 80037f8:	d057      	beq.n	80038aa <HAL_DMAEx_MultiBufferStart_IT+0xe9a>
 80037fa:	68fb      	ldr	r3, [r7, #12]
 80037fc:	681b      	ldr	r3, [r3, #0]
 80037fe:	4a88      	ldr	r2, [pc, #544]	@ (8003a20 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 8003800:	4293      	cmp	r3, r2
 8003802:	d050      	beq.n	80038a6 <HAL_DMAEx_MultiBufferStart_IT+0xe96>
 8003804:	68fb      	ldr	r3, [r7, #12]
 8003806:	681b      	ldr	r3, [r3, #0]
 8003808:	4a86      	ldr	r2, [pc, #536]	@ (8003a24 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 800380a:	4293      	cmp	r3, r2
 800380c:	d049      	beq.n	80038a2 <HAL_DMAEx_MultiBufferStart_IT+0xe92>
 800380e:	68fb      	ldr	r3, [r7, #12]
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	4a85      	ldr	r2, [pc, #532]	@ (8003a28 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 8003814:	4293      	cmp	r3, r2
 8003816:	d042      	beq.n	800389e <HAL_DMAEx_MultiBufferStart_IT+0xe8e>
 8003818:	68fb      	ldr	r3, [r7, #12]
 800381a:	681b      	ldr	r3, [r3, #0]
 800381c:	4a83      	ldr	r2, [pc, #524]	@ (8003a2c <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 800381e:	4293      	cmp	r3, r2
 8003820:	d03a      	beq.n	8003898 <HAL_DMAEx_MultiBufferStart_IT+0xe88>
 8003822:	68fb      	ldr	r3, [r7, #12]
 8003824:	681b      	ldr	r3, [r3, #0]
 8003826:	4a82      	ldr	r2, [pc, #520]	@ (8003a30 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 8003828:	4293      	cmp	r3, r2
 800382a:	d032      	beq.n	8003892 <HAL_DMAEx_MultiBufferStart_IT+0xe82>
 800382c:	68fb      	ldr	r3, [r7, #12]
 800382e:	681b      	ldr	r3, [r3, #0]
 8003830:	4a80      	ldr	r2, [pc, #512]	@ (8003a34 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 8003832:	4293      	cmp	r3, r2
 8003834:	d02a      	beq.n	800388c <HAL_DMAEx_MultiBufferStart_IT+0xe7c>
 8003836:	68fb      	ldr	r3, [r7, #12]
 8003838:	681b      	ldr	r3, [r3, #0]
 800383a:	4a7f      	ldr	r2, [pc, #508]	@ (8003a38 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 800383c:	4293      	cmp	r3, r2
 800383e:	d022      	beq.n	8003886 <HAL_DMAEx_MultiBufferStart_IT+0xe76>
 8003840:	68fb      	ldr	r3, [r7, #12]
 8003842:	681b      	ldr	r3, [r3, #0]
 8003844:	4a7d      	ldr	r2, [pc, #500]	@ (8003a3c <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 8003846:	4293      	cmp	r3, r2
 8003848:	d01a      	beq.n	8003880 <HAL_DMAEx_MultiBufferStart_IT+0xe70>
 800384a:	68fb      	ldr	r3, [r7, #12]
 800384c:	681b      	ldr	r3, [r3, #0]
 800384e:	4a7c      	ldr	r2, [pc, #496]	@ (8003a40 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 8003850:	4293      	cmp	r3, r2
 8003852:	d012      	beq.n	800387a <HAL_DMAEx_MultiBufferStart_IT+0xe6a>
 8003854:	68fb      	ldr	r3, [r7, #12]
 8003856:	681b      	ldr	r3, [r3, #0]
 8003858:	4a7a      	ldr	r2, [pc, #488]	@ (8003a44 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 800385a:	4293      	cmp	r3, r2
 800385c:	d00a      	beq.n	8003874 <HAL_DMAEx_MultiBufferStart_IT+0xe64>
 800385e:	68fb      	ldr	r3, [r7, #12]
 8003860:	681b      	ldr	r3, [r3, #0]
 8003862:	4a79      	ldr	r2, [pc, #484]	@ (8003a48 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 8003864:	4293      	cmp	r3, r2
 8003866:	d102      	bne.n	800386e <HAL_DMAEx_MultiBufferStart_IT+0xe5e>
 8003868:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800386c:	e01e      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 800386e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8003872:	e01b      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003874:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003878:	e018      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 800387a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 800387e:	e015      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003880:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8003884:	e012      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003886:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800388a:	e00f      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 800388c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003890:	e00c      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003892:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003896:	e009      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 8003898:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800389c:	e006      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 800389e:	2304      	movs	r3, #4
 80038a0:	e004      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 80038a2:	2304      	movs	r3, #4
 80038a4:	e002      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 80038a6:	2304      	movs	r3, #4
 80038a8:	e000      	b.n	80038ac <HAL_DMAEx_MultiBufferStart_IT+0xe9c>
 80038aa:	2304      	movs	r3, #4
 80038ac:	4a5a      	ldr	r2, [pc, #360]	@ (8003a18 <HAL_DMAEx_MultiBufferStart_IT+0x1008>)
 80038ae:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80038b0:	68fb      	ldr	r3, [r7, #12]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	461a      	mov	r2, r3
 80038b6:	4b65      	ldr	r3, [pc, #404]	@ (8003a4c <HAL_DMAEx_MultiBufferStart_IT+0x103c>)
 80038b8:	429a      	cmp	r2, r3
 80038ba:	d95c      	bls.n	8003976 <HAL_DMAEx_MultiBufferStart_IT+0xf66>
 80038bc:	68fb      	ldr	r3, [r7, #12]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	4a56      	ldr	r2, [pc, #344]	@ (8003a1c <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 80038c2:	4293      	cmp	r3, r2
 80038c4:	d053      	beq.n	800396e <HAL_DMAEx_MultiBufferStart_IT+0xf5e>
 80038c6:	68fb      	ldr	r3, [r7, #12]
 80038c8:	681b      	ldr	r3, [r3, #0]
 80038ca:	4a55      	ldr	r2, [pc, #340]	@ (8003a20 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 80038cc:	4293      	cmp	r3, r2
 80038ce:	d04c      	beq.n	800396a <HAL_DMAEx_MultiBufferStart_IT+0xf5a>
 80038d0:	68fb      	ldr	r3, [r7, #12]
 80038d2:	681b      	ldr	r3, [r3, #0]
 80038d4:	4a53      	ldr	r2, [pc, #332]	@ (8003a24 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 80038d6:	4293      	cmp	r3, r2
 80038d8:	d045      	beq.n	8003966 <HAL_DMAEx_MultiBufferStart_IT+0xf56>
 80038da:	68fb      	ldr	r3, [r7, #12]
 80038dc:	681b      	ldr	r3, [r3, #0]
 80038de:	4a52      	ldr	r2, [pc, #328]	@ (8003a28 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 80038e0:	4293      	cmp	r3, r2
 80038e2:	d03e      	beq.n	8003962 <HAL_DMAEx_MultiBufferStart_IT+0xf52>
 80038e4:	68fb      	ldr	r3, [r7, #12]
 80038e6:	681b      	ldr	r3, [r3, #0]
 80038e8:	4a50      	ldr	r2, [pc, #320]	@ (8003a2c <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 80038ea:	4293      	cmp	r3, r2
 80038ec:	d037      	beq.n	800395e <HAL_DMAEx_MultiBufferStart_IT+0xf4e>
 80038ee:	68fb      	ldr	r3, [r7, #12]
 80038f0:	681b      	ldr	r3, [r3, #0]
 80038f2:	4a4f      	ldr	r2, [pc, #316]	@ (8003a30 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 80038f4:	4293      	cmp	r3, r2
 80038f6:	d030      	beq.n	800395a <HAL_DMAEx_MultiBufferStart_IT+0xf4a>
 80038f8:	68fb      	ldr	r3, [r7, #12]
 80038fa:	681b      	ldr	r3, [r3, #0]
 80038fc:	4a4d      	ldr	r2, [pc, #308]	@ (8003a34 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 80038fe:	4293      	cmp	r3, r2
 8003900:	d029      	beq.n	8003956 <HAL_DMAEx_MultiBufferStart_IT+0xf46>
 8003902:	68fb      	ldr	r3, [r7, #12]
 8003904:	681b      	ldr	r3, [r3, #0]
 8003906:	4a4c      	ldr	r2, [pc, #304]	@ (8003a38 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 8003908:	4293      	cmp	r3, r2
 800390a:	d022      	beq.n	8003952 <HAL_DMAEx_MultiBufferStart_IT+0xf42>
 800390c:	68fb      	ldr	r3, [r7, #12]
 800390e:	681b      	ldr	r3, [r3, #0]
 8003910:	4a4a      	ldr	r2, [pc, #296]	@ (8003a3c <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 8003912:	4293      	cmp	r3, r2
 8003914:	d01a      	beq.n	800394c <HAL_DMAEx_MultiBufferStart_IT+0xf3c>
 8003916:	68fb      	ldr	r3, [r7, #12]
 8003918:	681b      	ldr	r3, [r3, #0]
 800391a:	4a49      	ldr	r2, [pc, #292]	@ (8003a40 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 800391c:	4293      	cmp	r3, r2
 800391e:	d012      	beq.n	8003946 <HAL_DMAEx_MultiBufferStart_IT+0xf36>
 8003920:	68fb      	ldr	r3, [r7, #12]
 8003922:	681b      	ldr	r3, [r3, #0]
 8003924:	4a47      	ldr	r2, [pc, #284]	@ (8003a44 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 8003926:	4293      	cmp	r3, r2
 8003928:	d00a      	beq.n	8003940 <HAL_DMAEx_MultiBufferStart_IT+0xf30>
 800392a:	68fb      	ldr	r3, [r7, #12]
 800392c:	681b      	ldr	r3, [r3, #0]
 800392e:	4a46      	ldr	r2, [pc, #280]	@ (8003a48 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 8003930:	4293      	cmp	r3, r2
 8003932:	d102      	bne.n	800393a <HAL_DMAEx_MultiBufferStart_IT+0xf2a>
 8003934:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003938:	e01a      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800393a:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 800393e:	e017      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003940:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003944:	e014      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003946:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800394a:	e011      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800394c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003950:	e00e      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003952:	2340      	movs	r3, #64	@ 0x40
 8003954:	e00c      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003956:	2340      	movs	r3, #64	@ 0x40
 8003958:	e00a      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800395a:	2340      	movs	r3, #64	@ 0x40
 800395c:	e008      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800395e:	2340      	movs	r3, #64	@ 0x40
 8003960:	e006      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003962:	2301      	movs	r3, #1
 8003964:	e004      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 8003966:	2301      	movs	r3, #1
 8003968:	e002      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800396a:	2301      	movs	r3, #1
 800396c:	e000      	b.n	8003970 <HAL_DMAEx_MultiBufferStart_IT+0xf60>
 800396e:	2301      	movs	r3, #1
 8003970:	4a37      	ldr	r2, [pc, #220]	@ (8003a50 <HAL_DMAEx_MultiBufferStart_IT+0x1040>)
 8003972:	60d3      	str	r3, [r2, #12]
 8003974:	e141      	b.n	8003bfa <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003976:	68fb      	ldr	r3, [r7, #12]
 8003978:	681b      	ldr	r3, [r3, #0]
 800397a:	461a      	mov	r2, r3
 800397c:	4b35      	ldr	r3, [pc, #212]	@ (8003a54 <HAL_DMAEx_MultiBufferStart_IT+0x1044>)
 800397e:	429a      	cmp	r2, r3
 8003980:	d97c      	bls.n	8003a7c <HAL_DMAEx_MultiBufferStart_IT+0x106c>
 8003982:	68fb      	ldr	r3, [r7, #12]
 8003984:	681b      	ldr	r3, [r3, #0]
 8003986:	4a25      	ldr	r2, [pc, #148]	@ (8003a1c <HAL_DMAEx_MultiBufferStart_IT+0x100c>)
 8003988:	4293      	cmp	r3, r2
 800398a:	d073      	beq.n	8003a74 <HAL_DMAEx_MultiBufferStart_IT+0x1064>
 800398c:	68fb      	ldr	r3, [r7, #12]
 800398e:	681b      	ldr	r3, [r3, #0]
 8003990:	4a23      	ldr	r2, [pc, #140]	@ (8003a20 <HAL_DMAEx_MultiBufferStart_IT+0x1010>)
 8003992:	4293      	cmp	r3, r2
 8003994:	d06c      	beq.n	8003a70 <HAL_DMAEx_MultiBufferStart_IT+0x1060>
 8003996:	68fb      	ldr	r3, [r7, #12]
 8003998:	681b      	ldr	r3, [r3, #0]
 800399a:	4a22      	ldr	r2, [pc, #136]	@ (8003a24 <HAL_DMAEx_MultiBufferStart_IT+0x1014>)
 800399c:	4293      	cmp	r3, r2
 800399e:	d065      	beq.n	8003a6c <HAL_DMAEx_MultiBufferStart_IT+0x105c>
 80039a0:	68fb      	ldr	r3, [r7, #12]
 80039a2:	681b      	ldr	r3, [r3, #0]
 80039a4:	4a20      	ldr	r2, [pc, #128]	@ (8003a28 <HAL_DMAEx_MultiBufferStart_IT+0x1018>)
 80039a6:	4293      	cmp	r3, r2
 80039a8:	d05e      	beq.n	8003a68 <HAL_DMAEx_MultiBufferStart_IT+0x1058>
 80039aa:	68fb      	ldr	r3, [r7, #12]
 80039ac:	681b      	ldr	r3, [r3, #0]
 80039ae:	4a1f      	ldr	r2, [pc, #124]	@ (8003a2c <HAL_DMAEx_MultiBufferStart_IT+0x101c>)
 80039b0:	4293      	cmp	r3, r2
 80039b2:	d057      	beq.n	8003a64 <HAL_DMAEx_MultiBufferStart_IT+0x1054>
 80039b4:	68fb      	ldr	r3, [r7, #12]
 80039b6:	681b      	ldr	r3, [r3, #0]
 80039b8:	4a1d      	ldr	r2, [pc, #116]	@ (8003a30 <HAL_DMAEx_MultiBufferStart_IT+0x1020>)
 80039ba:	4293      	cmp	r3, r2
 80039bc:	d050      	beq.n	8003a60 <HAL_DMAEx_MultiBufferStart_IT+0x1050>
 80039be:	68fb      	ldr	r3, [r7, #12]
 80039c0:	681b      	ldr	r3, [r3, #0]
 80039c2:	4a1c      	ldr	r2, [pc, #112]	@ (8003a34 <HAL_DMAEx_MultiBufferStart_IT+0x1024>)
 80039c4:	4293      	cmp	r3, r2
 80039c6:	d049      	beq.n	8003a5c <HAL_DMAEx_MultiBufferStart_IT+0x104c>
 80039c8:	68fb      	ldr	r3, [r7, #12]
 80039ca:	681b      	ldr	r3, [r3, #0]
 80039cc:	4a1a      	ldr	r2, [pc, #104]	@ (8003a38 <HAL_DMAEx_MultiBufferStart_IT+0x1028>)
 80039ce:	4293      	cmp	r3, r2
 80039d0:	d042      	beq.n	8003a58 <HAL_DMAEx_MultiBufferStart_IT+0x1048>
 80039d2:	68fb      	ldr	r3, [r7, #12]
 80039d4:	681b      	ldr	r3, [r3, #0]
 80039d6:	4a19      	ldr	r2, [pc, #100]	@ (8003a3c <HAL_DMAEx_MultiBufferStart_IT+0x102c>)
 80039d8:	4293      	cmp	r3, r2
 80039da:	d01a      	beq.n	8003a12 <HAL_DMAEx_MultiBufferStart_IT+0x1002>
 80039dc:	68fb      	ldr	r3, [r7, #12]
 80039de:	681b      	ldr	r3, [r3, #0]
 80039e0:	4a17      	ldr	r2, [pc, #92]	@ (8003a40 <HAL_DMAEx_MultiBufferStart_IT+0x1030>)
 80039e2:	4293      	cmp	r3, r2
 80039e4:	d012      	beq.n	8003a0c <HAL_DMAEx_MultiBufferStart_IT+0xffc>
 80039e6:	68fb      	ldr	r3, [r7, #12]
 80039e8:	681b      	ldr	r3, [r3, #0]
 80039ea:	4a16      	ldr	r2, [pc, #88]	@ (8003a44 <HAL_DMAEx_MultiBufferStart_IT+0x1034>)
 80039ec:	4293      	cmp	r3, r2
 80039ee:	d00a      	beq.n	8003a06 <HAL_DMAEx_MultiBufferStart_IT+0xff6>
 80039f0:	68fb      	ldr	r3, [r7, #12]
 80039f2:	681b      	ldr	r3, [r3, #0]
 80039f4:	4a14      	ldr	r2, [pc, #80]	@ (8003a48 <HAL_DMAEx_MultiBufferStart_IT+0x1038>)
 80039f6:	4293      	cmp	r3, r2
 80039f8:	d102      	bne.n	8003a00 <HAL_DMAEx_MultiBufferStart_IT+0xff0>
 80039fa:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 80039fe:	e03a      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a00:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003a04:	e037      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a06:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003a0a:	e034      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a0c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003a10:	e031      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a12:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003a16:	e02e      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a18:	40026000 	.word	0x40026000
 8003a1c:	40026010 	.word	0x40026010
 8003a20:	40026410 	.word	0x40026410
 8003a24:	40026070 	.word	0x40026070
 8003a28:	40026470 	.word	0x40026470
 8003a2c:	40026028 	.word	0x40026028
 8003a30:	40026428 	.word	0x40026428
 8003a34:	40026088 	.word	0x40026088
 8003a38:	40026488 	.word	0x40026488
 8003a3c:	40026040 	.word	0x40026040
 8003a40:	40026440 	.word	0x40026440
 8003a44:	400260a0 	.word	0x400260a0
 8003a48:	400264a0 	.word	0x400264a0
 8003a4c:	40026458 	.word	0x40026458
 8003a50:	40026400 	.word	0x40026400
 8003a54:	400260b8 	.word	0x400260b8
 8003a58:	2340      	movs	r3, #64	@ 0x40
 8003a5a:	e00c      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a5c:	2340      	movs	r3, #64	@ 0x40
 8003a5e:	e00a      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a60:	2340      	movs	r3, #64	@ 0x40
 8003a62:	e008      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a64:	2340      	movs	r3, #64	@ 0x40
 8003a66:	e006      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a68:	2301      	movs	r3, #1
 8003a6a:	e004      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a6c:	2301      	movs	r3, #1
 8003a6e:	e002      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a70:	2301      	movs	r3, #1
 8003a72:	e000      	b.n	8003a76 <HAL_DMAEx_MultiBufferStart_IT+0x1066>
 8003a74:	2301      	movs	r3, #1
 8003a76:	4a7b      	ldr	r2, [pc, #492]	@ (8003c64 <HAL_DMAEx_MultiBufferStart_IT+0x1254>)
 8003a78:	6093      	str	r3, [r2, #8]
 8003a7a:	e0be      	b.n	8003bfa <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003a7c:	68fb      	ldr	r3, [r7, #12]
 8003a7e:	681b      	ldr	r3, [r3, #0]
 8003a80:	461a      	mov	r2, r3
 8003a82:	4b79      	ldr	r3, [pc, #484]	@ (8003c68 <HAL_DMAEx_MultiBufferStart_IT+0x1258>)
 8003a84:	429a      	cmp	r2, r3
 8003a86:	d95c      	bls.n	8003b42 <HAL_DMAEx_MultiBufferStart_IT+0x1132>
 8003a88:	68fb      	ldr	r3, [r7, #12]
 8003a8a:	681b      	ldr	r3, [r3, #0]
 8003a8c:	4a77      	ldr	r2, [pc, #476]	@ (8003c6c <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
 8003a8e:	4293      	cmp	r3, r2
 8003a90:	d053      	beq.n	8003b3a <HAL_DMAEx_MultiBufferStart_IT+0x112a>
 8003a92:	68fb      	ldr	r3, [r7, #12]
 8003a94:	681b      	ldr	r3, [r3, #0]
 8003a96:	4a76      	ldr	r2, [pc, #472]	@ (8003c70 <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
 8003a98:	4293      	cmp	r3, r2
 8003a9a:	d04c      	beq.n	8003b36 <HAL_DMAEx_MultiBufferStart_IT+0x1126>
 8003a9c:	68fb      	ldr	r3, [r7, #12]
 8003a9e:	681b      	ldr	r3, [r3, #0]
 8003aa0:	4a74      	ldr	r2, [pc, #464]	@ (8003c74 <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
 8003aa2:	4293      	cmp	r3, r2
 8003aa4:	d045      	beq.n	8003b32 <HAL_DMAEx_MultiBufferStart_IT+0x1122>
 8003aa6:	68fb      	ldr	r3, [r7, #12]
 8003aa8:	681b      	ldr	r3, [r3, #0]
 8003aaa:	4a73      	ldr	r2, [pc, #460]	@ (8003c78 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
 8003aac:	4293      	cmp	r3, r2
 8003aae:	d03e      	beq.n	8003b2e <HAL_DMAEx_MultiBufferStart_IT+0x111e>
 8003ab0:	68fb      	ldr	r3, [r7, #12]
 8003ab2:	681b      	ldr	r3, [r3, #0]
 8003ab4:	4a71      	ldr	r2, [pc, #452]	@ (8003c7c <HAL_DMAEx_MultiBufferStart_IT+0x126c>)
 8003ab6:	4293      	cmp	r3, r2
 8003ab8:	d037      	beq.n	8003b2a <HAL_DMAEx_MultiBufferStart_IT+0x111a>
 8003aba:	68fb      	ldr	r3, [r7, #12]
 8003abc:	681b      	ldr	r3, [r3, #0]
 8003abe:	4a70      	ldr	r2, [pc, #448]	@ (8003c80 <HAL_DMAEx_MultiBufferStart_IT+0x1270>)
 8003ac0:	4293      	cmp	r3, r2
 8003ac2:	d030      	beq.n	8003b26 <HAL_DMAEx_MultiBufferStart_IT+0x1116>
 8003ac4:	68fb      	ldr	r3, [r7, #12]
 8003ac6:	681b      	ldr	r3, [r3, #0]
 8003ac8:	4a6e      	ldr	r2, [pc, #440]	@ (8003c84 <HAL_DMAEx_MultiBufferStart_IT+0x1274>)
 8003aca:	4293      	cmp	r3, r2
 8003acc:	d029      	beq.n	8003b22 <HAL_DMAEx_MultiBufferStart_IT+0x1112>
 8003ace:	68fb      	ldr	r3, [r7, #12]
 8003ad0:	681b      	ldr	r3, [r3, #0]
 8003ad2:	4a6d      	ldr	r2, [pc, #436]	@ (8003c88 <HAL_DMAEx_MultiBufferStart_IT+0x1278>)
 8003ad4:	4293      	cmp	r3, r2
 8003ad6:	d022      	beq.n	8003b1e <HAL_DMAEx_MultiBufferStart_IT+0x110e>
 8003ad8:	68fb      	ldr	r3, [r7, #12]
 8003ada:	681b      	ldr	r3, [r3, #0]
 8003adc:	4a6b      	ldr	r2, [pc, #428]	@ (8003c8c <HAL_DMAEx_MultiBufferStart_IT+0x127c>)
 8003ade:	4293      	cmp	r3, r2
 8003ae0:	d01a      	beq.n	8003b18 <HAL_DMAEx_MultiBufferStart_IT+0x1108>
 8003ae2:	68fb      	ldr	r3, [r7, #12]
 8003ae4:	681b      	ldr	r3, [r3, #0]
 8003ae6:	4a6a      	ldr	r2, [pc, #424]	@ (8003c90 <HAL_DMAEx_MultiBufferStart_IT+0x1280>)
 8003ae8:	4293      	cmp	r3, r2
 8003aea:	d012      	beq.n	8003b12 <HAL_DMAEx_MultiBufferStart_IT+0x1102>
 8003aec:	68fb      	ldr	r3, [r7, #12]
 8003aee:	681b      	ldr	r3, [r3, #0]
 8003af0:	4a68      	ldr	r2, [pc, #416]	@ (8003c94 <HAL_DMAEx_MultiBufferStart_IT+0x1284>)
 8003af2:	4293      	cmp	r3, r2
 8003af4:	d00a      	beq.n	8003b0c <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 8003af6:	68fb      	ldr	r3, [r7, #12]
 8003af8:	681b      	ldr	r3, [r3, #0]
 8003afa:	4a67      	ldr	r2, [pc, #412]	@ (8003c98 <HAL_DMAEx_MultiBufferStart_IT+0x1288>)
 8003afc:	4293      	cmp	r3, r2
 8003afe:	d102      	bne.n	8003b06 <HAL_DMAEx_MultiBufferStart_IT+0x10f6>
 8003b00:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b04:	e01a      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b06:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003b0a:	e017      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b0c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b10:	e014      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b12:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b16:	e011      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b18:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003b1c:	e00e      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b1e:	2340      	movs	r3, #64	@ 0x40
 8003b20:	e00c      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b22:	2340      	movs	r3, #64	@ 0x40
 8003b24:	e00a      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b26:	2340      	movs	r3, #64	@ 0x40
 8003b28:	e008      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b2a:	2340      	movs	r3, #64	@ 0x40
 8003b2c:	e006      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b2e:	2301      	movs	r3, #1
 8003b30:	e004      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b32:	2301      	movs	r3, #1
 8003b34:	e002      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b36:	2301      	movs	r3, #1
 8003b38:	e000      	b.n	8003b3c <HAL_DMAEx_MultiBufferStart_IT+0x112c>
 8003b3a:	2301      	movs	r3, #1
 8003b3c:	4a57      	ldr	r2, [pc, #348]	@ (8003c9c <HAL_DMAEx_MultiBufferStart_IT+0x128c>)
 8003b3e:	60d3      	str	r3, [r2, #12]
 8003b40:	e05b      	b.n	8003bfa <HAL_DMAEx_MultiBufferStart_IT+0x11ea>
 8003b42:	68fb      	ldr	r3, [r7, #12]
 8003b44:	681b      	ldr	r3, [r3, #0]
 8003b46:	4a49      	ldr	r2, [pc, #292]	@ (8003c6c <HAL_DMAEx_MultiBufferStart_IT+0x125c>)
 8003b48:	4293      	cmp	r3, r2
 8003b4a:	d053      	beq.n	8003bf4 <HAL_DMAEx_MultiBufferStart_IT+0x11e4>
 8003b4c:	68fb      	ldr	r3, [r7, #12]
 8003b4e:	681b      	ldr	r3, [r3, #0]
 8003b50:	4a47      	ldr	r2, [pc, #284]	@ (8003c70 <HAL_DMAEx_MultiBufferStart_IT+0x1260>)
 8003b52:	4293      	cmp	r3, r2
 8003b54:	d04c      	beq.n	8003bf0 <HAL_DMAEx_MultiBufferStart_IT+0x11e0>
 8003b56:	68fb      	ldr	r3, [r7, #12]
 8003b58:	681b      	ldr	r3, [r3, #0]
 8003b5a:	4a46      	ldr	r2, [pc, #280]	@ (8003c74 <HAL_DMAEx_MultiBufferStart_IT+0x1264>)
 8003b5c:	4293      	cmp	r3, r2
 8003b5e:	d045      	beq.n	8003bec <HAL_DMAEx_MultiBufferStart_IT+0x11dc>
 8003b60:	68fb      	ldr	r3, [r7, #12]
 8003b62:	681b      	ldr	r3, [r3, #0]
 8003b64:	4a44      	ldr	r2, [pc, #272]	@ (8003c78 <HAL_DMAEx_MultiBufferStart_IT+0x1268>)
 8003b66:	4293      	cmp	r3, r2
 8003b68:	d03e      	beq.n	8003be8 <HAL_DMAEx_MultiBufferStart_IT+0x11d8>
 8003b6a:	68fb      	ldr	r3, [r7, #12]
 8003b6c:	681b      	ldr	r3, [r3, #0]
 8003b6e:	4a43      	ldr	r2, [pc, #268]	@ (8003c7c <HAL_DMAEx_MultiBufferStart_IT+0x126c>)
 8003b70:	4293      	cmp	r3, r2
 8003b72:	d037      	beq.n	8003be4 <HAL_DMAEx_MultiBufferStart_IT+0x11d4>
 8003b74:	68fb      	ldr	r3, [r7, #12]
 8003b76:	681b      	ldr	r3, [r3, #0]
 8003b78:	4a41      	ldr	r2, [pc, #260]	@ (8003c80 <HAL_DMAEx_MultiBufferStart_IT+0x1270>)
 8003b7a:	4293      	cmp	r3, r2
 8003b7c:	d030      	beq.n	8003be0 <HAL_DMAEx_MultiBufferStart_IT+0x11d0>
 8003b7e:	68fb      	ldr	r3, [r7, #12]
 8003b80:	681b      	ldr	r3, [r3, #0]
 8003b82:	4a40      	ldr	r2, [pc, #256]	@ (8003c84 <HAL_DMAEx_MultiBufferStart_IT+0x1274>)
 8003b84:	4293      	cmp	r3, r2
 8003b86:	d029      	beq.n	8003bdc <HAL_DMAEx_MultiBufferStart_IT+0x11cc>
 8003b88:	68fb      	ldr	r3, [r7, #12]
 8003b8a:	681b      	ldr	r3, [r3, #0]
 8003b8c:	4a3e      	ldr	r2, [pc, #248]	@ (8003c88 <HAL_DMAEx_MultiBufferStart_IT+0x1278>)
 8003b8e:	4293      	cmp	r3, r2
 8003b90:	d022      	beq.n	8003bd8 <HAL_DMAEx_MultiBufferStart_IT+0x11c8>
 8003b92:	68fb      	ldr	r3, [r7, #12]
 8003b94:	681b      	ldr	r3, [r3, #0]
 8003b96:	4a3d      	ldr	r2, [pc, #244]	@ (8003c8c <HAL_DMAEx_MultiBufferStart_IT+0x127c>)
 8003b98:	4293      	cmp	r3, r2
 8003b9a:	d01a      	beq.n	8003bd2 <HAL_DMAEx_MultiBufferStart_IT+0x11c2>
 8003b9c:	68fb      	ldr	r3, [r7, #12]
 8003b9e:	681b      	ldr	r3, [r3, #0]
 8003ba0:	4a3b      	ldr	r2, [pc, #236]	@ (8003c90 <HAL_DMAEx_MultiBufferStart_IT+0x1280>)
 8003ba2:	4293      	cmp	r3, r2
 8003ba4:	d012      	beq.n	8003bcc <HAL_DMAEx_MultiBufferStart_IT+0x11bc>
 8003ba6:	68fb      	ldr	r3, [r7, #12]
 8003ba8:	681b      	ldr	r3, [r3, #0]
 8003baa:	4a3a      	ldr	r2, [pc, #232]	@ (8003c94 <HAL_DMAEx_MultiBufferStart_IT+0x1284>)
 8003bac:	4293      	cmp	r3, r2
 8003bae:	d00a      	beq.n	8003bc6 <HAL_DMAEx_MultiBufferStart_IT+0x11b6>
 8003bb0:	68fb      	ldr	r3, [r7, #12]
 8003bb2:	681b      	ldr	r3, [r3, #0]
 8003bb4:	4a38      	ldr	r2, [pc, #224]	@ (8003c98 <HAL_DMAEx_MultiBufferStart_IT+0x1288>)
 8003bb6:	4293      	cmp	r3, r2
 8003bb8:	d102      	bne.n	8003bc0 <HAL_DMAEx_MultiBufferStart_IT+0x11b0>
 8003bba:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bbe:	e01a      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bc0:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8003bc4:	e017      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bc6:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bca:	e014      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bcc:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bd0:	e011      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bd2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8003bd6:	e00e      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bd8:	2340      	movs	r3, #64	@ 0x40
 8003bda:	e00c      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bdc:	2340      	movs	r3, #64	@ 0x40
 8003bde:	e00a      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003be0:	2340      	movs	r3, #64	@ 0x40
 8003be2:	e008      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003be4:	2340      	movs	r3, #64	@ 0x40
 8003be6:	e006      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003be8:	2301      	movs	r3, #1
 8003bea:	e004      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bec:	2301      	movs	r3, #1
 8003bee:	e002      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bf0:	2301      	movs	r3, #1
 8003bf2:	e000      	b.n	8003bf6 <HAL_DMAEx_MultiBufferStart_IT+0x11e6>
 8003bf4:	2301      	movs	r3, #1
 8003bf6:	4a29      	ldr	r2, [pc, #164]	@ (8003c9c <HAL_DMAEx_MultiBufferStart_IT+0x128c>)
 8003bf8:	6093      	str	r3, [r2, #8]

    /* Enable Common interrupts*/
    hdma->Instance->CR.reg  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8003bfa:	68fb      	ldr	r3, [r7, #12]
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	681a      	ldr	r2, [r3, #0]
 8003c00:	68fb      	ldr	r3, [r7, #12]
 8003c02:	681b      	ldr	r3, [r3, #0]
 8003c04:	f042 0216 	orr.w	r2, r2, #22
 8003c08:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR.reg |= DMA_IT_FE;
 8003c0a:	68fb      	ldr	r3, [r7, #12]
 8003c0c:	681b      	ldr	r3, [r3, #0]
 8003c0e:	695a      	ldr	r2, [r3, #20]
 8003c10:	68fb      	ldr	r3, [r7, #12]
 8003c12:	681b      	ldr	r3, [r3, #0]
 8003c14:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8003c18:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8003c1a:	68fb      	ldr	r3, [r7, #12]
 8003c1c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8003c1e:	2b00      	cmp	r3, #0
 8003c20:	d103      	bne.n	8003c2a <HAL_DMAEx_MultiBufferStart_IT+0x121a>
 8003c22:	68fb      	ldr	r3, [r7, #12]
 8003c24:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003c26:	2b00      	cmp	r3, #0
 8003c28:	d007      	beq.n	8003c3a <HAL_DMAEx_MultiBufferStart_IT+0x122a>
    {
      hdma->Instance->CR.reg  |= DMA_IT_HT;
 8003c2a:	68fb      	ldr	r3, [r7, #12]
 8003c2c:	681b      	ldr	r3, [r3, #0]
 8003c2e:	681a      	ldr	r2, [r3, #0]
 8003c30:	68fb      	ldr	r3, [r7, #12]
 8003c32:	681b      	ldr	r3, [r3, #0]
 8003c34:	f042 0208 	orr.w	r2, r2, #8
 8003c38:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma); 
 8003c3a:	68fb      	ldr	r3, [r7, #12]
 8003c3c:	681b      	ldr	r3, [r3, #0]
 8003c3e:	681a      	ldr	r2, [r3, #0]
 8003c40:	68fb      	ldr	r3, [r7, #12]
 8003c42:	681b      	ldr	r3, [r3, #0]
 8003c44:	f042 0201 	orr.w	r2, r2, #1
 8003c48:	601a      	str	r2, [r3, #0]
 8003c4a:	e005      	b.n	8003c58 <HAL_DMAEx_MultiBufferStart_IT+0x1248>
  }
  else
  {     
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8003c4c:	68fb      	ldr	r3, [r7, #12]
 8003c4e:	2200      	movs	r2, #0
 8003c50:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 8003c54:	2302      	movs	r3, #2
 8003c56:	75fb      	strb	r3, [r7, #23]
  }  
  return status; 
 8003c58:	7dfb      	ldrb	r3, [r7, #23]
}
 8003c5a:	4618      	mov	r0, r3
 8003c5c:	3718      	adds	r7, #24
 8003c5e:	46bd      	mov	sp, r7
 8003c60:	bd80      	pop	{r7, pc}
 8003c62:	bf00      	nop
 8003c64:	40026400 	.word	0x40026400
 8003c68:	40026058 	.word	0x40026058
 8003c6c:	40026010 	.word	0x40026010
 8003c70:	40026410 	.word	0x40026410
 8003c74:	40026070 	.word	0x40026070
 8003c78:	40026470 	.word	0x40026470
 8003c7c:	40026028 	.word	0x40026028
 8003c80:	40026428 	.word	0x40026428
 8003c84:	40026088 	.word	0x40026088
 8003c88:	40026488 	.word	0x40026488
 8003c8c:	40026040 	.word	0x40026040
 8003c90:	40026440 	.word	0x40026440
 8003c94:	400260a0 	.word	0x400260a0
 8003c98:	400264a0 	.word	0x400264a0
 8003c9c:	40026000 	.word	0x40026000

08003ca0 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current 
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
 8003ca0:	b480      	push	{r7}
 8003ca2:	b085      	sub	sp, #20
 8003ca4:	af00      	add	r7, sp, #0
 8003ca6:	60f8      	str	r0, [r7, #12]
 8003ca8:	60b9      	str	r1, [r7, #8]
 8003caa:	4613      	mov	r3, r2
 8003cac:	71fb      	strb	r3, [r7, #7]
  if(memory == MEMORY0)
 8003cae:	79fb      	ldrb	r3, [r7, #7]
 8003cb0:	2b00      	cmp	r3, #0
 8003cb2:	d104      	bne.n	8003cbe <HAL_DMAEx_ChangeMemory+0x1e>
  {
    /* change the memory0 address */
    hdma->Instance->M0AR = Address;
 8003cb4:	68fb      	ldr	r3, [r7, #12]
 8003cb6:	681b      	ldr	r3, [r3, #0]
 8003cb8:	68ba      	ldr	r2, [r7, #8]
 8003cba:	60da      	str	r2, [r3, #12]
 8003cbc:	e003      	b.n	8003cc6 <HAL_DMAEx_ChangeMemory+0x26>
  }
  else
  {
    /* change the memory1 address */
    hdma->Instance->M1AR = Address;
 8003cbe:	68fb      	ldr	r3, [r7, #12]
 8003cc0:	681b      	ldr	r3, [r3, #0]
 8003cc2:	68ba      	ldr	r2, [r7, #8]
 8003cc4:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
 8003cc6:	2300      	movs	r3, #0
}
 8003cc8:	4618      	mov	r0, r3
 8003cca:	3714      	adds	r7, #20
 8003ccc:	46bd      	mov	sp, r7
 8003cce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cd2:	4770      	bx	lr

08003cd4 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{  
 8003cd4:	b480      	push	{r7}
 8003cd6:	b085      	sub	sp, #20
 8003cd8:	af00      	add	r7, sp, #0
 8003cda:	60f8      	str	r0, [r7, #12]
 8003cdc:	60b9      	str	r1, [r7, #8]
 8003cde:	607a      	str	r2, [r7, #4]
 8003ce0:	603b      	str	r3, [r7, #0]
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR.reg = DataLength;
 8003ce2:	68fb      	ldr	r3, [r7, #12]
 8003ce4:	681b      	ldr	r3, [r3, #0]
 8003ce6:	683a      	ldr	r2, [r7, #0]
 8003ce8:	605a      	str	r2, [r3, #4]
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003cea:	68fb      	ldr	r3, [r7, #12]
 8003cec:	689b      	ldr	r3, [r3, #8]
 8003cee:	2b40      	cmp	r3, #64	@ 0x40
 8003cf0:	d108      	bne.n	8003d04 <DMA_MultiBufferSetConfig+0x30>
  {   
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8003cf2:	68fb      	ldr	r3, [r7, #12]
 8003cf4:	681b      	ldr	r3, [r3, #0]
 8003cf6:	687a      	ldr	r2, [r7, #4]
 8003cf8:	609a      	str	r2, [r3, #8]
    
    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8003cfa:	68fb      	ldr	r3, [r7, #12]
 8003cfc:	681b      	ldr	r3, [r3, #0]
 8003cfe:	68ba      	ldr	r2, [r7, #8]
 8003d00:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 8003d02:	e007      	b.n	8003d14 <DMA_MultiBufferSetConfig+0x40>
    hdma->Instance->PAR = SrcAddress;
 8003d04:	68fb      	ldr	r3, [r7, #12]
 8003d06:	681b      	ldr	r3, [r3, #0]
 8003d08:	68ba      	ldr	r2, [r7, #8]
 8003d0a:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 8003d0c:	68fb      	ldr	r3, [r7, #12]
 8003d0e:	681b      	ldr	r3, [r3, #0]
 8003d10:	687a      	ldr	r2, [r7, #4]
 8003d12:	60da      	str	r2, [r3, #12]
}
 8003d14:	bf00      	nop
 8003d16:	3714      	adds	r7, #20
 8003d18:	46bd      	mov	sp, r7
 8003d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d1e:	4770      	bx	lr

08003d20 <HAL_HCD_Init>:
  * @brief  Initialize the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
{
 8003d20:	b580      	push	{r7, lr}
 8003d22:	b086      	sub	sp, #24
 8003d24:	af02      	add	r7, sp, #8
 8003d26:	6078      	str	r0, [r7, #4]
#if defined (USB_OTG_FS)
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */

  /* Check the HCD handle allocation */
  if (hhcd == NULL)
 8003d28:	687b      	ldr	r3, [r7, #4]
 8003d2a:	2b00      	cmp	r3, #0
 8003d2c:	d101      	bne.n	8003d32 <HAL_HCD_Init+0x12>
  {
    return HAL_ERROR;
 8003d2e:	2301      	movs	r3, #1
 8003d30:	e059      	b.n	8003de6 <HAL_HCD_Init+0xc6>

  /* Check the parameters */
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hhcd->Instance;
 8003d32:	687b      	ldr	r3, [r7, #4]
 8003d34:	681b      	ldr	r3, [r3, #0]
 8003d36:	60fb      	str	r3, [r7, #12]
#endif /* defined (USB_OTG_FS) */

  if (hhcd->State == HAL_HCD_STATE_RESET)
 8003d38:	687b      	ldr	r3, [r7, #4]
 8003d3a:	f893 33d5 	ldrb.w	r3, [r3, #981]	@ 0x3d5
 8003d3e:	b2db      	uxtb	r3, r3
 8003d40:	2b00      	cmp	r3, #0
 8003d42:	d106      	bne.n	8003d52 <HAL_HCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hhcd->Lock = HAL_UNLOCKED;
 8003d44:	687b      	ldr	r3, [r7, #4]
 8003d46:	2200      	movs	r2, #0
 8003d48:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

    /* Init the low level hardware */
    hhcd->MspInitCallback(hhcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_HCD_MspInit(hhcd);
 8003d4c:	6878      	ldr	r0, [r7, #4]
 8003d4e:	f02b fa77 	bl	802f240 <HAL_HCD_MspInit>
#endif /* (USE_HAL_HCD_REGISTER_CALLBACKS) */
  }

  hhcd->State = HAL_HCD_STATE_BUSY;
 8003d52:	687b      	ldr	r3, [r7, #4]
 8003d54:	2203      	movs	r2, #3
 8003d56:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 8003d5a:	68fb      	ldr	r3, [r7, #12]
 8003d5c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003d60:	d102      	bne.n	8003d68 <HAL_HCD_Init+0x48>
  {
    hhcd->Init.dma_enable = 0U;
 8003d62:	687b      	ldr	r3, [r7, #4]
 8003d64:	2200      	movs	r2, #0
 8003d66:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_HCD_DISABLE(hhcd);
 8003d68:	687b      	ldr	r3, [r7, #4]
 8003d6a:	681b      	ldr	r3, [r3, #0]
 8003d6c:	4618      	mov	r0, r3
 8003d6e:	f002 ff2a 	bl	8006bc6 <USB_DisableGlobalInt>

  /* Init the Core (common init.) */
  if (USB_CoreInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 8003d72:	687b      	ldr	r3, [r7, #4]
 8003d74:	6818      	ldr	r0, [r3, #0]
 8003d76:	687b      	ldr	r3, [r7, #4]
 8003d78:	7c1a      	ldrb	r2, [r3, #16]
 8003d7a:	f88d 2000 	strb.w	r2, [sp]
 8003d7e:	3304      	adds	r3, #4
 8003d80:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003d82:	f002 feab 	bl	8006adc <USB_CoreInit>
 8003d86:	4603      	mov	r3, r0
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	d005      	beq.n	8003d98 <HAL_HCD_Init+0x78>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003d8c:	687b      	ldr	r3, [r7, #4]
 8003d8e:	2202      	movs	r2, #2
 8003d90:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003d94:	2301      	movs	r3, #1
 8003d96:	e026      	b.n	8003de6 <HAL_HCD_Init+0xc6>
  }

  /* Force Host Mode */
  if (USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE) != HAL_OK)
 8003d98:	687b      	ldr	r3, [r7, #4]
 8003d9a:	681b      	ldr	r3, [r3, #0]
 8003d9c:	2101      	movs	r1, #1
 8003d9e:	4618      	mov	r0, r3
 8003da0:	f002 ff22 	bl	8006be8 <USB_SetCurrentMode>
 8003da4:	4603      	mov	r3, r0
 8003da6:	2b00      	cmp	r3, #0
 8003da8:	d005      	beq.n	8003db6 <HAL_HCD_Init+0x96>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003daa:	687b      	ldr	r3, [r7, #4]
 8003dac:	2202      	movs	r2, #2
 8003dae:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003db2:	2301      	movs	r3, #1
 8003db4:	e017      	b.n	8003de6 <HAL_HCD_Init+0xc6>
  }

  /* Init Host */
  if (USB_HostInit(hhcd->Instance, hhcd->Init) != HAL_OK)
 8003db6:	687b      	ldr	r3, [r7, #4]
 8003db8:	6818      	ldr	r0, [r3, #0]
 8003dba:	687b      	ldr	r3, [r7, #4]
 8003dbc:	7c1a      	ldrb	r2, [r3, #16]
 8003dbe:	f88d 2000 	strb.w	r2, [sp]
 8003dc2:	3304      	adds	r3, #4
 8003dc4:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003dc6:	f003 f8c5 	bl	8006f54 <USB_HostInit>
 8003dca:	4603      	mov	r3, r0
 8003dcc:	2b00      	cmp	r3, #0
 8003dce:	d005      	beq.n	8003ddc <HAL_HCD_Init+0xbc>
  {
    hhcd->State = HAL_HCD_STATE_ERROR;
 8003dd0:	687b      	ldr	r3, [r7, #4]
 8003dd2:	2202      	movs	r2, #2
 8003dd4:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5
    return HAL_ERROR;
 8003dd8:	2301      	movs	r3, #1
 8003dda:	e004      	b.n	8003de6 <HAL_HCD_Init+0xc6>
  }

  hhcd->State = HAL_HCD_STATE_READY;
 8003ddc:	687b      	ldr	r3, [r7, #4]
 8003dde:	2201      	movs	r2, #1
 8003de0:	f883 23d5 	strb.w	r2, [r3, #981]	@ 0x3d5

  return HAL_OK;
 8003de4:	2300      	movs	r3, #0
}
 8003de6:	4618      	mov	r0, r3
 8003de8:	3710      	adds	r7, #16
 8003dea:	46bd      	mov	sp, r7
 8003dec:	bd80      	pop	{r7, pc}

08003dee <HAL_HCD_HC_Init>:
  *          This parameter can be a value from 0 to32K
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd, uint8_t ch_num, uint8_t epnum,
                                  uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8003dee:	b590      	push	{r4, r7, lr}
 8003df0:	b08b      	sub	sp, #44	@ 0x2c
 8003df2:	af04      	add	r7, sp, #16
 8003df4:	6078      	str	r0, [r7, #4]
 8003df6:	4608      	mov	r0, r1
 8003df8:	4611      	mov	r1, r2
 8003dfa:	461a      	mov	r2, r3
 8003dfc:	4603      	mov	r3, r0
 8003dfe:	70fb      	strb	r3, [r7, #3]
 8003e00:	460b      	mov	r3, r1
 8003e02:	70bb      	strb	r3, [r7, #2]
 8003e04:	4613      	mov	r3, r2
 8003e06:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef status;
  uint32_t HostCoreSpeed;
  uint32_t HCcharMps = mps;
 8003e08:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
 8003e0a:	617b      	str	r3, [r7, #20]

  __HAL_LOCK(hhcd);
 8003e0c:	687b      	ldr	r3, [r7, #4]
 8003e0e:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8003e12:	2b01      	cmp	r3, #1
 8003e14:	d101      	bne.n	8003e1a <HAL_HCD_HC_Init+0x2c>
 8003e16:	2302      	movs	r3, #2
 8003e18:	e09d      	b.n	8003f56 <HAL_HCD_HC_Init+0x168>
 8003e1a:	687b      	ldr	r3, [r7, #4]
 8003e1c:	2201      	movs	r2, #1
 8003e1e:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  hhcd->hc[ch_num].do_ping = 0U;
 8003e22:	78fa      	ldrb	r2, [r7, #3]
 8003e24:	6879      	ldr	r1, [r7, #4]
 8003e26:	4613      	mov	r3, r2
 8003e28:	011b      	lsls	r3, r3, #4
 8003e2a:	1a9b      	subs	r3, r3, r2
 8003e2c:	009b      	lsls	r3, r3, #2
 8003e2e:	440b      	add	r3, r1
 8003e30:	3319      	adds	r3, #25
 8003e32:	2200      	movs	r2, #0
 8003e34:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].dev_addr = dev_address;
 8003e36:	78fa      	ldrb	r2, [r7, #3]
 8003e38:	6879      	ldr	r1, [r7, #4]
 8003e3a:	4613      	mov	r3, r2
 8003e3c:	011b      	lsls	r3, r3, #4
 8003e3e:	1a9b      	subs	r3, r3, r2
 8003e40:	009b      	lsls	r3, r3, #2
 8003e42:	440b      	add	r3, r1
 8003e44:	3314      	adds	r3, #20
 8003e46:	787a      	ldrb	r2, [r7, #1]
 8003e48:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 8003e4a:	78fa      	ldrb	r2, [r7, #3]
 8003e4c:	6879      	ldr	r1, [r7, #4]
 8003e4e:	4613      	mov	r3, r2
 8003e50:	011b      	lsls	r3, r3, #4
 8003e52:	1a9b      	subs	r3, r3, r2
 8003e54:	009b      	lsls	r3, r3, #2
 8003e56:	440b      	add	r3, r1
 8003e58:	3315      	adds	r3, #21
 8003e5a:	78fa      	ldrb	r2, [r7, #3]
 8003e5c:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type = ep_type;
 8003e5e:	78fa      	ldrb	r2, [r7, #3]
 8003e60:	6879      	ldr	r1, [r7, #4]
 8003e62:	4613      	mov	r3, r2
 8003e64:	011b      	lsls	r3, r3, #4
 8003e66:	1a9b      	subs	r3, r3, r2
 8003e68:	009b      	lsls	r3, r3, #2
 8003e6a:	440b      	add	r3, r1
 8003e6c:	3326      	adds	r3, #38	@ 0x26
 8003e6e:	f897 202c 	ldrb.w	r2, [r7, #44]	@ 0x2c
 8003e72:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 8003e74:	78fa      	ldrb	r2, [r7, #3]
 8003e76:	78bb      	ldrb	r3, [r7, #2]
 8003e78:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003e7c:	b2d8      	uxtb	r0, r3
 8003e7e:	6879      	ldr	r1, [r7, #4]
 8003e80:	4613      	mov	r3, r2
 8003e82:	011b      	lsls	r3, r3, #4
 8003e84:	1a9b      	subs	r3, r3, r2
 8003e86:	009b      	lsls	r3, r3, #2
 8003e88:	440b      	add	r3, r1
 8003e8a:	3316      	adds	r3, #22
 8003e8c:	4602      	mov	r2, r0
 8003e8e:	701a      	strb	r2, [r3, #0]

  (void)HAL_HCD_HC_ClearHubInfo(hhcd, ch_num);
 8003e90:	78fb      	ldrb	r3, [r7, #3]
 8003e92:	4619      	mov	r1, r3
 8003e94:	6878      	ldr	r0, [r7, #4]
 8003e96:	f000 fbc7 	bl	8004628 <HAL_HCD_HC_ClearHubInfo>

  if ((epnum & 0x80U) == 0x80U)
 8003e9a:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8003e9e:	2b00      	cmp	r3, #0
 8003ea0:	da0a      	bge.n	8003eb8 <HAL_HCD_HC_Init+0xca>
  {
    hhcd->hc[ch_num].ep_is_in = 1U;
 8003ea2:	78fa      	ldrb	r2, [r7, #3]
 8003ea4:	6879      	ldr	r1, [r7, #4]
 8003ea6:	4613      	mov	r3, r2
 8003ea8:	011b      	lsls	r3, r3, #4
 8003eaa:	1a9b      	subs	r3, r3, r2
 8003eac:	009b      	lsls	r3, r3, #2
 8003eae:	440b      	add	r3, r1
 8003eb0:	3317      	adds	r3, #23
 8003eb2:	2201      	movs	r2, #1
 8003eb4:	701a      	strb	r2, [r3, #0]
 8003eb6:	e009      	b.n	8003ecc <HAL_HCD_HC_Init+0xde>
  }
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
 8003eb8:	78fa      	ldrb	r2, [r7, #3]
 8003eba:	6879      	ldr	r1, [r7, #4]
 8003ebc:	4613      	mov	r3, r2
 8003ebe:	011b      	lsls	r3, r3, #4
 8003ec0:	1a9b      	subs	r3, r3, r2
 8003ec2:	009b      	lsls	r3, r3, #2
 8003ec4:	440b      	add	r3, r1
 8003ec6:	3317      	adds	r3, #23
 8003ec8:	2200      	movs	r2, #0
 8003eca:	701a      	strb	r2, [r3, #0]
  }

  HostCoreSpeed = USB_GetHostSpeed(hhcd->Instance);
 8003ecc:	687b      	ldr	r3, [r7, #4]
 8003ece:	681b      	ldr	r3, [r3, #0]
 8003ed0:	4618      	mov	r0, r3
 8003ed2:	f003 f9a3 	bl	800721c <USB_GetHostSpeed>
 8003ed6:	6138      	str	r0, [r7, #16]

  if (ep_type == EP_TYPE_ISOC)
 8003ed8:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8003edc:	2b01      	cmp	r3, #1
 8003ede:	d10b      	bne.n	8003ef8 <HAL_HCD_HC_Init+0x10a>
  {
    /* FS device plugged to HS HUB */
    if ((speed == HCD_DEVICE_SPEED_FULL) && (HostCoreSpeed == HPRT0_PRTSPD_HIGH_SPEED))
 8003ee0:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8003ee4:	2b01      	cmp	r3, #1
 8003ee6:	d107      	bne.n	8003ef8 <HAL_HCD_HC_Init+0x10a>
 8003ee8:	693b      	ldr	r3, [r7, #16]
 8003eea:	2b00      	cmp	r3, #0
 8003eec:	d104      	bne.n	8003ef8 <HAL_HCD_HC_Init+0x10a>
    {
      if (HCcharMps > ISO_SPLT_MPS)
 8003eee:	697b      	ldr	r3, [r7, #20]
 8003ef0:	2bbc      	cmp	r3, #188	@ 0xbc
 8003ef2:	d901      	bls.n	8003ef8 <HAL_HCD_HC_Init+0x10a>
      {
        /* ISO Max Packet Size for Split mode */
        HCcharMps = ISO_SPLT_MPS;
 8003ef4:	23bc      	movs	r3, #188	@ 0xbc
 8003ef6:	617b      	str	r3, [r7, #20]
      }
    }
  }

  hhcd->hc[ch_num].speed = speed;
 8003ef8:	78fa      	ldrb	r2, [r7, #3]
 8003efa:	6879      	ldr	r1, [r7, #4]
 8003efc:	4613      	mov	r3, r2
 8003efe:	011b      	lsls	r3, r3, #4
 8003f00:	1a9b      	subs	r3, r3, r2
 8003f02:	009b      	lsls	r3, r3, #2
 8003f04:	440b      	add	r3, r1
 8003f06:	3318      	adds	r3, #24
 8003f08:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
 8003f0c:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 8003f0e:	78fa      	ldrb	r2, [r7, #3]
 8003f10:	697b      	ldr	r3, [r7, #20]
 8003f12:	b298      	uxth	r0, r3
 8003f14:	6879      	ldr	r1, [r7, #4]
 8003f16:	4613      	mov	r3, r2
 8003f18:	011b      	lsls	r3, r3, #4
 8003f1a:	1a9b      	subs	r3, r3, r2
 8003f1c:	009b      	lsls	r3, r3, #2
 8003f1e:	440b      	add	r3, r1
 8003f20:	3328      	adds	r3, #40	@ 0x28
 8003f22:	4602      	mov	r2, r0
 8003f24:	801a      	strh	r2, [r3, #0]

  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 8003f26:	687b      	ldr	r3, [r7, #4]
 8003f28:	6818      	ldr	r0, [r3, #0]
 8003f2a:	697b      	ldr	r3, [r7, #20]
 8003f2c:	b29b      	uxth	r3, r3
 8003f2e:	787c      	ldrb	r4, [r7, #1]
 8003f30:	78ba      	ldrb	r2, [r7, #2]
 8003f32:	78f9      	ldrb	r1, [r7, #3]
 8003f34:	9302      	str	r3, [sp, #8]
 8003f36:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8003f3a:	9301      	str	r3, [sp, #4]
 8003f3c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8003f40:	9300      	str	r3, [sp, #0]
 8003f42:	4623      	mov	r3, r4
 8003f44:	f003 f992 	bl	800726c <USB_HC_Init>
 8003f48:	4603      	mov	r3, r0
 8003f4a:	73fb      	strb	r3, [r7, #15]
                        dev_address, speed, ep_type, (uint16_t)HCcharMps);

  __HAL_UNLOCK(hhcd);
 8003f4c:	687b      	ldr	r3, [r7, #4]
 8003f4e:	2200      	movs	r2, #0
 8003f50:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return status;
 8003f54:	7bfb      	ldrb	r3, [r7, #15]
}
 8003f56:	4618      	mov	r0, r3
 8003f58:	371c      	adds	r7, #28
 8003f5a:	46bd      	mov	sp, r7
 8003f5c:	bd90      	pop	{r4, r7, pc}

08003f5e <HAL_HCD_HC_Halt>:
  * @param  ch_num Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
 8003f5e:	b580      	push	{r7, lr}
 8003f60:	b084      	sub	sp, #16
 8003f62:	af00      	add	r7, sp, #0
 8003f64:	6078      	str	r0, [r7, #4]
 8003f66:	460b      	mov	r3, r1
 8003f68:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
 8003f6a:	2300      	movs	r3, #0
 8003f6c:	73fb      	strb	r3, [r7, #15]

  __HAL_LOCK(hhcd);
 8003f6e:	687b      	ldr	r3, [r7, #4]
 8003f70:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8003f74:	2b01      	cmp	r3, #1
 8003f76:	d101      	bne.n	8003f7c <HAL_HCD_HC_Halt+0x1e>
 8003f78:	2302      	movs	r3, #2
 8003f7a:	e00f      	b.n	8003f9c <HAL_HCD_HC_Halt+0x3e>
 8003f7c:	687b      	ldr	r3, [r7, #4]
 8003f7e:	2201      	movs	r2, #1
 8003f80:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  (void)USB_HC_Halt(hhcd->Instance, ch_num);
 8003f84:	687b      	ldr	r3, [r7, #4]
 8003f86:	681b      	ldr	r3, [r3, #0]
 8003f88:	78fa      	ldrb	r2, [r7, #3]
 8003f8a:	4611      	mov	r1, r2
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	f003 fd24 	bl	80079da <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 8003f92:	687b      	ldr	r3, [r7, #4]
 8003f94:	2200      	movs	r2, #0
 8003f96:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return status;
 8003f9a:	7bfb      	ldrb	r3, [r7, #15]
}
 8003f9c:	4618      	mov	r0, r3
 8003f9e:	3710      	adds	r7, #16
 8003fa0:	46bd      	mov	sp, r7
 8003fa2:	bd80      	pop	{r7, pc}

08003fa4 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 8003fa4:	b580      	push	{r7, lr}
 8003fa6:	b082      	sub	sp, #8
 8003fa8:	af00      	add	r7, sp, #0
 8003faa:	6078      	str	r0, [r7, #4]
 8003fac:	4608      	mov	r0, r1
 8003fae:	4611      	mov	r1, r2
 8003fb0:	461a      	mov	r2, r3
 8003fb2:	4603      	mov	r3, r0
 8003fb4:	70fb      	strb	r3, [r7, #3]
 8003fb6:	460b      	mov	r3, r1
 8003fb8:	70bb      	strb	r3, [r7, #2]
 8003fba:	4613      	mov	r3, r2
 8003fbc:	707b      	strb	r3, [r7, #1]
  hhcd->hc[ch_num].ep_is_in = direction;
 8003fbe:	78fa      	ldrb	r2, [r7, #3]
 8003fc0:	6879      	ldr	r1, [r7, #4]
 8003fc2:	4613      	mov	r3, r2
 8003fc4:	011b      	lsls	r3, r3, #4
 8003fc6:	1a9b      	subs	r3, r3, r2
 8003fc8:	009b      	lsls	r3, r3, #2
 8003fca:	440b      	add	r3, r1
 8003fcc:	3317      	adds	r3, #23
 8003fce:	78ba      	ldrb	r2, [r7, #2]
 8003fd0:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type  = ep_type;
 8003fd2:	78fa      	ldrb	r2, [r7, #3]
 8003fd4:	6879      	ldr	r1, [r7, #4]
 8003fd6:	4613      	mov	r3, r2
 8003fd8:	011b      	lsls	r3, r3, #4
 8003fda:	1a9b      	subs	r3, r3, r2
 8003fdc:	009b      	lsls	r3, r3, #2
 8003fde:	440b      	add	r3, r1
 8003fe0:	3326      	adds	r3, #38	@ 0x26
 8003fe2:	787a      	ldrb	r2, [r7, #1]
 8003fe4:	701a      	strb	r2, [r3, #0]

  if (token == 0U)
 8003fe6:	7c3b      	ldrb	r3, [r7, #16]
 8003fe8:	2b00      	cmp	r3, #0
 8003fea:	d114      	bne.n	8004016 <HAL_HCD_HC_SubmitRequest+0x72>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 8003fec:	78fa      	ldrb	r2, [r7, #3]
 8003fee:	6879      	ldr	r1, [r7, #4]
 8003ff0:	4613      	mov	r3, r2
 8003ff2:	011b      	lsls	r3, r3, #4
 8003ff4:	1a9b      	subs	r3, r3, r2
 8003ff6:	009b      	lsls	r3, r3, #2
 8003ff8:	440b      	add	r3, r1
 8003ffa:	332a      	adds	r3, #42	@ 0x2a
 8003ffc:	2203      	movs	r2, #3
 8003ffe:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].do_ping = do_ping;
 8004000:	78fa      	ldrb	r2, [r7, #3]
 8004002:	6879      	ldr	r1, [r7, #4]
 8004004:	4613      	mov	r3, r2
 8004006:	011b      	lsls	r3, r3, #4
 8004008:	1a9b      	subs	r3, r3, r2
 800400a:	009b      	lsls	r3, r3, #2
 800400c:	440b      	add	r3, r1
 800400e:	3319      	adds	r3, #25
 8004010:	7f3a      	ldrb	r2, [r7, #28]
 8004012:	701a      	strb	r2, [r3, #0]
 8004014:	e009      	b.n	800402a <HAL_HCD_HC_SubmitRequest+0x86>
  }
  else
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8004016:	78fa      	ldrb	r2, [r7, #3]
 8004018:	6879      	ldr	r1, [r7, #4]
 800401a:	4613      	mov	r3, r2
 800401c:	011b      	lsls	r3, r3, #4
 800401e:	1a9b      	subs	r3, r3, r2
 8004020:	009b      	lsls	r3, r3, #2
 8004022:	440b      	add	r3, r1
 8004024:	332a      	adds	r3, #42	@ 0x2a
 8004026:	2202      	movs	r2, #2
 8004028:	701a      	strb	r2, [r3, #0]
  }

  /* Manage Data Toggle */
  switch (ep_type)
 800402a:	787b      	ldrb	r3, [r7, #1]
 800402c:	2b03      	cmp	r3, #3
 800402e:	f200 8102 	bhi.w	8004236 <HAL_HCD_HC_SubmitRequest+0x292>
 8004032:	a201      	add	r2, pc, #4	@ (adr r2, 8004038 <HAL_HCD_HC_SubmitRequest+0x94>)
 8004034:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004038:	08004049 	.word	0x08004049
 800403c:	08004221 	.word	0x08004221
 8004040:	0800410d 	.word	0x0800410d
 8004044:	08004197 	.word	0x08004197
  {
    case EP_TYPE_CTRL:
      if (token == 1U) /* send data */
 8004048:	7c3b      	ldrb	r3, [r7, #16]
 800404a:	2b01      	cmp	r3, #1
 800404c:	f040 80f5 	bne.w	800423a <HAL_HCD_HC_SubmitRequest+0x296>
      {
        if (direction == 0U)
 8004050:	78bb      	ldrb	r3, [r7, #2]
 8004052:	2b00      	cmp	r3, #0
 8004054:	d12d      	bne.n	80040b2 <HAL_HCD_HC_SubmitRequest+0x10e>
        {
          if (length == 0U)
 8004056:	8b3b      	ldrh	r3, [r7, #24]
 8004058:	2b00      	cmp	r3, #0
 800405a:	d109      	bne.n	8004070 <HAL_HCD_HC_SubmitRequest+0xcc>
          {
            /* For Status OUT stage, Length == 0U, Status Out PID = 1 */
            hhcd->hc[ch_num].toggle_out = 1U;
 800405c:	78fa      	ldrb	r2, [r7, #3]
 800405e:	6879      	ldr	r1, [r7, #4]
 8004060:	4613      	mov	r3, r2
 8004062:	011b      	lsls	r3, r3, #4
 8004064:	1a9b      	subs	r3, r3, r2
 8004066:	009b      	lsls	r3, r3, #2
 8004068:	440b      	add	r3, r1
 800406a:	333d      	adds	r3, #61	@ 0x3d
 800406c:	2201      	movs	r2, #1
 800406e:	701a      	strb	r2, [r3, #0]
          }

          /* Set the Data Toggle bit as per the Flag */
          if (hhcd->hc[ch_num].toggle_out == 0U)
 8004070:	78fa      	ldrb	r2, [r7, #3]
 8004072:	6879      	ldr	r1, [r7, #4]
 8004074:	4613      	mov	r3, r2
 8004076:	011b      	lsls	r3, r3, #4
 8004078:	1a9b      	subs	r3, r3, r2
 800407a:	009b      	lsls	r3, r3, #2
 800407c:	440b      	add	r3, r1
 800407e:	333d      	adds	r3, #61	@ 0x3d
 8004080:	781b      	ldrb	r3, [r3, #0]
 8004082:	2b00      	cmp	r3, #0
 8004084:	d10a      	bne.n	800409c <HAL_HCD_HC_SubmitRequest+0xf8>
          {
            /* Put the PID 0 */
            hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8004086:	78fa      	ldrb	r2, [r7, #3]
 8004088:	6879      	ldr	r1, [r7, #4]
 800408a:	4613      	mov	r3, r2
 800408c:	011b      	lsls	r3, r3, #4
 800408e:	1a9b      	subs	r3, r3, r2
 8004090:	009b      	lsls	r3, r3, #2
 8004092:	440b      	add	r3, r1
 8004094:	332a      	adds	r3, #42	@ 0x2a
 8004096:	2200      	movs	r2, #0
 8004098:	701a      	strb	r2, [r3, #0]
              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
            }
          }
        }
      }
      break;
 800409a:	e0ce      	b.n	800423a <HAL_HCD_HC_SubmitRequest+0x296>
            hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800409c:	78fa      	ldrb	r2, [r7, #3]
 800409e:	6879      	ldr	r1, [r7, #4]
 80040a0:	4613      	mov	r3, r2
 80040a2:	011b      	lsls	r3, r3, #4
 80040a4:	1a9b      	subs	r3, r3, r2
 80040a6:	009b      	lsls	r3, r3, #2
 80040a8:	440b      	add	r3, r1
 80040aa:	332a      	adds	r3, #42	@ 0x2a
 80040ac:	2202      	movs	r2, #2
 80040ae:	701a      	strb	r2, [r3, #0]
      break;
 80040b0:	e0c3      	b.n	800423a <HAL_HCD_HC_SubmitRequest+0x296>
          if (hhcd->hc[ch_num].do_ssplit == 1U)
 80040b2:	78fa      	ldrb	r2, [r7, #3]
 80040b4:	6879      	ldr	r1, [r7, #4]
 80040b6:	4613      	mov	r3, r2
 80040b8:	011b      	lsls	r3, r3, #4
 80040ba:	1a9b      	subs	r3, r3, r2
 80040bc:	009b      	lsls	r3, r3, #2
 80040be:	440b      	add	r3, r1
 80040c0:	331a      	adds	r3, #26
 80040c2:	781b      	ldrb	r3, [r3, #0]
 80040c4:	2b01      	cmp	r3, #1
 80040c6:	f040 80b8 	bne.w	800423a <HAL_HCD_HC_SubmitRequest+0x296>
            if (hhcd->hc[ch_num].toggle_in == 0U)
 80040ca:	78fa      	ldrb	r2, [r7, #3]
 80040cc:	6879      	ldr	r1, [r7, #4]
 80040ce:	4613      	mov	r3, r2
 80040d0:	011b      	lsls	r3, r3, #4
 80040d2:	1a9b      	subs	r3, r3, r2
 80040d4:	009b      	lsls	r3, r3, #2
 80040d6:	440b      	add	r3, r1
 80040d8:	333c      	adds	r3, #60	@ 0x3c
 80040da:	781b      	ldrb	r3, [r3, #0]
 80040dc:	2b00      	cmp	r3, #0
 80040de:	d10a      	bne.n	80040f6 <HAL_HCD_HC_SubmitRequest+0x152>
              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80040e0:	78fa      	ldrb	r2, [r7, #3]
 80040e2:	6879      	ldr	r1, [r7, #4]
 80040e4:	4613      	mov	r3, r2
 80040e6:	011b      	lsls	r3, r3, #4
 80040e8:	1a9b      	subs	r3, r3, r2
 80040ea:	009b      	lsls	r3, r3, #2
 80040ec:	440b      	add	r3, r1
 80040ee:	332a      	adds	r3, #42	@ 0x2a
 80040f0:	2200      	movs	r2, #0
 80040f2:	701a      	strb	r2, [r3, #0]
      break;
 80040f4:	e0a1      	b.n	800423a <HAL_HCD_HC_SubmitRequest+0x296>
              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80040f6:	78fa      	ldrb	r2, [r7, #3]
 80040f8:	6879      	ldr	r1, [r7, #4]
 80040fa:	4613      	mov	r3, r2
 80040fc:	011b      	lsls	r3, r3, #4
 80040fe:	1a9b      	subs	r3, r3, r2
 8004100:	009b      	lsls	r3, r3, #2
 8004102:	440b      	add	r3, r1
 8004104:	332a      	adds	r3, #42	@ 0x2a
 8004106:	2202      	movs	r2, #2
 8004108:	701a      	strb	r2, [r3, #0]
      break;
 800410a:	e096      	b.n	800423a <HAL_HCD_HC_SubmitRequest+0x296>

    case EP_TYPE_BULK:
      if (direction == 0U)
 800410c:	78bb      	ldrb	r3, [r7, #2]
 800410e:	2b00      	cmp	r3, #0
 8004110:	d120      	bne.n	8004154 <HAL_HCD_HC_SubmitRequest+0x1b0>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8004112:	78fa      	ldrb	r2, [r7, #3]
 8004114:	6879      	ldr	r1, [r7, #4]
 8004116:	4613      	mov	r3, r2
 8004118:	011b      	lsls	r3, r3, #4
 800411a:	1a9b      	subs	r3, r3, r2
 800411c:	009b      	lsls	r3, r3, #2
 800411e:	440b      	add	r3, r1
 8004120:	333d      	adds	r3, #61	@ 0x3d
 8004122:	781b      	ldrb	r3, [r3, #0]
 8004124:	2b00      	cmp	r3, #0
 8004126:	d10a      	bne.n	800413e <HAL_HCD_HC_SubmitRequest+0x19a>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8004128:	78fa      	ldrb	r2, [r7, #3]
 800412a:	6879      	ldr	r1, [r7, #4]
 800412c:	4613      	mov	r3, r2
 800412e:	011b      	lsls	r3, r3, #4
 8004130:	1a9b      	subs	r3, r3, r2
 8004132:	009b      	lsls	r3, r3, #2
 8004134:	440b      	add	r3, r1
 8004136:	332a      	adds	r3, #42	@ 0x2a
 8004138:	2200      	movs	r2, #0
 800413a:	701a      	strb	r2, [r3, #0]
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }

      break;
 800413c:	e07e      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800413e:	78fa      	ldrb	r2, [r7, #3]
 8004140:	6879      	ldr	r1, [r7, #4]
 8004142:	4613      	mov	r3, r2
 8004144:	011b      	lsls	r3, r3, #4
 8004146:	1a9b      	subs	r3, r3, r2
 8004148:	009b      	lsls	r3, r3, #2
 800414a:	440b      	add	r3, r1
 800414c:	332a      	adds	r3, #42	@ 0x2a
 800414e:	2202      	movs	r2, #2
 8004150:	701a      	strb	r2, [r3, #0]
      break;
 8004152:	e073      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 8004154:	78fa      	ldrb	r2, [r7, #3]
 8004156:	6879      	ldr	r1, [r7, #4]
 8004158:	4613      	mov	r3, r2
 800415a:	011b      	lsls	r3, r3, #4
 800415c:	1a9b      	subs	r3, r3, r2
 800415e:	009b      	lsls	r3, r3, #2
 8004160:	440b      	add	r3, r1
 8004162:	333c      	adds	r3, #60	@ 0x3c
 8004164:	781b      	ldrb	r3, [r3, #0]
 8004166:	2b00      	cmp	r3, #0
 8004168:	d10a      	bne.n	8004180 <HAL_HCD_HC_SubmitRequest+0x1dc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 800416a:	78fa      	ldrb	r2, [r7, #3]
 800416c:	6879      	ldr	r1, [r7, #4]
 800416e:	4613      	mov	r3, r2
 8004170:	011b      	lsls	r3, r3, #4
 8004172:	1a9b      	subs	r3, r3, r2
 8004174:	009b      	lsls	r3, r3, #2
 8004176:	440b      	add	r3, r1
 8004178:	332a      	adds	r3, #42	@ 0x2a
 800417a:	2200      	movs	r2, #0
 800417c:	701a      	strb	r2, [r3, #0]
      break;
 800417e:	e05d      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8004180:	78fa      	ldrb	r2, [r7, #3]
 8004182:	6879      	ldr	r1, [r7, #4]
 8004184:	4613      	mov	r3, r2
 8004186:	011b      	lsls	r3, r3, #4
 8004188:	1a9b      	subs	r3, r3, r2
 800418a:	009b      	lsls	r3, r3, #2
 800418c:	440b      	add	r3, r1
 800418e:	332a      	adds	r3, #42	@ 0x2a
 8004190:	2202      	movs	r2, #2
 8004192:	701a      	strb	r2, [r3, #0]
      break;
 8004194:	e052      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
    case EP_TYPE_INTR:
      if (direction == 0U)
 8004196:	78bb      	ldrb	r3, [r7, #2]
 8004198:	2b00      	cmp	r3, #0
 800419a:	d120      	bne.n	80041de <HAL_HCD_HC_SubmitRequest+0x23a>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 800419c:	78fa      	ldrb	r2, [r7, #3]
 800419e:	6879      	ldr	r1, [r7, #4]
 80041a0:	4613      	mov	r3, r2
 80041a2:	011b      	lsls	r3, r3, #4
 80041a4:	1a9b      	subs	r3, r3, r2
 80041a6:	009b      	lsls	r3, r3, #2
 80041a8:	440b      	add	r3, r1
 80041aa:	333d      	adds	r3, #61	@ 0x3d
 80041ac:	781b      	ldrb	r3, [r3, #0]
 80041ae:	2b00      	cmp	r3, #0
 80041b0:	d10a      	bne.n	80041c8 <HAL_HCD_HC_SubmitRequest+0x224>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80041b2:	78fa      	ldrb	r2, [r7, #3]
 80041b4:	6879      	ldr	r1, [r7, #4]
 80041b6:	4613      	mov	r3, r2
 80041b8:	011b      	lsls	r3, r3, #4
 80041ba:	1a9b      	subs	r3, r3, r2
 80041bc:	009b      	lsls	r3, r3, #2
 80041be:	440b      	add	r3, r1
 80041c0:	332a      	adds	r3, #42	@ 0x2a
 80041c2:	2200      	movs	r2, #0
 80041c4:	701a      	strb	r2, [r3, #0]
        else
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }
      break;
 80041c6:	e039      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80041c8:	78fa      	ldrb	r2, [r7, #3]
 80041ca:	6879      	ldr	r1, [r7, #4]
 80041cc:	4613      	mov	r3, r2
 80041ce:	011b      	lsls	r3, r3, #4
 80041d0:	1a9b      	subs	r3, r3, r2
 80041d2:	009b      	lsls	r3, r3, #2
 80041d4:	440b      	add	r3, r1
 80041d6:	332a      	adds	r3, #42	@ 0x2a
 80041d8:	2202      	movs	r2, #2
 80041da:	701a      	strb	r2, [r3, #0]
      break;
 80041dc:	e02e      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 80041de:	78fa      	ldrb	r2, [r7, #3]
 80041e0:	6879      	ldr	r1, [r7, #4]
 80041e2:	4613      	mov	r3, r2
 80041e4:	011b      	lsls	r3, r3, #4
 80041e6:	1a9b      	subs	r3, r3, r2
 80041e8:	009b      	lsls	r3, r3, #2
 80041ea:	440b      	add	r3, r1
 80041ec:	333c      	adds	r3, #60	@ 0x3c
 80041ee:	781b      	ldrb	r3, [r3, #0]
 80041f0:	2b00      	cmp	r3, #0
 80041f2:	d10a      	bne.n	800420a <HAL_HCD_HC_SubmitRequest+0x266>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80041f4:	78fa      	ldrb	r2, [r7, #3]
 80041f6:	6879      	ldr	r1, [r7, #4]
 80041f8:	4613      	mov	r3, r2
 80041fa:	011b      	lsls	r3, r3, #4
 80041fc:	1a9b      	subs	r3, r3, r2
 80041fe:	009b      	lsls	r3, r3, #2
 8004200:	440b      	add	r3, r1
 8004202:	332a      	adds	r3, #42	@ 0x2a
 8004204:	2200      	movs	r2, #0
 8004206:	701a      	strb	r2, [r3, #0]
      break;
 8004208:	e018      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800420a:	78fa      	ldrb	r2, [r7, #3]
 800420c:	6879      	ldr	r1, [r7, #4]
 800420e:	4613      	mov	r3, r2
 8004210:	011b      	lsls	r3, r3, #4
 8004212:	1a9b      	subs	r3, r3, r2
 8004214:	009b      	lsls	r3, r3, #2
 8004216:	440b      	add	r3, r1
 8004218:	332a      	adds	r3, #42	@ 0x2a
 800421a:	2202      	movs	r2, #2
 800421c:	701a      	strb	r2, [r3, #0]
      break;
 800421e:	e00d      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>

    case EP_TYPE_ISOC:
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8004220:	78fa      	ldrb	r2, [r7, #3]
 8004222:	6879      	ldr	r1, [r7, #4]
 8004224:	4613      	mov	r3, r2
 8004226:	011b      	lsls	r3, r3, #4
 8004228:	1a9b      	subs	r3, r3, r2
 800422a:	009b      	lsls	r3, r3, #2
 800422c:	440b      	add	r3, r1
 800422e:	332a      	adds	r3, #42	@ 0x2a
 8004230:	2200      	movs	r2, #0
 8004232:	701a      	strb	r2, [r3, #0]
      break;
 8004234:	e002      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>

    default:
      break;
 8004236:	bf00      	nop
 8004238:	e000      	b.n	800423c <HAL_HCD_HC_SubmitRequest+0x298>
      break;
 800423a:	bf00      	nop
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 800423c:	78fa      	ldrb	r2, [r7, #3]
 800423e:	6879      	ldr	r1, [r7, #4]
 8004240:	4613      	mov	r3, r2
 8004242:	011b      	lsls	r3, r3, #4
 8004244:	1a9b      	subs	r3, r3, r2
 8004246:	009b      	lsls	r3, r3, #2
 8004248:	440b      	add	r3, r1
 800424a:	332c      	adds	r3, #44	@ 0x2c
 800424c:	697a      	ldr	r2, [r7, #20]
 800424e:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_len  = length;
 8004250:	78fa      	ldrb	r2, [r7, #3]
 8004252:	8b39      	ldrh	r1, [r7, #24]
 8004254:	6878      	ldr	r0, [r7, #4]
 8004256:	4613      	mov	r3, r2
 8004258:	011b      	lsls	r3, r3, #4
 800425a:	1a9b      	subs	r3, r3, r2
 800425c:	009b      	lsls	r3, r3, #2
 800425e:	4403      	add	r3, r0
 8004260:	3334      	adds	r3, #52	@ 0x34
 8004262:	6019      	str	r1, [r3, #0]
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8004264:	78fa      	ldrb	r2, [r7, #3]
 8004266:	6879      	ldr	r1, [r7, #4]
 8004268:	4613      	mov	r3, r2
 800426a:	011b      	lsls	r3, r3, #4
 800426c:	1a9b      	subs	r3, r3, r2
 800426e:	009b      	lsls	r3, r3, #2
 8004270:	440b      	add	r3, r1
 8004272:	334c      	adds	r3, #76	@ 0x4c
 8004274:	2200      	movs	r2, #0
 8004276:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_count = 0U;
 8004278:	78fa      	ldrb	r2, [r7, #3]
 800427a:	6879      	ldr	r1, [r7, #4]
 800427c:	4613      	mov	r3, r2
 800427e:	011b      	lsls	r3, r3, #4
 8004280:	1a9b      	subs	r3, r3, r2
 8004282:	009b      	lsls	r3, r3, #2
 8004284:	440b      	add	r3, r1
 8004286:	3338      	adds	r3, #56	@ 0x38
 8004288:	2200      	movs	r2, #0
 800428a:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 800428c:	78fa      	ldrb	r2, [r7, #3]
 800428e:	6879      	ldr	r1, [r7, #4]
 8004290:	4613      	mov	r3, r2
 8004292:	011b      	lsls	r3, r3, #4
 8004294:	1a9b      	subs	r3, r3, r2
 8004296:	009b      	lsls	r3, r3, #2
 8004298:	440b      	add	r3, r1
 800429a:	3315      	adds	r3, #21
 800429c:	78fa      	ldrb	r2, [r7, #3]
 800429e:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].state = HC_IDLE;
 80042a0:	78fa      	ldrb	r2, [r7, #3]
 80042a2:	6879      	ldr	r1, [r7, #4]
 80042a4:	4613      	mov	r3, r2
 80042a6:	011b      	lsls	r3, r3, #4
 80042a8:	1a9b      	subs	r3, r3, r2
 80042aa:	009b      	lsls	r3, r3, #2
 80042ac:	440b      	add	r3, r1
 80042ae:	334d      	adds	r3, #77	@ 0x4d
 80042b0:	2200      	movs	r2, #0
 80042b2:	701a      	strb	r2, [r3, #0]

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 80042b4:	687b      	ldr	r3, [r7, #4]
 80042b6:	6818      	ldr	r0, [r3, #0]
 80042b8:	78fa      	ldrb	r2, [r7, #3]
 80042ba:	4613      	mov	r3, r2
 80042bc:	011b      	lsls	r3, r3, #4
 80042be:	1a9b      	subs	r3, r3, r2
 80042c0:	009b      	lsls	r3, r3, #2
 80042c2:	3310      	adds	r3, #16
 80042c4:	687a      	ldr	r2, [r7, #4]
 80042c6:	4413      	add	r3, r2
 80042c8:	1d19      	adds	r1, r3, #4
 80042ca:	687b      	ldr	r3, [r7, #4]
 80042cc:	799b      	ldrb	r3, [r3, #6]
 80042ce:	461a      	mov	r2, r3
 80042d0:	f003 f8f8 	bl	80074c4 <USB_HC_StartXfer>
 80042d4:	4603      	mov	r3, r0
}
 80042d6:	4618      	mov	r0, r3
 80042d8:	3708      	adds	r7, #8
 80042da:	46bd      	mov	sp, r7
 80042dc:	bd80      	pop	{r7, pc}
 80042de:	bf00      	nop

080042e0 <HAL_HCD_IRQHandler>:
  * @brief  Handle HCD interrupt request.
  * @param  hhcd HCD handle
  * @retval None
  */
void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 80042e0:	b580      	push	{r7, lr}
 80042e2:	b086      	sub	sp, #24
 80042e4:	af00      	add	r7, sp, #0
 80042e6:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80042e8:	687b      	ldr	r3, [r7, #4]
 80042ea:	681b      	ldr	r3, [r3, #0]
 80042ec:	613b      	str	r3, [r7, #16]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80042ee:	693b      	ldr	r3, [r7, #16]
 80042f0:	60fb      	str	r3, [r7, #12]
  uint32_t i;
  uint32_t interrupt;

  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 80042f2:	687b      	ldr	r3, [r7, #4]
 80042f4:	681b      	ldr	r3, [r3, #0]
 80042f6:	4618      	mov	r0, r3
 80042f8:	f002 fdec 	bl	8006ed4 <USB_GetMode>
 80042fc:	4603      	mov	r3, r0
 80042fe:	2b01      	cmp	r3, #1
 8004300:	f040 80fb 	bne.w	80044fa <HAL_HCD_IRQHandler+0x21a>
  {
    /* Avoid spurious interrupt */
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 8004304:	687b      	ldr	r3, [r7, #4]
 8004306:	681b      	ldr	r3, [r3, #0]
 8004308:	4618      	mov	r0, r3
 800430a:	f002 fdaf 	bl	8006e6c <USB_ReadInterrupts>
 800430e:	4603      	mov	r3, r0
 8004310:	2b00      	cmp	r3, #0
 8004312:	f000 80f1 	beq.w	80044f8 <HAL_HCD_IRQHandler+0x218>
    {
      return;
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8004316:	687b      	ldr	r3, [r7, #4]
 8004318:	681b      	ldr	r3, [r3, #0]
 800431a:	4618      	mov	r0, r3
 800431c:	f002 fda6 	bl	8006e6c <USB_ReadInterrupts>
 8004320:	4603      	mov	r3, r0
 8004322:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8004326:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800432a:	d104      	bne.n	8004336 <HAL_HCD_IRQHandler+0x56>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	681b      	ldr	r3, [r3, #0]
 8004330:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 8004334:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 8004336:	687b      	ldr	r3, [r7, #4]
 8004338:	681b      	ldr	r3, [r3, #0]
 800433a:	4618      	mov	r0, r3
 800433c:	f002 fd96 	bl	8006e6c <USB_ReadInterrupts>
 8004340:	4603      	mov	r3, r0
 8004342:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8004346:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800434a:	d104      	bne.n	8004356 <HAL_HCD_IRQHandler+0x76>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 800434c:	687b      	ldr	r3, [r7, #4]
 800434e:	681b      	ldr	r3, [r3, #0]
 8004350:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8004354:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 8004356:	687b      	ldr	r3, [r7, #4]
 8004358:	681b      	ldr	r3, [r3, #0]
 800435a:	4618      	mov	r0, r3
 800435c:	f002 fd86 	bl	8006e6c <USB_ReadInterrupts>
 8004360:	4603      	mov	r3, r0
 8004362:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8004366:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800436a:	d104      	bne.n	8004376 <HAL_HCD_IRQHandler+0x96>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 800436c:	687b      	ldr	r3, [r7, #4]
 800436e:	681b      	ldr	r3, [r3, #0]
 8004370:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 8004374:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 8004376:	687b      	ldr	r3, [r7, #4]
 8004378:	681b      	ldr	r3, [r3, #0]
 800437a:	4618      	mov	r0, r3
 800437c:	f002 fd76 	bl	8006e6c <USB_ReadInterrupts>
 8004380:	4603      	mov	r3, r0
 8004382:	f003 0302 	and.w	r3, r3, #2
 8004386:	2b02      	cmp	r3, #2
 8004388:	d103      	bne.n	8004392 <HAL_HCD_IRQHandler+0xb2>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 800438a:	687b      	ldr	r3, [r7, #4]
 800438c:	681b      	ldr	r3, [r3, #0]
 800438e:	2202      	movs	r2, #2
 8004390:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host Disconnect Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 8004392:	687b      	ldr	r3, [r7, #4]
 8004394:	681b      	ldr	r3, [r3, #0]
 8004396:	4618      	mov	r0, r3
 8004398:	f002 fd68 	bl	8006e6c <USB_ReadInterrupts>
 800439c:	4603      	mov	r3, r0
 800439e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80043a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80043a6:	d120      	bne.n	80043ea <HAL_HCD_IRQHandler+0x10a>
    {
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 80043a8:	687b      	ldr	r3, [r7, #4]
 80043aa:	681b      	ldr	r3, [r3, #0]
 80043ac:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 80043b0:	615a      	str	r2, [r3, #20]

      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 80043b2:	68fb      	ldr	r3, [r7, #12]
 80043b4:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 80043b8:	681b      	ldr	r3, [r3, #0]
 80043ba:	f003 0301 	and.w	r3, r3, #1
 80043be:	2b00      	cmp	r3, #0
 80043c0:	d113      	bne.n	80043ea <HAL_HCD_IRQHandler+0x10a>
      {
        /* Flush USB Fifo */
        (void)USB_FlushTxFifo(USBx, 0x10U);
 80043c2:	2110      	movs	r1, #16
 80043c4:	6938      	ldr	r0, [r7, #16]
 80043c6:	f002 fc5b 	bl	8006c80 <USB_FlushTxFifo>
        (void)USB_FlushRxFifo(USBx);
 80043ca:	6938      	ldr	r0, [r7, #16]
 80043cc:	f002 fc8a 	bl	8006ce4 <USB_FlushRxFifo>

        if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 80043d0:	687b      	ldr	r3, [r7, #4]
 80043d2:	7a5b      	ldrb	r3, [r3, #9]
 80043d4:	2b02      	cmp	r3, #2
 80043d6:	d105      	bne.n	80043e4 <HAL_HCD_IRQHandler+0x104>
        {
          /* Restore FS Clock */
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80043d8:	687b      	ldr	r3, [r7, #4]
 80043da:	681b      	ldr	r3, [r3, #0]
 80043dc:	2101      	movs	r1, #1
 80043de:	4618      	mov	r0, r3
 80043e0:	f002 fe7c 	bl	80070dc <USB_InitFSLSPClkSel>

        /* Handle Host Port Disconnect Interrupt */
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
        hhcd->DisconnectCallback(hhcd);
#else
        HAL_HCD_Disconnect_Callback(hhcd);
 80043e4:	6878      	ldr	r0, [r7, #4]
 80043e6:	f02a ff9b 	bl	802f320 <HAL_HCD_Disconnect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Host Port Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 80043ea:	687b      	ldr	r3, [r7, #4]
 80043ec:	681b      	ldr	r3, [r3, #0]
 80043ee:	4618      	mov	r0, r3
 80043f0:	f002 fd3c 	bl	8006e6c <USB_ReadInterrupts>
 80043f4:	4603      	mov	r3, r0
 80043f6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80043fa:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80043fe:	d102      	bne.n	8004406 <HAL_HCD_IRQHandler+0x126>
    {
      HCD_Port_IRQHandler(hhcd);
 8004400:	6878      	ldr	r0, [r7, #4]
 8004402:	f001 fd33 	bl	8005e6c <HCD_Port_IRQHandler>
    }

    /* Handle Host SOF Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	681b      	ldr	r3, [r3, #0]
 800440a:	4618      	mov	r0, r3
 800440c:	f002 fd2e 	bl	8006e6c <USB_ReadInterrupts>
 8004410:	4603      	mov	r3, r0
 8004412:	f003 0308 	and.w	r3, r3, #8
 8004416:	2b08      	cmp	r3, #8
 8004418:	d106      	bne.n	8004428 <HAL_HCD_IRQHandler+0x148>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->SOFCallback(hhcd);
#else
      HAL_HCD_SOF_Callback(hhcd);
 800441a:	6878      	ldr	r0, [r7, #4]
 800441c:	f02a ff64 	bl	802f2e8 <HAL_HCD_SOF_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8004420:	687b      	ldr	r3, [r7, #4]
 8004422:	681b      	ldr	r3, [r3, #0]
 8004424:	2208      	movs	r2, #8
 8004426:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host channel Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 8004428:	687b      	ldr	r3, [r7, #4]
 800442a:	681b      	ldr	r3, [r3, #0]
 800442c:	4618      	mov	r0, r3
 800442e:	f002 fd1d 	bl	8006e6c <USB_ReadInterrupts>
 8004432:	4603      	mov	r3, r0
 8004434:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004438:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800443c:	d139      	bne.n	80044b2 <HAL_HCD_IRQHandler+0x1d2>
    {
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 800443e:	687b      	ldr	r3, [r7, #4]
 8004440:	681b      	ldr	r3, [r3, #0]
 8004442:	4618      	mov	r0, r3
 8004444:	f003 fab8 	bl	80079b8 <USB_HC_ReadInterrupt>
 8004448:	60b8      	str	r0, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800444a:	2300      	movs	r3, #0
 800444c:	617b      	str	r3, [r7, #20]
 800444e:	e025      	b.n	800449c <HAL_HCD_IRQHandler+0x1bc>
      {
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8004450:	697b      	ldr	r3, [r7, #20]
 8004452:	f003 030f 	and.w	r3, r3, #15
 8004456:	68ba      	ldr	r2, [r7, #8]
 8004458:	fa22 f303 	lsr.w	r3, r2, r3
 800445c:	f003 0301 	and.w	r3, r3, #1
 8004460:	2b00      	cmp	r3, #0
 8004462:	d018      	beq.n	8004496 <HAL_HCD_IRQHandler+0x1b6>
        {
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8004464:	697b      	ldr	r3, [r7, #20]
 8004466:	015a      	lsls	r2, r3, #5
 8004468:	68fb      	ldr	r3, [r7, #12]
 800446a:	4413      	add	r3, r2
 800446c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004470:	681b      	ldr	r3, [r3, #0]
 8004472:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8004476:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800447a:	d106      	bne.n	800448a <HAL_HCD_IRQHandler+0x1aa>
          {
            HCD_HC_IN_IRQHandler(hhcd, (uint8_t)i);
 800447c:	697b      	ldr	r3, [r7, #20]
 800447e:	b2db      	uxtb	r3, r3
 8004480:	4619      	mov	r1, r3
 8004482:	6878      	ldr	r0, [r7, #4]
 8004484:	f000 f905 	bl	8004692 <HCD_HC_IN_IRQHandler>
 8004488:	e005      	b.n	8004496 <HAL_HCD_IRQHandler+0x1b6>
          }
          else
          {
            HCD_HC_OUT_IRQHandler(hhcd, (uint8_t)i);
 800448a:	697b      	ldr	r3, [r7, #20]
 800448c:	b2db      	uxtb	r3, r3
 800448e:	4619      	mov	r1, r3
 8004490:	6878      	ldr	r0, [r7, #4]
 8004492:	f000 ff67 	bl	8005364 <HCD_HC_OUT_IRQHandler>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8004496:	697b      	ldr	r3, [r7, #20]
 8004498:	3301      	adds	r3, #1
 800449a:	617b      	str	r3, [r7, #20]
 800449c:	687b      	ldr	r3, [r7, #4]
 800449e:	795b      	ldrb	r3, [r3, #5]
 80044a0:	461a      	mov	r2, r3
 80044a2:	697b      	ldr	r3, [r7, #20]
 80044a4:	4293      	cmp	r3, r2
 80044a6:	d3d3      	bcc.n	8004450 <HAL_HCD_IRQHandler+0x170>
          }
        }
      }
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 80044a8:	687b      	ldr	r3, [r7, #4]
 80044aa:	681b      	ldr	r3, [r3, #0]
 80044ac:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 80044b0:	615a      	str	r2, [r3, #20]
    }

    /* Handle Rx Queue Level Interrupts */
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 80044b2:	687b      	ldr	r3, [r7, #4]
 80044b4:	681b      	ldr	r3, [r3, #0]
 80044b6:	4618      	mov	r0, r3
 80044b8:	f002 fcd8 	bl	8006e6c <USB_ReadInterrupts>
 80044bc:	4603      	mov	r3, r0
 80044be:	f003 0310 	and.w	r3, r3, #16
 80044c2:	2b10      	cmp	r3, #16
 80044c4:	d101      	bne.n	80044ca <HAL_HCD_IRQHandler+0x1ea>
 80044c6:	2301      	movs	r3, #1
 80044c8:	e000      	b.n	80044cc <HAL_HCD_IRQHandler+0x1ec>
 80044ca:	2300      	movs	r3, #0
 80044cc:	2b00      	cmp	r3, #0
 80044ce:	d014      	beq.n	80044fa <HAL_HCD_IRQHandler+0x21a>
    {
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80044d0:	687b      	ldr	r3, [r7, #4]
 80044d2:	681b      	ldr	r3, [r3, #0]
 80044d4:	699a      	ldr	r2, [r3, #24]
 80044d6:	687b      	ldr	r3, [r7, #4]
 80044d8:	681b      	ldr	r3, [r3, #0]
 80044da:	f022 0210 	bic.w	r2, r2, #16
 80044de:	619a      	str	r2, [r3, #24]

      HCD_RXQLVL_IRQHandler(hhcd);
 80044e0:	6878      	ldr	r0, [r7, #4]
 80044e2:	f001 fbe4 	bl	8005cae <HCD_RXQLVL_IRQHandler>

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	681b      	ldr	r3, [r3, #0]
 80044ea:	699a      	ldr	r2, [r3, #24]
 80044ec:	687b      	ldr	r3, [r7, #4]
 80044ee:	681b      	ldr	r3, [r3, #0]
 80044f0:	f042 0210 	orr.w	r2, r2, #16
 80044f4:	619a      	str	r2, [r3, #24]
 80044f6:	e000      	b.n	80044fa <HAL_HCD_IRQHandler+0x21a>
      return;
 80044f8:	bf00      	nop
    }
  }
}
 80044fa:	3718      	adds	r7, #24
 80044fc:	46bd      	mov	sp, r7
 80044fe:	bd80      	pop	{r7, pc}

08004500 <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
 8004500:	b580      	push	{r7, lr}
 8004502:	b082      	sub	sp, #8
 8004504:	af00      	add	r7, sp, #0
 8004506:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 8004508:	687b      	ldr	r3, [r7, #4]
 800450a:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 800450e:	2b01      	cmp	r3, #1
 8004510:	d101      	bne.n	8004516 <HAL_HCD_Start+0x16>
 8004512:	2302      	movs	r3, #2
 8004514:	e013      	b.n	800453e <HAL_HCD_Start+0x3e>
 8004516:	687b      	ldr	r3, [r7, #4]
 8004518:	2201      	movs	r2, #1
 800451a:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  /* Enable port power */
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 800451e:	687b      	ldr	r3, [r7, #4]
 8004520:	681b      	ldr	r3, [r3, #0]
 8004522:	2101      	movs	r1, #1
 8004524:	4618      	mov	r0, r3
 8004526:	f002 fe40 	bl	80071aa <USB_DriveVbus>

  /* Enable global interrupt */
  __HAL_HCD_ENABLE(hhcd);
 800452a:	687b      	ldr	r3, [r7, #4]
 800452c:	681b      	ldr	r3, [r3, #0]
 800452e:	4618      	mov	r0, r3
 8004530:	f002 fb38 	bl	8006ba4 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hhcd);
 8004534:	687b      	ldr	r3, [r7, #4]
 8004536:	2200      	movs	r2, #0
 8004538:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return HAL_OK;
 800453c:	2300      	movs	r3, #0
}
 800453e:	4618      	mov	r0, r3
 8004540:	3708      	adds	r7, #8
 8004542:	46bd      	mov	sp, r7
 8004544:	bd80      	pop	{r7, pc}

08004546 <HAL_HCD_Stop>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
 8004546:	b580      	push	{r7, lr}
 8004548:	b082      	sub	sp, #8
 800454a:	af00      	add	r7, sp, #0
 800454c:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	f893 33d4 	ldrb.w	r3, [r3, #980]	@ 0x3d4
 8004554:	2b01      	cmp	r3, #1
 8004556:	d101      	bne.n	800455c <HAL_HCD_Stop+0x16>
 8004558:	2302      	movs	r3, #2
 800455a:	e00d      	b.n	8004578 <HAL_HCD_Stop+0x32>
 800455c:	687b      	ldr	r3, [r7, #4]
 800455e:	2201      	movs	r2, #1
 8004560:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4
  (void)USB_StopHost(hhcd->Instance);
 8004564:	687b      	ldr	r3, [r7, #4]
 8004566:	681b      	ldr	r3, [r3, #0]
 8004568:	4618      	mov	r0, r3
 800456a:	f003 fb93 	bl	8007c94 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800456e:	687b      	ldr	r3, [r7, #4]
 8004570:	2200      	movs	r2, #0
 8004572:	f883 23d4 	strb.w	r2, [r3, #980]	@ 0x3d4

  return HAL_OK;
 8004576:	2300      	movs	r3, #0
}
 8004578:	4618      	mov	r0, r3
 800457a:	3708      	adds	r7, #8
 800457c:	46bd      	mov	sp, r7
 800457e:	bd80      	pop	{r7, pc}

08004580 <HAL_HCD_ResetPort>:
  * @brief  Reset the host port.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
 8004580:	b580      	push	{r7, lr}
 8004582:	b082      	sub	sp, #8
 8004584:	af00      	add	r7, sp, #0
 8004586:	6078      	str	r0, [r7, #4]
  return (USB_ResetPort(hhcd->Instance));
 8004588:	687b      	ldr	r3, [r7, #4]
 800458a:	681b      	ldr	r3, [r3, #0]
 800458c:	4618      	mov	r0, r3
 800458e:	f002 fde2 	bl	8007156 <USB_ResetPort>
 8004592:	4603      	mov	r3, r0
}
 8004594:	4618      	mov	r0, r3
 8004596:	3708      	adds	r7, #8
 8004598:	46bd      	mov	sp, r7
 800459a:	bd80      	pop	{r7, pc}

0800459c <HAL_HCD_HC_GetURBState>:
  *            URB_NYET/
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef const *hhcd, uint8_t chnum)
{
 800459c:	b480      	push	{r7}
 800459e:	b083      	sub	sp, #12
 80045a0:	af00      	add	r7, sp, #0
 80045a2:	6078      	str	r0, [r7, #4]
 80045a4:	460b      	mov	r3, r1
 80045a6:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].urb_state;
 80045a8:	78fa      	ldrb	r2, [r7, #3]
 80045aa:	6879      	ldr	r1, [r7, #4]
 80045ac:	4613      	mov	r3, r2
 80045ae:	011b      	lsls	r3, r3, #4
 80045b0:	1a9b      	subs	r3, r3, r2
 80045b2:	009b      	lsls	r3, r3, #2
 80045b4:	440b      	add	r3, r1
 80045b6:	334c      	adds	r3, #76	@ 0x4c
 80045b8:	781b      	ldrb	r3, [r3, #0]
}
 80045ba:	4618      	mov	r0, r3
 80045bc:	370c      	adds	r7, #12
 80045be:	46bd      	mov	sp, r7
 80045c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045c4:	4770      	bx	lr

080045c6 <HAL_HCD_HC_GetXferCount>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef const *hhcd, uint8_t chnum)
{
 80045c6:	b480      	push	{r7}
 80045c8:	b083      	sub	sp, #12
 80045ca:	af00      	add	r7, sp, #0
 80045cc:	6078      	str	r0, [r7, #4]
 80045ce:	460b      	mov	r3, r1
 80045d0:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].xfer_count;
 80045d2:	78fa      	ldrb	r2, [r7, #3]
 80045d4:	6879      	ldr	r1, [r7, #4]
 80045d6:	4613      	mov	r3, r2
 80045d8:	011b      	lsls	r3, r3, #4
 80045da:	1a9b      	subs	r3, r3, r2
 80045dc:	009b      	lsls	r3, r3, #2
 80045de:	440b      	add	r3, r1
 80045e0:	3338      	adds	r3, #56	@ 0x38
 80045e2:	681b      	ldr	r3, [r3, #0]
}
 80045e4:	4618      	mov	r0, r3
 80045e6:	370c      	adds	r7, #12
 80045e8:	46bd      	mov	sp, r7
 80045ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045ee:	4770      	bx	lr

080045f0 <HAL_HCD_GetCurrentFrame>:
  * @brief  Return the current Host frame number.
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
 80045f0:	b580      	push	{r7, lr}
 80045f2:	b082      	sub	sp, #8
 80045f4:	af00      	add	r7, sp, #0
 80045f6:	6078      	str	r0, [r7, #4]
  return (USB_GetCurrentFrame(hhcd->Instance));
 80045f8:	687b      	ldr	r3, [r7, #4]
 80045fa:	681b      	ldr	r3, [r3, #0]
 80045fc:	4618      	mov	r0, r3
 80045fe:	f002 fe24 	bl	800724a <USB_GetCurrentFrame>
 8004602:	4603      	mov	r3, r0
}
 8004604:	4618      	mov	r0, r3
 8004606:	3708      	adds	r7, #8
 8004608:	46bd      	mov	sp, r7
 800460a:	bd80      	pop	{r7, pc}

0800460c <HAL_HCD_GetCurrentSpeed>:
  * @brief  Return the Host enumeration speed.
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
 800460c:	b580      	push	{r7, lr}
 800460e:	b082      	sub	sp, #8
 8004610:	af00      	add	r7, sp, #0
 8004612:	6078      	str	r0, [r7, #4]
  return (USB_GetHostSpeed(hhcd->Instance));
 8004614:	687b      	ldr	r3, [r7, #4]
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	4618      	mov	r0, r3
 800461a:	f002 fdff 	bl	800721c <USB_GetHostSpeed>
 800461e:	4603      	mov	r3, r0
}
 8004620:	4618      	mov	r0, r3
 8004622:	3708      	adds	r7, #8
 8004624:	46bd      	mov	sp, r7
 8004626:	bd80      	pop	{r7, pc}

08004628 <HAL_HCD_HC_ClearHubInfo>:
  * @param  ch_num Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_ClearHubInfo(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
 8004628:	b480      	push	{r7}
 800462a:	b083      	sub	sp, #12
 800462c:	af00      	add	r7, sp, #0
 800462e:	6078      	str	r0, [r7, #4]
 8004630:	460b      	mov	r3, r1
 8004632:	70fb      	strb	r3, [r7, #3]
  hhcd->hc[ch_num].do_ssplit = 0U;
 8004634:	78fa      	ldrb	r2, [r7, #3]
 8004636:	6879      	ldr	r1, [r7, #4]
 8004638:	4613      	mov	r3, r2
 800463a:	011b      	lsls	r3, r3, #4
 800463c:	1a9b      	subs	r3, r3, r2
 800463e:	009b      	lsls	r3, r3, #2
 8004640:	440b      	add	r3, r1
 8004642:	331a      	adds	r3, #26
 8004644:	2200      	movs	r2, #0
 8004646:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].do_csplit = 0U;
 8004648:	78fa      	ldrb	r2, [r7, #3]
 800464a:	6879      	ldr	r1, [r7, #4]
 800464c:	4613      	mov	r3, r2
 800464e:	011b      	lsls	r3, r3, #4
 8004650:	1a9b      	subs	r3, r3, r2
 8004652:	009b      	lsls	r3, r3, #2
 8004654:	440b      	add	r3, r1
 8004656:	331b      	adds	r3, #27
 8004658:	2200      	movs	r2, #0
 800465a:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].hub_addr = 0U;
 800465c:	78fa      	ldrb	r2, [r7, #3]
 800465e:	6879      	ldr	r1, [r7, #4]
 8004660:	4613      	mov	r3, r2
 8004662:	011b      	lsls	r3, r3, #4
 8004664:	1a9b      	subs	r3, r3, r2
 8004666:	009b      	lsls	r3, r3, #2
 8004668:	440b      	add	r3, r1
 800466a:	3325      	adds	r3, #37	@ 0x25
 800466c:	2200      	movs	r2, #0
 800466e:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 8004670:	78fa      	ldrb	r2, [r7, #3]
 8004672:	6879      	ldr	r1, [r7, #4]
 8004674:	4613      	mov	r3, r2
 8004676:	011b      	lsls	r3, r3, #4
 8004678:	1a9b      	subs	r3, r3, r2
 800467a:	009b      	lsls	r3, r3, #2
 800467c:	440b      	add	r3, r1
 800467e:	3324      	adds	r3, #36	@ 0x24
 8004680:	2200      	movs	r2, #0
 8004682:	701a      	strb	r2, [r3, #0]

  return HAL_OK;
 8004684:	2300      	movs	r3, #0
}
 8004686:	4618      	mov	r0, r3
 8004688:	370c      	adds	r7, #12
 800468a:	46bd      	mov	sp, r7
 800468c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004690:	4770      	bx	lr

08004692 <HCD_HC_IN_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8004692:	b580      	push	{r7, lr}
 8004694:	b086      	sub	sp, #24
 8004696:	af00      	add	r7, sp, #0
 8004698:	6078      	str	r0, [r7, #4]
 800469a:	460b      	mov	r3, r1
 800469c:	70fb      	strb	r3, [r7, #3]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800469e:	687b      	ldr	r3, [r7, #4]
 80046a0:	681b      	ldr	r3, [r3, #0]
 80046a2:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80046a4:	697b      	ldr	r3, [r7, #20]
 80046a6:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg;

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 80046a8:	687b      	ldr	r3, [r7, #4]
 80046aa:	681b      	ldr	r3, [r3, #0]
 80046ac:	78fa      	ldrb	r2, [r7, #3]
 80046ae:	4611      	mov	r1, r2
 80046b0:	4618      	mov	r0, r3
 80046b2:	f002 fbee 	bl	8006e92 <USB_ReadChInterrupts>
 80046b6:	4603      	mov	r3, r0
 80046b8:	f003 0304 	and.w	r3, r3, #4
 80046bc:	2b04      	cmp	r3, #4
 80046be:	d11a      	bne.n	80046f6 <HCD_HC_IN_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 80046c0:	78fb      	ldrb	r3, [r7, #3]
 80046c2:	015a      	lsls	r2, r3, #5
 80046c4:	693b      	ldr	r3, [r7, #16]
 80046c6:	4413      	add	r3, r2
 80046c8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80046cc:	461a      	mov	r2, r3
 80046ce:	2304      	movs	r3, #4
 80046d0:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 80046d2:	78fa      	ldrb	r2, [r7, #3]
 80046d4:	6879      	ldr	r1, [r7, #4]
 80046d6:	4613      	mov	r3, r2
 80046d8:	011b      	lsls	r3, r3, #4
 80046da:	1a9b      	subs	r3, r3, r2
 80046dc:	009b      	lsls	r3, r3, #2
 80046de:	440b      	add	r3, r1
 80046e0:	334d      	adds	r3, #77	@ 0x4d
 80046e2:	2207      	movs	r2, #7
 80046e4:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80046e6:	687b      	ldr	r3, [r7, #4]
 80046e8:	681b      	ldr	r3, [r3, #0]
 80046ea:	78fa      	ldrb	r2, [r7, #3]
 80046ec:	4611      	mov	r1, r2
 80046ee:	4618      	mov	r0, r3
 80046f0:	f003 f973 	bl	80079da <USB_HC_Halt>
 80046f4:	e09e      	b.n	8004834 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_BBERR))
 80046f6:	687b      	ldr	r3, [r7, #4]
 80046f8:	681b      	ldr	r3, [r3, #0]
 80046fa:	78fa      	ldrb	r2, [r7, #3]
 80046fc:	4611      	mov	r1, r2
 80046fe:	4618      	mov	r0, r3
 8004700:	f002 fbc7 	bl	8006e92 <USB_ReadChInterrupts>
 8004704:	4603      	mov	r3, r0
 8004706:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800470a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800470e:	d11b      	bne.n	8004748 <HCD_HC_IN_IRQHandler+0xb6>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_BBERR);
 8004710:	78fb      	ldrb	r3, [r7, #3]
 8004712:	015a      	lsls	r2, r3, #5
 8004714:	693b      	ldr	r3, [r7, #16]
 8004716:	4413      	add	r3, r2
 8004718:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800471c:	461a      	mov	r2, r3
 800471e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8004722:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_BBLERR;
 8004724:	78fa      	ldrb	r2, [r7, #3]
 8004726:	6879      	ldr	r1, [r7, #4]
 8004728:	4613      	mov	r3, r2
 800472a:	011b      	lsls	r3, r3, #4
 800472c:	1a9b      	subs	r3, r3, r2
 800472e:	009b      	lsls	r3, r3, #2
 8004730:	440b      	add	r3, r1
 8004732:	334d      	adds	r3, #77	@ 0x4d
 8004734:	2208      	movs	r2, #8
 8004736:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004738:	687b      	ldr	r3, [r7, #4]
 800473a:	681b      	ldr	r3, [r3, #0]
 800473c:	78fa      	ldrb	r2, [r7, #3]
 800473e:	4611      	mov	r1, r2
 8004740:	4618      	mov	r0, r3
 8004742:	f003 f94a 	bl	80079da <USB_HC_Halt>
 8004746:	e075      	b.n	8004834 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	681b      	ldr	r3, [r3, #0]
 800474c:	78fa      	ldrb	r2, [r7, #3]
 800474e:	4611      	mov	r1, r2
 8004750:	4618      	mov	r0, r3
 8004752:	f002 fb9e 	bl	8006e92 <USB_ReadChInterrupts>
 8004756:	4603      	mov	r3, r0
 8004758:	f003 0308 	and.w	r3, r3, #8
 800475c:	2b08      	cmp	r3, #8
 800475e:	d11a      	bne.n	8004796 <HCD_HC_IN_IRQHandler+0x104>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8004760:	78fb      	ldrb	r3, [r7, #3]
 8004762:	015a      	lsls	r2, r3, #5
 8004764:	693b      	ldr	r3, [r7, #16]
 8004766:	4413      	add	r3, r2
 8004768:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800476c:	461a      	mov	r2, r3
 800476e:	2308      	movs	r3, #8
 8004770:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_STALL;
 8004772:	78fa      	ldrb	r2, [r7, #3]
 8004774:	6879      	ldr	r1, [r7, #4]
 8004776:	4613      	mov	r3, r2
 8004778:	011b      	lsls	r3, r3, #4
 800477a:	1a9b      	subs	r3, r3, r2
 800477c:	009b      	lsls	r3, r3, #2
 800477e:	440b      	add	r3, r1
 8004780:	334d      	adds	r3, #77	@ 0x4d
 8004782:	2206      	movs	r2, #6
 8004784:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004786:	687b      	ldr	r3, [r7, #4]
 8004788:	681b      	ldr	r3, [r3, #0]
 800478a:	78fa      	ldrb	r2, [r7, #3]
 800478c:	4611      	mov	r1, r2
 800478e:	4618      	mov	r0, r3
 8004790:	f003 f923 	bl	80079da <USB_HC_Halt>
 8004794:	e04e      	b.n	8004834 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	78fa      	ldrb	r2, [r7, #3]
 800479c:	4611      	mov	r1, r2
 800479e:	4618      	mov	r0, r3
 80047a0:	f002 fb77 	bl	8006e92 <USB_ReadChInterrupts>
 80047a4:	4603      	mov	r3, r0
 80047a6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80047aa:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80047ae:	d11b      	bne.n	80047e8 <HCD_HC_IN_IRQHandler+0x156>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 80047b0:	78fb      	ldrb	r3, [r7, #3]
 80047b2:	015a      	lsls	r2, r3, #5
 80047b4:	693b      	ldr	r3, [r7, #16]
 80047b6:	4413      	add	r3, r2
 80047b8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80047bc:	461a      	mov	r2, r3
 80047be:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80047c2:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_DATATGLERR;
 80047c4:	78fa      	ldrb	r2, [r7, #3]
 80047c6:	6879      	ldr	r1, [r7, #4]
 80047c8:	4613      	mov	r3, r2
 80047ca:	011b      	lsls	r3, r3, #4
 80047cc:	1a9b      	subs	r3, r3, r2
 80047ce:	009b      	lsls	r3, r3, #2
 80047d0:	440b      	add	r3, r1
 80047d2:	334d      	adds	r3, #77	@ 0x4d
 80047d4:	2209      	movs	r2, #9
 80047d6:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80047d8:	687b      	ldr	r3, [r7, #4]
 80047da:	681b      	ldr	r3, [r3, #0]
 80047dc:	78fa      	ldrb	r2, [r7, #3]
 80047de:	4611      	mov	r1, r2
 80047e0:	4618      	mov	r0, r3
 80047e2:	f003 f8fa 	bl	80079da <USB_HC_Halt>
 80047e6:	e025      	b.n	8004834 <HCD_HC_IN_IRQHandler+0x1a2>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 80047e8:	687b      	ldr	r3, [r7, #4]
 80047ea:	681b      	ldr	r3, [r3, #0]
 80047ec:	78fa      	ldrb	r2, [r7, #3]
 80047ee:	4611      	mov	r1, r2
 80047f0:	4618      	mov	r0, r3
 80047f2:	f002 fb4e 	bl	8006e92 <USB_ReadChInterrupts>
 80047f6:	4603      	mov	r3, r0
 80047f8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80047fc:	2b80      	cmp	r3, #128	@ 0x80
 80047fe:	d119      	bne.n	8004834 <HCD_HC_IN_IRQHandler+0x1a2>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8004800:	78fb      	ldrb	r3, [r7, #3]
 8004802:	015a      	lsls	r2, r3, #5
 8004804:	693b      	ldr	r3, [r7, #16]
 8004806:	4413      	add	r3, r2
 8004808:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800480c:	461a      	mov	r2, r3
 800480e:	2380      	movs	r3, #128	@ 0x80
 8004810:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 8004812:	78fa      	ldrb	r2, [r7, #3]
 8004814:	6879      	ldr	r1, [r7, #4]
 8004816:	4613      	mov	r3, r2
 8004818:	011b      	lsls	r3, r3, #4
 800481a:	1a9b      	subs	r3, r3, r2
 800481c:	009b      	lsls	r3, r3, #2
 800481e:	440b      	add	r3, r1
 8004820:	334d      	adds	r3, #77	@ 0x4d
 8004822:	2207      	movs	r2, #7
 8004824:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004826:	687b      	ldr	r3, [r7, #4]
 8004828:	681b      	ldr	r3, [r3, #0]
 800482a:	78fa      	ldrb	r2, [r7, #3]
 800482c:	4611      	mov	r1, r2
 800482e:	4618      	mov	r0, r3
 8004830:	f003 f8d3 	bl	80079da <USB_HC_Halt>
  else
  {
    /* ... */
  }

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 8004834:	687b      	ldr	r3, [r7, #4]
 8004836:	681b      	ldr	r3, [r3, #0]
 8004838:	78fa      	ldrb	r2, [r7, #3]
 800483a:	4611      	mov	r1, r2
 800483c:	4618      	mov	r0, r3
 800483e:	f002 fb28 	bl	8006e92 <USB_ReadChInterrupts>
 8004842:	4603      	mov	r3, r0
 8004844:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8004848:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800484c:	d112      	bne.n	8004874 <HCD_HC_IN_IRQHandler+0x1e2>
  {
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800484e:	687b      	ldr	r3, [r7, #4]
 8004850:	681b      	ldr	r3, [r3, #0]
 8004852:	78fa      	ldrb	r2, [r7, #3]
 8004854:	4611      	mov	r1, r2
 8004856:	4618      	mov	r0, r3
 8004858:	f003 f8bf 	bl	80079da <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 800485c:	78fb      	ldrb	r3, [r7, #3]
 800485e:	015a      	lsls	r2, r3, #5
 8004860:	693b      	ldr	r3, [r7, #16]
 8004862:	4413      	add	r3, r2
 8004864:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004868:	461a      	mov	r2, r3
 800486a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800486e:	6093      	str	r3, [r2, #8]
 8004870:	f000 bd75 	b.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 8004874:	687b      	ldr	r3, [r7, #4]
 8004876:	681b      	ldr	r3, [r3, #0]
 8004878:	78fa      	ldrb	r2, [r7, #3]
 800487a:	4611      	mov	r1, r2
 800487c:	4618      	mov	r0, r3
 800487e:	f002 fb08 	bl	8006e92 <USB_ReadChInterrupts>
 8004882:	4603      	mov	r3, r0
 8004884:	f003 0301 	and.w	r3, r3, #1
 8004888:	2b01      	cmp	r3, #1
 800488a:	f040 8128 	bne.w	8004ade <HCD_HC_IN_IRQHandler+0x44c>
  {
    /* Clear any pending ACK IT */
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 800488e:	78fb      	ldrb	r3, [r7, #3]
 8004890:	015a      	lsls	r2, r3, #5
 8004892:	693b      	ldr	r3, [r7, #16]
 8004894:	4413      	add	r3, r2
 8004896:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800489a:	461a      	mov	r2, r3
 800489c:	2320      	movs	r3, #32
 800489e:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_csplit == 1U)
 80048a0:	78fa      	ldrb	r2, [r7, #3]
 80048a2:	6879      	ldr	r1, [r7, #4]
 80048a4:	4613      	mov	r3, r2
 80048a6:	011b      	lsls	r3, r3, #4
 80048a8:	1a9b      	subs	r3, r3, r2
 80048aa:	009b      	lsls	r3, r3, #2
 80048ac:	440b      	add	r3, r1
 80048ae:	331b      	adds	r3, #27
 80048b0:	781b      	ldrb	r3, [r3, #0]
 80048b2:	2b01      	cmp	r3, #1
 80048b4:	d119      	bne.n	80048ea <HCD_HC_IN_IRQHandler+0x258>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 80048b6:	78fa      	ldrb	r2, [r7, #3]
 80048b8:	6879      	ldr	r1, [r7, #4]
 80048ba:	4613      	mov	r3, r2
 80048bc:	011b      	lsls	r3, r3, #4
 80048be:	1a9b      	subs	r3, r3, r2
 80048c0:	009b      	lsls	r3, r3, #2
 80048c2:	440b      	add	r3, r1
 80048c4:	331b      	adds	r3, #27
 80048c6:	2200      	movs	r2, #0
 80048c8:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 80048ca:	78fb      	ldrb	r3, [r7, #3]
 80048cc:	015a      	lsls	r2, r3, #5
 80048ce:	693b      	ldr	r3, [r7, #16]
 80048d0:	4413      	add	r3, r2
 80048d2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80048d6:	685b      	ldr	r3, [r3, #4]
 80048d8:	78fa      	ldrb	r2, [r7, #3]
 80048da:	0151      	lsls	r1, r2, #5
 80048dc:	693a      	ldr	r2, [r7, #16]
 80048de:	440a      	add	r2, r1
 80048e0:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80048e4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80048e8:	6053      	str	r3, [r2, #4]
    }

    if (hhcd->Init.dma_enable != 0U)
 80048ea:	687b      	ldr	r3, [r7, #4]
 80048ec:	799b      	ldrb	r3, [r3, #6]
 80048ee:	2b00      	cmp	r3, #0
 80048f0:	d01b      	beq.n	800492a <HCD_HC_IN_IRQHandler+0x298>
    {
      hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].XferSize - (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 80048f2:	78fa      	ldrb	r2, [r7, #3]
 80048f4:	6879      	ldr	r1, [r7, #4]
 80048f6:	4613      	mov	r3, r2
 80048f8:	011b      	lsls	r3, r3, #4
 80048fa:	1a9b      	subs	r3, r3, r2
 80048fc:	009b      	lsls	r3, r3, #2
 80048fe:	440b      	add	r3, r1
 8004900:	3330      	adds	r3, #48	@ 0x30
 8004902:	6819      	ldr	r1, [r3, #0]
 8004904:	78fb      	ldrb	r3, [r7, #3]
 8004906:	015a      	lsls	r2, r3, #5
 8004908:	693b      	ldr	r3, [r7, #16]
 800490a:	4413      	add	r3, r2
 800490c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004910:	691b      	ldr	r3, [r3, #16]
 8004912:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8004916:	78fa      	ldrb	r2, [r7, #3]
 8004918:	1ac9      	subs	r1, r1, r3
 800491a:	6878      	ldr	r0, [r7, #4]
 800491c:	4613      	mov	r3, r2
 800491e:	011b      	lsls	r3, r3, #4
 8004920:	1a9b      	subs	r3, r3, r2
 8004922:	009b      	lsls	r3, r3, #2
 8004924:	4403      	add	r3, r0
 8004926:	3338      	adds	r3, #56	@ 0x38
 8004928:	6019      	str	r1, [r3, #0]
    }

    hhcd->hc[chnum].state = HC_XFRC;
 800492a:	78fa      	ldrb	r2, [r7, #3]
 800492c:	6879      	ldr	r1, [r7, #4]
 800492e:	4613      	mov	r3, r2
 8004930:	011b      	lsls	r3, r3, #4
 8004932:	1a9b      	subs	r3, r3, r2
 8004934:	009b      	lsls	r3, r3, #2
 8004936:	440b      	add	r3, r1
 8004938:	334d      	adds	r3, #77	@ 0x4d
 800493a:	2201      	movs	r2, #1
 800493c:	701a      	strb	r2, [r3, #0]
    hhcd->hc[chnum].ErrCnt = 0U;
 800493e:	78fa      	ldrb	r2, [r7, #3]
 8004940:	6879      	ldr	r1, [r7, #4]
 8004942:	4613      	mov	r3, r2
 8004944:	011b      	lsls	r3, r3, #4
 8004946:	1a9b      	subs	r3, r3, r2
 8004948:	009b      	lsls	r3, r3, #2
 800494a:	440b      	add	r3, r1
 800494c:	3344      	adds	r3, #68	@ 0x44
 800494e:	2200      	movs	r2, #0
 8004950:	601a      	str	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8004952:	78fb      	ldrb	r3, [r7, #3]
 8004954:	015a      	lsls	r2, r3, #5
 8004956:	693b      	ldr	r3, [r7, #16]
 8004958:	4413      	add	r3, r2
 800495a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800495e:	461a      	mov	r2, r3
 8004960:	2301      	movs	r3, #1
 8004962:	6093      	str	r3, [r2, #8]

    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004964:	78fa      	ldrb	r2, [r7, #3]
 8004966:	6879      	ldr	r1, [r7, #4]
 8004968:	4613      	mov	r3, r2
 800496a:	011b      	lsls	r3, r3, #4
 800496c:	1a9b      	subs	r3, r3, r2
 800496e:	009b      	lsls	r3, r3, #2
 8004970:	440b      	add	r3, r1
 8004972:	3326      	adds	r3, #38	@ 0x26
 8004974:	781b      	ldrb	r3, [r3, #0]
 8004976:	2b00      	cmp	r3, #0
 8004978:	d00a      	beq.n	8004990 <HCD_HC_IN_IRQHandler+0x2fe>
        (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 800497a:	78fa      	ldrb	r2, [r7, #3]
 800497c:	6879      	ldr	r1, [r7, #4]
 800497e:	4613      	mov	r3, r2
 8004980:	011b      	lsls	r3, r3, #4
 8004982:	1a9b      	subs	r3, r3, r2
 8004984:	009b      	lsls	r3, r3, #2
 8004986:	440b      	add	r3, r1
 8004988:	3326      	adds	r3, #38	@ 0x26
 800498a:	781b      	ldrb	r3, [r3, #0]
    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800498c:	2b02      	cmp	r3, #2
 800498e:	d110      	bne.n	80049b2 <HCD_HC_IN_IRQHandler+0x320>
    {
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004990:	687b      	ldr	r3, [r7, #4]
 8004992:	681b      	ldr	r3, [r3, #0]
 8004994:	78fa      	ldrb	r2, [r7, #3]
 8004996:	4611      	mov	r1, r2
 8004998:	4618      	mov	r0, r3
 800499a:	f003 f81e 	bl	80079da <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 800499e:	78fb      	ldrb	r3, [r7, #3]
 80049a0:	015a      	lsls	r2, r3, #5
 80049a2:	693b      	ldr	r3, [r7, #16]
 80049a4:	4413      	add	r3, r2
 80049a6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80049aa:	461a      	mov	r2, r3
 80049ac:	2310      	movs	r3, #16
 80049ae:	6093      	str	r3, [r2, #8]
 80049b0:	e03d      	b.n	8004a2e <HCD_HC_IN_IRQHandler+0x39c>
    }
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_INTR) ||
 80049b2:	78fa      	ldrb	r2, [r7, #3]
 80049b4:	6879      	ldr	r1, [r7, #4]
 80049b6:	4613      	mov	r3, r2
 80049b8:	011b      	lsls	r3, r3, #4
 80049ba:	1a9b      	subs	r3, r3, r2
 80049bc:	009b      	lsls	r3, r3, #2
 80049be:	440b      	add	r3, r1
 80049c0:	3326      	adds	r3, #38	@ 0x26
 80049c2:	781b      	ldrb	r3, [r3, #0]
 80049c4:	2b03      	cmp	r3, #3
 80049c6:	d00a      	beq.n	80049de <HCD_HC_IN_IRQHandler+0x34c>
             (hhcd->hc[chnum].ep_type == EP_TYPE_ISOC))
 80049c8:	78fa      	ldrb	r2, [r7, #3]
 80049ca:	6879      	ldr	r1, [r7, #4]
 80049cc:	4613      	mov	r3, r2
 80049ce:	011b      	lsls	r3, r3, #4
 80049d0:	1a9b      	subs	r3, r3, r2
 80049d2:	009b      	lsls	r3, r3, #2
 80049d4:	440b      	add	r3, r1
 80049d6:	3326      	adds	r3, #38	@ 0x26
 80049d8:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_INTR) ||
 80049da:	2b01      	cmp	r3, #1
 80049dc:	d127      	bne.n	8004a2e <HCD_HC_IN_IRQHandler+0x39c>
    {
      USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 80049de:	78fb      	ldrb	r3, [r7, #3]
 80049e0:	015a      	lsls	r2, r3, #5
 80049e2:	693b      	ldr	r3, [r7, #16]
 80049e4:	4413      	add	r3, r2
 80049e6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80049ea:	681b      	ldr	r3, [r3, #0]
 80049ec:	78fa      	ldrb	r2, [r7, #3]
 80049ee:	0151      	lsls	r1, r2, #5
 80049f0:	693a      	ldr	r2, [r7, #16]
 80049f2:	440a      	add	r2, r1
 80049f4:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80049f8:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80049fc:	6013      	str	r3, [r2, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 80049fe:	78fa      	ldrb	r2, [r7, #3]
 8004a00:	6879      	ldr	r1, [r7, #4]
 8004a02:	4613      	mov	r3, r2
 8004a04:	011b      	lsls	r3, r3, #4
 8004a06:	1a9b      	subs	r3, r3, r2
 8004a08:	009b      	lsls	r3, r3, #2
 8004a0a:	440b      	add	r3, r1
 8004a0c:	334c      	adds	r3, #76	@ 0x4c
 8004a0e:	2201      	movs	r2, #1
 8004a10:	701a      	strb	r2, [r3, #0]

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8004a12:	78fa      	ldrb	r2, [r7, #3]
 8004a14:	6879      	ldr	r1, [r7, #4]
 8004a16:	4613      	mov	r3, r2
 8004a18:	011b      	lsls	r3, r3, #4
 8004a1a:	1a9b      	subs	r3, r3, r2
 8004a1c:	009b      	lsls	r3, r3, #2
 8004a1e:	440b      	add	r3, r1
 8004a20:	334c      	adds	r3, #76	@ 0x4c
 8004a22:	781a      	ldrb	r2, [r3, #0]
 8004a24:	78fb      	ldrb	r3, [r7, #3]
 8004a26:	4619      	mov	r1, r3
 8004a28:	6878      	ldr	r0, [r7, #4]
 8004a2a:	f02a fc87 	bl	802f33c <HAL_HCD_HC_NotifyURBChange_Callback>
    else
    {
      /* ... */
    }

    if (hhcd->Init.dma_enable == 1U)
 8004a2e:	687b      	ldr	r3, [r7, #4]
 8004a30:	799b      	ldrb	r3, [r3, #6]
 8004a32:	2b01      	cmp	r3, #1
 8004a34:	d13b      	bne.n	8004aae <HCD_HC_IN_IRQHandler+0x41c>
    {
      if ((((hhcd->hc[chnum].xfer_count + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet) & 1U) != 0U)
 8004a36:	78fa      	ldrb	r2, [r7, #3]
 8004a38:	6879      	ldr	r1, [r7, #4]
 8004a3a:	4613      	mov	r3, r2
 8004a3c:	011b      	lsls	r3, r3, #4
 8004a3e:	1a9b      	subs	r3, r3, r2
 8004a40:	009b      	lsls	r3, r3, #2
 8004a42:	440b      	add	r3, r1
 8004a44:	3338      	adds	r3, #56	@ 0x38
 8004a46:	6819      	ldr	r1, [r3, #0]
 8004a48:	78fa      	ldrb	r2, [r7, #3]
 8004a4a:	6878      	ldr	r0, [r7, #4]
 8004a4c:	4613      	mov	r3, r2
 8004a4e:	011b      	lsls	r3, r3, #4
 8004a50:	1a9b      	subs	r3, r3, r2
 8004a52:	009b      	lsls	r3, r3, #2
 8004a54:	4403      	add	r3, r0
 8004a56:	3328      	adds	r3, #40	@ 0x28
 8004a58:	881b      	ldrh	r3, [r3, #0]
 8004a5a:	440b      	add	r3, r1
 8004a5c:	1e59      	subs	r1, r3, #1
 8004a5e:	78fa      	ldrb	r2, [r7, #3]
 8004a60:	6878      	ldr	r0, [r7, #4]
 8004a62:	4613      	mov	r3, r2
 8004a64:	011b      	lsls	r3, r3, #4
 8004a66:	1a9b      	subs	r3, r3, r2
 8004a68:	009b      	lsls	r3, r3, #2
 8004a6a:	4403      	add	r3, r0
 8004a6c:	3328      	adds	r3, #40	@ 0x28
 8004a6e:	881b      	ldrh	r3, [r3, #0]
 8004a70:	fbb1 f3f3 	udiv	r3, r1, r3
 8004a74:	f003 0301 	and.w	r3, r3, #1
 8004a78:	2b00      	cmp	r3, #0
 8004a7a:	f000 8470 	beq.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
      {
        hhcd->hc[chnum].toggle_in ^= 1U;
 8004a7e:	78fa      	ldrb	r2, [r7, #3]
 8004a80:	6879      	ldr	r1, [r7, #4]
 8004a82:	4613      	mov	r3, r2
 8004a84:	011b      	lsls	r3, r3, #4
 8004a86:	1a9b      	subs	r3, r3, r2
 8004a88:	009b      	lsls	r3, r3, #2
 8004a8a:	440b      	add	r3, r1
 8004a8c:	333c      	adds	r3, #60	@ 0x3c
 8004a8e:	781b      	ldrb	r3, [r3, #0]
 8004a90:	78fa      	ldrb	r2, [r7, #3]
 8004a92:	f083 0301 	eor.w	r3, r3, #1
 8004a96:	b2d8      	uxtb	r0, r3
 8004a98:	6879      	ldr	r1, [r7, #4]
 8004a9a:	4613      	mov	r3, r2
 8004a9c:	011b      	lsls	r3, r3, #4
 8004a9e:	1a9b      	subs	r3, r3, r2
 8004aa0:	009b      	lsls	r3, r3, #2
 8004aa2:	440b      	add	r3, r1
 8004aa4:	333c      	adds	r3, #60	@ 0x3c
 8004aa6:	4602      	mov	r2, r0
 8004aa8:	701a      	strb	r2, [r3, #0]
 8004aaa:	f000 bc58 	b.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
      }
    }
    else
    {
      hhcd->hc[chnum].toggle_in ^= 1U;
 8004aae:	78fa      	ldrb	r2, [r7, #3]
 8004ab0:	6879      	ldr	r1, [r7, #4]
 8004ab2:	4613      	mov	r3, r2
 8004ab4:	011b      	lsls	r3, r3, #4
 8004ab6:	1a9b      	subs	r3, r3, r2
 8004ab8:	009b      	lsls	r3, r3, #2
 8004aba:	440b      	add	r3, r1
 8004abc:	333c      	adds	r3, #60	@ 0x3c
 8004abe:	781b      	ldrb	r3, [r3, #0]
 8004ac0:	78fa      	ldrb	r2, [r7, #3]
 8004ac2:	f083 0301 	eor.w	r3, r3, #1
 8004ac6:	b2d8      	uxtb	r0, r3
 8004ac8:	6879      	ldr	r1, [r7, #4]
 8004aca:	4613      	mov	r3, r2
 8004acc:	011b      	lsls	r3, r3, #4
 8004ace:	1a9b      	subs	r3, r3, r2
 8004ad0:	009b      	lsls	r3, r3, #2
 8004ad2:	440b      	add	r3, r1
 8004ad4:	333c      	adds	r3, #60	@ 0x3c
 8004ad6:	4602      	mov	r2, r0
 8004ad8:	701a      	strb	r2, [r3, #0]
 8004ada:	f000 bc40 	b.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 8004ade:	687b      	ldr	r3, [r7, #4]
 8004ae0:	681b      	ldr	r3, [r3, #0]
 8004ae2:	78fa      	ldrb	r2, [r7, #3]
 8004ae4:	4611      	mov	r1, r2
 8004ae6:	4618      	mov	r0, r3
 8004ae8:	f002 f9d3 	bl	8006e92 <USB_ReadChInterrupts>
 8004aec:	4603      	mov	r3, r0
 8004aee:	f003 0320 	and.w	r3, r3, #32
 8004af2:	2b20      	cmp	r3, #32
 8004af4:	d131      	bne.n	8004b5a <HCD_HC_IN_IRQHandler+0x4c8>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 8004af6:	78fb      	ldrb	r3, [r7, #3]
 8004af8:	015a      	lsls	r2, r3, #5
 8004afa:	693b      	ldr	r3, [r7, #16]
 8004afc:	4413      	add	r3, r2
 8004afe:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004b02:	461a      	mov	r2, r3
 8004b04:	2320      	movs	r3, #32
 8004b06:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_ssplit == 1U)
 8004b08:	78fa      	ldrb	r2, [r7, #3]
 8004b0a:	6879      	ldr	r1, [r7, #4]
 8004b0c:	4613      	mov	r3, r2
 8004b0e:	011b      	lsls	r3, r3, #4
 8004b10:	1a9b      	subs	r3, r3, r2
 8004b12:	009b      	lsls	r3, r3, #2
 8004b14:	440b      	add	r3, r1
 8004b16:	331a      	adds	r3, #26
 8004b18:	781b      	ldrb	r3, [r3, #0]
 8004b1a:	2b01      	cmp	r3, #1
 8004b1c:	f040 841f 	bne.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
    {
      hhcd->hc[chnum].do_csplit = 1U;
 8004b20:	78fa      	ldrb	r2, [r7, #3]
 8004b22:	6879      	ldr	r1, [r7, #4]
 8004b24:	4613      	mov	r3, r2
 8004b26:	011b      	lsls	r3, r3, #4
 8004b28:	1a9b      	subs	r3, r3, r2
 8004b2a:	009b      	lsls	r3, r3, #2
 8004b2c:	440b      	add	r3, r1
 8004b2e:	331b      	adds	r3, #27
 8004b30:	2201      	movs	r2, #1
 8004b32:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_ACK;
 8004b34:	78fa      	ldrb	r2, [r7, #3]
 8004b36:	6879      	ldr	r1, [r7, #4]
 8004b38:	4613      	mov	r3, r2
 8004b3a:	011b      	lsls	r3, r3, #4
 8004b3c:	1a9b      	subs	r3, r3, r2
 8004b3e:	009b      	lsls	r3, r3, #2
 8004b40:	440b      	add	r3, r1
 8004b42:	334d      	adds	r3, #77	@ 0x4d
 8004b44:	2203      	movs	r2, #3
 8004b46:	701a      	strb	r2, [r3, #0]

      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8004b48:	687b      	ldr	r3, [r7, #4]
 8004b4a:	681b      	ldr	r3, [r3, #0]
 8004b4c:	78fa      	ldrb	r2, [r7, #3]
 8004b4e:	4611      	mov	r1, r2
 8004b50:	4618      	mov	r0, r3
 8004b52:	f002 ff42 	bl	80079da <USB_HC_Halt>
 8004b56:	f000 bc02 	b.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 8004b5a:	687b      	ldr	r3, [r7, #4]
 8004b5c:	681b      	ldr	r3, [r3, #0]
 8004b5e:	78fa      	ldrb	r2, [r7, #3]
 8004b60:	4611      	mov	r1, r2
 8004b62:	4618      	mov	r0, r3
 8004b64:	f002 f995 	bl	8006e92 <USB_ReadChInterrupts>
 8004b68:	4603      	mov	r3, r0
 8004b6a:	f003 0302 	and.w	r3, r3, #2
 8004b6e:	2b02      	cmp	r3, #2
 8004b70:	f040 8305 	bne.w	800517e <HCD_HC_IN_IRQHandler+0xaec>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 8004b74:	78fb      	ldrb	r3, [r7, #3]
 8004b76:	015a      	lsls	r2, r3, #5
 8004b78:	693b      	ldr	r3, [r7, #16]
 8004b7a:	4413      	add	r3, r2
 8004b7c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004b80:	461a      	mov	r2, r3
 8004b82:	2302      	movs	r3, #2
 8004b84:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].state == HC_XFRC)
 8004b86:	78fa      	ldrb	r2, [r7, #3]
 8004b88:	6879      	ldr	r1, [r7, #4]
 8004b8a:	4613      	mov	r3, r2
 8004b8c:	011b      	lsls	r3, r3, #4
 8004b8e:	1a9b      	subs	r3, r3, r2
 8004b90:	009b      	lsls	r3, r3, #2
 8004b92:	440b      	add	r3, r1
 8004b94:	334d      	adds	r3, #77	@ 0x4d
 8004b96:	781b      	ldrb	r3, [r3, #0]
 8004b98:	2b01      	cmp	r3, #1
 8004b9a:	d114      	bne.n	8004bc6 <HCD_HC_IN_IRQHandler+0x534>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004b9c:	78fa      	ldrb	r2, [r7, #3]
 8004b9e:	6879      	ldr	r1, [r7, #4]
 8004ba0:	4613      	mov	r3, r2
 8004ba2:	011b      	lsls	r3, r3, #4
 8004ba4:	1a9b      	subs	r3, r3, r2
 8004ba6:	009b      	lsls	r3, r3, #2
 8004ba8:	440b      	add	r3, r1
 8004baa:	334d      	adds	r3, #77	@ 0x4d
 8004bac:	2202      	movs	r2, #2
 8004bae:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 8004bb0:	78fa      	ldrb	r2, [r7, #3]
 8004bb2:	6879      	ldr	r1, [r7, #4]
 8004bb4:	4613      	mov	r3, r2
 8004bb6:	011b      	lsls	r3, r3, #4
 8004bb8:	1a9b      	subs	r3, r3, r2
 8004bba:	009b      	lsls	r3, r3, #2
 8004bbc:	440b      	add	r3, r1
 8004bbe:	334c      	adds	r3, #76	@ 0x4c
 8004bc0:	2201      	movs	r2, #1
 8004bc2:	701a      	strb	r2, [r3, #0]
 8004bc4:	e2cc      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
    }
    else if (hhcd->hc[chnum].state == HC_STALL)
 8004bc6:	78fa      	ldrb	r2, [r7, #3]
 8004bc8:	6879      	ldr	r1, [r7, #4]
 8004bca:	4613      	mov	r3, r2
 8004bcc:	011b      	lsls	r3, r3, #4
 8004bce:	1a9b      	subs	r3, r3, r2
 8004bd0:	009b      	lsls	r3, r3, #2
 8004bd2:	440b      	add	r3, r1
 8004bd4:	334d      	adds	r3, #77	@ 0x4d
 8004bd6:	781b      	ldrb	r3, [r3, #0]
 8004bd8:	2b06      	cmp	r3, #6
 8004bda:	d114      	bne.n	8004c06 <HCD_HC_IN_IRQHandler+0x574>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004bdc:	78fa      	ldrb	r2, [r7, #3]
 8004bde:	6879      	ldr	r1, [r7, #4]
 8004be0:	4613      	mov	r3, r2
 8004be2:	011b      	lsls	r3, r3, #4
 8004be4:	1a9b      	subs	r3, r3, r2
 8004be6:	009b      	lsls	r3, r3, #2
 8004be8:	440b      	add	r3, r1
 8004bea:	334d      	adds	r3, #77	@ 0x4d
 8004bec:	2202      	movs	r2, #2
 8004bee:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_STALL;
 8004bf0:	78fa      	ldrb	r2, [r7, #3]
 8004bf2:	6879      	ldr	r1, [r7, #4]
 8004bf4:	4613      	mov	r3, r2
 8004bf6:	011b      	lsls	r3, r3, #4
 8004bf8:	1a9b      	subs	r3, r3, r2
 8004bfa:	009b      	lsls	r3, r3, #2
 8004bfc:	440b      	add	r3, r1
 8004bfe:	334c      	adds	r3, #76	@ 0x4c
 8004c00:	2205      	movs	r2, #5
 8004c02:	701a      	strb	r2, [r3, #0]
 8004c04:	e2ac      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
    }
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8004c06:	78fa      	ldrb	r2, [r7, #3]
 8004c08:	6879      	ldr	r1, [r7, #4]
 8004c0a:	4613      	mov	r3, r2
 8004c0c:	011b      	lsls	r3, r3, #4
 8004c0e:	1a9b      	subs	r3, r3, r2
 8004c10:	009b      	lsls	r3, r3, #2
 8004c12:	440b      	add	r3, r1
 8004c14:	334d      	adds	r3, #77	@ 0x4d
 8004c16:	781b      	ldrb	r3, [r3, #0]
 8004c18:	2b07      	cmp	r3, #7
 8004c1a:	d00b      	beq.n	8004c34 <HCD_HC_IN_IRQHandler+0x5a2>
             (hhcd->hc[chnum].state == HC_DATATGLERR))
 8004c1c:	78fa      	ldrb	r2, [r7, #3]
 8004c1e:	6879      	ldr	r1, [r7, #4]
 8004c20:	4613      	mov	r3, r2
 8004c22:	011b      	lsls	r3, r3, #4
 8004c24:	1a9b      	subs	r3, r3, r2
 8004c26:	009b      	lsls	r3, r3, #2
 8004c28:	440b      	add	r3, r1
 8004c2a:	334d      	adds	r3, #77	@ 0x4d
 8004c2c:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8004c2e:	2b09      	cmp	r3, #9
 8004c30:	f040 80a6 	bne.w	8004d80 <HCD_HC_IN_IRQHandler+0x6ee>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004c34:	78fa      	ldrb	r2, [r7, #3]
 8004c36:	6879      	ldr	r1, [r7, #4]
 8004c38:	4613      	mov	r3, r2
 8004c3a:	011b      	lsls	r3, r3, #4
 8004c3c:	1a9b      	subs	r3, r3, r2
 8004c3e:	009b      	lsls	r3, r3, #2
 8004c40:	440b      	add	r3, r1
 8004c42:	334d      	adds	r3, #77	@ 0x4d
 8004c44:	2202      	movs	r2, #2
 8004c46:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 8004c48:	78fa      	ldrb	r2, [r7, #3]
 8004c4a:	6879      	ldr	r1, [r7, #4]
 8004c4c:	4613      	mov	r3, r2
 8004c4e:	011b      	lsls	r3, r3, #4
 8004c50:	1a9b      	subs	r3, r3, r2
 8004c52:	009b      	lsls	r3, r3, #2
 8004c54:	440b      	add	r3, r1
 8004c56:	3344      	adds	r3, #68	@ 0x44
 8004c58:	681b      	ldr	r3, [r3, #0]
 8004c5a:	1c59      	adds	r1, r3, #1
 8004c5c:	6878      	ldr	r0, [r7, #4]
 8004c5e:	4613      	mov	r3, r2
 8004c60:	011b      	lsls	r3, r3, #4
 8004c62:	1a9b      	subs	r3, r3, r2
 8004c64:	009b      	lsls	r3, r3, #2
 8004c66:	4403      	add	r3, r0
 8004c68:	3344      	adds	r3, #68	@ 0x44
 8004c6a:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004c6c:	78fa      	ldrb	r2, [r7, #3]
 8004c6e:	6879      	ldr	r1, [r7, #4]
 8004c70:	4613      	mov	r3, r2
 8004c72:	011b      	lsls	r3, r3, #4
 8004c74:	1a9b      	subs	r3, r3, r2
 8004c76:	009b      	lsls	r3, r3, #2
 8004c78:	440b      	add	r3, r1
 8004c7a:	3344      	adds	r3, #68	@ 0x44
 8004c7c:	681b      	ldr	r3, [r3, #0]
 8004c7e:	2b02      	cmp	r3, #2
 8004c80:	d943      	bls.n	8004d0a <HCD_HC_IN_IRQHandler+0x678>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 8004c82:	78fa      	ldrb	r2, [r7, #3]
 8004c84:	6879      	ldr	r1, [r7, #4]
 8004c86:	4613      	mov	r3, r2
 8004c88:	011b      	lsls	r3, r3, #4
 8004c8a:	1a9b      	subs	r3, r3, r2
 8004c8c:	009b      	lsls	r3, r3, #2
 8004c8e:	440b      	add	r3, r1
 8004c90:	3344      	adds	r3, #68	@ 0x44
 8004c92:	2200      	movs	r2, #0
 8004c94:	601a      	str	r2, [r3, #0]

        if (hhcd->hc[chnum].do_ssplit == 1U)
 8004c96:	78fa      	ldrb	r2, [r7, #3]
 8004c98:	6879      	ldr	r1, [r7, #4]
 8004c9a:	4613      	mov	r3, r2
 8004c9c:	011b      	lsls	r3, r3, #4
 8004c9e:	1a9b      	subs	r3, r3, r2
 8004ca0:	009b      	lsls	r3, r3, #2
 8004ca2:	440b      	add	r3, r1
 8004ca4:	331a      	adds	r3, #26
 8004ca6:	781b      	ldrb	r3, [r3, #0]
 8004ca8:	2b01      	cmp	r3, #1
 8004caa:	d123      	bne.n	8004cf4 <HCD_HC_IN_IRQHandler+0x662>
        {
          hhcd->hc[chnum].do_csplit = 0U;
 8004cac:	78fa      	ldrb	r2, [r7, #3]
 8004cae:	6879      	ldr	r1, [r7, #4]
 8004cb0:	4613      	mov	r3, r2
 8004cb2:	011b      	lsls	r3, r3, #4
 8004cb4:	1a9b      	subs	r3, r3, r2
 8004cb6:	009b      	lsls	r3, r3, #2
 8004cb8:	440b      	add	r3, r1
 8004cba:	331b      	adds	r3, #27
 8004cbc:	2200      	movs	r2, #0
 8004cbe:	701a      	strb	r2, [r3, #0]
          hhcd->hc[chnum].ep_ss_schedule = 0U;
 8004cc0:	78fa      	ldrb	r2, [r7, #3]
 8004cc2:	6879      	ldr	r1, [r7, #4]
 8004cc4:	4613      	mov	r3, r2
 8004cc6:	011b      	lsls	r3, r3, #4
 8004cc8:	1a9b      	subs	r3, r3, r2
 8004cca:	009b      	lsls	r3, r3, #2
 8004ccc:	440b      	add	r3, r1
 8004cce:	331c      	adds	r3, #28
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	701a      	strb	r2, [r3, #0]
          __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8004cd4:	78fb      	ldrb	r3, [r7, #3]
 8004cd6:	015a      	lsls	r2, r3, #5
 8004cd8:	693b      	ldr	r3, [r7, #16]
 8004cda:	4413      	add	r3, r2
 8004cdc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004ce0:	685b      	ldr	r3, [r3, #4]
 8004ce2:	78fa      	ldrb	r2, [r7, #3]
 8004ce4:	0151      	lsls	r1, r2, #5
 8004ce6:	693a      	ldr	r2, [r7, #16]
 8004ce8:	440a      	add	r2, r1
 8004cea:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004cee:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004cf2:	6053      	str	r3, [r2, #4]
        }

        hhcd->hc[chnum].urb_state = URB_ERROR;
 8004cf4:	78fa      	ldrb	r2, [r7, #3]
 8004cf6:	6879      	ldr	r1, [r7, #4]
 8004cf8:	4613      	mov	r3, r2
 8004cfa:	011b      	lsls	r3, r3, #4
 8004cfc:	1a9b      	subs	r3, r3, r2
 8004cfe:	009b      	lsls	r3, r3, #2
 8004d00:	440b      	add	r3, r1
 8004d02:	334c      	adds	r3, #76	@ 0x4c
 8004d04:	2204      	movs	r2, #4
 8004d06:	701a      	strb	r2, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004d08:	e229      	b.n	800515e <HCD_HC_IN_IRQHandler+0xacc>
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8004d0a:	78fa      	ldrb	r2, [r7, #3]
 8004d0c:	6879      	ldr	r1, [r7, #4]
 8004d0e:	4613      	mov	r3, r2
 8004d10:	011b      	lsls	r3, r3, #4
 8004d12:	1a9b      	subs	r3, r3, r2
 8004d14:	009b      	lsls	r3, r3, #2
 8004d16:	440b      	add	r3, r1
 8004d18:	334c      	adds	r3, #76	@ 0x4c
 8004d1a:	2202      	movs	r2, #2
 8004d1c:	701a      	strb	r2, [r3, #0]

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004d1e:	78fa      	ldrb	r2, [r7, #3]
 8004d20:	6879      	ldr	r1, [r7, #4]
 8004d22:	4613      	mov	r3, r2
 8004d24:	011b      	lsls	r3, r3, #4
 8004d26:	1a9b      	subs	r3, r3, r2
 8004d28:	009b      	lsls	r3, r3, #2
 8004d2a:	440b      	add	r3, r1
 8004d2c:	3326      	adds	r3, #38	@ 0x26
 8004d2e:	781b      	ldrb	r3, [r3, #0]
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	d00b      	beq.n	8004d4c <HCD_HC_IN_IRQHandler+0x6ba>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8004d34:	78fa      	ldrb	r2, [r7, #3]
 8004d36:	6879      	ldr	r1, [r7, #4]
 8004d38:	4613      	mov	r3, r2
 8004d3a:	011b      	lsls	r3, r3, #4
 8004d3c:	1a9b      	subs	r3, r3, r2
 8004d3e:	009b      	lsls	r3, r3, #2
 8004d40:	440b      	add	r3, r1
 8004d42:	3326      	adds	r3, #38	@ 0x26
 8004d44:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004d46:	2b02      	cmp	r3, #2
 8004d48:	f040 8209 	bne.w	800515e <HCD_HC_IN_IRQHandler+0xacc>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 8004d4c:	78fb      	ldrb	r3, [r7, #3]
 8004d4e:	015a      	lsls	r2, r3, #5
 8004d50:	693b      	ldr	r3, [r7, #16]
 8004d52:	4413      	add	r3, r2
 8004d54:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004d58:	681b      	ldr	r3, [r3, #0]
 8004d5a:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8004d5c:	68fb      	ldr	r3, [r7, #12]
 8004d5e:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8004d62:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8004d64:	68fb      	ldr	r3, [r7, #12]
 8004d66:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8004d6a:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 8004d6c:	78fb      	ldrb	r3, [r7, #3]
 8004d6e:	015a      	lsls	r2, r3, #5
 8004d70:	693b      	ldr	r3, [r7, #16]
 8004d72:	4413      	add	r3, r2
 8004d74:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004d78:	461a      	mov	r2, r3
 8004d7a:	68fb      	ldr	r3, [r7, #12]
 8004d7c:	6013      	str	r3, [r2, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8004d7e:	e1ee      	b.n	800515e <HCD_HC_IN_IRQHandler+0xacc>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_NYET)
 8004d80:	78fa      	ldrb	r2, [r7, #3]
 8004d82:	6879      	ldr	r1, [r7, #4]
 8004d84:	4613      	mov	r3, r2
 8004d86:	011b      	lsls	r3, r3, #4
 8004d88:	1a9b      	subs	r3, r3, r2
 8004d8a:	009b      	lsls	r3, r3, #2
 8004d8c:	440b      	add	r3, r1
 8004d8e:	334d      	adds	r3, #77	@ 0x4d
 8004d90:	781b      	ldrb	r3, [r3, #0]
 8004d92:	2b05      	cmp	r3, #5
 8004d94:	f040 80c8 	bne.w	8004f28 <HCD_HC_IN_IRQHandler+0x896>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004d98:	78fa      	ldrb	r2, [r7, #3]
 8004d9a:	6879      	ldr	r1, [r7, #4]
 8004d9c:	4613      	mov	r3, r2
 8004d9e:	011b      	lsls	r3, r3, #4
 8004da0:	1a9b      	subs	r3, r3, r2
 8004da2:	009b      	lsls	r3, r3, #2
 8004da4:	440b      	add	r3, r1
 8004da6:	334d      	adds	r3, #77	@ 0x4d
 8004da8:	2202      	movs	r2, #2
 8004daa:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8004dac:	78fa      	ldrb	r2, [r7, #3]
 8004dae:	6879      	ldr	r1, [r7, #4]
 8004db0:	4613      	mov	r3, r2
 8004db2:	011b      	lsls	r3, r3, #4
 8004db4:	1a9b      	subs	r3, r3, r2
 8004db6:	009b      	lsls	r3, r3, #2
 8004db8:	440b      	add	r3, r1
 8004dba:	331b      	adds	r3, #27
 8004dbc:	781b      	ldrb	r3, [r3, #0]
 8004dbe:	2b01      	cmp	r3, #1
 8004dc0:	f040 81ce 	bne.w	8005160 <HCD_HC_IN_IRQHandler+0xace>
      {
        if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 8004dc4:	78fa      	ldrb	r2, [r7, #3]
 8004dc6:	6879      	ldr	r1, [r7, #4]
 8004dc8:	4613      	mov	r3, r2
 8004dca:	011b      	lsls	r3, r3, #4
 8004dcc:	1a9b      	subs	r3, r3, r2
 8004dce:	009b      	lsls	r3, r3, #2
 8004dd0:	440b      	add	r3, r1
 8004dd2:	3326      	adds	r3, #38	@ 0x26
 8004dd4:	781b      	ldrb	r3, [r3, #0]
 8004dd6:	2b03      	cmp	r3, #3
 8004dd8:	d16b      	bne.n	8004eb2 <HCD_HC_IN_IRQHandler+0x820>
        {
          hhcd->hc[chnum].NyetErrCnt++;
 8004dda:	78fa      	ldrb	r2, [r7, #3]
 8004ddc:	6879      	ldr	r1, [r7, #4]
 8004dde:	4613      	mov	r3, r2
 8004de0:	011b      	lsls	r3, r3, #4
 8004de2:	1a9b      	subs	r3, r3, r2
 8004de4:	009b      	lsls	r3, r3, #2
 8004de6:	440b      	add	r3, r1
 8004de8:	3348      	adds	r3, #72	@ 0x48
 8004dea:	681b      	ldr	r3, [r3, #0]
 8004dec:	1c59      	adds	r1, r3, #1
 8004dee:	6878      	ldr	r0, [r7, #4]
 8004df0:	4613      	mov	r3, r2
 8004df2:	011b      	lsls	r3, r3, #4
 8004df4:	1a9b      	subs	r3, r3, r2
 8004df6:	009b      	lsls	r3, r3, #2
 8004df8:	4403      	add	r3, r0
 8004dfa:	3348      	adds	r3, #72	@ 0x48
 8004dfc:	6019      	str	r1, [r3, #0]
          if (hhcd->hc[chnum].NyetErrCnt > 2U)
 8004dfe:	78fa      	ldrb	r2, [r7, #3]
 8004e00:	6879      	ldr	r1, [r7, #4]
 8004e02:	4613      	mov	r3, r2
 8004e04:	011b      	lsls	r3, r3, #4
 8004e06:	1a9b      	subs	r3, r3, r2
 8004e08:	009b      	lsls	r3, r3, #2
 8004e0a:	440b      	add	r3, r1
 8004e0c:	3348      	adds	r3, #72	@ 0x48
 8004e0e:	681b      	ldr	r3, [r3, #0]
 8004e10:	2b02      	cmp	r3, #2
 8004e12:	d943      	bls.n	8004e9c <HCD_HC_IN_IRQHandler+0x80a>
          {
            hhcd->hc[chnum].NyetErrCnt = 0U;
 8004e14:	78fa      	ldrb	r2, [r7, #3]
 8004e16:	6879      	ldr	r1, [r7, #4]
 8004e18:	4613      	mov	r3, r2
 8004e1a:	011b      	lsls	r3, r3, #4
 8004e1c:	1a9b      	subs	r3, r3, r2
 8004e1e:	009b      	lsls	r3, r3, #2
 8004e20:	440b      	add	r3, r1
 8004e22:	3348      	adds	r3, #72	@ 0x48
 8004e24:	2200      	movs	r2, #0
 8004e26:	601a      	str	r2, [r3, #0]
            hhcd->hc[chnum].do_csplit = 0U;
 8004e28:	78fa      	ldrb	r2, [r7, #3]
 8004e2a:	6879      	ldr	r1, [r7, #4]
 8004e2c:	4613      	mov	r3, r2
 8004e2e:	011b      	lsls	r3, r3, #4
 8004e30:	1a9b      	subs	r3, r3, r2
 8004e32:	009b      	lsls	r3, r3, #2
 8004e34:	440b      	add	r3, r1
 8004e36:	331b      	adds	r3, #27
 8004e38:	2200      	movs	r2, #0
 8004e3a:	701a      	strb	r2, [r3, #0]

            if (hhcd->hc[chnum].ErrCnt < 3U)
 8004e3c:	78fa      	ldrb	r2, [r7, #3]
 8004e3e:	6879      	ldr	r1, [r7, #4]
 8004e40:	4613      	mov	r3, r2
 8004e42:	011b      	lsls	r3, r3, #4
 8004e44:	1a9b      	subs	r3, r3, r2
 8004e46:	009b      	lsls	r3, r3, #2
 8004e48:	440b      	add	r3, r1
 8004e4a:	3344      	adds	r3, #68	@ 0x44
 8004e4c:	681b      	ldr	r3, [r3, #0]
 8004e4e:	2b02      	cmp	r3, #2
 8004e50:	d809      	bhi.n	8004e66 <HCD_HC_IN_IRQHandler+0x7d4>
            {
              hhcd->hc[chnum].ep_ss_schedule = 1U;
 8004e52:	78fa      	ldrb	r2, [r7, #3]
 8004e54:	6879      	ldr	r1, [r7, #4]
 8004e56:	4613      	mov	r3, r2
 8004e58:	011b      	lsls	r3, r3, #4
 8004e5a:	1a9b      	subs	r3, r3, r2
 8004e5c:	009b      	lsls	r3, r3, #2
 8004e5e:	440b      	add	r3, r1
 8004e60:	331c      	adds	r3, #28
 8004e62:	2201      	movs	r2, #1
 8004e64:	701a      	strb	r2, [r3, #0]
            }
            __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8004e66:	78fb      	ldrb	r3, [r7, #3]
 8004e68:	015a      	lsls	r2, r3, #5
 8004e6a:	693b      	ldr	r3, [r7, #16]
 8004e6c:	4413      	add	r3, r2
 8004e6e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004e72:	685b      	ldr	r3, [r3, #4]
 8004e74:	78fa      	ldrb	r2, [r7, #3]
 8004e76:	0151      	lsls	r1, r2, #5
 8004e78:	693a      	ldr	r2, [r7, #16]
 8004e7a:	440a      	add	r2, r1
 8004e7c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004e80:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004e84:	6053      	str	r3, [r2, #4]
            hhcd->hc[chnum].urb_state = URB_ERROR;
 8004e86:	78fa      	ldrb	r2, [r7, #3]
 8004e88:	6879      	ldr	r1, [r7, #4]
 8004e8a:	4613      	mov	r3, r2
 8004e8c:	011b      	lsls	r3, r3, #4
 8004e8e:	1a9b      	subs	r3, r3, r2
 8004e90:	009b      	lsls	r3, r3, #2
 8004e92:	440b      	add	r3, r1
 8004e94:	334c      	adds	r3, #76	@ 0x4c
 8004e96:	2204      	movs	r2, #4
 8004e98:	701a      	strb	r2, [r3, #0]
 8004e9a:	e014      	b.n	8004ec6 <HCD_HC_IN_IRQHandler+0x834>
          }
          else
          {
            hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8004e9c:	78fa      	ldrb	r2, [r7, #3]
 8004e9e:	6879      	ldr	r1, [r7, #4]
 8004ea0:	4613      	mov	r3, r2
 8004ea2:	011b      	lsls	r3, r3, #4
 8004ea4:	1a9b      	subs	r3, r3, r2
 8004ea6:	009b      	lsls	r3, r3, #2
 8004ea8:	440b      	add	r3, r1
 8004eaa:	334c      	adds	r3, #76	@ 0x4c
 8004eac:	2202      	movs	r2, #2
 8004eae:	701a      	strb	r2, [r3, #0]
 8004eb0:	e009      	b.n	8004ec6 <HCD_HC_IN_IRQHandler+0x834>
          }
        }
        else
        {
          hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8004eb2:	78fa      	ldrb	r2, [r7, #3]
 8004eb4:	6879      	ldr	r1, [r7, #4]
 8004eb6:	4613      	mov	r3, r2
 8004eb8:	011b      	lsls	r3, r3, #4
 8004eba:	1a9b      	subs	r3, r3, r2
 8004ebc:	009b      	lsls	r3, r3, #2
 8004ebe:	440b      	add	r3, r1
 8004ec0:	334c      	adds	r3, #76	@ 0x4c
 8004ec2:	2202      	movs	r2, #2
 8004ec4:	701a      	strb	r2, [r3, #0]
        }

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004ec6:	78fa      	ldrb	r2, [r7, #3]
 8004ec8:	6879      	ldr	r1, [r7, #4]
 8004eca:	4613      	mov	r3, r2
 8004ecc:	011b      	lsls	r3, r3, #4
 8004ece:	1a9b      	subs	r3, r3, r2
 8004ed0:	009b      	lsls	r3, r3, #2
 8004ed2:	440b      	add	r3, r1
 8004ed4:	3326      	adds	r3, #38	@ 0x26
 8004ed6:	781b      	ldrb	r3, [r3, #0]
 8004ed8:	2b00      	cmp	r3, #0
 8004eda:	d00b      	beq.n	8004ef4 <HCD_HC_IN_IRQHandler+0x862>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8004edc:	78fa      	ldrb	r2, [r7, #3]
 8004ede:	6879      	ldr	r1, [r7, #4]
 8004ee0:	4613      	mov	r3, r2
 8004ee2:	011b      	lsls	r3, r3, #4
 8004ee4:	1a9b      	subs	r3, r3, r2
 8004ee6:	009b      	lsls	r3, r3, #2
 8004ee8:	440b      	add	r3, r1
 8004eea:	3326      	adds	r3, #38	@ 0x26
 8004eec:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004eee:	2b02      	cmp	r3, #2
 8004ef0:	f040 8136 	bne.w	8005160 <HCD_HC_IN_IRQHandler+0xace>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 8004ef4:	78fb      	ldrb	r3, [r7, #3]
 8004ef6:	015a      	lsls	r2, r3, #5
 8004ef8:	693b      	ldr	r3, [r7, #16]
 8004efa:	4413      	add	r3, r2
 8004efc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004f00:	681b      	ldr	r3, [r3, #0]
 8004f02:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8004f04:	68fb      	ldr	r3, [r7, #12]
 8004f06:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8004f0a:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8004f0c:	68fb      	ldr	r3, [r7, #12]
 8004f0e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8004f12:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 8004f14:	78fb      	ldrb	r3, [r7, #3]
 8004f16:	015a      	lsls	r2, r3, #5
 8004f18:	693b      	ldr	r3, [r7, #16]
 8004f1a:	4413      	add	r3, r2
 8004f1c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004f20:	461a      	mov	r2, r3
 8004f22:	68fb      	ldr	r3, [r7, #12]
 8004f24:	6013      	str	r3, [r2, #0]
 8004f26:	e11b      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_ACK)
 8004f28:	78fa      	ldrb	r2, [r7, #3]
 8004f2a:	6879      	ldr	r1, [r7, #4]
 8004f2c:	4613      	mov	r3, r2
 8004f2e:	011b      	lsls	r3, r3, #4
 8004f30:	1a9b      	subs	r3, r3, r2
 8004f32:	009b      	lsls	r3, r3, #2
 8004f34:	440b      	add	r3, r1
 8004f36:	334d      	adds	r3, #77	@ 0x4d
 8004f38:	781b      	ldrb	r3, [r3, #0]
 8004f3a:	2b03      	cmp	r3, #3
 8004f3c:	f040 8081 	bne.w	8005042 <HCD_HC_IN_IRQHandler+0x9b0>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8004f40:	78fa      	ldrb	r2, [r7, #3]
 8004f42:	6879      	ldr	r1, [r7, #4]
 8004f44:	4613      	mov	r3, r2
 8004f46:	011b      	lsls	r3, r3, #4
 8004f48:	1a9b      	subs	r3, r3, r2
 8004f4a:	009b      	lsls	r3, r3, #2
 8004f4c:	440b      	add	r3, r1
 8004f4e:	334d      	adds	r3, #77	@ 0x4d
 8004f50:	2202      	movs	r2, #2
 8004f52:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8004f54:	78fa      	ldrb	r2, [r7, #3]
 8004f56:	6879      	ldr	r1, [r7, #4]
 8004f58:	4613      	mov	r3, r2
 8004f5a:	011b      	lsls	r3, r3, #4
 8004f5c:	1a9b      	subs	r3, r3, r2
 8004f5e:	009b      	lsls	r3, r3, #2
 8004f60:	440b      	add	r3, r1
 8004f62:	331b      	adds	r3, #27
 8004f64:	781b      	ldrb	r3, [r3, #0]
 8004f66:	2b01      	cmp	r3, #1
 8004f68:	f040 80fa 	bne.w	8005160 <HCD_HC_IN_IRQHandler+0xace>
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8004f6c:	78fa      	ldrb	r2, [r7, #3]
 8004f6e:	6879      	ldr	r1, [r7, #4]
 8004f70:	4613      	mov	r3, r2
 8004f72:	011b      	lsls	r3, r3, #4
 8004f74:	1a9b      	subs	r3, r3, r2
 8004f76:	009b      	lsls	r3, r3, #2
 8004f78:	440b      	add	r3, r1
 8004f7a:	334c      	adds	r3, #76	@ 0x4c
 8004f7c:	2202      	movs	r2, #2
 8004f7e:	701a      	strb	r2, [r3, #0]

        /* Set Complete split and re-activate the channel */
        USBx_HC(chnum)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 8004f80:	78fb      	ldrb	r3, [r7, #3]
 8004f82:	015a      	lsls	r2, r3, #5
 8004f84:	693b      	ldr	r3, [r7, #16]
 8004f86:	4413      	add	r3, r2
 8004f88:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004f8c:	685b      	ldr	r3, [r3, #4]
 8004f8e:	78fa      	ldrb	r2, [r7, #3]
 8004f90:	0151      	lsls	r1, r2, #5
 8004f92:	693a      	ldr	r2, [r7, #16]
 8004f94:	440a      	add	r2, r1
 8004f96:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004f9a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004f9e:	6053      	str	r3, [r2, #4]
        USBx_HC(chnum)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 8004fa0:	78fb      	ldrb	r3, [r7, #3]
 8004fa2:	015a      	lsls	r2, r3, #5
 8004fa4:	693b      	ldr	r3, [r7, #16]
 8004fa6:	4413      	add	r3, r2
 8004fa8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004fac:	68db      	ldr	r3, [r3, #12]
 8004fae:	78fa      	ldrb	r2, [r7, #3]
 8004fb0:	0151      	lsls	r1, r2, #5
 8004fb2:	693a      	ldr	r2, [r7, #16]
 8004fb4:	440a      	add	r2, r1
 8004fb6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004fba:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8004fbe:	60d3      	str	r3, [r2, #12]
        USBx_HC(chnum)->HCINTMSK &= ~USB_OTG_HCINT_ACK;
 8004fc0:	78fb      	ldrb	r3, [r7, #3]
 8004fc2:	015a      	lsls	r2, r3, #5
 8004fc4:	693b      	ldr	r3, [r7, #16]
 8004fc6:	4413      	add	r3, r2
 8004fc8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8004fcc:	68db      	ldr	r3, [r3, #12]
 8004fce:	78fa      	ldrb	r2, [r7, #3]
 8004fd0:	0151      	lsls	r1, r2, #5
 8004fd2:	693a      	ldr	r2, [r7, #16]
 8004fd4:	440a      	add	r2, r1
 8004fd6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8004fda:	f023 0320 	bic.w	r3, r3, #32
 8004fde:	60d3      	str	r3, [r2, #12]

        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8004fe0:	78fa      	ldrb	r2, [r7, #3]
 8004fe2:	6879      	ldr	r1, [r7, #4]
 8004fe4:	4613      	mov	r3, r2
 8004fe6:	011b      	lsls	r3, r3, #4
 8004fe8:	1a9b      	subs	r3, r3, r2
 8004fea:	009b      	lsls	r3, r3, #2
 8004fec:	440b      	add	r3, r1
 8004fee:	3326      	adds	r3, #38	@ 0x26
 8004ff0:	781b      	ldrb	r3, [r3, #0]
 8004ff2:	2b00      	cmp	r3, #0
 8004ff4:	d00b      	beq.n	800500e <HCD_HC_IN_IRQHandler+0x97c>
            (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8004ff6:	78fa      	ldrb	r2, [r7, #3]
 8004ff8:	6879      	ldr	r1, [r7, #4]
 8004ffa:	4613      	mov	r3, r2
 8004ffc:	011b      	lsls	r3, r3, #4
 8004ffe:	1a9b      	subs	r3, r3, r2
 8005000:	009b      	lsls	r3, r3, #2
 8005002:	440b      	add	r3, r1
 8005004:	3326      	adds	r3, #38	@ 0x26
 8005006:	781b      	ldrb	r3, [r3, #0]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005008:	2b02      	cmp	r3, #2
 800500a:	f040 80a9 	bne.w	8005160 <HCD_HC_IN_IRQHandler+0xace>
        {
          /* re-activate the channel */
          tmpreg = USBx_HC(chnum)->HCCHAR;
 800500e:	78fb      	ldrb	r3, [r7, #3]
 8005010:	015a      	lsls	r2, r3, #5
 8005012:	693b      	ldr	r3, [r7, #16]
 8005014:	4413      	add	r3, r2
 8005016:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800501a:	681b      	ldr	r3, [r3, #0]
 800501c:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800501e:	68fb      	ldr	r3, [r7, #12]
 8005020:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005024:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005026:	68fb      	ldr	r3, [r7, #12]
 8005028:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800502c:	60fb      	str	r3, [r7, #12]
          USBx_HC(chnum)->HCCHAR = tmpreg;
 800502e:	78fb      	ldrb	r3, [r7, #3]
 8005030:	015a      	lsls	r2, r3, #5
 8005032:	693b      	ldr	r3, [r7, #16]
 8005034:	4413      	add	r3, r2
 8005036:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800503a:	461a      	mov	r2, r3
 800503c:	68fb      	ldr	r3, [r7, #12]
 800503e:	6013      	str	r3, [r2, #0]
 8005040:	e08e      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_NAK)
 8005042:	78fa      	ldrb	r2, [r7, #3]
 8005044:	6879      	ldr	r1, [r7, #4]
 8005046:	4613      	mov	r3, r2
 8005048:	011b      	lsls	r3, r3, #4
 800504a:	1a9b      	subs	r3, r3, r2
 800504c:	009b      	lsls	r3, r3, #2
 800504e:	440b      	add	r3, r1
 8005050:	334d      	adds	r3, #77	@ 0x4d
 8005052:	781b      	ldrb	r3, [r3, #0]
 8005054:	2b04      	cmp	r3, #4
 8005056:	d143      	bne.n	80050e0 <HCD_HC_IN_IRQHandler+0xa4e>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005058:	78fa      	ldrb	r2, [r7, #3]
 800505a:	6879      	ldr	r1, [r7, #4]
 800505c:	4613      	mov	r3, r2
 800505e:	011b      	lsls	r3, r3, #4
 8005060:	1a9b      	subs	r3, r3, r2
 8005062:	009b      	lsls	r3, r3, #2
 8005064:	440b      	add	r3, r1
 8005066:	334d      	adds	r3, #77	@ 0x4d
 8005068:	2202      	movs	r2, #2
 800506a:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 800506c:	78fa      	ldrb	r2, [r7, #3]
 800506e:	6879      	ldr	r1, [r7, #4]
 8005070:	4613      	mov	r3, r2
 8005072:	011b      	lsls	r3, r3, #4
 8005074:	1a9b      	subs	r3, r3, r2
 8005076:	009b      	lsls	r3, r3, #2
 8005078:	440b      	add	r3, r1
 800507a:	334c      	adds	r3, #76	@ 0x4c
 800507c:	2202      	movs	r2, #2
 800507e:	701a      	strb	r2, [r3, #0]

      if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005080:	78fa      	ldrb	r2, [r7, #3]
 8005082:	6879      	ldr	r1, [r7, #4]
 8005084:	4613      	mov	r3, r2
 8005086:	011b      	lsls	r3, r3, #4
 8005088:	1a9b      	subs	r3, r3, r2
 800508a:	009b      	lsls	r3, r3, #2
 800508c:	440b      	add	r3, r1
 800508e:	3326      	adds	r3, #38	@ 0x26
 8005090:	781b      	ldrb	r3, [r3, #0]
 8005092:	2b00      	cmp	r3, #0
 8005094:	d00a      	beq.n	80050ac <HCD_HC_IN_IRQHandler+0xa1a>
          (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8005096:	78fa      	ldrb	r2, [r7, #3]
 8005098:	6879      	ldr	r1, [r7, #4]
 800509a:	4613      	mov	r3, r2
 800509c:	011b      	lsls	r3, r3, #4
 800509e:	1a9b      	subs	r3, r3, r2
 80050a0:	009b      	lsls	r3, r3, #2
 80050a2:	440b      	add	r3, r1
 80050a4:	3326      	adds	r3, #38	@ 0x26
 80050a6:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 80050a8:	2b02      	cmp	r3, #2
 80050aa:	d159      	bne.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
      {
        /* re-activate the channel */
        tmpreg = USBx_HC(chnum)->HCCHAR;
 80050ac:	78fb      	ldrb	r3, [r7, #3]
 80050ae:	015a      	lsls	r2, r3, #5
 80050b0:	693b      	ldr	r3, [r7, #16]
 80050b2:	4413      	add	r3, r2
 80050b4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80050b8:	681b      	ldr	r3, [r3, #0]
 80050ba:	60fb      	str	r3, [r7, #12]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80050bc:	68fb      	ldr	r3, [r7, #12]
 80050be:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80050c2:	60fb      	str	r3, [r7, #12]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 80050c4:	68fb      	ldr	r3, [r7, #12]
 80050c6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80050ca:	60fb      	str	r3, [r7, #12]
        USBx_HC(chnum)->HCCHAR = tmpreg;
 80050cc:	78fb      	ldrb	r3, [r7, #3]
 80050ce:	015a      	lsls	r2, r3, #5
 80050d0:	693b      	ldr	r3, [r7, #16]
 80050d2:	4413      	add	r3, r2
 80050d4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80050d8:	461a      	mov	r2, r3
 80050da:	68fb      	ldr	r3, [r7, #12]
 80050dc:	6013      	str	r3, [r2, #0]
 80050de:	e03f      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
      }
    }
    else if (hhcd->hc[chnum].state == HC_BBLERR)
 80050e0:	78fa      	ldrb	r2, [r7, #3]
 80050e2:	6879      	ldr	r1, [r7, #4]
 80050e4:	4613      	mov	r3, r2
 80050e6:	011b      	lsls	r3, r3, #4
 80050e8:	1a9b      	subs	r3, r3, r2
 80050ea:	009b      	lsls	r3, r3, #2
 80050ec:	440b      	add	r3, r1
 80050ee:	334d      	adds	r3, #77	@ 0x4d
 80050f0:	781b      	ldrb	r3, [r3, #0]
 80050f2:	2b08      	cmp	r3, #8
 80050f4:	d126      	bne.n	8005144 <HCD_HC_IN_IRQHandler+0xab2>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 80050f6:	78fa      	ldrb	r2, [r7, #3]
 80050f8:	6879      	ldr	r1, [r7, #4]
 80050fa:	4613      	mov	r3, r2
 80050fc:	011b      	lsls	r3, r3, #4
 80050fe:	1a9b      	subs	r3, r3, r2
 8005100:	009b      	lsls	r3, r3, #2
 8005102:	440b      	add	r3, r1
 8005104:	334d      	adds	r3, #77	@ 0x4d
 8005106:	2202      	movs	r2, #2
 8005108:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 800510a:	78fa      	ldrb	r2, [r7, #3]
 800510c:	6879      	ldr	r1, [r7, #4]
 800510e:	4613      	mov	r3, r2
 8005110:	011b      	lsls	r3, r3, #4
 8005112:	1a9b      	subs	r3, r3, r2
 8005114:	009b      	lsls	r3, r3, #2
 8005116:	440b      	add	r3, r1
 8005118:	3344      	adds	r3, #68	@ 0x44
 800511a:	681b      	ldr	r3, [r3, #0]
 800511c:	1c59      	adds	r1, r3, #1
 800511e:	6878      	ldr	r0, [r7, #4]
 8005120:	4613      	mov	r3, r2
 8005122:	011b      	lsls	r3, r3, #4
 8005124:	1a9b      	subs	r3, r3, r2
 8005126:	009b      	lsls	r3, r3, #2
 8005128:	4403      	add	r3, r0
 800512a:	3344      	adds	r3, #68	@ 0x44
 800512c:	6019      	str	r1, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_ERROR;
 800512e:	78fa      	ldrb	r2, [r7, #3]
 8005130:	6879      	ldr	r1, [r7, #4]
 8005132:	4613      	mov	r3, r2
 8005134:	011b      	lsls	r3, r3, #4
 8005136:	1a9b      	subs	r3, r3, r2
 8005138:	009b      	lsls	r3, r3, #2
 800513a:	440b      	add	r3, r1
 800513c:	334c      	adds	r3, #76	@ 0x4c
 800513e:	2204      	movs	r2, #4
 8005140:	701a      	strb	r2, [r3, #0]
 8005142:	e00d      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
    }
    else
    {
      if (hhcd->hc[chnum].state == HC_HALTED)
 8005144:	78fa      	ldrb	r2, [r7, #3]
 8005146:	6879      	ldr	r1, [r7, #4]
 8005148:	4613      	mov	r3, r2
 800514a:	011b      	lsls	r3, r3, #4
 800514c:	1a9b      	subs	r3, r3, r2
 800514e:	009b      	lsls	r3, r3, #2
 8005150:	440b      	add	r3, r1
 8005152:	334d      	adds	r3, #77	@ 0x4d
 8005154:	781b      	ldrb	r3, [r3, #0]
 8005156:	2b02      	cmp	r3, #2
 8005158:	f000 8100 	beq.w	800535c <HCD_HC_IN_IRQHandler+0xcca>
 800515c:	e000      	b.n	8005160 <HCD_HC_IN_IRQHandler+0xace>
      if (hhcd->hc[chnum].ErrCnt > 2U)
 800515e:	bf00      	nop
    }

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
    hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8005160:	78fa      	ldrb	r2, [r7, #3]
 8005162:	6879      	ldr	r1, [r7, #4]
 8005164:	4613      	mov	r3, r2
 8005166:	011b      	lsls	r3, r3, #4
 8005168:	1a9b      	subs	r3, r3, r2
 800516a:	009b      	lsls	r3, r3, #2
 800516c:	440b      	add	r3, r1
 800516e:	334c      	adds	r3, #76	@ 0x4c
 8005170:	781a      	ldrb	r2, [r3, #0]
 8005172:	78fb      	ldrb	r3, [r7, #3]
 8005174:	4619      	mov	r1, r3
 8005176:	6878      	ldr	r0, [r7, #4]
 8005178:	f02a f8e0 	bl	802f33c <HAL_HCD_HC_NotifyURBChange_Callback>
 800517c:	e0ef      	b.n	800535e <HCD_HC_IN_IRQHandler+0xccc>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 800517e:	687b      	ldr	r3, [r7, #4]
 8005180:	681b      	ldr	r3, [r3, #0]
 8005182:	78fa      	ldrb	r2, [r7, #3]
 8005184:	4611      	mov	r1, r2
 8005186:	4618      	mov	r0, r3
 8005188:	f001 fe83 	bl	8006e92 <USB_ReadChInterrupts>
 800518c:	4603      	mov	r3, r0
 800518e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8005192:	2b40      	cmp	r3, #64	@ 0x40
 8005194:	d12f      	bne.n	80051f6 <HCD_HC_IN_IRQHandler+0xb64>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8005196:	78fb      	ldrb	r3, [r7, #3]
 8005198:	015a      	lsls	r2, r3, #5
 800519a:	693b      	ldr	r3, [r7, #16]
 800519c:	4413      	add	r3, r2
 800519e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80051a2:	461a      	mov	r2, r3
 80051a4:	2340      	movs	r3, #64	@ 0x40
 80051a6:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_NYET;
 80051a8:	78fa      	ldrb	r2, [r7, #3]
 80051aa:	6879      	ldr	r1, [r7, #4]
 80051ac:	4613      	mov	r3, r2
 80051ae:	011b      	lsls	r3, r3, #4
 80051b0:	1a9b      	subs	r3, r3, r2
 80051b2:	009b      	lsls	r3, r3, #2
 80051b4:	440b      	add	r3, r1
 80051b6:	334d      	adds	r3, #77	@ 0x4d
 80051b8:	2205      	movs	r2, #5
 80051ba:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ssplit == 0U)
 80051bc:	78fa      	ldrb	r2, [r7, #3]
 80051be:	6879      	ldr	r1, [r7, #4]
 80051c0:	4613      	mov	r3, r2
 80051c2:	011b      	lsls	r3, r3, #4
 80051c4:	1a9b      	subs	r3, r3, r2
 80051c6:	009b      	lsls	r3, r3, #2
 80051c8:	440b      	add	r3, r1
 80051ca:	331a      	adds	r3, #26
 80051cc:	781b      	ldrb	r3, [r3, #0]
 80051ce:	2b00      	cmp	r3, #0
 80051d0:	d109      	bne.n	80051e6 <HCD_HC_IN_IRQHandler+0xb54>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 80051d2:	78fa      	ldrb	r2, [r7, #3]
 80051d4:	6879      	ldr	r1, [r7, #4]
 80051d6:	4613      	mov	r3, r2
 80051d8:	011b      	lsls	r3, r3, #4
 80051da:	1a9b      	subs	r3, r3, r2
 80051dc:	009b      	lsls	r3, r3, #2
 80051de:	440b      	add	r3, r1
 80051e0:	3344      	adds	r3, #68	@ 0x44
 80051e2:	2200      	movs	r2, #0
 80051e4:	601a      	str	r2, [r3, #0]
    }

    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80051e6:	687b      	ldr	r3, [r7, #4]
 80051e8:	681b      	ldr	r3, [r3, #0]
 80051ea:	78fa      	ldrb	r2, [r7, #3]
 80051ec:	4611      	mov	r1, r2
 80051ee:	4618      	mov	r0, r3
 80051f0:	f002 fbf3 	bl	80079da <USB_HC_Halt>
 80051f4:	e0b3      	b.n	800535e <HCD_HC_IN_IRQHandler+0xccc>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 80051f6:	687b      	ldr	r3, [r7, #4]
 80051f8:	681b      	ldr	r3, [r3, #0]
 80051fa:	78fa      	ldrb	r2, [r7, #3]
 80051fc:	4611      	mov	r1, r2
 80051fe:	4618      	mov	r0, r3
 8005200:	f001 fe47 	bl	8006e92 <USB_ReadChInterrupts>
 8005204:	4603      	mov	r3, r0
 8005206:	f003 0310 	and.w	r3, r3, #16
 800520a:	2b10      	cmp	r3, #16
 800520c:	f040 80a7 	bne.w	800535e <HCD_HC_IN_IRQHandler+0xccc>
  {
    if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 8005210:	78fa      	ldrb	r2, [r7, #3]
 8005212:	6879      	ldr	r1, [r7, #4]
 8005214:	4613      	mov	r3, r2
 8005216:	011b      	lsls	r3, r3, #4
 8005218:	1a9b      	subs	r3, r3, r2
 800521a:	009b      	lsls	r3, r3, #2
 800521c:	440b      	add	r3, r1
 800521e:	3326      	adds	r3, #38	@ 0x26
 8005220:	781b      	ldrb	r3, [r3, #0]
 8005222:	2b03      	cmp	r3, #3
 8005224:	d11b      	bne.n	800525e <HCD_HC_IN_IRQHandler+0xbcc>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 8005226:	78fa      	ldrb	r2, [r7, #3]
 8005228:	6879      	ldr	r1, [r7, #4]
 800522a:	4613      	mov	r3, r2
 800522c:	011b      	lsls	r3, r3, #4
 800522e:	1a9b      	subs	r3, r3, r2
 8005230:	009b      	lsls	r3, r3, #2
 8005232:	440b      	add	r3, r1
 8005234:	3344      	adds	r3, #68	@ 0x44
 8005236:	2200      	movs	r2, #0
 8005238:	601a      	str	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_NAK;
 800523a:	78fa      	ldrb	r2, [r7, #3]
 800523c:	6879      	ldr	r1, [r7, #4]
 800523e:	4613      	mov	r3, r2
 8005240:	011b      	lsls	r3, r3, #4
 8005242:	1a9b      	subs	r3, r3, r2
 8005244:	009b      	lsls	r3, r3, #2
 8005246:	440b      	add	r3, r1
 8005248:	334d      	adds	r3, #77	@ 0x4d
 800524a:	2204      	movs	r2, #4
 800524c:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 800524e:	687b      	ldr	r3, [r7, #4]
 8005250:	681b      	ldr	r3, [r3, #0]
 8005252:	78fa      	ldrb	r2, [r7, #3]
 8005254:	4611      	mov	r1, r2
 8005256:	4618      	mov	r0, r3
 8005258:	f002 fbbf 	bl	80079da <USB_HC_Halt>
 800525c:	e03f      	b.n	80052de <HCD_HC_IN_IRQHandler+0xc4c>
    }
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800525e:	78fa      	ldrb	r2, [r7, #3]
 8005260:	6879      	ldr	r1, [r7, #4]
 8005262:	4613      	mov	r3, r2
 8005264:	011b      	lsls	r3, r3, #4
 8005266:	1a9b      	subs	r3, r3, r2
 8005268:	009b      	lsls	r3, r3, #2
 800526a:	440b      	add	r3, r1
 800526c:	3326      	adds	r3, #38	@ 0x26
 800526e:	781b      	ldrb	r3, [r3, #0]
 8005270:	2b00      	cmp	r3, #0
 8005272:	d00a      	beq.n	800528a <HCD_HC_IN_IRQHandler+0xbf8>
             (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
 8005274:	78fa      	ldrb	r2, [r7, #3]
 8005276:	6879      	ldr	r1, [r7, #4]
 8005278:	4613      	mov	r3, r2
 800527a:	011b      	lsls	r3, r3, #4
 800527c:	1a9b      	subs	r3, r3, r2
 800527e:	009b      	lsls	r3, r3, #2
 8005280:	440b      	add	r3, r1
 8005282:	3326      	adds	r3, #38	@ 0x26
 8005284:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8005286:	2b02      	cmp	r3, #2
 8005288:	d129      	bne.n	80052de <HCD_HC_IN_IRQHandler+0xc4c>
    {
      hhcd->hc[chnum].ErrCnt = 0U;
 800528a:	78fa      	ldrb	r2, [r7, #3]
 800528c:	6879      	ldr	r1, [r7, #4]
 800528e:	4613      	mov	r3, r2
 8005290:	011b      	lsls	r3, r3, #4
 8005292:	1a9b      	subs	r3, r3, r2
 8005294:	009b      	lsls	r3, r3, #2
 8005296:	440b      	add	r3, r1
 8005298:	3344      	adds	r3, #68	@ 0x44
 800529a:	2200      	movs	r2, #0
 800529c:	601a      	str	r2, [r3, #0]

      if ((hhcd->Init.dma_enable == 0U) || (hhcd->hc[chnum].do_csplit == 1U))
 800529e:	687b      	ldr	r3, [r7, #4]
 80052a0:	799b      	ldrb	r3, [r3, #6]
 80052a2:	2b00      	cmp	r3, #0
 80052a4:	d00a      	beq.n	80052bc <HCD_HC_IN_IRQHandler+0xc2a>
 80052a6:	78fa      	ldrb	r2, [r7, #3]
 80052a8:	6879      	ldr	r1, [r7, #4]
 80052aa:	4613      	mov	r3, r2
 80052ac:	011b      	lsls	r3, r3, #4
 80052ae:	1a9b      	subs	r3, r3, r2
 80052b0:	009b      	lsls	r3, r3, #2
 80052b2:	440b      	add	r3, r1
 80052b4:	331b      	adds	r3, #27
 80052b6:	781b      	ldrb	r3, [r3, #0]
 80052b8:	2b01      	cmp	r3, #1
 80052ba:	d110      	bne.n	80052de <HCD_HC_IN_IRQHandler+0xc4c>
      {
        hhcd->hc[chnum].state = HC_NAK;
 80052bc:	78fa      	ldrb	r2, [r7, #3]
 80052be:	6879      	ldr	r1, [r7, #4]
 80052c0:	4613      	mov	r3, r2
 80052c2:	011b      	lsls	r3, r3, #4
 80052c4:	1a9b      	subs	r3, r3, r2
 80052c6:	009b      	lsls	r3, r3, #2
 80052c8:	440b      	add	r3, r1
 80052ca:	334d      	adds	r3, #77	@ 0x4d
 80052cc:	2204      	movs	r2, #4
 80052ce:	701a      	strb	r2, [r3, #0]
        (void)USB_HC_Halt(hhcd->Instance, chnum);
 80052d0:	687b      	ldr	r3, [r7, #4]
 80052d2:	681b      	ldr	r3, [r3, #0]
 80052d4:	78fa      	ldrb	r2, [r7, #3]
 80052d6:	4611      	mov	r1, r2
 80052d8:	4618      	mov	r0, r3
 80052da:	f002 fb7e 	bl	80079da <USB_HC_Halt>
    else
    {
      /* ... */
    }

    if (hhcd->hc[chnum].do_csplit == 1U)
 80052de:	78fa      	ldrb	r2, [r7, #3]
 80052e0:	6879      	ldr	r1, [r7, #4]
 80052e2:	4613      	mov	r3, r2
 80052e4:	011b      	lsls	r3, r3, #4
 80052e6:	1a9b      	subs	r3, r3, r2
 80052e8:	009b      	lsls	r3, r3, #2
 80052ea:	440b      	add	r3, r1
 80052ec:	331b      	adds	r3, #27
 80052ee:	781b      	ldrb	r3, [r3, #0]
 80052f0:	2b01      	cmp	r3, #1
 80052f2:	d129      	bne.n	8005348 <HCD_HC_IN_IRQHandler+0xcb6>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 80052f4:	78fa      	ldrb	r2, [r7, #3]
 80052f6:	6879      	ldr	r1, [r7, #4]
 80052f8:	4613      	mov	r3, r2
 80052fa:	011b      	lsls	r3, r3, #4
 80052fc:	1a9b      	subs	r3, r3, r2
 80052fe:	009b      	lsls	r3, r3, #2
 8005300:	440b      	add	r3, r1
 8005302:	331b      	adds	r3, #27
 8005304:	2200      	movs	r2, #0
 8005306:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8005308:	78fb      	ldrb	r3, [r7, #3]
 800530a:	015a      	lsls	r2, r3, #5
 800530c:	693b      	ldr	r3, [r7, #16]
 800530e:	4413      	add	r3, r2
 8005310:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005314:	685b      	ldr	r3, [r3, #4]
 8005316:	78fa      	ldrb	r2, [r7, #3]
 8005318:	0151      	lsls	r1, r2, #5
 800531a:	693a      	ldr	r2, [r7, #16]
 800531c:	440a      	add	r2, r1
 800531e:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005322:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005326:	6053      	str	r3, [r2, #4]
      __HAL_HCD_UNMASK_ACK_HC_INT(chnum);
 8005328:	78fb      	ldrb	r3, [r7, #3]
 800532a:	015a      	lsls	r2, r3, #5
 800532c:	693b      	ldr	r3, [r7, #16]
 800532e:	4413      	add	r3, r2
 8005330:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005334:	68db      	ldr	r3, [r3, #12]
 8005336:	78fa      	ldrb	r2, [r7, #3]
 8005338:	0151      	lsls	r1, r2, #5
 800533a:	693a      	ldr	r2, [r7, #16]
 800533c:	440a      	add	r2, r1
 800533e:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005342:	f043 0320 	orr.w	r3, r3, #32
 8005346:	60d3      	str	r3, [r2, #12]
    }

    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8005348:	78fb      	ldrb	r3, [r7, #3]
 800534a:	015a      	lsls	r2, r3, #5
 800534c:	693b      	ldr	r3, [r7, #16]
 800534e:	4413      	add	r3, r2
 8005350:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005354:	461a      	mov	r2, r3
 8005356:	2310      	movs	r3, #16
 8005358:	6093      	str	r3, [r2, #8]
 800535a:	e000      	b.n	800535e <HCD_HC_IN_IRQHandler+0xccc>
        return;
 800535c:	bf00      	nop
  }
  else
  {
    /* ... */
  }
}
 800535e:	3718      	adds	r7, #24
 8005360:	46bd      	mov	sp, r7
 8005362:	bd80      	pop	{r7, pc}

08005364 <HCD_HC_OUT_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8005364:	b580      	push	{r7, lr}
 8005366:	b086      	sub	sp, #24
 8005368:	af00      	add	r7, sp, #0
 800536a:	6078      	str	r0, [r7, #4]
 800536c:	460b      	mov	r3, r1
 800536e:	70fb      	strb	r3, [r7, #3]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005370:	687b      	ldr	r3, [r7, #4]
 8005372:	681b      	ldr	r3, [r3, #0]
 8005374:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005376:	697b      	ldr	r3, [r7, #20]
 8005378:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg;
  uint32_t num_packets;

  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 800537a:	687b      	ldr	r3, [r7, #4]
 800537c:	681b      	ldr	r3, [r3, #0]
 800537e:	78fa      	ldrb	r2, [r7, #3]
 8005380:	4611      	mov	r1, r2
 8005382:	4618      	mov	r0, r3
 8005384:	f001 fd85 	bl	8006e92 <USB_ReadChInterrupts>
 8005388:	4603      	mov	r3, r0
 800538a:	f003 0304 	and.w	r3, r3, #4
 800538e:	2b04      	cmp	r3, #4
 8005390:	d11b      	bne.n	80053ca <HCD_HC_OUT_IRQHandler+0x66>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 8005392:	78fb      	ldrb	r3, [r7, #3]
 8005394:	015a      	lsls	r2, r3, #5
 8005396:	693b      	ldr	r3, [r7, #16]
 8005398:	4413      	add	r3, r2
 800539a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800539e:	461a      	mov	r2, r3
 80053a0:	2304      	movs	r3, #4
 80053a2:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 80053a4:	78fa      	ldrb	r2, [r7, #3]
 80053a6:	6879      	ldr	r1, [r7, #4]
 80053a8:	4613      	mov	r3, r2
 80053aa:	011b      	lsls	r3, r3, #4
 80053ac:	1a9b      	subs	r3, r3, r2
 80053ae:	009b      	lsls	r3, r3, #2
 80053b0:	440b      	add	r3, r1
 80053b2:	334d      	adds	r3, #77	@ 0x4d
 80053b4:	2207      	movs	r2, #7
 80053b6:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80053b8:	687b      	ldr	r3, [r7, #4]
 80053ba:	681b      	ldr	r3, [r3, #0]
 80053bc:	78fa      	ldrb	r2, [r7, #3]
 80053be:	4611      	mov	r1, r2
 80053c0:	4618      	mov	r0, r3
 80053c2:	f002 fb0a 	bl	80079da <USB_HC_Halt>
 80053c6:	f000 bc6f 	b.w	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 80053ca:	687b      	ldr	r3, [r7, #4]
 80053cc:	681b      	ldr	r3, [r3, #0]
 80053ce:	78fa      	ldrb	r2, [r7, #3]
 80053d0:	4611      	mov	r1, r2
 80053d2:	4618      	mov	r0, r3
 80053d4:	f001 fd5d 	bl	8006e92 <USB_ReadChInterrupts>
 80053d8:	4603      	mov	r3, r0
 80053da:	f003 0320 	and.w	r3, r3, #32
 80053de:	2b20      	cmp	r3, #32
 80053e0:	f040 8082 	bne.w	80054e8 <HCD_HC_OUT_IRQHandler+0x184>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80053e4:	78fb      	ldrb	r3, [r7, #3]
 80053e6:	015a      	lsls	r2, r3, #5
 80053e8:	693b      	ldr	r3, [r7, #16]
 80053ea:	4413      	add	r3, r2
 80053ec:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80053f0:	461a      	mov	r2, r3
 80053f2:	2320      	movs	r3, #32
 80053f4:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].do_ping == 1U)
 80053f6:	78fa      	ldrb	r2, [r7, #3]
 80053f8:	6879      	ldr	r1, [r7, #4]
 80053fa:	4613      	mov	r3, r2
 80053fc:	011b      	lsls	r3, r3, #4
 80053fe:	1a9b      	subs	r3, r3, r2
 8005400:	009b      	lsls	r3, r3, #2
 8005402:	440b      	add	r3, r1
 8005404:	3319      	adds	r3, #25
 8005406:	781b      	ldrb	r3, [r3, #0]
 8005408:	2b01      	cmp	r3, #1
 800540a:	d124      	bne.n	8005456 <HCD_HC_OUT_IRQHandler+0xf2>
    {
      hhcd->hc[chnum].do_ping = 0U;
 800540c:	78fa      	ldrb	r2, [r7, #3]
 800540e:	6879      	ldr	r1, [r7, #4]
 8005410:	4613      	mov	r3, r2
 8005412:	011b      	lsls	r3, r3, #4
 8005414:	1a9b      	subs	r3, r3, r2
 8005416:	009b      	lsls	r3, r3, #2
 8005418:	440b      	add	r3, r1
 800541a:	3319      	adds	r3, #25
 800541c:	2200      	movs	r2, #0
 800541e:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005420:	78fa      	ldrb	r2, [r7, #3]
 8005422:	6879      	ldr	r1, [r7, #4]
 8005424:	4613      	mov	r3, r2
 8005426:	011b      	lsls	r3, r3, #4
 8005428:	1a9b      	subs	r3, r3, r2
 800542a:	009b      	lsls	r3, r3, #2
 800542c:	440b      	add	r3, r1
 800542e:	334c      	adds	r3, #76	@ 0x4c
 8005430:	2202      	movs	r2, #2
 8005432:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].state = HC_ACK;
 8005434:	78fa      	ldrb	r2, [r7, #3]
 8005436:	6879      	ldr	r1, [r7, #4]
 8005438:	4613      	mov	r3, r2
 800543a:	011b      	lsls	r3, r3, #4
 800543c:	1a9b      	subs	r3, r3, r2
 800543e:	009b      	lsls	r3, r3, #2
 8005440:	440b      	add	r3, r1
 8005442:	334d      	adds	r3, #77	@ 0x4d
 8005444:	2203      	movs	r2, #3
 8005446:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005448:	687b      	ldr	r3, [r7, #4]
 800544a:	681b      	ldr	r3, [r3, #0]
 800544c:	78fa      	ldrb	r2, [r7, #3]
 800544e:	4611      	mov	r1, r2
 8005450:	4618      	mov	r0, r3
 8005452:	f002 fac2 	bl	80079da <USB_HC_Halt>
    }

    if ((hhcd->hc[chnum].do_ssplit == 1U) && (hhcd->hc[chnum].do_csplit == 0U))
 8005456:	78fa      	ldrb	r2, [r7, #3]
 8005458:	6879      	ldr	r1, [r7, #4]
 800545a:	4613      	mov	r3, r2
 800545c:	011b      	lsls	r3, r3, #4
 800545e:	1a9b      	subs	r3, r3, r2
 8005460:	009b      	lsls	r3, r3, #2
 8005462:	440b      	add	r3, r1
 8005464:	331a      	adds	r3, #26
 8005466:	781b      	ldrb	r3, [r3, #0]
 8005468:	2b01      	cmp	r3, #1
 800546a:	f040 841d 	bne.w	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
 800546e:	78fa      	ldrb	r2, [r7, #3]
 8005470:	6879      	ldr	r1, [r7, #4]
 8005472:	4613      	mov	r3, r2
 8005474:	011b      	lsls	r3, r3, #4
 8005476:	1a9b      	subs	r3, r3, r2
 8005478:	009b      	lsls	r3, r3, #2
 800547a:	440b      	add	r3, r1
 800547c:	331b      	adds	r3, #27
 800547e:	781b      	ldrb	r3, [r3, #0]
 8005480:	2b00      	cmp	r3, #0
 8005482:	f040 8411 	bne.w	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
    {
      if (hhcd->hc[chnum].ep_type != EP_TYPE_ISOC)
 8005486:	78fa      	ldrb	r2, [r7, #3]
 8005488:	6879      	ldr	r1, [r7, #4]
 800548a:	4613      	mov	r3, r2
 800548c:	011b      	lsls	r3, r3, #4
 800548e:	1a9b      	subs	r3, r3, r2
 8005490:	009b      	lsls	r3, r3, #2
 8005492:	440b      	add	r3, r1
 8005494:	3326      	adds	r3, #38	@ 0x26
 8005496:	781b      	ldrb	r3, [r3, #0]
 8005498:	2b01      	cmp	r3, #1
 800549a:	d009      	beq.n	80054b0 <HCD_HC_OUT_IRQHandler+0x14c>
      {
        hhcd->hc[chnum].do_csplit = 1U;
 800549c:	78fa      	ldrb	r2, [r7, #3]
 800549e:	6879      	ldr	r1, [r7, #4]
 80054a0:	4613      	mov	r3, r2
 80054a2:	011b      	lsls	r3, r3, #4
 80054a4:	1a9b      	subs	r3, r3, r2
 80054a6:	009b      	lsls	r3, r3, #2
 80054a8:	440b      	add	r3, r1
 80054aa:	331b      	adds	r3, #27
 80054ac:	2201      	movs	r2, #1
 80054ae:	701a      	strb	r2, [r3, #0]
      }

      hhcd->hc[chnum].state = HC_ACK;
 80054b0:	78fa      	ldrb	r2, [r7, #3]
 80054b2:	6879      	ldr	r1, [r7, #4]
 80054b4:	4613      	mov	r3, r2
 80054b6:	011b      	lsls	r3, r3, #4
 80054b8:	1a9b      	subs	r3, r3, r2
 80054ba:	009b      	lsls	r3, r3, #2
 80054bc:	440b      	add	r3, r1
 80054be:	334d      	adds	r3, #77	@ 0x4d
 80054c0:	2203      	movs	r2, #3
 80054c2:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 80054c4:	687b      	ldr	r3, [r7, #4]
 80054c6:	681b      	ldr	r3, [r3, #0]
 80054c8:	78fa      	ldrb	r2, [r7, #3]
 80054ca:	4611      	mov	r1, r2
 80054cc:	4618      	mov	r0, r3
 80054ce:	f002 fa84 	bl	80079da <USB_HC_Halt>

      /* reset error_count */
      hhcd->hc[chnum].ErrCnt = 0U;
 80054d2:	78fa      	ldrb	r2, [r7, #3]
 80054d4:	6879      	ldr	r1, [r7, #4]
 80054d6:	4613      	mov	r3, r2
 80054d8:	011b      	lsls	r3, r3, #4
 80054da:	1a9b      	subs	r3, r3, r2
 80054dc:	009b      	lsls	r3, r3, #2
 80054de:	440b      	add	r3, r1
 80054e0:	3344      	adds	r3, #68	@ 0x44
 80054e2:	2200      	movs	r2, #0
 80054e4:	601a      	str	r2, [r3, #0]
 80054e6:	e3df      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
    }
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 80054e8:	687b      	ldr	r3, [r7, #4]
 80054ea:	681b      	ldr	r3, [r3, #0]
 80054ec:	78fa      	ldrb	r2, [r7, #3]
 80054ee:	4611      	mov	r1, r2
 80054f0:	4618      	mov	r0, r3
 80054f2:	f001 fcce 	bl	8006e92 <USB_ReadChInterrupts>
 80054f6:	4603      	mov	r3, r0
 80054f8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80054fc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8005500:	d111      	bne.n	8005526 <HCD_HC_OUT_IRQHandler+0x1c2>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 8005502:	78fb      	ldrb	r3, [r7, #3]
 8005504:	015a      	lsls	r2, r3, #5
 8005506:	693b      	ldr	r3, [r7, #16]
 8005508:	4413      	add	r3, r2
 800550a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800550e:	461a      	mov	r2, r3
 8005510:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8005514:	6093      	str	r3, [r2, #8]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005516:	687b      	ldr	r3, [r7, #4]
 8005518:	681b      	ldr	r3, [r3, #0]
 800551a:	78fa      	ldrb	r2, [r7, #3]
 800551c:	4611      	mov	r1, r2
 800551e:	4618      	mov	r0, r3
 8005520:	f002 fa5b 	bl	80079da <USB_HC_Halt>
 8005524:	e3c0      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 8005526:	687b      	ldr	r3, [r7, #4]
 8005528:	681b      	ldr	r3, [r3, #0]
 800552a:	78fa      	ldrb	r2, [r7, #3]
 800552c:	4611      	mov	r1, r2
 800552e:	4618      	mov	r0, r3
 8005530:	f001 fcaf 	bl	8006e92 <USB_ReadChInterrupts>
 8005534:	4603      	mov	r3, r0
 8005536:	f003 0301 	and.w	r3, r3, #1
 800553a:	2b01      	cmp	r3, #1
 800553c:	d168      	bne.n	8005610 <HCD_HC_OUT_IRQHandler+0x2ac>
  {
    hhcd->hc[chnum].ErrCnt = 0U;
 800553e:	78fa      	ldrb	r2, [r7, #3]
 8005540:	6879      	ldr	r1, [r7, #4]
 8005542:	4613      	mov	r3, r2
 8005544:	011b      	lsls	r3, r3, #4
 8005546:	1a9b      	subs	r3, r3, r2
 8005548:	009b      	lsls	r3, r3, #2
 800554a:	440b      	add	r3, r1
 800554c:	3344      	adds	r3, #68	@ 0x44
 800554e:	2200      	movs	r2, #0
 8005550:	601a      	str	r2, [r3, #0]

    /* transaction completed with NYET state, update do ping state */
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8005552:	687b      	ldr	r3, [r7, #4]
 8005554:	681b      	ldr	r3, [r3, #0]
 8005556:	78fa      	ldrb	r2, [r7, #3]
 8005558:	4611      	mov	r1, r2
 800555a:	4618      	mov	r0, r3
 800555c:	f001 fc99 	bl	8006e92 <USB_ReadChInterrupts>
 8005560:	4603      	mov	r3, r0
 8005562:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8005566:	2b40      	cmp	r3, #64	@ 0x40
 8005568:	d112      	bne.n	8005590 <HCD_HC_OUT_IRQHandler+0x22c>
    {
      hhcd->hc[chnum].do_ping = 1U;
 800556a:	78fa      	ldrb	r2, [r7, #3]
 800556c:	6879      	ldr	r1, [r7, #4]
 800556e:	4613      	mov	r3, r2
 8005570:	011b      	lsls	r3, r3, #4
 8005572:	1a9b      	subs	r3, r3, r2
 8005574:	009b      	lsls	r3, r3, #2
 8005576:	440b      	add	r3, r1
 8005578:	3319      	adds	r3, #25
 800557a:	2201      	movs	r2, #1
 800557c:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 800557e:	78fb      	ldrb	r3, [r7, #3]
 8005580:	015a      	lsls	r2, r3, #5
 8005582:	693b      	ldr	r3, [r7, #16]
 8005584:	4413      	add	r3, r2
 8005586:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800558a:	461a      	mov	r2, r3
 800558c:	2340      	movs	r3, #64	@ 0x40
 800558e:	6093      	str	r3, [r2, #8]
    }

    if (hhcd->hc[chnum].do_csplit != 0U)
 8005590:	78fa      	ldrb	r2, [r7, #3]
 8005592:	6879      	ldr	r1, [r7, #4]
 8005594:	4613      	mov	r3, r2
 8005596:	011b      	lsls	r3, r3, #4
 8005598:	1a9b      	subs	r3, r3, r2
 800559a:	009b      	lsls	r3, r3, #2
 800559c:	440b      	add	r3, r1
 800559e:	331b      	adds	r3, #27
 80055a0:	781b      	ldrb	r3, [r3, #0]
 80055a2:	2b00      	cmp	r3, #0
 80055a4:	d019      	beq.n	80055da <HCD_HC_OUT_IRQHandler+0x276>
    {
      hhcd->hc[chnum].do_csplit = 0U;
 80055a6:	78fa      	ldrb	r2, [r7, #3]
 80055a8:	6879      	ldr	r1, [r7, #4]
 80055aa:	4613      	mov	r3, r2
 80055ac:	011b      	lsls	r3, r3, #4
 80055ae:	1a9b      	subs	r3, r3, r2
 80055b0:	009b      	lsls	r3, r3, #2
 80055b2:	440b      	add	r3, r1
 80055b4:	331b      	adds	r3, #27
 80055b6:	2200      	movs	r2, #0
 80055b8:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 80055ba:	78fb      	ldrb	r3, [r7, #3]
 80055bc:	015a      	lsls	r2, r3, #5
 80055be:	693b      	ldr	r3, [r7, #16]
 80055c0:	4413      	add	r3, r2
 80055c2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80055c6:	685b      	ldr	r3, [r3, #4]
 80055c8:	78fa      	ldrb	r2, [r7, #3]
 80055ca:	0151      	lsls	r1, r2, #5
 80055cc:	693a      	ldr	r2, [r7, #16]
 80055ce:	440a      	add	r2, r1
 80055d0:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80055d4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80055d8:	6053      	str	r3, [r2, #4]
    }

    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 80055da:	78fb      	ldrb	r3, [r7, #3]
 80055dc:	015a      	lsls	r2, r3, #5
 80055de:	693b      	ldr	r3, [r7, #16]
 80055e0:	4413      	add	r3, r2
 80055e2:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80055e6:	461a      	mov	r2, r3
 80055e8:	2301      	movs	r3, #1
 80055ea:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_XFRC;
 80055ec:	78fa      	ldrb	r2, [r7, #3]
 80055ee:	6879      	ldr	r1, [r7, #4]
 80055f0:	4613      	mov	r3, r2
 80055f2:	011b      	lsls	r3, r3, #4
 80055f4:	1a9b      	subs	r3, r3, r2
 80055f6:	009b      	lsls	r3, r3, #2
 80055f8:	440b      	add	r3, r1
 80055fa:	334d      	adds	r3, #77	@ 0x4d
 80055fc:	2201      	movs	r2, #1
 80055fe:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8005600:	687b      	ldr	r3, [r7, #4]
 8005602:	681b      	ldr	r3, [r3, #0]
 8005604:	78fa      	ldrb	r2, [r7, #3]
 8005606:	4611      	mov	r1, r2
 8005608:	4618      	mov	r0, r3
 800560a:	f002 f9e6 	bl	80079da <USB_HC_Halt>
 800560e:	e34b      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8005610:	687b      	ldr	r3, [r7, #4]
 8005612:	681b      	ldr	r3, [r3, #0]
 8005614:	78fa      	ldrb	r2, [r7, #3]
 8005616:	4611      	mov	r1, r2
 8005618:	4618      	mov	r0, r3
 800561a:	f001 fc3a 	bl	8006e92 <USB_ReadChInterrupts>
 800561e:	4603      	mov	r3, r0
 8005620:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8005624:	2b40      	cmp	r3, #64	@ 0x40
 8005626:	d139      	bne.n	800569c <HCD_HC_OUT_IRQHandler+0x338>
  {
    hhcd->hc[chnum].state = HC_NYET;
 8005628:	78fa      	ldrb	r2, [r7, #3]
 800562a:	6879      	ldr	r1, [r7, #4]
 800562c:	4613      	mov	r3, r2
 800562e:	011b      	lsls	r3, r3, #4
 8005630:	1a9b      	subs	r3, r3, r2
 8005632:	009b      	lsls	r3, r3, #2
 8005634:	440b      	add	r3, r1
 8005636:	334d      	adds	r3, #77	@ 0x4d
 8005638:	2205      	movs	r2, #5
 800563a:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ssplit == 0U)
 800563c:	78fa      	ldrb	r2, [r7, #3]
 800563e:	6879      	ldr	r1, [r7, #4]
 8005640:	4613      	mov	r3, r2
 8005642:	011b      	lsls	r3, r3, #4
 8005644:	1a9b      	subs	r3, r3, r2
 8005646:	009b      	lsls	r3, r3, #2
 8005648:	440b      	add	r3, r1
 800564a:	331a      	adds	r3, #26
 800564c:	781b      	ldrb	r3, [r3, #0]
 800564e:	2b00      	cmp	r3, #0
 8005650:	d109      	bne.n	8005666 <HCD_HC_OUT_IRQHandler+0x302>
    {
      hhcd->hc[chnum].do_ping = 1U;
 8005652:	78fa      	ldrb	r2, [r7, #3]
 8005654:	6879      	ldr	r1, [r7, #4]
 8005656:	4613      	mov	r3, r2
 8005658:	011b      	lsls	r3, r3, #4
 800565a:	1a9b      	subs	r3, r3, r2
 800565c:	009b      	lsls	r3, r3, #2
 800565e:	440b      	add	r3, r1
 8005660:	3319      	adds	r3, #25
 8005662:	2201      	movs	r2, #1
 8005664:	701a      	strb	r2, [r3, #0]
    }

    hhcd->hc[chnum].ErrCnt = 0U;
 8005666:	78fa      	ldrb	r2, [r7, #3]
 8005668:	6879      	ldr	r1, [r7, #4]
 800566a:	4613      	mov	r3, r2
 800566c:	011b      	lsls	r3, r3, #4
 800566e:	1a9b      	subs	r3, r3, r2
 8005670:	009b      	lsls	r3, r3, #2
 8005672:	440b      	add	r3, r1
 8005674:	3344      	adds	r3, #68	@ 0x44
 8005676:	2200      	movs	r2, #0
 8005678:	601a      	str	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800567a:	687b      	ldr	r3, [r7, #4]
 800567c:	681b      	ldr	r3, [r3, #0]
 800567e:	78fa      	ldrb	r2, [r7, #3]
 8005680:	4611      	mov	r1, r2
 8005682:	4618      	mov	r0, r3
 8005684:	f002 f9a9 	bl	80079da <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8005688:	78fb      	ldrb	r3, [r7, #3]
 800568a:	015a      	lsls	r2, r3, #5
 800568c:	693b      	ldr	r3, [r7, #16]
 800568e:	4413      	add	r3, r2
 8005690:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005694:	461a      	mov	r2, r3
 8005696:	2340      	movs	r3, #64	@ 0x40
 8005698:	6093      	str	r3, [r2, #8]
 800569a:	e305      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 800569c:	687b      	ldr	r3, [r7, #4]
 800569e:	681b      	ldr	r3, [r3, #0]
 80056a0:	78fa      	ldrb	r2, [r7, #3]
 80056a2:	4611      	mov	r1, r2
 80056a4:	4618      	mov	r0, r3
 80056a6:	f001 fbf4 	bl	8006e92 <USB_ReadChInterrupts>
 80056aa:	4603      	mov	r3, r0
 80056ac:	f003 0308 	and.w	r3, r3, #8
 80056b0:	2b08      	cmp	r3, #8
 80056b2:	d11a      	bne.n	80056ea <HCD_HC_OUT_IRQHandler+0x386>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 80056b4:	78fb      	ldrb	r3, [r7, #3]
 80056b6:	015a      	lsls	r2, r3, #5
 80056b8:	693b      	ldr	r3, [r7, #16]
 80056ba:	4413      	add	r3, r2
 80056bc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80056c0:	461a      	mov	r2, r3
 80056c2:	2308      	movs	r3, #8
 80056c4:	6093      	str	r3, [r2, #8]
    hhcd->hc[chnum].state = HC_STALL;
 80056c6:	78fa      	ldrb	r2, [r7, #3]
 80056c8:	6879      	ldr	r1, [r7, #4]
 80056ca:	4613      	mov	r3, r2
 80056cc:	011b      	lsls	r3, r3, #4
 80056ce:	1a9b      	subs	r3, r3, r2
 80056d0:	009b      	lsls	r3, r3, #2
 80056d2:	440b      	add	r3, r1
 80056d4:	334d      	adds	r3, #77	@ 0x4d
 80056d6:	2206      	movs	r2, #6
 80056d8:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80056da:	687b      	ldr	r3, [r7, #4]
 80056dc:	681b      	ldr	r3, [r3, #0]
 80056de:	78fa      	ldrb	r2, [r7, #3]
 80056e0:	4611      	mov	r1, r2
 80056e2:	4618      	mov	r0, r3
 80056e4:	f002 f979 	bl	80079da <USB_HC_Halt>
 80056e8:	e2de      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 80056ea:	687b      	ldr	r3, [r7, #4]
 80056ec:	681b      	ldr	r3, [r3, #0]
 80056ee:	78fa      	ldrb	r2, [r7, #3]
 80056f0:	4611      	mov	r1, r2
 80056f2:	4618      	mov	r0, r3
 80056f4:	f001 fbcd 	bl	8006e92 <USB_ReadChInterrupts>
 80056f8:	4603      	mov	r3, r0
 80056fa:	f003 0310 	and.w	r3, r3, #16
 80056fe:	2b10      	cmp	r3, #16
 8005700:	d144      	bne.n	800578c <HCD_HC_OUT_IRQHandler+0x428>
  {
    hhcd->hc[chnum].ErrCnt = 0U;
 8005702:	78fa      	ldrb	r2, [r7, #3]
 8005704:	6879      	ldr	r1, [r7, #4]
 8005706:	4613      	mov	r3, r2
 8005708:	011b      	lsls	r3, r3, #4
 800570a:	1a9b      	subs	r3, r3, r2
 800570c:	009b      	lsls	r3, r3, #2
 800570e:	440b      	add	r3, r1
 8005710:	3344      	adds	r3, #68	@ 0x44
 8005712:	2200      	movs	r2, #0
 8005714:	601a      	str	r2, [r3, #0]
    hhcd->hc[chnum].state = HC_NAK;
 8005716:	78fa      	ldrb	r2, [r7, #3]
 8005718:	6879      	ldr	r1, [r7, #4]
 800571a:	4613      	mov	r3, r2
 800571c:	011b      	lsls	r3, r3, #4
 800571e:	1a9b      	subs	r3, r3, r2
 8005720:	009b      	lsls	r3, r3, #2
 8005722:	440b      	add	r3, r1
 8005724:	334d      	adds	r3, #77	@ 0x4d
 8005726:	2204      	movs	r2, #4
 8005728:	701a      	strb	r2, [r3, #0]

    if (hhcd->hc[chnum].do_ping == 0U)
 800572a:	78fa      	ldrb	r2, [r7, #3]
 800572c:	6879      	ldr	r1, [r7, #4]
 800572e:	4613      	mov	r3, r2
 8005730:	011b      	lsls	r3, r3, #4
 8005732:	1a9b      	subs	r3, r3, r2
 8005734:	009b      	lsls	r3, r3, #2
 8005736:	440b      	add	r3, r1
 8005738:	3319      	adds	r3, #25
 800573a:	781b      	ldrb	r3, [r3, #0]
 800573c:	2b00      	cmp	r3, #0
 800573e:	d114      	bne.n	800576a <HCD_HC_OUT_IRQHandler+0x406>
    {
      if (hhcd->hc[chnum].speed == HCD_DEVICE_SPEED_HIGH)
 8005740:	78fa      	ldrb	r2, [r7, #3]
 8005742:	6879      	ldr	r1, [r7, #4]
 8005744:	4613      	mov	r3, r2
 8005746:	011b      	lsls	r3, r3, #4
 8005748:	1a9b      	subs	r3, r3, r2
 800574a:	009b      	lsls	r3, r3, #2
 800574c:	440b      	add	r3, r1
 800574e:	3318      	adds	r3, #24
 8005750:	781b      	ldrb	r3, [r3, #0]
 8005752:	2b00      	cmp	r3, #0
 8005754:	d109      	bne.n	800576a <HCD_HC_OUT_IRQHandler+0x406>
      {
        hhcd->hc[chnum].do_ping = 1U;
 8005756:	78fa      	ldrb	r2, [r7, #3]
 8005758:	6879      	ldr	r1, [r7, #4]
 800575a:	4613      	mov	r3, r2
 800575c:	011b      	lsls	r3, r3, #4
 800575e:	1a9b      	subs	r3, r3, r2
 8005760:	009b      	lsls	r3, r3, #2
 8005762:	440b      	add	r3, r1
 8005764:	3319      	adds	r3, #25
 8005766:	2201      	movs	r2, #1
 8005768:	701a      	strb	r2, [r3, #0]
      }
    }

    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800576a:	687b      	ldr	r3, [r7, #4]
 800576c:	681b      	ldr	r3, [r3, #0]
 800576e:	78fa      	ldrb	r2, [r7, #3]
 8005770:	4611      	mov	r1, r2
 8005772:	4618      	mov	r0, r3
 8005774:	f002 f931 	bl	80079da <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8005778:	78fb      	ldrb	r3, [r7, #3]
 800577a:	015a      	lsls	r2, r3, #5
 800577c:	693b      	ldr	r3, [r7, #16]
 800577e:	4413      	add	r3, r2
 8005780:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005784:	461a      	mov	r2, r3
 8005786:	2310      	movs	r3, #16
 8005788:	6093      	str	r3, [r2, #8]
 800578a:	e28d      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 800578c:	687b      	ldr	r3, [r7, #4]
 800578e:	681b      	ldr	r3, [r3, #0]
 8005790:	78fa      	ldrb	r2, [r7, #3]
 8005792:	4611      	mov	r1, r2
 8005794:	4618      	mov	r0, r3
 8005796:	f001 fb7c 	bl	8006e92 <USB_ReadChInterrupts>
 800579a:	4603      	mov	r3, r0
 800579c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80057a0:	2b80      	cmp	r3, #128	@ 0x80
 80057a2:	d169      	bne.n	8005878 <HCD_HC_OUT_IRQHandler+0x514>
  {
    if (hhcd->Init.dma_enable == 0U)
 80057a4:	687b      	ldr	r3, [r7, #4]
 80057a6:	799b      	ldrb	r3, [r3, #6]
 80057a8:	2b00      	cmp	r3, #0
 80057aa:	d111      	bne.n	80057d0 <HCD_HC_OUT_IRQHandler+0x46c>
    {
      hhcd->hc[chnum].state = HC_XACTERR;
 80057ac:	78fa      	ldrb	r2, [r7, #3]
 80057ae:	6879      	ldr	r1, [r7, #4]
 80057b0:	4613      	mov	r3, r2
 80057b2:	011b      	lsls	r3, r3, #4
 80057b4:	1a9b      	subs	r3, r3, r2
 80057b6:	009b      	lsls	r3, r3, #2
 80057b8:	440b      	add	r3, r1
 80057ba:	334d      	adds	r3, #77	@ 0x4d
 80057bc:	2207      	movs	r2, #7
 80057be:	701a      	strb	r2, [r3, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 80057c0:	687b      	ldr	r3, [r7, #4]
 80057c2:	681b      	ldr	r3, [r3, #0]
 80057c4:	78fa      	ldrb	r2, [r7, #3]
 80057c6:	4611      	mov	r1, r2
 80057c8:	4618      	mov	r0, r3
 80057ca:	f002 f906 	bl	80079da <USB_HC_Halt>
 80057ce:	e049      	b.n	8005864 <HCD_HC_OUT_IRQHandler+0x500>
    }
    else
    {
      hhcd->hc[chnum].ErrCnt++;
 80057d0:	78fa      	ldrb	r2, [r7, #3]
 80057d2:	6879      	ldr	r1, [r7, #4]
 80057d4:	4613      	mov	r3, r2
 80057d6:	011b      	lsls	r3, r3, #4
 80057d8:	1a9b      	subs	r3, r3, r2
 80057da:	009b      	lsls	r3, r3, #2
 80057dc:	440b      	add	r3, r1
 80057de:	3344      	adds	r3, #68	@ 0x44
 80057e0:	681b      	ldr	r3, [r3, #0]
 80057e2:	1c59      	adds	r1, r3, #1
 80057e4:	6878      	ldr	r0, [r7, #4]
 80057e6:	4613      	mov	r3, r2
 80057e8:	011b      	lsls	r3, r3, #4
 80057ea:	1a9b      	subs	r3, r3, r2
 80057ec:	009b      	lsls	r3, r3, #2
 80057ee:	4403      	add	r3, r0
 80057f0:	3344      	adds	r3, #68	@ 0x44
 80057f2:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 80057f4:	78fa      	ldrb	r2, [r7, #3]
 80057f6:	6879      	ldr	r1, [r7, #4]
 80057f8:	4613      	mov	r3, r2
 80057fa:	011b      	lsls	r3, r3, #4
 80057fc:	1a9b      	subs	r3, r3, r2
 80057fe:	009b      	lsls	r3, r3, #2
 8005800:	440b      	add	r3, r1
 8005802:	3344      	adds	r3, #68	@ 0x44
 8005804:	681b      	ldr	r3, [r3, #0]
 8005806:	2b02      	cmp	r3, #2
 8005808:	d922      	bls.n	8005850 <HCD_HC_OUT_IRQHandler+0x4ec>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 800580a:	78fa      	ldrb	r2, [r7, #3]
 800580c:	6879      	ldr	r1, [r7, #4]
 800580e:	4613      	mov	r3, r2
 8005810:	011b      	lsls	r3, r3, #4
 8005812:	1a9b      	subs	r3, r3, r2
 8005814:	009b      	lsls	r3, r3, #2
 8005816:	440b      	add	r3, r1
 8005818:	3344      	adds	r3, #68	@ 0x44
 800581a:	2200      	movs	r2, #0
 800581c:	601a      	str	r2, [r3, #0]
        hhcd->hc[chnum].urb_state = URB_ERROR;
 800581e:	78fa      	ldrb	r2, [r7, #3]
 8005820:	6879      	ldr	r1, [r7, #4]
 8005822:	4613      	mov	r3, r2
 8005824:	011b      	lsls	r3, r3, #4
 8005826:	1a9b      	subs	r3, r3, r2
 8005828:	009b      	lsls	r3, r3, #2
 800582a:	440b      	add	r3, r1
 800582c:	334c      	adds	r3, #76	@ 0x4c
 800582e:	2204      	movs	r2, #4
 8005830:	701a      	strb	r2, [r3, #0]

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
        hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8005832:	78fa      	ldrb	r2, [r7, #3]
 8005834:	6879      	ldr	r1, [r7, #4]
 8005836:	4613      	mov	r3, r2
 8005838:	011b      	lsls	r3, r3, #4
 800583a:	1a9b      	subs	r3, r3, r2
 800583c:	009b      	lsls	r3, r3, #2
 800583e:	440b      	add	r3, r1
 8005840:	334c      	adds	r3, #76	@ 0x4c
 8005842:	781a      	ldrb	r2, [r3, #0]
 8005844:	78fb      	ldrb	r3, [r7, #3]
 8005846:	4619      	mov	r1, r3
 8005848:	6878      	ldr	r0, [r7, #4]
 800584a:	f029 fd77 	bl	802f33c <HAL_HCD_HC_NotifyURBChange_Callback>
 800584e:	e009      	b.n	8005864 <HCD_HC_OUT_IRQHandler+0x500>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005850:	78fa      	ldrb	r2, [r7, #3]
 8005852:	6879      	ldr	r1, [r7, #4]
 8005854:	4613      	mov	r3, r2
 8005856:	011b      	lsls	r3, r3, #4
 8005858:	1a9b      	subs	r3, r3, r2
 800585a:	009b      	lsls	r3, r3, #2
 800585c:	440b      	add	r3, r1
 800585e:	334c      	adds	r3, #76	@ 0x4c
 8005860:	2202      	movs	r2, #2
 8005862:	701a      	strb	r2, [r3, #0]
      }
    }
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8005864:	78fb      	ldrb	r3, [r7, #3]
 8005866:	015a      	lsls	r2, r3, #5
 8005868:	693b      	ldr	r3, [r7, #16]
 800586a:	4413      	add	r3, r2
 800586c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005870:	461a      	mov	r2, r3
 8005872:	2380      	movs	r3, #128	@ 0x80
 8005874:	6093      	str	r3, [r2, #8]
 8005876:	e217      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8005878:	687b      	ldr	r3, [r7, #4]
 800587a:	681b      	ldr	r3, [r3, #0]
 800587c:	78fa      	ldrb	r2, [r7, #3]
 800587e:	4611      	mov	r1, r2
 8005880:	4618      	mov	r0, r3
 8005882:	f001 fb06 	bl	8006e92 <USB_ReadChInterrupts>
 8005886:	4603      	mov	r3, r0
 8005888:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800588c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8005890:	d11b      	bne.n	80058ca <HCD_HC_OUT_IRQHandler+0x566>
  {
    hhcd->hc[chnum].state = HC_DATATGLERR;
 8005892:	78fa      	ldrb	r2, [r7, #3]
 8005894:	6879      	ldr	r1, [r7, #4]
 8005896:	4613      	mov	r3, r2
 8005898:	011b      	lsls	r3, r3, #4
 800589a:	1a9b      	subs	r3, r3, r2
 800589c:	009b      	lsls	r3, r3, #2
 800589e:	440b      	add	r3, r1
 80058a0:	334d      	adds	r3, #77	@ 0x4d
 80058a2:	2209      	movs	r2, #9
 80058a4:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80058a6:	687b      	ldr	r3, [r7, #4]
 80058a8:	681b      	ldr	r3, [r3, #0]
 80058aa:	78fa      	ldrb	r2, [r7, #3]
 80058ac:	4611      	mov	r1, r2
 80058ae:	4618      	mov	r0, r3
 80058b0:	f002 f893 	bl	80079da <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 80058b4:	78fb      	ldrb	r3, [r7, #3]
 80058b6:	015a      	lsls	r2, r3, #5
 80058b8:	693b      	ldr	r3, [r7, #16]
 80058ba:	4413      	add	r3, r2
 80058bc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80058c0:	461a      	mov	r2, r3
 80058c2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80058c6:	6093      	str	r3, [r2, #8]
 80058c8:	e1ee      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
  }
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 80058ca:	687b      	ldr	r3, [r7, #4]
 80058cc:	681b      	ldr	r3, [r3, #0]
 80058ce:	78fa      	ldrb	r2, [r7, #3]
 80058d0:	4611      	mov	r1, r2
 80058d2:	4618      	mov	r0, r3
 80058d4:	f001 fadd 	bl	8006e92 <USB_ReadChInterrupts>
 80058d8:	4603      	mov	r3, r0
 80058da:	f003 0302 	and.w	r3, r3, #2
 80058de:	2b02      	cmp	r3, #2
 80058e0:	f040 81df 	bne.w	8005ca2 <HCD_HC_OUT_IRQHandler+0x93e>
  {
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 80058e4:	78fb      	ldrb	r3, [r7, #3]
 80058e6:	015a      	lsls	r2, r3, #5
 80058e8:	693b      	ldr	r3, [r7, #16]
 80058ea:	4413      	add	r3, r2
 80058ec:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80058f0:	461a      	mov	r2, r3
 80058f2:	2302      	movs	r3, #2
 80058f4:	6093      	str	r3, [r2, #8]

    if (hhcd->hc[chnum].state == HC_XFRC)
 80058f6:	78fa      	ldrb	r2, [r7, #3]
 80058f8:	6879      	ldr	r1, [r7, #4]
 80058fa:	4613      	mov	r3, r2
 80058fc:	011b      	lsls	r3, r3, #4
 80058fe:	1a9b      	subs	r3, r3, r2
 8005900:	009b      	lsls	r3, r3, #2
 8005902:	440b      	add	r3, r1
 8005904:	334d      	adds	r3, #77	@ 0x4d
 8005906:	781b      	ldrb	r3, [r3, #0]
 8005908:	2b01      	cmp	r3, #1
 800590a:	f040 8093 	bne.w	8005a34 <HCD_HC_OUT_IRQHandler+0x6d0>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 800590e:	78fa      	ldrb	r2, [r7, #3]
 8005910:	6879      	ldr	r1, [r7, #4]
 8005912:	4613      	mov	r3, r2
 8005914:	011b      	lsls	r3, r3, #4
 8005916:	1a9b      	subs	r3, r3, r2
 8005918:	009b      	lsls	r3, r3, #2
 800591a:	440b      	add	r3, r1
 800591c:	334d      	adds	r3, #77	@ 0x4d
 800591e:	2202      	movs	r2, #2
 8005920:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_DONE;
 8005922:	78fa      	ldrb	r2, [r7, #3]
 8005924:	6879      	ldr	r1, [r7, #4]
 8005926:	4613      	mov	r3, r2
 8005928:	011b      	lsls	r3, r3, #4
 800592a:	1a9b      	subs	r3, r3, r2
 800592c:	009b      	lsls	r3, r3, #2
 800592e:	440b      	add	r3, r1
 8005930:	334c      	adds	r3, #76	@ 0x4c
 8005932:	2201      	movs	r2, #1
 8005934:	701a      	strb	r2, [r3, #0]

      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 8005936:	78fa      	ldrb	r2, [r7, #3]
 8005938:	6879      	ldr	r1, [r7, #4]
 800593a:	4613      	mov	r3, r2
 800593c:	011b      	lsls	r3, r3, #4
 800593e:	1a9b      	subs	r3, r3, r2
 8005940:	009b      	lsls	r3, r3, #2
 8005942:	440b      	add	r3, r1
 8005944:	3326      	adds	r3, #38	@ 0x26
 8005946:	781b      	ldrb	r3, [r3, #0]
 8005948:	2b02      	cmp	r3, #2
 800594a:	d00b      	beq.n	8005964 <HCD_HC_OUT_IRQHandler+0x600>
          (hhcd->hc[chnum].ep_type == EP_TYPE_INTR))
 800594c:	78fa      	ldrb	r2, [r7, #3]
 800594e:	6879      	ldr	r1, [r7, #4]
 8005950:	4613      	mov	r3, r2
 8005952:	011b      	lsls	r3, r3, #4
 8005954:	1a9b      	subs	r3, r3, r2
 8005956:	009b      	lsls	r3, r3, #2
 8005958:	440b      	add	r3, r1
 800595a:	3326      	adds	r3, #38	@ 0x26
 800595c:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 800595e:	2b03      	cmp	r3, #3
 8005960:	f040 8190 	bne.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
      {
        if (hhcd->Init.dma_enable == 0U)
 8005964:	687b      	ldr	r3, [r7, #4]
 8005966:	799b      	ldrb	r3, [r3, #6]
 8005968:	2b00      	cmp	r3, #0
 800596a:	d115      	bne.n	8005998 <HCD_HC_OUT_IRQHandler+0x634>
        {
          hhcd->hc[chnum].toggle_out ^= 1U;
 800596c:	78fa      	ldrb	r2, [r7, #3]
 800596e:	6879      	ldr	r1, [r7, #4]
 8005970:	4613      	mov	r3, r2
 8005972:	011b      	lsls	r3, r3, #4
 8005974:	1a9b      	subs	r3, r3, r2
 8005976:	009b      	lsls	r3, r3, #2
 8005978:	440b      	add	r3, r1
 800597a:	333d      	adds	r3, #61	@ 0x3d
 800597c:	781b      	ldrb	r3, [r3, #0]
 800597e:	78fa      	ldrb	r2, [r7, #3]
 8005980:	f083 0301 	eor.w	r3, r3, #1
 8005984:	b2d8      	uxtb	r0, r3
 8005986:	6879      	ldr	r1, [r7, #4]
 8005988:	4613      	mov	r3, r2
 800598a:	011b      	lsls	r3, r3, #4
 800598c:	1a9b      	subs	r3, r3, r2
 800598e:	009b      	lsls	r3, r3, #2
 8005990:	440b      	add	r3, r1
 8005992:	333d      	adds	r3, #61	@ 0x3d
 8005994:	4602      	mov	r2, r0
 8005996:	701a      	strb	r2, [r3, #0]
        }

        if ((hhcd->Init.dma_enable == 1U) && (hhcd->hc[chnum].xfer_len > 0U))
 8005998:	687b      	ldr	r3, [r7, #4]
 800599a:	799b      	ldrb	r3, [r3, #6]
 800599c:	2b01      	cmp	r3, #1
 800599e:	f040 8171 	bne.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
 80059a2:	78fa      	ldrb	r2, [r7, #3]
 80059a4:	6879      	ldr	r1, [r7, #4]
 80059a6:	4613      	mov	r3, r2
 80059a8:	011b      	lsls	r3, r3, #4
 80059aa:	1a9b      	subs	r3, r3, r2
 80059ac:	009b      	lsls	r3, r3, #2
 80059ae:	440b      	add	r3, r1
 80059b0:	3334      	adds	r3, #52	@ 0x34
 80059b2:	681b      	ldr	r3, [r3, #0]
 80059b4:	2b00      	cmp	r3, #0
 80059b6:	f000 8165 	beq.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
        {
          num_packets = (hhcd->hc[chnum].xfer_len + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet;
 80059ba:	78fa      	ldrb	r2, [r7, #3]
 80059bc:	6879      	ldr	r1, [r7, #4]
 80059be:	4613      	mov	r3, r2
 80059c0:	011b      	lsls	r3, r3, #4
 80059c2:	1a9b      	subs	r3, r3, r2
 80059c4:	009b      	lsls	r3, r3, #2
 80059c6:	440b      	add	r3, r1
 80059c8:	3334      	adds	r3, #52	@ 0x34
 80059ca:	6819      	ldr	r1, [r3, #0]
 80059cc:	78fa      	ldrb	r2, [r7, #3]
 80059ce:	6878      	ldr	r0, [r7, #4]
 80059d0:	4613      	mov	r3, r2
 80059d2:	011b      	lsls	r3, r3, #4
 80059d4:	1a9b      	subs	r3, r3, r2
 80059d6:	009b      	lsls	r3, r3, #2
 80059d8:	4403      	add	r3, r0
 80059da:	3328      	adds	r3, #40	@ 0x28
 80059dc:	881b      	ldrh	r3, [r3, #0]
 80059de:	440b      	add	r3, r1
 80059e0:	1e59      	subs	r1, r3, #1
 80059e2:	78fa      	ldrb	r2, [r7, #3]
 80059e4:	6878      	ldr	r0, [r7, #4]
 80059e6:	4613      	mov	r3, r2
 80059e8:	011b      	lsls	r3, r3, #4
 80059ea:	1a9b      	subs	r3, r3, r2
 80059ec:	009b      	lsls	r3, r3, #2
 80059ee:	4403      	add	r3, r0
 80059f0:	3328      	adds	r3, #40	@ 0x28
 80059f2:	881b      	ldrh	r3, [r3, #0]
 80059f4:	fbb1 f3f3 	udiv	r3, r1, r3
 80059f8:	60bb      	str	r3, [r7, #8]

          if ((num_packets & 1U) != 0U)
 80059fa:	68bb      	ldr	r3, [r7, #8]
 80059fc:	f003 0301 	and.w	r3, r3, #1
 8005a00:	2b00      	cmp	r3, #0
 8005a02:	f000 813f 	beq.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
          {
            hhcd->hc[chnum].toggle_out ^= 1U;
 8005a06:	78fa      	ldrb	r2, [r7, #3]
 8005a08:	6879      	ldr	r1, [r7, #4]
 8005a0a:	4613      	mov	r3, r2
 8005a0c:	011b      	lsls	r3, r3, #4
 8005a0e:	1a9b      	subs	r3, r3, r2
 8005a10:	009b      	lsls	r3, r3, #2
 8005a12:	440b      	add	r3, r1
 8005a14:	333d      	adds	r3, #61	@ 0x3d
 8005a16:	781b      	ldrb	r3, [r3, #0]
 8005a18:	78fa      	ldrb	r2, [r7, #3]
 8005a1a:	f083 0301 	eor.w	r3, r3, #1
 8005a1e:	b2d8      	uxtb	r0, r3
 8005a20:	6879      	ldr	r1, [r7, #4]
 8005a22:	4613      	mov	r3, r2
 8005a24:	011b      	lsls	r3, r3, #4
 8005a26:	1a9b      	subs	r3, r3, r2
 8005a28:	009b      	lsls	r3, r3, #2
 8005a2a:	440b      	add	r3, r1
 8005a2c:	333d      	adds	r3, #61	@ 0x3d
 8005a2e:	4602      	mov	r2, r0
 8005a30:	701a      	strb	r2, [r3, #0]
 8005a32:	e127      	b.n	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
          }
        }
      }
    }
    else if (hhcd->hc[chnum].state == HC_ACK)
 8005a34:	78fa      	ldrb	r2, [r7, #3]
 8005a36:	6879      	ldr	r1, [r7, #4]
 8005a38:	4613      	mov	r3, r2
 8005a3a:	011b      	lsls	r3, r3, #4
 8005a3c:	1a9b      	subs	r3, r3, r2
 8005a3e:	009b      	lsls	r3, r3, #2
 8005a40:	440b      	add	r3, r1
 8005a42:	334d      	adds	r3, #77	@ 0x4d
 8005a44:	781b      	ldrb	r3, [r3, #0]
 8005a46:	2b03      	cmp	r3, #3
 8005a48:	d120      	bne.n	8005a8c <HCD_HC_OUT_IRQHandler+0x728>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005a4a:	78fa      	ldrb	r2, [r7, #3]
 8005a4c:	6879      	ldr	r1, [r7, #4]
 8005a4e:	4613      	mov	r3, r2
 8005a50:	011b      	lsls	r3, r3, #4
 8005a52:	1a9b      	subs	r3, r3, r2
 8005a54:	009b      	lsls	r3, r3, #2
 8005a56:	440b      	add	r3, r1
 8005a58:	334d      	adds	r3, #77	@ 0x4d
 8005a5a:	2202      	movs	r2, #2
 8005a5c:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8005a5e:	78fa      	ldrb	r2, [r7, #3]
 8005a60:	6879      	ldr	r1, [r7, #4]
 8005a62:	4613      	mov	r3, r2
 8005a64:	011b      	lsls	r3, r3, #4
 8005a66:	1a9b      	subs	r3, r3, r2
 8005a68:	009b      	lsls	r3, r3, #2
 8005a6a:	440b      	add	r3, r1
 8005a6c:	331b      	adds	r3, #27
 8005a6e:	781b      	ldrb	r3, [r3, #0]
 8005a70:	2b01      	cmp	r3, #1
 8005a72:	f040 8107 	bne.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005a76:	78fa      	ldrb	r2, [r7, #3]
 8005a78:	6879      	ldr	r1, [r7, #4]
 8005a7a:	4613      	mov	r3, r2
 8005a7c:	011b      	lsls	r3, r3, #4
 8005a7e:	1a9b      	subs	r3, r3, r2
 8005a80:	009b      	lsls	r3, r3, #2
 8005a82:	440b      	add	r3, r1
 8005a84:	334c      	adds	r3, #76	@ 0x4c
 8005a86:	2202      	movs	r2, #2
 8005a88:	701a      	strb	r2, [r3, #0]
 8005a8a:	e0fb      	b.n	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
      }
    }
    else if (hhcd->hc[chnum].state == HC_NAK)
 8005a8c:	78fa      	ldrb	r2, [r7, #3]
 8005a8e:	6879      	ldr	r1, [r7, #4]
 8005a90:	4613      	mov	r3, r2
 8005a92:	011b      	lsls	r3, r3, #4
 8005a94:	1a9b      	subs	r3, r3, r2
 8005a96:	009b      	lsls	r3, r3, #2
 8005a98:	440b      	add	r3, r1
 8005a9a:	334d      	adds	r3, #77	@ 0x4d
 8005a9c:	781b      	ldrb	r3, [r3, #0]
 8005a9e:	2b04      	cmp	r3, #4
 8005aa0:	d13a      	bne.n	8005b18 <HCD_HC_OUT_IRQHandler+0x7b4>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005aa2:	78fa      	ldrb	r2, [r7, #3]
 8005aa4:	6879      	ldr	r1, [r7, #4]
 8005aa6:	4613      	mov	r3, r2
 8005aa8:	011b      	lsls	r3, r3, #4
 8005aaa:	1a9b      	subs	r3, r3, r2
 8005aac:	009b      	lsls	r3, r3, #2
 8005aae:	440b      	add	r3, r1
 8005ab0:	334d      	adds	r3, #77	@ 0x4d
 8005ab2:	2202      	movs	r2, #2
 8005ab4:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005ab6:	78fa      	ldrb	r2, [r7, #3]
 8005ab8:	6879      	ldr	r1, [r7, #4]
 8005aba:	4613      	mov	r3, r2
 8005abc:	011b      	lsls	r3, r3, #4
 8005abe:	1a9b      	subs	r3, r3, r2
 8005ac0:	009b      	lsls	r3, r3, #2
 8005ac2:	440b      	add	r3, r1
 8005ac4:	334c      	adds	r3, #76	@ 0x4c
 8005ac6:	2202      	movs	r2, #2
 8005ac8:	701a      	strb	r2, [r3, #0]

      if (hhcd->hc[chnum].do_csplit == 1U)
 8005aca:	78fa      	ldrb	r2, [r7, #3]
 8005acc:	6879      	ldr	r1, [r7, #4]
 8005ace:	4613      	mov	r3, r2
 8005ad0:	011b      	lsls	r3, r3, #4
 8005ad2:	1a9b      	subs	r3, r3, r2
 8005ad4:	009b      	lsls	r3, r3, #2
 8005ad6:	440b      	add	r3, r1
 8005ad8:	331b      	adds	r3, #27
 8005ada:	781b      	ldrb	r3, [r3, #0]
 8005adc:	2b01      	cmp	r3, #1
 8005ade:	f040 80d1 	bne.w	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
      {
        hhcd->hc[chnum].do_csplit = 0U;
 8005ae2:	78fa      	ldrb	r2, [r7, #3]
 8005ae4:	6879      	ldr	r1, [r7, #4]
 8005ae6:	4613      	mov	r3, r2
 8005ae8:	011b      	lsls	r3, r3, #4
 8005aea:	1a9b      	subs	r3, r3, r2
 8005aec:	009b      	lsls	r3, r3, #2
 8005aee:	440b      	add	r3, r1
 8005af0:	331b      	adds	r3, #27
 8005af2:	2200      	movs	r2, #0
 8005af4:	701a      	strb	r2, [r3, #0]
        __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8005af6:	78fb      	ldrb	r3, [r7, #3]
 8005af8:	015a      	lsls	r2, r3, #5
 8005afa:	693b      	ldr	r3, [r7, #16]
 8005afc:	4413      	add	r3, r2
 8005afe:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005b02:	685b      	ldr	r3, [r3, #4]
 8005b04:	78fa      	ldrb	r2, [r7, #3]
 8005b06:	0151      	lsls	r1, r2, #5
 8005b08:	693a      	ldr	r2, [r7, #16]
 8005b0a:	440a      	add	r2, r1
 8005b0c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8005b10:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005b14:	6053      	str	r3, [r2, #4]
 8005b16:	e0b5      	b.n	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
      }
    }
    else if (hhcd->hc[chnum].state == HC_NYET)
 8005b18:	78fa      	ldrb	r2, [r7, #3]
 8005b1a:	6879      	ldr	r1, [r7, #4]
 8005b1c:	4613      	mov	r3, r2
 8005b1e:	011b      	lsls	r3, r3, #4
 8005b20:	1a9b      	subs	r3, r3, r2
 8005b22:	009b      	lsls	r3, r3, #2
 8005b24:	440b      	add	r3, r1
 8005b26:	334d      	adds	r3, #77	@ 0x4d
 8005b28:	781b      	ldrb	r3, [r3, #0]
 8005b2a:	2b05      	cmp	r3, #5
 8005b2c:	d114      	bne.n	8005b58 <HCD_HC_OUT_IRQHandler+0x7f4>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005b2e:	78fa      	ldrb	r2, [r7, #3]
 8005b30:	6879      	ldr	r1, [r7, #4]
 8005b32:	4613      	mov	r3, r2
 8005b34:	011b      	lsls	r3, r3, #4
 8005b36:	1a9b      	subs	r3, r3, r2
 8005b38:	009b      	lsls	r3, r3, #2
 8005b3a:	440b      	add	r3, r1
 8005b3c:	334d      	adds	r3, #77	@ 0x4d
 8005b3e:	2202      	movs	r2, #2
 8005b40:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state  = URB_NOTREADY;
 8005b42:	78fa      	ldrb	r2, [r7, #3]
 8005b44:	6879      	ldr	r1, [r7, #4]
 8005b46:	4613      	mov	r3, r2
 8005b48:	011b      	lsls	r3, r3, #4
 8005b4a:	1a9b      	subs	r3, r3, r2
 8005b4c:	009b      	lsls	r3, r3, #2
 8005b4e:	440b      	add	r3, r1
 8005b50:	334c      	adds	r3, #76	@ 0x4c
 8005b52:	2202      	movs	r2, #2
 8005b54:	701a      	strb	r2, [r3, #0]
 8005b56:	e095      	b.n	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
    }
    else if (hhcd->hc[chnum].state == HC_STALL)
 8005b58:	78fa      	ldrb	r2, [r7, #3]
 8005b5a:	6879      	ldr	r1, [r7, #4]
 8005b5c:	4613      	mov	r3, r2
 8005b5e:	011b      	lsls	r3, r3, #4
 8005b60:	1a9b      	subs	r3, r3, r2
 8005b62:	009b      	lsls	r3, r3, #2
 8005b64:	440b      	add	r3, r1
 8005b66:	334d      	adds	r3, #77	@ 0x4d
 8005b68:	781b      	ldrb	r3, [r3, #0]
 8005b6a:	2b06      	cmp	r3, #6
 8005b6c:	d114      	bne.n	8005b98 <HCD_HC_OUT_IRQHandler+0x834>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005b6e:	78fa      	ldrb	r2, [r7, #3]
 8005b70:	6879      	ldr	r1, [r7, #4]
 8005b72:	4613      	mov	r3, r2
 8005b74:	011b      	lsls	r3, r3, #4
 8005b76:	1a9b      	subs	r3, r3, r2
 8005b78:	009b      	lsls	r3, r3, #2
 8005b7a:	440b      	add	r3, r1
 8005b7c:	334d      	adds	r3, #77	@ 0x4d
 8005b7e:	2202      	movs	r2, #2
 8005b80:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].urb_state  = URB_STALL;
 8005b82:	78fa      	ldrb	r2, [r7, #3]
 8005b84:	6879      	ldr	r1, [r7, #4]
 8005b86:	4613      	mov	r3, r2
 8005b88:	011b      	lsls	r3, r3, #4
 8005b8a:	1a9b      	subs	r3, r3, r2
 8005b8c:	009b      	lsls	r3, r3, #2
 8005b8e:	440b      	add	r3, r1
 8005b90:	334c      	adds	r3, #76	@ 0x4c
 8005b92:	2205      	movs	r2, #5
 8005b94:	701a      	strb	r2, [r3, #0]
 8005b96:	e075      	b.n	8005c84 <HCD_HC_OUT_IRQHandler+0x920>
    }
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8005b98:	78fa      	ldrb	r2, [r7, #3]
 8005b9a:	6879      	ldr	r1, [r7, #4]
 8005b9c:	4613      	mov	r3, r2
 8005b9e:	011b      	lsls	r3, r3, #4
 8005ba0:	1a9b      	subs	r3, r3, r2
 8005ba2:	009b      	lsls	r3, r3, #2
 8005ba4:	440b      	add	r3, r1
 8005ba6:	334d      	adds	r3, #77	@ 0x4d
 8005ba8:	781b      	ldrb	r3, [r3, #0]
 8005baa:	2b07      	cmp	r3, #7
 8005bac:	d00a      	beq.n	8005bc4 <HCD_HC_OUT_IRQHandler+0x860>
             (hhcd->hc[chnum].state == HC_DATATGLERR))
 8005bae:	78fa      	ldrb	r2, [r7, #3]
 8005bb0:	6879      	ldr	r1, [r7, #4]
 8005bb2:	4613      	mov	r3, r2
 8005bb4:	011b      	lsls	r3, r3, #4
 8005bb6:	1a9b      	subs	r3, r3, r2
 8005bb8:	009b      	lsls	r3, r3, #2
 8005bba:	440b      	add	r3, r1
 8005bbc:	334d      	adds	r3, #77	@ 0x4d
 8005bbe:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[chnum].state == HC_XACTERR) ||
 8005bc0:	2b09      	cmp	r3, #9
 8005bc2:	d170      	bne.n	8005ca6 <HCD_HC_OUT_IRQHandler+0x942>
    {
      hhcd->hc[chnum].state = HC_HALTED;
 8005bc4:	78fa      	ldrb	r2, [r7, #3]
 8005bc6:	6879      	ldr	r1, [r7, #4]
 8005bc8:	4613      	mov	r3, r2
 8005bca:	011b      	lsls	r3, r3, #4
 8005bcc:	1a9b      	subs	r3, r3, r2
 8005bce:	009b      	lsls	r3, r3, #2
 8005bd0:	440b      	add	r3, r1
 8005bd2:	334d      	adds	r3, #77	@ 0x4d
 8005bd4:	2202      	movs	r2, #2
 8005bd6:	701a      	strb	r2, [r3, #0]
      hhcd->hc[chnum].ErrCnt++;
 8005bd8:	78fa      	ldrb	r2, [r7, #3]
 8005bda:	6879      	ldr	r1, [r7, #4]
 8005bdc:	4613      	mov	r3, r2
 8005bde:	011b      	lsls	r3, r3, #4
 8005be0:	1a9b      	subs	r3, r3, r2
 8005be2:	009b      	lsls	r3, r3, #2
 8005be4:	440b      	add	r3, r1
 8005be6:	3344      	adds	r3, #68	@ 0x44
 8005be8:	681b      	ldr	r3, [r3, #0]
 8005bea:	1c59      	adds	r1, r3, #1
 8005bec:	6878      	ldr	r0, [r7, #4]
 8005bee:	4613      	mov	r3, r2
 8005bf0:	011b      	lsls	r3, r3, #4
 8005bf2:	1a9b      	subs	r3, r3, r2
 8005bf4:	009b      	lsls	r3, r3, #2
 8005bf6:	4403      	add	r3, r0
 8005bf8:	3344      	adds	r3, #68	@ 0x44
 8005bfa:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005bfc:	78fa      	ldrb	r2, [r7, #3]
 8005bfe:	6879      	ldr	r1, [r7, #4]
 8005c00:	4613      	mov	r3, r2
 8005c02:	011b      	lsls	r3, r3, #4
 8005c04:	1a9b      	subs	r3, r3, r2
 8005c06:	009b      	lsls	r3, r3, #2
 8005c08:	440b      	add	r3, r1
 8005c0a:	3344      	adds	r3, #68	@ 0x44
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	2b02      	cmp	r3, #2
 8005c10:	d914      	bls.n	8005c3c <HCD_HC_OUT_IRQHandler+0x8d8>
      {
        hhcd->hc[chnum].ErrCnt = 0U;
 8005c12:	78fa      	ldrb	r2, [r7, #3]
 8005c14:	6879      	ldr	r1, [r7, #4]
 8005c16:	4613      	mov	r3, r2
 8005c18:	011b      	lsls	r3, r3, #4
 8005c1a:	1a9b      	subs	r3, r3, r2
 8005c1c:	009b      	lsls	r3, r3, #2
 8005c1e:	440b      	add	r3, r1
 8005c20:	3344      	adds	r3, #68	@ 0x44
 8005c22:	2200      	movs	r2, #0
 8005c24:	601a      	str	r2, [r3, #0]
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8005c26:	78fa      	ldrb	r2, [r7, #3]
 8005c28:	6879      	ldr	r1, [r7, #4]
 8005c2a:	4613      	mov	r3, r2
 8005c2c:	011b      	lsls	r3, r3, #4
 8005c2e:	1a9b      	subs	r3, r3, r2
 8005c30:	009b      	lsls	r3, r3, #2
 8005c32:	440b      	add	r3, r1
 8005c34:	334c      	adds	r3, #76	@ 0x4c
 8005c36:	2204      	movs	r2, #4
 8005c38:	701a      	strb	r2, [r3, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005c3a:	e022      	b.n	8005c82 <HCD_HC_OUT_IRQHandler+0x91e>
      }
      else
      {
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8005c3c:	78fa      	ldrb	r2, [r7, #3]
 8005c3e:	6879      	ldr	r1, [r7, #4]
 8005c40:	4613      	mov	r3, r2
 8005c42:	011b      	lsls	r3, r3, #4
 8005c44:	1a9b      	subs	r3, r3, r2
 8005c46:	009b      	lsls	r3, r3, #2
 8005c48:	440b      	add	r3, r1
 8005c4a:	334c      	adds	r3, #76	@ 0x4c
 8005c4c:	2202      	movs	r2, #2
 8005c4e:	701a      	strb	r2, [r3, #0]

        /* re-activate the channel  */
        tmpreg = USBx_HC(chnum)->HCCHAR;
 8005c50:	78fb      	ldrb	r3, [r7, #3]
 8005c52:	015a      	lsls	r2, r3, #5
 8005c54:	693b      	ldr	r3, [r7, #16]
 8005c56:	4413      	add	r3, r2
 8005c58:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005c5c:	681b      	ldr	r3, [r3, #0]
 8005c5e:	60fb      	str	r3, [r7, #12]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005c60:	68fb      	ldr	r3, [r7, #12]
 8005c62:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005c66:	60fb      	str	r3, [r7, #12]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005c68:	68fb      	ldr	r3, [r7, #12]
 8005c6a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8005c6e:	60fb      	str	r3, [r7, #12]
        USBx_HC(chnum)->HCCHAR = tmpreg;
 8005c70:	78fb      	ldrb	r3, [r7, #3]
 8005c72:	015a      	lsls	r2, r3, #5
 8005c74:	693b      	ldr	r3, [r7, #16]
 8005c76:	4413      	add	r3, r2
 8005c78:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005c7c:	461a      	mov	r2, r3
 8005c7e:	68fb      	ldr	r3, [r7, #12]
 8005c80:	6013      	str	r3, [r2, #0]
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8005c82:	bf00      	nop
    }

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
    hhcd->HC_NotifyURBChangeCallback(hhcd, chnum, hhcd->hc[chnum].urb_state);
#else
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8005c84:	78fa      	ldrb	r2, [r7, #3]
 8005c86:	6879      	ldr	r1, [r7, #4]
 8005c88:	4613      	mov	r3, r2
 8005c8a:	011b      	lsls	r3, r3, #4
 8005c8c:	1a9b      	subs	r3, r3, r2
 8005c8e:	009b      	lsls	r3, r3, #2
 8005c90:	440b      	add	r3, r1
 8005c92:	334c      	adds	r3, #76	@ 0x4c
 8005c94:	781a      	ldrb	r2, [r3, #0]
 8005c96:	78fb      	ldrb	r3, [r7, #3]
 8005c98:	4619      	mov	r1, r3
 8005c9a:	6878      	ldr	r0, [r7, #4]
 8005c9c:	f029 fb4e 	bl	802f33c <HAL_HCD_HC_NotifyURBChange_Callback>
 8005ca0:	e002      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
  }
  else
  {
    return;
 8005ca2:	bf00      	nop
 8005ca4:	e000      	b.n	8005ca8 <HCD_HC_OUT_IRQHandler+0x944>
      return;
 8005ca6:	bf00      	nop
  }
}
 8005ca8:	3718      	adds	r7, #24
 8005caa:	46bd      	mov	sp, r7
 8005cac:	bd80      	pop	{r7, pc}

08005cae <HCD_RXQLVL_IRQHandler>:
  * @brief  Handle Rx Queue Level interrupt requests.
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8005cae:	b580      	push	{r7, lr}
 8005cb0:	b08a      	sub	sp, #40	@ 0x28
 8005cb2:	af00      	add	r7, sp, #0
 8005cb4:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005cb6:	687b      	ldr	r3, [r7, #4]
 8005cb8:	681b      	ldr	r3, [r3, #0]
 8005cba:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005cbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005cbe:	623b      	str	r3, [r7, #32]
  uint32_t GrxstspReg;
  uint32_t xferSizePktCnt;
  uint32_t tmpreg;
  uint32_t chnum;

  GrxstspReg = hhcd->Instance->GRXSTSP;
 8005cc0:	687b      	ldr	r3, [r7, #4]
 8005cc2:	681b      	ldr	r3, [r3, #0]
 8005cc4:	6a1b      	ldr	r3, [r3, #32]
 8005cc6:	61fb      	str	r3, [r7, #28]
  chnum = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
 8005cc8:	69fb      	ldr	r3, [r7, #28]
 8005cca:	f003 030f 	and.w	r3, r3, #15
 8005cce:	61bb      	str	r3, [r7, #24]
  pktsts = (GrxstspReg & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 8005cd0:	69fb      	ldr	r3, [r7, #28]
 8005cd2:	0c5b      	lsrs	r3, r3, #17
 8005cd4:	f003 030f 	and.w	r3, r3, #15
 8005cd8:	617b      	str	r3, [r7, #20]
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;
 8005cda:	69fb      	ldr	r3, [r7, #28]
 8005cdc:	091b      	lsrs	r3, r3, #4
 8005cde:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8005ce2:	613b      	str	r3, [r7, #16]

  switch (pktsts)
 8005ce4:	697b      	ldr	r3, [r7, #20]
 8005ce6:	2b02      	cmp	r3, #2
 8005ce8:	d004      	beq.n	8005cf4 <HCD_RXQLVL_IRQHandler+0x46>
 8005cea:	697b      	ldr	r3, [r7, #20]
 8005cec:	2b05      	cmp	r3, #5
 8005cee:	f000 80b6 	beq.w	8005e5e <HCD_RXQLVL_IRQHandler+0x1b0>
      break;

    case GRXSTS_PKTSTS_IN_XFER_COMP:
    case GRXSTS_PKTSTS_CH_HALTED:
    default:
      break;
 8005cf2:	e0b7      	b.n	8005e64 <HCD_RXQLVL_IRQHandler+0x1b6>
      if ((pktcnt > 0U) && (hhcd->hc[chnum].xfer_buff != (void *)0))
 8005cf4:	693b      	ldr	r3, [r7, #16]
 8005cf6:	2b00      	cmp	r3, #0
 8005cf8:	f000 80b3 	beq.w	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
 8005cfc:	6879      	ldr	r1, [r7, #4]
 8005cfe:	69ba      	ldr	r2, [r7, #24]
 8005d00:	4613      	mov	r3, r2
 8005d02:	011b      	lsls	r3, r3, #4
 8005d04:	1a9b      	subs	r3, r3, r2
 8005d06:	009b      	lsls	r3, r3, #2
 8005d08:	440b      	add	r3, r1
 8005d0a:	332c      	adds	r3, #44	@ 0x2c
 8005d0c:	681b      	ldr	r3, [r3, #0]
 8005d0e:	2b00      	cmp	r3, #0
 8005d10:	f000 80a7 	beq.w	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
        if ((hhcd->hc[chnum].xfer_count + pktcnt) <= hhcd->hc[chnum].xfer_len)
 8005d14:	6879      	ldr	r1, [r7, #4]
 8005d16:	69ba      	ldr	r2, [r7, #24]
 8005d18:	4613      	mov	r3, r2
 8005d1a:	011b      	lsls	r3, r3, #4
 8005d1c:	1a9b      	subs	r3, r3, r2
 8005d1e:	009b      	lsls	r3, r3, #2
 8005d20:	440b      	add	r3, r1
 8005d22:	3338      	adds	r3, #56	@ 0x38
 8005d24:	681a      	ldr	r2, [r3, #0]
 8005d26:	693b      	ldr	r3, [r7, #16]
 8005d28:	18d1      	adds	r1, r2, r3
 8005d2a:	6878      	ldr	r0, [r7, #4]
 8005d2c:	69ba      	ldr	r2, [r7, #24]
 8005d2e:	4613      	mov	r3, r2
 8005d30:	011b      	lsls	r3, r3, #4
 8005d32:	1a9b      	subs	r3, r3, r2
 8005d34:	009b      	lsls	r3, r3, #2
 8005d36:	4403      	add	r3, r0
 8005d38:	3334      	adds	r3, #52	@ 0x34
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	4299      	cmp	r1, r3
 8005d3e:	f200 8083 	bhi.w	8005e48 <HCD_RXQLVL_IRQHandler+0x19a>
          (void)USB_ReadPacket(hhcd->Instance,
 8005d42:	687b      	ldr	r3, [r7, #4]
 8005d44:	6818      	ldr	r0, [r3, #0]
 8005d46:	6879      	ldr	r1, [r7, #4]
 8005d48:	69ba      	ldr	r2, [r7, #24]
 8005d4a:	4613      	mov	r3, r2
 8005d4c:	011b      	lsls	r3, r3, #4
 8005d4e:	1a9b      	subs	r3, r3, r2
 8005d50:	009b      	lsls	r3, r3, #2
 8005d52:	440b      	add	r3, r1
 8005d54:	332c      	adds	r3, #44	@ 0x2c
 8005d56:	681b      	ldr	r3, [r3, #0]
 8005d58:	693a      	ldr	r2, [r7, #16]
 8005d5a:	b292      	uxth	r2, r2
 8005d5c:	4619      	mov	r1, r3
 8005d5e:	f001 f82d 	bl	8006dbc <USB_ReadPacket>
          hhcd->hc[chnum].xfer_buff += pktcnt;
 8005d62:	6879      	ldr	r1, [r7, #4]
 8005d64:	69ba      	ldr	r2, [r7, #24]
 8005d66:	4613      	mov	r3, r2
 8005d68:	011b      	lsls	r3, r3, #4
 8005d6a:	1a9b      	subs	r3, r3, r2
 8005d6c:	009b      	lsls	r3, r3, #2
 8005d6e:	440b      	add	r3, r1
 8005d70:	332c      	adds	r3, #44	@ 0x2c
 8005d72:	681a      	ldr	r2, [r3, #0]
 8005d74:	693b      	ldr	r3, [r7, #16]
 8005d76:	18d1      	adds	r1, r2, r3
 8005d78:	6878      	ldr	r0, [r7, #4]
 8005d7a:	69ba      	ldr	r2, [r7, #24]
 8005d7c:	4613      	mov	r3, r2
 8005d7e:	011b      	lsls	r3, r3, #4
 8005d80:	1a9b      	subs	r3, r3, r2
 8005d82:	009b      	lsls	r3, r3, #2
 8005d84:	4403      	add	r3, r0
 8005d86:	332c      	adds	r3, #44	@ 0x2c
 8005d88:	6019      	str	r1, [r3, #0]
          hhcd->hc[chnum].xfer_count += pktcnt;
 8005d8a:	6879      	ldr	r1, [r7, #4]
 8005d8c:	69ba      	ldr	r2, [r7, #24]
 8005d8e:	4613      	mov	r3, r2
 8005d90:	011b      	lsls	r3, r3, #4
 8005d92:	1a9b      	subs	r3, r3, r2
 8005d94:	009b      	lsls	r3, r3, #2
 8005d96:	440b      	add	r3, r1
 8005d98:	3338      	adds	r3, #56	@ 0x38
 8005d9a:	681a      	ldr	r2, [r3, #0]
 8005d9c:	693b      	ldr	r3, [r7, #16]
 8005d9e:	18d1      	adds	r1, r2, r3
 8005da0:	6878      	ldr	r0, [r7, #4]
 8005da2:	69ba      	ldr	r2, [r7, #24]
 8005da4:	4613      	mov	r3, r2
 8005da6:	011b      	lsls	r3, r3, #4
 8005da8:	1a9b      	subs	r3, r3, r2
 8005daa:	009b      	lsls	r3, r3, #2
 8005dac:	4403      	add	r3, r0
 8005dae:	3338      	adds	r3, #56	@ 0x38
 8005db0:	6019      	str	r1, [r3, #0]
          xferSizePktCnt = (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8005db2:	69bb      	ldr	r3, [r7, #24]
 8005db4:	015a      	lsls	r2, r3, #5
 8005db6:	6a3b      	ldr	r3, [r7, #32]
 8005db8:	4413      	add	r3, r2
 8005dba:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005dbe:	691b      	ldr	r3, [r3, #16]
 8005dc0:	0cdb      	lsrs	r3, r3, #19
 8005dc2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8005dc6:	60fb      	str	r3, [r7, #12]
          if ((hhcd->hc[chnum].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 8005dc8:	6879      	ldr	r1, [r7, #4]
 8005dca:	69ba      	ldr	r2, [r7, #24]
 8005dcc:	4613      	mov	r3, r2
 8005dce:	011b      	lsls	r3, r3, #4
 8005dd0:	1a9b      	subs	r3, r3, r2
 8005dd2:	009b      	lsls	r3, r3, #2
 8005dd4:	440b      	add	r3, r1
 8005dd6:	3328      	adds	r3, #40	@ 0x28
 8005dd8:	881b      	ldrh	r3, [r3, #0]
 8005dda:	461a      	mov	r2, r3
 8005ddc:	693b      	ldr	r3, [r7, #16]
 8005dde:	4293      	cmp	r3, r2
 8005de0:	d13f      	bne.n	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
 8005de2:	68fb      	ldr	r3, [r7, #12]
 8005de4:	2b00      	cmp	r3, #0
 8005de6:	d03c      	beq.n	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
            tmpreg = USBx_HC(chnum)->HCCHAR;
 8005de8:	69bb      	ldr	r3, [r7, #24]
 8005dea:	015a      	lsls	r2, r3, #5
 8005dec:	6a3b      	ldr	r3, [r7, #32]
 8005dee:	4413      	add	r3, r2
 8005df0:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005df4:	681b      	ldr	r3, [r3, #0]
 8005df6:	60bb      	str	r3, [r7, #8]
            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005df8:	68bb      	ldr	r3, [r7, #8]
 8005dfa:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005dfe:	60bb      	str	r3, [r7, #8]
            tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005e00:	68bb      	ldr	r3, [r7, #8]
 8005e02:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8005e06:	60bb      	str	r3, [r7, #8]
            USBx_HC(chnum)->HCCHAR = tmpreg;
 8005e08:	69bb      	ldr	r3, [r7, #24]
 8005e0a:	015a      	lsls	r2, r3, #5
 8005e0c:	6a3b      	ldr	r3, [r7, #32]
 8005e0e:	4413      	add	r3, r2
 8005e10:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8005e14:	461a      	mov	r2, r3
 8005e16:	68bb      	ldr	r3, [r7, #8]
 8005e18:	6013      	str	r3, [r2, #0]
            hhcd->hc[chnum].toggle_in ^= 1U;
 8005e1a:	6879      	ldr	r1, [r7, #4]
 8005e1c:	69ba      	ldr	r2, [r7, #24]
 8005e1e:	4613      	mov	r3, r2
 8005e20:	011b      	lsls	r3, r3, #4
 8005e22:	1a9b      	subs	r3, r3, r2
 8005e24:	009b      	lsls	r3, r3, #2
 8005e26:	440b      	add	r3, r1
 8005e28:	333c      	adds	r3, #60	@ 0x3c
 8005e2a:	781b      	ldrb	r3, [r3, #0]
 8005e2c:	f083 0301 	eor.w	r3, r3, #1
 8005e30:	b2d8      	uxtb	r0, r3
 8005e32:	6879      	ldr	r1, [r7, #4]
 8005e34:	69ba      	ldr	r2, [r7, #24]
 8005e36:	4613      	mov	r3, r2
 8005e38:	011b      	lsls	r3, r3, #4
 8005e3a:	1a9b      	subs	r3, r3, r2
 8005e3c:	009b      	lsls	r3, r3, #2
 8005e3e:	440b      	add	r3, r1
 8005e40:	333c      	adds	r3, #60	@ 0x3c
 8005e42:	4602      	mov	r2, r0
 8005e44:	701a      	strb	r2, [r3, #0]
      break;
 8005e46:	e00c      	b.n	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
          hhcd->hc[chnum].urb_state = URB_ERROR;
 8005e48:	6879      	ldr	r1, [r7, #4]
 8005e4a:	69ba      	ldr	r2, [r7, #24]
 8005e4c:	4613      	mov	r3, r2
 8005e4e:	011b      	lsls	r3, r3, #4
 8005e50:	1a9b      	subs	r3, r3, r2
 8005e52:	009b      	lsls	r3, r3, #2
 8005e54:	440b      	add	r3, r1
 8005e56:	334c      	adds	r3, #76	@ 0x4c
 8005e58:	2204      	movs	r2, #4
 8005e5a:	701a      	strb	r2, [r3, #0]
      break;
 8005e5c:	e001      	b.n	8005e62 <HCD_RXQLVL_IRQHandler+0x1b4>
      break;
 8005e5e:	bf00      	nop
 8005e60:	e000      	b.n	8005e64 <HCD_RXQLVL_IRQHandler+0x1b6>
      break;
 8005e62:	bf00      	nop
  }
}
 8005e64:	bf00      	nop
 8005e66:	3728      	adds	r7, #40	@ 0x28
 8005e68:	46bd      	mov	sp, r7
 8005e6a:	bd80      	pop	{r7, pc}

08005e6c <HCD_Port_IRQHandler>:
  * @brief  Handle Host Port interrupt requests.
  * @param  hhcd HCD handle
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8005e6c:	b580      	push	{r7, lr}
 8005e6e:	b086      	sub	sp, #24
 8005e70:	af00      	add	r7, sp, #0
 8005e72:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005e74:	687b      	ldr	r3, [r7, #4]
 8005e76:	681b      	ldr	r3, [r3, #0]
 8005e78:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005e7a:	697b      	ldr	r3, [r7, #20]
 8005e7c:	613b      	str	r3, [r7, #16]
  volatile uint32_t hprt0;
  volatile uint32_t hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 8005e7e:	693b      	ldr	r3, [r7, #16]
 8005e80:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8005e84:	681b      	ldr	r3, [r3, #0]
 8005e86:	60fb      	str	r3, [r7, #12]
  hprt0_dup = USBx_HPRT0;
 8005e88:	693b      	ldr	r3, [r7, #16]
 8005e8a:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8005e8e:	681b      	ldr	r3, [r3, #0]
 8005e90:	60bb      	str	r3, [r7, #8]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 8005e92:	68bb      	ldr	r3, [r7, #8]
 8005e94:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8005e98:	60bb      	str	r3, [r7, #8]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8005e9a:	68fb      	ldr	r3, [r7, #12]
 8005e9c:	f003 0302 	and.w	r3, r3, #2
 8005ea0:	2b02      	cmp	r3, #2
 8005ea2:	d10b      	bne.n	8005ebc <HCD_Port_IRQHandler+0x50>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8005ea4:	68fb      	ldr	r3, [r7, #12]
 8005ea6:	f003 0301 	and.w	r3, r3, #1
 8005eaa:	2b01      	cmp	r3, #1
 8005eac:	d102      	bne.n	8005eb4 <HCD_Port_IRQHandler+0x48>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
 8005eae:	6878      	ldr	r0, [r7, #4]
 8005eb0:	f029 fa28 	bl	802f304 <HAL_HCD_Connect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup |= USB_OTG_HPRT_PCDET;
 8005eb4:	68bb      	ldr	r3, [r7, #8]
 8005eb6:	f043 0302 	orr.w	r3, r3, #2
 8005eba:	60bb      	str	r3, [r7, #8]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8005ebc:	68fb      	ldr	r3, [r7, #12]
 8005ebe:	f003 0308 	and.w	r3, r3, #8
 8005ec2:	2b08      	cmp	r3, #8
 8005ec4:	d132      	bne.n	8005f2c <HCD_Port_IRQHandler+0xc0>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8005ec6:	68bb      	ldr	r3, [r7, #8]
 8005ec8:	f043 0308 	orr.w	r3, r3, #8
 8005ecc:	60bb      	str	r3, [r7, #8]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8005ece:	68fb      	ldr	r3, [r7, #12]
 8005ed0:	f003 0304 	and.w	r3, r3, #4
 8005ed4:	2b04      	cmp	r3, #4
 8005ed6:	d126      	bne.n	8005f26 <HCD_Port_IRQHandler+0xba>
    {
      if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 8005ed8:	687b      	ldr	r3, [r7, #4]
 8005eda:	7a5b      	ldrb	r3, [r3, #9]
 8005edc:	2b02      	cmp	r3, #2
 8005ede:	d113      	bne.n	8005f08 <HCD_Port_IRQHandler+0x9c>
      {
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8005ee0:	68fb      	ldr	r3, [r7, #12]
 8005ee2:	f403 23c0 	and.w	r3, r3, #393216	@ 0x60000
 8005ee6:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8005eea:	d106      	bne.n	8005efa <HCD_Port_IRQHandler+0x8e>
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
 8005eec:	687b      	ldr	r3, [r7, #4]
 8005eee:	681b      	ldr	r3, [r3, #0]
 8005ef0:	2102      	movs	r1, #2
 8005ef2:	4618      	mov	r0, r3
 8005ef4:	f001 f8f2 	bl	80070dc <USB_InitFSLSPClkSel>
 8005ef8:	e011      	b.n	8005f1e <HCD_Port_IRQHandler+0xb2>
        }
        else
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8005efa:	687b      	ldr	r3, [r7, #4]
 8005efc:	681b      	ldr	r3, [r3, #0]
 8005efe:	2101      	movs	r1, #1
 8005f00:	4618      	mov	r0, r3
 8005f02:	f001 f8eb 	bl	80070dc <USB_InitFSLSPClkSel>
 8005f06:	e00a      	b.n	8005f1e <HCD_Port_IRQHandler+0xb2>
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 8005f08:	687b      	ldr	r3, [r7, #4]
 8005f0a:	79db      	ldrb	r3, [r3, #7]
 8005f0c:	2b01      	cmp	r3, #1
 8005f0e:	d106      	bne.n	8005f1e <HCD_Port_IRQHandler+0xb2>
        {
          USBx_HOST->HFIR = HFIR_60_MHZ;
 8005f10:	693b      	ldr	r3, [r7, #16]
 8005f12:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8005f16:	461a      	mov	r2, r3
 8005f18:	f64e 2360 	movw	r3, #60000	@ 0xea60
 8005f1c:	6053      	str	r3, [r2, #4]
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 8005f1e:	6878      	ldr	r0, [r7, #4]
 8005f20:	f029 fa1a 	bl	802f358 <HAL_HCD_PortEnabled_Callback>
 8005f24:	e002      	b.n	8005f2c <HCD_Port_IRQHandler+0xc0>
    else
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortDisabledCallback(hhcd);
#else
      HAL_HCD_PortDisabled_Callback(hhcd);
 8005f26:	6878      	ldr	r0, [r7, #4]
 8005f28:	f029 fa24 	bl	802f374 <HAL_HCD_PortDisabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 8005f2c:	68fb      	ldr	r3, [r7, #12]
 8005f2e:	f003 0320 	and.w	r3, r3, #32
 8005f32:	2b20      	cmp	r3, #32
 8005f34:	d103      	bne.n	8005f3e <HCD_Port_IRQHandler+0xd2>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 8005f36:	68bb      	ldr	r3, [r7, #8]
 8005f38:	f043 0320 	orr.w	r3, r3, #32
 8005f3c:	60bb      	str	r3, [r7, #8]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 8005f3e:	693b      	ldr	r3, [r7, #16]
 8005f40:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8005f44:	461a      	mov	r2, r3
 8005f46:	68bb      	ldr	r3, [r7, #8]
 8005f48:	6013      	str	r3, [r2, #0]
}
 8005f4a:	bf00      	nop
 8005f4c:	3718      	adds	r7, #24
 8005f4e:	46bd      	mov	sp, r7
 8005f50:	bd80      	pop	{r7, pc}
	...

08005f54 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8005f54:	b580      	push	{r7, lr}
 8005f56:	b086      	sub	sp, #24
 8005f58:	af00      	add	r7, sp, #0
 8005f5a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8005f5c:	687b      	ldr	r3, [r7, #4]
 8005f5e:	2b00      	cmp	r3, #0
 8005f60:	d101      	bne.n	8005f66 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8005f62:	2301      	movs	r3, #1
 8005f64:	e24b      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8005f66:	687b      	ldr	r3, [r7, #4]
 8005f68:	681b      	ldr	r3, [r3, #0]
 8005f6a:	f003 0301 	and.w	r3, r3, #1
 8005f6e:	2b00      	cmp	r3, #0
 8005f70:	d05c      	beq.n	800602c <HAL_RCC_OscConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((RCC->CFGR.bit.sws == RCC_CFGR_SWS_HSE) ||\
 8005f72:	4b9b      	ldr	r3, [pc, #620]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005f74:	689b      	ldr	r3, [r3, #8]
 8005f76:	f3c3 0381 	ubfx	r3, r3, #2, #2
      ((RCC->CFGR.bit.sws == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == (0x1UL << 22U))))
 8005f7a:	4b99      	ldr	r3, [pc, #612]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005f7c:	689b      	ldr	r3, [r3, #8]
 8005f7e:	f3c3 0381 	ubfx	r3, r3, #2, #2
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8005f82:	687b      	ldr	r3, [r7, #4]
 8005f84:	685b      	ldr	r3, [r3, #4]
 8005f86:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8005f8a:	d106      	bne.n	8005f9a <HAL_RCC_OscConfig+0x46>
 8005f8c:	4b94      	ldr	r3, [pc, #592]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005f8e:	681b      	ldr	r3, [r3, #0]
 8005f90:	4a93      	ldr	r2, [pc, #588]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005f92:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005f96:	6013      	str	r3, [r2, #0]
 8005f98:	e01d      	b.n	8005fd6 <HAL_RCC_OscConfig+0x82>
 8005f9a:	687b      	ldr	r3, [r7, #4]
 8005f9c:	685b      	ldr	r3, [r3, #4]
 8005f9e:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8005fa2:	d10c      	bne.n	8005fbe <HAL_RCC_OscConfig+0x6a>
 8005fa4:	4b8e      	ldr	r3, [pc, #568]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fa6:	681b      	ldr	r3, [r3, #0]
 8005fa8:	4a8d      	ldr	r2, [pc, #564]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005faa:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8005fae:	6013      	str	r3, [r2, #0]
 8005fb0:	4b8b      	ldr	r3, [pc, #556]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fb2:	681b      	ldr	r3, [r3, #0]
 8005fb4:	4a8a      	ldr	r2, [pc, #552]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fb6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005fba:	6013      	str	r3, [r2, #0]
 8005fbc:	e00b      	b.n	8005fd6 <HAL_RCC_OscConfig+0x82>
 8005fbe:	4b88      	ldr	r3, [pc, #544]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fc0:	681b      	ldr	r3, [r3, #0]
 8005fc2:	4a87      	ldr	r2, [pc, #540]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fc4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005fc8:	6013      	str	r3, [r2, #0]
 8005fca:	4b85      	ldr	r3, [pc, #532]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fcc:	681b      	ldr	r3, [r3, #0]
 8005fce:	4a84      	ldr	r2, [pc, #528]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005fd0:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8005fd4:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	685b      	ldr	r3, [r3, #4]
 8005fda:	2b00      	cmp	r3, #0
 8005fdc:	d013      	beq.n	8006006 <HAL_RCC_OscConfig+0xb2>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8005fde:	f7fb fd17 	bl	8001a10 <HAL_GetTick>
 8005fe2:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005fe4:	e008      	b.n	8005ff8 <HAL_RCC_OscConfig+0xa4>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8005fe6:	f7fb fd13 	bl	8001a10 <HAL_GetTick>
 8005fea:	4602      	mov	r2, r0
 8005fec:	693b      	ldr	r3, [r7, #16]
 8005fee:	1ad3      	subs	r3, r2, r3
 8005ff0:	2b64      	cmp	r3, #100	@ 0x64
 8005ff2:	d901      	bls.n	8005ff8 <HAL_RCC_OscConfig+0xa4>
          {
            return HAL_TIMEOUT;
 8005ff4:	2303      	movs	r3, #3
 8005ff6:	e202      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005ff8:	4b79      	ldr	r3, [pc, #484]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8005ffa:	681b      	ldr	r3, [r3, #0]
 8005ffc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8006000:	2b00      	cmp	r3, #0
 8006002:	d0f0      	beq.n	8005fe6 <HAL_RCC_OscConfig+0x92>
 8006004:	e012      	b.n	800602c <HAL_RCC_OscConfig+0xd8>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8006006:	f7fb fd03 	bl	8001a10 <HAL_GetTick>
 800600a:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800600c:	e008      	b.n	8006020 <HAL_RCC_OscConfig+0xcc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800600e:	f7fb fcff 	bl	8001a10 <HAL_GetTick>
 8006012:	4602      	mov	r2, r0
 8006014:	693b      	ldr	r3, [r7, #16]
 8006016:	1ad3      	subs	r3, r2, r3
 8006018:	2b64      	cmp	r3, #100	@ 0x64
 800601a:	d901      	bls.n	8006020 <HAL_RCC_OscConfig+0xcc>
          {
            return HAL_TIMEOUT;
 800601c:	2303      	movs	r3, #3
 800601e:	e1ee      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8006020:	4b6f      	ldr	r3, [pc, #444]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006022:	681b      	ldr	r3, [r3, #0]
 8006024:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8006028:	2b00      	cmp	r3, #0
 800602a:	d1f0      	bne.n	800600e <HAL_RCC_OscConfig+0xba>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800602c:	687b      	ldr	r3, [r7, #4]
 800602e:	681b      	ldr	r3, [r3, #0]
 8006030:	f003 0302 	and.w	r3, r3, #2
 8006034:	2b00      	cmp	r3, #0
 8006036:	d063      	beq.n	8006100 <HAL_RCC_OscConfig+0x1ac>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8006038:	4b69      	ldr	r3, [pc, #420]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 800603a:	689b      	ldr	r3, [r3, #8]
 800603c:	f003 030c 	and.w	r3, r3, #12
 8006040:	2b00      	cmp	r3, #0
 8006042:	d00b      	beq.n	800605c <HAL_RCC_OscConfig+0x108>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8006044:	4b66      	ldr	r3, [pc, #408]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006046:	689b      	ldr	r3, [r3, #8]
 8006048:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800604c:	2b08      	cmp	r3, #8
 800604e:	d11c      	bne.n	800608a <HAL_RCC_OscConfig+0x136>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8006050:	4b63      	ldr	r3, [pc, #396]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006052:	685b      	ldr	r3, [r3, #4]
 8006054:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8006058:	2b00      	cmp	r3, #0
 800605a:	d116      	bne.n	800608a <HAL_RCC_OscConfig+0x136>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800605c:	4b60      	ldr	r3, [pc, #384]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 800605e:	681b      	ldr	r3, [r3, #0]
 8006060:	f003 0302 	and.w	r3, r3, #2
 8006064:	2b00      	cmp	r3, #0
 8006066:	d005      	beq.n	8006074 <HAL_RCC_OscConfig+0x120>
 8006068:	687b      	ldr	r3, [r7, #4]
 800606a:	68db      	ldr	r3, [r3, #12]
 800606c:	2b01      	cmp	r3, #1
 800606e:	d001      	beq.n	8006074 <HAL_RCC_OscConfig+0x120>
      {
        return HAL_ERROR;
 8006070:	2301      	movs	r3, #1
 8006072:	e1c4      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006074:	4b5a      	ldr	r3, [pc, #360]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006076:	681b      	ldr	r3, [r3, #0]
 8006078:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800607c:	687b      	ldr	r3, [r7, #4]
 800607e:	691b      	ldr	r3, [r3, #16]
 8006080:	00db      	lsls	r3, r3, #3
 8006082:	4957      	ldr	r1, [pc, #348]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006084:	4313      	orrs	r3, r2
 8006086:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8006088:	e03a      	b.n	8006100 <HAL_RCC_OscConfig+0x1ac>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800608a:	687b      	ldr	r3, [r7, #4]
 800608c:	68db      	ldr	r3, [r3, #12]
 800608e:	2b00      	cmp	r3, #0
 8006090:	d020      	beq.n	80060d4 <HAL_RCC_OscConfig+0x180>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8006092:	4b54      	ldr	r3, [pc, #336]	@ (80061e4 <HAL_RCC_OscConfig+0x290>)
 8006094:	2201      	movs	r2, #1
 8006096:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006098:	f7fb fcba 	bl	8001a10 <HAL_GetTick>
 800609c:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800609e:	e008      	b.n	80060b2 <HAL_RCC_OscConfig+0x15e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80060a0:	f7fb fcb6 	bl	8001a10 <HAL_GetTick>
 80060a4:	4602      	mov	r2, r0
 80060a6:	693b      	ldr	r3, [r7, #16]
 80060a8:	1ad3      	subs	r3, r2, r3
 80060aa:	2b02      	cmp	r3, #2
 80060ac:	d901      	bls.n	80060b2 <HAL_RCC_OscConfig+0x15e>
          {
            return HAL_TIMEOUT;
 80060ae:	2303      	movs	r3, #3
 80060b0:	e1a5      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80060b2:	4b4b      	ldr	r3, [pc, #300]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 80060b4:	681b      	ldr	r3, [r3, #0]
 80060b6:	f003 0302 	and.w	r3, r3, #2
 80060ba:	2b00      	cmp	r3, #0
 80060bc:	d0f0      	beq.n	80060a0 <HAL_RCC_OscConfig+0x14c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80060be:	4b48      	ldr	r3, [pc, #288]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 80060c0:	681b      	ldr	r3, [r3, #0]
 80060c2:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 80060c6:	687b      	ldr	r3, [r7, #4]
 80060c8:	691b      	ldr	r3, [r3, #16]
 80060ca:	00db      	lsls	r3, r3, #3
 80060cc:	4944      	ldr	r1, [pc, #272]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 80060ce:	4313      	orrs	r3, r2
 80060d0:	600b      	str	r3, [r1, #0]
 80060d2:	e015      	b.n	8006100 <HAL_RCC_OscConfig+0x1ac>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80060d4:	4b43      	ldr	r3, [pc, #268]	@ (80061e4 <HAL_RCC_OscConfig+0x290>)
 80060d6:	2200      	movs	r2, #0
 80060d8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80060da:	f7fb fc99 	bl	8001a10 <HAL_GetTick>
 80060de:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80060e0:	e008      	b.n	80060f4 <HAL_RCC_OscConfig+0x1a0>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80060e2:	f7fb fc95 	bl	8001a10 <HAL_GetTick>
 80060e6:	4602      	mov	r2, r0
 80060e8:	693b      	ldr	r3, [r7, #16]
 80060ea:	1ad3      	subs	r3, r2, r3
 80060ec:	2b02      	cmp	r3, #2
 80060ee:	d901      	bls.n	80060f4 <HAL_RCC_OscConfig+0x1a0>
          {
            return HAL_TIMEOUT;
 80060f0:	2303      	movs	r3, #3
 80060f2:	e184      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80060f4:	4b3a      	ldr	r3, [pc, #232]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 80060f6:	681b      	ldr	r3, [r3, #0]
 80060f8:	f003 0302 	and.w	r3, r3, #2
 80060fc:	2b00      	cmp	r3, #0
 80060fe:	d1f0      	bne.n	80060e2 <HAL_RCC_OscConfig+0x18e>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006100:	687b      	ldr	r3, [r7, #4]
 8006102:	681b      	ldr	r3, [r3, #0]
 8006104:	f003 0308 	and.w	r3, r3, #8
 8006108:	2b00      	cmp	r3, #0
 800610a:	d030      	beq.n	800616e <HAL_RCC_OscConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800610c:	687b      	ldr	r3, [r7, #4]
 800610e:	695b      	ldr	r3, [r3, #20]
 8006110:	2b00      	cmp	r3, #0
 8006112:	d016      	beq.n	8006142 <HAL_RCC_OscConfig+0x1ee>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8006114:	4b34      	ldr	r3, [pc, #208]	@ (80061e8 <HAL_RCC_OscConfig+0x294>)
 8006116:	2201      	movs	r2, #1
 8006118:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800611a:	f7fb fc79 	bl	8001a10 <HAL_GetTick>
 800611e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8006120:	e008      	b.n	8006134 <HAL_RCC_OscConfig+0x1e0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8006122:	f7fb fc75 	bl	8001a10 <HAL_GetTick>
 8006126:	4602      	mov	r2, r0
 8006128:	693b      	ldr	r3, [r7, #16]
 800612a:	1ad3      	subs	r3, r2, r3
 800612c:	2b02      	cmp	r3, #2
 800612e:	d901      	bls.n	8006134 <HAL_RCC_OscConfig+0x1e0>
        {
          return HAL_TIMEOUT;
 8006130:	2303      	movs	r3, #3
 8006132:	e164      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8006134:	4b2a      	ldr	r3, [pc, #168]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006136:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8006138:	f003 0302 	and.w	r3, r3, #2
 800613c:	2b00      	cmp	r3, #0
 800613e:	d0f0      	beq.n	8006122 <HAL_RCC_OscConfig+0x1ce>
 8006140:	e015      	b.n	800616e <HAL_RCC_OscConfig+0x21a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8006142:	4b29      	ldr	r3, [pc, #164]	@ (80061e8 <HAL_RCC_OscConfig+0x294>)
 8006144:	2200      	movs	r2, #0
 8006146:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8006148:	f7fb fc62 	bl	8001a10 <HAL_GetTick>
 800614c:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800614e:	e008      	b.n	8006162 <HAL_RCC_OscConfig+0x20e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8006150:	f7fb fc5e 	bl	8001a10 <HAL_GetTick>
 8006154:	4602      	mov	r2, r0
 8006156:	693b      	ldr	r3, [r7, #16]
 8006158:	1ad3      	subs	r3, r2, r3
 800615a:	2b02      	cmp	r3, #2
 800615c:	d901      	bls.n	8006162 <HAL_RCC_OscConfig+0x20e>
        {
          return HAL_TIMEOUT;
 800615e:	2303      	movs	r3, #3
 8006160:	e14d      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8006162:	4b1f      	ldr	r3, [pc, #124]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006164:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8006166:	f003 0302 	and.w	r3, r3, #2
 800616a:	2b00      	cmp	r3, #0
 800616c:	d1f0      	bne.n	8006150 <HAL_RCC_OscConfig+0x1fc>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800616e:	687b      	ldr	r3, [r7, #4]
 8006170:	681b      	ldr	r3, [r3, #0]
 8006172:	f003 0304 	and.w	r3, r3, #4
 8006176:	2b00      	cmp	r3, #0
 8006178:	f000 80a0 	beq.w	80062bc <HAL_RCC_OscConfig+0x368>
  {
    FlagStatus       pwrclkchanged = RESET;
 800617c:	2300      	movs	r3, #0
 800617e:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8006180:	4b17      	ldr	r3, [pc, #92]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006182:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006184:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8006188:	2b00      	cmp	r3, #0
 800618a:	d10f      	bne.n	80061ac <HAL_RCC_OscConfig+0x258>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800618c:	2300      	movs	r3, #0
 800618e:	60bb      	str	r3, [r7, #8]
 8006190:	4b13      	ldr	r3, [pc, #76]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006192:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8006194:	4a12      	ldr	r2, [pc, #72]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 8006196:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800619a:	6413      	str	r3, [r2, #64]	@ 0x40
 800619c:	4b10      	ldr	r3, [pc, #64]	@ (80061e0 <HAL_RCC_OscConfig+0x28c>)
 800619e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80061a0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80061a4:	60bb      	str	r3, [r7, #8]
 80061a6:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 80061a8:	2301      	movs	r3, #1
 80061aa:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 80061ac:	4b0f      	ldr	r3, [pc, #60]	@ (80061ec <HAL_RCC_OscConfig+0x298>)
 80061ae:	681b      	ldr	r3, [r3, #0]
 80061b0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80061b4:	2b00      	cmp	r3, #0
 80061b6:	d121      	bne.n	80061fc <HAL_RCC_OscConfig+0x2a8>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR.reg, PWR_CR_DBP);
 80061b8:	4b0c      	ldr	r3, [pc, #48]	@ (80061ec <HAL_RCC_OscConfig+0x298>)
 80061ba:	681b      	ldr	r3, [r3, #0]
 80061bc:	4a0b      	ldr	r2, [pc, #44]	@ (80061ec <HAL_RCC_OscConfig+0x298>)
 80061be:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80061c2:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80061c4:	f7fb fc24 	bl	8001a10 <HAL_GetTick>
 80061c8:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 80061ca:	e011      	b.n	80061f0 <HAL_RCC_OscConfig+0x29c>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80061cc:	f7fb fc20 	bl	8001a10 <HAL_GetTick>
 80061d0:	4602      	mov	r2, r0
 80061d2:	693b      	ldr	r3, [r7, #16]
 80061d4:	1ad3      	subs	r3, r2, r3
 80061d6:	2b02      	cmp	r3, #2
 80061d8:	d90a      	bls.n	80061f0 <HAL_RCC_OscConfig+0x29c>
        {
          return HAL_TIMEOUT;
 80061da:	2303      	movs	r3, #3
 80061dc:	e10f      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
 80061de:	bf00      	nop
 80061e0:	40023800 	.word	0x40023800
 80061e4:	42470000 	.word	0x42470000
 80061e8:	42470e80 	.word	0x42470e80
 80061ec:	40007000 	.word	0x40007000
      while(HAL_IS_BIT_CLR(PWR->CR.reg, PWR_CR_DBP))
 80061f0:	4b85      	ldr	r3, [pc, #532]	@ (8006408 <HAL_RCC_OscConfig+0x4b4>)
 80061f2:	681b      	ldr	r3, [r3, #0]
 80061f4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80061f8:	2b00      	cmp	r3, #0
 80061fa:	d0e7      	beq.n	80061cc <HAL_RCC_OscConfig+0x278>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80061fc:	687b      	ldr	r3, [r7, #4]
 80061fe:	689b      	ldr	r3, [r3, #8]
 8006200:	2b01      	cmp	r3, #1
 8006202:	d106      	bne.n	8006212 <HAL_RCC_OscConfig+0x2be>
 8006204:	4b81      	ldr	r3, [pc, #516]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006206:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006208:	4a80      	ldr	r2, [pc, #512]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800620a:	f043 0301 	orr.w	r3, r3, #1
 800620e:	6713      	str	r3, [r2, #112]	@ 0x70
 8006210:	e01c      	b.n	800624c <HAL_RCC_OscConfig+0x2f8>
 8006212:	687b      	ldr	r3, [r7, #4]
 8006214:	689b      	ldr	r3, [r3, #8]
 8006216:	2b05      	cmp	r3, #5
 8006218:	d10c      	bne.n	8006234 <HAL_RCC_OscConfig+0x2e0>
 800621a:	4b7c      	ldr	r3, [pc, #496]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800621c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800621e:	4a7b      	ldr	r2, [pc, #492]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006220:	f043 0304 	orr.w	r3, r3, #4
 8006224:	6713      	str	r3, [r2, #112]	@ 0x70
 8006226:	4b79      	ldr	r3, [pc, #484]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006228:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800622a:	4a78      	ldr	r2, [pc, #480]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800622c:	f043 0301 	orr.w	r3, r3, #1
 8006230:	6713      	str	r3, [r2, #112]	@ 0x70
 8006232:	e00b      	b.n	800624c <HAL_RCC_OscConfig+0x2f8>
 8006234:	4b75      	ldr	r3, [pc, #468]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006236:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006238:	4a74      	ldr	r2, [pc, #464]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800623a:	f023 0301 	bic.w	r3, r3, #1
 800623e:	6713      	str	r3, [r2, #112]	@ 0x70
 8006240:	4b72      	ldr	r3, [pc, #456]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006242:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006244:	4a71      	ldr	r2, [pc, #452]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006246:	f023 0304 	bic.w	r3, r3, #4
 800624a:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800624c:	687b      	ldr	r3, [r7, #4]
 800624e:	689b      	ldr	r3, [r3, #8]
 8006250:	2b00      	cmp	r3, #0
 8006252:	d015      	beq.n	8006280 <HAL_RCC_OscConfig+0x32c>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006254:	f7fb fbdc 	bl	8001a10 <HAL_GetTick>
 8006258:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800625a:	e00a      	b.n	8006272 <HAL_RCC_OscConfig+0x31e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800625c:	f7fb fbd8 	bl	8001a10 <HAL_GetTick>
 8006260:	4602      	mov	r2, r0
 8006262:	693b      	ldr	r3, [r7, #16]
 8006264:	1ad3      	subs	r3, r2, r3
 8006266:	f241 3288 	movw	r2, #5000	@ 0x1388
 800626a:	4293      	cmp	r3, r2
 800626c:	d901      	bls.n	8006272 <HAL_RCC_OscConfig+0x31e>
        {
          return HAL_TIMEOUT;
 800626e:	2303      	movs	r3, #3
 8006270:	e0c5      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006272:	4b66      	ldr	r3, [pc, #408]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006274:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006276:	f003 0302 	and.w	r3, r3, #2
 800627a:	2b00      	cmp	r3, #0
 800627c:	d0ee      	beq.n	800625c <HAL_RCC_OscConfig+0x308>
 800627e:	e014      	b.n	80062aa <HAL_RCC_OscConfig+0x356>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8006280:	f7fb fbc6 	bl	8001a10 <HAL_GetTick>
 8006284:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8006286:	e00a      	b.n	800629e <HAL_RCC_OscConfig+0x34a>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8006288:	f7fb fbc2 	bl	8001a10 <HAL_GetTick>
 800628c:	4602      	mov	r2, r0
 800628e:	693b      	ldr	r3, [r7, #16]
 8006290:	1ad3      	subs	r3, r2, r3
 8006292:	f241 3288 	movw	r2, #5000	@ 0x1388
 8006296:	4293      	cmp	r3, r2
 8006298:	d901      	bls.n	800629e <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 800629a:	2303      	movs	r3, #3
 800629c:	e0af      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800629e:	4b5b      	ldr	r3, [pc, #364]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 80062a0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80062a2:	f003 0302 	and.w	r3, r3, #2
 80062a6:	2b00      	cmp	r3, #0
 80062a8:	d1ee      	bne.n	8006288 <HAL_RCC_OscConfig+0x334>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80062aa:	7dfb      	ldrb	r3, [r7, #23]
 80062ac:	2b01      	cmp	r3, #1
 80062ae:	d105      	bne.n	80062bc <HAL_RCC_OscConfig+0x368>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80062b0:	4b56      	ldr	r3, [pc, #344]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 80062b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80062b4:	4a55      	ldr	r2, [pc, #340]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 80062b6:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80062ba:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80062bc:	687b      	ldr	r3, [r7, #4]
 80062be:	699b      	ldr	r3, [r3, #24]
 80062c0:	2b00      	cmp	r3, #0
 80062c2:	f000 809b 	beq.w	80063fc <HAL_RCC_OscConfig+0x4a8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80062c6:	4b51      	ldr	r3, [pc, #324]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 80062c8:	689b      	ldr	r3, [r3, #8]
 80062ca:	f003 030c 	and.w	r3, r3, #12
 80062ce:	2b08      	cmp	r3, #8
 80062d0:	d05c      	beq.n	800638c <HAL_RCC_OscConfig+0x438>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80062d2:	687b      	ldr	r3, [r7, #4]
 80062d4:	699b      	ldr	r3, [r3, #24]
 80062d6:	2b02      	cmp	r3, #2
 80062d8:	d141      	bne.n	800635e <HAL_RCC_OscConfig+0x40a>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80062da:	4b4d      	ldr	r3, [pc, #308]	@ (8006410 <HAL_RCC_OscConfig+0x4bc>)
 80062dc:	2200      	movs	r2, #0
 80062de:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80062e0:	f7fb fb96 	bl	8001a10 <HAL_GetTick>
 80062e4:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80062e6:	e008      	b.n	80062fa <HAL_RCC_OscConfig+0x3a6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80062e8:	f7fb fb92 	bl	8001a10 <HAL_GetTick>
 80062ec:	4602      	mov	r2, r0
 80062ee:	693b      	ldr	r3, [r7, #16]
 80062f0:	1ad3      	subs	r3, r2, r3
 80062f2:	2b02      	cmp	r3, #2
 80062f4:	d901      	bls.n	80062fa <HAL_RCC_OscConfig+0x3a6>
          {
            return HAL_TIMEOUT;
 80062f6:	2303      	movs	r3, #3
 80062f8:	e081      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80062fa:	4b44      	ldr	r3, [pc, #272]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 80062fc:	681b      	ldr	r3, [r3, #0]
 80062fe:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006302:	2b00      	cmp	r3, #0
 8006304:	d1f0      	bne.n	80062e8 <HAL_RCC_OscConfig+0x394>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR.reg, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8006306:	687b      	ldr	r3, [r7, #4]
 8006308:	69da      	ldr	r2, [r3, #28]
 800630a:	687b      	ldr	r3, [r7, #4]
 800630c:	6a1b      	ldr	r3, [r3, #32]
 800630e:	431a      	orrs	r2, r3
 8006310:	687b      	ldr	r3, [r7, #4]
 8006312:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006314:	019b      	lsls	r3, r3, #6
 8006316:	431a      	orrs	r2, r3
 8006318:	687b      	ldr	r3, [r7, #4]
 800631a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800631c:	085b      	lsrs	r3, r3, #1
 800631e:	3b01      	subs	r3, #1
 8006320:	041b      	lsls	r3, r3, #16
 8006322:	431a      	orrs	r2, r3
 8006324:	687b      	ldr	r3, [r7, #4]
 8006326:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8006328:	061b      	lsls	r3, r3, #24
 800632a:	4938      	ldr	r1, [pc, #224]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800632c:	4313      	orrs	r3, r2
 800632e:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8006330:	4b37      	ldr	r3, [pc, #220]	@ (8006410 <HAL_RCC_OscConfig+0x4bc>)
 8006332:	2201      	movs	r2, #1
 8006334:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8006336:	f7fb fb6b 	bl	8001a10 <HAL_GetTick>
 800633a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800633c:	e008      	b.n	8006350 <HAL_RCC_OscConfig+0x3fc>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800633e:	f7fb fb67 	bl	8001a10 <HAL_GetTick>
 8006342:	4602      	mov	r2, r0
 8006344:	693b      	ldr	r3, [r7, #16]
 8006346:	1ad3      	subs	r3, r2, r3
 8006348:	2b02      	cmp	r3, #2
 800634a:	d901      	bls.n	8006350 <HAL_RCC_OscConfig+0x3fc>
          {
            return HAL_TIMEOUT;
 800634c:	2303      	movs	r3, #3
 800634e:	e056      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8006350:	4b2e      	ldr	r3, [pc, #184]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006352:	681b      	ldr	r3, [r3, #0]
 8006354:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006358:	2b00      	cmp	r3, #0
 800635a:	d0f0      	beq.n	800633e <HAL_RCC_OscConfig+0x3ea>
 800635c:	e04e      	b.n	80063fc <HAL_RCC_OscConfig+0x4a8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800635e:	4b2c      	ldr	r3, [pc, #176]	@ (8006410 <HAL_RCC_OscConfig+0x4bc>)
 8006360:	2200      	movs	r2, #0
 8006362:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8006364:	f7fb fb54 	bl	8001a10 <HAL_GetTick>
 8006368:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800636a:	e008      	b.n	800637e <HAL_RCC_OscConfig+0x42a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800636c:	f7fb fb50 	bl	8001a10 <HAL_GetTick>
 8006370:	4602      	mov	r2, r0
 8006372:	693b      	ldr	r3, [r7, #16]
 8006374:	1ad3      	subs	r3, r2, r3
 8006376:	2b02      	cmp	r3, #2
 8006378:	d901      	bls.n	800637e <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
 800637a:	2303      	movs	r3, #3
 800637c:	e03f      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800637e:	4b23      	ldr	r3, [pc, #140]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 8006380:	681b      	ldr	r3, [r3, #0]
 8006382:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006386:	2b00      	cmp	r3, #0
 8006388:	d1f0      	bne.n	800636c <HAL_RCC_OscConfig+0x418>
 800638a:	e037      	b.n	80063fc <HAL_RCC_OscConfig+0x4a8>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800638c:	687b      	ldr	r3, [r7, #4]
 800638e:	699b      	ldr	r3, [r3, #24]
 8006390:	2b01      	cmp	r3, #1
 8006392:	d101      	bne.n	8006398 <HAL_RCC_OscConfig+0x444>
      {
        return HAL_ERROR;
 8006394:	2301      	movs	r3, #1
 8006396:	e032      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR.reg;
 8006398:	4b1c      	ldr	r3, [pc, #112]	@ (800640c <HAL_RCC_OscConfig+0x4b8>)
 800639a:	685b      	ldr	r3, [r3, #4]
 800639c:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	699b      	ldr	r3, [r3, #24]
 80063a2:	2b01      	cmp	r3, #1
 80063a4:	d028      	beq.n	80063f8 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80063a6:	68fb      	ldr	r3, [r7, #12]
 80063a8:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 80063ac:	687b      	ldr	r3, [r7, #4]
 80063ae:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80063b0:	429a      	cmp	r2, r3
 80063b2:	d121      	bne.n	80063f8 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80063b4:	68fb      	ldr	r3, [r7, #12]
 80063b6:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 80063ba:	687b      	ldr	r3, [r7, #4]
 80063bc:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80063be:	429a      	cmp	r2, r3
 80063c0:	d11a      	bne.n	80063f8 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80063c2:	68fa      	ldr	r2, [r7, #12]
 80063c4:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 80063c8:	4013      	ands	r3, r2
 80063ca:	687a      	ldr	r2, [r7, #4]
 80063cc:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80063ce:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80063d0:	4293      	cmp	r3, r2
 80063d2:	d111      	bne.n	80063f8 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80063d4:	68fb      	ldr	r3, [r7, #12]
 80063d6:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 80063da:	687b      	ldr	r3, [r7, #4]
 80063dc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80063de:	085b      	lsrs	r3, r3, #1
 80063e0:	3b01      	subs	r3, #1
 80063e2:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80063e4:	429a      	cmp	r2, r3
 80063e6:	d107      	bne.n	80063f8 <HAL_RCC_OscConfig+0x4a4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80063e8:	68fb      	ldr	r3, [r7, #12]
 80063ea:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 80063ee:	687b      	ldr	r3, [r7, #4]
 80063f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80063f2:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80063f4:	429a      	cmp	r2, r3
 80063f6:	d001      	beq.n	80063fc <HAL_RCC_OscConfig+0x4a8>
#endif
        {
          return HAL_ERROR;
 80063f8:	2301      	movs	r3, #1
 80063fa:	e000      	b.n	80063fe <HAL_RCC_OscConfig+0x4aa>
        }
      }
    }
  }
  return HAL_OK;
 80063fc:	2300      	movs	r3, #0
}
 80063fe:	4618      	mov	r0, r3
 8006400:	3718      	adds	r7, #24
 8006402:	46bd      	mov	sp, r7
 8006404:	bd80      	pop	{r7, pc}
 8006406:	bf00      	nop
 8006408:	40007000 	.word	0x40007000
 800640c:	40023800 	.word	0x40023800
 8006410:	42470060 	.word	0x42470060

08006414 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8006414:	b580      	push	{r7, lr}
 8006416:	b084      	sub	sp, #16
 8006418:	af00      	add	r7, sp, #0
 800641a:	6078      	str	r0, [r7, #4]
 800641c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800641e:	687b      	ldr	r3, [r7, #4]
 8006420:	2b00      	cmp	r3, #0
 8006422:	d101      	bne.n	8006428 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8006424:	2301      	movs	r3, #1
 8006426:	e0cc      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8006428:	4b68      	ldr	r3, [pc, #416]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 800642a:	681b      	ldr	r3, [r3, #0]
 800642c:	f003 0307 	and.w	r3, r3, #7
 8006430:	683a      	ldr	r2, [r7, #0]
 8006432:	429a      	cmp	r2, r3
 8006434:	d90c      	bls.n	8006450 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006436:	4b65      	ldr	r3, [pc, #404]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 8006438:	683a      	ldr	r2, [r7, #0]
 800643a:	b2d2      	uxtb	r2, r2
 800643c:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800643e:	4b63      	ldr	r3, [pc, #396]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 8006440:	681b      	ldr	r3, [r3, #0]
 8006442:	f003 0307 	and.w	r3, r3, #7
 8006446:	683a      	ldr	r2, [r7, #0]
 8006448:	429a      	cmp	r2, r3
 800644a:	d001      	beq.n	8006450 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 800644c:	2301      	movs	r3, #1
 800644e:	e0b8      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006450:	687b      	ldr	r3, [r7, #4]
 8006452:	681b      	ldr	r3, [r3, #0]
 8006454:	f003 0302 	and.w	r3, r3, #2
 8006458:	2b00      	cmp	r3, #0
 800645a:	d020      	beq.n	800649e <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800645c:	687b      	ldr	r3, [r7, #4]
 800645e:	681b      	ldr	r3, [r3, #0]
 8006460:	f003 0304 	and.w	r3, r3, #4
 8006464:	2b00      	cmp	r3, #0
 8006466:	d005      	beq.n	8006474 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8006468:	4b59      	ldr	r3, [pc, #356]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 800646a:	689b      	ldr	r3, [r3, #8]
 800646c:	4a58      	ldr	r2, [pc, #352]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 800646e:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 8006472:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006474:	687b      	ldr	r3, [r7, #4]
 8006476:	681b      	ldr	r3, [r3, #0]
 8006478:	f003 0308 	and.w	r3, r3, #8
 800647c:	2b00      	cmp	r3, #0
 800647e:	d005      	beq.n	800648c <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8006480:	4b53      	ldr	r3, [pc, #332]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006482:	689b      	ldr	r3, [r3, #8]
 8006484:	4a52      	ldr	r2, [pc, #328]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006486:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 800648a:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800648c:	4b50      	ldr	r3, [pc, #320]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 800648e:	689b      	ldr	r3, [r3, #8]
 8006490:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	689b      	ldr	r3, [r3, #8]
 8006498:	494d      	ldr	r1, [pc, #308]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 800649a:	4313      	orrs	r3, r2
 800649c:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800649e:	687b      	ldr	r3, [r7, #4]
 80064a0:	681b      	ldr	r3, [r3, #0]
 80064a2:	f003 0301 	and.w	r3, r3, #1
 80064a6:	2b00      	cmp	r3, #0
 80064a8:	d044      	beq.n	8006534 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80064aa:	687b      	ldr	r3, [r7, #4]
 80064ac:	685b      	ldr	r3, [r3, #4]
 80064ae:	2b01      	cmp	r3, #1
 80064b0:	d107      	bne.n	80064c2 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80064b2:	4b47      	ldr	r3, [pc, #284]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 80064b4:	681b      	ldr	r3, [r3, #0]
 80064b6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80064ba:	2b00      	cmp	r3, #0
 80064bc:	d119      	bne.n	80064f2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80064be:	2301      	movs	r3, #1
 80064c0:	e07f      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80064c2:	687b      	ldr	r3, [r7, #4]
 80064c4:	685b      	ldr	r3, [r3, #4]
 80064c6:	2b02      	cmp	r3, #2
 80064c8:	d003      	beq.n	80064d2 <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 80064ca:	687b      	ldr	r3, [r7, #4]
 80064cc:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80064ce:	2b03      	cmp	r3, #3
 80064d0:	d107      	bne.n	80064e2 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80064d2:	4b3f      	ldr	r3, [pc, #252]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 80064d4:	681b      	ldr	r3, [r3, #0]
 80064d6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80064da:	2b00      	cmp	r3, #0
 80064dc:	d109      	bne.n	80064f2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80064de:	2301      	movs	r3, #1
 80064e0:	e06f      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80064e2:	4b3b      	ldr	r3, [pc, #236]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 80064e4:	681b      	ldr	r3, [r3, #0]
 80064e6:	f003 0302 	and.w	r3, r3, #2
 80064ea:	2b00      	cmp	r3, #0
 80064ec:	d101      	bne.n	80064f2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80064ee:	2301      	movs	r3, #1
 80064f0:	e067      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80064f2:	4b37      	ldr	r3, [pc, #220]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 80064f4:	689b      	ldr	r3, [r3, #8]
 80064f6:	f023 0203 	bic.w	r2, r3, #3
 80064fa:	687b      	ldr	r3, [r7, #4]
 80064fc:	685b      	ldr	r3, [r3, #4]
 80064fe:	4934      	ldr	r1, [pc, #208]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006500:	4313      	orrs	r3, r2
 8006502:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8006504:	f7fb fa84 	bl	8001a10 <HAL_GetTick>
 8006508:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800650a:	e00a      	b.n	8006522 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800650c:	f7fb fa80 	bl	8001a10 <HAL_GetTick>
 8006510:	4602      	mov	r2, r0
 8006512:	68fb      	ldr	r3, [r7, #12]
 8006514:	1ad3      	subs	r3, r2, r3
 8006516:	f241 3288 	movw	r2, #5000	@ 0x1388
 800651a:	4293      	cmp	r3, r2
 800651c:	d901      	bls.n	8006522 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 800651e:	2303      	movs	r3, #3
 8006520:	e04f      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8006522:	4b2b      	ldr	r3, [pc, #172]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006524:	689b      	ldr	r3, [r3, #8]
 8006526:	f003 020c 	and.w	r2, r3, #12
 800652a:	687b      	ldr	r3, [r7, #4]
 800652c:	685b      	ldr	r3, [r3, #4]
 800652e:	009b      	lsls	r3, r3, #2
 8006530:	429a      	cmp	r2, r3
 8006532:	d1eb      	bne.n	800650c <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8006534:	4b25      	ldr	r3, [pc, #148]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 8006536:	681b      	ldr	r3, [r3, #0]
 8006538:	f003 0307 	and.w	r3, r3, #7
 800653c:	683a      	ldr	r2, [r7, #0]
 800653e:	429a      	cmp	r2, r3
 8006540:	d20c      	bcs.n	800655c <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006542:	4b22      	ldr	r3, [pc, #136]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 8006544:	683a      	ldr	r2, [r7, #0]
 8006546:	b2d2      	uxtb	r2, r2
 8006548:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800654a:	4b20      	ldr	r3, [pc, #128]	@ (80065cc <HAL_RCC_ClockConfig+0x1b8>)
 800654c:	681b      	ldr	r3, [r3, #0]
 800654e:	f003 0307 	and.w	r3, r3, #7
 8006552:	683a      	ldr	r2, [r7, #0]
 8006554:	429a      	cmp	r2, r3
 8006556:	d001      	beq.n	800655c <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8006558:	2301      	movs	r3, #1
 800655a:	e032      	b.n	80065c2 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800655c:	687b      	ldr	r3, [r7, #4]
 800655e:	681b      	ldr	r3, [r3, #0]
 8006560:	f003 0304 	and.w	r3, r3, #4
 8006564:	2b00      	cmp	r3, #0
 8006566:	d008      	beq.n	800657a <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8006568:	4b19      	ldr	r3, [pc, #100]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 800656a:	689b      	ldr	r3, [r3, #8]
 800656c:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 8006570:	687b      	ldr	r3, [r7, #4]
 8006572:	68db      	ldr	r3, [r3, #12]
 8006574:	4916      	ldr	r1, [pc, #88]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006576:	4313      	orrs	r3, r2
 8006578:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800657a:	687b      	ldr	r3, [r7, #4]
 800657c:	681b      	ldr	r3, [r3, #0]
 800657e:	f003 0308 	and.w	r3, r3, #8
 8006582:	2b00      	cmp	r3, #0
 8006584:	d009      	beq.n	800659a <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR.reg, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8006586:	4b12      	ldr	r3, [pc, #72]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006588:	689b      	ldr	r3, [r3, #8]
 800658a:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 800658e:	687b      	ldr	r3, [r7, #4]
 8006590:	691b      	ldr	r3, [r3, #16]
 8006592:	00db      	lsls	r3, r3, #3
 8006594:	490e      	ldr	r1, [pc, #56]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 8006596:	4313      	orrs	r3, r2
 8006598:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR.reg & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800659a:	f000 f897 	bl	80066cc <HAL_RCC_GetSysClockFreq>
 800659e:	4602      	mov	r2, r0
 80065a0:	4b0b      	ldr	r3, [pc, #44]	@ (80065d0 <HAL_RCC_ClockConfig+0x1bc>)
 80065a2:	689b      	ldr	r3, [r3, #8]
 80065a4:	091b      	lsrs	r3, r3, #4
 80065a6:	f003 030f 	and.w	r3, r3, #15
 80065aa:	490a      	ldr	r1, [pc, #40]	@ (80065d4 <HAL_RCC_ClockConfig+0x1c0>)
 80065ac:	5ccb      	ldrb	r3, [r1, r3]
 80065ae:	fa22 f303 	lsr.w	r3, r2, r3
 80065b2:	4a09      	ldr	r2, [pc, #36]	@ (80065d8 <HAL_RCC_ClockConfig+0x1c4>)
 80065b4:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 80065b6:	4b09      	ldr	r3, [pc, #36]	@ (80065dc <HAL_RCC_ClockConfig+0x1c8>)
 80065b8:	681b      	ldr	r3, [r3, #0]
 80065ba:	4618      	mov	r0, r3
 80065bc:	f7fb f9e4 	bl	8001988 <HAL_InitTick>

  return HAL_OK;
 80065c0:	2300      	movs	r3, #0
}
 80065c2:	4618      	mov	r0, r3
 80065c4:	3710      	adds	r7, #16
 80065c6:	46bd      	mov	sp, r7
 80065c8:	bd80      	pop	{r7, pc}
 80065ca:	bf00      	nop
 80065cc:	40023c00 	.word	0x40023c00
 80065d0:	40023800 	.word	0x40023800
 80065d4:	080315c0 	.word	0x080315c0
 80065d8:	20000000 	.word	0x20000000
 80065dc:	20000004 	.word	0x20000004

080065e0 <HAL_RCC_MCOConfig>:
  * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have
  *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80065e0:	b580      	push	{r7, lr}
 80065e2:	b08a      	sub	sp, #40	@ 0x28
 80065e4:	af00      	add	r7, sp, #0
 80065e6:	60f8      	str	r0, [r7, #12]
 80065e8:	60b9      	str	r1, [r7, #8]
 80065ea:	607a      	str	r2, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 80065ec:	68fb      	ldr	r3, [r7, #12]
 80065ee:	2b00      	cmp	r3, #0
 80065f0:	d130      	bne.n	8006654 <HAL_RCC_MCOConfig+0x74>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    __MCO1_CLK_ENABLE();
 80065f2:	2300      	movs	r3, #0
 80065f4:	617b      	str	r3, [r7, #20]
 80065f6:	4b32      	ldr	r3, [pc, #200]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 80065f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80065fa:	4a31      	ldr	r2, [pc, #196]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 80065fc:	f043 0301 	orr.w	r3, r3, #1
 8006600:	6313      	str	r3, [r2, #48]	@ 0x30
 8006602:	4b2f      	ldr	r3, [pc, #188]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 8006604:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006606:	f003 0301 	and.w	r3, r3, #1
 800660a:	617b      	str	r3, [r7, #20]
 800660c:	697b      	ldr	r3, [r7, #20]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.pGPIOx = MCO1_GPIO_PORT;
 800660e:	4b2d      	ldr	r3, [pc, #180]	@ (80066c4 <HAL_RCC_MCOConfig+0xe4>)
 8006610:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.GPIO_Config.PinNumber = MCO1_PIN;
 8006612:	2308      	movs	r3, #8
 8006614:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8006616:	2302      	movs	r3, #2
 8006618:	f887 3020 	strb.w	r3, [r7, #32]
    GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800661c:	2300      	movs	r3, #0
 800661e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    GPIO_InitStruct.GPIO_Config.PinSpeed = 3;
 8006622:	2303      	movs	r3, #3
 8006624:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
    GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 8006628:	2300      	movs	r3, #0
 800662a:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
    GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 800662e:	2300      	movs	r3, #0
 8006630:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
    GPIO_Init(&GPIO_InitStruct);
 8006634:	f107 0318 	add.w	r3, r7, #24
 8006638:	4618      	mov	r0, r3
 800663a:	f002 fe45 	bl	80092c8 <GPIO_Init>

    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    MODIFY_REG(RCC->CFGR.reg, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 800663e:	4b20      	ldr	r3, [pc, #128]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 8006640:	689b      	ldr	r3, [r3, #8]
 8006642:	f023 62ec 	bic.w	r2, r3, #123731968	@ 0x7600000
 8006646:	68b9      	ldr	r1, [r7, #8]
 8006648:	687b      	ldr	r3, [r7, #4]
 800664a:	430b      	orrs	r3, r1
 800664c:	491c      	ldr	r1, [pc, #112]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 800664e:	4313      	orrs	r3, r2
 8006650:	608b      	str	r3, [r1, #8]
#if defined(RCC_CFGR_MCO2EN)
    __HAL_RCC_MCO2_ENABLE();
#endif /* RCC_CFGR_MCO2EN */
  }
#endif /* RCC_CFGR_MCO2 */
}
 8006652:	e030      	b.n	80066b6 <HAL_RCC_MCOConfig+0xd6>
    __MCO2_CLK_ENABLE();
 8006654:	2300      	movs	r3, #0
 8006656:	613b      	str	r3, [r7, #16]
 8006658:	4b19      	ldr	r3, [pc, #100]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 800665a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800665c:	4a18      	ldr	r2, [pc, #96]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 800665e:	f043 0304 	orr.w	r3, r3, #4
 8006662:	6313      	str	r3, [r2, #48]	@ 0x30
 8006664:	4b16      	ldr	r3, [pc, #88]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 8006666:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006668:	f003 0304 	and.w	r3, r3, #4
 800666c:	613b      	str	r3, [r7, #16]
 800666e:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.pGPIOx = MCO2_GPIO_PORT;
 8006670:	4b15      	ldr	r3, [pc, #84]	@ (80066c8 <HAL_RCC_MCOConfig+0xe8>)
 8006672:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.GPIO_Config.PinNumber = MCO2_PIN;
 8006674:	2309      	movs	r3, #9
 8006676:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 8006678:	2302      	movs	r3, #2
 800667a:	f887 3020 	strb.w	r3, [r7, #32]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 800667e:	2300      	movs	r3, #0
 8006680:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
	GPIO_InitStruct.GPIO_Config.PinSpeed = 3;
 8006684:	2303      	movs	r3, #3
 8006686:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 800668a:	2300      	movs	r3, #0
 800668c:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0;
 8006690:	2300      	movs	r3, #0
 8006692:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
	GPIO_Init(&GPIO_InitStruct);
 8006696:	f107 0318 	add.w	r3, r7, #24
 800669a:	4618      	mov	r0, r3
 800669c:	f002 fe14 	bl	80092c8 <GPIO_Init>
    MODIFY_REG(RCC->CFGR.reg, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3U)));
 80066a0:	4b07      	ldr	r3, [pc, #28]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 80066a2:	689b      	ldr	r3, [r3, #8]
 80066a4:	f023 4278 	bic.w	r2, r3, #4160749568	@ 0xf8000000
 80066a8:	687b      	ldr	r3, [r7, #4]
 80066aa:	00d9      	lsls	r1, r3, #3
 80066ac:	68bb      	ldr	r3, [r7, #8]
 80066ae:	430b      	orrs	r3, r1
 80066b0:	4903      	ldr	r1, [pc, #12]	@ (80066c0 <HAL_RCC_MCOConfig+0xe0>)
 80066b2:	4313      	orrs	r3, r2
 80066b4:	608b      	str	r3, [r1, #8]
}
 80066b6:	bf00      	nop
 80066b8:	3728      	adds	r7, #40	@ 0x28
 80066ba:	46bd      	mov	sp, r7
 80066bc:	bd80      	pop	{r7, pc}
 80066be:	bf00      	nop
 80066c0:	40023800 	.word	0x40023800
 80066c4:	40020000 	.word	0x40020000
 80066c8:	40020800 	.word	0x40020800

080066cc <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80066cc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80066d0:	b094      	sub	sp, #80	@ 0x50
 80066d2:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 80066d4:	2300      	movs	r3, #0
 80066d6:	647b      	str	r3, [r7, #68]	@ 0x44
 80066d8:	2300      	movs	r3, #0
 80066da:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80066dc:	2300      	movs	r3, #0
 80066de:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 80066e0:	2300      	movs	r3, #0
 80066e2:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR.reg & RCC_CFGR_SWS)
 80066e4:	4b79      	ldr	r3, [pc, #484]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 80066e6:	689b      	ldr	r3, [r3, #8]
 80066e8:	f003 030c 	and.w	r3, r3, #12
 80066ec:	2b08      	cmp	r3, #8
 80066ee:	d00d      	beq.n	800670c <HAL_RCC_GetSysClockFreq+0x40>
 80066f0:	2b08      	cmp	r3, #8
 80066f2:	f200 80e1 	bhi.w	80068b8 <HAL_RCC_GetSysClockFreq+0x1ec>
 80066f6:	2b00      	cmp	r3, #0
 80066f8:	d002      	beq.n	8006700 <HAL_RCC_GetSysClockFreq+0x34>
 80066fa:	2b04      	cmp	r3, #4
 80066fc:	d003      	beq.n	8006706 <HAL_RCC_GetSysClockFreq+0x3a>
 80066fe:	e0db      	b.n	80068b8 <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8006700:	4b73      	ldr	r3, [pc, #460]	@ (80068d0 <HAL_RCC_GetSysClockFreq+0x204>)
 8006702:	64bb      	str	r3, [r7, #72]	@ 0x48
       break;
 8006704:	e0db      	b.n	80068be <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8006706:	4b73      	ldr	r3, [pc, #460]	@ (80068d4 <HAL_RCC_GetSysClockFreq+0x208>)
 8006708:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 800670a:	e0d8      	b.n	80068be <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLM;
 800670c:	4b6f      	ldr	r3, [pc, #444]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 800670e:	685b      	ldr	r3, [r3, #4]
 8006710:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8006714:	647b      	str	r3, [r7, #68]	@ 0x44
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8006716:	4b6d      	ldr	r3, [pc, #436]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 8006718:	685b      	ldr	r3, [r3, #4]
 800671a:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800671e:	2b00      	cmp	r3, #0
 8006720:	d063      	beq.n	80067ea <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8006722:	4b6a      	ldr	r3, [pc, #424]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 8006724:	685b      	ldr	r3, [r3, #4]
 8006726:	099b      	lsrs	r3, r3, #6
 8006728:	2200      	movs	r2, #0
 800672a:	63bb      	str	r3, [r7, #56]	@ 0x38
 800672c:	63fa      	str	r2, [r7, #60]	@ 0x3c
 800672e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006730:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006734:	633b      	str	r3, [r7, #48]	@ 0x30
 8006736:	2300      	movs	r3, #0
 8006738:	637b      	str	r3, [r7, #52]	@ 0x34
 800673a:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 800673e:	4622      	mov	r2, r4
 8006740:	462b      	mov	r3, r5
 8006742:	f04f 0000 	mov.w	r0, #0
 8006746:	f04f 0100 	mov.w	r1, #0
 800674a:	0159      	lsls	r1, r3, #5
 800674c:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8006750:	0150      	lsls	r0, r2, #5
 8006752:	4602      	mov	r2, r0
 8006754:	460b      	mov	r3, r1
 8006756:	4621      	mov	r1, r4
 8006758:	1a51      	subs	r1, r2, r1
 800675a:	6139      	str	r1, [r7, #16]
 800675c:	4629      	mov	r1, r5
 800675e:	eb63 0301 	sbc.w	r3, r3, r1
 8006762:	617b      	str	r3, [r7, #20]
 8006764:	f04f 0200 	mov.w	r2, #0
 8006768:	f04f 0300 	mov.w	r3, #0
 800676c:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8006770:	4659      	mov	r1, fp
 8006772:	018b      	lsls	r3, r1, #6
 8006774:	4651      	mov	r1, sl
 8006776:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 800677a:	4651      	mov	r1, sl
 800677c:	018a      	lsls	r2, r1, #6
 800677e:	4651      	mov	r1, sl
 8006780:	ebb2 0801 	subs.w	r8, r2, r1
 8006784:	4659      	mov	r1, fp
 8006786:	eb63 0901 	sbc.w	r9, r3, r1
 800678a:	f04f 0200 	mov.w	r2, #0
 800678e:	f04f 0300 	mov.w	r3, #0
 8006792:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8006796:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 800679a:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 800679e:	4690      	mov	r8, r2
 80067a0:	4699      	mov	r9, r3
 80067a2:	4623      	mov	r3, r4
 80067a4:	eb18 0303 	adds.w	r3, r8, r3
 80067a8:	60bb      	str	r3, [r7, #8]
 80067aa:	462b      	mov	r3, r5
 80067ac:	eb49 0303 	adc.w	r3, r9, r3
 80067b0:	60fb      	str	r3, [r7, #12]
 80067b2:	f04f 0200 	mov.w	r2, #0
 80067b6:	f04f 0300 	mov.w	r3, #0
 80067ba:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 80067be:	4629      	mov	r1, r5
 80067c0:	024b      	lsls	r3, r1, #9
 80067c2:	4621      	mov	r1, r4
 80067c4:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 80067c8:	4621      	mov	r1, r4
 80067ca:	024a      	lsls	r2, r1, #9
 80067cc:	4610      	mov	r0, r2
 80067ce:	4619      	mov	r1, r3
 80067d0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80067d2:	2200      	movs	r2, #0
 80067d4:	62bb      	str	r3, [r7, #40]	@ 0x28
 80067d6:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80067d8:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80067dc:	f7fa f966 	bl	8000aac <__aeabi_uldivmod>
 80067e0:	4602      	mov	r2, r0
 80067e2:	460b      	mov	r3, r1
 80067e4:	4613      	mov	r3, r2
 80067e6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80067e8:	e058      	b.n	800689c <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80067ea:	4b38      	ldr	r3, [pc, #224]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 80067ec:	685b      	ldr	r3, [r3, #4]
 80067ee:	099b      	lsrs	r3, r3, #6
 80067f0:	2200      	movs	r2, #0
 80067f2:	4618      	mov	r0, r3
 80067f4:	4611      	mov	r1, r2
 80067f6:	f3c0 0308 	ubfx	r3, r0, #0, #9
 80067fa:	623b      	str	r3, [r7, #32]
 80067fc:	2300      	movs	r3, #0
 80067fe:	627b      	str	r3, [r7, #36]	@ 0x24
 8006800:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8006804:	4642      	mov	r2, r8
 8006806:	464b      	mov	r3, r9
 8006808:	f04f 0000 	mov.w	r0, #0
 800680c:	f04f 0100 	mov.w	r1, #0
 8006810:	0159      	lsls	r1, r3, #5
 8006812:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8006816:	0150      	lsls	r0, r2, #5
 8006818:	4602      	mov	r2, r0
 800681a:	460b      	mov	r3, r1
 800681c:	4641      	mov	r1, r8
 800681e:	ebb2 0a01 	subs.w	sl, r2, r1
 8006822:	4649      	mov	r1, r9
 8006824:	eb63 0b01 	sbc.w	fp, r3, r1
 8006828:	f04f 0200 	mov.w	r2, #0
 800682c:	f04f 0300 	mov.w	r3, #0
 8006830:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8006834:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 8006838:	ea4f 128a 	mov.w	r2, sl, lsl #6
 800683c:	ebb2 040a 	subs.w	r4, r2, sl
 8006840:	eb63 050b 	sbc.w	r5, r3, fp
 8006844:	f04f 0200 	mov.w	r2, #0
 8006848:	f04f 0300 	mov.w	r3, #0
 800684c:	00eb      	lsls	r3, r5, #3
 800684e:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8006852:	00e2      	lsls	r2, r4, #3
 8006854:	4614      	mov	r4, r2
 8006856:	461d      	mov	r5, r3
 8006858:	4643      	mov	r3, r8
 800685a:	18e3      	adds	r3, r4, r3
 800685c:	603b      	str	r3, [r7, #0]
 800685e:	464b      	mov	r3, r9
 8006860:	eb45 0303 	adc.w	r3, r5, r3
 8006864:	607b      	str	r3, [r7, #4]
 8006866:	f04f 0200 	mov.w	r2, #0
 800686a:	f04f 0300 	mov.w	r3, #0
 800686e:	e9d7 4500 	ldrd	r4, r5, [r7]
 8006872:	4629      	mov	r1, r5
 8006874:	028b      	lsls	r3, r1, #10
 8006876:	4621      	mov	r1, r4
 8006878:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 800687c:	4621      	mov	r1, r4
 800687e:	028a      	lsls	r2, r1, #10
 8006880:	4610      	mov	r0, r2
 8006882:	4619      	mov	r1, r3
 8006884:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8006886:	2200      	movs	r2, #0
 8006888:	61bb      	str	r3, [r7, #24]
 800688a:	61fa      	str	r2, [r7, #28]
 800688c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8006890:	f7fa f90c 	bl	8000aac <__aeabi_uldivmod>
 8006894:	4602      	mov	r2, r0
 8006896:	460b      	mov	r3, r1
 8006898:	4613      	mov	r3, r2
 800689a:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR.reg & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800689c:	4b0b      	ldr	r3, [pc, #44]	@ (80068cc <HAL_RCC_GetSysClockFreq+0x200>)
 800689e:	685b      	ldr	r3, [r3, #4]
 80068a0:	0c1b      	lsrs	r3, r3, #16
 80068a2:	f003 0303 	and.w	r3, r3, #3
 80068a6:	3301      	adds	r3, #1
 80068a8:	005b      	lsls	r3, r3, #1
 80068aa:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco/pllp;
 80068ac:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80068ae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80068b0:	fbb2 f3f3 	udiv	r3, r2, r3
 80068b4:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 80068b6:	e002      	b.n	80068be <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 80068b8:	4b05      	ldr	r3, [pc, #20]	@ (80068d0 <HAL_RCC_GetSysClockFreq+0x204>)
 80068ba:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 80068bc:	bf00      	nop
    }
  }
  return sysclockfreq;
 80068be:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 80068c0:	4618      	mov	r0, r3
 80068c2:	3750      	adds	r7, #80	@ 0x50
 80068c4:	46bd      	mov	sp, r7
 80068c6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80068ca:	bf00      	nop
 80068cc:	40023800 	.word	0x40023800
 80068d0:	00f42400 	.word	0x00f42400
 80068d4:	007a1200 	.word	0x007a1200

080068d8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80068d8:	b480      	push	{r7}
 80068da:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 80068dc:	4b03      	ldr	r3, [pc, #12]	@ (80068ec <HAL_RCC_GetHCLKFreq+0x14>)
 80068de:	681b      	ldr	r3, [r3, #0]
}
 80068e0:	4618      	mov	r0, r3
 80068e2:	46bd      	mov	sp, r7
 80068e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068e8:	4770      	bx	lr
 80068ea:	bf00      	nop
 80068ec:	20000000 	.word	0x20000000

080068f0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80068f0:	b580      	push	{r7, lr}
 80068f2:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR.reg & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 80068f4:	f7ff fff0 	bl	80068d8 <HAL_RCC_GetHCLKFreq>
 80068f8:	4602      	mov	r2, r0
 80068fa:	4b05      	ldr	r3, [pc, #20]	@ (8006910 <HAL_RCC_GetPCLK1Freq+0x20>)
 80068fc:	689b      	ldr	r3, [r3, #8]
 80068fe:	0a9b      	lsrs	r3, r3, #10
 8006900:	f003 0307 	and.w	r3, r3, #7
 8006904:	4903      	ldr	r1, [pc, #12]	@ (8006914 <HAL_RCC_GetPCLK1Freq+0x24>)
 8006906:	5ccb      	ldrb	r3, [r1, r3]
 8006908:	fa22 f303 	lsr.w	r3, r2, r3
}
 800690c:	4618      	mov	r0, r3
 800690e:	bd80      	pop	{r7, pc}
 8006910:	40023800 	.word	0x40023800
 8006914:	080315d0 	.word	0x080315d0

08006918 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8006918:	b580      	push	{r7, lr}
 800691a:	b086      	sub	sp, #24
 800691c:	af00      	add	r7, sp, #0
 800691e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8006920:	2300      	movs	r3, #0
 8006922:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8006924:	2300      	movs	r3, #0
 8006926:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8006928:	687b      	ldr	r3, [r7, #4]
 800692a:	681b      	ldr	r3, [r3, #0]
 800692c:	f003 0301 	and.w	r3, r3, #1
 8006930:	2b00      	cmp	r3, #0
 8006932:	d105      	bne.n	8006940 <HAL_RCCEx_PeriphCLKConfig+0x28>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8006934:	687b      	ldr	r3, [r7, #4]
 8006936:	681b      	ldr	r3, [r3, #0]
 8006938:	f003 0304 	and.w	r3, r3, #4
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800693c:	2b00      	cmp	r3, #0
 800693e:	d035      	beq.n	80069ac <HAL_RCCEx_PeriphCLKConfig+0x94>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8006940:	4b62      	ldr	r3, [pc, #392]	@ (8006acc <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8006942:	2200      	movs	r2, #0
 8006944:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8006946:	f7fb f863 	bl	8001a10 <HAL_GetTick>
 800694a:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800694c:	e008      	b.n	8006960 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800694e:	f7fb f85f 	bl	8001a10 <HAL_GetTick>
 8006952:	4602      	mov	r2, r0
 8006954:	697b      	ldr	r3, [r7, #20]
 8006956:	1ad3      	subs	r3, r2, r3
 8006958:	2b02      	cmp	r3, #2
 800695a:	d901      	bls.n	8006960 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800695c:	2303      	movs	r3, #3
 800695e:	e0b0      	b.n	8006ac2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8006960:	4b5b      	ldr	r3, [pc, #364]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006962:	681b      	ldr	r3, [r3, #0]
 8006964:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8006968:	2b00      	cmp	r3, #0
 800696a:	d1f0      	bne.n	800694e <HAL_RCCEx_PeriphCLKConfig+0x36>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 800696c:	687b      	ldr	r3, [r7, #4]
 800696e:	685b      	ldr	r3, [r3, #4]
 8006970:	019a      	lsls	r2, r3, #6
 8006972:	687b      	ldr	r3, [r7, #4]
 8006974:	689b      	ldr	r3, [r3, #8]
 8006976:	071b      	lsls	r3, r3, #28
 8006978:	4955      	ldr	r1, [pc, #340]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 800697a:	4313      	orrs	r3, r2
 800697c:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8006980:	4b52      	ldr	r3, [pc, #328]	@ (8006acc <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8006982:	2201      	movs	r2, #1
 8006984:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8006986:	f7fb f843 	bl	8001a10 <HAL_GetTick>
 800698a:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800698c:	e008      	b.n	80069a0 <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800698e:	f7fb f83f 	bl	8001a10 <HAL_GetTick>
 8006992:	4602      	mov	r2, r0
 8006994:	697b      	ldr	r3, [r7, #20]
 8006996:	1ad3      	subs	r3, r2, r3
 8006998:	2b02      	cmp	r3, #2
 800699a:	d901      	bls.n	80069a0 <HAL_RCCEx_PeriphCLKConfig+0x88>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800699c:	2303      	movs	r3, #3
 800699e:	e090      	b.n	8006ac2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80069a0:	4b4b      	ldr	r3, [pc, #300]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 80069a2:	681b      	ldr	r3, [r3, #0]
 80069a4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80069a8:	2b00      	cmp	r3, #0
 80069aa:	d0f0      	beq.n	800698e <HAL_RCCEx_PeriphCLKConfig+0x76>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80069ac:	687b      	ldr	r3, [r7, #4]
 80069ae:	681b      	ldr	r3, [r3, #0]
 80069b0:	f003 0302 	and.w	r3, r3, #2
 80069b4:	2b00      	cmp	r3, #0
 80069b6:	f000 8083 	beq.w	8006ac0 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80069ba:	2300      	movs	r3, #0
 80069bc:	60fb      	str	r3, [r7, #12]
 80069be:	4b44      	ldr	r3, [pc, #272]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 80069c0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80069c2:	4a43      	ldr	r2, [pc, #268]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 80069c4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80069c8:	6413      	str	r3, [r2, #64]	@ 0x40
 80069ca:	4b41      	ldr	r3, [pc, #260]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 80069cc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80069ce:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80069d2:	60fb      	str	r3, [r7, #12]
 80069d4:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR.reg |= PWR_CR_DBP;
 80069d6:	4b3f      	ldr	r3, [pc, #252]	@ (8006ad4 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 80069d8:	681b      	ldr	r3, [r3, #0]
 80069da:	4a3e      	ldr	r2, [pc, #248]	@ (8006ad4 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 80069dc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80069e0:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 80069e2:	f7fb f815 	bl	8001a10 <HAL_GetTick>
 80069e6:	6178      	str	r0, [r7, #20]

    while((PWR->CR.reg & PWR_CR_DBP) == RESET)
 80069e8:	e008      	b.n	80069fc <HAL_RCCEx_PeriphCLKConfig+0xe4>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80069ea:	f7fb f811 	bl	8001a10 <HAL_GetTick>
 80069ee:	4602      	mov	r2, r0
 80069f0:	697b      	ldr	r3, [r7, #20]
 80069f2:	1ad3      	subs	r3, r2, r3
 80069f4:	2b02      	cmp	r3, #2
 80069f6:	d901      	bls.n	80069fc <HAL_RCCEx_PeriphCLKConfig+0xe4>
      {
        return HAL_TIMEOUT;
 80069f8:	2303      	movs	r3, #3
 80069fa:	e062      	b.n	8006ac2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while((PWR->CR.reg & PWR_CR_DBP) == RESET)
 80069fc:	4b35      	ldr	r3, [pc, #212]	@ (8006ad4 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 80069fe:	681b      	ldr	r3, [r3, #0]
 8006a00:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006a04:	2b00      	cmp	r3, #0
 8006a06:	d0f0      	beq.n	80069ea <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR.reg & RCC_BDCR_RTCSEL);
 8006a08:	4b31      	ldr	r3, [pc, #196]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a0a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006a0c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006a10:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8006a12:	693b      	ldr	r3, [r7, #16]
 8006a14:	2b00      	cmp	r3, #0
 8006a16:	d02f      	beq.n	8006a78 <HAL_RCCEx_PeriphCLKConfig+0x160>
 8006a18:	687b      	ldr	r3, [r7, #4]
 8006a1a:	68db      	ldr	r3, [r3, #12]
 8006a1c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006a20:	693a      	ldr	r2, [r7, #16]
 8006a22:	429a      	cmp	r2, r3
 8006a24:	d028      	beq.n	8006a78 <HAL_RCCEx_PeriphCLKConfig+0x160>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR.reg & ~(RCC_BDCR_RTCSEL));
 8006a26:	4b2a      	ldr	r3, [pc, #168]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a28:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006a2a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8006a2e:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8006a30:	4b29      	ldr	r3, [pc, #164]	@ (8006ad8 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8006a32:	2201      	movs	r2, #1
 8006a34:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8006a36:	4b28      	ldr	r3, [pc, #160]	@ (8006ad8 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8006a38:	2200      	movs	r2, #0
 8006a3a:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR.reg = tmpreg1;
 8006a3c:	4a24      	ldr	r2, [pc, #144]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a3e:	693b      	ldr	r3, [r7, #16]
 8006a40:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR.reg, RCC_BDCR_LSEON))
 8006a42:	4b23      	ldr	r3, [pc, #140]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a44:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006a46:	f003 0301 	and.w	r3, r3, #1
 8006a4a:	2b00      	cmp	r3, #0
 8006a4c:	d014      	beq.n	8006a78 <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8006a4e:	f7fa ffdf 	bl	8001a10 <HAL_GetTick>
 8006a52:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006a54:	e00a      	b.n	8006a6c <HAL_RCCEx_PeriphCLKConfig+0x154>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8006a56:	f7fa ffdb 	bl	8001a10 <HAL_GetTick>
 8006a5a:	4602      	mov	r2, r0
 8006a5c:	697b      	ldr	r3, [r7, #20]
 8006a5e:	1ad3      	subs	r3, r2, r3
 8006a60:	f241 3288 	movw	r2, #5000	@ 0x1388
 8006a64:	4293      	cmp	r3, r2
 8006a66:	d901      	bls.n	8006a6c <HAL_RCCEx_PeriphCLKConfig+0x154>
          {
            return HAL_TIMEOUT;
 8006a68:	2303      	movs	r3, #3
 8006a6a:	e02a      	b.n	8006ac2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8006a6c:	4b18      	ldr	r3, [pc, #96]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a6e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006a70:	f003 0302 	and.w	r3, r3, #2
 8006a74:	2b00      	cmp	r3, #0
 8006a76:	d0ee      	beq.n	8006a56 <HAL_RCCEx_PeriphCLKConfig+0x13e>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8006a78:	687b      	ldr	r3, [r7, #4]
 8006a7a:	68db      	ldr	r3, [r3, #12]
 8006a7c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8006a80:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8006a84:	d10d      	bne.n	8006aa2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
 8006a86:	4b12      	ldr	r3, [pc, #72]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a88:	689b      	ldr	r3, [r3, #8]
 8006a8a:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8006a8e:	687b      	ldr	r3, [r7, #4]
 8006a90:	68db      	ldr	r3, [r3, #12]
 8006a92:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8006a96:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8006a9a:	490d      	ldr	r1, [pc, #52]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006a9c:	4313      	orrs	r3, r2
 8006a9e:	608b      	str	r3, [r1, #8]
 8006aa0:	e005      	b.n	8006aae <HAL_RCCEx_PeriphCLKConfig+0x196>
 8006aa2:	4b0b      	ldr	r3, [pc, #44]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006aa4:	689b      	ldr	r3, [r3, #8]
 8006aa6:	4a0a      	ldr	r2, [pc, #40]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006aa8:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8006aac:	6093      	str	r3, [r2, #8]
 8006aae:	4b08      	ldr	r3, [pc, #32]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006ab0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8006ab2:	687b      	ldr	r3, [r7, #4]
 8006ab4:	68db      	ldr	r3, [r3, #12]
 8006ab6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8006aba:	4905      	ldr	r1, [pc, #20]	@ (8006ad0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8006abc:	4313      	orrs	r3, r2
 8006abe:	670b      	str	r3, [r1, #112]	@ 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8006ac0:	2300      	movs	r3, #0
}
 8006ac2:	4618      	mov	r0, r3
 8006ac4:	3718      	adds	r7, #24
 8006ac6:	46bd      	mov	sp, r7
 8006ac8:	bd80      	pop	{r7, pc}
 8006aca:	bf00      	nop
 8006acc:	42470068 	.word	0x42470068
 8006ad0:	40023800 	.word	0x40023800
 8006ad4:	40007000 	.word	0x40007000
 8006ad8:	42470e40 	.word	0x42470e40

08006adc <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8006adc:	b084      	sub	sp, #16
 8006ade:	b580      	push	{r7, lr}
 8006ae0:	b084      	sub	sp, #16
 8006ae2:	af00      	add	r7, sp, #0
 8006ae4:	6078      	str	r0, [r7, #4]
 8006ae6:	f107 001c 	add.w	r0, r7, #28
 8006aea:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8006aee:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 8006af2:	2b01      	cmp	r3, #1
 8006af4:	d123      	bne.n	8006b3e <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8006af6:	687b      	ldr	r3, [r7, #4]
 8006af8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006afa:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8006afe:	687b      	ldr	r3, [r7, #4]
 8006b00:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	68db      	ldr	r3, [r3, #12]
 8006b06:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 8006b0a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8006b0e:	687a      	ldr	r2, [r7, #4]
 8006b10:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8006b12:	687b      	ldr	r3, [r7, #4]
 8006b14:	68db      	ldr	r3, [r3, #12]
 8006b16:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8006b1a:	687b      	ldr	r3, [r7, #4]
 8006b1c:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8006b1e:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8006b22:	2b01      	cmp	r3, #1
 8006b24:	d105      	bne.n	8006b32 <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8006b26:	687b      	ldr	r3, [r7, #4]
 8006b28:	68db      	ldr	r3, [r3, #12]
 8006b2a:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 8006b2e:	687b      	ldr	r3, [r7, #4]
 8006b30:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8006b32:	6878      	ldr	r0, [r7, #4]
 8006b34:	f000 f9dc 	bl	8006ef0 <USB_CoreReset>
 8006b38:	4603      	mov	r3, r0
 8006b3a:	73fb      	strb	r3, [r7, #15]
 8006b3c:	e01b      	b.n	8006b76 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8006b3e:	687b      	ldr	r3, [r7, #4]
 8006b40:	68db      	ldr	r3, [r3, #12]
 8006b42:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8006b46:	687b      	ldr	r3, [r7, #4]
 8006b48:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8006b4a:	6878      	ldr	r0, [r7, #4]
 8006b4c:	f000 f9d0 	bl	8006ef0 <USB_CoreReset>
 8006b50:	4603      	mov	r3, r0
 8006b52:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8006b54:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8006b58:	2b00      	cmp	r3, #0
 8006b5a:	d106      	bne.n	8006b6a <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8006b5c:	687b      	ldr	r3, [r7, #4]
 8006b5e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006b60:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8006b64:	687b      	ldr	r3, [r7, #4]
 8006b66:	639a      	str	r2, [r3, #56]	@ 0x38
 8006b68:	e005      	b.n	8006b76 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8006b6a:	687b      	ldr	r3, [r7, #4]
 8006b6c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006b6e:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8006b72:	687b      	ldr	r3, [r7, #4]
 8006b74:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8006b76:	7fbb      	ldrb	r3, [r7, #30]
 8006b78:	2b01      	cmp	r3, #1
 8006b7a:	d10b      	bne.n	8006b94 <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8006b7c:	687b      	ldr	r3, [r7, #4]
 8006b7e:	689b      	ldr	r3, [r3, #8]
 8006b80:	f043 0206 	orr.w	r2, r3, #6
 8006b84:	687b      	ldr	r3, [r7, #4]
 8006b86:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	689b      	ldr	r3, [r3, #8]
 8006b8c:	f043 0220 	orr.w	r2, r3, #32
 8006b90:	687b      	ldr	r3, [r7, #4]
 8006b92:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8006b94:	7bfb      	ldrb	r3, [r7, #15]
}
 8006b96:	4618      	mov	r0, r3
 8006b98:	3710      	adds	r7, #16
 8006b9a:	46bd      	mov	sp, r7
 8006b9c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8006ba0:	b004      	add	sp, #16
 8006ba2:	4770      	bx	lr

08006ba4 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8006ba4:	b480      	push	{r7}
 8006ba6:	b083      	sub	sp, #12
 8006ba8:	af00      	add	r7, sp, #0
 8006baa:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8006bac:	687b      	ldr	r3, [r7, #4]
 8006bae:	689b      	ldr	r3, [r3, #8]
 8006bb0:	f043 0201 	orr.w	r2, r3, #1
 8006bb4:	687b      	ldr	r3, [r7, #4]
 8006bb6:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8006bb8:	2300      	movs	r3, #0
}
 8006bba:	4618      	mov	r0, r3
 8006bbc:	370c      	adds	r7, #12
 8006bbe:	46bd      	mov	sp, r7
 8006bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bc4:	4770      	bx	lr

08006bc6 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8006bc6:	b480      	push	{r7}
 8006bc8:	b083      	sub	sp, #12
 8006bca:	af00      	add	r7, sp, #0
 8006bcc:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8006bce:	687b      	ldr	r3, [r7, #4]
 8006bd0:	689b      	ldr	r3, [r3, #8]
 8006bd2:	f023 0201 	bic.w	r2, r3, #1
 8006bd6:	687b      	ldr	r3, [r7, #4]
 8006bd8:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8006bda:	2300      	movs	r3, #0
}
 8006bdc:	4618      	mov	r0, r3
 8006bde:	370c      	adds	r7, #12
 8006be0:	46bd      	mov	sp, r7
 8006be2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006be6:	4770      	bx	lr

08006be8 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8006be8:	b580      	push	{r7, lr}
 8006bea:	b084      	sub	sp, #16
 8006bec:	af00      	add	r7, sp, #0
 8006bee:	6078      	str	r0, [r7, #4]
 8006bf0:	460b      	mov	r3, r1
 8006bf2:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8006bf4:	2300      	movs	r3, #0
 8006bf6:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8006bf8:	687b      	ldr	r3, [r7, #4]
 8006bfa:	68db      	ldr	r3, [r3, #12]
 8006bfc:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 8006c00:	687b      	ldr	r3, [r7, #4]
 8006c02:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8006c04:	78fb      	ldrb	r3, [r7, #3]
 8006c06:	2b01      	cmp	r3, #1
 8006c08:	d115      	bne.n	8006c36 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8006c0a:	687b      	ldr	r3, [r7, #4]
 8006c0c:	68db      	ldr	r3, [r3, #12]
 8006c0e:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 8006c12:	687b      	ldr	r3, [r7, #4]
 8006c14:	60da      	str	r2, [r3, #12]

    do
    {
      delay_ms(10U);
 8006c16:	200a      	movs	r0, #10
 8006c18:	f003 fc2e 	bl	800a478 <delay_ms>
      ms += 10U;
 8006c1c:	68fb      	ldr	r3, [r7, #12]
 8006c1e:	330a      	adds	r3, #10
 8006c20:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8006c22:	6878      	ldr	r0, [r7, #4]
 8006c24:	f000 f956 	bl	8006ed4 <USB_GetMode>
 8006c28:	4603      	mov	r3, r0
 8006c2a:	2b01      	cmp	r3, #1
 8006c2c:	d01e      	beq.n	8006c6c <USB_SetCurrentMode+0x84>
 8006c2e:	68fb      	ldr	r3, [r7, #12]
 8006c30:	2bc7      	cmp	r3, #199	@ 0xc7
 8006c32:	d9f0      	bls.n	8006c16 <USB_SetCurrentMode+0x2e>
 8006c34:	e01a      	b.n	8006c6c <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8006c36:	78fb      	ldrb	r3, [r7, #3]
 8006c38:	2b00      	cmp	r3, #0
 8006c3a:	d115      	bne.n	8006c68 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	68db      	ldr	r3, [r3, #12]
 8006c40:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8006c44:	687b      	ldr	r3, [r7, #4]
 8006c46:	60da      	str	r2, [r3, #12]

    do
    {
    	delay_ms(10U);
 8006c48:	200a      	movs	r0, #10
 8006c4a:	f003 fc15 	bl	800a478 <delay_ms>
      ms += 10U;
 8006c4e:	68fb      	ldr	r3, [r7, #12]
 8006c50:	330a      	adds	r3, #10
 8006c52:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8006c54:	6878      	ldr	r0, [r7, #4]
 8006c56:	f000 f93d 	bl	8006ed4 <USB_GetMode>
 8006c5a:	4603      	mov	r3, r0
 8006c5c:	2b00      	cmp	r3, #0
 8006c5e:	d005      	beq.n	8006c6c <USB_SetCurrentMode+0x84>
 8006c60:	68fb      	ldr	r3, [r7, #12]
 8006c62:	2bc7      	cmp	r3, #199	@ 0xc7
 8006c64:	d9f0      	bls.n	8006c48 <USB_SetCurrentMode+0x60>
 8006c66:	e001      	b.n	8006c6c <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8006c68:	2301      	movs	r3, #1
 8006c6a:	e005      	b.n	8006c78 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 8006c6c:	68fb      	ldr	r3, [r7, #12]
 8006c6e:	2bc8      	cmp	r3, #200	@ 0xc8
 8006c70:	d101      	bne.n	8006c76 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8006c72:	2301      	movs	r3, #1
 8006c74:	e000      	b.n	8006c78 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8006c76:	2300      	movs	r3, #0
}
 8006c78:	4618      	mov	r0, r3
 8006c7a:	3710      	adds	r7, #16
 8006c7c:	46bd      	mov	sp, r7
 8006c7e:	bd80      	pop	{r7, pc}

08006c80 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8006c80:	b480      	push	{r7}
 8006c82:	b085      	sub	sp, #20
 8006c84:	af00      	add	r7, sp, #0
 8006c86:	6078      	str	r0, [r7, #4]
 8006c88:	6039      	str	r1, [r7, #0]
  volatile uint32_t count = 0U;
 8006c8a:	2300      	movs	r3, #0
 8006c8c:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006c8e:	68fb      	ldr	r3, [r7, #12]
 8006c90:	3301      	adds	r3, #1
 8006c92:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006c94:	68fb      	ldr	r3, [r7, #12]
 8006c96:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006c9a:	d901      	bls.n	8006ca0 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8006c9c:	2303      	movs	r3, #3
 8006c9e:	e01b      	b.n	8006cd8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	691b      	ldr	r3, [r3, #16]
 8006ca4:	2b00      	cmp	r3, #0
 8006ca6:	daf2      	bge.n	8006c8e <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8006ca8:	2300      	movs	r3, #0
 8006caa:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8006cac:	683b      	ldr	r3, [r7, #0]
 8006cae:	019b      	lsls	r3, r3, #6
 8006cb0:	f043 0220 	orr.w	r2, r3, #32
 8006cb4:	687b      	ldr	r3, [r7, #4]
 8006cb6:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006cb8:	68fb      	ldr	r3, [r7, #12]
 8006cba:	3301      	adds	r3, #1
 8006cbc:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006cbe:	68fb      	ldr	r3, [r7, #12]
 8006cc0:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006cc4:	d901      	bls.n	8006cca <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 8006cc6:	2303      	movs	r3, #3
 8006cc8:	e006      	b.n	8006cd8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8006cca:	687b      	ldr	r3, [r7, #4]
 8006ccc:	691b      	ldr	r3, [r3, #16]
 8006cce:	f003 0320 	and.w	r3, r3, #32
 8006cd2:	2b20      	cmp	r3, #32
 8006cd4:	d0f0      	beq.n	8006cb8 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 8006cd6:	2300      	movs	r3, #0
}
 8006cd8:	4618      	mov	r0, r3
 8006cda:	3714      	adds	r7, #20
 8006cdc:	46bd      	mov	sp, r7
 8006cde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ce2:	4770      	bx	lr

08006ce4 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8006ce4:	b480      	push	{r7}
 8006ce6:	b085      	sub	sp, #20
 8006ce8:	af00      	add	r7, sp, #0
 8006cea:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = 0U;
 8006cec:	2300      	movs	r3, #0
 8006cee:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006cf0:	68fb      	ldr	r3, [r7, #12]
 8006cf2:	3301      	adds	r3, #1
 8006cf4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006cf6:	68fb      	ldr	r3, [r7, #12]
 8006cf8:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006cfc:	d901      	bls.n	8006d02 <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 8006cfe:	2303      	movs	r3, #3
 8006d00:	e018      	b.n	8006d34 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006d02:	687b      	ldr	r3, [r7, #4]
 8006d04:	691b      	ldr	r3, [r3, #16]
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	daf2      	bge.n	8006cf0 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8006d0a:	2300      	movs	r3, #0
 8006d0c:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8006d0e:	687b      	ldr	r3, [r7, #4]
 8006d10:	2210      	movs	r2, #16
 8006d12:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006d14:	68fb      	ldr	r3, [r7, #12]
 8006d16:	3301      	adds	r3, #1
 8006d18:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006d1a:	68fb      	ldr	r3, [r7, #12]
 8006d1c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006d20:	d901      	bls.n	8006d26 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 8006d22:	2303      	movs	r3, #3
 8006d24:	e006      	b.n	8006d34 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8006d26:	687b      	ldr	r3, [r7, #4]
 8006d28:	691b      	ldr	r3, [r3, #16]
 8006d2a:	f003 0310 	and.w	r3, r3, #16
 8006d2e:	2b10      	cmp	r3, #16
 8006d30:	d0f0      	beq.n	8006d14 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 8006d32:	2300      	movs	r3, #0
}
 8006d34:	4618      	mov	r0, r3
 8006d36:	3714      	adds	r7, #20
 8006d38:	46bd      	mov	sp, r7
 8006d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d3e:	4770      	bx	lr

08006d40 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8006d40:	b480      	push	{r7}
 8006d42:	b089      	sub	sp, #36	@ 0x24
 8006d44:	af00      	add	r7, sp, #0
 8006d46:	60f8      	str	r0, [r7, #12]
 8006d48:	60b9      	str	r1, [r7, #8]
 8006d4a:	4611      	mov	r1, r2
 8006d4c:	461a      	mov	r2, r3
 8006d4e:	460b      	mov	r3, r1
 8006d50:	71fb      	strb	r3, [r7, #7]
 8006d52:	4613      	mov	r3, r2
 8006d54:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006d56:	68fb      	ldr	r3, [r7, #12]
 8006d58:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 8006d5a:	68bb      	ldr	r3, [r7, #8]
 8006d5c:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8006d5e:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8006d62:	2b00      	cmp	r3, #0
 8006d64:	d123      	bne.n	8006dae <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8006d66:	88bb      	ldrh	r3, [r7, #4]
 8006d68:	3303      	adds	r3, #3
 8006d6a:	089b      	lsrs	r3, r3, #2
 8006d6c:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8006d6e:	2300      	movs	r3, #0
 8006d70:	61bb      	str	r3, [r7, #24]
 8006d72:	e018      	b.n	8006da6 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8006d74:	79fb      	ldrb	r3, [r7, #7]
 8006d76:	031a      	lsls	r2, r3, #12
 8006d78:	697b      	ldr	r3, [r7, #20]
 8006d7a:	4413      	add	r3, r2
 8006d7c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006d80:	461a      	mov	r2, r3
 8006d82:	69fb      	ldr	r3, [r7, #28]
 8006d84:	681b      	ldr	r3, [r3, #0]
 8006d86:	6013      	str	r3, [r2, #0]
      pSrc++;
 8006d88:	69fb      	ldr	r3, [r7, #28]
 8006d8a:	3301      	adds	r3, #1
 8006d8c:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006d8e:	69fb      	ldr	r3, [r7, #28]
 8006d90:	3301      	adds	r3, #1
 8006d92:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006d94:	69fb      	ldr	r3, [r7, #28]
 8006d96:	3301      	adds	r3, #1
 8006d98:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006d9a:	69fb      	ldr	r3, [r7, #28]
 8006d9c:	3301      	adds	r3, #1
 8006d9e:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8006da0:	69bb      	ldr	r3, [r7, #24]
 8006da2:	3301      	adds	r3, #1
 8006da4:	61bb      	str	r3, [r7, #24]
 8006da6:	69ba      	ldr	r2, [r7, #24]
 8006da8:	693b      	ldr	r3, [r7, #16]
 8006daa:	429a      	cmp	r2, r3
 8006dac:	d3e2      	bcc.n	8006d74 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 8006dae:	2300      	movs	r3, #0
}
 8006db0:	4618      	mov	r0, r3
 8006db2:	3724      	adds	r7, #36	@ 0x24
 8006db4:	46bd      	mov	sp, r7
 8006db6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dba:	4770      	bx	lr

08006dbc <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8006dbc:	b480      	push	{r7}
 8006dbe:	b08b      	sub	sp, #44	@ 0x2c
 8006dc0:	af00      	add	r7, sp, #0
 8006dc2:	60f8      	str	r0, [r7, #12]
 8006dc4:	60b9      	str	r1, [r7, #8]
 8006dc6:	4613      	mov	r3, r2
 8006dc8:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006dca:	68fb      	ldr	r3, [r7, #12]
 8006dcc:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 8006dce:	68bb      	ldr	r3, [r7, #8]
 8006dd0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 8006dd2:	88fb      	ldrh	r3, [r7, #6]
 8006dd4:	089b      	lsrs	r3, r3, #2
 8006dd6:	b29b      	uxth	r3, r3
 8006dd8:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 8006dda:	88fb      	ldrh	r3, [r7, #6]
 8006ddc:	f003 0303 	and.w	r3, r3, #3
 8006de0:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 8006de2:	2300      	movs	r3, #0
 8006de4:	623b      	str	r3, [r7, #32]
 8006de6:	e014      	b.n	8006e12 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8006de8:	69bb      	ldr	r3, [r7, #24]
 8006dea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006dee:	681a      	ldr	r2, [r3, #0]
 8006df0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006df2:	601a      	str	r2, [r3, #0]
    pDest++;
 8006df4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006df6:	3301      	adds	r3, #1
 8006df8:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006dfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006dfc:	3301      	adds	r3, #1
 8006dfe:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006e00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006e02:	3301      	adds	r3, #1
 8006e04:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006e06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006e08:	3301      	adds	r3, #1
 8006e0a:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 8006e0c:	6a3b      	ldr	r3, [r7, #32]
 8006e0e:	3301      	adds	r3, #1
 8006e10:	623b      	str	r3, [r7, #32]
 8006e12:	6a3a      	ldr	r2, [r7, #32]
 8006e14:	697b      	ldr	r3, [r7, #20]
 8006e16:	429a      	cmp	r2, r3
 8006e18:	d3e6      	bcc.n	8006de8 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8006e1a:	8bfb      	ldrh	r3, [r7, #30]
 8006e1c:	2b00      	cmp	r3, #0
 8006e1e:	d01e      	beq.n	8006e5e <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8006e20:	2300      	movs	r3, #0
 8006e22:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8006e24:	69bb      	ldr	r3, [r7, #24]
 8006e26:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006e2a:	461a      	mov	r2, r3
 8006e2c:	f107 0310 	add.w	r3, r7, #16
 8006e30:	6812      	ldr	r2, [r2, #0]
 8006e32:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8006e34:	693a      	ldr	r2, [r7, #16]
 8006e36:	6a3b      	ldr	r3, [r7, #32]
 8006e38:	b2db      	uxtb	r3, r3
 8006e3a:	00db      	lsls	r3, r3, #3
 8006e3c:	fa22 f303 	lsr.w	r3, r2, r3
 8006e40:	b2da      	uxtb	r2, r3
 8006e42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006e44:	701a      	strb	r2, [r3, #0]
      i++;
 8006e46:	6a3b      	ldr	r3, [r7, #32]
 8006e48:	3301      	adds	r3, #1
 8006e4a:	623b      	str	r3, [r7, #32]
      pDest++;
 8006e4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006e4e:	3301      	adds	r3, #1
 8006e50:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 8006e52:	8bfb      	ldrh	r3, [r7, #30]
 8006e54:	3b01      	subs	r3, #1
 8006e56:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8006e58:	8bfb      	ldrh	r3, [r7, #30]
 8006e5a:	2b00      	cmp	r3, #0
 8006e5c:	d1ea      	bne.n	8006e34 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 8006e5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8006e60:	4618      	mov	r0, r3
 8006e62:	372c      	adds	r7, #44	@ 0x2c
 8006e64:	46bd      	mov	sp, r7
 8006e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e6a:	4770      	bx	lr

08006e6c <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 8006e6c:	b480      	push	{r7}
 8006e6e:	b085      	sub	sp, #20
 8006e70:	af00      	add	r7, sp, #0
 8006e72:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8006e74:	687b      	ldr	r3, [r7, #4]
 8006e76:	695b      	ldr	r3, [r3, #20]
 8006e78:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8006e7a:	687b      	ldr	r3, [r7, #4]
 8006e7c:	699b      	ldr	r3, [r3, #24]
 8006e7e:	68fa      	ldr	r2, [r7, #12]
 8006e80:	4013      	ands	r3, r2
 8006e82:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8006e84:	68fb      	ldr	r3, [r7, #12]
}
 8006e86:	4618      	mov	r0, r3
 8006e88:	3714      	adds	r7, #20
 8006e8a:	46bd      	mov	sp, r7
 8006e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e90:	4770      	bx	lr

08006e92 <USB_ReadChInterrupts>:
  * @param  USBx  Selected device
  * @param  chnum Channel number
  * @retval USB Channel Interrupt status
  */
uint32_t USB_ReadChInterrupts(const USB_OTG_GlobalTypeDef *USBx, uint8_t chnum)
{
 8006e92:	b480      	push	{r7}
 8006e94:	b085      	sub	sp, #20
 8006e96:	af00      	add	r7, sp, #0
 8006e98:	6078      	str	r0, [r7, #4]
 8006e9a:	460b      	mov	r3, r1
 8006e9c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006e9e:	687b      	ldr	r3, [r7, #4]
 8006ea0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg = USBx_HC(chnum)->HCINT;
 8006ea2:	78fb      	ldrb	r3, [r7, #3]
 8006ea4:	015a      	lsls	r2, r3, #5
 8006ea6:	68fb      	ldr	r3, [r7, #12]
 8006ea8:	4413      	add	r3, r2
 8006eaa:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8006eae:	689b      	ldr	r3, [r3, #8]
 8006eb0:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_HC(chnum)->HCINTMSK;
 8006eb2:	78fb      	ldrb	r3, [r7, #3]
 8006eb4:	015a      	lsls	r2, r3, #5
 8006eb6:	68fb      	ldr	r3, [r7, #12]
 8006eb8:	4413      	add	r3, r2
 8006eba:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8006ebe:	68db      	ldr	r3, [r3, #12]
 8006ec0:	68ba      	ldr	r2, [r7, #8]
 8006ec2:	4013      	ands	r3, r2
 8006ec4:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8006ec6:	68bb      	ldr	r3, [r7, #8]
}
 8006ec8:	4618      	mov	r0, r3
 8006eca:	3714      	adds	r7, #20
 8006ecc:	46bd      	mov	sp, r7
 8006ece:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ed2:	4770      	bx	lr

08006ed4 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 8006ed4:	b480      	push	{r7}
 8006ed6:	b083      	sub	sp, #12
 8006ed8:	af00      	add	r7, sp, #0
 8006eda:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8006edc:	687b      	ldr	r3, [r7, #4]
 8006ede:	695b      	ldr	r3, [r3, #20]
 8006ee0:	f003 0301 	and.w	r3, r3, #1
}
 8006ee4:	4618      	mov	r0, r3
 8006ee6:	370c      	adds	r7, #12
 8006ee8:	46bd      	mov	sp, r7
 8006eea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006eee:	4770      	bx	lr

08006ef0 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8006ef0:	b480      	push	{r7}
 8006ef2:	b085      	sub	sp, #20
 8006ef4:	af00      	add	r7, sp, #0
 8006ef6:	6078      	str	r0, [r7, #4]
  volatile uint32_t count = 0U;
 8006ef8:	2300      	movs	r3, #0
 8006efa:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006efc:	68fb      	ldr	r3, [r7, #12]
 8006efe:	3301      	adds	r3, #1
 8006f00:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006f02:	68fb      	ldr	r3, [r7, #12]
 8006f04:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006f08:	d901      	bls.n	8006f0e <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8006f0a:	2303      	movs	r3, #3
 8006f0c:	e01b      	b.n	8006f46 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006f0e:	687b      	ldr	r3, [r7, #4]
 8006f10:	691b      	ldr	r3, [r3, #16]
 8006f12:	2b00      	cmp	r3, #0
 8006f14:	daf2      	bge.n	8006efc <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 8006f16:	2300      	movs	r3, #0
 8006f18:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8006f1a:	687b      	ldr	r3, [r7, #4]
 8006f1c:	691b      	ldr	r3, [r3, #16]
 8006f1e:	f043 0201 	orr.w	r2, r3, #1
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006f26:	68fb      	ldr	r3, [r7, #12]
 8006f28:	3301      	adds	r3, #1
 8006f2a:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006f2c:	68fb      	ldr	r3, [r7, #12]
 8006f2e:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006f32:	d901      	bls.n	8006f38 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8006f34:	2303      	movs	r3, #3
 8006f36:	e006      	b.n	8006f46 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8006f38:	687b      	ldr	r3, [r7, #4]
 8006f3a:	691b      	ldr	r3, [r3, #16]
 8006f3c:	f003 0301 	and.w	r3, r3, #1
 8006f40:	2b01      	cmp	r3, #1
 8006f42:	d0f0      	beq.n	8006f26 <USB_CoreReset+0x36>

  return HAL_OK;
 8006f44:	2300      	movs	r3, #0
}
 8006f46:	4618      	mov	r0, r3
 8006f48:	3714      	adds	r7, #20
 8006f4a:	46bd      	mov	sp, r7
 8006f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f50:	4770      	bx	lr
	...

08006f54 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8006f54:	b084      	sub	sp, #16
 8006f56:	b580      	push	{r7, lr}
 8006f58:	b086      	sub	sp, #24
 8006f5a:	af00      	add	r7, sp, #0
 8006f5c:	6078      	str	r0, [r7, #4]
 8006f5e:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 8006f62:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8006f66:	2300      	movs	r3, #0
 8006f68:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006f6a:	687b      	ldr	r3, [r7, #4]
 8006f6c:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8006f6e:	68fb      	ldr	r3, [r7, #12]
 8006f70:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8006f74:	461a      	mov	r2, r3
 8006f76:	2300      	movs	r3, #0
 8006f78:	6013      	str	r3, [r2, #0]
#else
  /*
  * Disable HW VBUS sensing. VBUS is internally considered to be always
  * at VBUS-Valid level (5V).
  */
  USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8006f7a:	687b      	ldr	r3, [r7, #4]
 8006f7c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006f7e:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 8006f82:	687b      	ldr	r3, [r7, #4]
 8006f84:	639a      	str	r2, [r3, #56]	@ 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8006f86:	687b      	ldr	r3, [r7, #4]
 8006f88:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006f8a:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 8006f8e:	687b      	ldr	r3, [r7, #4]
 8006f90:	639a      	str	r2, [r3, #56]	@ 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 8006f92:	687b      	ldr	r3, [r7, #4]
 8006f94:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006f96:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 8006f9a:	687b      	ldr	r3, [r7, #4]
 8006f9c:	639a      	str	r2, [r3, #56]	@ 0x38
  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
#endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||
          defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */

  if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) == 0U)
 8006f9e:	687b      	ldr	r3, [r7, #4]
 8006fa0:	68db      	ldr	r3, [r3, #12]
 8006fa2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8006fa6:	2b00      	cmp	r3, #0
 8006fa8:	d119      	bne.n	8006fde <USB_HostInit+0x8a>
  {
    if (cfg.speed == USBH_FSLS_SPEED)
 8006faa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8006fae:	2b01      	cmp	r3, #1
 8006fb0:	d10a      	bne.n	8006fc8 <USB_HostInit+0x74>
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 8006fb2:	68fb      	ldr	r3, [r7, #12]
 8006fb4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8006fb8:	681b      	ldr	r3, [r3, #0]
 8006fba:	68fa      	ldr	r2, [r7, #12]
 8006fbc:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006fc0:	f043 0304 	orr.w	r3, r3, #4
 8006fc4:	6013      	str	r3, [r2, #0]
 8006fc6:	e014      	b.n	8006ff2 <USB_HostInit+0x9e>
    }
    else
    {
      /* Set default Max speed support */
      USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8006fc8:	68fb      	ldr	r3, [r7, #12]
 8006fca:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8006fce:	681b      	ldr	r3, [r3, #0]
 8006fd0:	68fa      	ldr	r2, [r7, #12]
 8006fd2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006fd6:	f023 0304 	bic.w	r3, r3, #4
 8006fda:	6013      	str	r3, [r2, #0]
 8006fdc:	e009      	b.n	8006ff2 <USB_HostInit+0x9e>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8006fde:	68fb      	ldr	r3, [r7, #12]
 8006fe0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8006fe4:	681b      	ldr	r3, [r3, #0]
 8006fe6:	68fa      	ldr	r2, [r7, #12]
 8006fe8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006fec:	f023 0304 	bic.w	r3, r3, #4
 8006ff0:	6013      	str	r3, [r2, #0]
  }

  /* Make sure the FIFOs are flushed. */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8006ff2:	2110      	movs	r1, #16
 8006ff4:	6878      	ldr	r0, [r7, #4]
 8006ff6:	f7ff fe43 	bl	8006c80 <USB_FlushTxFifo>
 8006ffa:	4603      	mov	r3, r0
 8006ffc:	2b00      	cmp	r3, #0
 8006ffe:	d001      	beq.n	8007004 <USB_HostInit+0xb0>
  {
    ret = HAL_ERROR;
 8007000:	2301      	movs	r3, #1
 8007002:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8007004:	6878      	ldr	r0, [r7, #4]
 8007006:	f7ff fe6d 	bl	8006ce4 <USB_FlushRxFifo>
 800700a:	4603      	mov	r3, r0
 800700c:	2b00      	cmp	r3, #0
 800700e:	d001      	beq.n	8007014 <USB_HostInit+0xc0>
  {
    ret = HAL_ERROR;
 8007010:	2301      	movs	r3, #1
 8007012:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 8007014:	2300      	movs	r3, #0
 8007016:	613b      	str	r3, [r7, #16]
 8007018:	e015      	b.n	8007046 <USB_HostInit+0xf2>
  {
    USBx_HC(i)->HCINT = CLEAR_INTERRUPT_MASK;
 800701a:	693b      	ldr	r3, [r7, #16]
 800701c:	015a      	lsls	r2, r3, #5
 800701e:	68fb      	ldr	r3, [r7, #12]
 8007020:	4413      	add	r3, r2
 8007022:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007026:	461a      	mov	r2, r3
 8007028:	f04f 33ff 	mov.w	r3, #4294967295
 800702c:	6093      	str	r3, [r2, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 800702e:	693b      	ldr	r3, [r7, #16]
 8007030:	015a      	lsls	r2, r3, #5
 8007032:	68fb      	ldr	r3, [r7, #12]
 8007034:	4413      	add	r3, r2
 8007036:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800703a:	461a      	mov	r2, r3
 800703c:	2300      	movs	r3, #0
 800703e:	60d3      	str	r3, [r2, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 8007040:	693b      	ldr	r3, [r7, #16]
 8007042:	3301      	adds	r3, #1
 8007044:	613b      	str	r3, [r7, #16]
 8007046:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 800704a:	461a      	mov	r2, r3
 800704c:	693b      	ldr	r3, [r7, #16]
 800704e:	4293      	cmp	r3, r2
 8007050:	d3e3      	bcc.n	800701a <USB_HostInit+0xc6>
  }

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8007052:	687b      	ldr	r3, [r7, #4]
 8007054:	2200      	movs	r2, #0
 8007056:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 8007058:	687b      	ldr	r3, [r7, #4]
 800705a:	f04f 32ff 	mov.w	r2, #4294967295
 800705e:	615a      	str	r2, [r3, #20]
#if defined (USB_OTG_HS)
  if (USBx == USB_OTG_HS)
 8007060:	687b      	ldr	r3, [r7, #4]
 8007062:	4a18      	ldr	r2, [pc, #96]	@ (80070c4 <USB_HostInit+0x170>)
 8007064:	4293      	cmp	r3, r2
 8007066:	d10b      	bne.n	8007080 <USB_HostInit+0x12c>
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x200U;
 8007068:	687b      	ldr	r3, [r7, #4]
 800706a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800706e:	625a      	str	r2, [r3, #36]	@ 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 8007070:	687b      	ldr	r3, [r7, #4]
 8007072:	4a15      	ldr	r2, [pc, #84]	@ (80070c8 <USB_HostInit+0x174>)
 8007074:	629a      	str	r2, [r3, #40]	@ 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 8007076:	687b      	ldr	r3, [r7, #4]
 8007078:	4a14      	ldr	r2, [pc, #80]	@ (80070cc <USB_HostInit+0x178>)
 800707a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
 800707e:	e009      	b.n	8007094 <USB_HostInit+0x140>
  }
  else
#endif /* defined (USB_OTG_HS) */
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x80U;
 8007080:	687b      	ldr	r3, [r7, #4]
 8007082:	2280      	movs	r2, #128	@ 0x80
 8007084:	625a      	str	r2, [r3, #36]	@ 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 8007086:	687b      	ldr	r3, [r7, #4]
 8007088:	4a11      	ldr	r2, [pc, #68]	@ (80070d0 <USB_HostInit+0x17c>)
 800708a:	629a      	str	r2, [r3, #40]	@ 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 800708c:	687b      	ldr	r3, [r7, #4]
 800708e:	4a11      	ldr	r2, [pc, #68]	@ (80070d4 <USB_HostInit+0x180>)
 8007090:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  }

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8007094:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8007098:	2b00      	cmp	r3, #0
 800709a:	d105      	bne.n	80070a8 <USB_HostInit+0x154>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 800709c:	687b      	ldr	r3, [r7, #4]
 800709e:	699b      	ldr	r3, [r3, #24]
 80070a0:	f043 0210 	orr.w	r2, r3, #16
 80070a4:	687b      	ldr	r3, [r7, #4]
 80070a6:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 80070a8:	687b      	ldr	r3, [r7, #4]
 80070aa:	699a      	ldr	r2, [r3, #24]
 80070ac:	4b0a      	ldr	r3, [pc, #40]	@ (80070d8 <USB_HostInit+0x184>)
 80070ae:	4313      	orrs	r3, r2
 80070b0:	687a      	ldr	r2, [r7, #4]
 80070b2:	6193      	str	r3, [r2, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return ret;
 80070b4:	7dfb      	ldrb	r3, [r7, #23]
}
 80070b6:	4618      	mov	r0, r3
 80070b8:	3718      	adds	r7, #24
 80070ba:	46bd      	mov	sp, r7
 80070bc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80070c0:	b004      	add	sp, #16
 80070c2:	4770      	bx	lr
 80070c4:	40040000 	.word	0x40040000
 80070c8:	01000200 	.word	0x01000200
 80070cc:	00e00300 	.word	0x00e00300
 80070d0:	00600080 	.word	0x00600080
 80070d4:	004000e0 	.word	0x004000e0
 80070d8:	a3200008 	.word	0xa3200008

080070dc <USB_InitFSLSPClkSel>:
  *           HCFG_48_MHZ : Full Speed 48 MHz Clock
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(const USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
 80070dc:	b480      	push	{r7}
 80070de:	b085      	sub	sp, #20
 80070e0:	af00      	add	r7, sp, #0
 80070e2:	6078      	str	r0, [r7, #4]
 80070e4:	460b      	mov	r3, r1
 80070e6:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80070e8:	687b      	ldr	r3, [r7, #4]
 80070ea:	60fb      	str	r3, [r7, #12]

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 80070ec:	68fb      	ldr	r3, [r7, #12]
 80070ee:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80070f2:	681b      	ldr	r3, [r3, #0]
 80070f4:	68fa      	ldr	r2, [r7, #12]
 80070f6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80070fa:	f023 0303 	bic.w	r3, r3, #3
 80070fe:	6013      	str	r3, [r2, #0]
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 8007100:	68fb      	ldr	r3, [r7, #12]
 8007102:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007106:	681a      	ldr	r2, [r3, #0]
 8007108:	78fb      	ldrb	r3, [r7, #3]
 800710a:	f003 0303 	and.w	r3, r3, #3
 800710e:	68f9      	ldr	r1, [r7, #12]
 8007110:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8007114:	4313      	orrs	r3, r2
 8007116:	600b      	str	r3, [r1, #0]

  if (freq == HCFG_48_MHZ)
 8007118:	78fb      	ldrb	r3, [r7, #3]
 800711a:	2b01      	cmp	r3, #1
 800711c:	d107      	bne.n	800712e <USB_InitFSLSPClkSel+0x52>
  {
    USBx_HOST->HFIR = HFIR_48_MHZ;
 800711e:	68fb      	ldr	r3, [r7, #12]
 8007120:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007124:	461a      	mov	r2, r3
 8007126:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 800712a:	6053      	str	r3, [r2, #4]
 800712c:	e00c      	b.n	8007148 <USB_InitFSLSPClkSel+0x6c>
  }
  else if (freq == HCFG_6_MHZ)
 800712e:	78fb      	ldrb	r3, [r7, #3]
 8007130:	2b02      	cmp	r3, #2
 8007132:	d107      	bne.n	8007144 <USB_InitFSLSPClkSel+0x68>
  {
    USBx_HOST->HFIR = HFIR_6_MHZ;
 8007134:	68fb      	ldr	r3, [r7, #12]
 8007136:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800713a:	461a      	mov	r2, r3
 800713c:	f241 7370 	movw	r3, #6000	@ 0x1770
 8007140:	6053      	str	r3, [r2, #4]
 8007142:	e001      	b.n	8007148 <USB_InitFSLSPClkSel+0x6c>
  }
  else
  {
    return HAL_ERROR;
 8007144:	2301      	movs	r3, #1
 8007146:	e000      	b.n	800714a <USB_InitFSLSPClkSel+0x6e>
  }

  return HAL_OK;
 8007148:	2300      	movs	r3, #0
}
 800714a:	4618      	mov	r0, r3
 800714c:	3714      	adds	r7, #20
 800714e:	46bd      	mov	sp, r7
 8007150:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007154:	4770      	bx	lr

08007156 <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(const USB_OTG_GlobalTypeDef *USBx)
{
 8007156:	b580      	push	{r7, lr}
 8007158:	b084      	sub	sp, #16
 800715a:	af00      	add	r7, sp, #0
 800715c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800715e:	687b      	ldr	r3, [r7, #4]
 8007160:	60fb      	str	r3, [r7, #12]

  volatile uint32_t hprt0 = 0U;
 8007162:	2300      	movs	r3, #0
 8007164:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 8007166:	68fb      	ldr	r3, [r7, #12]
 8007168:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 800716c:	681b      	ldr	r3, [r3, #0]
 800716e:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8007170:	68bb      	ldr	r3, [r7, #8]
 8007172:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8007176:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 8007178:	68bb      	ldr	r3, [r7, #8]
 800717a:	68fa      	ldr	r2, [r7, #12]
 800717c:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 8007180:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8007184:	6013      	str	r3, [r2, #0]
  HAL_Delay(100U);                                 /* See Note #1 */
 8007186:	2064      	movs	r0, #100	@ 0x64
 8007188:	f7fa fc4e 	bl	8001a28 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 800718c:	68bb      	ldr	r3, [r7, #8]
 800718e:	68fa      	ldr	r2, [r7, #12]
 8007190:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 8007194:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8007198:	6013      	str	r3, [r2, #0]
  HAL_Delay(10U);
 800719a:	200a      	movs	r0, #10
 800719c:	f7fa fc44 	bl	8001a28 <HAL_Delay>

  return HAL_OK;
 80071a0:	2300      	movs	r3, #0
}
 80071a2:	4618      	mov	r0, r3
 80071a4:	3710      	adds	r7, #16
 80071a6:	46bd      	mov	sp, r7
 80071a8:	bd80      	pop	{r7, pc}

080071aa <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(const USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 80071aa:	b480      	push	{r7}
 80071ac:	b085      	sub	sp, #20
 80071ae:	af00      	add	r7, sp, #0
 80071b0:	6078      	str	r0, [r7, #4]
 80071b2:	460b      	mov	r3, r1
 80071b4:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80071b6:	687b      	ldr	r3, [r7, #4]
 80071b8:	60fb      	str	r3, [r7, #12]
  volatile uint32_t hprt0 = 0U;
 80071ba:	2300      	movs	r3, #0
 80071bc:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 80071be:	68fb      	ldr	r3, [r7, #12]
 80071c0:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 80071c4:	681b      	ldr	r3, [r3, #0]
 80071c6:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80071c8:	68bb      	ldr	r3, [r7, #8]
 80071ca:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 80071ce:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 80071d0:	68bb      	ldr	r3, [r7, #8]
 80071d2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80071d6:	2b00      	cmp	r3, #0
 80071d8:	d109      	bne.n	80071ee <USB_DriveVbus+0x44>
 80071da:	78fb      	ldrb	r3, [r7, #3]
 80071dc:	2b01      	cmp	r3, #1
 80071de:	d106      	bne.n	80071ee <USB_DriveVbus+0x44>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 80071e0:	68bb      	ldr	r3, [r7, #8]
 80071e2:	68fa      	ldr	r2, [r7, #12]
 80071e4:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 80071e8:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80071ec:	6013      	str	r3, [r2, #0]
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 80071ee:	68bb      	ldr	r3, [r7, #8]
 80071f0:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80071f4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80071f8:	d109      	bne.n	800720e <USB_DriveVbus+0x64>
 80071fa:	78fb      	ldrb	r3, [r7, #3]
 80071fc:	2b00      	cmp	r3, #0
 80071fe:	d106      	bne.n	800720e <USB_DriveVbus+0x64>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 8007200:	68bb      	ldr	r3, [r7, #8]
 8007202:	68fa      	ldr	r2, [r7, #12]
 8007204:	f502 6288 	add.w	r2, r2, #1088	@ 0x440
 8007208:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800720c:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 800720e:	2300      	movs	r3, #0
}
 8007210:	4618      	mov	r0, r3
 8007212:	3714      	adds	r7, #20
 8007214:	46bd      	mov	sp, r7
 8007216:	f85d 7b04 	ldr.w	r7, [sp], #4
 800721a:	4770      	bx	lr

0800721c <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef const *USBx)
{
 800721c:	b480      	push	{r7}
 800721e:	b085      	sub	sp, #20
 8007220:	af00      	add	r7, sp, #0
 8007222:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	60fb      	str	r3, [r7, #12]
  volatile uint32_t hprt0 = 0U;
 8007228:	2300      	movs	r3, #0
 800722a:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 800722c:	68fb      	ldr	r3, [r7, #12]
 800722e:	f503 6388 	add.w	r3, r3, #1088	@ 0x440
 8007232:	681b      	ldr	r3, [r3, #0]
 8007234:	60bb      	str	r3, [r7, #8]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8007236:	68bb      	ldr	r3, [r7, #8]
 8007238:	0c5b      	lsrs	r3, r3, #17
 800723a:	f003 0303 	and.w	r3, r3, #3
}
 800723e:	4618      	mov	r0, r3
 8007240:	3714      	adds	r7, #20
 8007242:	46bd      	mov	sp, r7
 8007244:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007248:	4770      	bx	lr

0800724a <USB_GetCurrentFrame>:
  * @brief  Return Host Current Frame number
  * @param  USBx  Selected device
  * @retval current frame number
  */
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef const *USBx)
{
 800724a:	b480      	push	{r7}
 800724c:	b085      	sub	sp, #20
 800724e:	af00      	add	r7, sp, #0
 8007250:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007252:	687b      	ldr	r3, [r7, #4]
 8007254:	60fb      	str	r3, [r7, #12]

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 8007256:	68fb      	ldr	r3, [r7, #12]
 8007258:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800725c:	689b      	ldr	r3, [r3, #8]
 800725e:	b29b      	uxth	r3, r3
}
 8007260:	4618      	mov	r0, r3
 8007262:	3714      	adds	r7, #20
 8007264:	46bd      	mov	sp, r7
 8007266:	f85d 7b04 	ldr.w	r7, [sp], #4
 800726a:	4770      	bx	lr

0800726c <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 800726c:	b580      	push	{r7, lr}
 800726e:	b088      	sub	sp, #32
 8007270:	af00      	add	r7, sp, #0
 8007272:	6078      	str	r0, [r7, #4]
 8007274:	4608      	mov	r0, r1
 8007276:	4611      	mov	r1, r2
 8007278:	461a      	mov	r2, r3
 800727a:	4603      	mov	r3, r0
 800727c:	70fb      	strb	r3, [r7, #3]
 800727e:	460b      	mov	r3, r1
 8007280:	70bb      	strb	r3, [r7, #2]
 8007282:	4613      	mov	r3, r2
 8007284:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef ret = HAL_OK;
 8007286:	2300      	movs	r3, #0
 8007288:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800728a:	687b      	ldr	r3, [r7, #4]
 800728c:	613b      	str	r3, [r7, #16]
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 800728e:	78fb      	ldrb	r3, [r7, #3]
 8007290:	015a      	lsls	r2, r3, #5
 8007292:	693b      	ldr	r3, [r7, #16]
 8007294:	4413      	add	r3, r2
 8007296:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800729a:	461a      	mov	r2, r3
 800729c:	f04f 33ff 	mov.w	r3, #4294967295
 80072a0:	6093      	str	r3, [r2, #8]

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 80072a2:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 80072a6:	2b03      	cmp	r3, #3
 80072a8:	d87c      	bhi.n	80073a4 <USB_HC_Init+0x138>
 80072aa:	a201      	add	r2, pc, #4	@ (adr r2, 80072b0 <USB_HC_Init+0x44>)
 80072ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80072b0:	080072c1 	.word	0x080072c1
 80072b4:	08007367 	.word	0x08007367
 80072b8:	080072c1 	.word	0x080072c1
 80072bc:	08007329 	.word	0x08007329
  {
    case EP_TYPE_CTRL:
    case EP_TYPE_BULK:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80072c0:	78fb      	ldrb	r3, [r7, #3]
 80072c2:	015a      	lsls	r2, r3, #5
 80072c4:	693b      	ldr	r3, [r7, #16]
 80072c6:	4413      	add	r3, r2
 80072c8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80072cc:	461a      	mov	r2, r3
 80072ce:	f240 439d 	movw	r3, #1181	@ 0x49d
 80072d2:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 80072d4:	f997 3002 	ldrsb.w	r3, [r7, #2]
 80072d8:	2b00      	cmp	r3, #0
 80072da:	da10      	bge.n	80072fe <USB_HC_Init+0x92>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 80072dc:	78fb      	ldrb	r3, [r7, #3]
 80072de:	015a      	lsls	r2, r3, #5
 80072e0:	693b      	ldr	r3, [r7, #16]
 80072e2:	4413      	add	r3, r2
 80072e4:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80072e8:	68db      	ldr	r3, [r3, #12]
 80072ea:	78fa      	ldrb	r2, [r7, #3]
 80072ec:	0151      	lsls	r1, r2, #5
 80072ee:	693a      	ldr	r2, [r7, #16]
 80072f0:	440a      	add	r2, r1
 80072f2:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80072f6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80072fa:	60d3      	str	r3, [r2, #12]
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
                                                 USB_OTG_HCINTMSK_ACKM;
        }
#endif /* defined (USB_OTG_HS) */
      }
      break;
 80072fc:	e055      	b.n	80073aa <USB_HC_Init+0x13e>
        if (USBx == USB_OTG_HS)
 80072fe:	687b      	ldr	r3, [r7, #4]
 8007300:	4a6f      	ldr	r2, [pc, #444]	@ (80074c0 <USB_HC_Init+0x254>)
 8007302:	4293      	cmp	r3, r2
 8007304:	d151      	bne.n	80073aa <USB_HC_Init+0x13e>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 8007306:	78fb      	ldrb	r3, [r7, #3]
 8007308:	015a      	lsls	r2, r3, #5
 800730a:	693b      	ldr	r3, [r7, #16]
 800730c:	4413      	add	r3, r2
 800730e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007312:	68db      	ldr	r3, [r3, #12]
 8007314:	78fa      	ldrb	r2, [r7, #3]
 8007316:	0151      	lsls	r1, r2, #5
 8007318:	693a      	ldr	r2, [r7, #16]
 800731a:	440a      	add	r2, r1
 800731c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007320:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 8007324:	60d3      	str	r3, [r2, #12]
      break;
 8007326:	e040      	b.n	80073aa <USB_HC_Init+0x13e>

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007328:	78fb      	ldrb	r3, [r7, #3]
 800732a:	015a      	lsls	r2, r3, #5
 800732c:	693b      	ldr	r3, [r7, #16]
 800732e:	4413      	add	r3, r2
 8007330:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007334:	461a      	mov	r2, r3
 8007336:	f240 639d 	movw	r3, #1693	@ 0x69d
 800733a:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 800733c:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8007340:	2b00      	cmp	r3, #0
 8007342:	da34      	bge.n	80073ae <USB_HC_Init+0x142>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8007344:	78fb      	ldrb	r3, [r7, #3]
 8007346:	015a      	lsls	r2, r3, #5
 8007348:	693b      	ldr	r3, [r7, #16]
 800734a:	4413      	add	r3, r2
 800734c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007350:	68db      	ldr	r3, [r3, #12]
 8007352:	78fa      	ldrb	r2, [r7, #3]
 8007354:	0151      	lsls	r1, r2, #5
 8007356:	693a      	ldr	r2, [r7, #16]
 8007358:	440a      	add	r2, r1
 800735a:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800735e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8007362:	60d3      	str	r3, [r2, #12]
      }

      break;
 8007364:	e023      	b.n	80073ae <USB_HC_Init+0x142>

    case EP_TYPE_ISOC:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8007366:	78fb      	ldrb	r3, [r7, #3]
 8007368:	015a      	lsls	r2, r3, #5
 800736a:	693b      	ldr	r3, [r7, #16]
 800736c:	4413      	add	r3, r2
 800736e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007372:	461a      	mov	r2, r3
 8007374:	f240 2325 	movw	r3, #549	@ 0x225
 8007378:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_ACKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 800737a:	f997 3002 	ldrsb.w	r3, [r7, #2]
 800737e:	2b00      	cmp	r3, #0
 8007380:	da17      	bge.n	80073b2 <USB_HC_Init+0x146>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 8007382:	78fb      	ldrb	r3, [r7, #3]
 8007384:	015a      	lsls	r2, r3, #5
 8007386:	693b      	ldr	r3, [r7, #16]
 8007388:	4413      	add	r3, r2
 800738a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800738e:	68db      	ldr	r3, [r3, #12]
 8007390:	78fa      	ldrb	r2, [r7, #3]
 8007392:	0151      	lsls	r1, r2, #5
 8007394:	693a      	ldr	r2, [r7, #16]
 8007396:	440a      	add	r2, r1
 8007398:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800739c:	f443 73c0 	orr.w	r3, r3, #384	@ 0x180
 80073a0:	60d3      	str	r3, [r2, #12]
      }
      break;
 80073a2:	e006      	b.n	80073b2 <USB_HC_Init+0x146>

    default:
      ret = HAL_ERROR;
 80073a4:	2301      	movs	r3, #1
 80073a6:	77fb      	strb	r3, [r7, #31]
      break;
 80073a8:	e004      	b.n	80073b4 <USB_HC_Init+0x148>
      break;
 80073aa:	bf00      	nop
 80073ac:	e002      	b.n	80073b4 <USB_HC_Init+0x148>
      break;
 80073ae:	bf00      	nop
 80073b0:	e000      	b.n	80073b4 <USB_HC_Init+0x148>
      break;
 80073b2:	bf00      	nop
  }

  /* Clear Hub Start Split transaction */
  USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 80073b4:	78fb      	ldrb	r3, [r7, #3]
 80073b6:	015a      	lsls	r2, r3, #5
 80073b8:	693b      	ldr	r3, [r7, #16]
 80073ba:	4413      	add	r3, r2
 80073bc:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80073c0:	461a      	mov	r2, r3
 80073c2:	2300      	movs	r3, #0
 80073c4:	6053      	str	r3, [r2, #4]

  /* Enable host channel Halt interrupt */
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 80073c6:	78fb      	ldrb	r3, [r7, #3]
 80073c8:	015a      	lsls	r2, r3, #5
 80073ca:	693b      	ldr	r3, [r7, #16]
 80073cc:	4413      	add	r3, r2
 80073ce:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80073d2:	68db      	ldr	r3, [r3, #12]
 80073d4:	78fa      	ldrb	r2, [r7, #3]
 80073d6:	0151      	lsls	r1, r2, #5
 80073d8:	693a      	ldr	r2, [r7, #16]
 80073da:	440a      	add	r2, r1
 80073dc:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80073e0:	f043 0302 	orr.w	r3, r3, #2
 80073e4:	60d3      	str	r3, [r2, #12]

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 80073e6:	693b      	ldr	r3, [r7, #16]
 80073e8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80073ec:	699a      	ldr	r2, [r3, #24]
 80073ee:	78fb      	ldrb	r3, [r7, #3]
 80073f0:	f003 030f 	and.w	r3, r3, #15
 80073f4:	2101      	movs	r1, #1
 80073f6:	fa01 f303 	lsl.w	r3, r1, r3
 80073fa:	6939      	ldr	r1, [r7, #16]
 80073fc:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8007400:	4313      	orrs	r3, r2
 8007402:	618b      	str	r3, [r1, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8007404:	687b      	ldr	r3, [r7, #4]
 8007406:	699b      	ldr	r3, [r3, #24]
 8007408:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 800740c:	687b      	ldr	r3, [r7, #4]
 800740e:	619a      	str	r2, [r3, #24]

  /* Program the HCCHAR register */
  if ((epnum & 0x80U) == 0x80U)
 8007410:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8007414:	2b00      	cmp	r3, #0
 8007416:	da03      	bge.n	8007420 <USB_HC_Init+0x1b4>
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 8007418:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800741c:	61bb      	str	r3, [r7, #24]
 800741e:	e001      	b.n	8007424 <USB_HC_Init+0x1b8>
  }
  else
  {
    HCcharEpDir = 0U;
 8007420:	2300      	movs	r3, #0
 8007422:	61bb      	str	r3, [r7, #24]
  }

  HostCoreSpeed = USB_GetHostSpeed(USBx);
 8007424:	6878      	ldr	r0, [r7, #4]
 8007426:	f7ff fef9 	bl	800721c <USB_GetHostSpeed>
 800742a:	60f8      	str	r0, [r7, #12]

  /* LS device plugged to HUB */
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 800742c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8007430:	2b02      	cmp	r3, #2
 8007432:	d106      	bne.n	8007442 <USB_HC_Init+0x1d6>
 8007434:	68fb      	ldr	r3, [r7, #12]
 8007436:	2b02      	cmp	r3, #2
 8007438:	d003      	beq.n	8007442 <USB_HC_Init+0x1d6>
  {
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 800743a:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800743e:	617b      	str	r3, [r7, #20]
 8007440:	e001      	b.n	8007446 <USB_HC_Init+0x1da>
  }
  else
  {
    HCcharLowSpeed = 0U;
 8007442:	2300      	movs	r3, #0
 8007444:	617b      	str	r3, [r7, #20]
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007446:	787b      	ldrb	r3, [r7, #1]
 8007448:	059b      	lsls	r3, r3, #22
 800744a:	f003 52fe 	and.w	r2, r3, #532676608	@ 0x1fc00000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800744e:	78bb      	ldrb	r3, [r7, #2]
 8007450:	02db      	lsls	r3, r3, #11
 8007452:	f403 43f0 	and.w	r3, r3, #30720	@ 0x7800
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007456:	431a      	orrs	r2, r3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8007458:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 800745c:	049b      	lsls	r3, r3, #18
 800745e:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 8007462:	431a      	orrs	r2, r3
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) |
 8007464:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
 8007466:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800746a:	431a      	orrs	r2, r3
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 800746c:	69bb      	ldr	r3, [r7, #24]
 800746e:	431a      	orrs	r2, r3
 8007470:	697b      	ldr	r3, [r7, #20]
 8007472:	4313      	orrs	r3, r2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007474:	78fa      	ldrb	r2, [r7, #3]
 8007476:	0151      	lsls	r1, r2, #5
 8007478:	693a      	ldr	r2, [r7, #16]
 800747a:	440a      	add	r2, r1
 800747c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 8007480:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8007484:	6013      	str	r3, [r2, #0]

  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8007486:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 800748a:	2b03      	cmp	r3, #3
 800748c:	d003      	beq.n	8007496 <USB_HC_Init+0x22a>
 800748e:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 8007492:	2b01      	cmp	r3, #1
 8007494:	d10f      	bne.n	80074b6 <USB_HC_Init+0x24a>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8007496:	78fb      	ldrb	r3, [r7, #3]
 8007498:	015a      	lsls	r2, r3, #5
 800749a:	693b      	ldr	r3, [r7, #16]
 800749c:	4413      	add	r3, r2
 800749e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80074a2:	681b      	ldr	r3, [r3, #0]
 80074a4:	78fa      	ldrb	r2, [r7, #3]
 80074a6:	0151      	lsls	r1, r2, #5
 80074a8:	693a      	ldr	r2, [r7, #16]
 80074aa:	440a      	add	r2, r1
 80074ac:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80074b0:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80074b4:	6013      	str	r3, [r2, #0]
  }

  return ret;
 80074b6:	7ffb      	ldrb	r3, [r7, #31]
}
 80074b8:	4618      	mov	r0, r3
 80074ba:	3720      	adds	r7, #32
 80074bc:	46bd      	mov	sp, r7
 80074be:	bd80      	pop	{r7, pc}
 80074c0:	40040000 	.word	0x40040000

080074c4 <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 80074c4:	b580      	push	{r7, lr}
 80074c6:	b08c      	sub	sp, #48	@ 0x30
 80074c8:	af02      	add	r7, sp, #8
 80074ca:	60f8      	str	r0, [r7, #12]
 80074cc:	60b9      	str	r1, [r7, #8]
 80074ce:	4613      	mov	r3, r2
 80074d0:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80074d2:	68fb      	ldr	r3, [r7, #12]
 80074d4:	623b      	str	r3, [r7, #32]
  uint32_t ch_num = (uint32_t)hc->ch_num;
 80074d6:	68bb      	ldr	r3, [r7, #8]
 80074d8:	785b      	ldrb	r3, [r3, #1]
 80074da:	61fb      	str	r3, [r7, #28]
  volatile uint32_t tmpreg;
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = HC_MAX_PKT_CNT;
 80074dc:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80074e0:	837b      	strh	r3, [r7, #26]

#if defined (USB_OTG_HS)
  if (USBx == USB_OTG_HS)
 80074e2:	68fb      	ldr	r3, [r7, #12]
 80074e4:	4a5d      	ldr	r2, [pc, #372]	@ (800765c <USB_HC_StartXfer+0x198>)
 80074e6:	4293      	cmp	r3, r2
 80074e8:	d12f      	bne.n	800754a <USB_HC_StartXfer+0x86>
  {
    /* in DMA mode host Core automatically issues ping in case of NYET/NAK */
    if (dma == 1U)
 80074ea:	79fb      	ldrb	r3, [r7, #7]
 80074ec:	2b01      	cmp	r3, #1
 80074ee:	d11c      	bne.n	800752a <USB_HC_StartXfer+0x66>
    {
      if (((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)) && (hc->do_ssplit == 0U))
 80074f0:	68bb      	ldr	r3, [r7, #8]
 80074f2:	7c9b      	ldrb	r3, [r3, #18]
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d003      	beq.n	8007500 <USB_HC_StartXfer+0x3c>
 80074f8:	68bb      	ldr	r3, [r7, #8]
 80074fa:	7c9b      	ldrb	r3, [r3, #18]
 80074fc:	2b02      	cmp	r3, #2
 80074fe:	d124      	bne.n	800754a <USB_HC_StartXfer+0x86>
 8007500:	68bb      	ldr	r3, [r7, #8]
 8007502:	799b      	ldrb	r3, [r3, #6]
 8007504:	2b00      	cmp	r3, #0
 8007506:	d120      	bne.n	800754a <USB_HC_StartXfer+0x86>
      {

        USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 8007508:	69fb      	ldr	r3, [r7, #28]
 800750a:	015a      	lsls	r2, r3, #5
 800750c:	6a3b      	ldr	r3, [r7, #32]
 800750e:	4413      	add	r3, r2
 8007510:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007514:	68db      	ldr	r3, [r3, #12]
 8007516:	69fa      	ldr	r2, [r7, #28]
 8007518:	0151      	lsls	r1, r2, #5
 800751a:	6a3a      	ldr	r2, [r7, #32]
 800751c:	440a      	add	r2, r1
 800751e:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007522:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8007526:	60d3      	str	r3, [r2, #12]
 8007528:	e00f      	b.n	800754a <USB_HC_StartXfer+0x86>
                                                 USB_OTG_HCINTMSK_NAKM);
      }
    }
    else
    {
      if ((hc->speed == USBH_HS_SPEED) && (hc->do_ping == 1U))
 800752a:	68bb      	ldr	r3, [r7, #8]
 800752c:	791b      	ldrb	r3, [r3, #4]
 800752e:	2b00      	cmp	r3, #0
 8007530:	d10b      	bne.n	800754a <USB_HC_StartXfer+0x86>
 8007532:	68bb      	ldr	r3, [r7, #8]
 8007534:	795b      	ldrb	r3, [r3, #5]
 8007536:	2b01      	cmp	r3, #1
 8007538:	d107      	bne.n	800754a <USB_HC_StartXfer+0x86>
      {
        (void)USB_DoPing(USBx, hc->ch_num);
 800753a:	68bb      	ldr	r3, [r7, #8]
 800753c:	785b      	ldrb	r3, [r3, #1]
 800753e:	4619      	mov	r1, r3
 8007540:	68f8      	ldr	r0, [r7, #12]
 8007542:	f000 fb6b 	bl	8007c1c <USB_DoPing>
        return HAL_OK;
 8007546:	2300      	movs	r3, #0
 8007548:	e232      	b.n	80079b0 <USB_HC_StartXfer+0x4ec>
      }
    }
  }
#endif /* defined (USB_OTG_HS) */

  if (hc->do_ssplit == 1U)
 800754a:	68bb      	ldr	r3, [r7, #8]
 800754c:	799b      	ldrb	r3, [r3, #6]
 800754e:	2b01      	cmp	r3, #1
 8007550:	d158      	bne.n	8007604 <USB_HC_StartXfer+0x140>
  {
    /* Set number of packet to 1 for Split transaction */
    num_packets = 1U;
 8007552:	2301      	movs	r3, #1
 8007554:	84fb      	strh	r3, [r7, #38]	@ 0x26

    if (hc->ep_is_in != 0U)
 8007556:	68bb      	ldr	r3, [r7, #8]
 8007558:	78db      	ldrb	r3, [r3, #3]
 800755a:	2b00      	cmp	r3, #0
 800755c:	d007      	beq.n	800756e <USB_HC_StartXfer+0xaa>
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800755e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8007560:	68ba      	ldr	r2, [r7, #8]
 8007562:	8a92      	ldrh	r2, [r2, #20]
 8007564:	fb03 f202 	mul.w	r2, r3, r2
 8007568:	68bb      	ldr	r3, [r7, #8]
 800756a:	61da      	str	r2, [r3, #28]
 800756c:	e07c      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
    }
    else
    {
      if (hc->ep_type == EP_TYPE_ISOC)
 800756e:	68bb      	ldr	r3, [r7, #8]
 8007570:	7c9b      	ldrb	r3, [r3, #18]
 8007572:	2b01      	cmp	r3, #1
 8007574:	d130      	bne.n	80075d8 <USB_HC_StartXfer+0x114>
      {
        if (hc->xfer_len > ISO_SPLT_MPS)
 8007576:	68bb      	ldr	r3, [r7, #8]
 8007578:	6a1b      	ldr	r3, [r3, #32]
 800757a:	2bbc      	cmp	r3, #188	@ 0xbc
 800757c:	d918      	bls.n	80075b0 <USB_HC_StartXfer+0xec>
        {
          /* Isochrone Max Packet Size for Split mode */
          hc->XferSize = hc->max_packet;
 800757e:	68bb      	ldr	r3, [r7, #8]
 8007580:	8a9b      	ldrh	r3, [r3, #20]
 8007582:	461a      	mov	r2, r3
 8007584:	68bb      	ldr	r3, [r7, #8]
 8007586:	61da      	str	r2, [r3, #28]
          hc->xfer_len = hc->XferSize;
 8007588:	68bb      	ldr	r3, [r7, #8]
 800758a:	69da      	ldr	r2, [r3, #28]
 800758c:	68bb      	ldr	r3, [r7, #8]
 800758e:	621a      	str	r2, [r3, #32]

          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 8007590:	68bb      	ldr	r3, [r7, #8]
 8007592:	68db      	ldr	r3, [r3, #12]
 8007594:	2b01      	cmp	r3, #1
 8007596:	d003      	beq.n	80075a0 <USB_HC_StartXfer+0xdc>
 8007598:	68bb      	ldr	r3, [r7, #8]
 800759a:	68db      	ldr	r3, [r3, #12]
 800759c:	2b02      	cmp	r3, #2
 800759e:	d103      	bne.n	80075a8 <USB_HC_StartXfer+0xe4>
          {
            hc->iso_splt_xactPos = HCSPLT_MIDDLE;
 80075a0:	68bb      	ldr	r3, [r7, #8]
 80075a2:	2202      	movs	r2, #2
 80075a4:	60da      	str	r2, [r3, #12]
 80075a6:	e05f      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
          }
          else
          {
            hc->iso_splt_xactPos = HCSPLT_BEGIN;
 80075a8:	68bb      	ldr	r3, [r7, #8]
 80075aa:	2201      	movs	r2, #1
 80075ac:	60da      	str	r2, [r3, #12]
 80075ae:	e05b      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
          }
        }
        else
        {
          hc->XferSize = hc->xfer_len;
 80075b0:	68bb      	ldr	r3, [r7, #8]
 80075b2:	6a1a      	ldr	r2, [r3, #32]
 80075b4:	68bb      	ldr	r3, [r7, #8]
 80075b6:	61da      	str	r2, [r3, #28]

          if ((hc->iso_splt_xactPos != HCSPLT_BEGIN) && (hc->iso_splt_xactPos != HCSPLT_MIDDLE))
 80075b8:	68bb      	ldr	r3, [r7, #8]
 80075ba:	68db      	ldr	r3, [r3, #12]
 80075bc:	2b01      	cmp	r3, #1
 80075be:	d007      	beq.n	80075d0 <USB_HC_StartXfer+0x10c>
 80075c0:	68bb      	ldr	r3, [r7, #8]
 80075c2:	68db      	ldr	r3, [r3, #12]
 80075c4:	2b02      	cmp	r3, #2
 80075c6:	d003      	beq.n	80075d0 <USB_HC_StartXfer+0x10c>
          {
            hc->iso_splt_xactPos = HCSPLT_FULL;
 80075c8:	68bb      	ldr	r3, [r7, #8]
 80075ca:	2204      	movs	r2, #4
 80075cc:	60da      	str	r2, [r3, #12]
 80075ce:	e04b      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
          }
          else
          {
            hc->iso_splt_xactPos = HCSPLT_END;
 80075d0:	68bb      	ldr	r3, [r7, #8]
 80075d2:	2203      	movs	r2, #3
 80075d4:	60da      	str	r2, [r3, #12]
 80075d6:	e047      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
          }
        }
      }
      else
      {
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 80075d8:	79fb      	ldrb	r3, [r7, #7]
 80075da:	2b01      	cmp	r3, #1
 80075dc:	d10d      	bne.n	80075fa <USB_HC_StartXfer+0x136>
 80075de:	68bb      	ldr	r3, [r7, #8]
 80075e0:	6a1b      	ldr	r3, [r3, #32]
 80075e2:	68ba      	ldr	r2, [r7, #8]
 80075e4:	8a92      	ldrh	r2, [r2, #20]
 80075e6:	4293      	cmp	r3, r2
 80075e8:	d907      	bls.n	80075fa <USB_HC_StartXfer+0x136>
        {
          hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80075ea:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80075ec:	68ba      	ldr	r2, [r7, #8]
 80075ee:	8a92      	ldrh	r2, [r2, #20]
 80075f0:	fb03 f202 	mul.w	r2, r3, r2
 80075f4:	68bb      	ldr	r3, [r7, #8]
 80075f6:	61da      	str	r2, [r3, #28]
 80075f8:	e036      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
        }
        else
        {
          hc->XferSize = hc->xfer_len;
 80075fa:	68bb      	ldr	r3, [r7, #8]
 80075fc:	6a1a      	ldr	r2, [r3, #32]
 80075fe:	68bb      	ldr	r3, [r7, #8]
 8007600:	61da      	str	r2, [r3, #28]
 8007602:	e031      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
    }
  }
  else
  {
    /* Compute the expected number of packets associated to the transfer */
    if (hc->xfer_len > 0U)
 8007604:	68bb      	ldr	r3, [r7, #8]
 8007606:	6a1b      	ldr	r3, [r3, #32]
 8007608:	2b00      	cmp	r3, #0
 800760a:	d018      	beq.n	800763e <USB_HC_StartXfer+0x17a>
    {
      num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 800760c:	68bb      	ldr	r3, [r7, #8]
 800760e:	6a1b      	ldr	r3, [r3, #32]
 8007610:	68ba      	ldr	r2, [r7, #8]
 8007612:	8a92      	ldrh	r2, [r2, #20]
 8007614:	4413      	add	r3, r2
 8007616:	3b01      	subs	r3, #1
 8007618:	68ba      	ldr	r2, [r7, #8]
 800761a:	8a92      	ldrh	r2, [r2, #20]
 800761c:	fbb3 f3f2 	udiv	r3, r3, r2
 8007620:	84fb      	strh	r3, [r7, #38]	@ 0x26

      if (num_packets > max_hc_pkt_count)
 8007622:	8cfa      	ldrh	r2, [r7, #38]	@ 0x26
 8007624:	8b7b      	ldrh	r3, [r7, #26]
 8007626:	429a      	cmp	r2, r3
 8007628:	d90b      	bls.n	8007642 <USB_HC_StartXfer+0x17e>
      {
        num_packets = max_hc_pkt_count;
 800762a:	8b7b      	ldrh	r3, [r7, #26]
 800762c:	84fb      	strh	r3, [r7, #38]	@ 0x26
        hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800762e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8007630:	68ba      	ldr	r2, [r7, #8]
 8007632:	8a92      	ldrh	r2, [r2, #20]
 8007634:	fb03 f202 	mul.w	r2, r3, r2
 8007638:	68bb      	ldr	r3, [r7, #8]
 800763a:	61da      	str	r2, [r3, #28]
 800763c:	e001      	b.n	8007642 <USB_HC_StartXfer+0x17e>
      }
    }
    else
    {
      num_packets = 1U;
 800763e:	2301      	movs	r3, #1
 8007640:	84fb      	strh	r3, [r7, #38]	@ 0x26

    /*
    * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
    * max_packet size.
    */
    if (hc->ep_is_in != 0U)
 8007642:	68bb      	ldr	r3, [r7, #8]
 8007644:	78db      	ldrb	r3, [r3, #3]
 8007646:	2b00      	cmp	r3, #0
 8007648:	d00a      	beq.n	8007660 <USB_HC_StartXfer+0x19c>
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800764a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800764c:	68ba      	ldr	r2, [r7, #8]
 800764e:	8a92      	ldrh	r2, [r2, #20]
 8007650:	fb03 f202 	mul.w	r2, r3, r2
 8007654:	68bb      	ldr	r3, [r7, #8]
 8007656:	61da      	str	r2, [r3, #28]
 8007658:	e006      	b.n	8007668 <USB_HC_StartXfer+0x1a4>
 800765a:	bf00      	nop
 800765c:	40040000 	.word	0x40040000
    }
    else
    {
      hc->XferSize = hc->xfer_len;
 8007660:	68bb      	ldr	r3, [r7, #8]
 8007662:	6a1a      	ldr	r2, [r3, #32]
 8007664:	68bb      	ldr	r3, [r7, #8]
 8007666:	61da      	str	r2, [r3, #28]
    }
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007668:	68bb      	ldr	r3, [r7, #8]
 800766a:	69db      	ldr	r3, [r3, #28]
 800766c:	f3c3 0212 	ubfx	r2, r3, #0, #19
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007670:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8007672:	04d9      	lsls	r1, r3, #19
 8007674:	4ba3      	ldr	r3, [pc, #652]	@ (8007904 <USB_HC_StartXfer+0x440>)
 8007676:	400b      	ands	r3, r1
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007678:	431a      	orrs	r2, r3
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800767a:	68bb      	ldr	r3, [r7, #8]
 800767c:	7d9b      	ldrb	r3, [r3, #22]
 800767e:	075b      	lsls	r3, r3, #29
 8007680:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007684:	69f9      	ldr	r1, [r7, #28]
 8007686:	0148      	lsls	r0, r1, #5
 8007688:	6a39      	ldr	r1, [r7, #32]
 800768a:	4401      	add	r1, r0
 800768c:	f501 61a0 	add.w	r1, r1, #1280	@ 0x500
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007690:	4313      	orrs	r3, r2
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8007692:	610b      	str	r3, [r1, #16]

  if (dma != 0U)
 8007694:	79fb      	ldrb	r3, [r7, #7]
 8007696:	2b00      	cmp	r3, #0
 8007698:	d009      	beq.n	80076ae <USB_HC_StartXfer+0x1ea>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 800769a:	68bb      	ldr	r3, [r7, #8]
 800769c:	6999      	ldr	r1, [r3, #24]
 800769e:	69fb      	ldr	r3, [r7, #28]
 80076a0:	015a      	lsls	r2, r3, #5
 80076a2:	6a3b      	ldr	r3, [r7, #32]
 80076a4:	4413      	add	r3, r2
 80076a6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80076aa:	460a      	mov	r2, r1
 80076ac:	615a      	str	r2, [r3, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 80076ae:	6a3b      	ldr	r3, [r7, #32]
 80076b0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80076b4:	689b      	ldr	r3, [r3, #8]
 80076b6:	f003 0301 	and.w	r3, r3, #1
 80076ba:	2b00      	cmp	r3, #0
 80076bc:	bf0c      	ite	eq
 80076be:	2301      	moveq	r3, #1
 80076c0:	2300      	movne	r3, #0
 80076c2:	b2db      	uxtb	r3, r3
 80076c4:	767b      	strb	r3, [r7, #25]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 80076c6:	69fb      	ldr	r3, [r7, #28]
 80076c8:	015a      	lsls	r2, r3, #5
 80076ca:	6a3b      	ldr	r3, [r7, #32]
 80076cc:	4413      	add	r3, r2
 80076ce:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80076d2:	681b      	ldr	r3, [r3, #0]
 80076d4:	69fa      	ldr	r2, [r7, #28]
 80076d6:	0151      	lsls	r1, r2, #5
 80076d8:	6a3a      	ldr	r2, [r7, #32]
 80076da:	440a      	add	r2, r1
 80076dc:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80076e0:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 80076e4:	6013      	str	r3, [r2, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80076e6:	69fb      	ldr	r3, [r7, #28]
 80076e8:	015a      	lsls	r2, r3, #5
 80076ea:	6a3b      	ldr	r3, [r7, #32]
 80076ec:	4413      	add	r3, r2
 80076ee:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80076f2:	681a      	ldr	r2, [r3, #0]
 80076f4:	7e7b      	ldrb	r3, [r7, #25]
 80076f6:	075b      	lsls	r3, r3, #29
 80076f8:	69f9      	ldr	r1, [r7, #28]
 80076fa:	0148      	lsls	r0, r1, #5
 80076fc:	6a39      	ldr	r1, [r7, #32]
 80076fe:	4401      	add	r1, r0
 8007700:	f501 61a0 	add.w	r1, r1, #1280	@ 0x500
 8007704:	4313      	orrs	r3, r2
 8007706:	600b      	str	r3, [r1, #0]

  if (hc->do_ssplit == 1U)
 8007708:	68bb      	ldr	r3, [r7, #8]
 800770a:	799b      	ldrb	r3, [r3, #6]
 800770c:	2b01      	cmp	r3, #1
 800770e:	f040 80c3 	bne.w	8007898 <USB_HC_StartXfer+0x3d4>
  {
    /* Set Hub start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 8007712:	68bb      	ldr	r3, [r7, #8]
 8007714:	7c5b      	ldrb	r3, [r3, #17]
 8007716:	01db      	lsls	r3, r3, #7
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 8007718:	68ba      	ldr	r2, [r7, #8]
 800771a:	7c12      	ldrb	r2, [r2, #16]
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 800771c:	4313      	orrs	r3, r2
 800771e:	69fa      	ldr	r2, [r7, #28]
 8007720:	0151      	lsls	r1, r2, #5
 8007722:	6a3a      	ldr	r2, [r7, #32]
 8007724:	440a      	add	r2, r1
 8007726:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 800772a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 800772e:	6053      	str	r3, [r2, #4]

    /* unmask ack & nyet for IN/OUT transactions */
    USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_ACKM |
 8007730:	69fb      	ldr	r3, [r7, #28]
 8007732:	015a      	lsls	r2, r3, #5
 8007734:	6a3b      	ldr	r3, [r7, #32]
 8007736:	4413      	add	r3, r2
 8007738:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800773c:	68db      	ldr	r3, [r3, #12]
 800773e:	69fa      	ldr	r2, [r7, #28]
 8007740:	0151      	lsls	r1, r2, #5
 8007742:	6a3a      	ldr	r2, [r7, #32]
 8007744:	440a      	add	r2, r1
 8007746:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800774a:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800774e:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_NYET);

    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 8007750:	68bb      	ldr	r3, [r7, #8]
 8007752:	79db      	ldrb	r3, [r3, #7]
 8007754:	2b01      	cmp	r3, #1
 8007756:	d123      	bne.n	80077a0 <USB_HC_StartXfer+0x2dc>
 8007758:	68bb      	ldr	r3, [r7, #8]
 800775a:	78db      	ldrb	r3, [r3, #3]
 800775c:	2b00      	cmp	r3, #0
 800775e:	d11f      	bne.n	80077a0 <USB_HC_StartXfer+0x2dc>
    {
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 8007760:	69fb      	ldr	r3, [r7, #28]
 8007762:	015a      	lsls	r2, r3, #5
 8007764:	6a3b      	ldr	r3, [r7, #32]
 8007766:	4413      	add	r3, r2
 8007768:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800776c:	685b      	ldr	r3, [r3, #4]
 800776e:	69fa      	ldr	r2, [r7, #28]
 8007770:	0151      	lsls	r1, r2, #5
 8007772:	6a3a      	ldr	r2, [r7, #32]
 8007774:	440a      	add	r2, r1
 8007776:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800777a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800777e:	6053      	str	r3, [r2, #4]
      USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 8007780:	69fb      	ldr	r3, [r7, #28]
 8007782:	015a      	lsls	r2, r3, #5
 8007784:	6a3b      	ldr	r3, [r7, #32]
 8007786:	4413      	add	r3, r2
 8007788:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800778c:	68db      	ldr	r3, [r3, #12]
 800778e:	69fa      	ldr	r2, [r7, #28]
 8007790:	0151      	lsls	r1, r2, #5
 8007792:	6a3a      	ldr	r2, [r7, #32]
 8007794:	440a      	add	r2, r1
 8007796:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800779a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800779e:	60d3      	str	r3, [r2, #12]
    }

    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 80077a0:	68bb      	ldr	r3, [r7, #8]
 80077a2:	7c9b      	ldrb	r3, [r3, #18]
 80077a4:	2b01      	cmp	r3, #1
 80077a6:	d003      	beq.n	80077b0 <USB_HC_StartXfer+0x2ec>
 80077a8:	68bb      	ldr	r3, [r7, #8]
 80077aa:	7c9b      	ldrb	r3, [r3, #18]
 80077ac:	2b03      	cmp	r3, #3
 80077ae:	d117      	bne.n	80077e0 <USB_HC_StartXfer+0x31c>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 80077b0:	68bb      	ldr	r3, [r7, #8]
 80077b2:	79db      	ldrb	r3, [r3, #7]
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 80077b4:	2b01      	cmp	r3, #1
 80077b6:	d113      	bne.n	80077e0 <USB_HC_StartXfer+0x31c>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 80077b8:	68bb      	ldr	r3, [r7, #8]
 80077ba:	78db      	ldrb	r3, [r3, #3]
 80077bc:	2b01      	cmp	r3, #1
 80077be:	d10f      	bne.n	80077e0 <USB_HC_StartXfer+0x31c>
    {
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 80077c0:	69fb      	ldr	r3, [r7, #28]
 80077c2:	015a      	lsls	r2, r3, #5
 80077c4:	6a3b      	ldr	r3, [r7, #32]
 80077c6:	4413      	add	r3, r2
 80077c8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80077cc:	685b      	ldr	r3, [r3, #4]
 80077ce:	69fa      	ldr	r2, [r7, #28]
 80077d0:	0151      	lsls	r1, r2, #5
 80077d2:	6a3a      	ldr	r2, [r7, #32]
 80077d4:	440a      	add	r2, r1
 80077d6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 80077da:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80077de:	6053      	str	r3, [r2, #4]
    }

    /* Position management for iso out transaction on split mode */
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 80077e0:	68bb      	ldr	r3, [r7, #8]
 80077e2:	7c9b      	ldrb	r3, [r3, #18]
 80077e4:	2b01      	cmp	r3, #1
 80077e6:	d162      	bne.n	80078ae <USB_HC_StartXfer+0x3ea>
 80077e8:	68bb      	ldr	r3, [r7, #8]
 80077ea:	78db      	ldrb	r3, [r3, #3]
 80077ec:	2b00      	cmp	r3, #0
 80077ee:	d15e      	bne.n	80078ae <USB_HC_StartXfer+0x3ea>
    {
      /* Set data payload position */
      switch (hc->iso_splt_xactPos)
 80077f0:	68bb      	ldr	r3, [r7, #8]
 80077f2:	68db      	ldr	r3, [r3, #12]
 80077f4:	3b01      	subs	r3, #1
 80077f6:	2b03      	cmp	r3, #3
 80077f8:	d858      	bhi.n	80078ac <USB_HC_StartXfer+0x3e8>
 80077fa:	a201      	add	r2, pc, #4	@ (adr r2, 8007800 <USB_HC_StartXfer+0x33c>)
 80077fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007800:	08007811 	.word	0x08007811
 8007804:	08007833 	.word	0x08007833
 8007808:	08007855 	.word	0x08007855
 800780c:	08007877 	.word	0x08007877
      {
        case HCSPLT_BEGIN:
          /* First data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_1;
 8007810:	69fb      	ldr	r3, [r7, #28]
 8007812:	015a      	lsls	r2, r3, #5
 8007814:	6a3b      	ldr	r3, [r7, #32]
 8007816:	4413      	add	r3, r2
 8007818:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800781c:	685b      	ldr	r3, [r3, #4]
 800781e:	69fa      	ldr	r2, [r7, #28]
 8007820:	0151      	lsls	r1, r2, #5
 8007822:	6a3a      	ldr	r2, [r7, #32]
 8007824:	440a      	add	r2, r1
 8007826:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800782a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800782e:	6053      	str	r3, [r2, #4]
          break;
 8007830:	e03d      	b.n	80078ae <USB_HC_StartXfer+0x3ea>

        case HCSPLT_MIDDLE:
          /* Middle data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_Pos;
 8007832:	69fb      	ldr	r3, [r7, #28]
 8007834:	015a      	lsls	r2, r3, #5
 8007836:	6a3b      	ldr	r3, [r7, #32]
 8007838:	4413      	add	r3, r2
 800783a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 800783e:	685b      	ldr	r3, [r3, #4]
 8007840:	69fa      	ldr	r2, [r7, #28]
 8007842:	0151      	lsls	r1, r2, #5
 8007844:	6a3a      	ldr	r2, [r7, #32]
 8007846:	440a      	add	r2, r1
 8007848:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800784c:	f043 030e 	orr.w	r3, r3, #14
 8007850:	6053      	str	r3, [r2, #4]
          break;
 8007852:	e02c      	b.n	80078ae <USB_HC_StartXfer+0x3ea>

        case HCSPLT_END:
          /* End data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_0;
 8007854:	69fb      	ldr	r3, [r7, #28]
 8007856:	015a      	lsls	r2, r3, #5
 8007858:	6a3b      	ldr	r3, [r7, #32]
 800785a:	4413      	add	r3, r2
 800785c:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007860:	685b      	ldr	r3, [r3, #4]
 8007862:	69fa      	ldr	r2, [r7, #28]
 8007864:	0151      	lsls	r1, r2, #5
 8007866:	6a3a      	ldr	r2, [r7, #32]
 8007868:	440a      	add	r2, r1
 800786a:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 800786e:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8007872:	6053      	str	r3, [r2, #4]
          break;
 8007874:	e01b      	b.n	80078ae <USB_HC_StartXfer+0x3ea>

        case HCSPLT_FULL:
          /* Entire data payload for OUT Transaction */
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS;
 8007876:	69fb      	ldr	r3, [r7, #28]
 8007878:	015a      	lsls	r2, r3, #5
 800787a:	6a3b      	ldr	r3, [r7, #32]
 800787c:	4413      	add	r3, r2
 800787e:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007882:	685b      	ldr	r3, [r3, #4]
 8007884:	69fa      	ldr	r2, [r7, #28]
 8007886:	0151      	lsls	r1, r2, #5
 8007888:	6a3a      	ldr	r2, [r7, #32]
 800788a:	440a      	add	r2, r1
 800788c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007890:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 8007894:	6053      	str	r3, [r2, #4]
          break;
 8007896:	e00a      	b.n	80078ae <USB_HC_StartXfer+0x3ea>
    }
  }
  else
  {
    /* Clear Hub Start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 8007898:	69fb      	ldr	r3, [r7, #28]
 800789a:	015a      	lsls	r2, r3, #5
 800789c:	6a3b      	ldr	r3, [r7, #32]
 800789e:	4413      	add	r3, r2
 80078a0:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80078a4:	461a      	mov	r2, r3
 80078a6:	2300      	movs	r3, #0
 80078a8:	6053      	str	r3, [r2, #4]
 80078aa:	e000      	b.n	80078ae <USB_HC_StartXfer+0x3ea>
          break;
 80078ac:	bf00      	nop
  }

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80078ae:	69fb      	ldr	r3, [r7, #28]
 80078b0:	015a      	lsls	r2, r3, #5
 80078b2:	6a3b      	ldr	r3, [r7, #32]
 80078b4:	4413      	add	r3, r2
 80078b6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80078ba:	681b      	ldr	r3, [r3, #0]
 80078bc:	613b      	str	r3, [r7, #16]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80078be:	693b      	ldr	r3, [r7, #16]
 80078c0:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80078c4:	613b      	str	r3, [r7, #16]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 80078c6:	68bb      	ldr	r3, [r7, #8]
 80078c8:	78db      	ldrb	r3, [r3, #3]
 80078ca:	2b00      	cmp	r3, #0
 80078cc:	d004      	beq.n	80078d8 <USB_HC_StartXfer+0x414>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 80078ce:	693b      	ldr	r3, [r7, #16]
 80078d0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80078d4:	613b      	str	r3, [r7, #16]
 80078d6:	e003      	b.n	80078e0 <USB_HC_StartXfer+0x41c>
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 80078d8:	693b      	ldr	r3, [r7, #16]
 80078da:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 80078de:	613b      	str	r3, [r7, #16]
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 80078e0:	693b      	ldr	r3, [r7, #16]
 80078e2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80078e6:	613b      	str	r3, [r7, #16]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 80078e8:	69fb      	ldr	r3, [r7, #28]
 80078ea:	015a      	lsls	r2, r3, #5
 80078ec:	6a3b      	ldr	r3, [r7, #32]
 80078ee:	4413      	add	r3, r2
 80078f0:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80078f4:	461a      	mov	r2, r3
 80078f6:	693b      	ldr	r3, [r7, #16]
 80078f8:	6013      	str	r3, [r2, #0]

  if (dma != 0U) /* dma mode */
 80078fa:	79fb      	ldrb	r3, [r7, #7]
 80078fc:	2b00      	cmp	r3, #0
 80078fe:	d003      	beq.n	8007908 <USB_HC_StartXfer+0x444>
  {
    return HAL_OK;
 8007900:	2300      	movs	r3, #0
 8007902:	e055      	b.n	80079b0 <USB_HC_StartXfer+0x4ec>
 8007904:	1ff80000 	.word	0x1ff80000
  }

  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U) && (hc->do_csplit == 0U))
 8007908:	68bb      	ldr	r3, [r7, #8]
 800790a:	78db      	ldrb	r3, [r3, #3]
 800790c:	2b00      	cmp	r3, #0
 800790e:	d14e      	bne.n	80079ae <USB_HC_StartXfer+0x4ea>
 8007910:	68bb      	ldr	r3, [r7, #8]
 8007912:	6a1b      	ldr	r3, [r3, #32]
 8007914:	2b00      	cmp	r3, #0
 8007916:	d04a      	beq.n	80079ae <USB_HC_StartXfer+0x4ea>
 8007918:	68bb      	ldr	r3, [r7, #8]
 800791a:	79db      	ldrb	r3, [r3, #7]
 800791c:	2b00      	cmp	r3, #0
 800791e:	d146      	bne.n	80079ae <USB_HC_StartXfer+0x4ea>
  {
    switch (hc->ep_type)
 8007920:	68bb      	ldr	r3, [r7, #8]
 8007922:	7c9b      	ldrb	r3, [r3, #18]
 8007924:	2b03      	cmp	r3, #3
 8007926:	d831      	bhi.n	800798c <USB_HC_StartXfer+0x4c8>
 8007928:	a201      	add	r2, pc, #4	@ (adr r2, 8007930 <USB_HC_StartXfer+0x46c>)
 800792a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800792e:	bf00      	nop
 8007930:	08007941 	.word	0x08007941
 8007934:	08007965 	.word	0x08007965
 8007938:	08007941 	.word	0x08007941
 800793c:	08007965 	.word	0x08007965
    {
      /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:

        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007940:	68bb      	ldr	r3, [r7, #8]
 8007942:	6a1b      	ldr	r3, [r3, #32]
 8007944:	3303      	adds	r3, #3
 8007946:	089b      	lsrs	r3, r3, #2
 8007948:	82fb      	strh	r3, [r7, #22]

        /* check if there is enough space in FIFO space */
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 800794a:	8afa      	ldrh	r2, [r7, #22]
 800794c:	68fb      	ldr	r3, [r7, #12]
 800794e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007950:	b29b      	uxth	r3, r3
 8007952:	429a      	cmp	r2, r3
 8007954:	d91c      	bls.n	8007990 <USB_HC_StartXfer+0x4cc>
        {
          /* need to process data in nptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8007956:	68fb      	ldr	r3, [r7, #12]
 8007958:	699b      	ldr	r3, [r3, #24]
 800795a:	f043 0220 	orr.w	r2, r3, #32
 800795e:	68fb      	ldr	r3, [r7, #12]
 8007960:	619a      	str	r2, [r3, #24]
        }
        break;
 8007962:	e015      	b.n	8007990 <USB_HC_StartXfer+0x4cc>

      /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8007964:	68bb      	ldr	r3, [r7, #8]
 8007966:	6a1b      	ldr	r3, [r3, #32]
 8007968:	3303      	adds	r3, #3
 800796a:	089b      	lsrs	r3, r3, #2
 800796c:	82fb      	strh	r3, [r7, #22]
        /* check if there is enough space in FIFO space */
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800796e:	8afa      	ldrh	r2, [r7, #22]
 8007970:	6a3b      	ldr	r3, [r7, #32]
 8007972:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007976:	691b      	ldr	r3, [r3, #16]
 8007978:	b29b      	uxth	r3, r3
 800797a:	429a      	cmp	r2, r3
 800797c:	d90a      	bls.n	8007994 <USB_HC_StartXfer+0x4d0>
        {
          /* need to process data in ptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 800797e:	68fb      	ldr	r3, [r7, #12]
 8007980:	699b      	ldr	r3, [r3, #24]
 8007982:	f043 6280 	orr.w	r2, r3, #67108864	@ 0x4000000
 8007986:	68fb      	ldr	r3, [r7, #12]
 8007988:	619a      	str	r2, [r3, #24]
        }
        break;
 800798a:	e003      	b.n	8007994 <USB_HC_StartXfer+0x4d0>

      default:
        break;
 800798c:	bf00      	nop
 800798e:	e002      	b.n	8007996 <USB_HC_StartXfer+0x4d2>
        break;
 8007990:	bf00      	nop
 8007992:	e000      	b.n	8007996 <USB_HC_StartXfer+0x4d2>
        break;
 8007994:	bf00      	nop
    }

    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 8007996:	68bb      	ldr	r3, [r7, #8]
 8007998:	6999      	ldr	r1, [r3, #24]
 800799a:	68bb      	ldr	r3, [r7, #8]
 800799c:	785a      	ldrb	r2, [r3, #1]
 800799e:	68bb      	ldr	r3, [r7, #8]
 80079a0:	6a1b      	ldr	r3, [r3, #32]
 80079a2:	b29b      	uxth	r3, r3
 80079a4:	2000      	movs	r0, #0
 80079a6:	9000      	str	r0, [sp, #0]
 80079a8:	68f8      	ldr	r0, [r7, #12]
 80079aa:	f7ff f9c9 	bl	8006d40 <USB_WritePacket>
  }

  return HAL_OK;
 80079ae:	2300      	movs	r3, #0
}
 80079b0:	4618      	mov	r0, r3
 80079b2:	3728      	adds	r7, #40	@ 0x28
 80079b4:	46bd      	mov	sp, r7
 80079b6:	bd80      	pop	{r7, pc}

080079b8 <USB_HC_ReadInterrupt>:
  * @brief Read all host channel interrupts status
  * @param  USBx  Selected device
  * @retval HAL state
  */
uint32_t USB_HC_ReadInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 80079b8:	b480      	push	{r7}
 80079ba:	b085      	sub	sp, #20
 80079bc:	af00      	add	r7, sp, #0
 80079be:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80079c0:	687b      	ldr	r3, [r7, #4]
 80079c2:	60fb      	str	r3, [r7, #12]

  return ((USBx_HOST->HAINT) & 0xFFFFU);
 80079c4:	68fb      	ldr	r3, [r7, #12]
 80079c6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80079ca:	695b      	ldr	r3, [r3, #20]
 80079cc:	b29b      	uxth	r3, r3
}
 80079ce:	4618      	mov	r0, r3
 80079d0:	3714      	adds	r7, #20
 80079d2:	46bd      	mov	sp, r7
 80079d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079d8:	4770      	bx	lr

080079da <USB_HC_Halt>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Halt(const USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
{
 80079da:	b480      	push	{r7}
 80079dc:	b089      	sub	sp, #36	@ 0x24
 80079de:	af00      	add	r7, sp, #0
 80079e0:	6078      	str	r0, [r7, #4]
 80079e2:	460b      	mov	r3, r1
 80079e4:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80079e6:	687b      	ldr	r3, [r7, #4]
 80079e8:	61fb      	str	r3, [r7, #28]
  uint32_t hcnum = (uint32_t)hc_num;
 80079ea:	78fb      	ldrb	r3, [r7, #3]
 80079ec:	61bb      	str	r3, [r7, #24]
  volatile uint32_t count = 0U;
 80079ee:	2300      	movs	r3, #0
 80079f0:	60bb      	str	r3, [r7, #8]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 80079f2:	69bb      	ldr	r3, [r7, #24]
 80079f4:	015a      	lsls	r2, r3, #5
 80079f6:	69fb      	ldr	r3, [r7, #28]
 80079f8:	4413      	add	r3, r2
 80079fa:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 80079fe:	681b      	ldr	r3, [r3, #0]
 8007a00:	0c9b      	lsrs	r3, r3, #18
 8007a02:	f003 0303 	and.w	r3, r3, #3
 8007a06:	617b      	str	r3, [r7, #20]
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 8007a08:	69bb      	ldr	r3, [r7, #24]
 8007a0a:	015a      	lsls	r2, r3, #5
 8007a0c:	69fb      	ldr	r3, [r7, #28]
 8007a0e:	4413      	add	r3, r2
 8007a10:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a14:	681b      	ldr	r3, [r3, #0]
 8007a16:	0fdb      	lsrs	r3, r3, #31
 8007a18:	f003 0301 	and.w	r3, r3, #1
 8007a1c:	613b      	str	r3, [r7, #16]
  uint32_t SplitEna = (USBx_HC(hcnum)->HCSPLT & USB_OTG_HCSPLT_SPLITEN) >> 31;
 8007a1e:	69bb      	ldr	r3, [r7, #24]
 8007a20:	015a      	lsls	r2, r3, #5
 8007a22:	69fb      	ldr	r3, [r7, #28]
 8007a24:	4413      	add	r3, r2
 8007a26:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a2a:	685b      	ldr	r3, [r3, #4]
 8007a2c:	0fdb      	lsrs	r3, r3, #31
 8007a2e:	f003 0301 	and.w	r3, r3, #1
 8007a32:	60fb      	str	r3, [r7, #12]

  /* In buffer DMA, Channel disable must not be programmed for non-split periodic channels.
     At the end of the next uframe/frame (in the worst case), the core generates a channel halted
     and disables the channel automatically. */

  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 8007a34:	687b      	ldr	r3, [r7, #4]
 8007a36:	689b      	ldr	r3, [r3, #8]
 8007a38:	f003 0320 	and.w	r3, r3, #32
 8007a3c:	2b20      	cmp	r3, #32
 8007a3e:	d10d      	bne.n	8007a5c <USB_HC_Halt+0x82>
 8007a40:	68fb      	ldr	r3, [r7, #12]
 8007a42:	2b00      	cmp	r3, #0
 8007a44:	d10a      	bne.n	8007a5c <USB_HC_Halt+0x82>
 8007a46:	693b      	ldr	r3, [r7, #16]
 8007a48:	2b00      	cmp	r3, #0
 8007a4a:	d005      	beq.n	8007a58 <USB_HC_Halt+0x7e>
      ((ChannelEna == 0U) || (((HcEpType == HCCHAR_ISOC) || (HcEpType == HCCHAR_INTR)))))
 8007a4c:	697b      	ldr	r3, [r7, #20]
 8007a4e:	2b01      	cmp	r3, #1
 8007a50:	d002      	beq.n	8007a58 <USB_HC_Halt+0x7e>
 8007a52:	697b      	ldr	r3, [r7, #20]
 8007a54:	2b03      	cmp	r3, #3
 8007a56:	d101      	bne.n	8007a5c <USB_HC_Halt+0x82>
  {
    return HAL_OK;
 8007a58:	2300      	movs	r3, #0
 8007a5a:	e0d8      	b.n	8007c0e <USB_HC_Halt+0x234>
  }

  /* Check for space in the request queue to issue the halt. */
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8007a5c:	697b      	ldr	r3, [r7, #20]
 8007a5e:	2b00      	cmp	r3, #0
 8007a60:	d002      	beq.n	8007a68 <USB_HC_Halt+0x8e>
 8007a62:	697b      	ldr	r3, [r7, #20]
 8007a64:	2b02      	cmp	r3, #2
 8007a66:	d173      	bne.n	8007b50 <USB_HC_Halt+0x176>
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8007a68:	69bb      	ldr	r3, [r7, #24]
 8007a6a:	015a      	lsls	r2, r3, #5
 8007a6c:	69fb      	ldr	r3, [r7, #28]
 8007a6e:	4413      	add	r3, r2
 8007a70:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007a74:	681b      	ldr	r3, [r3, #0]
 8007a76:	69ba      	ldr	r2, [r7, #24]
 8007a78:	0151      	lsls	r1, r2, #5
 8007a7a:	69fa      	ldr	r2, [r7, #28]
 8007a7c:	440a      	add	r2, r1
 8007a7e:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007a82:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007a86:	6013      	str	r3, [r2, #0]

    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007a88:	687b      	ldr	r3, [r7, #4]
 8007a8a:	689b      	ldr	r3, [r3, #8]
 8007a8c:	f003 0320 	and.w	r3, r3, #32
 8007a90:	2b00      	cmp	r3, #0
 8007a92:	d14a      	bne.n	8007b2a <USB_HC_Halt+0x150>
    {
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8007a94:	687b      	ldr	r3, [r7, #4]
 8007a96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007a98:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8007a9c:	2b00      	cmp	r3, #0
 8007a9e:	d133      	bne.n	8007b08 <USB_HC_Halt+0x12e>
      {
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007aa0:	69bb      	ldr	r3, [r7, #24]
 8007aa2:	015a      	lsls	r2, r3, #5
 8007aa4:	69fb      	ldr	r3, [r7, #28]
 8007aa6:	4413      	add	r3, r2
 8007aa8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007aac:	681b      	ldr	r3, [r3, #0]
 8007aae:	69ba      	ldr	r2, [r7, #24]
 8007ab0:	0151      	lsls	r1, r2, #5
 8007ab2:	69fa      	ldr	r2, [r7, #28]
 8007ab4:	440a      	add	r2, r1
 8007ab6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007aba:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007abe:	6013      	str	r3, [r2, #0]
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007ac0:	69bb      	ldr	r3, [r7, #24]
 8007ac2:	015a      	lsls	r2, r3, #5
 8007ac4:	69fb      	ldr	r3, [r7, #28]
 8007ac6:	4413      	add	r3, r2
 8007ac8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007acc:	681b      	ldr	r3, [r3, #0]
 8007ace:	69ba      	ldr	r2, [r7, #24]
 8007ad0:	0151      	lsls	r1, r2, #5
 8007ad2:	69fa      	ldr	r2, [r7, #28]
 8007ad4:	440a      	add	r2, r1
 8007ad6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007ada:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007ade:	6013      	str	r3, [r2, #0]
        do
        {
          count++;
 8007ae0:	68bb      	ldr	r3, [r7, #8]
 8007ae2:	3301      	adds	r3, #1
 8007ae4:	60bb      	str	r3, [r7, #8]

          if (count > 1000U)
 8007ae6:	68bb      	ldr	r3, [r7, #8]
 8007ae8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007aec:	d82e      	bhi.n	8007b4c <USB_HC_Halt+0x172>
          {
            break;
          }
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007aee:	69bb      	ldr	r3, [r7, #24]
 8007af0:	015a      	lsls	r2, r3, #5
 8007af2:	69fb      	ldr	r3, [r7, #28]
 8007af4:	4413      	add	r3, r2
 8007af6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007afa:	681b      	ldr	r3, [r3, #0]
 8007afc:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007b00:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007b04:	d0ec      	beq.n	8007ae0 <USB_HC_Halt+0x106>
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007b06:	e081      	b.n	8007c0c <USB_HC_Halt+0x232>
      }
      else
      {
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007b08:	69bb      	ldr	r3, [r7, #24]
 8007b0a:	015a      	lsls	r2, r3, #5
 8007b0c:	69fb      	ldr	r3, [r7, #28]
 8007b0e:	4413      	add	r3, r2
 8007b10:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007b14:	681b      	ldr	r3, [r3, #0]
 8007b16:	69ba      	ldr	r2, [r7, #24]
 8007b18:	0151      	lsls	r1, r2, #5
 8007b1a:	69fa      	ldr	r2, [r7, #28]
 8007b1c:	440a      	add	r2, r1
 8007b1e:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007b22:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007b26:	6013      	str	r3, [r2, #0]
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007b28:	e070      	b.n	8007c0c <USB_HC_Halt+0x232>
      }
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007b2a:	69bb      	ldr	r3, [r7, #24]
 8007b2c:	015a      	lsls	r2, r3, #5
 8007b2e:	69fb      	ldr	r3, [r7, #28]
 8007b30:	4413      	add	r3, r2
 8007b32:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007b36:	681b      	ldr	r3, [r3, #0]
 8007b38:	69ba      	ldr	r2, [r7, #24]
 8007b3a:	0151      	lsls	r1, r2, #5
 8007b3c:	69fa      	ldr	r2, [r7, #28]
 8007b3e:	440a      	add	r2, r1
 8007b40:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007b44:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007b48:	6013      	str	r3, [r2, #0]
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007b4a:	e05f      	b.n	8007c0c <USB_HC_Halt+0x232>
            break;
 8007b4c:	bf00      	nop
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8007b4e:	e05d      	b.n	8007c0c <USB_HC_Halt+0x232>
    }
  }
  else
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8007b50:	69bb      	ldr	r3, [r7, #24]
 8007b52:	015a      	lsls	r2, r3, #5
 8007b54:	69fb      	ldr	r3, [r7, #28]
 8007b56:	4413      	add	r3, r2
 8007b58:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007b5c:	681b      	ldr	r3, [r3, #0]
 8007b5e:	69ba      	ldr	r2, [r7, #24]
 8007b60:	0151      	lsls	r1, r2, #5
 8007b62:	69fa      	ldr	r2, [r7, #28]
 8007b64:	440a      	add	r2, r1
 8007b66:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007b6a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007b6e:	6013      	str	r3, [r2, #0]

    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8007b70:	69fb      	ldr	r3, [r7, #28]
 8007b72:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007b76:	691b      	ldr	r3, [r3, #16]
 8007b78:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8007b7c:	2b00      	cmp	r3, #0
 8007b7e:	d133      	bne.n	8007be8 <USB_HC_Halt+0x20e>
    {
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8007b80:	69bb      	ldr	r3, [r7, #24]
 8007b82:	015a      	lsls	r2, r3, #5
 8007b84:	69fb      	ldr	r3, [r7, #28]
 8007b86:	4413      	add	r3, r2
 8007b88:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007b8c:	681b      	ldr	r3, [r3, #0]
 8007b8e:	69ba      	ldr	r2, [r7, #24]
 8007b90:	0151      	lsls	r1, r2, #5
 8007b92:	69fa      	ldr	r2, [r7, #28]
 8007b94:	440a      	add	r2, r1
 8007b96:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007b9a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007b9e:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007ba0:	69bb      	ldr	r3, [r7, #24]
 8007ba2:	015a      	lsls	r2, r3, #5
 8007ba4:	69fb      	ldr	r3, [r7, #28]
 8007ba6:	4413      	add	r3, r2
 8007ba8:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007bac:	681b      	ldr	r3, [r3, #0]
 8007bae:	69ba      	ldr	r2, [r7, #24]
 8007bb0:	0151      	lsls	r1, r2, #5
 8007bb2:	69fa      	ldr	r2, [r7, #28]
 8007bb4:	440a      	add	r2, r1
 8007bb6:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007bba:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007bbe:	6013      	str	r3, [r2, #0]
      do
      {
        count++;
 8007bc0:	68bb      	ldr	r3, [r7, #8]
 8007bc2:	3301      	adds	r3, #1
 8007bc4:	60bb      	str	r3, [r7, #8]

        if (count > 1000U)
 8007bc6:	68bb      	ldr	r3, [r7, #8]
 8007bc8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007bcc:	d81d      	bhi.n	8007c0a <USB_HC_Halt+0x230>
        {
          break;
        }
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007bce:	69bb      	ldr	r3, [r7, #24]
 8007bd0:	015a      	lsls	r2, r3, #5
 8007bd2:	69fb      	ldr	r3, [r7, #28]
 8007bd4:	4413      	add	r3, r2
 8007bd6:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007bda:	681b      	ldr	r3, [r3, #0]
 8007bdc:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007be0:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007be4:	d0ec      	beq.n	8007bc0 <USB_HC_Halt+0x1e6>
 8007be6:	e011      	b.n	8007c0c <USB_HC_Halt+0x232>
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8007be8:	69bb      	ldr	r3, [r7, #24]
 8007bea:	015a      	lsls	r2, r3, #5
 8007bec:	69fb      	ldr	r3, [r7, #28]
 8007bee:	4413      	add	r3, r2
 8007bf0:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007bf4:	681b      	ldr	r3, [r3, #0]
 8007bf6:	69ba      	ldr	r2, [r7, #24]
 8007bf8:	0151      	lsls	r1, r2, #5
 8007bfa:	69fa      	ldr	r2, [r7, #28]
 8007bfc:	440a      	add	r2, r1
 8007bfe:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007c02:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007c06:	6013      	str	r3, [r2, #0]
 8007c08:	e000      	b.n	8007c0c <USB_HC_Halt+0x232>
          break;
 8007c0a:	bf00      	nop
    }
  }

  return HAL_OK;
 8007c0c:	2300      	movs	r3, #0
}
 8007c0e:	4618      	mov	r0, r3
 8007c10:	3724      	adds	r7, #36	@ 0x24
 8007c12:	46bd      	mov	sp, r7
 8007c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c18:	4770      	bx	lr
	...

08007c1c <USB_DoPing>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_DoPing(const USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
{
 8007c1c:	b480      	push	{r7}
 8007c1e:	b087      	sub	sp, #28
 8007c20:	af00      	add	r7, sp, #0
 8007c22:	6078      	str	r0, [r7, #4]
 8007c24:	460b      	mov	r3, r1
 8007c26:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007c28:	687b      	ldr	r3, [r7, #4]
 8007c2a:	617b      	str	r3, [r7, #20]
  uint32_t chnum = (uint32_t)ch_num;
 8007c2c:	78fb      	ldrb	r3, [r7, #3]
 8007c2e:	613b      	str	r3, [r7, #16]
  uint32_t num_packets = 1U;
 8007c30:	2301      	movs	r3, #1
 8007c32:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8007c34:	68fb      	ldr	r3, [r7, #12]
 8007c36:	04da      	lsls	r2, r3, #19
 8007c38:	4b15      	ldr	r3, [pc, #84]	@ (8007c90 <USB_DoPing+0x74>)
 8007c3a:	4013      	ands	r3, r2
 8007c3c:	693a      	ldr	r2, [r7, #16]
 8007c3e:	0151      	lsls	r1, r2, #5
 8007c40:	697a      	ldr	r2, [r7, #20]
 8007c42:	440a      	add	r2, r1
 8007c44:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
 8007c48:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007c4c:	6113      	str	r3, [r2, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 8007c4e:	693b      	ldr	r3, [r7, #16]
 8007c50:	015a      	lsls	r2, r3, #5
 8007c52:	697b      	ldr	r3, [r7, #20]
 8007c54:	4413      	add	r3, r2
 8007c56:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007c5a:	681b      	ldr	r3, [r3, #0]
 8007c5c:	60bb      	str	r3, [r7, #8]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8007c5e:	68bb      	ldr	r3, [r7, #8]
 8007c60:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8007c64:	60bb      	str	r3, [r7, #8]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8007c66:	68bb      	ldr	r3, [r7, #8]
 8007c68:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007c6c:	60bb      	str	r3, [r7, #8]
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8007c6e:	693b      	ldr	r3, [r7, #16]
 8007c70:	015a      	lsls	r2, r3, #5
 8007c72:	697b      	ldr	r3, [r7, #20]
 8007c74:	4413      	add	r3, r2
 8007c76:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007c7a:	461a      	mov	r2, r3
 8007c7c:	68bb      	ldr	r3, [r7, #8]
 8007c7e:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8007c80:	2300      	movs	r3, #0
}
 8007c82:	4618      	mov	r0, r3
 8007c84:	371c      	adds	r7, #28
 8007c86:	46bd      	mov	sp, r7
 8007c88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c8c:	4770      	bx	lr
 8007c8e:	bf00      	nop
 8007c90:	1ff80000 	.word	0x1ff80000

08007c94 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 8007c94:	b580      	push	{r7, lr}
 8007c96:	b088      	sub	sp, #32
 8007c98:	af00      	add	r7, sp, #0
 8007c9a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8007c9c:	2300      	movs	r3, #0
 8007c9e:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007ca0:	687b      	ldr	r3, [r7, #4]
 8007ca2:	617b      	str	r3, [r7, #20]
  volatile uint32_t count = 0U;
 8007ca4:	2300      	movs	r3, #0
 8007ca6:	60fb      	str	r3, [r7, #12]
  uint32_t value;
  uint32_t i;

  (void)USB_DisableGlobalInt(USBx);
 8007ca8:	6878      	ldr	r0, [r7, #4]
 8007caa:	f7fe ff8c 	bl	8006bc6 <USB_DisableGlobalInt>

  /* Flush USB FIFO */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8007cae:	2110      	movs	r1, #16
 8007cb0:	6878      	ldr	r0, [r7, #4]
 8007cb2:	f7fe ffe5 	bl	8006c80 <USB_FlushTxFifo>
 8007cb6:	4603      	mov	r3, r0
 8007cb8:	2b00      	cmp	r3, #0
 8007cba:	d001      	beq.n	8007cc0 <USB_StopHost+0x2c>
  {
    ret = HAL_ERROR;
 8007cbc:	2301      	movs	r3, #1
 8007cbe:	77fb      	strb	r3, [r7, #31]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8007cc0:	6878      	ldr	r0, [r7, #4]
 8007cc2:	f7ff f80f 	bl	8006ce4 <USB_FlushRxFifo>
 8007cc6:	4603      	mov	r3, r0
 8007cc8:	2b00      	cmp	r3, #0
 8007cca:	d001      	beq.n	8007cd0 <USB_StopHost+0x3c>
  {
    ret = HAL_ERROR;
 8007ccc:	2301      	movs	r3, #1
 8007cce:	77fb      	strb	r3, [r7, #31]
  }

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
 8007cd0:	2300      	movs	r3, #0
 8007cd2:	61bb      	str	r3, [r7, #24]
 8007cd4:	e01f      	b.n	8007d16 <USB_StopHost+0x82>
  {
    value = USBx_HC(i)->HCCHAR;
 8007cd6:	69bb      	ldr	r3, [r7, #24]
 8007cd8:	015a      	lsls	r2, r3, #5
 8007cda:	697b      	ldr	r3, [r7, #20]
 8007cdc:	4413      	add	r3, r2
 8007cde:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007ce2:	681b      	ldr	r3, [r3, #0]
 8007ce4:	613b      	str	r3, [r7, #16]
    value |=  USB_OTG_HCCHAR_CHDIS;
 8007ce6:	693b      	ldr	r3, [r7, #16]
 8007ce8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007cec:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_CHENA;
 8007cee:	693b      	ldr	r3, [r7, #16]
 8007cf0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8007cf4:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007cf6:	693b      	ldr	r3, [r7, #16]
 8007cf8:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007cfc:	613b      	str	r3, [r7, #16]
    USBx_HC(i)->HCCHAR = value;
 8007cfe:	69bb      	ldr	r3, [r7, #24]
 8007d00:	015a      	lsls	r2, r3, #5
 8007d02:	697b      	ldr	r3, [r7, #20]
 8007d04:	4413      	add	r3, r2
 8007d06:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d0a:	461a      	mov	r2, r3
 8007d0c:	693b      	ldr	r3, [r7, #16]
 8007d0e:	6013      	str	r3, [r2, #0]
  for (i = 0U; i <= 15U; i++)
 8007d10:	69bb      	ldr	r3, [r7, #24]
 8007d12:	3301      	adds	r3, #1
 8007d14:	61bb      	str	r3, [r7, #24]
 8007d16:	69bb      	ldr	r3, [r7, #24]
 8007d18:	2b0f      	cmp	r3, #15
 8007d1a:	d9dc      	bls.n	8007cd6 <USB_StopHost+0x42>
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
 8007d1c:	2300      	movs	r3, #0
 8007d1e:	61bb      	str	r3, [r7, #24]
 8007d20:	e034      	b.n	8007d8c <USB_StopHost+0xf8>
  {
    value = USBx_HC(i)->HCCHAR;
 8007d22:	69bb      	ldr	r3, [r7, #24]
 8007d24:	015a      	lsls	r2, r3, #5
 8007d26:	697b      	ldr	r3, [r7, #20]
 8007d28:	4413      	add	r3, r2
 8007d2a:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d2e:	681b      	ldr	r3, [r3, #0]
 8007d30:	613b      	str	r3, [r7, #16]
    value |= USB_OTG_HCCHAR_CHDIS;
 8007d32:	693b      	ldr	r3, [r7, #16]
 8007d34:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007d38:	613b      	str	r3, [r7, #16]
    value |= USB_OTG_HCCHAR_CHENA;
 8007d3a:	693b      	ldr	r3, [r7, #16]
 8007d3c:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8007d40:	613b      	str	r3, [r7, #16]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8007d42:	693b      	ldr	r3, [r7, #16]
 8007d44:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8007d48:	613b      	str	r3, [r7, #16]
    USBx_HC(i)->HCCHAR = value;
 8007d4a:	69bb      	ldr	r3, [r7, #24]
 8007d4c:	015a      	lsls	r2, r3, #5
 8007d4e:	697b      	ldr	r3, [r7, #20]
 8007d50:	4413      	add	r3, r2
 8007d52:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d56:	461a      	mov	r2, r3
 8007d58:	693b      	ldr	r3, [r7, #16]
 8007d5a:	6013      	str	r3, [r2, #0]

    do
    {
      count++;
 8007d5c:	68fb      	ldr	r3, [r7, #12]
 8007d5e:	3301      	adds	r3, #1
 8007d60:	60fb      	str	r3, [r7, #12]

      if (count > 1000U)
 8007d62:	68fb      	ldr	r3, [r7, #12]
 8007d64:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007d68:	d80c      	bhi.n	8007d84 <USB_StopHost+0xf0>
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8007d6a:	69bb      	ldr	r3, [r7, #24]
 8007d6c:	015a      	lsls	r2, r3, #5
 8007d6e:	697b      	ldr	r3, [r7, #20]
 8007d70:	4413      	add	r3, r2
 8007d72:	f503 63a0 	add.w	r3, r3, #1280	@ 0x500
 8007d76:	681b      	ldr	r3, [r3, #0]
 8007d78:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8007d7c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8007d80:	d0ec      	beq.n	8007d5c <USB_StopHost+0xc8>
 8007d82:	e000      	b.n	8007d86 <USB_StopHost+0xf2>
        break;
 8007d84:	bf00      	nop
  for (i = 0U; i <= 15U; i++)
 8007d86:	69bb      	ldr	r3, [r7, #24]
 8007d88:	3301      	adds	r3, #1
 8007d8a:	61bb      	str	r3, [r7, #24]
 8007d8c:	69bb      	ldr	r3, [r7, #24]
 8007d8e:	2b0f      	cmp	r3, #15
 8007d90:	d9c7      	bls.n	8007d22 <USB_StopHost+0x8e>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = CLEAR_INTERRUPT_MASK;
 8007d92:	697b      	ldr	r3, [r7, #20]
 8007d94:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8007d98:	461a      	mov	r2, r3
 8007d9a:	f04f 33ff 	mov.w	r3, #4294967295
 8007d9e:	6153      	str	r3, [r2, #20]
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 8007da0:	687b      	ldr	r3, [r7, #4]
 8007da2:	f04f 32ff 	mov.w	r2, #4294967295
 8007da6:	615a      	str	r2, [r3, #20]

  (void)USB_EnableGlobalInt(USBx);
 8007da8:	6878      	ldr	r0, [r7, #4]
 8007daa:	f7fe fefb 	bl	8006ba4 <USB_EnableGlobalInt>

  return ret;
 8007dae:	7ffb      	ldrb	r3, [r7, #31]
}
 8007db0:	4618      	mov	r0, r3
 8007db2:	3720      	adds	r7, #32
 8007db4:	46bd      	mov	sp, r7
 8007db6:	bd80      	pop	{r7, pc}

08007db8 <fwrite_DWORD>:
/* @return				- the status code of the operation												*/
/*																										*/
/* @Note					- This function writes exactly 4 bytes to the file								*/
/********************************************************************************************************/
FRESULT fwrite_DWORD(FIL * file, DWORD word)
{
 8007db8:	b580      	push	{r7, lr}
 8007dba:	b084      	sub	sp, #16
 8007dbc:	af00      	add	r7, sp, #0
 8007dbe:	6078      	str	r0, [r7, #4]
 8007dc0:	6039      	str	r1, [r7, #0]
	unsigned char * p;
	UINT bw;

	p = (unsigned char *)&word;
 8007dc2:	463b      	mov	r3, r7
 8007dc4:	60fb      	str	r3, [r7, #12]

	return (f_write(file, p, 4, &bw));
 8007dc6:	f107 0308 	add.w	r3, r7, #8
 8007dca:	2204      	movs	r2, #4
 8007dcc:	68f9      	ldr	r1, [r7, #12]
 8007dce:	6878      	ldr	r0, [r7, #4]
 8007dd0:	f009 fdfb 	bl	80119ca <f_write>
 8007dd4:	4603      	mov	r3, r0
}
 8007dd6:	4618      	mov	r0, r3
 8007dd8:	3710      	adds	r7, #16
 8007dda:	46bd      	mov	sp, r7
 8007ddc:	bd80      	pop	{r7, pc}

08007dde <fwrite_WORD>:
/* @return				- the status code of the operation												*/
/*																										*/
/* @Note					- This function writes exactly 2 bytes to the file								*/
/********************************************************************************************************/
FRESULT fwrite_WORD(FIL * file, WORD word)
{
 8007dde:	b580      	push	{r7, lr}
 8007de0:	b084      	sub	sp, #16
 8007de2:	af00      	add	r7, sp, #0
 8007de4:	6078      	str	r0, [r7, #4]
 8007de6:	460b      	mov	r3, r1
 8007de8:	807b      	strh	r3, [r7, #2]
	unsigned char * p;
	UINT bw;

	p = (unsigned char*)&word;
 8007dea:	1cbb      	adds	r3, r7, #2
 8007dec:	60fb      	str	r3, [r7, #12]
	return (f_write(file, p, 2, &bw));
 8007dee:	f107 0308 	add.w	r3, r7, #8
 8007df2:	2202      	movs	r2, #2
 8007df4:	68f9      	ldr	r1, [r7, #12]
 8007df6:	6878      	ldr	r0, [r7, #4]
 8007df8:	f009 fde7 	bl	80119ca <f_write>
 8007dfc:	4603      	mov	r3, r0

}
 8007dfe:	4618      	mov	r0, r3
 8007e00:	3710      	adds	r7, #16
 8007e02:	46bd      	mov	sp, r7
 8007e04:	bd80      	pop	{r7, pc}
	...

08007e08 <set_avi_output_status>:
/* @return				- none																			*/
/*																										*/
/* @Note					- This function updates a global variable that controls AVI recording			*/
/********************************************************************************************************/
void set_avi_output_status(uint8_t stat)
{
 8007e08:	b480      	push	{r7}
 8007e0a:	b083      	sub	sp, #12
 8007e0c:	af00      	add	r7, sp, #0
 8007e0e:	4603      	mov	r3, r0
 8007e10:	71fb      	strb	r3, [r7, #7]
	bAviStartRecording = stat;
 8007e12:	4a04      	ldr	r2, [pc, #16]	@ (8007e24 <set_avi_output_status+0x1c>)
 8007e14:	79fb      	ldrb	r3, [r7, #7]
 8007e16:	7013      	strb	r3, [r2, #0]
}
 8007e18:	bf00      	nop
 8007e1a:	370c      	adds	r7, #12
 8007e1c:	46bd      	mov	sp, r7
 8007e1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e22:	4770      	bx	lr
 8007e24:	200028ea 	.word	0x200028ea

08007e28 <read_avi_output_status>:
/* @return				- current status of AVI output													*/
/*																										*/
/* @Note					- This function returns the value of a global variable that controls recording	*/
/********************************************************************************************************/
uint8_t read_avi_output_status()
{
 8007e28:	b480      	push	{r7}
 8007e2a:	af00      	add	r7, sp, #0
	return bAviStartRecording;
 8007e2c:	4b03      	ldr	r3, [pc, #12]	@ (8007e3c <read_avi_output_status+0x14>)
 8007e2e:	781b      	ldrb	r3, [r3, #0]
}
 8007e30:	4618      	mov	r0, r3
 8007e32:	46bd      	mov	sp, r7
 8007e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e38:	4770      	bx	lr
 8007e3a:	bf00      	nop
 8007e3c:	200028ea 	.word	0x200028ea

08007e40 <decode_jpeg_to_tft>:
/* @return				- none																			*/
/*																										*/
/* @Note					- This function decodes the JPEG image and handles the display process			*/
/********************************************************************************************************/
void decode_jpeg_to_tft(uint8_t *buff, uint32_t len)
{
 8007e40:	b580      	push	{r7, lr}
 8007e42:	b084      	sub	sp, #16
 8007e44:	af00      	add	r7, sp, #0
 8007e46:	6078      	str	r0, [r7, #4]
 8007e48:	6039      	str	r1, [r7, #0]
	uint32_t line_counter = 0;
 8007e4a:	2300      	movs	r3, #0
 8007e4c:	60fb      	str	r3, [r7, #12]
	uint32_t i = 0;
 8007e4e:	2300      	movs	r3, #0
 8007e50:	60bb      	str	r3, [r7, #8]

	buffer[0] = rowBuff;
 8007e52:	4b49      	ldr	r3, [pc, #292]	@ (8007f78 <decode_jpeg_to_tft+0x138>)
 8007e54:	4a49      	ldr	r2, [pc, #292]	@ (8007f7c <decode_jpeg_to_tft+0x13c>)
 8007e56:	601a      	str	r2, [r3, #0]

	// JPEG must begin with 0xFFD8 and end with 0xFFD9
	if (!(buff[0] == 0xFF && buff[1] == 0xD8 && buff[len-2]==0xFF && buff[len-1] == 0xD9))
 8007e58:	687b      	ldr	r3, [r7, #4]
 8007e5a:	781b      	ldrb	r3, [r3, #0]
 8007e5c:	2bff      	cmp	r3, #255	@ 0xff
 8007e5e:	f040 8087 	bne.w	8007f70 <decode_jpeg_to_tft+0x130>
 8007e62:	687b      	ldr	r3, [r7, #4]
 8007e64:	3301      	adds	r3, #1
 8007e66:	781b      	ldrb	r3, [r3, #0]
 8007e68:	2bd8      	cmp	r3, #216	@ 0xd8
 8007e6a:	f040 8081 	bne.w	8007f70 <decode_jpeg_to_tft+0x130>
 8007e6e:	683b      	ldr	r3, [r7, #0]
 8007e70:	3b02      	subs	r3, #2
 8007e72:	687a      	ldr	r2, [r7, #4]
 8007e74:	4413      	add	r3, r2
 8007e76:	781b      	ldrb	r3, [r3, #0]
 8007e78:	2bff      	cmp	r3, #255	@ 0xff
 8007e7a:	d179      	bne.n	8007f70 <decode_jpeg_to_tft+0x130>
 8007e7c:	683b      	ldr	r3, [r7, #0]
 8007e7e:	3b01      	subs	r3, #1
 8007e80:	687a      	ldr	r2, [r7, #4]
 8007e82:	4413      	add	r3, r2
 8007e84:	781b      	ldrb	r3, [r3, #0]
 8007e86:	2bd9      	cmp	r3, #217	@ 0xd9
 8007e88:	d172      	bne.n	8007f70 <decode_jpeg_to_tft+0x130>
		return;
	cinfo.err = jpeg_std_error(&jerr);
 8007e8a:	483d      	ldr	r0, [pc, #244]	@ (8007f80 <decode_jpeg_to_tft+0x140>)
 8007e8c:	f016 fc4a 	bl	801e724 <jpeg_std_error>
 8007e90:	4603      	mov	r3, r0
 8007e92:	4a3c      	ldr	r2, [pc, #240]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007e94:	6013      	str	r3, [r2, #0]

	jpeg_create_decompress(&cinfo);
 8007e96:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8007e9a:	2150      	movs	r1, #80	@ 0x50
 8007e9c:	4839      	ldr	r0, [pc, #228]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007e9e:	f00b f85e 	bl	8012f5e <jpeg_CreateDecompress>

	jpeg_mem_src(&cinfo, buff, len);
 8007ea2:	683a      	ldr	r2, [r7, #0]
 8007ea4:	6879      	ldr	r1, [r7, #4]
 8007ea6:	4837      	ldr	r0, [pc, #220]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007ea8:	f00c fd90 	bl	80149cc <jpeg_mem_src>
	jpeg_read_header(&cinfo, TRUE);
 8007eac:	2101      	movs	r1, #1
 8007eae:	4835      	ldr	r0, [pc, #212]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007eb0:	f00b fa0c 	bl	80132cc <jpeg_read_header>
	//cinfo.scale_num=1;
	//cinfo.scale_denom=2;
	cinfo.dct_method = JDCT_IFAST;
 8007eb4:	4b33      	ldr	r3, [pc, #204]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007eb6:	2201      	movs	r2, #1
 8007eb8:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

	jpeg_start_decompress(&cinfo);
 8007ebc:	4831      	ldr	r0, [pc, #196]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007ebe:	f00b fb12 	bl	80134e6 <jpeg_start_decompress>
	//while (cinfo.output_scanline < cinfo.output_height && line_counter < 240)

	while (cinfo.output_scanline < cinfo.output_height && line_counter < 228) //240-12 (12 for menu)
 8007ec2:	e044      	b.n	8007f4e <decode_jpeg_to_tft+0x10e>
	{
		(void)jpeg_read_scanlines(&cinfo, buffer, 1);
 8007ec4:	2201      	movs	r2, #1
 8007ec6:	492c      	ldr	r1, [pc, #176]	@ (8007f78 <decode_jpeg_to_tft+0x138>)
 8007ec8:	482e      	ldr	r0, [pc, #184]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007eca:	f00b fbf4 	bl	80136b6 <jpeg_read_scanlines>

		RGB_matrix=(RGB_typedef*)buffer[0];
 8007ece:	4b2a      	ldr	r3, [pc, #168]	@ (8007f78 <decode_jpeg_to_tft+0x138>)
 8007ed0:	681b      	ldr	r3, [r3, #0]
 8007ed2:	4a2d      	ldr	r2, [pc, #180]	@ (8007f88 <decode_jpeg_to_tft+0x148>)
 8007ed4:	6013      	str	r3, [r2, #0]
		for(i = 0; i < cinfo.output_width ; i++)
 8007ed6:	2300      	movs	r3, #0
 8007ed8:	60bb      	str	r3, [r7, #8]
 8007eda:	e030      	b.n	8007f3e <decode_jpeg_to_tft+0xfe>
		{
			RGB16PixelColor = (uint16_t)
			(
				((RGB_matrix[i].R & 0x00F8) >> 3)|
 8007edc:	4b2a      	ldr	r3, [pc, #168]	@ (8007f88 <decode_jpeg_to_tft+0x148>)
 8007ede:	6819      	ldr	r1, [r3, #0]
 8007ee0:	68ba      	ldr	r2, [r7, #8]
 8007ee2:	4613      	mov	r3, r2
 8007ee4:	005b      	lsls	r3, r3, #1
 8007ee6:	4413      	add	r3, r2
 8007ee8:	440b      	add	r3, r1
 8007eea:	789b      	ldrb	r3, [r3, #2]
 8007eec:	08db      	lsrs	r3, r3, #3
 8007eee:	b2db      	uxtb	r3, r3
 8007ef0:	b219      	sxth	r1, r3
				((RGB_matrix[i].G & 0x00FC) << 3)|
 8007ef2:	4b25      	ldr	r3, [pc, #148]	@ (8007f88 <decode_jpeg_to_tft+0x148>)
 8007ef4:	6818      	ldr	r0, [r3, #0]
 8007ef6:	68ba      	ldr	r2, [r7, #8]
 8007ef8:	4613      	mov	r3, r2
 8007efa:	005b      	lsls	r3, r3, #1
 8007efc:	4413      	add	r3, r2
 8007efe:	4403      	add	r3, r0
 8007f00:	785b      	ldrb	r3, [r3, #1]
 8007f02:	00db      	lsls	r3, r3, #3
				((RGB_matrix[i].R & 0x00F8) >> 3)|
 8007f04:	b21b      	sxth	r3, r3
 8007f06:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 8007f0a:	b21b      	sxth	r3, r3
 8007f0c:	430b      	orrs	r3, r1
 8007f0e:	b219      	sxth	r1, r3
				((RGB_matrix[i].B & 0x00F8) << 8)
 8007f10:	4b1d      	ldr	r3, [pc, #116]	@ (8007f88 <decode_jpeg_to_tft+0x148>)
 8007f12:	6818      	ldr	r0, [r3, #0]
 8007f14:	68ba      	ldr	r2, [r7, #8]
 8007f16:	4613      	mov	r3, r2
 8007f18:	005b      	lsls	r3, r3, #1
 8007f1a:	4413      	add	r3, r2
 8007f1c:	4403      	add	r3, r0
 8007f1e:	781b      	ldrb	r3, [r3, #0]
 8007f20:	021b      	lsls	r3, r3, #8
				((RGB_matrix[i].G & 0x00FC) << 3)|
 8007f22:	b21b      	sxth	r3, r3
 8007f24:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8007f28:	f023 0307 	bic.w	r3, r3, #7
 8007f2c:	b21b      	sxth	r3, r3
 8007f2e:	430b      	orrs	r3, r1
 8007f30:	b21b      	sxth	r3, r3
			RGB16PixelColor = (uint16_t)
 8007f32:	b29a      	uxth	r2, r3
 8007f34:	4b15      	ldr	r3, [pc, #84]	@ (8007f8c <decode_jpeg_to_tft+0x14c>)
 8007f36:	801a      	strh	r2, [r3, #0]
		for(i = 0; i < cinfo.output_width ; i++)
 8007f38:	68bb      	ldr	r3, [r7, #8]
 8007f3a:	3301      	adds	r3, #1
 8007f3c:	60bb      	str	r3, [r7, #8]
 8007f3e:	4b11      	ldr	r3, [pc, #68]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007f40:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8007f42:	68ba      	ldr	r2, [r7, #8]
 8007f44:	429a      	cmp	r2, r3
 8007f46:	d3c9      	bcc.n	8007edc <decode_jpeg_to_tft+0x9c>
			);

		}

	  	line_counter++;
 8007f48:	68fb      	ldr	r3, [r7, #12]
 8007f4a:	3301      	adds	r3, #1
 8007f4c:	60fb      	str	r3, [r7, #12]
	while (cinfo.output_scanline < cinfo.output_height && line_counter < 228) //240-12 (12 for menu)
 8007f4e:	4b0d      	ldr	r3, [pc, #52]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007f50:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8007f54:	4b0b      	ldr	r3, [pc, #44]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007f56:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8007f58:	429a      	cmp	r2, r3
 8007f5a:	d202      	bcs.n	8007f62 <decode_jpeg_to_tft+0x122>
 8007f5c:	68fb      	ldr	r3, [r7, #12]
 8007f5e:	2be3      	cmp	r3, #227	@ 0xe3
 8007f60:	d9b0      	bls.n	8007ec4 <decode_jpeg_to_tft+0x84>

	}

	jpeg_finish_decompress(&cinfo);
 8007f62:	4808      	ldr	r0, [pc, #32]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007f64:	f00b fa5c 	bl	8013420 <jpeg_finish_decompress>

	jpeg_destroy_decompress(&cinfo);
 8007f68:	4806      	ldr	r0, [pc, #24]	@ (8007f84 <decode_jpeg_to_tft+0x144>)
 8007f6a:	f00b f881 	bl	8013070 <jpeg_destroy_decompress>
 8007f6e:	e000      	b.n	8007f72 <decode_jpeg_to_tft+0x132>
		return;
 8007f70:	bf00      	nop
}
 8007f72:	3710      	adds	r7, #16
 8007f74:	46bd      	mov	sp, r7
 8007f76:	bd80      	pop	{r7, pc}
 8007f78:	20002458 	.word	0x20002458
 8007f7c:	20002460 	.word	0x20002460
 8007f80:	20002860 	.word	0x20002860
 8007f84:	20002270 	.word	0x20002270
 8007f88:	200028e4 	.word	0x200028e4
 8007f8c:	200028e8 	.word	0x200028e8

08007f90 <output_avi_header>:
/*						  it for video data to be written. The header includes the RIFF chunk, AVI main */
/*						  header (avih), and stream header (strh) among others. The dwSize fields are   */
/*						placeholders and should be updated with actual values during the writing process*/
/********************************************************************************************************/
FRESULT output_avi_header(FIL *file, uint8_t fps, uint16_t width, uint16_t height)
{
 8007f90:	b580      	push	{r7, lr}
 8007f92:	b0c0      	sub	sp, #256	@ 0x100
 8007f94:	af00      	add	r7, sp, #0
 8007f96:	60f8      	str	r0, [r7, #12]
 8007f98:	4608      	mov	r0, r1
 8007f9a:	4611      	mov	r1, r2
 8007f9c:	461a      	mov	r2, r3
 8007f9e:	4603      	mov	r3, r0
 8007fa0:	72fb      	strb	r3, [r7, #11]
 8007fa2:	460b      	mov	r3, r1
 8007fa4:	813b      	strh	r3, [r7, #8]
 8007fa6:	4613      	mov	r3, r2
 8007fa8:	80fb      	strh	r3, [r7, #6]
	FRESULT res=FR_OK;
 8007faa:	2300      	movs	r3, #0
 8007fac:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	UINT bw;
	RIFF RIFF_LIST;


	RIFF_LIST.dwRIFF = 'RIFF';
 8007fb0:	4bd8      	ldr	r3, [pc, #864]	@ (8008314 <output_avi_header+0x384>)
 8007fb2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
	res = f_write(file, "RIFF", 4, &bw); //offset=0
 8007fb6:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8007fba:	2204      	movs	r2, #4
 8007fbc:	49d6      	ldr	r1, [pc, #856]	@ (8008318 <output_avi_header+0x388>)
 8007fbe:	68f8      	ldr	r0, [r7, #12]
 8007fc0:	f009 fd03 	bl	80119ca <f_write>
 8007fc4:	4603      	mov	r3, r0
 8007fc6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	//RIFF_LIST.dwSize =  150 + 12 + len + 8*frames + 8 + 4*4*frames;
	RIFF_LIST.dwSize =  0;
 8007fca:	2300      	movs	r3, #0
 8007fcc:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
	// must rewrite when stop_output at file offset  4;
	res = fwrite_DWORD(file, RIFF_LIST.dwSize); //offset+4=4
 8007fd0:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8007fd4:	4619      	mov	r1, r3
 8007fd6:	68f8      	ldr	r0, [r7, #12]
 8007fd8:	f7ff feee 	bl	8007db8 <fwrite_DWORD>
 8007fdc:	4603      	mov	r3, r0
 8007fde:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	RIFF_LIST.dwFourCC = 'AVI ';
 8007fe2:	4bce      	ldr	r3, [pc, #824]	@ (800831c <output_avi_header+0x38c>)
 8007fe4:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
	res = f_write(file, "AVI ", 4, &bw); //offset+4=8
 8007fe8:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8007fec:	2204      	movs	r2, #4
 8007fee:	49cc      	ldr	r1, [pc, #816]	@ (8008320 <output_avi_header+0x390>)
 8007ff0:	68f8      	ldr	r0, [r7, #12]
 8007ff2:	f009 fcea 	bl	80119ca <f_write>
 8007ff6:	4603      	mov	r3, r0
 8007ff8:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	// 	RIFF_LIST.data = WAIT WITH THIS

	LIST hdrl;
	hdrl.dwList = 'LIST';
 8007ffc:	4bc9      	ldr	r3, [pc, #804]	@ (8008324 <output_avi_header+0x394>)
 8007ffe:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
	res = f_write(file, "LIST", 4, &bw); //offset+4=12
 8008002:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008006:	2204      	movs	r2, #4
 8008008:	49c7      	ldr	r1, [pc, #796]	@ (8008328 <output_avi_header+0x398>)
 800800a:	68f8      	ldr	r0, [r7, #12]
 800800c:	f009 fcdd 	bl	80119ca <f_write>
 8008010:	4603      	mov	r3, r0
 8008012:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	hdrl.dwSize = 208;
 8008016:	23d0      	movs	r3, #208	@ 0xd0
 8008018:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
	res = fwrite_DWORD(file, hdrl.dwSize);//offset+4=16
 800801c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8008020:	4619      	mov	r1, r3
 8008022:	68f8      	ldr	r0, [r7, #12]
 8008024:	f7ff fec8 	bl	8007db8 <fwrite_DWORD>
 8008028:	4603      	mov	r3, r0
 800802a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	hdrl.dwFourCC = 'hdrl';
 800802e:	4bbf      	ldr	r3, [pc, #764]	@ (800832c <output_avi_header+0x39c>)
 8008030:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
	res = f_write(file, "hdrl", 4, &bw);//offset+4=20
 8008034:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008038:	2204      	movs	r2, #4
 800803a:	49bd      	ldr	r1, [pc, #756]	@ (8008330 <output_avi_header+0x3a0>)
 800803c:	68f8      	ldr	r0, [r7, #12]
 800803e:	f009 fcc4 	bl	80119ca <f_write>
 8008042:	4603      	mov	r3, r0
 8008044:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	MainAVIHeader avih;

	avih.dwFourCC = 'avih';
 8008048:	4bba      	ldr	r3, [pc, #744]	@ (8008334 <output_avi_header+0x3a4>)
 800804a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
	res = f_write(file, "avih", 4, &bw); //offset+4=24
 800804e:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008052:	2204      	movs	r2, #4
 8008054:	49b8      	ldr	r1, [pc, #736]	@ (8008338 <output_avi_header+0x3a8>)
 8008056:	68f8      	ldr	r0, [r7, #12]
 8008058:	f009 fcb7 	bl	80119ca <f_write>
 800805c:	4603      	mov	r3, r0
 800805e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwSize = 56;
 8008062:	2338      	movs	r3, #56	@ 0x38
 8008064:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
	res = fwrite_DWORD(file, avih.dwSize);//offset+4=28
 8008068:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 800806c:	4619      	mov	r1, r3
 800806e:	68f8      	ldr	r0, [r7, #12]
 8008070:	f7ff fea2 	bl	8007db8 <fwrite_DWORD>
 8008074:	4603      	mov	r3, r0
 8008076:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwMicroSecPerFrame = 1000000/fps;
 800807a:	7afb      	ldrb	r3, [r7, #11]
 800807c:	4aaf      	ldr	r2, [pc, #700]	@ (800833c <output_avi_header+0x3ac>)
 800807e:	fb92 f3f3 	sdiv	r3, r2, r3
 8008082:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
	res = fwrite_DWORD(file, avih.dwMicroSecPerFrame);//offset+4=32
 8008086:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 800808a:	4619      	mov	r1, r3
 800808c:	68f8      	ldr	r0, [r7, #12]
 800808e:	f7ff fe93 	bl	8007db8 <fwrite_DWORD>
 8008092:	4603      	mov	r3, r0
 8008094:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwMaxBytesPerSec = 7000;
 8008098:	f641 3358 	movw	r3, #7000	@ 0x1b58
 800809c:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
	res = fwrite_DWORD(file, avih.dwMaxBytesPerSec);//offset+4=36
 80080a0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80080a4:	4619      	mov	r1, r3
 80080a6:	68f8      	ldr	r0, [r7, #12]
 80080a8:	f7ff fe86 	bl	8007db8 <fwrite_DWORD>
 80080ac:	4603      	mov	r3, r0
 80080ae:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwPaddingGranularity = 0;
 80080b2:	2300      	movs	r3, #0
 80080b4:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
	res = fwrite_DWORD(file, avih.dwPaddingGranularity);//offset+4=40
 80080b8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80080bc:	4619      	mov	r1, r3
 80080be:	68f8      	ldr	r0, [r7, #12]
 80080c0:	f7ff fe7a 	bl	8007db8 <fwrite_DWORD>
 80080c4:	4603      	mov	r3, r0
 80080c6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	// dwFlags set to 16, do not know why!
	avih.dwFlags = 16;
 80080ca:	2310      	movs	r3, #16
 80080cc:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
	res = fwrite_DWORD(file, avih.dwFlags);//offset+4=44
 80080d0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80080d4:	4619      	mov	r1, r3
 80080d6:	68f8      	ldr	r0, [r7, #12]
 80080d8:	f7ff fe6e 	bl	8007db8 <fwrite_DWORD>
 80080dc:	4603      	mov	r3, r0
 80080de:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
///////////////////////////////
	avih.dwTotalFrames = 0;  // frames, offset ?, must rewrite
 80080e2:	2300      	movs	r3, #0
 80080e4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

	res = fwrite_DWORD(file, avih.dwTotalFrames);//offset+4=48
 80080e8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80080ec:	4619      	mov	r1, r3
 80080ee:	68f8      	ldr	r0, [r7, #12]
 80080f0:	f7ff fe62 	bl	8007db8 <fwrite_DWORD>
 80080f4:	4603      	mov	r3, r0
 80080f6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwInitialFrames = 0;
 80080fa:	2300      	movs	r3, #0
 80080fc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
	res = fwrite_DWORD(file, avih.dwInitialFrames);//offset+4=52
 8008100:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8008104:	4619      	mov	r1, r3
 8008106:	68f8      	ldr	r0, [r7, #12]
 8008108:	f7ff fe56 	bl	8007db8 <fwrite_DWORD>
 800810c:	4603      	mov	r3, r0
 800810e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwStreams = 1;
 8008112:	2301      	movs	r3, #1
 8008114:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
	res = fwrite_DWORD(file, avih.dwStreams);//offset+4=56
 8008118:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 800811c:	4619      	mov	r1, r3
 800811e:	68f8      	ldr	r0, [r7, #12]
 8008120:	f7ff fe4a 	bl	8007db8 <fwrite_DWORD>
 8008124:	4603      	mov	r3, r0
 8008126:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwSuggestedBufferSize = 0;
 800812a:	2300      	movs	r3, #0
 800812c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
	res = fwrite_DWORD(file, avih.dwSuggestedBufferSize);//offset+4=60
 8008130:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8008134:	4619      	mov	r1, r3
 8008136:	68f8      	ldr	r0, [r7, #12]
 8008138:	f7ff fe3e 	bl	8007db8 <fwrite_DWORD>
 800813c:	4603      	mov	r3, r0
 800813e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwWidth = width;
 8008142:	893b      	ldrh	r3, [r7, #8]
 8008144:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
	res = fwrite_DWORD(file, avih.dwWidth);//offset+4=64
 8008148:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800814c:	4619      	mov	r1, r3
 800814e:	68f8      	ldr	r0, [r7, #12]
 8008150:	f7ff fe32 	bl	8007db8 <fwrite_DWORD>
 8008154:	4603      	mov	r3, r0
 8008156:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwHeight = height;
 800815a:	88fb      	ldrh	r3, [r7, #6]
 800815c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
	res = fwrite_DWORD(file, avih.dwHeight);//offset+4=68
 8008160:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8008164:	4619      	mov	r1, r3
 8008166:	68f8      	ldr	r0, [r7, #12]
 8008168:	f7ff fe26 	bl	8007db8 <fwrite_DWORD>
 800816c:	4603      	mov	r3, r0
 800816e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	avih.dwReserved[0] = 0;
 8008172:	2300      	movs	r3, #0
 8008174:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
	res = fwrite_DWORD(file, avih.dwReserved[0]);//offset+4=72
 8008178:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800817c:	4619      	mov	r1, r3
 800817e:	68f8      	ldr	r0, [r7, #12]
 8008180:	f7ff fe1a 	bl	8007db8 <fwrite_DWORD>
 8008184:	4603      	mov	r3, r0
 8008186:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[1] = 0;
 800818a:	2300      	movs	r3, #0
 800818c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	res = fwrite_DWORD(file, avih.dwReserved[1]);//offset+4=76
 8008190:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8008194:	4619      	mov	r1, r3
 8008196:	68f8      	ldr	r0, [r7, #12]
 8008198:	f7ff fe0e 	bl	8007db8 <fwrite_DWORD>
 800819c:	4603      	mov	r3, r0
 800819e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[2] = 0;
 80081a2:	2300      	movs	r3, #0
 80081a4:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
	res = fwrite_DWORD(file, avih.dwReserved[2]);//offset+4=80
 80081a8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80081ac:	4619      	mov	r1, r3
 80081ae:	68f8      	ldr	r0, [r7, #12]
 80081b0:	f7ff fe02 	bl	8007db8 <fwrite_DWORD>
 80081b4:	4603      	mov	r3, r0
 80081b6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	avih.dwReserved[3] = 0;
 80081ba:	2300      	movs	r3, #0
 80081bc:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
	res = fwrite_DWORD(file, avih.dwReserved[3]);//offset+4=84
 80081c0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80081c4:	4619      	mov	r1, r3
 80081c6:	68f8      	ldr	r0, [r7, #12]
 80081c8:	f7ff fdf6 	bl	8007db8 <fwrite_DWORD>
 80081cc:	4603      	mov	r3, r0
 80081ce:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	LIST strl;
	strl.dwList = 'LIST';
 80081d2:	4b54      	ldr	r3, [pc, #336]	@ (8008324 <output_avi_header+0x394>)
 80081d4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
	res = f_write(file, "LIST", 4, &bw);//offset+4=88
 80081d8:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80081dc:	2204      	movs	r2, #4
 80081de:	4952      	ldr	r1, [pc, #328]	@ (8008328 <output_avi_header+0x398>)
 80081e0:	68f8      	ldr	r0, [r7, #12]
 80081e2:	f009 fbf2 	bl	80119ca <f_write>
 80081e6:	4603      	mov	r3, r0
 80081e8:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strl.dwSize = 132;
 80081ec:	2384      	movs	r3, #132	@ 0x84
 80081ee:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	res = fwrite_DWORD(file, strl.dwSize);//offset+4=92
 80081f2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80081f6:	4619      	mov	r1, r3
 80081f8:	68f8      	ldr	r0, [r7, #12]
 80081fa:	f7ff fddd 	bl	8007db8 <fwrite_DWORD>
 80081fe:	4603      	mov	r3, r0
 8008200:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strl.dwFourCC = 'strl';
 8008204:	4b4e      	ldr	r3, [pc, #312]	@ (8008340 <output_avi_header+0x3b0>)
 8008206:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
	res = f_write(file, "strl", 4, &bw);//offset+4=96
 800820a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800820e:	2204      	movs	r2, #4
 8008210:	494c      	ldr	r1, [pc, #304]	@ (8008344 <output_avi_header+0x3b4>)
 8008212:	68f8      	ldr	r0, [r7, #12]
 8008214:	f009 fbd9 	bl	80119ca <f_write>
 8008218:	4603      	mov	r3, r0
 800821a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	AVIStreamHeader strh;
	strh.dwFourCC = 'strh';
 800821e:	4b4a      	ldr	r3, [pc, #296]	@ (8008348 <output_avi_header+0x3b8>)
 8008220:	653b      	str	r3, [r7, #80]	@ 0x50
	res = f_write(file, "strh", 4, &bw);//offset+4=100
 8008222:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008226:	2204      	movs	r2, #4
 8008228:	4948      	ldr	r1, [pc, #288]	@ (800834c <output_avi_header+0x3bc>)
 800822a:	68f8      	ldr	r0, [r7, #12]
 800822c:	f009 fbcd 	bl	80119ca <f_write>
 8008230:	4603      	mov	r3, r0
 8008232:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwSize = 48;
 8008236:	2330      	movs	r3, #48	@ 0x30
 8008238:	657b      	str	r3, [r7, #84]	@ 0x54
	res = fwrite_DWORD(file, strh.dwSize);//offset+4=104
 800823a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800823c:	4619      	mov	r1, r3
 800823e:	68f8      	ldr	r0, [r7, #12]
 8008240:	f7ff fdba 	bl	8007db8 <fwrite_DWORD>
 8008244:	4603      	mov	r3, r0
 8008246:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.fccType = 'vids';
 800824a:	4b41      	ldr	r3, [pc, #260]	@ (8008350 <output_avi_header+0x3c0>)
 800824c:	65bb      	str	r3, [r7, #88]	@ 0x58
	res = f_write(file, "vids", 4, &bw);//offset+4=108
 800824e:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008252:	2204      	movs	r2, #4
 8008254:	493f      	ldr	r1, [pc, #252]	@ (8008354 <output_avi_header+0x3c4>)
 8008256:	68f8      	ldr	r0, [r7, #12]
 8008258:	f009 fbb7 	bl	80119ca <f_write>
 800825c:	4603      	mov	r3, r0
 800825e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.fccHandler = 'MJPG';
 8008262:	4b3d      	ldr	r3, [pc, #244]	@ (8008358 <output_avi_header+0x3c8>)
 8008264:	65fb      	str	r3, [r7, #92]	@ 0x5c
	res = f_write(file, "MJPG", 4,&bw);//offset+4=112
 8008266:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800826a:	2204      	movs	r2, #4
 800826c:	493b      	ldr	r1, [pc, #236]	@ (800835c <output_avi_header+0x3cc>)
 800826e:	68f8      	ldr	r0, [r7, #12]
 8008270:	f009 fbab 	bl	80119ca <f_write>
 8008274:	4603      	mov	r3, r0
 8008276:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwFlags = 0;
 800827a:	2300      	movs	r3, #0
 800827c:	663b      	str	r3, [r7, #96]	@ 0x60
	res = fwrite_DWORD(file, strh.dwFlags);//offset+4=116
 800827e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008280:	4619      	mov	r1, r3
 8008282:	68f8      	ldr	r0, [r7, #12]
 8008284:	f7ff fd98 	bl	8007db8 <fwrite_DWORD>
 8008288:	4603      	mov	r3, r0
 800828a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.wPriority = 0; // +2 = 14
 800828e:	2300      	movs	r3, #0
 8008290:	f8a7 3064 	strh.w	r3, [r7, #100]	@ 0x64
	res = fwrite_WORD(file, strh.wPriority);//offset+4=120
 8008294:	f8b7 3064 	ldrh.w	r3, [r7, #100]	@ 0x64
 8008298:	4619      	mov	r1, r3
 800829a:	68f8      	ldr	r0, [r7, #12]
 800829c:	f7ff fd9f 	bl	8007dde <fwrite_WORD>
 80082a0:	4603      	mov	r3, r0
 80082a2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.wLanguage = 0; // +2 = 16
 80082a6:	2300      	movs	r3, #0
 80082a8:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
	res = fwrite_WORD(file, strh.wLanguage);//offset+2=122
 80082ac:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 80082b0:	4619      	mov	r1, r3
 80082b2:	68f8      	ldr	r0, [r7, #12]
 80082b4:	f7ff fd93 	bl	8007dde <fwrite_WORD>
 80082b8:	4603      	mov	r3, r0
 80082ba:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwInitialFrames = 0; // +4 = 20
 80082be:	2300      	movs	r3, #0
 80082c0:	66bb      	str	r3, [r7, #104]	@ 0x68
	res = fwrite_DWORD(file, strh.dwInitialFrames);//offset+2=124
 80082c2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80082c4:	4619      	mov	r1, r3
 80082c6:	68f8      	ldr	r0, [r7, #12]
 80082c8:	f7ff fd76 	bl	8007db8 <fwrite_DWORD>
 80082cc:	4603      	mov	r3, r0
 80082ce:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwScale = 1; // +4 = 24
 80082d2:	2301      	movs	r3, #1
 80082d4:	66fb      	str	r3, [r7, #108]	@ 0x6c
	res = fwrite_DWORD(file, strh.dwScale);//offset+4=128
 80082d6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80082d8:	4619      	mov	r1, r3
 80082da:	68f8      	ldr	r0, [r7, #12]
 80082dc:	f7ff fd6c 	bl	8007db8 <fwrite_DWORD>
 80082e0:	4603      	mov	r3, r0
 80082e2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	// insert FPS
	strh.dwRate = fps; // +4 = 28
 80082e6:	7afb      	ldrb	r3, [r7, #11]
 80082e8:	673b      	str	r3, [r7, #112]	@ 0x70
	res = fwrite_DWORD(file, strh.dwRate);//offset+4=132
 80082ea:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80082ec:	4619      	mov	r1, r3
 80082ee:	68f8      	ldr	r0, [r7, #12]
 80082f0:	f7ff fd62 	bl	8007db8 <fwrite_DWORD>
 80082f4:	4603      	mov	r3, r0
 80082f6:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwStart = 0; // +4 = 32
 80082fa:	2300      	movs	r3, #0
 80082fc:	677b      	str	r3, [r7, #116]	@ 0x74
	res = fwrite_DWORD(file, strh.dwStart);//offset+4=136
 80082fe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8008300:	4619      	mov	r1, r3
 8008302:	68f8      	ldr	r0, [r7, #12]
 8008304:	f7ff fd58 	bl	8007db8 <fwrite_DWORD>
 8008308:	4603      	mov	r3, r0
 800830a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	//////////////////////
	// insert nbr of jpegs, must rewrite, offset ?
	strh.dwLength = 0; //nbr_of_jpgs;  +4 = 36
 800830e:	2300      	movs	r3, #0
 8008310:	e026      	b.n	8008360 <output_avi_header+0x3d0>
 8008312:	bf00      	nop
 8008314:	52494646 	.word	0x52494646
 8008318:	080301c4 	.word	0x080301c4
 800831c:	41564920 	.word	0x41564920
 8008320:	080301cc 	.word	0x080301cc
 8008324:	4c495354 	.word	0x4c495354
 8008328:	080301d4 	.word	0x080301d4
 800832c:	6864726c 	.word	0x6864726c
 8008330:	080301dc 	.word	0x080301dc
 8008334:	61766968 	.word	0x61766968
 8008338:	080301e4 	.word	0x080301e4
 800833c:	000f4240 	.word	0x000f4240
 8008340:	7374726c 	.word	0x7374726c
 8008344:	080301ec 	.word	0x080301ec
 8008348:	73747268 	.word	0x73747268
 800834c:	080301f4 	.word	0x080301f4
 8008350:	76696473 	.word	0x76696473
 8008354:	080301fc 	.word	0x080301fc
 8008358:	4d4a5047 	.word	0x4d4a5047
 800835c:	08030204 	.word	0x08030204
 8008360:	67bb      	str	r3, [r7, #120]	@ 0x78
	res = fwrite_DWORD(file, strh.dwLength);//offset+4=140
 8008362:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8008364:	4619      	mov	r1, r3
 8008366:	68f8      	ldr	r0, [r7, #12]
 8008368:	f7ff fd26 	bl	8007db8 <fwrite_DWORD>
 800836c:	4603      	mov	r3, r0
 800836e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwSuggestedBufferSize = 0; // +4 = 40
 8008372:	2300      	movs	r3, #0
 8008374:	67fb      	str	r3, [r7, #124]	@ 0x7c
	res = fwrite_DWORD(file, strh.dwSuggestedBufferSize);//offset+4=144
 8008376:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8008378:	4619      	mov	r1, r3
 800837a:	68f8      	ldr	r0, [r7, #12]
 800837c:	f7ff fd1c 	bl	8007db8 <fwrite_DWORD>
 8008380:	4603      	mov	r3, r0
 8008382:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strh.dwQuality = 0; // +4 = 44
 8008386:	2300      	movs	r3, #0
 8008388:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
	res = fwrite_DWORD(file, strh.dwQuality);//offset+4=148
 800838c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8008390:	4619      	mov	r1, r3
 8008392:	68f8      	ldr	r0, [r7, #12]
 8008394:	f7ff fd10 	bl	8007db8 <fwrite_DWORD>
 8008398:	4603      	mov	r3, r0
 800839a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	// can be grouped into a single chunk within the file.
	// If it is zero, each sample of data (such as a video frame) must be in a separate chunk.
	// For video streams, this number is typically zero, although
	// it can be nonzero if all video frames are the same size.
	//
	strh.dwSampleSize = 0; // +4 = 48
 800839e:	2300      	movs	r3, #0
 80083a0:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
	res = fwrite_DWORD(file, strh.dwSampleSize);//offset+4=152
 80083a4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80083a8:	4619      	mov	r1, r3
 80083aa:	68f8      	ldr	r0, [r7, #12]
 80083ac:	f7ff fd04 	bl	8007db8 <fwrite_DWORD>
 80083b0:	4603      	mov	r3, r0
 80083b2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	EXBMINFOHEADER strf;

	strf.dwFourCC = 'strf';
 80083b6:	4b7d      	ldr	r3, [pc, #500]	@ (80085ac <output_avi_header+0x61c>)
 80083b8:	623b      	str	r3, [r7, #32]
	res = f_write(file, "strf", 4, &bw);//offset+4=156
 80083ba:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80083be:	2204      	movs	r2, #4
 80083c0:	497b      	ldr	r1, [pc, #492]	@ (80085b0 <output_avi_header+0x620>)
 80083c2:	68f8      	ldr	r0, [r7, #12]
 80083c4:	f009 fb01 	bl	80119ca <f_write>
 80083c8:	4603      	mov	r3, r0
 80083ca:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.dwSize = 40;
 80083ce:	2328      	movs	r3, #40	@ 0x28
 80083d0:	627b      	str	r3, [r7, #36]	@ 0x24
	res = fwrite_DWORD(file, strf.dwSize);//offset+4=160
 80083d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80083d4:	4619      	mov	r1, r3
 80083d6:	68f8      	ldr	r0, [r7, #12]
 80083d8:	f7ff fcee 	bl	8007db8 <fwrite_DWORD>
 80083dc:	4603      	mov	r3, r0
 80083de:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biSize = 40;
 80083e2:	2328      	movs	r3, #40	@ 0x28
 80083e4:	62bb      	str	r3, [r7, #40]	@ 0x28
	res = fwrite_DWORD(file, strf.biSize);//offset+4=164
 80083e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80083e8:	4619      	mov	r1, r3
 80083ea:	68f8      	ldr	r0, [r7, #12]
 80083ec:	f7ff fce4 	bl	8007db8 <fwrite_DWORD>
 80083f0:	4603      	mov	r3, r0
 80083f2:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biWidth = width;
 80083f6:	893b      	ldrh	r3, [r7, #8]
 80083f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
	res = fwrite_DWORD(file, strf.biWidth);//offset+4=168
 80083fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80083fc:	4619      	mov	r1, r3
 80083fe:	68f8      	ldr	r0, [r7, #12]
 8008400:	f7ff fcda 	bl	8007db8 <fwrite_DWORD>
 8008404:	4603      	mov	r3, r0
 8008406:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biHeight = height;
 800840a:	88fb      	ldrh	r3, [r7, #6]
 800840c:	633b      	str	r3, [r7, #48]	@ 0x30
	res = fwrite_DWORD(file, strf.biHeight);//offset+4=172
 800840e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8008410:	4619      	mov	r1, r3
 8008412:	68f8      	ldr	r0, [r7, #12]
 8008414:	f7ff fcd0 	bl	8007db8 <fwrite_DWORD>
 8008418:	4603      	mov	r3, r0
 800841a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biPlanes = 1;
 800841e:	2301      	movs	r3, #1
 8008420:	86bb      	strh	r3, [r7, #52]	@ 0x34
	res = fwrite_WORD(file, strf.biPlanes);//offset+4=176
 8008422:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8008424:	4619      	mov	r1, r3
 8008426:	68f8      	ldr	r0, [r7, #12]
 8008428:	f7ff fcd9 	bl	8007dde <fwrite_WORD>
 800842c:	4603      	mov	r3, r0
 800842e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biBitCount = 24;
 8008432:	2318      	movs	r3, #24
 8008434:	86fb      	strh	r3, [r7, #54]	@ 0x36
	res = fwrite_WORD(file, strf.biBitCount);//offset+2=178
 8008436:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8008438:	4619      	mov	r1, r3
 800843a:	68f8      	ldr	r0, [r7, #12]
 800843c:	f7ff fccf 	bl	8007dde <fwrite_WORD>
 8008440:	4603      	mov	r3, r0
 8008442:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biCompression = 'MJPG';
 8008446:	4b5b      	ldr	r3, [pc, #364]	@ (80085b4 <output_avi_header+0x624>)
 8008448:	63bb      	str	r3, [r7, #56]	@ 0x38
	res = f_write(file, "MJPG", 4, &bw);//offset+2=180
 800844a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800844e:	2204      	movs	r2, #4
 8008450:	4959      	ldr	r1, [pc, #356]	@ (80085b8 <output_avi_header+0x628>)
 8008452:	68f8      	ldr	r0, [r7, #12]
 8008454:	f009 fab9 	bl	80119ca <f_write>
 8008458:	4603      	mov	r3, r0
 800845a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	strf.biSizeImage = ((strf.biWidth*strf.biBitCount/8 + 3)&0xFFFFFFFC)*strf.biHeight;
 800845e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008460:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 8008462:	fb02 f303 	mul.w	r3, r2, r3
 8008466:	2b00      	cmp	r3, #0
 8008468:	da00      	bge.n	800846c <output_avi_header+0x4dc>
 800846a:	3307      	adds	r3, #7
 800846c:	10db      	asrs	r3, r3, #3
 800846e:	3303      	adds	r3, #3
 8008470:	f023 0303 	bic.w	r3, r3, #3
 8008474:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8008476:	fb02 f303 	mul.w	r3, r2, r3
 800847a:	63fb      	str	r3, [r7, #60]	@ 0x3c
	res = fwrite_DWORD(file, strf.biSizeImage);//offset+4=184
 800847c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800847e:	4619      	mov	r1, r3
 8008480:	68f8      	ldr	r0, [r7, #12]
 8008482:	f7ff fc99 	bl	8007db8 <fwrite_DWORD>
 8008486:	4603      	mov	r3, r0
 8008488:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biXPelsPerMeter = 0;
 800848c:	2300      	movs	r3, #0
 800848e:	643b      	str	r3, [r7, #64]	@ 0x40
	res = fwrite_DWORD(file, strf.biXPelsPerMeter);//offset+4=188
 8008490:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008492:	4619      	mov	r1, r3
 8008494:	68f8      	ldr	r0, [r7, #12]
 8008496:	f7ff fc8f 	bl	8007db8 <fwrite_DWORD>
 800849a:	4603      	mov	r3, r0
 800849c:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biYPelsPerMeter = 0;
 80084a0:	2300      	movs	r3, #0
 80084a2:	647b      	str	r3, [r7, #68]	@ 0x44
	res = fwrite_DWORD(file, strf.biYPelsPerMeter);//offset+4=192
 80084a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80084a6:	4619      	mov	r1, r3
 80084a8:	68f8      	ldr	r0, [r7, #12]
 80084aa:	f7ff fc85 	bl	8007db8 <fwrite_DWORD>
 80084ae:	4603      	mov	r3, r0
 80084b0:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biClrUsed = 0;
 80084b4:	2300      	movs	r3, #0
 80084b6:	64bb      	str	r3, [r7, #72]	@ 0x48
	res = fwrite_DWORD(file, strf.biClrUsed);//offset+4=196
 80084b8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80084ba:	4619      	mov	r1, r3
 80084bc:	68f8      	ldr	r0, [r7, #12]
 80084be:	f7ff fc7b 	bl	8007db8 <fwrite_DWORD>
 80084c2:	4603      	mov	r3, r0
 80084c4:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	strf.biClrImportant = 0;
 80084c8:	2300      	movs	r3, #0
 80084ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
	res = fwrite_DWORD(file, strf.biClrImportant);//offset+4=200
 80084cc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80084ce:	4619      	mov	r1, r3
 80084d0:	68f8      	ldr	r0, [r7, #12]
 80084d2:	f7ff fc71 	bl	8007db8 <fwrite_DWORD>
 80084d6:	4603      	mov	r3, r0
 80084d8:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	res = f_write(file, "LIST", 4, &bw);//offset+4=204
 80084dc:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 80084e0:	2204      	movs	r2, #4
 80084e2:	4936      	ldr	r1, [pc, #216]	@ (80085bc <output_avi_header+0x62c>)
 80084e4:	68f8      	ldr	r0, [r7, #12]
 80084e6:	f009 fa70 	bl	80119ca <f_write>
 80084ea:	4603      	mov	r3, r0
 80084ec:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	DWORD ddww = 16;
 80084f0:	2310      	movs	r3, #16
 80084f2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
	res = fwrite_DWORD(file, ddww);//offset+4=208
 80084f6:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80084fa:	68f8      	ldr	r0, [r7, #12]
 80084fc:	f7ff fc5c 	bl	8007db8 <fwrite_DWORD>
 8008500:	4603      	mov	r3, r0
 8008502:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	res = f_write(file, "odml", 4, &bw);//offset+4=212
 8008506:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800850a:	2204      	movs	r2, #4
 800850c:	492c      	ldr	r1, [pc, #176]	@ (80085c0 <output_avi_header+0x630>)
 800850e:	68f8      	ldr	r0, [r7, #12]
 8008510:	f009 fa5b 	bl	80119ca <f_write>
 8008514:	4603      	mov	r3, r0
 8008516:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	res = f_write(file, "dmlh", 4, &bw);//offset+4=216
 800851a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800851e:	2204      	movs	r2, #4
 8008520:	4928      	ldr	r1, [pc, #160]	@ (80085c4 <output_avi_header+0x634>)
 8008522:	68f8      	ldr	r0, [r7, #12]
 8008524:	f009 fa51 	bl	80119ca <f_write>
 8008528:	4603      	mov	r3, r0
 800852a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	DWORD szs = 4;
 800852e:	2304      	movs	r3, #4
 8008530:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
	res = fwrite_DWORD(file, szs);//offset+4=220
 8008534:	f8d7 10f4 	ldr.w	r1, [r7, #244]	@ 0xf4
 8008538:	68f8      	ldr	r0, [r7, #12]
 800853a:	f7ff fc3d 	bl	8007db8 <fwrite_DWORD>
 800853e:	4603      	mov	r3, r0
 8008540:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
////////////////////////////////////////
	// nbr of jpgs
	DWORD totalframes = 0; //nbr_of_jpgs; must rewrite, offset ?;
 8008544:	2300      	movs	r3, #0
 8008546:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
	res = fwrite_DWORD(file, totalframes);//offset+4=224
 800854a:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 800854e:	68f8      	ldr	r0, [r7, #12]
 8008550:	f7ff fc32 	bl	8007db8 <fwrite_DWORD>
 8008554:	4603      	mov	r3, r0
 8008556:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	LIST movi;
	movi.dwList = 'LIST';
 800855a:	4b1b      	ldr	r3, [pc, #108]	@ (80085c8 <output_avi_header+0x638>)
 800855c:	617b      	str	r3, [r7, #20]
	res = f_write(file, "LIST", 4, &bw);//offset+4=228
 800855e:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 8008562:	2204      	movs	r2, #4
 8008564:	4915      	ldr	r1, [pc, #84]	@ (80085bc <output_avi_header+0x62c>)
 8008566:	68f8      	ldr	r0, [r7, #12]
 8008568:	f009 fa2f 	bl	80119ca <f_write>
 800856c:	4603      	mov	r3, r0
 800856e:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

	//////////////////////////////
	//movi.dwSize = len + 4 + 8*nbr_of_jpgs;   must rewrite, offset?, len, nbr_of_jpgs;
	movi.dwSize = 0;
 8008572:	2300      	movs	r3, #0
 8008574:	61bb      	str	r3, [r7, #24]
	res = fwrite_DWORD(file, movi.dwSize);//offset+4=232
 8008576:	69bb      	ldr	r3, [r7, #24]
 8008578:	4619      	mov	r1, r3
 800857a:	68f8      	ldr	r0, [r7, #12]
 800857c:	f7ff fc1c 	bl	8007db8 <fwrite_DWORD>
 8008580:	4603      	mov	r3, r0
 8008582:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	movi.dwFourCC = 'movi';
 8008586:	4b11      	ldr	r3, [pc, #68]	@ (80085cc <output_avi_header+0x63c>)
 8008588:	61fb      	str	r3, [r7, #28]
	res = f_write(file, "movi", 4, &bw);//offset+4=236
 800858a:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
 800858e:	2204      	movs	r2, #4
 8008590:	490f      	ldr	r1, [pc, #60]	@ (80085d0 <output_avi_header+0x640>)
 8008592:	68f8      	ldr	r0, [r7, #12]
 8008594:	f009 fa19 	bl	80119ca <f_write>
 8008598:	4603      	mov	r3, r0
 800859a:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff
	return res;
 800859e:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
}
 80085a2:	4618      	mov	r0, r3
 80085a4:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 80085a8:	46bd      	mov	sp, r7
 80085aa:	bd80      	pop	{r7, pc}
 80085ac:	73747266 	.word	0x73747266
 80085b0:	0803020c 	.word	0x0803020c
 80085b4:	4d4a5047 	.word	0x4d4a5047
 80085b8:	08030204 	.word	0x08030204
 80085bc:	080301d4 	.word	0x080301d4
 80085c0:	08030214 	.word	0x08030214
 80085c4:	0803021c 	.word	0x0803021c
 80085c8:	4c495354 	.word	0x4c495354
 80085cc:	6d6f7669 	.word	0x6d6f7669
 80085d0:	08030224 	.word	0x08030224

080085d4 <start_output_mjpeg_avi>:
/*						 the recording process. It captures frames from the camera, checks for valid JPEG*/
/*						 headers, writes the data to the file, and updates the index. 					*/
/*						 The recording continues until the stop condition is met						*/
/********************************************************************************************************/
FRESULT start_output_mjpeg_avi(FIL *file, DCMI_HandleTypeDef *hdcmi, uint8_t fps, uint8_t resolution)
{
 80085d4:	b590      	push	{r4, r7, lr}
 80085d6:	f5ad 4dc1 	sub.w	sp, sp, #24704	@ 0x6080
 80085da:	b08f      	sub	sp, #60	@ 0x3c
 80085dc:	af00      	add	r7, sp, #0
 80085de:	f107 04b8 	add.w	r4, r7, #184	@ 0xb8
 80085e2:	f844 0cac 	str.w	r0, [r4, #-172]
 80085e6:	f107 00b8 	add.w	r0, r7, #184	@ 0xb8
 80085ea:	f840 1cb0 	str.w	r1, [r0, #-176]
 80085ee:	4619      	mov	r1, r3
 80085f0:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80085f4:	f803 2cb1 	strb.w	r2, [r3, #-177]
 80085f8:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80085fc:	460a      	mov	r2, r1
 80085fe:	f803 2cb2 	strb.w	r2, [r3, #-178]
	FRESULT res = FR_OK;
 8008602:	2300      	movs	r3, #0
 8008604:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008608:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 800860c:	7013      	strb	r3, [r2, #0]
	FIL temp_idx1;
	uint32_t next_idx1_offset;
	uint8_t dmabuff[MAX_AVI_BUFF];
	uint16_t width, height;
	uint16_t f_begin = 0;
 800860e:	2300      	movs	r3, #0
 8008610:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008614:	f102 022e 	add.w	r2, r2, #46	@ 0x2e
 8008618:	8013      	strh	r3, [r2, #0]
	uint32_t f_end = 0;
 800861a:	2300      	movs	r3, #0
 800861c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008620:	f102 0208 	add.w	r2, r2, #8
 8008624:	6013      	str	r3, [r2, #0]
	uint32_t idx = 0;
 8008626:	2300      	movs	r3, #0
 8008628:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800862c:	f102 0228 	add.w	r2, r2, #40	@ 0x28
 8008630:	6013      	str	r3, [r2, #0]

	uint32_t sublen=0;
 8008632:	2300      	movs	r3, #0
 8008634:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008638:	f102 0224 	add.w	r2, r2, #36	@ 0x24
 800863c:	6013      	str	r3, [r2, #0]
	uint8_t headerFinder=0;
 800863e:	2300      	movs	r3, #0
 8008640:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008644:	f102 0223 	add.w	r2, r2, #35	@ 0x23
 8008648:	7013      	strb	r3, [r2, #0]
	UINT bw;
	uint16_t f,r;
	CHUNK data;
	uint8_t *buff;
	uint8_t frame_ok=0;
 800864a:	2300      	movs	r3, #0
 800864c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008650:	f102 021b 	add.w	r2, r2, #27
 8008654:	7013      	strb	r3, [r2, #0]

	uint32_t lastSuccessTick;
	uint16_t timeout=0;
 8008656:	2300      	movs	r3, #0
 8008658:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800865c:	f102 0212 	add.w	r2, r2, #18
 8008660:	8013      	strh	r3, [r2, #0]
	uint8_t adjTime=0;
 8008662:	2300      	movs	r3, #0
 8008664:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008668:	f102 0211 	add.w	r2, r2, #17
 800866c:	7013      	strb	r3, [r2, #0]

	unsigned long beginTick;
	long time_diff=0;
 800866e:	2300      	movs	r3, #0
 8008670:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008674:	f102 0204 	add.w	r2, r2, #4
 8008678:	6013      	str	r3, [r2, #0]


	bAviStartRecording = AVI_START;
 800867a:	4b7a      	ldr	r3, [pc, #488]	@ (8008864 <start_output_mjpeg_avi+0x290>)
 800867c:	2201      	movs	r2, #1
 800867e:	701a      	strb	r2, [r3, #0]
	HAL_DCMI_Stop(hdcmi);
 8008680:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8008684:	f853 0cb0 	ldr.w	r0, [r3, #-176]
 8008688:	f7f9 fba4 	bl	8001dd4 <HAL_DCMI_Stop>
	ov2640_Init(0x60, CAMERA_Movie);
 800868c:	2101      	movs	r1, #1
 800868e:	2060      	movs	r0, #96	@ 0x60
 8008690:	f000 fc3c 	bl	8008f0c <ov2640_Init>

	width = 320;
 8008694:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 8008698:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800869c:	f102 0202 	add.w	r2, r2, #2
 80086a0:	8013      	strh	r3, [r2, #0]
	height = 240;
 80086a2:	23f0      	movs	r3, #240	@ 0xf0
 80086a4:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80086a8:	8013      	strh	r3, [r2, #0]

	 res = f_open(&temp_idx1, "0:/temp_idx1", FA_CREATE_ALWAYS|FA_WRITE|FA_READ);
 80086aa:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 80086ae:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 80086b2:	3b18      	subs	r3, #24
 80086b4:	220b      	movs	r2, #11
 80086b6:	496c      	ldr	r1, [pc, #432]	@ (8008868 <start_output_mjpeg_avi+0x294>)
 80086b8:	4618      	mov	r0, r3
 80086ba:	f008 fd1f 	bl	80110fc <f_open>
 80086be:	4603      	mov	r3, r0
 80086c0:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80086c4:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 80086c8:	7013      	strb	r3, [r2, #0]
	 if (res != FR_OK) return res;
 80086ca:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80086ce:	f103 0337 	add.w	r3, r3, #55	@ 0x37
 80086d2:	781b      	ldrb	r3, [r3, #0]
 80086d4:	2b00      	cmp	r3, #0
 80086d6:	d005      	beq.n	80086e4 <start_output_mjpeg_avi+0x110>
 80086d8:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80086dc:	f103 0337 	add.w	r3, r3, #55	@ 0x37
 80086e0:	781b      	ldrb	r3, [r3, #0]
 80086e2:	e2d7      	b.n	8008c94 <start_output_mjpeg_avi+0x6c0>

	 if (output_avi_header(file, fps, width, height) != FR_OK)  //default fps = 15
 80086e4:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80086e8:	881b      	ldrh	r3, [r3, #0]
 80086ea:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80086ee:	f102 0202 	add.w	r2, r2, #2
 80086f2:	8812      	ldrh	r2, [r2, #0]
 80086f4:	f107 01b8 	add.w	r1, r7, #184	@ 0xb8
 80086f8:	f811 1cb1 	ldrb.w	r1, [r1, #-177]
 80086fc:	f107 00b8 	add.w	r0, r7, #184	@ 0xb8
 8008700:	f850 0cac 	ldr.w	r0, [r0, #-172]
 8008704:	f7ff fc44 	bl	8007f90 <output_avi_header>
 8008708:	4603      	mov	r3, r0
 800870a:	2b00      	cmp	r3, #0
 800870c:	d005      	beq.n	800871a <start_output_mjpeg_avi+0x146>
		return res;
 800870e:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008712:	f103 0337 	add.w	r3, r3, #55	@ 0x37
 8008716:	781b      	ldrb	r3, [r3, #0]
 8008718:	e2bc      	b.n	8008c94 <start_output_mjpeg_avi+0x6c0>

	totalLen=0;
 800871a:	4b54      	ldr	r3, [pc, #336]	@ (800886c <start_output_mjpeg_avi+0x298>)
 800871c:	2200      	movs	r2, #0
 800871e:	601a      	str	r2, [r3, #0]
	frames=0;
 8008720:	4b53      	ldr	r3, [pc, #332]	@ (8008870 <start_output_mjpeg_avi+0x29c>)
 8008722:	2200      	movs	r2, #0
 8008724:	601a      	str	r2, [r3, #0]

	next_idx1_offset=4;
 8008726:	2304      	movs	r3, #4
 8008728:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800872c:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 8008730:	6013      	str	r3, [r2, #0]
	lastSuccessTick = HAL_GetTick();
 8008732:	f7f9 f96d 	bl	8001a10 <HAL_GetTick>
 8008736:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800873a:	f103 0314 	add.w	r3, r3, #20
 800873e:	6018      	str	r0, [r3, #0]
	while(bAviStartRecording == AVI_START)
 8008740:	e28e      	b.n	8008c60 <start_output_mjpeg_avi+0x68c>
	{
		memset(dmabuff,0, MAX_AVI_BUFF);
 8008742:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008746:	3b18      	subs	r3, #24
 8008748:	f44f 42a0 	mov.w	r2, #20480	@ 0x5000
 800874c:	2100      	movs	r1, #0
 800874e:	4618      	mov	r0, r3
 8008750:	f027 f926 	bl	802f9a0 <memset>
		headerFinder=0;
 8008754:	2300      	movs	r3, #0
 8008756:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800875a:	f102 0223 	add.w	r2, r2, #35	@ 0x23
 800875e:	7013      	strb	r3, [r2, #0]
		//if (frame_ok 0)
		if (frame_ok && adjTime  == 0)
 8008760:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008764:	f103 031b 	add.w	r3, r3, #27
 8008768:	781b      	ldrb	r3, [r3, #0]
 800876a:	2b00      	cmp	r3, #0
 800876c:	d026      	beq.n	80087bc <start_output_mjpeg_avi+0x1e8>
 800876e:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008772:	f103 0311 	add.w	r3, r3, #17
 8008776:	781b      	ldrb	r3, [r3, #0]
 8008778:	2b00      	cmp	r3, #0
 800877a:	d11f      	bne.n	80087bc <start_output_mjpeg_avi+0x1e8>
		{
			time_diff = HAL_GetTick()-lastSuccessTick;
 800877c:	f7f9 f948 	bl	8001a10 <HAL_GetTick>
 8008780:	4602      	mov	r2, r0
 8008782:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008786:	f103 0314 	add.w	r3, r3, #20
 800878a:	681b      	ldr	r3, [r3, #0]
 800878c:	1ad3      	subs	r3, r2, r3
 800878e:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008792:	f102 0204 	add.w	r2, r2, #4
 8008796:	6013      	str	r3, [r2, #0]

			//if (1000/fps > time_diff && time_diff > 0)
			if (1000 > time_diff)
 8008798:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800879c:	f103 0304 	add.w	r3, r3, #4
 80087a0:	681b      	ldr	r3, [r3, #0]
 80087a2:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80087a6:	da09      	bge.n	80087bc <start_output_mjpeg_avi+0x1e8>
				delay_ms(1000 - time_diff);
 80087a8:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80087ac:	f103 0304 	add.w	r3, r3, #4
 80087b0:	681b      	ldr	r3, [r3, #0]
 80087b2:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 80087b6:	4618      	mov	r0, r3
 80087b8:	f001 fe5e 	bl	800a478 <delay_ms>
		}

		beginTick = HAL_GetTick();
 80087bc:	f7f9 f928 	bl	8001a10 <HAL_GetTick>
 80087c0:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 80087c4:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 80087c8:	6018      	str	r0, [r3, #0]

		HAL_DCMI_Start_DMA(hdcmi, DCMI_MODE_SNAPSHOT, ((uint32_t)dmabuff), MAX_AVI_BUFF/4);
 80087ca:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 80087ce:	3a18      	subs	r2, #24
 80087d0:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80087d4:	4618      	mov	r0, r3
 80087d6:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 80087da:	2102      	movs	r1, #2
 80087dc:	f850 0cb0 	ldr.w	r0, [r0, #-176]
 80087e0:	f7f9 fa58 	bl	8001c94 <HAL_DCMI_Start_DMA>

		timeout=0;
 80087e4:	2300      	movs	r3, #0
 80087e6:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80087ea:	f102 0212 	add.w	r2, r2, #18
 80087ee:	8013      	strh	r3, [r2, #0]
		while((hdcmi->Instance->CR.reg & 0x03) == 3)
 80087f0:	e015      	b.n	800881e <start_output_mjpeg_avi+0x24a>
		{
			if (timeout > 1000)
 80087f2:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80087f6:	f103 0312 	add.w	r3, r3, #18
 80087fa:	881b      	ldrh	r3, [r3, #0]
 80087fc:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8008800:	d818      	bhi.n	8008834 <start_output_mjpeg_avi+0x260>
			{
				break; //max timeout: 1 seconds
			}
			delay_ms(1);
 8008802:	2001      	movs	r0, #1
 8008804:	f001 fe38 	bl	800a478 <delay_ms>
			timeout++;
 8008808:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800880c:	f103 0312 	add.w	r3, r3, #18
 8008810:	881b      	ldrh	r3, [r3, #0]
 8008812:	3301      	adds	r3, #1
 8008814:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008818:	f102 0212 	add.w	r2, r2, #18
 800881c:	8013      	strh	r3, [r2, #0]
		while((hdcmi->Instance->CR.reg & 0x03) == 3)
 800881e:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8008822:	f853 3cb0 	ldr.w	r3, [r3, #-176]
 8008826:	681b      	ldr	r3, [r3, #0]
 8008828:	681b      	ldr	r3, [r3, #0]
 800882a:	f003 0303 	and.w	r3, r3, #3
 800882e:	2b03      	cmp	r3, #3
 8008830:	d0df      	beq.n	80087f2 <start_output_mjpeg_avi+0x21e>
 8008832:	e000      	b.n	8008836 <start_output_mjpeg_avi+0x262>
				break; //max timeout: 1 seconds
 8008834:	bf00      	nop
		}
		if(timeout <= 1000)
 8008836:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800883a:	f103 0312 	add.w	r3, r3, #18
 800883e:	881b      	ldrh	r3, [r3, #0]
 8008840:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8008844:	f200 820c 	bhi.w	8008c60 <start_output_mjpeg_avi+0x68c>
		{
			frame_ok=0;
 8008848:	2300      	movs	r3, #0
 800884a:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800884e:	f102 021b 	add.w	r2, r2, #27
 8008852:	7013      	strb	r3, [r2, #0]
			for (idx = 0; idx<MAX_AVI_BUFF-4;idx++)
 8008854:	2300      	movs	r3, #0
 8008856:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800885a:	f102 0228 	add.w	r2, r2, #40	@ 0x28
 800885e:	6013      	str	r3, [r2, #0]
 8008860:	e1f4      	b.n	8008c4c <start_output_mjpeg_avi+0x678>
 8008862:	bf00      	nop
 8008864:	200028ea 	.word	0x200028ea
 8008868:	0803022c 	.word	0x0803022c
 800886c:	200028ec 	.word	0x200028ec
 8008870:	200028f0 	.word	0x200028f0
			{
				if (headerFinder == 0 && dmabuff[idx] == 0xff && dmabuff[idx+1]==0xD8)
 8008874:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008878:	f103 0323 	add.w	r3, r3, #35	@ 0x23
 800887c:	781b      	ldrb	r3, [r3, #0]
 800887e:	2b00      	cmp	r3, #0
 8008880:	d129      	bne.n	80088d6 <start_output_mjpeg_avi+0x302>
 8008882:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8008886:	461a      	mov	r2, r3
 8008888:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800888c:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8008890:	681b      	ldr	r3, [r3, #0]
 8008892:	4413      	add	r3, r2
 8008894:	3b98      	subs	r3, #152	@ 0x98
 8008896:	781b      	ldrb	r3, [r3, #0]
 8008898:	2bff      	cmp	r3, #255	@ 0xff
 800889a:	d11c      	bne.n	80088d6 <start_output_mjpeg_avi+0x302>
 800889c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80088a0:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 80088a4:	681b      	ldr	r3, [r3, #0]
 80088a6:	3301      	adds	r3, #1
 80088a8:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 80088ac:	4413      	add	r3, r2
 80088ae:	f813 3c98 	ldrb.w	r3, [r3, #-152]
 80088b2:	2bd8      	cmp	r3, #216	@ 0xd8
 80088b4:	d10f      	bne.n	80088d6 <start_output_mjpeg_avi+0x302>
				{
					headerFinder=1;
 80088b6:	2301      	movs	r3, #1
 80088b8:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80088bc:	f102 0223 	add.w	r2, r2, #35	@ 0x23
 80088c0:	7013      	strb	r3, [r2, #0]
					f_begin=idx;
 80088c2:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80088c6:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 80088ca:	681b      	ldr	r3, [r3, #0]
 80088cc:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80088d0:	f102 022e 	add.w	r2, r2, #46	@ 0x2e
 80088d4:	8013      	strh	r3, [r2, #0]
				}
				if (headerFinder==1 && dmabuff[idx]== 0xFF && dmabuff[idx+1] == 0xD9 )
 80088d6:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80088da:	f103 0323 	add.w	r3, r3, #35	@ 0x23
 80088de:	781b      	ldrb	r3, [r3, #0]
 80088e0:	2b01      	cmp	r3, #1
 80088e2:	f040 81a8 	bne.w	8008c36 <start_output_mjpeg_avi+0x662>
 80088e6:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80088ea:	461a      	mov	r2, r3
 80088ec:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80088f0:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 80088f4:	681b      	ldr	r3, [r3, #0]
 80088f6:	4413      	add	r3, r2
 80088f8:	3b98      	subs	r3, #152	@ 0x98
 80088fa:	781b      	ldrb	r3, [r3, #0]
 80088fc:	2bff      	cmp	r3, #255	@ 0xff
 80088fe:	f040 819a 	bne.w	8008c36 <start_output_mjpeg_avi+0x662>
 8008902:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008906:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 800890a:	681b      	ldr	r3, [r3, #0]
 800890c:	3301      	adds	r3, #1
 800890e:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008912:	4413      	add	r3, r2
 8008914:	f813 3c98 	ldrb.w	r3, [r3, #-152]
 8008918:	2bd9      	cmp	r3, #217	@ 0xd9
 800891a:	f040 818c 	bne.w	8008c36 <start_output_mjpeg_avi+0x662>
				{
					if (adjTime == 0) // 1 sec
 800891e:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008922:	f103 0311 	add.w	r3, r3, #17
 8008926:	781b      	ldrb	r3, [r3, #0]
 8008928:	2b00      	cmp	r3, #0
 800892a:	d109      	bne.n	8008940 <start_output_mjpeg_avi+0x36c>
						lastSuccessTick=beginTick;
 800892c:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008930:	f103 037c 	add.w	r3, r3, #124	@ 0x7c
 8008934:	681b      	ldr	r3, [r3, #0]
 8008936:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800893a:	f102 0214 	add.w	r2, r2, #20
 800893e:	6013      	str	r3, [r2, #0]

					adjTime = (adjTime+1)%fps; // 1 sec
 8008940:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008944:	f103 0311 	add.w	r3, r3, #17
 8008948:	781b      	ldrb	r3, [r3, #0]
 800894a:	3301      	adds	r3, #1
 800894c:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008950:	f812 2cb1 	ldrb.w	r2, [r2, #-177]
 8008954:	fb93 f1f2 	sdiv	r1, r3, r2
 8008958:	fb01 f202 	mul.w	r2, r1, r2
 800895c:	1a9b      	subs	r3, r3, r2
 800895e:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008962:	f102 0211 	add.w	r2, r2, #17
 8008966:	7013      	strb	r3, [r2, #0]

					frame_ok=1;
 8008968:	2301      	movs	r3, #1
 800896a:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800896e:	f102 021b 	add.w	r2, r2, #27
 8008972:	7013      	strb	r3, [r2, #0]
					headerFinder=0;
 8008974:	2300      	movs	r3, #0
 8008976:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 800897a:	f102 0223 	add.w	r2, r2, #35	@ 0x23
 800897e:	7013      	strb	r3, [r2, #0]
					f_end = idx+1;
 8008980:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008984:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8008988:	681b      	ldr	r3, [r3, #0]
 800898a:	3301      	adds	r3, #1
 800898c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008990:	f102 0208 	add.w	r2, r2, #8
 8008994:	6013      	str	r3, [r2, #0]

					buff = dmabuff + f_begin;
 8008996:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 800899a:	f103 032e 	add.w	r3, r3, #46	@ 0x2e
 800899e:	881a      	ldrh	r2, [r3, #0]
 80089a0:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80089a4:	3b18      	subs	r3, #24
 80089a6:	4413      	add	r3, r2
 80089a8:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80089ac:	f102 021c 	add.w	r2, r2, #28
 80089b0:	6013      	str	r3, [r2, #0]

					data.dwFourCC = '00db';
 80089b2:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80089b6:	461a      	mov	r2, r3
 80089b8:	4bb9      	ldr	r3, [pc, #740]	@ (8008ca0 <start_output_mjpeg_avi+0x6cc>)
 80089ba:	f842 3ca4 	str.w	r3, [r2, #-164]
					f_write(file, "00db", 4, &bw);
 80089be:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80089c2:	3b1c      	subs	r3, #28
 80089c4:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 80089c8:	4610      	mov	r0, r2
 80089ca:	2204      	movs	r2, #4
 80089cc:	49b5      	ldr	r1, [pc, #724]	@ (8008ca4 <start_output_mjpeg_avi+0x6d0>)
 80089ce:	f850 0cac 	ldr.w	r0, [r0, #-172]
 80089d2:	f008 fffa 	bl	80119ca <f_write>
					sublen = f_end-f_begin+1;
 80089d6:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 80089da:	f103 032e 	add.w	r3, r3, #46	@ 0x2e
 80089de:	881b      	ldrh	r3, [r3, #0]
 80089e0:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80089e4:	f102 0208 	add.w	r2, r2, #8
 80089e8:	6812      	ldr	r2, [r2, #0]
 80089ea:	1ad3      	subs	r3, r2, r3
 80089ec:	3301      	adds	r3, #1
 80089ee:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 80089f2:	f102 0224 	add.w	r2, r2, #36	@ 0x24
 80089f6:	6013      	str	r3, [r2, #0]

					data.dwSize = sublen;
 80089f8:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80089fc:	461a      	mov	r2, r3
 80089fe:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a02:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008a06:	681b      	ldr	r3, [r3, #0]
 8008a08:	f842 3ca0 	str.w	r3, [r2, #-160]
					fwrite_DWORD(file, data.dwSize);
 8008a0c:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8008a10:	f853 3ca0 	ldr.w	r3, [r3, #-160]
 8008a14:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008a18:	4619      	mov	r1, r3
 8008a1a:	f852 0cac 	ldr.w	r0, [r2, #-172]
 8008a1e:	f7ff f9cb 	bl	8007db8 <fwrite_DWORD>
					f = sublen / 512;
 8008a22:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a26:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008a2a:	681b      	ldr	r3, [r3, #0]
 8008a2c:	0a5b      	lsrs	r3, r3, #9
 8008a2e:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008a32:	f102 027a 	add.w	r2, r2, #122	@ 0x7a
 8008a36:	8013      	strh	r3, [r2, #0]
					r = sublen % 512;
 8008a38:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a3c:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008a40:	681b      	ldr	r3, [r3, #0]
 8008a42:	b29b      	uxth	r3, r3
 8008a44:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008a48:	f507 42c0 	add.w	r2, r7, #24576	@ 0x6000
 8008a4c:	f102 0278 	add.w	r2, r2, #120	@ 0x78
 8008a50:	8013      	strh	r3, [r2, #0]
					for (int i = 0; i < f; i++)
 8008a52:	2300      	movs	r3, #0
 8008a54:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008a58:	f102 020c 	add.w	r2, r2, #12
 8008a5c:	6013      	str	r3, [r2, #0]
 8008a5e:	e02d      	b.n	8008abc <start_output_mjpeg_avi+0x4e8>
					{
						res=f_write(file, buff, 512, &bw);
 8008a60:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008a64:	3b1c      	subs	r3, #28
 8008a66:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008a6a:	4610      	mov	r0, r2
 8008a6c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008a70:	f507 41c1 	add.w	r1, r7, #24704	@ 0x6080
 8008a74:	f101 011c 	add.w	r1, r1, #28
 8008a78:	6809      	ldr	r1, [r1, #0]
 8008a7a:	f850 0cac 	ldr.w	r0, [r0, #-172]
 8008a7e:	f008 ffa4 	bl	80119ca <f_write>
 8008a82:	4603      	mov	r3, r0
 8008a84:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008a88:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8008a8c:	7013      	strb	r3, [r2, #0]
						buff += 512;
 8008a8e:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008a92:	f103 031c 	add.w	r3, r3, #28
 8008a96:	681b      	ldr	r3, [r3, #0]
 8008a98:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8008a9c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008aa0:	f102 021c 	add.w	r2, r2, #28
 8008aa4:	6013      	str	r3, [r2, #0]
					for (int i = 0; i < f; i++)
 8008aa6:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008aaa:	f103 030c 	add.w	r3, r3, #12
 8008aae:	681b      	ldr	r3, [r3, #0]
 8008ab0:	3301      	adds	r3, #1
 8008ab2:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008ab6:	f102 020c 	add.w	r2, r2, #12
 8008aba:	6013      	str	r3, [r2, #0]
 8008abc:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ac0:	f103 037a 	add.w	r3, r3, #122	@ 0x7a
 8008ac4:	881b      	ldrh	r3, [r3, #0]
 8008ac6:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008aca:	f102 020c 	add.w	r2, r2, #12
 8008ace:	6812      	ldr	r2, [r2, #0]
 8008ad0:	429a      	cmp	r2, r3
 8008ad2:	dbc5      	blt.n	8008a60 <start_output_mjpeg_avi+0x48c>
					}

					if (r > 0)
 8008ad4:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ad8:	f103 0378 	add.w	r3, r3, #120	@ 0x78
 8008adc:	881b      	ldrh	r3, [r3, #0]
 8008ade:	2b00      	cmp	r3, #0
 8008ae0:	d019      	beq.n	8008b16 <start_output_mjpeg_avi+0x542>
					{
						res=f_write(file, buff, r, &bw);
 8008ae2:	f507 43c0 	add.w	r3, r7, #24576	@ 0x6000
 8008ae6:	f103 0378 	add.w	r3, r3, #120	@ 0x78
 8008aea:	881a      	ldrh	r2, [r3, #0]
 8008aec:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008af0:	3b1c      	subs	r3, #28
 8008af2:	f107 01b8 	add.w	r1, r7, #184	@ 0xb8
 8008af6:	4608      	mov	r0, r1
 8008af8:	f507 41c1 	add.w	r1, r7, #24704	@ 0x6080
 8008afc:	f101 011c 	add.w	r1, r1, #28
 8008b00:	6809      	ldr	r1, [r1, #0]
 8008b02:	f850 0cac 	ldr.w	r0, [r0, #-172]
 8008b06:	f008 ff60 	bl	80119ca <f_write>
 8008b0a:	4603      	mov	r3, r0
 8008b0c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008b10:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8008b14:	7013      	strb	r3, [r2, #0]

					}

					buff = dmabuff + f_begin;
 8008b16:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b1a:	f103 032e 	add.w	r3, r3, #46	@ 0x2e
 8008b1e:	881a      	ldrh	r2, [r3, #0]
 8008b20:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008b24:	3b18      	subs	r3, #24
 8008b26:	4413      	add	r3, r2
 8008b28:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008b2c:	f102 021c 	add.w	r2, r2, #28
 8008b30:	6013      	str	r3, [r2, #0]

					decode_jpeg_to_tft(buff, sublen);
 8008b32:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b36:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008b3a:	6819      	ldr	r1, [r3, #0]
 8008b3c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b40:	f103 031c 	add.w	r3, r3, #28
 8008b44:	6818      	ldr	r0, [r3, #0]
 8008b46:	f7ff f97b 	bl	8007e40 <decode_jpeg_to_tft>

					if (sublen%2)
 8008b4a:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b4e:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008b52:	681b      	ldr	r3, [r3, #0]
 8008b54:	f003 0301 	and.w	r3, r3, #1
 8008b58:	2b00      	cmp	r3, #0
 8008b5a:	d01c      	beq.n	8008b96 <start_output_mjpeg_avi+0x5c2>
					{
						sublen++;
 8008b5c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008b60:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008b64:	681b      	ldr	r3, [r3, #0]
 8008b66:	3301      	adds	r3, #1
 8008b68:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008b6c:	f102 0224 	add.w	r2, r2, #36	@ 0x24
 8008b70:	6013      	str	r3, [r2, #0]
						res=f_write(file, '\0', 1, &bw);
 8008b72:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008b76:	3b1c      	subs	r3, #28
 8008b78:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008b7c:	4610      	mov	r0, r2
 8008b7e:	2201      	movs	r2, #1
 8008b80:	2100      	movs	r1, #0
 8008b82:	f850 0cac 	ldr.w	r0, [r0, #-172]
 8008b86:	f008 ff20 	bl	80119ca <f_write>
 8008b8a:	4603      	mov	r3, r0
 8008b8c:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008b90:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8008b94:	7013      	strb	r3, [r2, #0]
					}
					frames++;
 8008b96:	4b44      	ldr	r3, [pc, #272]	@ (8008ca8 <start_output_mjpeg_avi+0x6d4>)
 8008b98:	681b      	ldr	r3, [r3, #0]
 8008b9a:	3301      	adds	r3, #1
 8008b9c:	4a42      	ldr	r2, [pc, #264]	@ (8008ca8 <start_output_mjpeg_avi+0x6d4>)
 8008b9e:	6013      	str	r3, [r2, #0]
					totalLen += (sublen);
 8008ba0:	4b42      	ldr	r3, [pc, #264]	@ (8008cac <start_output_mjpeg_avi+0x6d8>)
 8008ba2:	681a      	ldr	r2, [r3, #0]
 8008ba4:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008ba8:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008bac:	681b      	ldr	r3, [r3, #0]
 8008bae:	4413      	add	r3, r2
 8008bb0:	4a3e      	ldr	r2, [pc, #248]	@ (8008cac <start_output_mjpeg_avi+0x6d8>)
 8008bb2:	6013      	str	r3, [r2, #0]
					f_write(&temp_idx1, "00db", 4, &bw);
 8008bb4:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8008bb8:	3b1c      	subs	r3, #28
 8008bba:	f507 40a0 	add.w	r0, r7, #20480	@ 0x5000
 8008bbe:	f100 0038 	add.w	r0, r0, #56	@ 0x38
 8008bc2:	3818      	subs	r0, #24
 8008bc4:	2204      	movs	r2, #4
 8008bc6:	4937      	ldr	r1, [pc, #220]	@ (8008ca4 <start_output_mjpeg_avi+0x6d0>)
 8008bc8:	f008 feff 	bl	80119ca <f_write>
					fwrite_DWORD(&temp_idx1, 16);//AVI_KEYFRAME=16
 8008bcc:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008bd0:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8008bd4:	3b18      	subs	r3, #24
 8008bd6:	2110      	movs	r1, #16
 8008bd8:	4618      	mov	r0, r3
 8008bda:	f7ff f8ed 	bl	8007db8 <fwrite_DWORD>
					fwrite_DWORD(&temp_idx1, next_idx1_offset);
 8008bde:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008be2:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8008be6:	3b18      	subs	r3, #24
 8008be8:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008bec:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 8008bf0:	6811      	ldr	r1, [r2, #0]
 8008bf2:	4618      	mov	r0, r3
 8008bf4:	f7ff f8e0 	bl	8007db8 <fwrite_DWORD>
					fwrite_DWORD(&temp_idx1, sublen);
 8008bf8:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008bfc:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8008c00:	3b18      	subs	r3, #24
 8008c02:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008c06:	f102 0224 	add.w	r2, r2, #36	@ 0x24
 8008c0a:	6811      	ldr	r1, [r2, #0]
 8008c0c:	4618      	mov	r0, r3
 8008c0e:	f7ff f8d3 	bl	8007db8 <fwrite_DWORD>
					next_idx1_offset += (8+sublen);
 8008c12:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008c16:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8008c1a:	681a      	ldr	r2, [r3, #0]
 8008c1c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008c20:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8008c24:	681b      	ldr	r3, [r3, #0]
 8008c26:	4413      	add	r3, r2
 8008c28:	3308      	adds	r3, #8
 8008c2a:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008c2e:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 8008c32:	6013      	str	r3, [r2, #0]

					break;
 8008c34:	e014      	b.n	8008c60 <start_output_mjpeg_avi+0x68c>
			for (idx = 0; idx<MAX_AVI_BUFF-4;idx++)
 8008c36:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008c3a:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8008c3e:	681b      	ldr	r3, [r3, #0]
 8008c40:	3301      	adds	r3, #1
 8008c42:	f507 42c1 	add.w	r2, r7, #24704	@ 0x6080
 8008c46:	f102 0228 	add.w	r2, r2, #40	@ 0x28
 8008c4a:	6013      	str	r3, [r2, #0]
 8008c4c:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008c50:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8008c54:	681b      	ldr	r3, [r3, #0]
 8008c56:	f644 72fb 	movw	r2, #20475	@ 0x4ffb
 8008c5a:	4293      	cmp	r3, r2
 8008c5c:	f67f ae0a 	bls.w	8008874 <start_output_mjpeg_avi+0x2a0>
	while(bAviStartRecording == AVI_START)
 8008c60:	4b13      	ldr	r3, [pc, #76]	@ (8008cb0 <start_output_mjpeg_avi+0x6dc>)
 8008c62:	781b      	ldrb	r3, [r3, #0]
 8008c64:	2b01      	cmp	r3, #1
 8008c66:	f43f ad6c 	beq.w	8008742 <start_output_mjpeg_avi+0x16e>

			}

		}
	}
	if (bAviStartRecording == AVI_PENDING)
 8008c6a:	4b11      	ldr	r3, [pc, #68]	@ (8008cb0 <start_output_mjpeg_avi+0x6dc>)
 8008c6c:	781b      	ldrb	r3, [r3, #0]
 8008c6e:	2b02      	cmp	r3, #2
 8008c70:	d10b      	bne.n	8008c8a <start_output_mjpeg_avi+0x6b6>
	{
		stop_output_mjpeg_avi(file, &temp_idx1);
 8008c72:	f507 43a0 	add.w	r3, r7, #20480	@ 0x5000
 8008c76:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8008c7a:	3b18      	subs	r3, #24
 8008c7c:	f107 02b8 	add.w	r2, r7, #184	@ 0xb8
 8008c80:	4619      	mov	r1, r3
 8008c82:	f852 0cac 	ldr.w	r0, [r2, #-172]
 8008c86:	f000 f815 	bl	8008cb4 <stop_output_mjpeg_avi>
	}
	//bAviStartRecording = AVI_PENDING; //wait for rewriting some parameters and to close file;

	return res;
 8008c8a:	f507 43c1 	add.w	r3, r7, #24704	@ 0x6080
 8008c8e:	f103 0337 	add.w	r3, r3, #55	@ 0x37
 8008c92:	781b      	ldrb	r3, [r3, #0]
}
 8008c94:	4618      	mov	r0, r3
 8008c96:	f507 47c1 	add.w	r7, r7, #24704	@ 0x6080
 8008c9a:	373c      	adds	r7, #60	@ 0x3c
 8008c9c:	46bd      	mov	sp, r7
 8008c9e:	bd90      	pop	{r4, r7, pc}
 8008ca0:	30306462 	.word	0x30306462
 8008ca4:	0803023c 	.word	0x0803023c
 8008ca8:	200028f0 	.word	0x200028f0
 8008cac:	200028ec 	.word	0x200028ec
 8008cb0:	200028ea 	.word	0x200028ea

08008cb4 <stop_output_mjpeg_avi>:
/*						  It writes the 'idx1' chunk, updates the file size, frame count, and other     */
/*						 header information. It also closes the temporary index file and the main AVI   */
/*						 file, and sets the recording status to closed.                                 */
/********************************************************************************************************/
void stop_output_mjpeg_avi(FIL *file, FIL* temp_idx1)
{
 8008cb4:	b580      	push	{r7, lr}
 8008cb6:	f5ad 7d06 	sub.w	sp, sp, #536	@ 0x218
 8008cba:	af00      	add	r7, sp, #0
 8008cbc:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008cc0:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008cc4:	6018      	str	r0, [r3, #0]
 8008cc6:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008cca:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008cce:	6019      	str	r1, [r3, #0]
	UINT br;
	UINT bw;
	unsigned char buf[512];
	if (bAviStartRecording != AVI_PENDING) return;
 8008cd0:	4b75      	ldr	r3, [pc, #468]	@ (8008ea8 <stop_output_mjpeg_avi+0x1f4>)
 8008cd2:	781b      	ldrb	r3, [r3, #0]
 8008cd4:	2b02      	cmp	r3, #2
 8008cd6:	f040 80e2 	bne.w	8008e9e <stop_output_mjpeg_avi+0x1ea>

	f_write(file, "idx1", 4, &br);
 8008cda:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8008cde:	f507 7206 	add.w	r2, r7, #536	@ 0x218
 8008ce2:	f5a2 7005 	sub.w	r0, r2, #532	@ 0x214
 8008ce6:	2204      	movs	r2, #4
 8008ce8:	4970      	ldr	r1, [pc, #448]	@ (8008eac <stop_output_mjpeg_avi+0x1f8>)
 8008cea:	6800      	ldr	r0, [r0, #0]
 8008cec:	f008 fe6d 	bl	80119ca <f_write>
	fwrite_DWORD(file, 4*4*frames);
 8008cf0:	4b6f      	ldr	r3, [pc, #444]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008cf2:	681b      	ldr	r3, [r3, #0]
 8008cf4:	011a      	lsls	r2, r3, #4
 8008cf6:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008cfa:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008cfe:	4611      	mov	r1, r2
 8008d00:	6818      	ldr	r0, [r3, #0]
 8008d02:	f7ff f859 	bl	8007db8 <fwrite_DWORD>
	f_lseek(temp_idx1, 0);
 8008d06:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008d0a:	f5a3 7106 	sub.w	r1, r3, #536	@ 0x218
 8008d0e:	f04f 0200 	mov.w	r2, #0
 8008d12:	f04f 0300 	mov.w	r3, #0
 8008d16:	6808      	ldr	r0, [r1, #0]
 8008d18:	f009 f976 	bl	8012008 <f_lseek>
	do {
		f_read(temp_idx1, buf, 512, &br);
 8008d1c:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8008d20:	f107 010c 	add.w	r1, r7, #12
 8008d24:	f507 7206 	add.w	r2, r7, #536	@ 0x218
 8008d28:	f5a2 7006 	sub.w	r0, r2, #536	@ 0x218
 8008d2c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008d30:	6800      	ldr	r0, [r0, #0]
 8008d32:	f008 fcb2 	bl	801169a <f_read>
		f_write(file, buf, br, &bw);
 8008d36:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8008d3a:	f507 7303 	add.w	r3, r7, #524	@ 0x20c
 8008d3e:	f107 010c 	add.w	r1, r7, #12
 8008d42:	f507 7006 	add.w	r0, r7, #536	@ 0x218
 8008d46:	f5a0 7005 	sub.w	r0, r0, #532	@ 0x214
 8008d4a:	6800      	ldr	r0, [r0, #0]
 8008d4c:	f008 fe3d 	bl	80119ca <f_write>
	} while (br == 512);
 8008d50:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8008d54:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8008d58:	d0e0      	beq.n	8008d1c <stop_output_mjpeg_avi+0x68>
	f_close(temp_idx1);
 8008d5a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008d5e:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008d62:	6818      	ldr	r0, [r3, #0]
 8008d64:	f009 f926 	bl	8011fb4 <f_close>
	f_unlink("0:/temp_idx1");
 8008d68:	4852      	ldr	r0, [pc, #328]	@ (8008eb4 <stop_output_mjpeg_avi+0x200>)
 8008d6a:	f009 fd38 	bl	80127de <f_unlink>
	DWORD size;

	//RIFF_LIST.dwSize =  150 + 12 + len + 8*frames + 8 + 4*4*frames;

	//size = 150 + 12 + totalLen + 8*frames + 8 + 4*4*frames(idx1);
	size = 150 + 12 + totalLen + 8*frames + 8 + 4*4*frames;
 8008d6e:	4b50      	ldr	r3, [pc, #320]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008d70:	681b      	ldr	r3, [r3, #0]
 8008d72:	00da      	lsls	r2, r3, #3
 8008d74:	4b50      	ldr	r3, [pc, #320]	@ (8008eb8 <stop_output_mjpeg_avi+0x204>)
 8008d76:	681b      	ldr	r3, [r3, #0]
 8008d78:	441a      	add	r2, r3
 8008d7a:	4b4d      	ldr	r3, [pc, #308]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008d7c:	681b      	ldr	r3, [r3, #0]
 8008d7e:	011b      	lsls	r3, r3, #4
 8008d80:	4413      	add	r3, r2
 8008d82:	33aa      	adds	r3, #170	@ 0xaa
 8008d84:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 4);
 8008d88:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008d8c:	f5a3 7105 	sub.w	r1, r3, #532	@ 0x214
 8008d90:	f04f 0204 	mov.w	r2, #4
 8008d94:	f04f 0300 	mov.w	r3, #0
 8008d98:	6808      	ldr	r0, [r1, #0]
 8008d9a:	f009 f935 	bl	8012008 <f_lseek>
	fwrite_DWORD(file, size);
 8008d9e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008da2:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008da6:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008daa:	6818      	ldr	r0, [r3, #0]
 8008dac:	f7ff f804 	bl	8007db8 <fwrite_DWORD>

	//DWORD avih  totalframes = 0; nbr_of_jpgs;;
	size = frames;
 8008db0:	4b3f      	ldr	r3, [pc, #252]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008db2:	681b      	ldr	r3, [r3, #0]
 8008db4:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 48);
 8008db8:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008dbc:	f5a3 7105 	sub.w	r1, r3, #532	@ 0x214
 8008dc0:	f04f 0230 	mov.w	r2, #48	@ 0x30
 8008dc4:	f04f 0300 	mov.w	r3, #0
 8008dc8:	6808      	ldr	r0, [r1, #0]
 8008dca:	f009 f91d 	bl	8012008 <f_lseek>
	fwrite_DWORD(file, size);//offset+4=48
 8008dce:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008dd2:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008dd6:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008dda:	6818      	ldr	r0, [r3, #0]
 8008ddc:	f7fe ffec 	bl	8007db8 <fwrite_DWORD>

	//strh.dwLength = nbr_of_jpgs;  +4 = 36
	size=frames;
 8008de0:	4b33      	ldr	r3, [pc, #204]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008de2:	681b      	ldr	r3, [r3, #0]
 8008de4:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 140); //140
 8008de8:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008dec:	f5a3 7105 	sub.w	r1, r3, #532	@ 0x214
 8008df0:	f04f 028c 	mov.w	r2, #140	@ 0x8c
 8008df4:	f04f 0300 	mov.w	r3, #0
 8008df8:	6808      	ldr	r0, [r1, #0]
 8008dfa:	f009 f905 	bl	8012008 <f_lseek>
	fwrite_DWORD(file, size);
 8008dfe:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e02:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e06:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008e0a:	6818      	ldr	r0, [r3, #0]
 8008e0c:	f7fe ffd4 	bl	8007db8 <fwrite_DWORD>


	//totalFrames(dmlh)
	size=frames;
 8008e10:	4b27      	ldr	r3, [pc, #156]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008e12:	681b      	ldr	r3, [r3, #0]
 8008e14:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 224); //140
 8008e18:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e1c:	f5a3 7105 	sub.w	r1, r3, #532	@ 0x214
 8008e20:	f04f 02e0 	mov.w	r2, #224	@ 0xe0
 8008e24:	f04f 0300 	mov.w	r3, #0
 8008e28:	6808      	ldr	r0, [r1, #0]
 8008e2a:	f009 f8ed 	bl	8012008 <f_lseek>
	fwrite_DWORD(file, size);
 8008e2e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e32:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e36:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008e3a:	6818      	ldr	r0, [r3, #0]
 8008e3c:	f7fe ffbc 	bl	8007db8 <fwrite_DWORD>


	//movi.dwSize = len + 4 + 8*nbr_of_jpgs;
	size = totalLen + 4 + 8*frames;
 8008e40:	4b1b      	ldr	r3, [pc, #108]	@ (8008eb0 <stop_output_mjpeg_avi+0x1fc>)
 8008e42:	681b      	ldr	r3, [r3, #0]
 8008e44:	00da      	lsls	r2, r3, #3
 8008e46:	4b1c      	ldr	r3, [pc, #112]	@ (8008eb8 <stop_output_mjpeg_avi+0x204>)
 8008e48:	681b      	ldr	r3, [r3, #0]
 8008e4a:	4413      	add	r3, r2
 8008e4c:	3304      	adds	r3, #4
 8008e4e:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
	f_lseek(file, 232);
 8008e52:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e56:	f5a3 7105 	sub.w	r1, r3, #532	@ 0x214
 8008e5a:	f04f 02e8 	mov.w	r2, #232	@ 0xe8
 8008e5e:	f04f 0300 	mov.w	r3, #0
 8008e62:	6808      	ldr	r0, [r1, #0]
 8008e64:	f009 f8d0 	bl	8012008 <f_lseek>
	fwrite_DWORD(file, size);//offset+4=232
 8008e68:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e6c:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e70:	f8d7 1214 	ldr.w	r1, [r7, #532]	@ 0x214
 8008e74:	6818      	ldr	r0, [r3, #0]
 8008e76:	f7fe ff9f 	bl	8007db8 <fwrite_DWORD>
	f_close(temp_idx1);
 8008e7a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e7e:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
 8008e82:	6818      	ldr	r0, [r3, #0]
 8008e84:	f009 f896 	bl	8011fb4 <f_close>
	f_close(file);
 8008e88:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008e8c:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008e90:	6818      	ldr	r0, [r3, #0]
 8008e92:	f009 f88f 	bl	8011fb4 <f_close>
	bAviStartRecording = AVI_CLOSED_OUT;
 8008e96:	4b04      	ldr	r3, [pc, #16]	@ (8008ea8 <stop_output_mjpeg_avi+0x1f4>)
 8008e98:	2203      	movs	r2, #3
 8008e9a:	701a      	strb	r2, [r3, #0]
 8008e9c:	e000      	b.n	8008ea0 <stop_output_mjpeg_avi+0x1ec>
	if (bAviStartRecording != AVI_PENDING) return;
 8008e9e:	bf00      	nop
}
 8008ea0:	f507 7706 	add.w	r7, r7, #536	@ 0x218
 8008ea4:	46bd      	mov	sp, r7
 8008ea6:	bd80      	pop	{r7, pc}
 8008ea8:	200028ea 	.word	0x200028ea
 8008eac:	08030244 	.word	0x08030244
 8008eb0:	200028f0 	.word	0x200028f0
 8008eb4:	0803022c 	.word	0x0803022c
 8008eb8:	200028ec 	.word	0x200028ec

08008ebc <CAMERA_IO_Write>:
/* @return				- none																			*/
/*																										*/
/* @Note					- This function utilizes the I2C_Mem_Write function for communication			*/
/********************************************************************************************************/
void CAMERA_IO_Write(uint8_t deviceAddr, uint8_t reg, uint8_t value)
{
 8008ebc:	b580      	push	{r7, lr}
 8008ebe:	b084      	sub	sp, #16
 8008ec0:	af02      	add	r7, sp, #8
 8008ec2:	4603      	mov	r3, r0
 8008ec4:	71fb      	strb	r3, [r7, #7]
 8008ec6:	460b      	mov	r3, r1
 8008ec8:	71bb      	strb	r3, [r7, #6]
 8008eca:	4613      	mov	r3, r2
 8008ecc:	717b      	strb	r3, [r7, #5]
	I2C_Mem_Write(&hi2c1, deviceAddr, reg, I2C_MEMADD_SIZE_8BIT, &value, 1);
 8008ece:	79fb      	ldrb	r3, [r7, #7]
 8008ed0:	b299      	uxth	r1, r3
 8008ed2:	79bb      	ldrb	r3, [r7, #6]
 8008ed4:	b29a      	uxth	r2, r3
 8008ed6:	2301      	movs	r3, #1
 8008ed8:	9301      	str	r3, [sp, #4]
 8008eda:	1d7b      	adds	r3, r7, #5
 8008edc:	9300      	str	r3, [sp, #0]
 8008ede:	2301      	movs	r3, #1
 8008ee0:	4803      	ldr	r0, [pc, #12]	@ (8008ef0 <CAMERA_IO_Write+0x34>)
 8008ee2:	f000 fe3b 	bl	8009b5c <I2C_Mem_Write>
}
 8008ee6:	bf00      	nop
 8008ee8:	3708      	adds	r7, #8
 8008eea:	46bd      	mov	sp, r7
 8008eec:	bd80      	pop	{r7, pc}
 8008eee:	bf00      	nop
 8008ef0:	2000013c 	.word	0x2000013c

08008ef4 <CAMERA_Delay>:
/* @return				- none																			*/
/*																										*/
/* @Note					- This function is a wrapper for delay_ms										*/
/********************************************************************************************************/
void CAMERA_Delay(uint32_t Delay)
{
 8008ef4:	b580      	push	{r7, lr}
 8008ef6:	b082      	sub	sp, #8
 8008ef8:	af00      	add	r7, sp, #0
 8008efa:	6078      	str	r0, [r7, #4]
	delay_ms(Delay);
 8008efc:	687b      	ldr	r3, [r7, #4]
 8008efe:	4618      	mov	r0, r3
 8008f00:	f001 faba 	bl	800a478 <delay_ms>
}
 8008f04:	bf00      	nop
 8008f06:	3708      	adds	r7, #8
 8008f08:	46bd      	mov	sp, r7
 8008f0a:	bd80      	pop	{r7, pc}

08008f0c <ov2640_Init>:
/*																										*/
/* @Note					- This function performs hardware and software initialization steps and 		*/
/* 						  configures the camera based on the specified action.							*/
/********************************************************************************************************/
void ov2640_Init(uint16_t DeviceAddr, uint8_t action)
{
 8008f0c:	b580      	push	{r7, lr}
 8008f0e:	b084      	sub	sp, #16
 8008f10:	af00      	add	r7, sp, #0
 8008f12:	4603      	mov	r3, r0
 8008f14:	460a      	mov	r2, r1
 8008f16:	80fb      	strh	r3, [r7, #6]
 8008f18:	4613      	mov	r3, r2
 8008f1a:	717b      	strb	r3, [r7, #5]
  uint32_t index;

  //hardware and software initialization

  //power on
  GPIO_WritePin(CAMERA_PWDN_GPIO_Port, CAMERA_PWDN_Pin, RESET);
 8008f1c:	2200      	movs	r2, #0
 8008f1e:	210c      	movs	r1, #12
 8008f20:	4892      	ldr	r0, [pc, #584]	@ (800916c <ov2640_Init+0x260>)
 8008f22:	f000 fbf9 	bl	8009718 <GPIO_WritePin>
  delay_ms(1);
 8008f26:	2001      	movs	r0, #1
 8008f28:	f001 faa6 	bl	800a478 <delay_ms>
  //hardware reset
  GPIO_WritePin(CAMERA_RESET_GPIO_Port, CAMERA_RESET_Pin, RESET);
 8008f2c:	2200      	movs	r2, #0
 8008f2e:	2100      	movs	r1, #0
 8008f30:	488f      	ldr	r0, [pc, #572]	@ (8009170 <ov2640_Init+0x264>)
 8008f32:	f000 fbf1 	bl	8009718 <GPIO_WritePin>
  delay_ms(1);
 8008f36:	2001      	movs	r0, #1
 8008f38:	f001 fa9e 	bl	800a478 <delay_ms>
  GPIO_WritePin(CAMERA_RESET_GPIO_Port, CAMERA_RESET_Pin, SET);
 8008f3c:	2201      	movs	r2, #1
 8008f3e:	2100      	movs	r1, #0
 8008f40:	488b      	ldr	r0, [pc, #556]	@ (8009170 <ov2640_Init+0x264>)
 8008f42:	f000 fbe9 	bl	8009718 <GPIO_WritePin>
  delay_ms(1);
 8008f46:	2001      	movs	r0, #1
 8008f48:	f001 fa96 	bl	800a478 <delay_ms>

  // prepare the camera to be configured
  CAMERA_IO_Write(DeviceAddr, 0xff, 0x01);
 8008f4c:	88fb      	ldrh	r3, [r7, #6]
 8008f4e:	b2db      	uxtb	r3, r3
 8008f50:	2201      	movs	r2, #1
 8008f52:	21ff      	movs	r1, #255	@ 0xff
 8008f54:	4618      	mov	r0, r3
 8008f56:	f7ff ffb1 	bl	8008ebc <CAMERA_IO_Write>
  CAMERA_IO_Write(DeviceAddr, 0x12, 0x80);
 8008f5a:	88fb      	ldrh	r3, [r7, #6]
 8008f5c:	b2db      	uxtb	r3, r3
 8008f5e:	2280      	movs	r2, #128	@ 0x80
 8008f60:	2112      	movs	r1, #18
 8008f62:	4618      	mov	r0, r3
 8008f64:	f7ff ffaa 	bl	8008ebc <CAMERA_IO_Write>
  CAMERA_Delay(20);
 8008f68:	2014      	movs	r0, #20
 8008f6a:	f7ff ffc3 	bl	8008ef4 <CAMERA_Delay>

  // initialize OV2640
  switch (action)
 8008f6e:	797b      	ldrb	r3, [r7, #5]
 8008f70:	2b02      	cmp	r3, #2
 8008f72:	f000 808c 	beq.w	800908e <ov2640_Init+0x182>
 8008f76:	2b02      	cmp	r3, #2
 8008f78:	f300 80f2 	bgt.w	8009160 <ov2640_Init+0x254>
 8008f7c:	2b00      	cmp	r3, #0
 8008f7e:	d06b      	beq.n	8009058 <ov2640_Init+0x14c>
 8008f80:	2b01      	cmp	r3, #1
 8008f82:	f040 80ed 	bne.w	8009160 <ov2640_Init+0x254>
  {
	case CAMERA_Movie:
	{
		for(index = 0; index < (sizeof(OV2640_JPEG_INIT) / 2); index++)
 8008f86:	2300      	movs	r3, #0
 8008f88:	60fb      	str	r3, [r7, #12]
 8008f8a:	e013      	b.n	8008fb4 <ov2640_Init+0xa8>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_JPEG_INIT[index][0], OV2640_JPEG_INIT[index][1]);
 8008f8c:	88fb      	ldrh	r3, [r7, #6]
 8008f8e:	b2d8      	uxtb	r0, r3
 8008f90:	4a78      	ldr	r2, [pc, #480]	@ (8009174 <ov2640_Init+0x268>)
 8008f92:	68fb      	ldr	r3, [r7, #12]
 8008f94:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8008f98:	4a76      	ldr	r2, [pc, #472]	@ (8009174 <ov2640_Init+0x268>)
 8008f9a:	68fb      	ldr	r3, [r7, #12]
 8008f9c:	005b      	lsls	r3, r3, #1
 8008f9e:	4413      	add	r3, r2
 8008fa0:	785b      	ldrb	r3, [r3, #1]
 8008fa2:	461a      	mov	r2, r3
 8008fa4:	f7ff ff8a 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 8008fa8:	2001      	movs	r0, #1
 8008faa:	f7ff ffa3 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_JPEG_INIT) / 2); index++)
 8008fae:	68fb      	ldr	r3, [r7, #12]
 8008fb0:	3301      	adds	r3, #1
 8008fb2:	60fb      	str	r3, [r7, #12]
 8008fb4:	68fb      	ldr	r3, [r7, #12]
 8008fb6:	2bbe      	cmp	r3, #190	@ 0xbe
 8008fb8:	d9e8      	bls.n	8008f8c <ov2640_Init+0x80>
		}

		for(index = 0; index < (sizeof(OV2640_YUV422) / 2); index++)
 8008fba:	2300      	movs	r3, #0
 8008fbc:	60fb      	str	r3, [r7, #12]
 8008fbe:	e013      	b.n	8008fe8 <ov2640_Init+0xdc>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_YUV422[index][0], OV2640_YUV422[index][1]);
 8008fc0:	88fb      	ldrh	r3, [r7, #6]
 8008fc2:	b2d8      	uxtb	r0, r3
 8008fc4:	4a6c      	ldr	r2, [pc, #432]	@ (8009178 <ov2640_Init+0x26c>)
 8008fc6:	68fb      	ldr	r3, [r7, #12]
 8008fc8:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8008fcc:	4a6a      	ldr	r2, [pc, #424]	@ (8009178 <ov2640_Init+0x26c>)
 8008fce:	68fb      	ldr	r3, [r7, #12]
 8008fd0:	005b      	lsls	r3, r3, #1
 8008fd2:	4413      	add	r3, r2
 8008fd4:	785b      	ldrb	r3, [r3, #1]
 8008fd6:	461a      	mov	r2, r3
 8008fd8:	f7ff ff70 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 8008fdc:	2001      	movs	r0, #1
 8008fde:	f7ff ff89 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_YUV422) / 2); index++)
 8008fe2:	68fb      	ldr	r3, [r7, #12]
 8008fe4:	3301      	adds	r3, #1
 8008fe6:	60fb      	str	r3, [r7, #12]
 8008fe8:	68fb      	ldr	r3, [r7, #12]
 8008fea:	2b09      	cmp	r3, #9
 8008fec:	d9e8      	bls.n	8008fc0 <ov2640_Init+0xb4>
		}

		for(index = 0; index < (sizeof(OV2640_JPEG) / 2); index++)
 8008fee:	2300      	movs	r3, #0
 8008ff0:	60fb      	str	r3, [r7, #12]
 8008ff2:	e013      	b.n	800901c <ov2640_Init+0x110>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_JPEG[index][0], OV2640_JPEG[index][1]);
 8008ff4:	88fb      	ldrh	r3, [r7, #6]
 8008ff6:	b2d8      	uxtb	r0, r3
 8008ff8:	4a60      	ldr	r2, [pc, #384]	@ (800917c <ov2640_Init+0x270>)
 8008ffa:	68fb      	ldr	r3, [r7, #12]
 8008ffc:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009000:	4a5e      	ldr	r2, [pc, #376]	@ (800917c <ov2640_Init+0x270>)
 8009002:	68fb      	ldr	r3, [r7, #12]
 8009004:	005b      	lsls	r3, r3, #1
 8009006:	4413      	add	r3, r2
 8009008:	785b      	ldrb	r3, [r3, #1]
 800900a:	461a      	mov	r2, r3
 800900c:	f7ff ff56 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 8009010:	2001      	movs	r0, #1
 8009012:	f7ff ff6f 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_JPEG) / 2); index++)
 8009016:	68fb      	ldr	r3, [r7, #12]
 8009018:	3301      	adds	r3, #1
 800901a:	60fb      	str	r3, [r7, #12]
 800901c:	68fb      	ldr	r3, [r7, #12]
 800901e:	2b08      	cmp	r3, #8
 8009020:	d9e8      	bls.n	8008ff4 <ov2640_Init+0xe8>
		}

		for(index = 0; index < (sizeof(OV2640_320x240_JPEG) / 2); index++)
 8009022:	2300      	movs	r3, #0
 8009024:	60fb      	str	r3, [r7, #12]
 8009026:	e013      	b.n	8009050 <ov2640_Init+0x144>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_320x240_JPEG[index][0], OV2640_320x240_JPEG[index][1]);
 8009028:	88fb      	ldrh	r3, [r7, #6]
 800902a:	b2d8      	uxtb	r0, r3
 800902c:	4a54      	ldr	r2, [pc, #336]	@ (8009180 <ov2640_Init+0x274>)
 800902e:	68fb      	ldr	r3, [r7, #12]
 8009030:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009034:	4a52      	ldr	r2, [pc, #328]	@ (8009180 <ov2640_Init+0x274>)
 8009036:	68fb      	ldr	r3, [r7, #12]
 8009038:	005b      	lsls	r3, r3, #1
 800903a:	4413      	add	r3, r2
 800903c:	785b      	ldrb	r3, [r3, #1]
 800903e:	461a      	mov	r2, r3
 8009040:	f7ff ff3c 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 8009044:	2001      	movs	r0, #1
 8009046:	f7ff ff55 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_320x240_JPEG) / 2); index++)
 800904a:	68fb      	ldr	r3, [r7, #12]
 800904c:	3301      	adds	r3, #1
 800904e:	60fb      	str	r3, [r7, #12]
 8009050:	68fb      	ldr	r3, [r7, #12]
 8009052:	2b27      	cmp	r3, #39	@ 0x27
 8009054:	d9e8      	bls.n	8009028 <ov2640_Init+0x11c>
		}
		break;
 8009056:	e084      	b.n	8009162 <ov2640_Init+0x256>
	}

	case CAMERA_Monitor:
	{
		for(index = 0; index < (sizeof(OV2640_QVGA) / 2); index++)
 8009058:	2300      	movs	r3, #0
 800905a:	60fb      	str	r3, [r7, #12]
 800905c:	e013      	b.n	8009086 <ov2640_Init+0x17a>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_QVGA[index][0], OV2640_QVGA[index][1]);
 800905e:	88fb      	ldrh	r3, [r7, #6]
 8009060:	b2d8      	uxtb	r0, r3
 8009062:	4a48      	ldr	r2, [pc, #288]	@ (8009184 <ov2640_Init+0x278>)
 8009064:	68fb      	ldr	r3, [r7, #12]
 8009066:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 800906a:	4a46      	ldr	r2, [pc, #280]	@ (8009184 <ov2640_Init+0x278>)
 800906c:	68fb      	ldr	r3, [r7, #12]
 800906e:	005b      	lsls	r3, r3, #1
 8009070:	4413      	add	r3, r2
 8009072:	785b      	ldrb	r3, [r3, #1]
 8009074:	461a      	mov	r2, r3
 8009076:	f7ff ff21 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 800907a:	2001      	movs	r0, #1
 800907c:	f7ff ff3a 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_QVGA) / 2); index++)
 8009080:	68fb      	ldr	r3, [r7, #12]
 8009082:	3301      	adds	r3, #1
 8009084:	60fb      	str	r3, [r7, #12]
 8009086:	68fb      	ldr	r3, [r7, #12]
 8009088:	2bda      	cmp	r3, #218	@ 0xda
 800908a:	d9e8      	bls.n	800905e <ov2640_Init+0x152>
		}
		break;
 800908c:	e069      	b.n	8009162 <ov2640_Init+0x256>
	}
	case CAMERA_Picture:
	{
		for(index = 0; index < (sizeof(OV2640_JPEG_INIT) / 2); index++)
 800908e:	2300      	movs	r3, #0
 8009090:	60fb      	str	r3, [r7, #12]
 8009092:	e013      	b.n	80090bc <ov2640_Init+0x1b0>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_JPEG_INIT[index][0], OV2640_JPEG_INIT[index][1]);
 8009094:	88fb      	ldrh	r3, [r7, #6]
 8009096:	b2d8      	uxtb	r0, r3
 8009098:	4a36      	ldr	r2, [pc, #216]	@ (8009174 <ov2640_Init+0x268>)
 800909a:	68fb      	ldr	r3, [r7, #12]
 800909c:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 80090a0:	4a34      	ldr	r2, [pc, #208]	@ (8009174 <ov2640_Init+0x268>)
 80090a2:	68fb      	ldr	r3, [r7, #12]
 80090a4:	005b      	lsls	r3, r3, #1
 80090a6:	4413      	add	r3, r2
 80090a8:	785b      	ldrb	r3, [r3, #1]
 80090aa:	461a      	mov	r2, r3
 80090ac:	f7ff ff06 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 80090b0:	2001      	movs	r0, #1
 80090b2:	f7ff ff1f 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_JPEG_INIT) / 2); index++)
 80090b6:	68fb      	ldr	r3, [r7, #12]
 80090b8:	3301      	adds	r3, #1
 80090ba:	60fb      	str	r3, [r7, #12]
 80090bc:	68fb      	ldr	r3, [r7, #12]
 80090be:	2bbe      	cmp	r3, #190	@ 0xbe
 80090c0:	d9e8      	bls.n	8009094 <ov2640_Init+0x188>
		}

		for(index = 0; index < (sizeof(OV2640_YUV422) / 2); index++)
 80090c2:	2300      	movs	r3, #0
 80090c4:	60fb      	str	r3, [r7, #12]
 80090c6:	e013      	b.n	80090f0 <ov2640_Init+0x1e4>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_YUV422[index][0], OV2640_YUV422[index][1]);
 80090c8:	88fb      	ldrh	r3, [r7, #6]
 80090ca:	b2d8      	uxtb	r0, r3
 80090cc:	4a2a      	ldr	r2, [pc, #168]	@ (8009178 <ov2640_Init+0x26c>)
 80090ce:	68fb      	ldr	r3, [r7, #12]
 80090d0:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 80090d4:	4a28      	ldr	r2, [pc, #160]	@ (8009178 <ov2640_Init+0x26c>)
 80090d6:	68fb      	ldr	r3, [r7, #12]
 80090d8:	005b      	lsls	r3, r3, #1
 80090da:	4413      	add	r3, r2
 80090dc:	785b      	ldrb	r3, [r3, #1]
 80090de:	461a      	mov	r2, r3
 80090e0:	f7ff feec 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 80090e4:	2001      	movs	r0, #1
 80090e6:	f7ff ff05 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_YUV422) / 2); index++)
 80090ea:	68fb      	ldr	r3, [r7, #12]
 80090ec:	3301      	adds	r3, #1
 80090ee:	60fb      	str	r3, [r7, #12]
 80090f0:	68fb      	ldr	r3, [r7, #12]
 80090f2:	2b09      	cmp	r3, #9
 80090f4:	d9e8      	bls.n	80090c8 <ov2640_Init+0x1bc>
		}

		for(index = 0; index < (sizeof(OV2640_JPEG) / 2); index++)
 80090f6:	2300      	movs	r3, #0
 80090f8:	60fb      	str	r3, [r7, #12]
 80090fa:	e013      	b.n	8009124 <ov2640_Init+0x218>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_JPEG[index][0], OV2640_JPEG[index][1]);
 80090fc:	88fb      	ldrh	r3, [r7, #6]
 80090fe:	b2d8      	uxtb	r0, r3
 8009100:	4a1e      	ldr	r2, [pc, #120]	@ (800917c <ov2640_Init+0x270>)
 8009102:	68fb      	ldr	r3, [r7, #12]
 8009104:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 8009108:	4a1c      	ldr	r2, [pc, #112]	@ (800917c <ov2640_Init+0x270>)
 800910a:	68fb      	ldr	r3, [r7, #12]
 800910c:	005b      	lsls	r3, r3, #1
 800910e:	4413      	add	r3, r2
 8009110:	785b      	ldrb	r3, [r3, #1]
 8009112:	461a      	mov	r2, r3
 8009114:	f7ff fed2 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 8009118:	2001      	movs	r0, #1
 800911a:	f7ff feeb 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_JPEG) / 2); index++)
 800911e:	68fb      	ldr	r3, [r7, #12]
 8009120:	3301      	adds	r3, #1
 8009122:	60fb      	str	r3, [r7, #12]
 8009124:	68fb      	ldr	r3, [r7, #12]
 8009126:	2b08      	cmp	r3, #8
 8009128:	d9e8      	bls.n	80090fc <ov2640_Init+0x1f0>
		}

		for(index = 0; index < (sizeof(OV2640_1280x960_JPEG) / 2); index++)
 800912a:	2300      	movs	r3, #0
 800912c:	60fb      	str	r3, [r7, #12]
 800912e:	e013      	b.n	8009158 <ov2640_Init+0x24c>
		{
			CAMERA_IO_Write(DeviceAddr, OV2640_1280x960_JPEG[index][0], OV2640_1280x960_JPEG[index][1]);
 8009130:	88fb      	ldrh	r3, [r7, #6]
 8009132:	b2d8      	uxtb	r0, r3
 8009134:	4a14      	ldr	r2, [pc, #80]	@ (8009188 <ov2640_Init+0x27c>)
 8009136:	68fb      	ldr	r3, [r7, #12]
 8009138:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
 800913c:	4a12      	ldr	r2, [pc, #72]	@ (8009188 <ov2640_Init+0x27c>)
 800913e:	68fb      	ldr	r3, [r7, #12]
 8009140:	005b      	lsls	r3, r3, #1
 8009142:	4413      	add	r3, r2
 8009144:	785b      	ldrb	r3, [r3, #1]
 8009146:	461a      	mov	r2, r3
 8009148:	f7ff feb8 	bl	8008ebc <CAMERA_IO_Write>
			CAMERA_Delay(1);
 800914c:	2001      	movs	r0, #1
 800914e:	f7ff fed1 	bl	8008ef4 <CAMERA_Delay>
		for(index = 0; index < (sizeof(OV2640_1280x960_JPEG) / 2); index++)
 8009152:	68fb      	ldr	r3, [r7, #12]
 8009154:	3301      	adds	r3, #1
 8009156:	60fb      	str	r3, [r7, #12]
 8009158:	68fb      	ldr	r3, [r7, #12]
 800915a:	2b28      	cmp	r3, #40	@ 0x28
 800915c:	d9e8      	bls.n	8009130 <ov2640_Init+0x224>
		}
		break;
 800915e:	e000      	b.n	8009162 <ov2640_Init+0x256>
	}

	default:
	{
		break;
 8009160:	bf00      	nop
	}
  }
}
 8009162:	bf00      	nop
 8009164:	3710      	adds	r7, #16
 8009166:	46bd      	mov	sp, r7
 8009168:	bd80      	pop	{r7, pc}
 800916a:	bf00      	nop
 800916c:	40020800 	.word	0x40020800
 8009170:	40020c00 	.word	0x40020c00
 8009174:	08031798 	.word	0x08031798
 8009178:	08031918 	.word	0x08031918
 800917c:	0803192c 	.word	0x0803192c
 8009180:	08031940 	.word	0x08031940
 8009184:	080315e0 	.word	0x080315e0
 8009188:	08031990 	.word	0x08031990

0800918c <GPIO_PeriphClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void GPIO_PeriphClockControl(GPIO_RegDef_t *pGPIOx, uint8_t state)
{
 800918c:	b480      	push	{r7}
 800918e:	b083      	sub	sp, #12
 8009190:	af00      	add	r7, sp, #0
 8009192:	6078      	str	r0, [r7, #4]
 8009194:	460b      	mov	r3, r1
 8009196:	70fb      	strb	r3, [r7, #3]
		if(pGPIOx == GPIOA)
 8009198:	687b      	ldr	r3, [r7, #4]
 800919a:	4a41      	ldr	r2, [pc, #260]	@ (80092a0 <GPIO_PeriphClockControl+0x114>)
 800919c:	4293      	cmp	r3, r2
 800919e:	d109      	bne.n	80091b4 <GPIO_PeriphClockControl+0x28>
		{
			RCC->AHB1ENR.bit.gpioaen = state;
 80091a0:	4a40      	ldr	r2, [pc, #256]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 80091a2:	78fb      	ldrb	r3, [r7, #3]
 80091a4:	f003 0301 	and.w	r3, r3, #1
 80091a8:	b2d9      	uxtb	r1, r3
 80091aa:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80091ac:	f361 0300 	bfi	r3, r1, #0, #1
 80091b0:	6313      	str	r3, [r2, #48]	@ 0x30
			RCC->AHB1ENR.bit.gpiohen = state;
		}else if(pGPIOx == GPIOI)
		{
			RCC->AHB1ENR.bit.gpioien = state;
		}
}
 80091b2:	e06e      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOB)
 80091b4:	687b      	ldr	r3, [r7, #4]
 80091b6:	4a3c      	ldr	r2, [pc, #240]	@ (80092a8 <GPIO_PeriphClockControl+0x11c>)
 80091b8:	4293      	cmp	r3, r2
 80091ba:	d109      	bne.n	80091d0 <GPIO_PeriphClockControl+0x44>
			RCC->AHB1ENR.bit.gpioben = state;
 80091bc:	4a39      	ldr	r2, [pc, #228]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 80091be:	78fb      	ldrb	r3, [r7, #3]
 80091c0:	f003 0301 	and.w	r3, r3, #1
 80091c4:	b2d9      	uxtb	r1, r3
 80091c6:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80091c8:	f361 0341 	bfi	r3, r1, #1, #1
 80091cc:	6313      	str	r3, [r2, #48]	@ 0x30
}
 80091ce:	e060      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOC)
 80091d0:	687b      	ldr	r3, [r7, #4]
 80091d2:	4a36      	ldr	r2, [pc, #216]	@ (80092ac <GPIO_PeriphClockControl+0x120>)
 80091d4:	4293      	cmp	r3, r2
 80091d6:	d109      	bne.n	80091ec <GPIO_PeriphClockControl+0x60>
			RCC->AHB1ENR.bit.gpiocen = state;
 80091d8:	4a32      	ldr	r2, [pc, #200]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 80091da:	78fb      	ldrb	r3, [r7, #3]
 80091dc:	f003 0301 	and.w	r3, r3, #1
 80091e0:	b2d9      	uxtb	r1, r3
 80091e2:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80091e4:	f361 0382 	bfi	r3, r1, #2, #1
 80091e8:	6313      	str	r3, [r2, #48]	@ 0x30
}
 80091ea:	e052      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOD)
 80091ec:	687b      	ldr	r3, [r7, #4]
 80091ee:	4a30      	ldr	r2, [pc, #192]	@ (80092b0 <GPIO_PeriphClockControl+0x124>)
 80091f0:	4293      	cmp	r3, r2
 80091f2:	d109      	bne.n	8009208 <GPIO_PeriphClockControl+0x7c>
			RCC->AHB1ENR.bit.gpioden = state;
 80091f4:	4a2b      	ldr	r2, [pc, #172]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 80091f6:	78fb      	ldrb	r3, [r7, #3]
 80091f8:	f003 0301 	and.w	r3, r3, #1
 80091fc:	b2d9      	uxtb	r1, r3
 80091fe:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009200:	f361 03c3 	bfi	r3, r1, #3, #1
 8009204:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009206:	e044      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOE)
 8009208:	687b      	ldr	r3, [r7, #4]
 800920a:	4a2a      	ldr	r2, [pc, #168]	@ (80092b4 <GPIO_PeriphClockControl+0x128>)
 800920c:	4293      	cmp	r3, r2
 800920e:	d109      	bne.n	8009224 <GPIO_PeriphClockControl+0x98>
			RCC->AHB1ENR.bit.gpioeen = state;
 8009210:	4a24      	ldr	r2, [pc, #144]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 8009212:	78fb      	ldrb	r3, [r7, #3]
 8009214:	f003 0301 	and.w	r3, r3, #1
 8009218:	b2d9      	uxtb	r1, r3
 800921a:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 800921c:	f361 1304 	bfi	r3, r1, #4, #1
 8009220:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009222:	e036      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOF)
 8009224:	687b      	ldr	r3, [r7, #4]
 8009226:	4a24      	ldr	r2, [pc, #144]	@ (80092b8 <GPIO_PeriphClockControl+0x12c>)
 8009228:	4293      	cmp	r3, r2
 800922a:	d109      	bne.n	8009240 <GPIO_PeriphClockControl+0xb4>
			RCC->AHB1ENR.bit.gpiofen = state;
 800922c:	4a1d      	ldr	r2, [pc, #116]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 800922e:	78fb      	ldrb	r3, [r7, #3]
 8009230:	f003 0301 	and.w	r3, r3, #1
 8009234:	b2d9      	uxtb	r1, r3
 8009236:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009238:	f361 1345 	bfi	r3, r1, #5, #1
 800923c:	6313      	str	r3, [r2, #48]	@ 0x30
}
 800923e:	e028      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOG)
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	4a1e      	ldr	r2, [pc, #120]	@ (80092bc <GPIO_PeriphClockControl+0x130>)
 8009244:	4293      	cmp	r3, r2
 8009246:	d109      	bne.n	800925c <GPIO_PeriphClockControl+0xd0>
			RCC->AHB1ENR.bit.gpiogen = state;
 8009248:	4a16      	ldr	r2, [pc, #88]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 800924a:	78fb      	ldrb	r3, [r7, #3]
 800924c:	f003 0301 	and.w	r3, r3, #1
 8009250:	b2d9      	uxtb	r1, r3
 8009252:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009254:	f361 1386 	bfi	r3, r1, #6, #1
 8009258:	6313      	str	r3, [r2, #48]	@ 0x30
}
 800925a:	e01a      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOH)
 800925c:	687b      	ldr	r3, [r7, #4]
 800925e:	4a18      	ldr	r2, [pc, #96]	@ (80092c0 <GPIO_PeriphClockControl+0x134>)
 8009260:	4293      	cmp	r3, r2
 8009262:	d109      	bne.n	8009278 <GPIO_PeriphClockControl+0xec>
			RCC->AHB1ENR.bit.gpiohen = state;
 8009264:	4a0f      	ldr	r2, [pc, #60]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 8009266:	78fb      	ldrb	r3, [r7, #3]
 8009268:	f003 0301 	and.w	r3, r3, #1
 800926c:	b2d9      	uxtb	r1, r3
 800926e:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8009270:	f361 13c7 	bfi	r3, r1, #7, #1
 8009274:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009276:	e00c      	b.n	8009292 <GPIO_PeriphClockControl+0x106>
		}else if(pGPIOx == GPIOI)
 8009278:	687b      	ldr	r3, [r7, #4]
 800927a:	4a12      	ldr	r2, [pc, #72]	@ (80092c4 <GPIO_PeriphClockControl+0x138>)
 800927c:	4293      	cmp	r3, r2
 800927e:	d108      	bne.n	8009292 <GPIO_PeriphClockControl+0x106>
			RCC->AHB1ENR.bit.gpioien = state;
 8009280:	4a08      	ldr	r2, [pc, #32]	@ (80092a4 <GPIO_PeriphClockControl+0x118>)
 8009282:	78fb      	ldrb	r3, [r7, #3]
 8009284:	f003 0301 	and.w	r3, r3, #1
 8009288:	b2d9      	uxtb	r1, r3
 800928a:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 800928c:	f361 2308 	bfi	r3, r1, #8, #1
 8009290:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8009292:	bf00      	nop
 8009294:	370c      	adds	r7, #12
 8009296:	46bd      	mov	sp, r7
 8009298:	f85d 7b04 	ldr.w	r7, [sp], #4
 800929c:	4770      	bx	lr
 800929e:	bf00      	nop
 80092a0:	40020000 	.word	0x40020000
 80092a4:	40023800 	.word	0x40023800
 80092a8:	40020400 	.word	0x40020400
 80092ac:	40020800 	.word	0x40020800
 80092b0:	40020c00 	.word	0x40020c00
 80092b4:	40021000 	.word	0x40021000
 80092b8:	40021400 	.word	0x40021400
 80092bc:	40021800 	.word	0x40021800
 80092c0:	40021c00 	.word	0x40021c00
 80092c4:	40022000 	.word	0x40022000

080092c8 <GPIO_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
 80092c8:	b580      	push	{r7, lr}
 80092ca:	b086      	sub	sp, #24
 80092cc:	af00      	add	r7, sp, #0
 80092ce:	6078      	str	r0, [r7, #4]
	uint32_t temp = 0;		//temporary register var
 80092d0:	2300      	movs	r3, #0
 80092d2:	617b      	str	r3, [r7, #20]

	//enable peripheral clock
	GPIO_PeriphClockControl(pGPIOHandle->pGPIOx, ENABLE);
 80092d4:	687b      	ldr	r3, [r7, #4]
 80092d6:	681b      	ldr	r3, [r3, #0]
 80092d8:	2101      	movs	r1, #1
 80092da:	4618      	mov	r0, r3
 80092dc:	f7ff ff56 	bl	800918c <GPIO_PeriphClockControl>

	if(pGPIOHandle->GPIO_Config.PinMode <= GPIO_MODE_ANALOG)
 80092e0:	687b      	ldr	r3, [r7, #4]
 80092e2:	7a1b      	ldrb	r3, [r3, #8]
 80092e4:	2b03      	cmp	r3, #3
 80092e6:	d81f      	bhi.n	8009328 <GPIO_Init+0x60>
	{
		temp = pGPIOHandle->GPIO_Config.PinMode << (2 * pGPIOHandle->GPIO_Config.PinNumber); /*< shift to left by 2 bits because
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	7a1b      	ldrb	r3, [r3, #8]
 80092ec:	461a      	mov	r2, r3
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	685b      	ldr	r3, [r3, #4]
 80092f2:	005b      	lsls	r3, r3, #1
 80092f4:	fa02 f303 	lsl.w	r3, r2, r3
 80092f8:	617b      	str	r3, [r7, #20]
																							 each pin in MODER is two bits >*/
		pGPIOHandle->pGPIOx->MODER.reg &= ~(0x3 << pGPIOHandle->GPIO_Config.PinNumber);
 80092fa:	687b      	ldr	r3, [r7, #4]
 80092fc:	681b      	ldr	r3, [r3, #0]
 80092fe:	681a      	ldr	r2, [r3, #0]
 8009300:	687b      	ldr	r3, [r7, #4]
 8009302:	685b      	ldr	r3, [r3, #4]
 8009304:	2103      	movs	r1, #3
 8009306:	fa01 f303 	lsl.w	r3, r1, r3
 800930a:	43db      	mvns	r3, r3
 800930c:	4619      	mov	r1, r3
 800930e:	687b      	ldr	r3, [r7, #4]
 8009310:	681b      	ldr	r3, [r3, #0]
 8009312:	400a      	ands	r2, r1
 8009314:	601a      	str	r2, [r3, #0]
		pGPIOHandle->pGPIOx->MODER.reg |= temp;
 8009316:	687b      	ldr	r3, [r7, #4]
 8009318:	681b      	ldr	r3, [r3, #0]
 800931a:	6819      	ldr	r1, [r3, #0]
 800931c:	687b      	ldr	r3, [r7, #4]
 800931e:	681b      	ldr	r3, [r3, #0]
 8009320:	697a      	ldr	r2, [r7, #20]
 8009322:	430a      	orrs	r2, r1
 8009324:	601a      	str	r2, [r3, #0]
 8009326:	e113      	b.n	8009550 <GPIO_Init+0x288>
	}else
	{
		//interrupt mode
		if(GPIO_MODE_IT_FT == pGPIOHandle->GPIO_Config.PinMode)
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	7a1b      	ldrb	r3, [r3, #8]
 800932c:	2b06      	cmp	r3, #6
 800932e:	d117      	bne.n	8009360 <GPIO_Init+0x98>
		{
			//configure FTSR
			EXTI->FTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in FTSR
 8009330:	4b6c      	ldr	r3, [pc, #432]	@ (80094e4 <GPIO_Init+0x21c>)
 8009332:	68db      	ldr	r3, [r3, #12]
 8009334:	687a      	ldr	r2, [r7, #4]
 8009336:	6852      	ldr	r2, [r2, #4]
 8009338:	2101      	movs	r1, #1
 800933a:	fa01 f202 	lsl.w	r2, r1, r2
 800933e:	4611      	mov	r1, r2
 8009340:	4a68      	ldr	r2, [pc, #416]	@ (80094e4 <GPIO_Init+0x21c>)
 8009342:	430b      	orrs	r3, r1
 8009344:	60d3      	str	r3, [r2, #12]
			EXTI->RTSR.reg &= ~(1 << pGPIOHandle->GPIO_Config.PinNumber); 	//clear bit in RTSR just in case it is not reset
 8009346:	4b67      	ldr	r3, [pc, #412]	@ (80094e4 <GPIO_Init+0x21c>)
 8009348:	689b      	ldr	r3, [r3, #8]
 800934a:	687a      	ldr	r2, [r7, #4]
 800934c:	6852      	ldr	r2, [r2, #4]
 800934e:	2101      	movs	r1, #1
 8009350:	fa01 f202 	lsl.w	r2, r1, r2
 8009354:	43d2      	mvns	r2, r2
 8009356:	4611      	mov	r1, r2
 8009358:	4a62      	ldr	r2, [pc, #392]	@ (80094e4 <GPIO_Init+0x21c>)
 800935a:	400b      	ands	r3, r1
 800935c:	6093      	str	r3, [r2, #8]
 800935e:	e035      	b.n	80093cc <GPIO_Init+0x104>
		}else if(GPIO_MODE_IT_RT == pGPIOHandle->GPIO_Config.PinMode)
 8009360:	687b      	ldr	r3, [r7, #4]
 8009362:	7a1b      	ldrb	r3, [r3, #8]
 8009364:	2b05      	cmp	r3, #5
 8009366:	d117      	bne.n	8009398 <GPIO_Init+0xd0>
		{
			//configure RTSR
			EXTI->RTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in RTSR
 8009368:	4b5e      	ldr	r3, [pc, #376]	@ (80094e4 <GPIO_Init+0x21c>)
 800936a:	689b      	ldr	r3, [r3, #8]
 800936c:	687a      	ldr	r2, [r7, #4]
 800936e:	6852      	ldr	r2, [r2, #4]
 8009370:	2101      	movs	r1, #1
 8009372:	fa01 f202 	lsl.w	r2, r1, r2
 8009376:	4611      	mov	r1, r2
 8009378:	4a5a      	ldr	r2, [pc, #360]	@ (80094e4 <GPIO_Init+0x21c>)
 800937a:	430b      	orrs	r3, r1
 800937c:	6093      	str	r3, [r2, #8]
			EXTI->FTSR.reg &= ~(1 << pGPIOHandle->GPIO_Config.PinNumber); 	//clear bit in FTSR just in case it is not reset
 800937e:	4b59      	ldr	r3, [pc, #356]	@ (80094e4 <GPIO_Init+0x21c>)
 8009380:	68db      	ldr	r3, [r3, #12]
 8009382:	687a      	ldr	r2, [r7, #4]
 8009384:	6852      	ldr	r2, [r2, #4]
 8009386:	2101      	movs	r1, #1
 8009388:	fa01 f202 	lsl.w	r2, r1, r2
 800938c:	43d2      	mvns	r2, r2
 800938e:	4611      	mov	r1, r2
 8009390:	4a54      	ldr	r2, [pc, #336]	@ (80094e4 <GPIO_Init+0x21c>)
 8009392:	400b      	ands	r3, r1
 8009394:	60d3      	str	r3, [r2, #12]
 8009396:	e019      	b.n	80093cc <GPIO_Init+0x104>
		}else if (GPIO_MODE_IT_RFT == pGPIOHandle->GPIO_Config.PinMode)
 8009398:	687b      	ldr	r3, [r7, #4]
 800939a:	7a1b      	ldrb	r3, [r3, #8]
 800939c:	2b07      	cmp	r3, #7
 800939e:	d115      	bne.n	80093cc <GPIO_Init+0x104>
		{
			//configure both FTSR and RTSR registers
			EXTI->RTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber);	 	//set bit in RTSR
 80093a0:	4b50      	ldr	r3, [pc, #320]	@ (80094e4 <GPIO_Init+0x21c>)
 80093a2:	689b      	ldr	r3, [r3, #8]
 80093a4:	687a      	ldr	r2, [r7, #4]
 80093a6:	6852      	ldr	r2, [r2, #4]
 80093a8:	2101      	movs	r1, #1
 80093aa:	fa01 f202 	lsl.w	r2, r1, r2
 80093ae:	4611      	mov	r1, r2
 80093b0:	4a4c      	ldr	r2, [pc, #304]	@ (80094e4 <GPIO_Init+0x21c>)
 80093b2:	430b      	orrs	r3, r1
 80093b4:	6093      	str	r3, [r2, #8]
			EXTI->FTSR.reg |= (1 << pGPIOHandle->GPIO_Config.PinNumber); 	//set bit in FTSR
 80093b6:	4b4b      	ldr	r3, [pc, #300]	@ (80094e4 <GPIO_Init+0x21c>)
 80093b8:	68db      	ldr	r3, [r3, #12]
 80093ba:	687a      	ldr	r2, [r7, #4]
 80093bc:	6852      	ldr	r2, [r2, #4]
 80093be:	2101      	movs	r1, #1
 80093c0:	fa01 f202 	lsl.w	r2, r1, r2
 80093c4:	4611      	mov	r1, r2
 80093c6:	4a47      	ldr	r2, [pc, #284]	@ (80094e4 <GPIO_Init+0x21c>)
 80093c8:	430b      	orrs	r3, r1
 80093ca:	60d3      	str	r3, [r2, #12]
		}

		uint8_t temp1 = pGPIOHandle->GPIO_Config.PinNumber / 4;
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	685b      	ldr	r3, [r3, #4]
 80093d0:	089b      	lsrs	r3, r3, #2
 80093d2:	74fb      	strb	r3, [r7, #19]
		uint8_t temp2 = pGPIOHandle->GPIO_Config.PinNumber % 4;
 80093d4:	687b      	ldr	r3, [r7, #4]
 80093d6:	685b      	ldr	r3, [r3, #4]
 80093d8:	b2db      	uxtb	r3, r3
 80093da:	f003 0303 	and.w	r3, r3, #3
 80093de:	74bb      	strb	r3, [r7, #18]

		uint8_t portcode = GPIO_BASEADDR_TO_CODE(pGPIOHandle->pGPIOx);
 80093e0:	687b      	ldr	r3, [r7, #4]
 80093e2:	681b      	ldr	r3, [r3, #0]
 80093e4:	4a40      	ldr	r2, [pc, #256]	@ (80094e8 <GPIO_Init+0x220>)
 80093e6:	4293      	cmp	r3, r2
 80093e8:	d02b      	beq.n	8009442 <GPIO_Init+0x17a>
 80093ea:	687b      	ldr	r3, [r7, #4]
 80093ec:	681b      	ldr	r3, [r3, #0]
 80093ee:	4a3f      	ldr	r2, [pc, #252]	@ (80094ec <GPIO_Init+0x224>)
 80093f0:	4293      	cmp	r3, r2
 80093f2:	d024      	beq.n	800943e <GPIO_Init+0x176>
 80093f4:	687b      	ldr	r3, [r7, #4]
 80093f6:	681b      	ldr	r3, [r3, #0]
 80093f8:	4a3d      	ldr	r2, [pc, #244]	@ (80094f0 <GPIO_Init+0x228>)
 80093fa:	4293      	cmp	r3, r2
 80093fc:	d01d      	beq.n	800943a <GPIO_Init+0x172>
 80093fe:	687b      	ldr	r3, [r7, #4]
 8009400:	681b      	ldr	r3, [r3, #0]
 8009402:	4a3c      	ldr	r2, [pc, #240]	@ (80094f4 <GPIO_Init+0x22c>)
 8009404:	4293      	cmp	r3, r2
 8009406:	d016      	beq.n	8009436 <GPIO_Init+0x16e>
 8009408:	687b      	ldr	r3, [r7, #4]
 800940a:	681b      	ldr	r3, [r3, #0]
 800940c:	4a3a      	ldr	r2, [pc, #232]	@ (80094f8 <GPIO_Init+0x230>)
 800940e:	4293      	cmp	r3, r2
 8009410:	d00f      	beq.n	8009432 <GPIO_Init+0x16a>
 8009412:	687b      	ldr	r3, [r7, #4]
 8009414:	681b      	ldr	r3, [r3, #0]
 8009416:	4a39      	ldr	r2, [pc, #228]	@ (80094fc <GPIO_Init+0x234>)
 8009418:	4293      	cmp	r3, r2
 800941a:	d008      	beq.n	800942e <GPIO_Init+0x166>
 800941c:	687b      	ldr	r3, [r7, #4]
 800941e:	681b      	ldr	r3, [r3, #0]
 8009420:	4a37      	ldr	r2, [pc, #220]	@ (8009500 <GPIO_Init+0x238>)
 8009422:	4293      	cmp	r3, r2
 8009424:	d101      	bne.n	800942a <GPIO_Init+0x162>
 8009426:	2308      	movs	r3, #8
 8009428:	e00c      	b.n	8009444 <GPIO_Init+0x17c>
 800942a:	2300      	movs	r3, #0
 800942c:	e00a      	b.n	8009444 <GPIO_Init+0x17c>
 800942e:	2307      	movs	r3, #7
 8009430:	e008      	b.n	8009444 <GPIO_Init+0x17c>
 8009432:	2304      	movs	r3, #4
 8009434:	e006      	b.n	8009444 <GPIO_Init+0x17c>
 8009436:	2303      	movs	r3, #3
 8009438:	e004      	b.n	8009444 <GPIO_Init+0x17c>
 800943a:	2302      	movs	r3, #2
 800943c:	e002      	b.n	8009444 <GPIO_Init+0x17c>
 800943e:	2301      	movs	r3, #1
 8009440:	e000      	b.n	8009444 <GPIO_Init+0x17c>
 8009442:	2300      	movs	r3, #0
 8009444:	747b      	strb	r3, [r7, #17]
		RCC->APB2ENR.reg |= RCC_APB2ENR_SYSCFGEN; 											// enable SYSCFG peripheral clock
 8009446:	4b2f      	ldr	r3, [pc, #188]	@ (8009504 <GPIO_Init+0x23c>)
 8009448:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800944a:	4a2e      	ldr	r2, [pc, #184]	@ (8009504 <GPIO_Init+0x23c>)
 800944c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8009450:	6453      	str	r3, [r2, #68]	@ 0x44
		if((0 == temp1) || (1/4 == temp1) || (2/4 == temp1) || (3/4 == temp1))
 8009452:	7cfb      	ldrb	r3, [r7, #19]
 8009454:	2b00      	cmp	r3, #0
 8009456:	d008      	beq.n	800946a <GPIO_Init+0x1a2>
 8009458:	7cfb      	ldrb	r3, [r7, #19]
 800945a:	2b00      	cmp	r3, #0
 800945c:	d005      	beq.n	800946a <GPIO_Init+0x1a2>
 800945e:	7cfb      	ldrb	r3, [r7, #19]
 8009460:	2b00      	cmp	r3, #0
 8009462:	d002      	beq.n	800946a <GPIO_Init+0x1a2>
 8009464:	7cfb      	ldrb	r3, [r7, #19]
 8009466:	2b00      	cmp	r3, #0
 8009468:	d10b      	bne.n	8009482 <GPIO_Init+0x1ba>
		{
			SYSCFG->EXTICR[0] |= portcode << (temp2 * 4);
 800946a:	4b27      	ldr	r3, [pc, #156]	@ (8009508 <GPIO_Init+0x240>)
 800946c:	689b      	ldr	r3, [r3, #8]
 800946e:	7c79      	ldrb	r1, [r7, #17]
 8009470:	7cba      	ldrb	r2, [r7, #18]
 8009472:	0092      	lsls	r2, r2, #2
 8009474:	fa01 f202 	lsl.w	r2, r1, r2
 8009478:	4611      	mov	r1, r2
 800947a:	4a23      	ldr	r2, [pc, #140]	@ (8009508 <GPIO_Init+0x240>)
 800947c:	430b      	orrs	r3, r1
 800947e:	6093      	str	r3, [r2, #8]
 8009480:	e05b      	b.n	800953a <GPIO_Init+0x272>
		}
		else if((1 == temp1) || (5/4 == temp1) || (6/4 == temp1) || (7/4 == temp1))
 8009482:	7cfb      	ldrb	r3, [r7, #19]
 8009484:	2b01      	cmp	r3, #1
 8009486:	d008      	beq.n	800949a <GPIO_Init+0x1d2>
 8009488:	7cfb      	ldrb	r3, [r7, #19]
 800948a:	2b01      	cmp	r3, #1
 800948c:	d005      	beq.n	800949a <GPIO_Init+0x1d2>
 800948e:	7cfb      	ldrb	r3, [r7, #19]
 8009490:	2b01      	cmp	r3, #1
 8009492:	d002      	beq.n	800949a <GPIO_Init+0x1d2>
 8009494:	7cfb      	ldrb	r3, [r7, #19]
 8009496:	2b01      	cmp	r3, #1
 8009498:	d10b      	bne.n	80094b2 <GPIO_Init+0x1ea>
		{
			SYSCFG->EXTICR[1] |= portcode << (temp2 * 4);
 800949a:	4b1b      	ldr	r3, [pc, #108]	@ (8009508 <GPIO_Init+0x240>)
 800949c:	68db      	ldr	r3, [r3, #12]
 800949e:	7c79      	ldrb	r1, [r7, #17]
 80094a0:	7cba      	ldrb	r2, [r7, #18]
 80094a2:	0092      	lsls	r2, r2, #2
 80094a4:	fa01 f202 	lsl.w	r2, r1, r2
 80094a8:	4611      	mov	r1, r2
 80094aa:	4a17      	ldr	r2, [pc, #92]	@ (8009508 <GPIO_Init+0x240>)
 80094ac:	430b      	orrs	r3, r1
 80094ae:	60d3      	str	r3, [r2, #12]
 80094b0:	e043      	b.n	800953a <GPIO_Init+0x272>
		}
		else if((2 == temp1) || (9/4 == temp1) || (10/4 == temp1) || (11/4 == temp1))
 80094b2:	7cfb      	ldrb	r3, [r7, #19]
 80094b4:	2b02      	cmp	r3, #2
 80094b6:	d008      	beq.n	80094ca <GPIO_Init+0x202>
 80094b8:	7cfb      	ldrb	r3, [r7, #19]
 80094ba:	2b02      	cmp	r3, #2
 80094bc:	d005      	beq.n	80094ca <GPIO_Init+0x202>
 80094be:	7cfb      	ldrb	r3, [r7, #19]
 80094c0:	2b02      	cmp	r3, #2
 80094c2:	d002      	beq.n	80094ca <GPIO_Init+0x202>
 80094c4:	7cfb      	ldrb	r3, [r7, #19]
 80094c6:	2b02      	cmp	r3, #2
 80094c8:	d120      	bne.n	800950c <GPIO_Init+0x244>
		{
			SYSCFG->EXTICR[2] |= portcode << (temp2 * 4);
 80094ca:	4b0f      	ldr	r3, [pc, #60]	@ (8009508 <GPIO_Init+0x240>)
 80094cc:	691b      	ldr	r3, [r3, #16]
 80094ce:	7c79      	ldrb	r1, [r7, #17]
 80094d0:	7cba      	ldrb	r2, [r7, #18]
 80094d2:	0092      	lsls	r2, r2, #2
 80094d4:	fa01 f202 	lsl.w	r2, r1, r2
 80094d8:	4611      	mov	r1, r2
 80094da:	4a0b      	ldr	r2, [pc, #44]	@ (8009508 <GPIO_Init+0x240>)
 80094dc:	430b      	orrs	r3, r1
 80094de:	6113      	str	r3, [r2, #16]
 80094e0:	e02b      	b.n	800953a <GPIO_Init+0x272>
 80094e2:	bf00      	nop
 80094e4:	40013c00 	.word	0x40013c00
 80094e8:	40020000 	.word	0x40020000
 80094ec:	40020400 	.word	0x40020400
 80094f0:	40020800 	.word	0x40020800
 80094f4:	40020c00 	.word	0x40020c00
 80094f8:	40021000 	.word	0x40021000
 80094fc:	40021c00 	.word	0x40021c00
 8009500:	40022000 	.word	0x40022000
 8009504:	40023800 	.word	0x40023800
 8009508:	40013800 	.word	0x40013800
		}
		else if((3 == temp1) || (13/4 == temp1) || (14/4 == temp1) || (15/4 == temp1))
 800950c:	7cfb      	ldrb	r3, [r7, #19]
 800950e:	2b03      	cmp	r3, #3
 8009510:	d008      	beq.n	8009524 <GPIO_Init+0x25c>
 8009512:	7cfb      	ldrb	r3, [r7, #19]
 8009514:	2b03      	cmp	r3, #3
 8009516:	d005      	beq.n	8009524 <GPIO_Init+0x25c>
 8009518:	7cfb      	ldrb	r3, [r7, #19]
 800951a:	2b03      	cmp	r3, #3
 800951c:	d002      	beq.n	8009524 <GPIO_Init+0x25c>
 800951e:	7cfb      	ldrb	r3, [r7, #19]
 8009520:	2b03      	cmp	r3, #3
 8009522:	d10a      	bne.n	800953a <GPIO_Init+0x272>
		{
			SYSCFG->EXTICR[3] |= portcode << (temp2 * 4);
 8009524:	4b7a      	ldr	r3, [pc, #488]	@ (8009710 <GPIO_Init+0x448>)
 8009526:	695b      	ldr	r3, [r3, #20]
 8009528:	7c79      	ldrb	r1, [r7, #17]
 800952a:	7cba      	ldrb	r2, [r7, #18]
 800952c:	0092      	lsls	r2, r2, #2
 800952e:	fa01 f202 	lsl.w	r2, r1, r2
 8009532:	4611      	mov	r1, r2
 8009534:	4a76      	ldr	r2, [pc, #472]	@ (8009710 <GPIO_Init+0x448>)
 8009536:	430b      	orrs	r3, r1
 8009538:	6153      	str	r3, [r2, #20]
		}

		EXTI->IMR.reg |= 1 << pGPIOHandle->GPIO_Config.PinNumber;			//enable the EXTI interrupt delivery using IMR
 800953a:	4b76      	ldr	r3, [pc, #472]	@ (8009714 <GPIO_Init+0x44c>)
 800953c:	681b      	ldr	r3, [r3, #0]
 800953e:	687a      	ldr	r2, [r7, #4]
 8009540:	6852      	ldr	r2, [r2, #4]
 8009542:	2101      	movs	r1, #1
 8009544:	fa01 f202 	lsl.w	r2, r1, r2
 8009548:	4611      	mov	r1, r2
 800954a:	4a72      	ldr	r2, [pc, #456]	@ (8009714 <GPIO_Init+0x44c>)
 800954c:	430b      	orrs	r3, r1
 800954e:	6013      	str	r3, [r2, #0]
	}

	temp = pGPIOHandle->GPIO_Config.PinSpeed << (2 * pGPIOHandle->GPIO_Config.PinNumber);//shift to left by 2 bits
 8009550:	687b      	ldr	r3, [r7, #4]
 8009552:	7a5b      	ldrb	r3, [r3, #9]
 8009554:	461a      	mov	r2, r3
 8009556:	687b      	ldr	r3, [r7, #4]
 8009558:	685b      	ldr	r3, [r3, #4]
 800955a:	005b      	lsls	r3, r3, #1
 800955c:	fa02 f303 	lsl.w	r3, r2, r3
 8009560:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OSPEEDR.reg &= ~(0x3 <<(2 * pGPIOHandle->GPIO_Config.PinNumber));
 8009562:	687b      	ldr	r3, [r7, #4]
 8009564:	681b      	ldr	r3, [r3, #0]
 8009566:	689a      	ldr	r2, [r3, #8]
 8009568:	687b      	ldr	r3, [r7, #4]
 800956a:	685b      	ldr	r3, [r3, #4]
 800956c:	005b      	lsls	r3, r3, #1
 800956e:	2103      	movs	r1, #3
 8009570:	fa01 f303 	lsl.w	r3, r1, r3
 8009574:	43db      	mvns	r3, r3
 8009576:	4619      	mov	r1, r3
 8009578:	687b      	ldr	r3, [r7, #4]
 800957a:	681b      	ldr	r3, [r3, #0]
 800957c:	400a      	ands	r2, r1
 800957e:	609a      	str	r2, [r3, #8]
	pGPIOHandle->pGPIOx->OSPEEDR.reg |= temp;
 8009580:	687b      	ldr	r3, [r7, #4]
 8009582:	681b      	ldr	r3, [r3, #0]
 8009584:	6899      	ldr	r1, [r3, #8]
 8009586:	687b      	ldr	r3, [r7, #4]
 8009588:	681b      	ldr	r3, [r3, #0]
 800958a:	697a      	ldr	r2, [r7, #20]
 800958c:	430a      	orrs	r2, r1
 800958e:	609a      	str	r2, [r3, #8]

	temp = pGPIOHandle->GPIO_Config.PinPuPdControl << (2 * pGPIOHandle->GPIO_Config.PinNumber);//shift to left by 2 bits because
 8009590:	687b      	ldr	r3, [r7, #4]
 8009592:	7a9b      	ldrb	r3, [r3, #10]
 8009594:	461a      	mov	r2, r3
 8009596:	687b      	ldr	r3, [r7, #4]
 8009598:	685b      	ldr	r3, [r3, #4]
 800959a:	005b      	lsls	r3, r3, #1
 800959c:	fa02 f303 	lsl.w	r3, r2, r3
 80095a0:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->PUPDR.reg &= ~(0x3 <<( 2 * pGPIOHandle->GPIO_Config.PinNumber));
 80095a2:	687b      	ldr	r3, [r7, #4]
 80095a4:	681b      	ldr	r3, [r3, #0]
 80095a6:	68da      	ldr	r2, [r3, #12]
 80095a8:	687b      	ldr	r3, [r7, #4]
 80095aa:	685b      	ldr	r3, [r3, #4]
 80095ac:	005b      	lsls	r3, r3, #1
 80095ae:	2103      	movs	r1, #3
 80095b0:	fa01 f303 	lsl.w	r3, r1, r3
 80095b4:	43db      	mvns	r3, r3
 80095b6:	4619      	mov	r1, r3
 80095b8:	687b      	ldr	r3, [r7, #4]
 80095ba:	681b      	ldr	r3, [r3, #0]
 80095bc:	400a      	ands	r2, r1
 80095be:	60da      	str	r2, [r3, #12]
	pGPIOHandle->pGPIOx->PUPDR.reg |= temp;
 80095c0:	687b      	ldr	r3, [r7, #4]
 80095c2:	681b      	ldr	r3, [r3, #0]
 80095c4:	68d9      	ldr	r1, [r3, #12]
 80095c6:	687b      	ldr	r3, [r7, #4]
 80095c8:	681b      	ldr	r3, [r3, #0]
 80095ca:	697a      	ldr	r2, [r7, #20]
 80095cc:	430a      	orrs	r2, r1
 80095ce:	60da      	str	r2, [r3, #12]

	temp = pGPIOHandle->GPIO_Config.PinOPType << pGPIOHandle->GPIO_Config.PinNumber;//shift to left by 2 bits
 80095d0:	687b      	ldr	r3, [r7, #4]
 80095d2:	7adb      	ldrb	r3, [r3, #11]
 80095d4:	461a      	mov	r2, r3
 80095d6:	687b      	ldr	r3, [r7, #4]
 80095d8:	685b      	ldr	r3, [r3, #4]
 80095da:	fa02 f303 	lsl.w	r3, r2, r3
 80095de:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OTYPER.reg &= ~(0x1 << pGPIOHandle->GPIO_Config.PinNumber);
 80095e0:	687b      	ldr	r3, [r7, #4]
 80095e2:	681b      	ldr	r3, [r3, #0]
 80095e4:	685a      	ldr	r2, [r3, #4]
 80095e6:	687b      	ldr	r3, [r7, #4]
 80095e8:	685b      	ldr	r3, [r3, #4]
 80095ea:	2101      	movs	r1, #1
 80095ec:	fa01 f303 	lsl.w	r3, r1, r3
 80095f0:	43db      	mvns	r3, r3
 80095f2:	4619      	mov	r1, r3
 80095f4:	687b      	ldr	r3, [r7, #4]
 80095f6:	681b      	ldr	r3, [r3, #0]
 80095f8:	400a      	ands	r2, r1
 80095fa:	605a      	str	r2, [r3, #4]
	pGPIOHandle->pGPIOx->OTYPER.reg |= temp;
 80095fc:	687b      	ldr	r3, [r7, #4]
 80095fe:	681b      	ldr	r3, [r3, #0]
 8009600:	6859      	ldr	r1, [r3, #4]
 8009602:	687b      	ldr	r3, [r7, #4]
 8009604:	681b      	ldr	r3, [r3, #0]
 8009606:	697a      	ldr	r2, [r7, #20]
 8009608:	430a      	orrs	r2, r1
 800960a:	605a      	str	r2, [r3, #4]

	if(GPIO_MODE_AF == pGPIOHandle->GPIO_Config.PinMode)
 800960c:	687b      	ldr	r3, [r7, #4]
 800960e:	7a1b      	ldrb	r3, [r3, #8]
 8009610:	2b02      	cmp	r3, #2
 8009612:	d178      	bne.n	8009706 <GPIO_Init+0x43e>
	{
		uint8_t temp1 = 0, temp2 = 0;
 8009614:	2300      	movs	r3, #0
 8009616:	743b      	strb	r3, [r7, #16]
 8009618:	2300      	movs	r3, #0
 800961a:	73fb      	strb	r3, [r7, #15]

		temp1 = pGPIOHandle->GPIO_Config.PinNumber/8;	//AFRL = AFR[0]. Any integer smaller than 8 will be 0 after division
 800961c:	687b      	ldr	r3, [r7, #4]
 800961e:	685b      	ldr	r3, [r3, #4]
 8009620:	08db      	lsrs	r3, r3, #3
 8009622:	743b      	strb	r3, [r7, #16]
		temp2 = pGPIOHandle->GPIO_Config.PinNumber%8;
 8009624:	687b      	ldr	r3, [r7, #4]
 8009626:	685b      	ldr	r3, [r3, #4]
 8009628:	b2db      	uxtb	r3, r3
 800962a:	f003 0307 	and.w	r3, r3, #7
 800962e:	73fb      	strb	r3, [r7, #15]
		if((0 == temp1) || (1/8 == temp1) || (2/8 == temp1) || (3/8 == temp1) ||
 8009630:	7c3b      	ldrb	r3, [r7, #16]
 8009632:	2b00      	cmp	r3, #0
 8009634:	d014      	beq.n	8009660 <GPIO_Init+0x398>
 8009636:	7c3b      	ldrb	r3, [r7, #16]
 8009638:	2b00      	cmp	r3, #0
 800963a:	d011      	beq.n	8009660 <GPIO_Init+0x398>
 800963c:	7c3b      	ldrb	r3, [r7, #16]
 800963e:	2b00      	cmp	r3, #0
 8009640:	d00e      	beq.n	8009660 <GPIO_Init+0x398>
 8009642:	7c3b      	ldrb	r3, [r7, #16]
 8009644:	2b00      	cmp	r3, #0
 8009646:	d00b      	beq.n	8009660 <GPIO_Init+0x398>
 8009648:	7c3b      	ldrb	r3, [r7, #16]
 800964a:	2b00      	cmp	r3, #0
 800964c:	d008      	beq.n	8009660 <GPIO_Init+0x398>
			(4/8 == temp1 ) || (5/8 == temp1) || (6/8 == temp1) || (7/8 == temp1))
 800964e:	7c3b      	ldrb	r3, [r7, #16]
 8009650:	2b00      	cmp	r3, #0
 8009652:	d005      	beq.n	8009660 <GPIO_Init+0x398>
 8009654:	7c3b      	ldrb	r3, [r7, #16]
 8009656:	2b00      	cmp	r3, #0
 8009658:	d002      	beq.n	8009660 <GPIO_Init+0x398>
 800965a:	7c3b      	ldrb	r3, [r7, #16]
 800965c:	2b00      	cmp	r3, #0
 800965e:	d11d      	bne.n	800969c <GPIO_Init+0x3d4>
		{
			pGPIOHandle->pGPIOx->AFRL.reg &= ~(0xF << (4* temp2));
 8009660:	687b      	ldr	r3, [r7, #4]
 8009662:	681b      	ldr	r3, [r3, #0]
 8009664:	6a1a      	ldr	r2, [r3, #32]
 8009666:	7bfb      	ldrb	r3, [r7, #15]
 8009668:	009b      	lsls	r3, r3, #2
 800966a:	210f      	movs	r1, #15
 800966c:	fa01 f303 	lsl.w	r3, r1, r3
 8009670:	43db      	mvns	r3, r3
 8009672:	4619      	mov	r1, r3
 8009674:	687b      	ldr	r3, [r7, #4]
 8009676:	681b      	ldr	r3, [r3, #0]
 8009678:	400a      	ands	r2, r1
 800967a:	621a      	str	r2, [r3, #32]
			pGPIOHandle->pGPIOx->AFRL.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	6a1a      	ldr	r2, [r3, #32]
 8009682:	687b      	ldr	r3, [r7, #4]
 8009684:	7b1b      	ldrb	r3, [r3, #12]
 8009686:	4619      	mov	r1, r3
 8009688:	7bfb      	ldrb	r3, [r7, #15]
 800968a:	009b      	lsls	r3, r3, #2
 800968c:	fa01 f303 	lsl.w	r3, r1, r3
 8009690:	4619      	mov	r1, r3
 8009692:	687b      	ldr	r3, [r7, #4]
 8009694:	681b      	ldr	r3, [r3, #0]
 8009696:	430a      	orrs	r2, r1
 8009698:	621a      	str	r2, [r3, #32]
		{
			pGPIOHandle->pGPIOx->AFRH.reg &= ~(0xF << (4* temp2));
			pGPIOHandle->pGPIOx->AFRH.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
		}
	}
}
 800969a:	e034      	b.n	8009706 <GPIO_Init+0x43e>
		else if((1 == temp1) || (9/8 == temp1) || (10/8 == temp1) || (11/8 == temp1) ||
 800969c:	7c3b      	ldrb	r3, [r7, #16]
 800969e:	2b01      	cmp	r3, #1
 80096a0:	d014      	beq.n	80096cc <GPIO_Init+0x404>
 80096a2:	7c3b      	ldrb	r3, [r7, #16]
 80096a4:	2b01      	cmp	r3, #1
 80096a6:	d011      	beq.n	80096cc <GPIO_Init+0x404>
 80096a8:	7c3b      	ldrb	r3, [r7, #16]
 80096aa:	2b01      	cmp	r3, #1
 80096ac:	d00e      	beq.n	80096cc <GPIO_Init+0x404>
 80096ae:	7c3b      	ldrb	r3, [r7, #16]
 80096b0:	2b01      	cmp	r3, #1
 80096b2:	d00b      	beq.n	80096cc <GPIO_Init+0x404>
 80096b4:	7c3b      	ldrb	r3, [r7, #16]
 80096b6:	2b01      	cmp	r3, #1
 80096b8:	d008      	beq.n	80096cc <GPIO_Init+0x404>
				(12/8 == temp1 ) || (13/8 == temp1) || (14/8 == temp1) || (15/8 == temp1))
 80096ba:	7c3b      	ldrb	r3, [r7, #16]
 80096bc:	2b01      	cmp	r3, #1
 80096be:	d005      	beq.n	80096cc <GPIO_Init+0x404>
 80096c0:	7c3b      	ldrb	r3, [r7, #16]
 80096c2:	2b01      	cmp	r3, #1
 80096c4:	d002      	beq.n	80096cc <GPIO_Init+0x404>
 80096c6:	7c3b      	ldrb	r3, [r7, #16]
 80096c8:	2b01      	cmp	r3, #1
 80096ca:	d11c      	bne.n	8009706 <GPIO_Init+0x43e>
			pGPIOHandle->pGPIOx->AFRH.reg &= ~(0xF << (4* temp2));
 80096cc:	687b      	ldr	r3, [r7, #4]
 80096ce:	681b      	ldr	r3, [r3, #0]
 80096d0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80096d2:	7bfb      	ldrb	r3, [r7, #15]
 80096d4:	009b      	lsls	r3, r3, #2
 80096d6:	210f      	movs	r1, #15
 80096d8:	fa01 f303 	lsl.w	r3, r1, r3
 80096dc:	43db      	mvns	r3, r3
 80096de:	4619      	mov	r1, r3
 80096e0:	687b      	ldr	r3, [r7, #4]
 80096e2:	681b      	ldr	r3, [r3, #0]
 80096e4:	400a      	ands	r2, r1
 80096e6:	625a      	str	r2, [r3, #36]	@ 0x24
			pGPIOHandle->pGPIOx->AFRH.reg |= pGPIOHandle->GPIO_Config.PinAltFuncMode << (4* temp2);
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	681b      	ldr	r3, [r3, #0]
 80096ec:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80096ee:	687b      	ldr	r3, [r7, #4]
 80096f0:	7b1b      	ldrb	r3, [r3, #12]
 80096f2:	4619      	mov	r1, r3
 80096f4:	7bfb      	ldrb	r3, [r7, #15]
 80096f6:	009b      	lsls	r3, r3, #2
 80096f8:	fa01 f303 	lsl.w	r3, r1, r3
 80096fc:	4619      	mov	r1, r3
 80096fe:	687b      	ldr	r3, [r7, #4]
 8009700:	681b      	ldr	r3, [r3, #0]
 8009702:	430a      	orrs	r2, r1
 8009704:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8009706:	bf00      	nop
 8009708:	3718      	adds	r7, #24
 800970a:	46bd      	mov	sp, r7
 800970c:	bd80      	pop	{r7, pc}
 800970e:	bf00      	nop
 8009710:	40013800 	.word	0x40013800
 8009714:	40013c00 	.word	0x40013c00

08009718 <GPIO_WritePin>:
/* @return				-	none																		*/
/*																										*/
/* @Note				-	none																		*/
/********************************************************************************************************/
void GPIO_WritePin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t val)
{
 8009718:	b480      	push	{r7}
 800971a:	b083      	sub	sp, #12
 800971c:	af00      	add	r7, sp, #0
 800971e:	6078      	str	r0, [r7, #4]
 8009720:	460b      	mov	r3, r1
 8009722:	70fb      	strb	r3, [r7, #3]
 8009724:	4613      	mov	r3, r2
 8009726:	70bb      	strb	r3, [r7, #2]
	if(SET == val)
 8009728:	78bb      	ldrb	r3, [r7, #2]
 800972a:	2b01      	cmp	r3, #1
 800972c:	d109      	bne.n	8009742 <GPIO_WritePin+0x2a>
	{
		pGPIOx->ODR.reg |= (1 << PinNumber);
 800972e:	687b      	ldr	r3, [r7, #4]
 8009730:	695b      	ldr	r3, [r3, #20]
 8009732:	78fa      	ldrb	r2, [r7, #3]
 8009734:	2101      	movs	r1, #1
 8009736:	fa01 f202 	lsl.w	r2, r1, r2
 800973a:	431a      	orrs	r2, r3
 800973c:	687b      	ldr	r3, [r7, #4]
 800973e:	615a      	str	r2, [r3, #20]
	}else
	{
		pGPIOx->ODR.reg &= ~(1 << PinNumber);
	}
}
 8009740:	e009      	b.n	8009756 <GPIO_WritePin+0x3e>
		pGPIOx->ODR.reg &= ~(1 << PinNumber);
 8009742:	687b      	ldr	r3, [r7, #4]
 8009744:	695b      	ldr	r3, [r3, #20]
 8009746:	78fa      	ldrb	r2, [r7, #3]
 8009748:	2101      	movs	r1, #1
 800974a:	fa01 f202 	lsl.w	r2, r1, r2
 800974e:	43d2      	mvns	r2, r2
 8009750:	401a      	ands	r2, r3
 8009752:	687b      	ldr	r3, [r7, #4]
 8009754:	615a      	str	r2, [r3, #20]
}
 8009756:	bf00      	nop
 8009758:	370c      	adds	r7, #12
 800975a:	46bd      	mov	sp, r7
 800975c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009760:	4770      	bx	lr

08009762 <I2C_GenerateStartCondition>:
static void I2C_MasterHandleRXNEInterrupt(I2C_Handle_t *pI2CHandle );
static void I2C_MasterHandleTXEInterrupt(I2C_Handle_t *pI2CHandle );


static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
 8009762:	b480      	push	{r7}
 8009764:	b083      	sub	sp, #12
 8009766:	af00      	add	r7, sp, #0
 8009768:	6078      	str	r0, [r7, #4]
	pI2Cx->CR1.bit.start = SET;
 800976a:	687a      	ldr	r2, [r7, #4]
 800976c:	8813      	ldrh	r3, [r2, #0]
 800976e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8009772:	8013      	strh	r3, [r2, #0]
}
 8009774:	bf00      	nop
 8009776:	370c      	adds	r7, #12
 8009778:	46bd      	mov	sp, r7
 800977a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800977e:	4770      	bx	lr

08009780 <I2C_ClearADDRFlag>:
	pI2Cx->DR.bit.dr = SlaveAddr;
}


static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle )
{
 8009780:	b580      	push	{r7, lr}
 8009782:	b084      	sub	sp, #16
 8009784:	af00      	add	r7, sp, #0
 8009786:	6078      	str	r0, [r7, #4]
	uint32_t read_statusreg_dummy;

	//check for device mode
	if(ENABLE == pI2CHandle->pI2Cx->SR2.bit.msl)
 8009788:	687b      	ldr	r3, [r7, #4]
 800978a:	681b      	ldr	r3, [r3, #0]
 800978c:	699b      	ldr	r3, [r3, #24]
 800978e:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009792:	b2db      	uxtb	r3, r3
 8009794:	2b01      	cmp	r3, #1
 8009796:	d11f      	bne.n	80097d8 <I2C_ClearADDRFlag+0x58>
	{
		//device is in master mode
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
 8009798:	687b      	ldr	r3, [r7, #4]
 800979a:	7f1b      	ldrb	r3, [r3, #28]
 800979c:	2b01      	cmp	r3, #1
 800979e:	d112      	bne.n	80097c6 <I2C_ClearADDRFlag+0x46>
		{
			if(pI2CHandle->RxSize  == 1)
 80097a0:	687b      	ldr	r3, [r7, #4]
 80097a2:	6a1b      	ldr	r3, [r3, #32]
 80097a4:	2b01      	cmp	r3, #1
 80097a6:	d11f      	bne.n	80097e8 <I2C_ClearADDRFlag+0x68>
			{
				//first disable the ack
				I2C_ManageAcking(pI2CHandle->pI2Cx,I2C_ACK_DISABLE);
 80097a8:	687b      	ldr	r3, [r7, #4]
 80097aa:	681b      	ldr	r3, [r3, #0]
 80097ac:	2100      	movs	r1, #0
 80097ae:	4618      	mov	r0, r3
 80097b0:	f000 fa9d 	bl	8009cee <I2C_ManageAcking>

				//clear the ADDR flag ( read SR1 , read SR2)
				read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 80097b4:	687b      	ldr	r3, [r7, #4]
 80097b6:	681b      	ldr	r3, [r3, #0]
 80097b8:	695b      	ldr	r3, [r3, #20]
 80097ba:	60fb      	str	r3, [r7, #12]
				read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 80097bc:	687b      	ldr	r3, [r7, #4]
 80097be:	681b      	ldr	r3, [r3, #0]
 80097c0:	699b      	ldr	r3, [r3, #24]
 80097c2:	60fb      	str	r3, [r7, #12]
		//clear the ADDR flag ( read SR1 , read SR2)
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
		(void)read_statusreg_dummy;
	}
}
 80097c4:	e010      	b.n	80097e8 <I2C_ClearADDRFlag+0x68>
			read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 80097c6:	687b      	ldr	r3, [r7, #4]
 80097c8:	681b      	ldr	r3, [r3, #0]
 80097ca:	695b      	ldr	r3, [r3, #20]
 80097cc:	60fb      	str	r3, [r7, #12]
			read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 80097ce:	687b      	ldr	r3, [r7, #4]
 80097d0:	681b      	ldr	r3, [r3, #0]
 80097d2:	699b      	ldr	r3, [r3, #24]
 80097d4:	60fb      	str	r3, [r7, #12]
}
 80097d6:	e007      	b.n	80097e8 <I2C_ClearADDRFlag+0x68>
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR1.reg;
 80097d8:	687b      	ldr	r3, [r7, #4]
 80097da:	681b      	ldr	r3, [r3, #0]
 80097dc:	695b      	ldr	r3, [r3, #20]
 80097de:	60fb      	str	r3, [r7, #12]
		read_statusreg_dummy = pI2CHandle->pI2Cx->SR2.reg;
 80097e0:	687b      	ldr	r3, [r7, #4]
 80097e2:	681b      	ldr	r3, [r3, #0]
 80097e4:	699b      	ldr	r3, [r3, #24]
 80097e6:	60fb      	str	r3, [r7, #12]
}
 80097e8:	bf00      	nop
 80097ea:	3710      	adds	r7, #16
 80097ec:	46bd      	mov	sp, r7
 80097ee:	bd80      	pop	{r7, pc}

080097f0 <I2C_GenerateStopCondition>:


void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
 80097f0:	b480      	push	{r7}
 80097f2:	b083      	sub	sp, #12
 80097f4:	af00      	add	r7, sp, #0
 80097f6:	6078      	str	r0, [r7, #4]
	pI2Cx->CR1.bit.stop = SET;
 80097f8:	687a      	ldr	r2, [r7, #4]
 80097fa:	8813      	ldrh	r3, [r2, #0]
 80097fc:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8009800:	8013      	strh	r3, [r2, #0]
}
 8009802:	bf00      	nop
 8009804:	370c      	adds	r7, #12
 8009806:	46bd      	mov	sp, r7
 8009808:	f85d 7b04 	ldr.w	r7, [sp], #4
 800980c:	4770      	bx	lr

0800980e <I2C_PeripheralControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 800980e:	b480      	push	{r7}
 8009810:	b083      	sub	sp, #12
 8009812:	af00      	add	r7, sp, #0
 8009814:	6078      	str	r0, [r7, #4]
 8009816:	460b      	mov	r3, r1
 8009818:	70fb      	strb	r3, [r7, #3]
	pI2Cx->CR1.bit.pe = state;
 800981a:	78fb      	ldrb	r3, [r7, #3]
 800981c:	f003 0301 	and.w	r3, r3, #1
 8009820:	b2d9      	uxtb	r1, r3
 8009822:	687a      	ldr	r2, [r7, #4]
 8009824:	8813      	ldrh	r3, [r2, #0]
 8009826:	f361 0300 	bfi	r3, r1, #0, #1
 800982a:	8013      	strh	r3, [r2, #0]
}
 800982c:	bf00      	nop
 800982e:	370c      	adds	r7, #12
 8009830:	46bd      	mov	sp, r7
 8009832:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009836:	4770      	bx	lr

08009838 <I2C_PeriphClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_PeriphClockControl(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 8009838:	b480      	push	{r7}
 800983a:	b083      	sub	sp, #12
 800983c:	af00      	add	r7, sp, #0
 800983e:	6078      	str	r0, [r7, #4]
 8009840:	460b      	mov	r3, r1
 8009842:	70fb      	strb	r3, [r7, #3]
		if(pI2Cx == I2C1)
 8009844:	687b      	ldr	r3, [r7, #4]
 8009846:	4a17      	ldr	r2, [pc, #92]	@ (80098a4 <I2C_PeriphClockControl+0x6c>)
 8009848:	4293      	cmp	r3, r2
 800984a:	d109      	bne.n	8009860 <I2C_PeriphClockControl+0x28>
		{
			RCC->APB1ENR.bit.i2c1en = state;
 800984c:	4a16      	ldr	r2, [pc, #88]	@ (80098a8 <I2C_PeriphClockControl+0x70>)
 800984e:	78fb      	ldrb	r3, [r7, #3]
 8009850:	f003 0301 	and.w	r3, r3, #1
 8009854:	b2d9      	uxtb	r1, r3
 8009856:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009858:	f361 5355 	bfi	r3, r1, #21, #1
 800985c:	6413      	str	r3, [r2, #64]	@ 0x40
		else if (pI2Cx == I2C3)
		{
			RCC->APB1ENR.bit.i2c3en = state;
		}

}
 800985e:	e01a      	b.n	8009896 <I2C_PeriphClockControl+0x5e>
		else if (pI2Cx == I2C2)
 8009860:	687b      	ldr	r3, [r7, #4]
 8009862:	4a12      	ldr	r2, [pc, #72]	@ (80098ac <I2C_PeriphClockControl+0x74>)
 8009864:	4293      	cmp	r3, r2
 8009866:	d109      	bne.n	800987c <I2C_PeriphClockControl+0x44>
			RCC->APB1ENR.bit.i2c2en = state;
 8009868:	4a0f      	ldr	r2, [pc, #60]	@ (80098a8 <I2C_PeriphClockControl+0x70>)
 800986a:	78fb      	ldrb	r3, [r7, #3]
 800986c:	f003 0301 	and.w	r3, r3, #1
 8009870:	b2d9      	uxtb	r1, r3
 8009872:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009874:	f361 5396 	bfi	r3, r1, #22, #1
 8009878:	6413      	str	r3, [r2, #64]	@ 0x40
}
 800987a:	e00c      	b.n	8009896 <I2C_PeriphClockControl+0x5e>
		else if (pI2Cx == I2C3)
 800987c:	687b      	ldr	r3, [r7, #4]
 800987e:	4a0c      	ldr	r2, [pc, #48]	@ (80098b0 <I2C_PeriphClockControl+0x78>)
 8009880:	4293      	cmp	r3, r2
 8009882:	d108      	bne.n	8009896 <I2C_PeriphClockControl+0x5e>
			RCC->APB1ENR.bit.i2c3en = state;
 8009884:	4a08      	ldr	r2, [pc, #32]	@ (80098a8 <I2C_PeriphClockControl+0x70>)
 8009886:	78fb      	ldrb	r3, [r7, #3]
 8009888:	f003 0301 	and.w	r3, r3, #1
 800988c:	b2d9      	uxtb	r1, r3
 800988e:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8009890:	f361 53d7 	bfi	r3, r1, #23, #1
 8009894:	6413      	str	r3, [r2, #64]	@ 0x40
}
 8009896:	bf00      	nop
 8009898:	370c      	adds	r7, #12
 800989a:	46bd      	mov	sp, r7
 800989c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098a0:	4770      	bx	lr
 80098a2:	bf00      	nop
 80098a4:	40005400 	.word	0x40005400
 80098a8:	40023800 	.word	0x40023800
 80098ac:	40005800 	.word	0x40005800
 80098b0:	40005c00 	.word	0x40005c00

080098b4 <I2C_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
 80098b4:	b580      	push	{r7, lr}
 80098b6:	b086      	sub	sp, #24
 80098b8:	af00      	add	r7, sp, #0
 80098ba:	6078      	str	r0, [r7, #4]
	uint32_t temp = 0;
 80098bc:	2300      	movs	r3, #0
 80098be:	613b      	str	r3, [r7, #16]
	uint8_t trise;

	//enable the clock for the I2Cx peripheral
	I2C_PeriphClockControl(pI2CHandle->pI2Cx,ENABLE);
 80098c0:	687b      	ldr	r3, [r7, #4]
 80098c2:	681b      	ldr	r3, [r3, #0]
 80098c4:	2101      	movs	r1, #1
 80098c6:	4618      	mov	r0, r3
 80098c8:	f7ff ffb6 	bl	8009838 <I2C_PeriphClockControl>

	//configure the FREQ field of CR2
	temp = 0;
 80098cc:	2300      	movs	r3, #0
 80098ce:	613b      	str	r3, [r7, #16]
//	temp |= RCC_GetPCLK1Freq() /1000000U;
	temp |= HAL_RCC_GetPCLK1Freq() / 1000000U;
 80098d0:	f7fd f80e 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 80098d4:	4603      	mov	r3, r0
 80098d6:	4a56      	ldr	r2, [pc, #344]	@ (8009a30 <I2C_Init+0x17c>)
 80098d8:	fba2 2303 	umull	r2, r3, r2, r3
 80098dc:	0c9b      	lsrs	r3, r3, #18
 80098de:	693a      	ldr	r2, [r7, #16]
 80098e0:	4313      	orrs	r3, r2
 80098e2:	613b      	str	r3, [r7, #16]
	pI2CHandle->pI2Cx->CR2.bit.freq = temp;
 80098e4:	687b      	ldr	r3, [r7, #4]
 80098e6:	681a      	ldr	r2, [r3, #0]
 80098e8:	693b      	ldr	r3, [r7, #16]
 80098ea:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80098ee:	b2d9      	uxtb	r1, r3
 80098f0:	8893      	ldrh	r3, [r2, #4]
 80098f2:	f361 0305 	bfi	r3, r1, #0, #6
 80098f6:	8093      	strh	r3, [r2, #4]

   //program the device own address
	temp = 0;
 80098f8:	2300      	movs	r3, #0
 80098fa:	613b      	str	r3, [r7, #16]
	temp |= pI2CHandle->I2C_Config.I2C_DeviceAddress << 1;
 80098fc:	687b      	ldr	r3, [r7, #4]
 80098fe:	7a1b      	ldrb	r3, [r3, #8]
 8009900:	005b      	lsls	r3, r3, #1
 8009902:	693a      	ldr	r2, [r7, #16]
 8009904:	4313      	orrs	r3, r2
 8009906:	613b      	str	r3, [r7, #16]
	//reference manual states that it should always be kept equal to 1 by software
	temp |= ( 1 << 14);
 8009908:	693b      	ldr	r3, [r7, #16]
 800990a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800990e:	613b      	str	r3, [r7, #16]
//	temp |= (1 << 15);	//uncomment if you are using 10-bit slave address
	pI2CHandle->pI2Cx->OAR1.reg = temp;
 8009910:	687b      	ldr	r3, [r7, #4]
 8009912:	681b      	ldr	r3, [r3, #0]
 8009914:	693a      	ldr	r2, [r7, #16]
 8009916:	609a      	str	r2, [r3, #8]

	//CCR calculations
	I2C_CCR_Reg_t CCR_temp = {0};
 8009918:	2300      	movs	r3, #0
 800991a:	60fb      	str	r3, [r7, #12]
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_STANDARD)
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	685b      	ldr	r3, [r3, #4]
 8009920:	4a44      	ldr	r2, [pc, #272]	@ (8009a34 <I2C_Init+0x180>)
 8009922:	4293      	cmp	r3, r2
 8009924:	d80f      	bhi.n	8009946 <I2C_Init+0x92>
	{
		//mode is standard mode
		//CCR = Tscl/(2*Tpclk1) => CCR = f(pclk1)/[2*f(scl)]
//		CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
		CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 8009926:	f7fc ffe3 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 800992a:	4602      	mov	r2, r0
 800992c:	687b      	ldr	r3, [r7, #4]
 800992e:	685b      	ldr	r3, [r3, #4]
 8009930:	005b      	lsls	r3, r3, #1
 8009932:	fbb2 f3f3 	udiv	r3, r2, r3
 8009936:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800993a:	b29a      	uxth	r2, r3
 800993c:	89bb      	ldrh	r3, [r7, #12]
 800993e:	f362 030b 	bfi	r3, r2, #0, #12
 8009942:	81bb      	strh	r3, [r7, #12]
 8009944:	e035      	b.n	80099b2 <I2C_Init+0xfe>
	}
	else
	{
		//mode is fast mode
		CCR_temp.bit.fs =  ENABLE;
 8009946:	89bb      	ldrh	r3, [r7, #12]
 8009948:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800994c:	81bb      	strh	r3, [r7, #12]
		CCR_temp.bit.duty = pI2CHandle->I2C_Config.I2C_FMDutyCycle;
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	7a9b      	ldrb	r3, [r3, #10]
 8009952:	f003 0301 	and.w	r3, r3, #1
 8009956:	b2da      	uxtb	r2, r3
 8009958:	89bb      	ldrh	r3, [r7, #12]
 800995a:	f362 338e 	bfi	r3, r2, #14, #1
 800995e:	81bb      	strh	r3, [r7, #12]
		if(I2C_FM_DUTY_2 == pI2CHandle->I2C_Config.I2C_FMDutyCycle)
 8009960:	687b      	ldr	r3, [r7, #4]
 8009962:	7a9b      	ldrb	r3, [r3, #10]
 8009964:	2b00      	cmp	r3, #0
 8009966:	d111      	bne.n	800998c <I2C_Init+0xd8>
		{
//			CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
			CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 8009968:	f7fc ffc2 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 800996c:	4601      	mov	r1, r0
 800996e:	687b      	ldr	r3, [r7, #4]
 8009970:	685a      	ldr	r2, [r3, #4]
 8009972:	4613      	mov	r3, r2
 8009974:	005b      	lsls	r3, r3, #1
 8009976:	4413      	add	r3, r2
 8009978:	fbb1 f3f3 	udiv	r3, r1, r3
 800997c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8009980:	b29a      	uxth	r2, r3
 8009982:	89bb      	ldrh	r3, [r7, #12]
 8009984:	f362 030b 	bfi	r3, r2, #0, #12
 8009988:	81bb      	strh	r3, [r7, #12]
 800998a:	e012      	b.n	80099b2 <I2C_Init+0xfe>
		}
		else
		{
//			CCR_temp.bit.ccr = (RCC_GetPCLK1Freq() / ( 25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
			CCR_temp.bit.ccr = (HAL_RCC_GetPCLK1Freq() / ( 25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
 800998c:	f7fc ffb0 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 8009990:	4601      	mov	r1, r0
 8009992:	687b      	ldr	r3, [r7, #4]
 8009994:	685a      	ldr	r2, [r3, #4]
 8009996:	4613      	mov	r3, r2
 8009998:	009b      	lsls	r3, r3, #2
 800999a:	4413      	add	r3, r2
 800999c:	009a      	lsls	r2, r3, #2
 800999e:	4413      	add	r3, r2
 80099a0:	fbb1 f3f3 	udiv	r3, r1, r3
 80099a4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80099a8:	b29a      	uxth	r2, r3
 80099aa:	89bb      	ldrh	r3, [r7, #12]
 80099ac:	f362 030b 	bfi	r3, r2, #0, #12
 80099b0:	81bb      	strh	r3, [r7, #12]
		}
	}
	pI2CHandle->pI2Cx->CCR.reg = CCR_temp.reg;
 80099b2:	687b      	ldr	r3, [r7, #4]
 80099b4:	681b      	ldr	r3, [r3, #0]
 80099b6:	68fa      	ldr	r2, [r7, #12]
 80099b8:	61da      	str	r2, [r3, #28]

	//TRISE Configuration
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_STANDARD)
 80099ba:	687b      	ldr	r3, [r7, #4]
 80099bc:	685b      	ldr	r3, [r3, #4]
 80099be:	4a1d      	ldr	r2, [pc, #116]	@ (8009a34 <I2C_Init+0x180>)
 80099c0:	4293      	cmp	r3, r2
 80099c2:	d80a      	bhi.n	80099da <I2C_Init+0x126>
	{
		//mode is standard mode
//		trise = (RCC_GetPCLK1Freq() /1000000U) + 1 ;
		trise = (HAL_RCC_GetPCLK1Freq() /1000000U) + 1 ;
 80099c4:	f7fc ff94 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 80099c8:	4603      	mov	r3, r0
 80099ca:	4a19      	ldr	r2, [pc, #100]	@ (8009a30 <I2C_Init+0x17c>)
 80099cc:	fba2 2303 	umull	r2, r3, r2, r3
 80099d0:	0c9b      	lsrs	r3, r3, #18
 80099d2:	b2db      	uxtb	r3, r3
 80099d4:	3301      	adds	r3, #1
 80099d6:	75fb      	strb	r3, [r7, #23]
 80099d8:	e00e      	b.n	80099f8 <I2C_Init+0x144>
	}
	else
	{
		//mode is fast mode
//		trise = ( (RCC_GetPCLK1Freq() * 300) / 1000000000U ) + 1;
		trise = ( (HAL_RCC_GetPCLK1Freq() * 300) / 1000000000U ) + 1;
 80099da:	f7fc ff89 	bl	80068f0 <HAL_RCC_GetPCLK1Freq>
 80099de:	4603      	mov	r3, r0
 80099e0:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 80099e4:	fb02 f303 	mul.w	r3, r2, r3
 80099e8:	0a5b      	lsrs	r3, r3, #9
 80099ea:	4a13      	ldr	r2, [pc, #76]	@ (8009a38 <I2C_Init+0x184>)
 80099ec:	fba2 2303 	umull	r2, r3, r2, r3
 80099f0:	09db      	lsrs	r3, r3, #7
 80099f2:	b2db      	uxtb	r3, r3
 80099f4:	3301      	adds	r3, #1
 80099f6:	75fb      	strb	r3, [r7, #23]

	}

	pI2CHandle->pI2Cx->TRISE.bit.trise = trise;
 80099f8:	687b      	ldr	r3, [r7, #4]
 80099fa:	681a      	ldr	r2, [r3, #0]
 80099fc:	7dfb      	ldrb	r3, [r7, #23]
 80099fe:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8009a02:	b2d9      	uxtb	r1, r3
 8009a04:	8c13      	ldrh	r3, [r2, #32]
 8009a06:	f361 0305 	bfi	r3, r1, #0, #6
 8009a0a:	8413      	strh	r3, [r2, #32]

	//I2C peripheral enabled
	I2C_PeripheralControl(pI2CHandle->pI2Cx, ENABLE);
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	681b      	ldr	r3, [r3, #0]
 8009a10:	2101      	movs	r1, #1
 8009a12:	4618      	mov	r0, r3
 8009a14:	f7ff fefb 	bl	800980e <I2C_PeripheralControl>

	//ACK control bit set
	I2C_ManageAcking(pI2CHandle->pI2Cx, pI2CHandle->I2C_Config.I2C_AckControl);
 8009a18:	687b      	ldr	r3, [r7, #4]
 8009a1a:	681a      	ldr	r2, [r3, #0]
 8009a1c:	687b      	ldr	r3, [r7, #4]
 8009a1e:	7a5b      	ldrb	r3, [r3, #9]
 8009a20:	4619      	mov	r1, r3
 8009a22:	4610      	mov	r0, r2
 8009a24:	f000 f963 	bl	8009cee <I2C_ManageAcking>
}
 8009a28:	bf00      	nop
 8009a2a:	3718      	adds	r7, #24
 8009a2c:	46bd      	mov	sp, r7
 8009a2e:	bd80      	pop	{r7, pc}
 8009a30:	431bde83 	.word	0x431bde83
 8009a34:	000186a0 	.word	0x000186a0
 8009a38:	00044b83 	.word	0x00044b83

08009a3c <I2C_GetFlagStatus>:
/* @return				- flag state																	*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx , uint32_t FlagName)
{
 8009a3c:	b480      	push	{r7}
 8009a3e:	b083      	sub	sp, #12
 8009a40:	af00      	add	r7, sp, #0
 8009a42:	6078      	str	r0, [r7, #4]
 8009a44:	6039      	str	r1, [r7, #0]
	switch(FlagName)
 8009a46:	683b      	ldr	r3, [r7, #0]
 8009a48:	2b13      	cmp	r3, #19
 8009a4a:	d87f      	bhi.n	8009b4c <I2C_GetFlagStatus+0x110>
 8009a4c:	a201      	add	r2, pc, #4	@ (adr r2, 8009a54 <I2C_GetFlagStatus+0x18>)
 8009a4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009a52:	bf00      	nop
 8009a54:	08009aa5 	.word	0x08009aa5
 8009a58:	08009ab1 	.word	0x08009ab1
 8009a5c:	08009abd 	.word	0x08009abd
 8009a60:	08009ac9 	.word	0x08009ac9
 8009a64:	08009ad5 	.word	0x08009ad5
 8009a68:	08009ae1 	.word	0x08009ae1
 8009a6c:	08009aed 	.word	0x08009aed
 8009a70:	08009af9 	.word	0x08009af9
 8009a74:	08009b05 	.word	0x08009b05
 8009a78:	08009b11 	.word	0x08009b11
 8009a7c:	08009b4d 	.word	0x08009b4d
 8009a80:	08009b4d 	.word	0x08009b4d
 8009a84:	08009b4d 	.word	0x08009b4d
 8009a88:	08009b4d 	.word	0x08009b4d
 8009a8c:	08009b4d 	.word	0x08009b4d
 8009a90:	08009b4d 	.word	0x08009b4d
 8009a94:	08009b1d 	.word	0x08009b1d
 8009a98:	08009b29 	.word	0x08009b29
 8009a9c:	08009b35 	.word	0x08009b35
 8009aa0:	08009b41 	.word	0x08009b41
	{
		case I2C_SR1_SB:
		{
			return pI2Cx->SR1.bit.sb;
 8009aa4:	687b      	ldr	r3, [r7, #4]
 8009aa6:	695b      	ldr	r3, [r3, #20]
 8009aa8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009aac:	b2db      	uxtb	r3, r3
 8009aae:	e04e      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ADDR:
		{
			return pI2Cx->SR1.bit.addr;
 8009ab0:	687b      	ldr	r3, [r7, #4]
 8009ab2:	695b      	ldr	r3, [r3, #20]
 8009ab4:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8009ab8:	b2db      	uxtb	r3, r3
 8009aba:	e048      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_BTF:
		{
			return pI2Cx->SR1.bit.btf;
 8009abc:	687b      	ldr	r3, [r7, #4]
 8009abe:	695b      	ldr	r3, [r3, #20]
 8009ac0:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8009ac4:	b2db      	uxtb	r3, r3
 8009ac6:	e042      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ADD10:
		{
			return pI2Cx->SR1.bit.add10;
 8009ac8:	687b      	ldr	r3, [r7, #4]
 8009aca:	695b      	ldr	r3, [r3, #20]
 8009acc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8009ad0:	b2db      	uxtb	r3, r3
 8009ad2:	e03c      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_STOPF:
		{
			return pI2Cx->SR1.bit.stopf;
 8009ad4:	687b      	ldr	r3, [r7, #4]
 8009ad6:	695b      	ldr	r3, [r3, #20]
 8009ad8:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8009adc:	b2db      	uxtb	r3, r3
 8009ade:	e036      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_RxNE:
		{
			return pI2Cx->SR1.bit.rxne;
 8009ae0:	687b      	ldr	r3, [r7, #4]
 8009ae2:	695b      	ldr	r3, [r3, #20]
 8009ae4:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009ae8:	b2db      	uxtb	r3, r3
 8009aea:	e030      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_TxE:
		{
			return pI2Cx->SR1.bit.txe;
 8009aec:	687b      	ldr	r3, [r7, #4]
 8009aee:	695b      	ldr	r3, [r3, #20]
 8009af0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8009af4:	b2db      	uxtb	r3, r3
 8009af6:	e02a      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_BERR:
		{
			return pI2Cx->SR1.bit.berr;
 8009af8:	687b      	ldr	r3, [r7, #4]
 8009afa:	695b      	ldr	r3, [r3, #20]
 8009afc:	f3c3 2300 	ubfx	r3, r3, #8, #1
 8009b00:	b2db      	uxtb	r3, r3
 8009b02:	e024      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_ARLO:
		{
			return pI2Cx->SR1.bit.arlo;
 8009b04:	687b      	ldr	r3, [r7, #4]
 8009b06:	695b      	ldr	r3, [r3, #20]
 8009b08:	f3c3 2340 	ubfx	r3, r3, #9, #1
 8009b0c:	b2db      	uxtb	r3, r3
 8009b0e:	e01e      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_AF:
		{
			return pI2Cx->SR1.bit.af;
 8009b10:	687b      	ldr	r3, [r7, #4]
 8009b12:	695b      	ldr	r3, [r3, #20]
 8009b14:	f3c3 2380 	ubfx	r3, r3, #10, #1
 8009b18:	b2db      	uxtb	r3, r3
 8009b1a:	e018      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_OVR:
		{
			return pI2Cx->SR1.bit.ovr;
 8009b1c:	687b      	ldr	r3, [r7, #4]
 8009b1e:	695b      	ldr	r3, [r3, #20]
 8009b20:	f3c3 23c0 	ubfx	r3, r3, #11, #1
 8009b24:	b2db      	uxtb	r3, r3
 8009b26:	e012      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_PECERR:
		{
			return pI2Cx->SR1.bit.pecerr;
 8009b28:	687b      	ldr	r3, [r7, #4]
 8009b2a:	695b      	ldr	r3, [r3, #20]
 8009b2c:	f3c3 3300 	ubfx	r3, r3, #12, #1
 8009b30:	b2db      	uxtb	r3, r3
 8009b32:	e00c      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_TIMEOUT:
		{
			return pI2Cx->SR1.bit.timeout;
 8009b34:	687b      	ldr	r3, [r7, #4]
 8009b36:	695b      	ldr	r3, [r3, #20]
 8009b38:	f3c3 3380 	ubfx	r3, r3, #14, #1
 8009b3c:	b2db      	uxtb	r3, r3
 8009b3e:	e006      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		case I2C_SR1_SMBALERT:
		{
			return pI2Cx->SR1.bit.smbalert;
 8009b40:	687b      	ldr	r3, [r7, #4]
 8009b42:	695b      	ldr	r3, [r3, #20]
 8009b44:	f3c3 33c0 	ubfx	r3, r3, #15, #1
 8009b48:	b2db      	uxtb	r3, r3
 8009b4a:	e000      	b.n	8009b4e <I2C_GetFlagStatus+0x112>
			break;
		}
		default:
			return RESET;
 8009b4c:	2300      	movs	r3, #0
	}
}
 8009b4e:	4618      	mov	r0, r3
 8009b50:	370c      	adds	r7, #12
 8009b52:	46bd      	mov	sp, r7
 8009b54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b58:	4770      	bx	lr
 8009b5a:	bf00      	nop

08009b5c <I2C_Mem_Write>:
/* @return				- none																			*/
/*																										*/
/* @Note					- blocking function																*/
/********************************************************************************************************/
void I2C_Mem_Write(I2C_Handle_t *pI2CHandle, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
 8009b5c:	b580      	push	{r7, lr}
 8009b5e:	b084      	sub	sp, #16
 8009b60:	af00      	add	r7, sp, #0
 8009b62:	60f8      	str	r0, [r7, #12]
 8009b64:	4608      	mov	r0, r1
 8009b66:	4611      	mov	r1, r2
 8009b68:	461a      	mov	r2, r3
 8009b6a:	4603      	mov	r3, r0
 8009b6c:	817b      	strh	r3, [r7, #10]
 8009b6e:	460b      	mov	r3, r1
 8009b70:	813b      	strh	r3, [r7, #8]
 8009b72:	4613      	mov	r3, r2
 8009b74:	80fb      	strh	r3, [r7, #6]

	if(SET != pI2CHandle->pI2Cx->CR1.bit.pe)
 8009b76:	68fb      	ldr	r3, [r7, #12]
 8009b78:	681b      	ldr	r3, [r3, #0]
 8009b7a:	681b      	ldr	r3, [r3, #0]
 8009b7c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009b80:	b2db      	uxtb	r3, r3
 8009b82:	2b01      	cmp	r3, #1
 8009b84:	d005      	beq.n	8009b92 <I2C_Mem_Write+0x36>
	{
		pI2CHandle->pI2Cx->CR1.bit.pe = SET;
 8009b86:	68fb      	ldr	r3, [r7, #12]
 8009b88:	681a      	ldr	r2, [r3, #0]
 8009b8a:	8813      	ldrh	r3, [r2, #0]
 8009b8c:	f043 0301 	orr.w	r3, r3, #1
 8009b90:	8013      	strh	r3, [r2, #0]
	}

	pI2CHandle->pI2Cx->CR1.bit.pos = RESET;
 8009b92:	68fb      	ldr	r3, [r7, #12]
 8009b94:	681a      	ldr	r2, [r3, #0]
 8009b96:	8813      	ldrh	r3, [r2, #0]
 8009b98:	f36f 23cb 	bfc	r3, #11, #1
 8009b9c:	8013      	strh	r3, [r2, #0]

	pI2CHandle->pTxBuffer = pData;
 8009b9e:	68fb      	ldr	r3, [r7, #12]
 8009ba0:	69ba      	ldr	r2, [r7, #24]
 8009ba2:	60da      	str	r2, [r3, #12]
	pI2CHandle->TxLen = Size;
 8009ba4:	8bba      	ldrh	r2, [r7, #28]
 8009ba6:	68fb      	ldr	r3, [r7, #12]
 8009ba8:	615a      	str	r2, [r3, #20]

	I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
 8009baa:	68fb      	ldr	r3, [r7, #12]
 8009bac:	681b      	ldr	r3, [r3, #0]
 8009bae:	4618      	mov	r0, r3
 8009bb0:	f7ff fdd7 	bl	8009762 <I2C_GenerateStartCondition>

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_SB))
 8009bb4:	bf00      	nop
 8009bb6:	68fb      	ldr	r3, [r7, #12]
 8009bb8:	681b      	ldr	r3, [r3, #0]
 8009bba:	2100      	movs	r1, #0
 8009bbc:	4618      	mov	r0, r3
 8009bbe:	f7ff ff3d 	bl	8009a3c <I2C_GetFlagStatus>
 8009bc2:	4603      	mov	r3, r0
 8009bc4:	2b00      	cmp	r3, #0
 8009bc6:	d0f6      	beq.n	8009bb6 <I2C_Mem_Write+0x5a>
	{

	}

	pI2CHandle->pI2Cx->DR.reg = ((uint8_t)(DevAddress) & (uint8_t)(~(0x1UL << 0U)));
 8009bc8:	897b      	ldrh	r3, [r7, #10]
 8009bca:	b2db      	uxtb	r3, r3
 8009bcc:	461a      	mov	r2, r3
 8009bce:	68fb      	ldr	r3, [r7, #12]
 8009bd0:	681b      	ldr	r3, [r3, #0]
 8009bd2:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 8009bd6:	611a      	str	r2, [r3, #16]

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_ADDR))
 8009bd8:	bf00      	nop
 8009bda:	68fb      	ldr	r3, [r7, #12]
 8009bdc:	681b      	ldr	r3, [r3, #0]
 8009bde:	2101      	movs	r1, #1
 8009be0:	4618      	mov	r0, r3
 8009be2:	f7ff ff2b 	bl	8009a3c <I2C_GetFlagStatus>
 8009be6:	4603      	mov	r3, r0
 8009be8:	2b00      	cmp	r3, #0
 8009bea:	d0f6      	beq.n	8009bda <I2C_Mem_Write+0x7e>
	{

	}

	//clear the ADDR flag
	I2C_ClearADDRFlag(pI2CHandle);
 8009bec:	68f8      	ldr	r0, [r7, #12]
 8009bee:	f7ff fdc7 	bl	8009780 <I2C_ClearADDRFlag>

	if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8009bf2:	88fb      	ldrh	r3, [r7, #6]
 8009bf4:	2b01      	cmp	r3, #1
 8009bf6:	d105      	bne.n	8009c04 <I2C_Mem_Write+0xa8>
	{
		/* Send Memory Address */
		pI2CHandle->pI2Cx->DR.reg = ((uint8_t)(uint16_t)((DevAddress) & (uint16_t)(0x00FF)));
 8009bf8:	897b      	ldrh	r3, [r7, #10]
 8009bfa:	b2da      	uxtb	r2, r3
 8009bfc:	68fb      	ldr	r3, [r7, #12]
 8009bfe:	681b      	ldr	r3, [r3, #0]
 8009c00:	611a      	str	r2, [r3, #16]
 8009c02:	e003      	b.n	8009c0c <I2C_Mem_Write+0xb0>
	}
	else
	{
		pI2CHandle->pI2Cx->DR.reg = ((uint8_t)((uint16_t)(((uint16_t)((DevAddress) & (uint16_t)0x00FF)) >> 8)));
 8009c04:	68fb      	ldr	r3, [r7, #12]
 8009c06:	681b      	ldr	r3, [r3, #0]
 8009c08:	2200      	movs	r2, #0
 8009c0a:	611a      	str	r2, [r3, #16]
	}

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_TxE))
 8009c0c:	bf00      	nop
 8009c0e:	68fb      	ldr	r3, [r7, #12]
 8009c10:	681b      	ldr	r3, [r3, #0]
 8009c12:	2106      	movs	r1, #6
 8009c14:	4618      	mov	r0, r3
 8009c16:	f7ff ff11 	bl	8009a3c <I2C_GetFlagStatus>
 8009c1a:	4603      	mov	r3, r0
 8009c1c:	2b00      	cmp	r3, #0
 8009c1e:	d0f6      	beq.n	8009c0e <I2C_Mem_Write+0xb2>
	{

	}

	pI2CHandle->pI2Cx->DR.reg = ((uint8_t)(uint16_t)((DevAddress) & (uint16_t)(0x00FF)));
 8009c20:	897b      	ldrh	r3, [r7, #10]
 8009c22:	b2da      	uxtb	r2, r3
 8009c24:	68fb      	ldr	r3, [r7, #12]
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	611a      	str	r2, [r3, #16]

	while(pI2CHandle->TxLen > 0)
 8009c2a:	e03c      	b.n	8009ca6 <I2C_Mem_Write+0x14a>
	{
		while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_TxE))
 8009c2c:	bf00      	nop
 8009c2e:	68fb      	ldr	r3, [r7, #12]
 8009c30:	681b      	ldr	r3, [r3, #0]
 8009c32:	2106      	movs	r1, #6
 8009c34:	4618      	mov	r0, r3
 8009c36:	f7ff ff01 	bl	8009a3c <I2C_GetFlagStatus>
 8009c3a:	4603      	mov	r3, r0
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d0f6      	beq.n	8009c2e <I2C_Mem_Write+0xd2>
		{

		}

		pI2CHandle->pI2Cx->DR.reg = *pI2CHandle->pTxBuffer;
 8009c40:	68fb      	ldr	r3, [r7, #12]
 8009c42:	68db      	ldr	r3, [r3, #12]
 8009c44:	781a      	ldrb	r2, [r3, #0]
 8009c46:	68fb      	ldr	r3, [r7, #12]
 8009c48:	681b      	ldr	r3, [r3, #0]
 8009c4a:	611a      	str	r2, [r3, #16]

		pI2CHandle->pTxBuffer++;
 8009c4c:	68fb      	ldr	r3, [r7, #12]
 8009c4e:	68db      	ldr	r3, [r3, #12]
 8009c50:	1c5a      	adds	r2, r3, #1
 8009c52:	68fb      	ldr	r3, [r7, #12]
 8009c54:	60da      	str	r2, [r3, #12]

		pI2CHandle->TxLen--;
 8009c56:	68fb      	ldr	r3, [r7, #12]
 8009c58:	695b      	ldr	r3, [r3, #20]
 8009c5a:	1e5a      	subs	r2, r3, #1
 8009c5c:	68fb      	ldr	r3, [r7, #12]
 8009c5e:	615a      	str	r2, [r3, #20]
		Size--;
 8009c60:	8bbb      	ldrh	r3, [r7, #28]
 8009c62:	3b01      	subs	r3, #1
 8009c64:	83bb      	strh	r3, [r7, #28]

		if((SET == I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_BTF)) && (pI2CHandle->TxLen != 0))
 8009c66:	68fb      	ldr	r3, [r7, #12]
 8009c68:	681b      	ldr	r3, [r3, #0]
 8009c6a:	2102      	movs	r1, #2
 8009c6c:	4618      	mov	r0, r3
 8009c6e:	f7ff fee5 	bl	8009a3c <I2C_GetFlagStatus>
 8009c72:	4603      	mov	r3, r0
 8009c74:	2b01      	cmp	r3, #1
 8009c76:	d116      	bne.n	8009ca6 <I2C_Mem_Write+0x14a>
 8009c78:	68fb      	ldr	r3, [r7, #12]
 8009c7a:	695b      	ldr	r3, [r3, #20]
 8009c7c:	2b00      	cmp	r3, #0
 8009c7e:	d012      	beq.n	8009ca6 <I2C_Mem_Write+0x14a>
		{
			pI2CHandle->pI2Cx->DR.reg = *pI2CHandle->pTxBuffer;
 8009c80:	68fb      	ldr	r3, [r7, #12]
 8009c82:	68db      	ldr	r3, [r3, #12]
 8009c84:	781a      	ldrb	r2, [r3, #0]
 8009c86:	68fb      	ldr	r3, [r7, #12]
 8009c88:	681b      	ldr	r3, [r3, #0]
 8009c8a:	611a      	str	r2, [r3, #16]

			pI2CHandle->pTxBuffer++;
 8009c8c:	68fb      	ldr	r3, [r7, #12]
 8009c8e:	68db      	ldr	r3, [r3, #12]
 8009c90:	1c5a      	adds	r2, r3, #1
 8009c92:	68fb      	ldr	r3, [r7, #12]
 8009c94:	60da      	str	r2, [r3, #12]

			pI2CHandle->TxLen--;
 8009c96:	68fb      	ldr	r3, [r7, #12]
 8009c98:	695b      	ldr	r3, [r3, #20]
 8009c9a:	1e5a      	subs	r2, r3, #1
 8009c9c:	68fb      	ldr	r3, [r7, #12]
 8009c9e:	615a      	str	r2, [r3, #20]
			Size--;
 8009ca0:	8bbb      	ldrh	r3, [r7, #28]
 8009ca2:	3b01      	subs	r3, #1
 8009ca4:	83bb      	strh	r3, [r7, #28]
	while(pI2CHandle->TxLen > 0)
 8009ca6:	68fb      	ldr	r3, [r7, #12]
 8009ca8:	695b      	ldr	r3, [r3, #20]
 8009caa:	2b00      	cmp	r3, #0
 8009cac:	d1be      	bne.n	8009c2c <I2C_Mem_Write+0xd0>
		}
	}

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_BTF))
 8009cae:	e00c      	b.n	8009cca <I2C_Mem_Write+0x16e>
	{
		if(SET == pI2CHandle->pI2Cx->SR1.bit.af)
 8009cb0:	68fb      	ldr	r3, [r7, #12]
 8009cb2:	681b      	ldr	r3, [r3, #0]
 8009cb4:	695b      	ldr	r3, [r3, #20]
 8009cb6:	f3c3 2380 	ubfx	r3, r3, #10, #1
 8009cba:	b2db      	uxtb	r3, r3
 8009cbc:	2b01      	cmp	r3, #1
 8009cbe:	d104      	bne.n	8009cca <I2C_Mem_Write+0x16e>
		{
			I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
 8009cc0:	68fb      	ldr	r3, [r7, #12]
 8009cc2:	681b      	ldr	r3, [r3, #0]
 8009cc4:	4618      	mov	r0, r3
 8009cc6:	f7ff fd93 	bl	80097f0 <I2C_GenerateStopCondition>
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_SR1_BTF))
 8009cca:	68fb      	ldr	r3, [r7, #12]
 8009ccc:	681b      	ldr	r3, [r3, #0]
 8009cce:	2102      	movs	r1, #2
 8009cd0:	4618      	mov	r0, r3
 8009cd2:	f7ff feb3 	bl	8009a3c <I2C_GetFlagStatus>
 8009cd6:	4603      	mov	r3, r0
 8009cd8:	2b00      	cmp	r3, #0
 8009cda:	d0e9      	beq.n	8009cb0 <I2C_Mem_Write+0x154>
		}
	}

	I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
 8009cdc:	68fb      	ldr	r3, [r7, #12]
 8009cde:	681b      	ldr	r3, [r3, #0]
 8009ce0:	4618      	mov	r0, r3
 8009ce2:	f7ff fd85 	bl	80097f0 <I2C_GenerateStopCondition>
}
 8009ce6:	bf00      	nop
 8009ce8:	3710      	adds	r7, #16
 8009cea:	46bd      	mov	sp, r7
 8009cec:	bd80      	pop	{r7, pc}

08009cee <I2C_ManageAcking>:
/* @return				- none																			*/
/*																										*/
/* @Note				- none																			*/
/********************************************************************************************************/
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t state)
{
 8009cee:	b480      	push	{r7}
 8009cf0:	b083      	sub	sp, #12
 8009cf2:	af00      	add	r7, sp, #0
 8009cf4:	6078      	str	r0, [r7, #4]
 8009cf6:	460b      	mov	r3, r1
 8009cf8:	70fb      	strb	r3, [r7, #3]
	pI2Cx->CR1.bit.ack = state;
 8009cfa:	78fb      	ldrb	r3, [r7, #3]
 8009cfc:	f003 0301 	and.w	r3, r3, #1
 8009d00:	b2d9      	uxtb	r1, r3
 8009d02:	687a      	ldr	r2, [r7, #4]
 8009d04:	8813      	ldrh	r3, [r2, #0]
 8009d06:	f361 238a 	bfi	r3, r1, #10, #1
 8009d0a:	8013      	strh	r3, [r2, #0]
}
 8009d0c:	bf00      	nop
 8009d0e:	370c      	adds	r7, #12
 8009d10:	46bd      	mov	sp, r7
 8009d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d16:	4770      	bx	lr

08009d18 <RTC_ClockControl>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_ClockControl(RTC_Clock_State_t state)
{
 8009d18:	b480      	push	{r7}
 8009d1a:	b083      	sub	sp, #12
 8009d1c:	af00      	add	r7, sp, #0
 8009d1e:	4603      	mov	r3, r0
 8009d20:	71fb      	strb	r3, [r7, #7]
	if (state == RTC_ENABLE)
 8009d22:	79fb      	ldrb	r3, [r7, #7]
 8009d24:	2b01      	cmp	r3, #1
 8009d26:	d105      	bne.n	8009d34 <RTC_ClockControl+0x1c>
	{
		//enable RTC clock
		RCC->BDCR.bit.rtcen = SET;
 8009d28:	4a10      	ldr	r2, [pc, #64]	@ (8009d6c <RTC_ClockControl+0x54>)
 8009d2a:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009d2c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8009d30:	6713      	str	r3, [r2, #112]	@ 0x70
	{
		//backup domain software reset
		RCC->BDCR.bit.bdrst = SET;
		RCC->BDCR.bit.bdrst = RESET;
	}
}
 8009d32:	e015      	b.n	8009d60 <RTC_ClockControl+0x48>
	else if (state == RTC_DISABLE)
 8009d34:	79fb      	ldrb	r3, [r7, #7]
 8009d36:	2b00      	cmp	r3, #0
 8009d38:	d105      	bne.n	8009d46 <RTC_ClockControl+0x2e>
		RCC->BDCR.bit.rtcen = RESET;
 8009d3a:	4a0c      	ldr	r2, [pc, #48]	@ (8009d6c <RTC_ClockControl+0x54>)
 8009d3c:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009d3e:	f36f 33cf 	bfc	r3, #15, #1
 8009d42:	6713      	str	r3, [r2, #112]	@ 0x70
}
 8009d44:	e00c      	b.n	8009d60 <RTC_ClockControl+0x48>
	else if(state == RTC_RESET)
 8009d46:	79fb      	ldrb	r3, [r7, #7]
 8009d48:	2b02      	cmp	r3, #2
 8009d4a:	d109      	bne.n	8009d60 <RTC_ClockControl+0x48>
		RCC->BDCR.bit.bdrst = SET;
 8009d4c:	4a07      	ldr	r2, [pc, #28]	@ (8009d6c <RTC_ClockControl+0x54>)
 8009d4e:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009d50:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009d54:	6713      	str	r3, [r2, #112]	@ 0x70
		RCC->BDCR.bit.bdrst = RESET;
 8009d56:	4a05      	ldr	r2, [pc, #20]	@ (8009d6c <RTC_ClockControl+0x54>)
 8009d58:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009d5a:	f36f 4310 	bfc	r3, #16, #1
 8009d5e:	6713      	str	r3, [r2, #112]	@ 0x70
}
 8009d60:	bf00      	nop
 8009d62:	370c      	adds	r7, #12
 8009d64:	46bd      	mov	sp, r7
 8009d66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d6a:	4770      	bx	lr
 8009d6c:	40023800 	.word	0x40023800

08009d70 <RTC_Init>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_Init(RTC_Handle_t *pRTCHandle)
{
 8009d70:	b580      	push	{r7, lr}
 8009d72:	b082      	sub	sp, #8
 8009d74:	af00      	add	r7, sp, #0
 8009d76:	6078      	str	r0, [r7, #4]
	PWR->CR.bit.dbp = SET;
 8009d78:	4a2d      	ldr	r2, [pc, #180]	@ (8009e30 <RTC_Init+0xc0>)
 8009d7a:	6813      	ldr	r3, [r2, #0]
 8009d7c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8009d80:	6013      	str	r3, [r2, #0]

	//enable RTC clock
	RTC_ClockControl(RTC_ENABLE);
 8009d82:	2001      	movs	r0, #1
 8009d84:	f7ff ffc8 	bl	8009d18 <RTC_ClockControl>

	RCC->BDCR.bit.rtcsel = 2; //LSI
 8009d88:	4a2a      	ldr	r2, [pc, #168]	@ (8009e34 <RTC_Init+0xc4>)
 8009d8a:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8009d8c:	2102      	movs	r1, #2
 8009d8e:	f361 2309 	bfi	r3, r1, #8, #2
 8009d92:	6713      	str	r3, [r2, #112]	@ 0x70

	//Disable RTC registers write protection
	RTC->WPR.bit.key = 0xCA;
 8009d94:	4a28      	ldr	r2, [pc, #160]	@ (8009e38 <RTC_Init+0xc8>)
 8009d96:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009d98:	21ca      	movs	r1, #202	@ 0xca
 8009d9a:	f361 0307 	bfi	r3, r1, #0, #8
 8009d9e:	6253      	str	r3, [r2, #36]	@ 0x24
	RTC->WPR.bit.key = 0x53;
 8009da0:	4a25      	ldr	r2, [pc, #148]	@ (8009e38 <RTC_Init+0xc8>)
 8009da2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8009da4:	2153      	movs	r1, #83	@ 0x53
 8009da6:	f361 0307 	bfi	r3, r1, #0, #8
 8009daa:	6253      	str	r3, [r2, #36]	@ 0x24

	//Enable initialization mode
	RTC->ISR.bit.init = SET;
 8009dac:	4a22      	ldr	r2, [pc, #136]	@ (8009e38 <RTC_Init+0xc8>)
 8009dae:	68d3      	ldr	r3, [r2, #12]
 8009db0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009db4:	60d3      	str	r3, [r2, #12]

	while(!(SET == RTC->ISR.bit.initf))
 8009db6:	bf00      	nop
 8009db8:	4b1f      	ldr	r3, [pc, #124]	@ (8009e38 <RTC_Init+0xc8>)
 8009dba:	68db      	ldr	r3, [r3, #12]
 8009dbc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009dc0:	b2db      	uxtb	r3, r3
 8009dc2:	2b01      	cmp	r3, #1
 8009dc4:	d1f8      	bne.n	8009db8 <RTC_Init+0x48>
	{
		//Wait till initialization mode is set
	}

	RTC->PRER.bit.prediv_s = pRTCHandle->RTC_Config.RTC_SynchPrediv - 1;
 8009dc6:	687b      	ldr	r3, [r7, #4]
 8009dc8:	885b      	ldrh	r3, [r3, #2]
 8009dca:	3b01      	subs	r3, #1
 8009dcc:	b29b      	uxth	r3, r3
 8009dce:	4a1a      	ldr	r2, [pc, #104]	@ (8009e38 <RTC_Init+0xc8>)
 8009dd0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8009dd4:	b299      	uxth	r1, r3
 8009dd6:	6913      	ldr	r3, [r2, #16]
 8009dd8:	f361 030e 	bfi	r3, r1, #0, #15
 8009ddc:	6113      	str	r3, [r2, #16]
	RTC->PRER.bit.prediv_a = pRTCHandle->RTC_Config.RTC_AsynchPrediv - 1;
 8009dde:	687b      	ldr	r3, [r7, #4]
 8009de0:	785b      	ldrb	r3, [r3, #1]
 8009de2:	3b01      	subs	r3, #1
 8009de4:	b2db      	uxtb	r3, r3
 8009de6:	4a14      	ldr	r2, [pc, #80]	@ (8009e38 <RTC_Init+0xc8>)
 8009de8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8009dec:	b2d9      	uxtb	r1, r3
 8009dee:	6913      	ldr	r3, [r2, #16]
 8009df0:	f361 4316 	bfi	r3, r1, #16, #7
 8009df4:	6113      	str	r3, [r2, #16]

	//Set time
	RTC_SetTime(pRTCHandle);
 8009df6:	6878      	ldr	r0, [r7, #4]
 8009df8:	f000 f820 	bl	8009e3c <RTC_SetTime>

	//Set date
	RTC_SetDate(pRTCHandle);
 8009dfc:	6878      	ldr	r0, [r7, #4]
 8009dfe:	f000 f89d 	bl	8009f3c <RTC_SetDate>

	//Set RTC configuration
	RTC->CR.bit.fmt = pRTCHandle->RTC_Config.RTC_HourFormat;
 8009e02:	687b      	ldr	r3, [r7, #4]
 8009e04:	781b      	ldrb	r3, [r3, #0]
 8009e06:	4a0c      	ldr	r2, [pc, #48]	@ (8009e38 <RTC_Init+0xc8>)
 8009e08:	f003 0301 	and.w	r3, r3, #1
 8009e0c:	b2d9      	uxtb	r1, r3
 8009e0e:	6893      	ldr	r3, [r2, #8]
 8009e10:	f361 1386 	bfi	r3, r1, #6, #1
 8009e14:	6093      	str	r3, [r2, #8]

	//Disable initialization mode
	RTC->ISR.bit.init = RESET;
 8009e16:	4a08      	ldr	r2, [pc, #32]	@ (8009e38 <RTC_Init+0xc8>)
 8009e18:	68d3      	ldr	r3, [r2, #12]
 8009e1a:	f36f 13c7 	bfc	r3, #7, #1
 8009e1e:	60d3      	str	r3, [r2, #12]

	//Enable RTC registers write protection
	RTC->WPR.reg = 0xFF;
 8009e20:	4b05      	ldr	r3, [pc, #20]	@ (8009e38 <RTC_Init+0xc8>)
 8009e22:	22ff      	movs	r2, #255	@ 0xff
 8009e24:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8009e26:	bf00      	nop
 8009e28:	3708      	adds	r7, #8
 8009e2a:	46bd      	mov	sp, r7
 8009e2c:	bd80      	pop	{r7, pc}
 8009e2e:	bf00      	nop
 8009e30:	40007000 	.word	0x40007000
 8009e34:	40023800 	.word	0x40023800
 8009e38:	40002800 	.word	0x40002800

08009e3c <RTC_SetTime>:
/* @return				- none																			*/
/*																										*/
/* @Note					- 23 hours, 59 minutes, 59 seconds												*/
/********************************************************************************************************/
void RTC_SetTime(RTC_Handle_t *pRTCHandle)
{
 8009e3c:	b480      	push	{r7}
 8009e3e:	b085      	sub	sp, #20
 8009e40:	af00      	add	r7, sp, #0
 8009e42:	6078      	str	r0, [r7, #4]

	RTC_TR_Reg_t TR_temp = {0};
 8009e44:	2300      	movs	r3, #0
 8009e46:	60fb      	str	r3, [r7, #12]

	//Set RTC time
	TR_temp.bit.pm  = pRTCHandle->Time.AM_PM;
 8009e48:	687b      	ldr	r3, [r7, #4]
 8009e4a:	79db      	ldrb	r3, [r3, #7]
 8009e4c:	f003 0301 	and.w	r3, r3, #1
 8009e50:	b2da      	uxtb	r2, r3
 8009e52:	68fb      	ldr	r3, [r7, #12]
 8009e54:	f362 5396 	bfi	r3, r2, #22, #1
 8009e58:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.ht  = pRTCHandle->Time.hour   / 10;
 8009e5a:	687b      	ldr	r3, [r7, #4]
 8009e5c:	791b      	ldrb	r3, [r3, #4]
 8009e5e:	4a35      	ldr	r2, [pc, #212]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009e60:	fba2 2303 	umull	r2, r3, r2, r3
 8009e64:	08db      	lsrs	r3, r3, #3
 8009e66:	b2db      	uxtb	r3, r3
 8009e68:	f003 0303 	and.w	r3, r3, #3
 8009e6c:	b2da      	uxtb	r2, r3
 8009e6e:	68fb      	ldr	r3, [r7, #12]
 8009e70:	f362 5315 	bfi	r3, r2, #20, #2
 8009e74:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.hu  = pRTCHandle->Time.hour   % 10;
 8009e76:	687b      	ldr	r3, [r7, #4]
 8009e78:	791a      	ldrb	r2, [r3, #4]
 8009e7a:	4b2e      	ldr	r3, [pc, #184]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009e7c:	fba3 1302 	umull	r1, r3, r3, r2
 8009e80:	08d9      	lsrs	r1, r3, #3
 8009e82:	460b      	mov	r3, r1
 8009e84:	009b      	lsls	r3, r3, #2
 8009e86:	440b      	add	r3, r1
 8009e88:	005b      	lsls	r3, r3, #1
 8009e8a:	1ad3      	subs	r3, r2, r3
 8009e8c:	b2db      	uxtb	r3, r3
 8009e8e:	f003 030f 	and.w	r3, r3, #15
 8009e92:	b2da      	uxtb	r2, r3
 8009e94:	68fb      	ldr	r3, [r7, #12]
 8009e96:	f362 4313 	bfi	r3, r2, #16, #4
 8009e9a:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.mnt = pRTCHandle->Time.minute / 10;
 8009e9c:	687b      	ldr	r3, [r7, #4]
 8009e9e:	795b      	ldrb	r3, [r3, #5]
 8009ea0:	4a24      	ldr	r2, [pc, #144]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009ea2:	fba2 2303 	umull	r2, r3, r2, r3
 8009ea6:	08db      	lsrs	r3, r3, #3
 8009ea8:	b2db      	uxtb	r3, r3
 8009eaa:	f003 0307 	and.w	r3, r3, #7
 8009eae:	b2da      	uxtb	r2, r3
 8009eb0:	68fb      	ldr	r3, [r7, #12]
 8009eb2:	f362 330e 	bfi	r3, r2, #12, #3
 8009eb6:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.mnu = pRTCHandle->Time.minute % 10;
 8009eb8:	687b      	ldr	r3, [r7, #4]
 8009eba:	795a      	ldrb	r2, [r3, #5]
 8009ebc:	4b1d      	ldr	r3, [pc, #116]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009ebe:	fba3 1302 	umull	r1, r3, r3, r2
 8009ec2:	08d9      	lsrs	r1, r3, #3
 8009ec4:	460b      	mov	r3, r1
 8009ec6:	009b      	lsls	r3, r3, #2
 8009ec8:	440b      	add	r3, r1
 8009eca:	005b      	lsls	r3, r3, #1
 8009ecc:	1ad3      	subs	r3, r2, r3
 8009ece:	b2db      	uxtb	r3, r3
 8009ed0:	f003 030f 	and.w	r3, r3, #15
 8009ed4:	b2da      	uxtb	r2, r3
 8009ed6:	68fb      	ldr	r3, [r7, #12]
 8009ed8:	f362 230b 	bfi	r3, r2, #8, #4
 8009edc:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.st  = pRTCHandle->Time.second / 10;
 8009ede:	687b      	ldr	r3, [r7, #4]
 8009ee0:	799b      	ldrb	r3, [r3, #6]
 8009ee2:	4a14      	ldr	r2, [pc, #80]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009ee4:	fba2 2303 	umull	r2, r3, r2, r3
 8009ee8:	08db      	lsrs	r3, r3, #3
 8009eea:	b2db      	uxtb	r3, r3
 8009eec:	f003 0307 	and.w	r3, r3, #7
 8009ef0:	b2da      	uxtb	r2, r3
 8009ef2:	68fb      	ldr	r3, [r7, #12]
 8009ef4:	f362 1306 	bfi	r3, r2, #4, #3
 8009ef8:	60fb      	str	r3, [r7, #12]
	TR_temp.bit.su  = pRTCHandle->Time.second % 10;
 8009efa:	687b      	ldr	r3, [r7, #4]
 8009efc:	799a      	ldrb	r2, [r3, #6]
 8009efe:	4b0d      	ldr	r3, [pc, #52]	@ (8009f34 <RTC_SetTime+0xf8>)
 8009f00:	fba3 1302 	umull	r1, r3, r3, r2
 8009f04:	08d9      	lsrs	r1, r3, #3
 8009f06:	460b      	mov	r3, r1
 8009f08:	009b      	lsls	r3, r3, #2
 8009f0a:	440b      	add	r3, r1
 8009f0c:	005b      	lsls	r3, r3, #1
 8009f0e:	1ad3      	subs	r3, r2, r3
 8009f10:	b2db      	uxtb	r3, r3
 8009f12:	f003 030f 	and.w	r3, r3, #15
 8009f16:	b2da      	uxtb	r2, r3
 8009f18:	68fb      	ldr	r3, [r7, #12]
 8009f1a:	f362 0303 	bfi	r3, r2, #0, #4
 8009f1e:	60fb      	str	r3, [r7, #12]
	RTC->TR.reg = TR_temp.reg;
 8009f20:	4a05      	ldr	r2, [pc, #20]	@ (8009f38 <RTC_SetTime+0xfc>)
 8009f22:	68fb      	ldr	r3, [r7, #12]
 8009f24:	6013      	str	r3, [r2, #0]
}
 8009f26:	bf00      	nop
 8009f28:	3714      	adds	r7, #20
 8009f2a:	46bd      	mov	sp, r7
 8009f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f30:	4770      	bx	lr
 8009f32:	bf00      	nop
 8009f34:	cccccccd 	.word	0xcccccccd
 8009f38:	40002800 	.word	0x40002800

08009f3c <RTC_SetDate>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_SetDate(RTC_Handle_t * pRTCHandle)
{
 8009f3c:	b580      	push	{r7, lr}
 8009f3e:	b084      	sub	sp, #16
 8009f40:	af00      	add	r7, sp, #0
 8009f42:	6078      	str	r0, [r7, #4]
	RTC_DR_Reg_t DR_Temp = {0};
 8009f44:	2300      	movs	r3, #0
 8009f46:	60fb      	str	r3, [r7, #12]

	pRTCHandle->Date.month = (uint8_t)((pRTCHandle->Date.month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8009f48:	687b      	ldr	r3, [r7, #4]
 8009f4a:	7a5b      	ldrb	r3, [r3, #9]
 8009f4c:	f023 0310 	bic.w	r3, r3, #16
 8009f50:	b2db      	uxtb	r3, r3
 8009f52:	330a      	adds	r3, #10
 8009f54:	b2da      	uxtb	r2, r3
 8009f56:	687b      	ldr	r3, [r7, #4]
 8009f58:	725a      	strb	r2, [r3, #9]

	//Set RTC date
	DR_Temp.bit.yt  = (uint32_t)RTC_ByteToBcd2(pRTCHandle->Date.year / 10);
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	7a1b      	ldrb	r3, [r3, #8]
 8009f5e:	4a28      	ldr	r2, [pc, #160]	@ (800a000 <RTC_SetDate+0xc4>)
 8009f60:	fba2 2303 	umull	r2, r3, r2, r3
 8009f64:	08db      	lsrs	r3, r3, #3
 8009f66:	b2db      	uxtb	r3, r3
 8009f68:	4618      	mov	r0, r3
 8009f6a:	f000 fa09 	bl	800a380 <RTC_ByteToBcd2>
 8009f6e:	4603      	mov	r3, r0
 8009f70:	f003 030f 	and.w	r3, r3, #15
 8009f74:	b2da      	uxtb	r2, r3
 8009f76:	68fb      	ldr	r3, [r7, #12]
 8009f78:	f362 5317 	bfi	r3, r2, #20, #4
 8009f7c:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.yu  = (uint32_t)RTC_ByteToBcd2(pRTCHandle->Date.year % 10);
 8009f7e:	687b      	ldr	r3, [r7, #4]
 8009f80:	7a1a      	ldrb	r2, [r3, #8]
 8009f82:	4b1f      	ldr	r3, [pc, #124]	@ (800a000 <RTC_SetDate+0xc4>)
 8009f84:	fba3 1302 	umull	r1, r3, r3, r2
 8009f88:	08d9      	lsrs	r1, r3, #3
 8009f8a:	460b      	mov	r3, r1
 8009f8c:	009b      	lsls	r3, r3, #2
 8009f8e:	440b      	add	r3, r1
 8009f90:	005b      	lsls	r3, r3, #1
 8009f92:	1ad3      	subs	r3, r2, r3
 8009f94:	b2db      	uxtb	r3, r3
 8009f96:	4618      	mov	r0, r3
 8009f98:	f000 f9f2 	bl	800a380 <RTC_ByteToBcd2>
 8009f9c:	4603      	mov	r3, r0
 8009f9e:	f003 030f 	and.w	r3, r3, #15
 8009fa2:	b2da      	uxtb	r2, r3
 8009fa4:	68fb      	ldr	r3, [r7, #12]
 8009fa6:	f362 4313 	bfi	r3, r2, #16, #4
 8009faa:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.mu  = (uint32_t)RTC_ByteToBcd2(pRTCHandle->Date.month);
 8009fac:	687b      	ldr	r3, [r7, #4]
 8009fae:	7a5b      	ldrb	r3, [r3, #9]
 8009fb0:	4618      	mov	r0, r3
 8009fb2:	f000 f9e5 	bl	800a380 <RTC_ByteToBcd2>
 8009fb6:	4603      	mov	r3, r0
 8009fb8:	f003 030f 	and.w	r3, r3, #15
 8009fbc:	b2da      	uxtb	r2, r3
 8009fbe:	68fb      	ldr	r3, [r7, #12]
 8009fc0:	f362 230b 	bfi	r3, r2, #8, #4
 8009fc4:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.du  = (uint32_t)RTC_ByteToBcd2(pRTCHandle->Date.date);
 8009fc6:	687b      	ldr	r3, [r7, #4]
 8009fc8:	7a9b      	ldrb	r3, [r3, #10]
 8009fca:	4618      	mov	r0, r3
 8009fcc:	f000 f9d8 	bl	800a380 <RTC_ByteToBcd2>
 8009fd0:	4603      	mov	r3, r0
 8009fd2:	f003 030f 	and.w	r3, r3, #15
 8009fd6:	b2da      	uxtb	r2, r3
 8009fd8:	68fb      	ldr	r3, [r7, #12]
 8009fda:	f362 0303 	bfi	r3, r2, #0, #4
 8009fde:	60fb      	str	r3, [r7, #12]
	DR_Temp.bit.wdu = (uint32_t)pRTCHandle->Date.weekDay;
 8009fe0:	687b      	ldr	r3, [r7, #4]
 8009fe2:	7adb      	ldrb	r3, [r3, #11]
 8009fe4:	f003 0307 	and.w	r3, r3, #7
 8009fe8:	b2da      	uxtb	r2, r3
 8009fea:	68fb      	ldr	r3, [r7, #12]
 8009fec:	f362 334f 	bfi	r3, r2, #13, #3
 8009ff0:	60fb      	str	r3, [r7, #12]

	RTC->DR.reg = DR_Temp.reg;
 8009ff2:	4a04      	ldr	r2, [pc, #16]	@ (800a004 <RTC_SetDate+0xc8>)
 8009ff4:	68fb      	ldr	r3, [r7, #12]
 8009ff6:	6053      	str	r3, [r2, #4]
}
 8009ff8:	bf00      	nop
 8009ffa:	3710      	adds	r7, #16
 8009ffc:	46bd      	mov	sp, r7
 8009ffe:	bd80      	pop	{r7, pc}
 800a000:	cccccccd 	.word	0xcccccccd
 800a004:	40002800 	.word	0x40002800

0800a008 <RTC_GetTime>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_GetTime(RTC_Handle_t * pRTCHandle, Current_Date_Handle_t* pCurrentDateHandle)
{
 800a008:	b480      	push	{r7}
 800a00a:	b085      	sub	sp, #20
 800a00c:	af00      	add	r7, sp, #0
 800a00e:	6078      	str	r0, [r7, #4]
 800a010:	6039      	str	r1, [r7, #0]
	RTC_TR_Reg_t TR_temp = {0};
 800a012:	2300      	movs	r3, #0
 800a014:	60fb      	str	r3, [r7, #12]

	//Read the time values
	TR_temp.reg = RTC->TR.reg;
 800a016:	4b26      	ldr	r3, [pc, #152]	@ (800a0b0 <RTC_GetTime+0xa8>)
 800a018:	681b      	ldr	r3, [r3, #0]
 800a01a:	60fb      	str	r3, [r7, #12]

	while (!(SET == RTC->ISR.bit.rsf))
 800a01c:	bf00      	nop
 800a01e:	4b24      	ldr	r3, [pc, #144]	@ (800a0b0 <RTC_GetTime+0xa8>)
 800a020:	68db      	ldr	r3, [r3, #12]
 800a022:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a026:	b2db      	uxtb	r3, r3
 800a028:	2b01      	cmp	r3, #1
 800a02a:	d1f8      	bne.n	800a01e <RTC_GetTime+0x16>
	{
		//wait till the RTC time is updated
	}

	//read the time
	pCurrentDateHandle->Time.hour        = TR_temp.bit.ht  * 10 + TR_temp.bit.hu;
 800a02c:	68fb      	ldr	r3, [r7, #12]
 800a02e:	f3c3 5301 	ubfx	r3, r3, #20, #2
 800a032:	b2db      	uxtb	r3, r3
 800a034:	461a      	mov	r2, r3
 800a036:	0092      	lsls	r2, r2, #2
 800a038:	4413      	add	r3, r2
 800a03a:	005b      	lsls	r3, r3, #1
 800a03c:	b2db      	uxtb	r3, r3
 800a03e:	68fa      	ldr	r2, [r7, #12]
 800a040:	f3c2 4203 	ubfx	r2, r2, #16, #4
 800a044:	b2d2      	uxtb	r2, r2
 800a046:	4413      	add	r3, r2
 800a048:	b2da      	uxtb	r2, r3
 800a04a:	683b      	ldr	r3, [r7, #0]
 800a04c:	701a      	strb	r2, [r3, #0]
	pCurrentDateHandle->Time.minute      = TR_temp.bit.mnt * 10 + TR_temp.bit.mnu;
 800a04e:	68fb      	ldr	r3, [r7, #12]
 800a050:	f3c3 3302 	ubfx	r3, r3, #12, #3
 800a054:	b2db      	uxtb	r3, r3
 800a056:	461a      	mov	r2, r3
 800a058:	0092      	lsls	r2, r2, #2
 800a05a:	4413      	add	r3, r2
 800a05c:	005b      	lsls	r3, r3, #1
 800a05e:	b2db      	uxtb	r3, r3
 800a060:	68fa      	ldr	r2, [r7, #12]
 800a062:	f3c2 2203 	ubfx	r2, r2, #8, #4
 800a066:	b2d2      	uxtb	r2, r2
 800a068:	4413      	add	r3, r2
 800a06a:	b2da      	uxtb	r2, r3
 800a06c:	683b      	ldr	r3, [r7, #0]
 800a06e:	705a      	strb	r2, [r3, #1]
	pCurrentDateHandle->Time.second      = TR_temp.bit.st  * 10 + TR_temp.bit.su;
 800a070:	68fb      	ldr	r3, [r7, #12]
 800a072:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800a076:	b2db      	uxtb	r3, r3
 800a078:	461a      	mov	r2, r3
 800a07a:	0092      	lsls	r2, r2, #2
 800a07c:	4413      	add	r3, r2
 800a07e:	005b      	lsls	r3, r3, #1
 800a080:	b2db      	uxtb	r3, r3
 800a082:	68fa      	ldr	r2, [r7, #12]
 800a084:	f3c2 0203 	ubfx	r2, r2, #0, #4
 800a088:	b2d2      	uxtb	r2, r2
 800a08a:	4413      	add	r3, r2
 800a08c:	b2da      	uxtb	r2, r3
 800a08e:	683b      	ldr	r3, [r7, #0]
 800a090:	709a      	strb	r2, [r3, #2]
	pCurrentDateHandle->Time.hour_format = RTC->CR.bit.fmt;
 800a092:	4b07      	ldr	r3, [pc, #28]	@ (800a0b0 <RTC_GetTime+0xa8>)
 800a094:	689b      	ldr	r3, [r3, #8]
 800a096:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a09a:	b2db      	uxtb	r3, r3
 800a09c:	461a      	mov	r2, r3
 800a09e:	683b      	ldr	r3, [r7, #0]
 800a0a0:	70da      	strb	r2, [r3, #3]
}
 800a0a2:	bf00      	nop
 800a0a4:	3714      	adds	r7, #20
 800a0a6:	46bd      	mov	sp, r7
 800a0a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0ac:	4770      	bx	lr
 800a0ae:	bf00      	nop
 800a0b0:	40002800 	.word	0x40002800

0800a0b4 <RTC_GetDate>:
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_GetDate(RTC_Handle_t* pRTCHandle, Current_Date_Handle_t* pCurrentDateHandle)
{
 800a0b4:	b580      	push	{r7, lr}
 800a0b6:	b084      	sub	sp, #16
 800a0b8:	af00      	add	r7, sp, #0
 800a0ba:	6078      	str	r0, [r7, #4]
 800a0bc:	6039      	str	r1, [r7, #0]
	RTC_DR_Reg_t DR_temp = {0};
 800a0be:	2300      	movs	r3, #0
 800a0c0:	60fb      	str	r3, [r7, #12]

	//Read the date values
	DR_temp.reg = RTC->DR.reg;
 800a0c2:	4b34      	ldr	r3, [pc, #208]	@ (800a194 <RTC_GetDate+0xe0>)
 800a0c4:	685b      	ldr	r3, [r3, #4]
 800a0c6:	60fb      	str	r3, [r7, #12]

	pCurrentDateHandle->Date.year = DR_temp.bit.yt * 10;
 800a0c8:	68fb      	ldr	r3, [r7, #12]
 800a0ca:	f3c3 5303 	ubfx	r3, r3, #20, #4
 800a0ce:	b2db      	uxtb	r3, r3
 800a0d0:	461a      	mov	r2, r3
 800a0d2:	0092      	lsls	r2, r2, #2
 800a0d4:	4413      	add	r3, r2
 800a0d6:	005b      	lsls	r3, r3, #1
 800a0d8:	b2da      	uxtb	r2, r3
 800a0da:	683b      	ldr	r3, [r7, #0]
 800a0dc:	711a      	strb	r2, [r3, #4]
	pCurrentDateHandle->Date.year += DR_temp.bit.yu;
 800a0de:	68fb      	ldr	r3, [r7, #12]
 800a0e0:	f3c3 4303 	ubfx	r3, r3, #16, #4
 800a0e4:	b2da      	uxtb	r2, r3
 800a0e6:	683b      	ldr	r3, [r7, #0]
 800a0e8:	791b      	ldrb	r3, [r3, #4]
 800a0ea:	4413      	add	r3, r2
 800a0ec:	b2da      	uxtb	r2, r3
 800a0ee:	683b      	ldr	r3, [r7, #0]
 800a0f0:	711a      	strb	r2, [r3, #4]

	pCurrentDateHandle->Date.month = DR_temp.bit.mt * 10;
 800a0f2:	68fb      	ldr	r3, [r7, #12]
 800a0f4:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800a0f8:	b2db      	uxtb	r3, r3
 800a0fa:	461a      	mov	r2, r3
 800a0fc:	0092      	lsls	r2, r2, #2
 800a0fe:	4413      	add	r3, r2
 800a100:	005b      	lsls	r3, r3, #1
 800a102:	b2da      	uxtb	r2, r3
 800a104:	683b      	ldr	r3, [r7, #0]
 800a106:	715a      	strb	r2, [r3, #5]
	pCurrentDateHandle->Date.month += DR_temp.bit.mu;
 800a108:	68fb      	ldr	r3, [r7, #12]
 800a10a:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800a10e:	b2da      	uxtb	r2, r3
 800a110:	683b      	ldr	r3, [r7, #0]
 800a112:	795b      	ldrb	r3, [r3, #5]
 800a114:	4413      	add	r3, r2
 800a116:	b2da      	uxtb	r2, r3
 800a118:	683b      	ldr	r3, [r7, #0]
 800a11a:	715a      	strb	r2, [r3, #5]

	pCurrentDateHandle->Date.date = DR_temp.bit.dt * 10;
 800a11c:	68fb      	ldr	r3, [r7, #12]
 800a11e:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800a122:	b2db      	uxtb	r3, r3
 800a124:	461a      	mov	r2, r3
 800a126:	0092      	lsls	r2, r2, #2
 800a128:	4413      	add	r3, r2
 800a12a:	005b      	lsls	r3, r3, #1
 800a12c:	b2da      	uxtb	r2, r3
 800a12e:	683b      	ldr	r3, [r7, #0]
 800a130:	719a      	strb	r2, [r3, #6]
	pCurrentDateHandle->Date.date += DR_temp.bit.du;
 800a132:	68fb      	ldr	r3, [r7, #12]
 800a134:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800a138:	b2da      	uxtb	r2, r3
 800a13a:	683b      	ldr	r3, [r7, #0]
 800a13c:	799b      	ldrb	r3, [r3, #6]
 800a13e:	4413      	add	r3, r2
 800a140:	b2da      	uxtb	r2, r3
 800a142:	683b      	ldr	r3, [r7, #0]
 800a144:	719a      	strb	r2, [r3, #6]

	pCurrentDateHandle->Date.weekDay = DR_temp.bit.wdu;
 800a146:	68fb      	ldr	r3, [r7, #12]
 800a148:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800a14c:	b2db      	uxtb	r3, r3
 800a14e:	461a      	mov	r2, r3
 800a150:	683b      	ldr	r3, [r7, #0]
 800a152:	71da      	strb	r2, [r3, #7]

	pCurrentDateHandle->Date.year  = (uint8_t)RTC_Bcd2ToByte(pCurrentDateHandle->Date.year);
 800a154:	683b      	ldr	r3, [r7, #0]
 800a156:	791b      	ldrb	r3, [r3, #4]
 800a158:	4618      	mov	r0, r3
 800a15a:	f000 f92f 	bl	800a3bc <RTC_Bcd2ToByte>
 800a15e:	4603      	mov	r3, r0
 800a160:	461a      	mov	r2, r3
 800a162:	683b      	ldr	r3, [r7, #0]
 800a164:	711a      	strb	r2, [r3, #4]
	pCurrentDateHandle->Date.month = (uint8_t)RTC_Bcd2ToByte(pCurrentDateHandle->Date.month);
 800a166:	683b      	ldr	r3, [r7, #0]
 800a168:	795b      	ldrb	r3, [r3, #5]
 800a16a:	4618      	mov	r0, r3
 800a16c:	f000 f926 	bl	800a3bc <RTC_Bcd2ToByte>
 800a170:	4603      	mov	r3, r0
 800a172:	461a      	mov	r2, r3
 800a174:	683b      	ldr	r3, [r7, #0]
 800a176:	715a      	strb	r2, [r3, #5]
	pCurrentDateHandle->Date.date  = (uint8_t)RTC_Bcd2ToByte(pCurrentDateHandle->Date.date);
 800a178:	683b      	ldr	r3, [r7, #0]
 800a17a:	799b      	ldrb	r3, [r3, #6]
 800a17c:	4618      	mov	r0, r3
 800a17e:	f000 f91d 	bl	800a3bc <RTC_Bcd2ToByte>
 800a182:	4603      	mov	r3, r0
 800a184:	461a      	mov	r2, r3
 800a186:	683b      	ldr	r3, [r7, #0]
 800a188:	719a      	strb	r2, [r3, #6]
}
 800a18a:	bf00      	nop
 800a18c:	3710      	adds	r7, #16
 800a18e:	46bd      	mov	sp, r7
 800a190:	bd80      	pop	{r7, pc}
 800a192:	bf00      	nop
 800a194:	40002800 	.word	0x40002800

0800a198 <RTC_SetAlarm_IT>:
/*																										*/
/* @return				- none																			*/
/*																										*/
/* @Note					- none																			*/
/********************************************************************************************************/
void RTC_SetAlarm_IT(RTC_Handle_t *pRTCHandle, RTC_AlarmType_t alarmType, RTC_Alarm_t *pAlarm) {
 800a198:	b480      	push	{r7}
 800a19a:	b087      	sub	sp, #28
 800a19c:	af00      	add	r7, sp, #0
 800a19e:	60f8      	str	r0, [r7, #12]
 800a1a0:	460b      	mov	r3, r1
 800a1a2:	607a      	str	r2, [r7, #4]
 800a1a4:	72fb      	strb	r3, [r7, #11]
    // Disable RTC registers write protection
    RTC->WPR.bit.key = 0xCA;
 800a1a6:	4a72      	ldr	r2, [pc, #456]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a1a8:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a1aa:	21ca      	movs	r1, #202	@ 0xca
 800a1ac:	f361 0307 	bfi	r3, r1, #0, #8
 800a1b0:	6253      	str	r3, [r2, #36]	@ 0x24
    RTC->WPR.bit.key = 0x53;
 800a1b2:	4a6f      	ldr	r2, [pc, #444]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a1b4:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 800a1b6:	2153      	movs	r1, #83	@ 0x53
 800a1b8:	f361 0307 	bfi	r3, r1, #0, #8
 800a1bc:	6253      	str	r3, [r2, #36]	@ 0x24

    // Enable initialization mode
    RTC->ISR.bit.init = SET;
 800a1be:	4a6c      	ldr	r2, [pc, #432]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a1c0:	68d3      	ldr	r3, [r2, #12]
 800a1c2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800a1c6:	60d3      	str	r3, [r2, #12]

    while (!(SET == RTC->ISR.bit.initf))
 800a1c8:	bf00      	nop
 800a1ca:	4b69      	ldr	r3, [pc, #420]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a1cc:	68db      	ldr	r3, [r3, #12]
 800a1ce:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a1d2:	b2db      	uxtb	r3, r3
 800a1d4:	2b01      	cmp	r3, #1
 800a1d6:	d1f8      	bne.n	800a1ca <RTC_SetAlarm_IT+0x32>
    {
        // Wait till initialization mode is set
    }

    // Set RTC alarm configuration
    RTC_ALRMx_Reg_t *pALRM = (alarmType == RTC_ALARM_A) ? &RTC->ALRMAR : &RTC->ALRMBR;
 800a1d8:	7afb      	ldrb	r3, [r7, #11]
 800a1da:	2b00      	cmp	r3, #0
 800a1dc:	d101      	bne.n	800a1e2 <RTC_SetAlarm_IT+0x4a>
 800a1de:	4b65      	ldr	r3, [pc, #404]	@ (800a374 <RTC_SetAlarm_IT+0x1dc>)
 800a1e0:	e000      	b.n	800a1e4 <RTC_SetAlarm_IT+0x4c>
 800a1e2:	4b65      	ldr	r3, [pc, #404]	@ (800a378 <RTC_SetAlarm_IT+0x1e0>)
 800a1e4:	617b      	str	r3, [r7, #20]

    pALRM->bit.hu = pAlarm->hour / 10;
 800a1e6:	687b      	ldr	r3, [r7, #4]
 800a1e8:	781b      	ldrb	r3, [r3, #0]
 800a1ea:	4a64      	ldr	r2, [pc, #400]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a1ec:	fba2 2303 	umull	r2, r3, r2, r3
 800a1f0:	08db      	lsrs	r3, r3, #3
 800a1f2:	b2db      	uxtb	r3, r3
 800a1f4:	f003 030f 	and.w	r3, r3, #15
 800a1f8:	b2d9      	uxtb	r1, r3
 800a1fa:	697a      	ldr	r2, [r7, #20]
 800a1fc:	6813      	ldr	r3, [r2, #0]
 800a1fe:	f361 4313 	bfi	r3, r1, #16, #4
 800a202:	6013      	str	r3, [r2, #0]
    pALRM->bit.ht = pAlarm->hour % 10;
 800a204:	687b      	ldr	r3, [r7, #4]
 800a206:	781a      	ldrb	r2, [r3, #0]
 800a208:	4b5c      	ldr	r3, [pc, #368]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a20a:	fba3 1302 	umull	r1, r3, r3, r2
 800a20e:	08d9      	lsrs	r1, r3, #3
 800a210:	460b      	mov	r3, r1
 800a212:	009b      	lsls	r3, r3, #2
 800a214:	440b      	add	r3, r1
 800a216:	005b      	lsls	r3, r3, #1
 800a218:	1ad3      	subs	r3, r2, r3
 800a21a:	b2db      	uxtb	r3, r3
 800a21c:	f003 0303 	and.w	r3, r3, #3
 800a220:	b2d9      	uxtb	r1, r3
 800a222:	697a      	ldr	r2, [r7, #20]
 800a224:	6813      	ldr	r3, [r2, #0]
 800a226:	f361 5315 	bfi	r3, r1, #20, #2
 800a22a:	6013      	str	r3, [r2, #0]
    pALRM->bit.mnu = pAlarm->minute / 10;
 800a22c:	687b      	ldr	r3, [r7, #4]
 800a22e:	785b      	ldrb	r3, [r3, #1]
 800a230:	4a52      	ldr	r2, [pc, #328]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a232:	fba2 2303 	umull	r2, r3, r2, r3
 800a236:	08db      	lsrs	r3, r3, #3
 800a238:	b2db      	uxtb	r3, r3
 800a23a:	f003 030f 	and.w	r3, r3, #15
 800a23e:	b2d9      	uxtb	r1, r3
 800a240:	697a      	ldr	r2, [r7, #20]
 800a242:	6813      	ldr	r3, [r2, #0]
 800a244:	f361 230b 	bfi	r3, r1, #8, #4
 800a248:	6013      	str	r3, [r2, #0]
    pALRM->bit.mnt = pAlarm->minute % 10;
 800a24a:	687b      	ldr	r3, [r7, #4]
 800a24c:	785a      	ldrb	r2, [r3, #1]
 800a24e:	4b4b      	ldr	r3, [pc, #300]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a250:	fba3 1302 	umull	r1, r3, r3, r2
 800a254:	08d9      	lsrs	r1, r3, #3
 800a256:	460b      	mov	r3, r1
 800a258:	009b      	lsls	r3, r3, #2
 800a25a:	440b      	add	r3, r1
 800a25c:	005b      	lsls	r3, r3, #1
 800a25e:	1ad3      	subs	r3, r2, r3
 800a260:	b2db      	uxtb	r3, r3
 800a262:	f003 0307 	and.w	r3, r3, #7
 800a266:	b2d9      	uxtb	r1, r3
 800a268:	697a      	ldr	r2, [r7, #20]
 800a26a:	6813      	ldr	r3, [r2, #0]
 800a26c:	f361 330e 	bfi	r3, r1, #12, #3
 800a270:	6013      	str	r3, [r2, #0]
    pALRM->bit.su = pAlarm->second / 10;
 800a272:	687b      	ldr	r3, [r7, #4]
 800a274:	789b      	ldrb	r3, [r3, #2]
 800a276:	4a41      	ldr	r2, [pc, #260]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a278:	fba2 2303 	umull	r2, r3, r2, r3
 800a27c:	08db      	lsrs	r3, r3, #3
 800a27e:	b2db      	uxtb	r3, r3
 800a280:	f003 030f 	and.w	r3, r3, #15
 800a284:	b2d9      	uxtb	r1, r3
 800a286:	697a      	ldr	r2, [r7, #20]
 800a288:	6813      	ldr	r3, [r2, #0]
 800a28a:	f361 0303 	bfi	r3, r1, #0, #4
 800a28e:	6013      	str	r3, [r2, #0]
    pALRM->bit.st = pAlarm->second % 10;
 800a290:	687b      	ldr	r3, [r7, #4]
 800a292:	789a      	ldrb	r2, [r3, #2]
 800a294:	4b39      	ldr	r3, [pc, #228]	@ (800a37c <RTC_SetAlarm_IT+0x1e4>)
 800a296:	fba3 1302 	umull	r1, r3, r3, r2
 800a29a:	08d9      	lsrs	r1, r3, #3
 800a29c:	460b      	mov	r3, r1
 800a29e:	009b      	lsls	r3, r3, #2
 800a2a0:	440b      	add	r3, r1
 800a2a2:	005b      	lsls	r3, r3, #1
 800a2a4:	1ad3      	subs	r3, r2, r3
 800a2a6:	b2db      	uxtb	r3, r3
 800a2a8:	f003 0307 	and.w	r3, r3, #7
 800a2ac:	b2d9      	uxtb	r1, r3
 800a2ae:	697a      	ldr	r2, [r7, #20]
 800a2b0:	6813      	ldr	r3, [r2, #0]
 800a2b2:	f361 1306 	bfi	r3, r1, #4, #3
 800a2b6:	6013      	str	r3, [r2, #0]

    // masking options configuration
    pALRM->bit.msk1 = pAlarm->sec_msk;
 800a2b8:	687b      	ldr	r3, [r7, #4]
 800a2ba:	78db      	ldrb	r3, [r3, #3]
 800a2bc:	f003 0301 	and.w	r3, r3, #1
 800a2c0:	b2d9      	uxtb	r1, r3
 800a2c2:	697a      	ldr	r2, [r7, #20]
 800a2c4:	6813      	ldr	r3, [r2, #0]
 800a2c6:	f361 13c7 	bfi	r3, r1, #7, #1
 800a2ca:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk2 = pAlarm->min_msk;
 800a2cc:	687b      	ldr	r3, [r7, #4]
 800a2ce:	791b      	ldrb	r3, [r3, #4]
 800a2d0:	f003 0301 	and.w	r3, r3, #1
 800a2d4:	b2d9      	uxtb	r1, r3
 800a2d6:	697a      	ldr	r2, [r7, #20]
 800a2d8:	6813      	ldr	r3, [r2, #0]
 800a2da:	f361 33cf 	bfi	r3, r1, #15, #1
 800a2de:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk3 = pAlarm->hour_msk;
 800a2e0:	687b      	ldr	r3, [r7, #4]
 800a2e2:	795b      	ldrb	r3, [r3, #5]
 800a2e4:	f003 0301 	and.w	r3, r3, #1
 800a2e8:	b2d9      	uxtb	r1, r3
 800a2ea:	697a      	ldr	r2, [r7, #20]
 800a2ec:	6813      	ldr	r3, [r2, #0]
 800a2ee:	f361 53d7 	bfi	r3, r1, #23, #1
 800a2f2:	6013      	str	r3, [r2, #0]
    pALRM->bit.msk4 = pAlarm->dateweek_msk;
 800a2f4:	687b      	ldr	r3, [r7, #4]
 800a2f6:	799b      	ldrb	r3, [r3, #6]
 800a2f8:	f003 0301 	and.w	r3, r3, #1
 800a2fc:	b2d9      	uxtb	r1, r3
 800a2fe:	697a      	ldr	r2, [r7, #20]
 800a300:	6813      	ldr	r3, [r2, #0]
 800a302:	f361 73df 	bfi	r3, r1, #31, #1
 800a306:	6013      	str	r3, [r2, #0]

    // Clear the Alarm flag
    if (alarmType == RTC_ALARM_A)
 800a308:	7afb      	ldrb	r3, [r7, #11]
 800a30a:	2b00      	cmp	r3, #0
 800a30c:	d105      	bne.n	800a31a <RTC_SetAlarm_IT+0x182>
    {
        RTC->ISR.bit.alraf = RESET;
 800a30e:	4a18      	ldr	r2, [pc, #96]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a310:	68d3      	ldr	r3, [r2, #12]
 800a312:	f36f 2308 	bfc	r3, #8, #1
 800a316:	60d3      	str	r3, [r2, #12]
 800a318:	e004      	b.n	800a324 <RTC_SetAlarm_IT+0x18c>
    }
    else
    {
        RTC->ISR.bit.alrbf = RESET;
 800a31a:	4a15      	ldr	r2, [pc, #84]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a31c:	68d3      	ldr	r3, [r2, #12]
 800a31e:	f36f 2349 	bfc	r3, #9, #1
 800a322:	60d3      	str	r3, [r2, #12]
    }

    // Enable the Alarm interrupt
    if(alarmType == RTC_ALARM_A)
 800a324:	7afb      	ldrb	r3, [r7, #11]
 800a326:	2b00      	cmp	r3, #0
 800a328:	d10a      	bne.n	800a340 <RTC_SetAlarm_IT+0x1a8>
    {
    	RTC->CR.bit.alrae = SET;
 800a32a:	4a11      	ldr	r2, [pc, #68]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a32c:	6893      	ldr	r3, [r2, #8]
 800a32e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800a332:	6093      	str	r3, [r2, #8]
        RTC->CR.bit.alraie = SET;
 800a334:	4a0e      	ldr	r2, [pc, #56]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a336:	6893      	ldr	r3, [r2, #8]
 800a338:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800a33c:	6093      	str	r3, [r2, #8]
 800a33e:	e009      	b.n	800a354 <RTC_SetAlarm_IT+0x1bc>
    }
    else
    {
    	RTC->CR.bit.alrbe = SET;
 800a340:	4a0b      	ldr	r2, [pc, #44]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a342:	6893      	ldr	r3, [r2, #8]
 800a344:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800a348:	6093      	str	r3, [r2, #8]
        RTC->CR.bit.alrbie = SET;
 800a34a:	4a09      	ldr	r2, [pc, #36]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a34c:	6893      	ldr	r3, [r2, #8]
 800a34e:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800a352:	6093      	str	r3, [r2, #8]
    }

    // Disable initialization mode
    RTC->ISR.bit.init = RESET;
 800a354:	4a06      	ldr	r2, [pc, #24]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a356:	68d3      	ldr	r3, [r2, #12]
 800a358:	f36f 13c7 	bfc	r3, #7, #1
 800a35c:	60d3      	str	r3, [r2, #12]

    // Enable RTC registers write protection
    RTC->WPR.reg = 0xFF;
 800a35e:	4b04      	ldr	r3, [pc, #16]	@ (800a370 <RTC_SetAlarm_IT+0x1d8>)
 800a360:	22ff      	movs	r2, #255	@ 0xff
 800a362:	625a      	str	r2, [r3, #36]	@ 0x24
}
 800a364:	bf00      	nop
 800a366:	371c      	adds	r7, #28
 800a368:	46bd      	mov	sp, r7
 800a36a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a36e:	4770      	bx	lr
 800a370:	40002800 	.word	0x40002800
 800a374:	4000281c 	.word	0x4000281c
 800a378:	40002820 	.word	0x40002820
 800a37c:	cccccccd 	.word	0xcccccccd

0800a380 <RTC_ByteToBcd2>:
/*
 * Helper functions
 */
// Convert a 2-digit value to BCD format
uint8_t RTC_ByteToBcd2(uint8_t number)
{
 800a380:	b480      	push	{r7}
 800a382:	b085      	sub	sp, #20
 800a384:	af00      	add	r7, sp, #0
 800a386:	4603      	mov	r3, r0
 800a388:	71fb      	strb	r3, [r7, #7]
	uint32_t bcdhigh = 0U;
 800a38a:	2300      	movs	r3, #0
 800a38c:	60fb      	str	r3, [r7, #12]

	while (number >= 10U)
 800a38e:	e005      	b.n	800a39c <RTC_ByteToBcd2+0x1c>
	{
		bcdhigh++;
 800a390:	68fb      	ldr	r3, [r7, #12]
 800a392:	3301      	adds	r3, #1
 800a394:	60fb      	str	r3, [r7, #12]
		number -= 10U;
 800a396:	79fb      	ldrb	r3, [r7, #7]
 800a398:	3b0a      	subs	r3, #10
 800a39a:	71fb      	strb	r3, [r7, #7]
	while (number >= 10U)
 800a39c:	79fb      	ldrb	r3, [r7, #7]
 800a39e:	2b09      	cmp	r3, #9
 800a3a0:	d8f6      	bhi.n	800a390 <RTC_ByteToBcd2+0x10>
	}

	return ((uint8_t)(bcdhigh << 4U) | number);
 800a3a2:	68fb      	ldr	r3, [r7, #12]
 800a3a4:	b2db      	uxtb	r3, r3
 800a3a6:	011b      	lsls	r3, r3, #4
 800a3a8:	b2da      	uxtb	r2, r3
 800a3aa:	79fb      	ldrb	r3, [r7, #7]
 800a3ac:	4313      	orrs	r3, r2
 800a3ae:	b2db      	uxtb	r3, r3
}
 800a3b0:	4618      	mov	r0, r3
 800a3b2:	3714      	adds	r7, #20
 800a3b4:	46bd      	mov	sp, r7
 800a3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3ba:	4770      	bx	lr

0800a3bc <RTC_Bcd2ToByte>:

// Convert a 2-digit value from BCD to decimal
uint8_t RTC_Bcd2ToByte(uint8_t number)
{
 800a3bc:	b480      	push	{r7}
 800a3be:	b085      	sub	sp, #20
 800a3c0:	af00      	add	r7, sp, #0
 800a3c2:	4603      	mov	r3, r0
 800a3c4:	71fb      	strb	r3, [r7, #7]
	uint32_t tens = 0U;
 800a3c6:	2300      	movs	r3, #0
 800a3c8:	60fb      	str	r3, [r7, #12]
	tens = (((uint32_t)number & 0xF0U) >> 4U) * 10U;
 800a3ca:	79fb      	ldrb	r3, [r7, #7]
 800a3cc:	091b      	lsrs	r3, r3, #4
 800a3ce:	b2db      	uxtb	r3, r3
 800a3d0:	461a      	mov	r2, r3
 800a3d2:	4613      	mov	r3, r2
 800a3d4:	009b      	lsls	r3, r3, #2
 800a3d6:	4413      	add	r3, r2
 800a3d8:	005b      	lsls	r3, r3, #1
 800a3da:	60fb      	str	r3, [r7, #12]
	return (uint8_t)(tens + ((uint32_t)number & 0x0FU));
 800a3dc:	68fb      	ldr	r3, [r7, #12]
 800a3de:	b2da      	uxtb	r2, r3
 800a3e0:	79fb      	ldrb	r3, [r7, #7]
 800a3e2:	f003 030f 	and.w	r3, r3, #15
 800a3e6:	b2db      	uxtb	r3, r3
 800a3e8:	4413      	add	r3, r2
 800a3ea:	b2db      	uxtb	r3, r3
}
 800a3ec:	4618      	mov	r0, r3
 800a3ee:	3714      	adds	r7, #20
 800a3f0:	46bd      	mov	sp, r7
 800a3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3f6:	4770      	bx	lr

0800a3f8 <TIM1_Config>:
#include <simple_delay.h>
#include <stm32f407xx.h>
#include <stm32f4xx.h>

void TIM1_Config(void)
{
 800a3f8:	b480      	push	{r7}
 800a3fa:	af00      	add	r7, sp, #0
	RCC->APB2ENR.bit.tim1en = ENABLE;  	//TIM1 EN
 800a3fc:	4a11      	ldr	r2, [pc, #68]	@ (800a444 <TIM1_Config+0x4c>)
 800a3fe:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800a400:	f043 0301 	orr.w	r3, r3, #1
 800a404:	6453      	str	r3, [r2, #68]	@ 0x44
	TIM1->PSC = 167; 					// ~1 uS delay
 800a406:	4b10      	ldr	r3, [pc, #64]	@ (800a448 <TIM1_Config+0x50>)
 800a408:	22a7      	movs	r2, #167	@ 0xa7
 800a40a:	629a      	str	r2, [r3, #40]	@ 0x28
	TIM1->ARR |= 0xFFFF; 				//all bits set to 1
 800a40c:	4b0e      	ldr	r3, [pc, #56]	@ (800a448 <TIM1_Config+0x50>)
 800a40e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a410:	4a0d      	ldr	r2, [pc, #52]	@ (800a448 <TIM1_Config+0x50>)
 800a412:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 800a416:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 800a41a:	62d3      	str	r3, [r2, #44]	@ 0x2c
	TIM1->CR1.bit.cen = ENABLE; 		//timer counter EN
 800a41c:	4a0a      	ldr	r2, [pc, #40]	@ (800a448 <TIM1_Config+0x50>)
 800a41e:	8813      	ldrh	r3, [r2, #0]
 800a420:	f043 0301 	orr.w	r3, r3, #1
 800a424:	8013      	strh	r3, [r2, #0]

	while(SET != TIM1->SR.bit.uif)
 800a426:	bf00      	nop
 800a428:	4b07      	ldr	r3, [pc, #28]	@ (800a448 <TIM1_Config+0x50>)
 800a42a:	691b      	ldr	r3, [r3, #16]
 800a42c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800a430:	b2db      	uxtb	r3, r3
 800a432:	2b01      	cmp	r3, #1
 800a434:	d1f8      	bne.n	800a428 <TIM1_Config+0x30>
	{
		//Update interrupt pending. This bit is set by hardware when the registers are updated
	}
}
 800a436:	bf00      	nop
 800a438:	bf00      	nop
 800a43a:	46bd      	mov	sp, r7
 800a43c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a440:	4770      	bx	lr
 800a442:	bf00      	nop
 800a444:	40023800 	.word	0x40023800
 800a448:	40010000 	.word	0x40010000

0800a44c <delay_us>:

void delay_us(int micro)
{
 800a44c:	b480      	push	{r7}
 800a44e:	b083      	sub	sp, #12
 800a450:	af00      	add	r7, sp, #0
 800a452:	6078      	str	r0, [r7, #4]
	TIM1->CNT = 0x0000;  				//reset counter register
 800a454:	4b07      	ldr	r3, [pc, #28]	@ (800a474 <delay_us+0x28>)
 800a456:	2200      	movs	r2, #0
 800a458:	625a      	str	r2, [r3, #36]	@ 0x24
	while(TIM1->CNT < micro);
 800a45a:	bf00      	nop
 800a45c:	4b05      	ldr	r3, [pc, #20]	@ (800a474 <delay_us+0x28>)
 800a45e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800a460:	687b      	ldr	r3, [r7, #4]
 800a462:	429a      	cmp	r2, r3
 800a464:	d3fa      	bcc.n	800a45c <delay_us+0x10>
}
 800a466:	bf00      	nop
 800a468:	bf00      	nop
 800a46a:	370c      	adds	r7, #12
 800a46c:	46bd      	mov	sp, r7
 800a46e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a472:	4770      	bx	lr
 800a474:	40010000 	.word	0x40010000

0800a478 <delay_ms>:

void delay_ms(int ms)
{
 800a478:	b580      	push	{r7, lr}
 800a47a:	b084      	sub	sp, #16
 800a47c:	af00      	add	r7, sp, #0
 800a47e:	6078      	str	r0, [r7, #4]
	int i;
	for (i = 0; i < ms; i++)
 800a480:	2300      	movs	r3, #0
 800a482:	60fb      	str	r3, [r7, #12]
 800a484:	e006      	b.n	800a494 <delay_ms+0x1c>
	{
		delay_us(1000); 			//1 ms delay
 800a486:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800a48a:	f7ff ffdf 	bl	800a44c <delay_us>
	for (i = 0; i < ms; i++)
 800a48e:	68fb      	ldr	r3, [r7, #12]
 800a490:	3301      	adds	r3, #1
 800a492:	60fb      	str	r3, [r7, #12]
 800a494:	68fa      	ldr	r2, [r7, #12]
 800a496:	687b      	ldr	r3, [r7, #4]
 800a498:	429a      	cmp	r2, r3
 800a49a:	dbf4      	blt.n	800a486 <delay_ms+0xe>
	}
}
 800a49c:	bf00      	nop
 800a49e:	bf00      	nop
 800a4a0:	3710      	adds	r7, #16
 800a4a2:	46bd      	mov	sp, r7
 800a4a4:	bd80      	pop	{r7, pc}
	...

0800a4a8 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 800a4a8:	b580      	push	{r7, lr}
 800a4aa:	af00      	add	r7, sp, #0
  /*## FatFS: Link the USBH driver ###########################*/
  retUSBH = FATFS_LinkDriver(&USBH_Driver, USBHPath);
 800a4ac:	4904      	ldr	r1, [pc, #16]	@ (800a4c0 <MX_FATFS_Init+0x18>)
 800a4ae:	4805      	ldr	r0, [pc, #20]	@ (800a4c4 <MX_FATFS_Init+0x1c>)
 800a4b0:	f008 fc12 	bl	8012cd8 <FATFS_LinkDriver>
 800a4b4:	4603      	mov	r3, r0
 800a4b6:	461a      	mov	r2, r3
 800a4b8:	4b03      	ldr	r3, [pc, #12]	@ (800a4c8 <MX_FATFS_Init+0x20>)
 800a4ba:	701a      	strb	r2, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
 800a4bc:	bf00      	nop
 800a4be:	bd80      	pop	{r7, pc}
 800a4c0:	200028f8 	.word	0x200028f8
 800a4c4:	080319e4 	.word	0x080319e4
 800a4c8:	200028f4 	.word	0x200028f4

0800a4cc <get_fattime>:
  * @brief  Gets Time from RTC
  * @param  None
  * @retval Time in DWORD
  */
DWORD get_fattime(void)
{
 800a4cc:	b480      	push	{r7}
 800a4ce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN get_fattime */
  return 0;
 800a4d0:	2300      	movs	r3, #0
  /* USER CODE END get_fattime */
}
 800a4d2:	4618      	mov	r0, r3
 800a4d4:	46bd      	mov	sp, r7
 800a4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4da:	4770      	bx	lr

0800a4dc <USBH_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_initialize(BYTE lun)
{
 800a4dc:	b480      	push	{r7}
 800a4de:	b083      	sub	sp, #12
 800a4e0:	af00      	add	r7, sp, #0
 800a4e2:	4603      	mov	r3, r0
 800a4e4:	71fb      	strb	r3, [r7, #7]
  /* CAUTION : USB Host library has to be initialized in the application */

  return RES_OK;
 800a4e6:	2300      	movs	r3, #0
}
 800a4e8:	4618      	mov	r0, r3
 800a4ea:	370c      	adds	r7, #12
 800a4ec:	46bd      	mov	sp, r7
 800a4ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4f2:	4770      	bx	lr

0800a4f4 <USBH_status>:
  * @brief  Gets Disk Status
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_status(BYTE lun)
{
 800a4f4:	b580      	push	{r7, lr}
 800a4f6:	b084      	sub	sp, #16
 800a4f8:	af00      	add	r7, sp, #0
 800a4fa:	4603      	mov	r3, r0
 800a4fc:	71fb      	strb	r3, [r7, #7]
  DRESULT res = RES_ERROR;
 800a4fe:	2301      	movs	r3, #1
 800a500:	73fb      	strb	r3, [r7, #15]

  if(USBH_MSC_UnitIsReady(&hUSB_Host, lun))
 800a502:	79fb      	ldrb	r3, [r7, #7]
 800a504:	4619      	mov	r1, r3
 800a506:	4808      	ldr	r0, [pc, #32]	@ (800a528 <USBH_status+0x34>)
 800a508:	f000 fe36 	bl	800b178 <USBH_MSC_UnitIsReady>
 800a50c:	4603      	mov	r3, r0
 800a50e:	2b00      	cmp	r3, #0
 800a510:	d002      	beq.n	800a518 <USBH_status+0x24>
  {
    res = RES_OK;
 800a512:	2300      	movs	r3, #0
 800a514:	73fb      	strb	r3, [r7, #15]
 800a516:	e001      	b.n	800a51c <USBH_status+0x28>
  }
  else
  {
    res = RES_ERROR;
 800a518:	2301      	movs	r3, #1
 800a51a:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 800a51c:	7bfb      	ldrb	r3, [r7, #15]
}
 800a51e:	4618      	mov	r0, r3
 800a520:	3710      	adds	r7, #16
 800a522:	46bd      	mov	sp, r7
 800a524:	bd80      	pop	{r7, pc}
 800a526:	bf00      	nop
 800a528:	20002d90 	.word	0x20002d90

0800a52c <USBH_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT USBH_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 800a52c:	b580      	push	{r7, lr}
 800a52e:	b094      	sub	sp, #80	@ 0x50
 800a530:	af02      	add	r7, sp, #8
 800a532:	60b9      	str	r1, [r7, #8]
 800a534:	607a      	str	r2, [r7, #4]
 800a536:	603b      	str	r3, [r7, #0]
 800a538:	4603      	mov	r3, r0
 800a53a:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 800a53c:	2301      	movs	r3, #1
 800a53e:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Read(&hUSB_Host, lun, sector, buff, count) == USBH_OK)
 800a542:	7bf9      	ldrb	r1, [r7, #15]
 800a544:	683b      	ldr	r3, [r7, #0]
 800a546:	9300      	str	r3, [sp, #0]
 800a548:	68bb      	ldr	r3, [r7, #8]
 800a54a:	687a      	ldr	r2, [r7, #4]
 800a54c:	4813      	ldr	r0, [pc, #76]	@ (800a59c <USBH_read+0x70>)
 800a54e:	f000 fe5d 	bl	800b20c <USBH_MSC_Read>
 800a552:	4603      	mov	r3, r0
 800a554:	2b00      	cmp	r3, #0
 800a556:	d103      	bne.n	800a560 <USBH_read+0x34>
  {
    res = RES_OK;
 800a558:	2300      	movs	r3, #0
 800a55a:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 800a55e:	e017      	b.n	800a590 <USBH_read+0x64>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 800a560:	f107 0210 	add.w	r2, r7, #16
 800a564:	7bfb      	ldrb	r3, [r7, #15]
 800a566:	4619      	mov	r1, r3
 800a568:	480c      	ldr	r0, [pc, #48]	@ (800a59c <USBH_read+0x70>)
 800a56a:	f000 fe2b 	bl	800b1c4 <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 800a56e:	7f7b      	ldrb	r3, [r7, #29]
 800a570:	2b3a      	cmp	r3, #58	@ 0x3a
 800a572:	d005      	beq.n	800a580 <USBH_read+0x54>
 800a574:	2b3a      	cmp	r3, #58	@ 0x3a
 800a576:	dc07      	bgt.n	800a588 <USBH_read+0x5c>
 800a578:	2b04      	cmp	r3, #4
 800a57a:	d001      	beq.n	800a580 <USBH_read+0x54>
 800a57c:	2b28      	cmp	r3, #40	@ 0x28
 800a57e:	d103      	bne.n	800a588 <USBH_read+0x5c>
    {
    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog ("USB Disk is not ready!");
      res = RES_NOTRDY;
 800a580:	2303      	movs	r3, #3
 800a582:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a586:	e003      	b.n	800a590 <USBH_read+0x64>

    default:
      res = RES_ERROR;
 800a588:	2301      	movs	r3, #1
 800a58a:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a58e:	bf00      	nop
    }
  }

  return res;
 800a590:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 800a594:	4618      	mov	r0, r3
 800a596:	3748      	adds	r7, #72	@ 0x48
 800a598:	46bd      	mov	sp, r7
 800a59a:	bd80      	pop	{r7, pc}
 800a59c:	20002d90 	.word	0x20002d90

0800a5a0 <USBH_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT USBH_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 800a5a0:	b580      	push	{r7, lr}
 800a5a2:	b094      	sub	sp, #80	@ 0x50
 800a5a4:	af02      	add	r7, sp, #8
 800a5a6:	60b9      	str	r1, [r7, #8]
 800a5a8:	607a      	str	r2, [r7, #4]
 800a5aa:	603b      	str	r3, [r7, #0]
 800a5ac:	4603      	mov	r3, r0
 800a5ae:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 800a5b0:	2301      	movs	r3, #1
 800a5b2:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Write(&hUSB_Host, lun, sector, (BYTE *)buff, count) == USBH_OK)
 800a5b6:	7bf9      	ldrb	r1, [r7, #15]
 800a5b8:	683b      	ldr	r3, [r7, #0]
 800a5ba:	9300      	str	r3, [sp, #0]
 800a5bc:	68bb      	ldr	r3, [r7, #8]
 800a5be:	687a      	ldr	r2, [r7, #4]
 800a5c0:	4817      	ldr	r0, [pc, #92]	@ (800a620 <USBH_write+0x80>)
 800a5c2:	f000 fe8c 	bl	800b2de <USBH_MSC_Write>
 800a5c6:	4603      	mov	r3, r0
 800a5c8:	2b00      	cmp	r3, #0
 800a5ca:	d103      	bne.n	800a5d4 <USBH_write+0x34>
  {
    res = RES_OK;
 800a5cc:	2300      	movs	r3, #0
 800a5ce:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 800a5d2:	e01f      	b.n	800a614 <USBH_write+0x74>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 800a5d4:	f107 0210 	add.w	r2, r7, #16
 800a5d8:	7bfb      	ldrb	r3, [r7, #15]
 800a5da:	4619      	mov	r1, r3
 800a5dc:	4810      	ldr	r0, [pc, #64]	@ (800a620 <USBH_write+0x80>)
 800a5de:	f000 fdf1 	bl	800b1c4 <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 800a5e2:	7f7b      	ldrb	r3, [r7, #29]
 800a5e4:	2b3a      	cmp	r3, #58	@ 0x3a
 800a5e6:	d00d      	beq.n	800a604 <USBH_write+0x64>
 800a5e8:	2b3a      	cmp	r3, #58	@ 0x3a
 800a5ea:	dc0f      	bgt.n	800a60c <USBH_write+0x6c>
 800a5ec:	2b28      	cmp	r3, #40	@ 0x28
 800a5ee:	d009      	beq.n	800a604 <USBH_write+0x64>
 800a5f0:	2b28      	cmp	r3, #40	@ 0x28
 800a5f2:	dc0b      	bgt.n	800a60c <USBH_write+0x6c>
 800a5f4:	2b04      	cmp	r3, #4
 800a5f6:	d005      	beq.n	800a604 <USBH_write+0x64>
 800a5f8:	2b27      	cmp	r3, #39	@ 0x27
 800a5fa:	d107      	bne.n	800a60c <USBH_write+0x6c>
    {
    case SCSI_ASC_WRITE_PROTECTED:
      USBH_ErrLog("USB Disk is Write protected!");
      res = RES_WRPRT;
 800a5fc:	2302      	movs	r3, #2
 800a5fe:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a602:	e007      	b.n	800a614 <USBH_write+0x74>

    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog("USB Disk is not ready!");
      res = RES_NOTRDY;
 800a604:	2303      	movs	r3, #3
 800a606:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a60a:	e003      	b.n	800a614 <USBH_write+0x74>

    default:
      res = RES_ERROR;
 800a60c:	2301      	movs	r3, #1
 800a60e:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      break;
 800a612:	bf00      	nop
    }
  }

  return res;
 800a614:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 800a618:	4618      	mov	r0, r3
 800a61a:	3748      	adds	r7, #72	@ 0x48
 800a61c:	46bd      	mov	sp, r7
 800a61e:	bd80      	pop	{r7, pc}
 800a620:	20002d90 	.word	0x20002d90

0800a624 <USBH_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USBH_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 800a624:	b580      	push	{r7, lr}
 800a626:	b090      	sub	sp, #64	@ 0x40
 800a628:	af00      	add	r7, sp, #0
 800a62a:	4603      	mov	r3, r0
 800a62c:	603a      	str	r2, [r7, #0]
 800a62e:	71fb      	strb	r3, [r7, #7]
 800a630:	460b      	mov	r3, r1
 800a632:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_ERROR;
 800a634:	2301      	movs	r3, #1
 800a636:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  MSC_LUNTypeDef info;

  switch (cmd)
 800a63a:	79bb      	ldrb	r3, [r7, #6]
 800a63c:	2b03      	cmp	r3, #3
 800a63e:	d852      	bhi.n	800a6e6 <USBH_ioctl+0xc2>
 800a640:	a201      	add	r2, pc, #4	@ (adr r2, 800a648 <USBH_ioctl+0x24>)
 800a642:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a646:	bf00      	nop
 800a648:	0800a659 	.word	0x0800a659
 800a64c:	0800a661 	.word	0x0800a661
 800a650:	0800a68b 	.word	0x0800a68b
 800a654:	0800a6b7 	.word	0x0800a6b7
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC:
    res = RES_OK;
 800a658:	2300      	movs	r3, #0
 800a65a:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a65e:	e045      	b.n	800a6ec <USBH_ioctl+0xc8>

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a660:	f107 0208 	add.w	r2, r7, #8
 800a664:	79fb      	ldrb	r3, [r7, #7]
 800a666:	4619      	mov	r1, r3
 800a668:	4823      	ldr	r0, [pc, #140]	@ (800a6f8 <USBH_ioctl+0xd4>)
 800a66a:	f000 fdab 	bl	800b1c4 <USBH_MSC_GetLUNInfo>
 800a66e:	4603      	mov	r3, r0
 800a670:	2b00      	cmp	r3, #0
 800a672:	d106      	bne.n	800a682 <USBH_ioctl+0x5e>
    {
      *(DWORD*)buff = info.capacity.block_nbr;
 800a674:	68fa      	ldr	r2, [r7, #12]
 800a676:	683b      	ldr	r3, [r7, #0]
 800a678:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a67a:	2300      	movs	r3, #0
 800a67c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a680:	e034      	b.n	800a6ec <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a682:	2301      	movs	r3, #1
 800a684:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a688:	e030      	b.n	800a6ec <USBH_ioctl+0xc8>

  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a68a:	f107 0208 	add.w	r2, r7, #8
 800a68e:	79fb      	ldrb	r3, [r7, #7]
 800a690:	4619      	mov	r1, r3
 800a692:	4819      	ldr	r0, [pc, #100]	@ (800a6f8 <USBH_ioctl+0xd4>)
 800a694:	f000 fd96 	bl	800b1c4 <USBH_MSC_GetLUNInfo>
 800a698:	4603      	mov	r3, r0
 800a69a:	2b00      	cmp	r3, #0
 800a69c:	d107      	bne.n	800a6ae <USBH_ioctl+0x8a>
    {
      *(DWORD*)buff = info.capacity.block_size;
 800a69e:	8a3b      	ldrh	r3, [r7, #16]
 800a6a0:	461a      	mov	r2, r3
 800a6a2:	683b      	ldr	r3, [r7, #0]
 800a6a4:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a6a6:	2300      	movs	r3, #0
 800a6a8:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a6ac:	e01e      	b.n	800a6ec <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a6ae:	2301      	movs	r3, #1
 800a6b0:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a6b4:	e01a      	b.n	800a6ec <USBH_ioctl+0xc8>

    /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :

    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 800a6b6:	f107 0208 	add.w	r2, r7, #8
 800a6ba:	79fb      	ldrb	r3, [r7, #7]
 800a6bc:	4619      	mov	r1, r3
 800a6be:	480e      	ldr	r0, [pc, #56]	@ (800a6f8 <USBH_ioctl+0xd4>)
 800a6c0:	f000 fd80 	bl	800b1c4 <USBH_MSC_GetLUNInfo>
 800a6c4:	4603      	mov	r3, r0
 800a6c6:	2b00      	cmp	r3, #0
 800a6c8:	d109      	bne.n	800a6de <USBH_ioctl+0xba>
    {
      *(DWORD*)buff = info.capacity.block_size / USB_DEFAULT_BLOCK_SIZE;
 800a6ca:	8a3b      	ldrh	r3, [r7, #16]
 800a6cc:	0a5b      	lsrs	r3, r3, #9
 800a6ce:	b29b      	uxth	r3, r3
 800a6d0:	461a      	mov	r2, r3
 800a6d2:	683b      	ldr	r3, [r7, #0]
 800a6d4:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 800a6d6:	2300      	movs	r3, #0
 800a6d8:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 800a6dc:	e006      	b.n	800a6ec <USBH_ioctl+0xc8>
      res = RES_ERROR;
 800a6de:	2301      	movs	r3, #1
 800a6e0:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    break;
 800a6e4:	e002      	b.n	800a6ec <USBH_ioctl+0xc8>

  default:
    res = RES_PARERR;
 800a6e6:	2304      	movs	r3, #4
 800a6e8:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  }

  return res;
 800a6ec:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
}
 800a6f0:	4618      	mov	r0, r3
 800a6f2:	3740      	adds	r7, #64	@ 0x40
 800a6f4:	46bd      	mov	sp, r7
 800a6f6:	bd80      	pop	{r7, pc}
 800a6f8:	20002d90 	.word	0x20002d90

0800a6fc <MX_LIBJPEG_Init>:
/* USER CODE BEGIN 2 */
/* USER CODE END 2 */

/* LIBJPEG init function */
void MX_LIBJPEG_Init(void)
{
 800a6fc:	b480      	push	{r7}
 800a6fe:	af00      	add	r7, sp, #0
  */

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

}
 800a700:	bf00      	nop
 800a702:	46bd      	mov	sp, r7
 800a704:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a708:	4770      	bx	lr

0800a70a <USBH_MSC_InterfaceInit>:
  *         The function init the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceInit(USBH_HandleTypeDef *phost)
{
 800a70a:	b590      	push	{r4, r7, lr}
 800a70c:	b089      	sub	sp, #36	@ 0x24
 800a70e:	af04      	add	r7, sp, #16
 800a710:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef status;
  uint8_t interface;
  MSC_HandleTypeDef *MSC_Handle;

  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a718:	7919      	ldrb	r1, [r3, #4]
 800a71a:	2350      	movs	r3, #80	@ 0x50
 800a71c:	2206      	movs	r2, #6
 800a71e:	6878      	ldr	r0, [r7, #4]
 800a720:	f001 fc86 	bl	800c030 <USBH_FindInterface>
 800a724:	4603      	mov	r3, r0
 800a726:	73fb      	strb	r3, [r7, #15]

  if ((interface == 0xFFU) || (interface >= USBH_MAX_NUM_INTERFACES)) /* Not Valid Interface */
 800a728:	7bfb      	ldrb	r3, [r7, #15]
 800a72a:	2bff      	cmp	r3, #255	@ 0xff
 800a72c:	d002      	beq.n	800a734 <USBH_MSC_InterfaceInit+0x2a>
 800a72e:	7bfb      	ldrb	r3, [r7, #15]
 800a730:	2b01      	cmp	r3, #1
 800a732:	d901      	bls.n	800a738 <USBH_MSC_InterfaceInit+0x2e>
  {
    USBH_DbgLog("Cannot Find the interface for %s class.", phost->pActiveClass->Name);
    return USBH_FAIL;
 800a734:	2302      	movs	r3, #2
 800a736:	e106      	b.n	800a946 <USBH_MSC_InterfaceInit+0x23c>
  }

  status = USBH_SelectInterface(phost, interface);
 800a738:	7bfb      	ldrb	r3, [r7, #15]
 800a73a:	4619      	mov	r1, r3
 800a73c:	6878      	ldr	r0, [r7, #4]
 800a73e:	f001 fc5b 	bl	800bff8 <USBH_SelectInterface>
 800a742:	4603      	mov	r3, r0
 800a744:	73bb      	strb	r3, [r7, #14]

  if (status != USBH_OK)
 800a746:	7bbb      	ldrb	r3, [r7, #14]
 800a748:	2b00      	cmp	r3, #0
 800a74a:	d001      	beq.n	800a750 <USBH_MSC_InterfaceInit+0x46>
  {
    return USBH_FAIL;
 800a74c:	2302      	movs	r3, #2
 800a74e:	e0fa      	b.n	800a946 <USBH_MSC_InterfaceInit+0x23c>
  }

  phost->pActiveClass->pData = (MSC_HandleTypeDef *)USBH_malloc(sizeof(MSC_HandleTypeDef));
 800a750:	687b      	ldr	r3, [r7, #4]
 800a752:	f8d3 437c 	ldr.w	r4, [r3, #892]	@ 0x37c
 800a756:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800a75a:	f025 f843 	bl	802f7e4 <malloc>
 800a75e:	4603      	mov	r3, r0
 800a760:	61e3      	str	r3, [r4, #28]
  MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800a762:	687b      	ldr	r3, [r7, #4]
 800a764:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a768:	69db      	ldr	r3, [r3, #28]
 800a76a:	60bb      	str	r3, [r7, #8]

  if (MSC_Handle == NULL)
 800a76c:	68bb      	ldr	r3, [r7, #8]
 800a76e:	2b00      	cmp	r3, #0
 800a770:	d101      	bne.n	800a776 <USBH_MSC_InterfaceInit+0x6c>
  {
    USBH_DbgLog("Cannot allocate memory for MSC Handle");
    return USBH_FAIL;
 800a772:	2302      	movs	r3, #2
 800a774:	e0e7      	b.n	800a946 <USBH_MSC_InterfaceInit+0x23c>
  }

  /* Initialize msc handler */
  (void)USBH_memset(MSC_Handle, 0, sizeof(MSC_HandleTypeDef));
 800a776:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800a77a:	2100      	movs	r1, #0
 800a77c:	68b8      	ldr	r0, [r7, #8]
 800a77e:	f025 f90f 	bl	802f9a0 <memset>

  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress & 0x80U) != 0U)
 800a782:	7bfb      	ldrb	r3, [r7, #15]
 800a784:	687a      	ldr	r2, [r7, #4]
 800a786:	211a      	movs	r1, #26
 800a788:	fb01 f303 	mul.w	r3, r1, r3
 800a78c:	4413      	add	r3, r2
 800a78e:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a792:	781b      	ldrb	r3, [r3, #0]
 800a794:	b25b      	sxtb	r3, r3
 800a796:	2b00      	cmp	r3, #0
 800a798:	da16      	bge.n	800a7c8 <USBH_MSC_InterfaceInit+0xbe>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 800a79a:	7bfb      	ldrb	r3, [r7, #15]
 800a79c:	687a      	ldr	r2, [r7, #4]
 800a79e:	211a      	movs	r1, #26
 800a7a0:	fb01 f303 	mul.w	r3, r1, r3
 800a7a4:	4413      	add	r3, r2
 800a7a6:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a7aa:	781a      	ldrb	r2, [r3, #0]
 800a7ac:	68bb      	ldr	r3, [r7, #8]
 800a7ae:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 800a7b0:	7bfb      	ldrb	r3, [r7, #15]
 800a7b2:	687a      	ldr	r2, [r7, #4]
 800a7b4:	211a      	movs	r1, #26
 800a7b6:	fb01 f303 	mul.w	r3, r1, r3
 800a7ba:	4413      	add	r3, r2
 800a7bc:	f503 7354 	add.w	r3, r3, #848	@ 0x350
 800a7c0:	881a      	ldrh	r2, [r3, #0]
 800a7c2:	68bb      	ldr	r3, [r7, #8]
 800a7c4:	815a      	strh	r2, [r3, #10]
 800a7c6:	e015      	b.n	800a7f4 <USBH_MSC_InterfaceInit+0xea>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 800a7c8:	7bfb      	ldrb	r3, [r7, #15]
 800a7ca:	687a      	ldr	r2, [r7, #4]
 800a7cc:	211a      	movs	r1, #26
 800a7ce:	fb01 f303 	mul.w	r3, r1, r3
 800a7d2:	4413      	add	r3, r2
 800a7d4:	f203 334e 	addw	r3, r3, #846	@ 0x34e
 800a7d8:	781a      	ldrb	r2, [r3, #0]
 800a7da:	68bb      	ldr	r3, [r7, #8]
 800a7dc:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 800a7de:	7bfb      	ldrb	r3, [r7, #15]
 800a7e0:	687a      	ldr	r2, [r7, #4]
 800a7e2:	211a      	movs	r1, #26
 800a7e4:	fb01 f303 	mul.w	r3, r1, r3
 800a7e8:	4413      	add	r3, r2
 800a7ea:	f503 7354 	add.w	r3, r3, #848	@ 0x350
 800a7ee:	881a      	ldrh	r2, [r3, #0]
 800a7f0:	68bb      	ldr	r3, [r7, #8]
 800a7f2:	811a      	strh	r2, [r3, #8]
  }

  if ((phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress & 0x80U) != 0U)
 800a7f4:	7bfb      	ldrb	r3, [r7, #15]
 800a7f6:	687a      	ldr	r2, [r7, #4]
 800a7f8:	211a      	movs	r1, #26
 800a7fa:	fb01 f303 	mul.w	r3, r1, r3
 800a7fe:	4413      	add	r3, r2
 800a800:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800a804:	781b      	ldrb	r3, [r3, #0]
 800a806:	b25b      	sxtb	r3, r3
 800a808:	2b00      	cmp	r3, #0
 800a80a:	da16      	bge.n	800a83a <USBH_MSC_InterfaceInit+0x130>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 800a80c:	7bfb      	ldrb	r3, [r7, #15]
 800a80e:	687a      	ldr	r2, [r7, #4]
 800a810:	211a      	movs	r1, #26
 800a812:	fb01 f303 	mul.w	r3, r1, r3
 800a816:	4413      	add	r3, r2
 800a818:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800a81c:	781a      	ldrb	r2, [r3, #0]
 800a81e:	68bb      	ldr	r3, [r7, #8]
 800a820:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 800a822:	7bfb      	ldrb	r3, [r7, #15]
 800a824:	687a      	ldr	r2, [r7, #4]
 800a826:	211a      	movs	r1, #26
 800a828:	fb01 f303 	mul.w	r3, r1, r3
 800a82c:	4413      	add	r3, r2
 800a82e:	f503 7356 	add.w	r3, r3, #856	@ 0x358
 800a832:	881a      	ldrh	r2, [r3, #0]
 800a834:	68bb      	ldr	r3, [r7, #8]
 800a836:	815a      	strh	r2, [r3, #10]
 800a838:	e015      	b.n	800a866 <USBH_MSC_InterfaceInit+0x15c>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 800a83a:	7bfb      	ldrb	r3, [r7, #15]
 800a83c:	687a      	ldr	r2, [r7, #4]
 800a83e:	211a      	movs	r1, #26
 800a840:	fb01 f303 	mul.w	r3, r1, r3
 800a844:	4413      	add	r3, r2
 800a846:	f203 3356 	addw	r3, r3, #854	@ 0x356
 800a84a:	781a      	ldrb	r2, [r3, #0]
 800a84c:	68bb      	ldr	r3, [r7, #8]
 800a84e:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 800a850:	7bfb      	ldrb	r3, [r7, #15]
 800a852:	687a      	ldr	r2, [r7, #4]
 800a854:	211a      	movs	r1, #26
 800a856:	fb01 f303 	mul.w	r3, r1, r3
 800a85a:	4413      	add	r3, r2
 800a85c:	f503 7356 	add.w	r3, r3, #856	@ 0x358
 800a860:	881a      	ldrh	r2, [r3, #0]
 800a862:	68bb      	ldr	r3, [r7, #8]
 800a864:	811a      	strh	r2, [r3, #8]
  }

  MSC_Handle->state = MSC_INIT;
 800a866:	68bb      	ldr	r3, [r7, #8]
 800a868:	2200      	movs	r2, #0
 800a86a:	731a      	strb	r2, [r3, #12]
  MSC_Handle->error = MSC_OK;
 800a86c:	68bb      	ldr	r3, [r7, #8]
 800a86e:	2200      	movs	r2, #0
 800a870:	735a      	strb	r2, [r3, #13]
  MSC_Handle->req_state = MSC_REQ_IDLE;
 800a872:	68bb      	ldr	r3, [r7, #8]
 800a874:	2200      	movs	r2, #0
 800a876:	739a      	strb	r2, [r3, #14]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 800a878:	68bb      	ldr	r3, [r7, #8]
 800a87a:	799b      	ldrb	r3, [r3, #6]
 800a87c:	4619      	mov	r1, r3
 800a87e:	6878      	ldr	r0, [r7, #4]
 800a880:	f002 ff63 	bl	800d74a <USBH_AllocPipe>
 800a884:	4603      	mov	r3, r0
 800a886:	461a      	mov	r2, r3
 800a888:	68bb      	ldr	r3, [r7, #8]
 800a88a:	715a      	strb	r2, [r3, #5]
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 800a88c:	68bb      	ldr	r3, [r7, #8]
 800a88e:	79db      	ldrb	r3, [r3, #7]
 800a890:	4619      	mov	r1, r3
 800a892:	6878      	ldr	r0, [r7, #4]
 800a894:	f002 ff59 	bl	800d74a <USBH_AllocPipe>
 800a898:	4603      	mov	r3, r0
 800a89a:	461a      	mov	r2, r3
 800a89c:	68bb      	ldr	r3, [r7, #8]
 800a89e:	711a      	strb	r2, [r3, #4]

  (void)USBH_MSC_BOT_Init(phost);
 800a8a0:	6878      	ldr	r0, [r7, #4]
 800a8a2:	f000 fdc1 	bl	800b428 <USBH_MSC_BOT_Init>

  /* Open the new channels */
  if ((MSC_Handle->OutEp != 0U) && (MSC_Handle->OutEpSize != 0U))
 800a8a6:	68bb      	ldr	r3, [r7, #8]
 800a8a8:	799b      	ldrb	r3, [r3, #6]
 800a8aa:	2b00      	cmp	r3, #0
 800a8ac:	d01e      	beq.n	800a8ec <USBH_MSC_InterfaceInit+0x1e2>
 800a8ae:	68bb      	ldr	r3, [r7, #8]
 800a8b0:	891b      	ldrh	r3, [r3, #8]
 800a8b2:	2b00      	cmp	r3, #0
 800a8b4:	d01a      	beq.n	800a8ec <USBH_MSC_InterfaceInit+0x1e2>
  {
    (void)USBH_OpenPipe(phost, MSC_Handle->OutPipe, MSC_Handle->OutEp,
 800a8b6:	68bb      	ldr	r3, [r7, #8]
 800a8b8:	7959      	ldrb	r1, [r3, #5]
 800a8ba:	68bb      	ldr	r3, [r7, #8]
 800a8bc:	7998      	ldrb	r0, [r3, #6]
 800a8be:	687b      	ldr	r3, [r7, #4]
 800a8c0:	f893 431c 	ldrb.w	r4, [r3, #796]	@ 0x31c
 800a8c4:	687b      	ldr	r3, [r7, #4]
 800a8c6:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800a8ca:	68ba      	ldr	r2, [r7, #8]
 800a8cc:	8912      	ldrh	r2, [r2, #8]
 800a8ce:	9202      	str	r2, [sp, #8]
 800a8d0:	2202      	movs	r2, #2
 800a8d2:	9201      	str	r2, [sp, #4]
 800a8d4:	9300      	str	r3, [sp, #0]
 800a8d6:	4623      	mov	r3, r4
 800a8d8:	4602      	mov	r2, r0
 800a8da:	6878      	ldr	r0, [r7, #4]
 800a8dc:	f002 ff06 	bl	800d6ec <USBH_OpenPipe>
 800a8e0:	bf00      	nop
  else
  {
    return USBH_NOT_SUPPORTED;
  }

  if ((MSC_Handle->InEp != 0U) && (MSC_Handle->InEpSize != 0U))
 800a8e2:	68bb      	ldr	r3, [r7, #8]
 800a8e4:	79db      	ldrb	r3, [r3, #7]
 800a8e6:	2b00      	cmp	r3, #0
 800a8e8:	d02c      	beq.n	800a944 <USBH_MSC_InterfaceInit+0x23a>
 800a8ea:	e001      	b.n	800a8f0 <USBH_MSC_InterfaceInit+0x1e6>
    return USBH_NOT_SUPPORTED;
 800a8ec:	2303      	movs	r3, #3
 800a8ee:	e02a      	b.n	800a946 <USBH_MSC_InterfaceInit+0x23c>
  if ((MSC_Handle->InEp != 0U) && (MSC_Handle->InEpSize != 0U))
 800a8f0:	68bb      	ldr	r3, [r7, #8]
 800a8f2:	895b      	ldrh	r3, [r3, #10]
 800a8f4:	2b00      	cmp	r3, #0
 800a8f6:	d025      	beq.n	800a944 <USBH_MSC_InterfaceInit+0x23a>
  {
    (void)USBH_OpenPipe(phost, MSC_Handle->InPipe, MSC_Handle->InEp,
 800a8f8:	68bb      	ldr	r3, [r7, #8]
 800a8fa:	7919      	ldrb	r1, [r3, #4]
 800a8fc:	68bb      	ldr	r3, [r7, #8]
 800a8fe:	79d8      	ldrb	r0, [r3, #7]
 800a900:	687b      	ldr	r3, [r7, #4]
 800a902:	f893 431c 	ldrb.w	r4, [r3, #796]	@ 0x31c
 800a906:	687b      	ldr	r3, [r7, #4]
 800a908:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800a90c:	68ba      	ldr	r2, [r7, #8]
 800a90e:	8952      	ldrh	r2, [r2, #10]
 800a910:	9202      	str	r2, [sp, #8]
 800a912:	2202      	movs	r2, #2
 800a914:	9201      	str	r2, [sp, #4]
 800a916:	9300      	str	r3, [sp, #0]
 800a918:	4623      	mov	r3, r4
 800a91a:	4602      	mov	r2, r0
 800a91c:	6878      	ldr	r0, [r7, #4]
 800a91e:	f002 fee5 	bl	800d6ec <USBH_OpenPipe>
 800a922:	bf00      	nop
  else
  {
    return USBH_NOT_SUPPORTED;
  }

  (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 800a924:	68bb      	ldr	r3, [r7, #8]
 800a926:	791b      	ldrb	r3, [r3, #4]
 800a928:	2200      	movs	r2, #0
 800a92a:	4619      	mov	r1, r3
 800a92c:	6878      	ldr	r0, [r7, #4]
 800a92e:	f024 fe9f 	bl	802f670 <USBH_LL_SetToggle>
  (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 0U);
 800a932:	68bb      	ldr	r3, [r7, #8]
 800a934:	795b      	ldrb	r3, [r3, #5]
 800a936:	2200      	movs	r2, #0
 800a938:	4619      	mov	r1, r3
 800a93a:	6878      	ldr	r0, [r7, #4]
 800a93c:	f024 fe98 	bl	802f670 <USBH_LL_SetToggle>

  return USBH_OK;
 800a940:	2300      	movs	r3, #0
 800a942:	e000      	b.n	800a946 <USBH_MSC_InterfaceInit+0x23c>
    return USBH_NOT_SUPPORTED;
 800a944:	2303      	movs	r3, #3
}
 800a946:	4618      	mov	r0, r3
 800a948:	3714      	adds	r7, #20
 800a94a:	46bd      	mov	sp, r7
 800a94c:	bd90      	pop	{r4, r7, pc}

0800a94e <USBH_MSC_InterfaceDeInit>:
  *         The function DeInit the Pipes used for the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceDeInit(USBH_HandleTypeDef *phost)
{
 800a94e:	b580      	push	{r7, lr}
 800a950:	b084      	sub	sp, #16
 800a952:	af00      	add	r7, sp, #0
 800a954:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800a956:	687b      	ldr	r3, [r7, #4]
 800a958:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a95c:	69db      	ldr	r3, [r3, #28]
 800a95e:	60fb      	str	r3, [r7, #12]

  if ((MSC_Handle->OutPipe) != 0U)
 800a960:	68fb      	ldr	r3, [r7, #12]
 800a962:	795b      	ldrb	r3, [r3, #5]
 800a964:	2b00      	cmp	r3, #0
 800a966:	d00e      	beq.n	800a986 <USBH_MSC_InterfaceDeInit+0x38>
  {
    (void)USBH_ClosePipe(phost, MSC_Handle->OutPipe);
 800a968:	68fb      	ldr	r3, [r7, #12]
 800a96a:	795b      	ldrb	r3, [r3, #5]
 800a96c:	4619      	mov	r1, r3
 800a96e:	6878      	ldr	r0, [r7, #4]
 800a970:	f002 fedb 	bl	800d72a <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->OutPipe);
 800a974:	68fb      	ldr	r3, [r7, #12]
 800a976:	795b      	ldrb	r3, [r3, #5]
 800a978:	4619      	mov	r1, r3
 800a97a:	6878      	ldr	r0, [r7, #4]
 800a97c:	f002 ff06 	bl	800d78c <USBH_FreePipe>
    MSC_Handle->OutPipe = 0U;     /* Reset the Channel as Free */
 800a980:	68fb      	ldr	r3, [r7, #12]
 800a982:	2200      	movs	r2, #0
 800a984:	715a      	strb	r2, [r3, #5]
  }

  if ((MSC_Handle->InPipe != 0U))
 800a986:	68fb      	ldr	r3, [r7, #12]
 800a988:	791b      	ldrb	r3, [r3, #4]
 800a98a:	2b00      	cmp	r3, #0
 800a98c:	d00e      	beq.n	800a9ac <USBH_MSC_InterfaceDeInit+0x5e>
  {
    (void)USBH_ClosePipe(phost, MSC_Handle->InPipe);
 800a98e:	68fb      	ldr	r3, [r7, #12]
 800a990:	791b      	ldrb	r3, [r3, #4]
 800a992:	4619      	mov	r1, r3
 800a994:	6878      	ldr	r0, [r7, #4]
 800a996:	f002 fec8 	bl	800d72a <USBH_ClosePipe>
    (void)USBH_FreePipe(phost, MSC_Handle->InPipe);
 800a99a:	68fb      	ldr	r3, [r7, #12]
 800a99c:	791b      	ldrb	r3, [r3, #4]
 800a99e:	4619      	mov	r1, r3
 800a9a0:	6878      	ldr	r0, [r7, #4]
 800a9a2:	f002 fef3 	bl	800d78c <USBH_FreePipe>
    MSC_Handle->InPipe = 0U;     /* Reset the Channel as Free */
 800a9a6:	68fb      	ldr	r3, [r7, #12]
 800a9a8:	2200      	movs	r2, #0
 800a9aa:	711a      	strb	r2, [r3, #4]
  }

  if ((phost->pActiveClass->pData) != NULL)
 800a9ac:	687b      	ldr	r3, [r7, #4]
 800a9ae:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a9b2:	69db      	ldr	r3, [r3, #28]
 800a9b4:	2b00      	cmp	r3, #0
 800a9b6:	d00b      	beq.n	800a9d0 <USBH_MSC_InterfaceDeInit+0x82>
  {
    USBH_free(phost->pActiveClass->pData);
 800a9b8:	687b      	ldr	r3, [r7, #4]
 800a9ba:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a9be:	69db      	ldr	r3, [r3, #28]
 800a9c0:	4618      	mov	r0, r3
 800a9c2:	f024 ff17 	bl	802f7f4 <free>
    phost->pActiveClass->pData = 0U;
 800a9c6:	687b      	ldr	r3, [r7, #4]
 800a9c8:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a9cc:	2200      	movs	r2, #0
 800a9ce:	61da      	str	r2, [r3, #28]
  }

  return USBH_OK;
 800a9d0:	2300      	movs	r3, #0
}
 800a9d2:	4618      	mov	r0, r3
 800a9d4:	3710      	adds	r7, #16
 800a9d6:	46bd      	mov	sp, r7
 800a9d8:	bd80      	pop	{r7, pc}

0800a9da <USBH_MSC_ClassRequest>:
  *         for MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_ClassRequest(USBH_HandleTypeDef *phost)
{
 800a9da:	b580      	push	{r7, lr}
 800a9dc:	b084      	sub	sp, #16
 800a9de:	af00      	add	r7, sp, #0
 800a9e0:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800a9e2:	687b      	ldr	r3, [r7, #4]
 800a9e4:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800a9e8:	69db      	ldr	r3, [r3, #28]
 800a9ea:	60bb      	str	r3, [r7, #8]
  USBH_StatusTypeDef status = USBH_BUSY;
 800a9ec:	2301      	movs	r3, #1
 800a9ee:	73fb      	strb	r3, [r7, #15]
  uint8_t i;

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->req_state)
 800a9f0:	68bb      	ldr	r3, [r7, #8]
 800a9f2:	7b9b      	ldrb	r3, [r3, #14]
 800a9f4:	2b03      	cmp	r3, #3
 800a9f6:	d041      	beq.n	800aa7c <USBH_MSC_ClassRequest+0xa2>
 800a9f8:	2b03      	cmp	r3, #3
 800a9fa:	dc4b      	bgt.n	800aa94 <USBH_MSC_ClassRequest+0xba>
 800a9fc:	2b00      	cmp	r3, #0
 800a9fe:	d001      	beq.n	800aa04 <USBH_MSC_ClassRequest+0x2a>
 800aa00:	2b02      	cmp	r3, #2
 800aa02:	d147      	bne.n	800aa94 <USBH_MSC_ClassRequest+0xba>
  {
    case MSC_REQ_IDLE:
    case MSC_REQ_GET_MAX_LUN:
      /* Issue GetMaxLUN request */
      status = USBH_MSC_BOT_REQ_GetMaxLUN(phost, &MSC_Handle->max_lun);
 800aa04:	68bb      	ldr	r3, [r7, #8]
 800aa06:	4619      	mov	r1, r3
 800aa08:	6878      	ldr	r0, [r7, #4]
 800aa0a:	f000 fcee 	bl	800b3ea <USBH_MSC_BOT_REQ_GetMaxLUN>
 800aa0e:	4603      	mov	r3, r0
 800aa10:	73fb      	strb	r3, [r7, #15]

      /* When devices do not support the GetMaxLun request, this should
         be considered as only one logical unit is supported */
      if (status == USBH_NOT_SUPPORTED)
 800aa12:	7bfb      	ldrb	r3, [r7, #15]
 800aa14:	2b03      	cmp	r3, #3
 800aa16:	d104      	bne.n	800aa22 <USBH_MSC_ClassRequest+0x48>
      {
        MSC_Handle->max_lun = 0U;
 800aa18:	68bb      	ldr	r3, [r7, #8]
 800aa1a:	2200      	movs	r2, #0
 800aa1c:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 800aa1e:	2300      	movs	r3, #0
 800aa20:	73fb      	strb	r3, [r7, #15]
      }

      if (status == USBH_OK)
 800aa22:	7bfb      	ldrb	r3, [r7, #15]
 800aa24:	2b00      	cmp	r3, #0
 800aa26:	d137      	bne.n	800aa98 <USBH_MSC_ClassRequest+0xbe>
      {
        MSC_Handle->max_lun = (MSC_Handle->max_lun > MAX_SUPPORTED_LUN) ? MAX_SUPPORTED_LUN : (MSC_Handle->max_lun + 1U);
 800aa28:	68bb      	ldr	r3, [r7, #8]
 800aa2a:	781b      	ldrb	r3, [r3, #0]
 800aa2c:	2b02      	cmp	r3, #2
 800aa2e:	d804      	bhi.n	800aa3a <USBH_MSC_ClassRequest+0x60>
 800aa30:	68bb      	ldr	r3, [r7, #8]
 800aa32:	781b      	ldrb	r3, [r3, #0]
 800aa34:	3301      	adds	r3, #1
 800aa36:	b2da      	uxtb	r2, r3
 800aa38:	e000      	b.n	800aa3c <USBH_MSC_ClassRequest+0x62>
 800aa3a:	2202      	movs	r2, #2
 800aa3c:	68bb      	ldr	r3, [r7, #8]
 800aa3e:	701a      	strb	r2, [r3, #0]
        USBH_UsrLog("Number of supported LUN: %d", MSC_Handle->max_lun);

        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800aa40:	2300      	movs	r3, #0
 800aa42:	73bb      	strb	r3, [r7, #14]
 800aa44:	e014      	b.n	800aa70 <USBH_MSC_ClassRequest+0x96>
        {
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 800aa46:	7bbb      	ldrb	r3, [r7, #14]
 800aa48:	68ba      	ldr	r2, [r7, #8]
 800aa4a:	2134      	movs	r1, #52	@ 0x34
 800aa4c:	fb01 f303 	mul.w	r3, r1, r3
 800aa50:	4413      	add	r3, r2
 800aa52:	3392      	adds	r3, #146	@ 0x92
 800aa54:	2202      	movs	r2, #2
 800aa56:	701a      	strb	r2, [r3, #0]
          MSC_Handle->unit[i].state_changed = 0U;
 800aa58:	7bbb      	ldrb	r3, [r7, #14]
 800aa5a:	68ba      	ldr	r2, [r7, #8]
 800aa5c:	2134      	movs	r1, #52	@ 0x34
 800aa5e:	fb01 f303 	mul.w	r3, r1, r3
 800aa62:	4413      	add	r3, r2
 800aa64:	33c1      	adds	r3, #193	@ 0xc1
 800aa66:	2200      	movs	r2, #0
 800aa68:	701a      	strb	r2, [r3, #0]
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800aa6a:	7bbb      	ldrb	r3, [r7, #14]
 800aa6c:	3301      	adds	r3, #1
 800aa6e:	73bb      	strb	r3, [r7, #14]
 800aa70:	68bb      	ldr	r3, [r7, #8]
 800aa72:	781b      	ldrb	r3, [r3, #0]
 800aa74:	7bba      	ldrb	r2, [r7, #14]
 800aa76:	429a      	cmp	r2, r3
 800aa78:	d3e5      	bcc.n	800aa46 <USBH_MSC_ClassRequest+0x6c>
        }
      }
      break;
 800aa7a:	e00d      	b.n	800aa98 <USBH_MSC_ClassRequest+0xbe>

    case MSC_REQ_ERROR:
      /* a Clear Feature should be issued here */
      if (USBH_ClrFeature(phost, 0x00U) == USBH_OK)
 800aa7c:	2100      	movs	r1, #0
 800aa7e:	6878      	ldr	r0, [r7, #4]
 800aa80:	f002 f8ae 	bl	800cbe0 <USBH_ClrFeature>
 800aa84:	4603      	mov	r3, r0
 800aa86:	2b00      	cmp	r3, #0
 800aa88:	d108      	bne.n	800aa9c <USBH_MSC_ClassRequest+0xc2>
      {
        MSC_Handle->req_state = MSC_Handle->prev_req_state;
 800aa8a:	68bb      	ldr	r3, [r7, #8]
 800aa8c:	7bda      	ldrb	r2, [r3, #15]
 800aa8e:	68bb      	ldr	r3, [r7, #8]
 800aa90:	739a      	strb	r2, [r3, #14]
      }
      break;
 800aa92:	e003      	b.n	800aa9c <USBH_MSC_ClassRequest+0xc2>

    default:
      break;
 800aa94:	bf00      	nop
 800aa96:	e002      	b.n	800aa9e <USBH_MSC_ClassRequest+0xc4>
      break;
 800aa98:	bf00      	nop
 800aa9a:	e000      	b.n	800aa9e <USBH_MSC_ClassRequest+0xc4>
      break;
 800aa9c:	bf00      	nop
  }

  return status;
 800aa9e:	7bfb      	ldrb	r3, [r7, #15]
}
 800aaa0:	4618      	mov	r0, r3
 800aaa2:	3710      	adds	r7, #16
 800aaa4:	46bd      	mov	sp, r7
 800aaa6:	bd80      	pop	{r7, pc}

0800aaa8 <USBH_MSC_Process>:
  *         The function is for managing state machine for MSC data transfers
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_Process(USBH_HandleTypeDef *phost)
{
 800aaa8:	b580      	push	{r7, lr}
 800aaaa:	b086      	sub	sp, #24
 800aaac:	af00      	add	r7, sp, #0
 800aaae:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800aab0:	687b      	ldr	r3, [r7, #4]
 800aab2:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800aab6:	69db      	ldr	r3, [r3, #28]
 800aab8:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY;
 800aaba:	2301      	movs	r3, #1
 800aabc:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY;
 800aabe:	2301      	movs	r3, #1
 800aac0:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ready_status = USBH_BUSY;
 800aac2:	2301      	movs	r3, #1
 800aac4:	73bb      	strb	r3, [r7, #14]

  switch (MSC_Handle->state)
 800aac6:	693b      	ldr	r3, [r7, #16]
 800aac8:	7b1b      	ldrb	r3, [r3, #12]
 800aaca:	2b00      	cmp	r3, #0
 800aacc:	d003      	beq.n	800aad6 <USBH_MSC_Process+0x2e>
 800aace:	2b01      	cmp	r3, #1
 800aad0:	f000 826f 	beq.w	800afb2 <USBH_MSC_Process+0x50a>
    case MSC_IDLE:
      error = USBH_OK;
      break;

    default:
      break;
 800aad4:	e270      	b.n	800afb8 <USBH_MSC_Process+0x510>
      if (MSC_Handle->current_lun < MSC_Handle->max_lun)
 800aad6:	693b      	ldr	r3, [r7, #16]
 800aad8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aadc:	693a      	ldr	r2, [r7, #16]
 800aade:	7812      	ldrb	r2, [r2, #0]
 800aae0:	4293      	cmp	r3, r2
 800aae2:	f080 824e 	bcs.w	800af82 <USBH_MSC_Process+0x4da>
        MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 800aae6:	693b      	ldr	r3, [r7, #16]
 800aae8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aaec:	4619      	mov	r1, r3
 800aaee:	693a      	ldr	r2, [r7, #16]
 800aaf0:	2334      	movs	r3, #52	@ 0x34
 800aaf2:	fb01 f303 	mul.w	r3, r1, r3
 800aaf6:	4413      	add	r3, r2
 800aaf8:	3391      	adds	r3, #145	@ 0x91
 800aafa:	2201      	movs	r2, #1
 800aafc:	701a      	strb	r2, [r3, #0]
        switch (MSC_Handle->unit[MSC_Handle->current_lun].state)
 800aafe:	693b      	ldr	r3, [r7, #16]
 800ab00:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ab04:	4619      	mov	r1, r3
 800ab06:	693a      	ldr	r2, [r7, #16]
 800ab08:	2334      	movs	r3, #52	@ 0x34
 800ab0a:	fb01 f303 	mul.w	r3, r1, r3
 800ab0e:	4413      	add	r3, r2
 800ab10:	3390      	adds	r3, #144	@ 0x90
 800ab12:	781b      	ldrb	r3, [r3, #0]
 800ab14:	2b08      	cmp	r3, #8
 800ab16:	f200 8242 	bhi.w	800af9e <USBH_MSC_Process+0x4f6>
 800ab1a:	a201      	add	r2, pc, #4	@ (adr r2, 800ab20 <USBH_MSC_Process+0x78>)
 800ab1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ab20:	0800ab45 	.word	0x0800ab45
 800ab24:	0800af9f 	.word	0x0800af9f
 800ab28:	0800ac0d 	.word	0x0800ac0d
 800ab2c:	0800ad91 	.word	0x0800ad91
 800ab30:	0800ab6b 	.word	0x0800ab6b
 800ab34:	0800ae5d 	.word	0x0800ae5d
 800ab38:	0800af9f 	.word	0x0800af9f
 800ab3c:	0800af9f 	.word	0x0800af9f
 800ab40:	0800af71 	.word	0x0800af71
            MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_INQUIRY;
 800ab44:	693b      	ldr	r3, [r7, #16]
 800ab46:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ab4a:	4619      	mov	r1, r3
 800ab4c:	693a      	ldr	r2, [r7, #16]
 800ab4e:	2334      	movs	r3, #52	@ 0x34
 800ab50:	fb01 f303 	mul.w	r3, r1, r3
 800ab54:	4413      	add	r3, r2
 800ab56:	3390      	adds	r3, #144	@ 0x90
 800ab58:	2204      	movs	r2, #4
 800ab5a:	701a      	strb	r2, [r3, #0]
            MSC_Handle->timer = phost->Timer;
 800ab5c:	687b      	ldr	r3, [r7, #4]
 800ab5e:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800ab62:	693b      	ldr	r3, [r7, #16]
 800ab64:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
            break;
 800ab68:	e222      	b.n	800afb0 <USBH_MSC_Process+0x508>
            scsi_status = USBH_MSC_SCSI_Inquiry(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].inquiry);
 800ab6a:	693b      	ldr	r3, [r7, #16]
 800ab6c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ab70:	b2d9      	uxtb	r1, r3
 800ab72:	693b      	ldr	r3, [r7, #16]
 800ab74:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ab78:	461a      	mov	r2, r3
 800ab7a:	2334      	movs	r3, #52	@ 0x34
 800ab7c:	fb02 f303 	mul.w	r3, r2, r3
 800ab80:	3398      	adds	r3, #152	@ 0x98
 800ab82:	693a      	ldr	r2, [r7, #16]
 800ab84:	4413      	add	r3, r2
 800ab86:	3307      	adds	r3, #7
 800ab88:	461a      	mov	r2, r3
 800ab8a:	6878      	ldr	r0, [r7, #4]
 800ab8c:	f000 ff69 	bl	800ba62 <USBH_MSC_SCSI_Inquiry>
 800ab90:	4603      	mov	r3, r0
 800ab92:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800ab94:	7bfb      	ldrb	r3, [r7, #15]
 800ab96:	2b00      	cmp	r3, #0
 800ab98:	d10b      	bne.n	800abb2 <USBH_MSC_Process+0x10a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 800ab9a:	693b      	ldr	r3, [r7, #16]
 800ab9c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aba0:	4619      	mov	r1, r3
 800aba2:	693a      	ldr	r2, [r7, #16]
 800aba4:	2334      	movs	r3, #52	@ 0x34
 800aba6:	fb01 f303 	mul.w	r3, r1, r3
 800abaa:	4413      	add	r3, r2
 800abac:	3390      	adds	r3, #144	@ 0x90
 800abae:	2202      	movs	r2, #2
 800abb0:	701a      	strb	r2, [r3, #0]
            if (scsi_status == USBH_FAIL)
 800abb2:	7bfb      	ldrb	r3, [r7, #15]
 800abb4:	2b02      	cmp	r3, #2
 800abb6:	d10c      	bne.n	800abd2 <USBH_MSC_Process+0x12a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800abb8:	693b      	ldr	r3, [r7, #16]
 800abba:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800abbe:	4619      	mov	r1, r3
 800abc0:	693a      	ldr	r2, [r7, #16]
 800abc2:	2334      	movs	r3, #52	@ 0x34
 800abc4:	fb01 f303 	mul.w	r3, r1, r3
 800abc8:	4413      	add	r3, r2
 800abca:	3390      	adds	r3, #144	@ 0x90
 800abcc:	2205      	movs	r2, #5
 800abce:	701a      	strb	r2, [r3, #0]
            break;
 800abd0:	e1e7      	b.n	800afa2 <USBH_MSC_Process+0x4fa>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800abd2:	7bfb      	ldrb	r3, [r7, #15]
 800abd4:	2b04      	cmp	r3, #4
 800abd6:	f040 81e4 	bne.w	800afa2 <USBH_MSC_Process+0x4fa>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800abda:	693b      	ldr	r3, [r7, #16]
 800abdc:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800abe0:	4619      	mov	r1, r3
 800abe2:	693a      	ldr	r2, [r7, #16]
 800abe4:	2334      	movs	r3, #52	@ 0x34
 800abe6:	fb01 f303 	mul.w	r3, r1, r3
 800abea:	4413      	add	r3, r2
 800abec:	3390      	adds	r3, #144	@ 0x90
 800abee:	2201      	movs	r2, #1
 800abf0:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800abf2:	693b      	ldr	r3, [r7, #16]
 800abf4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800abf8:	4619      	mov	r1, r3
 800abfa:	693a      	ldr	r2, [r7, #16]
 800abfc:	2334      	movs	r3, #52	@ 0x34
 800abfe:	fb01 f303 	mul.w	r3, r1, r3
 800ac02:	4413      	add	r3, r2
 800ac04:	3391      	adds	r3, #145	@ 0x91
 800ac06:	2202      	movs	r2, #2
 800ac08:	701a      	strb	r2, [r3, #0]
            break;
 800ac0a:	e1ca      	b.n	800afa2 <USBH_MSC_Process+0x4fa>
            ready_status = USBH_MSC_SCSI_TestUnitReady(phost, (uint8_t)MSC_Handle->current_lun);
 800ac0c:	693b      	ldr	r3, [r7, #16]
 800ac0e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac12:	b2db      	uxtb	r3, r3
 800ac14:	4619      	mov	r1, r3
 800ac16:	6878      	ldr	r0, [r7, #4]
 800ac18:	f000 fe66 	bl	800b8e8 <USBH_MSC_SCSI_TestUnitReady>
 800ac1c:	4603      	mov	r3, r0
 800ac1e:	73bb      	strb	r3, [r7, #14]
            if (ready_status == USBH_OK)
 800ac20:	7bbb      	ldrb	r3, [r7, #14]
 800ac22:	2b00      	cmp	r3, #0
 800ac24:	d149      	bne.n	800acba <USBH_MSC_Process+0x212>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_OK)
 800ac26:	693b      	ldr	r3, [r7, #16]
 800ac28:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac2c:	4619      	mov	r1, r3
 800ac2e:	693a      	ldr	r2, [r7, #16]
 800ac30:	2334      	movs	r3, #52	@ 0x34
 800ac32:	fb01 f303 	mul.w	r3, r1, r3
 800ac36:	4413      	add	r3, r2
 800ac38:	3392      	adds	r3, #146	@ 0x92
 800ac3a:	781b      	ldrb	r3, [r3, #0]
 800ac3c:	2b00      	cmp	r3, #0
 800ac3e:	d00c      	beq.n	800ac5a <USBH_MSC_Process+0x1b2>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800ac40:	693b      	ldr	r3, [r7, #16]
 800ac42:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac46:	4619      	mov	r1, r3
 800ac48:	693a      	ldr	r2, [r7, #16]
 800ac4a:	2334      	movs	r3, #52	@ 0x34
 800ac4c:	fb01 f303 	mul.w	r3, r1, r3
 800ac50:	4413      	add	r3, r2
 800ac52:	33c1      	adds	r3, #193	@ 0xc1
 800ac54:	2201      	movs	r2, #1
 800ac56:	701a      	strb	r2, [r3, #0]
 800ac58:	e00b      	b.n	800ac72 <USBH_MSC_Process+0x1ca>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 800ac5a:	693b      	ldr	r3, [r7, #16]
 800ac5c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac60:	4619      	mov	r1, r3
 800ac62:	693a      	ldr	r2, [r7, #16]
 800ac64:	2334      	movs	r3, #52	@ 0x34
 800ac66:	fb01 f303 	mul.w	r3, r1, r3
 800ac6a:	4413      	add	r3, r2
 800ac6c:	33c1      	adds	r3, #193	@ 0xc1
 800ac6e:	2200      	movs	r2, #0
 800ac70:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_CAPACITY10;
 800ac72:	693b      	ldr	r3, [r7, #16]
 800ac74:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac78:	4619      	mov	r1, r3
 800ac7a:	693a      	ldr	r2, [r7, #16]
 800ac7c:	2334      	movs	r3, #52	@ 0x34
 800ac7e:	fb01 f303 	mul.w	r3, r1, r3
 800ac82:	4413      	add	r3, r2
 800ac84:	3390      	adds	r3, #144	@ 0x90
 800ac86:	2203      	movs	r2, #3
 800ac88:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 800ac8a:	693b      	ldr	r3, [r7, #16]
 800ac8c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ac90:	4619      	mov	r1, r3
 800ac92:	693a      	ldr	r2, [r7, #16]
 800ac94:	2334      	movs	r3, #52	@ 0x34
 800ac96:	fb01 f303 	mul.w	r3, r1, r3
 800ac9a:	4413      	add	r3, r2
 800ac9c:	3391      	adds	r3, #145	@ 0x91
 800ac9e:	2200      	movs	r2, #0
 800aca0:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_OK;
 800aca2:	693b      	ldr	r3, [r7, #16]
 800aca4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aca8:	4619      	mov	r1, r3
 800acaa:	693a      	ldr	r2, [r7, #16]
 800acac:	2334      	movs	r3, #52	@ 0x34
 800acae:	fb01 f303 	mul.w	r3, r1, r3
 800acb2:	4413      	add	r3, r2
 800acb4:	3392      	adds	r3, #146	@ 0x92
 800acb6:	2200      	movs	r2, #0
 800acb8:	701a      	strb	r2, [r3, #0]
            if (ready_status == USBH_FAIL)
 800acba:	7bbb      	ldrb	r3, [r7, #14]
 800acbc:	2b02      	cmp	r3, #2
 800acbe:	d14a      	bne.n	800ad56 <USBH_MSC_Process+0x2ae>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_FAIL)
 800acc0:	693b      	ldr	r3, [r7, #16]
 800acc2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800acc6:	4619      	mov	r1, r3
 800acc8:	693a      	ldr	r2, [r7, #16]
 800acca:	2334      	movs	r3, #52	@ 0x34
 800accc:	fb01 f303 	mul.w	r3, r1, r3
 800acd0:	4413      	add	r3, r2
 800acd2:	3392      	adds	r3, #146	@ 0x92
 800acd4:	781b      	ldrb	r3, [r3, #0]
 800acd6:	2b02      	cmp	r3, #2
 800acd8:	d00c      	beq.n	800acf4 <USBH_MSC_Process+0x24c>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 800acda:	693b      	ldr	r3, [r7, #16]
 800acdc:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ace0:	4619      	mov	r1, r3
 800ace2:	693a      	ldr	r2, [r7, #16]
 800ace4:	2334      	movs	r3, #52	@ 0x34
 800ace6:	fb01 f303 	mul.w	r3, r1, r3
 800acea:	4413      	add	r3, r2
 800acec:	33c1      	adds	r3, #193	@ 0xc1
 800acee:	2201      	movs	r2, #1
 800acf0:	701a      	strb	r2, [r3, #0]
 800acf2:	e00b      	b.n	800ad0c <USBH_MSC_Process+0x264>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 800acf4:	693b      	ldr	r3, [r7, #16]
 800acf6:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800acfa:	4619      	mov	r1, r3
 800acfc:	693a      	ldr	r2, [r7, #16]
 800acfe:	2334      	movs	r3, #52	@ 0x34
 800ad00:	fb01 f303 	mul.w	r3, r1, r3
 800ad04:	4413      	add	r3, r2
 800ad06:	33c1      	adds	r3, #193	@ 0xc1
 800ad08:	2200      	movs	r2, #0
 800ad0a:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800ad0c:	693b      	ldr	r3, [r7, #16]
 800ad0e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad12:	4619      	mov	r1, r3
 800ad14:	693a      	ldr	r2, [r7, #16]
 800ad16:	2334      	movs	r3, #52	@ 0x34
 800ad18:	fb01 f303 	mul.w	r3, r1, r3
 800ad1c:	4413      	add	r3, r2
 800ad1e:	3390      	adds	r3, #144	@ 0x90
 800ad20:	2205      	movs	r2, #5
 800ad22:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 800ad24:	693b      	ldr	r3, [r7, #16]
 800ad26:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad2a:	4619      	mov	r1, r3
 800ad2c:	693a      	ldr	r2, [r7, #16]
 800ad2e:	2334      	movs	r3, #52	@ 0x34
 800ad30:	fb01 f303 	mul.w	r3, r1, r3
 800ad34:	4413      	add	r3, r2
 800ad36:	3391      	adds	r3, #145	@ 0x91
 800ad38:	2201      	movs	r2, #1
 800ad3a:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 800ad3c:	693b      	ldr	r3, [r7, #16]
 800ad3e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad42:	4619      	mov	r1, r3
 800ad44:	693a      	ldr	r2, [r7, #16]
 800ad46:	2334      	movs	r3, #52	@ 0x34
 800ad48:	fb01 f303 	mul.w	r3, r1, r3
 800ad4c:	4413      	add	r3, r2
 800ad4e:	3392      	adds	r3, #146	@ 0x92
 800ad50:	2202      	movs	r2, #2
 800ad52:	701a      	strb	r2, [r3, #0]
            break;
 800ad54:	e127      	b.n	800afa6 <USBH_MSC_Process+0x4fe>
              if (ready_status == USBH_UNRECOVERED_ERROR)
 800ad56:	7bbb      	ldrb	r3, [r7, #14]
 800ad58:	2b04      	cmp	r3, #4
 800ad5a:	f040 8124 	bne.w	800afa6 <USBH_MSC_Process+0x4fe>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800ad5e:	693b      	ldr	r3, [r7, #16]
 800ad60:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad64:	4619      	mov	r1, r3
 800ad66:	693a      	ldr	r2, [r7, #16]
 800ad68:	2334      	movs	r3, #52	@ 0x34
 800ad6a:	fb01 f303 	mul.w	r3, r1, r3
 800ad6e:	4413      	add	r3, r2
 800ad70:	3390      	adds	r3, #144	@ 0x90
 800ad72:	2201      	movs	r2, #1
 800ad74:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800ad76:	693b      	ldr	r3, [r7, #16]
 800ad78:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad7c:	4619      	mov	r1, r3
 800ad7e:	693a      	ldr	r2, [r7, #16]
 800ad80:	2334      	movs	r3, #52	@ 0x34
 800ad82:	fb01 f303 	mul.w	r3, r1, r3
 800ad86:	4413      	add	r3, r2
 800ad88:	3391      	adds	r3, #145	@ 0x91
 800ad8a:	2202      	movs	r2, #2
 800ad8c:	701a      	strb	r2, [r3, #0]
            break;
 800ad8e:	e10a      	b.n	800afa6 <USBH_MSC_Process+0x4fe>
            scsi_status = USBH_MSC_SCSI_ReadCapacity(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].capacity);
 800ad90:	693b      	ldr	r3, [r7, #16]
 800ad92:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad96:	b2d9      	uxtb	r1, r3
 800ad98:	693b      	ldr	r3, [r7, #16]
 800ad9a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ad9e:	461a      	mov	r2, r3
 800ada0:	2334      	movs	r3, #52	@ 0x34
 800ada2:	fb02 f303 	mul.w	r3, r2, r3
 800ada6:	3390      	adds	r3, #144	@ 0x90
 800ada8:	693a      	ldr	r2, [r7, #16]
 800adaa:	4413      	add	r3, r2
 800adac:	3304      	adds	r3, #4
 800adae:	461a      	mov	r2, r3
 800adb0:	6878      	ldr	r0, [r7, #4]
 800adb2:	f000 fddc 	bl	800b96e <USBH_MSC_SCSI_ReadCapacity>
 800adb6:	4603      	mov	r3, r0
 800adb8:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800adba:	7bfb      	ldrb	r3, [r7, #15]
 800adbc:	2b00      	cmp	r3, #0
 800adbe:	d120      	bne.n	800ae02 <USBH_MSC_Process+0x35a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800adc0:	693b      	ldr	r3, [r7, #16]
 800adc2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800adc6:	4619      	mov	r1, r3
 800adc8:	693a      	ldr	r2, [r7, #16]
 800adca:	2334      	movs	r3, #52	@ 0x34
 800adcc:	fb01 f303 	mul.w	r3, r1, r3
 800add0:	4413      	add	r3, r2
 800add2:	3390      	adds	r3, #144	@ 0x90
 800add4:	2201      	movs	r2, #1
 800add6:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 800add8:	693b      	ldr	r3, [r7, #16]
 800adda:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800adde:	4619      	mov	r1, r3
 800ade0:	693a      	ldr	r2, [r7, #16]
 800ade2:	2334      	movs	r3, #52	@ 0x34
 800ade4:	fb01 f303 	mul.w	r3, r1, r3
 800ade8:	4413      	add	r3, r2
 800adea:	3391      	adds	r3, #145	@ 0x91
 800adec:	2200      	movs	r2, #0
 800adee:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 800adf0:	693b      	ldr	r3, [r7, #16]
 800adf2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800adf6:	3301      	adds	r3, #1
 800adf8:	b29a      	uxth	r2, r3
 800adfa:	693b      	ldr	r3, [r7, #16]
 800adfc:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            break;
 800ae00:	e0d3      	b.n	800afaa <USBH_MSC_Process+0x502>
            else if (scsi_status == USBH_FAIL)
 800ae02:	7bfb      	ldrb	r3, [r7, #15]
 800ae04:	2b02      	cmp	r3, #2
 800ae06:	d10c      	bne.n	800ae22 <USBH_MSC_Process+0x37a>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 800ae08:	693b      	ldr	r3, [r7, #16]
 800ae0a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae0e:	4619      	mov	r1, r3
 800ae10:	693a      	ldr	r2, [r7, #16]
 800ae12:	2334      	movs	r3, #52	@ 0x34
 800ae14:	fb01 f303 	mul.w	r3, r1, r3
 800ae18:	4413      	add	r3, r2
 800ae1a:	3390      	adds	r3, #144	@ 0x90
 800ae1c:	2205      	movs	r2, #5
 800ae1e:	701a      	strb	r2, [r3, #0]
            break;
 800ae20:	e0c3      	b.n	800afaa <USBH_MSC_Process+0x502>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800ae22:	7bfb      	ldrb	r3, [r7, #15]
 800ae24:	2b04      	cmp	r3, #4
 800ae26:	f040 80c0 	bne.w	800afaa <USBH_MSC_Process+0x502>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800ae2a:	693b      	ldr	r3, [r7, #16]
 800ae2c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae30:	4619      	mov	r1, r3
 800ae32:	693a      	ldr	r2, [r7, #16]
 800ae34:	2334      	movs	r3, #52	@ 0x34
 800ae36:	fb01 f303 	mul.w	r3, r1, r3
 800ae3a:	4413      	add	r3, r2
 800ae3c:	3390      	adds	r3, #144	@ 0x90
 800ae3e:	2201      	movs	r2, #1
 800ae40:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800ae42:	693b      	ldr	r3, [r7, #16]
 800ae44:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae48:	4619      	mov	r1, r3
 800ae4a:	693a      	ldr	r2, [r7, #16]
 800ae4c:	2334      	movs	r3, #52	@ 0x34
 800ae4e:	fb01 f303 	mul.w	r3, r1, r3
 800ae52:	4413      	add	r3, r2
 800ae54:	3391      	adds	r3, #145	@ 0x91
 800ae56:	2202      	movs	r2, #2
 800ae58:	701a      	strb	r2, [r3, #0]
            break;
 800ae5a:	e0a6      	b.n	800afaa <USBH_MSC_Process+0x502>
            scsi_status = USBH_MSC_SCSI_RequestSense(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].sense);
 800ae5c:	693b      	ldr	r3, [r7, #16]
 800ae5e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae62:	b2d9      	uxtb	r1, r3
 800ae64:	693b      	ldr	r3, [r7, #16]
 800ae66:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae6a:	461a      	mov	r2, r3
 800ae6c:	2334      	movs	r3, #52	@ 0x34
 800ae6e:	fb02 f303 	mul.w	r3, r2, r3
 800ae72:	3398      	adds	r3, #152	@ 0x98
 800ae74:	693a      	ldr	r2, [r7, #16]
 800ae76:	4413      	add	r3, r2
 800ae78:	3304      	adds	r3, #4
 800ae7a:	461a      	mov	r2, r3
 800ae7c:	6878      	ldr	r0, [r7, #4]
 800ae7e:	f000 fe95 	bl	800bbac <USBH_MSC_SCSI_RequestSense>
 800ae82:	4603      	mov	r3, r0
 800ae84:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800ae86:	7bfb      	ldrb	r3, [r7, #15]
 800ae88:	2b00      	cmp	r3, #0
 800ae8a:	d145      	bne.n	800af18 <USBH_MSC_Process+0x470>
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800ae8c:	693b      	ldr	r3, [r7, #16]
 800ae8e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800ae92:	4619      	mov	r1, r3
 800ae94:	693a      	ldr	r2, [r7, #16]
 800ae96:	2334      	movs	r3, #52	@ 0x34
 800ae98:	fb01 f303 	mul.w	r3, r1, r3
 800ae9c:	4413      	add	r3, r2
 800ae9e:	339c      	adds	r3, #156	@ 0x9c
 800aea0:	781b      	ldrb	r3, [r3, #0]
 800aea2:	2b06      	cmp	r3, #6
 800aea4:	d00c      	beq.n	800aec0 <USBH_MSC_Process+0x418>
                  (MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_NOT_READY))
 800aea6:	693b      	ldr	r3, [r7, #16]
 800aea8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aeac:	4619      	mov	r1, r3
 800aeae:	693a      	ldr	r2, [r7, #16]
 800aeb0:	2334      	movs	r3, #52	@ 0x34
 800aeb2:	fb01 f303 	mul.w	r3, r1, r3
 800aeb6:	4413      	add	r3, r2
 800aeb8:	339c      	adds	r3, #156	@ 0x9c
 800aeba:	781b      	ldrb	r3, [r3, #0]
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800aebc:	2b02      	cmp	r3, #2
 800aebe:	d117      	bne.n	800aef0 <USBH_MSC_Process+0x448>
                if ((phost->Timer - MSC_Handle->timer) < 10000U)
 800aec0:	687b      	ldr	r3, [r7, #4]
 800aec2:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800aec6:	693b      	ldr	r3, [r7, #16]
 800aec8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
 800aecc:	1ad3      	subs	r3, r2, r3
 800aece:	f242 720f 	movw	r2, #9999	@ 0x270f
 800aed2:	4293      	cmp	r3, r2
 800aed4:	d80c      	bhi.n	800aef0 <USBH_MSC_Process+0x448>
                  MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 800aed6:	693b      	ldr	r3, [r7, #16]
 800aed8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aedc:	4619      	mov	r1, r3
 800aede:	693a      	ldr	r2, [r7, #16]
 800aee0:	2334      	movs	r3, #52	@ 0x34
 800aee2:	fb01 f303 	mul.w	r3, r1, r3
 800aee6:	4413      	add	r3, r2
 800aee8:	3390      	adds	r3, #144	@ 0x90
 800aeea:	2202      	movs	r2, #2
 800aeec:	701a      	strb	r2, [r3, #0]
                  break;
 800aeee:	e05f      	b.n	800afb0 <USBH_MSC_Process+0x508>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800aef0:	693b      	ldr	r3, [r7, #16]
 800aef2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800aef6:	4619      	mov	r1, r3
 800aef8:	693a      	ldr	r2, [r7, #16]
 800aefa:	2334      	movs	r3, #52	@ 0x34
 800aefc:	fb01 f303 	mul.w	r3, r1, r3
 800af00:	4413      	add	r3, r2
 800af02:	3390      	adds	r3, #144	@ 0x90
 800af04:	2201      	movs	r2, #1
 800af06:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 800af08:	693b      	ldr	r3, [r7, #16]
 800af0a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af0e:	3301      	adds	r3, #1
 800af10:	b29a      	uxth	r2, r3
 800af12:	693b      	ldr	r3, [r7, #16]
 800af14:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            if (scsi_status == USBH_FAIL)
 800af18:	7bfb      	ldrb	r3, [r7, #15]
 800af1a:	2b02      	cmp	r3, #2
 800af1c:	d10c      	bne.n	800af38 <USBH_MSC_Process+0x490>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_UNRECOVERED_ERROR;
 800af1e:	693b      	ldr	r3, [r7, #16]
 800af20:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af24:	4619      	mov	r1, r3
 800af26:	693a      	ldr	r2, [r7, #16]
 800af28:	2334      	movs	r3, #52	@ 0x34
 800af2a:	fb01 f303 	mul.w	r3, r1, r3
 800af2e:	4413      	add	r3, r2
 800af30:	3390      	adds	r3, #144	@ 0x90
 800af32:	2208      	movs	r2, #8
 800af34:	701a      	strb	r2, [r3, #0]
            break;
 800af36:	e03a      	b.n	800afae <USBH_MSC_Process+0x506>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 800af38:	7bfb      	ldrb	r3, [r7, #15]
 800af3a:	2b04      	cmp	r3, #4
 800af3c:	d137      	bne.n	800afae <USBH_MSC_Process+0x506>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800af3e:	693b      	ldr	r3, [r7, #16]
 800af40:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af44:	4619      	mov	r1, r3
 800af46:	693a      	ldr	r2, [r7, #16]
 800af48:	2334      	movs	r3, #52	@ 0x34
 800af4a:	fb01 f303 	mul.w	r3, r1, r3
 800af4e:	4413      	add	r3, r2
 800af50:	3390      	adds	r3, #144	@ 0x90
 800af52:	2201      	movs	r2, #1
 800af54:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 800af56:	693b      	ldr	r3, [r7, #16]
 800af58:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af5c:	4619      	mov	r1, r3
 800af5e:	693a      	ldr	r2, [r7, #16]
 800af60:	2334      	movs	r3, #52	@ 0x34
 800af62:	fb01 f303 	mul.w	r3, r1, r3
 800af66:	4413      	add	r3, r2
 800af68:	3391      	adds	r3, #145	@ 0x91
 800af6a:	2202      	movs	r2, #2
 800af6c:	701a      	strb	r2, [r3, #0]
            break;
 800af6e:	e01e      	b.n	800afae <USBH_MSC_Process+0x506>
            MSC_Handle->current_lun++;
 800af70:	693b      	ldr	r3, [r7, #16]
 800af72:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	@ 0xf8
 800af76:	3301      	adds	r3, #1
 800af78:	b29a      	uxth	r2, r3
 800af7a:	693b      	ldr	r3, [r7, #16]
 800af7c:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
            break;
 800af80:	e016      	b.n	800afb0 <USBH_MSC_Process+0x508>
        MSC_Handle->current_lun = 0U;
 800af82:	693b      	ldr	r3, [r7, #16]
 800af84:	2200      	movs	r2, #0
 800af86:	f8a3 20f8 	strh.w	r2, [r3, #248]	@ 0xf8
        MSC_Handle->state = MSC_IDLE;
 800af8a:	693b      	ldr	r3, [r7, #16]
 800af8c:	2201      	movs	r2, #1
 800af8e:	731a      	strb	r2, [r3, #12]
        phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 800af90:	687b      	ldr	r3, [r7, #4]
 800af92:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800af96:	2102      	movs	r1, #2
 800af98:	6878      	ldr	r0, [r7, #4]
 800af9a:	4798      	blx	r3
      break;
 800af9c:	e00c      	b.n	800afb8 <USBH_MSC_Process+0x510>
            break;
 800af9e:	bf00      	nop
 800afa0:	e00a      	b.n	800afb8 <USBH_MSC_Process+0x510>
            break;
 800afa2:	bf00      	nop
 800afa4:	e008      	b.n	800afb8 <USBH_MSC_Process+0x510>
            break;
 800afa6:	bf00      	nop
 800afa8:	e006      	b.n	800afb8 <USBH_MSC_Process+0x510>
            break;
 800afaa:	bf00      	nop
 800afac:	e004      	b.n	800afb8 <USBH_MSC_Process+0x510>
            break;
 800afae:	bf00      	nop
      break;
 800afb0:	e002      	b.n	800afb8 <USBH_MSC_Process+0x510>
      error = USBH_OK;
 800afb2:	2300      	movs	r3, #0
 800afb4:	75fb      	strb	r3, [r7, #23]
      break;
 800afb6:	bf00      	nop
  }
  return error;
 800afb8:	7dfb      	ldrb	r3, [r7, #23]
}
 800afba:	4618      	mov	r0, r3
 800afbc:	3718      	adds	r7, #24
 800afbe:	46bd      	mov	sp, r7
 800afc0:	bd80      	pop	{r7, pc}
 800afc2:	bf00      	nop

0800afc4 <USBH_MSC_SOFProcess>:
  *         The function is for SOF state
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_SOFProcess(USBH_HandleTypeDef *phost)
{
 800afc4:	b480      	push	{r7}
 800afc6:	b083      	sub	sp, #12
 800afc8:	af00      	add	r7, sp, #0
 800afca:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phost);

  return USBH_OK;
 800afcc:	2300      	movs	r3, #0
}
 800afce:	4618      	mov	r0, r3
 800afd0:	370c      	adds	r7, #12
 800afd2:	46bd      	mov	sp, r7
 800afd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afd8:	4770      	bx	lr

0800afda <USBH_MSC_RdWrProcess>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_RdWrProcess(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800afda:	b580      	push	{r7, lr}
 800afdc:	b088      	sub	sp, #32
 800afde:	af02      	add	r7, sp, #8
 800afe0:	6078      	str	r0, [r7, #4]
 800afe2:	460b      	mov	r3, r1
 800afe4:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800afe6:	687b      	ldr	r3, [r7, #4]
 800afe8:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800afec:	69db      	ldr	r3, [r3, #28]
 800afee:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY;
 800aff0:	2301      	movs	r3, #1
 800aff2:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY;
 800aff4:	2301      	movs	r3, #1
 800aff6:	73fb      	strb	r3, [r7, #15]

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->unit[lun].state)
 800aff8:	78fb      	ldrb	r3, [r7, #3]
 800affa:	693a      	ldr	r2, [r7, #16]
 800affc:	2134      	movs	r1, #52	@ 0x34
 800affe:	fb01 f303 	mul.w	r3, r1, r3
 800b002:	4413      	add	r3, r2
 800b004:	3390      	adds	r3, #144	@ 0x90
 800b006:	781b      	ldrb	r3, [r3, #0]
 800b008:	2b07      	cmp	r3, #7
 800b00a:	d03c      	beq.n	800b086 <USBH_MSC_RdWrProcess+0xac>
 800b00c:	2b07      	cmp	r3, #7
 800b00e:	f300 80a7 	bgt.w	800b160 <USBH_MSC_RdWrProcess+0x186>
 800b012:	2b05      	cmp	r3, #5
 800b014:	d06c      	beq.n	800b0f0 <USBH_MSC_RdWrProcess+0x116>
 800b016:	2b06      	cmp	r3, #6
 800b018:	f040 80a2 	bne.w	800b160 <USBH_MSC_RdWrProcess+0x186>
  {

    case MSC_READ:
      scsi_status = USBH_MSC_SCSI_Read(phost, lun, 0U, NULL, 0U);
 800b01c:	78f9      	ldrb	r1, [r7, #3]
 800b01e:	2300      	movs	r3, #0
 800b020:	9300      	str	r3, [sp, #0]
 800b022:	2300      	movs	r3, #0
 800b024:	2200      	movs	r2, #0
 800b026:	6878      	ldr	r0, [r7, #4]
 800b028:	f000 fea4 	bl	800bd74 <USBH_MSC_SCSI_Read>
 800b02c:	4603      	mov	r3, r0
 800b02e:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b030:	7bfb      	ldrb	r3, [r7, #15]
 800b032:	2b00      	cmp	r3, #0
 800b034:	d10b      	bne.n	800b04e <USBH_MSC_RdWrProcess+0x74>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b036:	78fb      	ldrb	r3, [r7, #3]
 800b038:	693a      	ldr	r2, [r7, #16]
 800b03a:	2134      	movs	r1, #52	@ 0x34
 800b03c:	fb01 f303 	mul.w	r3, r1, r3
 800b040:	4413      	add	r3, r2
 800b042:	3390      	adds	r3, #144	@ 0x90
 800b044:	2201      	movs	r2, #1
 800b046:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 800b048:	2300      	movs	r3, #0
 800b04a:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b04c:	e08a      	b.n	800b164 <USBH_MSC_RdWrProcess+0x18a>
      else if (scsi_status == USBH_FAIL)
 800b04e:	7bfb      	ldrb	r3, [r7, #15]
 800b050:	2b02      	cmp	r3, #2
 800b052:	d109      	bne.n	800b068 <USBH_MSC_RdWrProcess+0x8e>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800b054:	78fb      	ldrb	r3, [r7, #3]
 800b056:	693a      	ldr	r2, [r7, #16]
 800b058:	2134      	movs	r1, #52	@ 0x34
 800b05a:	fb01 f303 	mul.w	r3, r1, r3
 800b05e:	4413      	add	r3, r2
 800b060:	3390      	adds	r3, #144	@ 0x90
 800b062:	2205      	movs	r2, #5
 800b064:	701a      	strb	r2, [r3, #0]
      break;
 800b066:	e07d      	b.n	800b164 <USBH_MSC_RdWrProcess+0x18a>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b068:	7bfb      	ldrb	r3, [r7, #15]
 800b06a:	2b04      	cmp	r3, #4
 800b06c:	d17a      	bne.n	800b164 <USBH_MSC_RdWrProcess+0x18a>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b06e:	78fb      	ldrb	r3, [r7, #3]
 800b070:	693a      	ldr	r2, [r7, #16]
 800b072:	2134      	movs	r1, #52	@ 0x34
 800b074:	fb01 f303 	mul.w	r3, r1, r3
 800b078:	4413      	add	r3, r2
 800b07a:	3390      	adds	r3, #144	@ 0x90
 800b07c:	2208      	movs	r2, #8
 800b07e:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b080:	2302      	movs	r3, #2
 800b082:	75fb      	strb	r3, [r7, #23]
      break;
 800b084:	e06e      	b.n	800b164 <USBH_MSC_RdWrProcess+0x18a>

    case MSC_WRITE:
      scsi_status = USBH_MSC_SCSI_Write(phost, lun, 0U, NULL, 0U);
 800b086:	78f9      	ldrb	r1, [r7, #3]
 800b088:	2300      	movs	r3, #0
 800b08a:	9300      	str	r3, [sp, #0]
 800b08c:	2300      	movs	r3, #0
 800b08e:	2200      	movs	r2, #0
 800b090:	6878      	ldr	r0, [r7, #4]
 800b092:	f000 fe04 	bl	800bc9e <USBH_MSC_SCSI_Write>
 800b096:	4603      	mov	r3, r0
 800b098:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b09a:	7bfb      	ldrb	r3, [r7, #15]
 800b09c:	2b00      	cmp	r3, #0
 800b09e:	d10b      	bne.n	800b0b8 <USBH_MSC_RdWrProcess+0xde>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b0a0:	78fb      	ldrb	r3, [r7, #3]
 800b0a2:	693a      	ldr	r2, [r7, #16]
 800b0a4:	2134      	movs	r1, #52	@ 0x34
 800b0a6:	fb01 f303 	mul.w	r3, r1, r3
 800b0aa:	4413      	add	r3, r2
 800b0ac:	3390      	adds	r3, #144	@ 0x90
 800b0ae:	2201      	movs	r2, #1
 800b0b0:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 800b0b2:	2300      	movs	r3, #0
 800b0b4:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b0b6:	e057      	b.n	800b168 <USBH_MSC_RdWrProcess+0x18e>
      else if (scsi_status == USBH_FAIL)
 800b0b8:	7bfb      	ldrb	r3, [r7, #15]
 800b0ba:	2b02      	cmp	r3, #2
 800b0bc:	d109      	bne.n	800b0d2 <USBH_MSC_RdWrProcess+0xf8>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800b0be:	78fb      	ldrb	r3, [r7, #3]
 800b0c0:	693a      	ldr	r2, [r7, #16]
 800b0c2:	2134      	movs	r1, #52	@ 0x34
 800b0c4:	fb01 f303 	mul.w	r3, r1, r3
 800b0c8:	4413      	add	r3, r2
 800b0ca:	3390      	adds	r3, #144	@ 0x90
 800b0cc:	2205      	movs	r2, #5
 800b0ce:	701a      	strb	r2, [r3, #0]
      break;
 800b0d0:	e04a      	b.n	800b168 <USBH_MSC_RdWrProcess+0x18e>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b0d2:	7bfb      	ldrb	r3, [r7, #15]
 800b0d4:	2b04      	cmp	r3, #4
 800b0d6:	d147      	bne.n	800b168 <USBH_MSC_RdWrProcess+0x18e>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b0d8:	78fb      	ldrb	r3, [r7, #3]
 800b0da:	693a      	ldr	r2, [r7, #16]
 800b0dc:	2134      	movs	r1, #52	@ 0x34
 800b0de:	fb01 f303 	mul.w	r3, r1, r3
 800b0e2:	4413      	add	r3, r2
 800b0e4:	3390      	adds	r3, #144	@ 0x90
 800b0e6:	2208      	movs	r2, #8
 800b0e8:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b0ea:	2302      	movs	r3, #2
 800b0ec:	75fb      	strb	r3, [r7, #23]
      break;
 800b0ee:	e03b      	b.n	800b168 <USBH_MSC_RdWrProcess+0x18e>

    case MSC_REQUEST_SENSE:
      scsi_status = USBH_MSC_SCSI_RequestSense(phost, lun, &MSC_Handle->unit[lun].sense);
 800b0f0:	78fb      	ldrb	r3, [r7, #3]
 800b0f2:	2234      	movs	r2, #52	@ 0x34
 800b0f4:	fb02 f303 	mul.w	r3, r2, r3
 800b0f8:	3398      	adds	r3, #152	@ 0x98
 800b0fa:	693a      	ldr	r2, [r7, #16]
 800b0fc:	4413      	add	r3, r2
 800b0fe:	1d1a      	adds	r2, r3, #4
 800b100:	78fb      	ldrb	r3, [r7, #3]
 800b102:	4619      	mov	r1, r3
 800b104:	6878      	ldr	r0, [r7, #4]
 800b106:	f000 fd51 	bl	800bbac <USBH_MSC_SCSI_RequestSense>
 800b10a:	4603      	mov	r3, r0
 800b10c:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800b10e:	7bfb      	ldrb	r3, [r7, #15]
 800b110:	2b00      	cmp	r3, #0
 800b112:	d113      	bne.n	800b13c <USBH_MSC_RdWrProcess+0x162>
      {
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
        USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[lun].sense.asc);
        USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[lun].sense.ascq);
        MSC_Handle->unit[lun].state = MSC_IDLE;
 800b114:	78fb      	ldrb	r3, [r7, #3]
 800b116:	693a      	ldr	r2, [r7, #16]
 800b118:	2134      	movs	r1, #52	@ 0x34
 800b11a:	fb01 f303 	mul.w	r3, r1, r3
 800b11e:	4413      	add	r3, r2
 800b120:	3390      	adds	r3, #144	@ 0x90
 800b122:	2201      	movs	r2, #1
 800b124:	701a      	strb	r2, [r3, #0]
        MSC_Handle->unit[lun].error = MSC_ERROR;
 800b126:	78fb      	ldrb	r3, [r7, #3]
 800b128:	693a      	ldr	r2, [r7, #16]
 800b12a:	2134      	movs	r1, #52	@ 0x34
 800b12c:	fb01 f303 	mul.w	r3, r1, r3
 800b130:	4413      	add	r3, r2
 800b132:	3391      	adds	r3, #145	@ 0x91
 800b134:	2202      	movs	r2, #2
 800b136:	701a      	strb	r2, [r3, #0]

        error = USBH_FAIL;
 800b138:	2302      	movs	r3, #2
 800b13a:	75fb      	strb	r3, [r7, #23]
      }
      if (scsi_status == USBH_FAIL)
 800b13c:	7bfb      	ldrb	r3, [r7, #15]
 800b13e:	2b02      	cmp	r3, #2
 800b140:	d014      	beq.n	800b16c <USBH_MSC_RdWrProcess+0x192>
      {
        USBH_UsrLog("MSC Device NOT ready");
      }
      else
      {
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 800b142:	7bfb      	ldrb	r3, [r7, #15]
 800b144:	2b04      	cmp	r3, #4
 800b146:	d111      	bne.n	800b16c <USBH_MSC_RdWrProcess+0x192>
        {
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800b148:	78fb      	ldrb	r3, [r7, #3]
 800b14a:	693a      	ldr	r2, [r7, #16]
 800b14c:	2134      	movs	r1, #52	@ 0x34
 800b14e:	fb01 f303 	mul.w	r3, r1, r3
 800b152:	4413      	add	r3, r2
 800b154:	3390      	adds	r3, #144	@ 0x90
 800b156:	2208      	movs	r2, #8
 800b158:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800b15a:	2302      	movs	r3, #2
 800b15c:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800b15e:	e005      	b.n	800b16c <USBH_MSC_RdWrProcess+0x192>

    default:
      break;
 800b160:	bf00      	nop
 800b162:	e004      	b.n	800b16e <USBH_MSC_RdWrProcess+0x194>
      break;
 800b164:	bf00      	nop
 800b166:	e002      	b.n	800b16e <USBH_MSC_RdWrProcess+0x194>
      break;
 800b168:	bf00      	nop
 800b16a:	e000      	b.n	800b16e <USBH_MSC_RdWrProcess+0x194>
      break;
 800b16c:	bf00      	nop

  }
  return error;
 800b16e:	7dfb      	ldrb	r3, [r7, #23]
}
 800b170:	4618      	mov	r0, r3
 800b172:	3718      	adds	r7, #24
 800b174:	46bd      	mov	sp, r7
 800b176:	bd80      	pop	{r7, pc}

0800b178 <USBH_MSC_UnitIsReady>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval Lun status (0: not ready / 1: ready)
  */
uint8_t USBH_MSC_UnitIsReady(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800b178:	b480      	push	{r7}
 800b17a:	b085      	sub	sp, #20
 800b17c:	af00      	add	r7, sp, #0
 800b17e:	6078      	str	r0, [r7, #4]
 800b180:	460b      	mov	r3, r1
 800b182:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b184:	687b      	ldr	r3, [r7, #4]
 800b186:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b18a:	69db      	ldr	r3, [r3, #28]
 800b18c:	60bb      	str	r3, [r7, #8]
  uint8_t res;

  if ((phost->gState == HOST_CLASS) && (MSC_Handle->unit[lun].error == MSC_OK))
 800b18e:	687b      	ldr	r3, [r7, #4]
 800b190:	781b      	ldrb	r3, [r3, #0]
 800b192:	b2db      	uxtb	r3, r3
 800b194:	2b0b      	cmp	r3, #11
 800b196:	d10c      	bne.n	800b1b2 <USBH_MSC_UnitIsReady+0x3a>
 800b198:	78fb      	ldrb	r3, [r7, #3]
 800b19a:	68ba      	ldr	r2, [r7, #8]
 800b19c:	2134      	movs	r1, #52	@ 0x34
 800b19e:	fb01 f303 	mul.w	r3, r1, r3
 800b1a2:	4413      	add	r3, r2
 800b1a4:	3391      	adds	r3, #145	@ 0x91
 800b1a6:	781b      	ldrb	r3, [r3, #0]
 800b1a8:	2b00      	cmp	r3, #0
 800b1aa:	d102      	bne.n	800b1b2 <USBH_MSC_UnitIsReady+0x3a>
  {
    res = 1U;
 800b1ac:	2301      	movs	r3, #1
 800b1ae:	73fb      	strb	r3, [r7, #15]
 800b1b0:	e001      	b.n	800b1b6 <USBH_MSC_UnitIsReady+0x3e>
  }
  else
  {
    res = 0U;
 800b1b2:	2300      	movs	r3, #0
 800b1b4:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 800b1b6:	7bfb      	ldrb	r3, [r7, #15]
}
 800b1b8:	4618      	mov	r0, r3
 800b1ba:	3714      	adds	r7, #20
 800b1bc:	46bd      	mov	sp, r7
 800b1be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1c2:	4770      	bx	lr

0800b1c4 <USBH_MSC_GetLUNInfo>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_GetLUNInfo(USBH_HandleTypeDef *phost, uint8_t lun, MSC_LUNTypeDef *info)
{
 800b1c4:	b580      	push	{r7, lr}
 800b1c6:	b086      	sub	sp, #24
 800b1c8:	af00      	add	r7, sp, #0
 800b1ca:	60f8      	str	r0, [r7, #12]
 800b1cc:	460b      	mov	r3, r1
 800b1ce:	607a      	str	r2, [r7, #4]
 800b1d0:	72fb      	strb	r3, [r7, #11]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b1d2:	68fb      	ldr	r3, [r7, #12]
 800b1d4:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b1d8:	69db      	ldr	r3, [r3, #28]
 800b1da:	617b      	str	r3, [r7, #20]
  if (phost->gState == HOST_CLASS)
 800b1dc:	68fb      	ldr	r3, [r7, #12]
 800b1de:	781b      	ldrb	r3, [r3, #0]
 800b1e0:	b2db      	uxtb	r3, r3
 800b1e2:	2b0b      	cmp	r3, #11
 800b1e4:	d10d      	bne.n	800b202 <USBH_MSC_GetLUNInfo+0x3e>
  {
    (void)USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 800b1e6:	7afb      	ldrb	r3, [r7, #11]
 800b1e8:	2234      	movs	r2, #52	@ 0x34
 800b1ea:	fb02 f303 	mul.w	r3, r2, r3
 800b1ee:	3390      	adds	r3, #144	@ 0x90
 800b1f0:	697a      	ldr	r2, [r7, #20]
 800b1f2:	4413      	add	r3, r2
 800b1f4:	2234      	movs	r2, #52	@ 0x34
 800b1f6:	4619      	mov	r1, r3
 800b1f8:	6878      	ldr	r0, [r7, #4]
 800b1fa:	f024 fc15 	bl	802fa28 <memcpy>
    return USBH_OK;
 800b1fe:	2300      	movs	r3, #0
 800b200:	e000      	b.n	800b204 <USBH_MSC_GetLUNInfo+0x40>
  }
  else
  {
    return USBH_FAIL;
 800b202:	2302      	movs	r3, #2
  }
}
 800b204:	4618      	mov	r0, r3
 800b206:	3718      	adds	r7, #24
 800b208:	46bd      	mov	sp, r7
 800b20a:	bd80      	pop	{r7, pc}

0800b20c <USBH_MSC_Read>:
USBH_StatusTypeDef USBH_MSC_Read(USBH_HandleTypeDef *phost,
                                 uint8_t lun,
                                 uint32_t address,
                                 uint8_t *pbuf,
                                 uint32_t length)
{
 800b20c:	b580      	push	{r7, lr}
 800b20e:	b088      	sub	sp, #32
 800b210:	af02      	add	r7, sp, #8
 800b212:	60f8      	str	r0, [r7, #12]
 800b214:	607a      	str	r2, [r7, #4]
 800b216:	603b      	str	r3, [r7, #0]
 800b218:	460b      	mov	r3, r1
 800b21a:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b21c:	68fb      	ldr	r3, [r7, #12]
 800b21e:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b222:	69db      	ldr	r3, [r3, #28]
 800b224:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 800b226:	68fb      	ldr	r3, [r7, #12]
 800b228:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b22c:	b2db      	uxtb	r3, r3
 800b22e:	2b00      	cmp	r3, #0
 800b230:	d00e      	beq.n	800b250 <USBH_MSC_Read+0x44>
      (phost->gState != HOST_CLASS) ||
 800b232:	68fb      	ldr	r3, [r7, #12]
 800b234:	781b      	ldrb	r3, [r3, #0]
 800b236:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 800b238:	2b0b      	cmp	r3, #11
 800b23a:	d109      	bne.n	800b250 <USBH_MSC_Read+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800b23c:	7afb      	ldrb	r3, [r7, #11]
 800b23e:	697a      	ldr	r2, [r7, #20]
 800b240:	2134      	movs	r1, #52	@ 0x34
 800b242:	fb01 f303 	mul.w	r3, r1, r3
 800b246:	4413      	add	r3, r2
 800b248:	3390      	adds	r3, #144	@ 0x90
 800b24a:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 800b24c:	2b01      	cmp	r3, #1
 800b24e:	d001      	beq.n	800b254 <USBH_MSC_Read+0x48>
  {
    return  USBH_FAIL;
 800b250:	2302      	movs	r3, #2
 800b252:	e040      	b.n	800b2d6 <USBH_MSC_Read+0xca>
  }

  MSC_Handle->state = MSC_READ;
 800b254:	697b      	ldr	r3, [r7, #20]
 800b256:	2206      	movs	r2, #6
 800b258:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_READ;
 800b25a:	7afb      	ldrb	r3, [r7, #11]
 800b25c:	697a      	ldr	r2, [r7, #20]
 800b25e:	2134      	movs	r1, #52	@ 0x34
 800b260:	fb01 f303 	mul.w	r3, r1, r3
 800b264:	4413      	add	r3, r2
 800b266:	3390      	adds	r3, #144	@ 0x90
 800b268:	2206      	movs	r2, #6
 800b26a:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 800b26c:	7afb      	ldrb	r3, [r7, #11]
 800b26e:	b29a      	uxth	r2, r3
 800b270:	697b      	ldr	r3, [r7, #20]
 800b272:	f8a3 20fa 	strh.w	r2, [r3, #250]	@ 0xfa

  (void)USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 800b276:	7af9      	ldrb	r1, [r7, #11]
 800b278:	6a3b      	ldr	r3, [r7, #32]
 800b27a:	9300      	str	r3, [sp, #0]
 800b27c:	683b      	ldr	r3, [r7, #0]
 800b27e:	687a      	ldr	r2, [r7, #4]
 800b280:	68f8      	ldr	r0, [r7, #12]
 800b282:	f000 fd77 	bl	800bd74 <USBH_MSC_SCSI_Read>

  timeout = phost->Timer;
 800b286:	68fb      	ldr	r3, [r7, #12]
 800b288:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800b28c:	613b      	str	r3, [r7, #16]

  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b28e:	e016      	b.n	800b2be <USBH_MSC_Read+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800b290:	68fb      	ldr	r3, [r7, #12]
 800b292:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800b296:	693b      	ldr	r3, [r7, #16]
 800b298:	1ad2      	subs	r2, r2, r3
 800b29a:	6a3b      	ldr	r3, [r7, #32]
 800b29c:	f242 7110 	movw	r1, #10000	@ 0x2710
 800b2a0:	fb01 f303 	mul.w	r3, r1, r3
 800b2a4:	429a      	cmp	r2, r3
 800b2a6:	d805      	bhi.n	800b2b4 <USBH_MSC_Read+0xa8>
 800b2a8:	68fb      	ldr	r3, [r7, #12]
 800b2aa:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b2ae:	b2db      	uxtb	r3, r3
 800b2b0:	2b00      	cmp	r3, #0
 800b2b2:	d104      	bne.n	800b2be <USBH_MSC_Read+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 800b2b4:	697b      	ldr	r3, [r7, #20]
 800b2b6:	2201      	movs	r2, #1
 800b2b8:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 800b2ba:	2302      	movs	r3, #2
 800b2bc:	e00b      	b.n	800b2d6 <USBH_MSC_Read+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b2be:	7afb      	ldrb	r3, [r7, #11]
 800b2c0:	4619      	mov	r1, r3
 800b2c2:	68f8      	ldr	r0, [r7, #12]
 800b2c4:	f7ff fe89 	bl	800afda <USBH_MSC_RdWrProcess>
 800b2c8:	4603      	mov	r3, r0
 800b2ca:	2b01      	cmp	r3, #1
 800b2cc:	d0e0      	beq.n	800b290 <USBH_MSC_Read+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 800b2ce:	697b      	ldr	r3, [r7, #20]
 800b2d0:	2201      	movs	r2, #1
 800b2d2:	731a      	strb	r2, [r3, #12]

  return USBH_OK;
 800b2d4:	2300      	movs	r3, #0
}
 800b2d6:	4618      	mov	r0, r3
 800b2d8:	3718      	adds	r7, #24
 800b2da:	46bd      	mov	sp, r7
 800b2dc:	bd80      	pop	{r7, pc}

0800b2de <USBH_MSC_Write>:
USBH_StatusTypeDef USBH_MSC_Write(USBH_HandleTypeDef *phost,
                                  uint8_t lun,
                                  uint32_t address,
                                  uint8_t *pbuf,
                                  uint32_t length)
{
 800b2de:	b580      	push	{r7, lr}
 800b2e0:	b088      	sub	sp, #32
 800b2e2:	af02      	add	r7, sp, #8
 800b2e4:	60f8      	str	r0, [r7, #12]
 800b2e6:	607a      	str	r2, [r7, #4]
 800b2e8:	603b      	str	r3, [r7, #0]
 800b2ea:	460b      	mov	r3, r1
 800b2ec:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b2ee:	68fb      	ldr	r3, [r7, #12]
 800b2f0:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b2f4:	69db      	ldr	r3, [r3, #28]
 800b2f6:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 800b2f8:	68fb      	ldr	r3, [r7, #12]
 800b2fa:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b2fe:	b2db      	uxtb	r3, r3
 800b300:	2b00      	cmp	r3, #0
 800b302:	d00e      	beq.n	800b322 <USBH_MSC_Write+0x44>
      (phost->gState != HOST_CLASS) ||
 800b304:	68fb      	ldr	r3, [r7, #12]
 800b306:	781b      	ldrb	r3, [r3, #0]
 800b308:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 800b30a:	2b0b      	cmp	r3, #11
 800b30c:	d109      	bne.n	800b322 <USBH_MSC_Write+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800b30e:	7afb      	ldrb	r3, [r7, #11]
 800b310:	697a      	ldr	r2, [r7, #20]
 800b312:	2134      	movs	r1, #52	@ 0x34
 800b314:	fb01 f303 	mul.w	r3, r1, r3
 800b318:	4413      	add	r3, r2
 800b31a:	3390      	adds	r3, #144	@ 0x90
 800b31c:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 800b31e:	2b01      	cmp	r3, #1
 800b320:	d001      	beq.n	800b326 <USBH_MSC_Write+0x48>
  {
    return  USBH_FAIL;
 800b322:	2302      	movs	r3, #2
 800b324:	e040      	b.n	800b3a8 <USBH_MSC_Write+0xca>
  }

  MSC_Handle->state = MSC_WRITE;
 800b326:	697b      	ldr	r3, [r7, #20]
 800b328:	2207      	movs	r2, #7
 800b32a:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_WRITE;
 800b32c:	7afb      	ldrb	r3, [r7, #11]
 800b32e:	697a      	ldr	r2, [r7, #20]
 800b330:	2134      	movs	r1, #52	@ 0x34
 800b332:	fb01 f303 	mul.w	r3, r1, r3
 800b336:	4413      	add	r3, r2
 800b338:	3390      	adds	r3, #144	@ 0x90
 800b33a:	2207      	movs	r2, #7
 800b33c:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 800b33e:	7afb      	ldrb	r3, [r7, #11]
 800b340:	b29a      	uxth	r2, r3
 800b342:	697b      	ldr	r3, [r7, #20]
 800b344:	f8a3 20fa 	strh.w	r2, [r3, #250]	@ 0xfa

  (void)USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 800b348:	7af9      	ldrb	r1, [r7, #11]
 800b34a:	6a3b      	ldr	r3, [r7, #32]
 800b34c:	9300      	str	r3, [sp, #0]
 800b34e:	683b      	ldr	r3, [r7, #0]
 800b350:	687a      	ldr	r2, [r7, #4]
 800b352:	68f8      	ldr	r0, [r7, #12]
 800b354:	f000 fca3 	bl	800bc9e <USBH_MSC_SCSI_Write>

  timeout = phost->Timer;
 800b358:	68fb      	ldr	r3, [r7, #12]
 800b35a:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800b35e:	613b      	str	r3, [r7, #16]
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b360:	e016      	b.n	800b390 <USBH_MSC_Write+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 800b362:	68fb      	ldr	r3, [r7, #12]
 800b364:	f8d3 23c4 	ldr.w	r2, [r3, #964]	@ 0x3c4
 800b368:	693b      	ldr	r3, [r7, #16]
 800b36a:	1ad2      	subs	r2, r2, r3
 800b36c:	6a3b      	ldr	r3, [r7, #32]
 800b36e:	f242 7110 	movw	r1, #10000	@ 0x2710
 800b372:	fb01 f303 	mul.w	r3, r1, r3
 800b376:	429a      	cmp	r2, r3
 800b378:	d805      	bhi.n	800b386 <USBH_MSC_Write+0xa8>
 800b37a:	68fb      	ldr	r3, [r7, #12]
 800b37c:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800b380:	b2db      	uxtb	r3, r3
 800b382:	2b00      	cmp	r3, #0
 800b384:	d104      	bne.n	800b390 <USBH_MSC_Write+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 800b386:	697b      	ldr	r3, [r7, #20]
 800b388:	2201      	movs	r2, #1
 800b38a:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 800b38c:	2302      	movs	r3, #2
 800b38e:	e00b      	b.n	800b3a8 <USBH_MSC_Write+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800b390:	7afb      	ldrb	r3, [r7, #11]
 800b392:	4619      	mov	r1, r3
 800b394:	68f8      	ldr	r0, [r7, #12]
 800b396:	f7ff fe20 	bl	800afda <USBH_MSC_RdWrProcess>
 800b39a:	4603      	mov	r3, r0
 800b39c:	2b01      	cmp	r3, #1
 800b39e:	d0e0      	beq.n	800b362 <USBH_MSC_Write+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 800b3a0:	697b      	ldr	r3, [r7, #20]
 800b3a2:	2201      	movs	r2, #1
 800b3a4:	731a      	strb	r2, [r3, #12]
  return USBH_OK;
 800b3a6:	2300      	movs	r3, #0
}
 800b3a8:	4618      	mov	r0, r3
 800b3aa:	3718      	adds	r7, #24
 800b3ac:	46bd      	mov	sp, r7
 800b3ae:	bd80      	pop	{r7, pc}

0800b3b0 <USBH_MSC_BOT_REQ_Reset>:
  *         The function the MSC BOT Reset request.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
{
 800b3b0:	b580      	push	{r7, lr}
 800b3b2:	b082      	sub	sp, #8
 800b3b4:	af00      	add	r7, sp, #0
 800b3b6:	6078      	str	r0, [r7, #4]

  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS
 800b3b8:	687b      	ldr	r3, [r7, #4]
 800b3ba:	2221      	movs	r2, #33	@ 0x21
 800b3bc:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 800b3be:	687b      	ldr	r3, [r7, #4]
 800b3c0:	22ff      	movs	r2, #255	@ 0xff
 800b3c2:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 800b3c4:	687b      	ldr	r3, [r7, #4]
 800b3c6:	2200      	movs	r2, #0
 800b3c8:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 800b3ca:	687b      	ldr	r3, [r7, #4]
 800b3cc:	2200      	movs	r2, #0
 800b3ce:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 0U;
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	2200      	movs	r2, #0
 800b3d4:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, NULL, 0U);
 800b3d6:	2200      	movs	r2, #0
 800b3d8:	2100      	movs	r1, #0
 800b3da:	6878      	ldr	r0, [r7, #4]
 800b3dc:	f001 ff35 	bl	800d24a <USBH_CtlReq>
 800b3e0:	4603      	mov	r3, r0
}
 800b3e2:	4618      	mov	r0, r3
 800b3e4:	3708      	adds	r7, #8
 800b3e6:	46bd      	mov	sp, r7
 800b3e8:	bd80      	pop	{r7, pc}

0800b3ea <USBH_MSC_BOT_REQ_GetMaxLUN>:
  * @param  phost: Host handle
  * @param  Maxlun: pointer to Maxlun variable
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
{
 800b3ea:	b580      	push	{r7, lr}
 800b3ec:	b082      	sub	sp, #8
 800b3ee:	af00      	add	r7, sp, #0
 800b3f0:	6078      	str	r0, [r7, #4]
 800b3f2:	6039      	str	r1, [r7, #0]
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS
 800b3f4:	687b      	ldr	r3, [r7, #4]
 800b3f6:	22a1      	movs	r2, #161	@ 0xa1
 800b3f8:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 800b3fa:	687b      	ldr	r3, [r7, #4]
 800b3fc:	22fe      	movs	r2, #254	@ 0xfe
 800b3fe:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 800b400:	687b      	ldr	r3, [r7, #4]
 800b402:	2200      	movs	r2, #0
 800b404:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 800b406:	687b      	ldr	r3, [r7, #4]
 800b408:	2200      	movs	r2, #0
 800b40a:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 1U;
 800b40c:	687b      	ldr	r3, [r7, #4]
 800b40e:	2201      	movs	r2, #1
 800b410:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, Maxlun, 1U);
 800b412:	2201      	movs	r2, #1
 800b414:	6839      	ldr	r1, [r7, #0]
 800b416:	6878      	ldr	r0, [r7, #4]
 800b418:	f001 ff17 	bl	800d24a <USBH_CtlReq>
 800b41c:	4603      	mov	r3, r0
}
 800b41e:	4618      	mov	r0, r3
 800b420:	3708      	adds	r7, #8
 800b422:	46bd      	mov	sp, r7
 800b424:	bd80      	pop	{r7, pc}
	...

0800b428 <USBH_MSC_BOT_Init>:
  *         The function Initializes the BOT protocol.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
{
 800b428:	b480      	push	{r7}
 800b42a:	b085      	sub	sp, #20
 800b42c:	af00      	add	r7, sp, #0
 800b42e:	6078      	str	r0, [r7, #4]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b430:	687b      	ldr	r3, [r7, #4]
 800b432:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b436:	69db      	ldr	r3, [r3, #28]
 800b438:	60fb      	str	r3, [r7, #12]

  MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
 800b43a:	68fb      	ldr	r3, [r7, #12]
 800b43c:	4a09      	ldr	r2, [pc, #36]	@ (800b464 <USBH_MSC_BOT_Init+0x3c>)
 800b43e:	655a      	str	r2, [r3, #84]	@ 0x54
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
 800b440:	68fb      	ldr	r3, [r7, #12]
 800b442:	4a09      	ldr	r2, [pc, #36]	@ (800b468 <USBH_MSC_BOT_Init+0x40>)
 800b444:	659a      	str	r2, [r3, #88]	@ 0x58
  MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b446:	68fb      	ldr	r3, [r7, #12]
 800b448:	2201      	movs	r2, #1
 800b44a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 800b44e:	68fb      	ldr	r3, [r7, #12]
 800b450:	2201      	movs	r2, #1
 800b452:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52

  return USBH_OK;
 800b456:	2300      	movs	r3, #0
}
 800b458:	4618      	mov	r0, r3
 800b45a:	3714      	adds	r7, #20
 800b45c:	46bd      	mov	sp, r7
 800b45e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b462:	4770      	bx	lr
 800b464:	43425355 	.word	0x43425355
 800b468:	20304050 	.word	0x20304050

0800b46c <USBH_MSC_BOT_Process>:
  * @param  phost: Host handle
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Process(USBH_HandleTypeDef *phost, uint8_t lun)
{
 800b46c:	b580      	push	{r7, lr}
 800b46e:	b088      	sub	sp, #32
 800b470:	af02      	add	r7, sp, #8
 800b472:	6078      	str	r0, [r7, #4]
 800b474:	460b      	mov	r3, r1
 800b476:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef   status = USBH_BUSY;
 800b478:	2301      	movs	r3, #1
 800b47a:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef   error  = USBH_BUSY;
 800b47c:	2301      	movs	r3, #1
 800b47e:	75bb      	strb	r3, [r7, #22]
  BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
 800b480:	2301      	movs	r3, #1
 800b482:	757b      	strb	r3, [r7, #21]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 800b484:	2300      	movs	r3, #0
 800b486:	753b      	strb	r3, [r7, #20]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b488:	687b      	ldr	r3, [r7, #4]
 800b48a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b48e:	69db      	ldr	r3, [r3, #28]
 800b490:	613b      	str	r3, [r7, #16]
  uint8_t toggle = 0U;
 800b492:	2300      	movs	r3, #0
 800b494:	73fb      	strb	r3, [r7, #15]

  switch (MSC_Handle->hbot.state)
 800b496:	693b      	ldr	r3, [r7, #16]
 800b498:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800b49c:	3b01      	subs	r3, #1
 800b49e:	2b0a      	cmp	r3, #10
 800b4a0:	f200 819e 	bhi.w	800b7e0 <USBH_MSC_BOT_Process+0x374>
 800b4a4:	a201      	add	r2, pc, #4	@ (adr r2, 800b4ac <USBH_MSC_BOT_Process+0x40>)
 800b4a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b4aa:	bf00      	nop
 800b4ac:	0800b4d9 	.word	0x0800b4d9
 800b4b0:	0800b501 	.word	0x0800b501
 800b4b4:	0800b56b 	.word	0x0800b56b
 800b4b8:	0800b589 	.word	0x0800b589
 800b4bc:	0800b60d 	.word	0x0800b60d
 800b4c0:	0800b62f 	.word	0x0800b62f
 800b4c4:	0800b6c7 	.word	0x0800b6c7
 800b4c8:	0800b6e3 	.word	0x0800b6e3
 800b4cc:	0800b735 	.word	0x0800b735
 800b4d0:	0800b765 	.word	0x0800b765
 800b4d4:	0800b7c7 	.word	0x0800b7c7
  {
    case BOT_SEND_CBW:
      MSC_Handle->hbot.cbw.field.LUN = lun;
 800b4d8:	693b      	ldr	r3, [r7, #16]
 800b4da:	78fa      	ldrb	r2, [r7, #3]
 800b4dc:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61
      MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;
 800b4e0:	693b      	ldr	r3, [r7, #16]
 800b4e2:	2202      	movs	r2, #2
 800b4e4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.cbw.data,
 800b4e8:	693b      	ldr	r3, [r7, #16]
 800b4ea:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 800b4ee:	693b      	ldr	r3, [r7, #16]
 800b4f0:	795b      	ldrb	r3, [r3, #5]
 800b4f2:	2201      	movs	r2, #1
 800b4f4:	9200      	str	r2, [sp, #0]
 800b4f6:	221f      	movs	r2, #31
 800b4f8:	6878      	ldr	r0, [r7, #4]
 800b4fa:	f002 f8b4 	bl	800d666 <USBH_BulkSendData>
                              BOT_CBW_LENGTH, MSC_Handle->OutPipe, 1U);

      break;
 800b4fe:	e17e      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>

    case BOT_SEND_CBW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 800b500:	693b      	ldr	r3, [r7, #16]
 800b502:	795b      	ldrb	r3, [r3, #5]
 800b504:	4619      	mov	r1, r3
 800b506:	6878      	ldr	r0, [r7, #4]
 800b508:	f024 f888 	bl	802f61c <USBH_LL_GetURBState>
 800b50c:	4603      	mov	r3, r0
 800b50e:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b510:	7d3b      	ldrb	r3, [r7, #20]
 800b512:	2b01      	cmp	r3, #1
 800b514:	d118      	bne.n	800b548 <USBH_MSC_BOT_Process+0xdc>
      {
        if (MSC_Handle->hbot.cbw.field.DataTransferLength != 0U)
 800b516:	693b      	ldr	r3, [r7, #16]
 800b518:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b51a:	2b00      	cmp	r3, #0
 800b51c:	d00f      	beq.n	800b53e <USBH_MSC_BOT_Process+0xd2>
        {
          /* If there is Data Transfer Stage */
          if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
 800b51e:	693b      	ldr	r3, [r7, #16]
 800b520:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
 800b524:	b25b      	sxtb	r3, r3
 800b526:	2b00      	cmp	r3, #0
 800b528:	da04      	bge.n	800b534 <USBH_MSC_BOT_Process+0xc8>
          {
            /* Data Direction is IN */
            MSC_Handle->hbot.state = BOT_DATA_IN;
 800b52a:	693b      	ldr	r3, [r7, #16]
 800b52c:	2203      	movs	r2, #3
 800b52e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800b532:	e157      	b.n	800b7e4 <USBH_MSC_BOT_Process+0x378>
            MSC_Handle->hbot.state = BOT_DATA_OUT;
 800b534:	693b      	ldr	r3, [r7, #16]
 800b536:	2205      	movs	r2, #5
 800b538:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b53c:	e152      	b.n	800b7e4 <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 800b53e:	693b      	ldr	r3, [r7, #16]
 800b540:	2207      	movs	r2, #7
 800b542:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b546:	e14d      	b.n	800b7e4 <USBH_MSC_BOT_Process+0x378>
      else if (URB_Status == USBH_URB_NOTREADY)
 800b548:	7d3b      	ldrb	r3, [r7, #20]
 800b54a:	2b02      	cmp	r3, #2
 800b54c:	d104      	bne.n	800b558 <USBH_MSC_BOT_Process+0xec>
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b54e:	693b      	ldr	r3, [r7, #16]
 800b550:	2201      	movs	r2, #1
 800b552:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b556:	e145      	b.n	800b7e4 <USBH_MSC_BOT_Process+0x378>
        if (URB_Status == USBH_URB_STALL)
 800b558:	7d3b      	ldrb	r3, [r7, #20]
 800b55a:	2b05      	cmp	r3, #5
 800b55c:	f040 8142 	bne.w	800b7e4 <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 800b560:	693b      	ldr	r3, [r7, #16]
 800b562:	220a      	movs	r2, #10
 800b564:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b568:	e13c      	b.n	800b7e4 <USBH_MSC_BOT_Process+0x378>

    case BOT_DATA_IN:
      /* Send first packet */
      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 800b56a:	693b      	ldr	r3, [r7, #16]
 800b56c:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b570:	693b      	ldr	r3, [r7, #16]
 800b572:	895a      	ldrh	r2, [r3, #10]
 800b574:	693b      	ldr	r3, [r7, #16]
 800b576:	791b      	ldrb	r3, [r3, #4]
 800b578:	6878      	ldr	r0, [r7, #4]
 800b57a:	f002 f899 	bl	800d6b0 <USBH_BulkReceiveData>
                                 MSC_Handle->InEpSize, MSC_Handle->InPipe);

      MSC_Handle->hbot.state = BOT_DATA_IN_WAIT;
 800b57e:	693b      	ldr	r3, [r7, #16]
 800b580:	2204      	movs	r2, #4
 800b582:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

      break;
 800b586:	e13a      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 800b588:	693b      	ldr	r3, [r7, #16]
 800b58a:	791b      	ldrb	r3, [r3, #4]
 800b58c:	4619      	mov	r1, r3
 800b58e:	6878      	ldr	r0, [r7, #4]
 800b590:	f024 f844 	bl	802f61c <USBH_LL_GetURBState>
 800b594:	4603      	mov	r3, r0
 800b596:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b598:	7d3b      	ldrb	r3, [r7, #20]
 800b59a:	2b01      	cmp	r3, #1
 800b59c:	d12d      	bne.n	800b5fa <USBH_MSC_BOT_Process+0x18e>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
 800b59e:	693b      	ldr	r3, [r7, #16]
 800b5a0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b5a2:	693a      	ldr	r2, [r7, #16]
 800b5a4:	8952      	ldrh	r2, [r2, #10]
 800b5a6:	4293      	cmp	r3, r2
 800b5a8:	d910      	bls.n	800b5cc <USBH_MSC_BOT_Process+0x160>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
 800b5aa:	693b      	ldr	r3, [r7, #16]
 800b5ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b5b0:	693a      	ldr	r2, [r7, #16]
 800b5b2:	8952      	ldrh	r2, [r2, #10]
 800b5b4:	441a      	add	r2, r3
 800b5b6:	693b      	ldr	r3, [r7, #16]
 800b5b8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;
 800b5bc:	693b      	ldr	r3, [r7, #16]
 800b5be:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b5c0:	693a      	ldr	r2, [r7, #16]
 800b5c2:	8952      	ldrh	r2, [r2, #10]
 800b5c4:	1a9a      	subs	r2, r3, r2
 800b5c6:	693b      	ldr	r3, [r7, #16]
 800b5c8:	65da      	str	r2, [r3, #92]	@ 0x5c
 800b5ca:	e002      	b.n	800b5d2 <USBH_MSC_BOT_Process+0x166>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 800b5cc:	693b      	ldr	r3, [r7, #16]
 800b5ce:	2200      	movs	r2, #0
 800b5d0:	65da      	str	r2, [r3, #92]	@ 0x5c
        }

        /* More Data To be Received */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 800b5d2:	693b      	ldr	r3, [r7, #16]
 800b5d4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b5d6:	2b00      	cmp	r3, #0
 800b5d8:	d00a      	beq.n	800b5f0 <USBH_MSC_BOT_Process+0x184>
        {
          /* Send next packet */
          (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 800b5da:	693b      	ldr	r3, [r7, #16]
 800b5dc:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b5e0:	693b      	ldr	r3, [r7, #16]
 800b5e2:	895a      	ldrh	r2, [r3, #10]
 800b5e4:	693b      	ldr	r3, [r7, #16]
 800b5e6:	791b      	ldrb	r3, [r3, #4]
 800b5e8:	6878      	ldr	r0, [r7, #4]
 800b5ea:	f002 f861 	bl	800d6b0 <USBH_BulkReceiveData>
#endif
      }
      else
      {
      }
      break;
 800b5ee:	e0fb      	b.n	800b7e8 <USBH_MSC_BOT_Process+0x37c>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 800b5f0:	693b      	ldr	r3, [r7, #16]
 800b5f2:	2207      	movs	r2, #7
 800b5f4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b5f8:	e0f6      	b.n	800b7e8 <USBH_MSC_BOT_Process+0x37c>
      else if (URB_Status == USBH_URB_STALL)
 800b5fa:	7d3b      	ldrb	r3, [r7, #20]
 800b5fc:	2b05      	cmp	r3, #5
 800b5fe:	f040 80f3 	bne.w	800b7e8 <USBH_MSC_BOT_Process+0x37c>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 800b602:	693b      	ldr	r3, [r7, #16]
 800b604:	2209      	movs	r2, #9
 800b606:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b60a:	e0ed      	b.n	800b7e8 <USBH_MSC_BOT_Process+0x37c>

    case BOT_DATA_OUT:

      (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 800b60c:	693b      	ldr	r3, [r7, #16]
 800b60e:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b612:	693b      	ldr	r3, [r7, #16]
 800b614:	891a      	ldrh	r2, [r3, #8]
 800b616:	693b      	ldr	r3, [r7, #16]
 800b618:	795b      	ldrb	r3, [r3, #5]
 800b61a:	2001      	movs	r0, #1
 800b61c:	9000      	str	r0, [sp, #0]
 800b61e:	6878      	ldr	r0, [r7, #4]
 800b620:	f002 f821 	bl	800d666 <USBH_BulkSendData>
                              MSC_Handle->OutEpSize, MSC_Handle->OutPipe, 1U);

      MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
 800b624:	693b      	ldr	r3, [r7, #16]
 800b626:	2206      	movs	r2, #6
 800b628:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b62c:	e0e7      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 800b62e:	693b      	ldr	r3, [r7, #16]
 800b630:	795b      	ldrb	r3, [r3, #5]
 800b632:	4619      	mov	r1, r3
 800b634:	6878      	ldr	r0, [r7, #4]
 800b636:	f023 fff1 	bl	802f61c <USBH_LL_GetURBState>
 800b63a:	4603      	mov	r3, r0
 800b63c:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 800b63e:	7d3b      	ldrb	r3, [r7, #20]
 800b640:	2b01      	cmp	r3, #1
 800b642:	d12f      	bne.n	800b6a4 <USBH_MSC_BOT_Process+0x238>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
 800b644:	693b      	ldr	r3, [r7, #16]
 800b646:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b648:	693a      	ldr	r2, [r7, #16]
 800b64a:	8912      	ldrh	r2, [r2, #8]
 800b64c:	4293      	cmp	r3, r2
 800b64e:	d910      	bls.n	800b672 <USBH_MSC_BOT_Process+0x206>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
 800b650:	693b      	ldr	r3, [r7, #16]
 800b652:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b656:	693a      	ldr	r2, [r7, #16]
 800b658:	8912      	ldrh	r2, [r2, #8]
 800b65a:	441a      	add	r2, r3
 800b65c:	693b      	ldr	r3, [r7, #16]
 800b65e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize;
 800b662:	693b      	ldr	r3, [r7, #16]
 800b664:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b666:	693a      	ldr	r2, [r7, #16]
 800b668:	8912      	ldrh	r2, [r2, #8]
 800b66a:	1a9a      	subs	r2, r3, r2
 800b66c:	693b      	ldr	r3, [r7, #16]
 800b66e:	65da      	str	r2, [r3, #92]	@ 0x5c
 800b670:	e002      	b.n	800b678 <USBH_MSC_BOT_Process+0x20c>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 800b672:	693b      	ldr	r3, [r7, #16]
 800b674:	2200      	movs	r2, #0
 800b676:	65da      	str	r2, [r3, #92]	@ 0x5c
        }

        /* More Data To be Sent */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 800b678:	693b      	ldr	r3, [r7, #16]
 800b67a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b67c:	2b00      	cmp	r3, #0
 800b67e:	d00c      	beq.n	800b69a <USBH_MSC_BOT_Process+0x22e>
        {
          (void)USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 800b680:	693b      	ldr	r3, [r7, #16]
 800b682:	f8d3 108c 	ldr.w	r1, [r3, #140]	@ 0x8c
 800b686:	693b      	ldr	r3, [r7, #16]
 800b688:	891a      	ldrh	r2, [r3, #8]
 800b68a:	693b      	ldr	r3, [r7, #16]
 800b68c:	795b      	ldrb	r3, [r3, #5]
 800b68e:	2001      	movs	r0, #1
 800b690:	9000      	str	r0, [sp, #0]
 800b692:	6878      	ldr	r0, [r7, #4]
 800b694:	f001 ffe7 	bl	800d666 <USBH_BulkSendData>
#endif
      }
      else
      {
      }
      break;
 800b698:	e0a8      	b.n	800b7ec <USBH_MSC_BOT_Process+0x380>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 800b69a:	693b      	ldr	r3, [r7, #16]
 800b69c:	2207      	movs	r2, #7
 800b69e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b6a2:	e0a3      	b.n	800b7ec <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_NOTREADY)
 800b6a4:	7d3b      	ldrb	r3, [r7, #20]
 800b6a6:	2b02      	cmp	r3, #2
 800b6a8:	d104      	bne.n	800b6b4 <USBH_MSC_BOT_Process+0x248>
        MSC_Handle->hbot.state  = BOT_DATA_OUT;
 800b6aa:	693b      	ldr	r3, [r7, #16]
 800b6ac:	2205      	movs	r2, #5
 800b6ae:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b6b2:	e09b      	b.n	800b7ec <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_STALL)
 800b6b4:	7d3b      	ldrb	r3, [r7, #20]
 800b6b6:	2b05      	cmp	r3, #5
 800b6b8:	f040 8098 	bne.w	800b7ec <USBH_MSC_BOT_Process+0x380>
        MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 800b6bc:	693b      	ldr	r3, [r7, #16]
 800b6be:	220a      	movs	r2, #10
 800b6c0:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b6c4:	e092      	b.n	800b7ec <USBH_MSC_BOT_Process+0x380>

    case BOT_RECEIVE_CSW:

      (void)USBH_BulkReceiveData(phost, MSC_Handle->hbot.csw.data,
 800b6c6:	693b      	ldr	r3, [r7, #16]
 800b6c8:	f103 0178 	add.w	r1, r3, #120	@ 0x78
 800b6cc:	693b      	ldr	r3, [r7, #16]
 800b6ce:	791b      	ldrb	r3, [r3, #4]
 800b6d0:	220d      	movs	r2, #13
 800b6d2:	6878      	ldr	r0, [r7, #4]
 800b6d4:	f001 ffec 	bl	800d6b0 <USBH_BulkReceiveData>
                                 BOT_CSW_LENGTH, MSC_Handle->InPipe);

      MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
 800b6d8:	693b      	ldr	r3, [r7, #16]
 800b6da:	2208      	movs	r2, #8
 800b6dc:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b6e0:	e08d      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>

    case BOT_RECEIVE_CSW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 800b6e2:	693b      	ldr	r3, [r7, #16]
 800b6e4:	791b      	ldrb	r3, [r3, #4]
 800b6e6:	4619      	mov	r1, r3
 800b6e8:	6878      	ldr	r0, [r7, #4]
 800b6ea:	f023 ff97 	bl	802f61c <USBH_LL_GetURBState>
 800b6ee:	4603      	mov	r3, r0
 800b6f0:	753b      	strb	r3, [r7, #20]

      /* Decode CSW */
      if (URB_Status == USBH_URB_DONE)
 800b6f2:	7d3b      	ldrb	r3, [r7, #20]
 800b6f4:	2b01      	cmp	r3, #1
 800b6f6:	d115      	bne.n	800b724 <USBH_MSC_BOT_Process+0x2b8>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b6f8:	693b      	ldr	r3, [r7, #16]
 800b6fa:	2201      	movs	r2, #1
 800b6fc:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 800b700:	693b      	ldr	r3, [r7, #16]
 800b702:	2201      	movs	r2, #1
 800b704:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
        CSW_Status = USBH_MSC_DecodeCSW(phost);
 800b708:	6878      	ldr	r0, [r7, #4]
 800b70a:	f000 f8a9 	bl	800b860 <USBH_MSC_DecodeCSW>
 800b70e:	4603      	mov	r3, r0
 800b710:	757b      	strb	r3, [r7, #21]

        if (CSW_Status == BOT_CSW_CMD_PASSED)
 800b712:	7d7b      	ldrb	r3, [r7, #21]
 800b714:	2b00      	cmp	r3, #0
 800b716:	d102      	bne.n	800b71e <USBH_MSC_BOT_Process+0x2b2>
        {
          status = USBH_OK;
 800b718:	2300      	movs	r3, #0
 800b71a:	75fb      	strb	r3, [r7, #23]
#endif
      }
      else
      {
      }
      break;
 800b71c:	e068      	b.n	800b7f0 <USBH_MSC_BOT_Process+0x384>
          status = USBH_FAIL;
 800b71e:	2302      	movs	r3, #2
 800b720:	75fb      	strb	r3, [r7, #23]
      break;
 800b722:	e065      	b.n	800b7f0 <USBH_MSC_BOT_Process+0x384>
      else if (URB_Status == USBH_URB_STALL)
 800b724:	7d3b      	ldrb	r3, [r7, #20]
 800b726:	2b05      	cmp	r3, #5
 800b728:	d162      	bne.n	800b7f0 <USBH_MSC_BOT_Process+0x384>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 800b72a:	693b      	ldr	r3, [r7, #16]
 800b72c:	2209      	movs	r2, #9
 800b72e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b732:	e05d      	b.n	800b7f0 <USBH_MSC_BOT_Process+0x384>

    case BOT_ERROR_IN:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
 800b734:	78fb      	ldrb	r3, [r7, #3]
 800b736:	2200      	movs	r2, #0
 800b738:	4619      	mov	r1, r3
 800b73a:	6878      	ldr	r0, [r7, #4]
 800b73c:	f000 f864 	bl	800b808 <USBH_MSC_BOT_Abort>
 800b740:	4603      	mov	r3, r0
 800b742:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 800b744:	7dbb      	ldrb	r3, [r7, #22]
 800b746:	2b00      	cmp	r3, #0
 800b748:	d104      	bne.n	800b754 <USBH_MSC_BOT_Process+0x2e8>
      {
        MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 800b74a:	693b      	ldr	r3, [r7, #16]
 800b74c:	2207      	movs	r2, #7
 800b74e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
      }
      else
      {
      }
      break;
 800b752:	e04f      	b.n	800b7f4 <USBH_MSC_BOT_Process+0x388>
      else if (error == USBH_UNRECOVERED_ERROR)
 800b754:	7dbb      	ldrb	r3, [r7, #22]
 800b756:	2b04      	cmp	r3, #4
 800b758:	d14c      	bne.n	800b7f4 <USBH_MSC_BOT_Process+0x388>
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 800b75a:	693b      	ldr	r3, [r7, #16]
 800b75c:	220b      	movs	r2, #11
 800b75e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b762:	e047      	b.n	800b7f4 <USBH_MSC_BOT_Process+0x388>

    case BOT_ERROR_OUT:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
 800b764:	78fb      	ldrb	r3, [r7, #3]
 800b766:	2201      	movs	r2, #1
 800b768:	4619      	mov	r1, r3
 800b76a:	6878      	ldr	r0, [r7, #4]
 800b76c:	f000 f84c 	bl	800b808 <USBH_MSC_BOT_Abort>
 800b770:	4603      	mov	r3, r0
 800b772:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 800b774:	7dbb      	ldrb	r3, [r7, #22]
 800b776:	2b00      	cmp	r3, #0
 800b778:	d11d      	bne.n	800b7b6 <USBH_MSC_BOT_Process+0x34a>
      {

        toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe);
 800b77a:	693b      	ldr	r3, [r7, #16]
 800b77c:	795b      	ldrb	r3, [r3, #5]
 800b77e:	4619      	mov	r1, r3
 800b780:	6878      	ldr	r0, [r7, #4]
 800b782:	f023 ffa8 	bl	802f6d6 <USBH_LL_GetToggle>
 800b786:	4603      	mov	r3, r0
 800b788:	73fb      	strb	r3, [r7, #15]
        (void)USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1U - toggle);
 800b78a:	693b      	ldr	r3, [r7, #16]
 800b78c:	7959      	ldrb	r1, [r3, #5]
 800b78e:	7bfb      	ldrb	r3, [r7, #15]
 800b790:	f1c3 0301 	rsb	r3, r3, #1
 800b794:	b2db      	uxtb	r3, r3
 800b796:	461a      	mov	r2, r3
 800b798:	6878      	ldr	r0, [r7, #4]
 800b79a:	f023 ff69 	bl	802f670 <USBH_LL_SetToggle>
        (void)USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 800b79e:	693b      	ldr	r3, [r7, #16]
 800b7a0:	791b      	ldrb	r3, [r3, #4]
 800b7a2:	2200      	movs	r2, #0
 800b7a4:	4619      	mov	r1, r3
 800b7a6:	6878      	ldr	r0, [r7, #4]
 800b7a8:	f023 ff62 	bl	802f670 <USBH_LL_SetToggle>
        MSC_Handle->hbot.state = BOT_ERROR_IN;
 800b7ac:	693b      	ldr	r3, [r7, #16]
 800b7ae:	2209      	movs	r2, #9
 800b7b0:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        if (error == USBH_UNRECOVERED_ERROR)
        {
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
        }
      }
      break;
 800b7b4:	e020      	b.n	800b7f8 <USBH_MSC_BOT_Process+0x38c>
        if (error == USBH_UNRECOVERED_ERROR)
 800b7b6:	7dbb      	ldrb	r3, [r7, #22]
 800b7b8:	2b04      	cmp	r3, #4
 800b7ba:	d11d      	bne.n	800b7f8 <USBH_MSC_BOT_Process+0x38c>
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 800b7bc:	693b      	ldr	r3, [r7, #16]
 800b7be:	220b      	movs	r2, #11
 800b7c0:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      break;
 800b7c4:	e018      	b.n	800b7f8 <USBH_MSC_BOT_Process+0x38c>


    case BOT_UNRECOVERED_ERROR:
      status = USBH_MSC_BOT_REQ_Reset(phost);
 800b7c6:	6878      	ldr	r0, [r7, #4]
 800b7c8:	f7ff fdf2 	bl	800b3b0 <USBH_MSC_BOT_REQ_Reset>
 800b7cc:	4603      	mov	r3, r0
 800b7ce:	75fb      	strb	r3, [r7, #23]
      if (status == USBH_OK)
 800b7d0:	7dfb      	ldrb	r3, [r7, #23]
 800b7d2:	2b00      	cmp	r3, #0
 800b7d4:	d112      	bne.n	800b7fc <USBH_MSC_BOT_Process+0x390>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b7d6:	693b      	ldr	r3, [r7, #16]
 800b7d8:	2201      	movs	r2, #1
 800b7da:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      }
      break;
 800b7de:	e00d      	b.n	800b7fc <USBH_MSC_BOT_Process+0x390>

    default:
      break;
 800b7e0:	bf00      	nop
 800b7e2:	e00c      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7e4:	bf00      	nop
 800b7e6:	e00a      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7e8:	bf00      	nop
 800b7ea:	e008      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7ec:	bf00      	nop
 800b7ee:	e006      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7f0:	bf00      	nop
 800b7f2:	e004      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7f4:	bf00      	nop
 800b7f6:	e002      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7f8:	bf00      	nop
 800b7fa:	e000      	b.n	800b7fe <USBH_MSC_BOT_Process+0x392>
      break;
 800b7fc:	bf00      	nop
  }
  return status;
 800b7fe:	7dfb      	ldrb	r3, [r7, #23]
}
 800b800:	4618      	mov	r0, r3
 800b802:	3718      	adds	r7, #24
 800b804:	46bd      	mov	sp, r7
 800b806:	bd80      	pop	{r7, pc}

0800b808 <USBH_MSC_BOT_Abort>:
  * @param  lun: Logical Unit Number
  * @param  dir: direction (0: out / 1 : in)
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
{
 800b808:	b580      	push	{r7, lr}
 800b80a:	b084      	sub	sp, #16
 800b80c:	af00      	add	r7, sp, #0
 800b80e:	6078      	str	r0, [r7, #4]
 800b810:	460b      	mov	r3, r1
 800b812:	70fb      	strb	r3, [r7, #3]
 800b814:	4613      	mov	r3, r2
 800b816:	70bb      	strb	r3, [r7, #2]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(lun);

  USBH_StatusTypeDef status = USBH_FAIL;
 800b818:	2302      	movs	r3, #2
 800b81a:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b81c:	687b      	ldr	r3, [r7, #4]
 800b81e:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b822:	69db      	ldr	r3, [r3, #28]
 800b824:	60bb      	str	r3, [r7, #8]

  switch (dir)
 800b826:	78bb      	ldrb	r3, [r7, #2]
 800b828:	2b00      	cmp	r3, #0
 800b82a:	d002      	beq.n	800b832 <USBH_MSC_BOT_Abort+0x2a>
 800b82c:	2b01      	cmp	r3, #1
 800b82e:	d009      	beq.n	800b844 <USBH_MSC_BOT_Abort+0x3c>
      /*send ClrFeature on Bulk OUT endpoint */
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
      break;

    default:
      break;
 800b830:	e011      	b.n	800b856 <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->InEp);
 800b832:	68bb      	ldr	r3, [r7, #8]
 800b834:	79db      	ldrb	r3, [r3, #7]
 800b836:	4619      	mov	r1, r3
 800b838:	6878      	ldr	r0, [r7, #4]
 800b83a:	f001 f9d1 	bl	800cbe0 <USBH_ClrFeature>
 800b83e:	4603      	mov	r3, r0
 800b840:	73fb      	strb	r3, [r7, #15]
      break;
 800b842:	e008      	b.n	800b856 <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
 800b844:	68bb      	ldr	r3, [r7, #8]
 800b846:	799b      	ldrb	r3, [r3, #6]
 800b848:	4619      	mov	r1, r3
 800b84a:	6878      	ldr	r0, [r7, #4]
 800b84c:	f001 f9c8 	bl	800cbe0 <USBH_ClrFeature>
 800b850:	4603      	mov	r3, r0
 800b852:	73fb      	strb	r3, [r7, #15]
      break;
 800b854:	bf00      	nop
  }
  return status;
 800b856:	7bfb      	ldrb	r3, [r7, #15]
}
 800b858:	4618      	mov	r0, r3
 800b85a:	3710      	adds	r7, #16
 800b85c:	46bd      	mov	sp, r7
 800b85e:	bd80      	pop	{r7, pc}

0800b860 <USBH_MSC_DecodeCSW>:
  *     2. the CSW is 13 (Dh) bytes in length,
  *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
  */

static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
{
 800b860:	b580      	push	{r7, lr}
 800b862:	b084      	sub	sp, #16
 800b864:	af00      	add	r7, sp, #0
 800b866:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b868:	687b      	ldr	r3, [r7, #4]
 800b86a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b86e:	69db      	ldr	r3, [r3, #28]
 800b870:	60bb      	str	r3, [r7, #8]
  BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
 800b872:	2301      	movs	r3, #1
 800b874:	73fb      	strb	r3, [r7, #15]

  /*Checking if the transfer length is different than 13*/
  if (USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
 800b876:	68bb      	ldr	r3, [r7, #8]
 800b878:	791b      	ldrb	r3, [r3, #4]
 800b87a:	4619      	mov	r1, r3
 800b87c:	6878      	ldr	r0, [r7, #4]
 800b87e:	f023 fe3b 	bl	802f4f8 <USBH_LL_GetLastXferSize>
 800b882:	4603      	mov	r3, r0
 800b884:	2b0d      	cmp	r3, #13
 800b886:	d002      	beq.n	800b88e <USBH_MSC_DecodeCSW+0x2e>
    Device intends to transfer no data)
    (11) Ho > Do  (Host expects to send data to the device,
    Device intends to receive data from the host)*/


    status = BOT_CSW_PHASE_ERROR;
 800b888:	2302      	movs	r3, #2
 800b88a:	73fb      	strb	r3, [r7, #15]
 800b88c:	e024      	b.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
  else
  {
    /* CSW length is Correct */

    /* Check validity of the CSW Signature and CSWStatus */
    if (MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
 800b88e:	68bb      	ldr	r3, [r7, #8]
 800b890:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800b892:	4a14      	ldr	r2, [pc, #80]	@ (800b8e4 <USBH_MSC_DecodeCSW+0x84>)
 800b894:	4293      	cmp	r3, r2
 800b896:	d11d      	bne.n	800b8d4 <USBH_MSC_DecodeCSW+0x74>
    {
      /* Check Condition 1. dCSWSignature is equal to 53425355h */

      if (MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
 800b898:	68bb      	ldr	r3, [r7, #8]
 800b89a:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800b89c:	68bb      	ldr	r3, [r7, #8]
 800b89e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b8a0:	429a      	cmp	r2, r3
 800b8a2:	d119      	bne.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
      {
        /* Check Condition 3. dCSWTag matches the dCBWTag from the
        corresponding CBW */

        if (MSC_Handle->hbot.csw.field.Status == 0U)
 800b8a4:	68bb      	ldr	r3, [r7, #8]
 800b8a6:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800b8aa:	2b00      	cmp	r3, #0
 800b8ac:	d102      	bne.n	800b8b4 <USBH_MSC_DecodeCSW+0x54>
          (12) Ho = Do (Host expects to send data to the device,
          Device intends to receive data from the host)

          */

          status = BOT_CSW_CMD_PASSED;
 800b8ae:	2300      	movs	r3, #0
 800b8b0:	73fb      	strb	r3, [r7, #15]
 800b8b2:	e011      	b.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
        }
        else if (MSC_Handle->hbot.csw.field.Status == 1U)
 800b8b4:	68bb      	ldr	r3, [r7, #8]
 800b8b6:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800b8ba:	2b01      	cmp	r3, #1
 800b8bc:	d102      	bne.n	800b8c4 <USBH_MSC_DecodeCSW+0x64>
        {
          status = BOT_CSW_CMD_FAILED;
 800b8be:	2301      	movs	r3, #1
 800b8c0:	73fb      	strb	r3, [r7, #15]
 800b8c2:	e009      	b.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
        }

        else if (MSC_Handle->hbot.csw.field.Status == 2U)
 800b8c4:	68bb      	ldr	r3, [r7, #8]
 800b8c6:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800b8ca:	2b02      	cmp	r3, #2
 800b8cc:	d104      	bne.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
          Di Device intends to send data to the host)
          (13) Ho < Do (Host expects to send data to the device,
          Device intends to receive data from the host)
          */

          status = BOT_CSW_PHASE_ERROR;
 800b8ce:	2302      	movs	r3, #2
 800b8d0:	73fb      	strb	r3, [r7, #15]
 800b8d2:	e001      	b.n	800b8d8 <USBH_MSC_DecodeCSW+0x78>
    else
    {
      /* If the CSW Signature is not valid, We sall return the Phase Error to
      Upper Layers for Reset Recovery */

      status = BOT_CSW_PHASE_ERROR;
 800b8d4:	2302      	movs	r3, #2
 800b8d6:	73fb      	strb	r3, [r7, #15]
    }
  } /* CSW Length Check*/

  return status;
 800b8d8:	7bfb      	ldrb	r3, [r7, #15]
}
 800b8da:	4618      	mov	r0, r3
 800b8dc:	3710      	adds	r7, #16
 800b8de:	46bd      	mov	sp, r7
 800b8e0:	bd80      	pop	{r7, pc}
 800b8e2:	bf00      	nop
 800b8e4:	53425355 	.word	0x53425355

0800b8e8 <USBH_MSC_SCSI_TestUnitReady>:
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady(USBH_HandleTypeDef *phost,
                                               uint8_t lun)
{
 800b8e8:	b580      	push	{r7, lr}
 800b8ea:	b084      	sub	sp, #16
 800b8ec:	af00      	add	r7, sp, #0
 800b8ee:	6078      	str	r0, [r7, #4]
 800b8f0:	460b      	mov	r3, r1
 800b8f2:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800b8f4:	2302      	movs	r3, #2
 800b8f6:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b8f8:	687b      	ldr	r3, [r7, #4]
 800b8fa:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b8fe:	69db      	ldr	r3, [r3, #28]
 800b900:	60bb      	str	r3, [r7, #8]

  switch (MSC_Handle->hbot.cmd_state)
 800b902:	68bb      	ldr	r3, [r7, #8]
 800b904:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800b908:	2b01      	cmp	r3, #1
 800b90a:	d002      	beq.n	800b912 <USBH_MSC_SCSI_TestUnitReady+0x2a>
 800b90c:	2b02      	cmp	r3, #2
 800b90e:	d021      	beq.n	800b954 <USBH_MSC_SCSI_TestUnitReady+0x6c>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800b910:	e028      	b.n	800b964 <USBH_MSC_SCSI_TestUnitReady+0x7c>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;
 800b912:	68bb      	ldr	r3, [r7, #8]
 800b914:	2200      	movs	r2, #0
 800b916:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 800b918:	68bb      	ldr	r3, [r7, #8]
 800b91a:	2200      	movs	r2, #0
 800b91c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800b920:	68bb      	ldr	r3, [r7, #8]
 800b922:	220a      	movs	r2, #10
 800b924:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800b928:	68bb      	ldr	r3, [r7, #8]
 800b92a:	3363      	adds	r3, #99	@ 0x63
 800b92c:	2210      	movs	r2, #16
 800b92e:	2100      	movs	r1, #0
 800b930:	4618      	mov	r0, r3
 800b932:	f024 f835 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY;
 800b936:	68bb      	ldr	r3, [r7, #8]
 800b938:	2200      	movs	r2, #0
 800b93a:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b93e:	68bb      	ldr	r3, [r7, #8]
 800b940:	2201      	movs	r2, #1
 800b942:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800b946:	68bb      	ldr	r3, [r7, #8]
 800b948:	2202      	movs	r2, #2
 800b94a:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      error = USBH_BUSY;
 800b94e:	2301      	movs	r3, #1
 800b950:	73fb      	strb	r3, [r7, #15]
      break;
 800b952:	e007      	b.n	800b964 <USBH_MSC_SCSI_TestUnitReady+0x7c>
      error = USBH_MSC_BOT_Process(phost, lun);
 800b954:	78fb      	ldrb	r3, [r7, #3]
 800b956:	4619      	mov	r1, r3
 800b958:	6878      	ldr	r0, [r7, #4]
 800b95a:	f7ff fd87 	bl	800b46c <USBH_MSC_BOT_Process>
 800b95e:	4603      	mov	r3, r0
 800b960:	73fb      	strb	r3, [r7, #15]
      break;
 800b962:	bf00      	nop
  }

  return error;
 800b964:	7bfb      	ldrb	r3, [r7, #15]
}
 800b966:	4618      	mov	r0, r3
 800b968:	3710      	adds	r7, #16
 800b96a:	46bd      	mov	sp, r7
 800b96c:	bd80      	pop	{r7, pc}

0800b96e <USBH_MSC_SCSI_ReadCapacity>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_CapacityTypeDef *capacity)
{
 800b96e:	b580      	push	{r7, lr}
 800b970:	b086      	sub	sp, #24
 800b972:	af00      	add	r7, sp, #0
 800b974:	60f8      	str	r0, [r7, #12]
 800b976:	460b      	mov	r3, r1
 800b978:	607a      	str	r2, [r7, #4]
 800b97a:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_BUSY;
 800b97c:	2301      	movs	r3, #1
 800b97e:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800b980:	68fb      	ldr	r3, [r7, #12]
 800b982:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800b986:	69db      	ldr	r3, [r3, #28]
 800b988:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800b98a:	693b      	ldr	r3, [r7, #16]
 800b98c:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800b990:	2b01      	cmp	r3, #1
 800b992:	d002      	beq.n	800b99a <USBH_MSC_SCSI_ReadCapacity+0x2c>
 800b994:	2b02      	cmp	r3, #2
 800b996:	d027      	beq.n	800b9e8 <USBH_MSC_SCSI_ReadCapacity+0x7a>
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
      }
      break;

    default:
      break;
 800b998:	e05e      	b.n	800ba58 <USBH_MSC_SCSI_ReadCapacity+0xea>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
 800b99a:	693b      	ldr	r3, [r7, #16]
 800b99c:	2208      	movs	r2, #8
 800b99e:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800b9a0:	693b      	ldr	r3, [r7, #16]
 800b9a2:	2280      	movs	r2, #128	@ 0x80
 800b9a4:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800b9a8:	693b      	ldr	r3, [r7, #16]
 800b9aa:	220a      	movs	r2, #10
 800b9ac:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800b9b0:	693b      	ldr	r3, [r7, #16]
 800b9b2:	3363      	adds	r3, #99	@ 0x63
 800b9b4:	2210      	movs	r2, #16
 800b9b6:	2100      	movs	r1, #0
 800b9b8:	4618      	mov	r0, r3
 800b9ba:	f023 fff1 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10;
 800b9be:	693b      	ldr	r3, [r7, #16]
 800b9c0:	2225      	movs	r2, #37	@ 0x25
 800b9c2:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800b9c6:	693b      	ldr	r3, [r7, #16]
 800b9c8:	2201      	movs	r2, #1
 800b9ca:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800b9ce:	693b      	ldr	r3, [r7, #16]
 800b9d0:	2202      	movs	r2, #2
 800b9d2:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800b9d6:	693b      	ldr	r3, [r7, #16]
 800b9d8:	f103 0210 	add.w	r2, r3, #16
 800b9dc:	693b      	ldr	r3, [r7, #16]
 800b9de:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800b9e2:	2301      	movs	r3, #1
 800b9e4:	75fb      	strb	r3, [r7, #23]
      break;
 800b9e6:	e037      	b.n	800ba58 <USBH_MSC_SCSI_ReadCapacity+0xea>
      error = USBH_MSC_BOT_Process(phost, lun);
 800b9e8:	7afb      	ldrb	r3, [r7, #11]
 800b9ea:	4619      	mov	r1, r3
 800b9ec:	68f8      	ldr	r0, [r7, #12]
 800b9ee:	f7ff fd3d 	bl	800b46c <USBH_MSC_BOT_Process>
 800b9f2:	4603      	mov	r3, r0
 800b9f4:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800b9f6:	7dfb      	ldrb	r3, [r7, #23]
 800b9f8:	2b00      	cmp	r3, #0
 800b9fa:	d12c      	bne.n	800ba56 <USBH_MSC_SCSI_ReadCapacity+0xe8>
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800b9fc:	693b      	ldr	r3, [r7, #16]
 800b9fe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba02:	3303      	adds	r3, #3
 800ba04:	781b      	ldrb	r3, [r3, #0]
 800ba06:	461a      	mov	r2, r3
 800ba08:	693b      	ldr	r3, [r7, #16]
 800ba0a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba0e:	3302      	adds	r3, #2
 800ba10:	781b      	ldrb	r3, [r3, #0]
 800ba12:	021b      	lsls	r3, r3, #8
 800ba14:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 800ba16:	693b      	ldr	r3, [r7, #16]
 800ba18:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba1c:	3301      	adds	r3, #1
 800ba1e:	781b      	ldrb	r3, [r3, #0]
 800ba20:	041b      	lsls	r3, r3, #16
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800ba22:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 800ba24:	693b      	ldr	r3, [r7, #16]
 800ba26:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba2a:	781b      	ldrb	r3, [r3, #0]
 800ba2c:	061b      	lsls	r3, r3, #24
 800ba2e:	431a      	orrs	r2, r3
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 800ba30:	687b      	ldr	r3, [r7, #4]
 800ba32:	601a      	str	r2, [r3, #0]
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
 800ba34:	693b      	ldr	r3, [r7, #16]
 800ba36:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba3a:	3307      	adds	r3, #7
 800ba3c:	781b      	ldrb	r3, [r3, #0]
 800ba3e:	461a      	mov	r2, r3
 800ba40:	693b      	ldr	r3, [r7, #16]
 800ba42:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ba46:	3306      	adds	r3, #6
 800ba48:	781b      	ldrb	r3, [r3, #0]
 800ba4a:	021b      	lsls	r3, r3, #8
 800ba4c:	b29b      	uxth	r3, r3
 800ba4e:	4313      	orrs	r3, r2
 800ba50:	b29a      	uxth	r2, r3
 800ba52:	687b      	ldr	r3, [r7, #4]
 800ba54:	809a      	strh	r2, [r3, #4]
      break;
 800ba56:	bf00      	nop
  }

  return error;
 800ba58:	7dfb      	ldrb	r3, [r7, #23]
}
 800ba5a:	4618      	mov	r0, r3
 800ba5c:	3718      	adds	r7, #24
 800ba5e:	46bd      	mov	sp, r7
 800ba60:	bd80      	pop	{r7, pc}

0800ba62 <USBH_MSC_SCSI_Inquiry>:
  * @param  capacity: pointer to the inquiry structure
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry(USBH_HandleTypeDef *phost, uint8_t lun,
                                         SCSI_StdInquiryDataTypeDef *inquiry)
{
 800ba62:	b580      	push	{r7, lr}
 800ba64:	b086      	sub	sp, #24
 800ba66:	af00      	add	r7, sp, #0
 800ba68:	60f8      	str	r0, [r7, #12]
 800ba6a:	460b      	mov	r3, r1
 800ba6c:	607a      	str	r2, [r7, #4]
 800ba6e:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef error = USBH_FAIL;
 800ba70:	2302      	movs	r3, #2
 800ba72:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800ba74:	68fb      	ldr	r3, [r7, #12]
 800ba76:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800ba7a:	69db      	ldr	r3, [r3, #28]
 800ba7c:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800ba7e:	693b      	ldr	r3, [r7, #16]
 800ba80:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800ba84:	2b01      	cmp	r3, #1
 800ba86:	d002      	beq.n	800ba8e <USBH_MSC_SCSI_Inquiry+0x2c>
 800ba88:	2b02      	cmp	r3, #2
 800ba8a:	d03d      	beq.n	800bb08 <USBH_MSC_SCSI_Inquiry+0xa6>
        (void)USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
      }
      break;

    default:
      break;
 800ba8c:	e089      	b.n	800bba2 <USBH_MSC_SCSI_Inquiry+0x140>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
 800ba8e:	693b      	ldr	r3, [r7, #16]
 800ba90:	2224      	movs	r2, #36	@ 0x24
 800ba92:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800ba94:	693b      	ldr	r3, [r7, #16]
 800ba96:	2280      	movs	r2, #128	@ 0x80
 800ba98:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800ba9c:	693b      	ldr	r3, [r7, #16]
 800ba9e:	220a      	movs	r2, #10
 800baa0:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
 800baa4:	693b      	ldr	r3, [r7, #16]
 800baa6:	3363      	adds	r3, #99	@ 0x63
 800baa8:	220a      	movs	r2, #10
 800baaa:	2100      	movs	r1, #0
 800baac:	4618      	mov	r0, r3
 800baae:	f023 ff77 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY;
 800bab2:	693b      	ldr	r3, [r7, #16]
 800bab4:	2212      	movs	r2, #18
 800bab6:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 800baba:	7afb      	ldrb	r3, [r7, #11]
 800babc:	015b      	lsls	r3, r3, #5
 800babe:	b2da      	uxtb	r2, r3
 800bac0:	693b      	ldr	r3, [r7, #16]
 800bac2:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 800bac6:	693b      	ldr	r3, [r7, #16]
 800bac8:	2200      	movs	r2, #0
 800baca:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 800bace:	693b      	ldr	r3, [r7, #16]
 800bad0:	2200      	movs	r2, #0
 800bad2:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = 0x24U;
 800bad6:	693b      	ldr	r3, [r7, #16]
 800bad8:	2224      	movs	r2, #36	@ 0x24
 800bada:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 800bade:	693b      	ldr	r3, [r7, #16]
 800bae0:	2200      	movs	r2, #0
 800bae2:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bae6:	693b      	ldr	r3, [r7, #16]
 800bae8:	2201      	movs	r2, #1
 800baea:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800baee:	693b      	ldr	r3, [r7, #16]
 800baf0:	2202      	movs	r2, #2
 800baf2:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800baf6:	693b      	ldr	r3, [r7, #16]
 800baf8:	f103 0210 	add.w	r2, r3, #16
 800bafc:	693b      	ldr	r3, [r7, #16]
 800bafe:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bb02:	2301      	movs	r3, #1
 800bb04:	75fb      	strb	r3, [r7, #23]
      break;
 800bb06:	e04c      	b.n	800bba2 <USBH_MSC_SCSI_Inquiry+0x140>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bb08:	7afb      	ldrb	r3, [r7, #11]
 800bb0a:	4619      	mov	r1, r3
 800bb0c:	68f8      	ldr	r0, [r7, #12]
 800bb0e:	f7ff fcad 	bl	800b46c <USBH_MSC_BOT_Process>
 800bb12:	4603      	mov	r3, r0
 800bb14:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800bb16:	7dfb      	ldrb	r3, [r7, #23]
 800bb18:	2b00      	cmp	r3, #0
 800bb1a:	d141      	bne.n	800bba0 <USBH_MSC_SCSI_Inquiry+0x13e>
        (void)USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
 800bb1c:	2222      	movs	r2, #34	@ 0x22
 800bb1e:	2100      	movs	r1, #0
 800bb20:	6878      	ldr	r0, [r7, #4]
 800bb22:	f023 ff3d 	bl	802f9a0 <memset>
        inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1FU;
 800bb26:	693b      	ldr	r3, [r7, #16]
 800bb28:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bb2c:	781b      	ldrb	r3, [r3, #0]
 800bb2e:	f003 031f 	and.w	r3, r3, #31
 800bb32:	b2da      	uxtb	r2, r3
 800bb34:	687b      	ldr	r3, [r7, #4]
 800bb36:	705a      	strb	r2, [r3, #1]
        inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5U;
 800bb38:	693b      	ldr	r3, [r7, #16]
 800bb3a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bb3e:	781b      	ldrb	r3, [r3, #0]
 800bb40:	095b      	lsrs	r3, r3, #5
 800bb42:	b2da      	uxtb	r2, r3
 800bb44:	687b      	ldr	r3, [r7, #4]
 800bb46:	701a      	strb	r2, [r3, #0]
        if (((uint32_t)MSC_Handle->hbot.pbuf[1] & 0x80U) == 0x80U)
 800bb48:	693b      	ldr	r3, [r7, #16]
 800bb4a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bb4e:	3301      	adds	r3, #1
 800bb50:	781b      	ldrb	r3, [r3, #0]
 800bb52:	b25b      	sxtb	r3, r3
 800bb54:	2b00      	cmp	r3, #0
 800bb56:	da03      	bge.n	800bb60 <USBH_MSC_SCSI_Inquiry+0xfe>
          inquiry->RemovableMedia = 1U;
 800bb58:	687b      	ldr	r3, [r7, #4]
 800bb5a:	2201      	movs	r2, #1
 800bb5c:	709a      	strb	r2, [r3, #2]
 800bb5e:	e002      	b.n	800bb66 <USBH_MSC_SCSI_Inquiry+0x104>
          inquiry->RemovableMedia = 0U;
 800bb60:	687b      	ldr	r3, [r7, #4]
 800bb62:	2200      	movs	r2, #0
 800bb64:	709a      	strb	r2, [r3, #2]
        (void)USBH_memcpy(inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8U);
 800bb66:	687b      	ldr	r3, [r7, #4]
 800bb68:	1cd8      	adds	r0, r3, #3
 800bb6a:	693b      	ldr	r3, [r7, #16]
 800bb6c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bb70:	3308      	adds	r3, #8
 800bb72:	2208      	movs	r2, #8
 800bb74:	4619      	mov	r1, r3
 800bb76:	f023 ff57 	bl	802fa28 <memcpy>
        (void)USBH_memcpy(inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16U);
 800bb7a:	687b      	ldr	r3, [r7, #4]
 800bb7c:	f103 000c 	add.w	r0, r3, #12
 800bb80:	693b      	ldr	r3, [r7, #16]
 800bb82:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bb86:	3310      	adds	r3, #16
 800bb88:	2210      	movs	r2, #16
 800bb8a:	4619      	mov	r1, r3
 800bb8c:	f023 ff4c 	bl	802fa28 <memcpy>
        (void)USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	331d      	adds	r3, #29
 800bb94:	693a      	ldr	r2, [r7, #16]
 800bb96:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
 800bb9a:	3220      	adds	r2, #32
 800bb9c:	6812      	ldr	r2, [r2, #0]
 800bb9e:	601a      	str	r2, [r3, #0]
      break;
 800bba0:	bf00      	nop
  }

  return error;
 800bba2:	7dfb      	ldrb	r3, [r7, #23]
}
 800bba4:	4618      	mov	r0, r3
 800bba6:	3718      	adds	r7, #24
 800bba8:	46bd      	mov	sp, r7
 800bbaa:	bd80      	pop	{r7, pc}

0800bbac <USBH_MSC_SCSI_RequestSense>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_SenseTypeDef *sense_data)
{
 800bbac:	b580      	push	{r7, lr}
 800bbae:	b086      	sub	sp, #24
 800bbb0:	af00      	add	r7, sp, #0
 800bbb2:	60f8      	str	r0, [r7, #12]
 800bbb4:	460b      	mov	r3, r1
 800bbb6:	607a      	str	r2, [r7, #4]
 800bbb8:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bbba:	2302      	movs	r3, #2
 800bbbc:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bbbe:	68fb      	ldr	r3, [r7, #12]
 800bbc0:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bbc4:	69db      	ldr	r3, [r3, #28]
 800bbc6:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bbc8:	693b      	ldr	r3, [r7, #16]
 800bbca:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bbce:	2b01      	cmp	r3, #1
 800bbd0:	d002      	beq.n	800bbd8 <USBH_MSC_SCSI_RequestSense+0x2c>
 800bbd2:	2b02      	cmp	r3, #2
 800bbd4:	d03d      	beq.n	800bc52 <USBH_MSC_SCSI_RequestSense+0xa6>
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
      }
      break;

    default:
      break;
 800bbd6:	e05d      	b.n	800bc94 <USBH_MSC_SCSI_RequestSense+0xe8>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
 800bbd8:	693b      	ldr	r3, [r7, #16]
 800bbda:	220e      	movs	r2, #14
 800bbdc:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bbde:	693b      	ldr	r3, [r7, #16]
 800bbe0:	2280      	movs	r2, #128	@ 0x80
 800bbe2:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bbe6:	693b      	ldr	r3, [r7, #16]
 800bbe8:	220a      	movs	r2, #10
 800bbea:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bbee:	693b      	ldr	r3, [r7, #16]
 800bbf0:	3363      	adds	r3, #99	@ 0x63
 800bbf2:	2210      	movs	r2, #16
 800bbf4:	2100      	movs	r1, #0
 800bbf6:	4618      	mov	r0, r3
 800bbf8:	f023 fed2 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE;
 800bbfc:	693b      	ldr	r3, [r7, #16]
 800bbfe:	2203      	movs	r2, #3
 800bc00:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 800bc04:	7afb      	ldrb	r3, [r7, #11]
 800bc06:	015b      	lsls	r3, r3, #5
 800bc08:	b2da      	uxtb	r2, r3
 800bc0a:	693b      	ldr	r3, [r7, #16]
 800bc0c:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 800bc10:	693b      	ldr	r3, [r7, #16]
 800bc12:	2200      	movs	r2, #0
 800bc14:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 800bc18:	693b      	ldr	r3, [r7, #16]
 800bc1a:	2200      	movs	r2, #0
 800bc1c:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
 800bc20:	693b      	ldr	r3, [r7, #16]
 800bc22:	220e      	movs	r2, #14
 800bc24:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 800bc28:	693b      	ldr	r3, [r7, #16]
 800bc2a:	2200      	movs	r2, #0
 800bc2c:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bc30:	693b      	ldr	r3, [r7, #16]
 800bc32:	2201      	movs	r2, #1
 800bc34:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bc38:	693b      	ldr	r3, [r7, #16]
 800bc3a:	2202      	movs	r2, #2
 800bc3c:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 800bc40:	693b      	ldr	r3, [r7, #16]
 800bc42:	f103 0210 	add.w	r2, r3, #16
 800bc46:	693b      	ldr	r3, [r7, #16]
 800bc48:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bc4c:	2301      	movs	r3, #1
 800bc4e:	75fb      	strb	r3, [r7, #23]
      break;
 800bc50:	e020      	b.n	800bc94 <USBH_MSC_SCSI_RequestSense+0xe8>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bc52:	7afb      	ldrb	r3, [r7, #11]
 800bc54:	4619      	mov	r1, r3
 800bc56:	68f8      	ldr	r0, [r7, #12]
 800bc58:	f7ff fc08 	bl	800b46c <USBH_MSC_BOT_Process>
 800bc5c:	4603      	mov	r3, r0
 800bc5e:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 800bc60:	7dfb      	ldrb	r3, [r7, #23]
 800bc62:	2b00      	cmp	r3, #0
 800bc64:	d115      	bne.n	800bc92 <USBH_MSC_SCSI_RequestSense+0xe6>
        sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0FU;
 800bc66:	693b      	ldr	r3, [r7, #16]
 800bc68:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc6c:	3302      	adds	r3, #2
 800bc6e:	781b      	ldrb	r3, [r3, #0]
 800bc70:	f003 030f 	and.w	r3, r3, #15
 800bc74:	b2da      	uxtb	r2, r3
 800bc76:	687b      	ldr	r3, [r7, #4]
 800bc78:	701a      	strb	r2, [r3, #0]
        sense_data->asc  = MSC_Handle->hbot.pbuf[12];
 800bc7a:	693b      	ldr	r3, [r7, #16]
 800bc7c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc80:	7b1a      	ldrb	r2, [r3, #12]
 800bc82:	687b      	ldr	r3, [r7, #4]
 800bc84:	705a      	strb	r2, [r3, #1]
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
 800bc86:	693b      	ldr	r3, [r7, #16]
 800bc88:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800bc8c:	7b5a      	ldrb	r2, [r3, #13]
 800bc8e:	687b      	ldr	r3, [r7, #4]
 800bc90:	709a      	strb	r2, [r3, #2]
      break;
 800bc92:	bf00      	nop
  }

  return error;
 800bc94:	7dfb      	ldrb	r3, [r7, #23]
}
 800bc96:	4618      	mov	r0, r3
 800bc98:	3718      	adds	r7, #24
 800bc9a:	46bd      	mov	sp, r7
 800bc9c:	bd80      	pop	{r7, pc}

0800bc9e <USBH_MSC_SCSI_Write>:
USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
                                       uint8_t lun,
                                       uint32_t address,
                                       uint8_t *pbuf,
                                       uint32_t length)
{
 800bc9e:	b580      	push	{r7, lr}
 800bca0:	b086      	sub	sp, #24
 800bca2:	af00      	add	r7, sp, #0
 800bca4:	60f8      	str	r0, [r7, #12]
 800bca6:	607a      	str	r2, [r7, #4]
 800bca8:	603b      	str	r3, [r7, #0]
 800bcaa:	460b      	mov	r3, r1
 800bcac:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bcae:	2302      	movs	r3, #2
 800bcb0:	75fb      	strb	r3, [r7, #23]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bcb2:	68fb      	ldr	r3, [r7, #12]
 800bcb4:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bcb8:	69db      	ldr	r3, [r3, #28]
 800bcba:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bcbc:	693b      	ldr	r3, [r7, #16]
 800bcbe:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bcc2:	2b01      	cmp	r3, #1
 800bcc4:	d002      	beq.n	800bccc <USBH_MSC_SCSI_Write+0x2e>
 800bcc6:	2b02      	cmp	r3, #2
 800bcc8:	d047      	beq.n	800bd5a <USBH_MSC_SCSI_Write+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800bcca:	e04e      	b.n	800bd6a <USBH_MSC_SCSI_Write+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 800bccc:	693b      	ldr	r3, [r7, #16]
 800bcce:	f8b3 3098 	ldrh.w	r3, [r3, #152]	@ 0x98
 800bcd2:	461a      	mov	r2, r3
 800bcd4:	6a3b      	ldr	r3, [r7, #32]
 800bcd6:	fb03 f202 	mul.w	r2, r3, r2
 800bcda:	693b      	ldr	r3, [r7, #16]
 800bcdc:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 800bcde:	693b      	ldr	r3, [r7, #16]
 800bce0:	2200      	movs	r2, #0
 800bce2:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bce6:	693b      	ldr	r3, [r7, #16]
 800bce8:	220a      	movs	r2, #10
 800bcea:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bcee:	693b      	ldr	r3, [r7, #16]
 800bcf0:	3363      	adds	r3, #99	@ 0x63
 800bcf2:	2210      	movs	r2, #16
 800bcf4:	2100      	movs	r1, #0
 800bcf6:	4618      	mov	r0, r3
 800bcf8:	f023 fe52 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10;
 800bcfc:	693b      	ldr	r3, [r7, #16]
 800bcfe:	222a      	movs	r2, #42	@ 0x2a
 800bd00:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 800bd04:	79fa      	ldrb	r2, [r7, #7]
 800bd06:	693b      	ldr	r3, [r7, #16]
 800bd08:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 800bd0c:	79ba      	ldrb	r2, [r7, #6]
 800bd0e:	693b      	ldr	r3, [r7, #16]
 800bd10:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 800bd14:	797a      	ldrb	r2, [r7, #5]
 800bd16:	693b      	ldr	r3, [r7, #16]
 800bd18:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 800bd1c:	1d3b      	adds	r3, r7, #4
 800bd1e:	781a      	ldrb	r2, [r3, #0]
 800bd20:	693b      	ldr	r3, [r7, #16]
 800bd22:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 800bd26:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800bd2a:	693b      	ldr	r3, [r7, #16]
 800bd2c:	f883 206a 	strb.w	r2, [r3, #106]	@ 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]);
 800bd30:	f107 0320 	add.w	r3, r7, #32
 800bd34:	781a      	ldrb	r2, [r3, #0]
 800bd36:	693b      	ldr	r3, [r7, #16]
 800bd38:	f883 206b 	strb.w	r2, [r3, #107]	@ 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800bd3c:	693b      	ldr	r3, [r7, #16]
 800bd3e:	2201      	movs	r2, #1
 800bd40:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800bd44:	693b      	ldr	r3, [r7, #16]
 800bd46:	2202      	movs	r2, #2
 800bd48:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 800bd4c:	693b      	ldr	r3, [r7, #16]
 800bd4e:	683a      	ldr	r2, [r7, #0]
 800bd50:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800bd54:	2301      	movs	r3, #1
 800bd56:	75fb      	strb	r3, [r7, #23]
      break;
 800bd58:	e007      	b.n	800bd6a <USBH_MSC_SCSI_Write+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 800bd5a:	7afb      	ldrb	r3, [r7, #11]
 800bd5c:	4619      	mov	r1, r3
 800bd5e:	68f8      	ldr	r0, [r7, #12]
 800bd60:	f7ff fb84 	bl	800b46c <USBH_MSC_BOT_Process>
 800bd64:	4603      	mov	r3, r0
 800bd66:	75fb      	strb	r3, [r7, #23]
      break;
 800bd68:	bf00      	nop
  }

  return error;
 800bd6a:	7dfb      	ldrb	r3, [r7, #23]
}
 800bd6c:	4618      	mov	r0, r3
 800bd6e:	3718      	adds	r7, #24
 800bd70:	46bd      	mov	sp, r7
 800bd72:	bd80      	pop	{r7, pc}

0800bd74 <USBH_MSC_SCSI_Read>:
USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
                                      uint8_t lun,
                                      uint32_t address,
                                      uint8_t *pbuf,
                                      uint32_t length)
{
 800bd74:	b580      	push	{r7, lr}
 800bd76:	b086      	sub	sp, #24
 800bd78:	af00      	add	r7, sp, #0
 800bd7a:	60f8      	str	r0, [r7, #12]
 800bd7c:	607a      	str	r2, [r7, #4]
 800bd7e:	603b      	str	r3, [r7, #0]
 800bd80:	460b      	mov	r3, r1
 800bd82:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL;
 800bd84:	2302      	movs	r3, #2
 800bd86:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800bd88:	68fb      	ldr	r3, [r7, #12]
 800bd8a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800bd8e:	69db      	ldr	r3, [r3, #28]
 800bd90:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800bd92:	693b      	ldr	r3, [r7, #16]
 800bd94:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
 800bd98:	2b01      	cmp	r3, #1
 800bd9a:	d002      	beq.n	800bda2 <USBH_MSC_SCSI_Read+0x2e>
 800bd9c:	2b02      	cmp	r3, #2
 800bd9e:	d047      	beq.n	800be30 <USBH_MSC_SCSI_Read+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800bda0:	e04e      	b.n	800be40 <USBH_MSC_SCSI_Read+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 800bda2:	693b      	ldr	r3, [r7, #16]
 800bda4:	f8b3 3098 	ldrh.w	r3, [r3, #152]	@ 0x98
 800bda8:	461a      	mov	r2, r3
 800bdaa:	6a3b      	ldr	r3, [r7, #32]
 800bdac:	fb03 f202 	mul.w	r2, r3, r2
 800bdb0:	693b      	ldr	r3, [r7, #16]
 800bdb2:	65da      	str	r2, [r3, #92]	@ 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 800bdb4:	693b      	ldr	r3, [r7, #16]
 800bdb6:	2280      	movs	r2, #128	@ 0x80
 800bdb8:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800bdbc:	693b      	ldr	r3, [r7, #16]
 800bdbe:	220a      	movs	r2, #10
 800bdc0:	f883 2062 	strb.w	r2, [r3, #98]	@ 0x62
      (void)USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 800bdc4:	693b      	ldr	r3, [r7, #16]
 800bdc6:	3363      	adds	r3, #99	@ 0x63
 800bdc8:	2210      	movs	r2, #16
 800bdca:	2100      	movs	r1, #0
 800bdcc:	4618      	mov	r0, r3
 800bdce:	f023 fde7 	bl	802f9a0 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10;
 800bdd2:	693b      	ldr	r3, [r7, #16]
 800bdd4:	2228      	movs	r2, #40	@ 0x28
 800bdd6:	f883 2063 	strb.w	r2, [r3, #99]	@ 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 800bdda:	79fa      	ldrb	r2, [r7, #7]
 800bddc:	693b      	ldr	r3, [r7, #16]
 800bdde:	f883 2065 	strb.w	r2, [r3, #101]	@ 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 800bde2:	79ba      	ldrb	r2, [r7, #6]
 800bde4:	693b      	ldr	r3, [r7, #16]
 800bde6:	f883 2066 	strb.w	r2, [r3, #102]	@ 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 800bdea:	797a      	ldrb	r2, [r7, #5]
 800bdec:	693b      	ldr	r3, [r7, #16]
 800bdee:	f883 2067 	strb.w	r2, [r3, #103]	@ 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 800bdf2:	1d3b      	adds	r3, r7, #4
 800bdf4:	781a      	ldrb	r2, [r3, #0]
 800bdf6:	693b      	ldr	r3, [r7, #16]
 800bdf8:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]);
 800bdfc:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800be00:	693b      	ldr	r3, [r7, #16]
 800be02:	f883 206a 	strb.w	r2, [r3, #106]	@ 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]);
 800be06:	f107 0320 	add.w	r3, r7, #32
 800be0a:	781a      	ldrb	r2, [r3, #0]
 800be0c:	693b      	ldr	r3, [r7, #16]
 800be0e:	f883 206b 	strb.w	r2, [r3, #107]	@ 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800be12:	693b      	ldr	r3, [r7, #16]
 800be14:	2201      	movs	r2, #1
 800be16:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800be1a:	693b      	ldr	r3, [r7, #16]
 800be1c:	2202      	movs	r2, #2
 800be1e:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 800be22:	693b      	ldr	r3, [r7, #16]
 800be24:	683a      	ldr	r2, [r7, #0]
 800be26:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      error = USBH_BUSY;
 800be2a:	2301      	movs	r3, #1
 800be2c:	75fb      	strb	r3, [r7, #23]
      break;
 800be2e:	e007      	b.n	800be40 <USBH_MSC_SCSI_Read+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 800be30:	7afb      	ldrb	r3, [r7, #11]
 800be32:	4619      	mov	r1, r3
 800be34:	68f8      	ldr	r0, [r7, #12]
 800be36:	f7ff fb19 	bl	800b46c <USBH_MSC_BOT_Process>
 800be3a:	4603      	mov	r3, r0
 800be3c:	75fb      	strb	r3, [r7, #23]
      break;
 800be3e:	bf00      	nop
  }

  return error;
 800be40:	7dfb      	ldrb	r3, [r7, #23]
}
 800be42:	4618      	mov	r0, r3
 800be44:	3718      	adds	r7, #24
 800be46:	46bd      	mov	sp, r7
 800be48:	bd80      	pop	{r7, pc}

0800be4a <USBH_Init>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Init(USBH_HandleTypeDef *phost,
                             void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                                              uint8_t id), uint8_t id)
{
 800be4a:	b580      	push	{r7, lr}
 800be4c:	b084      	sub	sp, #16
 800be4e:	af00      	add	r7, sp, #0
 800be50:	60f8      	str	r0, [r7, #12]
 800be52:	60b9      	str	r1, [r7, #8]
 800be54:	4613      	mov	r3, r2
 800be56:	71fb      	strb	r3, [r7, #7]
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 800be58:	68fb      	ldr	r3, [r7, #12]
 800be5a:	2b00      	cmp	r3, #0
 800be5c:	d101      	bne.n	800be62 <USBH_Init+0x18>
  {
    USBH_ErrLog("Invalid Host handle");
    return USBH_FAIL;
 800be5e:	2302      	movs	r3, #2
 800be60:	e029      	b.n	800beb6 <USBH_Init+0x6c>
  }

  /* Set DRiver ID */
  phost->id = id;
 800be62:	68fb      	ldr	r3, [r7, #12]
 800be64:	79fa      	ldrb	r2, [r7, #7]
 800be66:	f883 23cc 	strb.w	r2, [r3, #972]	@ 0x3cc

  /* Unlink class*/
  phost->pActiveClass = NULL;
 800be6a:	68fb      	ldr	r3, [r7, #12]
 800be6c:	2200      	movs	r2, #0
 800be6e:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
  phost->ClassNumber = 0U;
 800be72:	68fb      	ldr	r3, [r7, #12]
 800be74:	2200      	movs	r2, #0
 800be76:	f8c3 2380 	str.w	r2, [r3, #896]	@ 0x380

  /* Restore default states and prepare EP0 */
  (void)DeInitStateMachine(phost);
 800be7a:	68f8      	ldr	r0, [r7, #12]
 800be7c:	f000 f81f 	bl	800bebe <DeInitStateMachine>

  /* Restore default Device connection states */
  phost->device.PortEnabled = 0U;
 800be80:	68fb      	ldr	r3, [r7, #12]
 800be82:	2200      	movs	r2, #0
 800be84:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323
  phost->device.is_connected = 0U;
 800be88:	68fb      	ldr	r3, [r7, #12]
 800be8a:	2200      	movs	r2, #0
 800be8c:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.is_disconnected = 0U;
 800be90:	68fb      	ldr	r3, [r7, #12]
 800be92:	2200      	movs	r2, #0
 800be94:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_ReEnumerated = 0U;
 800be98:	68fb      	ldr	r3, [r7, #12]
 800be9a:	2200      	movs	r2, #0
 800be9c:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322

  /* Assign User process */
  if (pUsrFunc != NULL)
 800bea0:	68bb      	ldr	r3, [r7, #8]
 800bea2:	2b00      	cmp	r3, #0
 800bea4:	d003      	beq.n	800beae <USBH_Init+0x64>
  {
    phost->pUser = pUsrFunc;
 800bea6:	68fb      	ldr	r3, [r7, #12]
 800bea8:	68ba      	ldr	r2, [r7, #8]
 800beaa:	f8c3 23d4 	str.w	r2, [r3, #980]	@ 0x3d4

#endif /* (osCMSIS < 0x20000U) */
#endif /* (USBH_USE_OS == 1U) */

  /* Initialize low level driver */
  (void)USBH_LL_Init(phost);
 800beae:	68f8      	ldr	r0, [r7, #12]
 800beb0:	f023 fa6e 	bl	802f390 <USBH_LL_Init>

  return USBH_OK;
 800beb4:	2300      	movs	r3, #0
}
 800beb6:	4618      	mov	r0, r3
 800beb8:	3710      	adds	r7, #16
 800beba:	46bd      	mov	sp, r7
 800bebc:	bd80      	pop	{r7, pc}

0800bebe <DeInitStateMachine>:
  *         De-Initialize the Host state machine.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
{
 800bebe:	b580      	push	{r7, lr}
 800bec0:	b084      	sub	sp, #16
 800bec2:	af00      	add	r7, sp, #0
 800bec4:	6078      	str	r0, [r7, #4]
  uint32_t i = 0U;
 800bec6:	2300      	movs	r3, #0
 800bec8:	60fb      	str	r3, [r7, #12]

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 800beca:	2300      	movs	r3, #0
 800becc:	60fb      	str	r3, [r7, #12]
 800bece:	e009      	b.n	800bee4 <DeInitStateMachine+0x26>
  {
    phost->Pipes[i] = 0U;
 800bed0:	687a      	ldr	r2, [r7, #4]
 800bed2:	68fb      	ldr	r3, [r7, #12]
 800bed4:	33e0      	adds	r3, #224	@ 0xe0
 800bed6:	009b      	lsls	r3, r3, #2
 800bed8:	4413      	add	r3, r2
 800beda:	2200      	movs	r2, #0
 800bedc:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 800bede:	68fb      	ldr	r3, [r7, #12]
 800bee0:	3301      	adds	r3, #1
 800bee2:	60fb      	str	r3, [r7, #12]
 800bee4:	68fb      	ldr	r3, [r7, #12]
 800bee6:	2b0f      	cmp	r3, #15
 800bee8:	d9f2      	bls.n	800bed0 <DeInitStateMachine+0x12>
  }

  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 800beea:	2300      	movs	r3, #0
 800beec:	60fb      	str	r3, [r7, #12]
 800beee:	e009      	b.n	800bf04 <DeInitStateMachine+0x46>
  {
    phost->device.Data[i] = 0U;
 800bef0:	687a      	ldr	r2, [r7, #4]
 800bef2:	68fb      	ldr	r3, [r7, #12]
 800bef4:	4413      	add	r3, r2
 800bef6:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800befa:	2200      	movs	r2, #0
 800befc:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 800befe:	68fb      	ldr	r3, [r7, #12]
 800bf00:	3301      	adds	r3, #1
 800bf02:	60fb      	str	r3, [r7, #12]
 800bf04:	68fb      	ldr	r3, [r7, #12]
 800bf06:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800bf0a:	d3f1      	bcc.n	800bef0 <DeInitStateMachine+0x32>
  }

  phost->gState = HOST_IDLE;
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	2200      	movs	r2, #0
 800bf10:	701a      	strb	r2, [r3, #0]
  phost->EnumState = ENUM_IDLE;
 800bf12:	687b      	ldr	r3, [r7, #4]
 800bf14:	2200      	movs	r2, #0
 800bf16:	705a      	strb	r2, [r3, #1]
  phost->RequestState = CMD_SEND;
 800bf18:	687b      	ldr	r3, [r7, #4]
 800bf1a:	2201      	movs	r2, #1
 800bf1c:	709a      	strb	r2, [r3, #2]
  phost->Timer = 0U;
 800bf1e:	687b      	ldr	r3, [r7, #4]
 800bf20:	2200      	movs	r2, #0
 800bf22:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4

  phost->Control.state = CTRL_SETUP;
 800bf26:	687b      	ldr	r3, [r7, #4]
 800bf28:	2201      	movs	r2, #1
 800bf2a:	761a      	strb	r2, [r3, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800bf2c:	687b      	ldr	r3, [r7, #4]
 800bf2e:	2240      	movs	r2, #64	@ 0x40
 800bf30:	719a      	strb	r2, [r3, #6]
  phost->Control.errorcount = 0U;
 800bf32:	687b      	ldr	r3, [r7, #4]
 800bf34:	2200      	movs	r2, #0
 800bf36:	765a      	strb	r2, [r3, #25]

  phost->device.address = USBH_ADDRESS_DEFAULT;
 800bf38:	687b      	ldr	r3, [r7, #4]
 800bf3a:	2200      	movs	r2, #0
 800bf3c:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c
  phost->device.speed = (uint8_t)USBH_SPEED_FULL;
 800bf40:	687b      	ldr	r3, [r7, #4]
 800bf42:	2201      	movs	r2, #1
 800bf44:	f883 231d 	strb.w	r2, [r3, #797]	@ 0x31d
  phost->device.RstCnt = 0U;
 800bf48:	687b      	ldr	r3, [r7, #4]
 800bf4a:	2200      	movs	r2, #0
 800bf4c:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
  phost->device.EnumCnt = 0U;
 800bf50:	687b      	ldr	r3, [r7, #4]
 800bf52:	2200      	movs	r2, #0
 800bf54:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e

  /* Reset the device struct */
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 800bf58:	687b      	ldr	r3, [r7, #4]
 800bf5a:	331c      	adds	r3, #28
 800bf5c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800bf60:	2100      	movs	r1, #0
 800bf62:	4618      	mov	r0, r3
 800bf64:	f023 fd1c 	bl	802f9a0 <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 800bf68:	687b      	ldr	r3, [r7, #4]
 800bf6a:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800bf6e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800bf72:	2100      	movs	r1, #0
 800bf74:	4618      	mov	r0, r3
 800bf76:	f023 fd13 	bl	802f9a0 <memset>
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 800bf7a:	687b      	ldr	r3, [r7, #4]
 800bf7c:	f203 3326 	addw	r3, r3, #806	@ 0x326
 800bf80:	2212      	movs	r2, #18
 800bf82:	2100      	movs	r1, #0
 800bf84:	4618      	mov	r0, r3
 800bf86:	f023 fd0b 	bl	802f9a0 <memset>
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 800bf8a:	687b      	ldr	r3, [r7, #4]
 800bf8c:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800bf90:	223e      	movs	r2, #62	@ 0x3e
 800bf92:	2100      	movs	r1, #0
 800bf94:	4618      	mov	r0, r3
 800bf96:	f023 fd03 	bl	802f9a0 <memset>

  return USBH_OK;
 800bf9a:	2300      	movs	r3, #0
}
 800bf9c:	4618      	mov	r0, r3
 800bf9e:	3710      	adds	r7, #16
 800bfa0:	46bd      	mov	sp, r7
 800bfa2:	bd80      	pop	{r7, pc}

0800bfa4 <USBH_RegisterClass>:
  * @param  phost : Host Handle
  * @param  pclass: Class handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
 800bfa4:	b480      	push	{r7}
 800bfa6:	b085      	sub	sp, #20
 800bfa8:	af00      	add	r7, sp, #0
 800bfaa:	6078      	str	r0, [r7, #4]
 800bfac:	6039      	str	r1, [r7, #0]
  USBH_StatusTypeDef status = USBH_OK;
 800bfae:	2300      	movs	r3, #0
 800bfb0:	73fb      	strb	r3, [r7, #15]

  if (pclass != NULL)
 800bfb2:	683b      	ldr	r3, [r7, #0]
 800bfb4:	2b00      	cmp	r3, #0
 800bfb6:	d016      	beq.n	800bfe6 <USBH_RegisterClass+0x42>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 800bfb8:	687b      	ldr	r3, [r7, #4]
 800bfba:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800bfbe:	2b00      	cmp	r3, #0
 800bfc0:	d10e      	bne.n	800bfe0 <USBH_RegisterClass+0x3c>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 800bfc2:	687b      	ldr	r3, [r7, #4]
 800bfc4:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800bfc8:	1c59      	adds	r1, r3, #1
 800bfca:	687a      	ldr	r2, [r7, #4]
 800bfcc:	f8c2 1380 	str.w	r1, [r2, #896]	@ 0x380
 800bfd0:	687a      	ldr	r2, [r7, #4]
 800bfd2:	33de      	adds	r3, #222	@ 0xde
 800bfd4:	6839      	ldr	r1, [r7, #0]
 800bfd6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      status = USBH_OK;
 800bfda:	2300      	movs	r3, #0
 800bfdc:	73fb      	strb	r3, [r7, #15]
 800bfde:	e004      	b.n	800bfea <USBH_RegisterClass+0x46>
    }
    else
    {
      USBH_ErrLog("Max Class Number reached");
      status = USBH_FAIL;
 800bfe0:	2302      	movs	r3, #2
 800bfe2:	73fb      	strb	r3, [r7, #15]
 800bfe4:	e001      	b.n	800bfea <USBH_RegisterClass+0x46>
    }
  }
  else
  {
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
 800bfe6:	2302      	movs	r3, #2
 800bfe8:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800bfea:	7bfb      	ldrb	r3, [r7, #15]
}
 800bfec:	4618      	mov	r0, r3
 800bfee:	3714      	adds	r7, #20
 800bff0:	46bd      	mov	sp, r7
 800bff2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bff6:	4770      	bx	lr

0800bff8 <USBH_SelectInterface>:
  * @param  phost: Host Handle
  * @param  interface: Interface number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
 800bff8:	b480      	push	{r7}
 800bffa:	b085      	sub	sp, #20
 800bffc:	af00      	add	r7, sp, #0
 800bffe:	6078      	str	r0, [r7, #4]
 800c000:	460b      	mov	r3, r1
 800c002:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef status = USBH_OK;
 800c004:	2300      	movs	r3, #0
 800c006:	73fb      	strb	r3, [r7, #15]

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 800c008:	687b      	ldr	r3, [r7, #4]
 800c00a:	f893 333c 	ldrb.w	r3, [r3, #828]	@ 0x33c
 800c00e:	78fa      	ldrb	r2, [r7, #3]
 800c010:	429a      	cmp	r2, r3
 800c012:	d204      	bcs.n	800c01e <USBH_SelectInterface+0x26>
  {
    phost->device.current_interface = interface;
 800c014:	687b      	ldr	r3, [r7, #4]
 800c016:	78fa      	ldrb	r2, [r7, #3]
 800c018:	f883 2324 	strb.w	r2, [r3, #804]	@ 0x324
 800c01c:	e001      	b.n	800c022 <USBH_SelectInterface+0x2a>
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
 800c01e:	2302      	movs	r3, #2
 800c020:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800c022:	7bfb      	ldrb	r3, [r7, #15]
}
 800c024:	4618      	mov	r0, r3
 800c026:	3714      	adds	r7, #20
 800c028:	46bd      	mov	sp, r7
 800c02a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c02e:	4770      	bx	lr

0800c030 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 800c030:	b480      	push	{r7}
 800c032:	b087      	sub	sp, #28
 800c034:	af00      	add	r7, sp, #0
 800c036:	6078      	str	r0, [r7, #4]
 800c038:	4608      	mov	r0, r1
 800c03a:	4611      	mov	r1, r2
 800c03c:	461a      	mov	r2, r3
 800c03e:	4603      	mov	r3, r0
 800c040:	70fb      	strb	r3, [r7, #3]
 800c042:	460b      	mov	r3, r1
 800c044:	70bb      	strb	r3, [r7, #2]
 800c046:	4613      	mov	r3, r2
 800c048:	707b      	strb	r3, [r7, #1]
  USBH_InterfaceDescTypeDef *pif;
  USBH_CfgDescTypeDef *pcfg;
  uint8_t if_ix = 0U;
 800c04a:	2300      	movs	r3, #0
 800c04c:	75fb      	strb	r3, [r7, #23]

  pif = (USBH_InterfaceDescTypeDef *)NULL;
 800c04e:	2300      	movs	r3, #0
 800c050:	613b      	str	r3, [r7, #16]
  pcfg = &phost->device.CfgDesc;
 800c052:	687b      	ldr	r3, [r7, #4]
 800c054:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800c058:	60fb      	str	r3, [r7, #12]

  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c05a:	e025      	b.n	800c0a8 <USBH_FindInterface+0x78>
  {
    pif = &pcfg->Itf_Desc[if_ix];
 800c05c:	7dfb      	ldrb	r3, [r7, #23]
 800c05e:	221a      	movs	r2, #26
 800c060:	fb02 f303 	mul.w	r3, r2, r3
 800c064:	3308      	adds	r3, #8
 800c066:	68fa      	ldr	r2, [r7, #12]
 800c068:	4413      	add	r3, r2
 800c06a:	3302      	adds	r3, #2
 800c06c:	613b      	str	r3, [r7, #16]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c06e:	693b      	ldr	r3, [r7, #16]
 800c070:	795b      	ldrb	r3, [r3, #5]
 800c072:	78fa      	ldrb	r2, [r7, #3]
 800c074:	429a      	cmp	r2, r3
 800c076:	d002      	beq.n	800c07e <USBH_FindInterface+0x4e>
 800c078:	78fb      	ldrb	r3, [r7, #3]
 800c07a:	2bff      	cmp	r3, #255	@ 0xff
 800c07c:	d111      	bne.n	800c0a2 <USBH_FindInterface+0x72>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c07e:	693b      	ldr	r3, [r7, #16]
 800c080:	799b      	ldrb	r3, [r3, #6]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800c082:	78ba      	ldrb	r2, [r7, #2]
 800c084:	429a      	cmp	r2, r3
 800c086:	d002      	beq.n	800c08e <USBH_FindInterface+0x5e>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c088:	78bb      	ldrb	r3, [r7, #2]
 800c08a:	2bff      	cmp	r3, #255	@ 0xff
 800c08c:	d109      	bne.n	800c0a2 <USBH_FindInterface+0x72>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800c08e:	693b      	ldr	r3, [r7, #16]
 800c090:	79db      	ldrb	r3, [r3, #7]
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800c092:	787a      	ldrb	r2, [r7, #1]
 800c094:	429a      	cmp	r2, r3
 800c096:	d002      	beq.n	800c09e <USBH_FindInterface+0x6e>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800c098:	787b      	ldrb	r3, [r7, #1]
 800c09a:	2bff      	cmp	r3, #255	@ 0xff
 800c09c:	d101      	bne.n	800c0a2 <USBH_FindInterface+0x72>
    {
      return  if_ix;
 800c09e:	7dfb      	ldrb	r3, [r7, #23]
 800c0a0:	e006      	b.n	800c0b0 <USBH_FindInterface+0x80>
    }
    if_ix++;
 800c0a2:	7dfb      	ldrb	r3, [r7, #23]
 800c0a4:	3301      	adds	r3, #1
 800c0a6:	75fb      	strb	r3, [r7, #23]
  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800c0a8:	7dfb      	ldrb	r3, [r7, #23]
 800c0aa:	2b01      	cmp	r3, #1
 800c0ac:	d9d6      	bls.n	800c05c <USBH_FindInterface+0x2c>
  }
  return 0xFFU;
 800c0ae:	23ff      	movs	r3, #255	@ 0xff
}
 800c0b0:	4618      	mov	r0, r3
 800c0b2:	371c      	adds	r7, #28
 800c0b4:	46bd      	mov	sp, r7
 800c0b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0ba:	4770      	bx	lr

0800c0bc <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Start(USBH_HandleTypeDef *phost)
{
 800c0bc:	b580      	push	{r7, lr}
 800c0be:	b082      	sub	sp, #8
 800c0c0:	af00      	add	r7, sp, #0
 800c0c2:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  (void)USBH_LL_Start(phost);
 800c0c4:	6878      	ldr	r0, [r7, #4]
 800c0c6:	f023 f99f 	bl	802f408 <USBH_LL_Start>

  /* Activate VBUS on the port */
  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800c0ca:	2101      	movs	r1, #1
 800c0cc:	6878      	ldr	r0, [r7, #4]
 800c0ce:	f023 fab8 	bl	802f642 <USBH_LL_DriverVBUS>

  return USBH_OK;
 800c0d2:	2300      	movs	r3, #0
}
 800c0d4:	4618      	mov	r0, r3
 800c0d6:	3708      	adds	r7, #8
 800c0d8:	46bd      	mov	sp, r7
 800c0da:	bd80      	pop	{r7, pc}

0800c0dc <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Process(USBH_HandleTypeDef *phost)
{
 800c0dc:	b580      	push	{r7, lr}
 800c0de:	b088      	sub	sp, #32
 800c0e0:	af04      	add	r7, sp, #16
 800c0e2:	6078      	str	r0, [r7, #4]
  volatile USBH_StatusTypeDef status = USBH_FAIL;
 800c0e4:	2302      	movs	r3, #2
 800c0e6:	73bb      	strb	r3, [r7, #14]
  uint8_t idx = 0U;
 800c0e8:	2300      	movs	r3, #0
 800c0ea:	73fb      	strb	r3, [r7, #15]

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 800c0ec:	687b      	ldr	r3, [r7, #4]
 800c0ee:	f893 3321 	ldrb.w	r3, [r3, #801]	@ 0x321
 800c0f2:	b2db      	uxtb	r3, r3
 800c0f4:	2b01      	cmp	r3, #1
 800c0f6:	d102      	bne.n	800c0fe <USBH_Process+0x22>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 800c0f8:	687b      	ldr	r3, [r7, #4]
 800c0fa:	2203      	movs	r2, #3
 800c0fc:	701a      	strb	r2, [r3, #0]
  }

  switch (phost->gState)
 800c0fe:	687b      	ldr	r3, [r7, #4]
 800c100:	781b      	ldrb	r3, [r3, #0]
 800c102:	b2db      	uxtb	r3, r3
 800c104:	2b0b      	cmp	r3, #11
 800c106:	f200 81bb 	bhi.w	800c480 <USBH_Process+0x3a4>
 800c10a:	a201      	add	r2, pc, #4	@ (adr r2, 800c110 <USBH_Process+0x34>)
 800c10c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c110:	0800c141 	.word	0x0800c141
 800c114:	0800c173 	.word	0x0800c173
 800c118:	0800c1db 	.word	0x0800c1db
 800c11c:	0800c41b 	.word	0x0800c41b
 800c120:	0800c481 	.word	0x0800c481
 800c124:	0800c27b 	.word	0x0800c27b
 800c128:	0800c3c1 	.word	0x0800c3c1
 800c12c:	0800c2b1 	.word	0x0800c2b1
 800c130:	0800c2d1 	.word	0x0800c2d1
 800c134:	0800c2ef 	.word	0x0800c2ef
 800c138:	0800c333 	.word	0x0800c333
 800c13c:	0800c403 	.word	0x0800c403
  {
    case HOST_IDLE :

      if ((phost->device.is_connected) != 0U)
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	f893 3320 	ldrb.w	r3, [r3, #800]	@ 0x320
 800c146:	b2db      	uxtb	r3, r3
 800c148:	2b00      	cmp	r3, #0
 800c14a:	f000 819b 	beq.w	800c484 <USBH_Process+0x3a8>
      {
        USBH_UsrLog("USB Device Connected");

        /* Wait for 200 ms after connection */
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800c14e:	687b      	ldr	r3, [r7, #4]
 800c150:	2201      	movs	r2, #1
 800c152:	701a      	strb	r2, [r3, #0]
        USBH_Delay(200U);
 800c154:	20c8      	movs	r0, #200	@ 0xc8
 800c156:	f023 faf1 	bl	802f73c <USBH_Delay>
        (void)USBH_LL_ResetPort(phost);
 800c15a:	6878      	ldr	r0, [r7, #4]
 800c15c:	f023 f9b1 	bl	802f4c2 <USBH_LL_ResetPort>

        /* Make sure to start with Default address */
        phost->device.address = USBH_ADDRESS_DEFAULT;
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	2200      	movs	r2, #0
 800c164:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c
        phost->Timeout = 0U;
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	2200      	movs	r2, #0
 800c16c:	f8c3 23c8 	str.w	r2, [r3, #968]	@ 0x3c8
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c170:	e188      	b.n	800c484 <USBH_Process+0x3a8>

    case HOST_DEV_WAIT_FOR_ATTACHMENT: /* Wait for Port Enabled */

      if (phost->device.PortEnabled == 1U)
 800c172:	687b      	ldr	r3, [r7, #4]
 800c174:	f893 3323 	ldrb.w	r3, [r3, #803]	@ 0x323
 800c178:	2b01      	cmp	r3, #1
 800c17a:	d107      	bne.n	800c18c <USBH_Process+0xb0>
      {
        USBH_UsrLog("USB Device Reset Completed");
        phost->device.RstCnt = 0U;
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	2200      	movs	r2, #0
 800c180:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	2202      	movs	r2, #2
 800c188:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c18a:	e18a      	b.n	800c4a2 <USBH_Process+0x3c6>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 800c18c:	687b      	ldr	r3, [r7, #4]
 800c18e:	f8d3 33c8 	ldr.w	r3, [r3, #968]	@ 0x3c8
 800c192:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800c196:	d914      	bls.n	800c1c2 <USBH_Process+0xe6>
          phost->device.RstCnt++;
 800c198:	687b      	ldr	r3, [r7, #4]
 800c19a:	f893 331f 	ldrb.w	r3, [r3, #799]	@ 0x31f
 800c19e:	3301      	adds	r3, #1
 800c1a0:	b2da      	uxtb	r2, r3
 800c1a2:	687b      	ldr	r3, [r7, #4]
 800c1a4:	f883 231f 	strb.w	r2, [r3, #799]	@ 0x31f
          if (phost->device.RstCnt > 3U)
 800c1a8:	687b      	ldr	r3, [r7, #4]
 800c1aa:	f893 331f 	ldrb.w	r3, [r3, #799]	@ 0x31f
 800c1ae:	2b03      	cmp	r3, #3
 800c1b0:	d903      	bls.n	800c1ba <USBH_Process+0xde>
            phost->gState = HOST_ABORT_STATE;
 800c1b2:	687b      	ldr	r3, [r7, #4]
 800c1b4:	220d      	movs	r2, #13
 800c1b6:	701a      	strb	r2, [r3, #0]
      break;
 800c1b8:	e173      	b.n	800c4a2 <USBH_Process+0x3c6>
            phost->gState = HOST_IDLE;
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	2200      	movs	r2, #0
 800c1be:	701a      	strb	r2, [r3, #0]
      break;
 800c1c0:	e16f      	b.n	800c4a2 <USBH_Process+0x3c6>
          phost->Timeout += 10U;
 800c1c2:	687b      	ldr	r3, [r7, #4]
 800c1c4:	f8d3 33c8 	ldr.w	r3, [r3, #968]	@ 0x3c8
 800c1c8:	f103 020a 	add.w	r2, r3, #10
 800c1cc:	687b      	ldr	r3, [r7, #4]
 800c1ce:	f8c3 23c8 	str.w	r2, [r3, #968]	@ 0x3c8
          USBH_Delay(10U);
 800c1d2:	200a      	movs	r0, #10
 800c1d4:	f023 fab2 	bl	802f73c <USBH_Delay>
      break;
 800c1d8:	e163      	b.n	800c4a2 <USBH_Process+0x3c6>

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c1e0:	2b00      	cmp	r3, #0
 800c1e2:	d005      	beq.n	800c1f0 <USBH_Process+0x114>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 800c1e4:	687b      	ldr	r3, [r7, #4]
 800c1e6:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c1ea:	2104      	movs	r1, #4
 800c1ec:	6878      	ldr	r0, [r7, #4]
 800c1ee:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 800c1f0:	2064      	movs	r0, #100	@ 0x64
 800c1f2:	f023 faa3 	bl	802f73c <USBH_Delay>

      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 800c1f6:	6878      	ldr	r0, [r7, #4]
 800c1f8:	f023 f93c 	bl	802f474 <USBH_LL_GetSpeed>
 800c1fc:	4603      	mov	r3, r0
 800c1fe:	461a      	mov	r2, r3
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	f883 231d 	strb.w	r2, [r3, #797]	@ 0x31d

      phost->gState = HOST_ENUMERATION;
 800c206:	687b      	ldr	r3, [r7, #4]
 800c208:	2205      	movs	r2, #5
 800c20a:	701a      	strb	r2, [r3, #0]

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800c20c:	2100      	movs	r1, #0
 800c20e:	6878      	ldr	r0, [r7, #4]
 800c210:	f001 fa9b 	bl	800d74a <USBH_AllocPipe>
 800c214:	4603      	mov	r3, r0
 800c216:	461a      	mov	r2, r3
 800c218:	687b      	ldr	r3, [r7, #4]
 800c21a:	715a      	strb	r2, [r3, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800c21c:	2180      	movs	r1, #128	@ 0x80
 800c21e:	6878      	ldr	r0, [r7, #4]
 800c220:	f001 fa93 	bl	800d74a <USBH_AllocPipe>
 800c224:	4603      	mov	r3, r0
 800c226:	461a      	mov	r2, r3
 800c228:	687b      	ldr	r3, [r7, #4]
 800c22a:	711a      	strb	r2, [r3, #4]

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c22c:	687b      	ldr	r3, [r7, #4]
 800c22e:	7919      	ldrb	r1, [r3, #4]
 800c230:	687b      	ldr	r3, [r7, #4]
 800c232:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c236:	687b      	ldr	r3, [r7, #4]
 800c238:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 800c23c:	687a      	ldr	r2, [r7, #4]
 800c23e:	7992      	ldrb	r2, [r2, #6]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800c240:	9202      	str	r2, [sp, #8]
 800c242:	2200      	movs	r2, #0
 800c244:	9201      	str	r2, [sp, #4]
 800c246:	9300      	str	r3, [sp, #0]
 800c248:	4603      	mov	r3, r0
 800c24a:	2280      	movs	r2, #128	@ 0x80
 800c24c:	6878      	ldr	r0, [r7, #4]
 800c24e:	f001 fa4d 	bl	800d6ec <USBH_OpenPipe>

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800c252:	687b      	ldr	r3, [r7, #4]
 800c254:	7959      	ldrb	r1, [r3, #5]
 800c256:	687b      	ldr	r3, [r7, #4]
 800c258:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c25c:	687b      	ldr	r3, [r7, #4]
 800c25e:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 800c262:	687a      	ldr	r2, [r7, #4]
 800c264:	7992      	ldrb	r2, [r2, #6]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800c266:	9202      	str	r2, [sp, #8]
 800c268:	2200      	movs	r2, #0
 800c26a:	9201      	str	r2, [sp, #4]
 800c26c:	9300      	str	r3, [sp, #0]
 800c26e:	4603      	mov	r3, r0
 800c270:	2200      	movs	r2, #0
 800c272:	6878      	ldr	r0, [r7, #4]
 800c274:	f001 fa3a 	bl	800d6ec <USBH_OpenPipe>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c278:	e113      	b.n	800c4a2 <USBH_Process+0x3c6>

    case HOST_ENUMERATION:
      /* Check for enumeration status */
      status = USBH_HandleEnum(phost);
 800c27a:	6878      	ldr	r0, [r7, #4]
 800c27c:	f000 f916 	bl	800c4ac <USBH_HandleEnum>
 800c280:	4603      	mov	r3, r0
 800c282:	73bb      	strb	r3, [r7, #14]
      if (status == USBH_OK)
 800c284:	7bbb      	ldrb	r3, [r7, #14]
 800c286:	b2db      	uxtb	r3, r3
 800c288:	2b00      	cmp	r3, #0
 800c28a:	f040 80fd 	bne.w	800c488 <USBH_Process+0x3ac>
      {
        /* The function shall return USBH_OK when full enumeration is complete */
        USBH_UsrLog("Enumeration done.");

        phost->device.current_interface = 0U;
 800c28e:	687b      	ldr	r3, [r7, #4]
 800c290:	2200      	movs	r2, #0
 800c292:	f883 2324 	strb.w	r2, [r3, #804]	@ 0x324

        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	f893 3337 	ldrb.w	r3, [r3, #823]	@ 0x337
 800c29c:	2b01      	cmp	r3, #1
 800c29e:	d103      	bne.n	800c2a8 <USBH_Process+0x1cc>
        {
          USBH_UsrLog("This device has only 1 configuration.");
          phost->gState = HOST_SET_CONFIGURATION;
 800c2a0:	687b      	ldr	r3, [r7, #4]
 800c2a2:	2208      	movs	r2, #8
 800c2a4:	701a      	strb	r2, [r3, #0]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c2a6:	e0ef      	b.n	800c488 <USBH_Process+0x3ac>
          phost->gState = HOST_INPUT;
 800c2a8:	687b      	ldr	r3, [r7, #4]
 800c2aa:	2207      	movs	r2, #7
 800c2ac:	701a      	strb	r2, [r3, #0]
      break;
 800c2ae:	e0eb      	b.n	800c488 <USBH_Process+0x3ac>

    case HOST_INPUT:
    {
      /* user callback for end of device basic enumeration */
      if (phost->pUser != NULL)
 800c2b0:	687b      	ldr	r3, [r7, #4]
 800c2b2:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c2b6:	2b00      	cmp	r3, #0
 800c2b8:	f000 80e8 	beq.w	800c48c <USBH_Process+0x3b0>
      {
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c2c2:	2101      	movs	r1, #1
 800c2c4:	6878      	ldr	r0, [r7, #4]
 800c2c6:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 800c2c8:	687b      	ldr	r3, [r7, #4]
 800c2ca:	2208      	movs	r2, #8
 800c2cc:	701a      	strb	r2, [r3, #0]
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
    }
    break;
 800c2ce:	e0dd      	b.n	800c48c <USBH_Process+0x3b0>

    case HOST_SET_CONFIGURATION:
      /* set configuration */
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 800c2d0:	687b      	ldr	r3, [r7, #4]
 800c2d2:	f893 333d 	ldrb.w	r3, [r3, #829]	@ 0x33d
 800c2d6:	4619      	mov	r1, r3
 800c2d8:	6878      	ldr	r0, [r7, #4]
 800c2da:	f000 fc3a 	bl	800cb52 <USBH_SetCfg>
 800c2de:	4603      	mov	r3, r0
 800c2e0:	2b00      	cmp	r3, #0
 800c2e2:	f040 80d5 	bne.w	800c490 <USBH_Process+0x3b4>
      {
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 800c2e6:	687b      	ldr	r3, [r7, #4]
 800c2e8:	2209      	movs	r2, #9
 800c2ea:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c2ec:	e0d0      	b.n	800c490 <USBH_Process+0x3b4>

    case  HOST_SET_WAKEUP_FEATURE:

      if (((phost->device.CfgDesc.bmAttributes) & (1U << 5)) != 0U)
 800c2ee:	687b      	ldr	r3, [r7, #4]
 800c2f0:	f893 333f 	ldrb.w	r3, [r3, #831]	@ 0x33f
 800c2f4:	f003 0320 	and.w	r3, r3, #32
 800c2f8:	2b00      	cmp	r3, #0
 800c2fa:	d016      	beq.n	800c32a <USBH_Process+0x24e>
      {
        status = USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP);
 800c2fc:	2101      	movs	r1, #1
 800c2fe:	6878      	ldr	r0, [r7, #4]
 800c300:	f000 fc4a 	bl	800cb98 <USBH_SetFeature>
 800c304:	4603      	mov	r3, r0
 800c306:	73bb      	strb	r3, [r7, #14]

        if (status == USBH_OK)
 800c308:	7bbb      	ldrb	r3, [r7, #14]
 800c30a:	b2db      	uxtb	r3, r3
 800c30c:	2b00      	cmp	r3, #0
 800c30e:	d103      	bne.n	800c318 <USBH_Process+0x23c>
        {
          USBH_UsrLog("Device remote wakeup enabled");
          phost->gState = HOST_CHECK_CLASS;
 800c310:	687b      	ldr	r3, [r7, #4]
 800c312:	220a      	movs	r2, #10
 800c314:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c316:	e0bd      	b.n	800c494 <USBH_Process+0x3b8>
        else if (status == USBH_NOT_SUPPORTED)
 800c318:	7bbb      	ldrb	r3, [r7, #14]
 800c31a:	b2db      	uxtb	r3, r3
 800c31c:	2b03      	cmp	r3, #3
 800c31e:	f040 80b9 	bne.w	800c494 <USBH_Process+0x3b8>
          phost->gState = HOST_CHECK_CLASS;
 800c322:	687b      	ldr	r3, [r7, #4]
 800c324:	220a      	movs	r2, #10
 800c326:	701a      	strb	r2, [r3, #0]
      break;
 800c328:	e0b4      	b.n	800c494 <USBH_Process+0x3b8>
        phost->gState = HOST_CHECK_CLASS;
 800c32a:	687b      	ldr	r3, [r7, #4]
 800c32c:	220a      	movs	r2, #10
 800c32e:	701a      	strb	r2, [r3, #0]
      break;
 800c330:	e0b0      	b.n	800c494 <USBH_Process+0x3b8>

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
 800c332:	687b      	ldr	r3, [r7, #4]
 800c334:	f8d3 3380 	ldr.w	r3, [r3, #896]	@ 0x380
 800c338:	2b00      	cmp	r3, #0
 800c33a:	f000 80ad 	beq.w	800c498 <USBH_Process+0x3bc>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
 800c33e:	687b      	ldr	r3, [r7, #4]
 800c340:	2200      	movs	r2, #0
 800c342:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 800c346:	2300      	movs	r3, #0
 800c348:	73fb      	strb	r3, [r7, #15]
 800c34a:	e016      	b.n	800c37a <USBH_Process+0x29e>
        {
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 800c34c:	7bfa      	ldrb	r2, [r7, #15]
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	32de      	adds	r2, #222	@ 0xde
 800c352:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c356:	791a      	ldrb	r2, [r3, #4]
 800c358:	687b      	ldr	r3, [r7, #4]
 800c35a:	f893 3347 	ldrb.w	r3, [r3, #839]	@ 0x347
 800c35e:	429a      	cmp	r2, r3
 800c360:	d108      	bne.n	800c374 <USBH_Process+0x298>
          {
            phost->pActiveClass = phost->pClass[idx];
 800c362:	7bfa      	ldrb	r2, [r7, #15]
 800c364:	687b      	ldr	r3, [r7, #4]
 800c366:	32de      	adds	r2, #222	@ 0xde
 800c368:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c36c:	687b      	ldr	r3, [r7, #4]
 800c36e:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
            break;
 800c372:	e005      	b.n	800c380 <USBH_Process+0x2a4>
        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 800c374:	7bfb      	ldrb	r3, [r7, #15]
 800c376:	3301      	adds	r3, #1
 800c378:	73fb      	strb	r3, [r7, #15]
 800c37a:	7bfb      	ldrb	r3, [r7, #15]
 800c37c:	2b00      	cmp	r3, #0
 800c37e:	d0e5      	beq.n	800c34c <USBH_Process+0x270>
          }
        }

        if (phost->pActiveClass != NULL)
 800c380:	687b      	ldr	r3, [r7, #4]
 800c382:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c386:	2b00      	cmp	r3, #0
 800c388:	d016      	beq.n	800c3b8 <USBH_Process+0x2dc>
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 800c38a:	687b      	ldr	r3, [r7, #4]
 800c38c:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c390:	689b      	ldr	r3, [r3, #8]
 800c392:	6878      	ldr	r0, [r7, #4]
 800c394:	4798      	blx	r3
 800c396:	4603      	mov	r3, r0
 800c398:	2b00      	cmp	r3, #0
 800c39a:	d109      	bne.n	800c3b0 <USBH_Process+0x2d4>
          {
            phost->gState = HOST_CLASS_REQUEST;
 800c39c:	687b      	ldr	r3, [r7, #4]
 800c39e:	2206      	movs	r2, #6
 800c3a0:	701a      	strb	r2, [r3, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 800c3a2:	687b      	ldr	r3, [r7, #4]
 800c3a4:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c3a8:	2103      	movs	r1, #3
 800c3aa:	6878      	ldr	r0, [r7, #4]
 800c3ac:	4798      	blx	r3
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c3ae:	e073      	b.n	800c498 <USBH_Process+0x3bc>
            phost->gState = HOST_ABORT_STATE;
 800c3b0:	687b      	ldr	r3, [r7, #4]
 800c3b2:	220d      	movs	r2, #13
 800c3b4:	701a      	strb	r2, [r3, #0]
      break;
 800c3b6:	e06f      	b.n	800c498 <USBH_Process+0x3bc>
          phost->gState = HOST_ABORT_STATE;
 800c3b8:	687b      	ldr	r3, [r7, #4]
 800c3ba:	220d      	movs	r2, #13
 800c3bc:	701a      	strb	r2, [r3, #0]
      break;
 800c3be:	e06b      	b.n	800c498 <USBH_Process+0x3bc>

    case HOST_CLASS_REQUEST:
      /* process class standard control requests state machine */
      if (phost->pActiveClass != NULL)
 800c3c0:	687b      	ldr	r3, [r7, #4]
 800c3c2:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c3c6:	2b00      	cmp	r3, #0
 800c3c8:	d017      	beq.n	800c3fa <USBH_Process+0x31e>
      {
        status = phost->pActiveClass->Requests(phost);
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c3d0:	691b      	ldr	r3, [r3, #16]
 800c3d2:	6878      	ldr	r0, [r7, #4]
 800c3d4:	4798      	blx	r3
 800c3d6:	4603      	mov	r3, r0
 800c3d8:	73bb      	strb	r3, [r7, #14]

        if (status == USBH_OK)
 800c3da:	7bbb      	ldrb	r3, [r7, #14]
 800c3dc:	b2db      	uxtb	r3, r3
 800c3de:	2b00      	cmp	r3, #0
 800c3e0:	d103      	bne.n	800c3ea <USBH_Process+0x30e>
        {
          phost->gState = HOST_CLASS;
 800c3e2:	687b      	ldr	r3, [r7, #4]
 800c3e4:	220b      	movs	r2, #11
 800c3e6:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c3e8:	e058      	b.n	800c49c <USBH_Process+0x3c0>
        else if (status == USBH_FAIL)
 800c3ea:	7bbb      	ldrb	r3, [r7, #14]
 800c3ec:	b2db      	uxtb	r3, r3
 800c3ee:	2b02      	cmp	r3, #2
 800c3f0:	d154      	bne.n	800c49c <USBH_Process+0x3c0>
          phost->gState = HOST_ABORT_STATE;
 800c3f2:	687b      	ldr	r3, [r7, #4]
 800c3f4:	220d      	movs	r2, #13
 800c3f6:	701a      	strb	r2, [r3, #0]
      break;
 800c3f8:	e050      	b.n	800c49c <USBH_Process+0x3c0>
        phost->gState = HOST_ABORT_STATE;
 800c3fa:	687b      	ldr	r3, [r7, #4]
 800c3fc:	220d      	movs	r2, #13
 800c3fe:	701a      	strb	r2, [r3, #0]
      break;
 800c400:	e04c      	b.n	800c49c <USBH_Process+0x3c0>

    case HOST_CLASS:
      /* process class state machine */
      if (phost->pActiveClass != NULL)
 800c402:	687b      	ldr	r3, [r7, #4]
 800c404:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c408:	2b00      	cmp	r3, #0
 800c40a:	d049      	beq.n	800c4a0 <USBH_Process+0x3c4>
      {
        phost->pActiveClass->BgndProcess(phost);
 800c40c:	687b      	ldr	r3, [r7, #4]
 800c40e:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c412:	695b      	ldr	r3, [r3, #20]
 800c414:	6878      	ldr	r0, [r7, #4]
 800c416:	4798      	blx	r3
      }
      break;
 800c418:	e042      	b.n	800c4a0 <USBH_Process+0x3c4>

    case HOST_DEV_DISCONNECTED :
      phost->device.is_disconnected = 0U;
 800c41a:	687b      	ldr	r3, [r7, #4]
 800c41c:	2200      	movs	r2, #0
 800c41e:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321

      (void)DeInitStateMachine(phost);
 800c422:	6878      	ldr	r0, [r7, #4]
 800c424:	f7ff fd4b 	bl	800bebe <DeInitStateMachine>

      /* Re-Initilaize Host for new Enumeration */
      if (phost->pActiveClass != NULL)
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c42e:	2b00      	cmp	r3, #0
 800c430:	d009      	beq.n	800c446 <USBH_Process+0x36a>
      {
        phost->pActiveClass->DeInit(phost);
 800c432:	687b      	ldr	r3, [r7, #4]
 800c434:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c438:	68db      	ldr	r3, [r3, #12]
 800c43a:	6878      	ldr	r0, [r7, #4]
 800c43c:	4798      	blx	r3
        phost->pActiveClass = NULL;
 800c43e:	687b      	ldr	r3, [r7, #4]
 800c440:	2200      	movs	r2, #0
 800c442:	f8c3 237c 	str.w	r2, [r3, #892]	@ 0x37c
      }

      if (phost->pUser != NULL)
 800c446:	687b      	ldr	r3, [r7, #4]
 800c448:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c44c:	2b00      	cmp	r3, #0
 800c44e:	d005      	beq.n	800c45c <USBH_Process+0x380>
      {
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 800c450:	687b      	ldr	r3, [r7, #4]
 800c452:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800c456:	2105      	movs	r1, #5
 800c458:	6878      	ldr	r0, [r7, #4]
 800c45a:	4798      	blx	r3
      }
      USBH_UsrLog("USB Device disconnected");

      if (phost->device.is_ReEnumerated == 1U)
 800c45c:	687b      	ldr	r3, [r7, #4]
 800c45e:	f893 3322 	ldrb.w	r3, [r3, #802]	@ 0x322
 800c462:	b2db      	uxtb	r3, r3
 800c464:	2b01      	cmp	r3, #1
 800c466:	d107      	bne.n	800c478 <USBH_Process+0x39c>
      {
        phost->device.is_ReEnumerated = 0U;
 800c468:	687b      	ldr	r3, [r7, #4]
 800c46a:	2200      	movs	r2, #0
 800c46c:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322

        /* Start the host and re-enable Vbus */
        (void)USBH_Start(phost);
 800c470:	6878      	ldr	r0, [r7, #4]
 800c472:	f7ff fe23 	bl	800c0bc <USBH_Start>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      break;
 800c476:	e014      	b.n	800c4a2 <USBH_Process+0x3c6>
        (void)USBH_LL_Start(phost);
 800c478:	6878      	ldr	r0, [r7, #4]
 800c47a:	f022 ffc5 	bl	802f408 <USBH_LL_Start>
      break;
 800c47e:	e010      	b.n	800c4a2 <USBH_Process+0x3c6>

    case HOST_ABORT_STATE:
    default :
      break;
 800c480:	bf00      	nop
 800c482:	e00e      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c484:	bf00      	nop
 800c486:	e00c      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c488:	bf00      	nop
 800c48a:	e00a      	b.n	800c4a2 <USBH_Process+0x3c6>
    break;
 800c48c:	bf00      	nop
 800c48e:	e008      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c490:	bf00      	nop
 800c492:	e006      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c494:	bf00      	nop
 800c496:	e004      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c498:	bf00      	nop
 800c49a:	e002      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c49c:	bf00      	nop
 800c49e:	e000      	b.n	800c4a2 <USBH_Process+0x3c6>
      break;
 800c4a0:	bf00      	nop
  }
  return USBH_OK;
 800c4a2:	2300      	movs	r3, #0
}
 800c4a4:	4618      	mov	r0, r3
 800c4a6:	3710      	adds	r7, #16
 800c4a8:	46bd      	mov	sp, r7
 800c4aa:	bd80      	pop	{r7, pc}

0800c4ac <USBH_HandleEnum>:
  *         This function includes the complete enumeration process
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
 800c4ac:	b580      	push	{r7, lr}
 800c4ae:	b088      	sub	sp, #32
 800c4b0:	af04      	add	r7, sp, #16
 800c4b2:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef Status = USBH_BUSY;
 800c4b4:	2301      	movs	r3, #1
 800c4b6:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;
 800c4b8:	2301      	movs	r3, #1
 800c4ba:	73bb      	strb	r3, [r7, #14]

  switch (phost->EnumState)
 800c4bc:	687b      	ldr	r3, [r7, #4]
 800c4be:	785b      	ldrb	r3, [r3, #1]
 800c4c0:	2b07      	cmp	r3, #7
 800c4c2:	f200 81bd 	bhi.w	800c840 <USBH_HandleEnum+0x394>
 800c4c6:	a201      	add	r2, pc, #4	@ (adr r2, 800c4cc <USBH_HandleEnum+0x20>)
 800c4c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c4cc:	0800c4ed 	.word	0x0800c4ed
 800c4d0:	0800c5a7 	.word	0x0800c5a7
 800c4d4:	0800c611 	.word	0x0800c611
 800c4d8:	0800c69b 	.word	0x0800c69b
 800c4dc:	0800c705 	.word	0x0800c705
 800c4e0:	0800c775 	.word	0x0800c775
 800c4e4:	0800c7bb 	.word	0x0800c7bb
 800c4e8:	0800c801 	.word	0x0800c801
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 800c4ec:	2108      	movs	r1, #8
 800c4ee:	6878      	ldr	r0, [r7, #4]
 800c4f0:	f000 fa4c 	bl	800c98c <USBH_Get_DevDesc>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c4f8:	7bbb      	ldrb	r3, [r7, #14]
 800c4fa:	2b00      	cmp	r3, #0
 800c4fc:	d12e      	bne.n	800c55c <USBH_HandleEnum+0xb0>
      {
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800c4fe:	687b      	ldr	r3, [r7, #4]
 800c500:	f893 232d 	ldrb.w	r2, [r3, #813]	@ 0x32d
 800c504:	687b      	ldr	r3, [r7, #4]
 800c506:	719a      	strb	r2, [r3, #6]

        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800c508:	687b      	ldr	r3, [r7, #4]
 800c50a:	2201      	movs	r2, #1
 800c50c:	705a      	strb	r2, [r3, #1]

        /* modify control channels configuration for MaxPacket size */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c50e:	687b      	ldr	r3, [r7, #4]
 800c510:	7919      	ldrb	r1, [r3, #4]
 800c512:	687b      	ldr	r3, [r7, #4]
 800c514:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c518:	687b      	ldr	r3, [r7, #4]
 800c51a:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c51e:	687a      	ldr	r2, [r7, #4]
 800c520:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800c522:	9202      	str	r2, [sp, #8]
 800c524:	2200      	movs	r2, #0
 800c526:	9201      	str	r2, [sp, #4]
 800c528:	9300      	str	r3, [sp, #0]
 800c52a:	4603      	mov	r3, r0
 800c52c:	2280      	movs	r2, #128	@ 0x80
 800c52e:	6878      	ldr	r0, [r7, #4]
 800c530:	f001 f8dc 	bl	800d6ec <USBH_OpenPipe>

        /* Open Control pipes */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	7959      	ldrb	r1, [r3, #5]
 800c538:	687b      	ldr	r3, [r7, #4]
 800c53a:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c53e:	687b      	ldr	r3, [r7, #4]
 800c540:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c544:	687a      	ldr	r2, [r7, #4]
 800c546:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c548:	9202      	str	r2, [sp, #8]
 800c54a:	2200      	movs	r2, #0
 800c54c:	9201      	str	r2, [sp, #4]
 800c54e:	9300      	str	r3, [sp, #0]
 800c550:	4603      	mov	r3, r0
 800c552:	2200      	movs	r2, #0
 800c554:	6878      	ldr	r0, [r7, #4]
 800c556:	f001 f8c9 	bl	800d6ec <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 800c55a:	e173      	b.n	800c844 <USBH_HandleEnum+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c55c:	7bbb      	ldrb	r3, [r7, #14]
 800c55e:	2b03      	cmp	r3, #3
 800c560:	f040 8170 	bne.w	800c844 <USBH_HandleEnum+0x398>
        phost->device.EnumCnt++;
 800c564:	687b      	ldr	r3, [r7, #4]
 800c566:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c56a:	3301      	adds	r3, #1
 800c56c:	b2da      	uxtb	r2, r3
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c574:	687b      	ldr	r3, [r7, #4]
 800c576:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c57a:	2b03      	cmp	r3, #3
 800c57c:	d903      	bls.n	800c586 <USBH_HandleEnum+0xda>
          phost->gState = HOST_ABORT_STATE;
 800c57e:	687b      	ldr	r3, [r7, #4]
 800c580:	220d      	movs	r2, #13
 800c582:	701a      	strb	r2, [r3, #0]
      break;
 800c584:	e15e      	b.n	800c844 <USBH_HandleEnum+0x398>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c586:	687b      	ldr	r3, [r7, #4]
 800c588:	795b      	ldrb	r3, [r3, #5]
 800c58a:	4619      	mov	r1, r3
 800c58c:	6878      	ldr	r0, [r7, #4]
 800c58e:	f001 f8fd 	bl	800d78c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c592:	687b      	ldr	r3, [r7, #4]
 800c594:	791b      	ldrb	r3, [r3, #4]
 800c596:	4619      	mov	r1, r3
 800c598:	6878      	ldr	r0, [r7, #4]
 800c59a:	f001 f8f7 	bl	800d78c <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	2200      	movs	r2, #0
 800c5a2:	701a      	strb	r2, [r3, #0]
      break;
 800c5a4:	e14e      	b.n	800c844 <USBH_HandleEnum+0x398>

    case ENUM_GET_FULL_DEV_DESC:
      /* Get FULL Device Desc  */
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 800c5a6:	2112      	movs	r1, #18
 800c5a8:	6878      	ldr	r0, [r7, #4]
 800c5aa:	f000 f9ef 	bl	800c98c <USBH_Get_DevDesc>
 800c5ae:	4603      	mov	r3, r0
 800c5b0:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c5b2:	7bbb      	ldrb	r3, [r7, #14]
 800c5b4:	2b00      	cmp	r3, #0
 800c5b6:	d103      	bne.n	800c5c0 <USBH_HandleEnum+0x114>
      {
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);

        phost->EnumState = ENUM_SET_ADDR;
 800c5b8:	687b      	ldr	r3, [r7, #4]
 800c5ba:	2202      	movs	r2, #2
 800c5bc:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c5be:	e143      	b.n	800c848 <USBH_HandleEnum+0x39c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c5c0:	7bbb      	ldrb	r3, [r7, #14]
 800c5c2:	2b03      	cmp	r3, #3
 800c5c4:	f040 8140 	bne.w	800c848 <USBH_HandleEnum+0x39c>
        phost->device.EnumCnt++;
 800c5c8:	687b      	ldr	r3, [r7, #4]
 800c5ca:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c5ce:	3301      	adds	r3, #1
 800c5d0:	b2da      	uxtb	r2, r3
 800c5d2:	687b      	ldr	r3, [r7, #4]
 800c5d4:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c5d8:	687b      	ldr	r3, [r7, #4]
 800c5da:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c5de:	2b03      	cmp	r3, #3
 800c5e0:	d903      	bls.n	800c5ea <USBH_HandleEnum+0x13e>
          phost->gState = HOST_ABORT_STATE;
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	220d      	movs	r2, #13
 800c5e6:	701a      	strb	r2, [r3, #0]
      break;
 800c5e8:	e12e      	b.n	800c848 <USBH_HandleEnum+0x39c>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c5ea:	687b      	ldr	r3, [r7, #4]
 800c5ec:	795b      	ldrb	r3, [r3, #5]
 800c5ee:	4619      	mov	r1, r3
 800c5f0:	6878      	ldr	r0, [r7, #4]
 800c5f2:	f001 f8cb 	bl	800d78c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	791b      	ldrb	r3, [r3, #4]
 800c5fa:	4619      	mov	r1, r3
 800c5fc:	6878      	ldr	r0, [r7, #4]
 800c5fe:	f001 f8c5 	bl	800d78c <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c602:	687b      	ldr	r3, [r7, #4]
 800c604:	2200      	movs	r2, #0
 800c606:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c608:	687b      	ldr	r3, [r7, #4]
 800c60a:	2200      	movs	r2, #0
 800c60c:	701a      	strb	r2, [r3, #0]
      break;
 800c60e:	e11b      	b.n	800c848 <USBH_HandleEnum+0x39c>

    case ENUM_SET_ADDR:
      /* set address */
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 800c610:	2101      	movs	r1, #1
 800c612:	6878      	ldr	r0, [r7, #4]
 800c614:	f000 fa79 	bl	800cb0a <USBH_SetAddress>
 800c618:	4603      	mov	r3, r0
 800c61a:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c61c:	7bbb      	ldrb	r3, [r7, #14]
 800c61e:	2b00      	cmp	r3, #0
 800c620:	d130      	bne.n	800c684 <USBH_HandleEnum+0x1d8>
      {
        USBH_Delay(2U);
 800c622:	2002      	movs	r0, #2
 800c624:	f023 f88a 	bl	802f73c <USBH_Delay>
        phost->device.address = USBH_DEVICE_ADDRESS;
 800c628:	687b      	ldr	r3, [r7, #4]
 800c62a:	2201      	movs	r2, #1
 800c62c:	f883 231c 	strb.w	r2, [r3, #796]	@ 0x31c

        /* user callback for device address assigned */
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
        phost->EnumState = ENUM_GET_CFG_DESC;
 800c630:	687b      	ldr	r3, [r7, #4]
 800c632:	2203      	movs	r2, #3
 800c634:	705a      	strb	r2, [r3, #1]

        /* modify control channels to update device address */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c636:	687b      	ldr	r3, [r7, #4]
 800c638:	7919      	ldrb	r1, [r3, #4]
 800c63a:	687b      	ldr	r3, [r7, #4]
 800c63c:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c640:	687b      	ldr	r3, [r7, #4]
 800c642:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c646:	687a      	ldr	r2, [r7, #4]
 800c648:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800c64a:	9202      	str	r2, [sp, #8]
 800c64c:	2200      	movs	r2, #0
 800c64e:	9201      	str	r2, [sp, #4]
 800c650:	9300      	str	r3, [sp, #0]
 800c652:	4603      	mov	r3, r0
 800c654:	2280      	movs	r2, #128	@ 0x80
 800c656:	6878      	ldr	r0, [r7, #4]
 800c658:	f001 f848 	bl	800d6ec <USBH_OpenPipe>

        /* Open Control pipes */
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	7959      	ldrb	r1, [r3, #5]
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	f893 031c 	ldrb.w	r0, [r3, #796]	@ 0x31c
 800c666:	687b      	ldr	r3, [r7, #4]
 800c668:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
                            phost->device.speed, USBH_EP_CONTROL,
                            (uint16_t)phost->Control.pipe_size);
 800c66c:	687a      	ldr	r2, [r7, #4]
 800c66e:	7992      	ldrb	r2, [r2, #6]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800c670:	9202      	str	r2, [sp, #8]
 800c672:	2200      	movs	r2, #0
 800c674:	9201      	str	r2, [sp, #4]
 800c676:	9300      	str	r3, [sp, #0]
 800c678:	4603      	mov	r3, r0
 800c67a:	2200      	movs	r2, #0
 800c67c:	6878      	ldr	r0, [r7, #4]
 800c67e:	f001 f835 	bl	800d6ec <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 800c682:	e0e3      	b.n	800c84c <USBH_HandleEnum+0x3a0>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c684:	7bbb      	ldrb	r3, [r7, #14]
 800c686:	2b03      	cmp	r3, #3
 800c688:	f040 80e0 	bne.w	800c84c <USBH_HandleEnum+0x3a0>
        phost->gState = HOST_ABORT_STATE;
 800c68c:	687b      	ldr	r3, [r7, #4]
 800c68e:	220d      	movs	r2, #13
 800c690:	701a      	strb	r2, [r3, #0]
        phost->EnumState = ENUM_IDLE;
 800c692:	687b      	ldr	r3, [r7, #4]
 800c694:	2200      	movs	r2, #0
 800c696:	705a      	strb	r2, [r3, #1]
      break;
 800c698:	e0d8      	b.n	800c84c <USBH_HandleEnum+0x3a0>

    case ENUM_GET_CFG_DESC:
      /* get standard configuration descriptor */
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 800c69a:	2109      	movs	r1, #9
 800c69c:	6878      	ldr	r0, [r7, #4]
 800c69e:	f000 f9a1 	bl	800c9e4 <USBH_Get_CfgDesc>
 800c6a2:	4603      	mov	r3, r0
 800c6a4:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c6a6:	7bbb      	ldrb	r3, [r7, #14]
 800c6a8:	2b00      	cmp	r3, #0
 800c6aa:	d103      	bne.n	800c6b4 <USBH_HandleEnum+0x208>
      {
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800c6ac:	687b      	ldr	r3, [r7, #4]
 800c6ae:	2204      	movs	r2, #4
 800c6b0:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c6b2:	e0cd      	b.n	800c850 <USBH_HandleEnum+0x3a4>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c6b4:	7bbb      	ldrb	r3, [r7, #14]
 800c6b6:	2b03      	cmp	r3, #3
 800c6b8:	f040 80ca 	bne.w	800c850 <USBH_HandleEnum+0x3a4>
        phost->device.EnumCnt++;
 800c6bc:	687b      	ldr	r3, [r7, #4]
 800c6be:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c6c2:	3301      	adds	r3, #1
 800c6c4:	b2da      	uxtb	r2, r3
 800c6c6:	687b      	ldr	r3, [r7, #4]
 800c6c8:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c6cc:	687b      	ldr	r3, [r7, #4]
 800c6ce:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c6d2:	2b03      	cmp	r3, #3
 800c6d4:	d903      	bls.n	800c6de <USBH_HandleEnum+0x232>
          phost->gState = HOST_ABORT_STATE;
 800c6d6:	687b      	ldr	r3, [r7, #4]
 800c6d8:	220d      	movs	r2, #13
 800c6da:	701a      	strb	r2, [r3, #0]
      break;
 800c6dc:	e0b8      	b.n	800c850 <USBH_HandleEnum+0x3a4>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	795b      	ldrb	r3, [r3, #5]
 800c6e2:	4619      	mov	r1, r3
 800c6e4:	6878      	ldr	r0, [r7, #4]
 800c6e6:	f001 f851 	bl	800d78c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c6ea:	687b      	ldr	r3, [r7, #4]
 800c6ec:	791b      	ldrb	r3, [r3, #4]
 800c6ee:	4619      	mov	r1, r3
 800c6f0:	6878      	ldr	r0, [r7, #4]
 800c6f2:	f001 f84b 	bl	800d78c <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	2200      	movs	r2, #0
 800c6fa:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c6fc:	687b      	ldr	r3, [r7, #4]
 800c6fe:	2200      	movs	r2, #0
 800c700:	701a      	strb	r2, [r3, #0]
      break;
 800c702:	e0a5      	b.n	800c850 <USBH_HandleEnum+0x3a4>

    case ENUM_GET_FULL_CFG_DESC:
      /* get FULL config descriptor (config, interface, endpoints) */
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800c704:	687b      	ldr	r3, [r7, #4]
 800c706:	f8b3 333a 	ldrh.w	r3, [r3, #826]	@ 0x33a
 800c70a:	4619      	mov	r1, r3
 800c70c:	6878      	ldr	r0, [r7, #4]
 800c70e:	f000 f969 	bl	800c9e4 <USBH_Get_CfgDesc>
 800c712:	4603      	mov	r3, r0
 800c714:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 800c716:	7bbb      	ldrb	r3, [r7, #14]
 800c718:	2b00      	cmp	r3, #0
 800c71a:	d103      	bne.n	800c724 <USBH_HandleEnum+0x278>
      {
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800c71c:	687b      	ldr	r3, [r7, #4]
 800c71e:	2205      	movs	r2, #5
 800c720:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 800c722:	e097      	b.n	800c854 <USBH_HandleEnum+0x3a8>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c724:	7bbb      	ldrb	r3, [r7, #14]
 800c726:	2b03      	cmp	r3, #3
 800c728:	f040 8094 	bne.w	800c854 <USBH_HandleEnum+0x3a8>
        phost->device.EnumCnt++;
 800c72c:	687b      	ldr	r3, [r7, #4]
 800c72e:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c732:	3301      	adds	r3, #1
 800c734:	b2da      	uxtb	r2, r3
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	f883 231e 	strb.w	r2, [r3, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 800c73c:	687b      	ldr	r3, [r7, #4]
 800c73e:	f893 331e 	ldrb.w	r3, [r3, #798]	@ 0x31e
 800c742:	2b03      	cmp	r3, #3
 800c744:	d903      	bls.n	800c74e <USBH_HandleEnum+0x2a2>
          phost->gState = HOST_ABORT_STATE;
 800c746:	687b      	ldr	r3, [r7, #4]
 800c748:	220d      	movs	r2, #13
 800c74a:	701a      	strb	r2, [r3, #0]
      break;
 800c74c:	e082      	b.n	800c854 <USBH_HandleEnum+0x3a8>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c74e:	687b      	ldr	r3, [r7, #4]
 800c750:	795b      	ldrb	r3, [r3, #5]
 800c752:	4619      	mov	r1, r3
 800c754:	6878      	ldr	r0, [r7, #4]
 800c756:	f001 f819 	bl	800d78c <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c75a:	687b      	ldr	r3, [r7, #4]
 800c75c:	791b      	ldrb	r3, [r3, #4]
 800c75e:	4619      	mov	r1, r3
 800c760:	6878      	ldr	r0, [r7, #4]
 800c762:	f001 f813 	bl	800d78c <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800c766:	687b      	ldr	r3, [r7, #4]
 800c768:	2200      	movs	r2, #0
 800c76a:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 800c76c:	687b      	ldr	r3, [r7, #4]
 800c76e:	2200      	movs	r2, #0
 800c770:	701a      	strb	r2, [r3, #0]
      break;
 800c772:	e06f      	b.n	800c854 <USBH_HandleEnum+0x3a8>

    case ENUM_GET_MFC_STRING_DESC:
      if (phost->device.DevDesc.iManufacturer != 0U)
 800c774:	687b      	ldr	r3, [r7, #4]
 800c776:	f893 3334 	ldrb.w	r3, [r3, #820]	@ 0x334
 800c77a:	2b00      	cmp	r3, #0
 800c77c:	d019      	beq.n	800c7b2 <USBH_HandleEnum+0x306>
      {
        /* Check that Manufacturer String is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800c77e:	687b      	ldr	r3, [r7, #4]
 800c780:	f893 1334 	ldrb.w	r1, [r3, #820]	@ 0x334
                                        phost->device.Data, 0xFFU);
 800c784:	687b      	ldr	r3, [r7, #4]
 800c786:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800c78a:	23ff      	movs	r3, #255	@ 0xff
 800c78c:	6878      	ldr	r0, [r7, #4]
 800c78e:	f000 f953 	bl	800ca38 <USBH_Get_StringDesc>
 800c792:	4603      	mov	r3, r0
 800c794:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800c796:	7bbb      	ldrb	r3, [r7, #14]
 800c798:	2b00      	cmp	r3, #0
 800c79a:	d103      	bne.n	800c7a4 <USBH_HandleEnum+0x2f8>
        {
          /* User callback for Manufacturing string */
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c79c:	687b      	ldr	r3, [r7, #4]
 800c79e:	2206      	movs	r2, #6
 800c7a0:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c7a2:	e059      	b.n	800c858 <USBH_HandleEnum+0x3ac>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c7a4:	7bbb      	ldrb	r3, [r7, #14]
 800c7a6:	2b03      	cmp	r3, #3
 800c7a8:	d156      	bne.n	800c858 <USBH_HandleEnum+0x3ac>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c7aa:	687b      	ldr	r3, [r7, #4]
 800c7ac:	2206      	movs	r2, #6
 800c7ae:	705a      	strb	r2, [r3, #1]
      break;
 800c7b0:	e052      	b.n	800c858 <USBH_HandleEnum+0x3ac>
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800c7b2:	687b      	ldr	r3, [r7, #4]
 800c7b4:	2206      	movs	r2, #6
 800c7b6:	705a      	strb	r2, [r3, #1]
      break;
 800c7b8:	e04e      	b.n	800c858 <USBH_HandleEnum+0x3ac>

    case ENUM_GET_PRODUCT_STRING_DESC:
      if (phost->device.DevDesc.iProduct != 0U)
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	f893 3335 	ldrb.w	r3, [r3, #821]	@ 0x335
 800c7c0:	2b00      	cmp	r3, #0
 800c7c2:	d019      	beq.n	800c7f8 <USBH_HandleEnum+0x34c>
      {
        /* Check that Product string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800c7c4:	687b      	ldr	r3, [r7, #4]
 800c7c6:	f893 1335 	ldrb.w	r1, [r3, #821]	@ 0x335
                                        phost->device.Data, 0xFFU);
 800c7ca:	687b      	ldr	r3, [r7, #4]
 800c7cc:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800c7d0:	23ff      	movs	r3, #255	@ 0xff
 800c7d2:	6878      	ldr	r0, [r7, #4]
 800c7d4:	f000 f930 	bl	800ca38 <USBH_Get_StringDesc>
 800c7d8:	4603      	mov	r3, r0
 800c7da:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800c7dc:	7bbb      	ldrb	r3, [r7, #14]
 800c7de:	2b00      	cmp	r3, #0
 800c7e0:	d103      	bne.n	800c7ea <USBH_HandleEnum+0x33e>
        {
          /* User callback for Product string */
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c7e2:	687b      	ldr	r3, [r7, #4]
 800c7e4:	2207      	movs	r2, #7
 800c7e6:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
      }
      break;
 800c7e8:	e038      	b.n	800c85c <USBH_HandleEnum+0x3b0>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c7ea:	7bbb      	ldrb	r3, [r7, #14]
 800c7ec:	2b03      	cmp	r3, #3
 800c7ee:	d135      	bne.n	800c85c <USBH_HandleEnum+0x3b0>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c7f0:	687b      	ldr	r3, [r7, #4]
 800c7f2:	2207      	movs	r2, #7
 800c7f4:	705a      	strb	r2, [r3, #1]
      break;
 800c7f6:	e031      	b.n	800c85c <USBH_HandleEnum+0x3b0>
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800c7f8:	687b      	ldr	r3, [r7, #4]
 800c7fa:	2207      	movs	r2, #7
 800c7fc:	705a      	strb	r2, [r3, #1]
      break;
 800c7fe:	e02d      	b.n	800c85c <USBH_HandleEnum+0x3b0>

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 800c800:	687b      	ldr	r3, [r7, #4]
 800c802:	f893 3336 	ldrb.w	r3, [r3, #822]	@ 0x336
 800c806:	2b00      	cmp	r3, #0
 800c808:	d017      	beq.n	800c83a <USBH_HandleEnum+0x38e>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	f893 1336 	ldrb.w	r1, [r3, #822]	@ 0x336
                                        phost->device.Data, 0xFFU);
 800c810:	687b      	ldr	r3, [r7, #4]
 800c812:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800c816:	23ff      	movs	r3, #255	@ 0xff
 800c818:	6878      	ldr	r0, [r7, #4]
 800c81a:	f000 f90d 	bl	800ca38 <USBH_Get_StringDesc>
 800c81e:	4603      	mov	r3, r0
 800c820:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 800c822:	7bbb      	ldrb	r3, [r7, #14]
 800c824:	2b00      	cmp	r3, #0
 800c826:	d102      	bne.n	800c82e <USBH_HandleEnum+0x382>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
 800c828:	2300      	movs	r3, #0
 800c82a:	73fb      	strb	r3, [r7, #15]
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
      }
      break;
 800c82c:	e018      	b.n	800c860 <USBH_HandleEnum+0x3b4>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800c82e:	7bbb      	ldrb	r3, [r7, #14]
 800c830:	2b03      	cmp	r3, #3
 800c832:	d115      	bne.n	800c860 <USBH_HandleEnum+0x3b4>
          Status = USBH_OK;
 800c834:	2300      	movs	r3, #0
 800c836:	73fb      	strb	r3, [r7, #15]
      break;
 800c838:	e012      	b.n	800c860 <USBH_HandleEnum+0x3b4>
        Status = USBH_OK;
 800c83a:	2300      	movs	r3, #0
 800c83c:	73fb      	strb	r3, [r7, #15]
      break;
 800c83e:	e00f      	b.n	800c860 <USBH_HandleEnum+0x3b4>

    default:
      break;
 800c840:	bf00      	nop
 800c842:	e00e      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c844:	bf00      	nop
 800c846:	e00c      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c848:	bf00      	nop
 800c84a:	e00a      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c84c:	bf00      	nop
 800c84e:	e008      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c850:	bf00      	nop
 800c852:	e006      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c854:	bf00      	nop
 800c856:	e004      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c858:	bf00      	nop
 800c85a:	e002      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c85c:	bf00      	nop
 800c85e:	e000      	b.n	800c862 <USBH_HandleEnum+0x3b6>
      break;
 800c860:	bf00      	nop
  }
  return Status;
 800c862:	7bfb      	ldrb	r3, [r7, #15]
}
 800c864:	4618      	mov	r0, r3
 800c866:	3710      	adds	r7, #16
 800c868:	46bd      	mov	sp, r7
 800c86a:	bd80      	pop	{r7, pc}

0800c86c <USBH_LL_SetTimer>:
  *         Set the initial Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
 800c86c:	b480      	push	{r7}
 800c86e:	b083      	sub	sp, #12
 800c870:	af00      	add	r7, sp, #0
 800c872:	6078      	str	r0, [r7, #4]
 800c874:	6039      	str	r1, [r7, #0]
  phost->Timer = time;
 800c876:	687b      	ldr	r3, [r7, #4]
 800c878:	683a      	ldr	r2, [r7, #0]
 800c87a:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4
}
 800c87e:	bf00      	nop
 800c880:	370c      	adds	r7, #12
 800c882:	46bd      	mov	sp, r7
 800c884:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c888:	4770      	bx	lr

0800c88a <USBH_LL_IncTimer>:
  *         Increment Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
 800c88a:	b580      	push	{r7, lr}
 800c88c:	b082      	sub	sp, #8
 800c88e:	af00      	add	r7, sp, #0
 800c890:	6078      	str	r0, [r7, #4]
  phost->Timer++;
 800c892:	687b      	ldr	r3, [r7, #4]
 800c894:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800c898:	1c5a      	adds	r2, r3, #1
 800c89a:	687b      	ldr	r3, [r7, #4]
 800c89c:	f8c3 23c4 	str.w	r2, [r3, #964]	@ 0x3c4
  USBH_HandleSof(phost);
 800c8a0:	6878      	ldr	r0, [r7, #4]
 800c8a2:	f000 f804 	bl	800c8ae <USBH_HandleSof>
}
 800c8a6:	bf00      	nop
 800c8a8:	3708      	adds	r7, #8
 800c8aa:	46bd      	mov	sp, r7
 800c8ac:	bd80      	pop	{r7, pc}

0800c8ae <USBH_HandleSof>:
  *         Call SOF process
  * @param  phost: Host Handle
  * @retval None
  */
static void USBH_HandleSof(USBH_HandleTypeDef *phost)
{
 800c8ae:	b580      	push	{r7, lr}
 800c8b0:	b082      	sub	sp, #8
 800c8b2:	af00      	add	r7, sp, #0
 800c8b4:	6078      	str	r0, [r7, #4]
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800c8b6:	687b      	ldr	r3, [r7, #4]
 800c8b8:	781b      	ldrb	r3, [r3, #0]
 800c8ba:	b2db      	uxtb	r3, r3
 800c8bc:	2b0b      	cmp	r3, #11
 800c8be:	d10a      	bne.n	800c8d6 <USBH_HandleSof+0x28>
 800c8c0:	687b      	ldr	r3, [r7, #4]
 800c8c2:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c8c6:	2b00      	cmp	r3, #0
 800c8c8:	d005      	beq.n	800c8d6 <USBH_HandleSof+0x28>
  {
    phost->pActiveClass->SOFProcess(phost);
 800c8ca:	687b      	ldr	r3, [r7, #4]
 800c8cc:	f8d3 337c 	ldr.w	r3, [r3, #892]	@ 0x37c
 800c8d0:	699b      	ldr	r3, [r3, #24]
 800c8d2:	6878      	ldr	r0, [r7, #4]
 800c8d4:	4798      	blx	r3
  }
}
 800c8d6:	bf00      	nop
 800c8d8:	3708      	adds	r7, #8
 800c8da:	46bd      	mov	sp, r7
 800c8dc:	bd80      	pop	{r7, pc}

0800c8de <USBH_LL_PortEnabled>:
  *         Port Enabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
 800c8de:	b480      	push	{r7}
 800c8e0:	b083      	sub	sp, #12
 800c8e2:	af00      	add	r7, sp, #0
 800c8e4:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 1U;
 800c8e6:	687b      	ldr	r3, [r7, #4]
 800c8e8:	2201      	movs	r2, #1
 800c8ea:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return;
 800c8ee:	bf00      	nop
}
 800c8f0:	370c      	adds	r7, #12
 800c8f2:	46bd      	mov	sp, r7
 800c8f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8f8:	4770      	bx	lr

0800c8fa <USBH_LL_PortDisabled>:
  *         Port Disabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
 800c8fa:	b480      	push	{r7}
 800c8fc:	b083      	sub	sp, #12
 800c8fe:	af00      	add	r7, sp, #0
 800c900:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 0U;
 800c902:	687b      	ldr	r3, [r7, #4]
 800c904:	2200      	movs	r2, #0
 800c906:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323

  return;
 800c90a:	bf00      	nop
}
 800c90c:	370c      	adds	r7, #12
 800c90e:	46bd      	mov	sp, r7
 800c910:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c914:	4770      	bx	lr

0800c916 <USBH_LL_Connect>:
  *         Handle USB Host connection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 800c916:	b480      	push	{r7}
 800c918:	b083      	sub	sp, #12
 800c91a:	af00      	add	r7, sp, #0
 800c91c:	6078      	str	r0, [r7, #4]
  phost->device.is_connected = 1U;
 800c91e:	687b      	ldr	r3, [r7, #4]
 800c920:	2201      	movs	r2, #1
 800c922:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.is_disconnected = 0U;
 800c926:	687b      	ldr	r3, [r7, #4]
 800c928:	2200      	movs	r2, #0
 800c92a:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_ReEnumerated = 0U;
 800c92e:	687b      	ldr	r3, [r7, #4]
 800c930:	2200      	movs	r2, #0
 800c932:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
 800c936:	2300      	movs	r3, #0
}
 800c938:	4618      	mov	r0, r3
 800c93a:	370c      	adds	r7, #12
 800c93c:	46bd      	mov	sp, r7
 800c93e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c942:	4770      	bx	lr

0800c944 <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 800c944:	b580      	push	{r7, lr}
 800c946:	b082      	sub	sp, #8
 800c948:	af00      	add	r7, sp, #0
 800c94a:	6078      	str	r0, [r7, #4]
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 800c94c:	687b      	ldr	r3, [r7, #4]
 800c94e:	2201      	movs	r2, #1
 800c950:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_connected = 0U;
 800c954:	687b      	ldr	r3, [r7, #4]
 800c956:	2200      	movs	r2, #0
 800c958:	f883 2320 	strb.w	r2, [r3, #800]	@ 0x320
  phost->device.PortEnabled = 0U;
 800c95c:	687b      	ldr	r3, [r7, #4]
 800c95e:	2200      	movs	r2, #0
 800c960:	f883 2323 	strb.w	r2, [r3, #803]	@ 0x323

  /* Stop Host */
  (void)USBH_LL_Stop(phost);
 800c964:	6878      	ldr	r0, [r7, #4]
 800c966:	f022 fd6a 	bl	802f43e <USBH_LL_Stop>

  /* FRee Control Pipes */
  (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800c96a:	687b      	ldr	r3, [r7, #4]
 800c96c:	791b      	ldrb	r3, [r3, #4]
 800c96e:	4619      	mov	r1, r3
 800c970:	6878      	ldr	r0, [r7, #4]
 800c972:	f000 ff0b 	bl	800d78c <USBH_FreePipe>
  (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800c976:	687b      	ldr	r3, [r7, #4]
 800c978:	795b      	ldrb	r3, [r3, #5]
 800c97a:	4619      	mov	r1, r3
 800c97c:	6878      	ldr	r0, [r7, #4]
 800c97e:	f000 ff05 	bl	800d78c <USBH_FreePipe>
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
 800c982:	2300      	movs	r3, #0
}
 800c984:	4618      	mov	r0, r3
 800c986:	3708      	adds	r7, #8
 800c988:	46bd      	mov	sp, r7
 800c98a:	bd80      	pop	{r7, pc}

0800c98c <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint16_t length)
{
 800c98c:	b580      	push	{r7, lr}
 800c98e:	b086      	sub	sp, #24
 800c990:	af02      	add	r7, sp, #8
 800c992:	6078      	str	r0, [r7, #4]
 800c994:	460b      	mov	r3, r1
 800c996:	807b      	strh	r3, [r7, #2]
  USBH_StatusTypeDef status;

  if (length > sizeof(phost->device.Data))
 800c998:	887b      	ldrh	r3, [r7, #2]
 800c99a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800c99e:	d901      	bls.n	800c9a4 <USBH_Get_DevDesc+0x18>
  {
    USBH_ErrLog("Control error: Get Device Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800c9a0:	2303      	movs	r3, #3
 800c9a2:	e01b      	b.n	800c9dc <USBH_Get_DevDesc+0x50>
  }

  status = USBH_GetDescriptor(phost,
                              USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                              USB_DESC_DEVICE, phost->device.Data, length);
 800c9a4:	687b      	ldr	r3, [r7, #4]
 800c9a6:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
  status = USBH_GetDescriptor(phost,
 800c9aa:	887b      	ldrh	r3, [r7, #2]
 800c9ac:	9300      	str	r3, [sp, #0]
 800c9ae:	4613      	mov	r3, r2
 800c9b0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800c9b4:	2100      	movs	r1, #0
 800c9b6:	6878      	ldr	r0, [r7, #4]
 800c9b8:	f000 f872 	bl	800caa0 <USBH_GetDescriptor>
 800c9bc:	4603      	mov	r3, r0
 800c9be:	73fb      	strb	r3, [r7, #15]

  if (status == USBH_OK)
 800c9c0:	7bfb      	ldrb	r3, [r7, #15]
 800c9c2:	2b00      	cmp	r3, #0
 800c9c4:	d109      	bne.n	800c9da <USBH_Get_DevDesc+0x4e>
  {
    /* Commands successfully sent and Response Received */
    status = USBH_ParseDevDesc(phost, phost->device.Data, length);
 800c9c6:	687b      	ldr	r3, [r7, #4]
 800c9c8:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800c9cc:	887a      	ldrh	r2, [r7, #2]
 800c9ce:	4619      	mov	r1, r3
 800c9d0:	6878      	ldr	r0, [r7, #4]
 800c9d2:	f000 f929 	bl	800cc28 <USBH_ParseDevDesc>
 800c9d6:	4603      	mov	r3, r0
 800c9d8:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800c9da:	7bfb      	ldrb	r3, [r7, #15]
}
 800c9dc:	4618      	mov	r0, r3
 800c9de:	3710      	adds	r7, #16
 800c9e0:	46bd      	mov	sp, r7
 800c9e2:	bd80      	pop	{r7, pc}

0800c9e4 <USBH_Get_CfgDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_CfgDesc(USBH_HandleTypeDef *phost, uint16_t length)
{
 800c9e4:	b580      	push	{r7, lr}
 800c9e6:	b086      	sub	sp, #24
 800c9e8:	af02      	add	r7, sp, #8
 800c9ea:	6078      	str	r0, [r7, #4]
 800c9ec:	460b      	mov	r3, r1
 800c9ee:	807b      	strh	r3, [r7, #2]
  USBH_StatusTypeDef status;
  uint8_t *pData = phost->device.CfgDesc_Raw;
 800c9f0:	687b      	ldr	r3, [r7, #4]
 800c9f2:	331c      	adds	r3, #28
 800c9f4:	60bb      	str	r3, [r7, #8]

  if (length > sizeof(phost->device.CfgDesc_Raw))
 800c9f6:	887b      	ldrh	r3, [r7, #2]
 800c9f8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c9fc:	d901      	bls.n	800ca02 <USBH_Get_CfgDesc+0x1e>
  {
    USBH_ErrLog("Control error: Get configuration Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800c9fe:	2303      	movs	r3, #3
 800ca00:	e016      	b.n	800ca30 <USBH_Get_CfgDesc+0x4c>
  }

  status = USBH_GetDescriptor(phost, (USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD),
 800ca02:	887b      	ldrh	r3, [r7, #2]
 800ca04:	9300      	str	r3, [sp, #0]
 800ca06:	68bb      	ldr	r3, [r7, #8]
 800ca08:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800ca0c:	2100      	movs	r1, #0
 800ca0e:	6878      	ldr	r0, [r7, #4]
 800ca10:	f000 f846 	bl	800caa0 <USBH_GetDescriptor>
 800ca14:	4603      	mov	r3, r0
 800ca16:	73fb      	strb	r3, [r7, #15]
                              USB_DESC_CONFIGURATION, pData, length);

  if (status == USBH_OK)
 800ca18:	7bfb      	ldrb	r3, [r7, #15]
 800ca1a:	2b00      	cmp	r3, #0
 800ca1c:	d107      	bne.n	800ca2e <USBH_Get_CfgDesc+0x4a>
  {
    /* Commands successfully sent and Response Received  */
    status = USBH_ParseCfgDesc(phost, pData, length);
 800ca1e:	887b      	ldrh	r3, [r7, #2]
 800ca20:	461a      	mov	r2, r3
 800ca22:	68b9      	ldr	r1, [r7, #8]
 800ca24:	6878      	ldr	r0, [r7, #4]
 800ca26:	f000 f9af 	bl	800cd88 <USBH_ParseCfgDesc>
 800ca2a:	4603      	mov	r3, r0
 800ca2c:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800ca2e:	7bfb      	ldrb	r3, [r7, #15]
}
 800ca30:	4618      	mov	r0, r3
 800ca32:	3710      	adds	r7, #16
 800ca34:	46bd      	mov	sp, r7
 800ca36:	bd80      	pop	{r7, pc}

0800ca38 <USBH_Get_StringDesc>:
  * @param  buff: Buffer address for the descriptor
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_StringDesc(USBH_HandleTypeDef *phost, uint8_t string_index, uint8_t *buff, uint16_t length)
{
 800ca38:	b580      	push	{r7, lr}
 800ca3a:	b088      	sub	sp, #32
 800ca3c:	af02      	add	r7, sp, #8
 800ca3e:	60f8      	str	r0, [r7, #12]
 800ca40:	607a      	str	r2, [r7, #4]
 800ca42:	461a      	mov	r2, r3
 800ca44:	460b      	mov	r3, r1
 800ca46:	72fb      	strb	r3, [r7, #11]
 800ca48:	4613      	mov	r3, r2
 800ca4a:	813b      	strh	r3, [r7, #8]
  USBH_StatusTypeDef status;

  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 800ca4c:	893b      	ldrh	r3, [r7, #8]
 800ca4e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ca52:	d802      	bhi.n	800ca5a <USBH_Get_StringDesc+0x22>
 800ca54:	687b      	ldr	r3, [r7, #4]
 800ca56:	2b00      	cmp	r3, #0
 800ca58:	d101      	bne.n	800ca5e <USBH_Get_StringDesc+0x26>
  {
    USBH_ErrLog("Control error: Get String Descriptor failed, data buffer size issue");
    return USBH_NOT_SUPPORTED;
 800ca5a:	2303      	movs	r3, #3
 800ca5c:	e01c      	b.n	800ca98 <USBH_Get_StringDesc+0x60>
  }

  status = USBH_GetDescriptor(phost,
 800ca5e:	7afb      	ldrb	r3, [r7, #11]
 800ca60:	b29b      	uxth	r3, r3
 800ca62:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
 800ca66:	b29a      	uxth	r2, r3
                              USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                              USB_DESC_STRING | string_index,
                              phost->device.Data, length);
 800ca68:	68fb      	ldr	r3, [r7, #12]
 800ca6a:	f503 718e 	add.w	r1, r3, #284	@ 0x11c
  status = USBH_GetDescriptor(phost,
 800ca6e:	893b      	ldrh	r3, [r7, #8]
 800ca70:	9300      	str	r3, [sp, #0]
 800ca72:	460b      	mov	r3, r1
 800ca74:	2100      	movs	r1, #0
 800ca76:	68f8      	ldr	r0, [r7, #12]
 800ca78:	f000 f812 	bl	800caa0 <USBH_GetDescriptor>
 800ca7c:	4603      	mov	r3, r0
 800ca7e:	75fb      	strb	r3, [r7, #23]

  if (status == USBH_OK)
 800ca80:	7dfb      	ldrb	r3, [r7, #23]
 800ca82:	2b00      	cmp	r3, #0
 800ca84:	d107      	bne.n	800ca96 <USBH_Get_StringDesc+0x5e>
  {
    /* Commands successfully sent and Response Received */
    USBH_ParseStringDesc(phost->device.Data, buff, length);
 800ca86:	68fb      	ldr	r3, [r7, #12]
 800ca88:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800ca8c:	893a      	ldrh	r2, [r7, #8]
 800ca8e:	6879      	ldr	r1, [r7, #4]
 800ca90:	4618      	mov	r0, r3
 800ca92:	f000 fb8d 	bl	800d1b0 <USBH_ParseStringDesc>
  }

  return status;
 800ca96:	7dfb      	ldrb	r3, [r7, #23]
}
 800ca98:	4618      	mov	r0, r3
 800ca9a:	3718      	adds	r7, #24
 800ca9c:	46bd      	mov	sp, r7
 800ca9e:	bd80      	pop	{r7, pc}

0800caa0 <USBH_GetDescriptor>:
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_GetDescriptor(USBH_HandleTypeDef *phost, uint8_t req_type, uint16_t value_idx,
                                      uint8_t *buff, uint16_t length)
{
 800caa0:	b580      	push	{r7, lr}
 800caa2:	b084      	sub	sp, #16
 800caa4:	af00      	add	r7, sp, #0
 800caa6:	60f8      	str	r0, [r7, #12]
 800caa8:	607b      	str	r3, [r7, #4]
 800caaa:	460b      	mov	r3, r1
 800caac:	72fb      	strb	r3, [r7, #11]
 800caae:	4613      	mov	r3, r2
 800cab0:	813b      	strh	r3, [r7, #8]
  if (phost->RequestState == CMD_SEND)
 800cab2:	68fb      	ldr	r3, [r7, #12]
 800cab4:	789b      	ldrb	r3, [r3, #2]
 800cab6:	2b01      	cmp	r3, #1
 800cab8:	d11c      	bne.n	800caf4 <USBH_GetDescriptor+0x54>
  {
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800caba:	7afb      	ldrb	r3, [r7, #11]
 800cabc:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 800cac0:	b2da      	uxtb	r2, r3
 800cac2:	68fb      	ldr	r3, [r7, #12]
 800cac4:	741a      	strb	r2, [r3, #16]
    phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 800cac6:	68fb      	ldr	r3, [r7, #12]
 800cac8:	2206      	movs	r2, #6
 800caca:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = value_idx;
 800cacc:	68fb      	ldr	r3, [r7, #12]
 800cace:	893a      	ldrh	r2, [r7, #8]
 800cad0:	825a      	strh	r2, [r3, #18]

    if ((value_idx & 0xff00U) == USB_DESC_STRING)
 800cad2:	893b      	ldrh	r3, [r7, #8]
 800cad4:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
 800cad8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800cadc:	d104      	bne.n	800cae8 <USBH_GetDescriptor+0x48>
    {
      phost->Control.setup.b.wIndex.w = 0x0409U;
 800cade:	68fb      	ldr	r3, [r7, #12]
 800cae0:	f240 4209 	movw	r2, #1033	@ 0x409
 800cae4:	829a      	strh	r2, [r3, #20]
 800cae6:	e002      	b.n	800caee <USBH_GetDescriptor+0x4e>
    }
    else
    {
      phost->Control.setup.b.wIndex.w = 0U;
 800cae8:	68fb      	ldr	r3, [r7, #12]
 800caea:	2200      	movs	r2, #0
 800caec:	829a      	strh	r2, [r3, #20]
    }
    phost->Control.setup.b.wLength.w = length;
 800caee:	68fb      	ldr	r3, [r7, #12]
 800caf0:	8b3a      	ldrh	r2, [r7, #24]
 800caf2:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, buff, length);
 800caf4:	8b3b      	ldrh	r3, [r7, #24]
 800caf6:	461a      	mov	r2, r3
 800caf8:	6879      	ldr	r1, [r7, #4]
 800cafa:	68f8      	ldr	r0, [r7, #12]
 800cafc:	f000 fba5 	bl	800d24a <USBH_CtlReq>
 800cb00:	4603      	mov	r3, r0
}
 800cb02:	4618      	mov	r0, r3
 800cb04:	3710      	adds	r7, #16
 800cb06:	46bd      	mov	sp, r7
 800cb08:	bd80      	pop	{r7, pc}

0800cb0a <USBH_SetAddress>:
  * @param  DeviceAddress: Device address to assign
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetAddress(USBH_HandleTypeDef *phost,
                                   uint8_t DeviceAddress)
{
 800cb0a:	b580      	push	{r7, lr}
 800cb0c:	b082      	sub	sp, #8
 800cb0e:	af00      	add	r7, sp, #0
 800cb10:	6078      	str	r0, [r7, #4]
 800cb12:	460b      	mov	r3, r1
 800cb14:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cb16:	687b      	ldr	r3, [r7, #4]
 800cb18:	789b      	ldrb	r3, [r3, #2]
 800cb1a:	2b01      	cmp	r3, #1
 800cb1c:	d10f      	bne.n	800cb3e <USBH_SetAddress+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 800cb1e:	687b      	ldr	r3, [r7, #4]
 800cb20:	2200      	movs	r2, #0
 800cb22:	741a      	strb	r2, [r3, #16]
                                           USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 800cb24:	687b      	ldr	r3, [r7, #4]
 800cb26:	2205      	movs	r2, #5
 800cb28:	745a      	strb	r2, [r3, #17]

    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 800cb2a:	78fb      	ldrb	r3, [r7, #3]
 800cb2c:	b29a      	uxth	r2, r3
 800cb2e:	687b      	ldr	r3, [r7, #4]
 800cb30:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cb32:	687b      	ldr	r3, [r7, #4]
 800cb34:	2200      	movs	r2, #0
 800cb36:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cb38:	687b      	ldr	r3, [r7, #4]
 800cb3a:	2200      	movs	r2, #0
 800cb3c:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cb3e:	2200      	movs	r2, #0
 800cb40:	2100      	movs	r1, #0
 800cb42:	6878      	ldr	r0, [r7, #4]
 800cb44:	f000 fb81 	bl	800d24a <USBH_CtlReq>
 800cb48:	4603      	mov	r3, r0
}
 800cb4a:	4618      	mov	r0, r3
 800cb4c:	3708      	adds	r7, #8
 800cb4e:	46bd      	mov	sp, r7
 800cb50:	bd80      	pop	{r7, pc}

0800cb52 <USBH_SetCfg>:
  * @param  phost: Host Handle
  * @param  cfg_idx: Configuration value
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetCfg(USBH_HandleTypeDef *phost, uint16_t cfg_idx)
{
 800cb52:	b580      	push	{r7, lr}
 800cb54:	b082      	sub	sp, #8
 800cb56:	af00      	add	r7, sp, #0
 800cb58:	6078      	str	r0, [r7, #4]
 800cb5a:	460b      	mov	r3, r1
 800cb5c:	807b      	strh	r3, [r7, #2]
  if (phost->RequestState == CMD_SEND)
 800cb5e:	687b      	ldr	r3, [r7, #4]
 800cb60:	789b      	ldrb	r3, [r3, #2]
 800cb62:	2b01      	cmp	r3, #1
 800cb64:	d10e      	bne.n	800cb84 <USBH_SetCfg+0x32>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800cb66:	687b      	ldr	r3, [r7, #4]
 800cb68:	2200      	movs	r2, #0
 800cb6a:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	2209      	movs	r2, #9
 800cb70:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = cfg_idx;
 800cb72:	687b      	ldr	r3, [r7, #4]
 800cb74:	887a      	ldrh	r2, [r7, #2]
 800cb76:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cb78:	687b      	ldr	r3, [r7, #4]
 800cb7a:	2200      	movs	r2, #0
 800cb7c:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cb7e:	687b      	ldr	r3, [r7, #4]
 800cb80:	2200      	movs	r2, #0
 800cb82:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cb84:	2200      	movs	r2, #0
 800cb86:	2100      	movs	r1, #0
 800cb88:	6878      	ldr	r0, [r7, #4]
 800cb8a:	f000 fb5e 	bl	800d24a <USBH_CtlReq>
 800cb8e:	4603      	mov	r3, r0
}
 800cb90:	4618      	mov	r0, r3
 800cb92:	3708      	adds	r7, #8
 800cb94:	46bd      	mov	sp, r7
 800cb96:	bd80      	pop	{r7, pc}

0800cb98 <USBH_SetFeature>:
  * @param  pdev: Selected device
  * @param  itf_idx
  * @retval Status
  */
USBH_StatusTypeDef USBH_SetFeature(USBH_HandleTypeDef *phost, uint8_t wValue)
{
 800cb98:	b580      	push	{r7, lr}
 800cb9a:	b082      	sub	sp, #8
 800cb9c:	af00      	add	r7, sp, #0
 800cb9e:	6078      	str	r0, [r7, #4]
 800cba0:	460b      	mov	r3, r1
 800cba2:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cba4:	687b      	ldr	r3, [r7, #4]
 800cba6:	789b      	ldrb	r3, [r3, #2]
 800cba8:	2b01      	cmp	r3, #1
 800cbaa:	d10f      	bne.n	800cbcc <USBH_SetFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 800cbac:	687b      	ldr	r3, [r7, #4]
 800cbae:	2200      	movs	r2, #0
 800cbb0:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_FEATURE;
 800cbb2:	687b      	ldr	r3, [r7, #4]
 800cbb4:	2203      	movs	r2, #3
 800cbb6:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = wValue;
 800cbb8:	78fb      	ldrb	r3, [r7, #3]
 800cbba:	b29a      	uxth	r2, r3
 800cbbc:	687b      	ldr	r3, [r7, #4]
 800cbbe:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 800cbc0:	687b      	ldr	r3, [r7, #4]
 800cbc2:	2200      	movs	r2, #0
 800cbc4:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cbc6:	687b      	ldr	r3, [r7, #4]
 800cbc8:	2200      	movs	r2, #0
 800cbca:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cbcc:	2200      	movs	r2, #0
 800cbce:	2100      	movs	r1, #0
 800cbd0:	6878      	ldr	r0, [r7, #4]
 800cbd2:	f000 fb3a 	bl	800d24a <USBH_CtlReq>
 800cbd6:	4603      	mov	r3, r0
}
 800cbd8:	4618      	mov	r0, r3
 800cbda:	3708      	adds	r7, #8
 800cbdc:	46bd      	mov	sp, r7
 800cbde:	bd80      	pop	{r7, pc}

0800cbe0 <USBH_ClrFeature>:
  * @param  ep_num: endpoint number
  * @param  hc_num: Host channel number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClrFeature(USBH_HandleTypeDef *phost, uint8_t ep_num)
{
 800cbe0:	b580      	push	{r7, lr}
 800cbe2:	b082      	sub	sp, #8
 800cbe4:	af00      	add	r7, sp, #0
 800cbe6:	6078      	str	r0, [r7, #4]
 800cbe8:	460b      	mov	r3, r1
 800cbea:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800cbec:	687b      	ldr	r3, [r7, #4]
 800cbee:	789b      	ldrb	r3, [r3, #2]
 800cbf0:	2b01      	cmp	r3, #1
 800cbf2:	d10f      	bne.n	800cc14 <USBH_ClrFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 800cbf4:	687b      	ldr	r3, [r7, #4]
 800cbf6:	2202      	movs	r2, #2
 800cbf8:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 800cbfa:	687b      	ldr	r3, [r7, #4]
 800cbfc:	2201      	movs	r2, #1
 800cbfe:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 800cc00:	687b      	ldr	r3, [r7, #4]
 800cc02:	2200      	movs	r2, #0
 800cc04:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = ep_num;
 800cc06:	78fb      	ldrb	r3, [r7, #3]
 800cc08:	b29a      	uxth	r2, r3
 800cc0a:	687b      	ldr	r3, [r7, #4]
 800cc0c:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800cc0e:	687b      	ldr	r3, [r7, #4]
 800cc10:	2200      	movs	r2, #0
 800cc12:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, NULL, 0U);
 800cc14:	2200      	movs	r2, #0
 800cc16:	2100      	movs	r1, #0
 800cc18:	6878      	ldr	r0, [r7, #4]
 800cc1a:	f000 fb16 	bl	800d24a <USBH_CtlReq>
 800cc1e:	4603      	mov	r3, r0
}
 800cc20:	4618      	mov	r0, r3
 800cc22:	3708      	adds	r7, #8
 800cc24:	46bd      	mov	sp, r7
 800cc26:	bd80      	pop	{r7, pc}

0800cc28 <USBH_ParseDevDesc>:
  * @param  buf: Buffer where the source descriptor is available
  * @param  length: Length of the descriptor
  * @retval USBH status
  */
static USBH_StatusTypeDef USBH_ParseDevDesc(USBH_HandleTypeDef *phost, uint8_t *buf, uint16_t length)
{
 800cc28:	b480      	push	{r7}
 800cc2a:	b087      	sub	sp, #28
 800cc2c:	af00      	add	r7, sp, #0
 800cc2e:	60f8      	str	r0, [r7, #12]
 800cc30:	60b9      	str	r1, [r7, #8]
 800cc32:	4613      	mov	r3, r2
 800cc34:	80fb      	strh	r3, [r7, #6]
  USBH_DevDescTypeDef *dev_desc = &phost->device.DevDesc;
 800cc36:	68fb      	ldr	r3, [r7, #12]
 800cc38:	f203 3326 	addw	r3, r3, #806	@ 0x326
 800cc3c:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef status = USBH_OK;
 800cc3e:	2300      	movs	r3, #0
 800cc40:	75fb      	strb	r3, [r7, #23]

  if (buf == NULL)
 800cc42:	68bb      	ldr	r3, [r7, #8]
 800cc44:	2b00      	cmp	r3, #0
 800cc46:	d101      	bne.n	800cc4c <USBH_ParseDevDesc+0x24>
  {
    return USBH_FAIL;
 800cc48:	2302      	movs	r3, #2
 800cc4a:	e094      	b.n	800cd76 <USBH_ParseDevDesc+0x14e>
  }

  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 800cc4c:	68bb      	ldr	r3, [r7, #8]
 800cc4e:	781a      	ldrb	r2, [r3, #0]
 800cc50:	693b      	ldr	r3, [r7, #16]
 800cc52:	701a      	strb	r2, [r3, #0]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1U);
 800cc54:	68bb      	ldr	r3, [r7, #8]
 800cc56:	785a      	ldrb	r2, [r3, #1]
 800cc58:	693b      	ldr	r3, [r7, #16]
 800cc5a:	705a      	strb	r2, [r3, #1]
  dev_desc->bcdUSB             = LE16(buf +  2U);
 800cc5c:	68bb      	ldr	r3, [r7, #8]
 800cc5e:	3302      	adds	r3, #2
 800cc60:	781b      	ldrb	r3, [r3, #0]
 800cc62:	461a      	mov	r2, r3
 800cc64:	68bb      	ldr	r3, [r7, #8]
 800cc66:	3303      	adds	r3, #3
 800cc68:	781b      	ldrb	r3, [r3, #0]
 800cc6a:	021b      	lsls	r3, r3, #8
 800cc6c:	b29b      	uxth	r3, r3
 800cc6e:	4313      	orrs	r3, r2
 800cc70:	b29a      	uxth	r2, r3
 800cc72:	693b      	ldr	r3, [r7, #16]
 800cc74:	805a      	strh	r2, [r3, #2]
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 800cc76:	68bb      	ldr	r3, [r7, #8]
 800cc78:	791a      	ldrb	r2, [r3, #4]
 800cc7a:	693b      	ldr	r3, [r7, #16]
 800cc7c:	711a      	strb	r2, [r3, #4]
  dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5U);
 800cc7e:	68bb      	ldr	r3, [r7, #8]
 800cc80:	795a      	ldrb	r2, [r3, #5]
 800cc82:	693b      	ldr	r3, [r7, #16]
 800cc84:	715a      	strb	r2, [r3, #5]
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6U);
 800cc86:	68bb      	ldr	r3, [r7, #8]
 800cc88:	799a      	ldrb	r2, [r3, #6]
 800cc8a:	693b      	ldr	r3, [r7, #16]
 800cc8c:	719a      	strb	r2, [r3, #6]
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7U);
 800cc8e:	68bb      	ldr	r3, [r7, #8]
 800cc90:	79da      	ldrb	r2, [r3, #7]
 800cc92:	693b      	ldr	r3, [r7, #16]
 800cc94:	71da      	strb	r2, [r3, #7]

  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800cc96:	68fb      	ldr	r3, [r7, #12]
 800cc98:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800cc9c:	2b00      	cmp	r3, #0
 800cc9e:	d004      	beq.n	800ccaa <USBH_ParseDevDesc+0x82>
      (phost->device.speed == (uint8_t)USBH_SPEED_FULL))
 800cca0:	68fb      	ldr	r3, [r7, #12]
 800cca2:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 800cca6:	2b01      	cmp	r3, #1
 800cca8:	d11b      	bne.n	800cce2 <USBH_ParseDevDesc+0xba>
  {
    /* Make sure that the max packet size is either 8, 16, 32, 64 or force it to minimum allowed value */
    switch (dev_desc->bMaxPacketSize)
 800ccaa:	693b      	ldr	r3, [r7, #16]
 800ccac:	79db      	ldrb	r3, [r3, #7]
 800ccae:	2b20      	cmp	r3, #32
 800ccb0:	dc0f      	bgt.n	800ccd2 <USBH_ParseDevDesc+0xaa>
 800ccb2:	2b08      	cmp	r3, #8
 800ccb4:	db0f      	blt.n	800ccd6 <USBH_ParseDevDesc+0xae>
 800ccb6:	3b08      	subs	r3, #8
 800ccb8:	4a32      	ldr	r2, [pc, #200]	@ (800cd84 <USBH_ParseDevDesc+0x15c>)
 800ccba:	fa22 f303 	lsr.w	r3, r2, r3
 800ccbe:	f003 0301 	and.w	r3, r3, #1
 800ccc2:	2b00      	cmp	r3, #0
 800ccc4:	bf14      	ite	ne
 800ccc6:	2301      	movne	r3, #1
 800ccc8:	2300      	moveq	r3, #0
 800ccca:	b2db      	uxtb	r3, r3
 800cccc:	2b00      	cmp	r3, #0
 800ccce:	d106      	bne.n	800ccde <USBH_ParseDevDesc+0xb6>
 800ccd0:	e001      	b.n	800ccd6 <USBH_ParseDevDesc+0xae>
 800ccd2:	2b40      	cmp	r3, #64	@ 0x40
 800ccd4:	d003      	beq.n	800ccde <USBH_ParseDevDesc+0xb6>
      case 64:
        break;

      default:
        /* set the size to min allowed value in case the device has answered with incorrect size */
        dev_desc->bMaxPacketSize = 8U;
 800ccd6:	693b      	ldr	r3, [r7, #16]
 800ccd8:	2208      	movs	r2, #8
 800ccda:	71da      	strb	r2, [r3, #7]
        break;
 800ccdc:	e000      	b.n	800cce0 <USBH_ParseDevDesc+0xb8>
        break;
 800ccde:	bf00      	nop
    switch (dev_desc->bMaxPacketSize)
 800cce0:	e00e      	b.n	800cd00 <USBH_ParseDevDesc+0xd8>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800cce2:	68fb      	ldr	r3, [r7, #12]
 800cce4:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800cce8:	2b02      	cmp	r3, #2
 800ccea:	d107      	bne.n	800ccfc <USBH_ParseDevDesc+0xd4>
  {
    if (dev_desc->bMaxPacketSize != 8U)
 800ccec:	693b      	ldr	r3, [r7, #16]
 800ccee:	79db      	ldrb	r3, [r3, #7]
 800ccf0:	2b08      	cmp	r3, #8
 800ccf2:	d005      	beq.n	800cd00 <USBH_ParseDevDesc+0xd8>
    {
      /* set the size to 8 in case the device has answered with incorrect size */
      dev_desc->bMaxPacketSize = 8U;
 800ccf4:	693b      	ldr	r3, [r7, #16]
 800ccf6:	2208      	movs	r2, #8
 800ccf8:	71da      	strb	r2, [r3, #7]
 800ccfa:	e001      	b.n	800cd00 <USBH_ParseDevDesc+0xd8>
    }
  }
  else
  {
    status = USBH_NOT_SUPPORTED;
 800ccfc:	2303      	movs	r3, #3
 800ccfe:	75fb      	strb	r3, [r7, #23]
  }

  if (length > 8U)
 800cd00:	88fb      	ldrh	r3, [r7, #6]
 800cd02:	2b08      	cmp	r3, #8
 800cd04:	d936      	bls.n	800cd74 <USBH_ParseDevDesc+0x14c>
  {
    /* For 1st time after device connection, Host may issue only 8 bytes for
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16(buf +  8U);
 800cd06:	68bb      	ldr	r3, [r7, #8]
 800cd08:	3308      	adds	r3, #8
 800cd0a:	781b      	ldrb	r3, [r3, #0]
 800cd0c:	461a      	mov	r2, r3
 800cd0e:	68bb      	ldr	r3, [r7, #8]
 800cd10:	3309      	adds	r3, #9
 800cd12:	781b      	ldrb	r3, [r3, #0]
 800cd14:	021b      	lsls	r3, r3, #8
 800cd16:	b29b      	uxth	r3, r3
 800cd18:	4313      	orrs	r3, r2
 800cd1a:	b29a      	uxth	r2, r3
 800cd1c:	693b      	ldr	r3, [r7, #16]
 800cd1e:	811a      	strh	r2, [r3, #8]
    dev_desc->idProduct          = LE16(buf + 10U);
 800cd20:	68bb      	ldr	r3, [r7, #8]
 800cd22:	330a      	adds	r3, #10
 800cd24:	781b      	ldrb	r3, [r3, #0]
 800cd26:	461a      	mov	r2, r3
 800cd28:	68bb      	ldr	r3, [r7, #8]
 800cd2a:	330b      	adds	r3, #11
 800cd2c:	781b      	ldrb	r3, [r3, #0]
 800cd2e:	021b      	lsls	r3, r3, #8
 800cd30:	b29b      	uxth	r3, r3
 800cd32:	4313      	orrs	r3, r2
 800cd34:	b29a      	uxth	r2, r3
 800cd36:	693b      	ldr	r3, [r7, #16]
 800cd38:	815a      	strh	r2, [r3, #10]
    dev_desc->bcdDevice          = LE16(buf + 12U);
 800cd3a:	68bb      	ldr	r3, [r7, #8]
 800cd3c:	330c      	adds	r3, #12
 800cd3e:	781b      	ldrb	r3, [r3, #0]
 800cd40:	461a      	mov	r2, r3
 800cd42:	68bb      	ldr	r3, [r7, #8]
 800cd44:	330d      	adds	r3, #13
 800cd46:	781b      	ldrb	r3, [r3, #0]
 800cd48:	021b      	lsls	r3, r3, #8
 800cd4a:	b29b      	uxth	r3, r3
 800cd4c:	4313      	orrs	r3, r2
 800cd4e:	b29a      	uxth	r2, r3
 800cd50:	693b      	ldr	r3, [r7, #16]
 800cd52:	819a      	strh	r2, [r3, #12]
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 800cd54:	68bb      	ldr	r3, [r7, #8]
 800cd56:	7b9a      	ldrb	r2, [r3, #14]
 800cd58:	693b      	ldr	r3, [r7, #16]
 800cd5a:	739a      	strb	r2, [r3, #14]
    dev_desc->iProduct           = *(uint8_t *)(buf + 15U);
 800cd5c:	68bb      	ldr	r3, [r7, #8]
 800cd5e:	7bda      	ldrb	r2, [r3, #15]
 800cd60:	693b      	ldr	r3, [r7, #16]
 800cd62:	73da      	strb	r2, [r3, #15]
    dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16U);
 800cd64:	68bb      	ldr	r3, [r7, #8]
 800cd66:	7c1a      	ldrb	r2, [r3, #16]
 800cd68:	693b      	ldr	r3, [r7, #16]
 800cd6a:	741a      	strb	r2, [r3, #16]
    dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17U);
 800cd6c:	68bb      	ldr	r3, [r7, #8]
 800cd6e:	7c5a      	ldrb	r2, [r3, #17]
 800cd70:	693b      	ldr	r3, [r7, #16]
 800cd72:	745a      	strb	r2, [r3, #17]
  }

  return status;
 800cd74:	7dfb      	ldrb	r3, [r7, #23]
}
 800cd76:	4618      	mov	r0, r3
 800cd78:	371c      	adds	r7, #28
 800cd7a:	46bd      	mov	sp, r7
 800cd7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd80:	4770      	bx	lr
 800cd82:	bf00      	nop
 800cd84:	01000101 	.word	0x01000101

0800cd88 <USBH_ParseCfgDesc>:
  * @param  buf: Buffer where the source descriptor is available
  * @param  length: Length of the descriptor
  * @retval USBH status
  */
static USBH_StatusTypeDef USBH_ParseCfgDesc(USBH_HandleTypeDef *phost, uint8_t *buf, uint16_t length)
{
 800cd88:	b580      	push	{r7, lr}
 800cd8a:	b08c      	sub	sp, #48	@ 0x30
 800cd8c:	af00      	add	r7, sp, #0
 800cd8e:	60f8      	str	r0, [r7, #12]
 800cd90:	60b9      	str	r1, [r7, #8]
 800cd92:	4613      	mov	r3, r2
 800cd94:	80fb      	strh	r3, [r7, #6]
  USBH_CfgDescTypeDef *cfg_desc = &phost->device.CfgDesc;
 800cd96:	68fb      	ldr	r3, [r7, #12]
 800cd98:	f503 734e 	add.w	r3, r3, #824	@ 0x338
 800cd9c:	623b      	str	r3, [r7, #32]
  USBH_StatusTypeDef           status = USBH_OK;
 800cd9e:	2300      	movs	r3, #0
 800cda0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  USBH_InterfaceDescTypeDef    *pif;
  USBH_EpDescTypeDef           *pep;
  USBH_DescHeader_t            *pdesc;
  uint16_t                     ptr;
  uint8_t                      if_ix = 0U;
 800cda4:	2300      	movs	r3, #0
 800cda6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t                      ep_ix = 0U;
 800cdaa:	2300      	movs	r3, #0
 800cdac:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26

  if (buf == NULL)
 800cdb0:	68bb      	ldr	r3, [r7, #8]
 800cdb2:	2b00      	cmp	r3, #0
 800cdb4:	d101      	bne.n	800cdba <USBH_ParseCfgDesc+0x32>
  {
    return USBH_FAIL;
 800cdb6:	2302      	movs	r3, #2
 800cdb8:	e0da      	b.n	800cf70 <USBH_ParseCfgDesc+0x1e8>
  }

  pdesc = (USBH_DescHeader_t *)(void *)buf;
 800cdba:	68bb      	ldr	r3, [r7, #8]
 800cdbc:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Parse configuration descriptor */
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 800cdbe:	68bb      	ldr	r3, [r7, #8]
 800cdc0:	781a      	ldrb	r2, [r3, #0]
 800cdc2:	6a3b      	ldr	r3, [r7, #32]
 800cdc4:	701a      	strb	r2, [r3, #0]
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1U);
 800cdc6:	68bb      	ldr	r3, [r7, #8]
 800cdc8:	785a      	ldrb	r2, [r3, #1]
 800cdca:	6a3b      	ldr	r3, [r7, #32]
 800cdcc:	705a      	strb	r2, [r3, #1]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800cdce:	68bb      	ldr	r3, [r7, #8]
 800cdd0:	3302      	adds	r3, #2
 800cdd2:	781b      	ldrb	r3, [r3, #0]
 800cdd4:	461a      	mov	r2, r3
 800cdd6:	68bb      	ldr	r3, [r7, #8]
 800cdd8:	3303      	adds	r3, #3
 800cdda:	781b      	ldrb	r3, [r3, #0]
 800cddc:	021b      	lsls	r3, r3, #8
 800cdde:	b29b      	uxth	r3, r3
 800cde0:	4313      	orrs	r3, r2
 800cde2:	b29b      	uxth	r3, r3
 800cde4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800cde8:	bf28      	it	cs
 800cdea:	f44f 7380 	movcs.w	r3, #256	@ 0x100
 800cdee:	b29a      	uxth	r2, r3
 800cdf0:	6a3b      	ldr	r3, [r7, #32]
 800cdf2:	805a      	strh	r2, [r3, #2]
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4U);
 800cdf4:	68bb      	ldr	r3, [r7, #8]
 800cdf6:	791a      	ldrb	r2, [r3, #4]
 800cdf8:	6a3b      	ldr	r3, [r7, #32]
 800cdfa:	711a      	strb	r2, [r3, #4]
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5U);
 800cdfc:	68bb      	ldr	r3, [r7, #8]
 800cdfe:	795a      	ldrb	r2, [r3, #5]
 800ce00:	6a3b      	ldr	r3, [r7, #32]
 800ce02:	715a      	strb	r2, [r3, #5]
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6U);
 800ce04:	68bb      	ldr	r3, [r7, #8]
 800ce06:	799a      	ldrb	r2, [r3, #6]
 800ce08:	6a3b      	ldr	r3, [r7, #32]
 800ce0a:	719a      	strb	r2, [r3, #6]
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7U);
 800ce0c:	68bb      	ldr	r3, [r7, #8]
 800ce0e:	79da      	ldrb	r2, [r3, #7]
 800ce10:	6a3b      	ldr	r3, [r7, #32]
 800ce12:	71da      	strb	r2, [r3, #7]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8U);
 800ce14:	68bb      	ldr	r3, [r7, #8]
 800ce16:	7a1a      	ldrb	r2, [r3, #8]
 800ce18:	6a3b      	ldr	r3, [r7, #32]
 800ce1a:	721a      	strb	r2, [r3, #8]

  /* Make sure that the Configuration descriptor's bLength is equal to USB_CONFIGURATION_DESC_SIZE */
  if (cfg_desc->bLength != USB_CONFIGURATION_DESC_SIZE)
 800ce1c:	6a3b      	ldr	r3, [r7, #32]
 800ce1e:	781b      	ldrb	r3, [r3, #0]
 800ce20:	2b09      	cmp	r3, #9
 800ce22:	d002      	beq.n	800ce2a <USBH_ParseCfgDesc+0xa2>
  {
    cfg_desc->bLength = USB_CONFIGURATION_DESC_SIZE;
 800ce24:	6a3b      	ldr	r3, [r7, #32]
 800ce26:	2209      	movs	r2, #9
 800ce28:	701a      	strb	r2, [r3, #0]
  }

  if (length > USB_CONFIGURATION_DESC_SIZE)
 800ce2a:	88fb      	ldrh	r3, [r7, #6]
 800ce2c:	2b09      	cmp	r3, #9
 800ce2e:	f240 809d 	bls.w	800cf6c <USBH_ParseCfgDesc+0x1e4>
  {
    ptr = USB_LEN_CFG_DESC;
 800ce32:	2309      	movs	r3, #9
 800ce34:	82fb      	strh	r3, [r7, #22]
    pif = (USBH_InterfaceDescTypeDef *)NULL;
 800ce36:	2300      	movs	r3, #0
 800ce38:	61fb      	str	r3, [r7, #28]

    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800ce3a:	e081      	b.n	800cf40 <USBH_ParseCfgDesc+0x1b8>
    {
      pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 800ce3c:	f107 0316 	add.w	r3, r7, #22
 800ce40:	4619      	mov	r1, r3
 800ce42:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800ce44:	f000 f9e7 	bl	800d216 <USBH_GetNextDesc>
 800ce48:	62b8      	str	r0, [r7, #40]	@ 0x28
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 800ce4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ce4c:	785b      	ldrb	r3, [r3, #1]
 800ce4e:	2b04      	cmp	r3, #4
 800ce50:	d176      	bne.n	800cf40 <USBH_ParseCfgDesc+0x1b8>
      {
        /* Make sure that the interface descriptor's bLength is equal to USB_INTERFACE_DESC_SIZE */
        if (pdesc->bLength != USB_INTERFACE_DESC_SIZE)
 800ce52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ce54:	781b      	ldrb	r3, [r3, #0]
 800ce56:	2b09      	cmp	r3, #9
 800ce58:	d002      	beq.n	800ce60 <USBH_ParseCfgDesc+0xd8>
        {
          pdesc->bLength = USB_INTERFACE_DESC_SIZE;
 800ce5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ce5c:	2209      	movs	r2, #9
 800ce5e:	701a      	strb	r2, [r3, #0]
        }

        pif = &cfg_desc->Itf_Desc[if_ix];
 800ce60:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800ce64:	221a      	movs	r2, #26
 800ce66:	fb02 f303 	mul.w	r3, r2, r3
 800ce6a:	3308      	adds	r3, #8
 800ce6c:	6a3a      	ldr	r2, [r7, #32]
 800ce6e:	4413      	add	r3, r2
 800ce70:	3302      	adds	r3, #2
 800ce72:	61fb      	str	r3, [r7, #28]
        USBH_ParseInterfaceDesc(pif, (uint8_t *)(void *)pdesc);
 800ce74:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800ce76:	69f8      	ldr	r0, [r7, #28]
 800ce78:	f000 f87e 	bl	800cf78 <USBH_ParseInterfaceDesc>

        ep_ix = 0U;
 800ce7c:	2300      	movs	r3, #0
 800ce7e:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        pep = (USBH_EpDescTypeDef *)NULL;
 800ce82:	2300      	movs	r3, #0
 800ce84:	61bb      	str	r3, [r7, #24]

        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800ce86:	e043      	b.n	800cf10 <USBH_ParseCfgDesc+0x188>
        {
          pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 800ce88:	f107 0316 	add.w	r3, r7, #22
 800ce8c:	4619      	mov	r1, r3
 800ce8e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800ce90:	f000 f9c1 	bl	800d216 <USBH_GetNextDesc>
 800ce94:	62b8      	str	r0, [r7, #40]	@ 0x28

          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 800ce96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ce98:	785b      	ldrb	r3, [r3, #1]
 800ce9a:	2b05      	cmp	r3, #5
 800ce9c:	d138      	bne.n	800cf10 <USBH_ParseCfgDesc+0x188>
          {
            /* Check if the endpoint is appartening to an audio streaming interface */
            if ((pif->bInterfaceClass == 0x01U) &&
 800ce9e:	69fb      	ldr	r3, [r7, #28]
 800cea0:	795b      	ldrb	r3, [r3, #5]
 800cea2:	2b01      	cmp	r3, #1
 800cea4:	d113      	bne.n	800cece <USBH_ParseCfgDesc+0x146>
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 800cea6:	69fb      	ldr	r3, [r7, #28]
 800cea8:	799b      	ldrb	r3, [r3, #6]
            if ((pif->bInterfaceClass == 0x01U) &&
 800ceaa:	2b02      	cmp	r3, #2
 800ceac:	d003      	beq.n	800ceb6 <USBH_ParseCfgDesc+0x12e>
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 800ceae:	69fb      	ldr	r3, [r7, #28]
 800ceb0:	799b      	ldrb	r3, [r3, #6]
 800ceb2:	2b03      	cmp	r3, #3
 800ceb4:	d10b      	bne.n	800cece <USBH_ParseCfgDesc+0x146>
            {
              /* Check if it is supporting the USB AUDIO 01 class specification */
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800ceb6:	69fb      	ldr	r3, [r7, #28]
 800ceb8:	79db      	ldrb	r3, [r3, #7]
 800ceba:	2b00      	cmp	r3, #0
 800cebc:	d10b      	bne.n	800ced6 <USBH_ParseCfgDesc+0x14e>
 800cebe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cec0:	781b      	ldrb	r3, [r3, #0]
 800cec2:	2b09      	cmp	r3, #9
 800cec4:	d007      	beq.n	800ced6 <USBH_ParseCfgDesc+0x14e>
              {
                pdesc->bLength = 0x09U;
 800cec6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cec8:	2209      	movs	r2, #9
 800ceca:	701a      	strb	r2, [r3, #0]
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800cecc:	e003      	b.n	800ced6 <USBH_ParseCfgDesc+0x14e>
            }
            /* Make sure that the endpoint descriptor's bLength is equal to
               USB_ENDPOINT_DESC_SIZE for all other endpoints types */
            else
            {
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 800cece:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ced0:	2207      	movs	r2, #7
 800ced2:	701a      	strb	r2, [r3, #0]
 800ced4:	e000      	b.n	800ced8 <USBH_ParseCfgDesc+0x150>
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800ced6:	bf00      	nop
            }

            pep = &cfg_desc->Itf_Desc[if_ix].Ep_Desc[ep_ix];
 800ced8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800cedc:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800cee0:	3201      	adds	r2, #1
 800cee2:	00d2      	lsls	r2, r2, #3
 800cee4:	211a      	movs	r1, #26
 800cee6:	fb01 f303 	mul.w	r3, r1, r3
 800ceea:	4413      	add	r3, r2
 800ceec:	3308      	adds	r3, #8
 800ceee:	6a3a      	ldr	r2, [r7, #32]
 800cef0:	4413      	add	r3, r2
 800cef2:	3304      	adds	r3, #4
 800cef4:	61bb      	str	r3, [r7, #24]

            status = USBH_ParseEPDesc(phost, pep, (uint8_t *)(void *)pdesc);
 800cef6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800cef8:	69b9      	ldr	r1, [r7, #24]
 800cefa:	68f8      	ldr	r0, [r7, #12]
 800cefc:	f000 f870 	bl	800cfe0 <USBH_ParseEPDesc>
 800cf00:	4603      	mov	r3, r0
 800cf02:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

            ep_ix++;
 800cf06:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 800cf0a:	3301      	adds	r3, #1
 800cf0c:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800cf10:	69fb      	ldr	r3, [r7, #28]
 800cf12:	791b      	ldrb	r3, [r3, #4]
 800cf14:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800cf18:	429a      	cmp	r2, r3
 800cf1a:	d204      	bcs.n	800cf26 <USBH_ParseCfgDesc+0x19e>
 800cf1c:	6a3b      	ldr	r3, [r7, #32]
 800cf1e:	885a      	ldrh	r2, [r3, #2]
 800cf20:	8afb      	ldrh	r3, [r7, #22]
 800cf22:	429a      	cmp	r2, r3
 800cf24:	d8b0      	bhi.n	800ce88 <USBH_ParseCfgDesc+0x100>
          }
        }

        /* Check if the required endpoint(s) data are parsed */
        if (ep_ix < pif->bNumEndpoints)
 800cf26:	69fb      	ldr	r3, [r7, #28]
 800cf28:	791b      	ldrb	r3, [r3, #4]
 800cf2a:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800cf2e:	429a      	cmp	r2, r3
 800cf30:	d201      	bcs.n	800cf36 <USBH_ParseCfgDesc+0x1ae>
        {
          return USBH_NOT_SUPPORTED;
 800cf32:	2303      	movs	r3, #3
 800cf34:	e01c      	b.n	800cf70 <USBH_ParseCfgDesc+0x1e8>
        }

        if_ix++;
 800cf36:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800cf3a:	3301      	adds	r3, #1
 800cf3c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800cf40:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800cf44:	2b01      	cmp	r3, #1
 800cf46:	d805      	bhi.n	800cf54 <USBH_ParseCfgDesc+0x1cc>
 800cf48:	6a3b      	ldr	r3, [r7, #32]
 800cf4a:	885a      	ldrh	r2, [r3, #2]
 800cf4c:	8afb      	ldrh	r3, [r7, #22]
 800cf4e:	429a      	cmp	r2, r3
 800cf50:	f63f af74 	bhi.w	800ce3c <USBH_ParseCfgDesc+0xb4>
      }
    }

    /* Check if the required interface(s) data are parsed */
    if (if_ix < MIN(cfg_desc->bNumInterfaces, (uint8_t)USBH_MAX_NUM_INTERFACES))
 800cf54:	6a3b      	ldr	r3, [r7, #32]
 800cf56:	791b      	ldrb	r3, [r3, #4]
 800cf58:	2b02      	cmp	r3, #2
 800cf5a:	bf28      	it	cs
 800cf5c:	2302      	movcs	r3, #2
 800cf5e:	b2db      	uxtb	r3, r3
 800cf60:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 800cf64:	429a      	cmp	r2, r3
 800cf66:	d201      	bcs.n	800cf6c <USBH_ParseCfgDesc+0x1e4>
    {
      return USBH_NOT_SUPPORTED;
 800cf68:	2303      	movs	r3, #3
 800cf6a:	e001      	b.n	800cf70 <USBH_ParseCfgDesc+0x1e8>
    }
  }

  return status;
 800cf6c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 800cf70:	4618      	mov	r0, r3
 800cf72:	3730      	adds	r7, #48	@ 0x30
 800cf74:	46bd      	mov	sp, r7
 800cf76:	bd80      	pop	{r7, pc}

0800cf78 <USBH_ParseInterfaceDesc>:
  * @param  if_descriptor : Interface descriptor destination
  * @param  buf: Buffer where the descriptor data is available
  * @retval None
  */
static void USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor, uint8_t *buf)
{
 800cf78:	b480      	push	{r7}
 800cf7a:	b083      	sub	sp, #12
 800cf7c:	af00      	add	r7, sp, #0
 800cf7e:	6078      	str	r0, [r7, #4]
 800cf80:	6039      	str	r1, [r7, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0U);
 800cf82:	683b      	ldr	r3, [r7, #0]
 800cf84:	781a      	ldrb	r2, [r3, #0]
 800cf86:	687b      	ldr	r3, [r7, #4]
 800cf88:	701a      	strb	r2, [r3, #0]
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1U);
 800cf8a:	683b      	ldr	r3, [r7, #0]
 800cf8c:	785a      	ldrb	r2, [r3, #1]
 800cf8e:	687b      	ldr	r3, [r7, #4]
 800cf90:	705a      	strb	r2, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2U);
 800cf92:	683b      	ldr	r3, [r7, #0]
 800cf94:	789a      	ldrb	r2, [r3, #2]
 800cf96:	687b      	ldr	r3, [r7, #4]
 800cf98:	709a      	strb	r2, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3U);
 800cf9a:	683b      	ldr	r3, [r7, #0]
 800cf9c:	78da      	ldrb	r2, [r3, #3]
 800cf9e:	687b      	ldr	r3, [r7, #4]
 800cfa0:	70da      	strb	r2, [r3, #3]
  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4U), USBH_MAX_NUM_ENDPOINTS);
 800cfa2:	683b      	ldr	r3, [r7, #0]
 800cfa4:	3304      	adds	r3, #4
 800cfa6:	781b      	ldrb	r3, [r3, #0]
 800cfa8:	2b02      	cmp	r3, #2
 800cfaa:	bf28      	it	cs
 800cfac:	2302      	movcs	r3, #2
 800cfae:	b2da      	uxtb	r2, r3
 800cfb0:	687b      	ldr	r3, [r7, #4]
 800cfb2:	711a      	strb	r2, [r3, #4]
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5U);
 800cfb4:	683b      	ldr	r3, [r7, #0]
 800cfb6:	795a      	ldrb	r2, [r3, #5]
 800cfb8:	687b      	ldr	r3, [r7, #4]
 800cfba:	715a      	strb	r2, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6U);
 800cfbc:	683b      	ldr	r3, [r7, #0]
 800cfbe:	799a      	ldrb	r2, [r3, #6]
 800cfc0:	687b      	ldr	r3, [r7, #4]
 800cfc2:	719a      	strb	r2, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7U);
 800cfc4:	683b      	ldr	r3, [r7, #0]
 800cfc6:	79da      	ldrb	r2, [r3, #7]
 800cfc8:	687b      	ldr	r3, [r7, #4]
 800cfca:	71da      	strb	r2, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8U);
 800cfcc:	683b      	ldr	r3, [r7, #0]
 800cfce:	7a1a      	ldrb	r2, [r3, #8]
 800cfd0:	687b      	ldr	r3, [r7, #4]
 800cfd2:	721a      	strb	r2, [r3, #8]
}
 800cfd4:	bf00      	nop
 800cfd6:	370c      	adds	r7, #12
 800cfd8:	46bd      	mov	sp, r7
 800cfda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfde:	4770      	bx	lr

0800cfe0 <USBH_ParseEPDesc>:
  * @param  ep_descriptor: Endpoint descriptor destination address
  * @param  buf: Buffer where the parsed descriptor stored
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_ParseEPDesc(USBH_HandleTypeDef *phost, USBH_EpDescTypeDef *ep_descriptor, uint8_t *buf)
{
 800cfe0:	b480      	push	{r7}
 800cfe2:	b087      	sub	sp, #28
 800cfe4:	af00      	add	r7, sp, #0
 800cfe6:	60f8      	str	r0, [r7, #12]
 800cfe8:	60b9      	str	r1, [r7, #8]
 800cfea:	607a      	str	r2, [r7, #4]
  USBH_StatusTypeDef status = USBH_OK;
 800cfec:	2300      	movs	r3, #0
 800cfee:	75fb      	strb	r3, [r7, #23]

  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800cff0:	687b      	ldr	r3, [r7, #4]
 800cff2:	781a      	ldrb	r2, [r3, #0]
 800cff4:	68bb      	ldr	r3, [r7, #8]
 800cff6:	701a      	strb	r2, [r3, #0]
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1U);
 800cff8:	687b      	ldr	r3, [r7, #4]
 800cffa:	785a      	ldrb	r2, [r3, #1]
 800cffc:	68bb      	ldr	r3, [r7, #8]
 800cffe:	705a      	strb	r2, [r3, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2U);
 800d000:	687b      	ldr	r3, [r7, #4]
 800d002:	789a      	ldrb	r2, [r3, #2]
 800d004:	68bb      	ldr	r3, [r7, #8]
 800d006:	709a      	strb	r2, [r3, #2]
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3U);
 800d008:	687b      	ldr	r3, [r7, #4]
 800d00a:	78da      	ldrb	r2, [r3, #3]
 800d00c:	68bb      	ldr	r3, [r7, #8]
 800d00e:	70da      	strb	r2, [r3, #3]
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 800d010:	687b      	ldr	r3, [r7, #4]
 800d012:	3304      	adds	r3, #4
 800d014:	781b      	ldrb	r3, [r3, #0]
 800d016:	461a      	mov	r2, r3
 800d018:	687b      	ldr	r3, [r7, #4]
 800d01a:	3305      	adds	r3, #5
 800d01c:	781b      	ldrb	r3, [r3, #0]
 800d01e:	021b      	lsls	r3, r3, #8
 800d020:	b29b      	uxth	r3, r3
 800d022:	4313      	orrs	r3, r2
 800d024:	b29a      	uxth	r2, r3
 800d026:	68bb      	ldr	r3, [r7, #8]
 800d028:	809a      	strh	r2, [r3, #4]
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6U);
 800d02a:	687b      	ldr	r3, [r7, #4]
 800d02c:	799a      	ldrb	r2, [r3, #6]
 800d02e:	68bb      	ldr	r3, [r7, #8]
 800d030:	719a      	strb	r2, [r3, #6]

  /* Make sure that wMaxPacketSize is different from 0 */
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 800d032:	68bb      	ldr	r3, [r7, #8]
 800d034:	889b      	ldrh	r3, [r3, #4]
 800d036:	2b00      	cmp	r3, #0
 800d038:	d009      	beq.n	800d04e <USBH_ParseEPDesc+0x6e>
      (ep_descriptor->wMaxPacketSize > USBH_MAX_EP_PACKET_SIZE) ||
 800d03a:	68bb      	ldr	r3, [r7, #8]
 800d03c:	889b      	ldrh	r3, [r3, #4]
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 800d03e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800d042:	d804      	bhi.n	800d04e <USBH_ParseEPDesc+0x6e>
      (ep_descriptor->wMaxPacketSize > USBH_MAX_DATA_BUFFER))
 800d044:	68bb      	ldr	r3, [r7, #8]
 800d046:	889b      	ldrh	r3, [r3, #4]
      (ep_descriptor->wMaxPacketSize > USBH_MAX_EP_PACKET_SIZE) ||
 800d048:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d04c:	d901      	bls.n	800d052 <USBH_ParseEPDesc+0x72>
  {
    status = USBH_NOT_SUPPORTED;
 800d04e:	2303      	movs	r3, #3
 800d050:	75fb      	strb	r3, [r7, #23]
  }

  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 800d052:	68fb      	ldr	r3, [r7, #12]
 800d054:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d058:	2b00      	cmp	r3, #0
 800d05a:	d136      	bne.n	800d0ca <USBH_ParseEPDesc+0xea>
  {
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK)
 800d05c:	68bb      	ldr	r3, [r7, #8]
 800d05e:	78db      	ldrb	r3, [r3, #3]
 800d060:	f003 0303 	and.w	r3, r3, #3
 800d064:	2b02      	cmp	r3, #2
 800d066:	d108      	bne.n	800d07a <USBH_ParseEPDesc+0x9a>
    {
      if (ep_descriptor->wMaxPacketSize > 512U)
 800d068:	68bb      	ldr	r3, [r7, #8]
 800d06a:	889b      	ldrh	r3, [r3, #4]
 800d06c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d070:	f240 8097 	bls.w	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d074:	2303      	movs	r3, #3
 800d076:	75fb      	strb	r3, [r7, #23]
 800d078:	e093      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800d07a:	68bb      	ldr	r3, [r7, #8]
 800d07c:	78db      	ldrb	r3, [r3, #3]
 800d07e:	f003 0303 	and.w	r3, r3, #3
 800d082:	2b00      	cmp	r3, #0
 800d084:	d107      	bne.n	800d096 <USBH_ParseEPDesc+0xb6>
    {
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d086:	68bb      	ldr	r3, [r7, #8]
 800d088:	889b      	ldrh	r3, [r3, #4]
 800d08a:	2b40      	cmp	r3, #64	@ 0x40
 800d08c:	f240 8089 	bls.w	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d090:	2303      	movs	r3, #3
 800d092:	75fb      	strb	r3, [r7, #23]
 800d094:	e085      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For high-speed interrupt/isochronous endpoints, bInterval can vary from 1 to 16 */
    else if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 800d096:	68bb      	ldr	r3, [r7, #8]
 800d098:	78db      	ldrb	r3, [r3, #3]
 800d09a:	f003 0303 	and.w	r3, r3, #3
 800d09e:	2b01      	cmp	r3, #1
 800d0a0:	d005      	beq.n	800d0ae <USBH_ParseEPDesc+0xce>
        ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR))
 800d0a2:	68bb      	ldr	r3, [r7, #8]
 800d0a4:	78db      	ldrb	r3, [r3, #3]
 800d0a6:	f003 0303 	and.w	r3, r3, #3
    else if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC) ||
 800d0aa:	2b03      	cmp	r3, #3
 800d0ac:	d10a      	bne.n	800d0c4 <USBH_ParseEPDesc+0xe4>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d0ae:	68bb      	ldr	r3, [r7, #8]
 800d0b0:	799b      	ldrb	r3, [r3, #6]
 800d0b2:	2b00      	cmp	r3, #0
 800d0b4:	d003      	beq.n	800d0be <USBH_ParseEPDesc+0xde>
 800d0b6:	68bb      	ldr	r3, [r7, #8]
 800d0b8:	799b      	ldrb	r3, [r3, #6]
 800d0ba:	2b10      	cmp	r3, #16
 800d0bc:	d970      	bls.n	800d1a0 <USBH_ParseEPDesc+0x1c0>
      {
        status = USBH_NOT_SUPPORTED;
 800d0be:	2303      	movs	r3, #3
 800d0c0:	75fb      	strb	r3, [r7, #23]
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d0c2:	e06d      	b.n	800d1a0 <USBH_ParseEPDesc+0x1c0>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d0c4:	2303      	movs	r3, #3
 800d0c6:	75fb      	strb	r3, [r7, #23]
 800d0c8:	e06b      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 800d0ca:	68fb      	ldr	r3, [r7, #12]
 800d0cc:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d0d0:	2b01      	cmp	r3, #1
 800d0d2:	d13c      	bne.n	800d14e <USBH_ParseEPDesc+0x16e>
  {
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 800d0d4:	68bb      	ldr	r3, [r7, #8]
 800d0d6:	78db      	ldrb	r3, [r3, #3]
 800d0d8:	f003 0303 	and.w	r3, r3, #3
 800d0dc:	2b02      	cmp	r3, #2
 800d0de:	d005      	beq.n	800d0ec <USBH_ParseEPDesc+0x10c>
        ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL))
 800d0e0:	68bb      	ldr	r3, [r7, #8]
 800d0e2:	78db      	ldrb	r3, [r3, #3]
 800d0e4:	f003 0303 	and.w	r3, r3, #3
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 800d0e8:	2b00      	cmp	r3, #0
 800d0ea:	d106      	bne.n	800d0fa <USBH_ParseEPDesc+0x11a>
    {
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d0ec:	68bb      	ldr	r3, [r7, #8]
 800d0ee:	889b      	ldrh	r3, [r3, #4]
 800d0f0:	2b40      	cmp	r3, #64	@ 0x40
 800d0f2:	d956      	bls.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d0f4:	2303      	movs	r3, #3
 800d0f6:	75fb      	strb	r3, [r7, #23]
      if (ep_descriptor->wMaxPacketSize > 64U)
 800d0f8:	e053      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For full-speed isochronous endpoints, the value of bInterval must be in the range from 1 to 16.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC)
 800d0fa:	68bb      	ldr	r3, [r7, #8]
 800d0fc:	78db      	ldrb	r3, [r3, #3]
 800d0fe:	f003 0303 	and.w	r3, r3, #3
 800d102:	2b01      	cmp	r3, #1
 800d104:	d10e      	bne.n	800d124 <USBH_ParseEPDesc+0x144>
    {
      if ((ep_descriptor->bInterval == 0U) ||
 800d106:	68bb      	ldr	r3, [r7, #8]
 800d108:	799b      	ldrb	r3, [r3, #6]
 800d10a:	2b00      	cmp	r3, #0
 800d10c:	d007      	beq.n	800d11e <USBH_ParseEPDesc+0x13e>
          (ep_descriptor->bInterval > 0x10U) ||
 800d10e:	68bb      	ldr	r3, [r7, #8]
 800d110:	799b      	ldrb	r3, [r3, #6]
      if ((ep_descriptor->bInterval == 0U) ||
 800d112:	2b10      	cmp	r3, #16
 800d114:	d803      	bhi.n	800d11e <USBH_ParseEPDesc+0x13e>
          (ep_descriptor->wMaxPacketSize > 64U))
 800d116:	68bb      	ldr	r3, [r7, #8]
 800d118:	889b      	ldrh	r3, [r3, #4]
          (ep_descriptor->bInterval > 0x10U) ||
 800d11a:	2b40      	cmp	r3, #64	@ 0x40
 800d11c:	d941      	bls.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d11e:	2303      	movs	r3, #3
 800d120:	75fb      	strb	r3, [r7, #23]
 800d122:	e03e      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For full-speed interrupt endpoints, the value of bInterval may be from 1 to 255.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR)
 800d124:	68bb      	ldr	r3, [r7, #8]
 800d126:	78db      	ldrb	r3, [r3, #3]
 800d128:	f003 0303 	and.w	r3, r3, #3
 800d12c:	2b03      	cmp	r3, #3
 800d12e:	d10b      	bne.n	800d148 <USBH_ParseEPDesc+0x168>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 1023U))
 800d130:	68bb      	ldr	r3, [r7, #8]
 800d132:	799b      	ldrb	r3, [r3, #6]
 800d134:	2b00      	cmp	r3, #0
 800d136:	d004      	beq.n	800d142 <USBH_ParseEPDesc+0x162>
 800d138:	68bb      	ldr	r3, [r7, #8]
 800d13a:	889b      	ldrh	r3, [r3, #4]
 800d13c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800d140:	d32f      	bcc.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d142:	2303      	movs	r3, #3
 800d144:	75fb      	strb	r3, [r7, #23]
 800d146:	e02c      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d148:	2303      	movs	r3, #3
 800d14a:	75fb      	strb	r3, [r7, #23]
 800d14c:	e029      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
    }
  }
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800d14e:	68fb      	ldr	r3, [r7, #12]
 800d150:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d154:	2b02      	cmp	r3, #2
 800d156:	d120      	bne.n	800d19a <USBH_ParseEPDesc+0x1ba>
  {
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 800d158:	68bb      	ldr	r3, [r7, #8]
 800d15a:	78db      	ldrb	r3, [r3, #3]
 800d15c:	f003 0303 	and.w	r3, r3, #3
 800d160:	2b00      	cmp	r3, #0
 800d162:	d106      	bne.n	800d172 <USBH_ParseEPDesc+0x192>
    {
      if (ep_descriptor->wMaxPacketSize != 8U)
 800d164:	68bb      	ldr	r3, [r7, #8]
 800d166:	889b      	ldrh	r3, [r3, #4]
 800d168:	2b08      	cmp	r3, #8
 800d16a:	d01a      	beq.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d16c:	2303      	movs	r3, #3
 800d16e:	75fb      	strb	r3, [r7, #23]
 800d170:	e017      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    /* For low-speed interrupt endpoints, the value of bInterval may be from 1 to 255.*/
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_INTR)
 800d172:	68bb      	ldr	r3, [r7, #8]
 800d174:	78db      	ldrb	r3, [r3, #3]
 800d176:	f003 0303 	and.w	r3, r3, #3
 800d17a:	2b03      	cmp	r3, #3
 800d17c:	d10a      	bne.n	800d194 <USBH_ParseEPDesc+0x1b4>
    {
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 8U))
 800d17e:	68bb      	ldr	r3, [r7, #8]
 800d180:	799b      	ldrb	r3, [r3, #6]
 800d182:	2b00      	cmp	r3, #0
 800d184:	d003      	beq.n	800d18e <USBH_ParseEPDesc+0x1ae>
 800d186:	68bb      	ldr	r3, [r7, #8]
 800d188:	889b      	ldrh	r3, [r3, #4]
 800d18a:	2b08      	cmp	r3, #8
 800d18c:	d909      	bls.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      {
        status = USBH_NOT_SUPPORTED;
 800d18e:	2303      	movs	r3, #3
 800d190:	75fb      	strb	r3, [r7, #23]
 800d192:	e006      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      }
    }
    else
    {
      status = USBH_NOT_SUPPORTED;
 800d194:	2303      	movs	r3, #3
 800d196:	75fb      	strb	r3, [r7, #23]
 800d198:	e003      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
    }
  }
  else
  {
    status = USBH_NOT_SUPPORTED;
 800d19a:	2303      	movs	r3, #3
 800d19c:	75fb      	strb	r3, [r7, #23]
 800d19e:	e000      	b.n	800d1a2 <USBH_ParseEPDesc+0x1c2>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 800d1a0:	bf00      	nop
  }

  return status;
 800d1a2:	7dfb      	ldrb	r3, [r7, #23]
}
 800d1a4:	4618      	mov	r0, r3
 800d1a6:	371c      	adds	r7, #28
 800d1a8:	46bd      	mov	sp, r7
 800d1aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1ae:	4770      	bx	lr

0800d1b0 <USBH_ParseStringDesc>:
  * @param  pdest: Destination address pointer
  * @param  length: Length of the descriptor
  * @retval None
  */
static void USBH_ParseStringDesc(uint8_t *psrc, uint8_t *pdest, uint16_t length)
{
 800d1b0:	b480      	push	{r7}
 800d1b2:	b087      	sub	sp, #28
 800d1b4:	af00      	add	r7, sp, #0
 800d1b6:	60f8      	str	r0, [r7, #12]
 800d1b8:	60b9      	str	r1, [r7, #8]
 800d1ba:	4613      	mov	r3, r2
 800d1bc:	80fb      	strh	r3, [r7, #6]
  */

  /* Check which is lower size, the Size of string or the length of bytes read
  from the device */

  if (psrc[1] == USB_DESC_TYPE_STRING)
 800d1be:	68fb      	ldr	r3, [r7, #12]
 800d1c0:	3301      	adds	r3, #1
 800d1c2:	781b      	ldrb	r3, [r3, #0]
 800d1c4:	2b03      	cmp	r3, #3
 800d1c6:	d120      	bne.n	800d20a <USBH_ParseStringDesc+0x5a>
  {
    /* Make sure the Descriptor is String Type */

    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 800d1c8:	68fb      	ldr	r3, [r7, #12]
 800d1ca:	781b      	ldrb	r3, [r3, #0]
 800d1cc:	1e9a      	subs	r2, r3, #2
 800d1ce:	88fb      	ldrh	r3, [r7, #6]
 800d1d0:	4293      	cmp	r3, r2
 800d1d2:	bf28      	it	cs
 800d1d4:	4613      	movcs	r3, r2
 800d1d6:	82bb      	strh	r3, [r7, #20]

    /* Adjust the offset ignoring the String Len and Descriptor type */
    psrc += 2U;
 800d1d8:	68fb      	ldr	r3, [r7, #12]
 800d1da:	3302      	adds	r3, #2
 800d1dc:	60fb      	str	r3, [r7, #12]

    for (idx = 0U; idx < strlength; idx += 2U)
 800d1de:	2300      	movs	r3, #0
 800d1e0:	82fb      	strh	r3, [r7, #22]
 800d1e2:	e00b      	b.n	800d1fc <USBH_ParseStringDesc+0x4c>
    {
      /* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
 800d1e4:	8afb      	ldrh	r3, [r7, #22]
 800d1e6:	68fa      	ldr	r2, [r7, #12]
 800d1e8:	4413      	add	r3, r2
 800d1ea:	781a      	ldrb	r2, [r3, #0]
 800d1ec:	68bb      	ldr	r3, [r7, #8]
 800d1ee:	701a      	strb	r2, [r3, #0]
      pdest++;
 800d1f0:	68bb      	ldr	r3, [r7, #8]
 800d1f2:	3301      	adds	r3, #1
 800d1f4:	60bb      	str	r3, [r7, #8]
    for (idx = 0U; idx < strlength; idx += 2U)
 800d1f6:	8afb      	ldrh	r3, [r7, #22]
 800d1f8:	3302      	adds	r3, #2
 800d1fa:	82fb      	strh	r3, [r7, #22]
 800d1fc:	8afa      	ldrh	r2, [r7, #22]
 800d1fe:	8abb      	ldrh	r3, [r7, #20]
 800d200:	429a      	cmp	r2, r3
 800d202:	d3ef      	bcc.n	800d1e4 <USBH_ParseStringDesc+0x34>
    }
    *pdest = 0U; /* mark end of string */
 800d204:	68bb      	ldr	r3, [r7, #8]
 800d206:	2200      	movs	r2, #0
 800d208:	701a      	strb	r2, [r3, #0]
  }
}
 800d20a:	bf00      	nop
 800d20c:	371c      	adds	r7, #28
 800d20e:	46bd      	mov	sp, r7
 800d210:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d214:	4770      	bx	lr

0800d216 <USBH_GetNextDesc>:
  * @param  buf: Buffer where the cfg descriptor is available
  * @param  ptr: data pointer inside the cfg descriptor
  * @retval next header
  */
USBH_DescHeader_t *USBH_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 800d216:	b480      	push	{r7}
 800d218:	b085      	sub	sp, #20
 800d21a:	af00      	add	r7, sp, #0
 800d21c:	6078      	str	r0, [r7, #4]
 800d21e:	6039      	str	r1, [r7, #0]
  USBH_DescHeader_t *pnext;

  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800d220:	683b      	ldr	r3, [r7, #0]
 800d222:	881b      	ldrh	r3, [r3, #0]
 800d224:	687a      	ldr	r2, [r7, #4]
 800d226:	7812      	ldrb	r2, [r2, #0]
 800d228:	4413      	add	r3, r2
 800d22a:	b29a      	uxth	r2, r3
 800d22c:	683b      	ldr	r3, [r7, #0]
 800d22e:	801a      	strh	r2, [r3, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
                                        ((USBH_DescHeader_t *)(void *)pbuf)->bLength);
 800d230:	687b      	ldr	r3, [r7, #4]
 800d232:	781b      	ldrb	r3, [r3, #0]
 800d234:	461a      	mov	r2, r3
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800d236:	687b      	ldr	r3, [r7, #4]
 800d238:	4413      	add	r3, r2
 800d23a:	60fb      	str	r3, [r7, #12]

  return (pnext);
 800d23c:	68fb      	ldr	r3, [r7, #12]
}
 800d23e:	4618      	mov	r0, r3
 800d240:	3714      	adds	r7, #20
 800d242:	46bd      	mov	sp, r7
 800d244:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d248:	4770      	bx	lr

0800d24a <USBH_CtlReq>:
  * @param  length: length of the response
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
                               uint16_t length)
{
 800d24a:	b580      	push	{r7, lr}
 800d24c:	b086      	sub	sp, #24
 800d24e:	af00      	add	r7, sp, #0
 800d250:	60f8      	str	r0, [r7, #12]
 800d252:	60b9      	str	r1, [r7, #8]
 800d254:	4613      	mov	r3, r2
 800d256:	80fb      	strh	r3, [r7, #6]
  USBH_StatusTypeDef status;
  status = USBH_BUSY;
 800d258:	2301      	movs	r3, #1
 800d25a:	75fb      	strb	r3, [r7, #23]

  switch (phost->RequestState)
 800d25c:	68fb      	ldr	r3, [r7, #12]
 800d25e:	789b      	ldrb	r3, [r3, #2]
 800d260:	2b01      	cmp	r3, #1
 800d262:	d002      	beq.n	800d26a <USBH_CtlReq+0x20>
 800d264:	2b02      	cmp	r3, #2
 800d266:	d00f      	beq.n	800d288 <USBH_CtlReq+0x3e>
#endif
#endif
      break;

    default:
      break;
 800d268:	e027      	b.n	800d2ba <USBH_CtlReq+0x70>
      phost->Control.buff = buff;
 800d26a:	68fb      	ldr	r3, [r7, #12]
 800d26c:	68ba      	ldr	r2, [r7, #8]
 800d26e:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 800d270:	68fb      	ldr	r3, [r7, #12]
 800d272:	88fa      	ldrh	r2, [r7, #6]
 800d274:	819a      	strh	r2, [r3, #12]
      phost->Control.state = CTRL_SETUP;
 800d276:	68fb      	ldr	r3, [r7, #12]
 800d278:	2201      	movs	r2, #1
 800d27a:	761a      	strb	r2, [r3, #24]
      phost->RequestState = CMD_WAIT;
 800d27c:	68fb      	ldr	r3, [r7, #12]
 800d27e:	2202      	movs	r2, #2
 800d280:	709a      	strb	r2, [r3, #2]
      status = USBH_BUSY;
 800d282:	2301      	movs	r3, #1
 800d284:	75fb      	strb	r3, [r7, #23]
      break;
 800d286:	e018      	b.n	800d2ba <USBH_CtlReq+0x70>
      status = USBH_HandleControl(phost);
 800d288:	68f8      	ldr	r0, [r7, #12]
 800d28a:	f000 f81b 	bl	800d2c4 <USBH_HandleControl>
 800d28e:	4603      	mov	r3, r0
 800d290:	75fb      	strb	r3, [r7, #23]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800d292:	7dfb      	ldrb	r3, [r7, #23]
 800d294:	2b00      	cmp	r3, #0
 800d296:	d002      	beq.n	800d29e <USBH_CtlReq+0x54>
 800d298:	7dfb      	ldrb	r3, [r7, #23]
 800d29a:	2b03      	cmp	r3, #3
 800d29c:	d106      	bne.n	800d2ac <USBH_CtlReq+0x62>
        phost->RequestState = CMD_SEND;
 800d29e:	68fb      	ldr	r3, [r7, #12]
 800d2a0:	2201      	movs	r2, #1
 800d2a2:	709a      	strb	r2, [r3, #2]
        phost->Control.state = CTRL_IDLE;
 800d2a4:	68fb      	ldr	r3, [r7, #12]
 800d2a6:	2200      	movs	r2, #0
 800d2a8:	761a      	strb	r2, [r3, #24]
      break;
 800d2aa:	e005      	b.n	800d2b8 <USBH_CtlReq+0x6e>
      else if (status == USBH_FAIL)
 800d2ac:	7dfb      	ldrb	r3, [r7, #23]
 800d2ae:	2b02      	cmp	r3, #2
 800d2b0:	d102      	bne.n	800d2b8 <USBH_CtlReq+0x6e>
        phost->RequestState = CMD_SEND;
 800d2b2:	68fb      	ldr	r3, [r7, #12]
 800d2b4:	2201      	movs	r2, #1
 800d2b6:	709a      	strb	r2, [r3, #2]
      break;
 800d2b8:	bf00      	nop
  }
  return status;
 800d2ba:	7dfb      	ldrb	r3, [r7, #23]
}
 800d2bc:	4618      	mov	r0, r3
 800d2be:	3718      	adds	r7, #24
 800d2c0:	46bd      	mov	sp, r7
 800d2c2:	bd80      	pop	{r7, pc}

0800d2c4 <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
{
 800d2c4:	b580      	push	{r7, lr}
 800d2c6:	b086      	sub	sp, #24
 800d2c8:	af02      	add	r7, sp, #8
 800d2ca:	6078      	str	r0, [r7, #4]
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
 800d2cc:	2301      	movs	r3, #1
 800d2ce:	73fb      	strb	r3, [r7, #15]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 800d2d0:	2300      	movs	r3, #0
 800d2d2:	73bb      	strb	r3, [r7, #14]

  switch (phost->Control.state)
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	7e1b      	ldrb	r3, [r3, #24]
 800d2d8:	3b01      	subs	r3, #1
 800d2da:	2b0a      	cmp	r3, #10
 800d2dc:	f200 8156 	bhi.w	800d58c <USBH_HandleControl+0x2c8>
 800d2e0:	a201      	add	r2, pc, #4	@ (adr r2, 800d2e8 <USBH_HandleControl+0x24>)
 800d2e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d2e6:	bf00      	nop
 800d2e8:	0800d315 	.word	0x0800d315
 800d2ec:	0800d32f 	.word	0x0800d32f
 800d2f0:	0800d399 	.word	0x0800d399
 800d2f4:	0800d3bf 	.word	0x0800d3bf
 800d2f8:	0800d3f7 	.word	0x0800d3f7
 800d2fc:	0800d421 	.word	0x0800d421
 800d300:	0800d473 	.word	0x0800d473
 800d304:	0800d495 	.word	0x0800d495
 800d308:	0800d4d1 	.word	0x0800d4d1
 800d30c:	0800d4f7 	.word	0x0800d4f7
 800d310:	0800d535 	.word	0x0800d535
  {
    case CTRL_SETUP:
      /* send a SETUP packet */
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800d314:	687b      	ldr	r3, [r7, #4]
 800d316:	f103 0110 	add.w	r1, r3, #16
 800d31a:	687b      	ldr	r3, [r7, #4]
 800d31c:	795b      	ldrb	r3, [r3, #5]
 800d31e:	461a      	mov	r2, r3
 800d320:	6878      	ldr	r0, [r7, #4]
 800d322:	f000 f943 	bl	800d5ac <USBH_CtlSendSetup>
                              phost->Control.pipe_out);

      phost->Control.state = CTRL_SETUP_WAIT;
 800d326:	687b      	ldr	r3, [r7, #4]
 800d328:	2202      	movs	r2, #2
 800d32a:	761a      	strb	r2, [r3, #24]
      break;
 800d32c:	e139      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    case CTRL_SETUP_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d32e:	687b      	ldr	r3, [r7, #4]
 800d330:	795b      	ldrb	r3, [r3, #5]
 800d332:	4619      	mov	r1, r3
 800d334:	6878      	ldr	r0, [r7, #4]
 800d336:	f022 f971 	bl	802f61c <USBH_LL_GetURBState>
 800d33a:	4603      	mov	r3, r0
 800d33c:	73bb      	strb	r3, [r7, #14]
      /* case SETUP packet sent successfully */
      if (URB_Status == USBH_URB_DONE)
 800d33e:	7bbb      	ldrb	r3, [r7, #14]
 800d340:	2b01      	cmp	r3, #1
 800d342:	d11e      	bne.n	800d382 <USBH_HandleControl+0xbe>
      {
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 800d344:	687b      	ldr	r3, [r7, #4]
 800d346:	7c1b      	ldrb	r3, [r3, #16]
 800d348:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 800d34c:	737b      	strb	r3, [r7, #13]

        /* check if there is a data stage */
        if (phost->Control.setup.b.wLength.w != 0U)
 800d34e:	687b      	ldr	r3, [r7, #4]
 800d350:	8adb      	ldrh	r3, [r3, #22]
 800d352:	2b00      	cmp	r3, #0
 800d354:	d00a      	beq.n	800d36c <USBH_HandleControl+0xa8>
        {
          if (direction == USB_D2H)
 800d356:	7b7b      	ldrb	r3, [r7, #13]
 800d358:	2b80      	cmp	r3, #128	@ 0x80
 800d35a:	d103      	bne.n	800d364 <USBH_HandleControl+0xa0>
          {
            /* Data Direction is IN */
            phost->Control.state = CTRL_DATA_IN;
 800d35c:	687b      	ldr	r3, [r7, #4]
 800d35e:	2203      	movs	r2, #3
 800d360:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d362:	e115      	b.n	800d590 <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_DATA_OUT;
 800d364:	687b      	ldr	r3, [r7, #4]
 800d366:	2205      	movs	r2, #5
 800d368:	761a      	strb	r2, [r3, #24]
      break;
 800d36a:	e111      	b.n	800d590 <USBH_HandleControl+0x2cc>
          if (direction == USB_D2H)
 800d36c:	7b7b      	ldrb	r3, [r7, #13]
 800d36e:	2b80      	cmp	r3, #128	@ 0x80
 800d370:	d103      	bne.n	800d37a <USBH_HandleControl+0xb6>
            phost->Control.state = CTRL_STATUS_OUT;
 800d372:	687b      	ldr	r3, [r7, #4]
 800d374:	2209      	movs	r2, #9
 800d376:	761a      	strb	r2, [r3, #24]
      break;
 800d378:	e10a      	b.n	800d590 <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_STATUS_IN;
 800d37a:	687b      	ldr	r3, [r7, #4]
 800d37c:	2207      	movs	r2, #7
 800d37e:	761a      	strb	r2, [r3, #24]
      break;
 800d380:	e106      	b.n	800d590 <USBH_HandleControl+0x2cc>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800d382:	7bbb      	ldrb	r3, [r7, #14]
 800d384:	2b04      	cmp	r3, #4
 800d386:	d003      	beq.n	800d390 <USBH_HandleControl+0xcc>
 800d388:	7bbb      	ldrb	r3, [r7, #14]
 800d38a:	2b02      	cmp	r3, #2
 800d38c:	f040 8100 	bne.w	800d590 <USBH_HandleControl+0x2cc>
          phost->Control.state = CTRL_ERROR;
 800d390:	687b      	ldr	r3, [r7, #4]
 800d392:	220b      	movs	r2, #11
 800d394:	761a      	strb	r2, [r3, #24]
      break;
 800d396:	e0fb      	b.n	800d590 <USBH_HandleControl+0x2cc>

    case CTRL_DATA_IN:
      /* Issue an IN token */
      phost->Control.timer = (uint16_t)phost->Timer;
 800d398:	687b      	ldr	r3, [r7, #4]
 800d39a:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d39e:	b29a      	uxth	r2, r3
 800d3a0:	687b      	ldr	r3, [r7, #4]
 800d3a2:	81da      	strh	r2, [r3, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 800d3a4:	687b      	ldr	r3, [r7, #4]
 800d3a6:	6899      	ldr	r1, [r3, #8]
 800d3a8:	687b      	ldr	r3, [r7, #4]
 800d3aa:	899a      	ldrh	r2, [r3, #12]
 800d3ac:	687b      	ldr	r3, [r7, #4]
 800d3ae:	791b      	ldrb	r3, [r3, #4]
 800d3b0:	6878      	ldr	r0, [r7, #4]
 800d3b2:	f000 f93a 	bl	800d62a <USBH_CtlReceiveData>
                                phost->Control.length, phost->Control.pipe_in);

      phost->Control.state = CTRL_DATA_IN_WAIT;
 800d3b6:	687b      	ldr	r3, [r7, #4]
 800d3b8:	2204      	movs	r2, #4
 800d3ba:	761a      	strb	r2, [r3, #24]
      break;
 800d3bc:	e0f1      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    case CTRL_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800d3be:	687b      	ldr	r3, [r7, #4]
 800d3c0:	791b      	ldrb	r3, [r3, #4]
 800d3c2:	4619      	mov	r1, r3
 800d3c4:	6878      	ldr	r0, [r7, #4]
 800d3c6:	f022 f929 	bl	802f61c <USBH_LL_GetURBState>
 800d3ca:	4603      	mov	r3, r0
 800d3cc:	73bb      	strb	r3, [r7, #14]

      /* check is DATA packet transferred successfully */
      if (URB_Status == USBH_URB_DONE)
 800d3ce:	7bbb      	ldrb	r3, [r7, #14]
 800d3d0:	2b01      	cmp	r3, #1
 800d3d2:	d102      	bne.n	800d3da <USBH_HandleControl+0x116>
      {
        phost->Control.state = CTRL_STATUS_OUT;
 800d3d4:	687b      	ldr	r3, [r7, #4]
 800d3d6:	2209      	movs	r2, #9
 800d3d8:	761a      	strb	r2, [r3, #24]
#endif
#endif
      }

      /* manage error cases*/
      if (URB_Status == USBH_URB_STALL)
 800d3da:	7bbb      	ldrb	r3, [r7, #14]
 800d3dc:	2b05      	cmp	r3, #5
 800d3de:	d102      	bne.n	800d3e6 <USBH_HandleControl+0x122>
      {
        /* In stall case, return to previous machine state*/
        status = USBH_NOT_SUPPORTED;
 800d3e0:	2303      	movs	r3, #3
 800d3e2:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d3e4:	e0d6      	b.n	800d594 <USBH_HandleControl+0x2d0>
        if (URB_Status == USBH_URB_ERROR)
 800d3e6:	7bbb      	ldrb	r3, [r7, #14]
 800d3e8:	2b04      	cmp	r3, #4
 800d3ea:	f040 80d3 	bne.w	800d594 <USBH_HandleControl+0x2d0>
          phost->Control.state = CTRL_ERROR;
 800d3ee:	687b      	ldr	r3, [r7, #4]
 800d3f0:	220b      	movs	r2, #11
 800d3f2:	761a      	strb	r2, [r3, #24]
      break;
 800d3f4:	e0ce      	b.n	800d594 <USBH_HandleControl+0x2d0>

    case CTRL_DATA_OUT:

      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800d3f6:	687b      	ldr	r3, [r7, #4]
 800d3f8:	6899      	ldr	r1, [r3, #8]
 800d3fa:	687b      	ldr	r3, [r7, #4]
 800d3fc:	899a      	ldrh	r2, [r3, #12]
 800d3fe:	687b      	ldr	r3, [r7, #4]
 800d400:	795b      	ldrb	r3, [r3, #5]
 800d402:	2001      	movs	r0, #1
 800d404:	9000      	str	r0, [sp, #0]
 800d406:	6878      	ldr	r0, [r7, #4]
 800d408:	f000 f8ea 	bl	800d5e0 <USBH_CtlSendData>
                             phost->Control.pipe_out, 1U);

      phost->Control.timer = (uint16_t)phost->Timer;
 800d40c:	687b      	ldr	r3, [r7, #4]
 800d40e:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d412:	b29a      	uxth	r2, r3
 800d414:	687b      	ldr	r3, [r7, #4]
 800d416:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800d418:	687b      	ldr	r3, [r7, #4]
 800d41a:	2206      	movs	r2, #6
 800d41c:	761a      	strb	r2, [r3, #24]
      break;
 800d41e:	e0c0      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    case CTRL_DATA_OUT_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d420:	687b      	ldr	r3, [r7, #4]
 800d422:	795b      	ldrb	r3, [r3, #5]
 800d424:	4619      	mov	r1, r3
 800d426:	6878      	ldr	r0, [r7, #4]
 800d428:	f022 f8f8 	bl	802f61c <USBH_LL_GetURBState>
 800d42c:	4603      	mov	r3, r0
 800d42e:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 800d430:	7bbb      	ldrb	r3, [r7, #14]
 800d432:	2b01      	cmp	r3, #1
 800d434:	d103      	bne.n	800d43e <USBH_HandleControl+0x17a>
      {
        /* If the Setup Pkt is sent successful, then change the state */
        phost->Control.state = CTRL_STATUS_IN;
 800d436:	687b      	ldr	r3, [r7, #4]
 800d438:	2207      	movs	r2, #7
 800d43a:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d43c:	e0ac      	b.n	800d598 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_STALL)
 800d43e:	7bbb      	ldrb	r3, [r7, #14]
 800d440:	2b05      	cmp	r3, #5
 800d442:	d105      	bne.n	800d450 <USBH_HandleControl+0x18c>
        phost->Control.state = CTRL_STALLED;
 800d444:	687b      	ldr	r3, [r7, #4]
 800d446:	220c      	movs	r2, #12
 800d448:	761a      	strb	r2, [r3, #24]
        status = USBH_NOT_SUPPORTED;
 800d44a:	2303      	movs	r3, #3
 800d44c:	73fb      	strb	r3, [r7, #15]
      break;
 800d44e:	e0a3      	b.n	800d598 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_NOTREADY)
 800d450:	7bbb      	ldrb	r3, [r7, #14]
 800d452:	2b02      	cmp	r3, #2
 800d454:	d103      	bne.n	800d45e <USBH_HandleControl+0x19a>
        phost->Control.state = CTRL_DATA_OUT;
 800d456:	687b      	ldr	r3, [r7, #4]
 800d458:	2205      	movs	r2, #5
 800d45a:	761a      	strb	r2, [r3, #24]
      break;
 800d45c:	e09c      	b.n	800d598 <USBH_HandleControl+0x2d4>
        if (URB_Status == USBH_URB_ERROR)
 800d45e:	7bbb      	ldrb	r3, [r7, #14]
 800d460:	2b04      	cmp	r3, #4
 800d462:	f040 8099 	bne.w	800d598 <USBH_HandleControl+0x2d4>
          phost->Control.state = CTRL_ERROR;
 800d466:	687b      	ldr	r3, [r7, #4]
 800d468:	220b      	movs	r2, #11
 800d46a:	761a      	strb	r2, [r3, #24]
          status = USBH_FAIL;
 800d46c:	2302      	movs	r3, #2
 800d46e:	73fb      	strb	r3, [r7, #15]
      break;
 800d470:	e092      	b.n	800d598 <USBH_HandleControl+0x2d4>

    case CTRL_STATUS_IN:
      /* Send 0 bytes out packet */
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 800d472:	687b      	ldr	r3, [r7, #4]
 800d474:	791b      	ldrb	r3, [r3, #4]
 800d476:	2200      	movs	r2, #0
 800d478:	2100      	movs	r1, #0
 800d47a:	6878      	ldr	r0, [r7, #4]
 800d47c:	f000 f8d5 	bl	800d62a <USBH_CtlReceiveData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800d480:	687b      	ldr	r3, [r7, #4]
 800d482:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d486:	b29a      	uxth	r2, r3
 800d488:	687b      	ldr	r3, [r7, #4]
 800d48a:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800d48c:	687b      	ldr	r3, [r7, #4]
 800d48e:	2208      	movs	r2, #8
 800d490:	761a      	strb	r2, [r3, #24]

      break;
 800d492:	e086      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    case CTRL_STATUS_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800d494:	687b      	ldr	r3, [r7, #4]
 800d496:	791b      	ldrb	r3, [r3, #4]
 800d498:	4619      	mov	r1, r3
 800d49a:	6878      	ldr	r0, [r7, #4]
 800d49c:	f022 f8be 	bl	802f61c <USBH_LL_GetURBState>
 800d4a0:	4603      	mov	r3, r0
 800d4a2:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 800d4a4:	7bbb      	ldrb	r3, [r7, #14]
 800d4a6:	2b01      	cmp	r3, #1
 800d4a8:	d105      	bne.n	800d4b6 <USBH_HandleControl+0x1f2>
      {
        /* Control transfers completed, Exit the State Machine */
        phost->Control.state = CTRL_COMPLETE;
 800d4aa:	687b      	ldr	r3, [r7, #4]
 800d4ac:	220d      	movs	r2, #13
 800d4ae:	761a      	strb	r2, [r3, #24]
        status = USBH_OK;
 800d4b0:	2300      	movs	r3, #0
 800d4b2:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d4b4:	e072      	b.n	800d59c <USBH_HandleControl+0x2d8>
      else if (URB_Status == USBH_URB_ERROR)
 800d4b6:	7bbb      	ldrb	r3, [r7, #14]
 800d4b8:	2b04      	cmp	r3, #4
 800d4ba:	d103      	bne.n	800d4c4 <USBH_HandleControl+0x200>
        phost->Control.state = CTRL_ERROR;
 800d4bc:	687b      	ldr	r3, [r7, #4]
 800d4be:	220b      	movs	r2, #11
 800d4c0:	761a      	strb	r2, [r3, #24]
      break;
 800d4c2:	e06b      	b.n	800d59c <USBH_HandleControl+0x2d8>
        if (URB_Status == USBH_URB_STALL)
 800d4c4:	7bbb      	ldrb	r3, [r7, #14]
 800d4c6:	2b05      	cmp	r3, #5
 800d4c8:	d168      	bne.n	800d59c <USBH_HandleControl+0x2d8>
          status = USBH_NOT_SUPPORTED;
 800d4ca:	2303      	movs	r3, #3
 800d4cc:	73fb      	strb	r3, [r7, #15]
      break;
 800d4ce:	e065      	b.n	800d59c <USBH_HandleControl+0x2d8>

    case CTRL_STATUS_OUT:
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 800d4d0:	687b      	ldr	r3, [r7, #4]
 800d4d2:	795b      	ldrb	r3, [r3, #5]
 800d4d4:	2201      	movs	r2, #1
 800d4d6:	9200      	str	r2, [sp, #0]
 800d4d8:	2200      	movs	r2, #0
 800d4da:	2100      	movs	r1, #0
 800d4dc:	6878      	ldr	r0, [r7, #4]
 800d4de:	f000 f87f 	bl	800d5e0 <USBH_CtlSendData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800d4e2:	687b      	ldr	r3, [r7, #4]
 800d4e4:	f8d3 33c4 	ldr.w	r3, [r3, #964]	@ 0x3c4
 800d4e8:	b29a      	uxth	r2, r3
 800d4ea:	687b      	ldr	r3, [r7, #4]
 800d4ec:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800d4ee:	687b      	ldr	r3, [r7, #4]
 800d4f0:	220a      	movs	r2, #10
 800d4f2:	761a      	strb	r2, [r3, #24]
      break;
 800d4f4:	e055      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    case CTRL_STATUS_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800d4f6:	687b      	ldr	r3, [r7, #4]
 800d4f8:	795b      	ldrb	r3, [r3, #5]
 800d4fa:	4619      	mov	r1, r3
 800d4fc:	6878      	ldr	r0, [r7, #4]
 800d4fe:	f022 f88d 	bl	802f61c <USBH_LL_GetURBState>
 800d502:	4603      	mov	r3, r0
 800d504:	73bb      	strb	r3, [r7, #14]
      if (URB_Status == USBH_URB_DONE)
 800d506:	7bbb      	ldrb	r3, [r7, #14]
 800d508:	2b01      	cmp	r3, #1
 800d50a:	d105      	bne.n	800d518 <USBH_HandleControl+0x254>
      {
        status = USBH_OK;
 800d50c:	2300      	movs	r3, #0
 800d50e:	73fb      	strb	r3, [r7, #15]
        phost->Control.state = CTRL_COMPLETE;
 800d510:	687b      	ldr	r3, [r7, #4]
 800d512:	220d      	movs	r2, #13
 800d514:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif
        }
      }
      break;
 800d516:	e043      	b.n	800d5a0 <USBH_HandleControl+0x2dc>
      else if (URB_Status == USBH_URB_NOTREADY)
 800d518:	7bbb      	ldrb	r3, [r7, #14]
 800d51a:	2b02      	cmp	r3, #2
 800d51c:	d103      	bne.n	800d526 <USBH_HandleControl+0x262>
        phost->Control.state = CTRL_STATUS_OUT;
 800d51e:	687b      	ldr	r3, [r7, #4]
 800d520:	2209      	movs	r2, #9
 800d522:	761a      	strb	r2, [r3, #24]
      break;
 800d524:	e03c      	b.n	800d5a0 <USBH_HandleControl+0x2dc>
        if (URB_Status == USBH_URB_ERROR)
 800d526:	7bbb      	ldrb	r3, [r7, #14]
 800d528:	2b04      	cmp	r3, #4
 800d52a:	d139      	bne.n	800d5a0 <USBH_HandleControl+0x2dc>
          phost->Control.state = CTRL_ERROR;
 800d52c:	687b      	ldr	r3, [r7, #4]
 800d52e:	220b      	movs	r2, #11
 800d530:	761a      	strb	r2, [r3, #24]
      break;
 800d532:	e035      	b.n	800d5a0 <USBH_HandleControl+0x2dc>
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800d534:	687b      	ldr	r3, [r7, #4]
 800d536:	7e5b      	ldrb	r3, [r3, #25]
 800d538:	3301      	adds	r3, #1
 800d53a:	b2da      	uxtb	r2, r3
 800d53c:	687b      	ldr	r3, [r7, #4]
 800d53e:	765a      	strb	r2, [r3, #25]
 800d540:	687b      	ldr	r3, [r7, #4]
 800d542:	7e5b      	ldrb	r3, [r3, #25]
 800d544:	2b02      	cmp	r3, #2
 800d546:	d806      	bhi.n	800d556 <USBH_HandleControl+0x292>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 800d548:	687b      	ldr	r3, [r7, #4]
 800d54a:	2201      	movs	r2, #1
 800d54c:	761a      	strb	r2, [r3, #24]
        phost->RequestState = CMD_SEND;
 800d54e:	687b      	ldr	r3, [r7, #4]
 800d550:	2201      	movs	r2, #1
 800d552:	709a      	strb	r2, [r3, #2]
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);

        phost->gState = HOST_IDLE;
        status = USBH_FAIL;
      }
      break;
 800d554:	e025      	b.n	800d5a2 <USBH_HandleControl+0x2de>
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800d556:	687b      	ldr	r3, [r7, #4]
 800d558:	f8d3 33d4 	ldr.w	r3, [r3, #980]	@ 0x3d4
 800d55c:	2106      	movs	r1, #6
 800d55e:	6878      	ldr	r0, [r7, #4]
 800d560:	4798      	blx	r3
        phost->Control.errorcount = 0U;
 800d562:	687b      	ldr	r3, [r7, #4]
 800d564:	2200      	movs	r2, #0
 800d566:	765a      	strb	r2, [r3, #25]
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 800d568:	687b      	ldr	r3, [r7, #4]
 800d56a:	795b      	ldrb	r3, [r3, #5]
 800d56c:	4619      	mov	r1, r3
 800d56e:	6878      	ldr	r0, [r7, #4]
 800d570:	f000 f90c 	bl	800d78c <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800d574:	687b      	ldr	r3, [r7, #4]
 800d576:	791b      	ldrb	r3, [r3, #4]
 800d578:	4619      	mov	r1, r3
 800d57a:	6878      	ldr	r0, [r7, #4]
 800d57c:	f000 f906 	bl	800d78c <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800d580:	687b      	ldr	r3, [r7, #4]
 800d582:	2200      	movs	r2, #0
 800d584:	701a      	strb	r2, [r3, #0]
        status = USBH_FAIL;
 800d586:	2302      	movs	r3, #2
 800d588:	73fb      	strb	r3, [r7, #15]
      break;
 800d58a:	e00a      	b.n	800d5a2 <USBH_HandleControl+0x2de>

    default:
      break;
 800d58c:	bf00      	nop
 800d58e:	e008      	b.n	800d5a2 <USBH_HandleControl+0x2de>
      break;
 800d590:	bf00      	nop
 800d592:	e006      	b.n	800d5a2 <USBH_HandleControl+0x2de>
      break;
 800d594:	bf00      	nop
 800d596:	e004      	b.n	800d5a2 <USBH_HandleControl+0x2de>
      break;
 800d598:	bf00      	nop
 800d59a:	e002      	b.n	800d5a2 <USBH_HandleControl+0x2de>
      break;
 800d59c:	bf00      	nop
 800d59e:	e000      	b.n	800d5a2 <USBH_HandleControl+0x2de>
      break;
 800d5a0:	bf00      	nop
  }

  return status;
 800d5a2:	7bfb      	ldrb	r3, [r7, #15]
}
 800d5a4:	4618      	mov	r0, r3
 800d5a6:	3710      	adds	r7, #16
 800d5a8:	46bd      	mov	sp, r7
 800d5aa:	bd80      	pop	{r7, pc}

0800d5ac <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 800d5ac:	b580      	push	{r7, lr}
 800d5ae:	b088      	sub	sp, #32
 800d5b0:	af04      	add	r7, sp, #16
 800d5b2:	60f8      	str	r0, [r7, #12]
 800d5b4:	60b9      	str	r1, [r7, #8]
 800d5b6:	4613      	mov	r3, r2
 800d5b8:	71fb      	strb	r3, [r7, #7]

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d5ba:	79f9      	ldrb	r1, [r7, #7]
 800d5bc:	2300      	movs	r3, #0
 800d5be:	9303      	str	r3, [sp, #12]
 800d5c0:	2308      	movs	r3, #8
 800d5c2:	9302      	str	r3, [sp, #8]
 800d5c4:	68bb      	ldr	r3, [r7, #8]
 800d5c6:	9301      	str	r3, [sp, #4]
 800d5c8:	2300      	movs	r3, #0
 800d5ca:	9300      	str	r3, [sp, #0]
 800d5cc:	2300      	movs	r3, #0
 800d5ce:	2200      	movs	r2, #0
 800d5d0:	68f8      	ldr	r0, [r7, #12]
 800d5d2:	f021 fff2 	bl	802f5ba <USBH_LL_SubmitURB>
                          USBH_EP_CONTROL,      /* EP type          */
                          USBH_PID_SETUP,       /* Type setup       */
                          buff,                 /* data buffer      */
                          USBH_SETUP_PKT_SIZE,  /* data length      */
                          0U);
  return USBH_OK;
 800d5d6:	2300      	movs	r3, #0
}
 800d5d8:	4618      	mov	r0, r3
 800d5da:	3710      	adds	r7, #16
 800d5dc:	46bd      	mov	sp, r7
 800d5de:	bd80      	pop	{r7, pc}

0800d5e0 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 800d5e0:	b580      	push	{r7, lr}
 800d5e2:	b088      	sub	sp, #32
 800d5e4:	af04      	add	r7, sp, #16
 800d5e6:	60f8      	str	r0, [r7, #12]
 800d5e8:	60b9      	str	r1, [r7, #8]
 800d5ea:	4611      	mov	r1, r2
 800d5ec:	461a      	mov	r2, r3
 800d5ee:	460b      	mov	r3, r1
 800d5f0:	80fb      	strh	r3, [r7, #6]
 800d5f2:	4613      	mov	r3, r2
 800d5f4:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 800d5f6:	68fb      	ldr	r3, [r7, #12]
 800d5f8:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d5fc:	2b00      	cmp	r3, #0
 800d5fe:	d001      	beq.n	800d604 <USBH_CtlSendData+0x24>
  {
    do_ping = 0U;
 800d600:	2300      	movs	r3, #0
 800d602:	763b      	strb	r3, [r7, #24]
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d604:	7979      	ldrb	r1, [r7, #5]
 800d606:	7e3b      	ldrb	r3, [r7, #24]
 800d608:	9303      	str	r3, [sp, #12]
 800d60a:	88fb      	ldrh	r3, [r7, #6]
 800d60c:	9302      	str	r3, [sp, #8]
 800d60e:	68bb      	ldr	r3, [r7, #8]
 800d610:	9301      	str	r3, [sp, #4]
 800d612:	2301      	movs	r3, #1
 800d614:	9300      	str	r3, [sp, #0]
 800d616:	2300      	movs	r3, #0
 800d618:	2200      	movs	r2, #0
 800d61a:	68f8      	ldr	r0, [r7, #12]
 800d61c:	f021 ffcd 	bl	802f5ba <USBH_LL_SubmitURB>
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
 800d620:	2300      	movs	r3, #0
}
 800d622:	4618      	mov	r0, r3
 800d624:	3710      	adds	r7, #16
 800d626:	46bd      	mov	sp, r7
 800d628:	bd80      	pop	{r7, pc}

0800d62a <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 800d62a:	b580      	push	{r7, lr}
 800d62c:	b088      	sub	sp, #32
 800d62e:	af04      	add	r7, sp, #16
 800d630:	60f8      	str	r0, [r7, #12]
 800d632:	60b9      	str	r1, [r7, #8]
 800d634:	4611      	mov	r1, r2
 800d636:	461a      	mov	r2, r3
 800d638:	460b      	mov	r3, r1
 800d63a:	80fb      	strh	r3, [r7, #6]
 800d63c:	4613      	mov	r3, r2
 800d63e:	717b      	strb	r3, [r7, #5]
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d640:	7979      	ldrb	r1, [r7, #5]
 800d642:	2300      	movs	r3, #0
 800d644:	9303      	str	r3, [sp, #12]
 800d646:	88fb      	ldrh	r3, [r7, #6]
 800d648:	9302      	str	r3, [sp, #8]
 800d64a:	68bb      	ldr	r3, [r7, #8]
 800d64c:	9301      	str	r3, [sp, #4]
 800d64e:	2301      	movs	r3, #1
 800d650:	9300      	str	r3, [sp, #0]
 800d652:	2300      	movs	r3, #0
 800d654:	2201      	movs	r2, #1
 800d656:	68f8      	ldr	r0, [r7, #12]
 800d658:	f021 ffaf 	bl	802f5ba <USBH_LL_SubmitURB>
                          USBH_EP_CONTROL,      /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
 800d65c:	2300      	movs	r3, #0

}
 800d65e:	4618      	mov	r0, r3
 800d660:	3710      	adds	r7, #16
 800d662:	46bd      	mov	sp, r7
 800d664:	bd80      	pop	{r7, pc}

0800d666 <USBH_BulkSendData>:
USBH_StatusTypeDef USBH_BulkSendData(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint16_t length,
                                     uint8_t pipe_num,
                                     uint8_t do_ping)
{
 800d666:	b580      	push	{r7, lr}
 800d668:	b088      	sub	sp, #32
 800d66a:	af04      	add	r7, sp, #16
 800d66c:	60f8      	str	r0, [r7, #12]
 800d66e:	60b9      	str	r1, [r7, #8]
 800d670:	4611      	mov	r1, r2
 800d672:	461a      	mov	r2, r3
 800d674:	460b      	mov	r3, r1
 800d676:	80fb      	strh	r3, [r7, #6]
 800d678:	4613      	mov	r3, r2
 800d67a:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 800d67c:	68fb      	ldr	r3, [r7, #12]
 800d67e:	f893 331d 	ldrb.w	r3, [r3, #797]	@ 0x31d
 800d682:	2b00      	cmp	r3, #0
 800d684:	d001      	beq.n	800d68a <USBH_BulkSendData+0x24>
  {
    do_ping = 0U;
 800d686:	2300      	movs	r3, #0
 800d688:	763b      	strb	r3, [r7, #24]
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d68a:	7979      	ldrb	r1, [r7, #5]
 800d68c:	7e3b      	ldrb	r3, [r7, #24]
 800d68e:	9303      	str	r3, [sp, #12]
 800d690:	88fb      	ldrh	r3, [r7, #6]
 800d692:	9302      	str	r3, [sp, #8]
 800d694:	68bb      	ldr	r3, [r7, #8]
 800d696:	9301      	str	r3, [sp, #4]
 800d698:	2301      	movs	r3, #1
 800d69a:	9300      	str	r3, [sp, #0]
 800d69c:	2302      	movs	r3, #2
 800d69e:	2200      	movs	r2, #0
 800d6a0:	68f8      	ldr	r0, [r7, #12]
 800d6a2:	f021 ff8a 	bl	802f5ba <USBH_LL_SubmitURB>
                          USBH_EP_BULK,         /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/
  return USBH_OK;
 800d6a6:	2300      	movs	r3, #0
}
 800d6a8:	4618      	mov	r0, r3
 800d6aa:	3710      	adds	r7, #16
 800d6ac:	46bd      	mov	sp, r7
 800d6ae:	bd80      	pop	{r7, pc}

0800d6b0 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 800d6b0:	b580      	push	{r7, lr}
 800d6b2:	b088      	sub	sp, #32
 800d6b4:	af04      	add	r7, sp, #16
 800d6b6:	60f8      	str	r0, [r7, #12]
 800d6b8:	60b9      	str	r1, [r7, #8]
 800d6ba:	4611      	mov	r1, r2
 800d6bc:	461a      	mov	r2, r3
 800d6be:	460b      	mov	r3, r1
 800d6c0:	80fb      	strh	r3, [r7, #6]
 800d6c2:	4613      	mov	r3, r2
 800d6c4:	717b      	strb	r3, [r7, #5]
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 800d6c6:	7979      	ldrb	r1, [r7, #5]
 800d6c8:	2300      	movs	r3, #0
 800d6ca:	9303      	str	r3, [sp, #12]
 800d6cc:	88fb      	ldrh	r3, [r7, #6]
 800d6ce:	9302      	str	r3, [sp, #8]
 800d6d0:	68bb      	ldr	r3, [r7, #8]
 800d6d2:	9301      	str	r3, [sp, #4]
 800d6d4:	2301      	movs	r3, #1
 800d6d6:	9300      	str	r3, [sp, #0]
 800d6d8:	2302      	movs	r3, #2
 800d6da:	2201      	movs	r2, #1
 800d6dc:	68f8      	ldr	r0, [r7, #12]
 800d6de:	f021 ff6c 	bl	802f5ba <USBH_LL_SubmitURB>
                          USBH_EP_BULK,         /* EP type          */
                          USBH_PID_DATA,        /* Type Data        */
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;
 800d6e2:	2300      	movs	r3, #0
}
 800d6e4:	4618      	mov	r0, r3
 800d6e6:	3710      	adds	r7, #16
 800d6e8:	46bd      	mov	sp, r7
 800d6ea:	bd80      	pop	{r7, pc}

0800d6ec <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 800d6ec:	b580      	push	{r7, lr}
 800d6ee:	b086      	sub	sp, #24
 800d6f0:	af04      	add	r7, sp, #16
 800d6f2:	6078      	str	r0, [r7, #4]
 800d6f4:	4608      	mov	r0, r1
 800d6f6:	4611      	mov	r1, r2
 800d6f8:	461a      	mov	r2, r3
 800d6fa:	4603      	mov	r3, r0
 800d6fc:	70fb      	strb	r3, [r7, #3]
 800d6fe:	460b      	mov	r3, r1
 800d700:	70bb      	strb	r3, [r7, #2]
 800d702:	4613      	mov	r3, r2
 800d704:	707b      	strb	r3, [r7, #1]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 800d706:	7878      	ldrb	r0, [r7, #1]
 800d708:	78ba      	ldrb	r2, [r7, #2]
 800d70a:	78f9      	ldrb	r1, [r7, #3]
 800d70c:	8b3b      	ldrh	r3, [r7, #24]
 800d70e:	9302      	str	r3, [sp, #8]
 800d710:	7d3b      	ldrb	r3, [r7, #20]
 800d712:	9301      	str	r3, [sp, #4]
 800d714:	7c3b      	ldrb	r3, [r7, #16]
 800d716:	9300      	str	r3, [sp, #0]
 800d718:	4603      	mov	r3, r0
 800d71a:	6878      	ldr	r0, [r7, #4]
 800d71c:	f021 feff 	bl	802f51e <USBH_LL_OpenPipe>

  return USBH_OK;
 800d720:	2300      	movs	r3, #0
}
 800d722:	4618      	mov	r0, r3
 800d724:	3708      	adds	r7, #8
 800d726:	46bd      	mov	sp, r7
 800d728:	bd80      	pop	{r7, pc}

0800d72a <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 800d72a:	b580      	push	{r7, lr}
 800d72c:	b082      	sub	sp, #8
 800d72e:	af00      	add	r7, sp, #0
 800d730:	6078      	str	r0, [r7, #4]
 800d732:	460b      	mov	r3, r1
 800d734:	70fb      	strb	r3, [r7, #3]
  (void)USBH_LL_ClosePipe(phost, pipe_num);
 800d736:	78fb      	ldrb	r3, [r7, #3]
 800d738:	4619      	mov	r1, r3
 800d73a:	6878      	ldr	r0, [r7, #4]
 800d73c:	f021 ff1e 	bl	802f57c <USBH_LL_ClosePipe>

  return USBH_OK;
 800d740:	2300      	movs	r3, #0
}
 800d742:	4618      	mov	r0, r3
 800d744:	3708      	adds	r7, #8
 800d746:	46bd      	mov	sp, r7
 800d748:	bd80      	pop	{r7, pc}

0800d74a <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 800d74a:	b580      	push	{r7, lr}
 800d74c:	b084      	sub	sp, #16
 800d74e:	af00      	add	r7, sp, #0
 800d750:	6078      	str	r0, [r7, #4]
 800d752:	460b      	mov	r3, r1
 800d754:	70fb      	strb	r3, [r7, #3]
  uint16_t pipe;

  pipe =  USBH_GetFreePipe(phost);
 800d756:	6878      	ldr	r0, [r7, #4]
 800d758:	f000 f836 	bl	800d7c8 <USBH_GetFreePipe>
 800d75c:	4603      	mov	r3, r0
 800d75e:	81fb      	strh	r3, [r7, #14]

  if (pipe != 0xFFFFU)
 800d760:	89fb      	ldrh	r3, [r7, #14]
 800d762:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d766:	4293      	cmp	r3, r2
 800d768:	d00a      	beq.n	800d780 <USBH_AllocPipe+0x36>
  {
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 800d76a:	78fa      	ldrb	r2, [r7, #3]
 800d76c:	89fb      	ldrh	r3, [r7, #14]
 800d76e:	f003 030f 	and.w	r3, r3, #15
 800d772:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800d776:	6879      	ldr	r1, [r7, #4]
 800d778:	33e0      	adds	r3, #224	@ 0xe0
 800d77a:	009b      	lsls	r3, r3, #2
 800d77c:	440b      	add	r3, r1
 800d77e:	605a      	str	r2, [r3, #4]
  }

  return (uint8_t)pipe;
 800d780:	89fb      	ldrh	r3, [r7, #14]
 800d782:	b2db      	uxtb	r3, r3
}
 800d784:	4618      	mov	r0, r3
 800d786:	3710      	adds	r7, #16
 800d788:	46bd      	mov	sp, r7
 800d78a:	bd80      	pop	{r7, pc}

0800d78c <USBH_FreePipe>:
  * @param  phost: Host Handle
  * @param  idx: Pipe number to be freed
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_FreePipe(USBH_HandleTypeDef *phost, uint8_t idx)
{
 800d78c:	b480      	push	{r7}
 800d78e:	b083      	sub	sp, #12
 800d790:	af00      	add	r7, sp, #0
 800d792:	6078      	str	r0, [r7, #4]
 800d794:	460b      	mov	r3, r1
 800d796:	70fb      	strb	r3, [r7, #3]
  if (idx < USBH_MAX_PIPES_NBR)
 800d798:	78fb      	ldrb	r3, [r7, #3]
 800d79a:	2b0f      	cmp	r3, #15
 800d79c:	d80d      	bhi.n	800d7ba <USBH_FreePipe+0x2e>
  {
    phost->Pipes[idx] &= 0x7FFFU;
 800d79e:	78fb      	ldrb	r3, [r7, #3]
 800d7a0:	687a      	ldr	r2, [r7, #4]
 800d7a2:	33e0      	adds	r3, #224	@ 0xe0
 800d7a4:	009b      	lsls	r3, r3, #2
 800d7a6:	4413      	add	r3, r2
 800d7a8:	685a      	ldr	r2, [r3, #4]
 800d7aa:	78fb      	ldrb	r3, [r7, #3]
 800d7ac:	f3c2 020e 	ubfx	r2, r2, #0, #15
 800d7b0:	6879      	ldr	r1, [r7, #4]
 800d7b2:	33e0      	adds	r3, #224	@ 0xe0
 800d7b4:	009b      	lsls	r3, r3, #2
 800d7b6:	440b      	add	r3, r1
 800d7b8:	605a      	str	r2, [r3, #4]
  }

  return USBH_OK;
 800d7ba:	2300      	movs	r3, #0
}
 800d7bc:	4618      	mov	r0, r3
 800d7be:	370c      	adds	r7, #12
 800d7c0:	46bd      	mov	sp, r7
 800d7c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7c6:	4770      	bx	lr

0800d7c8 <USBH_GetFreePipe>:
  * @param  phost: Host Handle
  *         Get a free Pipe number for allocation to a device endpoint
  * @retval idx: Free Pipe number
  */
static uint16_t USBH_GetFreePipe(USBH_HandleTypeDef *phost)
{
 800d7c8:	b480      	push	{r7}
 800d7ca:	b085      	sub	sp, #20
 800d7cc:	af00      	add	r7, sp, #0
 800d7ce:	6078      	str	r0, [r7, #4]
  uint8_t idx = 0U;
 800d7d0:	2300      	movs	r3, #0
 800d7d2:	73fb      	strb	r3, [r7, #15]

  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d7d4:	2300      	movs	r3, #0
 800d7d6:	73fb      	strb	r3, [r7, #15]
 800d7d8:	e00f      	b.n	800d7fa <USBH_GetFreePipe+0x32>
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 800d7da:	7bfb      	ldrb	r3, [r7, #15]
 800d7dc:	687a      	ldr	r2, [r7, #4]
 800d7de:	33e0      	adds	r3, #224	@ 0xe0
 800d7e0:	009b      	lsls	r3, r3, #2
 800d7e2:	4413      	add	r3, r2
 800d7e4:	685b      	ldr	r3, [r3, #4]
 800d7e6:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800d7ea:	2b00      	cmp	r3, #0
 800d7ec:	d102      	bne.n	800d7f4 <USBH_GetFreePipe+0x2c>
    {
      return (uint16_t)idx;
 800d7ee:	7bfb      	ldrb	r3, [r7, #15]
 800d7f0:	b29b      	uxth	r3, r3
 800d7f2:	e007      	b.n	800d804 <USBH_GetFreePipe+0x3c>
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 800d7f4:	7bfb      	ldrb	r3, [r7, #15]
 800d7f6:	3301      	adds	r3, #1
 800d7f8:	73fb      	strb	r3, [r7, #15]
 800d7fa:	7bfb      	ldrb	r3, [r7, #15]
 800d7fc:	2b0f      	cmp	r3, #15
 800d7fe:	d9ec      	bls.n	800d7da <USBH_GetFreePipe+0x12>
    }
  }

  return 0xFFFFU;
 800d800:	f64f 73ff 	movw	r3, #65535	@ 0xffff
}
 800d804:	4618      	mov	r0, r3
 800d806:	3714      	adds	r7, #20
 800d808:	46bd      	mov	sp, r7
 800d80a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d80e:	4770      	bx	lr

0800d810 <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
 800d810:	b580      	push	{r7, lr}
 800d812:	b084      	sub	sp, #16
 800d814:	af00      	add	r7, sp, #0
 800d816:	4603      	mov	r3, r0
 800d818:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800d81a:	79fb      	ldrb	r3, [r7, #7]
 800d81c:	4a08      	ldr	r2, [pc, #32]	@ (800d840 <disk_status+0x30>)
 800d81e:	009b      	lsls	r3, r3, #2
 800d820:	4413      	add	r3, r2
 800d822:	685b      	ldr	r3, [r3, #4]
 800d824:	685b      	ldr	r3, [r3, #4]
 800d826:	79fa      	ldrb	r2, [r7, #7]
 800d828:	4905      	ldr	r1, [pc, #20]	@ (800d840 <disk_status+0x30>)
 800d82a:	440a      	add	r2, r1
 800d82c:	7a12      	ldrb	r2, [r2, #8]
 800d82e:	4610      	mov	r0, r2
 800d830:	4798      	blx	r3
 800d832:	4603      	mov	r3, r0
 800d834:	73fb      	strb	r3, [r7, #15]
  return stat;
 800d836:	7bfb      	ldrb	r3, [r7, #15]
}
 800d838:	4618      	mov	r0, r3
 800d83a:	3710      	adds	r7, #16
 800d83c:	46bd      	mov	sp, r7
 800d83e:	bd80      	pop	{r7, pc}
 800d840:	20002d84 	.word	0x20002d84

0800d844 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 800d844:	b580      	push	{r7, lr}
 800d846:	b084      	sub	sp, #16
 800d848:	af00      	add	r7, sp, #0
 800d84a:	4603      	mov	r3, r0
 800d84c:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat = RES_OK;
 800d84e:	2300      	movs	r3, #0
 800d850:	73fb      	strb	r3, [r7, #15]

  if(disk.is_initialized[pdrv] == 0)
 800d852:	79fb      	ldrb	r3, [r7, #7]
 800d854:	4a0e      	ldr	r2, [pc, #56]	@ (800d890 <disk_initialize+0x4c>)
 800d856:	5cd3      	ldrb	r3, [r2, r3]
 800d858:	2b00      	cmp	r3, #0
 800d85a:	d114      	bne.n	800d886 <disk_initialize+0x42>
  {
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800d85c:	79fb      	ldrb	r3, [r7, #7]
 800d85e:	4a0c      	ldr	r2, [pc, #48]	@ (800d890 <disk_initialize+0x4c>)
 800d860:	009b      	lsls	r3, r3, #2
 800d862:	4413      	add	r3, r2
 800d864:	685b      	ldr	r3, [r3, #4]
 800d866:	681b      	ldr	r3, [r3, #0]
 800d868:	79fa      	ldrb	r2, [r7, #7]
 800d86a:	4909      	ldr	r1, [pc, #36]	@ (800d890 <disk_initialize+0x4c>)
 800d86c:	440a      	add	r2, r1
 800d86e:	7a12      	ldrb	r2, [r2, #8]
 800d870:	4610      	mov	r0, r2
 800d872:	4798      	blx	r3
 800d874:	4603      	mov	r3, r0
 800d876:	73fb      	strb	r3, [r7, #15]
    if(stat == RES_OK)
 800d878:	7bfb      	ldrb	r3, [r7, #15]
 800d87a:	2b00      	cmp	r3, #0
 800d87c:	d103      	bne.n	800d886 <disk_initialize+0x42>
    {
      disk.is_initialized[pdrv] = 1;
 800d87e:	79fb      	ldrb	r3, [r7, #7]
 800d880:	4a03      	ldr	r2, [pc, #12]	@ (800d890 <disk_initialize+0x4c>)
 800d882:	2101      	movs	r1, #1
 800d884:	54d1      	strb	r1, [r2, r3]
    }
  }
  return stat;
 800d886:	7bfb      	ldrb	r3, [r7, #15]
}
 800d888:	4618      	mov	r0, r3
 800d88a:	3710      	adds	r7, #16
 800d88c:	46bd      	mov	sp, r7
 800d88e:	bd80      	pop	{r7, pc}
 800d890:	20002d84 	.word	0x20002d84

0800d894 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800d894:	b590      	push	{r4, r7, lr}
 800d896:	b087      	sub	sp, #28
 800d898:	af00      	add	r7, sp, #0
 800d89a:	60b9      	str	r1, [r7, #8]
 800d89c:	607a      	str	r2, [r7, #4]
 800d89e:	603b      	str	r3, [r7, #0]
 800d8a0:	4603      	mov	r3, r0
 800d8a2:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800d8a4:	7bfb      	ldrb	r3, [r7, #15]
 800d8a6:	4a0a      	ldr	r2, [pc, #40]	@ (800d8d0 <disk_read+0x3c>)
 800d8a8:	009b      	lsls	r3, r3, #2
 800d8aa:	4413      	add	r3, r2
 800d8ac:	685b      	ldr	r3, [r3, #4]
 800d8ae:	689c      	ldr	r4, [r3, #8]
 800d8b0:	7bfb      	ldrb	r3, [r7, #15]
 800d8b2:	4a07      	ldr	r2, [pc, #28]	@ (800d8d0 <disk_read+0x3c>)
 800d8b4:	4413      	add	r3, r2
 800d8b6:	7a18      	ldrb	r0, [r3, #8]
 800d8b8:	683b      	ldr	r3, [r7, #0]
 800d8ba:	687a      	ldr	r2, [r7, #4]
 800d8bc:	68b9      	ldr	r1, [r7, #8]
 800d8be:	47a0      	blx	r4
 800d8c0:	4603      	mov	r3, r0
 800d8c2:	75fb      	strb	r3, [r7, #23]
  return res;
 800d8c4:	7dfb      	ldrb	r3, [r7, #23]
}
 800d8c6:	4618      	mov	r0, r3
 800d8c8:	371c      	adds	r7, #28
 800d8ca:	46bd      	mov	sp, r7
 800d8cc:	bd90      	pop	{r4, r7, pc}
 800d8ce:	bf00      	nop
 800d8d0:	20002d84 	.word	0x20002d84

0800d8d4 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 800d8d4:	b590      	push	{r4, r7, lr}
 800d8d6:	b087      	sub	sp, #28
 800d8d8:	af00      	add	r7, sp, #0
 800d8da:	60b9      	str	r1, [r7, #8]
 800d8dc:	607a      	str	r2, [r7, #4]
 800d8de:	603b      	str	r3, [r7, #0]
 800d8e0:	4603      	mov	r3, r0
 800d8e2:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 800d8e4:	7bfb      	ldrb	r3, [r7, #15]
 800d8e6:	4a0a      	ldr	r2, [pc, #40]	@ (800d910 <disk_write+0x3c>)
 800d8e8:	009b      	lsls	r3, r3, #2
 800d8ea:	4413      	add	r3, r2
 800d8ec:	685b      	ldr	r3, [r3, #4]
 800d8ee:	68dc      	ldr	r4, [r3, #12]
 800d8f0:	7bfb      	ldrb	r3, [r7, #15]
 800d8f2:	4a07      	ldr	r2, [pc, #28]	@ (800d910 <disk_write+0x3c>)
 800d8f4:	4413      	add	r3, r2
 800d8f6:	7a18      	ldrb	r0, [r3, #8]
 800d8f8:	683b      	ldr	r3, [r7, #0]
 800d8fa:	687a      	ldr	r2, [r7, #4]
 800d8fc:	68b9      	ldr	r1, [r7, #8]
 800d8fe:	47a0      	blx	r4
 800d900:	4603      	mov	r3, r0
 800d902:	75fb      	strb	r3, [r7, #23]
  return res;
 800d904:	7dfb      	ldrb	r3, [r7, #23]
}
 800d906:	4618      	mov	r0, r3
 800d908:	371c      	adds	r7, #28
 800d90a:	46bd      	mov	sp, r7
 800d90c:	bd90      	pop	{r4, r7, pc}
 800d90e:	bf00      	nop
 800d910:	20002d84 	.word	0x20002d84

0800d914 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 800d914:	b580      	push	{r7, lr}
 800d916:	b084      	sub	sp, #16
 800d918:	af00      	add	r7, sp, #0
 800d91a:	4603      	mov	r3, r0
 800d91c:	603a      	str	r2, [r7, #0]
 800d91e:	71fb      	strb	r3, [r7, #7]
 800d920:	460b      	mov	r3, r1
 800d922:	71bb      	strb	r3, [r7, #6]
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800d924:	79fb      	ldrb	r3, [r7, #7]
 800d926:	4a09      	ldr	r2, [pc, #36]	@ (800d94c <disk_ioctl+0x38>)
 800d928:	009b      	lsls	r3, r3, #2
 800d92a:	4413      	add	r3, r2
 800d92c:	685b      	ldr	r3, [r3, #4]
 800d92e:	691b      	ldr	r3, [r3, #16]
 800d930:	79fa      	ldrb	r2, [r7, #7]
 800d932:	4906      	ldr	r1, [pc, #24]	@ (800d94c <disk_ioctl+0x38>)
 800d934:	440a      	add	r2, r1
 800d936:	7a10      	ldrb	r0, [r2, #8]
 800d938:	79b9      	ldrb	r1, [r7, #6]
 800d93a:	683a      	ldr	r2, [r7, #0]
 800d93c:	4798      	blx	r3
 800d93e:	4603      	mov	r3, r0
 800d940:	73fb      	strb	r3, [r7, #15]
  return res;
 800d942:	7bfb      	ldrb	r3, [r7, #15]
}
 800d944:	4618      	mov	r0, r3
 800d946:	3710      	adds	r7, #16
 800d948:	46bd      	mov	sp, r7
 800d94a:	bd80      	pop	{r7, pc}
 800d94c:	20002d84 	.word	0x20002d84

0800d950 <ld_word>:
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static
WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
 800d950:	b480      	push	{r7}
 800d952:	b085      	sub	sp, #20
 800d954:	af00      	add	r7, sp, #0
 800d956:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	3301      	adds	r3, #1
 800d95c:	781b      	ldrb	r3, [r3, #0]
 800d95e:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
 800d960:	89fb      	ldrh	r3, [r7, #14]
 800d962:	021b      	lsls	r3, r3, #8
 800d964:	b21a      	sxth	r2, r3
 800d966:	687b      	ldr	r3, [r7, #4]
 800d968:	781b      	ldrb	r3, [r3, #0]
 800d96a:	b21b      	sxth	r3, r3
 800d96c:	4313      	orrs	r3, r2
 800d96e:	b21b      	sxth	r3, r3
 800d970:	81fb      	strh	r3, [r7, #14]
	return rv;
 800d972:	89fb      	ldrh	r3, [r7, #14]
}
 800d974:	4618      	mov	r0, r3
 800d976:	3714      	adds	r7, #20
 800d978:	46bd      	mov	sp, r7
 800d97a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d97e:	4770      	bx	lr

0800d980 <ld_dword>:

static
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
 800d980:	b480      	push	{r7}
 800d982:	b085      	sub	sp, #20
 800d984:	af00      	add	r7, sp, #0
 800d986:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
 800d988:	687b      	ldr	r3, [r7, #4]
 800d98a:	3303      	adds	r3, #3
 800d98c:	781b      	ldrb	r3, [r3, #0]
 800d98e:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
 800d990:	68fb      	ldr	r3, [r7, #12]
 800d992:	021b      	lsls	r3, r3, #8
 800d994:	687a      	ldr	r2, [r7, #4]
 800d996:	3202      	adds	r2, #2
 800d998:	7812      	ldrb	r2, [r2, #0]
 800d99a:	4313      	orrs	r3, r2
 800d99c:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
 800d99e:	68fb      	ldr	r3, [r7, #12]
 800d9a0:	021b      	lsls	r3, r3, #8
 800d9a2:	687a      	ldr	r2, [r7, #4]
 800d9a4:	3201      	adds	r2, #1
 800d9a6:	7812      	ldrb	r2, [r2, #0]
 800d9a8:	4313      	orrs	r3, r2
 800d9aa:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
 800d9ac:	68fb      	ldr	r3, [r7, #12]
 800d9ae:	021b      	lsls	r3, r3, #8
 800d9b0:	687a      	ldr	r2, [r7, #4]
 800d9b2:	7812      	ldrb	r2, [r2, #0]
 800d9b4:	4313      	orrs	r3, r2
 800d9b6:	60fb      	str	r3, [r7, #12]
	return rv;
 800d9b8:	68fb      	ldr	r3, [r7, #12]
}
 800d9ba:	4618      	mov	r0, r3
 800d9bc:	3714      	adds	r7, #20
 800d9be:	46bd      	mov	sp, r7
 800d9c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9c4:	4770      	bx	lr

0800d9c6 <ld_qword>:

#if _FS_EXFAT
static
QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
{
 800d9c6:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 800d9ca:	b09d      	sub	sp, #116	@ 0x74
 800d9cc:	af00      	add	r7, sp, #0
 800d9ce:	6678      	str	r0, [r7, #100]	@ 0x64
	QWORD rv;

	rv = ptr[7];
 800d9d0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800d9d2:	3307      	adds	r3, #7
 800d9d4:	781b      	ldrb	r3, [r3, #0]
 800d9d6:	b2db      	uxtb	r3, r3
 800d9d8:	2200      	movs	r2, #0
 800d9da:	469a      	mov	sl, r3
 800d9dc:	4693      	mov	fp, r2
 800d9de:	e9c7 ab1a 	strd	sl, fp, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[6];
 800d9e2:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800d9e6:	f04f 0000 	mov.w	r0, #0
 800d9ea:	f04f 0100 	mov.w	r1, #0
 800d9ee:	0219      	lsls	r1, r3, #8
 800d9f0:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800d9f4:	0210      	lsls	r0, r2, #8
 800d9f6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800d9f8:	3306      	adds	r3, #6
 800d9fa:	781b      	ldrb	r3, [r3, #0]
 800d9fc:	b2db      	uxtb	r3, r3
 800d9fe:	2200      	movs	r2, #0
 800da00:	461c      	mov	r4, r3
 800da02:	4615      	mov	r5, r2
 800da04:	ea40 0804 	orr.w	r8, r0, r4
 800da08:	ea41 0905 	orr.w	r9, r1, r5
 800da0c:	e9c7 891a 	strd	r8, r9, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[5];
 800da10:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800da14:	f04f 0000 	mov.w	r0, #0
 800da18:	f04f 0100 	mov.w	r1, #0
 800da1c:	0219      	lsls	r1, r3, #8
 800da1e:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800da22:	0210      	lsls	r0, r2, #8
 800da24:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800da26:	3305      	adds	r3, #5
 800da28:	781b      	ldrb	r3, [r3, #0]
 800da2a:	b2db      	uxtb	r3, r3
 800da2c:	2200      	movs	r2, #0
 800da2e:	65bb      	str	r3, [r7, #88]	@ 0x58
 800da30:	65fa      	str	r2, [r7, #92]	@ 0x5c
 800da32:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
 800da36:	4623      	mov	r3, r4
 800da38:	4303      	orrs	r3, r0
 800da3a:	62bb      	str	r3, [r7, #40]	@ 0x28
 800da3c:	462b      	mov	r3, r5
 800da3e:	430b      	orrs	r3, r1
 800da40:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800da42:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	@ 0x28
 800da46:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[4];
 800da4a:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800da4e:	f04f 0000 	mov.w	r0, #0
 800da52:	f04f 0100 	mov.w	r1, #0
 800da56:	0219      	lsls	r1, r3, #8
 800da58:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800da5c:	0210      	lsls	r0, r2, #8
 800da5e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800da60:	3304      	adds	r3, #4
 800da62:	781b      	ldrb	r3, [r3, #0]
 800da64:	b2db      	uxtb	r3, r3
 800da66:	2200      	movs	r2, #0
 800da68:	653b      	str	r3, [r7, #80]	@ 0x50
 800da6a:	657a      	str	r2, [r7, #84]	@ 0x54
 800da6c:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	@ 0x50
 800da70:	4623      	mov	r3, r4
 800da72:	4303      	orrs	r3, r0
 800da74:	623b      	str	r3, [r7, #32]
 800da76:	462b      	mov	r3, r5
 800da78:	430b      	orrs	r3, r1
 800da7a:	627b      	str	r3, [r7, #36]	@ 0x24
 800da7c:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 800da80:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[3];
 800da84:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800da88:	f04f 0000 	mov.w	r0, #0
 800da8c:	f04f 0100 	mov.w	r1, #0
 800da90:	0219      	lsls	r1, r3, #8
 800da92:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800da96:	0210      	lsls	r0, r2, #8
 800da98:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800da9a:	3303      	adds	r3, #3
 800da9c:	781b      	ldrb	r3, [r3, #0]
 800da9e:	b2db      	uxtb	r3, r3
 800daa0:	2200      	movs	r2, #0
 800daa2:	64bb      	str	r3, [r7, #72]	@ 0x48
 800daa4:	64fa      	str	r2, [r7, #76]	@ 0x4c
 800daa6:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 800daaa:	4623      	mov	r3, r4
 800daac:	4303      	orrs	r3, r0
 800daae:	61bb      	str	r3, [r7, #24]
 800dab0:	462b      	mov	r3, r5
 800dab2:	430b      	orrs	r3, r1
 800dab4:	61fb      	str	r3, [r7, #28]
 800dab6:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800daba:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[2];
 800dabe:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800dac2:	f04f 0000 	mov.w	r0, #0
 800dac6:	f04f 0100 	mov.w	r1, #0
 800daca:	0219      	lsls	r1, r3, #8
 800dacc:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800dad0:	0210      	lsls	r0, r2, #8
 800dad2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800dad4:	3302      	adds	r3, #2
 800dad6:	781b      	ldrb	r3, [r3, #0]
 800dad8:	b2db      	uxtb	r3, r3
 800dada:	2200      	movs	r2, #0
 800dadc:	643b      	str	r3, [r7, #64]	@ 0x40
 800dade:	647a      	str	r2, [r7, #68]	@ 0x44
 800dae0:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 800dae4:	4623      	mov	r3, r4
 800dae6:	4303      	orrs	r3, r0
 800dae8:	613b      	str	r3, [r7, #16]
 800daea:	462b      	mov	r3, r5
 800daec:	430b      	orrs	r3, r1
 800daee:	617b      	str	r3, [r7, #20]
 800daf0:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800daf4:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[1];
 800daf8:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
 800dafc:	f04f 0200 	mov.w	r2, #0
 800db00:	f04f 0300 	mov.w	r3, #0
 800db04:	020b      	lsls	r3, r1, #8
 800db06:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 800db0a:	0202      	lsls	r2, r0, #8
 800db0c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 800db0e:	3101      	adds	r1, #1
 800db10:	7809      	ldrb	r1, [r1, #0]
 800db12:	b2c9      	uxtb	r1, r1
 800db14:	2000      	movs	r0, #0
 800db16:	63b9      	str	r1, [r7, #56]	@ 0x38
 800db18:	63f8      	str	r0, [r7, #60]	@ 0x3c
 800db1a:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
 800db1e:	4621      	mov	r1, r4
 800db20:	4311      	orrs	r1, r2
 800db22:	60b9      	str	r1, [r7, #8]
 800db24:	4629      	mov	r1, r5
 800db26:	4319      	orrs	r1, r3
 800db28:	60f9      	str	r1, [r7, #12]
 800db2a:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800db2e:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	rv = rv << 8 | ptr[0];
 800db32:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
 800db36:	f04f 0200 	mov.w	r2, #0
 800db3a:	f04f 0300 	mov.w	r3, #0
 800db3e:	020b      	lsls	r3, r1, #8
 800db40:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 800db44:	0202      	lsls	r2, r0, #8
 800db46:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 800db48:	7809      	ldrb	r1, [r1, #0]
 800db4a:	b2c9      	uxtb	r1, r1
 800db4c:	2000      	movs	r0, #0
 800db4e:	6339      	str	r1, [r7, #48]	@ 0x30
 800db50:	6378      	str	r0, [r7, #52]	@ 0x34
 800db52:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 800db56:	4621      	mov	r1, r4
 800db58:	4311      	orrs	r1, r2
 800db5a:	6039      	str	r1, [r7, #0]
 800db5c:	4629      	mov	r1, r5
 800db5e:	4319      	orrs	r1, r3
 800db60:	6079      	str	r1, [r7, #4]
 800db62:	e9d7 3400 	ldrd	r3, r4, [r7]
 800db66:	e9c7 341a 	strd	r3, r4, [r7, #104]	@ 0x68
	return rv;
 800db6a:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
}
 800db6e:	4610      	mov	r0, r2
 800db70:	4619      	mov	r1, r3
 800db72:	3774      	adds	r7, #116	@ 0x74
 800db74:	46bd      	mov	sp, r7
 800db76:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 800db7a:	4770      	bx	lr

0800db7c <st_word>:
#endif

#if !_FS_READONLY
static
void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
 800db7c:	b480      	push	{r7}
 800db7e:	b083      	sub	sp, #12
 800db80:	af00      	add	r7, sp, #0
 800db82:	6078      	str	r0, [r7, #4]
 800db84:	460b      	mov	r3, r1
 800db86:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 800db88:	687b      	ldr	r3, [r7, #4]
 800db8a:	1c5a      	adds	r2, r3, #1
 800db8c:	607a      	str	r2, [r7, #4]
 800db8e:	887a      	ldrh	r2, [r7, #2]
 800db90:	b2d2      	uxtb	r2, r2
 800db92:	701a      	strb	r2, [r3, #0]
 800db94:	887b      	ldrh	r3, [r7, #2]
 800db96:	0a1b      	lsrs	r3, r3, #8
 800db98:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
 800db9a:	687b      	ldr	r3, [r7, #4]
 800db9c:	1c5a      	adds	r2, r3, #1
 800db9e:	607a      	str	r2, [r7, #4]
 800dba0:	887a      	ldrh	r2, [r7, #2]
 800dba2:	b2d2      	uxtb	r2, r2
 800dba4:	701a      	strb	r2, [r3, #0]
}
 800dba6:	bf00      	nop
 800dba8:	370c      	adds	r7, #12
 800dbaa:	46bd      	mov	sp, r7
 800dbac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbb0:	4770      	bx	lr

0800dbb2 <st_dword>:

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
 800dbb2:	b480      	push	{r7}
 800dbb4:	b083      	sub	sp, #12
 800dbb6:	af00      	add	r7, sp, #0
 800dbb8:	6078      	str	r0, [r7, #4]
 800dbba:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dbbc:	687b      	ldr	r3, [r7, #4]
 800dbbe:	1c5a      	adds	r2, r3, #1
 800dbc0:	607a      	str	r2, [r7, #4]
 800dbc2:	683a      	ldr	r2, [r7, #0]
 800dbc4:	b2d2      	uxtb	r2, r2
 800dbc6:	701a      	strb	r2, [r3, #0]
 800dbc8:	683b      	ldr	r3, [r7, #0]
 800dbca:	0a1b      	lsrs	r3, r3, #8
 800dbcc:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dbce:	687b      	ldr	r3, [r7, #4]
 800dbd0:	1c5a      	adds	r2, r3, #1
 800dbd2:	607a      	str	r2, [r7, #4]
 800dbd4:	683a      	ldr	r2, [r7, #0]
 800dbd6:	b2d2      	uxtb	r2, r2
 800dbd8:	701a      	strb	r2, [r3, #0]
 800dbda:	683b      	ldr	r3, [r7, #0]
 800dbdc:	0a1b      	lsrs	r3, r3, #8
 800dbde:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800dbe0:	687b      	ldr	r3, [r7, #4]
 800dbe2:	1c5a      	adds	r2, r3, #1
 800dbe4:	607a      	str	r2, [r7, #4]
 800dbe6:	683a      	ldr	r2, [r7, #0]
 800dbe8:	b2d2      	uxtb	r2, r2
 800dbea:	701a      	strb	r2, [r3, #0]
 800dbec:	683b      	ldr	r3, [r7, #0]
 800dbee:	0a1b      	lsrs	r3, r3, #8
 800dbf0:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
 800dbf2:	687b      	ldr	r3, [r7, #4]
 800dbf4:	1c5a      	adds	r2, r3, #1
 800dbf6:	607a      	str	r2, [r7, #4]
 800dbf8:	683a      	ldr	r2, [r7, #0]
 800dbfa:	b2d2      	uxtb	r2, r2
 800dbfc:	701a      	strb	r2, [r3, #0]
}
 800dbfe:	bf00      	nop
 800dc00:	370c      	adds	r7, #12
 800dc02:	46bd      	mov	sp, r7
 800dc04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc08:	4770      	bx	lr

0800dc0a <st_qword>:

#if _FS_EXFAT
static
void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
{
 800dc0a:	b480      	push	{r7}
 800dc0c:	b085      	sub	sp, #20
 800dc0e:	af00      	add	r7, sp, #0
 800dc10:	60f8      	str	r0, [r7, #12]
 800dc12:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc16:	68fb      	ldr	r3, [r7, #12]
 800dc18:	1c5a      	adds	r2, r3, #1
 800dc1a:	60fa      	str	r2, [r7, #12]
 800dc1c:	783a      	ldrb	r2, [r7, #0]
 800dc1e:	701a      	strb	r2, [r3, #0]
 800dc20:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dc24:	f04f 0200 	mov.w	r2, #0
 800dc28:	f04f 0300 	mov.w	r3, #0
 800dc2c:	0a02      	lsrs	r2, r0, #8
 800dc2e:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dc32:	0a0b      	lsrs	r3, r1, #8
 800dc34:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc38:	68fb      	ldr	r3, [r7, #12]
 800dc3a:	1c5a      	adds	r2, r3, #1
 800dc3c:	60fa      	str	r2, [r7, #12]
 800dc3e:	783a      	ldrb	r2, [r7, #0]
 800dc40:	701a      	strb	r2, [r3, #0]
 800dc42:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dc46:	f04f 0200 	mov.w	r2, #0
 800dc4a:	f04f 0300 	mov.w	r3, #0
 800dc4e:	0a02      	lsrs	r2, r0, #8
 800dc50:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dc54:	0a0b      	lsrs	r3, r1, #8
 800dc56:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc5a:	68fb      	ldr	r3, [r7, #12]
 800dc5c:	1c5a      	adds	r2, r3, #1
 800dc5e:	60fa      	str	r2, [r7, #12]
 800dc60:	783a      	ldrb	r2, [r7, #0]
 800dc62:	701a      	strb	r2, [r3, #0]
 800dc64:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dc68:	f04f 0200 	mov.w	r2, #0
 800dc6c:	f04f 0300 	mov.w	r3, #0
 800dc70:	0a02      	lsrs	r2, r0, #8
 800dc72:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dc76:	0a0b      	lsrs	r3, r1, #8
 800dc78:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc7c:	68fb      	ldr	r3, [r7, #12]
 800dc7e:	1c5a      	adds	r2, r3, #1
 800dc80:	60fa      	str	r2, [r7, #12]
 800dc82:	783a      	ldrb	r2, [r7, #0]
 800dc84:	701a      	strb	r2, [r3, #0]
 800dc86:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dc8a:	f04f 0200 	mov.w	r2, #0
 800dc8e:	f04f 0300 	mov.w	r3, #0
 800dc92:	0a02      	lsrs	r2, r0, #8
 800dc94:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dc98:	0a0b      	lsrs	r3, r1, #8
 800dc9a:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dc9e:	68fb      	ldr	r3, [r7, #12]
 800dca0:	1c5a      	adds	r2, r3, #1
 800dca2:	60fa      	str	r2, [r7, #12]
 800dca4:	783a      	ldrb	r2, [r7, #0]
 800dca6:	701a      	strb	r2, [r3, #0]
 800dca8:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dcac:	f04f 0200 	mov.w	r2, #0
 800dcb0:	f04f 0300 	mov.w	r3, #0
 800dcb4:	0a02      	lsrs	r2, r0, #8
 800dcb6:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dcba:	0a0b      	lsrs	r3, r1, #8
 800dcbc:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dcc0:	68fb      	ldr	r3, [r7, #12]
 800dcc2:	1c5a      	adds	r2, r3, #1
 800dcc4:	60fa      	str	r2, [r7, #12]
 800dcc6:	783a      	ldrb	r2, [r7, #0]
 800dcc8:	701a      	strb	r2, [r3, #0]
 800dcca:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dcce:	f04f 0200 	mov.w	r2, #0
 800dcd2:	f04f 0300 	mov.w	r3, #0
 800dcd6:	0a02      	lsrs	r2, r0, #8
 800dcd8:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dcdc:	0a0b      	lsrs	r3, r1, #8
 800dcde:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val; val >>= 8;
 800dce2:	68fb      	ldr	r3, [r7, #12]
 800dce4:	1c5a      	adds	r2, r3, #1
 800dce6:	60fa      	str	r2, [r7, #12]
 800dce8:	783a      	ldrb	r2, [r7, #0]
 800dcea:	701a      	strb	r2, [r3, #0]
 800dcec:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dcf0:	f04f 0200 	mov.w	r2, #0
 800dcf4:	f04f 0300 	mov.w	r3, #0
 800dcf8:	0a02      	lsrs	r2, r0, #8
 800dcfa:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800dcfe:	0a0b      	lsrs	r3, r1, #8
 800dd00:	e9c7 2300 	strd	r2, r3, [r7]
	*ptr++ = (BYTE)val;
 800dd04:	68fb      	ldr	r3, [r7, #12]
 800dd06:	1c5a      	adds	r2, r3, #1
 800dd08:	60fa      	str	r2, [r7, #12]
 800dd0a:	783a      	ldrb	r2, [r7, #0]
 800dd0c:	701a      	strb	r2, [r3, #0]
}
 800dd0e:	bf00      	nop
 800dd10:	3714      	adds	r7, #20
 800dd12:	46bd      	mov	sp, r7
 800dd14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd18:	4770      	bx	lr

0800dd1a <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800dd1a:	b480      	push	{r7}
 800dd1c:	b087      	sub	sp, #28
 800dd1e:	af00      	add	r7, sp, #0
 800dd20:	60f8      	str	r0, [r7, #12]
 800dd22:	60b9      	str	r1, [r7, #8]
 800dd24:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800dd26:	68fb      	ldr	r3, [r7, #12]
 800dd28:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 800dd2a:	68bb      	ldr	r3, [r7, #8]
 800dd2c:	613b      	str	r3, [r7, #16]

	if (cnt) {
 800dd2e:	687b      	ldr	r3, [r7, #4]
 800dd30:	2b00      	cmp	r3, #0
 800dd32:	d00d      	beq.n	800dd50 <mem_cpy+0x36>
		do {
			*d++ = *s++;
 800dd34:	693a      	ldr	r2, [r7, #16]
 800dd36:	1c53      	adds	r3, r2, #1
 800dd38:	613b      	str	r3, [r7, #16]
 800dd3a:	697b      	ldr	r3, [r7, #20]
 800dd3c:	1c59      	adds	r1, r3, #1
 800dd3e:	6179      	str	r1, [r7, #20]
 800dd40:	7812      	ldrb	r2, [r2, #0]
 800dd42:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
 800dd44:	687b      	ldr	r3, [r7, #4]
 800dd46:	3b01      	subs	r3, #1
 800dd48:	607b      	str	r3, [r7, #4]
 800dd4a:	687b      	ldr	r3, [r7, #4]
 800dd4c:	2b00      	cmp	r3, #0
 800dd4e:	d1f1      	bne.n	800dd34 <mem_cpy+0x1a>
	}
}
 800dd50:	bf00      	nop
 800dd52:	371c      	adds	r7, #28
 800dd54:	46bd      	mov	sp, r7
 800dd56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd5a:	4770      	bx	lr

0800dd5c <mem_set>:

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
 800dd5c:	b480      	push	{r7}
 800dd5e:	b087      	sub	sp, #28
 800dd60:	af00      	add	r7, sp, #0
 800dd62:	60f8      	str	r0, [r7, #12]
 800dd64:	60b9      	str	r1, [r7, #8]
 800dd66:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800dd68:	68fb      	ldr	r3, [r7, #12]
 800dd6a:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
 800dd6c:	697b      	ldr	r3, [r7, #20]
 800dd6e:	1c5a      	adds	r2, r3, #1
 800dd70:	617a      	str	r2, [r7, #20]
 800dd72:	68ba      	ldr	r2, [r7, #8]
 800dd74:	b2d2      	uxtb	r2, r2
 800dd76:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
 800dd78:	687b      	ldr	r3, [r7, #4]
 800dd7a:	3b01      	subs	r3, #1
 800dd7c:	607b      	str	r3, [r7, #4]
 800dd7e:	687b      	ldr	r3, [r7, #4]
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	d1f3      	bne.n	800dd6c <mem_set+0x10>
}
 800dd84:	bf00      	nop
 800dd86:	bf00      	nop
 800dd88:	371c      	adds	r7, #28
 800dd8a:	46bd      	mov	sp, r7
 800dd8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd90:	4770      	bx	lr

0800dd92 <mem_cmp>:

/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
 800dd92:	b480      	push	{r7}
 800dd94:	b089      	sub	sp, #36	@ 0x24
 800dd96:	af00      	add	r7, sp, #0
 800dd98:	60f8      	str	r0, [r7, #12]
 800dd9a:	60b9      	str	r1, [r7, #8]
 800dd9c:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 800dd9e:	68fb      	ldr	r3, [r7, #12]
 800dda0:	61fb      	str	r3, [r7, #28]
 800dda2:	68bb      	ldr	r3, [r7, #8]
 800dda4:	61bb      	str	r3, [r7, #24]
	int r = 0;
 800dda6:	2300      	movs	r3, #0
 800dda8:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
 800ddaa:	69fb      	ldr	r3, [r7, #28]
 800ddac:	1c5a      	adds	r2, r3, #1
 800ddae:	61fa      	str	r2, [r7, #28]
 800ddb0:	781b      	ldrb	r3, [r3, #0]
 800ddb2:	4619      	mov	r1, r3
 800ddb4:	69bb      	ldr	r3, [r7, #24]
 800ddb6:	1c5a      	adds	r2, r3, #1
 800ddb8:	61ba      	str	r2, [r7, #24]
 800ddba:	781b      	ldrb	r3, [r3, #0]
 800ddbc:	1acb      	subs	r3, r1, r3
 800ddbe:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
 800ddc0:	687b      	ldr	r3, [r7, #4]
 800ddc2:	3b01      	subs	r3, #1
 800ddc4:	607b      	str	r3, [r7, #4]
 800ddc6:	687b      	ldr	r3, [r7, #4]
 800ddc8:	2b00      	cmp	r3, #0
 800ddca:	d002      	beq.n	800ddd2 <mem_cmp+0x40>
 800ddcc:	697b      	ldr	r3, [r7, #20]
 800ddce:	2b00      	cmp	r3, #0
 800ddd0:	d0eb      	beq.n	800ddaa <mem_cmp+0x18>

	return r;
 800ddd2:	697b      	ldr	r3, [r7, #20]
}
 800ddd4:	4618      	mov	r0, r3
 800ddd6:	3724      	adds	r7, #36	@ 0x24
 800ddd8:	46bd      	mov	sp, r7
 800ddda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddde:	4770      	bx	lr

0800dde0 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
 800dde0:	b480      	push	{r7}
 800dde2:	b083      	sub	sp, #12
 800dde4:	af00      	add	r7, sp, #0
 800dde6:	6078      	str	r0, [r7, #4]
 800dde8:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 800ddea:	e002      	b.n	800ddf2 <chk_chr+0x12>
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	3301      	adds	r3, #1
 800ddf0:	607b      	str	r3, [r7, #4]
 800ddf2:	687b      	ldr	r3, [r7, #4]
 800ddf4:	781b      	ldrb	r3, [r3, #0]
 800ddf6:	2b00      	cmp	r3, #0
 800ddf8:	d005      	beq.n	800de06 <chk_chr+0x26>
 800ddfa:	687b      	ldr	r3, [r7, #4]
 800ddfc:	781b      	ldrb	r3, [r3, #0]
 800ddfe:	461a      	mov	r2, r3
 800de00:	683b      	ldr	r3, [r7, #0]
 800de02:	4293      	cmp	r3, r2
 800de04:	d1f2      	bne.n	800ddec <chk_chr+0xc>
	return *str;
 800de06:	687b      	ldr	r3, [r7, #4]
 800de08:	781b      	ldrb	r3, [r3, #0]
}
 800de0a:	4618      	mov	r0, r3
 800de0c:	370c      	adds	r7, #12
 800de0e:	46bd      	mov	sp, r7
 800de10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de14:	4770      	bx	lr
	...

0800de18 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 800de18:	b480      	push	{r7}
 800de1a:	b085      	sub	sp, #20
 800de1c:	af00      	add	r7, sp, #0
 800de1e:	6078      	str	r0, [r7, #4]
 800de20:	6039      	str	r1, [r7, #0]
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 800de22:	2300      	movs	r3, #0
 800de24:	60bb      	str	r3, [r7, #8]
 800de26:	68bb      	ldr	r3, [r7, #8]
 800de28:	60fb      	str	r3, [r7, #12]
 800de2a:	e029      	b.n	800de80 <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
 800de2c:	4a27      	ldr	r2, [pc, #156]	@ (800decc <chk_lock+0xb4>)
 800de2e:	68fb      	ldr	r3, [r7, #12]
 800de30:	011b      	lsls	r3, r3, #4
 800de32:	4413      	add	r3, r2
 800de34:	681b      	ldr	r3, [r3, #0]
 800de36:	2b00      	cmp	r3, #0
 800de38:	d01d      	beq.n	800de76 <chk_lock+0x5e>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800de3a:	4a24      	ldr	r2, [pc, #144]	@ (800decc <chk_lock+0xb4>)
 800de3c:	68fb      	ldr	r3, [r7, #12]
 800de3e:	011b      	lsls	r3, r3, #4
 800de40:	4413      	add	r3, r2
 800de42:	681a      	ldr	r2, [r3, #0]
 800de44:	687b      	ldr	r3, [r7, #4]
 800de46:	681b      	ldr	r3, [r3, #0]
 800de48:	429a      	cmp	r2, r3
 800de4a:	d116      	bne.n	800de7a <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
 800de4c:	4a1f      	ldr	r2, [pc, #124]	@ (800decc <chk_lock+0xb4>)
 800de4e:	68fb      	ldr	r3, [r7, #12]
 800de50:	011b      	lsls	r3, r3, #4
 800de52:	4413      	add	r3, r2
 800de54:	3304      	adds	r3, #4
 800de56:	681a      	ldr	r2, [r3, #0]
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	689b      	ldr	r3, [r3, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800de5c:	429a      	cmp	r2, r3
 800de5e:	d10c      	bne.n	800de7a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 800de60:	4a1a      	ldr	r2, [pc, #104]	@ (800decc <chk_lock+0xb4>)
 800de62:	68fb      	ldr	r3, [r7, #12]
 800de64:	011b      	lsls	r3, r3, #4
 800de66:	4413      	add	r3, r2
 800de68:	3308      	adds	r3, #8
 800de6a:	681a      	ldr	r2, [r3, #0]
 800de6c:	687b      	ldr	r3, [r7, #4]
 800de6e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
				Files[i].clu == dp->obj.sclust &&
 800de70:	429a      	cmp	r2, r3
 800de72:	d102      	bne.n	800de7a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 800de74:	e007      	b.n	800de86 <chk_lock+0x6e>
		} else {			/* Blank entry */
			be = 1;
 800de76:	2301      	movs	r3, #1
 800de78:	60bb      	str	r3, [r7, #8]
	for (i = be = 0; i < _FS_LOCK; i++) {
 800de7a:	68fb      	ldr	r3, [r7, #12]
 800de7c:	3301      	adds	r3, #1
 800de7e:	60fb      	str	r3, [r7, #12]
 800de80:	68fb      	ldr	r3, [r7, #12]
 800de82:	2b01      	cmp	r3, #1
 800de84:	d9d2      	bls.n	800de2c <chk_lock+0x14>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
 800de86:	68fb      	ldr	r3, [r7, #12]
 800de88:	2b02      	cmp	r3, #2
 800de8a:	d109      	bne.n	800dea0 <chk_lock+0x88>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 800de8c:	68bb      	ldr	r3, [r7, #8]
 800de8e:	2b00      	cmp	r3, #0
 800de90:	d102      	bne.n	800de98 <chk_lock+0x80>
 800de92:	683b      	ldr	r3, [r7, #0]
 800de94:	2b02      	cmp	r3, #2
 800de96:	d101      	bne.n	800de9c <chk_lock+0x84>
 800de98:	2300      	movs	r3, #0
 800de9a:	e010      	b.n	800debe <chk_lock+0xa6>
 800de9c:	2312      	movs	r3, #18
 800de9e:	e00e      	b.n	800debe <chk_lock+0xa6>
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800dea0:	683b      	ldr	r3, [r7, #0]
 800dea2:	2b00      	cmp	r3, #0
 800dea4:	d108      	bne.n	800deb8 <chk_lock+0xa0>
 800dea6:	4a09      	ldr	r2, [pc, #36]	@ (800decc <chk_lock+0xb4>)
 800dea8:	68fb      	ldr	r3, [r7, #12]
 800deaa:	011b      	lsls	r3, r3, #4
 800deac:	4413      	add	r3, r2
 800deae:	330c      	adds	r3, #12
 800deb0:	881b      	ldrh	r3, [r3, #0]
 800deb2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800deb6:	d101      	bne.n	800debc <chk_lock+0xa4>
 800deb8:	2310      	movs	r3, #16
 800deba:	e000      	b.n	800debe <chk_lock+0xa6>
 800debc:	2300      	movs	r3, #0
}
 800debe:	4618      	mov	r0, r3
 800dec0:	3714      	adds	r7, #20
 800dec2:	46bd      	mov	sp, r7
 800dec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dec8:	4770      	bx	lr
 800deca:	bf00      	nop
 800decc:	20002904 	.word	0x20002904

0800ded0 <enq_lock>:


static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
 800ded0:	b480      	push	{r7}
 800ded2:	b083      	sub	sp, #12
 800ded4:	af00      	add	r7, sp, #0
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800ded6:	2300      	movs	r3, #0
 800ded8:	607b      	str	r3, [r7, #4]
 800deda:	e002      	b.n	800dee2 <enq_lock+0x12>
 800dedc:	687b      	ldr	r3, [r7, #4]
 800dede:	3301      	adds	r3, #1
 800dee0:	607b      	str	r3, [r7, #4]
 800dee2:	687b      	ldr	r3, [r7, #4]
 800dee4:	2b01      	cmp	r3, #1
 800dee6:	d806      	bhi.n	800def6 <enq_lock+0x26>
 800dee8:	4a09      	ldr	r2, [pc, #36]	@ (800df10 <enq_lock+0x40>)
 800deea:	687b      	ldr	r3, [r7, #4]
 800deec:	011b      	lsls	r3, r3, #4
 800deee:	4413      	add	r3, r2
 800def0:	681b      	ldr	r3, [r3, #0]
 800def2:	2b00      	cmp	r3, #0
 800def4:	d1f2      	bne.n	800dedc <enq_lock+0xc>
	return (i == _FS_LOCK) ? 0 : 1;
 800def6:	687b      	ldr	r3, [r7, #4]
 800def8:	2b02      	cmp	r3, #2
 800defa:	bf14      	ite	ne
 800defc:	2301      	movne	r3, #1
 800defe:	2300      	moveq	r3, #0
 800df00:	b2db      	uxtb	r3, r3
}
 800df02:	4618      	mov	r0, r3
 800df04:	370c      	adds	r7, #12
 800df06:	46bd      	mov	sp, r7
 800df08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df0c:	4770      	bx	lr
 800df0e:	bf00      	nop
 800df10:	20002904 	.word	0x20002904

0800df14 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 800df14:	b480      	push	{r7}
 800df16:	b085      	sub	sp, #20
 800df18:	af00      	add	r7, sp, #0
 800df1a:	6078      	str	r0, [r7, #4]
 800df1c:	6039      	str	r1, [r7, #0]
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800df1e:	2300      	movs	r3, #0
 800df20:	60fb      	str	r3, [r7, #12]
 800df22:	e01f      	b.n	800df64 <inc_lock+0x50>
		if (Files[i].fs == dp->obj.fs &&
 800df24:	4a41      	ldr	r2, [pc, #260]	@ (800e02c <inc_lock+0x118>)
 800df26:	68fb      	ldr	r3, [r7, #12]
 800df28:	011b      	lsls	r3, r3, #4
 800df2a:	4413      	add	r3, r2
 800df2c:	681a      	ldr	r2, [r3, #0]
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	681b      	ldr	r3, [r3, #0]
 800df32:	429a      	cmp	r2, r3
 800df34:	d113      	bne.n	800df5e <inc_lock+0x4a>
			Files[i].clu == dp->obj.sclust &&
 800df36:	4a3d      	ldr	r2, [pc, #244]	@ (800e02c <inc_lock+0x118>)
 800df38:	68fb      	ldr	r3, [r7, #12]
 800df3a:	011b      	lsls	r3, r3, #4
 800df3c:	4413      	add	r3, r2
 800df3e:	3304      	adds	r3, #4
 800df40:	681a      	ldr	r2, [r3, #0]
 800df42:	687b      	ldr	r3, [r7, #4]
 800df44:	689b      	ldr	r3, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
 800df46:	429a      	cmp	r2, r3
 800df48:	d109      	bne.n	800df5e <inc_lock+0x4a>
			Files[i].ofs == dp->dptr) break;
 800df4a:	4a38      	ldr	r2, [pc, #224]	@ (800e02c <inc_lock+0x118>)
 800df4c:	68fb      	ldr	r3, [r7, #12]
 800df4e:	011b      	lsls	r3, r3, #4
 800df50:	4413      	add	r3, r2
 800df52:	3308      	adds	r3, #8
 800df54:	681a      	ldr	r2, [r3, #0]
 800df56:	687b      	ldr	r3, [r7, #4]
 800df58:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
			Files[i].clu == dp->obj.sclust &&
 800df5a:	429a      	cmp	r2, r3
 800df5c:	d006      	beq.n	800df6c <inc_lock+0x58>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800df5e:	68fb      	ldr	r3, [r7, #12]
 800df60:	3301      	adds	r3, #1
 800df62:	60fb      	str	r3, [r7, #12]
 800df64:	68fb      	ldr	r3, [r7, #12]
 800df66:	2b01      	cmp	r3, #1
 800df68:	d9dc      	bls.n	800df24 <inc_lock+0x10>
 800df6a:	e000      	b.n	800df6e <inc_lock+0x5a>
			Files[i].ofs == dp->dptr) break;
 800df6c:	bf00      	nop
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 800df6e:	68fb      	ldr	r3, [r7, #12]
 800df70:	2b02      	cmp	r3, #2
 800df72:	d132      	bne.n	800dfda <inc_lock+0xc6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800df74:	2300      	movs	r3, #0
 800df76:	60fb      	str	r3, [r7, #12]
 800df78:	e002      	b.n	800df80 <inc_lock+0x6c>
 800df7a:	68fb      	ldr	r3, [r7, #12]
 800df7c:	3301      	adds	r3, #1
 800df7e:	60fb      	str	r3, [r7, #12]
 800df80:	68fb      	ldr	r3, [r7, #12]
 800df82:	2b01      	cmp	r3, #1
 800df84:	d806      	bhi.n	800df94 <inc_lock+0x80>
 800df86:	4a29      	ldr	r2, [pc, #164]	@ (800e02c <inc_lock+0x118>)
 800df88:	68fb      	ldr	r3, [r7, #12]
 800df8a:	011b      	lsls	r3, r3, #4
 800df8c:	4413      	add	r3, r2
 800df8e:	681b      	ldr	r3, [r3, #0]
 800df90:	2b00      	cmp	r3, #0
 800df92:	d1f2      	bne.n	800df7a <inc_lock+0x66>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 800df94:	68fb      	ldr	r3, [r7, #12]
 800df96:	2b02      	cmp	r3, #2
 800df98:	d101      	bne.n	800df9e <inc_lock+0x8a>
 800df9a:	2300      	movs	r3, #0
 800df9c:	e040      	b.n	800e020 <inc_lock+0x10c>
		Files[i].fs = dp->obj.fs;
 800df9e:	687b      	ldr	r3, [r7, #4]
 800dfa0:	681a      	ldr	r2, [r3, #0]
 800dfa2:	4922      	ldr	r1, [pc, #136]	@ (800e02c <inc_lock+0x118>)
 800dfa4:	68fb      	ldr	r3, [r7, #12]
 800dfa6:	011b      	lsls	r3, r3, #4
 800dfa8:	440b      	add	r3, r1
 800dfaa:	601a      	str	r2, [r3, #0]
		Files[i].clu = dp->obj.sclust;
 800dfac:	687b      	ldr	r3, [r7, #4]
 800dfae:	689a      	ldr	r2, [r3, #8]
 800dfb0:	491e      	ldr	r1, [pc, #120]	@ (800e02c <inc_lock+0x118>)
 800dfb2:	68fb      	ldr	r3, [r7, #12]
 800dfb4:	011b      	lsls	r3, r3, #4
 800dfb6:	440b      	add	r3, r1
 800dfb8:	3304      	adds	r3, #4
 800dfba:	601a      	str	r2, [r3, #0]
		Files[i].ofs = dp->dptr;
 800dfbc:	687b      	ldr	r3, [r7, #4]
 800dfbe:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800dfc0:	491a      	ldr	r1, [pc, #104]	@ (800e02c <inc_lock+0x118>)
 800dfc2:	68fb      	ldr	r3, [r7, #12]
 800dfc4:	011b      	lsls	r3, r3, #4
 800dfc6:	440b      	add	r3, r1
 800dfc8:	3308      	adds	r3, #8
 800dfca:	601a      	str	r2, [r3, #0]
		Files[i].ctr = 0;
 800dfcc:	4a17      	ldr	r2, [pc, #92]	@ (800e02c <inc_lock+0x118>)
 800dfce:	68fb      	ldr	r3, [r7, #12]
 800dfd0:	011b      	lsls	r3, r3, #4
 800dfd2:	4413      	add	r3, r2
 800dfd4:	330c      	adds	r3, #12
 800dfd6:	2200      	movs	r2, #0
 800dfd8:	801a      	strh	r2, [r3, #0]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800dfda:	683b      	ldr	r3, [r7, #0]
 800dfdc:	2b00      	cmp	r3, #0
 800dfde:	d009      	beq.n	800dff4 <inc_lock+0xe0>
 800dfe0:	4a12      	ldr	r2, [pc, #72]	@ (800e02c <inc_lock+0x118>)
 800dfe2:	68fb      	ldr	r3, [r7, #12]
 800dfe4:	011b      	lsls	r3, r3, #4
 800dfe6:	4413      	add	r3, r2
 800dfe8:	330c      	adds	r3, #12
 800dfea:	881b      	ldrh	r3, [r3, #0]
 800dfec:	2b00      	cmp	r3, #0
 800dfee:	d001      	beq.n	800dff4 <inc_lock+0xe0>
 800dff0:	2300      	movs	r3, #0
 800dff2:	e015      	b.n	800e020 <inc_lock+0x10c>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800dff4:	683b      	ldr	r3, [r7, #0]
 800dff6:	2b00      	cmp	r3, #0
 800dff8:	d108      	bne.n	800e00c <inc_lock+0xf8>
 800dffa:	4a0c      	ldr	r2, [pc, #48]	@ (800e02c <inc_lock+0x118>)
 800dffc:	68fb      	ldr	r3, [r7, #12]
 800dffe:	011b      	lsls	r3, r3, #4
 800e000:	4413      	add	r3, r2
 800e002:	330c      	adds	r3, #12
 800e004:	881b      	ldrh	r3, [r3, #0]
 800e006:	3301      	adds	r3, #1
 800e008:	b29a      	uxth	r2, r3
 800e00a:	e001      	b.n	800e010 <inc_lock+0xfc>
 800e00c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800e010:	4906      	ldr	r1, [pc, #24]	@ (800e02c <inc_lock+0x118>)
 800e012:	68fb      	ldr	r3, [r7, #12]
 800e014:	011b      	lsls	r3, r3, #4
 800e016:	440b      	add	r3, r1
 800e018:	330c      	adds	r3, #12
 800e01a:	801a      	strh	r2, [r3, #0]

	return i + 1;
 800e01c:	68fb      	ldr	r3, [r7, #12]
 800e01e:	3301      	adds	r3, #1
}
 800e020:	4618      	mov	r0, r3
 800e022:	3714      	adds	r7, #20
 800e024:	46bd      	mov	sp, r7
 800e026:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e02a:	4770      	bx	lr
 800e02c:	20002904 	.word	0x20002904

0800e030 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
 800e030:	b480      	push	{r7}
 800e032:	b085      	sub	sp, #20
 800e034:	af00      	add	r7, sp, #0
 800e036:	6078      	str	r0, [r7, #4]
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 800e038:	687b      	ldr	r3, [r7, #4]
 800e03a:	3b01      	subs	r3, #1
 800e03c:	607b      	str	r3, [r7, #4]
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	2b01      	cmp	r3, #1
 800e042:	d825      	bhi.n	800e090 <dec_lock+0x60>
		n = Files[i].ctr;
 800e044:	4a17      	ldr	r2, [pc, #92]	@ (800e0a4 <dec_lock+0x74>)
 800e046:	687b      	ldr	r3, [r7, #4]
 800e048:	011b      	lsls	r3, r3, #4
 800e04a:	4413      	add	r3, r2
 800e04c:	330c      	adds	r3, #12
 800e04e:	881b      	ldrh	r3, [r3, #0]
 800e050:	81fb      	strh	r3, [r7, #14]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 800e052:	89fb      	ldrh	r3, [r7, #14]
 800e054:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800e058:	d101      	bne.n	800e05e <dec_lock+0x2e>
 800e05a:	2300      	movs	r3, #0
 800e05c:	81fb      	strh	r3, [r7, #14]
		if (n > 0) n--;				/* Decrement read mode open count */
 800e05e:	89fb      	ldrh	r3, [r7, #14]
 800e060:	2b00      	cmp	r3, #0
 800e062:	d002      	beq.n	800e06a <dec_lock+0x3a>
 800e064:	89fb      	ldrh	r3, [r7, #14]
 800e066:	3b01      	subs	r3, #1
 800e068:	81fb      	strh	r3, [r7, #14]
		Files[i].ctr = n;
 800e06a:	4a0e      	ldr	r2, [pc, #56]	@ (800e0a4 <dec_lock+0x74>)
 800e06c:	687b      	ldr	r3, [r7, #4]
 800e06e:	011b      	lsls	r3, r3, #4
 800e070:	4413      	add	r3, r2
 800e072:	330c      	adds	r3, #12
 800e074:	89fa      	ldrh	r2, [r7, #14]
 800e076:	801a      	strh	r2, [r3, #0]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800e078:	89fb      	ldrh	r3, [r7, #14]
 800e07a:	2b00      	cmp	r3, #0
 800e07c:	d105      	bne.n	800e08a <dec_lock+0x5a>
 800e07e:	4a09      	ldr	r2, [pc, #36]	@ (800e0a4 <dec_lock+0x74>)
 800e080:	687b      	ldr	r3, [r7, #4]
 800e082:	011b      	lsls	r3, r3, #4
 800e084:	4413      	add	r3, r2
 800e086:	2200      	movs	r2, #0
 800e088:	601a      	str	r2, [r3, #0]
		res = FR_OK;
 800e08a:	2300      	movs	r3, #0
 800e08c:	737b      	strb	r3, [r7, #13]
 800e08e:	e001      	b.n	800e094 <dec_lock+0x64>
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 800e090:	2302      	movs	r3, #2
 800e092:	737b      	strb	r3, [r7, #13]
	}
	return res;
 800e094:	7b7b      	ldrb	r3, [r7, #13]
}
 800e096:	4618      	mov	r0, r3
 800e098:	3714      	adds	r7, #20
 800e09a:	46bd      	mov	sp, r7
 800e09c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0a0:	4770      	bx	lr
 800e0a2:	bf00      	nop
 800e0a4:	20002904 	.word	0x20002904

0800e0a8 <clear_lock>:

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
 800e0a8:	b480      	push	{r7}
 800e0aa:	b085      	sub	sp, #20
 800e0ac:	af00      	add	r7, sp, #0
 800e0ae:	6078      	str	r0, [r7, #4]
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 800e0b0:	2300      	movs	r3, #0
 800e0b2:	60fb      	str	r3, [r7, #12]
 800e0b4:	e010      	b.n	800e0d8 <clear_lock+0x30>
		if (Files[i].fs == fs) Files[i].fs = 0;
 800e0b6:	4a0d      	ldr	r2, [pc, #52]	@ (800e0ec <clear_lock+0x44>)
 800e0b8:	68fb      	ldr	r3, [r7, #12]
 800e0ba:	011b      	lsls	r3, r3, #4
 800e0bc:	4413      	add	r3, r2
 800e0be:	681b      	ldr	r3, [r3, #0]
 800e0c0:	687a      	ldr	r2, [r7, #4]
 800e0c2:	429a      	cmp	r2, r3
 800e0c4:	d105      	bne.n	800e0d2 <clear_lock+0x2a>
 800e0c6:	4a09      	ldr	r2, [pc, #36]	@ (800e0ec <clear_lock+0x44>)
 800e0c8:	68fb      	ldr	r3, [r7, #12]
 800e0ca:	011b      	lsls	r3, r3, #4
 800e0cc:	4413      	add	r3, r2
 800e0ce:	2200      	movs	r2, #0
 800e0d0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < _FS_LOCK; i++) {
 800e0d2:	68fb      	ldr	r3, [r7, #12]
 800e0d4:	3301      	adds	r3, #1
 800e0d6:	60fb      	str	r3, [r7, #12]
 800e0d8:	68fb      	ldr	r3, [r7, #12]
 800e0da:	2b01      	cmp	r3, #1
 800e0dc:	d9eb      	bls.n	800e0b6 <clear_lock+0xe>
	}
}
 800e0de:	bf00      	nop
 800e0e0:	bf00      	nop
 800e0e2:	3714      	adds	r7, #20
 800e0e4:	46bd      	mov	sp, r7
 800e0e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0ea:	4770      	bx	lr
 800e0ec:	20002904 	.word	0x20002904

0800e0f0 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs			/* File system object */
)
{
 800e0f0:	b580      	push	{r7, lr}
 800e0f2:	b086      	sub	sp, #24
 800e0f4:	af00      	add	r7, sp, #0
 800e0f6:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 800e0f8:	2300      	movs	r3, #0
 800e0fa:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800e0fc:	687b      	ldr	r3, [r7, #4]
 800e0fe:	78db      	ldrb	r3, [r3, #3]
 800e100:	2b00      	cmp	r3, #0
 800e102:	d034      	beq.n	800e16e <sync_window+0x7e>
		wsect = fs->winsect;	/* Current sector number */
 800e104:	687b      	ldr	r3, [r7, #4]
 800e106:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800e108:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800e10a:	687b      	ldr	r3, [r7, #4]
 800e10c:	7858      	ldrb	r0, [r3, #1]
 800e10e:	687b      	ldr	r3, [r7, #4]
 800e110:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e114:	2301      	movs	r3, #1
 800e116:	697a      	ldr	r2, [r7, #20]
 800e118:	f7ff fbdc 	bl	800d8d4 <disk_write>
 800e11c:	4603      	mov	r3, r0
 800e11e:	2b00      	cmp	r3, #0
 800e120:	d002      	beq.n	800e128 <sync_window+0x38>
			res = FR_DISK_ERR;
 800e122:	2301      	movs	r3, #1
 800e124:	73fb      	strb	r3, [r7, #15]
 800e126:	e022      	b.n	800e16e <sync_window+0x7e>
		} else {
			fs->wflag = 0;
 800e128:	687b      	ldr	r3, [r7, #4]
 800e12a:	2200      	movs	r2, #0
 800e12c:	70da      	strb	r2, [r3, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800e12e:	687b      	ldr	r3, [r7, #4]
 800e130:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e132:	697a      	ldr	r2, [r7, #20]
 800e134:	1ad2      	subs	r2, r2, r3
 800e136:	687b      	ldr	r3, [r7, #4]
 800e138:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e13a:	429a      	cmp	r2, r3
 800e13c:	d217      	bcs.n	800e16e <sync_window+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	789b      	ldrb	r3, [r3, #2]
 800e142:	613b      	str	r3, [r7, #16]
 800e144:	e010      	b.n	800e168 <sync_window+0x78>
					wsect += fs->fsize;
 800e146:	687b      	ldr	r3, [r7, #4]
 800e148:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e14a:	697a      	ldr	r2, [r7, #20]
 800e14c:	4413      	add	r3, r2
 800e14e:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
 800e150:	687b      	ldr	r3, [r7, #4]
 800e152:	7858      	ldrb	r0, [r3, #1]
 800e154:	687b      	ldr	r3, [r7, #4]
 800e156:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e15a:	2301      	movs	r3, #1
 800e15c:	697a      	ldr	r2, [r7, #20]
 800e15e:	f7ff fbb9 	bl	800d8d4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e162:	693b      	ldr	r3, [r7, #16]
 800e164:	3b01      	subs	r3, #1
 800e166:	613b      	str	r3, [r7, #16]
 800e168:	693b      	ldr	r3, [r7, #16]
 800e16a:	2b01      	cmp	r3, #1
 800e16c:	d8eb      	bhi.n	800e146 <sync_window+0x56>
				}
			}
		}
	}
	return res;
 800e16e:	7bfb      	ldrb	r3, [r7, #15]
}
 800e170:	4618      	mov	r0, r3
 800e172:	3718      	adds	r7, #24
 800e174:	46bd      	mov	sp, r7
 800e176:	bd80      	pop	{r7, pc}

0800e178 <move_window>:
static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs,			/* File system object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
 800e178:	b580      	push	{r7, lr}
 800e17a:	b084      	sub	sp, #16
 800e17c:	af00      	add	r7, sp, #0
 800e17e:	6078      	str	r0, [r7, #4]
 800e180:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
 800e182:	2300      	movs	r3, #0
 800e184:	73fb      	strb	r3, [r7, #15]


	if (sector != fs->winsect) {	/* Window offset changed? */
 800e186:	687b      	ldr	r3, [r7, #4]
 800e188:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800e18a:	683a      	ldr	r2, [r7, #0]
 800e18c:	429a      	cmp	r2, r3
 800e18e:	d01b      	beq.n	800e1c8 <move_window+0x50>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 800e190:	6878      	ldr	r0, [r7, #4]
 800e192:	f7ff ffad 	bl	800e0f0 <sync_window>
 800e196:	4603      	mov	r3, r0
 800e198:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 800e19a:	7bfb      	ldrb	r3, [r7, #15]
 800e19c:	2b00      	cmp	r3, #0
 800e19e:	d113      	bne.n	800e1c8 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800e1a0:	687b      	ldr	r3, [r7, #4]
 800e1a2:	7858      	ldrb	r0, [r3, #1]
 800e1a4:	687b      	ldr	r3, [r7, #4]
 800e1a6:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e1aa:	2301      	movs	r3, #1
 800e1ac:	683a      	ldr	r2, [r7, #0]
 800e1ae:	f7ff fb71 	bl	800d894 <disk_read>
 800e1b2:	4603      	mov	r3, r0
 800e1b4:	2b00      	cmp	r3, #0
 800e1b6:	d004      	beq.n	800e1c2 <move_window+0x4a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 800e1b8:	f04f 33ff 	mov.w	r3, #4294967295
 800e1bc:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
 800e1be:	2301      	movs	r3, #1
 800e1c0:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sector;
 800e1c2:	687b      	ldr	r3, [r7, #4]
 800e1c4:	683a      	ldr	r2, [r7, #0]
 800e1c6:	639a      	str	r2, [r3, #56]	@ 0x38
		}
	}
	return res;
 800e1c8:	7bfb      	ldrb	r3, [r7, #15]
}
 800e1ca:	4618      	mov	r0, r3
 800e1cc:	3710      	adds	r7, #16
 800e1ce:	46bd      	mov	sp, r7
 800e1d0:	bd80      	pop	{r7, pc}
	...

0800e1d4 <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 800e1d4:	b580      	push	{r7, lr}
 800e1d6:	b084      	sub	sp, #16
 800e1d8:	af00      	add	r7, sp, #0
 800e1da:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
 800e1dc:	6878      	ldr	r0, [r7, #4]
 800e1de:	f7ff ff87 	bl	800e0f0 <sync_window>
 800e1e2:	4603      	mov	r3, r0
 800e1e4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800e1e6:	7bfb      	ldrb	r3, [r7, #15]
 800e1e8:	2b00      	cmp	r3, #0
 800e1ea:	d159      	bne.n	800e2a0 <sync_fs+0xcc>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800e1ec:	687b      	ldr	r3, [r7, #4]
 800e1ee:	781b      	ldrb	r3, [r3, #0]
 800e1f0:	2b03      	cmp	r3, #3
 800e1f2:	d149      	bne.n	800e288 <sync_fs+0xb4>
 800e1f4:	687b      	ldr	r3, [r7, #4]
 800e1f6:	791b      	ldrb	r3, [r3, #4]
 800e1f8:	2b01      	cmp	r3, #1
 800e1fa:	d145      	bne.n	800e288 <sync_fs+0xb4>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
 800e1fc:	687b      	ldr	r3, [r7, #4]
 800e1fe:	f103 003c 	add.w	r0, r3, #60	@ 0x3c
 800e202:	687b      	ldr	r3, [r7, #4]
 800e204:	899b      	ldrh	r3, [r3, #12]
 800e206:	461a      	mov	r2, r3
 800e208:	2100      	movs	r1, #0
 800e20a:	f7ff fda7 	bl	800dd5c <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
 800e20e:	687b      	ldr	r3, [r7, #4]
 800e210:	333c      	adds	r3, #60	@ 0x3c
 800e212:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 800e216:	f64a 2155 	movw	r1, #43605	@ 0xaa55
 800e21a:	4618      	mov	r0, r3
 800e21c:	f7ff fcae 	bl	800db7c <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
 800e220:	687b      	ldr	r3, [r7, #4]
 800e222:	333c      	adds	r3, #60	@ 0x3c
 800e224:	4921      	ldr	r1, [pc, #132]	@ (800e2ac <sync_fs+0xd8>)
 800e226:	4618      	mov	r0, r3
 800e228:	f7ff fcc3 	bl	800dbb2 <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
 800e22c:	687b      	ldr	r3, [r7, #4]
 800e22e:	333c      	adds	r3, #60	@ 0x3c
 800e230:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800e234:	491e      	ldr	r1, [pc, #120]	@ (800e2b0 <sync_fs+0xdc>)
 800e236:	4618      	mov	r0, r3
 800e238:	f7ff fcbb 	bl	800dbb2 <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 800e23c:	687b      	ldr	r3, [r7, #4]
 800e23e:	333c      	adds	r3, #60	@ 0x3c
 800e240:	f503 72f4 	add.w	r2, r3, #488	@ 0x1e8
 800e244:	687b      	ldr	r3, [r7, #4]
 800e246:	69db      	ldr	r3, [r3, #28]
 800e248:	4619      	mov	r1, r3
 800e24a:	4610      	mov	r0, r2
 800e24c:	f7ff fcb1 	bl	800dbb2 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 800e250:	687b      	ldr	r3, [r7, #4]
 800e252:	333c      	adds	r3, #60	@ 0x3c
 800e254:	f503 72f6 	add.w	r2, r3, #492	@ 0x1ec
 800e258:	687b      	ldr	r3, [r7, #4]
 800e25a:	699b      	ldr	r3, [r3, #24]
 800e25c:	4619      	mov	r1, r3
 800e25e:	4610      	mov	r0, r2
 800e260:	f7ff fca7 	bl	800dbb2 <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
 800e264:	687b      	ldr	r3, [r7, #4]
 800e266:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e268:	1c5a      	adds	r2, r3, #1
 800e26a:	687b      	ldr	r3, [r7, #4]
 800e26c:	639a      	str	r2, [r3, #56]	@ 0x38
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800e26e:	687b      	ldr	r3, [r7, #4]
 800e270:	7858      	ldrb	r0, [r3, #1]
 800e272:	687b      	ldr	r3, [r7, #4]
 800e274:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e278:	687b      	ldr	r3, [r7, #4]
 800e27a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800e27c:	2301      	movs	r3, #1
 800e27e:	f7ff fb29 	bl	800d8d4 <disk_write>
			fs->fsi_flag = 0;
 800e282:	687b      	ldr	r3, [r7, #4]
 800e284:	2200      	movs	r2, #0
 800e286:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800e288:	687b      	ldr	r3, [r7, #4]
 800e28a:	785b      	ldrb	r3, [r3, #1]
 800e28c:	2200      	movs	r2, #0
 800e28e:	2100      	movs	r1, #0
 800e290:	4618      	mov	r0, r3
 800e292:	f7ff fb3f 	bl	800d914 <disk_ioctl>
 800e296:	4603      	mov	r3, r0
 800e298:	2b00      	cmp	r3, #0
 800e29a:	d001      	beq.n	800e2a0 <sync_fs+0xcc>
 800e29c:	2301      	movs	r3, #1
 800e29e:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 800e2a0:	7bfb      	ldrb	r3, [r7, #15]
}
 800e2a2:	4618      	mov	r0, r3
 800e2a4:	3710      	adds	r7, #16
 800e2a6:	46bd      	mov	sp, r7
 800e2a8:	bd80      	pop	{r7, pc}
 800e2aa:	bf00      	nop
 800e2ac:	41615252 	.word	0x41615252
 800e2b0:	61417272 	.word	0x61417272

0800e2b4 <clust2sect>:
static
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 800e2b4:	b480      	push	{r7}
 800e2b6:	b083      	sub	sp, #12
 800e2b8:	af00      	add	r7, sp, #0
 800e2ba:	6078      	str	r0, [r7, #4]
 800e2bc:	6039      	str	r1, [r7, #0]
	clst -= 2;
 800e2be:	683b      	ldr	r3, [r7, #0]
 800e2c0:	3b02      	subs	r3, #2
 800e2c2:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e2c4:	687b      	ldr	r3, [r7, #4]
 800e2c6:	6a1b      	ldr	r3, [r3, #32]
 800e2c8:	3b02      	subs	r3, #2
 800e2ca:	683a      	ldr	r2, [r7, #0]
 800e2cc:	429a      	cmp	r2, r3
 800e2ce:	d301      	bcc.n	800e2d4 <clust2sect+0x20>
 800e2d0:	2300      	movs	r3, #0
 800e2d2:	e008      	b.n	800e2e6 <clust2sect+0x32>
	return clst * fs->csize + fs->database;
 800e2d4:	687b      	ldr	r3, [r7, #4]
 800e2d6:	895b      	ldrh	r3, [r3, #10]
 800e2d8:	461a      	mov	r2, r3
 800e2da:	683b      	ldr	r3, [r7, #0]
 800e2dc:	fb03 f202 	mul.w	r2, r3, r2
 800e2e0:	687b      	ldr	r3, [r7, #4]
 800e2e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800e2e4:	4413      	add	r3, r2
}
 800e2e6:	4618      	mov	r0, r3
 800e2e8:	370c      	adds	r7, #12
 800e2ea:	46bd      	mov	sp, r7
 800e2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e2f0:	4770      	bx	lr
	...

0800e2f4 <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	_FDID* obj,	/* Corresponding object */
	DWORD clst	/* Cluster number to get the value */
)
{
 800e2f4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800e2f8:	b088      	sub	sp, #32
 800e2fa:	af00      	add	r7, sp, #0
 800e2fc:	6078      	str	r0, [r7, #4]
 800e2fe:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
 800e300:	687b      	ldr	r3, [r7, #4]
 800e302:	681b      	ldr	r3, [r3, #0]
 800e304:	61bb      	str	r3, [r7, #24]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800e306:	683b      	ldr	r3, [r7, #0]
 800e308:	2b01      	cmp	r3, #1
 800e30a:	d904      	bls.n	800e316 <get_fat+0x22>
 800e30c:	69bb      	ldr	r3, [r7, #24]
 800e30e:	6a1b      	ldr	r3, [r3, #32]
 800e310:	683a      	ldr	r2, [r7, #0]
 800e312:	429a      	cmp	r2, r3
 800e314:	d302      	bcc.n	800e31c <get_fat+0x28>
		val = 1;	/* Internal error */
 800e316:	2301      	movs	r3, #1
 800e318:	61fb      	str	r3, [r7, #28]
 800e31a:	e139      	b.n	800e590 <get_fat+0x29c>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800e31c:	f04f 33ff 	mov.w	r3, #4294967295
 800e320:	61fb      	str	r3, [r7, #28]

		switch (fs->fs_type) {
 800e322:	69bb      	ldr	r3, [r7, #24]
 800e324:	781b      	ldrb	r3, [r3, #0]
 800e326:	3b01      	subs	r3, #1
 800e328:	2b03      	cmp	r3, #3
 800e32a:	f200 8125 	bhi.w	800e578 <get_fat+0x284>
 800e32e:	a201      	add	r2, pc, #4	@ (adr r2, 800e334 <get_fat+0x40>)
 800e330:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e334:	0800e345 	.word	0x0800e345
 800e338:	0800e3f1 	.word	0x0800e3f1
 800e33c:	0800e43d 	.word	0x0800e43d
 800e340:	0800e48d 	.word	0x0800e48d
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 800e344:	683b      	ldr	r3, [r7, #0]
 800e346:	60fb      	str	r3, [r7, #12]
 800e348:	68fb      	ldr	r3, [r7, #12]
 800e34a:	085b      	lsrs	r3, r3, #1
 800e34c:	68fa      	ldr	r2, [r7, #12]
 800e34e:	4413      	add	r3, r2
 800e350:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e352:	69bb      	ldr	r3, [r7, #24]
 800e354:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e356:	69bb      	ldr	r3, [r7, #24]
 800e358:	899b      	ldrh	r3, [r3, #12]
 800e35a:	4619      	mov	r1, r3
 800e35c:	68fb      	ldr	r3, [r7, #12]
 800e35e:	fbb3 f3f1 	udiv	r3, r3, r1
 800e362:	4413      	add	r3, r2
 800e364:	4619      	mov	r1, r3
 800e366:	69b8      	ldr	r0, [r7, #24]
 800e368:	f7ff ff06 	bl	800e178 <move_window>
 800e36c:	4603      	mov	r3, r0
 800e36e:	2b00      	cmp	r3, #0
 800e370:	f040 8105 	bne.w	800e57e <get_fat+0x28a>
			wc = fs->win[bc++ % SS(fs)];
 800e374:	68fb      	ldr	r3, [r7, #12]
 800e376:	1c5a      	adds	r2, r3, #1
 800e378:	60fa      	str	r2, [r7, #12]
 800e37a:	69ba      	ldr	r2, [r7, #24]
 800e37c:	8992      	ldrh	r2, [r2, #12]
 800e37e:	fbb3 f1f2 	udiv	r1, r3, r2
 800e382:	fb01 f202 	mul.w	r2, r1, r2
 800e386:	1a9b      	subs	r3, r3, r2
 800e388:	69ba      	ldr	r2, [r7, #24]
 800e38a:	4413      	add	r3, r2
 800e38c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800e390:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e392:	69bb      	ldr	r3, [r7, #24]
 800e394:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e396:	69bb      	ldr	r3, [r7, #24]
 800e398:	899b      	ldrh	r3, [r3, #12]
 800e39a:	4619      	mov	r1, r3
 800e39c:	68fb      	ldr	r3, [r7, #12]
 800e39e:	fbb3 f3f1 	udiv	r3, r3, r1
 800e3a2:	4413      	add	r3, r2
 800e3a4:	4619      	mov	r1, r3
 800e3a6:	69b8      	ldr	r0, [r7, #24]
 800e3a8:	f7ff fee6 	bl	800e178 <move_window>
 800e3ac:	4603      	mov	r3, r0
 800e3ae:	2b00      	cmp	r3, #0
 800e3b0:	f040 80e7 	bne.w	800e582 <get_fat+0x28e>
			wc |= fs->win[bc % SS(fs)] << 8;
 800e3b4:	69bb      	ldr	r3, [r7, #24]
 800e3b6:	899b      	ldrh	r3, [r3, #12]
 800e3b8:	461a      	mov	r2, r3
 800e3ba:	68fb      	ldr	r3, [r7, #12]
 800e3bc:	fbb3 f1f2 	udiv	r1, r3, r2
 800e3c0:	fb01 f202 	mul.w	r2, r1, r2
 800e3c4:	1a9b      	subs	r3, r3, r2
 800e3c6:	69ba      	ldr	r2, [r7, #24]
 800e3c8:	4413      	add	r3, r2
 800e3ca:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800e3ce:	021b      	lsls	r3, r3, #8
 800e3d0:	68ba      	ldr	r2, [r7, #8]
 800e3d2:	4313      	orrs	r3, r2
 800e3d4:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800e3d6:	683b      	ldr	r3, [r7, #0]
 800e3d8:	f003 0301 	and.w	r3, r3, #1
 800e3dc:	2b00      	cmp	r3, #0
 800e3de:	d002      	beq.n	800e3e6 <get_fat+0xf2>
 800e3e0:	68bb      	ldr	r3, [r7, #8]
 800e3e2:	091b      	lsrs	r3, r3, #4
 800e3e4:	e002      	b.n	800e3ec <get_fat+0xf8>
 800e3e6:	68bb      	ldr	r3, [r7, #8]
 800e3e8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e3ec:	61fb      	str	r3, [r7, #28]
			break;
 800e3ee:	e0cf      	b.n	800e590 <get_fat+0x29c>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e3f0:	69bb      	ldr	r3, [r7, #24]
 800e3f2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e3f4:	69bb      	ldr	r3, [r7, #24]
 800e3f6:	899b      	ldrh	r3, [r3, #12]
 800e3f8:	085b      	lsrs	r3, r3, #1
 800e3fa:	b29b      	uxth	r3, r3
 800e3fc:	4619      	mov	r1, r3
 800e3fe:	683b      	ldr	r3, [r7, #0]
 800e400:	fbb3 f3f1 	udiv	r3, r3, r1
 800e404:	4413      	add	r3, r2
 800e406:	4619      	mov	r1, r3
 800e408:	69b8      	ldr	r0, [r7, #24]
 800e40a:	f7ff feb5 	bl	800e178 <move_window>
 800e40e:	4603      	mov	r3, r0
 800e410:	2b00      	cmp	r3, #0
 800e412:	f040 80b8 	bne.w	800e586 <get_fat+0x292>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e416:	69bb      	ldr	r3, [r7, #24]
 800e418:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e41c:	683b      	ldr	r3, [r7, #0]
 800e41e:	005b      	lsls	r3, r3, #1
 800e420:	69ba      	ldr	r2, [r7, #24]
 800e422:	8992      	ldrh	r2, [r2, #12]
 800e424:	fbb3 f0f2 	udiv	r0, r3, r2
 800e428:	fb00 f202 	mul.w	r2, r0, r2
 800e42c:	1a9b      	subs	r3, r3, r2
 800e42e:	440b      	add	r3, r1
 800e430:	4618      	mov	r0, r3
 800e432:	f7ff fa8d 	bl	800d950 <ld_word>
 800e436:	4603      	mov	r3, r0
 800e438:	61fb      	str	r3, [r7, #28]
			break;
 800e43a:	e0a9      	b.n	800e590 <get_fat+0x29c>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e43c:	69bb      	ldr	r3, [r7, #24]
 800e43e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e440:	69bb      	ldr	r3, [r7, #24]
 800e442:	899b      	ldrh	r3, [r3, #12]
 800e444:	089b      	lsrs	r3, r3, #2
 800e446:	b29b      	uxth	r3, r3
 800e448:	4619      	mov	r1, r3
 800e44a:	683b      	ldr	r3, [r7, #0]
 800e44c:	fbb3 f3f1 	udiv	r3, r3, r1
 800e450:	4413      	add	r3, r2
 800e452:	4619      	mov	r1, r3
 800e454:	69b8      	ldr	r0, [r7, #24]
 800e456:	f7ff fe8f 	bl	800e178 <move_window>
 800e45a:	4603      	mov	r3, r0
 800e45c:	2b00      	cmp	r3, #0
 800e45e:	f040 8094 	bne.w	800e58a <get_fat+0x296>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800e462:	69bb      	ldr	r3, [r7, #24]
 800e464:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e468:	683b      	ldr	r3, [r7, #0]
 800e46a:	009b      	lsls	r3, r3, #2
 800e46c:	69ba      	ldr	r2, [r7, #24]
 800e46e:	8992      	ldrh	r2, [r2, #12]
 800e470:	fbb3 f0f2 	udiv	r0, r3, r2
 800e474:	fb00 f202 	mul.w	r2, r0, r2
 800e478:	1a9b      	subs	r3, r3, r2
 800e47a:	440b      	add	r3, r1
 800e47c:	4618      	mov	r0, r3
 800e47e:	f7ff fa7f 	bl	800d980 <ld_dword>
 800e482:	4603      	mov	r3, r0
 800e484:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 800e488:	61fb      	str	r3, [r7, #28]
			break;
 800e48a:	e081      	b.n	800e590 <get_fat+0x29c>
#if _FS_EXFAT
		case FS_EXFAT :
			if (obj->objsize) {
 800e48c:	687b      	ldr	r3, [r7, #4]
 800e48e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800e492:	4313      	orrs	r3, r2
 800e494:	d070      	beq.n	800e578 <get_fat+0x284>
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	689b      	ldr	r3, [r3, #8]
 800e49a:	683a      	ldr	r2, [r7, #0]
 800e49c:	1ad3      	subs	r3, r2, r3
 800e49e:	617b      	str	r3, [r7, #20]
				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 800e4a0:	687b      	ldr	r3, [r7, #4]
 800e4a2:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800e4a6:	1e54      	subs	r4, r2, #1
 800e4a8:	f143 35ff 	adc.w	r5, r3, #4294967295
 800e4ac:	69bb      	ldr	r3, [r7, #24]
 800e4ae:	899b      	ldrh	r3, [r3, #12]
 800e4b0:	b29b      	uxth	r3, r3
 800e4b2:	2200      	movs	r2, #0
 800e4b4:	4698      	mov	r8, r3
 800e4b6:	4691      	mov	r9, r2
 800e4b8:	4642      	mov	r2, r8
 800e4ba:	464b      	mov	r3, r9
 800e4bc:	4620      	mov	r0, r4
 800e4be:	4629      	mov	r1, r5
 800e4c0:	f7f2 faf4 	bl	8000aac <__aeabi_uldivmod>
 800e4c4:	4602      	mov	r2, r0
 800e4c6:	460b      	mov	r3, r1
 800e4c8:	69bb      	ldr	r3, [r7, #24]
 800e4ca:	895b      	ldrh	r3, [r3, #10]
 800e4cc:	fbb2 f3f3 	udiv	r3, r2, r3
 800e4d0:	613b      	str	r3, [r7, #16]

				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
 800e4d2:	687b      	ldr	r3, [r7, #4]
 800e4d4:	79db      	ldrb	r3, [r3, #7]
 800e4d6:	2b02      	cmp	r3, #2
 800e4d8:	d10e      	bne.n	800e4f8 <get_fat+0x204>
					if (cofs <= clen) {
 800e4da:	697a      	ldr	r2, [r7, #20]
 800e4dc:	693b      	ldr	r3, [r7, #16]
 800e4de:	429a      	cmp	r2, r3
 800e4e0:	d80a      	bhi.n	800e4f8 <get_fat+0x204>
						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
 800e4e2:	697a      	ldr	r2, [r7, #20]
 800e4e4:	693b      	ldr	r3, [r7, #16]
 800e4e6:	429a      	cmp	r2, r3
 800e4e8:	d002      	beq.n	800e4f0 <get_fat+0x1fc>
 800e4ea:	683b      	ldr	r3, [r7, #0]
 800e4ec:	3301      	adds	r3, #1
 800e4ee:	e001      	b.n	800e4f4 <get_fat+0x200>
 800e4f0:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 800e4f4:	61fb      	str	r3, [r7, #28]
						break;
 800e4f6:	e04b      	b.n	800e590 <get_fat+0x29c>
					}
				}
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 800e4f8:	687b      	ldr	r3, [r7, #4]
 800e4fa:	79db      	ldrb	r3, [r3, #7]
 800e4fc:	2b03      	cmp	r3, #3
 800e4fe:	d108      	bne.n	800e512 <get_fat+0x21e>
 800e500:	687b      	ldr	r3, [r7, #4]
 800e502:	699b      	ldr	r3, [r3, #24]
 800e504:	697a      	ldr	r2, [r7, #20]
 800e506:	429a      	cmp	r2, r3
 800e508:	d203      	bcs.n	800e512 <get_fat+0x21e>
					val = clst + 1; 	/* Generate the value */
 800e50a:	683b      	ldr	r3, [r7, #0]
 800e50c:	3301      	adds	r3, #1
 800e50e:	61fb      	str	r3, [r7, #28]
					break;
 800e510:	e03e      	b.n	800e590 <get_fat+0x29c>
				}
				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
 800e512:	687b      	ldr	r3, [r7, #4]
 800e514:	79db      	ldrb	r3, [r3, #7]
 800e516:	2b02      	cmp	r3, #2
 800e518:	d02e      	beq.n	800e578 <get_fat+0x284>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 800e51a:	687b      	ldr	r3, [r7, #4]
 800e51c:	69db      	ldr	r3, [r3, #28]
 800e51e:	2b00      	cmp	r3, #0
 800e520:	d003      	beq.n	800e52a <get_fat+0x236>
						val = 0x7FFFFFFF;	/* Generate EOC */
 800e522:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 800e526:	61fb      	str	r3, [r7, #28]
					} else {
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
					}
					break;
 800e528:	e032      	b.n	800e590 <get_fat+0x29c>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e52a:	69bb      	ldr	r3, [r7, #24]
 800e52c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e52e:	69bb      	ldr	r3, [r7, #24]
 800e530:	899b      	ldrh	r3, [r3, #12]
 800e532:	089b      	lsrs	r3, r3, #2
 800e534:	b29b      	uxth	r3, r3
 800e536:	4619      	mov	r1, r3
 800e538:	683b      	ldr	r3, [r7, #0]
 800e53a:	fbb3 f3f1 	udiv	r3, r3, r1
 800e53e:	4413      	add	r3, r2
 800e540:	4619      	mov	r1, r3
 800e542:	69b8      	ldr	r0, [r7, #24]
 800e544:	f7ff fe18 	bl	800e178 <move_window>
 800e548:	4603      	mov	r3, r0
 800e54a:	2b00      	cmp	r3, #0
 800e54c:	d11f      	bne.n	800e58e <get_fat+0x29a>
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 800e54e:	69bb      	ldr	r3, [r7, #24]
 800e550:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e554:	683b      	ldr	r3, [r7, #0]
 800e556:	009b      	lsls	r3, r3, #2
 800e558:	69ba      	ldr	r2, [r7, #24]
 800e55a:	8992      	ldrh	r2, [r2, #12]
 800e55c:	fbb3 f0f2 	udiv	r0, r3, r2
 800e560:	fb00 f202 	mul.w	r2, r0, r2
 800e564:	1a9b      	subs	r3, r3, r2
 800e566:	440b      	add	r3, r1
 800e568:	4618      	mov	r0, r3
 800e56a:	f7ff fa09 	bl	800d980 <ld_dword>
 800e56e:	4603      	mov	r3, r0
 800e570:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800e574:	61fb      	str	r3, [r7, #28]
					break;
 800e576:	e00b      	b.n	800e590 <get_fat+0x29c>
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
 800e578:	2301      	movs	r3, #1
 800e57a:	61fb      	str	r3, [r7, #28]
 800e57c:	e008      	b.n	800e590 <get_fat+0x29c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e57e:	bf00      	nop
 800e580:	e006      	b.n	800e590 <get_fat+0x29c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e582:	bf00      	nop
 800e584:	e004      	b.n	800e590 <get_fat+0x29c>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e586:	bf00      	nop
 800e588:	e002      	b.n	800e590 <get_fat+0x29c>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e58a:	bf00      	nop
 800e58c:	e000      	b.n	800e590 <get_fat+0x29c>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e58e:	bf00      	nop
		}
	}

	return val;
 800e590:	69fb      	ldr	r3, [r7, #28]
}
 800e592:	4618      	mov	r0, r3
 800e594:	3720      	adds	r7, #32
 800e596:	46bd      	mov	sp, r7
 800e598:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800e59c <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding file system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 800e59c:	b590      	push	{r4, r7, lr}
 800e59e:	b089      	sub	sp, #36	@ 0x24
 800e5a0:	af00      	add	r7, sp, #0
 800e5a2:	60f8      	str	r0, [r7, #12]
 800e5a4:	60b9      	str	r1, [r7, #8]
 800e5a6:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
 800e5a8:	2302      	movs	r3, #2
 800e5aa:	77fb      	strb	r3, [r7, #31]

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800e5ac:	68bb      	ldr	r3, [r7, #8]
 800e5ae:	2b01      	cmp	r3, #1
 800e5b0:	f240 810d 	bls.w	800e7ce <put_fat+0x232>
 800e5b4:	68fb      	ldr	r3, [r7, #12]
 800e5b6:	6a1b      	ldr	r3, [r3, #32]
 800e5b8:	68ba      	ldr	r2, [r7, #8]
 800e5ba:	429a      	cmp	r2, r3
 800e5bc:	f080 8107 	bcs.w	800e7ce <put_fat+0x232>
		switch (fs->fs_type) {
 800e5c0:	68fb      	ldr	r3, [r7, #12]
 800e5c2:	781b      	ldrb	r3, [r3, #0]
 800e5c4:	2b04      	cmp	r3, #4
 800e5c6:	f300 8102 	bgt.w	800e7ce <put_fat+0x232>
 800e5ca:	2b03      	cmp	r3, #3
 800e5cc:	f280 80b3 	bge.w	800e736 <put_fat+0x19a>
 800e5d0:	2b01      	cmp	r3, #1
 800e5d2:	d003      	beq.n	800e5dc <put_fat+0x40>
 800e5d4:	2b02      	cmp	r3, #2
 800e5d6:	f000 8083 	beq.w	800e6e0 <put_fat+0x144>
 800e5da:	e0f8      	b.n	800e7ce <put_fat+0x232>
		case FS_FAT12 :	/* Bitfield items */
			bc = (UINT)clst; bc += bc / 2;
 800e5dc:	68bb      	ldr	r3, [r7, #8]
 800e5de:	61bb      	str	r3, [r7, #24]
 800e5e0:	69bb      	ldr	r3, [r7, #24]
 800e5e2:	085b      	lsrs	r3, r3, #1
 800e5e4:	69ba      	ldr	r2, [r7, #24]
 800e5e6:	4413      	add	r3, r2
 800e5e8:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800e5ea:	68fb      	ldr	r3, [r7, #12]
 800e5ec:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e5ee:	68fb      	ldr	r3, [r7, #12]
 800e5f0:	899b      	ldrh	r3, [r3, #12]
 800e5f2:	4619      	mov	r1, r3
 800e5f4:	69bb      	ldr	r3, [r7, #24]
 800e5f6:	fbb3 f3f1 	udiv	r3, r3, r1
 800e5fa:	4413      	add	r3, r2
 800e5fc:	4619      	mov	r1, r3
 800e5fe:	68f8      	ldr	r0, [r7, #12]
 800e600:	f7ff fdba 	bl	800e178 <move_window>
 800e604:	4603      	mov	r3, r0
 800e606:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e608:	7ffb      	ldrb	r3, [r7, #31]
 800e60a:	2b00      	cmp	r3, #0
 800e60c:	f040 80d8 	bne.w	800e7c0 <put_fat+0x224>
			p = fs->win + bc++ % SS(fs);
 800e610:	68fb      	ldr	r3, [r7, #12]
 800e612:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e616:	69bb      	ldr	r3, [r7, #24]
 800e618:	1c5a      	adds	r2, r3, #1
 800e61a:	61ba      	str	r2, [r7, #24]
 800e61c:	68fa      	ldr	r2, [r7, #12]
 800e61e:	8992      	ldrh	r2, [r2, #12]
 800e620:	fbb3 f0f2 	udiv	r0, r3, r2
 800e624:	fb00 f202 	mul.w	r2, r0, r2
 800e628:	1a9b      	subs	r3, r3, r2
 800e62a:	440b      	add	r3, r1
 800e62c:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800e62e:	68bb      	ldr	r3, [r7, #8]
 800e630:	f003 0301 	and.w	r3, r3, #1
 800e634:	2b00      	cmp	r3, #0
 800e636:	d00d      	beq.n	800e654 <put_fat+0xb8>
 800e638:	697b      	ldr	r3, [r7, #20]
 800e63a:	781b      	ldrb	r3, [r3, #0]
 800e63c:	b25b      	sxtb	r3, r3
 800e63e:	f003 030f 	and.w	r3, r3, #15
 800e642:	b25a      	sxtb	r2, r3
 800e644:	687b      	ldr	r3, [r7, #4]
 800e646:	b2db      	uxtb	r3, r3
 800e648:	011b      	lsls	r3, r3, #4
 800e64a:	b25b      	sxtb	r3, r3
 800e64c:	4313      	orrs	r3, r2
 800e64e:	b25b      	sxtb	r3, r3
 800e650:	b2db      	uxtb	r3, r3
 800e652:	e001      	b.n	800e658 <put_fat+0xbc>
 800e654:	687b      	ldr	r3, [r7, #4]
 800e656:	b2db      	uxtb	r3, r3
 800e658:	697a      	ldr	r2, [r7, #20]
 800e65a:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 800e65c:	68fb      	ldr	r3, [r7, #12]
 800e65e:	2201      	movs	r2, #1
 800e660:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800e662:	68fb      	ldr	r3, [r7, #12]
 800e664:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e666:	68fb      	ldr	r3, [r7, #12]
 800e668:	899b      	ldrh	r3, [r3, #12]
 800e66a:	4619      	mov	r1, r3
 800e66c:	69bb      	ldr	r3, [r7, #24]
 800e66e:	fbb3 f3f1 	udiv	r3, r3, r1
 800e672:	4413      	add	r3, r2
 800e674:	4619      	mov	r1, r3
 800e676:	68f8      	ldr	r0, [r7, #12]
 800e678:	f7ff fd7e 	bl	800e178 <move_window>
 800e67c:	4603      	mov	r3, r0
 800e67e:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e680:	7ffb      	ldrb	r3, [r7, #31]
 800e682:	2b00      	cmp	r3, #0
 800e684:	f040 809e 	bne.w	800e7c4 <put_fat+0x228>
			p = fs->win + bc % SS(fs);
 800e688:	68fb      	ldr	r3, [r7, #12]
 800e68a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e68e:	68fb      	ldr	r3, [r7, #12]
 800e690:	899b      	ldrh	r3, [r3, #12]
 800e692:	461a      	mov	r2, r3
 800e694:	69bb      	ldr	r3, [r7, #24]
 800e696:	fbb3 f0f2 	udiv	r0, r3, r2
 800e69a:	fb00 f202 	mul.w	r2, r0, r2
 800e69e:	1a9b      	subs	r3, r3, r2
 800e6a0:	440b      	add	r3, r1
 800e6a2:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800e6a4:	68bb      	ldr	r3, [r7, #8]
 800e6a6:	f003 0301 	and.w	r3, r3, #1
 800e6aa:	2b00      	cmp	r3, #0
 800e6ac:	d003      	beq.n	800e6b6 <put_fat+0x11a>
 800e6ae:	687b      	ldr	r3, [r7, #4]
 800e6b0:	091b      	lsrs	r3, r3, #4
 800e6b2:	b2db      	uxtb	r3, r3
 800e6b4:	e00e      	b.n	800e6d4 <put_fat+0x138>
 800e6b6:	697b      	ldr	r3, [r7, #20]
 800e6b8:	781b      	ldrb	r3, [r3, #0]
 800e6ba:	b25b      	sxtb	r3, r3
 800e6bc:	f023 030f 	bic.w	r3, r3, #15
 800e6c0:	b25a      	sxtb	r2, r3
 800e6c2:	687b      	ldr	r3, [r7, #4]
 800e6c4:	0a1b      	lsrs	r3, r3, #8
 800e6c6:	b25b      	sxtb	r3, r3
 800e6c8:	f003 030f 	and.w	r3, r3, #15
 800e6cc:	b25b      	sxtb	r3, r3
 800e6ce:	4313      	orrs	r3, r2
 800e6d0:	b25b      	sxtb	r3, r3
 800e6d2:	b2db      	uxtb	r3, r3
 800e6d4:	697a      	ldr	r2, [r7, #20]
 800e6d6:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 800e6d8:	68fb      	ldr	r3, [r7, #12]
 800e6da:	2201      	movs	r2, #1
 800e6dc:	70da      	strb	r2, [r3, #3]
			break;
 800e6de:	e076      	b.n	800e7ce <put_fat+0x232>

		case FS_FAT16 :	/* WORD aligned items */
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800e6e0:	68fb      	ldr	r3, [r7, #12]
 800e6e2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e6e4:	68fb      	ldr	r3, [r7, #12]
 800e6e6:	899b      	ldrh	r3, [r3, #12]
 800e6e8:	085b      	lsrs	r3, r3, #1
 800e6ea:	b29b      	uxth	r3, r3
 800e6ec:	4619      	mov	r1, r3
 800e6ee:	68bb      	ldr	r3, [r7, #8]
 800e6f0:	fbb3 f3f1 	udiv	r3, r3, r1
 800e6f4:	4413      	add	r3, r2
 800e6f6:	4619      	mov	r1, r3
 800e6f8:	68f8      	ldr	r0, [r7, #12]
 800e6fa:	f7ff fd3d 	bl	800e178 <move_window>
 800e6fe:	4603      	mov	r3, r0
 800e700:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e702:	7ffb      	ldrb	r3, [r7, #31]
 800e704:	2b00      	cmp	r3, #0
 800e706:	d15f      	bne.n	800e7c8 <put_fat+0x22c>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 800e708:	68fb      	ldr	r3, [r7, #12]
 800e70a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e70e:	68bb      	ldr	r3, [r7, #8]
 800e710:	005b      	lsls	r3, r3, #1
 800e712:	68fa      	ldr	r2, [r7, #12]
 800e714:	8992      	ldrh	r2, [r2, #12]
 800e716:	fbb3 f0f2 	udiv	r0, r3, r2
 800e71a:	fb00 f202 	mul.w	r2, r0, r2
 800e71e:	1a9b      	subs	r3, r3, r2
 800e720:	440b      	add	r3, r1
 800e722:	687a      	ldr	r2, [r7, #4]
 800e724:	b292      	uxth	r2, r2
 800e726:	4611      	mov	r1, r2
 800e728:	4618      	mov	r0, r3
 800e72a:	f7ff fa27 	bl	800db7c <st_word>
			fs->wflag = 1;
 800e72e:	68fb      	ldr	r3, [r7, #12]
 800e730:	2201      	movs	r2, #1
 800e732:	70da      	strb	r2, [r3, #3]
			break;
 800e734:	e04b      	b.n	800e7ce <put_fat+0x232>

		case FS_FAT32 :	/* DWORD aligned items */
#if _FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800e736:	68fb      	ldr	r3, [r7, #12]
 800e738:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e73a:	68fb      	ldr	r3, [r7, #12]
 800e73c:	899b      	ldrh	r3, [r3, #12]
 800e73e:	089b      	lsrs	r3, r3, #2
 800e740:	b29b      	uxth	r3, r3
 800e742:	4619      	mov	r1, r3
 800e744:	68bb      	ldr	r3, [r7, #8]
 800e746:	fbb3 f3f1 	udiv	r3, r3, r1
 800e74a:	4413      	add	r3, r2
 800e74c:	4619      	mov	r1, r3
 800e74e:	68f8      	ldr	r0, [r7, #12]
 800e750:	f7ff fd12 	bl	800e178 <move_window>
 800e754:	4603      	mov	r3, r0
 800e756:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800e758:	7ffb      	ldrb	r3, [r7, #31]
 800e75a:	2b00      	cmp	r3, #0
 800e75c:	d136      	bne.n	800e7cc <put_fat+0x230>
			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 800e75e:	68fb      	ldr	r3, [r7, #12]
 800e760:	781b      	ldrb	r3, [r3, #0]
 800e762:	2b04      	cmp	r3, #4
 800e764:	d017      	beq.n	800e796 <put_fat+0x1fa>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800e766:	687b      	ldr	r3, [r7, #4]
 800e768:	f023 4470 	bic.w	r4, r3, #4026531840	@ 0xf0000000
 800e76c:	68fb      	ldr	r3, [r7, #12]
 800e76e:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e772:	68bb      	ldr	r3, [r7, #8]
 800e774:	009b      	lsls	r3, r3, #2
 800e776:	68fa      	ldr	r2, [r7, #12]
 800e778:	8992      	ldrh	r2, [r2, #12]
 800e77a:	fbb3 f0f2 	udiv	r0, r3, r2
 800e77e:	fb00 f202 	mul.w	r2, r0, r2
 800e782:	1a9b      	subs	r3, r3, r2
 800e784:	440b      	add	r3, r1
 800e786:	4618      	mov	r0, r3
 800e788:	f7ff f8fa 	bl	800d980 <ld_dword>
 800e78c:	4603      	mov	r3, r0
 800e78e:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 800e792:	4323      	orrs	r3, r4
 800e794:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
 800e796:	68fb      	ldr	r3, [r7, #12]
 800e798:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800e79c:	68bb      	ldr	r3, [r7, #8]
 800e79e:	009b      	lsls	r3, r3, #2
 800e7a0:	68fa      	ldr	r2, [r7, #12]
 800e7a2:	8992      	ldrh	r2, [r2, #12]
 800e7a4:	fbb3 f0f2 	udiv	r0, r3, r2
 800e7a8:	fb00 f202 	mul.w	r2, r0, r2
 800e7ac:	1a9b      	subs	r3, r3, r2
 800e7ae:	440b      	add	r3, r1
 800e7b0:	6879      	ldr	r1, [r7, #4]
 800e7b2:	4618      	mov	r0, r3
 800e7b4:	f7ff f9fd 	bl	800dbb2 <st_dword>
			fs->wflag = 1;
 800e7b8:	68fb      	ldr	r3, [r7, #12]
 800e7ba:	2201      	movs	r2, #1
 800e7bc:	70da      	strb	r2, [r3, #3]
			break;
 800e7be:	e006      	b.n	800e7ce <put_fat+0x232>
			if (res != FR_OK) break;
 800e7c0:	bf00      	nop
 800e7c2:	e004      	b.n	800e7ce <put_fat+0x232>
			if (res != FR_OK) break;
 800e7c4:	bf00      	nop
 800e7c6:	e002      	b.n	800e7ce <put_fat+0x232>
			if (res != FR_OK) break;
 800e7c8:	bf00      	nop
 800e7ca:	e000      	b.n	800e7ce <put_fat+0x232>
			if (res != FR_OK) break;
 800e7cc:	bf00      	nop
		}
	}
	return res;
 800e7ce:	7ffb      	ldrb	r3, [r7, #31]
}
 800e7d0:	4618      	mov	r0, r3
 800e7d2:	3724      	adds	r7, #36	@ 0x24
 800e7d4:	46bd      	mov	sp, r7
 800e7d6:	bd90      	pop	{r4, r7, pc}

0800e7d8 <find_bitmap>:
DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
	FATFS* fs,	/* File system object */
	DWORD clst,	/* Cluster number to scan from */
	DWORD ncl	/* Number of contiguous clusters to find (1..) */
)
{
 800e7d8:	b580      	push	{r7, lr}
 800e7da:	b08a      	sub	sp, #40	@ 0x28
 800e7dc:	af00      	add	r7, sp, #0
 800e7de:	60f8      	str	r0, [r7, #12]
 800e7e0:	60b9      	str	r1, [r7, #8]
 800e7e2:	607a      	str	r2, [r7, #4]
	BYTE bm, bv;
	UINT i;
	DWORD val, scl, ctr;


	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
 800e7e4:	68bb      	ldr	r3, [r7, #8]
 800e7e6:	3b02      	subs	r3, #2
 800e7e8:	60bb      	str	r3, [r7, #8]
	if (clst >= fs->n_fatent - 2) clst = 0;
 800e7ea:	68fb      	ldr	r3, [r7, #12]
 800e7ec:	6a1b      	ldr	r3, [r3, #32]
 800e7ee:	3b02      	subs	r3, #2
 800e7f0:	68ba      	ldr	r2, [r7, #8]
 800e7f2:	429a      	cmp	r2, r3
 800e7f4:	d301      	bcc.n	800e7fa <find_bitmap+0x22>
 800e7f6:	2300      	movs	r3, #0
 800e7f8:	60bb      	str	r3, [r7, #8]
	scl = val = clst; ctr = 0;
 800e7fa:	68bb      	ldr	r3, [r7, #8]
 800e7fc:	61fb      	str	r3, [r7, #28]
 800e7fe:	69fb      	ldr	r3, [r7, #28]
 800e800:	61bb      	str	r3, [r7, #24]
 800e802:	2300      	movs	r3, #0
 800e804:	617b      	str	r3, [r7, #20]
	for (;;) {
		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
 800e806:	68fb      	ldr	r3, [r7, #12]
 800e808:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e80a:	69fb      	ldr	r3, [r7, #28]
 800e80c:	08db      	lsrs	r3, r3, #3
 800e80e:	68f9      	ldr	r1, [r7, #12]
 800e810:	8989      	ldrh	r1, [r1, #12]
 800e812:	fbb3 f3f1 	udiv	r3, r3, r1
 800e816:	4413      	add	r3, r2
 800e818:	4619      	mov	r1, r3
 800e81a:	68f8      	ldr	r0, [r7, #12]
 800e81c:	f7ff fcac 	bl	800e178 <move_window>
 800e820:	4603      	mov	r3, r0
 800e822:	2b00      	cmp	r3, #0
 800e824:	d002      	beq.n	800e82c <find_bitmap+0x54>
 800e826:	f04f 33ff 	mov.w	r3, #4294967295
 800e82a:	e058      	b.n	800e8de <find_bitmap+0x106>
		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 800e82c:	69fb      	ldr	r3, [r7, #28]
 800e82e:	08db      	lsrs	r3, r3, #3
 800e830:	68fa      	ldr	r2, [r7, #12]
 800e832:	8992      	ldrh	r2, [r2, #12]
 800e834:	fbb3 f1f2 	udiv	r1, r3, r2
 800e838:	fb01 f202 	mul.w	r2, r1, r2
 800e83c:	1a9b      	subs	r3, r3, r2
 800e83e:	623b      	str	r3, [r7, #32]
 800e840:	69fb      	ldr	r3, [r7, #28]
 800e842:	f003 0307 	and.w	r3, r3, #7
 800e846:	2201      	movs	r2, #1
 800e848:	fa02 f303 	lsl.w	r3, r2, r3
 800e84c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		do {
			do {
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 800e850:	68fa      	ldr	r2, [r7, #12]
 800e852:	6a3b      	ldr	r3, [r7, #32]
 800e854:	4413      	add	r3, r2
 800e856:	333c      	adds	r3, #60	@ 0x3c
 800e858:	781a      	ldrb	r2, [r3, #0]
 800e85a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800e85e:	4013      	ands	r3, r2
 800e860:	74fb      	strb	r3, [r7, #19]
 800e862:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800e866:	005b      	lsls	r3, r3, #1
 800e868:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 800e86c:	69fb      	ldr	r3, [r7, #28]
 800e86e:	3301      	adds	r3, #1
 800e870:	61fb      	str	r3, [r7, #28]
 800e872:	68fb      	ldr	r3, [r7, #12]
 800e874:	6a1b      	ldr	r3, [r3, #32]
 800e876:	3b02      	subs	r3, #2
 800e878:	69fa      	ldr	r2, [r7, #28]
 800e87a:	429a      	cmp	r2, r3
 800e87c:	d307      	bcc.n	800e88e <find_bitmap+0xb6>
					val = 0; bm = 0; i = SS(fs);
 800e87e:	2300      	movs	r3, #0
 800e880:	61fb      	str	r3, [r7, #28]
 800e882:	2300      	movs	r3, #0
 800e884:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 800e888:	68fb      	ldr	r3, [r7, #12]
 800e88a:	899b      	ldrh	r3, [r3, #12]
 800e88c:	623b      	str	r3, [r7, #32]
				}
				if (!bv) {	/* Is it a free cluster? */
 800e88e:	7cfb      	ldrb	r3, [r7, #19]
 800e890:	2b00      	cmp	r3, #0
 800e892:	d109      	bne.n	800e8a8 <find_bitmap+0xd0>
					if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
 800e894:	697b      	ldr	r3, [r7, #20]
 800e896:	3301      	adds	r3, #1
 800e898:	617b      	str	r3, [r7, #20]
 800e89a:	697a      	ldr	r2, [r7, #20]
 800e89c:	687b      	ldr	r3, [r7, #4]
 800e89e:	429a      	cmp	r2, r3
 800e8a0:	d106      	bne.n	800e8b0 <find_bitmap+0xd8>
 800e8a2:	69bb      	ldr	r3, [r7, #24]
 800e8a4:	3302      	adds	r3, #2
 800e8a6:	e01a      	b.n	800e8de <find_bitmap+0x106>
				} else {
					scl = val; ctr = 0;		/* Encountered a cluster in-use, restart to scan */
 800e8a8:	69fb      	ldr	r3, [r7, #28]
 800e8aa:	61bb      	str	r3, [r7, #24]
 800e8ac:	2300      	movs	r3, #0
 800e8ae:	617b      	str	r3, [r7, #20]
				}
				if (val == clst) return 0;	/* All cluster scanned? */
 800e8b0:	69fa      	ldr	r2, [r7, #28]
 800e8b2:	68bb      	ldr	r3, [r7, #8]
 800e8b4:	429a      	cmp	r2, r3
 800e8b6:	d101      	bne.n	800e8bc <find_bitmap+0xe4>
 800e8b8:	2300      	movs	r3, #0
 800e8ba:	e010      	b.n	800e8de <find_bitmap+0x106>
			} while (bm);
 800e8bc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800e8c0:	2b00      	cmp	r3, #0
 800e8c2:	d1c5      	bne.n	800e850 <find_bitmap+0x78>
			bm = 1;
 800e8c4:	2301      	movs	r3, #1
 800e8c6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		} while (++i < SS(fs));
 800e8ca:	6a3b      	ldr	r3, [r7, #32]
 800e8cc:	3301      	adds	r3, #1
 800e8ce:	623b      	str	r3, [r7, #32]
 800e8d0:	68fb      	ldr	r3, [r7, #12]
 800e8d2:	899b      	ldrh	r3, [r3, #12]
 800e8d4:	461a      	mov	r2, r3
 800e8d6:	6a3b      	ldr	r3, [r7, #32]
 800e8d8:	4293      	cmp	r3, r2
 800e8da:	d3b9      	bcc.n	800e850 <find_bitmap+0x78>
		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
 800e8dc:	e793      	b.n	800e806 <find_bitmap+0x2e>
	}
}
 800e8de:	4618      	mov	r0, r3
 800e8e0:	3728      	adds	r7, #40	@ 0x28
 800e8e2:	46bd      	mov	sp, r7
 800e8e4:	bd80      	pop	{r7, pc}

0800e8e6 <change_bitmap>:
	FATFS* fs,	/* File system object */
	DWORD clst,	/* Cluster number to change from */
	DWORD ncl,	/* Number of clusters to be changed */
	int bv		/* bit value to be set (0 or 1) */
)
{
 800e8e6:	b580      	push	{r7, lr}
 800e8e8:	b088      	sub	sp, #32
 800e8ea:	af00      	add	r7, sp, #0
 800e8ec:	60f8      	str	r0, [r7, #12]
 800e8ee:	60b9      	str	r1, [r7, #8]
 800e8f0:	607a      	str	r2, [r7, #4]
 800e8f2:	603b      	str	r3, [r7, #0]
	BYTE bm;
	UINT i;
	DWORD sect;

	clst -= 2;	/* The first bit corresponds to cluster #2 */
 800e8f4:	68bb      	ldr	r3, [r7, #8]
 800e8f6:	3b02      	subs	r3, #2
 800e8f8:	60bb      	str	r3, [r7, #8]
	sect = fs->database + clst / 8 / SS(fs);	/* Sector address (assuming bitmap is located top of the cluster heap) */
 800e8fa:	68fb      	ldr	r3, [r7, #12]
 800e8fc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e8fe:	68bb      	ldr	r3, [r7, #8]
 800e900:	08db      	lsrs	r3, r3, #3
 800e902:	68f9      	ldr	r1, [r7, #12]
 800e904:	8989      	ldrh	r1, [r1, #12]
 800e906:	fbb3 f3f1 	udiv	r3, r3, r1
 800e90a:	4413      	add	r3, r2
 800e90c:	617b      	str	r3, [r7, #20]
	i = clst / 8 % SS(fs);						/* Byte offset in the sector */
 800e90e:	68bb      	ldr	r3, [r7, #8]
 800e910:	08db      	lsrs	r3, r3, #3
 800e912:	68fa      	ldr	r2, [r7, #12]
 800e914:	8992      	ldrh	r2, [r2, #12]
 800e916:	fbb3 f1f2 	udiv	r1, r3, r2
 800e91a:	fb01 f202 	mul.w	r2, r1, r2
 800e91e:	1a9b      	subs	r3, r3, r2
 800e920:	61bb      	str	r3, [r7, #24]
	bm = 1 << (clst % 8);						/* Bit mask in the byte */
 800e922:	68bb      	ldr	r3, [r7, #8]
 800e924:	f003 0307 	and.w	r3, r3, #7
 800e928:	2201      	movs	r2, #1
 800e92a:	fa02 f303 	lsl.w	r3, r2, r3
 800e92e:	77fb      	strb	r3, [r7, #31]
	for (;;) {
		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 800e930:	697b      	ldr	r3, [r7, #20]
 800e932:	1c5a      	adds	r2, r3, #1
 800e934:	617a      	str	r2, [r7, #20]
 800e936:	4619      	mov	r1, r3
 800e938:	68f8      	ldr	r0, [r7, #12]
 800e93a:	f7ff fc1d 	bl	800e178 <move_window>
 800e93e:	4603      	mov	r3, r0
 800e940:	2b00      	cmp	r3, #0
 800e942:	d001      	beq.n	800e948 <change_bitmap+0x62>
 800e944:	2301      	movs	r3, #1
 800e946:	e03f      	b.n	800e9c8 <change_bitmap+0xe2>
		do {
			do {
				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 800e948:	68fa      	ldr	r2, [r7, #12]
 800e94a:	69bb      	ldr	r3, [r7, #24]
 800e94c:	4413      	add	r3, r2
 800e94e:	333c      	adds	r3, #60	@ 0x3c
 800e950:	781a      	ldrb	r2, [r3, #0]
 800e952:	7ffb      	ldrb	r3, [r7, #31]
 800e954:	4013      	ands	r3, r2
 800e956:	b2db      	uxtb	r3, r3
 800e958:	2b00      	cmp	r3, #0
 800e95a:	bf14      	ite	ne
 800e95c:	2301      	movne	r3, #1
 800e95e:	2300      	moveq	r3, #0
 800e960:	b2db      	uxtb	r3, r3
 800e962:	461a      	mov	r2, r3
 800e964:	683b      	ldr	r3, [r7, #0]
 800e966:	4293      	cmp	r3, r2
 800e968:	d101      	bne.n	800e96e <change_bitmap+0x88>
 800e96a:	2302      	movs	r3, #2
 800e96c:	e02c      	b.n	800e9c8 <change_bitmap+0xe2>
				fs->win[i] ^= bm;	/* Flip the bit */
 800e96e:	68fa      	ldr	r2, [r7, #12]
 800e970:	69bb      	ldr	r3, [r7, #24]
 800e972:	4413      	add	r3, r2
 800e974:	333c      	adds	r3, #60	@ 0x3c
 800e976:	781a      	ldrb	r2, [r3, #0]
 800e978:	7ffb      	ldrb	r3, [r7, #31]
 800e97a:	4053      	eors	r3, r2
 800e97c:	b2d9      	uxtb	r1, r3
 800e97e:	68fa      	ldr	r2, [r7, #12]
 800e980:	69bb      	ldr	r3, [r7, #24]
 800e982:	4413      	add	r3, r2
 800e984:	333c      	adds	r3, #60	@ 0x3c
 800e986:	460a      	mov	r2, r1
 800e988:	701a      	strb	r2, [r3, #0]
				fs->wflag = 1;
 800e98a:	68fb      	ldr	r3, [r7, #12]
 800e98c:	2201      	movs	r2, #1
 800e98e:	70da      	strb	r2, [r3, #3]
				if (--ncl == 0) return FR_OK;	/* All bits processed? */
 800e990:	687b      	ldr	r3, [r7, #4]
 800e992:	3b01      	subs	r3, #1
 800e994:	607b      	str	r3, [r7, #4]
 800e996:	687b      	ldr	r3, [r7, #4]
 800e998:	2b00      	cmp	r3, #0
 800e99a:	d101      	bne.n	800e9a0 <change_bitmap+0xba>
 800e99c:	2300      	movs	r3, #0
 800e99e:	e013      	b.n	800e9c8 <change_bitmap+0xe2>
			} while (bm <<= 1);		/* Next bit */
 800e9a0:	7ffb      	ldrb	r3, [r7, #31]
 800e9a2:	005b      	lsls	r3, r3, #1
 800e9a4:	77fb      	strb	r3, [r7, #31]
 800e9a6:	7ffb      	ldrb	r3, [r7, #31]
 800e9a8:	2b00      	cmp	r3, #0
 800e9aa:	d1cd      	bne.n	800e948 <change_bitmap+0x62>
			bm = 1;
 800e9ac:	2301      	movs	r3, #1
 800e9ae:	77fb      	strb	r3, [r7, #31]
		} while (++i < SS(fs));		/* Next byte */
 800e9b0:	69bb      	ldr	r3, [r7, #24]
 800e9b2:	3301      	adds	r3, #1
 800e9b4:	61bb      	str	r3, [r7, #24]
 800e9b6:	68fb      	ldr	r3, [r7, #12]
 800e9b8:	899b      	ldrh	r3, [r3, #12]
 800e9ba:	461a      	mov	r2, r3
 800e9bc:	69bb      	ldr	r3, [r7, #24]
 800e9be:	4293      	cmp	r3, r2
 800e9c0:	d3c2      	bcc.n	800e948 <change_bitmap+0x62>
		i = 0;
 800e9c2:	2300      	movs	r3, #0
 800e9c4:	61bb      	str	r3, [r7, #24]
		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 800e9c6:	e7b3      	b.n	800e930 <change_bitmap+0x4a>
	}
}
 800e9c8:	4618      	mov	r0, r3
 800e9ca:	3720      	adds	r7, #32
 800e9cc:	46bd      	mov	sp, r7
 800e9ce:	bd80      	pop	{r7, pc}

0800e9d0 <fill_first_frag>:

static
FRESULT fill_first_frag (
	_FDID* obj	/* Pointer to the corresponding object */
)
{
 800e9d0:	b580      	push	{r7, lr}
 800e9d2:	b086      	sub	sp, #24
 800e9d4:	af00      	add	r7, sp, #0
 800e9d6:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD cl, n;

	if (obj->stat == 3) {	/* Has the object been changed 'fragmented'? */
 800e9d8:	687b      	ldr	r3, [r7, #4]
 800e9da:	79db      	ldrb	r3, [r3, #7]
 800e9dc:	2b03      	cmp	r3, #3
 800e9de:	d121      	bne.n	800ea24 <fill_first_frag+0x54>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 800e9e0:	687b      	ldr	r3, [r7, #4]
 800e9e2:	689b      	ldr	r3, [r3, #8]
 800e9e4:	617b      	str	r3, [r7, #20]
 800e9e6:	687b      	ldr	r3, [r7, #4]
 800e9e8:	699b      	ldr	r3, [r3, #24]
 800e9ea:	613b      	str	r3, [r7, #16]
 800e9ec:	e014      	b.n	800ea18 <fill_first_frag+0x48>
			res = put_fat(obj->fs, cl, cl + 1);
 800e9ee:	687b      	ldr	r3, [r7, #4]
 800e9f0:	6818      	ldr	r0, [r3, #0]
 800e9f2:	697b      	ldr	r3, [r7, #20]
 800e9f4:	3301      	adds	r3, #1
 800e9f6:	461a      	mov	r2, r3
 800e9f8:	6979      	ldr	r1, [r7, #20]
 800e9fa:	f7ff fdcf 	bl	800e59c <put_fat>
 800e9fe:	4603      	mov	r3, r0
 800ea00:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) return res;
 800ea02:	7bfb      	ldrb	r3, [r7, #15]
 800ea04:	2b00      	cmp	r3, #0
 800ea06:	d001      	beq.n	800ea0c <fill_first_frag+0x3c>
 800ea08:	7bfb      	ldrb	r3, [r7, #15]
 800ea0a:	e00c      	b.n	800ea26 <fill_first_frag+0x56>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 800ea0c:	697b      	ldr	r3, [r7, #20]
 800ea0e:	3301      	adds	r3, #1
 800ea10:	617b      	str	r3, [r7, #20]
 800ea12:	693b      	ldr	r3, [r7, #16]
 800ea14:	3b01      	subs	r3, #1
 800ea16:	613b      	str	r3, [r7, #16]
 800ea18:	693b      	ldr	r3, [r7, #16]
 800ea1a:	2b00      	cmp	r3, #0
 800ea1c:	d1e7      	bne.n	800e9ee <fill_first_frag+0x1e>
		}
		obj->stat = 0;	/* Change status 'FAT chain is valid' */
 800ea1e:	687b      	ldr	r3, [r7, #4]
 800ea20:	2200      	movs	r2, #0
 800ea22:	71da      	strb	r2, [r3, #7]
	}
	return FR_OK;
 800ea24:	2300      	movs	r3, #0
}
 800ea26:	4618      	mov	r0, r3
 800ea28:	3718      	adds	r7, #24
 800ea2a:	46bd      	mov	sp, r7
 800ea2c:	bd80      	pop	{r7, pc}

0800ea2e <fill_last_frag>:
FRESULT fill_last_frag (
	_FDID* obj,	/* Pointer to the corresponding object */
	DWORD lcl,	/* Last cluster of the fragment */
	DWORD term	/* Value to set the last FAT entry */
)
{
 800ea2e:	b580      	push	{r7, lr}
 800ea30:	b086      	sub	sp, #24
 800ea32:	af00      	add	r7, sp, #0
 800ea34:	60f8      	str	r0, [r7, #12]
 800ea36:	60b9      	str	r1, [r7, #8]
 800ea38:	607a      	str	r2, [r7, #4]
	FRESULT res;

	while (obj->n_frag > 0) {	/* Create the last chain on the FAT */
 800ea3a:	e020      	b.n	800ea7e <fill_last_frag+0x50>
		res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
 800ea3c:	68fb      	ldr	r3, [r7, #12]
 800ea3e:	6818      	ldr	r0, [r3, #0]
 800ea40:	68fb      	ldr	r3, [r7, #12]
 800ea42:	69db      	ldr	r3, [r3, #28]
 800ea44:	68ba      	ldr	r2, [r7, #8]
 800ea46:	1ad3      	subs	r3, r2, r3
 800ea48:	1c59      	adds	r1, r3, #1
 800ea4a:	68fb      	ldr	r3, [r7, #12]
 800ea4c:	69db      	ldr	r3, [r3, #28]
 800ea4e:	2b01      	cmp	r3, #1
 800ea50:	d905      	bls.n	800ea5e <fill_last_frag+0x30>
 800ea52:	68fb      	ldr	r3, [r7, #12]
 800ea54:	69db      	ldr	r3, [r3, #28]
 800ea56:	68ba      	ldr	r2, [r7, #8]
 800ea58:	1ad3      	subs	r3, r2, r3
 800ea5a:	3302      	adds	r3, #2
 800ea5c:	e000      	b.n	800ea60 <fill_last_frag+0x32>
 800ea5e:	687b      	ldr	r3, [r7, #4]
 800ea60:	461a      	mov	r2, r3
 800ea62:	f7ff fd9b 	bl	800e59c <put_fat>
 800ea66:	4603      	mov	r3, r0
 800ea68:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) return res;
 800ea6a:	7dfb      	ldrb	r3, [r7, #23]
 800ea6c:	2b00      	cmp	r3, #0
 800ea6e:	d001      	beq.n	800ea74 <fill_last_frag+0x46>
 800ea70:	7dfb      	ldrb	r3, [r7, #23]
 800ea72:	e009      	b.n	800ea88 <fill_last_frag+0x5a>
		obj->n_frag--;
 800ea74:	68fb      	ldr	r3, [r7, #12]
 800ea76:	69db      	ldr	r3, [r3, #28]
 800ea78:	1e5a      	subs	r2, r3, #1
 800ea7a:	68fb      	ldr	r3, [r7, #12]
 800ea7c:	61da      	str	r2, [r3, #28]
	while (obj->n_frag > 0) {	/* Create the last chain on the FAT */
 800ea7e:	68fb      	ldr	r3, [r7, #12]
 800ea80:	69db      	ldr	r3, [r3, #28]
 800ea82:	2b00      	cmp	r3, #0
 800ea84:	d1da      	bne.n	800ea3c <fill_last_frag+0xe>
	}
	return FR_OK;
 800ea86:	2300      	movs	r3, #0
}
 800ea88:	4618      	mov	r0, r3
 800ea8a:	3718      	adds	r7, #24
 800ea8c:	46bd      	mov	sp, r7
 800ea8e:	bd80      	pop	{r7, pc}

0800ea90 <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
 800ea90:	b580      	push	{r7, lr}
 800ea92:	b08a      	sub	sp, #40	@ 0x28
 800ea94:	af00      	add	r7, sp, #0
 800ea96:	60f8      	str	r0, [r7, #12]
 800ea98:	60b9      	str	r1, [r7, #8]
 800ea9a:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
 800ea9c:	2300      	movs	r3, #0
 800ea9e:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
 800eaa0:	68fb      	ldr	r3, [r7, #12]
 800eaa2:	681b      	ldr	r3, [r3, #0]
 800eaa4:	61bb      	str	r3, [r7, #24]
#if _FS_EXFAT || _USE_TRIM
	DWORD scl = clst, ecl = clst;
 800eaa6:	68bb      	ldr	r3, [r7, #8]
 800eaa8:	627b      	str	r3, [r7, #36]	@ 0x24
 800eaaa:	68bb      	ldr	r3, [r7, #8]
 800eaac:	623b      	str	r3, [r7, #32]
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800eaae:	68bb      	ldr	r3, [r7, #8]
 800eab0:	2b01      	cmp	r3, #1
 800eab2:	d904      	bls.n	800eabe <remove_chain+0x2e>
 800eab4:	69bb      	ldr	r3, [r7, #24]
 800eab6:	6a1b      	ldr	r3, [r3, #32]
 800eab8:	68ba      	ldr	r2, [r7, #8]
 800eaba:	429a      	cmp	r2, r3
 800eabc:	d301      	bcc.n	800eac2 <remove_chain+0x32>
 800eabe:	2302      	movs	r3, #2
 800eac0:	e096      	b.n	800ebf0 <remove_chain+0x160>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800eac2:	687b      	ldr	r3, [r7, #4]
 800eac4:	2b00      	cmp	r3, #0
 800eac6:	d014      	beq.n	800eaf2 <remove_chain+0x62>
 800eac8:	69bb      	ldr	r3, [r7, #24]
 800eaca:	781b      	ldrb	r3, [r3, #0]
 800eacc:	2b04      	cmp	r3, #4
 800eace:	d103      	bne.n	800ead8 <remove_chain+0x48>
 800ead0:	68fb      	ldr	r3, [r7, #12]
 800ead2:	79db      	ldrb	r3, [r3, #7]
 800ead4:	2b02      	cmp	r3, #2
 800ead6:	d00c      	beq.n	800eaf2 <remove_chain+0x62>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 800ead8:	f04f 32ff 	mov.w	r2, #4294967295
 800eadc:	6879      	ldr	r1, [r7, #4]
 800eade:	69b8      	ldr	r0, [r7, #24]
 800eae0:	f7ff fd5c 	bl	800e59c <put_fat>
 800eae4:	4603      	mov	r3, r0
 800eae6:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
 800eae8:	7ffb      	ldrb	r3, [r7, #31]
 800eaea:	2b00      	cmp	r3, #0
 800eaec:	d001      	beq.n	800eaf2 <remove_chain+0x62>
 800eaee:	7ffb      	ldrb	r3, [r7, #31]
 800eaf0:	e07e      	b.n	800ebf0 <remove_chain+0x160>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800eaf2:	68b9      	ldr	r1, [r7, #8]
 800eaf4:	68f8      	ldr	r0, [r7, #12]
 800eaf6:	f7ff fbfd 	bl	800e2f4 <get_fat>
 800eafa:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
 800eafc:	697b      	ldr	r3, [r7, #20]
 800eafe:	2b00      	cmp	r3, #0
 800eb00:	d055      	beq.n	800ebae <remove_chain+0x11e>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800eb02:	697b      	ldr	r3, [r7, #20]
 800eb04:	2b01      	cmp	r3, #1
 800eb06:	d101      	bne.n	800eb0c <remove_chain+0x7c>
 800eb08:	2302      	movs	r3, #2
 800eb0a:	e071      	b.n	800ebf0 <remove_chain+0x160>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800eb0c:	697b      	ldr	r3, [r7, #20]
 800eb0e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800eb12:	d101      	bne.n	800eb18 <remove_chain+0x88>
 800eb14:	2301      	movs	r3, #1
 800eb16:	e06b      	b.n	800ebf0 <remove_chain+0x160>
		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 800eb18:	69bb      	ldr	r3, [r7, #24]
 800eb1a:	781b      	ldrb	r3, [r3, #0]
 800eb1c:	2b04      	cmp	r3, #4
 800eb1e:	d00b      	beq.n	800eb38 <remove_chain+0xa8>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 800eb20:	2200      	movs	r2, #0
 800eb22:	68b9      	ldr	r1, [r7, #8]
 800eb24:	69b8      	ldr	r0, [r7, #24]
 800eb26:	f7ff fd39 	bl	800e59c <put_fat>
 800eb2a:	4603      	mov	r3, r0
 800eb2c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
 800eb2e:	7ffb      	ldrb	r3, [r7, #31]
 800eb30:	2b00      	cmp	r3, #0
 800eb32:	d001      	beq.n	800eb38 <remove_chain+0xa8>
 800eb34:	7ffb      	ldrb	r3, [r7, #31]
 800eb36:	e05b      	b.n	800ebf0 <remove_chain+0x160>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800eb38:	69bb      	ldr	r3, [r7, #24]
 800eb3a:	69da      	ldr	r2, [r3, #28]
 800eb3c:	69bb      	ldr	r3, [r7, #24]
 800eb3e:	6a1b      	ldr	r3, [r3, #32]
 800eb40:	3b02      	subs	r3, #2
 800eb42:	429a      	cmp	r2, r3
 800eb44:	d20b      	bcs.n	800eb5e <remove_chain+0xce>
			fs->free_clst++;
 800eb46:	69bb      	ldr	r3, [r7, #24]
 800eb48:	69db      	ldr	r3, [r3, #28]
 800eb4a:	1c5a      	adds	r2, r3, #1
 800eb4c:	69bb      	ldr	r3, [r7, #24]
 800eb4e:	61da      	str	r2, [r3, #28]
			fs->fsi_flag |= 1;
 800eb50:	69bb      	ldr	r3, [r7, #24]
 800eb52:	791b      	ldrb	r3, [r3, #4]
 800eb54:	f043 0301 	orr.w	r3, r3, #1
 800eb58:	b2da      	uxtb	r2, r3
 800eb5a:	69bb      	ldr	r3, [r7, #24]
 800eb5c:	711a      	strb	r2, [r3, #4]
		}
#if _FS_EXFAT || _USE_TRIM
		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 800eb5e:	6a3b      	ldr	r3, [r7, #32]
 800eb60:	3301      	adds	r3, #1
 800eb62:	697a      	ldr	r2, [r7, #20]
 800eb64:	429a      	cmp	r2, r3
 800eb66:	d102      	bne.n	800eb6e <remove_chain+0xde>
			ecl = nxt;
 800eb68:	697b      	ldr	r3, [r7, #20]
 800eb6a:	623b      	str	r3, [r7, #32]
 800eb6c:	e017      	b.n	800eb9e <remove_chain+0x10e>
		} else {				/* End of contiguous cluster block */
#if _FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 800eb6e:	69bb      	ldr	r3, [r7, #24]
 800eb70:	781b      	ldrb	r3, [r3, #0]
 800eb72:	2b04      	cmp	r3, #4
 800eb74:	d10f      	bne.n	800eb96 <remove_chain+0x106>
				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
 800eb76:	6a3a      	ldr	r2, [r7, #32]
 800eb78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800eb7a:	1ad3      	subs	r3, r2, r3
 800eb7c:	1c5a      	adds	r2, r3, #1
 800eb7e:	2300      	movs	r3, #0
 800eb80:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800eb82:	69b8      	ldr	r0, [r7, #24]
 800eb84:	f7ff feaf 	bl	800e8e6 <change_bitmap>
 800eb88:	4603      	mov	r3, r0
 800eb8a:	77fb      	strb	r3, [r7, #31]
				if (res != FR_OK) return res;
 800eb8c:	7ffb      	ldrb	r3, [r7, #31]
 800eb8e:	2b00      	cmp	r3, #0
 800eb90:	d001      	beq.n	800eb96 <remove_chain+0x106>
 800eb92:	7ffb      	ldrb	r3, [r7, #31]
 800eb94:	e02c      	b.n	800ebf0 <remove_chain+0x160>
#if _USE_TRIM
			rt[0] = clust2sect(fs, scl);					/* Start sector */
			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
#endif
			scl = ecl = nxt;
 800eb96:	697b      	ldr	r3, [r7, #20]
 800eb98:	623b      	str	r3, [r7, #32]
 800eb9a:	6a3b      	ldr	r3, [r7, #32]
 800eb9c:	627b      	str	r3, [r7, #36]	@ 0x24
		}
#endif
		clst = nxt;					/* Next cluster */
 800eb9e:	697b      	ldr	r3, [r7, #20]
 800eba0:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 800eba2:	69bb      	ldr	r3, [r7, #24]
 800eba4:	6a1b      	ldr	r3, [r3, #32]
 800eba6:	68ba      	ldr	r2, [r7, #8]
 800eba8:	429a      	cmp	r2, r3
 800ebaa:	d3a2      	bcc.n	800eaf2 <remove_chain+0x62>
 800ebac:	e000      	b.n	800ebb0 <remove_chain+0x120>
		if (nxt == 0) break;				/* Empty cluster? */
 800ebae:	bf00      	nop

#if _FS_EXFAT
	if (fs->fs_type == FS_EXFAT) {
 800ebb0:	69bb      	ldr	r3, [r7, #24]
 800ebb2:	781b      	ldrb	r3, [r3, #0]
 800ebb4:	2b04      	cmp	r3, #4
 800ebb6:	d11a      	bne.n	800ebee <remove_chain+0x15e>
		if (pclst == 0) {	/* Does the object have no chain? */
 800ebb8:	687b      	ldr	r3, [r7, #4]
 800ebba:	2b00      	cmp	r3, #0
 800ebbc:	d103      	bne.n	800ebc6 <remove_chain+0x136>
			obj->stat = 0;		/* Change the object status 'initial' */
 800ebbe:	68fb      	ldr	r3, [r7, #12]
 800ebc0:	2200      	movs	r2, #0
 800ebc2:	71da      	strb	r2, [r3, #7]
 800ebc4:	e013      	b.n	800ebee <remove_chain+0x15e>
		} else {
			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain get contiguous? */
 800ebc6:	68fb      	ldr	r3, [r7, #12]
 800ebc8:	79db      	ldrb	r3, [r3, #7]
 800ebca:	2b03      	cmp	r3, #3
 800ebcc:	d10f      	bne.n	800ebee <remove_chain+0x15e>
 800ebce:	68fb      	ldr	r3, [r7, #12]
 800ebd0:	689b      	ldr	r3, [r3, #8]
 800ebd2:	687a      	ldr	r2, [r7, #4]
 800ebd4:	429a      	cmp	r2, r3
 800ebd6:	d30a      	bcc.n	800ebee <remove_chain+0x15e>
 800ebd8:	68fb      	ldr	r3, [r7, #12]
 800ebda:	689a      	ldr	r2, [r3, #8]
 800ebdc:	68fb      	ldr	r3, [r7, #12]
 800ebde:	699b      	ldr	r3, [r3, #24]
 800ebe0:	4413      	add	r3, r2
 800ebe2:	687a      	ldr	r2, [r7, #4]
 800ebe4:	429a      	cmp	r2, r3
 800ebe6:	d802      	bhi.n	800ebee <remove_chain+0x15e>
				obj->stat = 2;	/* Change the object status 'contiguous' */
 800ebe8:	68fb      	ldr	r3, [r7, #12]
 800ebea:	2202      	movs	r2, #2
 800ebec:	71da      	strb	r2, [r3, #7]
			}
		}
	}
#endif
	return FR_OK;
 800ebee:	2300      	movs	r3, #0
}
 800ebf0:	4618      	mov	r0, r3
 800ebf2:	3728      	adds	r7, #40	@ 0x28
 800ebf4:	46bd      	mov	sp, r7
 800ebf6:	bd80      	pop	{r7, pc}

0800ebf8 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	_FDID* obj,			/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 800ebf8:	b580      	push	{r7, lr}
 800ebfa:	b088      	sub	sp, #32
 800ebfc:	af00      	add	r7, sp, #0
 800ebfe:	6078      	str	r0, [r7, #4]
 800ec00:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
 800ec02:	687b      	ldr	r3, [r7, #4]
 800ec04:	681b      	ldr	r3, [r3, #0]
 800ec06:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
 800ec08:	683b      	ldr	r3, [r7, #0]
 800ec0a:	2b00      	cmp	r3, #0
 800ec0c:	d10d      	bne.n	800ec2a <create_chain+0x32>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 800ec0e:	693b      	ldr	r3, [r7, #16]
 800ec10:	699b      	ldr	r3, [r3, #24]
 800ec12:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800ec14:	69bb      	ldr	r3, [r7, #24]
 800ec16:	2b00      	cmp	r3, #0
 800ec18:	d004      	beq.n	800ec24 <create_chain+0x2c>
 800ec1a:	693b      	ldr	r3, [r7, #16]
 800ec1c:	6a1b      	ldr	r3, [r3, #32]
 800ec1e:	69ba      	ldr	r2, [r7, #24]
 800ec20:	429a      	cmp	r2, r3
 800ec22:	d31b      	bcc.n	800ec5c <create_chain+0x64>
 800ec24:	2301      	movs	r3, #1
 800ec26:	61bb      	str	r3, [r7, #24]
 800ec28:	e018      	b.n	800ec5c <create_chain+0x64>
	}
	else {				/* Stretch current chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800ec2a:	6839      	ldr	r1, [r7, #0]
 800ec2c:	6878      	ldr	r0, [r7, #4]
 800ec2e:	f7ff fb61 	bl	800e2f4 <get_fat>
 800ec32:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Invalid FAT value */
 800ec34:	68fb      	ldr	r3, [r7, #12]
 800ec36:	2b01      	cmp	r3, #1
 800ec38:	d801      	bhi.n	800ec3e <create_chain+0x46>
 800ec3a:	2301      	movs	r3, #1
 800ec3c:	e0d9      	b.n	800edf2 <create_chain+0x1fa>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 800ec3e:	68fb      	ldr	r3, [r7, #12]
 800ec40:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ec44:	d101      	bne.n	800ec4a <create_chain+0x52>
 800ec46:	68fb      	ldr	r3, [r7, #12]
 800ec48:	e0d3      	b.n	800edf2 <create_chain+0x1fa>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800ec4a:	693b      	ldr	r3, [r7, #16]
 800ec4c:	6a1b      	ldr	r3, [r3, #32]
 800ec4e:	68fa      	ldr	r2, [r7, #12]
 800ec50:	429a      	cmp	r2, r3
 800ec52:	d201      	bcs.n	800ec58 <create_chain+0x60>
 800ec54:	68fb      	ldr	r3, [r7, #12]
 800ec56:	e0cc      	b.n	800edf2 <create_chain+0x1fa>
		scl = clst;
 800ec58:	683b      	ldr	r3, [r7, #0]
 800ec5a:	61bb      	str	r3, [r7, #24]
	}

#if _FS_EXFAT
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800ec5c:	693b      	ldr	r3, [r7, #16]
 800ec5e:	781b      	ldrb	r3, [r3, #0]
 800ec60:	2b04      	cmp	r3, #4
 800ec62:	d164      	bne.n	800ed2e <create_chain+0x136>
		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
 800ec64:	2201      	movs	r2, #1
 800ec66:	69b9      	ldr	r1, [r7, #24]
 800ec68:	6938      	ldr	r0, [r7, #16]
 800ec6a:	f7ff fdb5 	bl	800e7d8 <find_bitmap>
 800ec6e:	61f8      	str	r0, [r7, #28]
		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
 800ec70:	69fb      	ldr	r3, [r7, #28]
 800ec72:	2b00      	cmp	r3, #0
 800ec74:	d003      	beq.n	800ec7e <create_chain+0x86>
 800ec76:	69fb      	ldr	r3, [r7, #28]
 800ec78:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ec7c:	d101      	bne.n	800ec82 <create_chain+0x8a>
 800ec7e:	69fb      	ldr	r3, [r7, #28]
 800ec80:	e0b7      	b.n	800edf2 <create_chain+0x1fa>
		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
 800ec82:	2301      	movs	r3, #1
 800ec84:	2201      	movs	r2, #1
 800ec86:	69f9      	ldr	r1, [r7, #28]
 800ec88:	6938      	ldr	r0, [r7, #16]
 800ec8a:	f7ff fe2c 	bl	800e8e6 <change_bitmap>
 800ec8e:	4603      	mov	r3, r0
 800ec90:	75fb      	strb	r3, [r7, #23]
		if (res == FR_INT_ERR) return 1;
 800ec92:	7dfb      	ldrb	r3, [r7, #23]
 800ec94:	2b02      	cmp	r3, #2
 800ec96:	d101      	bne.n	800ec9c <create_chain+0xa4>
 800ec98:	2301      	movs	r3, #1
 800ec9a:	e0aa      	b.n	800edf2 <create_chain+0x1fa>
		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
 800ec9c:	7dfb      	ldrb	r3, [r7, #23]
 800ec9e:	2b01      	cmp	r3, #1
 800eca0:	d102      	bne.n	800eca8 <create_chain+0xb0>
 800eca2:	f04f 33ff 	mov.w	r3, #4294967295
 800eca6:	e0a4      	b.n	800edf2 <create_chain+0x1fa>
		if (clst == 0) {							/* Is it a new chain? */
 800eca8:	683b      	ldr	r3, [r7, #0]
 800ecaa:	2b00      	cmp	r3, #0
 800ecac:	d103      	bne.n	800ecb6 <create_chain+0xbe>
			obj->stat = 2;							/* Set status 'contiguous' */
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	2202      	movs	r2, #2
 800ecb2:	71da      	strb	r2, [r3, #7]
 800ecb4:	e011      	b.n	800ecda <create_chain+0xe2>
		} else {									/* It is a stretched chain */
			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 800ecb6:	687b      	ldr	r3, [r7, #4]
 800ecb8:	79db      	ldrb	r3, [r3, #7]
 800ecba:	2b02      	cmp	r3, #2
 800ecbc:	d10d      	bne.n	800ecda <create_chain+0xe2>
 800ecbe:	69bb      	ldr	r3, [r7, #24]
 800ecc0:	3301      	adds	r3, #1
 800ecc2:	69fa      	ldr	r2, [r7, #28]
 800ecc4:	429a      	cmp	r2, r3
 800ecc6:	d008      	beq.n	800ecda <create_chain+0xe2>
				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	689b      	ldr	r3, [r3, #8]
 800eccc:	69ba      	ldr	r2, [r7, #24]
 800ecce:	1ad2      	subs	r2, r2, r3
 800ecd0:	687b      	ldr	r3, [r7, #4]
 800ecd2:	619a      	str	r2, [r3, #24]
				obj->stat = 3;						/* Change status 'just fragmented' */
 800ecd4:	687b      	ldr	r3, [r7, #4]
 800ecd6:	2203      	movs	r2, #3
 800ecd8:	71da      	strb	r2, [r3, #7]
			}
		}
		if (obj->stat != 2) {	/* Is the file non-contiguous? */
 800ecda:	687b      	ldr	r3, [r7, #4]
 800ecdc:	79db      	ldrb	r3, [r3, #7]
 800ecde:	2b02      	cmp	r3, #2
 800ece0:	d064      	beq.n	800edac <create_chain+0x1b4>
			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 800ece2:	683b      	ldr	r3, [r7, #0]
 800ece4:	3301      	adds	r3, #1
 800ece6:	69fa      	ldr	r2, [r7, #28]
 800ece8:	429a      	cmp	r2, r3
 800ecea:	d10b      	bne.n	800ed04 <create_chain+0x10c>
				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 800ecec:	687b      	ldr	r3, [r7, #4]
 800ecee:	69db      	ldr	r3, [r3, #28]
 800ecf0:	2b00      	cmp	r3, #0
 800ecf2:	d003      	beq.n	800ecfc <create_chain+0x104>
 800ecf4:	687b      	ldr	r3, [r7, #4]
 800ecf6:	69db      	ldr	r3, [r3, #28]
 800ecf8:	3301      	adds	r3, #1
 800ecfa:	e000      	b.n	800ecfe <create_chain+0x106>
 800ecfc:	2302      	movs	r3, #2
 800ecfe:	687a      	ldr	r2, [r7, #4]
 800ed00:	61d3      	str	r3, [r2, #28]
 800ed02:	e053      	b.n	800edac <create_chain+0x1b4>
			} else {				/* New fragment */
				if (obj->n_frag == 0) obj->n_frag = 1;
 800ed04:	687b      	ldr	r3, [r7, #4]
 800ed06:	69db      	ldr	r3, [r3, #28]
 800ed08:	2b00      	cmp	r3, #0
 800ed0a:	d102      	bne.n	800ed12 <create_chain+0x11a>
 800ed0c:	687b      	ldr	r3, [r7, #4]
 800ed0e:	2201      	movs	r2, #1
 800ed10:	61da      	str	r2, [r3, #28]
				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
 800ed12:	69fa      	ldr	r2, [r7, #28]
 800ed14:	6839      	ldr	r1, [r7, #0]
 800ed16:	6878      	ldr	r0, [r7, #4]
 800ed18:	f7ff fe89 	bl	800ea2e <fill_last_frag>
 800ed1c:	4603      	mov	r3, r0
 800ed1e:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) obj->n_frag = 1;
 800ed20:	7dfb      	ldrb	r3, [r7, #23]
 800ed22:	2b00      	cmp	r3, #0
 800ed24:	d142      	bne.n	800edac <create_chain+0x1b4>
 800ed26:	687b      	ldr	r3, [r7, #4]
 800ed28:	2201      	movs	r2, #1
 800ed2a:	61da      	str	r2, [r3, #28]
 800ed2c:	e03e      	b.n	800edac <create_chain+0x1b4>
			}
		}
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		ncl = scl;	/* Start cluster */
 800ed2e:	69bb      	ldr	r3, [r7, #24]
 800ed30:	61fb      	str	r3, [r7, #28]
		for (;;) {
			ncl++;							/* Next cluster */
 800ed32:	69fb      	ldr	r3, [r7, #28]
 800ed34:	3301      	adds	r3, #1
 800ed36:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800ed38:	693b      	ldr	r3, [r7, #16]
 800ed3a:	6a1b      	ldr	r3, [r3, #32]
 800ed3c:	69fa      	ldr	r2, [r7, #28]
 800ed3e:	429a      	cmp	r2, r3
 800ed40:	d307      	bcc.n	800ed52 <create_chain+0x15a>
				ncl = 2;
 800ed42:	2302      	movs	r3, #2
 800ed44:	61fb      	str	r3, [r7, #28]
				if (ncl > scl) return 0;	/* No free cluster */
 800ed46:	69fa      	ldr	r2, [r7, #28]
 800ed48:	69bb      	ldr	r3, [r7, #24]
 800ed4a:	429a      	cmp	r2, r3
 800ed4c:	d901      	bls.n	800ed52 <create_chain+0x15a>
 800ed4e:	2300      	movs	r3, #0
 800ed50:	e04f      	b.n	800edf2 <create_chain+0x1fa>
			}
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 800ed52:	69f9      	ldr	r1, [r7, #28]
 800ed54:	6878      	ldr	r0, [r7, #4]
 800ed56:	f7ff facd 	bl	800e2f4 <get_fat>
 800ed5a:	60f8      	str	r0, [r7, #12]
			if (cs == 0) break;				/* Found a free cluster */
 800ed5c:	68fb      	ldr	r3, [r7, #12]
 800ed5e:	2b00      	cmp	r3, #0
 800ed60:	d00e      	beq.n	800ed80 <create_chain+0x188>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 800ed62:	68fb      	ldr	r3, [r7, #12]
 800ed64:	2b01      	cmp	r3, #1
 800ed66:	d003      	beq.n	800ed70 <create_chain+0x178>
 800ed68:	68fb      	ldr	r3, [r7, #12]
 800ed6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ed6e:	d101      	bne.n	800ed74 <create_chain+0x17c>
 800ed70:	68fb      	ldr	r3, [r7, #12]
 800ed72:	e03e      	b.n	800edf2 <create_chain+0x1fa>
			if (ncl == scl) return 0;		/* No free cluster */
 800ed74:	69fa      	ldr	r2, [r7, #28]
 800ed76:	69bb      	ldr	r3, [r7, #24]
 800ed78:	429a      	cmp	r2, r3
 800ed7a:	d1da      	bne.n	800ed32 <create_chain+0x13a>
 800ed7c:	2300      	movs	r3, #0
 800ed7e:	e038      	b.n	800edf2 <create_chain+0x1fa>
			if (cs == 0) break;				/* Found a free cluster */
 800ed80:	bf00      	nop
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
 800ed82:	f04f 32ff 	mov.w	r2, #4294967295
 800ed86:	69f9      	ldr	r1, [r7, #28]
 800ed88:	6938      	ldr	r0, [r7, #16]
 800ed8a:	f7ff fc07 	bl	800e59c <put_fat>
 800ed8e:	4603      	mov	r3, r0
 800ed90:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
 800ed92:	7dfb      	ldrb	r3, [r7, #23]
 800ed94:	2b00      	cmp	r3, #0
 800ed96:	d109      	bne.n	800edac <create_chain+0x1b4>
 800ed98:	683b      	ldr	r3, [r7, #0]
 800ed9a:	2b00      	cmp	r3, #0
 800ed9c:	d006      	beq.n	800edac <create_chain+0x1b4>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
 800ed9e:	69fa      	ldr	r2, [r7, #28]
 800eda0:	6839      	ldr	r1, [r7, #0]
 800eda2:	6938      	ldr	r0, [r7, #16]
 800eda4:	f7ff fbfa 	bl	800e59c <put_fat>
 800eda8:	4603      	mov	r3, r0
 800edaa:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800edac:	7dfb      	ldrb	r3, [r7, #23]
 800edae:	2b00      	cmp	r3, #0
 800edb0:	d116      	bne.n	800ede0 <create_chain+0x1e8>
		fs->last_clst = ncl;
 800edb2:	693b      	ldr	r3, [r7, #16]
 800edb4:	69fa      	ldr	r2, [r7, #28]
 800edb6:	619a      	str	r2, [r3, #24]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800edb8:	693b      	ldr	r3, [r7, #16]
 800edba:	69da      	ldr	r2, [r3, #28]
 800edbc:	693b      	ldr	r3, [r7, #16]
 800edbe:	6a1b      	ldr	r3, [r3, #32]
 800edc0:	3b02      	subs	r3, #2
 800edc2:	429a      	cmp	r2, r3
 800edc4:	d804      	bhi.n	800edd0 <create_chain+0x1d8>
 800edc6:	693b      	ldr	r3, [r7, #16]
 800edc8:	69db      	ldr	r3, [r3, #28]
 800edca:	1e5a      	subs	r2, r3, #1
 800edcc:	693b      	ldr	r3, [r7, #16]
 800edce:	61da      	str	r2, [r3, #28]
		fs->fsi_flag |= 1;
 800edd0:	693b      	ldr	r3, [r7, #16]
 800edd2:	791b      	ldrb	r3, [r3, #4]
 800edd4:	f043 0301 	orr.w	r3, r3, #1
 800edd8:	b2da      	uxtb	r2, r3
 800edda:	693b      	ldr	r3, [r7, #16]
 800eddc:	711a      	strb	r2, [r3, #4]
 800edde:	e007      	b.n	800edf0 <create_chain+0x1f8>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800ede0:	7dfb      	ldrb	r3, [r7, #23]
 800ede2:	2b01      	cmp	r3, #1
 800ede4:	d102      	bne.n	800edec <create_chain+0x1f4>
 800ede6:	f04f 33ff 	mov.w	r3, #4294967295
 800edea:	e000      	b.n	800edee <create_chain+0x1f6>
 800edec:	2301      	movs	r3, #1
 800edee:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
 800edf0:	69fb      	ldr	r3, [r7, #28]
}
 800edf2:	4618      	mov	r0, r3
 800edf4:	3720      	adds	r7, #32
 800edf6:	46bd      	mov	sp, r7
 800edf8:	bd80      	pop	{r7, pc}

0800edfa <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
 800edfa:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800edfe:	b088      	sub	sp, #32
 800ee00:	af00      	add	r7, sp, #0
 800ee02:	60f8      	str	r0, [r7, #12]
 800ee04:	e9c7 2300 	strd	r2, r3, [r7]
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;
 800ee08:	68fb      	ldr	r3, [r7, #12]
 800ee0a:	681b      	ldr	r3, [r3, #0]
 800ee0c:	617b      	str	r3, [r7, #20]


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800ee0e:	68fb      	ldr	r3, [r7, #12]
 800ee10:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ee12:	3304      	adds	r3, #4
 800ee14:	61bb      	str	r3, [r7, #24]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800ee16:	697b      	ldr	r3, [r7, #20]
 800ee18:	899b      	ldrh	r3, [r3, #12]
 800ee1a:	b29b      	uxth	r3, r3
 800ee1c:	2200      	movs	r2, #0
 800ee1e:	4698      	mov	r8, r3
 800ee20:	4691      	mov	r9, r2
 800ee22:	4642      	mov	r2, r8
 800ee24:	464b      	mov	r3, r9
 800ee26:	e9d7 0100 	ldrd	r0, r1, [r7]
 800ee2a:	f7f1 fe3f 	bl	8000aac <__aeabi_uldivmod>
 800ee2e:	4602      	mov	r2, r0
 800ee30:	460b      	mov	r3, r1
 800ee32:	4610      	mov	r0, r2
 800ee34:	4619      	mov	r1, r3
 800ee36:	697b      	ldr	r3, [r7, #20]
 800ee38:	895b      	ldrh	r3, [r3, #10]
 800ee3a:	b29b      	uxth	r3, r3
 800ee3c:	2200      	movs	r2, #0
 800ee3e:	461c      	mov	r4, r3
 800ee40:	4615      	mov	r5, r2
 800ee42:	4622      	mov	r2, r4
 800ee44:	462b      	mov	r3, r5
 800ee46:	f7f1 fe31 	bl	8000aac <__aeabi_uldivmod>
 800ee4a:	4602      	mov	r2, r0
 800ee4c:	460b      	mov	r3, r1
 800ee4e:	4613      	mov	r3, r2
 800ee50:	61fb      	str	r3, [r7, #28]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800ee52:	69bb      	ldr	r3, [r7, #24]
 800ee54:	1d1a      	adds	r2, r3, #4
 800ee56:	61ba      	str	r2, [r7, #24]
 800ee58:	681b      	ldr	r3, [r3, #0]
 800ee5a:	613b      	str	r3, [r7, #16]
		if (ncl == 0) return 0;	/* End of table? (error) */
 800ee5c:	693b      	ldr	r3, [r7, #16]
 800ee5e:	2b00      	cmp	r3, #0
 800ee60:	d101      	bne.n	800ee66 <clmt_clust+0x6c>
 800ee62:	2300      	movs	r3, #0
 800ee64:	e010      	b.n	800ee88 <clmt_clust+0x8e>
		if (cl < ncl) break;	/* In this fragment? */
 800ee66:	69fa      	ldr	r2, [r7, #28]
 800ee68:	693b      	ldr	r3, [r7, #16]
 800ee6a:	429a      	cmp	r2, r3
 800ee6c:	d307      	bcc.n	800ee7e <clmt_clust+0x84>
		cl -= ncl; tbl++;		/* Next fragment */
 800ee6e:	69fa      	ldr	r2, [r7, #28]
 800ee70:	693b      	ldr	r3, [r7, #16]
 800ee72:	1ad3      	subs	r3, r2, r3
 800ee74:	61fb      	str	r3, [r7, #28]
 800ee76:	69bb      	ldr	r3, [r7, #24]
 800ee78:	3304      	adds	r3, #4
 800ee7a:	61bb      	str	r3, [r7, #24]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800ee7c:	e7e9      	b.n	800ee52 <clmt_clust+0x58>
		if (cl < ncl) break;	/* In this fragment? */
 800ee7e:	bf00      	nop
	}
	return cl + *tbl;	/* Return the cluster number */
 800ee80:	69bb      	ldr	r3, [r7, #24]
 800ee82:	681a      	ldr	r2, [r3, #0]
 800ee84:	69fb      	ldr	r3, [r7, #28]
 800ee86:	4413      	add	r3, r2
}
 800ee88:	4618      	mov	r0, r3
 800ee8a:	3720      	adds	r7, #32
 800ee8c:	46bd      	mov	sp, r7
 800ee8e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800ee92 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
 800ee92:	b580      	push	{r7, lr}
 800ee94:	b086      	sub	sp, #24
 800ee96:	af00      	add	r7, sp, #0
 800ee98:	6078      	str	r0, [r7, #4]
 800ee9a:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
 800ee9c:	687b      	ldr	r3, [r7, #4]
 800ee9e:	681b      	ldr	r3, [r3, #0]
 800eea0:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800eea2:	693b      	ldr	r3, [r7, #16]
 800eea4:	781b      	ldrb	r3, [r3, #0]
 800eea6:	2b04      	cmp	r3, #4
 800eea8:	d102      	bne.n	800eeb0 <dir_sdi+0x1e>
 800eeaa:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800eeae:	e001      	b.n	800eeb4 <dir_sdi+0x22>
 800eeb0:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 800eeb4:	683b      	ldr	r3, [r7, #0]
 800eeb6:	429a      	cmp	r2, r3
 800eeb8:	d904      	bls.n	800eec4 <dir_sdi+0x32>
 800eeba:	683b      	ldr	r3, [r7, #0]
 800eebc:	f003 031f 	and.w	r3, r3, #31
 800eec0:	2b00      	cmp	r3, #0
 800eec2:	d001      	beq.n	800eec8 <dir_sdi+0x36>
		return FR_INT_ERR;
 800eec4:	2302      	movs	r3, #2
 800eec6:	e074      	b.n	800efb2 <dir_sdi+0x120>
	}
	dp->dptr = ofs;				/* Set current offset */
 800eec8:	687b      	ldr	r3, [r7, #4]
 800eeca:	683a      	ldr	r2, [r7, #0]
 800eecc:	631a      	str	r2, [r3, #48]	@ 0x30
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800eece:	687b      	ldr	r3, [r7, #4]
 800eed0:	689b      	ldr	r3, [r3, #8]
 800eed2:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800eed4:	697b      	ldr	r3, [r7, #20]
 800eed6:	2b00      	cmp	r3, #0
 800eed8:	d109      	bne.n	800eeee <dir_sdi+0x5c>
 800eeda:	693b      	ldr	r3, [r7, #16]
 800eedc:	781b      	ldrb	r3, [r3, #0]
 800eede:	2b02      	cmp	r3, #2
 800eee0:	d905      	bls.n	800eeee <dir_sdi+0x5c>
		clst = fs->dirbase;
 800eee2:	693b      	ldr	r3, [r7, #16]
 800eee4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eee6:	617b      	str	r3, [r7, #20]
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 800eee8:	687b      	ldr	r3, [r7, #4]
 800eeea:	2200      	movs	r2, #0
 800eeec:	71da      	strb	r2, [r3, #7]
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800eeee:	697b      	ldr	r3, [r7, #20]
 800eef0:	2b00      	cmp	r3, #0
 800eef2:	d10c      	bne.n	800ef0e <dir_sdi+0x7c>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 800eef4:	683b      	ldr	r3, [r7, #0]
 800eef6:	095b      	lsrs	r3, r3, #5
 800eef8:	693a      	ldr	r2, [r7, #16]
 800eefa:	8912      	ldrh	r2, [r2, #8]
 800eefc:	4293      	cmp	r3, r2
 800eefe:	d301      	bcc.n	800ef04 <dir_sdi+0x72>
 800ef00:	2302      	movs	r3, #2
 800ef02:	e056      	b.n	800efb2 <dir_sdi+0x120>
		dp->sect = fs->dirbase;
 800ef04:	693b      	ldr	r3, [r7, #16]
 800ef06:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800ef08:	687b      	ldr	r3, [r7, #4]
 800ef0a:	639a      	str	r2, [r3, #56]	@ 0x38
 800ef0c:	e02d      	b.n	800ef6a <dir_sdi+0xd8>

	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800ef0e:	693b      	ldr	r3, [r7, #16]
 800ef10:	895b      	ldrh	r3, [r3, #10]
 800ef12:	461a      	mov	r2, r3
 800ef14:	693b      	ldr	r3, [r7, #16]
 800ef16:	899b      	ldrh	r3, [r3, #12]
 800ef18:	fb02 f303 	mul.w	r3, r2, r3
 800ef1c:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
 800ef1e:	e019      	b.n	800ef54 <dir_sdi+0xc2>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800ef20:	687b      	ldr	r3, [r7, #4]
 800ef22:	6979      	ldr	r1, [r7, #20]
 800ef24:	4618      	mov	r0, r3
 800ef26:	f7ff f9e5 	bl	800e2f4 <get_fat>
 800ef2a:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800ef2c:	697b      	ldr	r3, [r7, #20]
 800ef2e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ef32:	d101      	bne.n	800ef38 <dir_sdi+0xa6>
 800ef34:	2301      	movs	r3, #1
 800ef36:	e03c      	b.n	800efb2 <dir_sdi+0x120>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800ef38:	697b      	ldr	r3, [r7, #20]
 800ef3a:	2b01      	cmp	r3, #1
 800ef3c:	d904      	bls.n	800ef48 <dir_sdi+0xb6>
 800ef3e:	693b      	ldr	r3, [r7, #16]
 800ef40:	6a1b      	ldr	r3, [r3, #32]
 800ef42:	697a      	ldr	r2, [r7, #20]
 800ef44:	429a      	cmp	r2, r3
 800ef46:	d301      	bcc.n	800ef4c <dir_sdi+0xba>
 800ef48:	2302      	movs	r3, #2
 800ef4a:	e032      	b.n	800efb2 <dir_sdi+0x120>
			ofs -= csz;
 800ef4c:	683a      	ldr	r2, [r7, #0]
 800ef4e:	68fb      	ldr	r3, [r7, #12]
 800ef50:	1ad3      	subs	r3, r2, r3
 800ef52:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
 800ef54:	683a      	ldr	r2, [r7, #0]
 800ef56:	68fb      	ldr	r3, [r7, #12]
 800ef58:	429a      	cmp	r2, r3
 800ef5a:	d2e1      	bcs.n	800ef20 <dir_sdi+0x8e>
		}
		dp->sect = clust2sect(fs, clst);
 800ef5c:	6979      	ldr	r1, [r7, #20]
 800ef5e:	6938      	ldr	r0, [r7, #16]
 800ef60:	f7ff f9a8 	bl	800e2b4 <clust2sect>
 800ef64:	4602      	mov	r2, r0
 800ef66:	687b      	ldr	r3, [r7, #4]
 800ef68:	639a      	str	r2, [r3, #56]	@ 0x38
	}
	dp->clust = clst;					/* Current cluster# */
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	697a      	ldr	r2, [r7, #20]
 800ef6e:	635a      	str	r2, [r3, #52]	@ 0x34
	if (!dp->sect) return FR_INT_ERR;
 800ef70:	687b      	ldr	r3, [r7, #4]
 800ef72:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ef74:	2b00      	cmp	r3, #0
 800ef76:	d101      	bne.n	800ef7c <dir_sdi+0xea>
 800ef78:	2302      	movs	r3, #2
 800ef7a:	e01a      	b.n	800efb2 <dir_sdi+0x120>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800ef7c:	687b      	ldr	r3, [r7, #4]
 800ef7e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800ef80:	693b      	ldr	r3, [r7, #16]
 800ef82:	899b      	ldrh	r3, [r3, #12]
 800ef84:	4619      	mov	r1, r3
 800ef86:	683b      	ldr	r3, [r7, #0]
 800ef88:	fbb3 f3f1 	udiv	r3, r3, r1
 800ef8c:	441a      	add	r2, r3
 800ef8e:	687b      	ldr	r3, [r7, #4]
 800ef90:	639a      	str	r2, [r3, #56]	@ 0x38
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800ef92:	693b      	ldr	r3, [r7, #16]
 800ef94:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800ef98:	693b      	ldr	r3, [r7, #16]
 800ef9a:	899b      	ldrh	r3, [r3, #12]
 800ef9c:	461a      	mov	r2, r3
 800ef9e:	683b      	ldr	r3, [r7, #0]
 800efa0:	fbb3 f0f2 	udiv	r0, r3, r2
 800efa4:	fb00 f202 	mul.w	r2, r0, r2
 800efa8:	1a9b      	subs	r3, r3, r2
 800efaa:	18ca      	adds	r2, r1, r3
 800efac:	687b      	ldr	r3, [r7, #4]
 800efae:	63da      	str	r2, [r3, #60]	@ 0x3c

	return FR_OK;
 800efb0:	2300      	movs	r3, #0
}
 800efb2:	4618      	mov	r0, r3
 800efb4:	3718      	adds	r7, #24
 800efb6:	46bd      	mov	sp, r7
 800efb8:	bd80      	pop	{r7, pc}

0800efba <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 800efba:	b580      	push	{r7, lr}
 800efbc:	b086      	sub	sp, #24
 800efbe:	af00      	add	r7, sp, #0
 800efc0:	6078      	str	r0, [r7, #4]
 800efc2:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
 800efc4:	687b      	ldr	r3, [r7, #4]
 800efc6:	681b      	ldr	r3, [r3, #0]
 800efc8:	60fb      	str	r3, [r7, #12]
#if !_FS_READONLY
	UINT n;
#endif

	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800efce:	3320      	adds	r3, #32
 800efd0:	60bb      	str	r3, [r7, #8]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800efd2:	687b      	ldr	r3, [r7, #4]
 800efd4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800efd6:	2b00      	cmp	r3, #0
 800efd8:	d00b      	beq.n	800eff2 <dir_next+0x38>
 800efda:	68fb      	ldr	r3, [r7, #12]
 800efdc:	781b      	ldrb	r3, [r3, #0]
 800efde:	2b04      	cmp	r3, #4
 800efe0:	d102      	bne.n	800efe8 <dir_next+0x2e>
 800efe2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800efe6:	e001      	b.n	800efec <dir_next+0x32>
 800efe8:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 800efec:	68bb      	ldr	r3, [r7, #8]
 800efee:	429a      	cmp	r2, r3
 800eff0:	d801      	bhi.n	800eff6 <dir_next+0x3c>
 800eff2:	2304      	movs	r3, #4
 800eff4:	e0c3      	b.n	800f17e <dir_next+0x1c4>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800eff6:	68fb      	ldr	r3, [r7, #12]
 800eff8:	899b      	ldrh	r3, [r3, #12]
 800effa:	461a      	mov	r2, r3
 800effc:	68bb      	ldr	r3, [r7, #8]
 800effe:	fbb3 f1f2 	udiv	r1, r3, r2
 800f002:	fb01 f202 	mul.w	r2, r1, r2
 800f006:	1a9b      	subs	r3, r3, r2
 800f008:	2b00      	cmp	r3, #0
 800f00a:	f040 80a5 	bne.w	800f158 <dir_next+0x19e>
		dp->sect++;				/* Next sector */
 800f00e:	687b      	ldr	r3, [r7, #4]
 800f010:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f012:	1c5a      	adds	r2, r3, #1
 800f014:	687b      	ldr	r3, [r7, #4]
 800f016:	639a      	str	r2, [r3, #56]	@ 0x38

		if (!dp->clust) {		/* Static table */
 800f018:	687b      	ldr	r3, [r7, #4]
 800f01a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f01c:	2b00      	cmp	r3, #0
 800f01e:	d10b      	bne.n	800f038 <dir_next+0x7e>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800f020:	68bb      	ldr	r3, [r7, #8]
 800f022:	095b      	lsrs	r3, r3, #5
 800f024:	68fa      	ldr	r2, [r7, #12]
 800f026:	8912      	ldrh	r2, [r2, #8]
 800f028:	4293      	cmp	r3, r2
 800f02a:	f0c0 8095 	bcc.w	800f158 <dir_next+0x19e>
				dp->sect = 0; return FR_NO_FILE;
 800f02e:	687b      	ldr	r3, [r7, #4]
 800f030:	2200      	movs	r2, #0
 800f032:	639a      	str	r2, [r3, #56]	@ 0x38
 800f034:	2304      	movs	r3, #4
 800f036:	e0a2      	b.n	800f17e <dir_next+0x1c4>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800f038:	68fb      	ldr	r3, [r7, #12]
 800f03a:	899b      	ldrh	r3, [r3, #12]
 800f03c:	461a      	mov	r2, r3
 800f03e:	68bb      	ldr	r3, [r7, #8]
 800f040:	fbb3 f3f2 	udiv	r3, r3, r2
 800f044:	68fa      	ldr	r2, [r7, #12]
 800f046:	8952      	ldrh	r2, [r2, #10]
 800f048:	3a01      	subs	r2, #1
 800f04a:	4013      	ands	r3, r2
 800f04c:	2b00      	cmp	r3, #0
 800f04e:	f040 8083 	bne.w	800f158 <dir_next+0x19e>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800f052:	687a      	ldr	r2, [r7, #4]
 800f054:	687b      	ldr	r3, [r7, #4]
 800f056:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f058:	4619      	mov	r1, r3
 800f05a:	4610      	mov	r0, r2
 800f05c:	f7ff f94a 	bl	800e2f4 <get_fat>
 800f060:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800f062:	697b      	ldr	r3, [r7, #20]
 800f064:	2b01      	cmp	r3, #1
 800f066:	d801      	bhi.n	800f06c <dir_next+0xb2>
 800f068:	2302      	movs	r3, #2
 800f06a:	e088      	b.n	800f17e <dir_next+0x1c4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800f06c:	697b      	ldr	r3, [r7, #20]
 800f06e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f072:	d101      	bne.n	800f078 <dir_next+0xbe>
 800f074:	2301      	movs	r3, #1
 800f076:	e082      	b.n	800f17e <dir_next+0x1c4>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800f078:	68fb      	ldr	r3, [r7, #12]
 800f07a:	6a1b      	ldr	r3, [r3, #32]
 800f07c:	697a      	ldr	r2, [r7, #20]
 800f07e:	429a      	cmp	r2, r3
 800f080:	d360      	bcc.n	800f144 <dir_next+0x18a>
#if !_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
 800f082:	683b      	ldr	r3, [r7, #0]
 800f084:	2b00      	cmp	r3, #0
 800f086:	d104      	bne.n	800f092 <dir_next+0xd8>
						dp->sect = 0; return FR_NO_FILE;
 800f088:	687b      	ldr	r3, [r7, #4]
 800f08a:	2200      	movs	r2, #0
 800f08c:	639a      	str	r2, [r3, #56]	@ 0x38
 800f08e:	2304      	movs	r3, #4
 800f090:	e075      	b.n	800f17e <dir_next+0x1c4>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800f092:	687a      	ldr	r2, [r7, #4]
 800f094:	687b      	ldr	r3, [r7, #4]
 800f096:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800f098:	4619      	mov	r1, r3
 800f09a:	4610      	mov	r0, r2
 800f09c:	f7ff fdac 	bl	800ebf8 <create_chain>
 800f0a0:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800f0a2:	697b      	ldr	r3, [r7, #20]
 800f0a4:	2b00      	cmp	r3, #0
 800f0a6:	d101      	bne.n	800f0ac <dir_next+0xf2>
 800f0a8:	2307      	movs	r3, #7
 800f0aa:	e068      	b.n	800f17e <dir_next+0x1c4>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800f0ac:	697b      	ldr	r3, [r7, #20]
 800f0ae:	2b01      	cmp	r3, #1
 800f0b0:	d101      	bne.n	800f0b6 <dir_next+0xfc>
 800f0b2:	2302      	movs	r3, #2
 800f0b4:	e063      	b.n	800f17e <dir_next+0x1c4>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800f0b6:	697b      	ldr	r3, [r7, #20]
 800f0b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f0bc:	d101      	bne.n	800f0c2 <dir_next+0x108>
 800f0be:	2301      	movs	r3, #1
 800f0c0:	e05d      	b.n	800f17e <dir_next+0x1c4>
					/* Clean-up the stretched table */
					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
 800f0c2:	687b      	ldr	r3, [r7, #4]
 800f0c4:	79db      	ldrb	r3, [r3, #7]
 800f0c6:	f043 0304 	orr.w	r3, r3, #4
 800f0ca:	b2da      	uxtb	r2, r3
 800f0cc:	687b      	ldr	r3, [r7, #4]
 800f0ce:	71da      	strb	r2, [r3, #7]
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 800f0d0:	68f8      	ldr	r0, [r7, #12]
 800f0d2:	f7ff f80d 	bl	800e0f0 <sync_window>
 800f0d6:	4603      	mov	r3, r0
 800f0d8:	2b00      	cmp	r3, #0
 800f0da:	d001      	beq.n	800f0e0 <dir_next+0x126>
 800f0dc:	2301      	movs	r3, #1
 800f0de:	e04e      	b.n	800f17e <dir_next+0x1c4>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 800f0e0:	68fb      	ldr	r3, [r7, #12]
 800f0e2:	f103 003c 	add.w	r0, r3, #60	@ 0x3c
 800f0e6:	68fb      	ldr	r3, [r7, #12]
 800f0e8:	899b      	ldrh	r3, [r3, #12]
 800f0ea:	461a      	mov	r2, r3
 800f0ec:	2100      	movs	r1, #0
 800f0ee:	f7fe fe35 	bl	800dd5c <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800f0f2:	2300      	movs	r3, #0
 800f0f4:	613b      	str	r3, [r7, #16]
 800f0f6:	6979      	ldr	r1, [r7, #20]
 800f0f8:	68f8      	ldr	r0, [r7, #12]
 800f0fa:	f7ff f8db 	bl	800e2b4 <clust2sect>
 800f0fe:	4602      	mov	r2, r0
 800f100:	68fb      	ldr	r3, [r7, #12]
 800f102:	639a      	str	r2, [r3, #56]	@ 0x38
 800f104:	e012      	b.n	800f12c <dir_next+0x172>
						fs->wflag = 1;
 800f106:	68fb      	ldr	r3, [r7, #12]
 800f108:	2201      	movs	r2, #1
 800f10a:	70da      	strb	r2, [r3, #3]
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 800f10c:	68f8      	ldr	r0, [r7, #12]
 800f10e:	f7fe ffef 	bl	800e0f0 <sync_window>
 800f112:	4603      	mov	r3, r0
 800f114:	2b00      	cmp	r3, #0
 800f116:	d001      	beq.n	800f11c <dir_next+0x162>
 800f118:	2301      	movs	r3, #1
 800f11a:	e030      	b.n	800f17e <dir_next+0x1c4>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800f11c:	693b      	ldr	r3, [r7, #16]
 800f11e:	3301      	adds	r3, #1
 800f120:	613b      	str	r3, [r7, #16]
 800f122:	68fb      	ldr	r3, [r7, #12]
 800f124:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f126:	1c5a      	adds	r2, r3, #1
 800f128:	68fb      	ldr	r3, [r7, #12]
 800f12a:	639a      	str	r2, [r3, #56]	@ 0x38
 800f12c:	68fb      	ldr	r3, [r7, #12]
 800f12e:	895b      	ldrh	r3, [r3, #10]
 800f130:	461a      	mov	r2, r3
 800f132:	693b      	ldr	r3, [r7, #16]
 800f134:	4293      	cmp	r3, r2
 800f136:	d3e6      	bcc.n	800f106 <dir_next+0x14c>
					}
					fs->winsect -= n;							/* Restore window offset */
 800f138:	68fb      	ldr	r3, [r7, #12]
 800f13a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800f13c:	693b      	ldr	r3, [r7, #16]
 800f13e:	1ad2      	subs	r2, r2, r3
 800f140:	68fb      	ldr	r3, [r7, #12]
 800f142:	639a      	str	r2, [r3, #56]	@ 0x38
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
 800f144:	687b      	ldr	r3, [r7, #4]
 800f146:	697a      	ldr	r2, [r7, #20]
 800f148:	635a      	str	r2, [r3, #52]	@ 0x34
				dp->sect = clust2sect(fs, clst);
 800f14a:	6979      	ldr	r1, [r7, #20]
 800f14c:	68f8      	ldr	r0, [r7, #12]
 800f14e:	f7ff f8b1 	bl	800e2b4 <clust2sect>
 800f152:	4602      	mov	r2, r0
 800f154:	687b      	ldr	r3, [r7, #4]
 800f156:	639a      	str	r2, [r3, #56]	@ 0x38
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
 800f158:	687b      	ldr	r3, [r7, #4]
 800f15a:	68ba      	ldr	r2, [r7, #8]
 800f15c:	631a      	str	r2, [r3, #48]	@ 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800f15e:	68fb      	ldr	r3, [r7, #12]
 800f160:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800f164:	68fb      	ldr	r3, [r7, #12]
 800f166:	899b      	ldrh	r3, [r3, #12]
 800f168:	461a      	mov	r2, r3
 800f16a:	68bb      	ldr	r3, [r7, #8]
 800f16c:	fbb3 f0f2 	udiv	r0, r3, r2
 800f170:	fb00 f202 	mul.w	r2, r0, r2
 800f174:	1a9b      	subs	r3, r3, r2
 800f176:	18ca      	adds	r2, r1, r3
 800f178:	687b      	ldr	r3, [r7, #4]
 800f17a:	63da      	str	r2, [r3, #60]	@ 0x3c

	return FR_OK;
 800f17c:	2300      	movs	r3, #0
}
 800f17e:	4618      	mov	r0, r3
 800f180:	3718      	adds	r7, #24
 800f182:	46bd      	mov	sp, r7
 800f184:	bd80      	pop	{r7, pc}

0800f186 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate */
)
{
 800f186:	b580      	push	{r7, lr}
 800f188:	b086      	sub	sp, #24
 800f18a:	af00      	add	r7, sp, #0
 800f18c:	6078      	str	r0, [r7, #4]
 800f18e:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
 800f190:	687b      	ldr	r3, [r7, #4]
 800f192:	681b      	ldr	r3, [r3, #0]
 800f194:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
 800f196:	2100      	movs	r1, #0
 800f198:	6878      	ldr	r0, [r7, #4]
 800f19a:	f7ff fe7a 	bl	800ee92 <dir_sdi>
 800f19e:	4603      	mov	r3, r0
 800f1a0:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800f1a2:	7dfb      	ldrb	r3, [r7, #23]
 800f1a4:	2b00      	cmp	r3, #0
 800f1a6:	d140      	bne.n	800f22a <dir_alloc+0xa4>
		n = 0;
 800f1a8:	2300      	movs	r3, #0
 800f1aa:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
 800f1ac:	687b      	ldr	r3, [r7, #4]
 800f1ae:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f1b0:	4619      	mov	r1, r3
 800f1b2:	68f8      	ldr	r0, [r7, #12]
 800f1b4:	f7fe ffe0 	bl	800e178 <move_window>
 800f1b8:	4603      	mov	r3, r0
 800f1ba:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800f1bc:	7dfb      	ldrb	r3, [r7, #23]
 800f1be:	2b00      	cmp	r3, #0
 800f1c0:	d132      	bne.n	800f228 <dir_alloc+0xa2>
#if _FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
 800f1c2:	68fb      	ldr	r3, [r7, #12]
 800f1c4:	781b      	ldrb	r3, [r3, #0]
 800f1c6:	2b04      	cmp	r3, #4
 800f1c8:	d108      	bne.n	800f1dc <dir_alloc+0x56>
 800f1ca:	687b      	ldr	r3, [r7, #4]
 800f1cc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f1ce:	781b      	ldrb	r3, [r3, #0]
 800f1d0:	b25b      	sxtb	r3, r3
 800f1d2:	43db      	mvns	r3, r3
 800f1d4:	b2db      	uxtb	r3, r3
 800f1d6:	09db      	lsrs	r3, r3, #7
 800f1d8:	b2db      	uxtb	r3, r3
 800f1da:	e00f      	b.n	800f1fc <dir_alloc+0x76>
 800f1dc:	687b      	ldr	r3, [r7, #4]
 800f1de:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f1e0:	781b      	ldrb	r3, [r3, #0]
 800f1e2:	2be5      	cmp	r3, #229	@ 0xe5
 800f1e4:	d004      	beq.n	800f1f0 <dir_alloc+0x6a>
 800f1e6:	687b      	ldr	r3, [r7, #4]
 800f1e8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f1ea:	781b      	ldrb	r3, [r3, #0]
 800f1ec:	2b00      	cmp	r3, #0
 800f1ee:	d101      	bne.n	800f1f4 <dir_alloc+0x6e>
 800f1f0:	2301      	movs	r3, #1
 800f1f2:	e000      	b.n	800f1f6 <dir_alloc+0x70>
 800f1f4:	2300      	movs	r3, #0
 800f1f6:	f003 0301 	and.w	r3, r3, #1
 800f1fa:	b2db      	uxtb	r3, r3
 800f1fc:	2b00      	cmp	r3, #0
 800f1fe:	d007      	beq.n	800f210 <dir_alloc+0x8a>
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 800f200:	693b      	ldr	r3, [r7, #16]
 800f202:	3301      	adds	r3, #1
 800f204:	613b      	str	r3, [r7, #16]
 800f206:	693a      	ldr	r2, [r7, #16]
 800f208:	683b      	ldr	r3, [r7, #0]
 800f20a:	429a      	cmp	r2, r3
 800f20c:	d102      	bne.n	800f214 <dir_alloc+0x8e>
 800f20e:	e00c      	b.n	800f22a <dir_alloc+0xa4>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 800f210:	2300      	movs	r3, #0
 800f212:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);
 800f214:	2101      	movs	r1, #1
 800f216:	6878      	ldr	r0, [r7, #4]
 800f218:	f7ff fecf 	bl	800efba <dir_next>
 800f21c:	4603      	mov	r3, r0
 800f21e:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 800f220:	7dfb      	ldrb	r3, [r7, #23]
 800f222:	2b00      	cmp	r3, #0
 800f224:	d0c2      	beq.n	800f1ac <dir_alloc+0x26>
 800f226:	e000      	b.n	800f22a <dir_alloc+0xa4>
			if (res != FR_OK) break;
 800f228:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800f22a:	7dfb      	ldrb	r3, [r7, #23]
 800f22c:	2b04      	cmp	r3, #4
 800f22e:	d101      	bne.n	800f234 <dir_alloc+0xae>
 800f230:	2307      	movs	r3, #7
 800f232:	75fb      	strb	r3, [r7, #23]
	return res;
 800f234:	7dfb      	ldrb	r3, [r7, #23]
}
 800f236:	4618      	mov	r0, r3
 800f238:	3718      	adds	r7, #24
 800f23a:	46bd      	mov	sp, r7
 800f23c:	bd80      	pop	{r7, pc}

0800f23e <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the key entry */
)
{
 800f23e:	b580      	push	{r7, lr}
 800f240:	b084      	sub	sp, #16
 800f242:	af00      	add	r7, sp, #0
 800f244:	6078      	str	r0, [r7, #4]
 800f246:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
 800f248:	683b      	ldr	r3, [r7, #0]
 800f24a:	331a      	adds	r3, #26
 800f24c:	4618      	mov	r0, r3
 800f24e:	f7fe fb7f 	bl	800d950 <ld_word>
 800f252:	4603      	mov	r3, r0
 800f254:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
 800f256:	687b      	ldr	r3, [r7, #4]
 800f258:	781b      	ldrb	r3, [r3, #0]
 800f25a:	2b03      	cmp	r3, #3
 800f25c:	d109      	bne.n	800f272 <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800f25e:	683b      	ldr	r3, [r7, #0]
 800f260:	3314      	adds	r3, #20
 800f262:	4618      	mov	r0, r3
 800f264:	f7fe fb74 	bl	800d950 <ld_word>
 800f268:	4603      	mov	r3, r0
 800f26a:	041b      	lsls	r3, r3, #16
 800f26c:	68fa      	ldr	r2, [r7, #12]
 800f26e:	4313      	orrs	r3, r2
 800f270:	60fb      	str	r3, [r7, #12]
	}

	return cl;
 800f272:	68fb      	ldr	r3, [r7, #12]
}
 800f274:	4618      	mov	r0, r3
 800f276:	3710      	adds	r7, #16
 800f278:	46bd      	mov	sp, r7
 800f27a:	bd80      	pop	{r7, pc}

0800f27c <st_clust>:
void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
 800f27c:	b580      	push	{r7, lr}
 800f27e:	b084      	sub	sp, #16
 800f280:	af00      	add	r7, sp, #0
 800f282:	60f8      	str	r0, [r7, #12]
 800f284:	60b9      	str	r1, [r7, #8]
 800f286:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 800f288:	68bb      	ldr	r3, [r7, #8]
 800f28a:	331a      	adds	r3, #26
 800f28c:	687a      	ldr	r2, [r7, #4]
 800f28e:	b292      	uxth	r2, r2
 800f290:	4611      	mov	r1, r2
 800f292:	4618      	mov	r0, r3
 800f294:	f7fe fc72 	bl	800db7c <st_word>
	if (fs->fs_type == FS_FAT32) {
 800f298:	68fb      	ldr	r3, [r7, #12]
 800f29a:	781b      	ldrb	r3, [r3, #0]
 800f29c:	2b03      	cmp	r3, #3
 800f29e:	d109      	bne.n	800f2b4 <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800f2a0:	68bb      	ldr	r3, [r7, #8]
 800f2a2:	f103 0214 	add.w	r2, r3, #20
 800f2a6:	687b      	ldr	r3, [r7, #4]
 800f2a8:	0c1b      	lsrs	r3, r3, #16
 800f2aa:	b29b      	uxth	r3, r3
 800f2ac:	4619      	mov	r1, r3
 800f2ae:	4610      	mov	r0, r2
 800f2b0:	f7fe fc64 	bl	800db7c <st_word>
	}
}
 800f2b4:	bf00      	nop
 800f2b6:	3710      	adds	r7, #16
 800f2b8:	46bd      	mov	sp, r7
 800f2ba:	bd80      	pop	{r7, pc}

0800f2bc <cmp_lfn>:
static
int cmp_lfn (				/* 1:matched, 0:not matched */
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
)
{
 800f2bc:	b590      	push	{r4, r7, lr}
 800f2be:	b087      	sub	sp, #28
 800f2c0:	af00      	add	r7, sp, #0
 800f2c2:	6078      	str	r0, [r7, #4]
 800f2c4:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 800f2c6:	683b      	ldr	r3, [r7, #0]
 800f2c8:	331a      	adds	r3, #26
 800f2ca:	4618      	mov	r0, r3
 800f2cc:	f7fe fb40 	bl	800d950 <ld_word>
 800f2d0:	4603      	mov	r3, r0
 800f2d2:	2b00      	cmp	r3, #0
 800f2d4:	d001      	beq.n	800f2da <cmp_lfn+0x1e>
 800f2d6:	2300      	movs	r3, #0
 800f2d8:	e059      	b.n	800f38e <cmp_lfn+0xd2>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800f2da:	683b      	ldr	r3, [r7, #0]
 800f2dc:	781b      	ldrb	r3, [r3, #0]
 800f2de:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800f2e2:	1e5a      	subs	r2, r3, #1
 800f2e4:	4613      	mov	r3, r2
 800f2e6:	005b      	lsls	r3, r3, #1
 800f2e8:	4413      	add	r3, r2
 800f2ea:	009b      	lsls	r3, r3, #2
 800f2ec:	4413      	add	r3, r2
 800f2ee:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800f2f0:	2301      	movs	r3, #1
 800f2f2:	81fb      	strh	r3, [r7, #14]
 800f2f4:	2300      	movs	r3, #0
 800f2f6:	613b      	str	r3, [r7, #16]
 800f2f8:	e033      	b.n	800f362 <cmp_lfn+0xa6>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800f2fa:	4a27      	ldr	r2, [pc, #156]	@ (800f398 <cmp_lfn+0xdc>)
 800f2fc:	693b      	ldr	r3, [r7, #16]
 800f2fe:	4413      	add	r3, r2
 800f300:	781b      	ldrb	r3, [r3, #0]
 800f302:	461a      	mov	r2, r3
 800f304:	683b      	ldr	r3, [r7, #0]
 800f306:	4413      	add	r3, r2
 800f308:	4618      	mov	r0, r3
 800f30a:	f7fe fb21 	bl	800d950 <ld_word>
 800f30e:	4603      	mov	r3, r0
 800f310:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 800f312:	89fb      	ldrh	r3, [r7, #14]
 800f314:	2b00      	cmp	r3, #0
 800f316:	d01a      	beq.n	800f34e <cmp_lfn+0x92>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800f318:	697b      	ldr	r3, [r7, #20]
 800f31a:	2bfe      	cmp	r3, #254	@ 0xfe
 800f31c:	d812      	bhi.n	800f344 <cmp_lfn+0x88>
 800f31e:	89bb      	ldrh	r3, [r7, #12]
 800f320:	4618      	mov	r0, r3
 800f322:	f003 fd25 	bl	8012d70 <ff_wtoupper>
 800f326:	4603      	mov	r3, r0
 800f328:	461c      	mov	r4, r3
 800f32a:	697b      	ldr	r3, [r7, #20]
 800f32c:	1c5a      	adds	r2, r3, #1
 800f32e:	617a      	str	r2, [r7, #20]
 800f330:	005b      	lsls	r3, r3, #1
 800f332:	687a      	ldr	r2, [r7, #4]
 800f334:	4413      	add	r3, r2
 800f336:	881b      	ldrh	r3, [r3, #0]
 800f338:	4618      	mov	r0, r3
 800f33a:	f003 fd19 	bl	8012d70 <ff_wtoupper>
 800f33e:	4603      	mov	r3, r0
 800f340:	429c      	cmp	r4, r3
 800f342:	d001      	beq.n	800f348 <cmp_lfn+0x8c>
				return 0;					/* Not matched */
 800f344:	2300      	movs	r3, #0
 800f346:	e022      	b.n	800f38e <cmp_lfn+0xd2>
			}
			wc = uc;
 800f348:	89bb      	ldrh	r3, [r7, #12]
 800f34a:	81fb      	strh	r3, [r7, #14]
 800f34c:	e006      	b.n	800f35c <cmp_lfn+0xa0>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800f34e:	89bb      	ldrh	r3, [r7, #12]
 800f350:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800f354:	4293      	cmp	r3, r2
 800f356:	d001      	beq.n	800f35c <cmp_lfn+0xa0>
 800f358:	2300      	movs	r3, #0
 800f35a:	e018      	b.n	800f38e <cmp_lfn+0xd2>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800f35c:	693b      	ldr	r3, [r7, #16]
 800f35e:	3301      	adds	r3, #1
 800f360:	613b      	str	r3, [r7, #16]
 800f362:	693b      	ldr	r3, [r7, #16]
 800f364:	2b0c      	cmp	r3, #12
 800f366:	d9c8      	bls.n	800f2fa <cmp_lfn+0x3e>
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800f368:	683b      	ldr	r3, [r7, #0]
 800f36a:	781b      	ldrb	r3, [r3, #0]
 800f36c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800f370:	2b00      	cmp	r3, #0
 800f372:	d00b      	beq.n	800f38c <cmp_lfn+0xd0>
 800f374:	89fb      	ldrh	r3, [r7, #14]
 800f376:	2b00      	cmp	r3, #0
 800f378:	d008      	beq.n	800f38c <cmp_lfn+0xd0>
 800f37a:	697b      	ldr	r3, [r7, #20]
 800f37c:	005b      	lsls	r3, r3, #1
 800f37e:	687a      	ldr	r2, [r7, #4]
 800f380:	4413      	add	r3, r2
 800f382:	881b      	ldrh	r3, [r3, #0]
 800f384:	2b00      	cmp	r3, #0
 800f386:	d001      	beq.n	800f38c <cmp_lfn+0xd0>
 800f388:	2300      	movs	r3, #0
 800f38a:	e000      	b.n	800f38e <cmp_lfn+0xd2>

	return 1;		/* The part of LFN matched */
 800f38c:	2301      	movs	r3, #1
}
 800f38e:	4618      	mov	r0, r3
 800f390:	371c      	adds	r7, #28
 800f392:	46bd      	mov	sp, r7
 800f394:	bd90      	pop	{r4, r7, pc}
 800f396:	bf00      	nop
 800f398:	08031a78 	.word	0x08031a78

0800f39c <pick_lfn>:
static
int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
	BYTE* dir			/* Pointer to the LFN entry */
)
{
 800f39c:	b580      	push	{r7, lr}
 800f39e:	b086      	sub	sp, #24
 800f3a0:	af00      	add	r7, sp, #0
 800f3a2:	6078      	str	r0, [r7, #4]
 800f3a4:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 800f3a6:	683b      	ldr	r3, [r7, #0]
 800f3a8:	331a      	adds	r3, #26
 800f3aa:	4618      	mov	r0, r3
 800f3ac:	f7fe fad0 	bl	800d950 <ld_word>
 800f3b0:	4603      	mov	r3, r0
 800f3b2:	2b00      	cmp	r3, #0
 800f3b4:	d001      	beq.n	800f3ba <pick_lfn+0x1e>
 800f3b6:	2300      	movs	r3, #0
 800f3b8:	e04d      	b.n	800f456 <pick_lfn+0xba>

	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800f3ba:	683b      	ldr	r3, [r7, #0]
 800f3bc:	781b      	ldrb	r3, [r3, #0]
 800f3be:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800f3c2:	1e5a      	subs	r2, r3, #1
 800f3c4:	4613      	mov	r3, r2
 800f3c6:	005b      	lsls	r3, r3, #1
 800f3c8:	4413      	add	r3, r2
 800f3ca:	009b      	lsls	r3, r3, #2
 800f3cc:	4413      	add	r3, r2
 800f3ce:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800f3d0:	2301      	movs	r3, #1
 800f3d2:	81fb      	strh	r3, [r7, #14]
 800f3d4:	2300      	movs	r3, #0
 800f3d6:	613b      	str	r3, [r7, #16]
 800f3d8:	e028      	b.n	800f42c <pick_lfn+0x90>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800f3da:	4a21      	ldr	r2, [pc, #132]	@ (800f460 <pick_lfn+0xc4>)
 800f3dc:	693b      	ldr	r3, [r7, #16]
 800f3de:	4413      	add	r3, r2
 800f3e0:	781b      	ldrb	r3, [r3, #0]
 800f3e2:	461a      	mov	r2, r3
 800f3e4:	683b      	ldr	r3, [r7, #0]
 800f3e6:	4413      	add	r3, r2
 800f3e8:	4618      	mov	r0, r3
 800f3ea:	f7fe fab1 	bl	800d950 <ld_word>
 800f3ee:	4603      	mov	r3, r0
 800f3f0:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 800f3f2:	89fb      	ldrh	r3, [r7, #14]
 800f3f4:	2b00      	cmp	r3, #0
 800f3f6:	d00f      	beq.n	800f418 <pick_lfn+0x7c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800f3f8:	697b      	ldr	r3, [r7, #20]
 800f3fa:	2bfe      	cmp	r3, #254	@ 0xfe
 800f3fc:	d901      	bls.n	800f402 <pick_lfn+0x66>
 800f3fe:	2300      	movs	r3, #0
 800f400:	e029      	b.n	800f456 <pick_lfn+0xba>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800f402:	89bb      	ldrh	r3, [r7, #12]
 800f404:	81fb      	strh	r3, [r7, #14]
 800f406:	697b      	ldr	r3, [r7, #20]
 800f408:	1c5a      	adds	r2, r3, #1
 800f40a:	617a      	str	r2, [r7, #20]
 800f40c:	005b      	lsls	r3, r3, #1
 800f40e:	687a      	ldr	r2, [r7, #4]
 800f410:	4413      	add	r3, r2
 800f412:	89fa      	ldrh	r2, [r7, #14]
 800f414:	801a      	strh	r2, [r3, #0]
 800f416:	e006      	b.n	800f426 <pick_lfn+0x8a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800f418:	89bb      	ldrh	r3, [r7, #12]
 800f41a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800f41e:	4293      	cmp	r3, r2
 800f420:	d001      	beq.n	800f426 <pick_lfn+0x8a>
 800f422:	2300      	movs	r3, #0
 800f424:	e017      	b.n	800f456 <pick_lfn+0xba>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800f426:	693b      	ldr	r3, [r7, #16]
 800f428:	3301      	adds	r3, #1
 800f42a:	613b      	str	r3, [r7, #16]
 800f42c:	693b      	ldr	r3, [r7, #16]
 800f42e:	2b0c      	cmp	r3, #12
 800f430:	d9d3      	bls.n	800f3da <pick_lfn+0x3e>
		}
	}

	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 800f432:	683b      	ldr	r3, [r7, #0]
 800f434:	781b      	ldrb	r3, [r3, #0]
 800f436:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800f43a:	2b00      	cmp	r3, #0
 800f43c:	d00a      	beq.n	800f454 <pick_lfn+0xb8>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 800f43e:	697b      	ldr	r3, [r7, #20]
 800f440:	2bfe      	cmp	r3, #254	@ 0xfe
 800f442:	d901      	bls.n	800f448 <pick_lfn+0xac>
 800f444:	2300      	movs	r3, #0
 800f446:	e006      	b.n	800f456 <pick_lfn+0xba>
		lfnbuf[i] = 0;
 800f448:	697b      	ldr	r3, [r7, #20]
 800f44a:	005b      	lsls	r3, r3, #1
 800f44c:	687a      	ldr	r2, [r7, #4]
 800f44e:	4413      	add	r3, r2
 800f450:	2200      	movs	r2, #0
 800f452:	801a      	strh	r2, [r3, #0]
	}

	return 1;		/* The part of LFN is valid */
 800f454:	2301      	movs	r3, #1
}
 800f456:	4618      	mov	r0, r3
 800f458:	3718      	adds	r7, #24
 800f45a:	46bd      	mov	sp, r7
 800f45c:	bd80      	pop	{r7, pc}
 800f45e:	bf00      	nop
 800f460:	08031a78 	.word	0x08031a78

0800f464 <put_lfn>:
	const WCHAR* lfn,	/* Pointer to the LFN */
	BYTE* dir,			/* Pointer to the LFN entry to be created */
	BYTE ord,			/* LFN order (1-20) */
	BYTE sum			/* Checksum of the corresponding SFN */
)
{
 800f464:	b580      	push	{r7, lr}
 800f466:	b088      	sub	sp, #32
 800f468:	af00      	add	r7, sp, #0
 800f46a:	60f8      	str	r0, [r7, #12]
 800f46c:	60b9      	str	r1, [r7, #8]
 800f46e:	4611      	mov	r1, r2
 800f470:	461a      	mov	r2, r3
 800f472:	460b      	mov	r3, r1
 800f474:	71fb      	strb	r3, [r7, #7]
 800f476:	4613      	mov	r3, r2
 800f478:	71bb      	strb	r3, [r7, #6]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
 800f47a:	68bb      	ldr	r3, [r7, #8]
 800f47c:	330d      	adds	r3, #13
 800f47e:	79ba      	ldrb	r2, [r7, #6]
 800f480:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800f482:	68bb      	ldr	r3, [r7, #8]
 800f484:	330b      	adds	r3, #11
 800f486:	220f      	movs	r2, #15
 800f488:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
 800f48a:	68bb      	ldr	r3, [r7, #8]
 800f48c:	330c      	adds	r3, #12
 800f48e:	2200      	movs	r2, #0
 800f490:	701a      	strb	r2, [r3, #0]
	st_word(dir + LDIR_FstClusLO, 0);
 800f492:	68bb      	ldr	r3, [r7, #8]
 800f494:	331a      	adds	r3, #26
 800f496:	2100      	movs	r1, #0
 800f498:	4618      	mov	r0, r3
 800f49a:	f7fe fb6f 	bl	800db7c <st_word>

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 800f49e:	79fb      	ldrb	r3, [r7, #7]
 800f4a0:	1e5a      	subs	r2, r3, #1
 800f4a2:	4613      	mov	r3, r2
 800f4a4:	005b      	lsls	r3, r3, #1
 800f4a6:	4413      	add	r3, r2
 800f4a8:	009b      	lsls	r3, r3, #2
 800f4aa:	4413      	add	r3, r2
 800f4ac:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
 800f4ae:	2300      	movs	r3, #0
 800f4b0:	82fb      	strh	r3, [r7, #22]
 800f4b2:	2300      	movs	r3, #0
 800f4b4:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f4b6:	8afb      	ldrh	r3, [r7, #22]
 800f4b8:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800f4bc:	4293      	cmp	r3, r2
 800f4be:	d007      	beq.n	800f4d0 <put_lfn+0x6c>
 800f4c0:	69fb      	ldr	r3, [r7, #28]
 800f4c2:	1c5a      	adds	r2, r3, #1
 800f4c4:	61fa      	str	r2, [r7, #28]
 800f4c6:	005b      	lsls	r3, r3, #1
 800f4c8:	68fa      	ldr	r2, [r7, #12]
 800f4ca:	4413      	add	r3, r2
 800f4cc:	881b      	ldrh	r3, [r3, #0]
 800f4ce:	82fb      	strh	r3, [r7, #22]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 800f4d0:	4a17      	ldr	r2, [pc, #92]	@ (800f530 <put_lfn+0xcc>)
 800f4d2:	69bb      	ldr	r3, [r7, #24]
 800f4d4:	4413      	add	r3, r2
 800f4d6:	781b      	ldrb	r3, [r3, #0]
 800f4d8:	461a      	mov	r2, r3
 800f4da:	68bb      	ldr	r3, [r7, #8]
 800f4dc:	4413      	add	r3, r2
 800f4de:	8afa      	ldrh	r2, [r7, #22]
 800f4e0:	4611      	mov	r1, r2
 800f4e2:	4618      	mov	r0, r3
 800f4e4:	f7fe fb4a 	bl	800db7c <st_word>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f4e8:	8afb      	ldrh	r3, [r7, #22]
 800f4ea:	2b00      	cmp	r3, #0
 800f4ec:	d102      	bne.n	800f4f4 <put_lfn+0x90>
 800f4ee:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800f4f2:	82fb      	strh	r3, [r7, #22]
	} while (++s < 13);
 800f4f4:	69bb      	ldr	r3, [r7, #24]
 800f4f6:	3301      	adds	r3, #1
 800f4f8:	61bb      	str	r3, [r7, #24]
 800f4fa:	69bb      	ldr	r3, [r7, #24]
 800f4fc:	2b0c      	cmp	r3, #12
 800f4fe:	d9da      	bls.n	800f4b6 <put_lfn+0x52>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 800f500:	8afb      	ldrh	r3, [r7, #22]
 800f502:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800f506:	4293      	cmp	r3, r2
 800f508:	d006      	beq.n	800f518 <put_lfn+0xb4>
 800f50a:	69fb      	ldr	r3, [r7, #28]
 800f50c:	005b      	lsls	r3, r3, #1
 800f50e:	68fa      	ldr	r2, [r7, #12]
 800f510:	4413      	add	r3, r2
 800f512:	881b      	ldrh	r3, [r3, #0]
 800f514:	2b00      	cmp	r3, #0
 800f516:	d103      	bne.n	800f520 <put_lfn+0xbc>
 800f518:	79fb      	ldrb	r3, [r7, #7]
 800f51a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800f51e:	71fb      	strb	r3, [r7, #7]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 800f520:	68bb      	ldr	r3, [r7, #8]
 800f522:	79fa      	ldrb	r2, [r7, #7]
 800f524:	701a      	strb	r2, [r3, #0]
}
 800f526:	bf00      	nop
 800f528:	3720      	adds	r7, #32
 800f52a:	46bd      	mov	sp, r7
 800f52c:	bd80      	pop	{r7, pc}
 800f52e:	bf00      	nop
 800f530:	08031a78 	.word	0x08031a78

0800f534 <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 800f534:	b580      	push	{r7, lr}
 800f536:	b08c      	sub	sp, #48	@ 0x30
 800f538:	af00      	add	r7, sp, #0
 800f53a:	60f8      	str	r0, [r7, #12]
 800f53c:	60b9      	str	r1, [r7, #8]
 800f53e:	607a      	str	r2, [r7, #4]
 800f540:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 800f542:	220b      	movs	r2, #11
 800f544:	68b9      	ldr	r1, [r7, #8]
 800f546:	68f8      	ldr	r0, [r7, #12]
 800f548:	f7fe fbe7 	bl	800dd1a <mem_cpy>

	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 800f54c:	683b      	ldr	r3, [r7, #0]
 800f54e:	2b05      	cmp	r3, #5
 800f550:	d92b      	bls.n	800f5aa <gen_numname+0x76>
		sr = seq;
 800f552:	683b      	ldr	r3, [r7, #0]
 800f554:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC */
 800f556:	e022      	b.n	800f59e <gen_numname+0x6a>
			wc = *lfn++;
 800f558:	687b      	ldr	r3, [r7, #4]
 800f55a:	1c9a      	adds	r2, r3, #2
 800f55c:	607a      	str	r2, [r7, #4]
 800f55e:	881b      	ldrh	r3, [r3, #0]
 800f560:	847b      	strh	r3, [r7, #34]	@ 0x22
			for (i = 0; i < 16; i++) {
 800f562:	2300      	movs	r3, #0
 800f564:	62bb      	str	r3, [r7, #40]	@ 0x28
 800f566:	e017      	b.n	800f598 <gen_numname+0x64>
				sr = (sr << 1) + (wc & 1);
 800f568:	69fb      	ldr	r3, [r7, #28]
 800f56a:	005a      	lsls	r2, r3, #1
 800f56c:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 800f56e:	f003 0301 	and.w	r3, r3, #1
 800f572:	4413      	add	r3, r2
 800f574:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
 800f576:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 800f578:	085b      	lsrs	r3, r3, #1
 800f57a:	847b      	strh	r3, [r7, #34]	@ 0x22
				if (sr & 0x10000) sr ^= 0x11021;
 800f57c:	69fb      	ldr	r3, [r7, #28]
 800f57e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800f582:	2b00      	cmp	r3, #0
 800f584:	d005      	beq.n	800f592 <gen_numname+0x5e>
 800f586:	69fb      	ldr	r3, [r7, #28]
 800f588:	f483 3388 	eor.w	r3, r3, #69632	@ 0x11000
 800f58c:	f083 0321 	eor.w	r3, r3, #33	@ 0x21
 800f590:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < 16; i++) {
 800f592:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f594:	3301      	adds	r3, #1
 800f596:	62bb      	str	r3, [r7, #40]	@ 0x28
 800f598:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f59a:	2b0f      	cmp	r3, #15
 800f59c:	d9e4      	bls.n	800f568 <gen_numname+0x34>
		while (*lfn) {	/* Create a CRC */
 800f59e:	687b      	ldr	r3, [r7, #4]
 800f5a0:	881b      	ldrh	r3, [r3, #0]
 800f5a2:	2b00      	cmp	r3, #0
 800f5a4:	d1d8      	bne.n	800f558 <gen_numname+0x24>
			}
		}
		seq = (UINT)sr;
 800f5a6:	69fb      	ldr	r3, [r7, #28]
 800f5a8:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
 800f5aa:	2307      	movs	r3, #7
 800f5ac:	62bb      	str	r3, [r7, #40]	@ 0x28
	do {
		c = (BYTE)((seq % 16) + '0');
 800f5ae:	683b      	ldr	r3, [r7, #0]
 800f5b0:	b2db      	uxtb	r3, r3
 800f5b2:	f003 030f 	and.w	r3, r3, #15
 800f5b6:	b2db      	uxtb	r3, r3
 800f5b8:	3330      	adds	r3, #48	@ 0x30
 800f5ba:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		if (c > '9') c += 7;
 800f5be:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f5c2:	2b39      	cmp	r3, #57	@ 0x39
 800f5c4:	d904      	bls.n	800f5d0 <gen_numname+0x9c>
 800f5c6:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f5ca:	3307      	adds	r3, #7
 800f5cc:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		ns[i--] = c;
 800f5d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f5d2:	1e5a      	subs	r2, r3, #1
 800f5d4:	62ba      	str	r2, [r7, #40]	@ 0x28
 800f5d6:	3330      	adds	r3, #48	@ 0x30
 800f5d8:	443b      	add	r3, r7
 800f5da:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 800f5de:	f803 2c1c 	strb.w	r2, [r3, #-28]
		seq /= 16;
 800f5e2:	683b      	ldr	r3, [r7, #0]
 800f5e4:	091b      	lsrs	r3, r3, #4
 800f5e6:	603b      	str	r3, [r7, #0]
	} while (seq);
 800f5e8:	683b      	ldr	r3, [r7, #0]
 800f5ea:	2b00      	cmp	r3, #0
 800f5ec:	d1df      	bne.n	800f5ae <gen_numname+0x7a>
	ns[i] = '~';
 800f5ee:	f107 0214 	add.w	r2, r7, #20
 800f5f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f5f4:	4413      	add	r3, r2
 800f5f6:	227e      	movs	r2, #126	@ 0x7e
 800f5f8:	701a      	strb	r2, [r3, #0]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800f5fa:	2300      	movs	r3, #0
 800f5fc:	627b      	str	r3, [r7, #36]	@ 0x24
 800f5fe:	e002      	b.n	800f606 <gen_numname+0xd2>
 800f600:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f602:	3301      	adds	r3, #1
 800f604:	627b      	str	r3, [r7, #36]	@ 0x24
 800f606:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f608:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f60a:	429a      	cmp	r2, r3
 800f60c:	d205      	bcs.n	800f61a <gen_numname+0xe6>
 800f60e:	68fa      	ldr	r2, [r7, #12]
 800f610:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f612:	4413      	add	r3, r2
 800f614:	781b      	ldrb	r3, [r3, #0]
 800f616:	2b20      	cmp	r3, #32
 800f618:	d1f2      	bne.n	800f600 <gen_numname+0xcc>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f61a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f61c:	2b07      	cmp	r3, #7
 800f61e:	d807      	bhi.n	800f630 <gen_numname+0xfc>
 800f620:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f622:	1c5a      	adds	r2, r3, #1
 800f624:	62ba      	str	r2, [r7, #40]	@ 0x28
 800f626:	3330      	adds	r3, #48	@ 0x30
 800f628:	443b      	add	r3, r7
 800f62a:	f813 1c1c 	ldrb.w	r1, [r3, #-28]
 800f62e:	e000      	b.n	800f632 <gen_numname+0xfe>
 800f630:	2120      	movs	r1, #32
 800f632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f634:	1c5a      	adds	r2, r3, #1
 800f636:	627a      	str	r2, [r7, #36]	@ 0x24
 800f638:	68fa      	ldr	r2, [r7, #12]
 800f63a:	4413      	add	r3, r2
 800f63c:	460a      	mov	r2, r1
 800f63e:	701a      	strb	r2, [r3, #0]
	} while (j < 8);
 800f640:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f642:	2b07      	cmp	r3, #7
 800f644:	d9e9      	bls.n	800f61a <gen_numname+0xe6>
}
 800f646:	bf00      	nop
 800f648:	bf00      	nop
 800f64a:	3730      	adds	r7, #48	@ 0x30
 800f64c:	46bd      	mov	sp, r7
 800f64e:	bd80      	pop	{r7, pc}

0800f650 <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 800f650:	b480      	push	{r7}
 800f652:	b085      	sub	sp, #20
 800f654:	af00      	add	r7, sp, #0
 800f656:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
 800f658:	2300      	movs	r3, #0
 800f65a:	73fb      	strb	r3, [r7, #15]
	UINT n = 11;
 800f65c:	230b      	movs	r3, #11
 800f65e:	60bb      	str	r3, [r7, #8]

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800f660:	7bfb      	ldrb	r3, [r7, #15]
 800f662:	b2da      	uxtb	r2, r3
 800f664:	0852      	lsrs	r2, r2, #1
 800f666:	01db      	lsls	r3, r3, #7
 800f668:	4313      	orrs	r3, r2
 800f66a:	b2da      	uxtb	r2, r3
 800f66c:	687b      	ldr	r3, [r7, #4]
 800f66e:	1c59      	adds	r1, r3, #1
 800f670:	6079      	str	r1, [r7, #4]
 800f672:	781b      	ldrb	r3, [r3, #0]
 800f674:	4413      	add	r3, r2
 800f676:	73fb      	strb	r3, [r7, #15]
	} while (--n);
 800f678:	68bb      	ldr	r3, [r7, #8]
 800f67a:	3b01      	subs	r3, #1
 800f67c:	60bb      	str	r3, [r7, #8]
 800f67e:	68bb      	ldr	r3, [r7, #8]
 800f680:	2b00      	cmp	r3, #0
 800f682:	d1ed      	bne.n	800f660 <sum_sfn+0x10>
	return sum;
 800f684:	7bfb      	ldrb	r3, [r7, #15]
}
 800f686:	4618      	mov	r0, r3
 800f688:	3714      	adds	r7, #20
 800f68a:	46bd      	mov	sp, r7
 800f68c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f690:	4770      	bx	lr

0800f692 <xdir_sum>:

static
WORD xdir_sum (			/* Get checksum of the directoly block */
	const BYTE* dir		/* Directory entry block to be calculated */
)
{
 800f692:	b480      	push	{r7}
 800f694:	b087      	sub	sp, #28
 800f696:	af00      	add	r7, sp, #0
 800f698:	6078      	str	r0, [r7, #4]
	UINT i, szblk;
	WORD sum;


	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
 800f69a:	687b      	ldr	r3, [r7, #4]
 800f69c:	3301      	adds	r3, #1
 800f69e:	781b      	ldrb	r3, [r3, #0]
 800f6a0:	3301      	adds	r3, #1
 800f6a2:	015b      	lsls	r3, r3, #5
 800f6a4:	60fb      	str	r3, [r7, #12]
	for (i = sum = 0; i < szblk; i++) {
 800f6a6:	2300      	movs	r3, #0
 800f6a8:	827b      	strh	r3, [r7, #18]
 800f6aa:	2300      	movs	r3, #0
 800f6ac:	617b      	str	r3, [r7, #20]
 800f6ae:	e017      	b.n	800f6e0 <xdir_sum+0x4e>
		if (i == XDIR_SetSum) {	/* Skip sum field */
 800f6b0:	697b      	ldr	r3, [r7, #20]
 800f6b2:	2b02      	cmp	r3, #2
 800f6b4:	d103      	bne.n	800f6be <xdir_sum+0x2c>
			i++;
 800f6b6:	697b      	ldr	r3, [r7, #20]
 800f6b8:	3301      	adds	r3, #1
 800f6ba:	617b      	str	r3, [r7, #20]
 800f6bc:	e00d      	b.n	800f6da <xdir_sum+0x48>
		} else {
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 800f6be:	8a7b      	ldrh	r3, [r7, #18]
 800f6c0:	03db      	lsls	r3, r3, #15
 800f6c2:	b29a      	uxth	r2, r3
 800f6c4:	8a7b      	ldrh	r3, [r7, #18]
 800f6c6:	085b      	lsrs	r3, r3, #1
 800f6c8:	b29b      	uxth	r3, r3
 800f6ca:	4413      	add	r3, r2
 800f6cc:	b29b      	uxth	r3, r3
 800f6ce:	6879      	ldr	r1, [r7, #4]
 800f6d0:	697a      	ldr	r2, [r7, #20]
 800f6d2:	440a      	add	r2, r1
 800f6d4:	7812      	ldrb	r2, [r2, #0]
 800f6d6:	4413      	add	r3, r2
 800f6d8:	827b      	strh	r3, [r7, #18]
	for (i = sum = 0; i < szblk; i++) {
 800f6da:	697b      	ldr	r3, [r7, #20]
 800f6dc:	3301      	adds	r3, #1
 800f6de:	617b      	str	r3, [r7, #20]
 800f6e0:	697a      	ldr	r2, [r7, #20]
 800f6e2:	68fb      	ldr	r3, [r7, #12]
 800f6e4:	429a      	cmp	r2, r3
 800f6e6:	d3e3      	bcc.n	800f6b0 <xdir_sum+0x1e>
		}
	}
	return sum;
 800f6e8:	8a7b      	ldrh	r3, [r7, #18]
}
 800f6ea:	4618      	mov	r0, r3
 800f6ec:	371c      	adds	r7, #28
 800f6ee:	46bd      	mov	sp, r7
 800f6f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6f4:	4770      	bx	lr

0800f6f6 <xname_sum>:

static
WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
	const WCHAR* name	/* File name to be calculated */
)
{
 800f6f6:	b580      	push	{r7, lr}
 800f6f8:	b084      	sub	sp, #16
 800f6fa:	af00      	add	r7, sp, #0
 800f6fc:	6078      	str	r0, [r7, #4]
	WCHAR chr;
	WORD sum = 0;
 800f6fe:	2300      	movs	r3, #0
 800f700:	81fb      	strh	r3, [r7, #14]


	while ((chr = *name++) != 0) {
 800f702:	e01f      	b.n	800f744 <xname_sum+0x4e>
		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
 800f704:	89bb      	ldrh	r3, [r7, #12]
 800f706:	4618      	mov	r0, r3
 800f708:	f003 fb32 	bl	8012d70 <ff_wtoupper>
 800f70c:	4603      	mov	r3, r0
 800f70e:	81bb      	strh	r3, [r7, #12]
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 800f710:	89fb      	ldrh	r3, [r7, #14]
 800f712:	03db      	lsls	r3, r3, #15
 800f714:	b29a      	uxth	r2, r3
 800f716:	89fb      	ldrh	r3, [r7, #14]
 800f718:	085b      	lsrs	r3, r3, #1
 800f71a:	b29b      	uxth	r3, r3
 800f71c:	4413      	add	r3, r2
 800f71e:	b29a      	uxth	r2, r3
 800f720:	89bb      	ldrh	r3, [r7, #12]
 800f722:	b2db      	uxtb	r3, r3
 800f724:	b29b      	uxth	r3, r3
 800f726:	4413      	add	r3, r2
 800f728:	81fb      	strh	r3, [r7, #14]
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 800f72a:	89fb      	ldrh	r3, [r7, #14]
 800f72c:	03db      	lsls	r3, r3, #15
 800f72e:	b29a      	uxth	r2, r3
 800f730:	89fb      	ldrh	r3, [r7, #14]
 800f732:	085b      	lsrs	r3, r3, #1
 800f734:	b29b      	uxth	r3, r3
 800f736:	4413      	add	r3, r2
 800f738:	b29a      	uxth	r2, r3
 800f73a:	89bb      	ldrh	r3, [r7, #12]
 800f73c:	0a1b      	lsrs	r3, r3, #8
 800f73e:	b29b      	uxth	r3, r3
 800f740:	4413      	add	r3, r2
 800f742:	81fb      	strh	r3, [r7, #14]
	while ((chr = *name++) != 0) {
 800f744:	687b      	ldr	r3, [r7, #4]
 800f746:	1c9a      	adds	r2, r3, #2
 800f748:	607a      	str	r2, [r7, #4]
 800f74a:	881b      	ldrh	r3, [r3, #0]
 800f74c:	81bb      	strh	r3, [r7, #12]
 800f74e:	89bb      	ldrh	r3, [r7, #12]
 800f750:	2b00      	cmp	r3, #0
 800f752:	d1d7      	bne.n	800f704 <xname_sum+0xe>
	}
	return sum;
 800f754:	89fb      	ldrh	r3, [r7, #14]
}
 800f756:	4618      	mov	r0, r3
 800f758:	3710      	adds	r7, #16
 800f75a:	46bd      	mov	sp, r7
 800f75c:	bd80      	pop	{r7, pc}
	...

0800f760 <load_xdir>:

static
FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
)
{
 800f760:	b590      	push	{r4, r7, lr}
 800f762:	b087      	sub	sp, #28
 800f764:	af00      	add	r7, sp, #0
 800f766:	6078      	str	r0, [r7, #4]
	FRESULT res;
	UINT i, sz_ent;
	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 800f768:	687b      	ldr	r3, [r7, #4]
 800f76a:	681b      	ldr	r3, [r3, #0]
 800f76c:	695b      	ldr	r3, [r3, #20]
 800f76e:	613b      	str	r3, [r7, #16]


	/* Load 85 entry */
	res = move_window(dp->obj.fs, dp->sect);
 800f770:	687b      	ldr	r3, [r7, #4]
 800f772:	681a      	ldr	r2, [r3, #0]
 800f774:	687b      	ldr	r3, [r7, #4]
 800f776:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f778:	4619      	mov	r1, r3
 800f77a:	4610      	mov	r0, r2
 800f77c:	f7fe fcfc 	bl	800e178 <move_window>
 800f780:	4603      	mov	r3, r0
 800f782:	73fb      	strb	r3, [r7, #15]
	if (res != FR_OK) return res;
 800f784:	7bfb      	ldrb	r3, [r7, #15]
 800f786:	2b00      	cmp	r3, #0
 800f788:	d001      	beq.n	800f78e <load_xdir+0x2e>
 800f78a:	7bfb      	ldrb	r3, [r7, #15]
 800f78c:	e09f      	b.n	800f8ce <load_xdir+0x16e>
	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
 800f78e:	687b      	ldr	r3, [r7, #4]
 800f790:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f792:	781b      	ldrb	r3, [r3, #0]
 800f794:	2b85      	cmp	r3, #133	@ 0x85
 800f796:	d001      	beq.n	800f79c <load_xdir+0x3c>
 800f798:	2302      	movs	r3, #2
 800f79a:	e098      	b.n	800f8ce <load_xdir+0x16e>
	mem_cpy(dirb + 0, dp->dir, SZDIRE);
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f7a0:	2220      	movs	r2, #32
 800f7a2:	4619      	mov	r1, r3
 800f7a4:	6938      	ldr	r0, [r7, #16]
 800f7a6:	f7fe fab8 	bl	800dd1a <mem_cpy>
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 800f7aa:	693b      	ldr	r3, [r7, #16]
 800f7ac:	3301      	adds	r3, #1
 800f7ae:	781b      	ldrb	r3, [r3, #0]
 800f7b0:	3301      	adds	r3, #1
 800f7b2:	015b      	lsls	r3, r3, #5
 800f7b4:	60bb      	str	r3, [r7, #8]
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 800f7b6:	68bb      	ldr	r3, [r7, #8]
 800f7b8:	2b5f      	cmp	r3, #95	@ 0x5f
 800f7ba:	d903      	bls.n	800f7c4 <load_xdir+0x64>
 800f7bc:	68bb      	ldr	r3, [r7, #8]
 800f7be:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 800f7c2:	d901      	bls.n	800f7c8 <load_xdir+0x68>
 800f7c4:	2302      	movs	r3, #2
 800f7c6:	e082      	b.n	800f8ce <load_xdir+0x16e>

	/* Load C0 entry */
	res = dir_next(dp, 0);
 800f7c8:	2100      	movs	r1, #0
 800f7ca:	6878      	ldr	r0, [r7, #4]
 800f7cc:	f7ff fbf5 	bl	800efba <dir_next>
 800f7d0:	4603      	mov	r3, r0
 800f7d2:	73fb      	strb	r3, [r7, #15]
	if (res != FR_OK) return res;
 800f7d4:	7bfb      	ldrb	r3, [r7, #15]
 800f7d6:	2b00      	cmp	r3, #0
 800f7d8:	d001      	beq.n	800f7de <load_xdir+0x7e>
 800f7da:	7bfb      	ldrb	r3, [r7, #15]
 800f7dc:	e077      	b.n	800f8ce <load_xdir+0x16e>
	res = move_window(dp->obj.fs, dp->sect);
 800f7de:	687b      	ldr	r3, [r7, #4]
 800f7e0:	681a      	ldr	r2, [r3, #0]
 800f7e2:	687b      	ldr	r3, [r7, #4]
 800f7e4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f7e6:	4619      	mov	r1, r3
 800f7e8:	4610      	mov	r0, r2
 800f7ea:	f7fe fcc5 	bl	800e178 <move_window>
 800f7ee:	4603      	mov	r3, r0
 800f7f0:	73fb      	strb	r3, [r7, #15]
	if (res != FR_OK) return res;
 800f7f2:	7bfb      	ldrb	r3, [r7, #15]
 800f7f4:	2b00      	cmp	r3, #0
 800f7f6:	d001      	beq.n	800f7fc <load_xdir+0x9c>
 800f7f8:	7bfb      	ldrb	r3, [r7, #15]
 800f7fa:	e068      	b.n	800f8ce <load_xdir+0x16e>
	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
 800f7fc:	687b      	ldr	r3, [r7, #4]
 800f7fe:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f800:	781b      	ldrb	r3, [r3, #0]
 800f802:	2bc0      	cmp	r3, #192	@ 0xc0
 800f804:	d001      	beq.n	800f80a <load_xdir+0xaa>
 800f806:	2302      	movs	r3, #2
 800f808:	e061      	b.n	800f8ce <load_xdir+0x16e>
	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
 800f80a:	693b      	ldr	r3, [r7, #16]
 800f80c:	f103 0020 	add.w	r0, r3, #32
 800f810:	687b      	ldr	r3, [r7, #4]
 800f812:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f814:	2220      	movs	r2, #32
 800f816:	4619      	mov	r1, r3
 800f818:	f7fe fa7f 	bl	800dd1a <mem_cpy>
	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 800f81c:	693b      	ldr	r3, [r7, #16]
 800f81e:	3323      	adds	r3, #35	@ 0x23
 800f820:	781b      	ldrb	r3, [r3, #0]
 800f822:	332c      	adds	r3, #44	@ 0x2c
 800f824:	4a2c      	ldr	r2, [pc, #176]	@ (800f8d8 <load_xdir+0x178>)
 800f826:	fba2 2303 	umull	r2, r3, r2, r3
 800f82a:	08db      	lsrs	r3, r3, #3
 800f82c:	015b      	lsls	r3, r3, #5
 800f82e:	68ba      	ldr	r2, [r7, #8]
 800f830:	429a      	cmp	r2, r3
 800f832:	d201      	bcs.n	800f838 <load_xdir+0xd8>
 800f834:	2302      	movs	r3, #2
 800f836:	e04a      	b.n	800f8ce <load_xdir+0x16e>

	/* Load C1 entries */
	i = SZDIRE * 2;	/* C1 offset */
 800f838:	2340      	movs	r3, #64	@ 0x40
 800f83a:	617b      	str	r3, [r7, #20]
	do {
		res = dir_next(dp, 0);
 800f83c:	2100      	movs	r1, #0
 800f83e:	6878      	ldr	r0, [r7, #4]
 800f840:	f7ff fbbb 	bl	800efba <dir_next>
 800f844:	4603      	mov	r3, r0
 800f846:	73fb      	strb	r3, [r7, #15]
		if (res != FR_OK) return res;
 800f848:	7bfb      	ldrb	r3, [r7, #15]
 800f84a:	2b00      	cmp	r3, #0
 800f84c:	d001      	beq.n	800f852 <load_xdir+0xf2>
 800f84e:	7bfb      	ldrb	r3, [r7, #15]
 800f850:	e03d      	b.n	800f8ce <load_xdir+0x16e>
		res = move_window(dp->obj.fs, dp->sect);
 800f852:	687b      	ldr	r3, [r7, #4]
 800f854:	681a      	ldr	r2, [r3, #0]
 800f856:	687b      	ldr	r3, [r7, #4]
 800f858:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f85a:	4619      	mov	r1, r3
 800f85c:	4610      	mov	r0, r2
 800f85e:	f7fe fc8b 	bl	800e178 <move_window>
 800f862:	4603      	mov	r3, r0
 800f864:	73fb      	strb	r3, [r7, #15]
		if (res != FR_OK) return res;
 800f866:	7bfb      	ldrb	r3, [r7, #15]
 800f868:	2b00      	cmp	r3, #0
 800f86a:	d001      	beq.n	800f870 <load_xdir+0x110>
 800f86c:	7bfb      	ldrb	r3, [r7, #15]
 800f86e:	e02e      	b.n	800f8ce <load_xdir+0x16e>
		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
 800f870:	687b      	ldr	r3, [r7, #4]
 800f872:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f874:	781b      	ldrb	r3, [r3, #0]
 800f876:	2bc1      	cmp	r3, #193	@ 0xc1
 800f878:	d001      	beq.n	800f87e <load_xdir+0x11e>
 800f87a:	2302      	movs	r3, #2
 800f87c:	e027      	b.n	800f8ce <load_xdir+0x16e>
		if (i < MAXDIRB(_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
 800f87e:	697b      	ldr	r3, [r7, #20]
 800f880:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 800f884:	d208      	bcs.n	800f898 <load_xdir+0x138>
 800f886:	693a      	ldr	r2, [r7, #16]
 800f888:	697b      	ldr	r3, [r7, #20]
 800f88a:	18d0      	adds	r0, r2, r3
 800f88c:	687b      	ldr	r3, [r7, #4]
 800f88e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f890:	2220      	movs	r2, #32
 800f892:	4619      	mov	r1, r3
 800f894:	f7fe fa41 	bl	800dd1a <mem_cpy>
	} while ((i += SZDIRE) < sz_ent);
 800f898:	697b      	ldr	r3, [r7, #20]
 800f89a:	3320      	adds	r3, #32
 800f89c:	617b      	str	r3, [r7, #20]
 800f89e:	697a      	ldr	r2, [r7, #20]
 800f8a0:	68bb      	ldr	r3, [r7, #8]
 800f8a2:	429a      	cmp	r2, r3
 800f8a4:	d3ca      	bcc.n	800f83c <load_xdir+0xdc>

	/* Sanity check (do it when accessible object name) */
	if (i <= MAXDIRB(_MAX_LFN)) {
 800f8a6:	697b      	ldr	r3, [r7, #20]
 800f8a8:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 800f8ac:	d80e      	bhi.n	800f8cc <load_xdir+0x16c>
		if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
 800f8ae:	6938      	ldr	r0, [r7, #16]
 800f8b0:	f7ff feef 	bl	800f692 <xdir_sum>
 800f8b4:	4603      	mov	r3, r0
 800f8b6:	461c      	mov	r4, r3
 800f8b8:	693b      	ldr	r3, [r7, #16]
 800f8ba:	3302      	adds	r3, #2
 800f8bc:	4618      	mov	r0, r3
 800f8be:	f7fe f847 	bl	800d950 <ld_word>
 800f8c2:	4603      	mov	r3, r0
 800f8c4:	429c      	cmp	r4, r3
 800f8c6:	d001      	beq.n	800f8cc <load_xdir+0x16c>
 800f8c8:	2302      	movs	r3, #2
 800f8ca:	e000      	b.n	800f8ce <load_xdir+0x16e>
	}
	return FR_OK;
 800f8cc:	2300      	movs	r3, #0
}
 800f8ce:	4618      	mov	r0, r3
 800f8d0:	371c      	adds	r7, #28
 800f8d2:	46bd      	mov	sp, r7
 800f8d4:	bd90      	pop	{r4, r7, pc}
 800f8d6:	bf00      	nop
 800f8d8:	88888889 	.word	0x88888889

0800f8dc <load_obj_dir>:
static
FRESULT load_obj_dir (
	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
	const _FDID* obj	/* Object with its containing directory information */
)
{
 800f8dc:	b5b0      	push	{r4, r5, r7, lr}
 800f8de:	b084      	sub	sp, #16
 800f8e0:	af00      	add	r7, sp, #0
 800f8e2:	6078      	str	r0, [r7, #4]
 800f8e4:	6039      	str	r1, [r7, #0]
	FRESULT res;

	/* Open object containing directory */
	dp->obj.fs = obj->fs;
 800f8e6:	6839      	ldr	r1, [r7, #0]
 800f8e8:	6808      	ldr	r0, [r1, #0]
 800f8ea:	6879      	ldr	r1, [r7, #4]
 800f8ec:	6008      	str	r0, [r1, #0]
	dp->obj.sclust = obj->c_scl;
 800f8ee:	6839      	ldr	r1, [r7, #0]
 800f8f0:	6a08      	ldr	r0, [r1, #32]
 800f8f2:	6879      	ldr	r1, [r7, #4]
 800f8f4:	6088      	str	r0, [r1, #8]
	dp->obj.stat = (BYTE)obj->c_size;
 800f8f6:	6839      	ldr	r1, [r7, #0]
 800f8f8:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 800f8fa:	b2c8      	uxtb	r0, r1
 800f8fc:	6879      	ldr	r1, [r7, #4]
 800f8fe:	71c8      	strb	r0, [r1, #7]
	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 800f900:	6839      	ldr	r1, [r7, #0]
 800f902:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 800f904:	2000      	movs	r0, #0
 800f906:	460c      	mov	r4, r1
 800f908:	4605      	mov	r5, r0
 800f90a:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
 800f90e:	2300      	movs	r3, #0
 800f910:	6879      	ldr	r1, [r7, #4]
 800f912:	e9c1 2304 	strd	r2, r3, [r1, #16]
	dp->blk_ofs = obj->c_ofs;
 800f916:	683b      	ldr	r3, [r7, #0]
 800f918:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800f91a:	687b      	ldr	r3, [r7, #4]
 800f91c:	64da      	str	r2, [r3, #76]	@ 0x4c

	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 800f91e:	687b      	ldr	r3, [r7, #4]
 800f920:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800f922:	4619      	mov	r1, r3
 800f924:	6878      	ldr	r0, [r7, #4]
 800f926:	f7ff fab4 	bl	800ee92 <dir_sdi>
 800f92a:	4603      	mov	r3, r0
 800f92c:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800f92e:	7bfb      	ldrb	r3, [r7, #15]
 800f930:	2b00      	cmp	r3, #0
 800f932:	d104      	bne.n	800f93e <load_obj_dir+0x62>
		res = load_xdir(dp);		/* Load the object's entry block */
 800f934:	6878      	ldr	r0, [r7, #4]
 800f936:	f7ff ff13 	bl	800f760 <load_xdir>
 800f93a:	4603      	mov	r3, r0
 800f93c:	73fb      	strb	r3, [r7, #15]
	}
	return res;
 800f93e:	7bfb      	ldrb	r3, [r7, #15]
}
 800f940:	4618      	mov	r0, r3
 800f942:	3710      	adds	r7, #16
 800f944:	46bd      	mov	sp, r7
 800f946:	bdb0      	pop	{r4, r5, r7, pc}

0800f948 <store_xdir>:
/*-----------------------------------------------*/
static
FRESULT store_xdir (
	DIR* dp				/* Pointer to the direcotry object */
)
{
 800f948:	b590      	push	{r4, r7, lr}
 800f94a:	b087      	sub	sp, #28
 800f94c:	af00      	add	r7, sp, #0
 800f94e:	6078      	str	r0, [r7, #4]
	FRESULT res;
	UINT nent;
	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 800f950:	687b      	ldr	r3, [r7, #4]
 800f952:	681b      	ldr	r3, [r3, #0]
 800f954:	695b      	ldr	r3, [r3, #20]
 800f956:	60fb      	str	r3, [r7, #12]

	/* Create set sum */
	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 800f958:	68fb      	ldr	r3, [r7, #12]
 800f95a:	1c9c      	adds	r4, r3, #2
 800f95c:	68f8      	ldr	r0, [r7, #12]
 800f95e:	f7ff fe98 	bl	800f692 <xdir_sum>
 800f962:	4603      	mov	r3, r0
 800f964:	4619      	mov	r1, r3
 800f966:	4620      	mov	r0, r4
 800f968:	f7fe f908 	bl	800db7c <st_word>
	nent = dirb[XDIR_NumSec] + 1;
 800f96c:	68fb      	ldr	r3, [r7, #12]
 800f96e:	3301      	adds	r3, #1
 800f970:	781b      	ldrb	r3, [r3, #0]
 800f972:	3301      	adds	r3, #1
 800f974:	613b      	str	r3, [r7, #16]

	/* Store the set of directory to the volume */
	res = dir_sdi(dp, dp->blk_ofs);
 800f976:	687b      	ldr	r3, [r7, #4]
 800f978:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800f97a:	4619      	mov	r1, r3
 800f97c:	6878      	ldr	r0, [r7, #4]
 800f97e:	f7ff fa88 	bl	800ee92 <dir_sdi>
 800f982:	4603      	mov	r3, r0
 800f984:	75fb      	strb	r3, [r7, #23]
	while (res == FR_OK) {
 800f986:	e026      	b.n	800f9d6 <store_xdir+0x8e>
		res = move_window(dp->obj.fs, dp->sect);
 800f988:	687b      	ldr	r3, [r7, #4]
 800f98a:	681a      	ldr	r2, [r3, #0]
 800f98c:	687b      	ldr	r3, [r7, #4]
 800f98e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f990:	4619      	mov	r1, r3
 800f992:	4610      	mov	r0, r2
 800f994:	f7fe fbf0 	bl	800e178 <move_window>
 800f998:	4603      	mov	r3, r0
 800f99a:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800f99c:	7dfb      	ldrb	r3, [r7, #23]
 800f99e:	2b00      	cmp	r3, #0
 800f9a0:	d11d      	bne.n	800f9de <store_xdir+0x96>
		mem_cpy(dp->dir, dirb, SZDIRE);
 800f9a2:	687b      	ldr	r3, [r7, #4]
 800f9a4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800f9a6:	2220      	movs	r2, #32
 800f9a8:	68f9      	ldr	r1, [r7, #12]
 800f9aa:	4618      	mov	r0, r3
 800f9ac:	f7fe f9b5 	bl	800dd1a <mem_cpy>
		dp->obj.fs->wflag = 1;
 800f9b0:	687b      	ldr	r3, [r7, #4]
 800f9b2:	681b      	ldr	r3, [r3, #0]
 800f9b4:	2201      	movs	r2, #1
 800f9b6:	70da      	strb	r2, [r3, #3]
		if (--nent == 0) break;
 800f9b8:	693b      	ldr	r3, [r7, #16]
 800f9ba:	3b01      	subs	r3, #1
 800f9bc:	613b      	str	r3, [r7, #16]
 800f9be:	693b      	ldr	r3, [r7, #16]
 800f9c0:	2b00      	cmp	r3, #0
 800f9c2:	d00e      	beq.n	800f9e2 <store_xdir+0x9a>
		dirb += SZDIRE;
 800f9c4:	68fb      	ldr	r3, [r7, #12]
 800f9c6:	3320      	adds	r3, #32
 800f9c8:	60fb      	str	r3, [r7, #12]
		res = dir_next(dp, 0);
 800f9ca:	2100      	movs	r1, #0
 800f9cc:	6878      	ldr	r0, [r7, #4]
 800f9ce:	f7ff faf4 	bl	800efba <dir_next>
 800f9d2:	4603      	mov	r3, r0
 800f9d4:	75fb      	strb	r3, [r7, #23]
	while (res == FR_OK) {
 800f9d6:	7dfb      	ldrb	r3, [r7, #23]
 800f9d8:	2b00      	cmp	r3, #0
 800f9da:	d0d5      	beq.n	800f988 <store_xdir+0x40>
 800f9dc:	e002      	b.n	800f9e4 <store_xdir+0x9c>
		if (res != FR_OK) break;
 800f9de:	bf00      	nop
 800f9e0:	e000      	b.n	800f9e4 <store_xdir+0x9c>
		if (--nent == 0) break;
 800f9e2:	bf00      	nop
	}
	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
 800f9e4:	7dfb      	ldrb	r3, [r7, #23]
 800f9e6:	2b00      	cmp	r3, #0
 800f9e8:	d002      	beq.n	800f9f0 <store_xdir+0xa8>
 800f9ea:	7dfb      	ldrb	r3, [r7, #23]
 800f9ec:	2b01      	cmp	r3, #1
 800f9ee:	d101      	bne.n	800f9f4 <store_xdir+0xac>
 800f9f0:	7dfb      	ldrb	r3, [r7, #23]
 800f9f2:	e000      	b.n	800f9f6 <store_xdir+0xae>
 800f9f4:	2302      	movs	r3, #2
}
 800f9f6:	4618      	mov	r0, r3
 800f9f8:	371c      	adds	r7, #28
 800f9fa:	46bd      	mov	sp, r7
 800f9fc:	bd90      	pop	{r4, r7, pc}

0800f9fe <create_xdir>:
static
void create_xdir (
	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
	const WCHAR* lfn	/* Pointer to the nul terminated file name */
)
{
 800f9fe:	b590      	push	{r4, r7, lr}
 800fa00:	b085      	sub	sp, #20
 800fa02:	af00      	add	r7, sp, #0
 800fa04:	6078      	str	r0, [r7, #4]
 800fa06:	6039      	str	r1, [r7, #0]
	BYTE nb, nc;
	WCHAR chr;


	/* Create 85+C0 entry */
	mem_set(dirb, 0, 2 * SZDIRE);
 800fa08:	2240      	movs	r2, #64	@ 0x40
 800fa0a:	2100      	movs	r1, #0
 800fa0c:	6878      	ldr	r0, [r7, #4]
 800fa0e:	f7fe f9a5 	bl	800dd5c <mem_set>
	dirb[XDIR_Type] = 0x85;
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	2285      	movs	r2, #133	@ 0x85
 800fa16:	701a      	strb	r2, [r3, #0]
	dirb[XDIR_Type + SZDIRE] = 0xC0;
 800fa18:	687b      	ldr	r3, [r7, #4]
 800fa1a:	3320      	adds	r3, #32
 800fa1c:	22c0      	movs	r2, #192	@ 0xc0
 800fa1e:	701a      	strb	r2, [r3, #0]

	/* Create C1 entries */
	nc = 0; nb = 1; chr = 1; i = SZDIRE * 2;
 800fa20:	2300      	movs	r3, #0
 800fa22:	72bb      	strb	r3, [r7, #10]
 800fa24:	2301      	movs	r3, #1
 800fa26:	72fb      	strb	r3, [r7, #11]
 800fa28:	2301      	movs	r3, #1
 800fa2a:	813b      	strh	r3, [r7, #8]
 800fa2c:	2340      	movs	r3, #64	@ 0x40
 800fa2e:	60fb      	str	r3, [r7, #12]
	do {
		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
 800fa30:	68fb      	ldr	r3, [r7, #12]
 800fa32:	1c5a      	adds	r2, r3, #1
 800fa34:	60fa      	str	r2, [r7, #12]
 800fa36:	687a      	ldr	r2, [r7, #4]
 800fa38:	4413      	add	r3, r2
 800fa3a:	22c1      	movs	r2, #193	@ 0xc1
 800fa3c:	701a      	strb	r2, [r3, #0]
 800fa3e:	68fb      	ldr	r3, [r7, #12]
 800fa40:	1c5a      	adds	r2, r3, #1
 800fa42:	60fa      	str	r2, [r7, #12]
 800fa44:	687a      	ldr	r2, [r7, #4]
 800fa46:	4413      	add	r3, r2
 800fa48:	2200      	movs	r2, #0
 800fa4a:	701a      	strb	r2, [r3, #0]
		do {	/* Fill name field */
			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
 800fa4c:	893b      	ldrh	r3, [r7, #8]
 800fa4e:	2b00      	cmp	r3, #0
 800fa50:	d00b      	beq.n	800fa6a <create_xdir+0x6c>
 800fa52:	7abb      	ldrb	r3, [r7, #10]
 800fa54:	005b      	lsls	r3, r3, #1
 800fa56:	683a      	ldr	r2, [r7, #0]
 800fa58:	4413      	add	r3, r2
 800fa5a:	881b      	ldrh	r3, [r3, #0]
 800fa5c:	813b      	strh	r3, [r7, #8]
 800fa5e:	893b      	ldrh	r3, [r7, #8]
 800fa60:	2b00      	cmp	r3, #0
 800fa62:	d002      	beq.n	800fa6a <create_xdir+0x6c>
 800fa64:	7abb      	ldrb	r3, [r7, #10]
 800fa66:	3301      	adds	r3, #1
 800fa68:	72bb      	strb	r3, [r7, #10]
			st_word(dirb + i, chr); 		/* Store it */
 800fa6a:	687a      	ldr	r2, [r7, #4]
 800fa6c:	68fb      	ldr	r3, [r7, #12]
 800fa6e:	4413      	add	r3, r2
 800fa70:	893a      	ldrh	r2, [r7, #8]
 800fa72:	4611      	mov	r1, r2
 800fa74:	4618      	mov	r0, r3
 800fa76:	f7fe f881 	bl	800db7c <st_word>
		} while ((i += 2) % SZDIRE != 0);
 800fa7a:	68fb      	ldr	r3, [r7, #12]
 800fa7c:	3302      	adds	r3, #2
 800fa7e:	60fb      	str	r3, [r7, #12]
 800fa80:	68fb      	ldr	r3, [r7, #12]
 800fa82:	f003 031f 	and.w	r3, r3, #31
 800fa86:	2b00      	cmp	r3, #0
 800fa88:	d1e0      	bne.n	800fa4c <create_xdir+0x4e>
		nb++;
 800fa8a:	7afb      	ldrb	r3, [r7, #11]
 800fa8c:	3301      	adds	r3, #1
 800fa8e:	72fb      	strb	r3, [r7, #11]
	} while (lfn[nc]);	/* Fill next entry if any char follows */
 800fa90:	7abb      	ldrb	r3, [r7, #10]
 800fa92:	005b      	lsls	r3, r3, #1
 800fa94:	683a      	ldr	r2, [r7, #0]
 800fa96:	4413      	add	r3, r2
 800fa98:	881b      	ldrh	r3, [r3, #0]
 800fa9a:	2b00      	cmp	r3, #0
 800fa9c:	d1c8      	bne.n	800fa30 <create_xdir+0x32>

	dirb[XDIR_NumName] = nc;	/* Set name length */
 800fa9e:	687b      	ldr	r3, [r7, #4]
 800faa0:	3323      	adds	r3, #35	@ 0x23
 800faa2:	7aba      	ldrb	r2, [r7, #10]
 800faa4:	701a      	strb	r2, [r3, #0]
	dirb[XDIR_NumSec] = nb;		/* Set block length */
 800faa6:	687b      	ldr	r3, [r7, #4]
 800faa8:	3301      	adds	r3, #1
 800faaa:	7afa      	ldrb	r2, [r7, #11]
 800faac:	701a      	strb	r2, [r3, #0]
	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
 800faae:	687b      	ldr	r3, [r7, #4]
 800fab0:	f103 0424 	add.w	r4, r3, #36	@ 0x24
 800fab4:	6838      	ldr	r0, [r7, #0]
 800fab6:	f7ff fe1e 	bl	800f6f6 <xname_sum>
 800faba:	4603      	mov	r3, r0
 800fabc:	4619      	mov	r1, r3
 800fabe:	4620      	mov	r0, r4
 800fac0:	f7fe f85c 	bl	800db7c <st_word>
}
 800fac4:	bf00      	nop
 800fac6:	3714      	adds	r7, #20
 800fac8:	46bd      	mov	sp, r7
 800faca:	bd90      	pop	{r4, r7, pc}

0800facc <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
 800facc:	b580      	push	{r7, lr}
 800face:	b086      	sub	sp, #24
 800fad0:	af00      	add	r7, sp, #0
 800fad2:	6078      	str	r0, [r7, #4]
 800fad4:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_NO_FILE;
 800fad6:	2304      	movs	r3, #4
 800fad8:	75fb      	strb	r3, [r7, #23]
	FATFS *fs = dp->obj.fs;
 800fada:	687b      	ldr	r3, [r7, #4]
 800fadc:	681b      	ldr	r3, [r3, #0]
 800fade:	613b      	str	r3, [r7, #16]
	BYTE a, c;
#if _USE_LFN != 0
	BYTE ord = 0xFF, sum = 0xFF;
 800fae0:	23ff      	movs	r3, #255	@ 0xff
 800fae2:	757b      	strb	r3, [r7, #21]
 800fae4:	23ff      	movs	r3, #255	@ 0xff
 800fae6:	753b      	strb	r3, [r7, #20]
#endif

	while (dp->sect) {
 800fae8:	e09f      	b.n	800fc2a <dir_read+0x15e>
		res = move_window(fs, dp->sect);
 800faea:	687b      	ldr	r3, [r7, #4]
 800faec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800faee:	4619      	mov	r1, r3
 800faf0:	6938      	ldr	r0, [r7, #16]
 800faf2:	f7fe fb41 	bl	800e178 <move_window>
 800faf6:	4603      	mov	r3, r0
 800faf8:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800fafa:	7dfb      	ldrb	r3, [r7, #23]
 800fafc:	2b00      	cmp	r3, #0
 800fafe:	f040 809a 	bne.w	800fc36 <dir_read+0x16a>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800fb02:	687b      	ldr	r3, [r7, #4]
 800fb04:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fb06:	781b      	ldrb	r3, [r3, #0]
 800fb08:	75bb      	strb	r3, [r7, #22]
		if (c == 0) {
 800fb0a:	7dbb      	ldrb	r3, [r7, #22]
 800fb0c:	2b00      	cmp	r3, #0
 800fb0e:	d102      	bne.n	800fb16 <dir_read+0x4a>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800fb10:	2304      	movs	r3, #4
 800fb12:	75fb      	strb	r3, [r7, #23]
 800fb14:	e096      	b.n	800fc44 <dir_read+0x178>
		}
#if _FS_EXFAT
		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800fb16:	693b      	ldr	r3, [r7, #16]
 800fb18:	781b      	ldrb	r3, [r3, #0]
 800fb1a:	2b04      	cmp	r3, #4
 800fb1c:	d118      	bne.n	800fb50 <dir_read+0x84>
			if (_USE_LABEL && vol) {
				if (c == 0x83) break;	/* Volume label entry? */
			} else {
				if (c == 0x85) {		/* Start of the file entry block? */
 800fb1e:	7dbb      	ldrb	r3, [r7, #22]
 800fb20:	2b85      	cmp	r3, #133	@ 0x85
 800fb22:	d179      	bne.n	800fc18 <dir_read+0x14c>
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 800fb24:	687b      	ldr	r3, [r7, #4]
 800fb26:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800fb28:	687b      	ldr	r3, [r7, #4]
 800fb2a:	64da      	str	r2, [r3, #76]	@ 0x4c
					res = load_xdir(dp);	/* Load the entry block */
 800fb2c:	6878      	ldr	r0, [r7, #4]
 800fb2e:	f7ff fe17 	bl	800f760 <load_xdir>
 800fb32:	4603      	mov	r3, r0
 800fb34:	75fb      	strb	r3, [r7, #23]
					if (res == FR_OK) {
 800fb36:	7dfb      	ldrb	r3, [r7, #23]
 800fb38:	2b00      	cmp	r3, #0
 800fb3a:	d17e      	bne.n	800fc3a <dir_read+0x16e>
						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 800fb3c:	693b      	ldr	r3, [r7, #16]
 800fb3e:	695b      	ldr	r3, [r3, #20]
 800fb40:	3304      	adds	r3, #4
 800fb42:	781b      	ldrb	r3, [r3, #0]
 800fb44:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800fb48:	b2da      	uxtb	r2, r3
 800fb4a:	687b      	ldr	r3, [r7, #4]
 800fb4c:	719a      	strb	r2, [r3, #6]
					}
					break;
 800fb4e:	e074      	b.n	800fc3a <dir_read+0x16e>
				}
			}
		} else
#endif
		{	/* On the FAT12/16/32 volume */
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800fb50:	687b      	ldr	r3, [r7, #4]
 800fb52:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fb54:	330b      	adds	r3, #11
 800fb56:	781b      	ldrb	r3, [r3, #0]
 800fb58:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800fb5c:	73fb      	strb	r3, [r7, #15]
 800fb5e:	687b      	ldr	r3, [r7, #4]
 800fb60:	7bfa      	ldrb	r2, [r7, #15]
 800fb62:	719a      	strb	r2, [r3, #6]
#if _USE_LFN != 0	/* LFN configuration */
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800fb64:	7dbb      	ldrb	r3, [r7, #22]
 800fb66:	2be5      	cmp	r3, #229	@ 0xe5
 800fb68:	d00e      	beq.n	800fb88 <dir_read+0xbc>
 800fb6a:	7dbb      	ldrb	r3, [r7, #22]
 800fb6c:	2b2e      	cmp	r3, #46	@ 0x2e
 800fb6e:	d00b      	beq.n	800fb88 <dir_read+0xbc>
 800fb70:	7bfb      	ldrb	r3, [r7, #15]
 800fb72:	f023 0320 	bic.w	r3, r3, #32
 800fb76:	2b08      	cmp	r3, #8
 800fb78:	bf0c      	ite	eq
 800fb7a:	2301      	moveq	r3, #1
 800fb7c:	2300      	movne	r3, #0
 800fb7e:	b2db      	uxtb	r3, r3
 800fb80:	461a      	mov	r2, r3
 800fb82:	683b      	ldr	r3, [r7, #0]
 800fb84:	4293      	cmp	r3, r2
 800fb86:	d002      	beq.n	800fb8e <dir_read+0xc2>
				ord = 0xFF;
 800fb88:	23ff      	movs	r3, #255	@ 0xff
 800fb8a:	757b      	strb	r3, [r7, #21]
 800fb8c:	e044      	b.n	800fc18 <dir_read+0x14c>
			} else {
				if (a == AM_LFN) {			/* An LFN entry is found */
 800fb8e:	7bfb      	ldrb	r3, [r7, #15]
 800fb90:	2b0f      	cmp	r3, #15
 800fb92:	d12f      	bne.n	800fbf4 <dir_read+0x128>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800fb94:	7dbb      	ldrb	r3, [r7, #22]
 800fb96:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800fb9a:	2b00      	cmp	r3, #0
 800fb9c:	d00d      	beq.n	800fbba <dir_read+0xee>
						sum = dp->dir[LDIR_Chksum];
 800fb9e:	687b      	ldr	r3, [r7, #4]
 800fba0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fba2:	7b5b      	ldrb	r3, [r3, #13]
 800fba4:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;
 800fba6:	7dbb      	ldrb	r3, [r7, #22]
 800fba8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800fbac:	75bb      	strb	r3, [r7, #22]
 800fbae:	7dbb      	ldrb	r3, [r7, #22]
 800fbb0:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;
 800fbb2:	687b      	ldr	r3, [r7, #4]
 800fbb4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800fbb6:	687b      	ldr	r3, [r7, #4]
 800fbb8:	64da      	str	r2, [r3, #76]	@ 0x4c
					}
					/* Check LFN validity and capture it */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800fbba:	7dba      	ldrb	r2, [r7, #22]
 800fbbc:	7d7b      	ldrb	r3, [r7, #21]
 800fbbe:	429a      	cmp	r2, r3
 800fbc0:	d115      	bne.n	800fbee <dir_read+0x122>
 800fbc2:	687b      	ldr	r3, [r7, #4]
 800fbc4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fbc6:	330d      	adds	r3, #13
 800fbc8:	781b      	ldrb	r3, [r3, #0]
 800fbca:	7d3a      	ldrb	r2, [r7, #20]
 800fbcc:	429a      	cmp	r2, r3
 800fbce:	d10e      	bne.n	800fbee <dir_read+0x122>
 800fbd0:	693b      	ldr	r3, [r7, #16]
 800fbd2:	691a      	ldr	r2, [r3, #16]
 800fbd4:	687b      	ldr	r3, [r7, #4]
 800fbd6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fbd8:	4619      	mov	r1, r3
 800fbda:	4610      	mov	r0, r2
 800fbdc:	f7ff fbde 	bl	800f39c <pick_lfn>
 800fbe0:	4603      	mov	r3, r0
 800fbe2:	2b00      	cmp	r3, #0
 800fbe4:	d003      	beq.n	800fbee <dir_read+0x122>
 800fbe6:	7d7b      	ldrb	r3, [r7, #21]
 800fbe8:	3b01      	subs	r3, #1
 800fbea:	b2db      	uxtb	r3, r3
 800fbec:	e000      	b.n	800fbf0 <dir_read+0x124>
 800fbee:	23ff      	movs	r3, #255	@ 0xff
 800fbf0:	757b      	strb	r3, [r7, #21]
 800fbf2:	e011      	b.n	800fc18 <dir_read+0x14c>
				} else {					/* An SFN entry is found */
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800fbf4:	7d7b      	ldrb	r3, [r7, #21]
 800fbf6:	2b00      	cmp	r3, #0
 800fbf8:	d109      	bne.n	800fc0e <dir_read+0x142>
 800fbfa:	687b      	ldr	r3, [r7, #4]
 800fbfc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fbfe:	4618      	mov	r0, r3
 800fc00:	f7ff fd26 	bl	800f650 <sum_sfn>
 800fc04:	4603      	mov	r3, r0
 800fc06:	461a      	mov	r2, r3
 800fc08:	7d3b      	ldrb	r3, [r7, #20]
 800fc0a:	4293      	cmp	r3, r2
 800fc0c:	d017      	beq.n	800fc3e <dir_read+0x172>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800fc0e:	687b      	ldr	r3, [r7, #4]
 800fc10:	f04f 32ff 	mov.w	r2, #4294967295
 800fc14:	64da      	str	r2, [r3, #76]	@ 0x4c
					}
					break;
 800fc16:	e012      	b.n	800fc3e <dir_read+0x172>
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
 800fc18:	2100      	movs	r1, #0
 800fc1a:	6878      	ldr	r0, [r7, #4]
 800fc1c:	f7ff f9cd 	bl	800efba <dir_next>
 800fc20:	4603      	mov	r3, r0
 800fc22:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800fc24:	7dfb      	ldrb	r3, [r7, #23]
 800fc26:	2b00      	cmp	r3, #0
 800fc28:	d10b      	bne.n	800fc42 <dir_read+0x176>
	while (dp->sect) {
 800fc2a:	687b      	ldr	r3, [r7, #4]
 800fc2c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800fc2e:	2b00      	cmp	r3, #0
 800fc30:	f47f af5b 	bne.w	800faea <dir_read+0x1e>
 800fc34:	e006      	b.n	800fc44 <dir_read+0x178>
		if (res != FR_OK) break;
 800fc36:	bf00      	nop
 800fc38:	e004      	b.n	800fc44 <dir_read+0x178>
					break;
 800fc3a:	bf00      	nop
 800fc3c:	e002      	b.n	800fc44 <dir_read+0x178>
					break;
 800fc3e:	bf00      	nop
 800fc40:	e000      	b.n	800fc44 <dir_read+0x178>
		if (res != FR_OK) break;
 800fc42:	bf00      	nop
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800fc44:	7dfb      	ldrb	r3, [r7, #23]
 800fc46:	2b00      	cmp	r3, #0
 800fc48:	d002      	beq.n	800fc50 <dir_read+0x184>
 800fc4a:	687b      	ldr	r3, [r7, #4]
 800fc4c:	2200      	movs	r2, #0
 800fc4e:	639a      	str	r2, [r3, #56]	@ 0x38
	return res;
 800fc50:	7dfb      	ldrb	r3, [r7, #23]
}
 800fc52:	4618      	mov	r0, r3
 800fc54:	3718      	adds	r7, #24
 800fc56:	46bd      	mov	sp, r7
 800fc58:	bd80      	pop	{r7, pc}

0800fc5a <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object with the file name */
)
{
 800fc5a:	b590      	push	{r4, r7, lr}
 800fc5c:	b089      	sub	sp, #36	@ 0x24
 800fc5e:	af00      	add	r7, sp, #0
 800fc60:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800fc62:	687b      	ldr	r3, [r7, #4]
 800fc64:	681b      	ldr	r3, [r3, #0]
 800fc66:	60fb      	str	r3, [r7, #12]
	BYTE c;
#if _USE_LFN != 0
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800fc68:	2100      	movs	r1, #0
 800fc6a:	6878      	ldr	r0, [r7, #4]
 800fc6c:	f7ff f911 	bl	800ee92 <dir_sdi>
 800fc70:	4603      	mov	r3, r0
 800fc72:	77fb      	strb	r3, [r7, #31]
	if (res != FR_OK) return res;
 800fc74:	7ffb      	ldrb	r3, [r7, #31]
 800fc76:	2b00      	cmp	r3, #0
 800fc78:	d001      	beq.n	800fc7e <dir_find+0x24>
 800fc7a:	7ffb      	ldrb	r3, [r7, #31]
 800fc7c:	e113      	b.n	800fea6 <dir_find+0x24c>
#if _FS_EXFAT
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800fc7e:	68fb      	ldr	r3, [r7, #12]
 800fc80:	781b      	ldrb	r3, [r3, #0]
 800fc82:	2b04      	cmp	r3, #4
 800fc84:	d165      	bne.n	800fd52 <dir_find+0xf8>
		BYTE nc;
		UINT di, ni;
		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
 800fc86:	68fb      	ldr	r3, [r7, #12]
 800fc88:	691b      	ldr	r3, [r3, #16]
 800fc8a:	4618      	mov	r0, r3
 800fc8c:	f7ff fd33 	bl	800f6f6 <xname_sum>
 800fc90:	4603      	mov	r3, r0
 800fc92:	813b      	strh	r3, [r7, #8]

		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
 800fc94:	e050      	b.n	800fd38 <dir_find+0xde>
#if _MAX_LFN < 255
			if (fs->dirbuf[XDIR_NumName] > _MAX_LFN) continue;			/* Skip comparison if inaccessible object name */
#endif
			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 800fc96:	68fb      	ldr	r3, [r7, #12]
 800fc98:	695b      	ldr	r3, [r3, #20]
 800fc9a:	3324      	adds	r3, #36	@ 0x24
 800fc9c:	4618      	mov	r0, r3
 800fc9e:	f7fd fe57 	bl	800d950 <ld_word>
 800fca2:	4603      	mov	r3, r0
 800fca4:	461a      	mov	r2, r3
 800fca6:	893b      	ldrh	r3, [r7, #8]
 800fca8:	4293      	cmp	r3, r2
 800fcaa:	d144      	bne.n	800fd36 <dir_find+0xdc>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800fcac:	68fb      	ldr	r3, [r7, #12]
 800fcae:	695b      	ldr	r3, [r3, #20]
 800fcb0:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
 800fcb4:	76fb      	strb	r3, [r7, #27]
 800fcb6:	2340      	movs	r3, #64	@ 0x40
 800fcb8:	617b      	str	r3, [r7, #20]
 800fcba:	2300      	movs	r3, #0
 800fcbc:	613b      	str	r3, [r7, #16]
 800fcbe:	e029      	b.n	800fd14 <dir_find+0xba>
				if ((di % SZDIRE) == 0) di += 2;
 800fcc0:	697b      	ldr	r3, [r7, #20]
 800fcc2:	f003 031f 	and.w	r3, r3, #31
 800fcc6:	2b00      	cmp	r3, #0
 800fcc8:	d102      	bne.n	800fcd0 <dir_find+0x76>
 800fcca:	697b      	ldr	r3, [r7, #20]
 800fccc:	3302      	adds	r3, #2
 800fcce:	617b      	str	r3, [r7, #20]
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800fcd0:	68fb      	ldr	r3, [r7, #12]
 800fcd2:	695a      	ldr	r2, [r3, #20]
 800fcd4:	697b      	ldr	r3, [r7, #20]
 800fcd6:	4413      	add	r3, r2
 800fcd8:	4618      	mov	r0, r3
 800fcda:	f7fd fe39 	bl	800d950 <ld_word>
 800fcde:	4603      	mov	r3, r0
 800fce0:	4618      	mov	r0, r3
 800fce2:	f003 f845 	bl	8012d70 <ff_wtoupper>
 800fce6:	4603      	mov	r3, r0
 800fce8:	461c      	mov	r4, r3
 800fcea:	68fb      	ldr	r3, [r7, #12]
 800fcec:	691a      	ldr	r2, [r3, #16]
 800fcee:	693b      	ldr	r3, [r7, #16]
 800fcf0:	005b      	lsls	r3, r3, #1
 800fcf2:	4413      	add	r3, r2
 800fcf4:	881b      	ldrh	r3, [r3, #0]
 800fcf6:	4618      	mov	r0, r3
 800fcf8:	f003 f83a 	bl	8012d70 <ff_wtoupper>
 800fcfc:	4603      	mov	r3, r0
 800fcfe:	429c      	cmp	r4, r3
 800fd00:	d10c      	bne.n	800fd1c <dir_find+0xc2>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800fd02:	7efb      	ldrb	r3, [r7, #27]
 800fd04:	3b01      	subs	r3, #1
 800fd06:	76fb      	strb	r3, [r7, #27]
 800fd08:	697b      	ldr	r3, [r7, #20]
 800fd0a:	3302      	adds	r3, #2
 800fd0c:	617b      	str	r3, [r7, #20]
 800fd0e:	693b      	ldr	r3, [r7, #16]
 800fd10:	3301      	adds	r3, #1
 800fd12:	613b      	str	r3, [r7, #16]
 800fd14:	7efb      	ldrb	r3, [r7, #27]
 800fd16:	2b00      	cmp	r3, #0
 800fd18:	d1d2      	bne.n	800fcc0 <dir_find+0x66>
 800fd1a:	e000      	b.n	800fd1e <dir_find+0xc4>
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800fd1c:	bf00      	nop
			}
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 800fd1e:	7efb      	ldrb	r3, [r7, #27]
 800fd20:	2b00      	cmp	r3, #0
 800fd22:	d109      	bne.n	800fd38 <dir_find+0xde>
 800fd24:	68fb      	ldr	r3, [r7, #12]
 800fd26:	691a      	ldr	r2, [r3, #16]
 800fd28:	693b      	ldr	r3, [r7, #16]
 800fd2a:	005b      	lsls	r3, r3, #1
 800fd2c:	4413      	add	r3, r2
 800fd2e:	881b      	ldrh	r3, [r3, #0]
 800fd30:	2b00      	cmp	r3, #0
 800fd32:	d00b      	beq.n	800fd4c <dir_find+0xf2>
 800fd34:	e000      	b.n	800fd38 <dir_find+0xde>
			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 800fd36:	bf00      	nop
		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
 800fd38:	2100      	movs	r1, #0
 800fd3a:	6878      	ldr	r0, [r7, #4]
 800fd3c:	f7ff fec6 	bl	800facc <dir_read>
 800fd40:	4603      	mov	r3, r0
 800fd42:	77fb      	strb	r3, [r7, #31]
 800fd44:	7ffb      	ldrb	r3, [r7, #31]
 800fd46:	2b00      	cmp	r3, #0
 800fd48:	d0a5      	beq.n	800fc96 <dir_find+0x3c>
 800fd4a:	e000      	b.n	800fd4e <dir_find+0xf4>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 800fd4c:	bf00      	nop
		}
		return res;
 800fd4e:	7ffb      	ldrb	r3, [r7, #31]
 800fd50:	e0a9      	b.n	800fea6 <dir_find+0x24c>
	}
#endif
	/* On the FAT12/16/32 volume */
#if _USE_LFN != 0
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800fd52:	23ff      	movs	r3, #255	@ 0xff
 800fd54:	773b      	strb	r3, [r7, #28]
 800fd56:	7f3b      	ldrb	r3, [r7, #28]
 800fd58:	777b      	strb	r3, [r7, #29]
 800fd5a:	687b      	ldr	r3, [r7, #4]
 800fd5c:	f04f 32ff 	mov.w	r2, #4294967295
 800fd60:	64da      	str	r2, [r3, #76]	@ 0x4c
#endif
	do {
		res = move_window(fs, dp->sect);
 800fd62:	687b      	ldr	r3, [r7, #4]
 800fd64:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800fd66:	4619      	mov	r1, r3
 800fd68:	68f8      	ldr	r0, [r7, #12]
 800fd6a:	f7fe fa05 	bl	800e178 <move_window>
 800fd6e:	4603      	mov	r3, r0
 800fd70:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) break;
 800fd72:	7ffb      	ldrb	r3, [r7, #31]
 800fd74:	2b00      	cmp	r3, #0
 800fd76:	f040 8090 	bne.w	800fe9a <dir_find+0x240>
		c = dp->dir[DIR_Name];
 800fd7a:	687b      	ldr	r3, [r7, #4]
 800fd7c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fd7e:	781b      	ldrb	r3, [r3, #0]
 800fd80:	77bb      	strb	r3, [r7, #30]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800fd82:	7fbb      	ldrb	r3, [r7, #30]
 800fd84:	2b00      	cmp	r3, #0
 800fd86:	d102      	bne.n	800fd8e <dir_find+0x134>
 800fd88:	2304      	movs	r3, #4
 800fd8a:	77fb      	strb	r3, [r7, #31]
 800fd8c:	e08a      	b.n	800fea4 <dir_find+0x24a>
#if _USE_LFN != 0	/* LFN configuration */
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800fd8e:	687b      	ldr	r3, [r7, #4]
 800fd90:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fd92:	330b      	adds	r3, #11
 800fd94:	781b      	ldrb	r3, [r3, #0]
 800fd96:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800fd9a:	72fb      	strb	r3, [r7, #11]
 800fd9c:	687b      	ldr	r3, [r7, #4]
 800fd9e:	7afa      	ldrb	r2, [r7, #11]
 800fda0:	719a      	strb	r2, [r3, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800fda2:	7fbb      	ldrb	r3, [r7, #30]
 800fda4:	2be5      	cmp	r3, #229	@ 0xe5
 800fda6:	d007      	beq.n	800fdb8 <dir_find+0x15e>
 800fda8:	7afb      	ldrb	r3, [r7, #11]
 800fdaa:	f003 0308 	and.w	r3, r3, #8
 800fdae:	2b00      	cmp	r3, #0
 800fdb0:	d009      	beq.n	800fdc6 <dir_find+0x16c>
 800fdb2:	7afb      	ldrb	r3, [r7, #11]
 800fdb4:	2b0f      	cmp	r3, #15
 800fdb6:	d006      	beq.n	800fdc6 <dir_find+0x16c>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800fdb8:	23ff      	movs	r3, #255	@ 0xff
 800fdba:	777b      	strb	r3, [r7, #29]
 800fdbc:	687b      	ldr	r3, [r7, #4]
 800fdbe:	f04f 32ff 	mov.w	r2, #4294967295
 800fdc2:	64da      	str	r2, [r3, #76]	@ 0x4c
 800fdc4:	e05e      	b.n	800fe84 <dir_find+0x22a>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 800fdc6:	7afb      	ldrb	r3, [r7, #11]
 800fdc8:	2b0f      	cmp	r3, #15
 800fdca:	d136      	bne.n	800fe3a <dir_find+0x1e0>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800fdcc:	687b      	ldr	r3, [r7, #4]
 800fdce:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800fdd2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800fdd6:	2b00      	cmp	r3, #0
 800fdd8:	d154      	bne.n	800fe84 <dir_find+0x22a>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800fdda:	7fbb      	ldrb	r3, [r7, #30]
 800fddc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800fde0:	2b00      	cmp	r3, #0
 800fde2:	d00d      	beq.n	800fe00 <dir_find+0x1a6>
						sum = dp->dir[LDIR_Chksum];
 800fde4:	687b      	ldr	r3, [r7, #4]
 800fde6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fde8:	7b5b      	ldrb	r3, [r3, #13]
 800fdea:	773b      	strb	r3, [r7, #28]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800fdec:	7fbb      	ldrb	r3, [r7, #30]
 800fdee:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800fdf2:	77bb      	strb	r3, [r7, #30]
 800fdf4:	7fbb      	ldrb	r3, [r7, #30]
 800fdf6:	777b      	strb	r3, [r7, #29]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800fdf8:	687b      	ldr	r3, [r7, #4]
 800fdfa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800fdfc:	687b      	ldr	r3, [r7, #4]
 800fdfe:	64da      	str	r2, [r3, #76]	@ 0x4c
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800fe00:	7fba      	ldrb	r2, [r7, #30]
 800fe02:	7f7b      	ldrb	r3, [r7, #29]
 800fe04:	429a      	cmp	r2, r3
 800fe06:	d115      	bne.n	800fe34 <dir_find+0x1da>
 800fe08:	687b      	ldr	r3, [r7, #4]
 800fe0a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fe0c:	330d      	adds	r3, #13
 800fe0e:	781b      	ldrb	r3, [r3, #0]
 800fe10:	7f3a      	ldrb	r2, [r7, #28]
 800fe12:	429a      	cmp	r2, r3
 800fe14:	d10e      	bne.n	800fe34 <dir_find+0x1da>
 800fe16:	68fb      	ldr	r3, [r7, #12]
 800fe18:	691a      	ldr	r2, [r3, #16]
 800fe1a:	687b      	ldr	r3, [r7, #4]
 800fe1c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fe1e:	4619      	mov	r1, r3
 800fe20:	4610      	mov	r0, r2
 800fe22:	f7ff fa4b 	bl	800f2bc <cmp_lfn>
 800fe26:	4603      	mov	r3, r0
 800fe28:	2b00      	cmp	r3, #0
 800fe2a:	d003      	beq.n	800fe34 <dir_find+0x1da>
 800fe2c:	7f7b      	ldrb	r3, [r7, #29]
 800fe2e:	3b01      	subs	r3, #1
 800fe30:	b2db      	uxtb	r3, r3
 800fe32:	e000      	b.n	800fe36 <dir_find+0x1dc>
 800fe34:	23ff      	movs	r3, #255	@ 0xff
 800fe36:	777b      	strb	r3, [r7, #29]
 800fe38:	e024      	b.n	800fe84 <dir_find+0x22a>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800fe3a:	7f7b      	ldrb	r3, [r7, #29]
 800fe3c:	2b00      	cmp	r3, #0
 800fe3e:	d109      	bne.n	800fe54 <dir_find+0x1fa>
 800fe40:	687b      	ldr	r3, [r7, #4]
 800fe42:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fe44:	4618      	mov	r0, r3
 800fe46:	f7ff fc03 	bl	800f650 <sum_sfn>
 800fe4a:	4603      	mov	r3, r0
 800fe4c:	461a      	mov	r2, r3
 800fe4e:	7f3b      	ldrb	r3, [r7, #28]
 800fe50:	4293      	cmp	r3, r2
 800fe52:	d024      	beq.n	800fe9e <dir_find+0x244>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800fe54:	687b      	ldr	r3, [r7, #4]
 800fe56:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800fe5a:	f003 0301 	and.w	r3, r3, #1
 800fe5e:	2b00      	cmp	r3, #0
 800fe60:	d10a      	bne.n	800fe78 <dir_find+0x21e>
 800fe62:	687b      	ldr	r3, [r7, #4]
 800fe64:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 800fe66:	687b      	ldr	r3, [r7, #4]
 800fe68:	3340      	adds	r3, #64	@ 0x40
 800fe6a:	220b      	movs	r2, #11
 800fe6c:	4619      	mov	r1, r3
 800fe6e:	f7fd ff90 	bl	800dd92 <mem_cmp>
 800fe72:	4603      	mov	r3, r0
 800fe74:	2b00      	cmp	r3, #0
 800fe76:	d014      	beq.n	800fea2 <dir_find+0x248>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800fe78:	23ff      	movs	r3, #255	@ 0xff
 800fe7a:	777b      	strb	r3, [r7, #29]
 800fe7c:	687b      	ldr	r3, [r7, #4]
 800fe7e:	f04f 32ff 	mov.w	r2, #4294967295
 800fe82:	64da      	str	r2, [r3, #76]	@ 0x4c
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
		res = dir_next(dp, 0);	/* Next entry */
 800fe84:	2100      	movs	r1, #0
 800fe86:	6878      	ldr	r0, [r7, #4]
 800fe88:	f7ff f897 	bl	800efba <dir_next>
 800fe8c:	4603      	mov	r3, r0
 800fe8e:	77fb      	strb	r3, [r7, #31]
	} while (res == FR_OK);
 800fe90:	7ffb      	ldrb	r3, [r7, #31]
 800fe92:	2b00      	cmp	r3, #0
 800fe94:	f43f af65 	beq.w	800fd62 <dir_find+0x108>
 800fe98:	e004      	b.n	800fea4 <dir_find+0x24a>
		if (res != FR_OK) break;
 800fe9a:	bf00      	nop
 800fe9c:	e002      	b.n	800fea4 <dir_find+0x24a>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800fe9e:	bf00      	nop
 800fea0:	e000      	b.n	800fea4 <dir_find+0x24a>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800fea2:	bf00      	nop

	return res;
 800fea4:	7ffb      	ldrb	r3, [r7, #31]
}
 800fea6:	4618      	mov	r0, r3
 800fea8:	3724      	adds	r7, #36	@ 0x24
 800feaa:	46bd      	mov	sp, r7
 800feac:	bd90      	pop	{r4, r7, pc}
	...

0800feb0 <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 800feb0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800feb4:	b0a0      	sub	sp, #128	@ 0x80
 800feb6:	af00      	add	r7, sp, #0
 800feb8:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800feba:	687b      	ldr	r3, [r7, #4]
 800febc:	681b      	ldr	r3, [r3, #0]
 800febe:	66fb      	str	r3, [r7, #108]	@ 0x6c
#if _USE_LFN != 0	/* LFN configuration */
	UINT n, nlen, nent;
	BYTE sn[12], sum;


	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800fec0:	687b      	ldr	r3, [r7, #4]
 800fec2:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800fec6:	f003 03a0 	and.w	r3, r3, #160	@ 0xa0
 800feca:	2b00      	cmp	r3, #0
 800fecc:	d001      	beq.n	800fed2 <dir_register+0x22>
 800fece:	2306      	movs	r3, #6
 800fed0:	e192      	b.n	80101f8 <dir_register+0x348>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800fed2:	2300      	movs	r3, #0
 800fed4:	677b      	str	r3, [r7, #116]	@ 0x74
 800fed6:	e002      	b.n	800fede <dir_register+0x2e>
 800fed8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800feda:	3301      	adds	r3, #1
 800fedc:	677b      	str	r3, [r7, #116]	@ 0x74
 800fede:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800fee0:	691a      	ldr	r2, [r3, #16]
 800fee2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800fee4:	005b      	lsls	r3, r3, #1
 800fee6:	4413      	add	r3, r2
 800fee8:	881b      	ldrh	r3, [r3, #0]
 800feea:	2b00      	cmp	r3, #0
 800feec:	d1f4      	bne.n	800fed8 <dir_register+0x28>

#if _FS_EXFAT
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800feee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800fef0:	781b      	ldrb	r3, [r3, #0]
 800fef2:	2b04      	cmp	r3, #4
 800fef4:	f040 80a3 	bne.w	801003e <dir_register+0x18e>
		DIR dj;

		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 800fef8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800fefa:	330e      	adds	r3, #14
 800fefc:	4aa4      	ldr	r2, [pc, #656]	@ (8010190 <dir_register+0x2e0>)
 800fefe:	fba2 2303 	umull	r2, r3, r2, r3
 800ff02:	08db      	lsrs	r3, r3, #3
 800ff04:	3302      	adds	r3, #2
 800ff06:	673b      	str	r3, [r7, #112]	@ 0x70
		res = dir_alloc(dp, nent);		/* Allocate entries */
 800ff08:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 800ff0a:	6878      	ldr	r0, [r7, #4]
 800ff0c:	f7ff f93b 	bl	800f186 <dir_alloc>
 800ff10:	4603      	mov	r3, r0
 800ff12:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
		if (res != FR_OK) return res;
 800ff16:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ff1a:	2b00      	cmp	r3, #0
 800ff1c:	d002      	beq.n	800ff24 <dir_register+0x74>
 800ff1e:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ff22:	e169      	b.n	80101f8 <dir_register+0x348>
		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
 800ff24:	687b      	ldr	r3, [r7, #4]
 800ff26:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800ff28:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800ff2a:	3b01      	subs	r3, #1
 800ff2c:	015b      	lsls	r3, r3, #5
 800ff2e:	1ad2      	subs	r2, r2, r3
 800ff30:	687b      	ldr	r3, [r7, #4]
 800ff32:	64da      	str	r2, [r3, #76]	@ 0x4c

		if (dp->obj.sclust != 0 && (dp->obj.stat & 4)) {	/* Has the sub-directory been stretched? */
 800ff34:	687b      	ldr	r3, [r7, #4]
 800ff36:	689b      	ldr	r3, [r3, #8]
 800ff38:	2b00      	cmp	r3, #0
 800ff3a:	d076      	beq.n	801002a <dir_register+0x17a>
 800ff3c:	687b      	ldr	r3, [r7, #4]
 800ff3e:	79db      	ldrb	r3, [r3, #7]
 800ff40:	f003 0304 	and.w	r3, r3, #4
 800ff44:	2b00      	cmp	r3, #0
 800ff46:	d070      	beq.n	801002a <dir_register+0x17a>
			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase the directory size by cluster size */
 800ff48:	687b      	ldr	r3, [r7, #4]
 800ff4a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800ff4e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 800ff50:	8949      	ldrh	r1, [r1, #10]
 800ff52:	4608      	mov	r0, r1
 800ff54:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 800ff56:	8989      	ldrh	r1, [r1, #12]
 800ff58:	fb00 f101 	mul.w	r1, r0, r1
 800ff5c:	2000      	movs	r0, #0
 800ff5e:	460c      	mov	r4, r1
 800ff60:	4605      	mov	r5, r0
 800ff62:	eb12 0804 	adds.w	r8, r2, r4
 800ff66:	eb43 0905 	adc.w	r9, r3, r5
 800ff6a:	687b      	ldr	r3, [r7, #4]
 800ff6c:	e9c3 8904 	strd	r8, r9, [r3, #16]
			res = fill_first_frag(&dp->obj);				/* Fill first fragment on the FAT if needed */
 800ff70:	687b      	ldr	r3, [r7, #4]
 800ff72:	4618      	mov	r0, r3
 800ff74:	f7fe fd2c 	bl	800e9d0 <fill_first_frag>
 800ff78:	4603      	mov	r3, r0
 800ff7a:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res != FR_OK) return res;
 800ff7e:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d002      	beq.n	800ff8c <dir_register+0xdc>
 800ff86:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ff8a:	e135      	b.n	80101f8 <dir_register+0x348>
			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 800ff8c:	6878      	ldr	r0, [r7, #4]
 800ff8e:	687b      	ldr	r3, [r7, #4]
 800ff90:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ff92:	f04f 32ff 	mov.w	r2, #4294967295
 800ff96:	4619      	mov	r1, r3
 800ff98:	f7fe fd49 	bl	800ea2e <fill_last_frag>
 800ff9c:	4603      	mov	r3, r0
 800ff9e:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res != FR_OK) return res;
 800ffa2:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ffa6:	2b00      	cmp	r3, #0
 800ffa8:	d002      	beq.n	800ffb0 <dir_register+0x100>
 800ffaa:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ffae:	e123      	b.n	80101f8 <dir_register+0x348>
			res = load_obj_dir(&dj, &dp->obj);				/* Load the object status */
 800ffb0:	687a      	ldr	r2, [r7, #4]
 800ffb2:	f107 0308 	add.w	r3, r7, #8
 800ffb6:	4611      	mov	r1, r2
 800ffb8:	4618      	mov	r0, r3
 800ffba:	f7ff fc8f 	bl	800f8dc <load_obj_dir>
 800ffbe:	4603      	mov	r3, r0
 800ffc0:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res != FR_OK) return res;
 800ffc4:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ffc8:	2b00      	cmp	r3, #0
 800ffca:	d002      	beq.n	800ffd2 <dir_register+0x122>
 800ffcc:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 800ffd0:	e112      	b.n	80101f8 <dir_register+0x348>
			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
 800ffd2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800ffd4:	695b      	ldr	r3, [r3, #20]
 800ffd6:	f103 0138 	add.w	r1, r3, #56	@ 0x38
 800ffda:	687b      	ldr	r3, [r7, #4]
 800ffdc:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800ffe0:	4608      	mov	r0, r1
 800ffe2:	f7fd fe12 	bl	800dc0a <st_qword>
			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
 800ffe6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800ffe8:	695b      	ldr	r3, [r3, #20]
 800ffea:	f103 0128 	add.w	r1, r3, #40	@ 0x28
 800ffee:	687b      	ldr	r3, [r7, #4]
 800fff0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800fff4:	4608      	mov	r0, r1
 800fff6:	f7fd fe08 	bl	800dc0a <st_qword>
			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
 800fffa:	687b      	ldr	r3, [r7, #4]
 800fffc:	79da      	ldrb	r2, [r3, #7]
 800fffe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010000:	695b      	ldr	r3, [r3, #20]
 8010002:	3321      	adds	r3, #33	@ 0x21
 8010004:	f042 0201 	orr.w	r2, r2, #1
 8010008:	b2d2      	uxtb	r2, r2
 801000a:	701a      	strb	r2, [r3, #0]
			res = store_xdir(&dj);							/* Store the object status */
 801000c:	f107 0308 	add.w	r3, r7, #8
 8010010:	4618      	mov	r0, r3
 8010012:	f7ff fc99 	bl	800f948 <store_xdir>
 8010016:	4603      	mov	r3, r0
 8010018:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res != FR_OK) return res;
 801001c:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8010020:	2b00      	cmp	r3, #0
 8010022:	d002      	beq.n	801002a <dir_register+0x17a>
 8010024:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8010028:	e0e6      	b.n	80101f8 <dir_register+0x348>
		}

		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
 801002a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801002c:	695a      	ldr	r2, [r3, #20]
 801002e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010030:	691b      	ldr	r3, [r3, #16]
 8010032:	4619      	mov	r1, r3
 8010034:	4610      	mov	r0, r2
 8010036:	f7ff fce2 	bl	800f9fe <create_xdir>
		return FR_OK;
 801003a:	2300      	movs	r3, #0
 801003c:	e0dc      	b.n	80101f8 <dir_register+0x348>
	}
#endif
	/* On the FAT12/16/32 volume */
	mem_cpy(sn, dp->fn, 12);
 801003e:	687b      	ldr	r3, [r7, #4]
 8010040:	f103 0140 	add.w	r1, r3, #64	@ 0x40
 8010044:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
 8010048:	220c      	movs	r2, #12
 801004a:	4618      	mov	r0, r3
 801004c:	f7fd fe65 	bl	800dd1a <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8010050:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8010054:	f003 0301 	and.w	r3, r3, #1
 8010058:	2b00      	cmp	r3, #0
 801005a:	d033      	beq.n	80100c4 <dir_register+0x214>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 801005c:	687b      	ldr	r3, [r7, #4]
 801005e:	2240      	movs	r2, #64	@ 0x40
 8010060:	f883 204b 	strb.w	r2, [r3, #75]	@ 0x4b
		for (n = 1; n < 100; n++) {
 8010064:	2301      	movs	r3, #1
 8010066:	67bb      	str	r3, [r7, #120]	@ 0x78
 8010068:	e016      	b.n	8010098 <dir_register+0x1e8>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 801006a:	687b      	ldr	r3, [r7, #4]
 801006c:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 8010070:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010072:	691a      	ldr	r2, [r3, #16]
 8010074:	f107 015c 	add.w	r1, r7, #92	@ 0x5c
 8010078:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801007a:	f7ff fa5b 	bl	800f534 <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 801007e:	6878      	ldr	r0, [r7, #4]
 8010080:	f7ff fdeb 	bl	800fc5a <dir_find>
 8010084:	4603      	mov	r3, r0
 8010086:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res != FR_OK) break;
 801008a:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 801008e:	2b00      	cmp	r3, #0
 8010090:	d106      	bne.n	80100a0 <dir_register+0x1f0>
		for (n = 1; n < 100; n++) {
 8010092:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8010094:	3301      	adds	r3, #1
 8010096:	67bb      	str	r3, [r7, #120]	@ 0x78
 8010098:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801009a:	2b63      	cmp	r3, #99	@ 0x63
 801009c:	d9e5      	bls.n	801006a <dir_register+0x1ba>
 801009e:	e000      	b.n	80100a2 <dir_register+0x1f2>
			if (res != FR_OK) break;
 80100a0:	bf00      	nop
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 80100a2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80100a4:	2b64      	cmp	r3, #100	@ 0x64
 80100a6:	d101      	bne.n	80100ac <dir_register+0x1fc>
 80100a8:	2307      	movs	r3, #7
 80100aa:	e0a5      	b.n	80101f8 <dir_register+0x348>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 80100ac:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80100b0:	2b04      	cmp	r3, #4
 80100b2:	d002      	beq.n	80100ba <dir_register+0x20a>
 80100b4:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80100b8:	e09e      	b.n	80101f8 <dir_register+0x348>
		dp->fn[NSFLAG] = sn[NSFLAG];
 80100ba:	f897 2067 	ldrb.w	r2, [r7, #103]	@ 0x67
 80100be:	687b      	ldr	r3, [r7, #4]
 80100c0:	f883 204b 	strb.w	r2, [r3, #75]	@ 0x4b
	}

	/* Create an SFN with/without LFNs. */
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 80100c4:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 80100c8:	f003 0302 	and.w	r3, r3, #2
 80100cc:	2b00      	cmp	r3, #0
 80100ce:	d007      	beq.n	80100e0 <dir_register+0x230>
 80100d0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80100d2:	330c      	adds	r3, #12
 80100d4:	4a2f      	ldr	r2, [pc, #188]	@ (8010194 <dir_register+0x2e4>)
 80100d6:	fba2 2303 	umull	r2, r3, r2, r3
 80100da:	089b      	lsrs	r3, r3, #2
 80100dc:	3301      	adds	r3, #1
 80100de:	e000      	b.n	80100e2 <dir_register+0x232>
 80100e0:	2301      	movs	r3, #1
 80100e2:	673b      	str	r3, [r7, #112]	@ 0x70
	res = dir_alloc(dp, nent);		/* Allocate entries */
 80100e4:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80100e6:	6878      	ldr	r0, [r7, #4]
 80100e8:	f7ff f84d 	bl	800f186 <dir_alloc>
 80100ec:	4603      	mov	r3, r0
 80100ee:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 80100f2:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80100f6:	2b00      	cmp	r3, #0
 80100f8:	d14f      	bne.n	801019a <dir_register+0x2ea>
 80100fa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80100fc:	3b01      	subs	r3, #1
 80100fe:	673b      	str	r3, [r7, #112]	@ 0x70
 8010100:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8010102:	2b00      	cmp	r3, #0
 8010104:	d049      	beq.n	801019a <dir_register+0x2ea>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 8010106:	687b      	ldr	r3, [r7, #4]
 8010108:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801010a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801010c:	015b      	lsls	r3, r3, #5
 801010e:	1ad3      	subs	r3, r2, r3
 8010110:	4619      	mov	r1, r3
 8010112:	6878      	ldr	r0, [r7, #4]
 8010114:	f7fe febd 	bl	800ee92 <dir_sdi>
 8010118:	4603      	mov	r3, r0
 801011a:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
		if (res == FR_OK) {
 801011e:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8010122:	2b00      	cmp	r3, #0
 8010124:	d139      	bne.n	801019a <dir_register+0x2ea>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 8010126:	687b      	ldr	r3, [r7, #4]
 8010128:	3340      	adds	r3, #64	@ 0x40
 801012a:	4618      	mov	r0, r3
 801012c:	f7ff fa90 	bl	800f650 <sum_sfn>
 8010130:	4603      	mov	r3, r0
 8010132:	f887 306b 	strb.w	r3, [r7, #107]	@ 0x6b
			do {					/* Store LFN entries in bottom first */
				res = move_window(fs, dp->sect);
 8010136:	687b      	ldr	r3, [r7, #4]
 8010138:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801013a:	4619      	mov	r1, r3
 801013c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801013e:	f7fe f81b 	bl	800e178 <move_window>
 8010142:	4603      	mov	r3, r0
 8010144:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
				if (res != FR_OK) break;
 8010148:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 801014c:	2b00      	cmp	r3, #0
 801014e:	d123      	bne.n	8010198 <dir_register+0x2e8>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 8010150:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010152:	6918      	ldr	r0, [r3, #16]
 8010154:	687b      	ldr	r3, [r7, #4]
 8010156:	6bd9      	ldr	r1, [r3, #60]	@ 0x3c
 8010158:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801015a:	b2da      	uxtb	r2, r3
 801015c:	f897 306b 	ldrb.w	r3, [r7, #107]	@ 0x6b
 8010160:	f7ff f980 	bl	800f464 <put_lfn>
				fs->wflag = 1;
 8010164:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010166:	2201      	movs	r2, #1
 8010168:	70da      	strb	r2, [r3, #3]
				res = dir_next(dp, 0);	/* Next entry */
 801016a:	2100      	movs	r1, #0
 801016c:	6878      	ldr	r0, [r7, #4]
 801016e:	f7fe ff24 	bl	800efba <dir_next>
 8010172:	4603      	mov	r3, r0
 8010174:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			} while (res == FR_OK && --nent);
 8010178:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 801017c:	2b00      	cmp	r3, #0
 801017e:	d10c      	bne.n	801019a <dir_register+0x2ea>
 8010180:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8010182:	3b01      	subs	r3, #1
 8010184:	673b      	str	r3, [r7, #112]	@ 0x70
 8010186:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8010188:	2b00      	cmp	r3, #0
 801018a:	d1d4      	bne.n	8010136 <dir_register+0x286>
 801018c:	e005      	b.n	801019a <dir_register+0x2ea>
 801018e:	bf00      	nop
 8010190:	88888889 	.word	0x88888889
 8010194:	4ec4ec4f 	.word	0x4ec4ec4f
				if (res != FR_OK) break;
 8010198:	bf00      	nop
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
 801019a:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 801019e:	2b00      	cmp	r3, #0
 80101a0:	d128      	bne.n	80101f4 <dir_register+0x344>
		res = move_window(fs, dp->sect);
 80101a2:	687b      	ldr	r3, [r7, #4]
 80101a4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80101a6:	4619      	mov	r1, r3
 80101a8:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80101aa:	f7fd ffe5 	bl	800e178 <move_window>
 80101ae:	4603      	mov	r3, r0
 80101b0:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
		if (res == FR_OK) {
 80101b4:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80101b8:	2b00      	cmp	r3, #0
 80101ba:	d11b      	bne.n	80101f4 <dir_register+0x344>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 80101bc:	687b      	ldr	r3, [r7, #4]
 80101be:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80101c0:	2220      	movs	r2, #32
 80101c2:	2100      	movs	r1, #0
 80101c4:	4618      	mov	r0, r3
 80101c6:	f7fd fdc9 	bl	800dd5c <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 80101ca:	687b      	ldr	r3, [r7, #4]
 80101cc:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 80101ce:	687b      	ldr	r3, [r7, #4]
 80101d0:	3340      	adds	r3, #64	@ 0x40
 80101d2:	220b      	movs	r2, #11
 80101d4:	4619      	mov	r1, r3
 80101d6:	f7fd fda0 	bl	800dd1a <mem_cpy>
#if _USE_LFN != 0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 80101da:	687b      	ldr	r3, [r7, #4]
 80101dc:	f893 204b 	ldrb.w	r2, [r3, #75]	@ 0x4b
 80101e0:	687b      	ldr	r3, [r7, #4]
 80101e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80101e4:	330c      	adds	r3, #12
 80101e6:	f002 0218 	and.w	r2, r2, #24
 80101ea:	b2d2      	uxtb	r2, r2
 80101ec:	701a      	strb	r2, [r3, #0]
#endif
			fs->wflag = 1;
 80101ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80101f0:	2201      	movs	r2, #1
 80101f2:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
 80101f4:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
}
 80101f8:	4618      	mov	r0, r3
 80101fa:	3780      	adds	r7, #128	@ 0x80
 80101fc:	46bd      	mov	sp, r7
 80101fe:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8010202:	bf00      	nop

08010204 <dir_remove>:

static
FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
	DIR* dp				/* Directory object pointing the entry to be removed */
)
{
 8010204:	b580      	push	{r7, lr}
 8010206:	b086      	sub	sp, #24
 8010208:	af00      	add	r7, sp, #0
 801020a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 801020c:	687b      	ldr	r3, [r7, #4]
 801020e:	681b      	ldr	r3, [r3, #0]
 8010210:	613b      	str	r3, [r7, #16]
#if _USE_LFN != 0	/* LFN configuration */
	DWORD last = dp->dptr;
 8010212:	687b      	ldr	r3, [r7, #4]
 8010214:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8010216:	60fb      	str	r3, [r7, #12]

	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8010218:	687b      	ldr	r3, [r7, #4]
 801021a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801021c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010220:	d007      	beq.n	8010232 <dir_remove+0x2e>
 8010222:	687b      	ldr	r3, [r7, #4]
 8010224:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8010226:	4619      	mov	r1, r3
 8010228:	6878      	ldr	r0, [r7, #4]
 801022a:	f7fe fe32 	bl	800ee92 <dir_sdi>
 801022e:	4603      	mov	r3, r0
 8010230:	e000      	b.n	8010234 <dir_remove+0x30>
 8010232:	2300      	movs	r3, #0
 8010234:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8010236:	7dfb      	ldrb	r3, [r7, #23]
 8010238:	2b00      	cmp	r3, #0
 801023a:	d136      	bne.n	80102aa <dir_remove+0xa6>
		do {
			res = move_window(fs, dp->sect);
 801023c:	687b      	ldr	r3, [r7, #4]
 801023e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010240:	4619      	mov	r1, r3
 8010242:	6938      	ldr	r0, [r7, #16]
 8010244:	f7fd ff98 	bl	800e178 <move_window>
 8010248:	4603      	mov	r3, r0
 801024a:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 801024c:	7dfb      	ldrb	r3, [r7, #23]
 801024e:	2b00      	cmp	r3, #0
 8010250:	d123      	bne.n	801029a <dir_remove+0x96>
			/* Mark an entry 'deleted' */
			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8010252:	693b      	ldr	r3, [r7, #16]
 8010254:	781b      	ldrb	r3, [r3, #0]
 8010256:	2b04      	cmp	r3, #4
 8010258:	d109      	bne.n	801026e <dir_remove+0x6a>
				dp->dir[XDIR_Type] &= 0x7F;
 801025a:	687b      	ldr	r3, [r7, #4]
 801025c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801025e:	781a      	ldrb	r2, [r3, #0]
 8010260:	687b      	ldr	r3, [r7, #4]
 8010262:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010264:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 8010268:	b2d2      	uxtb	r2, r2
 801026a:	701a      	strb	r2, [r3, #0]
 801026c:	e003      	b.n	8010276 <dir_remove+0x72>
			} else {									/* On the FAT12/16/32 volume */
				dp->dir[DIR_Name] = DDEM;
 801026e:	687b      	ldr	r3, [r7, #4]
 8010270:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010272:	22e5      	movs	r2, #229	@ 0xe5
 8010274:	701a      	strb	r2, [r3, #0]
			}
			fs->wflag = 1;
 8010276:	693b      	ldr	r3, [r7, #16]
 8010278:	2201      	movs	r2, #1
 801027a:	70da      	strb	r2, [r3, #3]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 801027c:	687b      	ldr	r3, [r7, #4]
 801027e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8010280:	68fa      	ldr	r2, [r7, #12]
 8010282:	429a      	cmp	r2, r3
 8010284:	d90b      	bls.n	801029e <dir_remove+0x9a>
			res = dir_next(dp, 0);	/* Next entry */
 8010286:	2100      	movs	r1, #0
 8010288:	6878      	ldr	r0, [r7, #4]
 801028a:	f7fe fe96 	bl	800efba <dir_next>
 801028e:	4603      	mov	r3, r0
 8010290:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);
 8010292:	7dfb      	ldrb	r3, [r7, #23]
 8010294:	2b00      	cmp	r3, #0
 8010296:	d0d1      	beq.n	801023c <dir_remove+0x38>
 8010298:	e002      	b.n	80102a0 <dir_remove+0x9c>
			if (res != FR_OK) break;
 801029a:	bf00      	nop
 801029c:	e000      	b.n	80102a0 <dir_remove+0x9c>
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 801029e:	bf00      	nop
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 80102a0:	7dfb      	ldrb	r3, [r7, #23]
 80102a2:	2b04      	cmp	r3, #4
 80102a4:	d101      	bne.n	80102aa <dir_remove+0xa6>
 80102a6:	2302      	movs	r3, #2
 80102a8:	75fb      	strb	r3, [r7, #23]
		dp->dir[DIR_Name] = DDEM;
		fs->wflag = 1;
	}
#endif

	return res;
 80102aa:	7dfb      	ldrb	r3, [r7, #23]
}
 80102ac:	4618      	mov	r0, r3
 80102ae:	3718      	adds	r7, #24
 80102b0:	46bd      	mov	sp, r7
 80102b2:	bd80      	pop	{r7, pc}

080102b4 <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
 80102b4:	b580      	push	{r7, lr}
 80102b6:	b08a      	sub	sp, #40	@ 0x28
 80102b8:	af00      	add	r7, sp, #0
 80102ba:	6078      	str	r0, [r7, #4]
 80102bc:	6039      	str	r1, [r7, #0]
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 80102be:	683b      	ldr	r3, [r7, #0]
 80102c0:	681b      	ldr	r3, [r3, #0]
 80102c2:	613b      	str	r3, [r7, #16]
 80102c4:	687b      	ldr	r3, [r7, #4]
 80102c6:	681b      	ldr	r3, [r3, #0]
 80102c8:	691b      	ldr	r3, [r3, #16]
 80102ca:	60fb      	str	r3, [r7, #12]
 80102cc:	2300      	movs	r3, #0
 80102ce:	617b      	str	r3, [r7, #20]
 80102d0:	697b      	ldr	r3, [r7, #20]
 80102d2:	61bb      	str	r3, [r7, #24]
	for (;;) {
		w = p[si++];					/* Get a character */
 80102d4:	69bb      	ldr	r3, [r7, #24]
 80102d6:	1c5a      	adds	r2, r3, #1
 80102d8:	61ba      	str	r2, [r7, #24]
 80102da:	693a      	ldr	r2, [r7, #16]
 80102dc:	4413      	add	r3, r2
 80102de:	781b      	ldrb	r3, [r3, #0]
 80102e0:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (w < ' ') break;				/* Break if end of the path name */
 80102e2:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80102e4:	2b1f      	cmp	r3, #31
 80102e6:	d940      	bls.n	801036a <create_name+0xb6>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 80102e8:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80102ea:	2b2f      	cmp	r3, #47	@ 0x2f
 80102ec:	d006      	beq.n	80102fc <create_name+0x48>
 80102ee:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80102f0:	2b5c      	cmp	r3, #92	@ 0x5c
 80102f2:	d110      	bne.n	8010316 <create_name+0x62>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 80102f4:	e002      	b.n	80102fc <create_name+0x48>
 80102f6:	69bb      	ldr	r3, [r7, #24]
 80102f8:	3301      	adds	r3, #1
 80102fa:	61bb      	str	r3, [r7, #24]
 80102fc:	693a      	ldr	r2, [r7, #16]
 80102fe:	69bb      	ldr	r3, [r7, #24]
 8010300:	4413      	add	r3, r2
 8010302:	781b      	ldrb	r3, [r3, #0]
 8010304:	2b2f      	cmp	r3, #47	@ 0x2f
 8010306:	d0f6      	beq.n	80102f6 <create_name+0x42>
 8010308:	693a      	ldr	r2, [r7, #16]
 801030a:	69bb      	ldr	r3, [r7, #24]
 801030c:	4413      	add	r3, r2
 801030e:	781b      	ldrb	r3, [r3, #0]
 8010310:	2b5c      	cmp	r3, #92	@ 0x5c
 8010312:	d0f0      	beq.n	80102f6 <create_name+0x42>
			break;
 8010314:	e02a      	b.n	801036c <create_name+0xb8>
		}
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8010316:	697b      	ldr	r3, [r7, #20]
 8010318:	2bfe      	cmp	r3, #254	@ 0xfe
 801031a:	d901      	bls.n	8010320 <create_name+0x6c>
 801031c:	2306      	movs	r3, #6
 801031e:	e17d      	b.n	801061c <create_name+0x368>
#if !_LFN_UNICODE
		w &= 0xFF;
 8010320:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010322:	b2db      	uxtb	r3, r3
 8010324:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8010326:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010328:	2101      	movs	r1, #1
 801032a:	4618      	mov	r0, r3
 801032c:	f002 fce4 	bl	8012cf8 <ff_convert>
 8010330:	4603      	mov	r3, r0
 8010332:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8010334:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010336:	2b00      	cmp	r3, #0
 8010338:	d101      	bne.n	801033e <create_name+0x8a>
 801033a:	2306      	movs	r3, #6
 801033c:	e16e      	b.n	801061c <create_name+0x368>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 801033e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010340:	2b7f      	cmp	r3, #127	@ 0x7f
 8010342:	d809      	bhi.n	8010358 <create_name+0xa4>
 8010344:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010346:	4619      	mov	r1, r3
 8010348:	488d      	ldr	r0, [pc, #564]	@ (8010580 <create_name+0x2cc>)
 801034a:	f7fd fd49 	bl	800dde0 <chk_chr>
 801034e:	4603      	mov	r3, r0
 8010350:	2b00      	cmp	r3, #0
 8010352:	d001      	beq.n	8010358 <create_name+0xa4>
 8010354:	2306      	movs	r3, #6
 8010356:	e161      	b.n	801061c <create_name+0x368>
		lfn[di++] = w;					/* Store the Unicode character */
 8010358:	697b      	ldr	r3, [r7, #20]
 801035a:	1c5a      	adds	r2, r3, #1
 801035c:	617a      	str	r2, [r7, #20]
 801035e:	005b      	lsls	r3, r3, #1
 8010360:	68fa      	ldr	r2, [r7, #12]
 8010362:	4413      	add	r3, r2
 8010364:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8010366:	801a      	strh	r2, [r3, #0]
		w = p[si++];					/* Get a character */
 8010368:	e7b4      	b.n	80102d4 <create_name+0x20>
		if (w < ' ') break;				/* Break if end of the path name */
 801036a:	bf00      	nop
	}
	*path = &p[si];						/* Return pointer to the next segment */
 801036c:	693a      	ldr	r2, [r7, #16]
 801036e:	69bb      	ldr	r3, [r7, #24]
 8010370:	441a      	add	r2, r3
 8010372:	683b      	ldr	r3, [r7, #0]
 8010374:	601a      	str	r2, [r3, #0]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8010376:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010378:	2b1f      	cmp	r3, #31
 801037a:	d801      	bhi.n	8010380 <create_name+0xcc>
 801037c:	2304      	movs	r3, #4
 801037e:	e000      	b.n	8010382 <create_name+0xce>
 8010380:	2300      	movs	r3, #0
 8010382:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8010386:	e011      	b.n	80103ac <create_name+0xf8>
		w = lfn[di - 1];
 8010388:	697b      	ldr	r3, [r7, #20]
 801038a:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 801038e:	3b01      	subs	r3, #1
 8010390:	005b      	lsls	r3, r3, #1
 8010392:	68fa      	ldr	r2, [r7, #12]
 8010394:	4413      	add	r3, r2
 8010396:	881b      	ldrh	r3, [r3, #0]
 8010398:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (w != ' ' && w != '.') break;
 801039a:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 801039c:	2b20      	cmp	r3, #32
 801039e:	d002      	beq.n	80103a6 <create_name+0xf2>
 80103a0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80103a2:	2b2e      	cmp	r3, #46	@ 0x2e
 80103a4:	d106      	bne.n	80103b4 <create_name+0x100>
		di--;
 80103a6:	697b      	ldr	r3, [r7, #20]
 80103a8:	3b01      	subs	r3, #1
 80103aa:	617b      	str	r3, [r7, #20]
	while (di) {						/* Snip off trailing spaces and dots if exist */
 80103ac:	697b      	ldr	r3, [r7, #20]
 80103ae:	2b00      	cmp	r3, #0
 80103b0:	d1ea      	bne.n	8010388 <create_name+0xd4>
 80103b2:	e000      	b.n	80103b6 <create_name+0x102>
		if (w != ' ' && w != '.') break;
 80103b4:	bf00      	nop
	}
	lfn[di] = 0;						/* LFN is created */
 80103b6:	697b      	ldr	r3, [r7, #20]
 80103b8:	005b      	lsls	r3, r3, #1
 80103ba:	68fa      	ldr	r2, [r7, #12]
 80103bc:	4413      	add	r3, r2
 80103be:	2200      	movs	r2, #0
 80103c0:	801a      	strh	r2, [r3, #0]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 80103c2:	697b      	ldr	r3, [r7, #20]
 80103c4:	2b00      	cmp	r3, #0
 80103c6:	d101      	bne.n	80103cc <create_name+0x118>
 80103c8:	2306      	movs	r3, #6
 80103ca:	e127      	b.n	801061c <create_name+0x368>

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 80103cc:	687b      	ldr	r3, [r7, #4]
 80103ce:	3340      	adds	r3, #64	@ 0x40
 80103d0:	220b      	movs	r2, #11
 80103d2:	2120      	movs	r1, #32
 80103d4:	4618      	mov	r0, r3
 80103d6:	f7fd fcc1 	bl	800dd5c <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 80103da:	2300      	movs	r3, #0
 80103dc:	61bb      	str	r3, [r7, #24]
 80103de:	e002      	b.n	80103e6 <create_name+0x132>
 80103e0:	69bb      	ldr	r3, [r7, #24]
 80103e2:	3301      	adds	r3, #1
 80103e4:	61bb      	str	r3, [r7, #24]
 80103e6:	69bb      	ldr	r3, [r7, #24]
 80103e8:	005b      	lsls	r3, r3, #1
 80103ea:	68fa      	ldr	r2, [r7, #12]
 80103ec:	4413      	add	r3, r2
 80103ee:	881b      	ldrh	r3, [r3, #0]
 80103f0:	2b20      	cmp	r3, #32
 80103f2:	d0f5      	beq.n	80103e0 <create_name+0x12c>
 80103f4:	69bb      	ldr	r3, [r7, #24]
 80103f6:	005b      	lsls	r3, r3, #1
 80103f8:	68fa      	ldr	r2, [r7, #12]
 80103fa:	4413      	add	r3, r2
 80103fc:	881b      	ldrh	r3, [r3, #0]
 80103fe:	2b2e      	cmp	r3, #46	@ 0x2e
 8010400:	d0ee      	beq.n	80103e0 <create_name+0x12c>
	if (si) cf |= NS_LOSS | NS_LFN;
 8010402:	69bb      	ldr	r3, [r7, #24]
 8010404:	2b00      	cmp	r3, #0
 8010406:	d009      	beq.n	801041c <create_name+0x168>
 8010408:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801040c:	f043 0303 	orr.w	r3, r3, #3
 8010410:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8010414:	e002      	b.n	801041c <create_name+0x168>
 8010416:	697b      	ldr	r3, [r7, #20]
 8010418:	3b01      	subs	r3, #1
 801041a:	617b      	str	r3, [r7, #20]
 801041c:	697b      	ldr	r3, [r7, #20]
 801041e:	2b00      	cmp	r3, #0
 8010420:	d009      	beq.n	8010436 <create_name+0x182>
 8010422:	697b      	ldr	r3, [r7, #20]
 8010424:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 8010428:	3b01      	subs	r3, #1
 801042a:	005b      	lsls	r3, r3, #1
 801042c:	68fa      	ldr	r2, [r7, #12]
 801042e:	4413      	add	r3, r2
 8010430:	881b      	ldrh	r3, [r3, #0]
 8010432:	2b2e      	cmp	r3, #46	@ 0x2e
 8010434:	d1ef      	bne.n	8010416 <create_name+0x162>

	i = b = 0; ni = 8;
 8010436:	2300      	movs	r3, #0
 8010438:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 801043c:	2300      	movs	r3, #0
 801043e:	623b      	str	r3, [r7, #32]
 8010440:	2308      	movs	r3, #8
 8010442:	61fb      	str	r3, [r7, #28]
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8010444:	69bb      	ldr	r3, [r7, #24]
 8010446:	1c5a      	adds	r2, r3, #1
 8010448:	61ba      	str	r2, [r7, #24]
 801044a:	005b      	lsls	r3, r3, #1
 801044c:	68fa      	ldr	r2, [r7, #12]
 801044e:	4413      	add	r3, r2
 8010450:	881b      	ldrh	r3, [r3, #0]
 8010452:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (!w) break;					/* Break on end of the LFN */
 8010454:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010456:	2b00      	cmp	r3, #0
 8010458:	f000 8090 	beq.w	801057c <create_name+0x2c8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 801045c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 801045e:	2b20      	cmp	r3, #32
 8010460:	d006      	beq.n	8010470 <create_name+0x1bc>
 8010462:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010464:	2b2e      	cmp	r3, #46	@ 0x2e
 8010466:	d10a      	bne.n	801047e <create_name+0x1ca>
 8010468:	69ba      	ldr	r2, [r7, #24]
 801046a:	697b      	ldr	r3, [r7, #20]
 801046c:	429a      	cmp	r2, r3
 801046e:	d006      	beq.n	801047e <create_name+0x1ca>
			cf |= NS_LOSS | NS_LFN; continue;
 8010470:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010474:	f043 0303 	orr.w	r3, r3, #3
 8010478:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 801047c:	e07d      	b.n	801057a <create_name+0x2c6>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 801047e:	6a3a      	ldr	r2, [r7, #32]
 8010480:	69fb      	ldr	r3, [r7, #28]
 8010482:	429a      	cmp	r2, r3
 8010484:	d203      	bcs.n	801048e <create_name+0x1da>
 8010486:	69ba      	ldr	r2, [r7, #24]
 8010488:	697b      	ldr	r3, [r7, #20]
 801048a:	429a      	cmp	r2, r3
 801048c:	d123      	bne.n	80104d6 <create_name+0x222>
			if (ni == 11) {				/* Long extension */
 801048e:	69fb      	ldr	r3, [r7, #28]
 8010490:	2b0b      	cmp	r3, #11
 8010492:	d106      	bne.n	80104a2 <create_name+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
 8010494:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010498:	f043 0303 	orr.w	r3, r3, #3
 801049c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 80104a0:	e075      	b.n	801058e <create_name+0x2da>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 80104a2:	69ba      	ldr	r2, [r7, #24]
 80104a4:	697b      	ldr	r3, [r7, #20]
 80104a6:	429a      	cmp	r2, r3
 80104a8:	d005      	beq.n	80104b6 <create_name+0x202>
 80104aa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80104ae:	f043 0303 	orr.w	r3, r3, #3
 80104b2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (si > di) break;			/* No extension */
 80104b6:	69ba      	ldr	r2, [r7, #24]
 80104b8:	697b      	ldr	r3, [r7, #20]
 80104ba:	429a      	cmp	r2, r3
 80104bc:	d866      	bhi.n	801058c <create_name+0x2d8>
			si = di; i = 8; ni = 11;	/* Enter extension section */
 80104be:	697b      	ldr	r3, [r7, #20]
 80104c0:	61bb      	str	r3, [r7, #24]
 80104c2:	2308      	movs	r3, #8
 80104c4:	623b      	str	r3, [r7, #32]
 80104c6:	230b      	movs	r3, #11
 80104c8:	61fb      	str	r3, [r7, #28]
			b <<= 2; continue;
 80104ca:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80104ce:	009b      	lsls	r3, r3, #2
 80104d0:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 80104d4:	e051      	b.n	801057a <create_name+0x2c6>
		}

		if (w >= 0x80) {				/* Non ASCII character */
 80104d6:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80104d8:	2b7f      	cmp	r3, #127	@ 0x7f
 80104da:	d914      	bls.n	8010506 <create_name+0x252>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 80104dc:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80104de:	2100      	movs	r1, #0
 80104e0:	4618      	mov	r0, r3
 80104e2:	f002 fc09 	bl	8012cf8 <ff_convert>
 80104e6:	4603      	mov	r3, r0
 80104e8:	84bb      	strh	r3, [r7, #36]	@ 0x24
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 80104ea:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80104ec:	2b00      	cmp	r3, #0
 80104ee:	d004      	beq.n	80104fa <create_name+0x246>
 80104f0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80104f2:	3b80      	subs	r3, #128	@ 0x80
 80104f4:	4a23      	ldr	r2, [pc, #140]	@ (8010584 <create_name+0x2d0>)
 80104f6:	5cd3      	ldrb	r3, [r2, r3]
 80104f8:	84bb      	strh	r3, [r7, #36]	@ 0x24
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 80104fa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80104fe:	f043 0302 	orr.w	r3, r3, #2
 8010502:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8010506:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010508:	2b00      	cmp	r3, #0
 801050a:	d007      	beq.n	801051c <create_name+0x268>
 801050c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 801050e:	4619      	mov	r1, r3
 8010510:	481d      	ldr	r0, [pc, #116]	@ (8010588 <create_name+0x2d4>)
 8010512:	f7fd fc65 	bl	800dde0 <chk_chr>
 8010516:	4603      	mov	r3, r0
 8010518:	2b00      	cmp	r3, #0
 801051a:	d008      	beq.n	801052e <create_name+0x27a>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 801051c:	235f      	movs	r3, #95	@ 0x5f
 801051e:	84bb      	strh	r3, [r7, #36]	@ 0x24
 8010520:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010524:	f043 0303 	orr.w	r3, r3, #3
 8010528:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 801052c:	e01b      	b.n	8010566 <create_name+0x2b2>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 801052e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010530:	2b40      	cmp	r3, #64	@ 0x40
 8010532:	d909      	bls.n	8010548 <create_name+0x294>
 8010534:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010536:	2b5a      	cmp	r3, #90	@ 0x5a
 8010538:	d806      	bhi.n	8010548 <create_name+0x294>
					b |= 2;
 801053a:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 801053e:	f043 0302 	orr.w	r3, r3, #2
 8010542:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8010546:	e00e      	b.n	8010566 <create_name+0x2b2>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 8010548:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 801054a:	2b60      	cmp	r3, #96	@ 0x60
 801054c:	d90b      	bls.n	8010566 <create_name+0x2b2>
 801054e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010550:	2b7a      	cmp	r3, #122	@ 0x7a
 8010552:	d808      	bhi.n	8010566 <create_name+0x2b2>
						b |= 1; w -= 0x20;
 8010554:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8010558:	f043 0301 	orr.w	r3, r3, #1
 801055c:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8010560:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8010562:	3b20      	subs	r3, #32
 8010564:	84bb      	strh	r3, [r7, #36]	@ 0x24
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8010566:	6a3b      	ldr	r3, [r7, #32]
 8010568:	1c5a      	adds	r2, r3, #1
 801056a:	623a      	str	r2, [r7, #32]
 801056c:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 801056e:	b2d1      	uxtb	r1, r2
 8010570:	687a      	ldr	r2, [r7, #4]
 8010572:	4413      	add	r3, r2
 8010574:	460a      	mov	r2, r1
 8010576:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
		w = lfn[si++];					/* Get an LFN character */
 801057a:	e763      	b.n	8010444 <create_name+0x190>
		if (!w) break;					/* Break on end of the LFN */
 801057c:	bf00      	nop
 801057e:	e006      	b.n	801058e <create_name+0x2da>
 8010580:	08030250 	.word	0x08030250
 8010584:	080319f8 	.word	0x080319f8
 8010588:	0803025c 	.word	0x0803025c
			if (si > di) break;			/* No extension */
 801058c:	bf00      	nop
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 801058e:	687b      	ldr	r3, [r7, #4]
 8010590:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8010594:	2be5      	cmp	r3, #229	@ 0xe5
 8010596:	d103      	bne.n	80105a0 <create_name+0x2ec>
 8010598:	687b      	ldr	r3, [r7, #4]
 801059a:	2205      	movs	r2, #5
 801059c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

	if (ni == 8) b <<= 2;
 80105a0:	69fb      	ldr	r3, [r7, #28]
 80105a2:	2b08      	cmp	r3, #8
 80105a4:	d104      	bne.n	80105b0 <create_name+0x2fc>
 80105a6:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80105aa:	009b      	lsls	r3, r3, #2
 80105ac:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 80105b0:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80105b4:	f003 030c 	and.w	r3, r3, #12
 80105b8:	2b0c      	cmp	r3, #12
 80105ba:	d005      	beq.n	80105c8 <create_name+0x314>
 80105bc:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80105c0:	f003 0303 	and.w	r3, r3, #3
 80105c4:	2b03      	cmp	r3, #3
 80105c6:	d105      	bne.n	80105d4 <create_name+0x320>
 80105c8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80105cc:	f043 0302 	orr.w	r3, r3, #2
 80105d0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 80105d4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80105d8:	f003 0302 	and.w	r3, r3, #2
 80105dc:	2b00      	cmp	r3, #0
 80105de:	d117      	bne.n	8010610 <create_name+0x35c>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 80105e0:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80105e4:	f003 0303 	and.w	r3, r3, #3
 80105e8:	2b01      	cmp	r3, #1
 80105ea:	d105      	bne.n	80105f8 <create_name+0x344>
 80105ec:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80105f0:	f043 0310 	orr.w	r3, r3, #16
 80105f4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 80105f8:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80105fc:	f003 030c 	and.w	r3, r3, #12
 8010600:	2b04      	cmp	r3, #4
 8010602:	d105      	bne.n	8010610 <create_name+0x35c>
 8010604:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010608:	f043 0308 	orr.w	r3, r3, #8
 801060c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8010610:	687b      	ldr	r3, [r7, #4]
 8010612:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 8010616:	f883 204b 	strb.w	r2, [r3, #75]	@ 0x4b

	return FR_OK;
 801061a:	2300      	movs	r3, #0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

	return FR_OK;
#endif /* _USE_LFN != 0 */
}
 801061c:	4618      	mov	r0, r3
 801061e:	3728      	adds	r7, #40	@ 0x28
 8010620:	46bd      	mov	sp, r7
 8010622:	bd80      	pop	{r7, pc}

08010624 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8010624:	b580      	push	{r7, lr}
 8010626:	b086      	sub	sp, #24
 8010628:	af00      	add	r7, sp, #0
 801062a:	6078      	str	r0, [r7, #4]
 801062c:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
 801062e:	687b      	ldr	r3, [r7, #4]
 8010630:	613b      	str	r3, [r7, #16]
	FATFS *fs = obj->fs;
 8010632:	693b      	ldr	r3, [r7, #16]
 8010634:	681b      	ldr	r3, [r3, #0]
 8010636:	60fb      	str	r3, [r7, #12]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8010638:	e002      	b.n	8010640 <follow_path+0x1c>
 801063a:	683b      	ldr	r3, [r7, #0]
 801063c:	3301      	adds	r3, #1
 801063e:	603b      	str	r3, [r7, #0]
 8010640:	683b      	ldr	r3, [r7, #0]
 8010642:	781b      	ldrb	r3, [r3, #0]
 8010644:	2b2f      	cmp	r3, #47	@ 0x2f
 8010646:	d0f8      	beq.n	801063a <follow_path+0x16>
 8010648:	683b      	ldr	r3, [r7, #0]
 801064a:	781b      	ldrb	r3, [r3, #0]
 801064c:	2b5c      	cmp	r3, #92	@ 0x5c
 801064e:	d0f4      	beq.n	801063a <follow_path+0x16>
		obj->sclust = 0;					/* Start from root directory */
 8010650:	693b      	ldr	r3, [r7, #16]
 8010652:	2200      	movs	r2, #0
 8010654:	609a      	str	r2, [r3, #8]
	}
#if _FS_EXFAT
	obj->n_frag = 0;	/* Invalidate last fragment counter of the object */
 8010656:	693b      	ldr	r3, [r7, #16]
 8010658:	2200      	movs	r2, #0
 801065a:	61da      	str	r2, [r3, #28]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 801065c:	683b      	ldr	r3, [r7, #0]
 801065e:	781b      	ldrb	r3, [r3, #0]
 8010660:	2b1f      	cmp	r3, #31
 8010662:	d80a      	bhi.n	801067a <follow_path+0x56>
		dp->fn[NSFLAG] = NS_NONAME;
 8010664:	687b      	ldr	r3, [r7, #4]
 8010666:	2280      	movs	r2, #128	@ 0x80
 8010668:	f883 204b 	strb.w	r2, [r3, #75]	@ 0x4b
		res = dir_sdi(dp, 0);
 801066c:	2100      	movs	r1, #0
 801066e:	6878      	ldr	r0, [r7, #4]
 8010670:	f7fe fc0f 	bl	800ee92 <dir_sdi>
 8010674:	4603      	mov	r3, r0
 8010676:	75fb      	strb	r3, [r7, #23]
 8010678:	e07d      	b.n	8010776 <follow_path+0x152>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 801067a:	463b      	mov	r3, r7
 801067c:	4619      	mov	r1, r3
 801067e:	6878      	ldr	r0, [r7, #4]
 8010680:	f7ff fe18 	bl	80102b4 <create_name>
 8010684:	4603      	mov	r3, r0
 8010686:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 8010688:	7dfb      	ldrb	r3, [r7, #23]
 801068a:	2b00      	cmp	r3, #0
 801068c:	d16e      	bne.n	801076c <follow_path+0x148>
			res = dir_find(dp);				/* Find an object with the segment name */
 801068e:	6878      	ldr	r0, [r7, #4]
 8010690:	f7ff fae3 	bl	800fc5a <dir_find>
 8010694:	4603      	mov	r3, r0
 8010696:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
 8010698:	687b      	ldr	r3, [r7, #4]
 801069a:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 801069e:	72fb      	strb	r3, [r7, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 80106a0:	7dfb      	ldrb	r3, [r7, #23]
 80106a2:	2b00      	cmp	r3, #0
 80106a4:	d00a      	beq.n	80106bc <follow_path+0x98>
				if (res == FR_NO_FILE) {	/* Object is not found */
 80106a6:	7dfb      	ldrb	r3, [r7, #23]
 80106a8:	2b04      	cmp	r3, #4
 80106aa:	d161      	bne.n	8010770 <follow_path+0x14c>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80106ac:	7afb      	ldrb	r3, [r7, #11]
 80106ae:	f003 0304 	and.w	r3, r3, #4
 80106b2:	2b00      	cmp	r3, #0
 80106b4:	d15c      	bne.n	8010770 <follow_path+0x14c>
 80106b6:	2305      	movs	r3, #5
 80106b8:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
 80106ba:	e059      	b.n	8010770 <follow_path+0x14c>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 80106bc:	7afb      	ldrb	r3, [r7, #11]
 80106be:	f003 0304 	and.w	r3, r3, #4
 80106c2:	2b00      	cmp	r3, #0
 80106c4:	d156      	bne.n	8010774 <follow_path+0x150>
			/* Get into the sub-directory */
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 80106c6:	693b      	ldr	r3, [r7, #16]
 80106c8:	799b      	ldrb	r3, [r3, #6]
 80106ca:	f003 0310 	and.w	r3, r3, #16
 80106ce:	2b00      	cmp	r3, #0
 80106d0:	d102      	bne.n	80106d8 <follow_path+0xb4>
				res = FR_NO_PATH; break;
 80106d2:	2305      	movs	r3, #5
 80106d4:	75fb      	strb	r3, [r7, #23]
 80106d6:	e04e      	b.n	8010776 <follow_path+0x152>
			}
#if _FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
 80106d8:	68fb      	ldr	r3, [r7, #12]
 80106da:	781b      	ldrb	r3, [r3, #0]
 80106dc:	2b04      	cmp	r3, #4
 80106de:	d130      	bne.n	8010742 <follow_path+0x11e>
				obj->c_scl = obj->sclust;
 80106e0:	693b      	ldr	r3, [r7, #16]
 80106e2:	689a      	ldr	r2, [r3, #8]
 80106e4:	693b      	ldr	r3, [r7, #16]
 80106e6:	621a      	str	r2, [r3, #32]
				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
 80106e8:	693b      	ldr	r3, [r7, #16]
 80106ea:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80106ee:	4613      	mov	r3, r2
 80106f0:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80106f4:	693a      	ldr	r2, [r7, #16]
 80106f6:	79d2      	ldrb	r2, [r2, #7]
 80106f8:	431a      	orrs	r2, r3
 80106fa:	693b      	ldr	r3, [r7, #16]
 80106fc:	625a      	str	r2, [r3, #36]	@ 0x24
				obj->c_ofs = dp->blk_ofs;
 80106fe:	687b      	ldr	r3, [r7, #4]
 8010700:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8010702:	693b      	ldr	r3, [r7, #16]
 8010704:	629a      	str	r2, [r3, #40]	@ 0x28
				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
 8010706:	68fb      	ldr	r3, [r7, #12]
 8010708:	695b      	ldr	r3, [r3, #20]
 801070a:	3334      	adds	r3, #52	@ 0x34
 801070c:	4618      	mov	r0, r3
 801070e:	f7fd f937 	bl	800d980 <ld_dword>
 8010712:	4602      	mov	r2, r0
 8010714:	693b      	ldr	r3, [r7, #16]
 8010716:	609a      	str	r2, [r3, #8]
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
 8010718:	68fb      	ldr	r3, [r7, #12]
 801071a:	695b      	ldr	r3, [r3, #20]
 801071c:	3321      	adds	r3, #33	@ 0x21
 801071e:	781b      	ldrb	r3, [r3, #0]
 8010720:	f003 0302 	and.w	r3, r3, #2
 8010724:	b2da      	uxtb	r2, r3
 8010726:	693b      	ldr	r3, [r7, #16]
 8010728:	71da      	strb	r2, [r3, #7]
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 801072a:	68fb      	ldr	r3, [r7, #12]
 801072c:	695b      	ldr	r3, [r3, #20]
 801072e:	3338      	adds	r3, #56	@ 0x38
 8010730:	4618      	mov	r0, r3
 8010732:	f7fd f948 	bl	800d9c6 <ld_qword>
 8010736:	4602      	mov	r2, r0
 8010738:	460b      	mov	r3, r1
 801073a:	6939      	ldr	r1, [r7, #16]
 801073c:	e9c1 2304 	strd	r2, r3, [r1, #16]
 8010740:	e79b      	b.n	801067a <follow_path+0x56>
			} else
#endif
			{
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8010742:	68fb      	ldr	r3, [r7, #12]
 8010744:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 8010748:	687b      	ldr	r3, [r7, #4]
 801074a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801074c:	68fa      	ldr	r2, [r7, #12]
 801074e:	8992      	ldrh	r2, [r2, #12]
 8010750:	fbb3 f0f2 	udiv	r0, r3, r2
 8010754:	fb00 f202 	mul.w	r2, r0, r2
 8010758:	1a9b      	subs	r3, r3, r2
 801075a:	440b      	add	r3, r1
 801075c:	4619      	mov	r1, r3
 801075e:	68f8      	ldr	r0, [r7, #12]
 8010760:	f7fe fd6d 	bl	800f23e <ld_clust>
 8010764:	4602      	mov	r2, r0
 8010766:	693b      	ldr	r3, [r7, #16]
 8010768:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 801076a:	e786      	b.n	801067a <follow_path+0x56>
			if (res != FR_OK) break;
 801076c:	bf00      	nop
 801076e:	e002      	b.n	8010776 <follow_path+0x152>
				break;
 8010770:	bf00      	nop
 8010772:	e000      	b.n	8010776 <follow_path+0x152>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8010774:	bf00      	nop
			}
		}
	}

	return res;
 8010776:	7dfb      	ldrb	r3, [r7, #23]
}
 8010778:	4618      	mov	r0, r3
 801077a:	3718      	adds	r7, #24
 801077c:	46bd      	mov	sp, r7
 801077e:	bd80      	pop	{r7, pc}

08010780 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8010780:	b480      	push	{r7}
 8010782:	b087      	sub	sp, #28
 8010784:	af00      	add	r7, sp, #0
 8010786:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8010788:	f04f 33ff 	mov.w	r3, #4294967295
 801078c:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 801078e:	687b      	ldr	r3, [r7, #4]
 8010790:	681b      	ldr	r3, [r3, #0]
 8010792:	2b00      	cmp	r3, #0
 8010794:	d031      	beq.n	80107fa <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8010796:	687b      	ldr	r3, [r7, #4]
 8010798:	681b      	ldr	r3, [r3, #0]
 801079a:	617b      	str	r3, [r7, #20]
 801079c:	e002      	b.n	80107a4 <get_ldnumber+0x24>
 801079e:	697b      	ldr	r3, [r7, #20]
 80107a0:	3301      	adds	r3, #1
 80107a2:	617b      	str	r3, [r7, #20]
 80107a4:	697b      	ldr	r3, [r7, #20]
 80107a6:	781b      	ldrb	r3, [r3, #0]
 80107a8:	2b1f      	cmp	r3, #31
 80107aa:	d903      	bls.n	80107b4 <get_ldnumber+0x34>
 80107ac:	697b      	ldr	r3, [r7, #20]
 80107ae:	781b      	ldrb	r3, [r3, #0]
 80107b0:	2b3a      	cmp	r3, #58	@ 0x3a
 80107b2:	d1f4      	bne.n	801079e <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 80107b4:	697b      	ldr	r3, [r7, #20]
 80107b6:	781b      	ldrb	r3, [r3, #0]
 80107b8:	2b3a      	cmp	r3, #58	@ 0x3a
 80107ba:	d11c      	bne.n	80107f6 <get_ldnumber+0x76>
			tp = *path;
 80107bc:	687b      	ldr	r3, [r7, #4]
 80107be:	681b      	ldr	r3, [r3, #0]
 80107c0:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0';
 80107c2:	68fb      	ldr	r3, [r7, #12]
 80107c4:	1c5a      	adds	r2, r3, #1
 80107c6:	60fa      	str	r2, [r7, #12]
 80107c8:	781b      	ldrb	r3, [r3, #0]
 80107ca:	3b30      	subs	r3, #48	@ 0x30
 80107cc:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 80107ce:	68bb      	ldr	r3, [r7, #8]
 80107d0:	2b09      	cmp	r3, #9
 80107d2:	d80e      	bhi.n	80107f2 <get_ldnumber+0x72>
 80107d4:	68fa      	ldr	r2, [r7, #12]
 80107d6:	697b      	ldr	r3, [r7, #20]
 80107d8:	429a      	cmp	r2, r3
 80107da:	d10a      	bne.n	80107f2 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 80107dc:	68bb      	ldr	r3, [r7, #8]
 80107de:	2b00      	cmp	r3, #0
 80107e0:	d107      	bne.n	80107f2 <get_ldnumber+0x72>
					vol = (int)i;
 80107e2:	68bb      	ldr	r3, [r7, #8]
 80107e4:	613b      	str	r3, [r7, #16]
					*path = ++tt;
 80107e6:	697b      	ldr	r3, [r7, #20]
 80107e8:	3301      	adds	r3, #1
 80107ea:	617b      	str	r3, [r7, #20]
 80107ec:	687b      	ldr	r3, [r7, #4]
 80107ee:	697a      	ldr	r2, [r7, #20]
 80107f0:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
 80107f2:	693b      	ldr	r3, [r7, #16]
 80107f4:	e002      	b.n	80107fc <get_ldnumber+0x7c>
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 80107f6:	2300      	movs	r3, #0
 80107f8:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
 80107fa:	693b      	ldr	r3, [r7, #16]
}
 80107fc:	4618      	mov	r0, r3
 80107fe:	371c      	adds	r7, #28
 8010800:	46bd      	mov	sp, r7
 8010802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010806:	4770      	bx	lr

08010808 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 8010808:	b580      	push	{r7, lr}
 801080a:	b082      	sub	sp, #8
 801080c:	af00      	add	r7, sp, #0
 801080e:	6078      	str	r0, [r7, #4]
 8010810:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8010812:	687b      	ldr	r3, [r7, #4]
 8010814:	2200      	movs	r2, #0
 8010816:	70da      	strb	r2, [r3, #3]
 8010818:	687b      	ldr	r3, [r7, #4]
 801081a:	f04f 32ff 	mov.w	r2, #4294967295
 801081e:	639a      	str	r2, [r3, #56]	@ 0x38
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8010820:	6839      	ldr	r1, [r7, #0]
 8010822:	6878      	ldr	r0, [r7, #4]
 8010824:	f7fd fca8 	bl	800e178 <move_window>
 8010828:	4603      	mov	r3, r0
 801082a:	2b00      	cmp	r3, #0
 801082c:	d001      	beq.n	8010832 <check_fs+0x2a>
 801082e:	2304      	movs	r3, #4
 8010830:	e044      	b.n	80108bc <check_fs+0xb4>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8010832:	687b      	ldr	r3, [r7, #4]
 8010834:	333c      	adds	r3, #60	@ 0x3c
 8010836:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 801083a:	4618      	mov	r0, r3
 801083c:	f7fd f888 	bl	800d950 <ld_word>
 8010840:	4603      	mov	r3, r0
 8010842:	461a      	mov	r2, r3
 8010844:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 8010848:	429a      	cmp	r2, r3
 801084a:	d001      	beq.n	8010850 <check_fs+0x48>
 801084c:	2303      	movs	r3, #3
 801084e:	e035      	b.n	80108bc <check_fs+0xb4>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8010850:	687b      	ldr	r3, [r7, #4]
 8010852:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8010856:	2be9      	cmp	r3, #233	@ 0xe9
 8010858:	d009      	beq.n	801086e <check_fs+0x66>
 801085a:	687b      	ldr	r3, [r7, #4]
 801085c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8010860:	2beb      	cmp	r3, #235	@ 0xeb
 8010862:	d11e      	bne.n	80108a2 <check_fs+0x9a>
 8010864:	687b      	ldr	r3, [r7, #4]
 8010866:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 801086a:	2b90      	cmp	r3, #144	@ 0x90
 801086c:	d119      	bne.n	80108a2 <check_fs+0x9a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 801086e:	687b      	ldr	r3, [r7, #4]
 8010870:	333c      	adds	r3, #60	@ 0x3c
 8010872:	3336      	adds	r3, #54	@ 0x36
 8010874:	4618      	mov	r0, r3
 8010876:	f7fd f883 	bl	800d980 <ld_dword>
 801087a:	4603      	mov	r3, r0
 801087c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 8010880:	4a10      	ldr	r2, [pc, #64]	@ (80108c4 <check_fs+0xbc>)
 8010882:	4293      	cmp	r3, r2
 8010884:	d101      	bne.n	801088a <check_fs+0x82>
 8010886:	2300      	movs	r3, #0
 8010888:	e018      	b.n	80108bc <check_fs+0xb4>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 801088a:	687b      	ldr	r3, [r7, #4]
 801088c:	333c      	adds	r3, #60	@ 0x3c
 801088e:	3352      	adds	r3, #82	@ 0x52
 8010890:	4618      	mov	r0, r3
 8010892:	f7fd f875 	bl	800d980 <ld_dword>
 8010896:	4603      	mov	r3, r0
 8010898:	4a0b      	ldr	r2, [pc, #44]	@ (80108c8 <check_fs+0xc0>)
 801089a:	4293      	cmp	r3, r2
 801089c:	d101      	bne.n	80108a2 <check_fs+0x9a>
 801089e:	2300      	movs	r3, #0
 80108a0:	e00c      	b.n	80108bc <check_fs+0xb4>
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
 80108a2:	687b      	ldr	r3, [r7, #4]
 80108a4:	333c      	adds	r3, #60	@ 0x3c
 80108a6:	220b      	movs	r2, #11
 80108a8:	4908      	ldr	r1, [pc, #32]	@ (80108cc <check_fs+0xc4>)
 80108aa:	4618      	mov	r0, r3
 80108ac:	f7fd fa71 	bl	800dd92 <mem_cmp>
 80108b0:	4603      	mov	r3, r0
 80108b2:	2b00      	cmp	r3, #0
 80108b4:	d101      	bne.n	80108ba <check_fs+0xb2>
 80108b6:	2301      	movs	r3, #1
 80108b8:	e000      	b.n	80108bc <check_fs+0xb4>
#endif
	return 2;
 80108ba:	2302      	movs	r3, #2
}
 80108bc:	4618      	mov	r0, r3
 80108be:	3708      	adds	r7, #8
 80108c0:	46bd      	mov	sp, r7
 80108c2:	bd80      	pop	{r7, pc}
 80108c4:	00544146 	.word	0x00544146
 80108c8:	33544146 	.word	0x33544146
 80108cc:	08030264 	.word	0x08030264

080108d0 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 80108d0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80108d4:	b09c      	sub	sp, #112	@ 0x70
 80108d6:	af00      	add	r7, sp, #0
 80108d8:	61f8      	str	r0, [r7, #28]
 80108da:	61b9      	str	r1, [r7, #24]
 80108dc:	4613      	mov	r3, r2
 80108de:	75fb      	strb	r3, [r7, #23]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 80108e0:	69bb      	ldr	r3, [r7, #24]
 80108e2:	2200      	movs	r2, #0
 80108e4:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
 80108e6:	69f8      	ldr	r0, [r7, #28]
 80108e8:	f7ff ff4a 	bl	8010780 <get_ldnumber>
 80108ec:	6578      	str	r0, [r7, #84]	@ 0x54
	if (vol < 0) return FR_INVALID_DRIVE;
 80108ee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80108f0:	2b00      	cmp	r3, #0
 80108f2:	da01      	bge.n	80108f8 <find_volume+0x28>
 80108f4:	230b      	movs	r3, #11
 80108f6:	e376      	b.n	8010fe6 <find_volume+0x716>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 80108f8:	4aa6      	ldr	r2, [pc, #664]	@ (8010b94 <find_volume+0x2c4>)
 80108fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80108fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010900:	653b      	str	r3, [r7, #80]	@ 0x50
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8010902:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010904:	2b00      	cmp	r3, #0
 8010906:	d101      	bne.n	801090c <find_volume+0x3c>
 8010908:	230c      	movs	r3, #12
 801090a:	e36c      	b.n	8010fe6 <find_volume+0x716>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 801090c:	69bb      	ldr	r3, [r7, #24]
 801090e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010910:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8010912:	7dfb      	ldrb	r3, [r7, #23]
 8010914:	f023 0301 	bic.w	r3, r3, #1
 8010918:	75fb      	strb	r3, [r7, #23]
	if (fs->fs_type) {					/* If the volume has been mounted */
 801091a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801091c:	781b      	ldrb	r3, [r3, #0]
 801091e:	2b00      	cmp	r3, #0
 8010920:	d01a      	beq.n	8010958 <find_volume+0x88>
		stat = disk_status(fs->drv);
 8010922:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010924:	785b      	ldrb	r3, [r3, #1]
 8010926:	4618      	mov	r0, r3
 8010928:	f7fc ff72 	bl	800d810 <disk_status>
 801092c:	4603      	mov	r3, r0
 801092e:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8010932:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8010936:	f003 0301 	and.w	r3, r3, #1
 801093a:	2b00      	cmp	r3, #0
 801093c:	d10c      	bne.n	8010958 <find_volume+0x88>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 801093e:	7dfb      	ldrb	r3, [r7, #23]
 8010940:	2b00      	cmp	r3, #0
 8010942:	d007      	beq.n	8010954 <find_volume+0x84>
 8010944:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8010948:	f003 0304 	and.w	r3, r3, #4
 801094c:	2b00      	cmp	r3, #0
 801094e:	d001      	beq.n	8010954 <find_volume+0x84>
				return FR_WRITE_PROTECTED;
 8010950:	230a      	movs	r3, #10
 8010952:	e348      	b.n	8010fe6 <find_volume+0x716>
			}
			return FR_OK;				/* The file system object is valid */
 8010954:	2300      	movs	r3, #0
 8010956:	e346      	b.n	8010fe6 <find_volume+0x716>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8010958:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801095a:	2200      	movs	r2, #0
 801095c:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 801095e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010960:	b2da      	uxtb	r2, r3
 8010962:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010964:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8010966:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010968:	785b      	ldrb	r3, [r3, #1]
 801096a:	4618      	mov	r0, r3
 801096c:	f7fc ff6a 	bl	800d844 <disk_initialize>
 8010970:	4603      	mov	r3, r0
 8010972:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8010976:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 801097a:	f003 0301 	and.w	r3, r3, #1
 801097e:	2b00      	cmp	r3, #0
 8010980:	d001      	beq.n	8010986 <find_volume+0xb6>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8010982:	2303      	movs	r3, #3
 8010984:	e32f      	b.n	8010fe6 <find_volume+0x716>
	}
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8010986:	7dfb      	ldrb	r3, [r7, #23]
 8010988:	2b00      	cmp	r3, #0
 801098a:	d007      	beq.n	801099c <find_volume+0xcc>
 801098c:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8010990:	f003 0304 	and.w	r3, r3, #4
 8010994:	2b00      	cmp	r3, #0
 8010996:	d001      	beq.n	801099c <find_volume+0xcc>
		return FR_WRITE_PROTECTED;
 8010998:	230a      	movs	r3, #10
 801099a:	e324      	b.n	8010fe6 <find_volume+0x716>
	}
#if _MAX_SS != _MIN_SS					/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
 801099c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801099e:	7858      	ldrb	r0, [r3, #1]
 80109a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80109a2:	330c      	adds	r3, #12
 80109a4:	461a      	mov	r2, r3
 80109a6:	2102      	movs	r1, #2
 80109a8:	f7fc ffb4 	bl	800d914 <disk_ioctl>
 80109ac:	4603      	mov	r3, r0
 80109ae:	2b00      	cmp	r3, #0
 80109b0:	d001      	beq.n	80109b6 <find_volume+0xe6>
 80109b2:	2301      	movs	r3, #1
 80109b4:	e317      	b.n	8010fe6 <find_volume+0x716>
	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
 80109b6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80109b8:	899b      	ldrh	r3, [r3, #12]
 80109ba:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80109be:	d80d      	bhi.n	80109dc <find_volume+0x10c>
 80109c0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80109c2:	899b      	ldrh	r3, [r3, #12]
 80109c4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80109c8:	d308      	bcc.n	80109dc <find_volume+0x10c>
 80109ca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80109cc:	899b      	ldrh	r3, [r3, #12]
 80109ce:	461a      	mov	r2, r3
 80109d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80109d2:	899b      	ldrh	r3, [r3, #12]
 80109d4:	3b01      	subs	r3, #1
 80109d6:	4013      	ands	r3, r2
 80109d8:	2b00      	cmp	r3, #0
 80109da:	d001      	beq.n	80109e0 <find_volume+0x110>
 80109dc:	2301      	movs	r3, #1
 80109de:	e302      	b.n	8010fe6 <find_volume+0x716>
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
	bsect = 0;
 80109e0:	2300      	movs	r3, #0
 80109e2:	66bb      	str	r3, [r7, #104]	@ 0x68
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 80109e4:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80109e6:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 80109e8:	f7ff ff0e 	bl	8010808 <check_fs>
 80109ec:	4603      	mov	r3, r0
 80109ee:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 80109f2:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 80109f6:	2b02      	cmp	r3, #2
 80109f8:	d14d      	bne.n	8010a96 <find_volume+0x1c6>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80109fa:	2300      	movs	r3, #0
 80109fc:	65bb      	str	r3, [r7, #88]	@ 0x58
 80109fe:	e020      	b.n	8010a42 <find_volume+0x172>
			pt = fs->win + (MBR_Table + i * SZ_PTE);
 8010a00:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010a02:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 8010a06:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a08:	011b      	lsls	r3, r3, #4
 8010a0a:	f503 73df 	add.w	r3, r3, #446	@ 0x1be
 8010a0e:	4413      	add	r3, r2
 8010a10:	64bb      	str	r3, [r7, #72]	@ 0x48
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8010a12:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010a14:	3304      	adds	r3, #4
 8010a16:	781b      	ldrb	r3, [r3, #0]
 8010a18:	2b00      	cmp	r3, #0
 8010a1a:	d006      	beq.n	8010a2a <find_volume+0x15a>
 8010a1c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010a1e:	3308      	adds	r3, #8
 8010a20:	4618      	mov	r0, r3
 8010a22:	f7fc ffad 	bl	800d980 <ld_dword>
 8010a26:	4602      	mov	r2, r0
 8010a28:	e000      	b.n	8010a2c <find_volume+0x15c>
 8010a2a:	2200      	movs	r2, #0
 8010a2c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a2e:	009b      	lsls	r3, r3, #2
 8010a30:	3360      	adds	r3, #96	@ 0x60
 8010a32:	f107 0110 	add.w	r1, r7, #16
 8010a36:	440b      	add	r3, r1
 8010a38:	f843 2c50 	str.w	r2, [r3, #-80]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 8010a3c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a3e:	3301      	adds	r3, #1
 8010a40:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010a42:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a44:	2b03      	cmp	r3, #3
 8010a46:	d9db      	bls.n	8010a00 <find_volume+0x130>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
 8010a48:	2300      	movs	r3, #0
 8010a4a:	65bb      	str	r3, [r7, #88]	@ 0x58
		if (i) i--;
 8010a4c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a4e:	2b00      	cmp	r3, #0
 8010a50:	d002      	beq.n	8010a58 <find_volume+0x188>
 8010a52:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a54:	3b01      	subs	r3, #1
 8010a56:	65bb      	str	r3, [r7, #88]	@ 0x58
		do {							/* Find an FAT volume */
			bsect = br[i];
 8010a58:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a5a:	009b      	lsls	r3, r3, #2
 8010a5c:	3360      	adds	r3, #96	@ 0x60
 8010a5e:	f107 0210 	add.w	r2, r7, #16
 8010a62:	4413      	add	r3, r2
 8010a64:	f853 3c50 	ldr.w	r3, [r3, #-80]
 8010a68:	66bb      	str	r3, [r7, #104]	@ 0x68
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8010a6a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010a6c:	2b00      	cmp	r3, #0
 8010a6e:	d005      	beq.n	8010a7c <find_volume+0x1ac>
 8010a70:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8010a72:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8010a74:	f7ff fec8 	bl	8010808 <check_fs>
 8010a78:	4603      	mov	r3, r0
 8010a7a:	e000      	b.n	8010a7e <find_volume+0x1ae>
 8010a7c:	2303      	movs	r3, #3
 8010a7e:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8010a82:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010a86:	2b01      	cmp	r3, #1
 8010a88:	d905      	bls.n	8010a96 <find_volume+0x1c6>
 8010a8a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a8c:	3301      	adds	r3, #1
 8010a8e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010a90:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010a92:	2b03      	cmp	r3, #3
 8010a94:	d9e0      	bls.n	8010a58 <find_volume+0x188>
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8010a96:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010a9a:	2b04      	cmp	r3, #4
 8010a9c:	d101      	bne.n	8010aa2 <find_volume+0x1d2>
 8010a9e:	2301      	movs	r3, #1
 8010aa0:	e2a1      	b.n	8010fe6 <find_volume+0x716>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8010aa2:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010aa6:	2b01      	cmp	r3, #1
 8010aa8:	d901      	bls.n	8010aae <find_volume+0x1de>
 8010aaa:	230d      	movs	r3, #13
 8010aac:	e29b      	b.n	8010fe6 <find_volume+0x716>

	/* An FAT volume is found (bsect). Following code initializes the file system object */

#if _FS_EXFAT
	if (fmt == 1) {
 8010aae:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010ab2:	2b01      	cmp	r3, #1
 8010ab4:	f040 8101 	bne.w	8010cba <find_volume+0x3ea>
		QWORD maxlba;

		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 8010ab8:	230b      	movs	r3, #11
 8010aba:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010abc:	e002      	b.n	8010ac4 <find_volume+0x1f4>
 8010abe:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010ac0:	3301      	adds	r3, #1
 8010ac2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010ac4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010ac6:	2b3f      	cmp	r3, #63	@ 0x3f
 8010ac8:	d806      	bhi.n	8010ad8 <find_volume+0x208>
 8010aca:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010acc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010ace:	4413      	add	r3, r2
 8010ad0:	333c      	adds	r3, #60	@ 0x3c
 8010ad2:	781b      	ldrb	r3, [r3, #0]
 8010ad4:	2b00      	cmp	r3, #0
 8010ad6:	d0f2      	beq.n	8010abe <find_volume+0x1ee>
		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
 8010ad8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010ada:	2b3f      	cmp	r3, #63	@ 0x3f
 8010adc:	d801      	bhi.n	8010ae2 <find_volume+0x212>
 8010ade:	230d      	movs	r3, #13
 8010ae0:	e281      	b.n	8010fe6 <find_volume+0x716>

		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
 8010ae2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ae4:	333c      	adds	r3, #60	@ 0x3c
 8010ae6:	3368      	adds	r3, #104	@ 0x68
 8010ae8:	4618      	mov	r0, r3
 8010aea:	f7fc ff31 	bl	800d950 <ld_word>
 8010aee:	4603      	mov	r3, r0
 8010af0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8010af4:	d001      	beq.n	8010afa <find_volume+0x22a>
 8010af6:	230d      	movs	r3, #13
 8010af8:	e275      	b.n	8010fe6 <find_volume+0x716>

		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
 8010afa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010afc:	f893 30a8 	ldrb.w	r3, [r3, #168]	@ 0xa8
 8010b00:	461a      	mov	r2, r3
 8010b02:	2301      	movs	r3, #1
 8010b04:	4093      	lsls	r3, r2
 8010b06:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010b08:	8992      	ldrh	r2, [r2, #12]
 8010b0a:	4293      	cmp	r3, r2
 8010b0c:	d001      	beq.n	8010b12 <find_volume+0x242>
			return FR_NO_FILESYSTEM;
 8010b0e:	230d      	movs	r3, #13
 8010b10:	e269      	b.n	8010fe6 <find_volume+0x716>
		}

		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
 8010b12:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b14:	333c      	adds	r3, #60	@ 0x3c
 8010b16:	3348      	adds	r3, #72	@ 0x48
 8010b18:	4618      	mov	r0, r3
 8010b1a:	f7fc ff54 	bl	800d9c6 <ld_qword>
 8010b1e:	4602      	mov	r2, r0
 8010b20:	460b      	mov	r3, r1
 8010b22:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8010b24:	2000      	movs	r0, #0
 8010b26:	60b9      	str	r1, [r7, #8]
 8010b28:	60f8      	str	r0, [r7, #12]
 8010b2a:	68b9      	ldr	r1, [r7, #8]
 8010b2c:	1851      	adds	r1, r2, r1
 8010b2e:	6039      	str	r1, [r7, #0]
 8010b30:	68f9      	ldr	r1, [r7, #12]
 8010b32:	eb43 0101 	adc.w	r1, r3, r1
 8010b36:	6079      	str	r1, [r7, #4]
 8010b38:	e9d7 2300 	ldrd	r2, r3, [r7]
 8010b3c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
 8010b40:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8010b44:	2b01      	cmp	r3, #1
 8010b46:	d301      	bcc.n	8010b4c <find_volume+0x27c>
 8010b48:	230d      	movs	r3, #13
 8010b4a:	e24c      	b.n	8010fe6 <find_volume+0x716>

		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 8010b4c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b4e:	333c      	adds	r3, #60	@ 0x3c
 8010b50:	3354      	adds	r3, #84	@ 0x54
 8010b52:	4618      	mov	r0, r3
 8010b54:	f7fc ff14 	bl	800d980 <ld_dword>
 8010b58:	4602      	mov	r2, r0
 8010b5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b5c:	625a      	str	r2, [r3, #36]	@ 0x24

		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 8010b5e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b60:	f893 20aa 	ldrb.w	r2, [r3, #170]	@ 0xaa
 8010b64:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b66:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 8010b68:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b6a:	789b      	ldrb	r3, [r3, #2]
 8010b6c:	2b01      	cmp	r3, #1
 8010b6e:	d001      	beq.n	8010b74 <find_volume+0x2a4>
 8010b70:	230d      	movs	r3, #13
 8010b72:	e238      	b.n	8010fe6 <find_volume+0x716>

		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
 8010b74:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b76:	f893 30a9 	ldrb.w	r3, [r3, #169]	@ 0xa9
 8010b7a:	461a      	mov	r2, r3
 8010b7c:	2301      	movs	r3, #1
 8010b7e:	4093      	lsls	r3, r2
 8010b80:	b29a      	uxth	r2, r3
 8010b82:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b84:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
 8010b86:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b88:	895b      	ldrh	r3, [r3, #10]
 8010b8a:	2b00      	cmp	r3, #0
 8010b8c:	d104      	bne.n	8010b98 <find_volume+0x2c8>
 8010b8e:	230d      	movs	r3, #13
 8010b90:	e229      	b.n	8010fe6 <find_volume+0x716>
 8010b92:	bf00      	nop
 8010b94:	200028fc 	.word	0x200028fc

		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
 8010b98:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010b9a:	333c      	adds	r3, #60	@ 0x3c
 8010b9c:	335c      	adds	r3, #92	@ 0x5c
 8010b9e:	4618      	mov	r0, r3
 8010ba0:	f7fc feee 	bl	800d980 <ld_dword>
 8010ba4:	63f8      	str	r0, [r7, #60]	@ 0x3c
		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
 8010ba6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010ba8:	4a99      	ldr	r2, [pc, #612]	@ (8010e10 <find_volume+0x540>)
 8010baa:	4293      	cmp	r3, r2
 8010bac:	d901      	bls.n	8010bb2 <find_volume+0x2e2>
 8010bae:	230d      	movs	r3, #13
 8010bb0:	e219      	b.n	8010fe6 <find_volume+0x716>
		fs->n_fatent = nclst + 2;
 8010bb2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010bb4:	1c9a      	adds	r2, r3, #2
 8010bb6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bb8:	621a      	str	r2, [r3, #32]

		/* Boundaries and Limits */
		fs->volbase = bsect;
 8010bba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bbc:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8010bbe:	629a      	str	r2, [r3, #40]	@ 0x28
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8010bc0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bc2:	333c      	adds	r3, #60	@ 0x3c
 8010bc4:	3358      	adds	r3, #88	@ 0x58
 8010bc6:	4618      	mov	r0, r3
 8010bc8:	f7fc feda 	bl	800d980 <ld_dword>
 8010bcc:	4602      	mov	r2, r0
 8010bce:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010bd0:	441a      	add	r2, r3
 8010bd2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bd4:	635a      	str	r2, [r3, #52]	@ 0x34
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8010bd6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bd8:	333c      	adds	r3, #60	@ 0x3c
 8010bda:	3350      	adds	r3, #80	@ 0x50
 8010bdc:	4618      	mov	r0, r3
 8010bde:	f7fc fecf 	bl	800d980 <ld_dword>
 8010be2:	4602      	mov	r2, r0
 8010be4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010be6:	441a      	add	r2, r3
 8010be8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bea:	62da      	str	r2, [r3, #44]	@ 0x2c
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8010bec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bee:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8010bf0:	2200      	movs	r2, #0
 8010bf2:	469a      	mov	sl, r3
 8010bf4:	4693      	mov	fp, r2
 8010bf6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010bf8:	895b      	ldrh	r3, [r3, #10]
 8010bfa:	461a      	mov	r2, r3
 8010bfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010bfe:	fb02 f303 	mul.w	r3, r2, r3
 8010c02:	2200      	movs	r2, #0
 8010c04:	4698      	mov	r8, r3
 8010c06:	4691      	mov	r9, r2
 8010c08:	eb1a 0408 	adds.w	r4, sl, r8
 8010c0c:	eb4b 0509 	adc.w	r5, fp, r9
 8010c10:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8010c14:	42a2      	cmp	r2, r4
 8010c16:	41ab      	sbcs	r3, r5
 8010c18:	d201      	bcs.n	8010c1e <find_volume+0x34e>
 8010c1a:	230d      	movs	r3, #13
 8010c1c:	e1e3      	b.n	8010fe6 <find_volume+0x716>
		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 8010c1e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c20:	333c      	adds	r3, #60	@ 0x3c
 8010c22:	3360      	adds	r3, #96	@ 0x60
 8010c24:	4618      	mov	r0, r3
 8010c26:	f7fc feab 	bl	800d980 <ld_dword>
 8010c2a:	4602      	mov	r2, r0
 8010c2c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c2e:	631a      	str	r2, [r3, #48]	@ 0x30

		/* Check if bitmap location is in assumption (at the first cluster) */
		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
 8010c30:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c32:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8010c34:	4619      	mov	r1, r3
 8010c36:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8010c38:	f7fd fb3c 	bl	800e2b4 <clust2sect>
 8010c3c:	4603      	mov	r3, r0
 8010c3e:	4619      	mov	r1, r3
 8010c40:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8010c42:	f7fd fa99 	bl	800e178 <move_window>
 8010c46:	4603      	mov	r3, r0
 8010c48:	2b00      	cmp	r3, #0
 8010c4a:	d001      	beq.n	8010c50 <find_volume+0x380>
 8010c4c:	2301      	movs	r3, #1
 8010c4e:	e1ca      	b.n	8010fe6 <find_volume+0x716>
		for (i = 0; i < SS(fs); i += SZDIRE) {
 8010c50:	2300      	movs	r3, #0
 8010c52:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010c54:	e015      	b.n	8010c82 <find_volume+0x3b2>
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 8010c56:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010c58:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010c5a:	4413      	add	r3, r2
 8010c5c:	333c      	adds	r3, #60	@ 0x3c
 8010c5e:	781b      	ldrb	r3, [r3, #0]
 8010c60:	2b81      	cmp	r3, #129	@ 0x81
 8010c62:	d10b      	bne.n	8010c7c <find_volume+0x3ac>
 8010c64:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c66:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 8010c6a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010c6c:	3314      	adds	r3, #20
 8010c6e:	4413      	add	r3, r2
 8010c70:	4618      	mov	r0, r3
 8010c72:	f7fc fe85 	bl	800d980 <ld_dword>
 8010c76:	4603      	mov	r3, r0
 8010c78:	2b02      	cmp	r3, #2
 8010c7a:	d009      	beq.n	8010c90 <find_volume+0x3c0>
		for (i = 0; i < SS(fs); i += SZDIRE) {
 8010c7c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010c7e:	3320      	adds	r3, #32
 8010c80:	65bb      	str	r3, [r7, #88]	@ 0x58
 8010c82:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c84:	899b      	ldrh	r3, [r3, #12]
 8010c86:	461a      	mov	r2, r3
 8010c88:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010c8a:	4293      	cmp	r3, r2
 8010c8c:	d3e3      	bcc.n	8010c56 <find_volume+0x386>
 8010c8e:	e000      	b.n	8010c92 <find_volume+0x3c2>
			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 8010c90:	bf00      	nop
		}
		if (i == SS(fs)) return FR_NO_FILESYSTEM;
 8010c92:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010c94:	899b      	ldrh	r3, [r3, #12]
 8010c96:	461a      	mov	r2, r3
 8010c98:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8010c9a:	4293      	cmp	r3, r2
 8010c9c:	d101      	bne.n	8010ca2 <find_volume+0x3d2>
 8010c9e:	230d      	movs	r3, #13
 8010ca0:	e1a1      	b.n	8010fe6 <find_volume+0x716>
#if !_FS_READONLY
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8010ca2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ca4:	f04f 32ff 	mov.w	r2, #4294967295
 8010ca8:	61da      	str	r2, [r3, #28]
 8010caa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cac:	69da      	ldr	r2, [r3, #28]
 8010cae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cb0:	619a      	str	r2, [r3, #24]
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
 8010cb2:	2304      	movs	r3, #4
 8010cb4:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
 8010cb8:	e17d      	b.n	8010fb6 <find_volume+0x6e6>
	} else
#endif	/* _FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8010cba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cbc:	333c      	adds	r3, #60	@ 0x3c
 8010cbe:	330b      	adds	r3, #11
 8010cc0:	4618      	mov	r0, r3
 8010cc2:	f7fc fe45 	bl	800d950 <ld_word>
 8010cc6:	4603      	mov	r3, r0
 8010cc8:	461a      	mov	r2, r3
 8010cca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ccc:	899b      	ldrh	r3, [r3, #12]
 8010cce:	429a      	cmp	r2, r3
 8010cd0:	d001      	beq.n	8010cd6 <find_volume+0x406>
 8010cd2:	230d      	movs	r3, #13
 8010cd4:	e187      	b.n	8010fe6 <find_volume+0x716>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 8010cd6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cd8:	333c      	adds	r3, #60	@ 0x3c
 8010cda:	3316      	adds	r3, #22
 8010cdc:	4618      	mov	r0, r3
 8010cde:	f7fc fe37 	bl	800d950 <ld_word>
 8010ce2:	4603      	mov	r3, r0
 8010ce4:	667b      	str	r3, [r7, #100]	@ 0x64
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8010ce6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8010ce8:	2b00      	cmp	r3, #0
 8010cea:	d106      	bne.n	8010cfa <find_volume+0x42a>
 8010cec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cee:	333c      	adds	r3, #60	@ 0x3c
 8010cf0:	3324      	adds	r3, #36	@ 0x24
 8010cf2:	4618      	mov	r0, r3
 8010cf4:	f7fc fe44 	bl	800d980 <ld_dword>
 8010cf8:	6678      	str	r0, [r7, #100]	@ 0x64
		fs->fsize = fasize;
 8010cfa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010cfc:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8010cfe:	625a      	str	r2, [r3, #36]	@ 0x24

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8010d00:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d02:	f893 204c 	ldrb.w	r2, [r3, #76]	@ 0x4c
 8010d06:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d08:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8010d0a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d0c:	789b      	ldrb	r3, [r3, #2]
 8010d0e:	2b01      	cmp	r3, #1
 8010d10:	d005      	beq.n	8010d1e <find_volume+0x44e>
 8010d12:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d14:	789b      	ldrb	r3, [r3, #2]
 8010d16:	2b02      	cmp	r3, #2
 8010d18:	d001      	beq.n	8010d1e <find_volume+0x44e>
 8010d1a:	230d      	movs	r3, #13
 8010d1c:	e163      	b.n	8010fe6 <find_volume+0x716>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8010d1e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d20:	789b      	ldrb	r3, [r3, #2]
 8010d22:	461a      	mov	r2, r3
 8010d24:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8010d26:	fb02 f303 	mul.w	r3, r2, r3
 8010d2a:	667b      	str	r3, [r7, #100]	@ 0x64

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8010d2c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d2e:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 8010d32:	461a      	mov	r2, r3
 8010d34:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d36:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8010d38:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d3a:	895b      	ldrh	r3, [r3, #10]
 8010d3c:	2b00      	cmp	r3, #0
 8010d3e:	d008      	beq.n	8010d52 <find_volume+0x482>
 8010d40:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d42:	895b      	ldrh	r3, [r3, #10]
 8010d44:	461a      	mov	r2, r3
 8010d46:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d48:	895b      	ldrh	r3, [r3, #10]
 8010d4a:	3b01      	subs	r3, #1
 8010d4c:	4013      	ands	r3, r2
 8010d4e:	2b00      	cmp	r3, #0
 8010d50:	d001      	beq.n	8010d56 <find_volume+0x486>
 8010d52:	230d      	movs	r3, #13
 8010d54:	e147      	b.n	8010fe6 <find_volume+0x716>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8010d56:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d58:	333c      	adds	r3, #60	@ 0x3c
 8010d5a:	3311      	adds	r3, #17
 8010d5c:	4618      	mov	r0, r3
 8010d5e:	f7fc fdf7 	bl	800d950 <ld_word>
 8010d62:	4603      	mov	r3, r0
 8010d64:	461a      	mov	r2, r3
 8010d66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d68:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8010d6a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d6c:	891b      	ldrh	r3, [r3, #8]
 8010d6e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010d70:	8992      	ldrh	r2, [r2, #12]
 8010d72:	0952      	lsrs	r2, r2, #5
 8010d74:	b292      	uxth	r2, r2
 8010d76:	fbb3 f1f2 	udiv	r1, r3, r2
 8010d7a:	fb01 f202 	mul.w	r2, r1, r2
 8010d7e:	1a9b      	subs	r3, r3, r2
 8010d80:	b29b      	uxth	r3, r3
 8010d82:	2b00      	cmp	r3, #0
 8010d84:	d001      	beq.n	8010d8a <find_volume+0x4ba>
 8010d86:	230d      	movs	r3, #13
 8010d88:	e12d      	b.n	8010fe6 <find_volume+0x716>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 8010d8a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010d8c:	333c      	adds	r3, #60	@ 0x3c
 8010d8e:	3313      	adds	r3, #19
 8010d90:	4618      	mov	r0, r3
 8010d92:	f7fc fddd 	bl	800d950 <ld_word>
 8010d96:	4603      	mov	r3, r0
 8010d98:	663b      	str	r3, [r7, #96]	@ 0x60
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8010d9a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8010d9c:	2b00      	cmp	r3, #0
 8010d9e:	d106      	bne.n	8010dae <find_volume+0x4de>
 8010da0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010da2:	333c      	adds	r3, #60	@ 0x3c
 8010da4:	3320      	adds	r3, #32
 8010da6:	4618      	mov	r0, r3
 8010da8:	f7fc fdea 	bl	800d980 <ld_dword>
 8010dac:	6638      	str	r0, [r7, #96]	@ 0x60

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 8010dae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010db0:	333c      	adds	r3, #60	@ 0x3c
 8010db2:	330e      	adds	r3, #14
 8010db4:	4618      	mov	r0, r3
 8010db6:	f7fc fdcb 	bl	800d950 <ld_word>
 8010dba:	4603      	mov	r3, r0
 8010dbc:	f8a7 3046 	strh.w	r3, [r7, #70]	@ 0x46
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8010dc0:	f8b7 3046 	ldrh.w	r3, [r7, #70]	@ 0x46
 8010dc4:	2b00      	cmp	r3, #0
 8010dc6:	d101      	bne.n	8010dcc <find_volume+0x4fc>
 8010dc8:	230d      	movs	r3, #13
 8010dca:	e10c      	b.n	8010fe6 <find_volume+0x716>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8010dcc:	f8b7 2046 	ldrh.w	r2, [r7, #70]	@ 0x46
 8010dd0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8010dd2:	4413      	add	r3, r2
 8010dd4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010dd6:	8911      	ldrh	r1, [r2, #8]
 8010dd8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010dda:	8992      	ldrh	r2, [r2, #12]
 8010ddc:	0952      	lsrs	r2, r2, #5
 8010dde:	b292      	uxth	r2, r2
 8010de0:	fbb1 f2f2 	udiv	r2, r1, r2
 8010de4:	b292      	uxth	r2, r2
 8010de6:	4413      	add	r3, r2
 8010de8:	643b      	str	r3, [r7, #64]	@ 0x40
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8010dea:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8010dec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8010dee:	429a      	cmp	r2, r3
 8010df0:	d201      	bcs.n	8010df6 <find_volume+0x526>
 8010df2:	230d      	movs	r3, #13
 8010df4:	e0f7      	b.n	8010fe6 <find_volume+0x716>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8010df6:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8010df8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8010dfa:	1ad3      	subs	r3, r2, r3
 8010dfc:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8010dfe:	8952      	ldrh	r2, [r2, #10]
 8010e00:	fbb3 f3f2 	udiv	r3, r3, r2
 8010e04:	63fb      	str	r3, [r7, #60]	@ 0x3c
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8010e06:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010e08:	2b00      	cmp	r3, #0
 8010e0a:	d103      	bne.n	8010e14 <find_volume+0x544>
 8010e0c:	230d      	movs	r3, #13
 8010e0e:	e0ea      	b.n	8010fe6 <find_volume+0x716>
 8010e10:	7ffffffd 	.word	0x7ffffffd
		fmt = FS_FAT32;
 8010e14:	2303      	movs	r3, #3
 8010e16:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8010e1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010e1c:	f64f 72f5 	movw	r2, #65525	@ 0xfff5
 8010e20:	4293      	cmp	r3, r2
 8010e22:	d802      	bhi.n	8010e2a <find_volume+0x55a>
 8010e24:	2302      	movs	r3, #2
 8010e26:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8010e2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010e2c:	f640 72f5 	movw	r2, #4085	@ 0xff5
 8010e30:	4293      	cmp	r3, r2
 8010e32:	d802      	bhi.n	8010e3a <find_volume+0x56a>
 8010e34:	2301      	movs	r3, #1
 8010e36:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8010e3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010e3c:	1c9a      	adds	r2, r3, #2
 8010e3e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e40:	621a      	str	r2, [r3, #32]
		fs->volbase = bsect;							/* Volume start sector */
 8010e42:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e44:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8010e46:	629a      	str	r2, [r3, #40]	@ 0x28
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8010e48:	f8b7 2046 	ldrh.w	r2, [r7, #70]	@ 0x46
 8010e4c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010e4e:	441a      	add	r2, r3
 8010e50:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e52:	62da      	str	r2, [r3, #44]	@ 0x2c
		fs->database = bsect + sysect;					/* Data start sector */
 8010e54:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8010e56:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8010e58:	441a      	add	r2, r3
 8010e5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e5c:	635a      	str	r2, [r3, #52]	@ 0x34
		if (fmt == FS_FAT32) {
 8010e5e:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010e62:	2b03      	cmp	r3, #3
 8010e64:	d11e      	bne.n	8010ea4 <find_volume+0x5d4>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8010e66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e68:	333c      	adds	r3, #60	@ 0x3c
 8010e6a:	332a      	adds	r3, #42	@ 0x2a
 8010e6c:	4618      	mov	r0, r3
 8010e6e:	f7fc fd6f 	bl	800d950 <ld_word>
 8010e72:	4603      	mov	r3, r0
 8010e74:	2b00      	cmp	r3, #0
 8010e76:	d001      	beq.n	8010e7c <find_volume+0x5ac>
 8010e78:	230d      	movs	r3, #13
 8010e7a:	e0b4      	b.n	8010fe6 <find_volume+0x716>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 8010e7c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e7e:	891b      	ldrh	r3, [r3, #8]
 8010e80:	2b00      	cmp	r3, #0
 8010e82:	d001      	beq.n	8010e88 <find_volume+0x5b8>
 8010e84:	230d      	movs	r3, #13
 8010e86:	e0ae      	b.n	8010fe6 <find_volume+0x716>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8010e88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e8a:	333c      	adds	r3, #60	@ 0x3c
 8010e8c:	332c      	adds	r3, #44	@ 0x2c
 8010e8e:	4618      	mov	r0, r3
 8010e90:	f7fc fd76 	bl	800d980 <ld_dword>
 8010e94:	4602      	mov	r2, r0
 8010e96:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e98:	631a      	str	r2, [r3, #48]	@ 0x30
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8010e9a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010e9c:	6a1b      	ldr	r3, [r3, #32]
 8010e9e:	009b      	lsls	r3, r3, #2
 8010ea0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8010ea2:	e01f      	b.n	8010ee4 <find_volume+0x614>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8010ea4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ea6:	891b      	ldrh	r3, [r3, #8]
 8010ea8:	2b00      	cmp	r3, #0
 8010eaa:	d101      	bne.n	8010eb0 <find_volume+0x5e0>
 8010eac:	230d      	movs	r3, #13
 8010eae:	e09a      	b.n	8010fe6 <find_volume+0x716>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8010eb0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010eb2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8010eb4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8010eb6:	441a      	add	r2, r3
 8010eb8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010eba:	631a      	str	r2, [r3, #48]	@ 0x30
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8010ebc:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010ec0:	2b02      	cmp	r3, #2
 8010ec2:	d103      	bne.n	8010ecc <find_volume+0x5fc>
 8010ec4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ec6:	6a1b      	ldr	r3, [r3, #32]
 8010ec8:	005b      	lsls	r3, r3, #1
 8010eca:	e00a      	b.n	8010ee2 <find_volume+0x612>
 8010ecc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ece:	6a1a      	ldr	r2, [r3, #32]
 8010ed0:	4613      	mov	r3, r2
 8010ed2:	005b      	lsls	r3, r3, #1
 8010ed4:	4413      	add	r3, r2
 8010ed6:	085a      	lsrs	r2, r3, #1
 8010ed8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010eda:	6a1b      	ldr	r3, [r3, #32]
 8010edc:	f003 0301 	and.w	r3, r3, #1
 8010ee0:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 8010ee2:	65fb      	str	r3, [r7, #92]	@ 0x5c
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8010ee4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010ee6:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8010ee8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010eea:	899b      	ldrh	r3, [r3, #12]
 8010eec:	4619      	mov	r1, r3
 8010eee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8010ef0:	440b      	add	r3, r1
 8010ef2:	3b01      	subs	r3, #1
 8010ef4:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8010ef6:	8989      	ldrh	r1, [r1, #12]
 8010ef8:	fbb3 f3f1 	udiv	r3, r3, r1
 8010efc:	429a      	cmp	r2, r3
 8010efe:	d201      	bcs.n	8010f04 <find_volume+0x634>
 8010f00:	230d      	movs	r3, #13
 8010f02:	e070      	b.n	8010fe6 <find_volume+0x716>

#if !_FS_READONLY
		/* Get FSINFO if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8010f04:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f06:	f04f 32ff 	mov.w	r2, #4294967295
 8010f0a:	61da      	str	r2, [r3, #28]
 8010f0c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f0e:	69da      	ldr	r2, [r3, #28]
 8010f10:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f12:	619a      	str	r2, [r3, #24]
		fs->fsi_flag = 0x80;
 8010f14:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f16:	2280      	movs	r2, #128	@ 0x80
 8010f18:	711a      	strb	r2, [r3, #4]
#if (_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 8010f1a:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 8010f1e:	2b03      	cmp	r3, #3
 8010f20:	d149      	bne.n	8010fb6 <find_volume+0x6e6>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8010f22:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f24:	333c      	adds	r3, #60	@ 0x3c
 8010f26:	3330      	adds	r3, #48	@ 0x30
 8010f28:	4618      	mov	r0, r3
 8010f2a:	f7fc fd11 	bl	800d950 <ld_word>
 8010f2e:	4603      	mov	r3, r0
 8010f30:	2b01      	cmp	r3, #1
 8010f32:	d140      	bne.n	8010fb6 <find_volume+0x6e6>
			&& move_window(fs, bsect + 1) == FR_OK)
 8010f34:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010f36:	3301      	adds	r3, #1
 8010f38:	4619      	mov	r1, r3
 8010f3a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8010f3c:	f7fd f91c 	bl	800e178 <move_window>
 8010f40:	4603      	mov	r3, r0
 8010f42:	2b00      	cmp	r3, #0
 8010f44:	d137      	bne.n	8010fb6 <find_volume+0x6e6>
		{
			fs->fsi_flag = 0;
 8010f46:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f48:	2200      	movs	r2, #0
 8010f4a:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8010f4c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f4e:	333c      	adds	r3, #60	@ 0x3c
 8010f50:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 8010f54:	4618      	mov	r0, r3
 8010f56:	f7fc fcfb 	bl	800d950 <ld_word>
 8010f5a:	4603      	mov	r3, r0
 8010f5c:	461a      	mov	r2, r3
 8010f5e:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 8010f62:	429a      	cmp	r2, r3
 8010f64:	d127      	bne.n	8010fb6 <find_volume+0x6e6>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 8010f66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f68:	333c      	adds	r3, #60	@ 0x3c
 8010f6a:	4618      	mov	r0, r3
 8010f6c:	f7fc fd08 	bl	800d980 <ld_dword>
 8010f70:	4603      	mov	r3, r0
 8010f72:	4a1f      	ldr	r2, [pc, #124]	@ (8010ff0 <find_volume+0x720>)
 8010f74:	4293      	cmp	r3, r2
 8010f76:	d11e      	bne.n	8010fb6 <find_volume+0x6e6>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8010f78:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f7a:	333c      	adds	r3, #60	@ 0x3c
 8010f7c:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 8010f80:	4618      	mov	r0, r3
 8010f82:	f7fc fcfd 	bl	800d980 <ld_dword>
 8010f86:	4603      	mov	r3, r0
 8010f88:	4a1a      	ldr	r2, [pc, #104]	@ (8010ff4 <find_volume+0x724>)
 8010f8a:	4293      	cmp	r3, r2
 8010f8c:	d113      	bne.n	8010fb6 <find_volume+0x6e6>
			{
#if (_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 8010f8e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010f90:	333c      	adds	r3, #60	@ 0x3c
 8010f92:	f503 73f4 	add.w	r3, r3, #488	@ 0x1e8
 8010f96:	4618      	mov	r0, r3
 8010f98:	f7fc fcf2 	bl	800d980 <ld_dword>
 8010f9c:	4602      	mov	r2, r0
 8010f9e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fa0:	61da      	str	r2, [r3, #28]
#endif
#if (_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8010fa2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fa4:	333c      	adds	r3, #60	@ 0x3c
 8010fa6:	f503 73f6 	add.w	r3, r3, #492	@ 0x1ec
 8010faa:	4618      	mov	r0, r3
 8010fac:	f7fc fce8 	bl	800d980 <ld_dword>
 8010fb0:	4602      	mov	r2, r0
 8010fb2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fb4:	619a      	str	r2, [r3, #24]
		}
#endif	/* (_FS_NOFSINFO & 3) != 3 */
#endif	/* !_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
 8010fb6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fb8:	f897 206f 	ldrb.w	r2, [r7, #111]	@ 0x6f
 8010fbc:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8010fbe:	4b0e      	ldr	r3, [pc, #56]	@ (8010ff8 <find_volume+0x728>)
 8010fc0:	881b      	ldrh	r3, [r3, #0]
 8010fc2:	3301      	adds	r3, #1
 8010fc4:	b29a      	uxth	r2, r3
 8010fc6:	4b0c      	ldr	r3, [pc, #48]	@ (8010ff8 <find_volume+0x728>)
 8010fc8:	801a      	strh	r2, [r3, #0]
 8010fca:	4b0b      	ldr	r3, [pc, #44]	@ (8010ff8 <find_volume+0x728>)
 8010fcc:	881a      	ldrh	r2, [r3, #0]
 8010fce:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fd0:	80da      	strh	r2, [r3, #6]
#if _USE_LFN == 1
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 8010fd2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fd4:	4a09      	ldr	r2, [pc, #36]	@ (8010ffc <find_volume+0x72c>)
 8010fd6:	611a      	str	r2, [r3, #16]
#if _FS_EXFAT
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 8010fd8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010fda:	4a09      	ldr	r2, [pc, #36]	@ (8011000 <find_volume+0x730>)
 8010fdc:	615a      	str	r2, [r3, #20]
#endif
#if _FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
 8010fde:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8010fe0:	f7fd f862 	bl	800e0a8 <clear_lock>
#endif
	return FR_OK;
 8010fe4:	2300      	movs	r3, #0
}
 8010fe6:	4618      	mov	r0, r3
 8010fe8:	3770      	adds	r7, #112	@ 0x70
 8010fea:	46bd      	mov	sp, r7
 8010fec:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8010ff0:	41615252 	.word	0x41615252
 8010ff4:	61417272 	.word	0x61417272
 8010ff8:	20002900 	.word	0x20002900
 8010ffc:	20002b84 	.word	0x20002b84
 8011000:	20002924 	.word	0x20002924

08011004 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 8011004:	b580      	push	{r7, lr}
 8011006:	b084      	sub	sp, #16
 8011008:	af00      	add	r7, sp, #0
 801100a:	6078      	str	r0, [r7, #4]
 801100c:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
 801100e:	2309      	movs	r3, #9
 8011010:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8011012:	687b      	ldr	r3, [r7, #4]
 8011014:	2b00      	cmp	r3, #0
 8011016:	d01c      	beq.n	8011052 <validate+0x4e>
 8011018:	687b      	ldr	r3, [r7, #4]
 801101a:	681b      	ldr	r3, [r3, #0]
 801101c:	2b00      	cmp	r3, #0
 801101e:	d018      	beq.n	8011052 <validate+0x4e>
 8011020:	687b      	ldr	r3, [r7, #4]
 8011022:	681b      	ldr	r3, [r3, #0]
 8011024:	781b      	ldrb	r3, [r3, #0]
 8011026:	2b00      	cmp	r3, #0
 8011028:	d013      	beq.n	8011052 <validate+0x4e>
 801102a:	687b      	ldr	r3, [r7, #4]
 801102c:	889a      	ldrh	r2, [r3, #4]
 801102e:	687b      	ldr	r3, [r7, #4]
 8011030:	681b      	ldr	r3, [r3, #0]
 8011032:	88db      	ldrh	r3, [r3, #6]
 8011034:	429a      	cmp	r2, r3
 8011036:	d10c      	bne.n	8011052 <validate+0x4e>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8011038:	687b      	ldr	r3, [r7, #4]
 801103a:	681b      	ldr	r3, [r3, #0]
 801103c:	785b      	ldrb	r3, [r3, #1]
 801103e:	4618      	mov	r0, r3
 8011040:	f7fc fbe6 	bl	800d810 <disk_status>
 8011044:	4603      	mov	r3, r0
 8011046:	f003 0301 	and.w	r3, r3, #1
 801104a:	2b00      	cmp	r3, #0
 801104c:	d101      	bne.n	8011052 <validate+0x4e>
			res = FR_OK;
 801104e:	2300      	movs	r3, #0
 8011050:	73fb      	strb	r3, [r7, #15]
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8011052:	7bfb      	ldrb	r3, [r7, #15]
 8011054:	2b00      	cmp	r3, #0
 8011056:	d102      	bne.n	801105e <validate+0x5a>
 8011058:	687b      	ldr	r3, [r7, #4]
 801105a:	681b      	ldr	r3, [r3, #0]
 801105c:	e000      	b.n	8011060 <validate+0x5c>
 801105e:	2300      	movs	r3, #0
 8011060:	683a      	ldr	r2, [r7, #0]
 8011062:	6013      	str	r3, [r2, #0]
	return res;
 8011064:	7bfb      	ldrb	r3, [r7, #15]
}
 8011066:	4618      	mov	r0, r3
 8011068:	3710      	adds	r7, #16
 801106a:	46bd      	mov	sp, r7
 801106c:	bd80      	pop	{r7, pc}
	...

08011070 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8011070:	b580      	push	{r7, lr}
 8011072:	b088      	sub	sp, #32
 8011074:	af00      	add	r7, sp, #0
 8011076:	60f8      	str	r0, [r7, #12]
 8011078:	60b9      	str	r1, [r7, #8]
 801107a:	4613      	mov	r3, r2
 801107c:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 801107e:	68bb      	ldr	r3, [r7, #8]
 8011080:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 8011082:	f107 0310 	add.w	r3, r7, #16
 8011086:	4618      	mov	r0, r3
 8011088:	f7ff fb7a 	bl	8010780 <get_ldnumber>
 801108c:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
 801108e:	69fb      	ldr	r3, [r7, #28]
 8011090:	2b00      	cmp	r3, #0
 8011092:	da01      	bge.n	8011098 <f_mount+0x28>
 8011094:	230b      	movs	r3, #11
 8011096:	e02b      	b.n	80110f0 <f_mount+0x80>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8011098:	4a17      	ldr	r2, [pc, #92]	@ (80110f8 <f_mount+0x88>)
 801109a:	69fb      	ldr	r3, [r7, #28]
 801109c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80110a0:	61bb      	str	r3, [r7, #24]

	if (cfs) {
 80110a2:	69bb      	ldr	r3, [r7, #24]
 80110a4:	2b00      	cmp	r3, #0
 80110a6:	d005      	beq.n	80110b4 <f_mount+0x44>
#if _FS_LOCK != 0
		clear_lock(cfs);
 80110a8:	69b8      	ldr	r0, [r7, #24]
 80110aa:	f7fc fffd 	bl	800e0a8 <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80110ae:	69bb      	ldr	r3, [r7, #24]
 80110b0:	2200      	movs	r2, #0
 80110b2:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 80110b4:	68fb      	ldr	r3, [r7, #12]
 80110b6:	2b00      	cmp	r3, #0
 80110b8:	d002      	beq.n	80110c0 <f_mount+0x50>
		fs->fs_type = 0;				/* Clear new fs object */
 80110ba:	68fb      	ldr	r3, [r7, #12]
 80110bc:	2200      	movs	r2, #0
 80110be:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80110c0:	68fa      	ldr	r2, [r7, #12]
 80110c2:	490d      	ldr	r1, [pc, #52]	@ (80110f8 <f_mount+0x88>)
 80110c4:	69fb      	ldr	r3, [r7, #28]
 80110c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80110ca:	68fb      	ldr	r3, [r7, #12]
 80110cc:	2b00      	cmp	r3, #0
 80110ce:	d002      	beq.n	80110d6 <f_mount+0x66>
 80110d0:	79fb      	ldrb	r3, [r7, #7]
 80110d2:	2b01      	cmp	r3, #1
 80110d4:	d001      	beq.n	80110da <f_mount+0x6a>
 80110d6:	2300      	movs	r3, #0
 80110d8:	e00a      	b.n	80110f0 <f_mount+0x80>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 80110da:	f107 010c 	add.w	r1, r7, #12
 80110de:	f107 0308 	add.w	r3, r7, #8
 80110e2:	2200      	movs	r2, #0
 80110e4:	4618      	mov	r0, r3
 80110e6:	f7ff fbf3 	bl	80108d0 <find_volume>
 80110ea:	4603      	mov	r3, r0
 80110ec:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
 80110ee:	7dfb      	ldrb	r3, [r7, #23]
}
 80110f0:	4618      	mov	r0, r3
 80110f2:	3720      	adds	r7, #32
 80110f4:	46bd      	mov	sp, r7
 80110f6:	bd80      	pop	{r7, pc}
 80110f8:	200028fc 	.word	0x200028fc

080110fc <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 80110fc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8011100:	b0a8      	sub	sp, #160	@ 0xa0
 8011102:	af00      	add	r7, sp, #0
 8011104:	6278      	str	r0, [r7, #36]	@ 0x24
 8011106:	6239      	str	r1, [r7, #32]
 8011108:	4613      	mov	r3, r2
 801110a:	77fb      	strb	r3, [r7, #31]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 801110c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801110e:	2b00      	cmp	r3, #0
 8011110:	d101      	bne.n	8011116 <f_open+0x1a>
 8011112:	2309      	movs	r3, #9
 8011114:	e2bc      	b.n	8011690 <f_open+0x594>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 8011116:	7ffb      	ldrb	r3, [r7, #31]
 8011118:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801111c:	77fb      	strb	r3, [r7, #31]
	res = find_volume(&path, &fs, mode);
 801111e:	7ffb      	ldrb	r3, [r7, #31]
 8011120:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
 8011124:	f107 0020 	add.w	r0, r7, #32
 8011128:	461a      	mov	r2, r3
 801112a:	f7ff fbd1 	bl	80108d0 <find_volume>
 801112e:	4603      	mov	r3, r0
 8011130:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
	if (res == FR_OK) {
 8011134:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8011138:	2b00      	cmp	r3, #0
 801113a:	f040 82a0 	bne.w	801167e <f_open+0x582>
		dj.obj.fs = fs;
 801113e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011140:	633b      	str	r3, [r7, #48]	@ 0x30
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 8011142:	6a3b      	ldr	r3, [r7, #32]
 8011144:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 8011148:	4619      	mov	r1, r3
 801114a:	4610      	mov	r0, r2
 801114c:	f7ff fa6a 	bl	8010624 <follow_path>
 8011150:	4603      	mov	r3, r0
 8011152:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 8011156:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 801115a:	2b00      	cmp	r3, #0
 801115c:	d118      	bne.n	8011190 <f_open+0x94>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 801115e:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 8011162:	b25b      	sxtb	r3, r3
 8011164:	2b00      	cmp	r3, #0
 8011166:	da03      	bge.n	8011170 <f_open+0x74>
				res = FR_INVALID_NAME;
 8011168:	2306      	movs	r3, #6
 801116a:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
 801116e:	e00f      	b.n	8011190 <f_open+0x94>
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8011170:	7ffb      	ldrb	r3, [r7, #31]
 8011172:	2b01      	cmp	r3, #1
 8011174:	bf8c      	ite	hi
 8011176:	2301      	movhi	r3, #1
 8011178:	2300      	movls	r3, #0
 801117a:	b2db      	uxtb	r3, r3
 801117c:	461a      	mov	r2, r3
 801117e:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8011182:	4611      	mov	r1, r2
 8011184:	4618      	mov	r0, r3
 8011186:	f7fc fe47 	bl	800de18 <chk_lock>
 801118a:	4603      	mov	r3, r0
 801118c:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8011190:	7ffb      	ldrb	r3, [r7, #31]
 8011192:	f003 031c 	and.w	r3, r3, #28
 8011196:	2b00      	cmp	r3, #0
 8011198:	f000 8117 	beq.w	80113ca <f_open+0x2ce>
			if (res != FR_OK) {					/* No file, create new */
 801119c:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80111a0:	2b00      	cmp	r3, #0
 80111a2:	d017      	beq.n	80111d4 <f_open+0xd8>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80111a4:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80111a8:	2b04      	cmp	r3, #4
 80111aa:	d10e      	bne.n	80111ca <f_open+0xce>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80111ac:	f7fc fe90 	bl	800ded0 <enq_lock>
 80111b0:	4603      	mov	r3, r0
 80111b2:	2b00      	cmp	r3, #0
 80111b4:	d006      	beq.n	80111c4 <f_open+0xc8>
 80111b6:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 80111ba:	4618      	mov	r0, r3
 80111bc:	f7fe fe78 	bl	800feb0 <dir_register>
 80111c0:	4603      	mov	r3, r0
 80111c2:	e000      	b.n	80111c6 <f_open+0xca>
 80111c4:	2312      	movs	r3, #18
 80111c6:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80111ca:	7ffb      	ldrb	r3, [r7, #31]
 80111cc:	f043 0308 	orr.w	r3, r3, #8
 80111d0:	77fb      	strb	r3, [r7, #31]
 80111d2:	e011      	b.n	80111f8 <f_open+0xfc>
			}
			else {								/* Any object is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80111d4:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 80111d8:	f003 0311 	and.w	r3, r3, #17
 80111dc:	2b00      	cmp	r3, #0
 80111de:	d003      	beq.n	80111e8 <f_open+0xec>
					res = FR_DENIED;
 80111e0:	2307      	movs	r3, #7
 80111e2:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
 80111e6:	e007      	b.n	80111f8 <f_open+0xfc>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 80111e8:	7ffb      	ldrb	r3, [r7, #31]
 80111ea:	f003 0304 	and.w	r3, r3, #4
 80111ee:	2b00      	cmp	r3, #0
 80111f0:	d002      	beq.n	80111f8 <f_open+0xfc>
 80111f2:	2308      	movs	r3, #8
 80111f4:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80111f8:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80111fc:	2b00      	cmp	r3, #0
 80111fe:	f040 8100 	bne.w	8011402 <f_open+0x306>
 8011202:	7ffb      	ldrb	r3, [r7, #31]
 8011204:	f003 0308 	and.w	r3, r3, #8
 8011208:	2b00      	cmp	r3, #0
 801120a:	f000 80fa 	beq.w	8011402 <f_open+0x306>
				dw = GET_FATTIME();
 801120e:	f7f9 f95d 	bl	800a4cc <get_fattime>
 8011212:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#if _FS_EXFAT
				if (fs->fs_type == FS_EXFAT) {
 8011216:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011218:	781b      	ldrb	r3, [r3, #0]
 801121a:	2b04      	cmp	r3, #4
 801121c:	f040 8085 	bne.w	801132a <f_open+0x22e>
					/* Get current allocation info */
					fp->obj.fs = fs;
 8011220:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011222:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011224:	601a      	str	r2, [r3, #0]
					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
 8011226:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011228:	695b      	ldr	r3, [r3, #20]
 801122a:	3334      	adds	r3, #52	@ 0x34
 801122c:	4618      	mov	r0, r3
 801122e:	f7fc fba7 	bl	800d980 <ld_dword>
 8011232:	4602      	mov	r2, r0
 8011234:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011236:	609a      	str	r2, [r3, #8]
					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 8011238:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801123a:	695b      	ldr	r3, [r3, #20]
 801123c:	3338      	adds	r3, #56	@ 0x38
 801123e:	4618      	mov	r0, r3
 8011240:	f7fc fbc1 	bl	800d9c6 <ld_qword>
 8011244:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011246:	e9c3 0104 	strd	r0, r1, [r3, #16]
					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
 801124a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801124c:	695b      	ldr	r3, [r3, #20]
 801124e:	3321      	adds	r3, #33	@ 0x21
 8011250:	781b      	ldrb	r3, [r3, #0]
 8011252:	f003 0302 	and.w	r3, r3, #2
 8011256:	b2db      	uxtb	r3, r3
 8011258:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801125a:	71d3      	strb	r3, [r2, #7]
					fp->obj.n_frag = 0;
 801125c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801125e:	2200      	movs	r2, #0
 8011260:	61da      	str	r2, [r3, #28]
					/* Initialize directory entry block */
					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
 8011262:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011264:	695b      	ldr	r3, [r3, #20]
 8011266:	3308      	adds	r3, #8
 8011268:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801126c:	4618      	mov	r0, r3
 801126e:	f7fc fca0 	bl	800dbb2 <st_dword>
					fs->dirbuf[XDIR_CrtTime10] = 0;
 8011272:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011274:	695b      	ldr	r3, [r3, #20]
 8011276:	f103 0214 	add.w	r2, r3, #20
 801127a:	2300      	movs	r3, #0
 801127c:	7013      	strb	r3, [r2, #0]
					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
 801127e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011280:	695b      	ldr	r3, [r3, #20]
 8011282:	330c      	adds	r3, #12
 8011284:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 8011288:	4618      	mov	r0, r3
 801128a:	f7fc fc92 	bl	800dbb2 <st_dword>
					fs->dirbuf[XDIR_ModTime10] = 0;
 801128e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011290:	695b      	ldr	r3, [r3, #20]
 8011292:	f103 0215 	add.w	r2, r3, #21
 8011296:	2300      	movs	r3, #0
 8011298:	7013      	strb	r3, [r2, #0]
					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
 801129a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801129c:	695b      	ldr	r3, [r3, #20]
 801129e:	1d1a      	adds	r2, r3, #4
 80112a0:	2320      	movs	r3, #32
 80112a2:	7013      	strb	r3, [r2, #0]
					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
 80112a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112a6:	695b      	ldr	r3, [r3, #20]
 80112a8:	3334      	adds	r3, #52	@ 0x34
 80112aa:	2100      	movs	r1, #0
 80112ac:	4618      	mov	r0, r3
 80112ae:	f7fc fc80 	bl	800dbb2 <st_dword>
					st_qword(fs->dirbuf + XDIR_FileSize, 0);
 80112b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112b4:	695b      	ldr	r3, [r3, #20]
 80112b6:	f103 0138 	add.w	r1, r3, #56	@ 0x38
 80112ba:	f04f 0200 	mov.w	r2, #0
 80112be:	f04f 0300 	mov.w	r3, #0
 80112c2:	4608      	mov	r0, r1
 80112c4:	f7fc fca1 	bl	800dc0a <st_qword>
					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
 80112c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112ca:	695b      	ldr	r3, [r3, #20]
 80112cc:	f103 0128 	add.w	r1, r3, #40	@ 0x28
 80112d0:	f04f 0200 	mov.w	r2, #0
 80112d4:	f04f 0300 	mov.w	r3, #0
 80112d8:	4608      	mov	r0, r1
 80112da:	f7fc fc96 	bl	800dc0a <st_qword>
					fs->dirbuf[XDIR_GenFlags] = 1;
 80112de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112e0:	695b      	ldr	r3, [r3, #20]
 80112e2:	f103 0221 	add.w	r2, r3, #33	@ 0x21
 80112e6:	2301      	movs	r3, #1
 80112e8:	7013      	strb	r3, [r2, #0]
					res = store_xdir(&dj);
 80112ea:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 80112ee:	4618      	mov	r0, r3
 80112f0:	f7fe fb2a 	bl	800f948 <store_xdir>
 80112f4:	4603      	mov	r3, r0
 80112f6:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
 80112fa:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80112fe:	2b00      	cmp	r3, #0
 8011300:	d17f      	bne.n	8011402 <f_open+0x306>
 8011302:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011304:	689b      	ldr	r3, [r3, #8]
 8011306:	2b00      	cmp	r3, #0
 8011308:	d07b      	beq.n	8011402 <f_open+0x306>
						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 801130a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801130c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801130e:	689b      	ldr	r3, [r3, #8]
 8011310:	2200      	movs	r2, #0
 8011312:	4619      	mov	r1, r3
 8011314:	f7fd fbbc 	bl	800ea90 <remove_chain>
 8011318:	4603      	mov	r3, r0
 801131a:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
 801131e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011320:	689b      	ldr	r3, [r3, #8]
 8011322:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011324:	3b01      	subs	r3, #1
 8011326:	6193      	str	r3, [r2, #24]
 8011328:	e06b      	b.n	8011402 <f_open+0x306>
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 801132a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801132c:	330e      	adds	r3, #14
 801132e:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 8011332:	4618      	mov	r0, r3
 8011334:	f7fc fc3d 	bl	800dbb2 <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 8011338:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801133a:	3316      	adds	r3, #22
 801133c:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 8011340:	4618      	mov	r0, r3
 8011342:	f7fc fc36 	bl	800dbb2 <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8011346:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8011348:	f103 020b 	add.w	r2, r3, #11
 801134c:	2320      	movs	r3, #32
 801134e:	7013      	strb	r3, [r2, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 8011350:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011352:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8011354:	4619      	mov	r1, r3
 8011356:	4610      	mov	r0, r2
 8011358:	f7fd ff71 	bl	800f23e <ld_clust>
 801135c:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 8011360:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8011362:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8011364:	2200      	movs	r2, #0
 8011366:	4619      	mov	r1, r3
 8011368:	f7fd ff88 	bl	800f27c <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
 801136c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801136e:	331c      	adds	r3, #28
 8011370:	2100      	movs	r1, #0
 8011372:	4618      	mov	r0, r3
 8011374:	f7fc fc1d 	bl	800dbb2 <st_dword>
					fs->wflag = 1;
 8011378:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801137a:	2301      	movs	r3, #1
 801137c:	70d3      	strb	r3, [r2, #3]

					if (cl) {							/* Remove the cluster chain if exist */
 801137e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8011382:	2b00      	cmp	r3, #0
 8011384:	d03d      	beq.n	8011402 <f_open+0x306>
						dw = fs->winsect;
 8011386:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011388:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801138a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
						res = remove_chain(&dj.obj, cl, 0);
 801138e:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8011392:	2200      	movs	r2, #0
 8011394:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 8011398:	4618      	mov	r0, r3
 801139a:	f7fd fb79 	bl	800ea90 <remove_chain>
 801139e:	4603      	mov	r3, r0
 80113a0:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
						if (res == FR_OK) {
 80113a4:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80113a8:	2b00      	cmp	r3, #0
 80113aa:	d12a      	bne.n	8011402 <f_open+0x306>
							res = move_window(fs, dw);
 80113ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113ae:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 80113b2:	4618      	mov	r0, r3
 80113b4:	f7fc fee0 	bl	800e178 <move_window>
 80113b8:	4603      	mov	r3, r0
 80113ba:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80113be:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80113c0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80113c4:	3b01      	subs	r3, #1
 80113c6:	6193      	str	r3, [r2, #24]
 80113c8:	e01b      	b.n	8011402 <f_open+0x306>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
 80113ca:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80113ce:	2b00      	cmp	r3, #0
 80113d0:	d117      	bne.n	8011402 <f_open+0x306>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 80113d2:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 80113d6:	f003 0310 	and.w	r3, r3, #16
 80113da:	2b00      	cmp	r3, #0
 80113dc:	d003      	beq.n	80113e6 <f_open+0x2ea>
					res = FR_NO_FILE;
 80113de:	2304      	movs	r3, #4
 80113e0:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
 80113e4:	e00d      	b.n	8011402 <f_open+0x306>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 80113e6:	7ffb      	ldrb	r3, [r7, #31]
 80113e8:	f003 0302 	and.w	r3, r3, #2
 80113ec:	2b00      	cmp	r3, #0
 80113ee:	d008      	beq.n	8011402 <f_open+0x306>
 80113f0:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 80113f4:	f003 0301 	and.w	r3, r3, #1
 80113f8:	2b00      	cmp	r3, #0
 80113fa:	d002      	beq.n	8011402 <f_open+0x306>
						res = FR_DENIED;
 80113fc:	2307      	movs	r3, #7
 80113fe:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
					}
				}
			}
		}
		if (res == FR_OK) {
 8011402:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8011406:	2b00      	cmp	r3, #0
 8011408:	d126      	bne.n	8011458 <f_open+0x35c>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 801140a:	7ffb      	ldrb	r3, [r7, #31]
 801140c:	f003 0308 	and.w	r3, r3, #8
 8011410:	2b00      	cmp	r3, #0
 8011412:	d003      	beq.n	801141c <f_open+0x320>
				mode |= FA_MODIFIED;
 8011414:	7ffb      	ldrb	r3, [r7, #31]
 8011416:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801141a:	77fb      	strb	r3, [r7, #31]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 801141c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801141e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8011420:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011422:	649a      	str	r2, [r3, #72]	@ 0x48
			fp->dir_ptr = dj.dir;
 8011424:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8011426:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011428:	64da      	str	r2, [r3, #76]	@ 0x4c
#if _FS_LOCK != 0
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 801142a:	7ffb      	ldrb	r3, [r7, #31]
 801142c:	2b01      	cmp	r3, #1
 801142e:	bf8c      	ite	hi
 8011430:	2301      	movhi	r3, #1
 8011432:	2300      	movls	r3, #0
 8011434:	b2db      	uxtb	r3, r3
 8011436:	461a      	mov	r2, r3
 8011438:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 801143c:	4611      	mov	r1, r2
 801143e:	4618      	mov	r0, r3
 8011440:	f7fc fd68 	bl	800df14 <inc_lock>
 8011444:	4602      	mov	r2, r0
 8011446:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011448:	62da      	str	r2, [r3, #44]	@ 0x2c
			if (!fp->obj.lockid) res = FR_INT_ERR;
 801144a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801144c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801144e:	2b00      	cmp	r3, #0
 8011450:	d102      	bne.n	8011458 <f_open+0x35c>
 8011452:	2302      	movs	r3, #2
 8011454:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
				}
			}
		}
#endif

		if (res == FR_OK) {
 8011458:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 801145c:	2b00      	cmp	r3, #0
 801145e:	f040 810e 	bne.w	801167e <f_open+0x582>
#if _FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8011462:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011464:	781b      	ldrb	r3, [r3, #0]
 8011466:	2b04      	cmp	r3, #4
 8011468:	d12d      	bne.n	80114c6 <f_open+0x3ca>
				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 801146a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801146c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801146e:	621a      	str	r2, [r3, #32]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 8011470:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8011474:	4613      	mov	r3, r2
 8011476:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 801147a:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
 801147e:	431a      	orrs	r2, r3
 8011480:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011482:	625a      	str	r2, [r3, #36]	@ 0x24
				fp->obj.c_ofs = dj.blk_ofs;
 8011484:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8011486:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011488:	629a      	str	r2, [r3, #40]	@ 0x28
				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object allocation info */
 801148a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801148c:	695b      	ldr	r3, [r3, #20]
 801148e:	3334      	adds	r3, #52	@ 0x34
 8011490:	4618      	mov	r0, r3
 8011492:	f7fc fa75 	bl	800d980 <ld_dword>
 8011496:	4602      	mov	r2, r0
 8011498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801149a:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 801149c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801149e:	695b      	ldr	r3, [r3, #20]
 80114a0:	3338      	adds	r3, #56	@ 0x38
 80114a2:	4618      	mov	r0, r3
 80114a4:	f7fc fa8f 	bl	800d9c6 <ld_qword>
 80114a8:	4602      	mov	r2, r0
 80114aa:	460b      	mov	r3, r1
 80114ac:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80114ae:	e9c1 2304 	strd	r2, r3, [r1, #16]
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
 80114b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80114b4:	695b      	ldr	r3, [r3, #20]
 80114b6:	3321      	adds	r3, #33	@ 0x21
 80114b8:	781b      	ldrb	r3, [r3, #0]
 80114ba:	f003 0302 	and.w	r3, r3, #2
 80114be:	b2da      	uxtb	r2, r3
 80114c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114c2:	71da      	strb	r2, [r3, #7]
 80114c4:	e016      	b.n	80114f4 <f_open+0x3f8>
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 80114c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80114c8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80114ca:	4619      	mov	r1, r3
 80114cc:	4610      	mov	r0, r2
 80114ce:	f7fd feb6 	bl	800f23e <ld_clust>
 80114d2:	4602      	mov	r2, r0
 80114d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114d6:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 80114d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80114da:	331c      	adds	r3, #28
 80114dc:	4618      	mov	r0, r3
 80114de:	f7fc fa4f 	bl	800d980 <ld_dword>
 80114e2:	4603      	mov	r3, r0
 80114e4:	2200      	movs	r2, #0
 80114e6:	613b      	str	r3, [r7, #16]
 80114e8:	617a      	str	r2, [r7, #20]
 80114ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114ec:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 80114f0:	e9c3 1204 	strd	r1, r2, [r3, #16]
			}
#if _USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
 80114f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114f6:	2200      	movs	r2, #0
 80114f8:	651a      	str	r2, [r3, #80]	@ 0x50
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
 80114fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80114fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114fe:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
 8011500:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011502:	88da      	ldrh	r2, [r3, #6]
 8011504:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011506:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
 8011508:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801150a:	7ffa      	ldrb	r2, [r7, #31]
 801150c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
			fp->err = 0;			/* Clear error flag */
 8011510:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011512:	2200      	movs	r2, #0
 8011514:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
			fp->sect = 0;			/* Invalidate current data sector */
 8011518:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801151a:	2200      	movs	r2, #0
 801151c:	645a      	str	r2, [r3, #68]	@ 0x44
			fp->fptr = 0;			/* Set file pointer top of the file */
 801151e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8011520:	f04f 0200 	mov.w	r2, #0
 8011524:	f04f 0300 	mov.w	r3, #0
 8011528:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
#if !_FS_READONLY
#if !_FS_TINY
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 801152c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801152e:	3354      	adds	r3, #84	@ 0x54
 8011530:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8011534:	2100      	movs	r1, #0
 8011536:	4618      	mov	r0, r3
 8011538:	f7fc fc10 	bl	800dd5c <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 801153c:	7ffb      	ldrb	r3, [r7, #31]
 801153e:	f003 0320 	and.w	r3, r3, #32
 8011542:	2b00      	cmp	r3, #0
 8011544:	f000 809b 	beq.w	801167e <f_open+0x582>
 8011548:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801154a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 801154e:	4313      	orrs	r3, r2
 8011550:	f000 8095 	beq.w	801167e <f_open+0x582>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8011554:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011556:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 801155a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801155c:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8011560:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011562:	895b      	ldrh	r3, [r3, #10]
 8011564:	461a      	mov	r2, r3
 8011566:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011568:	899b      	ldrh	r3, [r3, #12]
 801156a:	fb02 f303 	mul.w	r3, r2, r3
 801156e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8011572:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011574:	689b      	ldr	r3, [r3, #8]
 8011576:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 801157a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801157c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8011580:	e9c7 2324 	strd	r2, r3, [r7, #144]	@ 0x90
 8011584:	e023      	b.n	80115ce <f_open+0x4d2>
					clst = get_fat(&fp->obj, clst);
 8011586:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011588:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801158c:	4618      	mov	r0, r3
 801158e:	f7fc feb1 	bl	800e2f4 <get_fat>
 8011592:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
					if (clst <= 1) res = FR_INT_ERR;
 8011596:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801159a:	2b01      	cmp	r3, #1
 801159c:	d802      	bhi.n	80115a4 <f_open+0x4a8>
 801159e:	2302      	movs	r3, #2
 80115a0:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 80115a4:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 80115a8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80115ac:	d102      	bne.n	80115b4 <f_open+0x4b8>
 80115ae:	2301      	movs	r3, #1
 80115b0:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 80115b4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80115b8:	2200      	movs	r2, #0
 80115ba:	4698      	mov	r8, r3
 80115bc:	4691      	mov	r9, r2
 80115be:	e9d7 2324 	ldrd	r2, r3, [r7, #144]	@ 0x90
 80115c2:	ebb2 0a08 	subs.w	sl, r2, r8
 80115c6:	eb63 0b09 	sbc.w	fp, r3, r9
 80115ca:	e9c7 ab24 	strd	sl, fp, [r7, #144]	@ 0x90
 80115ce:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80115d2:	2b00      	cmp	r3, #0
 80115d4:	d10a      	bne.n	80115ec <f_open+0x4f0>
 80115d6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80115da:	2200      	movs	r2, #0
 80115dc:	461c      	mov	r4, r3
 80115de:	4615      	mov	r5, r2
 80115e0:	e9d7 2324 	ldrd	r2, r3, [r7, #144]	@ 0x90
 80115e4:	4294      	cmp	r4, r2
 80115e6:	eb75 0303 	sbcs.w	r3, r5, r3
 80115ea:	d3cc      	bcc.n	8011586 <f_open+0x48a>
				}
				fp->clust = clst;
 80115ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80115ee:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 80115f2:	641a      	str	r2, [r3, #64]	@ 0x40
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 80115f4:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80115f8:	2b00      	cmp	r3, #0
 80115fa:	d140      	bne.n	801167e <f_open+0x582>
 80115fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80115fe:	899b      	ldrh	r3, [r3, #12]
 8011600:	b29b      	uxth	r3, r3
 8011602:	2200      	movs	r2, #0
 8011604:	60bb      	str	r3, [r7, #8]
 8011606:	60fa      	str	r2, [r7, #12]
 8011608:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
 801160c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8011610:	f7ef fa4c 	bl	8000aac <__aeabi_uldivmod>
 8011614:	4313      	orrs	r3, r2
 8011616:	d032      	beq.n	801167e <f_open+0x582>
					if ((sc = clust2sect(fs, clst)) == 0) {
 8011618:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801161a:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801161e:	4618      	mov	r0, r3
 8011620:	f7fc fe48 	bl	800e2b4 <clust2sect>
 8011624:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 8011628:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801162c:	2b00      	cmp	r3, #0
 801162e:	d103      	bne.n	8011638 <f_open+0x53c>
						res = FR_INT_ERR;
 8011630:	2302      	movs	r3, #2
 8011632:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
 8011636:	e022      	b.n	801167e <f_open+0x582>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8011638:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801163a:	899b      	ldrh	r3, [r3, #12]
 801163c:	b29b      	uxth	r3, r3
 801163e:	2200      	movs	r2, #0
 8011640:	603b      	str	r3, [r7, #0]
 8011642:	607a      	str	r2, [r7, #4]
 8011644:	e9d7 2300 	ldrd	r2, r3, [r7]
 8011648:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
 801164c:	f7ef fa2e 	bl	8000aac <__aeabi_uldivmod>
 8011650:	4602      	mov	r2, r0
 8011652:	460b      	mov	r3, r1
 8011654:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8011658:	441a      	add	r2, r3
 801165a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801165c:	645a      	str	r2, [r3, #68]	@ 0x44
#if !_FS_TINY
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 801165e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011660:	7858      	ldrb	r0, [r3, #1]
 8011662:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011664:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8011668:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801166a:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 801166c:	2301      	movs	r3, #1
 801166e:	f7fc f911 	bl	800d894 <disk_read>
 8011672:	4603      	mov	r3, r0
 8011674:	2b00      	cmp	r3, #0
 8011676:	d002      	beq.n	801167e <f_open+0x582>
 8011678:	2301      	movs	r3, #1
 801167a:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 801167e:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8011682:	2b00      	cmp	r3, #0
 8011684:	d002      	beq.n	801168c <f_open+0x590>
 8011686:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011688:	2200      	movs	r2, #0
 801168a:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 801168c:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
}
 8011690:	4618      	mov	r0, r3
 8011692:	37a0      	adds	r7, #160	@ 0xa0
 8011694:	46bd      	mov	sp, r7
 8011696:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0801169a <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 801169a:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801169e:	b098      	sub	sp, #96	@ 0x60
 80116a0:	af00      	add	r7, sp, #0
 80116a2:	62f8      	str	r0, [r7, #44]	@ 0x2c
 80116a4:	62b9      	str	r1, [r7, #40]	@ 0x28
 80116a6:	627a      	str	r2, [r7, #36]	@ 0x24
 80116a8:	623b      	str	r3, [r7, #32]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
 80116aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80116ac:	64fb      	str	r3, [r7, #76]	@ 0x4c


	*br = 0;	/* Clear read byte counter */
 80116ae:	6a3a      	ldr	r2, [r7, #32]
 80116b0:	2300      	movs	r3, #0
 80116b2:	6013      	str	r3, [r2, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 80116b4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80116b6:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80116ba:	4619      	mov	r1, r3
 80116bc:	4610      	mov	r0, r2
 80116be:	f7ff fca1 	bl	8011004 <validate>
 80116c2:	4603      	mov	r3, r0
 80116c4:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 80116c8:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 80116cc:	2b00      	cmp	r3, #0
 80116ce:	d108      	bne.n	80116e2 <f_read+0x48>
 80116d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116d2:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 80116d6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 80116da:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 80116de:	2b00      	cmp	r3, #0
 80116e0:	d002      	beq.n	80116e8 <f_read+0x4e>
 80116e2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 80116e6:	e16b      	b.n	80119c0 <f_read+0x326>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 80116e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116ea:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80116ee:	f003 0301 	and.w	r3, r3, #1
 80116f2:	2b00      	cmp	r3, #0
 80116f4:	d101      	bne.n	80116fa <f_read+0x60>
 80116f6:	2307      	movs	r3, #7
 80116f8:	e162      	b.n	80119c0 <f_read+0x326>
	remain = fp->obj.objsize - fp->fptr;
 80116fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116fc:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8011700:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011702:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011706:	ebb0 0802 	subs.w	r8, r0, r2
 801170a:	eb61 0903 	sbc.w	r9, r1, r3
 801170e:	e9c7 8910 	strd	r8, r9, [r7, #64]	@ 0x40
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8011712:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011714:	2200      	movs	r2, #0
 8011716:	461c      	mov	r4, r3
 8011718:	4615      	mov	r5, r2
 801171a:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 801171e:	42a2      	cmp	r2, r4
 8011720:	41ab      	sbcs	r3, r5
 8011722:	f080 8148 	bcs.w	80119b6 <f_read+0x31c>
 8011726:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8011728:	627b      	str	r3, [r7, #36]	@ 0x24

	for ( ;  btr;								/* Repeat until all data read */
 801172a:	e144      	b.n	80119b6 <f_read+0x31c>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 801172c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801172e:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011732:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011734:	899b      	ldrh	r3, [r3, #12]
 8011736:	b29b      	uxth	r3, r3
 8011738:	2200      	movs	r2, #0
 801173a:	61bb      	str	r3, [r7, #24]
 801173c:	61fa      	str	r2, [r7, #28]
 801173e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8011742:	f7ef f9b3 	bl	8000aac <__aeabi_uldivmod>
 8011746:	4313      	orrs	r3, r2
 8011748:	f040 80e9 	bne.w	801191e <f_read+0x284>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 801174c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801174e:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011752:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011754:	899b      	ldrh	r3, [r3, #12]
 8011756:	b29b      	uxth	r3, r3
 8011758:	2200      	movs	r2, #0
 801175a:	613b      	str	r3, [r7, #16]
 801175c:	617a      	str	r2, [r7, #20]
 801175e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8011762:	f7ef f9a3 	bl	8000aac <__aeabi_uldivmod>
 8011766:	4602      	mov	r2, r0
 8011768:	460b      	mov	r3, r1
 801176a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801176c:	895b      	ldrh	r3, [r3, #10]
 801176e:	3b01      	subs	r3, #1
 8011770:	4013      	ands	r3, r2
 8011772:	63fb      	str	r3, [r7, #60]	@ 0x3c
			if (csect == 0) {					/* On the cluster boundary? */
 8011774:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011776:	2b00      	cmp	r3, #0
 8011778:	d132      	bne.n	80117e0 <f_read+0x146>
				if (fp->fptr == 0) {			/* On the top of the file? */
 801177a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801177c:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011780:	4313      	orrs	r3, r2
 8011782:	d103      	bne.n	801178c <f_read+0xf2>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8011784:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011786:	689b      	ldr	r3, [r3, #8]
 8011788:	65bb      	str	r3, [r7, #88]	@ 0x58
 801178a:	e013      	b.n	80117b4 <f_read+0x11a>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 801178c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801178e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011790:	2b00      	cmp	r3, #0
 8011792:	d007      	beq.n	80117a4 <f_read+0x10a>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8011794:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011796:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 801179a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801179c:	f7fd fb2d 	bl	800edfa <clmt_clust>
 80117a0:	65b8      	str	r0, [r7, #88]	@ 0x58
 80117a2:	e007      	b.n	80117b4 <f_read+0x11a>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 80117a4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80117a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117a8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80117aa:	4619      	mov	r1, r3
 80117ac:	4610      	mov	r0, r2
 80117ae:	f7fc fda1 	bl	800e2f4 <get_fat>
 80117b2:	65b8      	str	r0, [r7, #88]	@ 0x58
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 80117b4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80117b6:	2b01      	cmp	r3, #1
 80117b8:	d805      	bhi.n	80117c6 <f_read+0x12c>
 80117ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117bc:	2202      	movs	r2, #2
 80117be:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80117c2:	2302      	movs	r3, #2
 80117c4:	e0fc      	b.n	80119c0 <f_read+0x326>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80117c6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80117c8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80117cc:	d105      	bne.n	80117da <f_read+0x140>
 80117ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117d0:	2201      	movs	r2, #1
 80117d2:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80117d6:	2301      	movs	r3, #1
 80117d8:	e0f2      	b.n	80119c0 <f_read+0x326>
				fp->clust = clst;				/* Update current cluster */
 80117da:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117dc:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80117de:	641a      	str	r2, [r3, #64]	@ 0x40
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 80117e0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80117e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117e4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80117e6:	4619      	mov	r1, r3
 80117e8:	4610      	mov	r0, r2
 80117ea:	f7fc fd63 	bl	800e2b4 <clust2sect>
 80117ee:	63b8      	str	r0, [r7, #56]	@ 0x38
			if (!sect) ABORT(fs, FR_INT_ERR);
 80117f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80117f2:	2b00      	cmp	r3, #0
 80117f4:	d105      	bne.n	8011802 <f_read+0x168>
 80117f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117f8:	2202      	movs	r2, #2
 80117fa:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80117fe:	2302      	movs	r3, #2
 8011800:	e0de      	b.n	80119c0 <f_read+0x326>
			sect += csect;
 8011802:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011804:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011806:	4413      	add	r3, r2
 8011808:	63bb      	str	r3, [r7, #56]	@ 0x38
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 801180a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801180c:	899b      	ldrh	r3, [r3, #12]
 801180e:	461a      	mov	r2, r3
 8011810:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011812:	fbb3 f3f2 	udiv	r3, r3, r2
 8011816:	653b      	str	r3, [r7, #80]	@ 0x50
			if (cc) {							/* Read maximum contiguous sectors directly */
 8011818:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801181a:	2b00      	cmp	r3, #0
 801181c:	d043      	beq.n	80118a6 <f_read+0x20c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 801181e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011820:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8011822:	4413      	add	r3, r2
 8011824:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011826:	8952      	ldrh	r2, [r2, #10]
 8011828:	4293      	cmp	r3, r2
 801182a:	d905      	bls.n	8011838 <f_read+0x19e>
					cc = fs->csize - csect;
 801182c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801182e:	895b      	ldrh	r3, [r3, #10]
 8011830:	461a      	mov	r2, r3
 8011832:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011834:	1ad3      	subs	r3, r2, r3
 8011836:	653b      	str	r3, [r7, #80]	@ 0x50
				}
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8011838:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801183a:	7858      	ldrb	r0, [r3, #1]
 801183c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801183e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011840:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8011842:	f7fc f827 	bl	800d894 <disk_read>
 8011846:	4603      	mov	r3, r0
 8011848:	2b00      	cmp	r3, #0
 801184a:	d005      	beq.n	8011858 <f_read+0x1be>
 801184c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801184e:	2201      	movs	r2, #1
 8011850:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011854:	2301      	movs	r3, #1
 8011856:	e0b3      	b.n	80119c0 <f_read+0x326>
#if _FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8011858:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801185a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 801185e:	b25b      	sxtb	r3, r3
 8011860:	2b00      	cmp	r3, #0
 8011862:	da18      	bge.n	8011896 <f_read+0x1fc>
 8011864:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011866:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011868:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801186a:	1ad3      	subs	r3, r2, r3
 801186c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801186e:	429a      	cmp	r2, r3
 8011870:	d911      	bls.n	8011896 <f_read+0x1fc>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8011872:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011874:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011876:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011878:	1ad3      	subs	r3, r2, r3
 801187a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801187c:	8992      	ldrh	r2, [r2, #12]
 801187e:	fb02 f303 	mul.w	r3, r2, r3
 8011882:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011884:	18d0      	adds	r0, r2, r3
 8011886:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011888:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 801188c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801188e:	899b      	ldrh	r3, [r3, #12]
 8011890:	461a      	mov	r2, r3
 8011892:	f7fc fa42 	bl	800dd1a <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8011896:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011898:	899b      	ldrh	r3, [r3, #12]
 801189a:	461a      	mov	r2, r3
 801189c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801189e:	fb02 f303 	mul.w	r3, r2, r3
 80118a2:	657b      	str	r3, [r7, #84]	@ 0x54
				continue;
 80118a4:	e067      	b.n	8011976 <f_read+0x2dc>
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 80118a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118a8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80118aa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80118ac:	429a      	cmp	r2, r3
 80118ae:	d033      	beq.n	8011918 <f_read+0x27e>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 80118b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118b2:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80118b6:	b25b      	sxtb	r3, r3
 80118b8:	2b00      	cmp	r3, #0
 80118ba:	da1b      	bge.n	80118f4 <f_read+0x25a>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80118bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118be:	7858      	ldrb	r0, [r3, #1]
 80118c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118c2:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 80118c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118c8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80118ca:	2301      	movs	r3, #1
 80118cc:	f7fc f802 	bl	800d8d4 <disk_write>
 80118d0:	4603      	mov	r3, r0
 80118d2:	2b00      	cmp	r3, #0
 80118d4:	d005      	beq.n	80118e2 <f_read+0x248>
 80118d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118d8:	2201      	movs	r2, #1
 80118da:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80118de:	2301      	movs	r3, #1
 80118e0:	e06e      	b.n	80119c0 <f_read+0x326>
					fp->flag &= (BYTE)~FA_DIRTY;
 80118e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118e4:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80118e8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80118ec:	b2da      	uxtb	r2, r3
 80118ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118f0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 80118f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118f6:	7858      	ldrb	r0, [r3, #1]
 80118f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118fa:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 80118fe:	2301      	movs	r3, #1
 8011900:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011902:	f7fb ffc7 	bl	800d894 <disk_read>
 8011906:	4603      	mov	r3, r0
 8011908:	2b00      	cmp	r3, #0
 801190a:	d005      	beq.n	8011918 <f_read+0x27e>
 801190c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801190e:	2201      	movs	r2, #1
 8011910:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011914:	2301      	movs	r3, #1
 8011916:	e053      	b.n	80119c0 <f_read+0x326>
			}
#endif
			fp->sect = sect;
 8011918:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801191a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801191c:	645a      	str	r2, [r3, #68]	@ 0x44
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 801191e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011920:	899b      	ldrh	r3, [r3, #12]
 8011922:	4618      	mov	r0, r3
 8011924:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011926:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 801192a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801192c:	899b      	ldrh	r3, [r3, #12]
 801192e:	fbb2 f1f3 	udiv	r1, r2, r3
 8011932:	fb01 f303 	mul.w	r3, r1, r3
 8011936:	1ad3      	subs	r3, r2, r3
 8011938:	1ac3      	subs	r3, r0, r3
 801193a:	657b      	str	r3, [r7, #84]	@ 0x54
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 801193c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801193e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011940:	429a      	cmp	r2, r3
 8011942:	d901      	bls.n	8011948 <f_read+0x2ae>
 8011944:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011946:	657b      	str	r3, [r7, #84]	@ 0x54
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8011948:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801194a:	f103 0454 	add.w	r4, r3, #84	@ 0x54
 801194e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011950:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011954:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011956:	899b      	ldrh	r3, [r3, #12]
 8011958:	b29b      	uxth	r3, r3
 801195a:	2200      	movs	r2, #0
 801195c:	60bb      	str	r3, [r7, #8]
 801195e:	60fa      	str	r2, [r7, #12]
 8011960:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8011964:	f7ef f8a2 	bl	8000aac <__aeabi_uldivmod>
 8011968:	4613      	mov	r3, r2
 801196a:	4423      	add	r3, r4
 801196c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801196e:	4619      	mov	r1, r3
 8011970:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8011972:	f7fc f9d2 	bl	800dd1a <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8011976:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011978:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801197a:	4413      	add	r3, r2
 801197c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801197e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011980:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011984:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8011986:	2000      	movs	r0, #0
 8011988:	468a      	mov	sl, r1
 801198a:	4683      	mov	fp, r0
 801198c:	eb12 010a 	adds.w	r1, r2, sl
 8011990:	6039      	str	r1, [r7, #0]
 8011992:	eb43 030b 	adc.w	r3, r3, fp
 8011996:	607b      	str	r3, [r7, #4]
 8011998:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801199a:	e9d7 1200 	ldrd	r1, r2, [r7]
 801199e:	e9c3 120e 	strd	r1, r2, [r3, #56]	@ 0x38
 80119a2:	6a3b      	ldr	r3, [r7, #32]
 80119a4:	681a      	ldr	r2, [r3, #0]
 80119a6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80119a8:	441a      	add	r2, r3
 80119aa:	6a3b      	ldr	r3, [r7, #32]
 80119ac:	601a      	str	r2, [r3, #0]
 80119ae:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80119b0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80119b2:	1ad3      	subs	r3, r2, r3
 80119b4:	627b      	str	r3, [r7, #36]	@ 0x24
	for ( ;  btr;								/* Repeat until all data read */
 80119b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80119b8:	2b00      	cmp	r3, #0
 80119ba:	f47f aeb7 	bne.w	801172c <f_read+0x92>
#endif
	}

	LEAVE_FF(fs, FR_OK);
 80119be:	2300      	movs	r3, #0
}
 80119c0:	4618      	mov	r0, r3
 80119c2:	3760      	adds	r7, #96	@ 0x60
 80119c4:	46bd      	mov	sp, r7
 80119c6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080119ca <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 80119ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80119ce:	b091      	sub	sp, #68	@ 0x44
 80119d0:	af00      	add	r7, sp, #0
 80119d2:	61f8      	str	r0, [r7, #28]
 80119d4:	61b9      	str	r1, [r7, #24]
 80119d6:	617a      	str	r2, [r7, #20]
 80119d8:	613b      	str	r3, [r7, #16]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;
 80119da:	69bb      	ldr	r3, [r7, #24]
 80119dc:	62fb      	str	r3, [r7, #44]	@ 0x2c


	*bw = 0;	/* Clear write byte counter */
 80119de:	693b      	ldr	r3, [r7, #16]
 80119e0:	2200      	movs	r2, #0
 80119e2:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 80119e4:	69fb      	ldr	r3, [r7, #28]
 80119e6:	f107 0220 	add.w	r2, r7, #32
 80119ea:	4611      	mov	r1, r2
 80119ec:	4618      	mov	r0, r3
 80119ee:	f7ff fb09 	bl	8011004 <validate>
 80119f2:	4603      	mov	r3, r0
 80119f4:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 80119f8:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 80119fc:	2b00      	cmp	r3, #0
 80119fe:	d108      	bne.n	8011a12 <f_write+0x48>
 8011a00:	69fb      	ldr	r3, [r7, #28]
 8011a02:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8011a06:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 8011a0a:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8011a0e:	2b00      	cmp	r3, #0
 8011a10:	d002      	beq.n	8011a18 <f_write+0x4e>
 8011a12:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8011a16:	e1aa      	b.n	8011d6e <f_write+0x3a4>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8011a18:	69fb      	ldr	r3, [r7, #28]
 8011a1a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011a1e:	f003 0302 	and.w	r3, r3, #2
 8011a22:	2b00      	cmp	r3, #0
 8011a24:	d101      	bne.n	8011a2a <f_write+0x60>
 8011a26:	2307      	movs	r3, #7
 8011a28:	e1a1      	b.n	8011d6e <f_write+0x3a4>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8011a2a:	6a3b      	ldr	r3, [r7, #32]
 8011a2c:	781b      	ldrb	r3, [r3, #0]
 8011a2e:	2b04      	cmp	r3, #4
 8011a30:	f000 818d 	beq.w	8011d4e <f_write+0x384>
 8011a34:	69fb      	ldr	r3, [r7, #28]
 8011a36:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011a3a:	697b      	ldr	r3, [r7, #20]
 8011a3c:	18d1      	adds	r1, r2, r3
 8011a3e:	69fb      	ldr	r3, [r7, #28]
 8011a40:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011a44:	4613      	mov	r3, r2
 8011a46:	4299      	cmp	r1, r3
 8011a48:	f080 8181 	bcs.w	8011d4e <f_write+0x384>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8011a4c:	69fb      	ldr	r3, [r7, #28]
 8011a4e:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011a52:	4613      	mov	r3, r2
 8011a54:	43db      	mvns	r3, r3
 8011a56:	617b      	str	r3, [r7, #20]
	}

	for ( ;  btw;							/* Repeat until all data written */
 8011a58:	e179      	b.n	8011d4e <f_write+0x384>
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8011a5a:	69fb      	ldr	r3, [r7, #28]
 8011a5c:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011a60:	6a3b      	ldr	r3, [r7, #32]
 8011a62:	899b      	ldrh	r3, [r3, #12]
 8011a64:	b29b      	uxth	r3, r3
 8011a66:	2200      	movs	r2, #0
 8011a68:	461d      	mov	r5, r3
 8011a6a:	4616      	mov	r6, r2
 8011a6c:	462a      	mov	r2, r5
 8011a6e:	4633      	mov	r3, r6
 8011a70:	f7ef f81c 	bl	8000aac <__aeabi_uldivmod>
 8011a74:	4313      	orrs	r3, r2
 8011a76:	f040 810a 	bne.w	8011c8e <f_write+0x2c4>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8011a7a:	69fb      	ldr	r3, [r7, #28]
 8011a7c:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011a80:	6a3b      	ldr	r3, [r7, #32]
 8011a82:	899b      	ldrh	r3, [r3, #12]
 8011a84:	b29b      	uxth	r3, r3
 8011a86:	2200      	movs	r2, #0
 8011a88:	60bb      	str	r3, [r7, #8]
 8011a8a:	60fa      	str	r2, [r7, #12]
 8011a8c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8011a90:	f7ef f80c 	bl	8000aac <__aeabi_uldivmod>
 8011a94:	4602      	mov	r2, r0
 8011a96:	460b      	mov	r3, r1
 8011a98:	6a3b      	ldr	r3, [r7, #32]
 8011a9a:	895b      	ldrh	r3, [r3, #10]
 8011a9c:	3b01      	subs	r3, #1
 8011a9e:	4013      	ands	r3, r2
 8011aa0:	62bb      	str	r3, [r7, #40]	@ 0x28
			if (csect == 0) {				/* On the cluster boundary? */
 8011aa2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011aa4:	2b00      	cmp	r3, #0
 8011aa6:	d146      	bne.n	8011b36 <f_write+0x16c>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8011aa8:	69fb      	ldr	r3, [r7, #28]
 8011aaa:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011aae:	4313      	orrs	r3, r2
 8011ab0:	d10c      	bne.n	8011acc <f_write+0x102>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8011ab2:	69fb      	ldr	r3, [r7, #28]
 8011ab4:	689b      	ldr	r3, [r3, #8]
 8011ab6:	63bb      	str	r3, [r7, #56]	@ 0x38
					if (clst == 0) {		/* If no cluster is allocated, */
 8011ab8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011aba:	2b00      	cmp	r3, #0
 8011abc:	d11a      	bne.n	8011af4 <f_write+0x12a>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8011abe:	69fb      	ldr	r3, [r7, #28]
 8011ac0:	2100      	movs	r1, #0
 8011ac2:	4618      	mov	r0, r3
 8011ac4:	f7fd f898 	bl	800ebf8 <create_chain>
 8011ac8:	63b8      	str	r0, [r7, #56]	@ 0x38
 8011aca:	e013      	b.n	8011af4 <f_write+0x12a>
					}
				} else {					/* On the middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 8011acc:	69fb      	ldr	r3, [r7, #28]
 8011ace:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011ad0:	2b00      	cmp	r3, #0
 8011ad2:	d007      	beq.n	8011ae4 <f_write+0x11a>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8011ad4:	69fb      	ldr	r3, [r7, #28]
 8011ad6:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011ada:	69f8      	ldr	r0, [r7, #28]
 8011adc:	f7fd f98d 	bl	800edfa <clmt_clust>
 8011ae0:	63b8      	str	r0, [r7, #56]	@ 0x38
 8011ae2:	e007      	b.n	8011af4 <f_write+0x12a>
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8011ae4:	69fa      	ldr	r2, [r7, #28]
 8011ae6:	69fb      	ldr	r3, [r7, #28]
 8011ae8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011aea:	4619      	mov	r1, r3
 8011aec:	4610      	mov	r0, r2
 8011aee:	f7fd f883 	bl	800ebf8 <create_chain>
 8011af2:	63b8      	str	r0, [r7, #56]	@ 0x38
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8011af4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011af6:	2b00      	cmp	r3, #0
 8011af8:	f000 812e 	beq.w	8011d58 <f_write+0x38e>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8011afc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011afe:	2b01      	cmp	r3, #1
 8011b00:	d105      	bne.n	8011b0e <f_write+0x144>
 8011b02:	69fb      	ldr	r3, [r7, #28]
 8011b04:	2202      	movs	r2, #2
 8011b06:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011b0a:	2302      	movs	r3, #2
 8011b0c:	e12f      	b.n	8011d6e <f_write+0x3a4>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8011b0e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011b10:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011b14:	d105      	bne.n	8011b22 <f_write+0x158>
 8011b16:	69fb      	ldr	r3, [r7, #28]
 8011b18:	2201      	movs	r2, #1
 8011b1a:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011b1e:	2301      	movs	r3, #1
 8011b20:	e125      	b.n	8011d6e <f_write+0x3a4>
				fp->clust = clst;			/* Update current cluster */
 8011b22:	69fb      	ldr	r3, [r7, #28]
 8011b24:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011b26:	641a      	str	r2, [r3, #64]	@ 0x40
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8011b28:	69fb      	ldr	r3, [r7, #28]
 8011b2a:	689b      	ldr	r3, [r3, #8]
 8011b2c:	2b00      	cmp	r3, #0
 8011b2e:	d102      	bne.n	8011b36 <f_write+0x16c>
 8011b30:	69fb      	ldr	r3, [r7, #28]
 8011b32:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011b34:	609a      	str	r2, [r3, #8]
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8011b36:	69fb      	ldr	r3, [r7, #28]
 8011b38:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011b3c:	b25b      	sxtb	r3, r3
 8011b3e:	2b00      	cmp	r3, #0
 8011b40:	da1b      	bge.n	8011b7a <f_write+0x1b0>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8011b42:	6a3b      	ldr	r3, [r7, #32]
 8011b44:	7858      	ldrb	r0, [r3, #1]
 8011b46:	69fb      	ldr	r3, [r7, #28]
 8011b48:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8011b4c:	69fb      	ldr	r3, [r7, #28]
 8011b4e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011b50:	2301      	movs	r3, #1
 8011b52:	f7fb febf 	bl	800d8d4 <disk_write>
 8011b56:	4603      	mov	r3, r0
 8011b58:	2b00      	cmp	r3, #0
 8011b5a:	d005      	beq.n	8011b68 <f_write+0x19e>
 8011b5c:	69fb      	ldr	r3, [r7, #28]
 8011b5e:	2201      	movs	r2, #1
 8011b60:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011b64:	2301      	movs	r3, #1
 8011b66:	e102      	b.n	8011d6e <f_write+0x3a4>
				fp->flag &= (BYTE)~FA_DIRTY;
 8011b68:	69fb      	ldr	r3, [r7, #28]
 8011b6a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011b6e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011b72:	b2da      	uxtb	r2, r3
 8011b74:	69fb      	ldr	r3, [r7, #28]
 8011b76:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 8011b7a:	6a3a      	ldr	r2, [r7, #32]
 8011b7c:	69fb      	ldr	r3, [r7, #28]
 8011b7e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011b80:	4619      	mov	r1, r3
 8011b82:	4610      	mov	r0, r2
 8011b84:	f7fc fb96 	bl	800e2b4 <clust2sect>
 8011b88:	6278      	str	r0, [r7, #36]	@ 0x24
			if (!sect) ABORT(fs, FR_INT_ERR);
 8011b8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b8c:	2b00      	cmp	r3, #0
 8011b8e:	d105      	bne.n	8011b9c <f_write+0x1d2>
 8011b90:	69fb      	ldr	r3, [r7, #28]
 8011b92:	2202      	movs	r2, #2
 8011b94:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011b98:	2302      	movs	r3, #2
 8011b9a:	e0e8      	b.n	8011d6e <f_write+0x3a4>
			sect += csect;
 8011b9c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011b9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011ba0:	4413      	add	r3, r2
 8011ba2:	627b      	str	r3, [r7, #36]	@ 0x24
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8011ba4:	6a3b      	ldr	r3, [r7, #32]
 8011ba6:	899b      	ldrh	r3, [r3, #12]
 8011ba8:	461a      	mov	r2, r3
 8011baa:	697b      	ldr	r3, [r7, #20]
 8011bac:	fbb3 f3f2 	udiv	r3, r3, r2
 8011bb0:	633b      	str	r3, [r7, #48]	@ 0x30
			if (cc) {						/* Write maximum contiguous sectors directly */
 8011bb2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011bb4:	2b00      	cmp	r3, #0
 8011bb6:	d046      	beq.n	8011c46 <f_write+0x27c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8011bb8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011bba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011bbc:	4413      	add	r3, r2
 8011bbe:	6a3a      	ldr	r2, [r7, #32]
 8011bc0:	8952      	ldrh	r2, [r2, #10]
 8011bc2:	4293      	cmp	r3, r2
 8011bc4:	d905      	bls.n	8011bd2 <f_write+0x208>
					cc = fs->csize - csect;
 8011bc6:	6a3b      	ldr	r3, [r7, #32]
 8011bc8:	895b      	ldrh	r3, [r3, #10]
 8011bca:	461a      	mov	r2, r3
 8011bcc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011bce:	1ad3      	subs	r3, r2, r3
 8011bd0:	633b      	str	r3, [r7, #48]	@ 0x30
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8011bd2:	6a3b      	ldr	r3, [r7, #32]
 8011bd4:	7858      	ldrb	r0, [r3, #1]
 8011bd6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011bd8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011bda:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011bdc:	f7fb fe7a 	bl	800d8d4 <disk_write>
 8011be0:	4603      	mov	r3, r0
 8011be2:	2b00      	cmp	r3, #0
 8011be4:	d005      	beq.n	8011bf2 <f_write+0x228>
 8011be6:	69fb      	ldr	r3, [r7, #28]
 8011be8:	2201      	movs	r2, #1
 8011bea:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011bee:	2301      	movs	r3, #1
 8011bf0:	e0bd      	b.n	8011d6e <f_write+0x3a4>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8011bf2:	69fb      	ldr	r3, [r7, #28]
 8011bf4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011bf6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bf8:	1ad3      	subs	r3, r2, r3
 8011bfa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011bfc:	429a      	cmp	r2, r3
 8011bfe:	d91a      	bls.n	8011c36 <f_write+0x26c>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8011c00:	69fb      	ldr	r3, [r7, #28]
 8011c02:	f103 0054 	add.w	r0, r3, #84	@ 0x54
 8011c06:	69fb      	ldr	r3, [r7, #28]
 8011c08:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011c0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011c0c:	1ad3      	subs	r3, r2, r3
 8011c0e:	6a3a      	ldr	r2, [r7, #32]
 8011c10:	8992      	ldrh	r2, [r2, #12]
 8011c12:	fb02 f303 	mul.w	r3, r2, r3
 8011c16:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011c18:	18d1      	adds	r1, r2, r3
 8011c1a:	6a3b      	ldr	r3, [r7, #32]
 8011c1c:	899b      	ldrh	r3, [r3, #12]
 8011c1e:	461a      	mov	r2, r3
 8011c20:	f7fc f87b 	bl	800dd1a <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 8011c24:	69fb      	ldr	r3, [r7, #28]
 8011c26:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011c2a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011c2e:	b2da      	uxtb	r2, r3
 8011c30:	69fb      	ldr	r3, [r7, #28]
 8011c32:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8011c36:	6a3b      	ldr	r3, [r7, #32]
 8011c38:	899b      	ldrh	r3, [r3, #12]
 8011c3a:	461a      	mov	r2, r3
 8011c3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c3e:	fb02 f303 	mul.w	r3, r2, r3
 8011c42:	637b      	str	r3, [r7, #52]	@ 0x34
				continue;
 8011c44:	e058      	b.n	8011cf8 <f_write+0x32e>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8011c46:	69fb      	ldr	r3, [r7, #28]
 8011c48:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011c4a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011c4c:	429a      	cmp	r2, r3
 8011c4e:	d01b      	beq.n	8011c88 <f_write+0x2be>
				fp->fptr < fp->obj.objsize &&
 8011c50:	69fb      	ldr	r3, [r7, #28]
 8011c52:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011c56:	69fb      	ldr	r3, [r7, #28]
 8011c58:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8011c5c:	4290      	cmp	r0, r2
 8011c5e:	eb71 0303 	sbcs.w	r3, r1, r3
 8011c62:	d211      	bcs.n	8011c88 <f_write+0x2be>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 8011c64:	6a3b      	ldr	r3, [r7, #32]
 8011c66:	7858      	ldrb	r0, [r3, #1]
 8011c68:	69fb      	ldr	r3, [r7, #28]
 8011c6a:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8011c6e:	2301      	movs	r3, #1
 8011c70:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011c72:	f7fb fe0f 	bl	800d894 <disk_read>
 8011c76:	4603      	mov	r3, r0
				fp->fptr < fp->obj.objsize &&
 8011c78:	2b00      	cmp	r3, #0
 8011c7a:	d005      	beq.n	8011c88 <f_write+0x2be>
					ABORT(fs, FR_DISK_ERR);
 8011c7c:	69fb      	ldr	r3, [r7, #28]
 8011c7e:	2201      	movs	r2, #1
 8011c80:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8011c84:	2301      	movs	r3, #1
 8011c86:	e072      	b.n	8011d6e <f_write+0x3a4>
			}
#endif
			fp->sect = sect;
 8011c88:	69fb      	ldr	r3, [r7, #28]
 8011c8a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011c8c:	645a      	str	r2, [r3, #68]	@ 0x44
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8011c8e:	6a3b      	ldr	r3, [r7, #32]
 8011c90:	899b      	ldrh	r3, [r3, #12]
 8011c92:	4618      	mov	r0, r3
 8011c94:	69fb      	ldr	r3, [r7, #28]
 8011c96:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011c9a:	6a3b      	ldr	r3, [r7, #32]
 8011c9c:	899b      	ldrh	r3, [r3, #12]
 8011c9e:	fbb2 f1f3 	udiv	r1, r2, r3
 8011ca2:	fb01 f303 	mul.w	r3, r1, r3
 8011ca6:	1ad3      	subs	r3, r2, r3
 8011ca8:	1ac3      	subs	r3, r0, r3
 8011caa:	637b      	str	r3, [r7, #52]	@ 0x34
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8011cac:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011cae:	697b      	ldr	r3, [r7, #20]
 8011cb0:	429a      	cmp	r2, r3
 8011cb2:	d901      	bls.n	8011cb8 <f_write+0x2ee>
 8011cb4:	697b      	ldr	r3, [r7, #20]
 8011cb6:	637b      	str	r3, [r7, #52]	@ 0x34
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8011cb8:	69fb      	ldr	r3, [r7, #28]
 8011cba:	f103 0454 	add.w	r4, r3, #84	@ 0x54
 8011cbe:	69fb      	ldr	r3, [r7, #28]
 8011cc0:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8011cc4:	6a3b      	ldr	r3, [r7, #32]
 8011cc6:	899b      	ldrh	r3, [r3, #12]
 8011cc8:	b29b      	uxth	r3, r3
 8011cca:	2200      	movs	r2, #0
 8011ccc:	603b      	str	r3, [r7, #0]
 8011cce:	607a      	str	r2, [r7, #4]
 8011cd0:	e9d7 2300 	ldrd	r2, r3, [r7]
 8011cd4:	f7ee feea 	bl	8000aac <__aeabi_uldivmod>
 8011cd8:	4613      	mov	r3, r2
 8011cda:	4423      	add	r3, r4
 8011cdc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011cde:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8011ce0:	4618      	mov	r0, r3
 8011ce2:	f7fc f81a 	bl	800dd1a <mem_cpy>
		fp->flag |= FA_DIRTY;
 8011ce6:	69fb      	ldr	r3, [r7, #28]
 8011ce8:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011cec:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8011cf0:	b2da      	uxtb	r2, r3
 8011cf2:	69fb      	ldr	r3, [r7, #28]
 8011cf4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8011cf8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011cfa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011cfc:	4413      	add	r3, r2
 8011cfe:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011d00:	69fb      	ldr	r3, [r7, #28]
 8011d02:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011d06:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8011d08:	2000      	movs	r0, #0
 8011d0a:	4688      	mov	r8, r1
 8011d0c:	4681      	mov	r9, r0
 8011d0e:	eb12 0a08 	adds.w	sl, r2, r8
 8011d12:	eb43 0b09 	adc.w	fp, r3, r9
 8011d16:	69fb      	ldr	r3, [r7, #28]
 8011d18:	e9c3 ab0e 	strd	sl, fp, [r3, #56]	@ 0x38
 8011d1c:	69fb      	ldr	r3, [r7, #28]
 8011d1e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8011d22:	69fb      	ldr	r3, [r7, #28]
 8011d24:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8011d28:	4290      	cmp	r0, r2
 8011d2a:	eb71 0403 	sbcs.w	r4, r1, r3
 8011d2e:	d201      	bcs.n	8011d34 <f_write+0x36a>
 8011d30:	4610      	mov	r0, r2
 8011d32:	4619      	mov	r1, r3
 8011d34:	69fb      	ldr	r3, [r7, #28]
 8011d36:	e9c3 0104 	strd	r0, r1, [r3, #16]
 8011d3a:	693b      	ldr	r3, [r7, #16]
 8011d3c:	681a      	ldr	r2, [r3, #0]
 8011d3e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d40:	441a      	add	r2, r3
 8011d42:	693b      	ldr	r3, [r7, #16]
 8011d44:	601a      	str	r2, [r3, #0]
 8011d46:	697a      	ldr	r2, [r7, #20]
 8011d48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d4a:	1ad3      	subs	r3, r2, r3
 8011d4c:	617b      	str	r3, [r7, #20]
	for ( ;  btw;							/* Repeat until all data written */
 8011d4e:	697b      	ldr	r3, [r7, #20]
 8011d50:	2b00      	cmp	r3, #0
 8011d52:	f47f ae82 	bne.w	8011a5a <f_write+0x90>
 8011d56:	e000      	b.n	8011d5a <f_write+0x390>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8011d58:	bf00      	nop
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8011d5a:	69fb      	ldr	r3, [r7, #28]
 8011d5c:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011d60:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8011d64:	b2da      	uxtb	r2, r3
 8011d66:	69fb      	ldr	r3, [r7, #28]
 8011d68:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

	LEAVE_FF(fs, FR_OK);
 8011d6c:	2300      	movs	r3, #0
}
 8011d6e:	4618      	mov	r0, r3
 8011d70:	3744      	adds	r7, #68	@ 0x44
 8011d72:	46bd      	mov	sp, r7
 8011d74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08011d78 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8011d78:	b580      	push	{r7, lr}
 8011d7a:	b09a      	sub	sp, #104	@ 0x68
 8011d7c:	af00      	add	r7, sp, #0
 8011d7e:	6078      	str	r0, [r7, #4]
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8011d80:	687b      	ldr	r3, [r7, #4]
 8011d82:	f107 0258 	add.w	r2, r7, #88	@ 0x58
 8011d86:	4611      	mov	r1, r2
 8011d88:	4618      	mov	r0, r3
 8011d8a:	f7ff f93b 	bl	8011004 <validate>
 8011d8e:	4603      	mov	r3, r0
 8011d90:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
	if (res == FR_OK) {
 8011d94:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011d98:	2b00      	cmp	r3, #0
 8011d9a:	f040 8105 	bne.w	8011fa8 <f_sync+0x230>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8011d9e:	687b      	ldr	r3, [r7, #4]
 8011da0:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011da4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011da8:	2b00      	cmp	r3, #0
 8011daa:	f000 80fd 	beq.w	8011fa8 <f_sync+0x230>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8011dae:	687b      	ldr	r3, [r7, #4]
 8011db0:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011db4:	b25b      	sxtb	r3, r3
 8011db6:	2b00      	cmp	r3, #0
 8011db8:	da17      	bge.n	8011dea <f_sync+0x72>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8011dba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011dbc:	7858      	ldrb	r0, [r3, #1]
 8011dbe:	687b      	ldr	r3, [r7, #4]
 8011dc0:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8011dc4:	687b      	ldr	r3, [r7, #4]
 8011dc6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011dc8:	2301      	movs	r3, #1
 8011dca:	f7fb fd83 	bl	800d8d4 <disk_write>
 8011dce:	4603      	mov	r3, r0
 8011dd0:	2b00      	cmp	r3, #0
 8011dd2:	d001      	beq.n	8011dd8 <f_sync+0x60>
 8011dd4:	2301      	movs	r3, #1
 8011dd6:	e0e9      	b.n	8011fac <f_sync+0x234>
				fp->flag &= (BYTE)~FA_DIRTY;
 8011dd8:	687b      	ldr	r3, [r7, #4]
 8011dda:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011dde:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011de2:	b2da      	uxtb	r2, r3
 8011de4:	687b      	ldr	r3, [r7, #4]
 8011de6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 8011dea:	f7f8 fb6f 	bl	800a4cc <get_fattime>
 8011dee:	6638      	str	r0, [r7, #96]	@ 0x60
#if _FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8011df0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011df2:	781b      	ldrb	r3, [r3, #0]
 8011df4:	2b04      	cmp	r3, #4
 8011df6:	f040 808c 	bne.w	8011f12 <f_sync+0x19a>
				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
 8011dfa:	687b      	ldr	r3, [r7, #4]
 8011dfc:	4618      	mov	r0, r3
 8011dfe:	f7fc fde7 	bl	800e9d0 <fill_first_frag>
 8011e02:	4603      	mov	r3, r0
 8011e04:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				if (res == FR_OK) {
 8011e08:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011e0c:	2b00      	cmp	r3, #0
 8011e0e:	d10a      	bne.n	8011e26 <f_sync+0xae>
					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 8011e10:	6878      	ldr	r0, [r7, #4]
 8011e12:	687b      	ldr	r3, [r7, #4]
 8011e14:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011e16:	f04f 32ff 	mov.w	r2, #4294967295
 8011e1a:	4619      	mov	r1, r3
 8011e1c:	f7fc fe07 	bl	800ea2e <fill_last_frag>
 8011e20:	4603      	mov	r3, r0
 8011e22:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				}
				if (res == FR_OK) {
 8011e26:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011e2a:	2b00      	cmp	r3, #0
 8011e2c:	f040 80bc 	bne.w	8011fa8 <f_sync+0x230>
					INIT_NAMBUF(fs);
					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
 8011e30:	687a      	ldr	r2, [r7, #4]
 8011e32:	f107 0308 	add.w	r3, r7, #8
 8011e36:	4611      	mov	r1, r2
 8011e38:	4618      	mov	r0, r3
 8011e3a:	f7fd fd4f 	bl	800f8dc <load_obj_dir>
 8011e3e:	4603      	mov	r3, r0
 8011e40:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
					if (res == FR_OK) {
 8011e44:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011e48:	2b00      	cmp	r3, #0
 8011e4a:	f040 80ad 	bne.w	8011fa8 <f_sync+0x230>
						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive bit */
 8011e4e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011e50:	695b      	ldr	r3, [r3, #20]
 8011e52:	3304      	adds	r3, #4
 8011e54:	781a      	ldrb	r2, [r3, #0]
 8011e56:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011e58:	695b      	ldr	r3, [r3, #20]
 8011e5a:	3304      	adds	r3, #4
 8011e5c:	f042 0220 	orr.w	r2, r2, #32
 8011e60:	b2d2      	uxtb	r2, r2
 8011e62:	701a      	strb	r2, [r3, #0]
						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation info */
 8011e64:	687b      	ldr	r3, [r7, #4]
 8011e66:	79da      	ldrb	r2, [r3, #7]
 8011e68:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011e6a:	695b      	ldr	r3, [r3, #20]
 8011e6c:	3321      	adds	r3, #33	@ 0x21
 8011e6e:	f042 0201 	orr.w	r2, r2, #1
 8011e72:	b2d2      	uxtb	r2, r2
 8011e74:	701a      	strb	r2, [r3, #0]
						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
 8011e76:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011e78:	695b      	ldr	r3, [r3, #20]
 8011e7a:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	689b      	ldr	r3, [r3, #8]
 8011e82:	4619      	mov	r1, r3
 8011e84:	4610      	mov	r0, r2
 8011e86:	f7fb fe94 	bl	800dbb2 <st_dword>
						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
 8011e8a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011e8c:	695b      	ldr	r3, [r3, #20]
 8011e8e:	f103 0138 	add.w	r1, r3, #56	@ 0x38
 8011e92:	687b      	ldr	r3, [r7, #4]
 8011e94:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8011e98:	4608      	mov	r0, r1
 8011e9a:	f7fb feb6 	bl	800dc0a <st_qword>
						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
 8011e9e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011ea0:	695b      	ldr	r3, [r3, #20]
 8011ea2:	f103 0128 	add.w	r1, r3, #40	@ 0x28
 8011ea6:	687b      	ldr	r3, [r7, #4]
 8011ea8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8011eac:	4608      	mov	r0, r1
 8011eae:	f7fb feac 	bl	800dc0a <st_qword>
						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
 8011eb2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011eb4:	695b      	ldr	r3, [r3, #20]
 8011eb6:	330c      	adds	r3, #12
 8011eb8:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8011eba:	4618      	mov	r0, r3
 8011ebc:	f7fb fe79 	bl	800dbb2 <st_dword>
						fs->dirbuf[XDIR_ModTime10] = 0;
 8011ec0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011ec2:	695b      	ldr	r3, [r3, #20]
 8011ec4:	3315      	adds	r3, #21
 8011ec6:	2200      	movs	r2, #0
 8011ec8:	701a      	strb	r2, [r3, #0]
						st_dword(fs->dirbuf + XDIR_AccTime, 0);
 8011eca:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011ecc:	695b      	ldr	r3, [r3, #20]
 8011ece:	3310      	adds	r3, #16
 8011ed0:	2100      	movs	r1, #0
 8011ed2:	4618      	mov	r0, r3
 8011ed4:	f7fb fe6d 	bl	800dbb2 <st_dword>
						res = store_xdir(&dj);	/* Restore it to the directory */
 8011ed8:	f107 0308 	add.w	r3, r7, #8
 8011edc:	4618      	mov	r0, r3
 8011ede:	f7fd fd33 	bl	800f948 <store_xdir>
 8011ee2:	4603      	mov	r3, r0
 8011ee4:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
						if (res == FR_OK) {
 8011ee8:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011eec:	2b00      	cmp	r3, #0
 8011eee:	d15b      	bne.n	8011fa8 <f_sync+0x230>
							res = sync_fs(fs);
 8011ef0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011ef2:	4618      	mov	r0, r3
 8011ef4:	f7fc f96e 	bl	800e1d4 <sync_fs>
 8011ef8:	4603      	mov	r3, r0
 8011efa:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
							fp->flag &= (BYTE)~FA_MODIFIED;
 8011efe:	687b      	ldr	r3, [r7, #4]
 8011f00:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011f04:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8011f08:	b2da      	uxtb	r2, r3
 8011f0a:	687b      	ldr	r3, [r7, #4]
 8011f0c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
 8011f10:	e04a      	b.n	8011fa8 <f_sync+0x230>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 8011f12:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8011f14:	687b      	ldr	r3, [r7, #4]
 8011f16:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011f18:	4619      	mov	r1, r3
 8011f1a:	4610      	mov	r0, r2
 8011f1c:	f7fc f92c 	bl	800e178 <move_window>
 8011f20:	4603      	mov	r3, r0
 8011f22:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				if (res == FR_OK) {
 8011f26:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8011f2a:	2b00      	cmp	r3, #0
 8011f2c:	d13c      	bne.n	8011fa8 <f_sync+0x230>
					dir = fp->dir_ptr;
 8011f2e:	687b      	ldr	r3, [r7, #4]
 8011f30:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8011f32:	65fb      	str	r3, [r7, #92]	@ 0x5c
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 8011f34:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8011f36:	330b      	adds	r3, #11
 8011f38:	781a      	ldrb	r2, [r3, #0]
 8011f3a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8011f3c:	330b      	adds	r3, #11
 8011f3e:	f042 0220 	orr.w	r2, r2, #32
 8011f42:	b2d2      	uxtb	r2, r2
 8011f44:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8011f46:	687b      	ldr	r3, [r7, #4]
 8011f48:	6818      	ldr	r0, [r3, #0]
 8011f4a:	687b      	ldr	r3, [r7, #4]
 8011f4c:	689b      	ldr	r3, [r3, #8]
 8011f4e:	461a      	mov	r2, r3
 8011f50:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8011f52:	f7fd f993 	bl	800f27c <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8011f56:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8011f58:	f103 001c 	add.w	r0, r3, #28
 8011f5c:	687b      	ldr	r3, [r7, #4]
 8011f5e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8011f62:	4613      	mov	r3, r2
 8011f64:	4619      	mov	r1, r3
 8011f66:	f7fb fe24 	bl	800dbb2 <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 8011f6a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8011f6c:	3316      	adds	r3, #22
 8011f6e:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8011f70:	4618      	mov	r0, r3
 8011f72:	f7fb fe1e 	bl	800dbb2 <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
 8011f76:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8011f78:	3312      	adds	r3, #18
 8011f7a:	2100      	movs	r1, #0
 8011f7c:	4618      	mov	r0, r3
 8011f7e:	f7fb fdfd 	bl	800db7c <st_word>
					fs->wflag = 1;
 8011f82:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011f84:	2201      	movs	r2, #1
 8011f86:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8011f88:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8011f8a:	4618      	mov	r0, r3
 8011f8c:	f7fc f922 	bl	800e1d4 <sync_fs>
 8011f90:	4603      	mov	r3, r0
 8011f92:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
					fp->flag &= (BYTE)~FA_MODIFIED;
 8011f96:	687b      	ldr	r3, [r7, #4]
 8011f98:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8011f9c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8011fa0:	b2da      	uxtb	r2, r3
 8011fa2:	687b      	ldr	r3, [r7, #4]
 8011fa4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 8011fa8:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
}
 8011fac:	4618      	mov	r0, r3
 8011fae:	3768      	adds	r7, #104	@ 0x68
 8011fb0:	46bd      	mov	sp, r7
 8011fb2:	bd80      	pop	{r7, pc}

08011fb4 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8011fb4:	b580      	push	{r7, lr}
 8011fb6:	b084      	sub	sp, #16
 8011fb8:	af00      	add	r7, sp, #0
 8011fba:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8011fbc:	6878      	ldr	r0, [r7, #4]
 8011fbe:	f7ff fedb 	bl	8011d78 <f_sync>
 8011fc2:	4603      	mov	r3, r0
 8011fc4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
 8011fc6:	7bfb      	ldrb	r3, [r7, #15]
 8011fc8:	2b00      	cmp	r3, #0
 8011fca:	d118      	bne.n	8011ffe <f_close+0x4a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8011fcc:	687b      	ldr	r3, [r7, #4]
 8011fce:	f107 0208 	add.w	r2, r7, #8
 8011fd2:	4611      	mov	r1, r2
 8011fd4:	4618      	mov	r0, r3
 8011fd6:	f7ff f815 	bl	8011004 <validate>
 8011fda:	4603      	mov	r3, r0
 8011fdc:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 8011fde:	7bfb      	ldrb	r3, [r7, #15]
 8011fe0:	2b00      	cmp	r3, #0
 8011fe2:	d10c      	bne.n	8011ffe <f_close+0x4a>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 8011fe4:	687b      	ldr	r3, [r7, #4]
 8011fe6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011fe8:	4618      	mov	r0, r3
 8011fea:	f7fc f821 	bl	800e030 <dec_lock>
 8011fee:	4603      	mov	r3, r0
 8011ff0:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK)
 8011ff2:	7bfb      	ldrb	r3, [r7, #15]
 8011ff4:	2b00      	cmp	r3, #0
 8011ff6:	d102      	bne.n	8011ffe <f_close+0x4a>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
 8011ff8:	687b      	ldr	r3, [r7, #4]
 8011ffa:	2200      	movs	r2, #0
 8011ffc:	601a      	str	r2, [r3, #0]
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
 8011ffe:	7bfb      	ldrb	r3, [r7, #15]
}
 8012000:	4618      	mov	r0, r3
 8012002:	3710      	adds	r7, #16
 8012004:	46bd      	mov	sp, r7
 8012006:	bd80      	pop	{r7, pc}

08012008 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8012008:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801200c:	b0ba      	sub	sp, #232	@ 0xe8
 801200e:	af00      	add	r7, sp, #0
 8012010:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
 8012014:	e9c7 2326 	strd	r2, r3, [r7, #152]	@ 0x98
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8012018:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 801201c:	f107 03a8 	add.w	r3, r7, #168	@ 0xa8
 8012020:	4619      	mov	r1, r3
 8012022:	4610      	mov	r0, r2
 8012024:	f7fe ffee 	bl	8011004 <validate>
 8012028:	4603      	mov	r3, r0
 801202a:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
	if (res == FR_OK) res = (FRESULT)fp->err;
 801202e:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012032:	2b00      	cmp	r3, #0
 8012034:	d105      	bne.n	8012042 <f_lseek+0x3a>
 8012036:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801203a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 801203e:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
 8012042:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012046:	2b00      	cmp	r3, #0
 8012048:	d111      	bne.n	801206e <f_lseek+0x66>
 801204a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801204e:	781b      	ldrb	r3, [r3, #0]
 8012050:	2b04      	cmp	r3, #4
 8012052:	d10c      	bne.n	801206e <f_lseek+0x66>
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 8012054:	f8d7 00a4 	ldr.w	r0, [r7, #164]	@ 0xa4
 8012058:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801205c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801205e:	f04f 32ff 	mov.w	r2, #4294967295
 8012062:	4619      	mov	r1, r3
 8012064:	f7fc fce3 	bl	800ea2e <fill_last_frag>
 8012068:	4603      	mov	r3, r0
 801206a:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 801206e:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012072:	2b00      	cmp	r3, #0
 8012074:	d002      	beq.n	801207c <f_lseek+0x74>
 8012076:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 801207a:	e3ab      	b.n	80127d4 <f_lseek+0x7cc>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 801207c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012080:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012082:	2b00      	cmp	r3, #0
 8012084:	f000 8152 	beq.w	801232c <f_lseek+0x324>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8012088:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 801208c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012090:	bf08      	it	eq
 8012092:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 8012096:	f040 8087 	bne.w	80121a8 <f_lseek+0x1a0>
			tbl = fp->cltbl;
 801209a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801209e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80120a0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 80120a4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80120a8:	1d1a      	adds	r2, r3, #4
 80120aa:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 80120ae:	681b      	ldr	r3, [r3, #0]
 80120b0:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 80120b4:	2302      	movs	r3, #2
 80120b6:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
			cl = fp->obj.sclust;		/* Origin of the chain */
 80120ba:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80120be:	689b      	ldr	r3, [r3, #8]
 80120c0:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
			if (cl) {
 80120c4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80120c8:	2b00      	cmp	r3, #0
 80120ca:	d058      	beq.n	801217e <f_lseek+0x176>
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 80120cc:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80120d0:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 80120d4:	2300      	movs	r3, #0
 80120d6:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 80120da:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80120de:	3302      	adds	r3, #2
 80120e0:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
					do {
						pcl = cl; ncl++;
 80120e4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80120e8:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 80120ec:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80120f0:	3301      	adds	r3, #1
 80120f2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
						cl = get_fat(&fp->obj, cl);
 80120f6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80120fa:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 80120fe:	4618      	mov	r0, r3
 8012100:	f7fc f8f8 	bl	800e2f4 <get_fat>
 8012104:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8012108:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801210c:	2b01      	cmp	r3, #1
 801210e:	d806      	bhi.n	801211e <f_lseek+0x116>
 8012110:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012114:	2202      	movs	r2, #2
 8012116:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 801211a:	2302      	movs	r3, #2
 801211c:	e35a      	b.n	80127d4 <f_lseek+0x7cc>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801211e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8012122:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012126:	d106      	bne.n	8012136 <f_lseek+0x12e>
 8012128:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801212c:	2201      	movs	r2, #1
 801212e:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8012132:	2301      	movs	r3, #1
 8012134:	e34e      	b.n	80127d4 <f_lseek+0x7cc>
					} while (cl == pcl + 1);
 8012136:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801213a:	3301      	adds	r3, #1
 801213c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8012140:	429a      	cmp	r2, r3
 8012142:	d0cf      	beq.n	80120e4 <f_lseek+0xdc>
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8012144:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8012148:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801214c:	429a      	cmp	r2, r3
 801214e:	d80f      	bhi.n	8012170 <f_lseek+0x168>
						*tbl++ = ncl; *tbl++ = tcl;
 8012150:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8012154:	1d1a      	adds	r2, r3, #4
 8012156:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 801215a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 801215e:	601a      	str	r2, [r3, #0]
 8012160:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8012164:	1d1a      	adds	r2, r3, #4
 8012166:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 801216a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801216e:	601a      	str	r2, [r3, #0]
					}
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8012170:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012174:	6a1b      	ldr	r3, [r3, #32]
 8012176:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 801217a:	429a      	cmp	r2, r3
 801217c:	d3a6      	bcc.n	80120cc <f_lseek+0xc4>
			}
			*fp->cltbl = ulen;	/* Number of items used */
 801217e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012182:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012184:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8012188:	601a      	str	r2, [r3, #0]
			if (ulen <= tlen) {
 801218a:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 801218e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8012192:	429a      	cmp	r2, r3
 8012194:	d804      	bhi.n	80121a0 <f_lseek+0x198>
				*tbl = 0;		/* Terminate table */
 8012196:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 801219a:	2200      	movs	r2, #0
 801219c:	601a      	str	r2, [r3, #0]
 801219e:	e317      	b.n	80127d0 <f_lseek+0x7c8>
			} else {
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 80121a0:	2311      	movs	r3, #17
 80121a2:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
 80121a6:	e313      	b.n	80127d0 <f_lseek+0x7c8>
			}
		} else {						/* Fast seek */
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 80121a8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80121ac:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80121b0:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80121b4:	4290      	cmp	r0, r2
 80121b6:	eb71 0303 	sbcs.w	r3, r1, r3
 80121ba:	d205      	bcs.n	80121c8 <f_lseek+0x1c0>
 80121bc:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80121c0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80121c4:	e9c7 2326 	strd	r2, r3, [r7, #152]	@ 0x98
			fp->fptr = ofs;				/* Set file pointer */
 80121c8:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 80121cc:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80121d0:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
			if (ofs) {
 80121d4:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80121d8:	4313      	orrs	r3, r2
 80121da:	f000 82f9 	beq.w	80127d0 <f_lseek+0x7c8>
				fp->clust = clmt_clust(fp, ofs - 1);
 80121de:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80121e2:	f112 38ff 	adds.w	r8, r2, #4294967295
 80121e6:	f143 39ff 	adc.w	r9, r3, #4294967295
 80121ea:	4642      	mov	r2, r8
 80121ec:	464b      	mov	r3, r9
 80121ee:	f8d7 00a4 	ldr.w	r0, [r7, #164]	@ 0xa4
 80121f2:	f7fc fe02 	bl	800edfa <clmt_clust>
 80121f6:	4602      	mov	r2, r0
 80121f8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80121fc:	641a      	str	r2, [r3, #64]	@ 0x40
				dsc = clust2sect(fs, fp->clust);
 80121fe:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8012202:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012206:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012208:	4619      	mov	r1, r3
 801220a:	4610      	mov	r0, r2
 801220c:	f7fc f852 	bl	800e2b4 <clust2sect>
 8012210:	f8c7 00b8 	str.w	r0, [r7, #184]	@ 0xb8
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8012214:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8012218:	2b00      	cmp	r3, #0
 801221a:	d106      	bne.n	801222a <f_lseek+0x222>
 801221c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012220:	2202      	movs	r2, #2
 8012222:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8012226:	2302      	movs	r3, #2
 8012228:	e2d4      	b.n	80127d4 <f_lseek+0x7cc>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 801222a:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 801222e:	1e54      	subs	r4, r2, #1
 8012230:	f143 35ff 	adc.w	r5, r3, #4294967295
 8012234:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012238:	899b      	ldrh	r3, [r3, #12]
 801223a:	b29b      	uxth	r3, r3
 801223c:	2200      	movs	r2, #0
 801223e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8012242:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 8012246:	e9d7 2324 	ldrd	r2, r3, [r7, #144]	@ 0x90
 801224a:	4620      	mov	r0, r4
 801224c:	4629      	mov	r1, r5
 801224e:	f7ee fc2d 	bl	8000aac <__aeabi_uldivmod>
 8012252:	4602      	mov	r2, r0
 8012254:	460b      	mov	r3, r1
 8012256:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801225a:	895b      	ldrh	r3, [r3, #10]
 801225c:	3b01      	subs	r3, #1
 801225e:	4013      	ands	r3, r2
 8012260:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8012264:	4413      	add	r3, r2
 8012266:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 801226a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801226e:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8012272:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012276:	899b      	ldrh	r3, [r3, #12]
 8012278:	b29b      	uxth	r3, r3
 801227a:	2200      	movs	r2, #0
 801227c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8012280:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8012284:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8012288:	f7ee fc10 	bl	8000aac <__aeabi_uldivmod>
 801228c:	4313      	orrs	r3, r2
 801228e:	f000 829f 	beq.w	80127d0 <f_lseek+0x7c8>
 8012292:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012296:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012298:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801229c:	429a      	cmp	r2, r3
 801229e:	f000 8297 	beq.w	80127d0 <f_lseek+0x7c8>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 80122a2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122a6:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80122aa:	b25b      	sxtb	r3, r3
 80122ac:	2b00      	cmp	r3, #0
 80122ae:	da21      	bge.n	80122f4 <f_lseek+0x2ec>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80122b0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80122b4:	7858      	ldrb	r0, [r3, #1]
 80122b6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122ba:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 80122be:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122c2:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80122c4:	2301      	movs	r3, #1
 80122c6:	f7fb fb05 	bl	800d8d4 <disk_write>
 80122ca:	4603      	mov	r3, r0
 80122cc:	2b00      	cmp	r3, #0
 80122ce:	d006      	beq.n	80122de <f_lseek+0x2d6>
 80122d0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122d4:	2201      	movs	r2, #1
 80122d6:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80122da:	2301      	movs	r3, #1
 80122dc:	e27a      	b.n	80127d4 <f_lseek+0x7cc>
						fp->flag &= (BYTE)~FA_DIRTY;
 80122de:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122e2:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80122e6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80122ea:	b2da      	uxtb	r2, r3
 80122ec:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122f0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
					}
#endif
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 80122f4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80122f8:	7858      	ldrb	r0, [r3, #1]
 80122fa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80122fe:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8012302:	2301      	movs	r3, #1
 8012304:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8012308:	f7fb fac4 	bl	800d894 <disk_read>
 801230c:	4603      	mov	r3, r0
 801230e:	2b00      	cmp	r3, #0
 8012310:	d006      	beq.n	8012320 <f_lseek+0x318>
 8012312:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012316:	2201      	movs	r2, #1
 8012318:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 801231c:	2301      	movs	r3, #1
 801231e:	e259      	b.n	80127d4 <f_lseek+0x7cc>
#endif
					fp->sect = dsc;
 8012320:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012324:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8012328:	645a      	str	r2, [r3, #68]	@ 0x44
 801232a:	e251      	b.n	80127d0 <f_lseek+0x7c8>
#endif

	/* Normal Seek */
	{
#if _FS_EXFAT
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
 801232c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012330:	781b      	ldrb	r3, [r3, #0]
 8012332:	2b04      	cmp	r3, #4
 8012334:	d009      	beq.n	801234a <f_lseek+0x342>
 8012336:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 801233a:	2b01      	cmp	r3, #1
 801233c:	d305      	bcc.n	801234a <f_lseek+0x342>
 801233e:	f04f 32ff 	mov.w	r2, #4294967295
 8012342:	f04f 0300 	mov.w	r3, #0
 8012346:	e9c7 2326 	strd	r2, r3, [r7, #152]	@ 0x98
#endif
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 801234a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801234e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8012352:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 8012356:	4290      	cmp	r0, r2
 8012358:	eb71 0303 	sbcs.w	r3, r1, r3
 801235c:	d20d      	bcs.n	801237a <f_lseek+0x372>
 801235e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012362:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8012366:	f003 0302 	and.w	r3, r3, #2
 801236a:	2b00      	cmp	r3, #0
 801236c:	d105      	bne.n	801237a <f_lseek+0x372>
			ofs = fp->obj.objsize;
 801236e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012372:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8012376:	e9c7 2326 	strd	r2, r3, [r7, #152]	@ 0x98
		}
		ifptr = fp->fptr;
 801237a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801237e:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8012382:	e9c7 2330 	strd	r2, r3, [r7, #192]	@ 0xc0
		fp->fptr = nsect = 0;
 8012386:	2300      	movs	r3, #0
 8012388:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 801238c:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 8012390:	f04f 0200 	mov.w	r2, #0
 8012394:	f04f 0300 	mov.w	r3, #0
 8012398:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
		if (ofs) {
 801239c:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80123a0:	4313      	orrs	r3, r2
 80123a2:	f000 819a 	beq.w	80126da <f_lseek+0x6d2>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 80123a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80123aa:	895b      	ldrh	r3, [r3, #10]
 80123ac:	461a      	mov	r2, r3
 80123ae:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80123b2:	899b      	ldrh	r3, [r3, #12]
 80123b4:	fb02 f303 	mul.w	r3, r2, r3
 80123b8:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
			if (ifptr > 0 &&
 80123bc:	e9d7 2330 	ldrd	r2, r3, [r7, #192]	@ 0xc0
 80123c0:	4313      	orrs	r3, r2
 80123c2:	d069      	beq.n	8012498 <f_lseek+0x490>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 80123c4:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80123c8:	1e51      	subs	r1, r2, #1
 80123ca:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
 80123ce:	f143 33ff 	adc.w	r3, r3, #4294967295
 80123d2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 80123d6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80123da:	2200      	movs	r2, #0
 80123dc:	67bb      	str	r3, [r7, #120]	@ 0x78
 80123de:	67fa      	str	r2, [r7, #124]	@ 0x7c
 80123e0:	e9d7 231e 	ldrd	r2, r3, [r7, #120]	@ 0x78
 80123e4:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
 80123e8:	f7ee fb60 	bl	8000aac <__aeabi_uldivmod>
 80123ec:	4602      	mov	r2, r0
 80123ee:	460b      	mov	r3, r1
 80123f0:	4614      	mov	r4, r2
 80123f2:	461d      	mov	r5, r3
 80123f4:	e9d7 2330 	ldrd	r2, r3, [r7, #192]	@ 0xc0
 80123f8:	1e51      	subs	r1, r2, #1
 80123fa:	6739      	str	r1, [r7, #112]	@ 0x70
 80123fc:	f143 33ff 	adc.w	r3, r3, #4294967295
 8012400:	677b      	str	r3, [r7, #116]	@ 0x74
 8012402:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8012406:	2200      	movs	r2, #0
 8012408:	66bb      	str	r3, [r7, #104]	@ 0x68
 801240a:	66fa      	str	r2, [r7, #108]	@ 0x6c
 801240c:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 8012410:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 8012414:	f7ee fb4a 	bl	8000aac <__aeabi_uldivmod>
 8012418:	4602      	mov	r2, r0
 801241a:	460b      	mov	r3, r1
			if (ifptr > 0 &&
 801241c:	4294      	cmp	r4, r2
 801241e:	eb75 0303 	sbcs.w	r3, r5, r3
 8012422:	d339      	bcc.n	8012498 <f_lseek+0x490>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8012424:	e9d7 2330 	ldrd	r2, r3, [r7, #192]	@ 0xc0
 8012428:	1e51      	subs	r1, r2, #1
 801242a:	6639      	str	r1, [r7, #96]	@ 0x60
 801242c:	f143 33ff 	adc.w	r3, r3, #4294967295
 8012430:	667b      	str	r3, [r7, #100]	@ 0x64
 8012432:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8012436:	3b01      	subs	r3, #1
 8012438:	2200      	movs	r2, #0
 801243a:	65bb      	str	r3, [r7, #88]	@ 0x58
 801243c:	65fa      	str	r2, [r7, #92]	@ 0x5c
 801243e:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 8012442:	460b      	mov	r3, r1
 8012444:	ea6f 0a03 	mvn.w	sl, r3
 8012448:	4613      	mov	r3, r2
 801244a:	ea6f 0b03 	mvn.w	fp, r3
 801244e:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 8012452:	460b      	mov	r3, r1
 8012454:	ea03 030a 	and.w	r3, r3, sl
 8012458:	653b      	str	r3, [r7, #80]	@ 0x50
 801245a:	4613      	mov	r3, r2
 801245c:	ea03 030b 	and.w	r3, r3, fp
 8012460:	657b      	str	r3, [r7, #84]	@ 0x54
 8012462:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012466:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 801246a:	e9c3 120e 	strd	r1, r2, [r3, #56]	@ 0x38
				ofs -= fp->fptr;
 801246e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012472:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8012476:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 801247a:	1a14      	subs	r4, r2, r0
 801247c:	60bc      	str	r4, [r7, #8]
 801247e:	eb63 0301 	sbc.w	r3, r3, r1
 8012482:	60fb      	str	r3, [r7, #12]
 8012484:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8012488:	e9c7 3426 	strd	r3, r4, [r7, #152]	@ 0x98
				clst = fp->clust;
 801248c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012490:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012492:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8012496:	e031      	b.n	80124fc <f_lseek+0x4f4>
			} else {									/* When seek to back cluster, */
				clst = fp->obj.sclust;					/* start from the first cluster */
 8012498:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801249c:	689b      	ldr	r3, [r3, #8]
 801249e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 80124a2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80124a6:	2b00      	cmp	r3, #0
 80124a8:	d123      	bne.n	80124f2 <f_lseek+0x4ea>
					clst = create_chain(&fp->obj, 0);
 80124aa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80124ae:	2100      	movs	r1, #0
 80124b0:	4618      	mov	r0, r3
 80124b2:	f7fc fba1 	bl	800ebf8 <create_chain>
 80124b6:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 80124ba:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80124be:	2b01      	cmp	r3, #1
 80124c0:	d106      	bne.n	80124d0 <f_lseek+0x4c8>
 80124c2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80124c6:	2202      	movs	r2, #2
 80124c8:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80124cc:	2302      	movs	r3, #2
 80124ce:	e181      	b.n	80127d4 <f_lseek+0x7cc>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80124d0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80124d4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80124d8:	d106      	bne.n	80124e8 <f_lseek+0x4e0>
 80124da:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80124de:	2201      	movs	r2, #1
 80124e0:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80124e4:	2301      	movs	r3, #1
 80124e6:	e175      	b.n	80127d4 <f_lseek+0x7cc>
					fp->obj.sclust = clst;
 80124e8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80124ec:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80124f0:	6093      	str	r3, [r2, #8]
				}
#endif
				fp->clust = clst;
 80124f2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80124f6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80124fa:	6413      	str	r3, [r2, #64]	@ 0x40
			}
			if (clst != 0) {
 80124fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012500:	2b00      	cmp	r3, #0
 8012502:	f000 80ea 	beq.w	80126da <f_lseek+0x6d2>
				while (ofs > bcs) {						/* Cluster following loop */
 8012506:	e090      	b.n	801262a <f_lseek+0x622>
					ofs -= bcs; fp->fptr += bcs;
 8012508:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801250c:	2200      	movs	r2, #0
 801250e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8012510:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8012512:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 8012516:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 801251a:	4621      	mov	r1, r4
 801251c:	1a51      	subs	r1, r2, r1
 801251e:	6039      	str	r1, [r7, #0]
 8012520:	4629      	mov	r1, r5
 8012522:	eb63 0301 	sbc.w	r3, r3, r1
 8012526:	607b      	str	r3, [r7, #4]
 8012528:	e9d7 3400 	ldrd	r3, r4, [r7]
 801252c:	e9c7 3426 	strd	r3, r4, [r7, #152]	@ 0x98
 8012530:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012534:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8012538:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 801253c:	2000      	movs	r0, #0
 801253e:	6439      	str	r1, [r7, #64]	@ 0x40
 8012540:	6478      	str	r0, [r7, #68]	@ 0x44
 8012542:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 8012546:	4621      	mov	r1, r4
 8012548:	1851      	adds	r1, r2, r1
 801254a:	63b9      	str	r1, [r7, #56]	@ 0x38
 801254c:	4629      	mov	r1, r5
 801254e:	414b      	adcs	r3, r1
 8012550:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8012552:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012556:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 801255a:	e9c3 120e 	strd	r1, r2, [r3, #56]	@ 0x38
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 801255e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012562:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8012566:	f003 0302 	and.w	r3, r3, #2
 801256a:	2b00      	cmp	r3, #0
 801256c:	d031      	beq.n	80125d2 <f_lseek+0x5ca>
						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
 801256e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012572:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8012576:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801257a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 801257e:	4282      	cmp	r2, r0
 8012580:	418b      	sbcs	r3, r1
 8012582:	d212      	bcs.n	80125aa <f_lseek+0x5a2>
							fp->obj.objsize = fp->fptr;
 8012584:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012588:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 801258c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012590:	e9c3 0104 	strd	r0, r1, [r3, #16]
							fp->flag |= FA_MODIFIED;
 8012594:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012598:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 801259c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80125a0:	b2db      	uxtb	r3, r3
 80125a2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80125a6:	f882 3030 	strb.w	r3, [r2, #48]	@ 0x30
						}
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 80125aa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80125ae:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 80125b2:	4618      	mov	r0, r3
 80125b4:	f7fc fb20 	bl	800ebf8 <create_chain>
 80125b8:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
						if (clst == 0) {				/* Clip file size in case of disk full */
 80125bc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80125c0:	2b00      	cmp	r3, #0
 80125c2:	d10f      	bne.n	80125e4 <f_lseek+0x5dc>
							ofs = 0; break;
 80125c4:	f04f 0200 	mov.w	r2, #0
 80125c8:	f04f 0300 	mov.w	r3, #0
 80125cc:	e9c7 2326 	strd	r2, r3, [r7, #152]	@ 0x98
 80125d0:	e03b      	b.n	801264a <f_lseek+0x642>
						}
					} else
#endif
					{
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 80125d2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80125d6:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 80125da:	4618      	mov	r0, r3
 80125dc:	f7fb fe8a 	bl	800e2f4 <get_fat>
 80125e0:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80125e4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80125e8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80125ec:	d106      	bne.n	80125fc <f_lseek+0x5f4>
 80125ee:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80125f2:	2201      	movs	r2, #1
 80125f4:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80125f8:	2301      	movs	r3, #1
 80125fa:	e0eb      	b.n	80127d4 <f_lseek+0x7cc>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 80125fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012600:	2b01      	cmp	r3, #1
 8012602:	d906      	bls.n	8012612 <f_lseek+0x60a>
 8012604:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012608:	6a1a      	ldr	r2, [r3, #32]
 801260a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801260e:	4293      	cmp	r3, r2
 8012610:	d306      	bcc.n	8012620 <f_lseek+0x618>
 8012612:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012616:	2202      	movs	r2, #2
 8012618:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 801261c:	2302      	movs	r3, #2
 801261e:	e0d9      	b.n	80127d4 <f_lseek+0x7cc>
					fp->clust = clst;
 8012620:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8012624:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012628:	6413      	str	r3, [r2, #64]	@ 0x40
				while (ofs > bcs) {						/* Cluster following loop */
 801262a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801262e:	2200      	movs	r2, #0
 8012630:	633b      	str	r3, [r7, #48]	@ 0x30
 8012632:	637a      	str	r2, [r7, #52]	@ 0x34
 8012634:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 8012638:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 801263c:	4621      	mov	r1, r4
 801263e:	4291      	cmp	r1, r2
 8012640:	4629      	mov	r1, r5
 8012642:	eb71 0303 	sbcs.w	r3, r1, r3
 8012646:	f4ff af5f 	bcc.w	8012508 <f_lseek+0x500>
				}
				fp->fptr += ofs;
 801264a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801264e:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8012652:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 8012656:	1884      	adds	r4, r0, r2
 8012658:	62bc      	str	r4, [r7, #40]	@ 0x28
 801265a:	eb41 0303 	adc.w	r3, r1, r3
 801265e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012660:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012664:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 8012668:	e9c3 120e 	strd	r1, r2, [r3, #56]	@ 0x38
				if (ofs % SS(fs)) {
 801266c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012670:	899b      	ldrh	r3, [r3, #12]
 8012672:	b29b      	uxth	r3, r3
 8012674:	2200      	movs	r2, #0
 8012676:	623b      	str	r3, [r7, #32]
 8012678:	627a      	str	r2, [r7, #36]	@ 0x24
 801267a:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
 801267e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8012682:	f7ee fa13 	bl	8000aac <__aeabi_uldivmod>
 8012686:	4313      	orrs	r3, r2
 8012688:	d027      	beq.n	80126da <f_lseek+0x6d2>
					nsect = clust2sect(fs, clst);	/* Current sector */
 801268a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801268e:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 8012692:	4618      	mov	r0, r3
 8012694:	f7fb fe0e 	bl	800e2b4 <clust2sect>
 8012698:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc
					if (!nsect) ABORT(fs, FR_INT_ERR);
 801269c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80126a0:	2b00      	cmp	r3, #0
 80126a2:	d106      	bne.n	80126b2 <f_lseek+0x6aa>
 80126a4:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80126a8:	2202      	movs	r2, #2
 80126aa:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80126ae:	2302      	movs	r3, #2
 80126b0:	e090      	b.n	80127d4 <f_lseek+0x7cc>
					nsect += (DWORD)(ofs / SS(fs));
 80126b2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80126b6:	899b      	ldrh	r3, [r3, #12]
 80126b8:	b29b      	uxth	r3, r3
 80126ba:	2200      	movs	r2, #0
 80126bc:	61bb      	str	r3, [r7, #24]
 80126be:	61fa      	str	r2, [r7, #28]
 80126c0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80126c4:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
 80126c8:	f7ee f9f0 	bl	8000aac <__aeabi_uldivmod>
 80126cc:	4602      	mov	r2, r0
 80126ce:	460b      	mov	r3, r1
 80126d0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80126d4:	4413      	add	r3, r2
 80126d6:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
				}
			}
		}
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 80126da:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80126de:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 80126e2:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 80126e6:	e9d1 0104 	ldrd	r0, r1, [r1, #16]
 80126ea:	4290      	cmp	r0, r2
 80126ec:	eb71 0303 	sbcs.w	r3, r1, r3
 80126f0:	d212      	bcs.n	8012718 <f_lseek+0x710>
			fp->obj.objsize = fp->fptr;
 80126f2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80126f6:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 80126fa:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 80126fe:	e9c1 2304 	strd	r2, r3, [r1, #16]
			fp->flag |= FA_MODIFIED;
 8012702:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012706:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 801270a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801270e:	b2da      	uxtb	r2, r3
 8012710:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012714:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
		}
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8012718:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801271c:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8012720:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8012724:	899b      	ldrh	r3, [r3, #12]
 8012726:	b29b      	uxth	r3, r3
 8012728:	2200      	movs	r2, #0
 801272a:	613b      	str	r3, [r7, #16]
 801272c:	617a      	str	r2, [r7, #20]
 801272e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8012732:	f7ee f9bb 	bl	8000aac <__aeabi_uldivmod>
 8012736:	4313      	orrs	r3, r2
 8012738:	d04a      	beq.n	80127d0 <f_lseek+0x7c8>
 801273a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801273e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012740:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8012744:	429a      	cmp	r2, r3
 8012746:	d043      	beq.n	80127d0 <f_lseek+0x7c8>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8012748:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801274c:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8012750:	b25b      	sxtb	r3, r3
 8012752:	2b00      	cmp	r3, #0
 8012754:	da21      	bge.n	801279a <f_lseek+0x792>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8012756:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801275a:	7858      	ldrb	r0, [r3, #1]
 801275c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012760:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 8012764:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012768:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 801276a:	2301      	movs	r3, #1
 801276c:	f7fb f8b2 	bl	800d8d4 <disk_write>
 8012770:	4603      	mov	r3, r0
 8012772:	2b00      	cmp	r3, #0
 8012774:	d006      	beq.n	8012784 <f_lseek+0x77c>
 8012776:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801277a:	2201      	movs	r2, #1
 801277c:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 8012780:	2301      	movs	r3, #1
 8012782:	e027      	b.n	80127d4 <f_lseek+0x7cc>
				fp->flag &= (BYTE)~FA_DIRTY;
 8012784:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012788:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 801278c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8012790:	b2da      	uxtb	r2, r3
 8012792:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8012796:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
			}
#endif
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 801279a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801279e:	7858      	ldrb	r0, [r3, #1]
 80127a0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80127a4:	f103 0154 	add.w	r1, r3, #84	@ 0x54
 80127a8:	2301      	movs	r3, #1
 80127aa:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80127ae:	f7fb f871 	bl	800d894 <disk_read>
 80127b2:	4603      	mov	r3, r0
 80127b4:	2b00      	cmp	r3, #0
 80127b6:	d006      	beq.n	80127c6 <f_lseek+0x7be>
 80127b8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80127bc:	2201      	movs	r2, #1
 80127be:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
 80127c2:	2301      	movs	r3, #1
 80127c4:	e006      	b.n	80127d4 <f_lseek+0x7cc>
#endif
			fp->sect = nsect;
 80127c6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80127ca:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80127ce:	645a      	str	r2, [r3, #68]	@ 0x44
		}
	}

	LEAVE_FF(fs, res);
 80127d0:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
}
 80127d4:	4618      	mov	r0, r3
 80127d6:	37e8      	adds	r7, #232	@ 0xe8
 80127d8:	46bd      	mov	sp, r7
 80127da:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080127de <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 80127de:	b580      	push	{r7, lr}
 80127e0:	b0ba      	sub	sp, #232	@ 0xe8
 80127e2:	af00      	add	r7, sp, #0
 80127e4:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj, sdj;
	DWORD dclst = 0;
 80127e6:	2300      	movs	r3, #0
 80127e8:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 80127ec:	f107 013c 	add.w	r1, r7, #60	@ 0x3c
 80127f0:	1d3b      	adds	r3, r7, #4
 80127f2:	2202      	movs	r2, #2
 80127f4:	4618      	mov	r0, r3
 80127f6:	f7fe f86b 	bl	80108d0 <find_volume>
 80127fa:	4603      	mov	r3, r0
 80127fc:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
	dj.obj.fs = fs;
 8012800:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012802:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
	if (res == FR_OK) {
 8012806:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 801280a:	2b00      	cmp	r3, #0
 801280c:	f040 80c3 	bne.w	8012996 <f_unlink+0x1b8>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
 8012810:	687a      	ldr	r2, [r7, #4]
 8012812:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8012816:	4611      	mov	r1, r2
 8012818:	4618      	mov	r0, r3
 801281a:	f7fd ff03 	bl	8010624 <follow_path>
 801281e:	4603      	mov	r3, r0
 8012820:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if _FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 8012824:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012828:	2b00      	cmp	r3, #0
 801282a:	d108      	bne.n	801283e <f_unlink+0x60>
 801282c:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8012830:	2102      	movs	r1, #2
 8012832:	4618      	mov	r0, r3
 8012834:	f7fb faf0 	bl	800de18 <chk_lock>
 8012838:	4603      	mov	r3, r0
 801283a:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
#endif
		if (res == FR_OK) {					/* The object is accessible */
 801283e:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012842:	2b00      	cmp	r3, #0
 8012844:	f040 80a7 	bne.w	8012996 <f_unlink+0x1b8>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 8012848:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 801284c:	b25b      	sxtb	r3, r3
 801284e:	2b00      	cmp	r3, #0
 8012850:	da03      	bge.n	801285a <f_unlink+0x7c>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 8012852:	2306      	movs	r3, #6
 8012854:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
 8012858:	e008      	b.n	801286c <f_unlink+0x8e>
			} else {
				if (dj.obj.attr & AM_RDO) {
 801285a:	f897 3096 	ldrb.w	r3, [r7, #150]	@ 0x96
 801285e:	f003 0301 	and.w	r3, r3, #1
 8012862:	2b00      	cmp	r3, #0
 8012864:	d002      	beq.n	801286c <f_unlink+0x8e>
					res = FR_DENIED;		/* Cannot remove R/O object */
 8012866:	2307      	movs	r3, #7
 8012868:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
				}
			}
			if (res == FR_OK) {
 801286c:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012870:	2b00      	cmp	r3, #0
 8012872:	d166      	bne.n	8012942 <f_unlink+0x164>
#if _FS_EXFAT
				obj.fs = fs;
 8012874:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012876:	60bb      	str	r3, [r7, #8]
				if (fs->fs_type == FS_EXFAT) {
 8012878:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801287a:	781b      	ldrb	r3, [r3, #0]
 801287c:	2b04      	cmp	r3, #4
 801287e:	d11d      	bne.n	80128bc <f_unlink+0xde>
					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
 8012880:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012882:	695b      	ldr	r3, [r3, #20]
 8012884:	3334      	adds	r3, #52	@ 0x34
 8012886:	4618      	mov	r0, r3
 8012888:	f7fb f87a 	bl	800d980 <ld_dword>
 801288c:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
 8012890:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012894:	613b      	str	r3, [r7, #16]
					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
 8012896:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012898:	695b      	ldr	r3, [r3, #20]
 801289a:	3338      	adds	r3, #56	@ 0x38
 801289c:	4618      	mov	r0, r3
 801289e:	f7fb f892 	bl	800d9c6 <ld_qword>
 80128a2:	4602      	mov	r2, r0
 80128a4:	460b      	mov	r3, r1
 80128a6:	e9c7 2306 	strd	r2, r3, [r7, #24]
					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
 80128aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80128ac:	695b      	ldr	r3, [r3, #20]
 80128ae:	3321      	adds	r3, #33	@ 0x21
 80128b0:	781b      	ldrb	r3, [r3, #0]
 80128b2:	f003 0302 	and.w	r3, r3, #2
 80128b6:	b2db      	uxtb	r3, r3
 80128b8:	73fb      	strb	r3, [r7, #15]
 80128ba:	e008      	b.n	80128ce <f_unlink+0xf0>
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
 80128bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80128be:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80128c2:	4611      	mov	r1, r2
 80128c4:	4618      	mov	r0, r3
 80128c6:	f7fc fcba 	bl	800f23e <ld_clust>
 80128ca:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 80128ce:	f897 3096 	ldrb.w	r3, [r7, #150]	@ 0x96
 80128d2:	f003 0310 	and.w	r3, r3, #16
 80128d6:	2b00      	cmp	r3, #0
 80128d8:	d033      	beq.n	8012942 <f_unlink+0x164>
					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
						res = FR_DENIED;
					} else
#endif
					{
						sdj.obj.fs = fs;						/* Open the sub-directory */
 80128da:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80128dc:	643b      	str	r3, [r7, #64]	@ 0x40
						sdj.obj.sclust = dclst;
 80128de:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80128e2:	64bb      	str	r3, [r7, #72]	@ 0x48
#if _FS_EXFAT
						if (fs->fs_type == FS_EXFAT) {
 80128e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80128e6:	781b      	ldrb	r3, [r3, #0]
 80128e8:	2b04      	cmp	r3, #4
 80128ea:	d106      	bne.n	80128fa <f_unlink+0x11c>
							sdj.obj.objsize = obj.objsize;
 80128ec:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80128f0:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
							sdj.obj.stat = obj.stat;
 80128f4:	7bfb      	ldrb	r3, [r7, #15]
 80128f6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
						}
#endif
						res = dir_sdi(&sdj, 0);
 80128fa:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80128fe:	2100      	movs	r1, #0
 8012900:	4618      	mov	r0, r3
 8012902:	f7fc fac6 	bl	800ee92 <dir_sdi>
 8012906:	4603      	mov	r3, r0
 8012908:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
						if (res == FR_OK) {
 801290c:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012910:	2b00      	cmp	r3, #0
 8012912:	d116      	bne.n	8012942 <f_unlink+0x164>
							res = dir_read(&sdj, 0);			/* Read an item */
 8012914:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 8012918:	2100      	movs	r1, #0
 801291a:	4618      	mov	r0, r3
 801291c:	f7fd f8d6 	bl	800facc <dir_read>
 8012920:	4603      	mov	r3, r0
 8012922:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 8012926:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 801292a:	2b00      	cmp	r3, #0
 801292c:	d102      	bne.n	8012934 <f_unlink+0x156>
 801292e:	2307      	movs	r3, #7
 8012930:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 8012934:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012938:	2b04      	cmp	r3, #4
 801293a:	d102      	bne.n	8012942 <f_unlink+0x164>
 801293c:	2300      	movs	r3, #0
 801293e:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
						}
					}
				}
			}
			if (res == FR_OK) {
 8012942:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012946:	2b00      	cmp	r3, #0
 8012948:	d125      	bne.n	8012996 <f_unlink+0x1b8>
				res = dir_remove(&dj);			/* Remove the directory entry */
 801294a:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 801294e:	4618      	mov	r0, r3
 8012950:	f7fd fc58 	bl	8010204 <dir_remove>
 8012954:	4603      	mov	r3, r0
 8012956:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
 801295a:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 801295e:	2b00      	cmp	r3, #0
 8012960:	d10e      	bne.n	8012980 <f_unlink+0x1a2>
 8012962:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012966:	2b00      	cmp	r3, #0
 8012968:	d00a      	beq.n	8012980 <f_unlink+0x1a2>
#if _FS_EXFAT
					res = remove_chain(&obj, dclst, 0);
 801296a:	f107 0308 	add.w	r3, r7, #8
 801296e:	2200      	movs	r2, #0
 8012970:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 8012974:	4618      	mov	r0, r3
 8012976:	f7fc f88b 	bl	800ea90 <remove_chain>
 801297a:	4603      	mov	r3, r0
 801297c:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
#else
					res = remove_chain(&dj.obj, dclst, 0);
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
 8012980:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 8012984:	2b00      	cmp	r3, #0
 8012986:	d106      	bne.n	8012996 <f_unlink+0x1b8>
 8012988:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801298a:	4618      	mov	r0, r3
 801298c:	f7fb fc22 	bl	800e1d4 <sync_fs>
 8012990:	4603      	mov	r3, r0
 8012992:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
			}
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
 8012996:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
}
 801299a:	4618      	mov	r0, r3
 801299c:	37e8      	adds	r7, #232	@ 0xe8
 801299e:	46bd      	mov	sp, r7
 80129a0:	bd80      	pop	{r7, pc}

080129a2 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 80129a2:	b5b0      	push	{r4, r5, r7, lr}
 80129a4:	b0a0      	sub	sp, #128	@ 0x80
 80129a6:	af00      	add	r7, sp, #0
 80129a8:	6078      	str	r0, [r7, #4]
	DWORD dsc, dcl, pcl, tm;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 80129aa:	f107 010c 	add.w	r1, r7, #12
 80129ae:	1d3b      	adds	r3, r7, #4
 80129b0:	2202      	movs	r2, #2
 80129b2:	4618      	mov	r0, r3
 80129b4:	f7fd ff8c 	bl	80108d0 <find_volume>
 80129b8:	4603      	mov	r3, r0
 80129ba:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
	dj.obj.fs = fs;
 80129be:	68fb      	ldr	r3, [r7, #12]
 80129c0:	613b      	str	r3, [r7, #16]
	if (res == FR_OK) {
 80129c2:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80129c6:	2b00      	cmp	r3, #0
 80129c8:	f040 8133 	bne.w	8012c32 <f_mkdir+0x290>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
 80129cc:	687a      	ldr	r2, [r7, #4]
 80129ce:	f107 0310 	add.w	r3, r7, #16
 80129d2:	4611      	mov	r1, r2
 80129d4:	4618      	mov	r0, r3
 80129d6:	f7fd fe25 	bl	8010624 <follow_path>
 80129da:	4603      	mov	r3, r0
 80129dc:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 80129e0:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80129e4:	2b00      	cmp	r3, #0
 80129e6:	d102      	bne.n	80129ee <f_mkdir+0x4c>
 80129e8:	2308      	movs	r3, #8
 80129ea:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;
		}
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 80129ee:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 80129f2:	2b04      	cmp	r3, #4
 80129f4:	f040 811d 	bne.w	8012c32 <f_mkdir+0x290>
			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
 80129f8:	f107 0310 	add.w	r3, r7, #16
 80129fc:	2100      	movs	r1, #0
 80129fe:	4618      	mov	r0, r3
 8012a00:	f7fc f8fa 	bl	800ebf8 <create_chain>
 8012a04:	66f8      	str	r0, [r7, #108]	@ 0x6c
			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
 8012a06:	68fb      	ldr	r3, [r7, #12]
 8012a08:	895b      	ldrh	r3, [r3, #10]
 8012a0a:	461a      	mov	r2, r3
 8012a0c:	68fb      	ldr	r3, [r7, #12]
 8012a0e:	899b      	ldrh	r3, [r3, #12]
 8012a10:	fb02 f303 	mul.w	r3, r2, r3
 8012a14:	2200      	movs	r2, #0
 8012a16:	461c      	mov	r4, r3
 8012a18:	4615      	mov	r5, r2
 8012a1a:	e9c7 4508 	strd	r4, r5, [r7, #32]
			res = FR_OK;
 8012a1e:	2300      	movs	r3, #0
 8012a20:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8012a24:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012a26:	2b00      	cmp	r3, #0
 8012a28:	d102      	bne.n	8012a30 <f_mkdir+0x8e>
 8012a2a:	2307      	movs	r3, #7
 8012a2c:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (dcl == 1) res = FR_INT_ERR;
 8012a30:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012a32:	2b01      	cmp	r3, #1
 8012a34:	d102      	bne.n	8012a3c <f_mkdir+0x9a>
 8012a36:	2302      	movs	r3, #2
 8012a38:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8012a3c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012a3e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012a42:	d102      	bne.n	8012a4a <f_mkdir+0xa8>
 8012a44:	2301      	movs	r3, #1
 8012a46:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
 8012a4a:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012a4e:	2b00      	cmp	r3, #0
 8012a50:	d106      	bne.n	8012a60 <f_mkdir+0xbe>
 8012a52:	68fb      	ldr	r3, [r7, #12]
 8012a54:	4618      	mov	r0, r3
 8012a56:	f7fb fb4b 	bl	800e0f0 <sync_window>
 8012a5a:	4603      	mov	r3, r0
 8012a5c:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			tm = GET_FATTIME();
 8012a60:	f7f7 fd34 	bl	800a4cc <get_fattime>
 8012a64:	66b8      	str	r0, [r7, #104]	@ 0x68
			if (res == FR_OK) {					/* Initialize the new directory table */
 8012a66:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012a6a:	2b00      	cmp	r3, #0
 8012a6c:	d170      	bne.n	8012b50 <f_mkdir+0x1ae>
				dsc = clust2sect(fs, dcl);
 8012a6e:	68fb      	ldr	r3, [r7, #12]
 8012a70:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8012a72:	4618      	mov	r0, r3
 8012a74:	f7fb fc1e 	bl	800e2b4 <clust2sect>
 8012a78:	6778      	str	r0, [r7, #116]	@ 0x74
				dir = fs->win;
 8012a7a:	68fb      	ldr	r3, [r7, #12]
 8012a7c:	333c      	adds	r3, #60	@ 0x3c
 8012a7e:	667b      	str	r3, [r7, #100]	@ 0x64
				mem_set(dir, 0, SS(fs));
 8012a80:	68fb      	ldr	r3, [r7, #12]
 8012a82:	899b      	ldrh	r3, [r3, #12]
 8012a84:	461a      	mov	r2, r3
 8012a86:	2100      	movs	r1, #0
 8012a88:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8012a8a:	f7fb f967 	bl	800dd5c <mem_set>
				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 8012a8e:	68fb      	ldr	r3, [r7, #12]
 8012a90:	781b      	ldrb	r3, [r3, #0]
 8012a92:	2b04      	cmp	r3, #4
 8012a94:	d036      	beq.n	8012b04 <f_mkdir+0x162>
					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
 8012a96:	220b      	movs	r2, #11
 8012a98:	2120      	movs	r1, #32
 8012a9a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8012a9c:	f7fb f95e 	bl	800dd5c <mem_set>
					dir[DIR_Name] = '.';
 8012aa0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012aa2:	222e      	movs	r2, #46	@ 0x2e
 8012aa4:	701a      	strb	r2, [r3, #0]
					dir[DIR_Attr] = AM_DIR;
 8012aa6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012aa8:	330b      	adds	r3, #11
 8012aaa:	2210      	movs	r2, #16
 8012aac:	701a      	strb	r2, [r3, #0]
					st_dword(dir + DIR_ModTime, tm);
 8012aae:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012ab0:	3316      	adds	r3, #22
 8012ab2:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8012ab4:	4618      	mov	r0, r3
 8012ab6:	f7fb f87c 	bl	800dbb2 <st_dword>
					st_clust(fs, dir, dcl);
 8012aba:	68fb      	ldr	r3, [r7, #12]
 8012abc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8012abe:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8012ac0:	4618      	mov	r0, r3
 8012ac2:	f7fc fbdb 	bl	800f27c <st_clust>
					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
 8012ac6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012ac8:	3320      	adds	r3, #32
 8012aca:	2220      	movs	r2, #32
 8012acc:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8012ace:	4618      	mov	r0, r3
 8012ad0:	f7fb f923 	bl	800dd1a <mem_cpy>
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8012ad4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012ad6:	3321      	adds	r3, #33	@ 0x21
 8012ad8:	222e      	movs	r2, #46	@ 0x2e
 8012ada:	701a      	strb	r2, [r3, #0]
 8012adc:	69bb      	ldr	r3, [r7, #24]
 8012ade:	673b      	str	r3, [r7, #112]	@ 0x70
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8012ae0:	68fb      	ldr	r3, [r7, #12]
 8012ae2:	781b      	ldrb	r3, [r3, #0]
 8012ae4:	2b03      	cmp	r3, #3
 8012ae6:	d106      	bne.n	8012af6 <f_mkdir+0x154>
 8012ae8:	68fb      	ldr	r3, [r7, #12]
 8012aea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012aec:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8012aee:	429a      	cmp	r2, r3
 8012af0:	d101      	bne.n	8012af6 <f_mkdir+0x154>
 8012af2:	2300      	movs	r3, #0
 8012af4:	673b      	str	r3, [r7, #112]	@ 0x70
					st_clust(fs, dir + SZDIRE, pcl);
 8012af6:	68f8      	ldr	r0, [r7, #12]
 8012af8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012afa:	3320      	adds	r3, #32
 8012afc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8012afe:	4619      	mov	r1, r3
 8012b00:	f7fc fbbc 	bl	800f27c <st_clust>
				}
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8012b04:	68fb      	ldr	r3, [r7, #12]
 8012b06:	895b      	ldrh	r3, [r3, #10]
 8012b08:	67bb      	str	r3, [r7, #120]	@ 0x78
 8012b0a:	e01c      	b.n	8012b46 <f_mkdir+0x1a4>
					fs->winsect = dsc++;
 8012b0c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8012b0e:	1c5a      	adds	r2, r3, #1
 8012b10:	677a      	str	r2, [r7, #116]	@ 0x74
 8012b12:	68fa      	ldr	r2, [r7, #12]
 8012b14:	6393      	str	r3, [r2, #56]	@ 0x38
					fs->wflag = 1;
 8012b16:	68fb      	ldr	r3, [r7, #12]
 8012b18:	2201      	movs	r2, #1
 8012b1a:	70da      	strb	r2, [r3, #3]
					res = sync_window(fs);
 8012b1c:	68fb      	ldr	r3, [r7, #12]
 8012b1e:	4618      	mov	r0, r3
 8012b20:	f7fb fae6 	bl	800e0f0 <sync_window>
 8012b24:	4603      	mov	r3, r0
 8012b26:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
					if (res != FR_OK) break;
 8012b2a:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012b2e:	2b00      	cmp	r3, #0
 8012b30:	d10d      	bne.n	8012b4e <f_mkdir+0x1ac>
					mem_set(dir, 0, SS(fs));
 8012b32:	68fb      	ldr	r3, [r7, #12]
 8012b34:	899b      	ldrh	r3, [r3, #12]
 8012b36:	461a      	mov	r2, r3
 8012b38:	2100      	movs	r1, #0
 8012b3a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8012b3c:	f7fb f90e 	bl	800dd5c <mem_set>
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8012b40:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8012b42:	3b01      	subs	r3, #1
 8012b44:	67bb      	str	r3, [r7, #120]	@ 0x78
 8012b46:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8012b48:	2b00      	cmp	r3, #0
 8012b4a:	d1df      	bne.n	8012b0c <f_mkdir+0x16a>
 8012b4c:	e000      	b.n	8012b50 <f_mkdir+0x1ae>
					if (res != FR_OK) break;
 8012b4e:	bf00      	nop
				}
			}
			if (res == FR_OK) {
 8012b50:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012b54:	2b00      	cmp	r3, #0
 8012b56:	d107      	bne.n	8012b68 <f_mkdir+0x1c6>
				res = dir_register(&dj);	/* Register the object to the directoy */
 8012b58:	f107 0310 	add.w	r3, r7, #16
 8012b5c:	4618      	mov	r0, r3
 8012b5e:	f7fd f9a7 	bl	800feb0 <dir_register>
 8012b62:	4603      	mov	r3, r0
 8012b64:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
			}
			if (res == FR_OK) {
 8012b68:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012b6c:	2b00      	cmp	r3, #0
 8012b6e:	d159      	bne.n	8012c24 <f_mkdir+0x282>
#if _FS_EXFAT
				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
 8012b70:	68fb      	ldr	r3, [r7, #12]
 8012b72:	781b      	ldrb	r3, [r3, #0]
 8012b74:	2b04      	cmp	r3, #4
 8012b76:	d134      	bne.n	8012be2 <f_mkdir+0x240>
					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
 8012b78:	68fb      	ldr	r3, [r7, #12]
 8012b7a:	695b      	ldr	r3, [r3, #20]
 8012b7c:	330c      	adds	r3, #12
 8012b7e:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8012b80:	4618      	mov	r0, r3
 8012b82:	f7fb f816 	bl	800dbb2 <st_dword>
					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
 8012b86:	68fb      	ldr	r3, [r7, #12]
 8012b88:	695b      	ldr	r3, [r3, #20]
 8012b8a:	3334      	adds	r3, #52	@ 0x34
 8012b8c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8012b8e:	4618      	mov	r0, r3
 8012b90:	f7fb f80f 	bl	800dbb2 <st_dword>
					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
 8012b94:	68fb      	ldr	r3, [r7, #12]
 8012b96:	695b      	ldr	r3, [r3, #20]
 8012b98:	f103 0038 	add.w	r0, r3, #56	@ 0x38
 8012b9c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8012ba0:	4613      	mov	r3, r2
 8012ba2:	4619      	mov	r1, r3
 8012ba4:	f7fb f805 	bl	800dbb2 <st_dword>
					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
 8012ba8:	68fb      	ldr	r3, [r7, #12]
 8012baa:	695b      	ldr	r3, [r3, #20]
 8012bac:	f103 0028 	add.w	r0, r3, #40	@ 0x28
 8012bb0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8012bb4:	4613      	mov	r3, r2
 8012bb6:	4619      	mov	r1, r3
 8012bb8:	f7fa fffb 	bl	800dbb2 <st_dword>
					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag (contiguous) */
 8012bbc:	68fb      	ldr	r3, [r7, #12]
 8012bbe:	695b      	ldr	r3, [r3, #20]
 8012bc0:	3321      	adds	r3, #33	@ 0x21
 8012bc2:	2203      	movs	r2, #3
 8012bc4:	701a      	strb	r2, [r3, #0]
					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
 8012bc6:	68fb      	ldr	r3, [r7, #12]
 8012bc8:	695b      	ldr	r3, [r3, #20]
 8012bca:	3304      	adds	r3, #4
 8012bcc:	2210      	movs	r2, #16
 8012bce:	701a      	strb	r2, [r3, #0]
					res = store_xdir(&dj);
 8012bd0:	f107 0310 	add.w	r3, r7, #16
 8012bd4:	4618      	mov	r0, r3
 8012bd6:	f7fc feb7 	bl	800f948 <store_xdir>
 8012bda:	4603      	mov	r3, r0
 8012bdc:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
 8012be0:	e014      	b.n	8012c0c <f_mkdir+0x26a>
				} else
#endif
				{
					dir = dj.dir;
 8012be2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8012be4:	667b      	str	r3, [r7, #100]	@ 0x64
					st_dword(dir + DIR_ModTime, tm);	/* Created time */
 8012be6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012be8:	3316      	adds	r3, #22
 8012bea:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8012bec:	4618      	mov	r0, r3
 8012bee:	f7fa ffe0 	bl	800dbb2 <st_dword>
					st_clust(fs, dir, dcl);				/* Table start cluster */
 8012bf2:	68fb      	ldr	r3, [r7, #12]
 8012bf4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8012bf6:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8012bf8:	4618      	mov	r0, r3
 8012bfa:	f7fc fb3f 	bl	800f27c <st_clust>
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8012bfe:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8012c00:	330b      	adds	r3, #11
 8012c02:	2210      	movs	r2, #16
 8012c04:	701a      	strb	r2, [r3, #0]
					fs->wflag = 1;
 8012c06:	68fb      	ldr	r3, [r7, #12]
 8012c08:	2201      	movs	r2, #1
 8012c0a:	70da      	strb	r2, [r3, #3]
				}
				if (res == FR_OK) {
 8012c0c:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
 8012c10:	2b00      	cmp	r3, #0
 8012c12:	d10e      	bne.n	8012c32 <f_mkdir+0x290>
					res = sync_fs(fs);
 8012c14:	68fb      	ldr	r3, [r7, #12]
 8012c16:	4618      	mov	r0, r3
 8012c18:	f7fb fadc 	bl	800e1d4 <sync_fs>
 8012c1c:	4603      	mov	r3, r0
 8012c1e:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
 8012c22:	e006      	b.n	8012c32 <f_mkdir+0x290>
				}
			} else {
				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 8012c24:	f107 0310 	add.w	r3, r7, #16
 8012c28:	2200      	movs	r2, #0
 8012c2a:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8012c2c:	4618      	mov	r0, r3
 8012c2e:	f7fb ff2f 	bl	800ea90 <remove_chain>
			}
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
 8012c32:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
}
 8012c36:	4618      	mov	r0, r3
 8012c38:	3780      	adds	r7, #128	@ 0x80
 8012c3a:	46bd      	mov	sp, r7
 8012c3c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08012c40 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 8012c40:	b480      	push	{r7}
 8012c42:	b087      	sub	sp, #28
 8012c44:	af00      	add	r7, sp, #0
 8012c46:	60f8      	str	r0, [r7, #12]
 8012c48:	60b9      	str	r1, [r7, #8]
 8012c4a:	4613      	mov	r3, r2
 8012c4c:	71fb      	strb	r3, [r7, #7]
  uint8_t ret = 1;
 8012c4e:	2301      	movs	r3, #1
 8012c50:	75fb      	strb	r3, [r7, #23]
  uint8_t DiskNum = 0;
 8012c52:	2300      	movs	r3, #0
 8012c54:	75bb      	strb	r3, [r7, #22]

  if(disk.nbr < _VOLUMES)
 8012c56:	4b1f      	ldr	r3, [pc, #124]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c58:	7a5b      	ldrb	r3, [r3, #9]
 8012c5a:	b2db      	uxtb	r3, r3
 8012c5c:	2b00      	cmp	r3, #0
 8012c5e:	d131      	bne.n	8012cc4 <FATFS_LinkDriverEx+0x84>
  {
    disk.is_initialized[disk.nbr] = 0;
 8012c60:	4b1c      	ldr	r3, [pc, #112]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c62:	7a5b      	ldrb	r3, [r3, #9]
 8012c64:	b2db      	uxtb	r3, r3
 8012c66:	461a      	mov	r2, r3
 8012c68:	4b1a      	ldr	r3, [pc, #104]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c6a:	2100      	movs	r1, #0
 8012c6c:	5499      	strb	r1, [r3, r2]
    disk.drv[disk.nbr] = drv;
 8012c6e:	4b19      	ldr	r3, [pc, #100]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c70:	7a5b      	ldrb	r3, [r3, #9]
 8012c72:	b2db      	uxtb	r3, r3
 8012c74:	4a17      	ldr	r2, [pc, #92]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c76:	009b      	lsls	r3, r3, #2
 8012c78:	4413      	add	r3, r2
 8012c7a:	68fa      	ldr	r2, [r7, #12]
 8012c7c:	605a      	str	r2, [r3, #4]
    disk.lun[disk.nbr] = lun;
 8012c7e:	4b15      	ldr	r3, [pc, #84]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c80:	7a5b      	ldrb	r3, [r3, #9]
 8012c82:	b2db      	uxtb	r3, r3
 8012c84:	461a      	mov	r2, r3
 8012c86:	4b13      	ldr	r3, [pc, #76]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c88:	4413      	add	r3, r2
 8012c8a:	79fa      	ldrb	r2, [r7, #7]
 8012c8c:	721a      	strb	r2, [r3, #8]
    DiskNum = disk.nbr++;
 8012c8e:	4b11      	ldr	r3, [pc, #68]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c90:	7a5b      	ldrb	r3, [r3, #9]
 8012c92:	b2db      	uxtb	r3, r3
 8012c94:	1c5a      	adds	r2, r3, #1
 8012c96:	b2d1      	uxtb	r1, r2
 8012c98:	4a0e      	ldr	r2, [pc, #56]	@ (8012cd4 <FATFS_LinkDriverEx+0x94>)
 8012c9a:	7251      	strb	r1, [r2, #9]
 8012c9c:	75bb      	strb	r3, [r7, #22]
    path[0] = DiskNum + '0';
 8012c9e:	7dbb      	ldrb	r3, [r7, #22]
 8012ca0:	3330      	adds	r3, #48	@ 0x30
 8012ca2:	b2da      	uxtb	r2, r3
 8012ca4:	68bb      	ldr	r3, [r7, #8]
 8012ca6:	701a      	strb	r2, [r3, #0]
    path[1] = ':';
 8012ca8:	68bb      	ldr	r3, [r7, #8]
 8012caa:	3301      	adds	r3, #1
 8012cac:	223a      	movs	r2, #58	@ 0x3a
 8012cae:	701a      	strb	r2, [r3, #0]
    path[2] = '/';
 8012cb0:	68bb      	ldr	r3, [r7, #8]
 8012cb2:	3302      	adds	r3, #2
 8012cb4:	222f      	movs	r2, #47	@ 0x2f
 8012cb6:	701a      	strb	r2, [r3, #0]
    path[3] = 0;
 8012cb8:	68bb      	ldr	r3, [r7, #8]
 8012cba:	3303      	adds	r3, #3
 8012cbc:	2200      	movs	r2, #0
 8012cbe:	701a      	strb	r2, [r3, #0]
    ret = 0;
 8012cc0:	2300      	movs	r3, #0
 8012cc2:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8012cc4:	7dfb      	ldrb	r3, [r7, #23]
}
 8012cc6:	4618      	mov	r0, r3
 8012cc8:	371c      	adds	r7, #28
 8012cca:	46bd      	mov	sp, r7
 8012ccc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012cd0:	4770      	bx	lr
 8012cd2:	bf00      	nop
 8012cd4:	20002d84 	.word	0x20002d84

08012cd8 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8012cd8:	b580      	push	{r7, lr}
 8012cda:	b082      	sub	sp, #8
 8012cdc:	af00      	add	r7, sp, #0
 8012cde:	6078      	str	r0, [r7, #4]
 8012ce0:	6039      	str	r1, [r7, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
 8012ce2:	2200      	movs	r2, #0
 8012ce4:	6839      	ldr	r1, [r7, #0]
 8012ce6:	6878      	ldr	r0, [r7, #4]
 8012ce8:	f7ff ffaa 	bl	8012c40 <FATFS_LinkDriverEx>
 8012cec:	4603      	mov	r3, r0
}
 8012cee:	4618      	mov	r0, r3
 8012cf0:	3708      	adds	r7, #8
 8012cf2:	46bd      	mov	sp, r7
 8012cf4:	bd80      	pop	{r7, pc}
	...

08012cf8 <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
)
{
 8012cf8:	b480      	push	{r7}
 8012cfa:	b085      	sub	sp, #20
 8012cfc:	af00      	add	r7, sp, #0
 8012cfe:	4603      	mov	r3, r0
 8012d00:	6039      	str	r1, [r7, #0]
 8012d02:	80fb      	strh	r3, [r7, #6]
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8012d04:	88fb      	ldrh	r3, [r7, #6]
 8012d06:	2b7f      	cmp	r3, #127	@ 0x7f
 8012d08:	d802      	bhi.n	8012d10 <ff_convert+0x18>
		c = chr;
 8012d0a:	88fb      	ldrh	r3, [r7, #6]
 8012d0c:	81fb      	strh	r3, [r7, #14]
 8012d0e:	e025      	b.n	8012d5c <ff_convert+0x64>

	} else {
		if (dir) {		/* OEM code to Unicode */
 8012d10:	683b      	ldr	r3, [r7, #0]
 8012d12:	2b00      	cmp	r3, #0
 8012d14:	d00b      	beq.n	8012d2e <ff_convert+0x36>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8012d16:	88fb      	ldrh	r3, [r7, #6]
 8012d18:	2bff      	cmp	r3, #255	@ 0xff
 8012d1a:	d805      	bhi.n	8012d28 <ff_convert+0x30>
 8012d1c:	88fb      	ldrh	r3, [r7, #6]
 8012d1e:	3b80      	subs	r3, #128	@ 0x80
 8012d20:	4a12      	ldr	r2, [pc, #72]	@ (8012d6c <ff_convert+0x74>)
 8012d22:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8012d26:	e000      	b.n	8012d2a <ff_convert+0x32>
 8012d28:	2300      	movs	r3, #0
 8012d2a:	81fb      	strh	r3, [r7, #14]
 8012d2c:	e016      	b.n	8012d5c <ff_convert+0x64>

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 8012d2e:	2300      	movs	r3, #0
 8012d30:	81fb      	strh	r3, [r7, #14]
 8012d32:	e009      	b.n	8012d48 <ff_convert+0x50>
				if (chr == Tbl[c]) break;
 8012d34:	89fb      	ldrh	r3, [r7, #14]
 8012d36:	4a0d      	ldr	r2, [pc, #52]	@ (8012d6c <ff_convert+0x74>)
 8012d38:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8012d3c:	88fa      	ldrh	r2, [r7, #6]
 8012d3e:	429a      	cmp	r2, r3
 8012d40:	d006      	beq.n	8012d50 <ff_convert+0x58>
			for (c = 0; c < 0x80; c++) {
 8012d42:	89fb      	ldrh	r3, [r7, #14]
 8012d44:	3301      	adds	r3, #1
 8012d46:	81fb      	strh	r3, [r7, #14]
 8012d48:	89fb      	ldrh	r3, [r7, #14]
 8012d4a:	2b7f      	cmp	r3, #127	@ 0x7f
 8012d4c:	d9f2      	bls.n	8012d34 <ff_convert+0x3c>
 8012d4e:	e000      	b.n	8012d52 <ff_convert+0x5a>
				if (chr == Tbl[c]) break;
 8012d50:	bf00      	nop
			}
			c = (c + 0x80) & 0xFF;
 8012d52:	89fb      	ldrh	r3, [r7, #14]
 8012d54:	3380      	adds	r3, #128	@ 0x80
 8012d56:	b29b      	uxth	r3, r3
 8012d58:	b2db      	uxtb	r3, r3
 8012d5a:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
 8012d5c:	89fb      	ldrh	r3, [r7, #14]
}
 8012d5e:	4618      	mov	r0, r3
 8012d60:	3714      	adds	r7, #20
 8012d62:	46bd      	mov	sp, r7
 8012d64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d68:	4770      	bx	lr
 8012d6a:	bf00      	nop
 8012d6c:	08031a88 	.word	0x08031a88

08012d70 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 8012d70:	b480      	push	{r7}
 8012d72:	b087      	sub	sp, #28
 8012d74:	af00      	add	r7, sp, #0
 8012d76:	4603      	mov	r3, r0
 8012d78:	80fb      	strh	r3, [r7, #6]
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 8012d7a:	88fb      	ldrh	r3, [r7, #6]
 8012d7c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8012d80:	d201      	bcs.n	8012d86 <ff_wtoupper+0x16>
 8012d82:	4b3e      	ldr	r3, [pc, #248]	@ (8012e7c <ff_wtoupper+0x10c>)
 8012d84:	e000      	b.n	8012d88 <ff_wtoupper+0x18>
 8012d86:	4b3e      	ldr	r3, [pc, #248]	@ (8012e80 <ff_wtoupper+0x110>)
 8012d88:	617b      	str	r3, [r7, #20]
	for (;;) {
		bc = *p++;								/* Get block base */
 8012d8a:	697b      	ldr	r3, [r7, #20]
 8012d8c:	1c9a      	adds	r2, r3, #2
 8012d8e:	617a      	str	r2, [r7, #20]
 8012d90:	881b      	ldrh	r3, [r3, #0]
 8012d92:	827b      	strh	r3, [r7, #18]
		if (!bc || chr < bc) break;
 8012d94:	8a7b      	ldrh	r3, [r7, #18]
 8012d96:	2b00      	cmp	r3, #0
 8012d98:	d068      	beq.n	8012e6c <ff_wtoupper+0xfc>
 8012d9a:	88fa      	ldrh	r2, [r7, #6]
 8012d9c:	8a7b      	ldrh	r3, [r7, #18]
 8012d9e:	429a      	cmp	r2, r3
 8012da0:	d364      	bcc.n	8012e6c <ff_wtoupper+0xfc>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8012da2:	697b      	ldr	r3, [r7, #20]
 8012da4:	1c9a      	adds	r2, r3, #2
 8012da6:	617a      	str	r2, [r7, #20]
 8012da8:	881b      	ldrh	r3, [r3, #0]
 8012daa:	823b      	strh	r3, [r7, #16]
 8012dac:	8a3b      	ldrh	r3, [r7, #16]
 8012dae:	0a1b      	lsrs	r3, r3, #8
 8012db0:	81fb      	strh	r3, [r7, #14]
 8012db2:	8a3b      	ldrh	r3, [r7, #16]
 8012db4:	b2db      	uxtb	r3, r3
 8012db6:	823b      	strh	r3, [r7, #16]
		if (chr < bc + nc) {	/* In the block? */
 8012db8:	88fa      	ldrh	r2, [r7, #6]
 8012dba:	8a79      	ldrh	r1, [r7, #18]
 8012dbc:	8a3b      	ldrh	r3, [r7, #16]
 8012dbe:	440b      	add	r3, r1
 8012dc0:	429a      	cmp	r2, r3
 8012dc2:	da49      	bge.n	8012e58 <ff_wtoupper+0xe8>
			switch (cmd) {
 8012dc4:	89fb      	ldrh	r3, [r7, #14]
 8012dc6:	2b08      	cmp	r3, #8
 8012dc8:	d84f      	bhi.n	8012e6a <ff_wtoupper+0xfa>
 8012dca:	a201      	add	r2, pc, #4	@ (adr r2, 8012dd0 <ff_wtoupper+0x60>)
 8012dcc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012dd0:	08012df5 	.word	0x08012df5
 8012dd4:	08012e07 	.word	0x08012e07
 8012dd8:	08012e1d 	.word	0x08012e1d
 8012ddc:	08012e25 	.word	0x08012e25
 8012de0:	08012e2d 	.word	0x08012e2d
 8012de4:	08012e35 	.word	0x08012e35
 8012de8:	08012e3d 	.word	0x08012e3d
 8012dec:	08012e45 	.word	0x08012e45
 8012df0:	08012e4d 	.word	0x08012e4d
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 8012df4:	88fa      	ldrh	r2, [r7, #6]
 8012df6:	8a7b      	ldrh	r3, [r7, #18]
 8012df8:	1ad3      	subs	r3, r2, r3
 8012dfa:	005b      	lsls	r3, r3, #1
 8012dfc:	697a      	ldr	r2, [r7, #20]
 8012dfe:	4413      	add	r3, r2
 8012e00:	881b      	ldrh	r3, [r3, #0]
 8012e02:	80fb      	strh	r3, [r7, #6]
 8012e04:	e027      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 8012e06:	88fa      	ldrh	r2, [r7, #6]
 8012e08:	8a7b      	ldrh	r3, [r7, #18]
 8012e0a:	1ad3      	subs	r3, r2, r3
 8012e0c:	b29b      	uxth	r3, r3
 8012e0e:	f003 0301 	and.w	r3, r3, #1
 8012e12:	b29b      	uxth	r3, r3
 8012e14:	88fa      	ldrh	r2, [r7, #6]
 8012e16:	1ad3      	subs	r3, r2, r3
 8012e18:	80fb      	strh	r3, [r7, #6]
 8012e1a:	e01c      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 2: chr -= 16; break;				/* Shift -16 */
 8012e1c:	88fb      	ldrh	r3, [r7, #6]
 8012e1e:	3b10      	subs	r3, #16
 8012e20:	80fb      	strh	r3, [r7, #6]
 8012e22:	e018      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 3:	chr -= 32; break;				/* Shift -32 */
 8012e24:	88fb      	ldrh	r3, [r7, #6]
 8012e26:	3b20      	subs	r3, #32
 8012e28:	80fb      	strh	r3, [r7, #6]
 8012e2a:	e014      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 4:	chr -= 48; break;				/* Shift -48 */
 8012e2c:	88fb      	ldrh	r3, [r7, #6]
 8012e2e:	3b30      	subs	r3, #48	@ 0x30
 8012e30:	80fb      	strh	r3, [r7, #6]
 8012e32:	e010      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 5:	chr -= 26; break;				/* Shift -26 */
 8012e34:	88fb      	ldrh	r3, [r7, #6]
 8012e36:	3b1a      	subs	r3, #26
 8012e38:	80fb      	strh	r3, [r7, #6]
 8012e3a:	e00c      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 6:	chr += 8; break;				/* Shift +8 */
 8012e3c:	88fb      	ldrh	r3, [r7, #6]
 8012e3e:	3308      	adds	r3, #8
 8012e40:	80fb      	strh	r3, [r7, #6]
 8012e42:	e008      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 7: chr -= 80; break;				/* Shift -80 */
 8012e44:	88fb      	ldrh	r3, [r7, #6]
 8012e46:	3b50      	subs	r3, #80	@ 0x50
 8012e48:	80fb      	strh	r3, [r7, #6]
 8012e4a:	e004      	b.n	8012e56 <ff_wtoupper+0xe6>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 8012e4c:	88fb      	ldrh	r3, [r7, #6]
 8012e4e:	f5a3 53e3 	sub.w	r3, r3, #7264	@ 0x1c60
 8012e52:	80fb      	strh	r3, [r7, #6]
 8012e54:	bf00      	nop
			}
			break;
 8012e56:	e008      	b.n	8012e6a <ff_wtoupper+0xfa>
		}
		if (!cmd) p += nc;
 8012e58:	89fb      	ldrh	r3, [r7, #14]
 8012e5a:	2b00      	cmp	r3, #0
 8012e5c:	d195      	bne.n	8012d8a <ff_wtoupper+0x1a>
 8012e5e:	8a3b      	ldrh	r3, [r7, #16]
 8012e60:	005b      	lsls	r3, r3, #1
 8012e62:	697a      	ldr	r2, [r7, #20]
 8012e64:	4413      	add	r3, r2
 8012e66:	617b      	str	r3, [r7, #20]
		bc = *p++;								/* Get block base */
 8012e68:	e78f      	b.n	8012d8a <ff_wtoupper+0x1a>
			break;
 8012e6a:	bf00      	nop
	}

	return chr;
 8012e6c:	88fb      	ldrh	r3, [r7, #6]
}
 8012e6e:	4618      	mov	r0, r3
 8012e70:	371c      	adds	r7, #28
 8012e72:	46bd      	mov	sp, r7
 8012e74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e78:	4770      	bx	lr
 8012e7a:	bf00      	nop
 8012e7c:	08031b88 	.word	0x08031b88
 8012e80:	08031d7c 	.word	0x08031d7c

08012e84 <jpeg_abort>:
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
 8012e84:	b580      	push	{r7, lr}
 8012e86:	b084      	sub	sp, #16
 8012e88:	af00      	add	r7, sp, #0
 8012e8a:	6078      	str	r0, [r7, #4]
  int pool;

  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
  if (cinfo->mem == NULL)
 8012e8c:	687b      	ldr	r3, [r7, #4]
 8012e8e:	685b      	ldr	r3, [r3, #4]
 8012e90:	2b00      	cmp	r3, #0
 8012e92:	d01e      	beq.n	8012ed2 <jpeg_abort+0x4e>
    return;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 8012e94:	2301      	movs	r3, #1
 8012e96:	60fb      	str	r3, [r7, #12]
 8012e98:	e008      	b.n	8012eac <jpeg_abort+0x28>
    (*cinfo->mem->free_pool) (cinfo, pool);
 8012e9a:	687b      	ldr	r3, [r7, #4]
 8012e9c:	685b      	ldr	r3, [r3, #4]
 8012e9e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012ea0:	68f9      	ldr	r1, [r7, #12]
 8012ea2:	6878      	ldr	r0, [r7, #4]
 8012ea4:	4798      	blx	r3
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 8012ea6:	68fb      	ldr	r3, [r7, #12]
 8012ea8:	3b01      	subs	r3, #1
 8012eaa:	60fb      	str	r3, [r7, #12]
 8012eac:	68fb      	ldr	r3, [r7, #12]
 8012eae:	2b00      	cmp	r3, #0
 8012eb0:	dcf3      	bgt.n	8012e9a <jpeg_abort+0x16>
  }

  /* Reset overall state for possible reuse of object */
  if (cinfo->is_decompressor) {
 8012eb2:	687b      	ldr	r3, [r7, #4]
 8012eb4:	691b      	ldr	r3, [r3, #16]
 8012eb6:	2b00      	cmp	r3, #0
 8012eb8:	d007      	beq.n	8012eca <jpeg_abort+0x46>
    cinfo->global_state = DSTATE_START;
 8012eba:	687b      	ldr	r3, [r7, #4]
 8012ebc:	22c8      	movs	r2, #200	@ 0xc8
 8012ebe:	615a      	str	r2, [r3, #20]
    /* Try to keep application from accessing now-deleted marker list.
     * A bit kludgy to do it here, but this is the most central place.
     */
    ((j_decompress_ptr) cinfo)->marker_list = NULL;
 8012ec0:	687b      	ldr	r3, [r7, #4]
 8012ec2:	2200      	movs	r2, #0
 8012ec4:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
 8012ec8:	e004      	b.n	8012ed4 <jpeg_abort+0x50>
  } else {
    cinfo->global_state = CSTATE_START;
 8012eca:	687b      	ldr	r3, [r7, #4]
 8012ecc:	2264      	movs	r2, #100	@ 0x64
 8012ece:	615a      	str	r2, [r3, #20]
 8012ed0:	e000      	b.n	8012ed4 <jpeg_abort+0x50>
    return;
 8012ed2:	bf00      	nop
  }
}
 8012ed4:	3710      	adds	r7, #16
 8012ed6:	46bd      	mov	sp, r7
 8012ed8:	bd80      	pop	{r7, pc}

08012eda <jpeg_destroy>:
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
 8012eda:	b580      	push	{r7, lr}
 8012edc:	b082      	sub	sp, #8
 8012ede:	af00      	add	r7, sp, #0
 8012ee0:	6078      	str	r0, [r7, #4]
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
 8012ee2:	687b      	ldr	r3, [r7, #4]
 8012ee4:	685b      	ldr	r3, [r3, #4]
 8012ee6:	2b00      	cmp	r3, #0
 8012ee8:	d004      	beq.n	8012ef4 <jpeg_destroy+0x1a>
    (*cinfo->mem->self_destruct) (cinfo);
 8012eea:	687b      	ldr	r3, [r7, #4]
 8012eec:	685b      	ldr	r3, [r3, #4]
 8012eee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012ef0:	6878      	ldr	r0, [r7, #4]
 8012ef2:	4798      	blx	r3
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
 8012ef4:	687b      	ldr	r3, [r7, #4]
 8012ef6:	2200      	movs	r2, #0
 8012ef8:	605a      	str	r2, [r3, #4]
  cinfo->global_state = 0;	/* mark it destroyed */
 8012efa:	687b      	ldr	r3, [r7, #4]
 8012efc:	2200      	movs	r2, #0
 8012efe:	615a      	str	r2, [r3, #20]
}
 8012f00:	bf00      	nop
 8012f02:	3708      	adds	r7, #8
 8012f04:	46bd      	mov	sp, r7
 8012f06:	bd80      	pop	{r7, pc}

08012f08 <jpeg_alloc_quant_table>:
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
 8012f08:	b580      	push	{r7, lr}
 8012f0a:	b084      	sub	sp, #16
 8012f0c:	af00      	add	r7, sp, #0
 8012f0e:	6078      	str	r0, [r7, #4]
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
 8012f10:	687b      	ldr	r3, [r7, #4]
 8012f12:	685b      	ldr	r3, [r3, #4]
 8012f14:	681b      	ldr	r3, [r3, #0]
 8012f16:	2284      	movs	r2, #132	@ 0x84
 8012f18:	2100      	movs	r1, #0
 8012f1a:	6878      	ldr	r0, [r7, #4]
 8012f1c:	4798      	blx	r3
 8012f1e:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 8012f20:	68fb      	ldr	r3, [r7, #12]
 8012f22:	2200      	movs	r2, #0
 8012f24:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  return tbl;
 8012f28:	68fb      	ldr	r3, [r7, #12]
}
 8012f2a:	4618      	mov	r0, r3
 8012f2c:	3710      	adds	r7, #16
 8012f2e:	46bd      	mov	sp, r7
 8012f30:	bd80      	pop	{r7, pc}

08012f32 <jpeg_alloc_huff_table>:


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
 8012f32:	b580      	push	{r7, lr}
 8012f34:	b084      	sub	sp, #16
 8012f36:	af00      	add	r7, sp, #0
 8012f38:	6078      	str	r0, [r7, #4]
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
 8012f3a:	687b      	ldr	r3, [r7, #4]
 8012f3c:	685b      	ldr	r3, [r3, #4]
 8012f3e:	681b      	ldr	r3, [r3, #0]
 8012f40:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8012f44:	2100      	movs	r1, #0
 8012f46:	6878      	ldr	r0, [r7, #4]
 8012f48:	4798      	blx	r3
 8012f4a:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 8012f4c:	68fb      	ldr	r3, [r7, #12]
 8012f4e:	2200      	movs	r2, #0
 8012f50:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
  return tbl;
 8012f54:	68fb      	ldr	r3, [r7, #12]
}
 8012f56:	4618      	mov	r0, r3
 8012f58:	3710      	adds	r7, #16
 8012f5a:	46bd      	mov	sp, r7
 8012f5c:	bd80      	pop	{r7, pc}

08012f5e <jpeg_CreateDecompress>:
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
 8012f5e:	b580      	push	{r7, lr}
 8012f60:	b088      	sub	sp, #32
 8012f62:	af00      	add	r7, sp, #0
 8012f64:	60f8      	str	r0, [r7, #12]
 8012f66:	60b9      	str	r1, [r7, #8]
 8012f68:	607a      	str	r2, [r7, #4]
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
 8012f6a:	68fb      	ldr	r3, [r7, #12]
 8012f6c:	2200      	movs	r2, #0
 8012f6e:	605a      	str	r2, [r3, #4]
  if (version != JPEG_LIB_VERSION)
 8012f70:	68bb      	ldr	r3, [r7, #8]
 8012f72:	2b50      	cmp	r3, #80	@ 0x50
 8012f74:	d010      	beq.n	8012f98 <jpeg_CreateDecompress+0x3a>
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
 8012f76:	68fb      	ldr	r3, [r7, #12]
 8012f78:	681b      	ldr	r3, [r3, #0]
 8012f7a:	220d      	movs	r2, #13
 8012f7c:	615a      	str	r2, [r3, #20]
 8012f7e:	68fb      	ldr	r3, [r7, #12]
 8012f80:	681b      	ldr	r3, [r3, #0]
 8012f82:	2250      	movs	r2, #80	@ 0x50
 8012f84:	619a      	str	r2, [r3, #24]
 8012f86:	68fb      	ldr	r3, [r7, #12]
 8012f88:	681b      	ldr	r3, [r3, #0]
 8012f8a:	68ba      	ldr	r2, [r7, #8]
 8012f8c:	61da      	str	r2, [r3, #28]
 8012f8e:	68fb      	ldr	r3, [r7, #12]
 8012f90:	681b      	ldr	r3, [r3, #0]
 8012f92:	681b      	ldr	r3, [r3, #0]
 8012f94:	68f8      	ldr	r0, [r7, #12]
 8012f96:	4798      	blx	r3
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
 8012f98:	687b      	ldr	r3, [r7, #4]
 8012f9a:	f5b3 7ff4 	cmp.w	r3, #488	@ 0x1e8
 8012f9e:	d011      	beq.n	8012fc4 <jpeg_CreateDecompress+0x66>
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
 8012fa0:	68fb      	ldr	r3, [r7, #12]
 8012fa2:	681b      	ldr	r3, [r3, #0]
 8012fa4:	2216      	movs	r2, #22
 8012fa6:	615a      	str	r2, [r3, #20]
 8012fa8:	68fb      	ldr	r3, [r7, #12]
 8012faa:	681b      	ldr	r3, [r3, #0]
 8012fac:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8012fb0:	619a      	str	r2, [r3, #24]
 8012fb2:	68fb      	ldr	r3, [r7, #12]
 8012fb4:	681b      	ldr	r3, [r3, #0]
 8012fb6:	687a      	ldr	r2, [r7, #4]
 8012fb8:	61da      	str	r2, [r3, #28]
 8012fba:	68fb      	ldr	r3, [r7, #12]
 8012fbc:	681b      	ldr	r3, [r3, #0]
 8012fbe:	681b      	ldr	r3, [r3, #0]
 8012fc0:	68f8      	ldr	r0, [r7, #12]
 8012fc2:	4798      	blx	r3
   * client_data, so we have to save and restore those fields.
   * Note: if application hasn't set client_data, tools like Purify may
   * complain here.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
 8012fc4:	68fb      	ldr	r3, [r7, #12]
 8012fc6:	681b      	ldr	r3, [r3, #0]
 8012fc8:	61bb      	str	r3, [r7, #24]
    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
 8012fca:	68fb      	ldr	r3, [r7, #12]
 8012fcc:	68db      	ldr	r3, [r3, #12]
 8012fce:	617b      	str	r3, [r7, #20]
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
 8012fd0:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 8012fd4:	2100      	movs	r1, #0
 8012fd6:	68f8      	ldr	r0, [r7, #12]
 8012fd8:	f01c fce2 	bl	802f9a0 <memset>
    cinfo->err = err;
 8012fdc:	68fb      	ldr	r3, [r7, #12]
 8012fde:	69ba      	ldr	r2, [r7, #24]
 8012fe0:	601a      	str	r2, [r3, #0]
    cinfo->client_data = client_data;
 8012fe2:	68fb      	ldr	r3, [r7, #12]
 8012fe4:	697a      	ldr	r2, [r7, #20]
 8012fe6:	60da      	str	r2, [r3, #12]
  }
  cinfo->is_decompressor = TRUE;
 8012fe8:	68fb      	ldr	r3, [r7, #12]
 8012fea:	2201      	movs	r2, #1
 8012fec:	611a      	str	r2, [r3, #16]

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);
 8012fee:	68f8      	ldr	r0, [r7, #12]
 8012ff0:	f019 fc8e 	bl	802c910 <jinit_memory_mgr>

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
 8012ff4:	68fb      	ldr	r3, [r7, #12]
 8012ff6:	2200      	movs	r2, #0
 8012ff8:	609a      	str	r2, [r3, #8]
  cinfo->src = NULL;
 8012ffa:	68fb      	ldr	r3, [r7, #12]
 8012ffc:	2200      	movs	r2, #0
 8012ffe:	619a      	str	r2, [r3, #24]

  for (i = 0; i < NUM_QUANT_TBLS; i++)
 8013000:	2300      	movs	r3, #0
 8013002:	61fb      	str	r3, [r7, #28]
 8013004:	e009      	b.n	801301a <jpeg_CreateDecompress+0xbc>
    cinfo->quant_tbl_ptrs[i] = NULL;
 8013006:	68fa      	ldr	r2, [r7, #12]
 8013008:	69fb      	ldr	r3, [r7, #28]
 801300a:	3328      	adds	r3, #40	@ 0x28
 801300c:	009b      	lsls	r3, r3, #2
 801300e:	4413      	add	r3, r2
 8013010:	2200      	movs	r2, #0
 8013012:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_QUANT_TBLS; i++)
 8013014:	69fb      	ldr	r3, [r7, #28]
 8013016:	3301      	adds	r3, #1
 8013018:	61fb      	str	r3, [r7, #28]
 801301a:	69fb      	ldr	r3, [r7, #28]
 801301c:	2b03      	cmp	r3, #3
 801301e:	ddf2      	ble.n	8013006 <jpeg_CreateDecompress+0xa8>

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8013020:	2300      	movs	r3, #0
 8013022:	61fb      	str	r3, [r7, #28]
 8013024:	e010      	b.n	8013048 <jpeg_CreateDecompress+0xea>
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
 8013026:	68fa      	ldr	r2, [r7, #12]
 8013028:	69fb      	ldr	r3, [r7, #28]
 801302a:	332c      	adds	r3, #44	@ 0x2c
 801302c:	009b      	lsls	r3, r3, #2
 801302e:	4413      	add	r3, r2
 8013030:	2200      	movs	r2, #0
 8013032:	605a      	str	r2, [r3, #4]
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
 8013034:	68fa      	ldr	r2, [r7, #12]
 8013036:	69fb      	ldr	r3, [r7, #28]
 8013038:	3330      	adds	r3, #48	@ 0x30
 801303a:	009b      	lsls	r3, r3, #2
 801303c:	4413      	add	r3, r2
 801303e:	2200      	movs	r2, #0
 8013040:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8013042:	69fb      	ldr	r3, [r7, #28]
 8013044:	3301      	adds	r3, #1
 8013046:	61fb      	str	r3, [r7, #28]
 8013048:	69fb      	ldr	r3, [r7, #28]
 801304a:	2b03      	cmp	r3, #3
 801304c:	ddeb      	ble.n	8013026 <jpeg_CreateDecompress+0xc8>
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  cinfo->marker_list = NULL;
 801304e:	68fb      	ldr	r3, [r7, #12]
 8013050:	2200      	movs	r2, #0
 8013052:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
  jinit_marker_reader(cinfo);
 8013056:	68f8      	ldr	r0, [r7, #12]
 8013058:	f009 fdda 	bl	801cc10 <jinit_marker_reader>

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);
 801305c:	68f8      	ldr	r0, [r7, #12]
 801305e:	f006 ffdf 	bl	801a020 <jinit_input_controller>

  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
 8013062:	68fb      	ldr	r3, [r7, #12]
 8013064:	22c8      	movs	r2, #200	@ 0xc8
 8013066:	615a      	str	r2, [r3, #20]
}
 8013068:	bf00      	nop
 801306a:	3720      	adds	r7, #32
 801306c:	46bd      	mov	sp, r7
 801306e:	bd80      	pop	{r7, pc}

08013070 <jpeg_destroy_decompress>:
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
 8013070:	b580      	push	{r7, lr}
 8013072:	b082      	sub	sp, #8
 8013074:	af00      	add	r7, sp, #0
 8013076:	6078      	str	r0, [r7, #4]
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
 8013078:	6878      	ldr	r0, [r7, #4]
 801307a:	f7ff ff2e 	bl	8012eda <jpeg_destroy>
}
 801307e:	bf00      	nop
 8013080:	3708      	adds	r7, #8
 8013082:	46bd      	mov	sp, r7
 8013084:	bd80      	pop	{r7, pc}
	...

08013088 <default_decompress_parms>:
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
 8013088:	b580      	push	{r7, lr}
 801308a:	b086      	sub	sp, #24
 801308c:	af00      	add	r7, sp, #0
 801308e:	6078      	str	r0, [r7, #4]
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
 8013090:	687b      	ldr	r3, [r7, #4]
 8013092:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8013094:	2b04      	cmp	r3, #4
 8013096:	f000 8097 	beq.w	80131c8 <default_decompress_parms+0x140>
 801309a:	2b04      	cmp	r3, #4
 801309c:	f300 80ca 	bgt.w	8013234 <default_decompress_parms+0x1ac>
 80130a0:	2b01      	cmp	r3, #1
 80130a2:	d002      	beq.n	80130aa <default_decompress_parms+0x22>
 80130a4:	2b03      	cmp	r3, #3
 80130a6:	d009      	beq.n	80130bc <default_decompress_parms+0x34>
 80130a8:	e0c4      	b.n	8013234 <default_decompress_parms+0x1ac>
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
 80130aa:	687b      	ldr	r3, [r7, #4]
 80130ac:	2201      	movs	r2, #1
 80130ae:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    cinfo->out_color_space = JCS_GRAYSCALE;
 80130b2:	687b      	ldr	r3, [r7, #4]
 80130b4:	2201      	movs	r2, #1
 80130b6:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 80130ba:	e0c4      	b.n	8013246 <default_decompress_parms+0x1be>
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
 80130bc:	687b      	ldr	r3, [r7, #4]
 80130be:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 80130c2:	2b00      	cmp	r3, #0
 80130c4:	d004      	beq.n	80130d0 <default_decompress_parms+0x48>
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
 80130c6:	687b      	ldr	r3, [r7, #4]
 80130c8:	2203      	movs	r2, #3
 80130ca:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 80130ce:	e076      	b.n	80131be <default_decompress_parms+0x136>
    } else if (cinfo->saw_Adobe_marker) {
 80130d0:	687b      	ldr	r3, [r7, #4]
 80130d2:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
 80130d6:	2b00      	cmp	r3, #0
 80130d8:	d027      	beq.n	801312a <default_decompress_parms+0xa2>
      switch (cinfo->Adobe_transform) {
 80130da:	687b      	ldr	r3, [r7, #4]
 80130dc:	f893 312c 	ldrb.w	r3, [r3, #300]	@ 0x12c
 80130e0:	2b00      	cmp	r3, #0
 80130e2:	d002      	beq.n	80130ea <default_decompress_parms+0x62>
 80130e4:	2b01      	cmp	r3, #1
 80130e6:	d005      	beq.n	80130f4 <default_decompress_parms+0x6c>
 80130e8:	e009      	b.n	80130fe <default_decompress_parms+0x76>
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
 80130ea:	687b      	ldr	r3, [r7, #4]
 80130ec:	2202      	movs	r2, #2
 80130ee:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 80130f2:	e064      	b.n	80131be <default_decompress_parms+0x136>
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
 80130f4:	687b      	ldr	r3, [r7, #4]
 80130f6:	2203      	movs	r2, #3
 80130f8:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 80130fc:	e05f      	b.n	80131be <default_decompress_parms+0x136>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 80130fe:	687b      	ldr	r3, [r7, #4]
 8013100:	681b      	ldr	r3, [r3, #0]
 8013102:	2274      	movs	r2, #116	@ 0x74
 8013104:	615a      	str	r2, [r3, #20]
 8013106:	687b      	ldr	r3, [r7, #4]
 8013108:	f893 212c 	ldrb.w	r2, [r3, #300]	@ 0x12c
 801310c:	687b      	ldr	r3, [r7, #4]
 801310e:	681b      	ldr	r3, [r3, #0]
 8013110:	619a      	str	r2, [r3, #24]
 8013112:	687b      	ldr	r3, [r7, #4]
 8013114:	681b      	ldr	r3, [r3, #0]
 8013116:	685b      	ldr	r3, [r3, #4]
 8013118:	f04f 31ff 	mov.w	r1, #4294967295
 801311c:	6878      	ldr	r0, [r7, #4]
 801311e:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 8013120:	687b      	ldr	r3, [r7, #4]
 8013122:	2203      	movs	r2, #3
 8013124:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8013128:	e049      	b.n	80131be <default_decompress_parms+0x136>
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
 801312a:	687b      	ldr	r3, [r7, #4]
 801312c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8013130:	681b      	ldr	r3, [r3, #0]
 8013132:	617b      	str	r3, [r7, #20]
      int cid1 = cinfo->comp_info[1].component_id;
 8013134:	687b      	ldr	r3, [r7, #4]
 8013136:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801313a:	3358      	adds	r3, #88	@ 0x58
 801313c:	681b      	ldr	r3, [r3, #0]
 801313e:	613b      	str	r3, [r7, #16]
      int cid2 = cinfo->comp_info[2].component_id;
 8013140:	687b      	ldr	r3, [r7, #4]
 8013142:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8013146:	33b0      	adds	r3, #176	@ 0xb0
 8013148:	681b      	ldr	r3, [r3, #0]
 801314a:	60fb      	str	r3, [r7, #12]

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
 801314c:	697b      	ldr	r3, [r7, #20]
 801314e:	2b01      	cmp	r3, #1
 8013150:	d10a      	bne.n	8013168 <default_decompress_parms+0xe0>
 8013152:	693b      	ldr	r3, [r7, #16]
 8013154:	2b02      	cmp	r3, #2
 8013156:	d107      	bne.n	8013168 <default_decompress_parms+0xe0>
 8013158:	68fb      	ldr	r3, [r7, #12]
 801315a:	2b03      	cmp	r3, #3
 801315c:	d104      	bne.n	8013168 <default_decompress_parms+0xe0>
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
 801315e:	687b      	ldr	r3, [r7, #4]
 8013160:	2203      	movs	r2, #3
 8013162:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 8013166:	e02a      	b.n	80131be <default_decompress_parms+0x136>
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
 8013168:	697b      	ldr	r3, [r7, #20]
 801316a:	2b52      	cmp	r3, #82	@ 0x52
 801316c:	d10a      	bne.n	8013184 <default_decompress_parms+0xfc>
 801316e:	693b      	ldr	r3, [r7, #16]
 8013170:	2b47      	cmp	r3, #71	@ 0x47
 8013172:	d107      	bne.n	8013184 <default_decompress_parms+0xfc>
 8013174:	68fb      	ldr	r3, [r7, #12]
 8013176:	2b42      	cmp	r3, #66	@ 0x42
 8013178:	d104      	bne.n	8013184 <default_decompress_parms+0xfc>
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
 801317a:	687b      	ldr	r3, [r7, #4]
 801317c:	2202      	movs	r2, #2
 801317e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 8013182:	e01c      	b.n	80131be <default_decompress_parms+0x136>
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	681b      	ldr	r3, [r3, #0]
 8013188:	3318      	adds	r3, #24
 801318a:	60bb      	str	r3, [r7, #8]
 801318c:	68bb      	ldr	r3, [r7, #8]
 801318e:	697a      	ldr	r2, [r7, #20]
 8013190:	601a      	str	r2, [r3, #0]
 8013192:	68bb      	ldr	r3, [r7, #8]
 8013194:	3304      	adds	r3, #4
 8013196:	693a      	ldr	r2, [r7, #16]
 8013198:	601a      	str	r2, [r3, #0]
 801319a:	68bb      	ldr	r3, [r7, #8]
 801319c:	3308      	adds	r3, #8
 801319e:	68fa      	ldr	r2, [r7, #12]
 80131a0:	601a      	str	r2, [r3, #0]
 80131a2:	687b      	ldr	r3, [r7, #4]
 80131a4:	681b      	ldr	r3, [r3, #0]
 80131a6:	2271      	movs	r2, #113	@ 0x71
 80131a8:	615a      	str	r2, [r3, #20]
 80131aa:	687b      	ldr	r3, [r7, #4]
 80131ac:	681b      	ldr	r3, [r3, #0]
 80131ae:	685b      	ldr	r3, [r3, #4]
 80131b0:	2101      	movs	r1, #1
 80131b2:	6878      	ldr	r0, [r7, #4]
 80131b4:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 80131b6:	687b      	ldr	r3, [r7, #4]
 80131b8:	2203      	movs	r2, #3
 80131ba:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
 80131be:	687b      	ldr	r3, [r7, #4]
 80131c0:	2202      	movs	r2, #2
 80131c2:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 80131c6:	e03e      	b.n	8013246 <default_decompress_parms+0x1be>
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
 80131c8:	687b      	ldr	r3, [r7, #4]
 80131ca:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
 80131ce:	2b00      	cmp	r3, #0
 80131d0:	d027      	beq.n	8013222 <default_decompress_parms+0x19a>
      switch (cinfo->Adobe_transform) {
 80131d2:	687b      	ldr	r3, [r7, #4]
 80131d4:	f893 312c 	ldrb.w	r3, [r3, #300]	@ 0x12c
 80131d8:	2b00      	cmp	r3, #0
 80131da:	d002      	beq.n	80131e2 <default_decompress_parms+0x15a>
 80131dc:	2b02      	cmp	r3, #2
 80131de:	d005      	beq.n	80131ec <default_decompress_parms+0x164>
 80131e0:	e009      	b.n	80131f6 <default_decompress_parms+0x16e>
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
 80131e2:	687b      	ldr	r3, [r7, #4]
 80131e4:	2204      	movs	r2, #4
 80131e6:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 80131ea:	e01e      	b.n	801322a <default_decompress_parms+0x1a2>
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
 80131ec:	687b      	ldr	r3, [r7, #4]
 80131ee:	2205      	movs	r2, #5
 80131f0:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 80131f4:	e019      	b.n	801322a <default_decompress_parms+0x1a2>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 80131f6:	687b      	ldr	r3, [r7, #4]
 80131f8:	681b      	ldr	r3, [r3, #0]
 80131fa:	2274      	movs	r2, #116	@ 0x74
 80131fc:	615a      	str	r2, [r3, #20]
 80131fe:	687b      	ldr	r3, [r7, #4]
 8013200:	f893 212c 	ldrb.w	r2, [r3, #300]	@ 0x12c
 8013204:	687b      	ldr	r3, [r7, #4]
 8013206:	681b      	ldr	r3, [r3, #0]
 8013208:	619a      	str	r2, [r3, #24]
 801320a:	687b      	ldr	r3, [r7, #4]
 801320c:	681b      	ldr	r3, [r3, #0]
 801320e:	685b      	ldr	r3, [r3, #4]
 8013210:	f04f 31ff 	mov.w	r1, #4294967295
 8013214:	6878      	ldr	r0, [r7, #4]
 8013216:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
 8013218:	687b      	ldr	r3, [r7, #4]
 801321a:	2205      	movs	r2, #5
 801321c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	break;
 8013220:	e003      	b.n	801322a <default_decompress_parms+0x1a2>
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
 8013222:	687b      	ldr	r3, [r7, #4]
 8013224:	2204      	movs	r2, #4
 8013226:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    }
    cinfo->out_color_space = JCS_CMYK;
 801322a:	687b      	ldr	r3, [r7, #4]
 801322c:	2204      	movs	r2, #4
 801322e:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8013232:	e008      	b.n	8013246 <default_decompress_parms+0x1be>
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
 8013234:	687b      	ldr	r3, [r7, #4]
 8013236:	2200      	movs	r2, #0
 8013238:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    cinfo->out_color_space = JCS_UNKNOWN;
 801323c:	687b      	ldr	r3, [r7, #4]
 801323e:	2200      	movs	r2, #0
 8013240:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
    break;
 8013244:	bf00      	nop
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = cinfo->block_size;		/* 1:1 scaling */
 8013246:	687b      	ldr	r3, [r7, #4]
 8013248:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801324c:	461a      	mov	r2, r3
 801324e:	687b      	ldr	r3, [r7, #4]
 8013250:	62da      	str	r2, [r3, #44]	@ 0x2c
  cinfo->scale_denom = cinfo->block_size;
 8013252:	687b      	ldr	r3, [r7, #4]
 8013254:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8013258:	461a      	mov	r2, r3
 801325a:	687b      	ldr	r3, [r7, #4]
 801325c:	631a      	str	r2, [r3, #48]	@ 0x30
  cinfo->output_gamma = 1.0;
 801325e:	6879      	ldr	r1, [r7, #4]
 8013260:	f04f 0200 	mov.w	r2, #0
 8013264:	4b18      	ldr	r3, [pc, #96]	@ (80132c8 <default_decompress_parms+0x240>)
 8013266:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
  cinfo->buffered_image = FALSE;
 801326a:	687b      	ldr	r3, [r7, #4]
 801326c:	2200      	movs	r2, #0
 801326e:	641a      	str	r2, [r3, #64]	@ 0x40
  cinfo->raw_data_out = FALSE;
 8013270:	687b      	ldr	r3, [r7, #4]
 8013272:	2200      	movs	r2, #0
 8013274:	645a      	str	r2, [r3, #68]	@ 0x44
  cinfo->dct_method = JDCT_DEFAULT;
 8013276:	687b      	ldr	r3, [r7, #4]
 8013278:	2200      	movs	r2, #0
 801327a:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
  cinfo->do_fancy_upsampling = TRUE;
 801327e:	687b      	ldr	r3, [r7, #4]
 8013280:	2201      	movs	r2, #1
 8013282:	64da      	str	r2, [r3, #76]	@ 0x4c
  cinfo->do_block_smoothing = TRUE;
 8013284:	687b      	ldr	r3, [r7, #4]
 8013286:	2201      	movs	r2, #1
 8013288:	651a      	str	r2, [r3, #80]	@ 0x50
  cinfo->quantize_colors = FALSE;
 801328a:	687b      	ldr	r3, [r7, #4]
 801328c:	2200      	movs	r2, #0
 801328e:	655a      	str	r2, [r3, #84]	@ 0x54
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
 8013290:	687b      	ldr	r3, [r7, #4]
 8013292:	2202      	movs	r2, #2
 8013294:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
 8013298:	687b      	ldr	r3, [r7, #4]
 801329a:	2201      	movs	r2, #1
 801329c:	65da      	str	r2, [r3, #92]	@ 0x5c
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
 801329e:	687b      	ldr	r3, [r7, #4]
 80132a0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80132a4:	661a      	str	r2, [r3, #96]	@ 0x60
  cinfo->colormap = NULL;
 80132a6:	687b      	ldr	r3, [r7, #4]
 80132a8:	2200      	movs	r2, #0
 80132aa:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
 80132ae:	687b      	ldr	r3, [r7, #4]
 80132b0:	2200      	movs	r2, #0
 80132b2:	665a      	str	r2, [r3, #100]	@ 0x64
  cinfo->enable_external_quant = FALSE;
 80132b4:	687b      	ldr	r3, [r7, #4]
 80132b6:	2200      	movs	r2, #0
 80132b8:	669a      	str	r2, [r3, #104]	@ 0x68
  cinfo->enable_2pass_quant = FALSE;
 80132ba:	687b      	ldr	r3, [r7, #4]
 80132bc:	2200      	movs	r2, #0
 80132be:	66da      	str	r2, [r3, #108]	@ 0x6c
}
 80132c0:	bf00      	nop
 80132c2:	3718      	adds	r7, #24
 80132c4:	46bd      	mov	sp, r7
 80132c6:	bd80      	pop	{r7, pc}
 80132c8:	3ff00000 	.word	0x3ff00000

080132cc <jpeg_read_header>:
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
 80132cc:	b580      	push	{r7, lr}
 80132ce:	b084      	sub	sp, #16
 80132d0:	af00      	add	r7, sp, #0
 80132d2:	6078      	str	r0, [r7, #4]
 80132d4:	6039      	str	r1, [r7, #0]
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
 80132d6:	687b      	ldr	r3, [r7, #4]
 80132d8:	695b      	ldr	r3, [r3, #20]
 80132da:	2bc8      	cmp	r3, #200	@ 0xc8
 80132dc:	d011      	beq.n	8013302 <jpeg_read_header+0x36>
      cinfo->global_state != DSTATE_INHEADER)
 80132de:	687b      	ldr	r3, [r7, #4]
 80132e0:	695b      	ldr	r3, [r3, #20]
  if (cinfo->global_state != DSTATE_START &&
 80132e2:	2bc9      	cmp	r3, #201	@ 0xc9
 80132e4:	d00d      	beq.n	8013302 <jpeg_read_header+0x36>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80132e6:	687b      	ldr	r3, [r7, #4]
 80132e8:	681b      	ldr	r3, [r3, #0]
 80132ea:	2215      	movs	r2, #21
 80132ec:	615a      	str	r2, [r3, #20]
 80132ee:	687b      	ldr	r3, [r7, #4]
 80132f0:	681b      	ldr	r3, [r3, #0]
 80132f2:	687a      	ldr	r2, [r7, #4]
 80132f4:	6952      	ldr	r2, [r2, #20]
 80132f6:	619a      	str	r2, [r3, #24]
 80132f8:	687b      	ldr	r3, [r7, #4]
 80132fa:	681b      	ldr	r3, [r3, #0]
 80132fc:	681b      	ldr	r3, [r3, #0]
 80132fe:	6878      	ldr	r0, [r7, #4]
 8013300:	4798      	blx	r3

  retcode = jpeg_consume_input(cinfo);
 8013302:	6878      	ldr	r0, [r7, #4]
 8013304:	f000 f828 	bl	8013358 <jpeg_consume_input>
 8013308:	60f8      	str	r0, [r7, #12]

  switch (retcode) {
 801330a:	68fb      	ldr	r3, [r7, #12]
 801330c:	2b02      	cmp	r3, #2
 801330e:	d00b      	beq.n	8013328 <jpeg_read_header+0x5c>
 8013310:	68fb      	ldr	r3, [r7, #12]
 8013312:	2b02      	cmp	r3, #2
 8013314:	dc1b      	bgt.n	801334e <jpeg_read_header+0x82>
 8013316:	68fb      	ldr	r3, [r7, #12]
 8013318:	2b00      	cmp	r3, #0
 801331a:	d017      	beq.n	801334c <jpeg_read_header+0x80>
 801331c:	68fb      	ldr	r3, [r7, #12]
 801331e:	2b01      	cmp	r3, #1
 8013320:	d115      	bne.n	801334e <jpeg_read_header+0x82>
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
 8013322:	2301      	movs	r3, #1
 8013324:	60fb      	str	r3, [r7, #12]
    break;
 8013326:	e012      	b.n	801334e <jpeg_read_header+0x82>
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
 8013328:	683b      	ldr	r3, [r7, #0]
 801332a:	2b00      	cmp	r3, #0
 801332c:	d008      	beq.n	8013340 <jpeg_read_header+0x74>
      ERREXIT(cinfo, JERR_NO_IMAGE);
 801332e:	687b      	ldr	r3, [r7, #4]
 8013330:	681b      	ldr	r3, [r3, #0]
 8013332:	2235      	movs	r2, #53	@ 0x35
 8013334:	615a      	str	r2, [r3, #20]
 8013336:	687b      	ldr	r3, [r7, #4]
 8013338:	681b      	ldr	r3, [r3, #0]
 801333a:	681b      	ldr	r3, [r3, #0]
 801333c:	6878      	ldr	r0, [r7, #4]
 801333e:	4798      	blx	r3
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
 8013340:	6878      	ldr	r0, [r7, #4]
 8013342:	f7ff fd9f 	bl	8012e84 <jpeg_abort>
    retcode = JPEG_HEADER_TABLES_ONLY;
 8013346:	2302      	movs	r3, #2
 8013348:	60fb      	str	r3, [r7, #12]
    break;
 801334a:	e000      	b.n	801334e <jpeg_read_header+0x82>
  case JPEG_SUSPENDED:
    /* no work */
    break;
 801334c:	bf00      	nop
  }

  return retcode;
 801334e:	68fb      	ldr	r3, [r7, #12]
}
 8013350:	4618      	mov	r0, r3
 8013352:	3710      	adds	r7, #16
 8013354:	46bd      	mov	sp, r7
 8013356:	bd80      	pop	{r7, pc}

08013358 <jpeg_consume_input>:
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
 8013358:	b580      	push	{r7, lr}
 801335a:	b084      	sub	sp, #16
 801335c:	af00      	add	r7, sp, #0
 801335e:	6078      	str	r0, [r7, #4]
  int retcode = JPEG_SUSPENDED;
 8013360:	2300      	movs	r3, #0
 8013362:	60fb      	str	r3, [r7, #12]

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
 8013364:	687b      	ldr	r3, [r7, #4]
 8013366:	695b      	ldr	r3, [r3, #20]
 8013368:	3bc8      	subs	r3, #200	@ 0xc8
 801336a:	2b0a      	cmp	r3, #10
 801336c:	d842      	bhi.n	80133f4 <jpeg_consume_input+0x9c>
 801336e:	a201      	add	r2, pc, #4	@ (adr r2, 8013374 <jpeg_consume_input+0x1c>)
 8013370:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013374:	080133a1 	.word	0x080133a1
 8013378:	080133bd 	.word	0x080133bd
 801337c:	080133df 	.word	0x080133df
 8013380:	080133e5 	.word	0x080133e5
 8013384:	080133e5 	.word	0x080133e5
 8013388:	080133e5 	.word	0x080133e5
 801338c:	080133e5 	.word	0x080133e5
 8013390:	080133e5 	.word	0x080133e5
 8013394:	080133e5 	.word	0x080133e5
 8013398:	080133f5 	.word	0x080133f5
 801339c:	080133e5 	.word	0x080133e5
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
 80133a0:	687b      	ldr	r3, [r7, #4]
 80133a2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80133a6:	685b      	ldr	r3, [r3, #4]
 80133a8:	6878      	ldr	r0, [r7, #4]
 80133aa:	4798      	blx	r3
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
 80133ac:	687b      	ldr	r3, [r7, #4]
 80133ae:	699b      	ldr	r3, [r3, #24]
 80133b0:	689b      	ldr	r3, [r3, #8]
 80133b2:	6878      	ldr	r0, [r7, #4]
 80133b4:	4798      	blx	r3
    cinfo->global_state = DSTATE_INHEADER;
 80133b6:	687b      	ldr	r3, [r7, #4]
 80133b8:	22c9      	movs	r2, #201	@ 0xc9
 80133ba:	615a      	str	r2, [r3, #20]
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 80133bc:	687b      	ldr	r3, [r7, #4]
 80133be:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80133c2:	681b      	ldr	r3, [r3, #0]
 80133c4:	6878      	ldr	r0, [r7, #4]
 80133c6:	4798      	blx	r3
 80133c8:	60f8      	str	r0, [r7, #12]
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
 80133ca:	68fb      	ldr	r3, [r7, #12]
 80133cc:	2b01      	cmp	r3, #1
 80133ce:	d120      	bne.n	8013412 <jpeg_consume_input+0xba>
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
 80133d0:	6878      	ldr	r0, [r7, #4]
 80133d2:	f7ff fe59 	bl	8013088 <default_decompress_parms>
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
 80133d6:	687b      	ldr	r3, [r7, #4]
 80133d8:	22ca      	movs	r2, #202	@ 0xca
 80133da:	615a      	str	r2, [r3, #20]
    }
    break;
 80133dc:	e019      	b.n	8013412 <jpeg_consume_input+0xba>
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
 80133de:	2301      	movs	r3, #1
 80133e0:	60fb      	str	r3, [r7, #12]
    break;
 80133e2:	e017      	b.n	8013414 <jpeg_consume_input+0xbc>
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 80133e4:	687b      	ldr	r3, [r7, #4]
 80133e6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80133ea:	681b      	ldr	r3, [r3, #0]
 80133ec:	6878      	ldr	r0, [r7, #4]
 80133ee:	4798      	blx	r3
 80133f0:	60f8      	str	r0, [r7, #12]
    break;
 80133f2:	e00f      	b.n	8013414 <jpeg_consume_input+0xbc>
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80133f4:	687b      	ldr	r3, [r7, #4]
 80133f6:	681b      	ldr	r3, [r3, #0]
 80133f8:	2215      	movs	r2, #21
 80133fa:	615a      	str	r2, [r3, #20]
 80133fc:	687b      	ldr	r3, [r7, #4]
 80133fe:	681b      	ldr	r3, [r3, #0]
 8013400:	687a      	ldr	r2, [r7, #4]
 8013402:	6952      	ldr	r2, [r2, #20]
 8013404:	619a      	str	r2, [r3, #24]
 8013406:	687b      	ldr	r3, [r7, #4]
 8013408:	681b      	ldr	r3, [r3, #0]
 801340a:	681b      	ldr	r3, [r3, #0]
 801340c:	6878      	ldr	r0, [r7, #4]
 801340e:	4798      	blx	r3
 8013410:	e000      	b.n	8013414 <jpeg_consume_input+0xbc>
    break;
 8013412:	bf00      	nop
  }
  return retcode;
 8013414:	68fb      	ldr	r3, [r7, #12]
}
 8013416:	4618      	mov	r0, r3
 8013418:	3710      	adds	r7, #16
 801341a:	46bd      	mov	sp, r7
 801341c:	bd80      	pop	{r7, pc}
 801341e:	bf00      	nop

08013420 <jpeg_finish_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
 8013420:	b580      	push	{r7, lr}
 8013422:	b082      	sub	sp, #8
 8013424:	af00      	add	r7, sp, #0
 8013426:	6078      	str	r0, [r7, #4]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 8013428:	687b      	ldr	r3, [r7, #4]
 801342a:	695b      	ldr	r3, [r3, #20]
 801342c:	2bcd      	cmp	r3, #205	@ 0xcd
 801342e:	d003      	beq.n	8013438 <jpeg_finish_decompress+0x18>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 8013430:	687b      	ldr	r3, [r7, #4]
 8013432:	695b      	ldr	r3, [r3, #20]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 8013434:	2bce      	cmp	r3, #206	@ 0xce
 8013436:	d11d      	bne.n	8013474 <jpeg_finish_decompress+0x54>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 8013438:	687b      	ldr	r3, [r7, #4]
 801343a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801343c:	2b00      	cmp	r3, #0
 801343e:	d119      	bne.n	8013474 <jpeg_finish_decompress+0x54>
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
 8013440:	687b      	ldr	r3, [r7, #4]
 8013442:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8013446:	687b      	ldr	r3, [r7, #4]
 8013448:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801344a:	429a      	cmp	r2, r3
 801344c:	d208      	bcs.n	8013460 <jpeg_finish_decompress+0x40>
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
 801344e:	687b      	ldr	r3, [r7, #4]
 8013450:	681b      	ldr	r3, [r3, #0]
 8013452:	2245      	movs	r2, #69	@ 0x45
 8013454:	615a      	str	r2, [r3, #20]
 8013456:	687b      	ldr	r3, [r7, #4]
 8013458:	681b      	ldr	r3, [r3, #0]
 801345a:	681b      	ldr	r3, [r3, #0]
 801345c:	6878      	ldr	r0, [r7, #4]
 801345e:	4798      	blx	r3
    (*cinfo->master->finish_output_pass) (cinfo);
 8013460:	687b      	ldr	r3, [r7, #4]
 8013462:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8013466:	685b      	ldr	r3, [r3, #4]
 8013468:	6878      	ldr	r0, [r7, #4]
 801346a:	4798      	blx	r3
    cinfo->global_state = DSTATE_STOPPING;
 801346c:	687b      	ldr	r3, [r7, #4]
 801346e:	22d2      	movs	r2, #210	@ 0xd2
 8013470:	615a      	str	r2, [r3, #20]
 8013472:	e019      	b.n	80134a8 <jpeg_finish_decompress+0x88>
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
 8013474:	687b      	ldr	r3, [r7, #4]
 8013476:	695b      	ldr	r3, [r3, #20]
 8013478:	2bcf      	cmp	r3, #207	@ 0xcf
 801347a:	d103      	bne.n	8013484 <jpeg_finish_decompress+0x64>
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
 801347c:	687b      	ldr	r3, [r7, #4]
 801347e:	22d2      	movs	r2, #210	@ 0xd2
 8013480:	615a      	str	r2, [r3, #20]
 8013482:	e01d      	b.n	80134c0 <jpeg_finish_decompress+0xa0>
  } else if (cinfo->global_state != DSTATE_STOPPING) {
 8013484:	687b      	ldr	r3, [r7, #4]
 8013486:	695b      	ldr	r3, [r3, #20]
 8013488:	2bd2      	cmp	r3, #210	@ 0xd2
 801348a:	d019      	beq.n	80134c0 <jpeg_finish_decompress+0xa0>
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 801348c:	687b      	ldr	r3, [r7, #4]
 801348e:	681b      	ldr	r3, [r3, #0]
 8013490:	2215      	movs	r2, #21
 8013492:	615a      	str	r2, [r3, #20]
 8013494:	687b      	ldr	r3, [r7, #4]
 8013496:	681b      	ldr	r3, [r3, #0]
 8013498:	687a      	ldr	r2, [r7, #4]
 801349a:	6952      	ldr	r2, [r2, #20]
 801349c:	619a      	str	r2, [r3, #24]
 801349e:	687b      	ldr	r3, [r7, #4]
 80134a0:	681b      	ldr	r3, [r3, #0]
 80134a2:	681b      	ldr	r3, [r3, #0]
 80134a4:	6878      	ldr	r0, [r7, #4]
 80134a6:	4798      	blx	r3
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
 80134a8:	e00a      	b.n	80134c0 <jpeg_finish_decompress+0xa0>
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
 80134aa:	687b      	ldr	r3, [r7, #4]
 80134ac:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80134b0:	681b      	ldr	r3, [r3, #0]
 80134b2:	6878      	ldr	r0, [r7, #4]
 80134b4:	4798      	blx	r3
 80134b6:	4603      	mov	r3, r0
 80134b8:	2b00      	cmp	r3, #0
 80134ba:	d101      	bne.n	80134c0 <jpeg_finish_decompress+0xa0>
      return FALSE;		/* Suspend, come back later */
 80134bc:	2300      	movs	r3, #0
 80134be:	e00e      	b.n	80134de <jpeg_finish_decompress+0xbe>
  while (! cinfo->inputctl->eoi_reached) {
 80134c0:	687b      	ldr	r3, [r7, #4]
 80134c2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80134c6:	695b      	ldr	r3, [r3, #20]
 80134c8:	2b00      	cmp	r3, #0
 80134ca:	d0ee      	beq.n	80134aa <jpeg_finish_decompress+0x8a>
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
 80134cc:	687b      	ldr	r3, [r7, #4]
 80134ce:	699b      	ldr	r3, [r3, #24]
 80134d0:	699b      	ldr	r3, [r3, #24]
 80134d2:	6878      	ldr	r0, [r7, #4]
 80134d4:	4798      	blx	r3
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
 80134d6:	6878      	ldr	r0, [r7, #4]
 80134d8:	f7ff fcd4 	bl	8012e84 <jpeg_abort>
  return TRUE;
 80134dc:	2301      	movs	r3, #1
}
 80134de:	4618      	mov	r0, r3
 80134e0:	3708      	adds	r7, #8
 80134e2:	46bd      	mov	sp, r7
 80134e4:	bd80      	pop	{r7, pc}

080134e6 <jpeg_start_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
 80134e6:	b580      	push	{r7, lr}
 80134e8:	b084      	sub	sp, #16
 80134ea:	af00      	add	r7, sp, #0
 80134ec:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state == DSTATE_READY) {
 80134ee:	687b      	ldr	r3, [r7, #4]
 80134f0:	695b      	ldr	r3, [r3, #20]
 80134f2:	2bca      	cmp	r3, #202	@ 0xca
 80134f4:	d10e      	bne.n	8013514 <jpeg_start_decompress+0x2e>
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
 80134f6:	6878      	ldr	r0, [r7, #4]
 80134f8:	f009 fff0 	bl	801d4dc <jinit_master_decompress>
    if (cinfo->buffered_image) {
 80134fc:	687b      	ldr	r3, [r7, #4]
 80134fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8013500:	2b00      	cmp	r3, #0
 8013502:	d004      	beq.n	801350e <jpeg_start_decompress+0x28>
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
 8013504:	687b      	ldr	r3, [r7, #4]
 8013506:	22cf      	movs	r2, #207	@ 0xcf
 8013508:	615a      	str	r2, [r3, #20]
      return TRUE;
 801350a:	2301      	movs	r3, #1
 801350c:	e063      	b.n	80135d6 <jpeg_start_decompress+0xf0>
    }
    cinfo->global_state = DSTATE_PRELOAD;
 801350e:	687b      	ldr	r3, [r7, #4]
 8013510:	22cb      	movs	r2, #203	@ 0xcb
 8013512:	615a      	str	r2, [r3, #20]
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
 8013514:	687b      	ldr	r3, [r7, #4]
 8013516:	695b      	ldr	r3, [r3, #20]
 8013518:	2bcb      	cmp	r3, #203	@ 0xcb
 801351a:	d146      	bne.n	80135aa <jpeg_start_decompress+0xc4>
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
 801351c:	687b      	ldr	r3, [r7, #4]
 801351e:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8013522:	691b      	ldr	r3, [r3, #16]
 8013524:	2b00      	cmp	r3, #0
 8013526:	d039      	beq.n	801359c <jpeg_start_decompress+0xb6>
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
 8013528:	687b      	ldr	r3, [r7, #4]
 801352a:	689b      	ldr	r3, [r3, #8]
 801352c:	2b00      	cmp	r3, #0
 801352e:	d004      	beq.n	801353a <jpeg_start_decompress+0x54>
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	689b      	ldr	r3, [r3, #8]
 8013534:	681b      	ldr	r3, [r3, #0]
 8013536:	6878      	ldr	r0, [r7, #4]
 8013538:	4798      	blx	r3
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
 801353a:	687b      	ldr	r3, [r7, #4]
 801353c:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8013540:	681b      	ldr	r3, [r3, #0]
 8013542:	6878      	ldr	r0, [r7, #4]
 8013544:	4798      	blx	r3
 8013546:	60f8      	str	r0, [r7, #12]
	if (retcode == JPEG_SUSPENDED)
 8013548:	68fb      	ldr	r3, [r7, #12]
 801354a:	2b00      	cmp	r3, #0
 801354c:	d101      	bne.n	8013552 <jpeg_start_decompress+0x6c>
	  return FALSE;
 801354e:	2300      	movs	r3, #0
 8013550:	e041      	b.n	80135d6 <jpeg_start_decompress+0xf0>
	if (retcode == JPEG_REACHED_EOI)
 8013552:	68fb      	ldr	r3, [r7, #12]
 8013554:	2b02      	cmp	r3, #2
 8013556:	d020      	beq.n	801359a <jpeg_start_decompress+0xb4>
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
 8013558:	687b      	ldr	r3, [r7, #4]
 801355a:	689b      	ldr	r3, [r3, #8]
 801355c:	2b00      	cmp	r3, #0
 801355e:	d0e3      	beq.n	8013528 <jpeg_start_decompress+0x42>
 8013560:	68fb      	ldr	r3, [r7, #12]
 8013562:	2b03      	cmp	r3, #3
 8013564:	d002      	beq.n	801356c <jpeg_start_decompress+0x86>
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
 8013566:	68fb      	ldr	r3, [r7, #12]
 8013568:	2b01      	cmp	r3, #1
 801356a:	d1dd      	bne.n	8013528 <jpeg_start_decompress+0x42>
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
 801356c:	687b      	ldr	r3, [r7, #4]
 801356e:	689b      	ldr	r3, [r3, #8]
 8013570:	685a      	ldr	r2, [r3, #4]
 8013572:	3201      	adds	r2, #1
 8013574:	605a      	str	r2, [r3, #4]
 8013576:	685a      	ldr	r2, [r3, #4]
 8013578:	687b      	ldr	r3, [r7, #4]
 801357a:	689b      	ldr	r3, [r3, #8]
 801357c:	689b      	ldr	r3, [r3, #8]
 801357e:	429a      	cmp	r2, r3
 8013580:	dbd2      	blt.n	8013528 <jpeg_start_decompress+0x42>
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
 8013582:	687b      	ldr	r3, [r7, #4]
 8013584:	689b      	ldr	r3, [r3, #8]
 8013586:	689a      	ldr	r2, [r3, #8]
 8013588:	687b      	ldr	r3, [r7, #4]
 801358a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801358e:	4619      	mov	r1, r3
 8013590:	687b      	ldr	r3, [r7, #4]
 8013592:	689b      	ldr	r3, [r3, #8]
 8013594:	440a      	add	r2, r1
 8013596:	609a      	str	r2, [r3, #8]
      for (;;) {
 8013598:	e7c6      	b.n	8013528 <jpeg_start_decompress+0x42>
	  break;
 801359a:	bf00      	nop
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
 801359c:	687b      	ldr	r3, [r7, #4]
 801359e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80135a2:	687b      	ldr	r3, [r7, #4]
 80135a4:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 80135a8:	e011      	b.n	80135ce <jpeg_start_decompress+0xe8>
  } else if (cinfo->global_state != DSTATE_PRESCAN)
 80135aa:	687b      	ldr	r3, [r7, #4]
 80135ac:	695b      	ldr	r3, [r3, #20]
 80135ae:	2bcc      	cmp	r3, #204	@ 0xcc
 80135b0:	d00d      	beq.n	80135ce <jpeg_start_decompress+0xe8>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80135b2:	687b      	ldr	r3, [r7, #4]
 80135b4:	681b      	ldr	r3, [r3, #0]
 80135b6:	2215      	movs	r2, #21
 80135b8:	615a      	str	r2, [r3, #20]
 80135ba:	687b      	ldr	r3, [r7, #4]
 80135bc:	681b      	ldr	r3, [r3, #0]
 80135be:	687a      	ldr	r2, [r7, #4]
 80135c0:	6952      	ldr	r2, [r2, #20]
 80135c2:	619a      	str	r2, [r3, #24]
 80135c4:	687b      	ldr	r3, [r7, #4]
 80135c6:	681b      	ldr	r3, [r3, #0]
 80135c8:	681b      	ldr	r3, [r3, #0]
 80135ca:	6878      	ldr	r0, [r7, #4]
 80135cc:	4798      	blx	r3
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
 80135ce:	6878      	ldr	r0, [r7, #4]
 80135d0:	f000 f805 	bl	80135de <output_pass_setup>
 80135d4:	4603      	mov	r3, r0
}
 80135d6:	4618      	mov	r0, r3
 80135d8:	3710      	adds	r7, #16
 80135da:	46bd      	mov	sp, r7
 80135dc:	bd80      	pop	{r7, pc}

080135de <output_pass_setup>:
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
 80135de:	b590      	push	{r4, r7, lr}
 80135e0:	b085      	sub	sp, #20
 80135e2:	af00      	add	r7, sp, #0
 80135e4:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state != DSTATE_PRESCAN) {
 80135e6:	687b      	ldr	r3, [r7, #4]
 80135e8:	695b      	ldr	r3, [r3, #20]
 80135ea:	2bcc      	cmp	r3, #204	@ 0xcc
 80135ec:	d04f      	beq.n	801368e <output_pass_setup+0xb0>
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 80135ee:	687b      	ldr	r3, [r7, #4]
 80135f0:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 80135f4:	681b      	ldr	r3, [r3, #0]
 80135f6:	6878      	ldr	r0, [r7, #4]
 80135f8:	4798      	blx	r3
    cinfo->output_scanline = 0;
 80135fa:	687b      	ldr	r3, [r7, #4]
 80135fc:	2200      	movs	r2, #0
 80135fe:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    cinfo->global_state = DSTATE_PRESCAN;
 8013602:	687b      	ldr	r3, [r7, #4]
 8013604:	22cc      	movs	r2, #204	@ 0xcc
 8013606:	615a      	str	r2, [r3, #20]
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
 8013608:	e041      	b.n	801368e <output_pass_setup+0xb0>
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
 801360a:	687b      	ldr	r3, [r7, #4]
 801360c:	689b      	ldr	r3, [r3, #8]
 801360e:	2b00      	cmp	r3, #0
 8013610:	d00f      	beq.n	8013632 <output_pass_setup+0x54>
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 8013612:	687b      	ldr	r3, [r7, #4]
 8013614:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8013618:	687b      	ldr	r3, [r7, #4]
 801361a:	689b      	ldr	r3, [r3, #8]
 801361c:	605a      	str	r2, [r3, #4]
	cinfo->progress->pass_limit = (long) cinfo->output_height;
 801361e:	687b      	ldr	r3, [r7, #4]
 8013620:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 8013622:	687b      	ldr	r3, [r7, #4]
 8013624:	689b      	ldr	r3, [r3, #8]
 8013626:	609a      	str	r2, [r3, #8]
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 8013628:	687b      	ldr	r3, [r7, #4]
 801362a:	689b      	ldr	r3, [r3, #8]
 801362c:	681b      	ldr	r3, [r3, #0]
 801362e:	6878      	ldr	r0, [r7, #4]
 8013630:	4798      	blx	r3
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
 8013632:	687b      	ldr	r3, [r7, #4]
 8013634:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8013638:	60fb      	str	r3, [r7, #12]
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
 801363a:	687b      	ldr	r3, [r7, #4]
 801363c:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8013640:	685c      	ldr	r4, [r3, #4]
 8013642:	687b      	ldr	r3, [r7, #4]
 8013644:	f103 028c 	add.w	r2, r3, #140	@ 0x8c
 8013648:	2300      	movs	r3, #0
 801364a:	2100      	movs	r1, #0
 801364c:	6878      	ldr	r0, [r7, #4]
 801364e:	47a0      	blx	r4
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
 8013650:	687b      	ldr	r3, [r7, #4]
 8013652:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8013656:	68fa      	ldr	r2, [r7, #12]
 8013658:	429a      	cmp	r2, r3
 801365a:	d101      	bne.n	8013660 <output_pass_setup+0x82>
	return FALSE;		/* No progress made, must suspend */
 801365c:	2300      	movs	r3, #0
 801365e:	e026      	b.n	80136ae <output_pass_setup+0xd0>
    while (cinfo->output_scanline < cinfo->output_height) {
 8013660:	687b      	ldr	r3, [r7, #4]
 8013662:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8013666:	687b      	ldr	r3, [r7, #4]
 8013668:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801366a:	429a      	cmp	r2, r3
 801366c:	d3cd      	bcc.n	801360a <output_pass_setup+0x2c>
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
 801366e:	687b      	ldr	r3, [r7, #4]
 8013670:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8013674:	685b      	ldr	r3, [r3, #4]
 8013676:	6878      	ldr	r0, [r7, #4]
 8013678:	4798      	blx	r3
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 801367a:	687b      	ldr	r3, [r7, #4]
 801367c:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8013680:	681b      	ldr	r3, [r3, #0]
 8013682:	6878      	ldr	r0, [r7, #4]
 8013684:	4798      	blx	r3
    cinfo->output_scanline = 0;
 8013686:	687b      	ldr	r3, [r7, #4]
 8013688:	2200      	movs	r2, #0
 801368a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  while (cinfo->master->is_dummy_pass) {
 801368e:	687b      	ldr	r3, [r7, #4]
 8013690:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 8013694:	689b      	ldr	r3, [r3, #8]
 8013696:	2b00      	cmp	r3, #0
 8013698:	d1e2      	bne.n	8013660 <output_pass_setup+0x82>
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
 801369a:	687b      	ldr	r3, [r7, #4]
 801369c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801369e:	2b00      	cmp	r3, #0
 80136a0:	d001      	beq.n	80136a6 <output_pass_setup+0xc8>
 80136a2:	22ce      	movs	r2, #206	@ 0xce
 80136a4:	e000      	b.n	80136a8 <output_pass_setup+0xca>
 80136a6:	22cd      	movs	r2, #205	@ 0xcd
 80136a8:	687b      	ldr	r3, [r7, #4]
 80136aa:	615a      	str	r2, [r3, #20]
  return TRUE;
 80136ac:	2301      	movs	r3, #1
}
 80136ae:	4618      	mov	r0, r3
 80136b0:	3714      	adds	r7, #20
 80136b2:	46bd      	mov	sp, r7
 80136b4:	bd90      	pop	{r4, r7, pc}

080136b6 <jpeg_read_scanlines>:
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
 80136b6:	b590      	push	{r4, r7, lr}
 80136b8:	b087      	sub	sp, #28
 80136ba:	af00      	add	r7, sp, #0
 80136bc:	60f8      	str	r0, [r7, #12]
 80136be:	60b9      	str	r1, [r7, #8]
 80136c0:	607a      	str	r2, [r7, #4]
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
 80136c2:	68fb      	ldr	r3, [r7, #12]
 80136c4:	695b      	ldr	r3, [r3, #20]
 80136c6:	2bcd      	cmp	r3, #205	@ 0xcd
 80136c8:	d00d      	beq.n	80136e6 <jpeg_read_scanlines+0x30>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 80136ca:	68fb      	ldr	r3, [r7, #12]
 80136cc:	681b      	ldr	r3, [r3, #0]
 80136ce:	2215      	movs	r2, #21
 80136d0:	615a      	str	r2, [r3, #20]
 80136d2:	68fb      	ldr	r3, [r7, #12]
 80136d4:	681b      	ldr	r3, [r3, #0]
 80136d6:	68fa      	ldr	r2, [r7, #12]
 80136d8:	6952      	ldr	r2, [r2, #20]
 80136da:	619a      	str	r2, [r3, #24]
 80136dc:	68fb      	ldr	r3, [r7, #12]
 80136de:	681b      	ldr	r3, [r3, #0]
 80136e0:	681b      	ldr	r3, [r3, #0]
 80136e2:	68f8      	ldr	r0, [r7, #12]
 80136e4:	4798      	blx	r3
  if (cinfo->output_scanline >= cinfo->output_height) {
 80136e6:	68fb      	ldr	r3, [r7, #12]
 80136e8:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 80136ec:	68fb      	ldr	r3, [r7, #12]
 80136ee:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80136f0:	429a      	cmp	r2, r3
 80136f2:	d30c      	bcc.n	801370e <jpeg_read_scanlines+0x58>
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
 80136f4:	68fb      	ldr	r3, [r7, #12]
 80136f6:	681b      	ldr	r3, [r3, #0]
 80136f8:	227e      	movs	r2, #126	@ 0x7e
 80136fa:	615a      	str	r2, [r3, #20]
 80136fc:	68fb      	ldr	r3, [r7, #12]
 80136fe:	681b      	ldr	r3, [r3, #0]
 8013700:	685b      	ldr	r3, [r3, #4]
 8013702:	f04f 31ff 	mov.w	r1, #4294967295
 8013706:	68f8      	ldr	r0, [r7, #12]
 8013708:	4798      	blx	r3
    return 0;
 801370a:	2300      	movs	r3, #0
 801370c:	e028      	b.n	8013760 <jpeg_read_scanlines+0xaa>
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
 801370e:	68fb      	ldr	r3, [r7, #12]
 8013710:	689b      	ldr	r3, [r3, #8]
 8013712:	2b00      	cmp	r3, #0
 8013714:	d00f      	beq.n	8013736 <jpeg_read_scanlines+0x80>
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 8013716:	68fb      	ldr	r3, [r7, #12]
 8013718:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 801371c:	68fb      	ldr	r3, [r7, #12]
 801371e:	689b      	ldr	r3, [r3, #8]
 8013720:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->output_height;
 8013722:	68fb      	ldr	r3, [r7, #12]
 8013724:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 8013726:	68fb      	ldr	r3, [r7, #12]
 8013728:	689b      	ldr	r3, [r3, #8]
 801372a:	609a      	str	r2, [r3, #8]
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 801372c:	68fb      	ldr	r3, [r7, #12]
 801372e:	689b      	ldr	r3, [r3, #8]
 8013730:	681b      	ldr	r3, [r3, #0]
 8013732:	68f8      	ldr	r0, [r7, #12]
 8013734:	4798      	blx	r3
  }

  /* Process some data */
  row_ctr = 0;
 8013736:	2300      	movs	r3, #0
 8013738:	617b      	str	r3, [r7, #20]
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
 801373a:	68fb      	ldr	r3, [r7, #12]
 801373c:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 8013740:	685c      	ldr	r4, [r3, #4]
 8013742:	f107 0214 	add.w	r2, r7, #20
 8013746:	687b      	ldr	r3, [r7, #4]
 8013748:	68b9      	ldr	r1, [r7, #8]
 801374a:	68f8      	ldr	r0, [r7, #12]
 801374c:	47a0      	blx	r4
  cinfo->output_scanline += row_ctr;
 801374e:	68fb      	ldr	r3, [r7, #12]
 8013750:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 8013754:	697b      	ldr	r3, [r7, #20]
 8013756:	441a      	add	r2, r3
 8013758:	68fb      	ldr	r3, [r7, #12]
 801375a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  return row_ctr;
 801375e:	697b      	ldr	r3, [r7, #20]
}
 8013760:	4618      	mov	r0, r3
 8013762:	371c      	adds	r7, #28
 8013764:	46bd      	mov	sp, r7
 8013766:	bd90      	pop	{r4, r7, pc}

08013768 <get_byte>:


LOCAL(int)
get_byte (j_decompress_ptr cinfo)
/* Read next input byte; we do not support suspension in this module. */
{
 8013768:	b580      	push	{r7, lr}
 801376a:	b084      	sub	sp, #16
 801376c:	af00      	add	r7, sp, #0
 801376e:	6078      	str	r0, [r7, #4]
  struct jpeg_source_mgr * src = cinfo->src;
 8013770:	687b      	ldr	r3, [r7, #4]
 8013772:	699b      	ldr	r3, [r3, #24]
 8013774:	60fb      	str	r3, [r7, #12]

  if (src->bytes_in_buffer == 0)
 8013776:	68fb      	ldr	r3, [r7, #12]
 8013778:	685b      	ldr	r3, [r3, #4]
 801377a:	2b00      	cmp	r3, #0
 801377c:	d10f      	bne.n	801379e <get_byte+0x36>
    if (! (*src->fill_input_buffer) (cinfo))
 801377e:	68fb      	ldr	r3, [r7, #12]
 8013780:	68db      	ldr	r3, [r3, #12]
 8013782:	6878      	ldr	r0, [r7, #4]
 8013784:	4798      	blx	r3
 8013786:	4603      	mov	r3, r0
 8013788:	2b00      	cmp	r3, #0
 801378a:	d108      	bne.n	801379e <get_byte+0x36>
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
 801378c:	687b      	ldr	r3, [r7, #4]
 801378e:	681b      	ldr	r3, [r3, #0]
 8013790:	2219      	movs	r2, #25
 8013792:	615a      	str	r2, [r3, #20]
 8013794:	687b      	ldr	r3, [r7, #4]
 8013796:	681b      	ldr	r3, [r3, #0]
 8013798:	681b      	ldr	r3, [r3, #0]
 801379a:	6878      	ldr	r0, [r7, #4]
 801379c:	4798      	blx	r3
  src->bytes_in_buffer--;
 801379e:	68fb      	ldr	r3, [r7, #12]
 80137a0:	685b      	ldr	r3, [r3, #4]
 80137a2:	1e5a      	subs	r2, r3, #1
 80137a4:	68fb      	ldr	r3, [r7, #12]
 80137a6:	605a      	str	r2, [r3, #4]
  return GETJOCTET(*src->next_input_byte++);
 80137a8:	68fb      	ldr	r3, [r7, #12]
 80137aa:	681b      	ldr	r3, [r3, #0]
 80137ac:	1c59      	adds	r1, r3, #1
 80137ae:	68fa      	ldr	r2, [r7, #12]
 80137b0:	6011      	str	r1, [r2, #0]
 80137b2:	781b      	ldrb	r3, [r3, #0]
}
 80137b4:	4618      	mov	r0, r3
 80137b6:	3710      	adds	r7, #16
 80137b8:	46bd      	mov	sp, r7
 80137ba:	bd80      	pop	{r7, pc}

080137bc <arith_decode>:
 * derived from Markus Kuhn's JBIG implementation.
 */

LOCAL(int)
arith_decode (j_decompress_ptr cinfo, unsigned char *st)
{
 80137bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80137c0:	b083      	sub	sp, #12
 80137c2:	af00      	add	r7, sp, #0
 80137c4:	6078      	str	r0, [r7, #4]
 80137c6:	6039      	str	r1, [r7, #0]
  register arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;
 80137c8:	687b      	ldr	r3, [r7, #4]
 80137ca:	f8d3 41d0 	ldr.w	r4, [r3, #464]	@ 0x1d0
  register unsigned char nl, nm;
  register INT32 qe, temp;
  register int sv, data;

  /* Renormalization & data input per section D.2.6 */
  while (e->a < 0x8000L) {
 80137ce:	e036      	b.n	801383e <arith_decode+0x82>
    if (--e->ct < 0) {
 80137d0:	6923      	ldr	r3, [r4, #16]
 80137d2:	3b01      	subs	r3, #1
 80137d4:	6123      	str	r3, [r4, #16]
 80137d6:	6923      	ldr	r3, [r4, #16]
 80137d8:	2b00      	cmp	r3, #0
 80137da:	da2d      	bge.n	8013838 <arith_decode+0x7c>
      /* Need to fetch next data byte */
      if (cinfo->unread_marker)
 80137dc:	687b      	ldr	r3, [r7, #4]
 80137de:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 80137e2:	2b00      	cmp	r3, #0
 80137e4:	d001      	beq.n	80137ea <arith_decode+0x2e>
	data = 0;		/* stuff zero data */
 80137e6:	2500      	movs	r5, #0
 80137e8:	e013      	b.n	8013812 <arith_decode+0x56>
      else {
	data = get_byte(cinfo);	/* read next input byte */
 80137ea:	6878      	ldr	r0, [r7, #4]
 80137ec:	f7ff ffbc 	bl	8013768 <get_byte>
 80137f0:	4605      	mov	r5, r0
	if (data == 0xFF) {	/* zero stuff or marker code */
 80137f2:	2dff      	cmp	r5, #255	@ 0xff
 80137f4:	d10d      	bne.n	8013812 <arith_decode+0x56>
	  do data = get_byte(cinfo);
 80137f6:	6878      	ldr	r0, [r7, #4]
 80137f8:	f7ff ffb6 	bl	8013768 <get_byte>
 80137fc:	4605      	mov	r5, r0
	  while (data == 0xFF);	/* swallow extra 0xFF bytes */
 80137fe:	2dff      	cmp	r5, #255	@ 0xff
 8013800:	d0f9      	beq.n	80137f6 <arith_decode+0x3a>
	  if (data == 0)
 8013802:	2d00      	cmp	r5, #0
 8013804:	d101      	bne.n	801380a <arith_decode+0x4e>
	    data = 0xFF;	/* discard stuffed zero byte */
 8013806:	25ff      	movs	r5, #255	@ 0xff
 8013808:	e003      	b.n	8013812 <arith_decode+0x56>
	     * a marker while processing the compressed data
	     * segment is legal in arithmetic coding.
	     * The convention is to supply zero data
	     * then until decoding is complete.
	     */
	    cinfo->unread_marker = data;
 801380a:	687b      	ldr	r3, [r7, #4]
 801380c:	f8c3 51b4 	str.w	r5, [r3, #436]	@ 0x1b4
	    data = 0;
 8013810:	2500      	movs	r5, #0
	  }
	}
      }
      e->c = (e->c << 8) | data; /* insert data into C register */
 8013812:	68a3      	ldr	r3, [r4, #8]
 8013814:	021b      	lsls	r3, r3, #8
 8013816:	432b      	orrs	r3, r5
 8013818:	60a3      	str	r3, [r4, #8]
      if ((e->ct += 8) < 0)	 /* update bit shift counter */
 801381a:	6923      	ldr	r3, [r4, #16]
 801381c:	3308      	adds	r3, #8
 801381e:	6123      	str	r3, [r4, #16]
 8013820:	6923      	ldr	r3, [r4, #16]
 8013822:	2b00      	cmp	r3, #0
 8013824:	da08      	bge.n	8013838 <arith_decode+0x7c>
	/* Need more initial bytes */
	if (++e->ct == 0)
 8013826:	6923      	ldr	r3, [r4, #16]
 8013828:	3301      	adds	r3, #1
 801382a:	6123      	str	r3, [r4, #16]
 801382c:	6923      	ldr	r3, [r4, #16]
 801382e:	2b00      	cmp	r3, #0
 8013830:	d102      	bne.n	8013838 <arith_decode+0x7c>
	  /* Got 2 initial bytes -> re-init A and exit loop */
	  e->a = 0x8000L; /* => e->a = 0x10000L after loop exit */
 8013832:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8013836:	60e3      	str	r3, [r4, #12]
    }
    e->a <<= 1;
 8013838:	68e3      	ldr	r3, [r4, #12]
 801383a:	005b      	lsls	r3, r3, #1
 801383c:	60e3      	str	r3, [r4, #12]
  while (e->a < 0x8000L) {
 801383e:	68e3      	ldr	r3, [r4, #12]
 8013840:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8013844:	dbc4      	blt.n	80137d0 <arith_decode+0x14>
  }

  /* Fetch values from our compact representation of Table D.3(D.2):
   * Qe values and probability estimation state machine
   */
  sv = *st;
 8013846:	683b      	ldr	r3, [r7, #0]
 8013848:	781b      	ldrb	r3, [r3, #0]
 801384a:	461e      	mov	r6, r3
  qe = jpeg_aritab[sv & 0x7F];	/* => Qe_Value */
 801384c:	f006 037f 	and.w	r3, r6, #127	@ 0x7f
 8013850:	4a2c      	ldr	r2, [pc, #176]	@ (8013904 <arith_decode+0x148>)
 8013852:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
  nl = qe & 0xFF; qe >>= 8;	/* Next_Index_LPS + Switch_MPS */
 8013856:	fa5f f985 	uxtb.w	r9, r5
 801385a:	122d      	asrs	r5, r5, #8
  nm = qe & 0xFF; qe >>= 8;	/* Next_Index_MPS */
 801385c:	fa5f f885 	uxtb.w	r8, r5
 8013860:	122d      	asrs	r5, r5, #8

  /* Decode & estimation procedures per sections D.2.4 & D.2.5 */
  temp = e->a - qe;
 8013862:	68e3      	ldr	r3, [r4, #12]
 8013864:	1b5a      	subs	r2, r3, r5
  e->a = temp;
 8013866:	60e2      	str	r2, [r4, #12]
  temp <<= e->ct;
 8013868:	6923      	ldr	r3, [r4, #16]
 801386a:	409a      	lsls	r2, r3
  if (e->c >= temp) {
 801386c:	68a3      	ldr	r3, [r4, #8]
 801386e:	429a      	cmp	r2, r3
 8013870:	dc21      	bgt.n	80138b6 <arith_decode+0xfa>
    e->c -= temp;
 8013872:	68a3      	ldr	r3, [r4, #8]
 8013874:	1a9b      	subs	r3, r3, r2
 8013876:	60a3      	str	r3, [r4, #8]
    /* Conditional LPS (less probable symbol) exchange */
    if (e->a < qe) {
 8013878:	68e3      	ldr	r3, [r4, #12]
 801387a:	429d      	cmp	r5, r3
 801387c:	dd0c      	ble.n	8013898 <arith_decode+0xdc>
      e->a = qe;
 801387e:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 8013880:	b273      	sxtb	r3, r6
 8013882:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8013886:	b25a      	sxtb	r2, r3
 8013888:	fa4f f388 	sxtb.w	r3, r8
 801388c:	4053      	eors	r3, r2
 801388e:	b25b      	sxtb	r3, r3
 8013890:	b2da      	uxtb	r2, r3
 8013892:	683b      	ldr	r3, [r7, #0]
 8013894:	701a      	strb	r2, [r3, #0]
 8013896:	e02e      	b.n	80138f6 <arith_decode+0x13a>
    } else {
      e->a = qe;
 8013898:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 801389a:	b273      	sxtb	r3, r6
 801389c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80138a0:	b25a      	sxtb	r2, r3
 80138a2:	fa4f f389 	sxtb.w	r3, r9
 80138a6:	4053      	eors	r3, r2
 80138a8:	b25b      	sxtb	r3, r3
 80138aa:	b2da      	uxtb	r2, r3
 80138ac:	683b      	ldr	r3, [r7, #0]
 80138ae:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 80138b0:	f086 0680 	eor.w	r6, r6, #128	@ 0x80
 80138b4:	e01f      	b.n	80138f6 <arith_decode+0x13a>
    }
  } else if (e->a < 0x8000L) {
 80138b6:	68e3      	ldr	r3, [r4, #12]
 80138b8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80138bc:	da1b      	bge.n	80138f6 <arith_decode+0x13a>
    /* Conditional MPS (more probable symbol) exchange */
    if (e->a < qe) {
 80138be:	68e3      	ldr	r3, [r4, #12]
 80138c0:	429d      	cmp	r5, r3
 80138c2:	dd0d      	ble.n	80138e0 <arith_decode+0x124>
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 80138c4:	b273      	sxtb	r3, r6
 80138c6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80138ca:	b25a      	sxtb	r2, r3
 80138cc:	fa4f f389 	sxtb.w	r3, r9
 80138d0:	4053      	eors	r3, r2
 80138d2:	b25b      	sxtb	r3, r3
 80138d4:	b2da      	uxtb	r2, r3
 80138d6:	683b      	ldr	r3, [r7, #0]
 80138d8:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 80138da:	f086 0680 	eor.w	r6, r6, #128	@ 0x80
 80138de:	e00a      	b.n	80138f6 <arith_decode+0x13a>
    } else {
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 80138e0:	b273      	sxtb	r3, r6
 80138e2:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80138e6:	b25a      	sxtb	r2, r3
 80138e8:	fa4f f388 	sxtb.w	r3, r8
 80138ec:	4053      	eors	r3, r2
 80138ee:	b25b      	sxtb	r3, r3
 80138f0:	b2da      	uxtb	r2, r3
 80138f2:	683b      	ldr	r3, [r7, #0]
 80138f4:	701a      	strb	r2, [r3, #0]
    }
  }

  return sv >> 7;
 80138f6:	11f3      	asrs	r3, r6, #7
}
 80138f8:	4618      	mov	r0, r3
 80138fa:	370c      	adds	r7, #12
 80138fc:	46bd      	mov	sp, r7
 80138fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8013902:	bf00      	nop
 8013904:	08031e38 	.word	0x08031e38

08013908 <process_restart>:
 * Check for a restart marker & resynchronize decoder.
 */

LOCAL(void)
process_restart (j_decompress_ptr cinfo)
{
 8013908:	b580      	push	{r7, lr}
 801390a:	b086      	sub	sp, #24
 801390c:	af00      	add	r7, sp, #0
 801390e:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8013910:	687b      	ldr	r3, [r7, #4]
 8013912:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8013916:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 8013918:	687b      	ldr	r3, [r7, #4]
 801391a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801391e:	689b      	ldr	r3, [r3, #8]
 8013920:	6878      	ldr	r0, [r7, #4]
 8013922:	4798      	blx	r3
 8013924:	4603      	mov	r3, r0
 8013926:	2b00      	cmp	r3, #0
 8013928:	d108      	bne.n	801393c <process_restart+0x34>
    ERREXIT(cinfo, JERR_CANT_SUSPEND);
 801392a:	687b      	ldr	r3, [r7, #4]
 801392c:	681b      	ldr	r3, [r3, #0]
 801392e:	2219      	movs	r2, #25
 8013930:	615a      	str	r2, [r3, #20]
 8013932:	687b      	ldr	r3, [r7, #4]
 8013934:	681b      	ldr	r3, [r3, #0]
 8013936:	681b      	ldr	r3, [r3, #0]
 8013938:	6878      	ldr	r0, [r7, #4]
 801393a:	4798      	blx	r3

  /* Re-initialize statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801393c:	2300      	movs	r3, #0
 801393e:	617b      	str	r3, [r7, #20]
 8013940:	e051      	b.n	80139e6 <process_restart+0xde>
    compptr = cinfo->cur_comp_info[ci];
 8013942:	687a      	ldr	r2, [r7, #4]
 8013944:	697b      	ldr	r3, [r7, #20]
 8013946:	3354      	adds	r3, #84	@ 0x54
 8013948:	009b      	lsls	r3, r3, #2
 801394a:	4413      	add	r3, r2
 801394c:	685b      	ldr	r3, [r3, #4]
 801394e:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 8013950:	687b      	ldr	r3, [r7, #4]
 8013952:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013956:	2b00      	cmp	r3, #0
 8013958:	d009      	beq.n	801396e <process_restart+0x66>
 801395a:	687b      	ldr	r3, [r7, #4]
 801395c:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8013960:	2b00      	cmp	r3, #0
 8013962:	d11d      	bne.n	80139a0 <process_restart+0x98>
 8013964:	687b      	ldr	r3, [r7, #4]
 8013966:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801396a:	2b00      	cmp	r3, #0
 801396c:	d118      	bne.n	80139a0 <process_restart+0x98>
      MEMZERO(entropy->dc_stats[compptr->dc_tbl_no], DC_STAT_BINS);
 801396e:	68fb      	ldr	r3, [r7, #12]
 8013970:	695a      	ldr	r2, [r3, #20]
 8013972:	693b      	ldr	r3, [r7, #16]
 8013974:	320e      	adds	r2, #14
 8013976:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801397a:	2240      	movs	r2, #64	@ 0x40
 801397c:	2100      	movs	r1, #0
 801397e:	4618      	mov	r0, r3
 8013980:	f01c f80e 	bl	802f9a0 <memset>
      /* Reset DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 8013984:	693a      	ldr	r2, [r7, #16]
 8013986:	697b      	ldr	r3, [r7, #20]
 8013988:	3304      	adds	r3, #4
 801398a:	009b      	lsls	r3, r3, #2
 801398c:	4413      	add	r3, r2
 801398e:	2200      	movs	r2, #0
 8013990:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 8013992:	693a      	ldr	r2, [r7, #16]
 8013994:	697b      	ldr	r3, [r7, #20]
 8013996:	3308      	adds	r3, #8
 8013998:	009b      	lsls	r3, r3, #2
 801399a:	4413      	add	r3, r2
 801399c:	2200      	movs	r2, #0
 801399e:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 80139a0:	687b      	ldr	r3, [r7, #4]
 80139a2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80139a6:	2b00      	cmp	r3, #0
 80139a8:	d104      	bne.n	80139b4 <process_restart+0xac>
 80139aa:	687b      	ldr	r3, [r7, #4]
 80139ac:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80139b0:	2b00      	cmp	r3, #0
 80139b2:	d109      	bne.n	80139c8 <process_restart+0xc0>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80139b4:	687b      	ldr	r3, [r7, #4]
 80139b6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 80139ba:	2b00      	cmp	r3, #0
 80139bc:	d010      	beq.n	80139e0 <process_restart+0xd8>
	(cinfo->progressive_mode && cinfo->Ss)) {
 80139be:	687b      	ldr	r3, [r7, #4]
 80139c0:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80139c4:	2b00      	cmp	r3, #0
 80139c6:	d00b      	beq.n	80139e0 <process_restart+0xd8>
      MEMZERO(entropy->ac_stats[compptr->ac_tbl_no], AC_STAT_BINS);
 80139c8:	68fb      	ldr	r3, [r7, #12]
 80139ca:	699a      	ldr	r2, [r3, #24]
 80139cc:	693b      	ldr	r3, [r7, #16]
 80139ce:	321e      	adds	r2, #30
 80139d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80139d4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80139d8:	2100      	movs	r1, #0
 80139da:	4618      	mov	r0, r3
 80139dc:	f01b ffe0 	bl	802f9a0 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80139e0:	697b      	ldr	r3, [r7, #20]
 80139e2:	3301      	adds	r3, #1
 80139e4:	617b      	str	r3, [r7, #20]
 80139e6:	687b      	ldr	r3, [r7, #4]
 80139e8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80139ec:	697a      	ldr	r2, [r7, #20]
 80139ee:	429a      	cmp	r2, r3
 80139f0:	dba7      	blt.n	8013942 <process_restart+0x3a>
    }
  }

  /* Reset arithmetic decoding variables */
  entropy->c = 0;
 80139f2:	693b      	ldr	r3, [r7, #16]
 80139f4:	2200      	movs	r2, #0
 80139f6:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 80139f8:	693b      	ldr	r3, [r7, #16]
 80139fa:	2200      	movs	r2, #0
 80139fc:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 80139fe:	693b      	ldr	r3, [r7, #16]
 8013a00:	f06f 020f 	mvn.w	r2, #15
 8013a04:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8013a06:	687b      	ldr	r3, [r7, #4]
 8013a08:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8013a0c:	693b      	ldr	r3, [r7, #16]
 8013a0e:	635a      	str	r2, [r3, #52]	@ 0x34
}
 8013a10:	bf00      	nop
 8013a12:	3718      	adds	r7, #24
 8013a14:	46bd      	mov	sp, r7
 8013a16:	bd80      	pop	{r7, pc}

08013a18 <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8013a18:	b580      	push	{r7, lr}
 8013a1a:	b08c      	sub	sp, #48	@ 0x30
 8013a1c:	af00      	add	r7, sp, #0
 8013a1e:	6078      	str	r0, [r7, #4]
 8013a20:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8013a22:	687b      	ldr	r3, [r7, #4]
 8013a24:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8013a28:	61fb      	str	r3, [r7, #28]
  unsigned char *st;
  int blkn, ci, tbl, sign;
  int v, m;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8013a2a:	687b      	ldr	r3, [r7, #4]
 8013a2c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8013a30:	2b00      	cmp	r3, #0
 8013a32:	d00b      	beq.n	8013a4c <decode_mcu_DC_first+0x34>
    if (entropy->restarts_to_go == 0)
 8013a34:	69fb      	ldr	r3, [r7, #28]
 8013a36:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013a38:	2b00      	cmp	r3, #0
 8013a3a:	d102      	bne.n	8013a42 <decode_mcu_DC_first+0x2a>
      process_restart(cinfo);
 8013a3c:	6878      	ldr	r0, [r7, #4]
 8013a3e:	f7ff ff63 	bl	8013908 <process_restart>
    entropy->restarts_to_go--;
 8013a42:	69fb      	ldr	r3, [r7, #28]
 8013a44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013a46:	1e5a      	subs	r2, r3, #1
 8013a48:	69fb      	ldr	r3, [r7, #28]
 8013a4a:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8013a4c:	69fb      	ldr	r3, [r7, #28]
 8013a4e:	691b      	ldr	r3, [r3, #16]
 8013a50:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013a54:	d101      	bne.n	8013a5a <decode_mcu_DC_first+0x42>
 8013a56:	2301      	movs	r3, #1
 8013a58:	e0ec      	b.n	8013c34 <decode_mcu_DC_first+0x21c>

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8013a5a:	2300      	movs	r3, #0
 8013a5c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013a5e:	e0e1      	b.n	8013c24 <decode_mcu_DC_first+0x20c>
    block = MCU_data[blkn];
 8013a60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013a62:	009b      	lsls	r3, r3, #2
 8013a64:	683a      	ldr	r2, [r7, #0]
 8013a66:	4413      	add	r3, r2
 8013a68:	681b      	ldr	r3, [r3, #0]
 8013a6a:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 8013a6c:	687b      	ldr	r3, [r7, #4]
 8013a6e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013a70:	325c      	adds	r2, #92	@ 0x5c
 8013a72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013a76:	617b      	str	r3, [r7, #20]
    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;
 8013a78:	687a      	ldr	r2, [r7, #4]
 8013a7a:	697b      	ldr	r3, [r7, #20]
 8013a7c:	3354      	adds	r3, #84	@ 0x54
 8013a7e:	009b      	lsls	r3, r3, #2
 8013a80:	4413      	add	r3, r2
 8013a82:	685b      	ldr	r3, [r3, #4]
 8013a84:	695b      	ldr	r3, [r3, #20]
 8013a86:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 8013a88:	69fb      	ldr	r3, [r7, #28]
 8013a8a:	693a      	ldr	r2, [r7, #16]
 8013a8c:	320e      	adds	r2, #14
 8013a8e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8013a92:	69f9      	ldr	r1, [r7, #28]
 8013a94:	697b      	ldr	r3, [r7, #20]
 8013a96:	3308      	adds	r3, #8
 8013a98:	009b      	lsls	r3, r3, #2
 8013a9a:	440b      	add	r3, r1
 8013a9c:	685b      	ldr	r3, [r3, #4]
 8013a9e:	4413      	add	r3, r2
 8013aa0:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 8013aa2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013aa4:	6878      	ldr	r0, [r7, #4]
 8013aa6:	f7ff fe89 	bl	80137bc <arith_decode>
 8013aaa:	4603      	mov	r3, r0
 8013aac:	2b00      	cmp	r3, #0
 8013aae:	d107      	bne.n	8013ac0 <decode_mcu_DC_first+0xa8>
      entropy->dc_context[ci] = 0;
 8013ab0:	69fa      	ldr	r2, [r7, #28]
 8013ab2:	697b      	ldr	r3, [r7, #20]
 8013ab4:	3308      	adds	r3, #8
 8013ab6:	009b      	lsls	r3, r3, #2
 8013ab8:	4413      	add	r3, r2
 8013aba:	2200      	movs	r2, #0
 8013abc:	605a      	str	r2, [r3, #4]
 8013abe:	e0a0      	b.n	8013c02 <decode_mcu_DC_first+0x1ea>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 8013ac0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013ac2:	3301      	adds	r3, #1
 8013ac4:	4619      	mov	r1, r3
 8013ac6:	6878      	ldr	r0, [r7, #4]
 8013ac8:	f7ff fe78 	bl	80137bc <arith_decode>
 8013acc:	60f8      	str	r0, [r7, #12]
      st += 2; st += sign;
 8013ace:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013ad0:	3302      	adds	r3, #2
 8013ad2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8013ad4:	68fb      	ldr	r3, [r7, #12]
 8013ad6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013ad8:	4413      	add	r3, r2
 8013ada:	62fb      	str	r3, [r7, #44]	@ 0x2c
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8013adc:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013ade:	6878      	ldr	r0, [r7, #4]
 8013ae0:	f7ff fe6c 	bl	80137bc <arith_decode>
 8013ae4:	6238      	str	r0, [r7, #32]
 8013ae6:	6a3b      	ldr	r3, [r7, #32]
 8013ae8:	2b00      	cmp	r3, #0
 8013aea:	d029      	beq.n	8013b40 <decode_mcu_DC_first+0x128>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 8013aec:	69fb      	ldr	r3, [r7, #28]
 8013aee:	693a      	ldr	r2, [r7, #16]
 8013af0:	320e      	adds	r2, #14
 8013af2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013af6:	3314      	adds	r3, #20
 8013af8:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 8013afa:	e01a      	b.n	8013b32 <decode_mcu_DC_first+0x11a>
	  if ((m <<= 1) == 0x8000) {
 8013afc:	6a3b      	ldr	r3, [r7, #32]
 8013afe:	005b      	lsls	r3, r3, #1
 8013b00:	623b      	str	r3, [r7, #32]
 8013b02:	6a3b      	ldr	r3, [r7, #32]
 8013b04:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8013b08:	d110      	bne.n	8013b2c <decode_mcu_DC_first+0x114>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8013b0a:	687b      	ldr	r3, [r7, #4]
 8013b0c:	681b      	ldr	r3, [r3, #0]
 8013b0e:	2275      	movs	r2, #117	@ 0x75
 8013b10:	615a      	str	r2, [r3, #20]
 8013b12:	687b      	ldr	r3, [r7, #4]
 8013b14:	681b      	ldr	r3, [r3, #0]
 8013b16:	685b      	ldr	r3, [r3, #4]
 8013b18:	f04f 31ff 	mov.w	r1, #4294967295
 8013b1c:	6878      	ldr	r0, [r7, #4]
 8013b1e:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 8013b20:	69fb      	ldr	r3, [r7, #28]
 8013b22:	f04f 32ff 	mov.w	r2, #4294967295
 8013b26:	611a      	str	r2, [r3, #16]
	    return TRUE;
 8013b28:	2301      	movs	r3, #1
 8013b2a:	e083      	b.n	8013c34 <decode_mcu_DC_first+0x21c>
	  }
	  st += 1;
 8013b2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013b2e:	3301      	adds	r3, #1
 8013b30:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 8013b32:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013b34:	6878      	ldr	r0, [r7, #4]
 8013b36:	f7ff fe41 	bl	80137bc <arith_decode>
 8013b3a:	4603      	mov	r3, r0
 8013b3c:	2b00      	cmp	r3, #0
 8013b3e:	d1dd      	bne.n	8013afc <decode_mcu_DC_first+0xe4>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 8013b40:	687a      	ldr	r2, [r7, #4]
 8013b42:	693b      	ldr	r3, [r7, #16]
 8013b44:	4413      	add	r3, r2
 8013b46:	33e8      	adds	r3, #232	@ 0xe8
 8013b48:	781b      	ldrb	r3, [r3, #0]
 8013b4a:	461a      	mov	r2, r3
 8013b4c:	2301      	movs	r3, #1
 8013b4e:	4093      	lsls	r3, r2
 8013b50:	105b      	asrs	r3, r3, #1
 8013b52:	6a3a      	ldr	r2, [r7, #32]
 8013b54:	429a      	cmp	r2, r3
 8013b56:	da07      	bge.n	8013b68 <decode_mcu_DC_first+0x150>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 8013b58:	69fa      	ldr	r2, [r7, #28]
 8013b5a:	697b      	ldr	r3, [r7, #20]
 8013b5c:	3308      	adds	r3, #8
 8013b5e:	009b      	lsls	r3, r3, #2
 8013b60:	4413      	add	r3, r2
 8013b62:	2200      	movs	r2, #0
 8013b64:	605a      	str	r2, [r3, #4]
 8013b66:	e01e      	b.n	8013ba6 <decode_mcu_DC_first+0x18e>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 8013b68:	687a      	ldr	r2, [r7, #4]
 8013b6a:	693b      	ldr	r3, [r7, #16]
 8013b6c:	4413      	add	r3, r2
 8013b6e:	33f8      	adds	r3, #248	@ 0xf8
 8013b70:	781b      	ldrb	r3, [r3, #0]
 8013b72:	461a      	mov	r2, r3
 8013b74:	2301      	movs	r3, #1
 8013b76:	4093      	lsls	r3, r2
 8013b78:	105b      	asrs	r3, r3, #1
 8013b7a:	6a3a      	ldr	r2, [r7, #32]
 8013b7c:	429a      	cmp	r2, r3
 8013b7e:	dd09      	ble.n	8013b94 <decode_mcu_DC_first+0x17c>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 8013b80:	68fb      	ldr	r3, [r7, #12]
 8013b82:	3303      	adds	r3, #3
 8013b84:	009a      	lsls	r2, r3, #2
 8013b86:	69f9      	ldr	r1, [r7, #28]
 8013b88:	697b      	ldr	r3, [r7, #20]
 8013b8a:	3308      	adds	r3, #8
 8013b8c:	009b      	lsls	r3, r3, #2
 8013b8e:	440b      	add	r3, r1
 8013b90:	605a      	str	r2, [r3, #4]
 8013b92:	e008      	b.n	8013ba6 <decode_mcu_DC_first+0x18e>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 8013b94:	68fb      	ldr	r3, [r7, #12]
 8013b96:	3301      	adds	r3, #1
 8013b98:	009a      	lsls	r2, r3, #2
 8013b9a:	69f9      	ldr	r1, [r7, #28]
 8013b9c:	697b      	ldr	r3, [r7, #20]
 8013b9e:	3308      	adds	r3, #8
 8013ba0:	009b      	lsls	r3, r3, #2
 8013ba2:	440b      	add	r3, r1
 8013ba4:	605a      	str	r2, [r3, #4]
      v = m;
 8013ba6:	6a3b      	ldr	r3, [r7, #32]
 8013ba8:	627b      	str	r3, [r7, #36]	@ 0x24
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 8013baa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013bac:	330e      	adds	r3, #14
 8013bae:	62fb      	str	r3, [r7, #44]	@ 0x2c
      while (m >>= 1)
 8013bb0:	e00a      	b.n	8013bc8 <decode_mcu_DC_first+0x1b0>
	if (arith_decode(cinfo, st)) v |= m;
 8013bb2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013bb4:	6878      	ldr	r0, [r7, #4]
 8013bb6:	f7ff fe01 	bl	80137bc <arith_decode>
 8013bba:	4603      	mov	r3, r0
 8013bbc:	2b00      	cmp	r3, #0
 8013bbe:	d003      	beq.n	8013bc8 <decode_mcu_DC_first+0x1b0>
 8013bc0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013bc2:	6a3b      	ldr	r3, [r7, #32]
 8013bc4:	4313      	orrs	r3, r2
 8013bc6:	627b      	str	r3, [r7, #36]	@ 0x24
      while (m >>= 1)
 8013bc8:	6a3b      	ldr	r3, [r7, #32]
 8013bca:	105b      	asrs	r3, r3, #1
 8013bcc:	623b      	str	r3, [r7, #32]
 8013bce:	6a3b      	ldr	r3, [r7, #32]
 8013bd0:	2b00      	cmp	r3, #0
 8013bd2:	d1ee      	bne.n	8013bb2 <decode_mcu_DC_first+0x19a>
      v += 1; if (sign) v = -v;
 8013bd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013bd6:	3301      	adds	r3, #1
 8013bd8:	627b      	str	r3, [r7, #36]	@ 0x24
 8013bda:	68fb      	ldr	r3, [r7, #12]
 8013bdc:	2b00      	cmp	r3, #0
 8013bde:	d002      	beq.n	8013be6 <decode_mcu_DC_first+0x1ce>
 8013be0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013be2:	425b      	negs	r3, r3
 8013be4:	627b      	str	r3, [r7, #36]	@ 0x24
      entropy->last_dc_val[ci] += v;
 8013be6:	69fa      	ldr	r2, [r7, #28]
 8013be8:	697b      	ldr	r3, [r7, #20]
 8013bea:	3304      	adds	r3, #4
 8013bec:	009b      	lsls	r3, r3, #2
 8013bee:	4413      	add	r3, r2
 8013bf0:	685a      	ldr	r2, [r3, #4]
 8013bf2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013bf4:	441a      	add	r2, r3
 8013bf6:	69f9      	ldr	r1, [r7, #28]
 8013bf8:	697b      	ldr	r3, [r7, #20]
 8013bfa:	3304      	adds	r3, #4
 8013bfc:	009b      	lsls	r3, r3, #2
 8013bfe:	440b      	add	r3, r1
 8013c00:	605a      	str	r2, [r3, #4]
    }

    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
    (*block)[0] = (JCOEF) (entropy->last_dc_val[ci] << cinfo->Al);
 8013c02:	69fa      	ldr	r2, [r7, #28]
 8013c04:	697b      	ldr	r3, [r7, #20]
 8013c06:	3304      	adds	r3, #4
 8013c08:	009b      	lsls	r3, r3, #2
 8013c0a:	4413      	add	r3, r2
 8013c0c:	685a      	ldr	r2, [r3, #4]
 8013c0e:	687b      	ldr	r3, [r7, #4]
 8013c10:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8013c14:	fa02 f303 	lsl.w	r3, r2, r3
 8013c18:	b21a      	sxth	r2, r3
 8013c1a:	69bb      	ldr	r3, [r7, #24]
 8013c1c:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8013c1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013c20:	3301      	adds	r3, #1
 8013c22:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013c24:	687b      	ldr	r3, [r7, #4]
 8013c26:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8013c2a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013c2c:	429a      	cmp	r2, r3
 8013c2e:	f6ff af17 	blt.w	8013a60 <decode_mcu_DC_first+0x48>
  }

  return TRUE;
 8013c32:	2301      	movs	r3, #1
}
 8013c34:	4618      	mov	r0, r3
 8013c36:	3730      	adds	r7, #48	@ 0x30
 8013c38:	46bd      	mov	sp, r7
 8013c3a:	bd80      	pop	{r7, pc}

08013c3c <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8013c3c:	b580      	push	{r7, lr}
 8013c3e:	b08c      	sub	sp, #48	@ 0x30
 8013c40:	af00      	add	r7, sp, #0
 8013c42:	6078      	str	r0, [r7, #4]
 8013c44:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8013c46:	687b      	ldr	r3, [r7, #4]
 8013c48:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8013c4c:	61fb      	str	r3, [r7, #28]
  int tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8013c4e:	687b      	ldr	r3, [r7, #4]
 8013c50:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8013c54:	2b00      	cmp	r3, #0
 8013c56:	d00b      	beq.n	8013c70 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 8013c58:	69fb      	ldr	r3, [r7, #28]
 8013c5a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013c5c:	2b00      	cmp	r3, #0
 8013c5e:	d102      	bne.n	8013c66 <decode_mcu_AC_first+0x2a>
      process_restart(cinfo);
 8013c60:	6878      	ldr	r0, [r7, #4]
 8013c62:	f7ff fe51 	bl	8013908 <process_restart>
    entropy->restarts_to_go--;
 8013c66:	69fb      	ldr	r3, [r7, #28]
 8013c68:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013c6a:	1e5a      	subs	r2, r3, #1
 8013c6c:	69fb      	ldr	r3, [r7, #28]
 8013c6e:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8013c70:	69fb      	ldr	r3, [r7, #28]
 8013c72:	691b      	ldr	r3, [r3, #16]
 8013c74:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013c78:	d101      	bne.n	8013c7e <decode_mcu_AC_first+0x42>
 8013c7a:	2301      	movs	r3, #1
 8013c7c:	e0da      	b.n	8013e34 <decode_mcu_AC_first+0x1f8>

  natural_order = cinfo->natural_order;
 8013c7e:	687b      	ldr	r3, [r7, #4]
 8013c80:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8013c84:	61bb      	str	r3, [r7, #24]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 8013c86:	683b      	ldr	r3, [r7, #0]
 8013c88:	681b      	ldr	r3, [r3, #0]
 8013c8a:	617b      	str	r3, [r7, #20]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 8013c8c:	687b      	ldr	r3, [r7, #4]
 8013c8e:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8013c92:	699b      	ldr	r3, [r3, #24]
 8013c94:	613b      	str	r3, [r7, #16]

  /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

  /* Figure F.20: Decode_AC_coefficients */
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8013c96:	687b      	ldr	r3, [r7, #4]
 8013c98:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8013c9c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013c9e:	e0bf      	b.n	8013e20 <decode_mcu_AC_first+0x1e4>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 8013ca0:	69fb      	ldr	r3, [r7, #28]
 8013ca2:	693a      	ldr	r2, [r7, #16]
 8013ca4:	321e      	adds	r2, #30
 8013ca6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013caa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013cac:	1e5a      	subs	r2, r3, #1
 8013cae:	4613      	mov	r3, r2
 8013cb0:	005b      	lsls	r3, r3, #1
 8013cb2:	4413      	add	r3, r2
 8013cb4:	440b      	add	r3, r1
 8013cb6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 8013cb8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013cba:	6878      	ldr	r0, [r7, #4]
 8013cbc:	f7ff fd7e 	bl	80137bc <arith_decode>
 8013cc0:	4603      	mov	r3, r0
 8013cc2:	2b00      	cmp	r3, #0
 8013cc4:	f040 80b4 	bne.w	8013e30 <decode_mcu_AC_first+0x1f4>
    while (arith_decode(cinfo, st + 1) == 0) {
 8013cc8:	e01c      	b.n	8013d04 <decode_mcu_AC_first+0xc8>
      st += 3; k++;
 8013cca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013ccc:	3303      	adds	r3, #3
 8013cce:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8013cd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013cd2:	3301      	adds	r3, #1
 8013cd4:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (k > cinfo->Se) {
 8013cd6:	687b      	ldr	r3, [r7, #4]
 8013cd8:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8013cdc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013cde:	429a      	cmp	r2, r3
 8013ce0:	dd10      	ble.n	8013d04 <decode_mcu_AC_first+0xc8>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8013ce2:	687b      	ldr	r3, [r7, #4]
 8013ce4:	681b      	ldr	r3, [r3, #0]
 8013ce6:	2275      	movs	r2, #117	@ 0x75
 8013ce8:	615a      	str	r2, [r3, #20]
 8013cea:	687b      	ldr	r3, [r7, #4]
 8013cec:	681b      	ldr	r3, [r3, #0]
 8013cee:	685b      	ldr	r3, [r3, #4]
 8013cf0:	f04f 31ff 	mov.w	r1, #4294967295
 8013cf4:	6878      	ldr	r0, [r7, #4]
 8013cf6:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 8013cf8:	69fb      	ldr	r3, [r7, #28]
 8013cfa:	f04f 32ff 	mov.w	r2, #4294967295
 8013cfe:	611a      	str	r2, [r3, #16]
	return TRUE;
 8013d00:	2301      	movs	r3, #1
 8013d02:	e097      	b.n	8013e34 <decode_mcu_AC_first+0x1f8>
    while (arith_decode(cinfo, st + 1) == 0) {
 8013d04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013d06:	3301      	adds	r3, #1
 8013d08:	4619      	mov	r1, r3
 8013d0a:	6878      	ldr	r0, [r7, #4]
 8013d0c:	f7ff fd56 	bl	80137bc <arith_decode>
 8013d10:	4603      	mov	r3, r0
 8013d12:	2b00      	cmp	r3, #0
 8013d14:	d0d9      	beq.n	8013cca <decode_mcu_AC_first+0x8e>
      }
    }
    /* Figure F.21: Decoding nonzero value v */
    /* Figure F.22: Decoding the sign of v */
    sign = arith_decode(cinfo, entropy->fixed_bin);
 8013d16:	69fb      	ldr	r3, [r7, #28]
 8013d18:	33b8      	adds	r3, #184	@ 0xb8
 8013d1a:	4619      	mov	r1, r3
 8013d1c:	6878      	ldr	r0, [r7, #4]
 8013d1e:	f7ff fd4d 	bl	80137bc <arith_decode>
 8013d22:	60f8      	str	r0, [r7, #12]
    st += 2;
 8013d24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013d26:	3302      	adds	r3, #2
 8013d28:	62fb      	str	r3, [r7, #44]	@ 0x2c
    /* Figure F.23: Decoding the magnitude category of v */
    if ((m = arith_decode(cinfo, st)) != 0) {
 8013d2a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013d2c:	6878      	ldr	r0, [r7, #4]
 8013d2e:	f7ff fd45 	bl	80137bc <arith_decode>
 8013d32:	6238      	str	r0, [r7, #32]
 8013d34:	6a3b      	ldr	r3, [r7, #32]
 8013d36:	2b00      	cmp	r3, #0
 8013d38:	d040      	beq.n	8013dbc <decode_mcu_AC_first+0x180>
      if (arith_decode(cinfo, st)) {
 8013d3a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013d3c:	6878      	ldr	r0, [r7, #4]
 8013d3e:	f7ff fd3d 	bl	80137bc <arith_decode>
 8013d42:	4603      	mov	r3, r0
 8013d44:	2b00      	cmp	r3, #0
 8013d46:	d039      	beq.n	8013dbc <decode_mcu_AC_first+0x180>
	m <<= 1;
 8013d48:	6a3b      	ldr	r3, [r7, #32]
 8013d4a:	005b      	lsls	r3, r3, #1
 8013d4c:	623b      	str	r3, [r7, #32]
	st = entropy->ac_stats[tbl] +
 8013d4e:	69fb      	ldr	r3, [r7, #28]
 8013d50:	693a      	ldr	r2, [r7, #16]
 8013d52:	321e      	adds	r2, #30
 8013d54:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	     (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 8013d58:	6879      	ldr	r1, [r7, #4]
 8013d5a:	693b      	ldr	r3, [r7, #16]
 8013d5c:	440b      	add	r3, r1
 8013d5e:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8013d62:	781b      	ldrb	r3, [r3, #0]
 8013d64:	4619      	mov	r1, r3
 8013d66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013d68:	428b      	cmp	r3, r1
 8013d6a:	dc01      	bgt.n	8013d70 <decode_mcu_AC_first+0x134>
 8013d6c:	23bd      	movs	r3, #189	@ 0xbd
 8013d6e:	e000      	b.n	8013d72 <decode_mcu_AC_first+0x136>
 8013d70:	23d9      	movs	r3, #217	@ 0xd9
	st = entropy->ac_stats[tbl] +
 8013d72:	4413      	add	r3, r2
 8013d74:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 8013d76:	e01a      	b.n	8013dae <decode_mcu_AC_first+0x172>
	  if ((m <<= 1) == 0x8000) {
 8013d78:	6a3b      	ldr	r3, [r7, #32]
 8013d7a:	005b      	lsls	r3, r3, #1
 8013d7c:	623b      	str	r3, [r7, #32]
 8013d7e:	6a3b      	ldr	r3, [r7, #32]
 8013d80:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8013d84:	d110      	bne.n	8013da8 <decode_mcu_AC_first+0x16c>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8013d86:	687b      	ldr	r3, [r7, #4]
 8013d88:	681b      	ldr	r3, [r3, #0]
 8013d8a:	2275      	movs	r2, #117	@ 0x75
 8013d8c:	615a      	str	r2, [r3, #20]
 8013d8e:	687b      	ldr	r3, [r7, #4]
 8013d90:	681b      	ldr	r3, [r3, #0]
 8013d92:	685b      	ldr	r3, [r3, #4]
 8013d94:	f04f 31ff 	mov.w	r1, #4294967295
 8013d98:	6878      	ldr	r0, [r7, #4]
 8013d9a:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 8013d9c:	69fb      	ldr	r3, [r7, #28]
 8013d9e:	f04f 32ff 	mov.w	r2, #4294967295
 8013da2:	611a      	str	r2, [r3, #16]
	    return TRUE;
 8013da4:	2301      	movs	r3, #1
 8013da6:	e045      	b.n	8013e34 <decode_mcu_AC_first+0x1f8>
	  }
	  st += 1;
 8013da8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013daa:	3301      	adds	r3, #1
 8013dac:	62fb      	str	r3, [r7, #44]	@ 0x2c
	while (arith_decode(cinfo, st)) {
 8013dae:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013db0:	6878      	ldr	r0, [r7, #4]
 8013db2:	f7ff fd03 	bl	80137bc <arith_decode>
 8013db6:	4603      	mov	r3, r0
 8013db8:	2b00      	cmp	r3, #0
 8013dba:	d1dd      	bne.n	8013d78 <decode_mcu_AC_first+0x13c>
	}
      }
    }
    v = m;
 8013dbc:	6a3b      	ldr	r3, [r7, #32]
 8013dbe:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Figure F.24: Decoding the magnitude bit pattern of v */
    st += 14;
 8013dc0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013dc2:	330e      	adds	r3, #14
 8013dc4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    while (m >>= 1)
 8013dc6:	e00a      	b.n	8013dde <decode_mcu_AC_first+0x1a2>
      if (arith_decode(cinfo, st)) v |= m;
 8013dc8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013dca:	6878      	ldr	r0, [r7, #4]
 8013dcc:	f7ff fcf6 	bl	80137bc <arith_decode>
 8013dd0:	4603      	mov	r3, r0
 8013dd2:	2b00      	cmp	r3, #0
 8013dd4:	d003      	beq.n	8013dde <decode_mcu_AC_first+0x1a2>
 8013dd6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013dd8:	6a3b      	ldr	r3, [r7, #32]
 8013dda:	4313      	orrs	r3, r2
 8013ddc:	627b      	str	r3, [r7, #36]	@ 0x24
    while (m >>= 1)
 8013dde:	6a3b      	ldr	r3, [r7, #32]
 8013de0:	105b      	asrs	r3, r3, #1
 8013de2:	623b      	str	r3, [r7, #32]
 8013de4:	6a3b      	ldr	r3, [r7, #32]
 8013de6:	2b00      	cmp	r3, #0
 8013de8:	d1ee      	bne.n	8013dc8 <decode_mcu_AC_first+0x18c>
    v += 1; if (sign) v = -v;
 8013dea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013dec:	3301      	adds	r3, #1
 8013dee:	627b      	str	r3, [r7, #36]	@ 0x24
 8013df0:	68fb      	ldr	r3, [r7, #12]
 8013df2:	2b00      	cmp	r3, #0
 8013df4:	d002      	beq.n	8013dfc <decode_mcu_AC_first+0x1c0>
 8013df6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013df8:	425b      	negs	r3, r3
 8013dfa:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Scale and output coefficient in natural (dezigzagged) order */
    (*block)[natural_order[k]] = (JCOEF) (v << cinfo->Al);
 8013dfc:	687b      	ldr	r3, [r7, #4]
 8013dfe:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8013e02:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013e04:	fa02 f103 	lsl.w	r1, r2, r3
 8013e08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013e0a:	009b      	lsls	r3, r3, #2
 8013e0c:	69ba      	ldr	r2, [r7, #24]
 8013e0e:	4413      	add	r3, r2
 8013e10:	681a      	ldr	r2, [r3, #0]
 8013e12:	b209      	sxth	r1, r1
 8013e14:	697b      	ldr	r3, [r7, #20]
 8013e16:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8013e1a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013e1c:	3301      	adds	r3, #1
 8013e1e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013e20:	687b      	ldr	r3, [r7, #4]
 8013e22:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8013e26:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013e28:	429a      	cmp	r2, r3
 8013e2a:	f77f af39 	ble.w	8013ca0 <decode_mcu_AC_first+0x64>
 8013e2e:	e000      	b.n	8013e32 <decode_mcu_AC_first+0x1f6>
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 8013e30:	bf00      	nop
  }

  return TRUE;
 8013e32:	2301      	movs	r3, #1
}
 8013e34:	4618      	mov	r0, r3
 8013e36:	3730      	adds	r7, #48	@ 0x30
 8013e38:	46bd      	mov	sp, r7
 8013e3a:	bd80      	pop	{r7, pc}

08013e3c <decode_mcu_DC_refine>:
 * MCU decoding for DC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8013e3c:	b580      	push	{r7, lr}
 8013e3e:	b086      	sub	sp, #24
 8013e40:	af00      	add	r7, sp, #0
 8013e42:	6078      	str	r0, [r7, #4]
 8013e44:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8013e46:	687b      	ldr	r3, [r7, #4]
 8013e48:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8013e4c:	613b      	str	r3, [r7, #16]
  unsigned char *st;
  int p1, blkn;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8013e4e:	687b      	ldr	r3, [r7, #4]
 8013e50:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8013e54:	2b00      	cmp	r3, #0
 8013e56:	d00b      	beq.n	8013e70 <decode_mcu_DC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 8013e58:	693b      	ldr	r3, [r7, #16]
 8013e5a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013e5c:	2b00      	cmp	r3, #0
 8013e5e:	d102      	bne.n	8013e66 <decode_mcu_DC_refine+0x2a>
      process_restart(cinfo);
 8013e60:	6878      	ldr	r0, [r7, #4]
 8013e62:	f7ff fd51 	bl	8013908 <process_restart>
    entropy->restarts_to_go--;
 8013e66:	693b      	ldr	r3, [r7, #16]
 8013e68:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013e6a:	1e5a      	subs	r2, r3, #1
 8013e6c:	693b      	ldr	r3, [r7, #16]
 8013e6e:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  st = entropy->fixed_bin;	/* use fixed probability estimation */
 8013e70:	693b      	ldr	r3, [r7, #16]
 8013e72:	33b8      	adds	r3, #184	@ 0xb8
 8013e74:	60fb      	str	r3, [r7, #12]
  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 8013e76:	687b      	ldr	r3, [r7, #4]
 8013e78:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8013e7c:	2201      	movs	r2, #1
 8013e7e:	fa02 f303 	lsl.w	r3, r2, r3
 8013e82:	60bb      	str	r3, [r7, #8]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8013e84:	2300      	movs	r3, #0
 8013e86:	617b      	str	r3, [r7, #20]
 8013e88:	e01a      	b.n	8013ec0 <decode_mcu_DC_refine+0x84>
    /* Encoded data is simply the next bit of the two's-complement DC value */
    if (arith_decode(cinfo, st))
 8013e8a:	68f9      	ldr	r1, [r7, #12]
 8013e8c:	6878      	ldr	r0, [r7, #4]
 8013e8e:	f7ff fc95 	bl	80137bc <arith_decode>
 8013e92:	4603      	mov	r3, r0
 8013e94:	2b00      	cmp	r3, #0
 8013e96:	d010      	beq.n	8013eba <decode_mcu_DC_refine+0x7e>
      MCU_data[blkn][0][0] |= p1;
 8013e98:	697b      	ldr	r3, [r7, #20]
 8013e9a:	009b      	lsls	r3, r3, #2
 8013e9c:	683a      	ldr	r2, [r7, #0]
 8013e9e:	4413      	add	r3, r2
 8013ea0:	681b      	ldr	r3, [r3, #0]
 8013ea2:	f9b3 1000 	ldrsh.w	r1, [r3]
 8013ea6:	68bb      	ldr	r3, [r7, #8]
 8013ea8:	b21a      	sxth	r2, r3
 8013eaa:	697b      	ldr	r3, [r7, #20]
 8013eac:	009b      	lsls	r3, r3, #2
 8013eae:	6838      	ldr	r0, [r7, #0]
 8013eb0:	4403      	add	r3, r0
 8013eb2:	681b      	ldr	r3, [r3, #0]
 8013eb4:	430a      	orrs	r2, r1
 8013eb6:	b212      	sxth	r2, r2
 8013eb8:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8013eba:	697b      	ldr	r3, [r7, #20]
 8013ebc:	3301      	adds	r3, #1
 8013ebe:	617b      	str	r3, [r7, #20]
 8013ec0:	687b      	ldr	r3, [r7, #4]
 8013ec2:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8013ec6:	697a      	ldr	r2, [r7, #20]
 8013ec8:	429a      	cmp	r2, r3
 8013eca:	dbde      	blt.n	8013e8a <decode_mcu_DC_refine+0x4e>
  }

  return TRUE;
 8013ecc:	2301      	movs	r3, #1
}
 8013ece:	4618      	mov	r0, r3
 8013ed0:	3718      	adds	r7, #24
 8013ed2:	46bd      	mov	sp, r7
 8013ed4:	bd80      	pop	{r7, pc}

08013ed6 <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8013ed6:	b580      	push	{r7, lr}
 8013ed8:	b08c      	sub	sp, #48	@ 0x30
 8013eda:	af00      	add	r7, sp, #0
 8013edc:	6078      	str	r0, [r7, #4]
 8013ede:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 8013ee0:	687b      	ldr	r3, [r7, #4]
 8013ee2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8013ee6:	623b      	str	r3, [r7, #32]
  int tbl, k, kex;
  int p1, m1;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 8013ee8:	687b      	ldr	r3, [r7, #4]
 8013eea:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8013eee:	2b00      	cmp	r3, #0
 8013ef0:	d00b      	beq.n	8013f0a <decode_mcu_AC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 8013ef2:	6a3b      	ldr	r3, [r7, #32]
 8013ef4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013ef6:	2b00      	cmp	r3, #0
 8013ef8:	d102      	bne.n	8013f00 <decode_mcu_AC_refine+0x2a>
      process_restart(cinfo);
 8013efa:	6878      	ldr	r0, [r7, #4]
 8013efc:	f7ff fd04 	bl	8013908 <process_restart>
    entropy->restarts_to_go--;
 8013f00:	6a3b      	ldr	r3, [r7, #32]
 8013f02:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013f04:	1e5a      	subs	r2, r3, #1
 8013f06:	6a3b      	ldr	r3, [r7, #32]
 8013f08:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 8013f0a:	6a3b      	ldr	r3, [r7, #32]
 8013f0c:	691b      	ldr	r3, [r3, #16]
 8013f0e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013f12:	d101      	bne.n	8013f18 <decode_mcu_AC_refine+0x42>
 8013f14:	2301      	movs	r3, #1
 8013f16:	e0c8      	b.n	80140aa <decode_mcu_AC_refine+0x1d4>

  natural_order = cinfo->natural_order;
 8013f18:	687b      	ldr	r3, [r7, #4]
 8013f1a:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8013f1e:	61fb      	str	r3, [r7, #28]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 8013f20:	683b      	ldr	r3, [r7, #0]
 8013f22:	681b      	ldr	r3, [r3, #0]
 8013f24:	61bb      	str	r3, [r7, #24]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 8013f26:	687b      	ldr	r3, [r7, #4]
 8013f28:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8013f2c:	699b      	ldr	r3, [r3, #24]
 8013f2e:	617b      	str	r3, [r7, #20]

  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 8013f30:	687b      	ldr	r3, [r7, #4]
 8013f32:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8013f36:	2201      	movs	r2, #1
 8013f38:	fa02 f303 	lsl.w	r3, r2, r3
 8013f3c:	613b      	str	r3, [r7, #16]
  m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 8013f3e:	687b      	ldr	r3, [r7, #4]
 8013f40:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8013f44:	f04f 32ff 	mov.w	r2, #4294967295
 8013f48:	fa02 f303 	lsl.w	r3, r2, r3
 8013f4c:	60fb      	str	r3, [r7, #12]

  /* Establish EOBx (previous stage end-of-block) index */
  for (kex = cinfo->Se; kex > 0; kex--)
 8013f4e:	687b      	ldr	r3, [r7, #4]
 8013f50:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8013f54:	627b      	str	r3, [r7, #36]	@ 0x24
 8013f56:	e00c      	b.n	8013f72 <decode_mcu_AC_refine+0x9c>
    if ((*block)[natural_order[kex]]) break;
 8013f58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f5a:	009b      	lsls	r3, r3, #2
 8013f5c:	69fa      	ldr	r2, [r7, #28]
 8013f5e:	4413      	add	r3, r2
 8013f60:	681a      	ldr	r2, [r3, #0]
 8013f62:	69bb      	ldr	r3, [r7, #24]
 8013f64:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8013f68:	2b00      	cmp	r3, #0
 8013f6a:	d106      	bne.n	8013f7a <decode_mcu_AC_refine+0xa4>
  for (kex = cinfo->Se; kex > 0; kex--)
 8013f6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f6e:	3b01      	subs	r3, #1
 8013f70:	627b      	str	r3, [r7, #36]	@ 0x24
 8013f72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f74:	2b00      	cmp	r3, #0
 8013f76:	dcef      	bgt.n	8013f58 <decode_mcu_AC_refine+0x82>
 8013f78:	e000      	b.n	8013f7c <decode_mcu_AC_refine+0xa6>
    if ((*block)[natural_order[kex]]) break;
 8013f7a:	bf00      	nop

  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8013f7c:	687b      	ldr	r3, [r7, #4]
 8013f7e:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8013f82:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013f84:	e089      	b.n	801409a <decode_mcu_AC_refine+0x1c4>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 8013f86:	6a3b      	ldr	r3, [r7, #32]
 8013f88:	697a      	ldr	r2, [r7, #20]
 8013f8a:	321e      	adds	r2, #30
 8013f8c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013f90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013f92:	1e5a      	subs	r2, r3, #1
 8013f94:	4613      	mov	r3, r2
 8013f96:	005b      	lsls	r3, r3, #1
 8013f98:	4413      	add	r3, r2
 8013f9a:	440b      	add	r3, r1
 8013f9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (k > kex)
 8013f9e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8013fa0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013fa2:	429a      	cmp	r2, r3
 8013fa4:	dc00      	bgt.n	8013fa8 <decode_mcu_AC_refine+0xd2>
 8013fa6:	e007      	b.n	8013fb8 <decode_mcu_AC_refine+0xe2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 8013fa8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8013faa:	6878      	ldr	r0, [r7, #4]
 8013fac:	f7ff fc06 	bl	80137bc <arith_decode>
 8013fb0:	4603      	mov	r3, r0
 8013fb2:	2b00      	cmp	r3, #0
 8013fb4:	d000      	beq.n	8013fb8 <decode_mcu_AC_refine+0xe2>
 8013fb6:	e077      	b.n	80140a8 <decode_mcu_AC_refine+0x1d2>
    for (;;) {
      thiscoef = *block + natural_order[k];
 8013fb8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013fba:	009b      	lsls	r3, r3, #2
 8013fbc:	69fa      	ldr	r2, [r7, #28]
 8013fbe:	4413      	add	r3, r2
 8013fc0:	681b      	ldr	r3, [r3, #0]
 8013fc2:	005b      	lsls	r3, r3, #1
 8013fc4:	69ba      	ldr	r2, [r7, #24]
 8013fc6:	4413      	add	r3, r2
 8013fc8:	60bb      	str	r3, [r7, #8]
      if (*thiscoef) {				/* previously nonzero coef */
 8013fca:	68bb      	ldr	r3, [r7, #8]
 8013fcc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013fd0:	2b00      	cmp	r3, #0
 8013fd2:	d025      	beq.n	8014020 <decode_mcu_AC_refine+0x14a>
	if (arith_decode(cinfo, st + 2)) {
 8013fd4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013fd6:	3302      	adds	r3, #2
 8013fd8:	4619      	mov	r1, r3
 8013fda:	6878      	ldr	r0, [r7, #4]
 8013fdc:	f7ff fbee 	bl	80137bc <arith_decode>
 8013fe0:	4603      	mov	r3, r0
 8013fe2:	2b00      	cmp	r3, #0
 8013fe4:	d055      	beq.n	8014092 <decode_mcu_AC_refine+0x1bc>
	  if (*thiscoef < 0)
 8013fe6:	68bb      	ldr	r3, [r7, #8]
 8013fe8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013fec:	2b00      	cmp	r3, #0
 8013fee:	da0b      	bge.n	8014008 <decode_mcu_AC_refine+0x132>
	    *thiscoef += m1;
 8013ff0:	68bb      	ldr	r3, [r7, #8]
 8013ff2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013ff6:	b29a      	uxth	r2, r3
 8013ff8:	68fb      	ldr	r3, [r7, #12]
 8013ffa:	b29b      	uxth	r3, r3
 8013ffc:	4413      	add	r3, r2
 8013ffe:	b29b      	uxth	r3, r3
 8014000:	b21a      	sxth	r2, r3
 8014002:	68bb      	ldr	r3, [r7, #8]
 8014004:	801a      	strh	r2, [r3, #0]
	  else
	    *thiscoef += p1;
	}
	break;
 8014006:	e044      	b.n	8014092 <decode_mcu_AC_refine+0x1bc>
	    *thiscoef += p1;
 8014008:	68bb      	ldr	r3, [r7, #8]
 801400a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801400e:	b29a      	uxth	r2, r3
 8014010:	693b      	ldr	r3, [r7, #16]
 8014012:	b29b      	uxth	r3, r3
 8014014:	4413      	add	r3, r2
 8014016:	b29b      	uxth	r3, r3
 8014018:	b21a      	sxth	r2, r3
 801401a:	68bb      	ldr	r3, [r7, #8]
 801401c:	801a      	strh	r2, [r3, #0]
	break;
 801401e:	e038      	b.n	8014092 <decode_mcu_AC_refine+0x1bc>
      }
      if (arith_decode(cinfo, st + 1)) {	/* newly nonzero coef */
 8014020:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014022:	3301      	adds	r3, #1
 8014024:	4619      	mov	r1, r3
 8014026:	6878      	ldr	r0, [r7, #4]
 8014028:	f7ff fbc8 	bl	80137bc <arith_decode>
 801402c:	4603      	mov	r3, r0
 801402e:	2b00      	cmp	r3, #0
 8014030:	d012      	beq.n	8014058 <decode_mcu_AC_refine+0x182>
	if (arith_decode(cinfo, entropy->fixed_bin))
 8014032:	6a3b      	ldr	r3, [r7, #32]
 8014034:	33b8      	adds	r3, #184	@ 0xb8
 8014036:	4619      	mov	r1, r3
 8014038:	6878      	ldr	r0, [r7, #4]
 801403a:	f7ff fbbf 	bl	80137bc <arith_decode>
 801403e:	4603      	mov	r3, r0
 8014040:	2b00      	cmp	r3, #0
 8014042:	d004      	beq.n	801404e <decode_mcu_AC_refine+0x178>
	  *thiscoef = m1;
 8014044:	68fb      	ldr	r3, [r7, #12]
 8014046:	b21a      	sxth	r2, r3
 8014048:	68bb      	ldr	r3, [r7, #8]
 801404a:	801a      	strh	r2, [r3, #0]
	else
	  *thiscoef = p1;
	break;
 801404c:	e022      	b.n	8014094 <decode_mcu_AC_refine+0x1be>
	  *thiscoef = p1;
 801404e:	693b      	ldr	r3, [r7, #16]
 8014050:	b21a      	sxth	r2, r3
 8014052:	68bb      	ldr	r3, [r7, #8]
 8014054:	801a      	strh	r2, [r3, #0]
	break;
 8014056:	e01d      	b.n	8014094 <decode_mcu_AC_refine+0x1be>
      }
      st += 3; k++;
 8014058:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801405a:	3303      	adds	r3, #3
 801405c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801405e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014060:	3301      	adds	r3, #1
 8014062:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (k > cinfo->Se) {
 8014064:	687b      	ldr	r3, [r7, #4]
 8014066:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 801406a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801406c:	429a      	cmp	r2, r3
 801406e:	dda3      	ble.n	8013fb8 <decode_mcu_AC_refine+0xe2>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8014070:	687b      	ldr	r3, [r7, #4]
 8014072:	681b      	ldr	r3, [r3, #0]
 8014074:	2275      	movs	r2, #117	@ 0x75
 8014076:	615a      	str	r2, [r3, #20]
 8014078:	687b      	ldr	r3, [r7, #4]
 801407a:	681b      	ldr	r3, [r3, #0]
 801407c:	685b      	ldr	r3, [r3, #4]
 801407e:	f04f 31ff 	mov.w	r1, #4294967295
 8014082:	6878      	ldr	r0, [r7, #4]
 8014084:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 8014086:	6a3b      	ldr	r3, [r7, #32]
 8014088:	f04f 32ff 	mov.w	r2, #4294967295
 801408c:	611a      	str	r2, [r3, #16]
	return TRUE;
 801408e:	2301      	movs	r3, #1
 8014090:	e00b      	b.n	80140aa <decode_mcu_AC_refine+0x1d4>
	break;
 8014092:	bf00      	nop
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 8014094:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014096:	3301      	adds	r3, #1
 8014098:	62bb      	str	r3, [r7, #40]	@ 0x28
 801409a:	687b      	ldr	r3, [r7, #4]
 801409c:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80140a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80140a2:	429a      	cmp	r2, r3
 80140a4:	f77f af6f 	ble.w	8013f86 <decode_mcu_AC_refine+0xb0>
      }
    }
  }

  return TRUE;
 80140a8:	2301      	movs	r3, #1
}
 80140aa:	4618      	mov	r0, r3
 80140ac:	3730      	adds	r7, #48	@ 0x30
 80140ae:	46bd      	mov	sp, r7
 80140b0:	bd80      	pop	{r7, pc}

080140b2 <decode_mcu>:
 * Decode one MCU's worth of arithmetic-compressed coefficients.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 80140b2:	b580      	push	{r7, lr}
 80140b4:	b08e      	sub	sp, #56	@ 0x38
 80140b6:	af00      	add	r7, sp, #0
 80140b8:	6078      	str	r0, [r7, #4]
 80140ba:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 80140bc:	687b      	ldr	r3, [r7, #4]
 80140be:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80140c2:	623b      	str	r3, [r7, #32]
  int blkn, ci, tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 80140c4:	687b      	ldr	r3, [r7, #4]
 80140c6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 80140ca:	2b00      	cmp	r3, #0
 80140cc:	d00b      	beq.n	80140e6 <decode_mcu+0x34>
    if (entropy->restarts_to_go == 0)
 80140ce:	6a3b      	ldr	r3, [r7, #32]
 80140d0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80140d2:	2b00      	cmp	r3, #0
 80140d4:	d102      	bne.n	80140dc <decode_mcu+0x2a>
      process_restart(cinfo);
 80140d6:	6878      	ldr	r0, [r7, #4]
 80140d8:	f7ff fc16 	bl	8013908 <process_restart>
    entropy->restarts_to_go--;
 80140dc:	6a3b      	ldr	r3, [r7, #32]
 80140de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80140e0:	1e5a      	subs	r2, r3, #1
 80140e2:	6a3b      	ldr	r3, [r7, #32]
 80140e4:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 80140e6:	6a3b      	ldr	r3, [r7, #32]
 80140e8:	691b      	ldr	r3, [r3, #16]
 80140ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 80140ee:	d101      	bne.n	80140f4 <decode_mcu+0x42>
 80140f0:	2301      	movs	r3, #1
 80140f2:	e1ba      	b.n	801446a <decode_mcu+0x3b8>

  natural_order = cinfo->natural_order;
 80140f4:	687b      	ldr	r3, [r7, #4]
 80140f6:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 80140fa:	61fb      	str	r3, [r7, #28]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80140fc:	2300      	movs	r3, #0
 80140fe:	633b      	str	r3, [r7, #48]	@ 0x30
 8014100:	e1ab      	b.n	801445a <decode_mcu+0x3a8>
    block = MCU_data[blkn];
 8014102:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014104:	009b      	lsls	r3, r3, #2
 8014106:	683a      	ldr	r2, [r7, #0]
 8014108:	4413      	add	r3, r2
 801410a:	681b      	ldr	r3, [r3, #0]
 801410c:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 801410e:	687b      	ldr	r3, [r7, #4]
 8014110:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014112:	325c      	adds	r2, #92	@ 0x5c
 8014114:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014118:	617b      	str	r3, [r7, #20]
    compptr = cinfo->cur_comp_info[ci];
 801411a:	687a      	ldr	r2, [r7, #4]
 801411c:	697b      	ldr	r3, [r7, #20]
 801411e:	3354      	adds	r3, #84	@ 0x54
 8014120:	009b      	lsls	r3, r3, #2
 8014122:	4413      	add	r3, r2
 8014124:	685b      	ldr	r3, [r3, #4]
 8014126:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    tbl = compptr->dc_tbl_no;
 8014128:	693b      	ldr	r3, [r7, #16]
 801412a:	695b      	ldr	r3, [r3, #20]
 801412c:	60fb      	str	r3, [r7, #12]

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 801412e:	6a3b      	ldr	r3, [r7, #32]
 8014130:	68fa      	ldr	r2, [r7, #12]
 8014132:	320e      	adds	r2, #14
 8014134:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8014138:	6a39      	ldr	r1, [r7, #32]
 801413a:	697b      	ldr	r3, [r7, #20]
 801413c:	3308      	adds	r3, #8
 801413e:	009b      	lsls	r3, r3, #2
 8014140:	440b      	add	r3, r1
 8014142:	685b      	ldr	r3, [r3, #4]
 8014144:	4413      	add	r3, r2
 8014146:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 8014148:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801414a:	6878      	ldr	r0, [r7, #4]
 801414c:	f7ff fb36 	bl	80137bc <arith_decode>
 8014150:	4603      	mov	r3, r0
 8014152:	2b00      	cmp	r3, #0
 8014154:	d107      	bne.n	8014166 <decode_mcu+0xb4>
      entropy->dc_context[ci] = 0;
 8014156:	6a3a      	ldr	r2, [r7, #32]
 8014158:	697b      	ldr	r3, [r7, #20]
 801415a:	3308      	adds	r3, #8
 801415c:	009b      	lsls	r3, r3, #2
 801415e:	4413      	add	r3, r2
 8014160:	2200      	movs	r2, #0
 8014162:	605a      	str	r2, [r3, #4]
 8014164:	e0a0      	b.n	80142a8 <decode_mcu+0x1f6>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 8014166:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014168:	3301      	adds	r3, #1
 801416a:	4619      	mov	r1, r3
 801416c:	6878      	ldr	r0, [r7, #4]
 801416e:	f7ff fb25 	bl	80137bc <arith_decode>
 8014172:	60b8      	str	r0, [r7, #8]
      st += 2; st += sign;
 8014174:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014176:	3302      	adds	r3, #2
 8014178:	637b      	str	r3, [r7, #52]	@ 0x34
 801417a:	68bb      	ldr	r3, [r7, #8]
 801417c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801417e:	4413      	add	r3, r2
 8014180:	637b      	str	r3, [r7, #52]	@ 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8014182:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8014184:	6878      	ldr	r0, [r7, #4]
 8014186:	f7ff fb19 	bl	80137bc <arith_decode>
 801418a:	6278      	str	r0, [r7, #36]	@ 0x24
 801418c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801418e:	2b00      	cmp	r3, #0
 8014190:	d029      	beq.n	80141e6 <decode_mcu+0x134>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 8014192:	6a3b      	ldr	r3, [r7, #32]
 8014194:	68fa      	ldr	r2, [r7, #12]
 8014196:	320e      	adds	r2, #14
 8014198:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801419c:	3314      	adds	r3, #20
 801419e:	637b      	str	r3, [r7, #52]	@ 0x34
	while (arith_decode(cinfo, st)) {
 80141a0:	e01a      	b.n	80141d8 <decode_mcu+0x126>
	  if ((m <<= 1) == 0x8000) {
 80141a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80141a4:	005b      	lsls	r3, r3, #1
 80141a6:	627b      	str	r3, [r7, #36]	@ 0x24
 80141a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80141aa:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80141ae:	d110      	bne.n	80141d2 <decode_mcu+0x120>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 80141b0:	687b      	ldr	r3, [r7, #4]
 80141b2:	681b      	ldr	r3, [r3, #0]
 80141b4:	2275      	movs	r2, #117	@ 0x75
 80141b6:	615a      	str	r2, [r3, #20]
 80141b8:	687b      	ldr	r3, [r7, #4]
 80141ba:	681b      	ldr	r3, [r3, #0]
 80141bc:	685b      	ldr	r3, [r3, #4]
 80141be:	f04f 31ff 	mov.w	r1, #4294967295
 80141c2:	6878      	ldr	r0, [r7, #4]
 80141c4:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 80141c6:	6a3b      	ldr	r3, [r7, #32]
 80141c8:	f04f 32ff 	mov.w	r2, #4294967295
 80141cc:	611a      	str	r2, [r3, #16]
	    return TRUE;
 80141ce:	2301      	movs	r3, #1
 80141d0:	e14b      	b.n	801446a <decode_mcu+0x3b8>
	  }
	  st += 1;
 80141d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80141d4:	3301      	adds	r3, #1
 80141d6:	637b      	str	r3, [r7, #52]	@ 0x34
	while (arith_decode(cinfo, st)) {
 80141d8:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80141da:	6878      	ldr	r0, [r7, #4]
 80141dc:	f7ff faee 	bl	80137bc <arith_decode>
 80141e0:	4603      	mov	r3, r0
 80141e2:	2b00      	cmp	r3, #0
 80141e4:	d1dd      	bne.n	80141a2 <decode_mcu+0xf0>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 80141e6:	687a      	ldr	r2, [r7, #4]
 80141e8:	68fb      	ldr	r3, [r7, #12]
 80141ea:	4413      	add	r3, r2
 80141ec:	33e8      	adds	r3, #232	@ 0xe8
 80141ee:	781b      	ldrb	r3, [r3, #0]
 80141f0:	461a      	mov	r2, r3
 80141f2:	2301      	movs	r3, #1
 80141f4:	4093      	lsls	r3, r2
 80141f6:	105b      	asrs	r3, r3, #1
 80141f8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80141fa:	429a      	cmp	r2, r3
 80141fc:	da07      	bge.n	801420e <decode_mcu+0x15c>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 80141fe:	6a3a      	ldr	r2, [r7, #32]
 8014200:	697b      	ldr	r3, [r7, #20]
 8014202:	3308      	adds	r3, #8
 8014204:	009b      	lsls	r3, r3, #2
 8014206:	4413      	add	r3, r2
 8014208:	2200      	movs	r2, #0
 801420a:	605a      	str	r2, [r3, #4]
 801420c:	e01e      	b.n	801424c <decode_mcu+0x19a>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 801420e:	687a      	ldr	r2, [r7, #4]
 8014210:	68fb      	ldr	r3, [r7, #12]
 8014212:	4413      	add	r3, r2
 8014214:	33f8      	adds	r3, #248	@ 0xf8
 8014216:	781b      	ldrb	r3, [r3, #0]
 8014218:	461a      	mov	r2, r3
 801421a:	2301      	movs	r3, #1
 801421c:	4093      	lsls	r3, r2
 801421e:	105b      	asrs	r3, r3, #1
 8014220:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8014222:	429a      	cmp	r2, r3
 8014224:	dd09      	ble.n	801423a <decode_mcu+0x188>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 8014226:	68bb      	ldr	r3, [r7, #8]
 8014228:	3303      	adds	r3, #3
 801422a:	009a      	lsls	r2, r3, #2
 801422c:	6a39      	ldr	r1, [r7, #32]
 801422e:	697b      	ldr	r3, [r7, #20]
 8014230:	3308      	adds	r3, #8
 8014232:	009b      	lsls	r3, r3, #2
 8014234:	440b      	add	r3, r1
 8014236:	605a      	str	r2, [r3, #4]
 8014238:	e008      	b.n	801424c <decode_mcu+0x19a>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 801423a:	68bb      	ldr	r3, [r7, #8]
 801423c:	3301      	adds	r3, #1
 801423e:	009a      	lsls	r2, r3, #2
 8014240:	6a39      	ldr	r1, [r7, #32]
 8014242:	697b      	ldr	r3, [r7, #20]
 8014244:	3308      	adds	r3, #8
 8014246:	009b      	lsls	r3, r3, #2
 8014248:	440b      	add	r3, r1
 801424a:	605a      	str	r2, [r3, #4]
      v = m;
 801424c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801424e:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 8014250:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014252:	330e      	adds	r3, #14
 8014254:	637b      	str	r3, [r7, #52]	@ 0x34
      while (m >>= 1)
 8014256:	e00a      	b.n	801426e <decode_mcu+0x1bc>
	if (arith_decode(cinfo, st)) v |= m;
 8014258:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801425a:	6878      	ldr	r0, [r7, #4]
 801425c:	f7ff faae 	bl	80137bc <arith_decode>
 8014260:	4603      	mov	r3, r0
 8014262:	2b00      	cmp	r3, #0
 8014264:	d003      	beq.n	801426e <decode_mcu+0x1bc>
 8014266:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014268:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801426a:	4313      	orrs	r3, r2
 801426c:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (m >>= 1)
 801426e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014270:	105b      	asrs	r3, r3, #1
 8014272:	627b      	str	r3, [r7, #36]	@ 0x24
 8014274:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014276:	2b00      	cmp	r3, #0
 8014278:	d1ee      	bne.n	8014258 <decode_mcu+0x1a6>
      v += 1; if (sign) v = -v;
 801427a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801427c:	3301      	adds	r3, #1
 801427e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014280:	68bb      	ldr	r3, [r7, #8]
 8014282:	2b00      	cmp	r3, #0
 8014284:	d002      	beq.n	801428c <decode_mcu+0x1da>
 8014286:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014288:	425b      	negs	r3, r3
 801428a:	62bb      	str	r3, [r7, #40]	@ 0x28
      entropy->last_dc_val[ci] += v;
 801428c:	6a3a      	ldr	r2, [r7, #32]
 801428e:	697b      	ldr	r3, [r7, #20]
 8014290:	3304      	adds	r3, #4
 8014292:	009b      	lsls	r3, r3, #2
 8014294:	4413      	add	r3, r2
 8014296:	685a      	ldr	r2, [r3, #4]
 8014298:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801429a:	441a      	add	r2, r3
 801429c:	6a39      	ldr	r1, [r7, #32]
 801429e:	697b      	ldr	r3, [r7, #20]
 80142a0:	3304      	adds	r3, #4
 80142a2:	009b      	lsls	r3, r3, #2
 80142a4:	440b      	add	r3, r1
 80142a6:	605a      	str	r2, [r3, #4]
    }

    (*block)[0] = (JCOEF) entropy->last_dc_val[ci];
 80142a8:	6a3a      	ldr	r2, [r7, #32]
 80142aa:	697b      	ldr	r3, [r7, #20]
 80142ac:	3304      	adds	r3, #4
 80142ae:	009b      	lsls	r3, r3, #2
 80142b0:	4413      	add	r3, r2
 80142b2:	685b      	ldr	r3, [r3, #4]
 80142b4:	b21a      	sxth	r2, r3
 80142b6:	69bb      	ldr	r3, [r7, #24]
 80142b8:	801a      	strh	r2, [r3, #0]

    /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

    if (cinfo->lim_Se == 0) continue;
 80142ba:	687b      	ldr	r3, [r7, #4]
 80142bc:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80142c0:	2b00      	cmp	r3, #0
 80142c2:	f000 80c4 	beq.w	801444e <decode_mcu+0x39c>
    tbl = compptr->ac_tbl_no;
 80142c6:	693b      	ldr	r3, [r7, #16]
 80142c8:	699b      	ldr	r3, [r3, #24]
 80142ca:	60fb      	str	r3, [r7, #12]
    k = 0;
 80142cc:	2300      	movs	r3, #0
 80142ce:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Figure F.20: Decode_AC_coefficients */
    do {
      st = entropy->ac_stats[tbl] + 3 * k;
 80142d0:	6a3b      	ldr	r3, [r7, #32]
 80142d2:	68fa      	ldr	r2, [r7, #12]
 80142d4:	321e      	adds	r2, #30
 80142d6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80142da:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80142dc:	4613      	mov	r3, r2
 80142de:	005b      	lsls	r3, r3, #1
 80142e0:	4413      	add	r3, r2
 80142e2:	440b      	add	r3, r1
 80142e4:	637b      	str	r3, [r7, #52]	@ 0x34
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 80142e6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80142e8:	6878      	ldr	r0, [r7, #4]
 80142ea:	f7ff fa67 	bl	80137bc <arith_decode>
 80142ee:	4603      	mov	r3, r0
 80142f0:	2b00      	cmp	r3, #0
 80142f2:	f040 80ae 	bne.w	8014452 <decode_mcu+0x3a0>
      for (;;) {
	k++;
 80142f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80142f8:	3301      	adds	r3, #1
 80142fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
	if (arith_decode(cinfo, st + 1)) break;
 80142fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80142fe:	3301      	adds	r3, #1
 8014300:	4619      	mov	r1, r3
 8014302:	6878      	ldr	r0, [r7, #4]
 8014304:	f7ff fa5a 	bl	80137bc <arith_decode>
 8014308:	4603      	mov	r3, r0
 801430a:	2b00      	cmp	r3, #0
 801430c:	d119      	bne.n	8014342 <decode_mcu+0x290>
	st += 3;
 801430e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014310:	3303      	adds	r3, #3
 8014312:	637b      	str	r3, [r7, #52]	@ 0x34
	if (k >= cinfo->lim_Se) {
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801431a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801431c:	429a      	cmp	r2, r3
 801431e:	dbea      	blt.n	80142f6 <decode_mcu+0x244>
	  WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 8014320:	687b      	ldr	r3, [r7, #4]
 8014322:	681b      	ldr	r3, [r3, #0]
 8014324:	2275      	movs	r2, #117	@ 0x75
 8014326:	615a      	str	r2, [r3, #20]
 8014328:	687b      	ldr	r3, [r7, #4]
 801432a:	681b      	ldr	r3, [r3, #0]
 801432c:	685b      	ldr	r3, [r3, #4]
 801432e:	f04f 31ff 	mov.w	r1, #4294967295
 8014332:	6878      	ldr	r0, [r7, #4]
 8014334:	4798      	blx	r3
	  entropy->ct = -1;			/* spectral overflow */
 8014336:	6a3b      	ldr	r3, [r7, #32]
 8014338:	f04f 32ff 	mov.w	r2, #4294967295
 801433c:	611a      	str	r2, [r3, #16]
	  return TRUE;
 801433e:	2301      	movs	r3, #1
 8014340:	e093      	b.n	801446a <decode_mcu+0x3b8>
	if (arith_decode(cinfo, st + 1)) break;
 8014342:	bf00      	nop
	}
      }
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, entropy->fixed_bin);
 8014344:	6a3b      	ldr	r3, [r7, #32]
 8014346:	33b8      	adds	r3, #184	@ 0xb8
 8014348:	4619      	mov	r1, r3
 801434a:	6878      	ldr	r0, [r7, #4]
 801434c:	f7ff fa36 	bl	80137bc <arith_decode>
 8014350:	60b8      	str	r0, [r7, #8]
      st += 2;
 8014352:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014354:	3302      	adds	r3, #2
 8014356:	637b      	str	r3, [r7, #52]	@ 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 8014358:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801435a:	6878      	ldr	r0, [r7, #4]
 801435c:	f7ff fa2e 	bl	80137bc <arith_decode>
 8014360:	6278      	str	r0, [r7, #36]	@ 0x24
 8014362:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014364:	2b00      	cmp	r3, #0
 8014366:	d040      	beq.n	80143ea <decode_mcu+0x338>
	if (arith_decode(cinfo, st)) {
 8014368:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801436a:	6878      	ldr	r0, [r7, #4]
 801436c:	f7ff fa26 	bl	80137bc <arith_decode>
 8014370:	4603      	mov	r3, r0
 8014372:	2b00      	cmp	r3, #0
 8014374:	d039      	beq.n	80143ea <decode_mcu+0x338>
	  m <<= 1;
 8014376:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014378:	005b      	lsls	r3, r3, #1
 801437a:	627b      	str	r3, [r7, #36]	@ 0x24
	  st = entropy->ac_stats[tbl] +
 801437c:	6a3b      	ldr	r3, [r7, #32]
 801437e:	68fa      	ldr	r2, [r7, #12]
 8014380:	321e      	adds	r2, #30
 8014382:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	       (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 8014386:	6879      	ldr	r1, [r7, #4]
 8014388:	68fb      	ldr	r3, [r7, #12]
 801438a:	440b      	add	r3, r1
 801438c:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8014390:	781b      	ldrb	r3, [r3, #0]
 8014392:	4619      	mov	r1, r3
 8014394:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014396:	428b      	cmp	r3, r1
 8014398:	dc01      	bgt.n	801439e <decode_mcu+0x2ec>
 801439a:	23bd      	movs	r3, #189	@ 0xbd
 801439c:	e000      	b.n	80143a0 <decode_mcu+0x2ee>
 801439e:	23d9      	movs	r3, #217	@ 0xd9
	  st = entropy->ac_stats[tbl] +
 80143a0:	4413      	add	r3, r2
 80143a2:	637b      	str	r3, [r7, #52]	@ 0x34
	  while (arith_decode(cinfo, st)) {
 80143a4:	e01a      	b.n	80143dc <decode_mcu+0x32a>
	    if ((m <<= 1) == 0x8000) {
 80143a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80143a8:	005b      	lsls	r3, r3, #1
 80143aa:	627b      	str	r3, [r7, #36]	@ 0x24
 80143ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80143ae:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80143b2:	d110      	bne.n	80143d6 <decode_mcu+0x324>
	      WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 80143b4:	687b      	ldr	r3, [r7, #4]
 80143b6:	681b      	ldr	r3, [r3, #0]
 80143b8:	2275      	movs	r2, #117	@ 0x75
 80143ba:	615a      	str	r2, [r3, #20]
 80143bc:	687b      	ldr	r3, [r7, #4]
 80143be:	681b      	ldr	r3, [r3, #0]
 80143c0:	685b      	ldr	r3, [r3, #4]
 80143c2:	f04f 31ff 	mov.w	r1, #4294967295
 80143c6:	6878      	ldr	r0, [r7, #4]
 80143c8:	4798      	blx	r3
	      entropy->ct = -1;			/* magnitude overflow */
 80143ca:	6a3b      	ldr	r3, [r7, #32]
 80143cc:	f04f 32ff 	mov.w	r2, #4294967295
 80143d0:	611a      	str	r2, [r3, #16]
	      return TRUE;
 80143d2:	2301      	movs	r3, #1
 80143d4:	e049      	b.n	801446a <decode_mcu+0x3b8>
	    }
	    st += 1;
 80143d6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80143d8:	3301      	adds	r3, #1
 80143da:	637b      	str	r3, [r7, #52]	@ 0x34
	  while (arith_decode(cinfo, st)) {
 80143dc:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80143de:	6878      	ldr	r0, [r7, #4]
 80143e0:	f7ff f9ec 	bl	80137bc <arith_decode>
 80143e4:	4603      	mov	r3, r0
 80143e6:	2b00      	cmp	r3, #0
 80143e8:	d1dd      	bne.n	80143a6 <decode_mcu+0x2f4>
	  }
	}
      }
      v = m;
 80143ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80143ec:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 80143ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80143f0:	330e      	adds	r3, #14
 80143f2:	637b      	str	r3, [r7, #52]	@ 0x34
      while (m >>= 1)
 80143f4:	e00a      	b.n	801440c <decode_mcu+0x35a>
	if (arith_decode(cinfo, st)) v |= m;
 80143f6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80143f8:	6878      	ldr	r0, [r7, #4]
 80143fa:	f7ff f9df 	bl	80137bc <arith_decode>
 80143fe:	4603      	mov	r3, r0
 8014400:	2b00      	cmp	r3, #0
 8014402:	d003      	beq.n	801440c <decode_mcu+0x35a>
 8014404:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014406:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014408:	4313      	orrs	r3, r2
 801440a:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (m >>= 1)
 801440c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801440e:	105b      	asrs	r3, r3, #1
 8014410:	627b      	str	r3, [r7, #36]	@ 0x24
 8014412:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014414:	2b00      	cmp	r3, #0
 8014416:	d1ee      	bne.n	80143f6 <decode_mcu+0x344>
      v += 1; if (sign) v = -v;
 8014418:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801441a:	3301      	adds	r3, #1
 801441c:	62bb      	str	r3, [r7, #40]	@ 0x28
 801441e:	68bb      	ldr	r3, [r7, #8]
 8014420:	2b00      	cmp	r3, #0
 8014422:	d002      	beq.n	801442a <decode_mcu+0x378>
 8014424:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014426:	425b      	negs	r3, r3
 8014428:	62bb      	str	r3, [r7, #40]	@ 0x28
      (*block)[natural_order[k]] = (JCOEF) v;
 801442a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801442c:	009b      	lsls	r3, r3, #2
 801442e:	69fa      	ldr	r2, [r7, #28]
 8014430:	4413      	add	r3, r2
 8014432:	681a      	ldr	r2, [r3, #0]
 8014434:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014436:	b219      	sxth	r1, r3
 8014438:	69bb      	ldr	r3, [r7, #24]
 801443a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    } while (k < cinfo->lim_Se);
 801443e:	687b      	ldr	r3, [r7, #4]
 8014440:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8014444:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8014446:	429a      	cmp	r2, r3
 8014448:	f6ff af42 	blt.w	80142d0 <decode_mcu+0x21e>
 801444c:	e002      	b.n	8014454 <decode_mcu+0x3a2>
    if (cinfo->lim_Se == 0) continue;
 801444e:	bf00      	nop
 8014450:	e000      	b.n	8014454 <decode_mcu+0x3a2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 8014452:	bf00      	nop
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8014454:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014456:	3301      	adds	r3, #1
 8014458:	633b      	str	r3, [r7, #48]	@ 0x30
 801445a:	687b      	ldr	r3, [r7, #4]
 801445c:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8014460:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014462:	429a      	cmp	r2, r3
 8014464:	f6ff ae4d 	blt.w	8014102 <decode_mcu+0x50>
  }

  return TRUE;
 8014468:	2301      	movs	r3, #1
}
 801446a:	4618      	mov	r0, r3
 801446c:	3738      	adds	r7, #56	@ 0x38
 801446e:	46bd      	mov	sp, r7
 8014470:	bd80      	pop	{r7, pc}
	...

08014474 <start_pass>:
 * Initialize for an arithmetic-compressed scan.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 8014474:	b580      	push	{r7, lr}
 8014476:	b08a      	sub	sp, #40	@ 0x28
 8014478:	af00      	add	r7, sp, #0
 801447a:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 801447c:	687b      	ldr	r3, [r7, #4]
 801447e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014482:	61fb      	str	r3, [r7, #28]
  int ci, tbl;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 8014484:	687b      	ldr	r3, [r7, #4]
 8014486:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801448a:	2b00      	cmp	r3, #0
 801448c:	f000 80e7 	beq.w	801465e <start_pass+0x1ea>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 8014490:	687b      	ldr	r3, [r7, #4]
 8014492:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8014496:	2b00      	cmp	r3, #0
 8014498:	d105      	bne.n	80144a6 <start_pass+0x32>
      if (cinfo->Se != 0)
 801449a:	687b      	ldr	r3, [r7, #4]
 801449c:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80144a0:	2b00      	cmp	r3, #0
 80144a2:	d015      	beq.n	80144d0 <start_pass+0x5c>
	goto bad;
 80144a4:	e02d      	b.n	8014502 <start_pass+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 80144a6:	687b      	ldr	r3, [r7, #4]
 80144a8:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80144ac:	687b      	ldr	r3, [r7, #4]
 80144ae:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80144b2:	429a      	cmp	r2, r3
 80144b4:	db20      	blt.n	80144f8 <start_pass+0x84>
 80144b6:	687b      	ldr	r3, [r7, #4]
 80144b8:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80144bc:	687b      	ldr	r3, [r7, #4]
 80144be:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80144c2:	429a      	cmp	r2, r3
 80144c4:	dc18      	bgt.n	80144f8 <start_pass+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 80144c6:	687b      	ldr	r3, [r7, #4]
 80144c8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80144cc:	2b01      	cmp	r3, #1
 80144ce:	d115      	bne.n	80144fc <start_pass+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 80144d0:	687b      	ldr	r3, [r7, #4]
 80144d2:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80144d6:	2b00      	cmp	r3, #0
 80144d8:	d008      	beq.n	80144ec <start_pass+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 80144da:	687b      	ldr	r3, [r7, #4]
 80144dc:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80144e0:	1e5a      	subs	r2, r3, #1
 80144e2:	687b      	ldr	r3, [r7, #4]
 80144e4:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80144e8:	429a      	cmp	r2, r3
 80144ea:	d109      	bne.n	8014500 <start_pass+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 80144ec:	687b      	ldr	r3, [r7, #4]
 80144ee:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80144f2:	2b0d      	cmp	r3, #13
 80144f4:	dd26      	ble.n	8014544 <start_pass+0xd0>
      bad:
 80144f6:	e004      	b.n	8014502 <start_pass+0x8e>
	goto bad;
 80144f8:	bf00      	nop
 80144fa:	e002      	b.n	8014502 <start_pass+0x8e>
	goto bad;
 80144fc:	bf00      	nop
 80144fe:	e000      	b.n	8014502 <start_pass+0x8e>
	goto bad;
 8014500:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 8014502:	687b      	ldr	r3, [r7, #4]
 8014504:	681b      	ldr	r3, [r3, #0]
 8014506:	2211      	movs	r2, #17
 8014508:	615a      	str	r2, [r3, #20]
 801450a:	687b      	ldr	r3, [r7, #4]
 801450c:	681b      	ldr	r3, [r3, #0]
 801450e:	687a      	ldr	r2, [r7, #4]
 8014510:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 8014514:	619a      	str	r2, [r3, #24]
 8014516:	687b      	ldr	r3, [r7, #4]
 8014518:	681b      	ldr	r3, [r3, #0]
 801451a:	687a      	ldr	r2, [r7, #4]
 801451c:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 8014520:	61da      	str	r2, [r3, #28]
 8014522:	687b      	ldr	r3, [r7, #4]
 8014524:	681b      	ldr	r3, [r3, #0]
 8014526:	687a      	ldr	r2, [r7, #4]
 8014528:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 801452c:	621a      	str	r2, [r3, #32]
 801452e:	687b      	ldr	r3, [r7, #4]
 8014530:	681b      	ldr	r3, [r3, #0]
 8014532:	687a      	ldr	r2, [r7, #4]
 8014534:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 8014538:	625a      	str	r2, [r3, #36]	@ 0x24
 801453a:	687b      	ldr	r3, [r7, #4]
 801453c:	681b      	ldr	r3, [r3, #0]
 801453e:	681b      	ldr	r3, [r3, #0]
 8014540:	6878      	ldr	r0, [r7, #4]
 8014542:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014544:	2300      	movs	r3, #0
 8014546:	627b      	str	r3, [r7, #36]	@ 0x24
 8014548:	e064      	b.n	8014614 <start_pass+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 801454a:	687a      	ldr	r2, [r7, #4]
 801454c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801454e:	3354      	adds	r3, #84	@ 0x54
 8014550:	009b      	lsls	r3, r3, #2
 8014552:	4413      	add	r3, r2
 8014554:	685b      	ldr	r3, [r3, #4]
 8014556:	685b      	ldr	r3, [r3, #4]
 8014558:	61bb      	str	r3, [r7, #24]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 801455a:	687b      	ldr	r3, [r7, #4]
 801455c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8014560:	69bb      	ldr	r3, [r7, #24]
 8014562:	021b      	lsls	r3, r3, #8
 8014564:	4413      	add	r3, r2
 8014566:	617b      	str	r3, [r7, #20]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 8014568:	687b      	ldr	r3, [r7, #4]
 801456a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801456e:	2b00      	cmp	r3, #0
 8014570:	d016      	beq.n	80145a0 <start_pass+0x12c>
 8014572:	697b      	ldr	r3, [r7, #20]
 8014574:	681b      	ldr	r3, [r3, #0]
 8014576:	2b00      	cmp	r3, #0
 8014578:	da12      	bge.n	80145a0 <start_pass+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 801457a:	687b      	ldr	r3, [r7, #4]
 801457c:	681b      	ldr	r3, [r3, #0]
 801457e:	2276      	movs	r2, #118	@ 0x76
 8014580:	615a      	str	r2, [r3, #20]
 8014582:	687b      	ldr	r3, [r7, #4]
 8014584:	681b      	ldr	r3, [r3, #0]
 8014586:	69ba      	ldr	r2, [r7, #24]
 8014588:	619a      	str	r2, [r3, #24]
 801458a:	687b      	ldr	r3, [r7, #4]
 801458c:	681b      	ldr	r3, [r3, #0]
 801458e:	2200      	movs	r2, #0
 8014590:	61da      	str	r2, [r3, #28]
 8014592:	687b      	ldr	r3, [r7, #4]
 8014594:	681b      	ldr	r3, [r3, #0]
 8014596:	685b      	ldr	r3, [r3, #4]
 8014598:	f04f 31ff 	mov.w	r1, #4294967295
 801459c:	6878      	ldr	r0, [r7, #4]
 801459e:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80145a0:	687b      	ldr	r3, [r7, #4]
 80145a2:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80145a6:	623b      	str	r3, [r7, #32]
 80145a8:	e02b      	b.n	8014602 <start_pass+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 80145aa:	6a3b      	ldr	r3, [r7, #32]
 80145ac:	009b      	lsls	r3, r3, #2
 80145ae:	697a      	ldr	r2, [r7, #20]
 80145b0:	4413      	add	r3, r2
 80145b2:	681b      	ldr	r3, [r3, #0]
 80145b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80145b8:	613b      	str	r3, [r7, #16]
	if (cinfo->Ah != expected)
 80145ba:	687b      	ldr	r3, [r7, #4]
 80145bc:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80145c0:	693a      	ldr	r2, [r7, #16]
 80145c2:	429a      	cmp	r2, r3
 80145c4:	d012      	beq.n	80145ec <start_pass+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 80145c6:	687b      	ldr	r3, [r7, #4]
 80145c8:	681b      	ldr	r3, [r3, #0]
 80145ca:	2276      	movs	r2, #118	@ 0x76
 80145cc:	615a      	str	r2, [r3, #20]
 80145ce:	687b      	ldr	r3, [r7, #4]
 80145d0:	681b      	ldr	r3, [r3, #0]
 80145d2:	69ba      	ldr	r2, [r7, #24]
 80145d4:	619a      	str	r2, [r3, #24]
 80145d6:	687b      	ldr	r3, [r7, #4]
 80145d8:	681b      	ldr	r3, [r3, #0]
 80145da:	6a3a      	ldr	r2, [r7, #32]
 80145dc:	61da      	str	r2, [r3, #28]
 80145de:	687b      	ldr	r3, [r7, #4]
 80145e0:	681b      	ldr	r3, [r3, #0]
 80145e2:	685b      	ldr	r3, [r3, #4]
 80145e4:	f04f 31ff 	mov.w	r1, #4294967295
 80145e8:	6878      	ldr	r0, [r7, #4]
 80145ea:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 80145ec:	6a3b      	ldr	r3, [r7, #32]
 80145ee:	009b      	lsls	r3, r3, #2
 80145f0:	697a      	ldr	r2, [r7, #20]
 80145f2:	4413      	add	r3, r2
 80145f4:	687a      	ldr	r2, [r7, #4]
 80145f6:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 80145fa:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80145fc:	6a3b      	ldr	r3, [r7, #32]
 80145fe:	3301      	adds	r3, #1
 8014600:	623b      	str	r3, [r7, #32]
 8014602:	687b      	ldr	r3, [r7, #4]
 8014604:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8014608:	6a3a      	ldr	r2, [r7, #32]
 801460a:	429a      	cmp	r2, r3
 801460c:	ddcd      	ble.n	80145aa <start_pass+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801460e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014610:	3301      	adds	r3, #1
 8014612:	627b      	str	r3, [r7, #36]	@ 0x24
 8014614:	687b      	ldr	r3, [r7, #4]
 8014616:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 801461a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801461c:	429a      	cmp	r2, r3
 801461e:	db94      	blt.n	801454a <start_pass+0xd6>
      }
    }
    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 8014620:	687b      	ldr	r3, [r7, #4]
 8014622:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8014626:	2b00      	cmp	r3, #0
 8014628:	d10c      	bne.n	8014644 <start_pass+0x1d0>
      if (cinfo->Ss == 0)
 801462a:	687b      	ldr	r3, [r7, #4]
 801462c:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8014630:	2b00      	cmp	r3, #0
 8014632:	d103      	bne.n	801463c <start_pass+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 8014634:	69fb      	ldr	r3, [r7, #28]
 8014636:	4a80      	ldr	r2, [pc, #512]	@ (8014838 <start_pass+0x3c4>)
 8014638:	605a      	str	r2, [r3, #4]
 801463a:	e03a      	b.n	80146b2 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 801463c:	69fb      	ldr	r3, [r7, #28]
 801463e:	4a7f      	ldr	r2, [pc, #508]	@ (801483c <start_pass+0x3c8>)
 8014640:	605a      	str	r2, [r3, #4]
 8014642:	e036      	b.n	80146b2 <start_pass+0x23e>
    } else {
      if (cinfo->Ss == 0)
 8014644:	687b      	ldr	r3, [r7, #4]
 8014646:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801464a:	2b00      	cmp	r3, #0
 801464c:	d103      	bne.n	8014656 <start_pass+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 801464e:	69fb      	ldr	r3, [r7, #28]
 8014650:	4a7b      	ldr	r2, [pc, #492]	@ (8014840 <start_pass+0x3cc>)
 8014652:	605a      	str	r2, [r3, #4]
 8014654:	e02d      	b.n	80146b2 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 8014656:	69fb      	ldr	r3, [r7, #28]
 8014658:	4a7a      	ldr	r2, [pc, #488]	@ (8014844 <start_pass+0x3d0>)
 801465a:	605a      	str	r2, [r3, #4]
 801465c:	e029      	b.n	80146b2 <start_pass+0x23e>
    }
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 801465e:	687b      	ldr	r3, [r7, #4]
 8014660:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8014664:	2b00      	cmp	r3, #0
 8014666:	d116      	bne.n	8014696 <start_pass+0x222>
 8014668:	687b      	ldr	r3, [r7, #4]
 801466a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801466e:	2b00      	cmp	r3, #0
 8014670:	d111      	bne.n	8014696 <start_pass+0x222>
 8014672:	687b      	ldr	r3, [r7, #4]
 8014674:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8014678:	2b00      	cmp	r3, #0
 801467a:	d10c      	bne.n	8014696 <start_pass+0x222>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 801467c:	687b      	ldr	r3, [r7, #4]
 801467e:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 8014682:	2b3f      	cmp	r3, #63	@ 0x3f
 8014684:	dc12      	bgt.n	80146ac <start_pass+0x238>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 8014686:	687b      	ldr	r3, [r7, #4]
 8014688:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 801468c:	687b      	ldr	r3, [r7, #4]
 801468e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8014692:	429a      	cmp	r2, r3
 8014694:	d00a      	beq.n	80146ac <start_pass+0x238>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 8014696:	687b      	ldr	r3, [r7, #4]
 8014698:	681b      	ldr	r3, [r3, #0]
 801469a:	227d      	movs	r2, #125	@ 0x7d
 801469c:	615a      	str	r2, [r3, #20]
 801469e:	687b      	ldr	r3, [r7, #4]
 80146a0:	681b      	ldr	r3, [r3, #0]
 80146a2:	685b      	ldr	r3, [r3, #4]
 80146a4:	f04f 31ff 	mov.w	r1, #4294967295
 80146a8:	6878      	ldr	r0, [r7, #4]
 80146aa:	4798      	blx	r3
    /* Select MCU decoding routine */
    entropy->pub.decode_mcu = decode_mcu;
 80146ac:	69fb      	ldr	r3, [r7, #28]
 80146ae:	4a66      	ldr	r2, [pc, #408]	@ (8014848 <start_pass+0x3d4>)
 80146b0:	605a      	str	r2, [r3, #4]
  }

  /* Allocate & initialize requested statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80146b2:	2300      	movs	r3, #0
 80146b4:	627b      	str	r3, [r7, #36]	@ 0x24
 80146b6:	e0a4      	b.n	8014802 <start_pass+0x38e>
    compptr = cinfo->cur_comp_info[ci];
 80146b8:	687a      	ldr	r2, [r7, #4]
 80146ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80146bc:	3354      	adds	r3, #84	@ 0x54
 80146be:	009b      	lsls	r3, r3, #2
 80146c0:	4413      	add	r3, r2
 80146c2:	685b      	ldr	r3, [r3, #4]
 80146c4:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 80146c6:	687b      	ldr	r3, [r7, #4]
 80146c8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80146cc:	2b00      	cmp	r3, #0
 80146ce:	d009      	beq.n	80146e4 <start_pass+0x270>
 80146d0:	687b      	ldr	r3, [r7, #4]
 80146d2:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80146d6:	2b00      	cmp	r3, #0
 80146d8:	d146      	bne.n	8014768 <start_pass+0x2f4>
 80146da:	687b      	ldr	r3, [r7, #4]
 80146dc:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80146e0:	2b00      	cmp	r3, #0
 80146e2:	d141      	bne.n	8014768 <start_pass+0x2f4>
      tbl = compptr->dc_tbl_no;
 80146e4:	68fb      	ldr	r3, [r7, #12]
 80146e6:	695b      	ldr	r3, [r3, #20]
 80146e8:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 80146ea:	68bb      	ldr	r3, [r7, #8]
 80146ec:	2b00      	cmp	r3, #0
 80146ee:	db02      	blt.n	80146f6 <start_pass+0x282>
 80146f0:	68bb      	ldr	r3, [r7, #8]
 80146f2:	2b0f      	cmp	r3, #15
 80146f4:	dd0c      	ble.n	8014710 <start_pass+0x29c>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 80146f6:	687b      	ldr	r3, [r7, #4]
 80146f8:	681b      	ldr	r3, [r3, #0]
 80146fa:	2232      	movs	r2, #50	@ 0x32
 80146fc:	615a      	str	r2, [r3, #20]
 80146fe:	687b      	ldr	r3, [r7, #4]
 8014700:	681b      	ldr	r3, [r3, #0]
 8014702:	68ba      	ldr	r2, [r7, #8]
 8014704:	619a      	str	r2, [r3, #24]
 8014706:	687b      	ldr	r3, [r7, #4]
 8014708:	681b      	ldr	r3, [r3, #0]
 801470a:	681b      	ldr	r3, [r3, #0]
 801470c:	6878      	ldr	r0, [r7, #4]
 801470e:	4798      	blx	r3
      if (entropy->dc_stats[tbl] == NULL)
 8014710:	69fb      	ldr	r3, [r7, #28]
 8014712:	68ba      	ldr	r2, [r7, #8]
 8014714:	320e      	adds	r2, #14
 8014716:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801471a:	2b00      	cmp	r3, #0
 801471c:	d10c      	bne.n	8014738 <start_pass+0x2c4>
	entropy->dc_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 801471e:	687b      	ldr	r3, [r7, #4]
 8014720:	685b      	ldr	r3, [r3, #4]
 8014722:	681b      	ldr	r3, [r3, #0]
 8014724:	2240      	movs	r2, #64	@ 0x40
 8014726:	2101      	movs	r1, #1
 8014728:	6878      	ldr	r0, [r7, #4]
 801472a:	4798      	blx	r3
 801472c:	4601      	mov	r1, r0
 801472e:	69fb      	ldr	r3, [r7, #28]
 8014730:	68ba      	ldr	r2, [r7, #8]
 8014732:	320e      	adds	r2, #14
 8014734:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, DC_STAT_BINS);
      MEMZERO(entropy->dc_stats[tbl], DC_STAT_BINS);
 8014738:	69fb      	ldr	r3, [r7, #28]
 801473a:	68ba      	ldr	r2, [r7, #8]
 801473c:	320e      	adds	r2, #14
 801473e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014742:	2240      	movs	r2, #64	@ 0x40
 8014744:	2100      	movs	r1, #0
 8014746:	4618      	mov	r0, r3
 8014748:	f01b f92a 	bl	802f9a0 <memset>
      /* Initialize DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 801474c:	69fa      	ldr	r2, [r7, #28]
 801474e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014750:	3304      	adds	r3, #4
 8014752:	009b      	lsls	r3, r3, #2
 8014754:	4413      	add	r3, r2
 8014756:	2200      	movs	r2, #0
 8014758:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 801475a:	69fa      	ldr	r2, [r7, #28]
 801475c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801475e:	3308      	adds	r3, #8
 8014760:	009b      	lsls	r3, r3, #2
 8014762:	4413      	add	r3, r2
 8014764:	2200      	movs	r2, #0
 8014766:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 8014768:	687b      	ldr	r3, [r7, #4]
 801476a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801476e:	2b00      	cmp	r3, #0
 8014770:	d104      	bne.n	801477c <start_pass+0x308>
 8014772:	687b      	ldr	r3, [r7, #4]
 8014774:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8014778:	2b00      	cmp	r3, #0
 801477a:	d109      	bne.n	8014790 <start_pass+0x31c>
	(cinfo->progressive_mode && cinfo->Ss)) {
 801477c:	687b      	ldr	r3, [r7, #4]
 801477e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 8014782:	2b00      	cmp	r3, #0
 8014784:	d03a      	beq.n	80147fc <start_pass+0x388>
	(cinfo->progressive_mode && cinfo->Ss)) {
 8014786:	687b      	ldr	r3, [r7, #4]
 8014788:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801478c:	2b00      	cmp	r3, #0
 801478e:	d035      	beq.n	80147fc <start_pass+0x388>
      tbl = compptr->ac_tbl_no;
 8014790:	68fb      	ldr	r3, [r7, #12]
 8014792:	699b      	ldr	r3, [r3, #24]
 8014794:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 8014796:	68bb      	ldr	r3, [r7, #8]
 8014798:	2b00      	cmp	r3, #0
 801479a:	db02      	blt.n	80147a2 <start_pass+0x32e>
 801479c:	68bb      	ldr	r3, [r7, #8]
 801479e:	2b0f      	cmp	r3, #15
 80147a0:	dd0c      	ble.n	80147bc <start_pass+0x348>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 80147a2:	687b      	ldr	r3, [r7, #4]
 80147a4:	681b      	ldr	r3, [r3, #0]
 80147a6:	2232      	movs	r2, #50	@ 0x32
 80147a8:	615a      	str	r2, [r3, #20]
 80147aa:	687b      	ldr	r3, [r7, #4]
 80147ac:	681b      	ldr	r3, [r3, #0]
 80147ae:	68ba      	ldr	r2, [r7, #8]
 80147b0:	619a      	str	r2, [r3, #24]
 80147b2:	687b      	ldr	r3, [r7, #4]
 80147b4:	681b      	ldr	r3, [r3, #0]
 80147b6:	681b      	ldr	r3, [r3, #0]
 80147b8:	6878      	ldr	r0, [r7, #4]
 80147ba:	4798      	blx	r3
      if (entropy->ac_stats[tbl] == NULL)
 80147bc:	69fb      	ldr	r3, [r7, #28]
 80147be:	68ba      	ldr	r2, [r7, #8]
 80147c0:	321e      	adds	r2, #30
 80147c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80147c6:	2b00      	cmp	r3, #0
 80147c8:	d10d      	bne.n	80147e6 <start_pass+0x372>
	entropy->ac_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 80147ca:	687b      	ldr	r3, [r7, #4]
 80147cc:	685b      	ldr	r3, [r3, #4]
 80147ce:	681b      	ldr	r3, [r3, #0]
 80147d0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80147d4:	2101      	movs	r1, #1
 80147d6:	6878      	ldr	r0, [r7, #4]
 80147d8:	4798      	blx	r3
 80147da:	4601      	mov	r1, r0
 80147dc:	69fb      	ldr	r3, [r7, #28]
 80147de:	68ba      	ldr	r2, [r7, #8]
 80147e0:	321e      	adds	r2, #30
 80147e2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, AC_STAT_BINS);
      MEMZERO(entropy->ac_stats[tbl], AC_STAT_BINS);
 80147e6:	69fb      	ldr	r3, [r7, #28]
 80147e8:	68ba      	ldr	r2, [r7, #8]
 80147ea:	321e      	adds	r2, #30
 80147ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80147f0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80147f4:	2100      	movs	r1, #0
 80147f6:	4618      	mov	r0, r3
 80147f8:	f01b f8d2 	bl	802f9a0 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80147fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80147fe:	3301      	adds	r3, #1
 8014800:	627b      	str	r3, [r7, #36]	@ 0x24
 8014802:	687b      	ldr	r3, [r7, #4]
 8014804:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8014808:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801480a:	429a      	cmp	r2, r3
 801480c:	f6ff af54 	blt.w	80146b8 <start_pass+0x244>
    }
  }

  /* Initialize arithmetic decoding variables */
  entropy->c = 0;
 8014810:	69fb      	ldr	r3, [r7, #28]
 8014812:	2200      	movs	r2, #0
 8014814:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 8014816:	69fb      	ldr	r3, [r7, #28]
 8014818:	2200      	movs	r2, #0
 801481a:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 801481c:	69fb      	ldr	r3, [r7, #28]
 801481e:	f06f 020f 	mvn.w	r2, #15
 8014822:	611a      	str	r2, [r3, #16]

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8014824:	687b      	ldr	r3, [r7, #4]
 8014826:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801482a:	69fb      	ldr	r3, [r7, #28]
 801482c:	635a      	str	r2, [r3, #52]	@ 0x34
}
 801482e:	bf00      	nop
 8014830:	3728      	adds	r7, #40	@ 0x28
 8014832:	46bd      	mov	sp, r7
 8014834:	bd80      	pop	{r7, pc}
 8014836:	bf00      	nop
 8014838:	08013a19 	.word	0x08013a19
 801483c:	08013c3d 	.word	0x08013c3d
 8014840:	08013e3d 	.word	0x08013e3d
 8014844:	08013ed7 	.word	0x08013ed7
 8014848:	080140b3 	.word	0x080140b3

0801484c <jinit_arith_decoder>:
 * Module initialization routine for arithmetic entropy decoding.
 */

GLOBAL(void)
jinit_arith_decoder (j_decompress_ptr cinfo)
{
 801484c:	b580      	push	{r7, lr}
 801484e:	b086      	sub	sp, #24
 8014850:	af00      	add	r7, sp, #0
 8014852:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy;
  int i;

  entropy = (arith_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8014854:	687b      	ldr	r3, [r7, #4]
 8014856:	685b      	ldr	r3, [r3, #4]
 8014858:	681b      	ldr	r3, [r3, #0]
 801485a:	22bc      	movs	r2, #188	@ 0xbc
 801485c:	2101      	movs	r1, #1
 801485e:	6878      	ldr	r0, [r7, #4]
 8014860:	4798      	blx	r3
 8014862:	60b8      	str	r0, [r7, #8]
				SIZEOF(arith_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 8014864:	687b      	ldr	r3, [r7, #4]
 8014866:	68ba      	ldr	r2, [r7, #8]
 8014868:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
  entropy->pub.start_pass = start_pass;
 801486c:	68bb      	ldr	r3, [r7, #8]
 801486e:	4a27      	ldr	r2, [pc, #156]	@ (801490c <jinit_arith_decoder+0xc0>)
 8014870:	601a      	str	r2, [r3, #0]

  /* Mark tables unallocated */
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 8014872:	2300      	movs	r3, #0
 8014874:	617b      	str	r3, [r7, #20]
 8014876:	e00e      	b.n	8014896 <jinit_arith_decoder+0x4a>
    entropy->dc_stats[i] = NULL;
 8014878:	68bb      	ldr	r3, [r7, #8]
 801487a:	697a      	ldr	r2, [r7, #20]
 801487c:	320e      	adds	r2, #14
 801487e:	2100      	movs	r1, #0
 8014880:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    entropy->ac_stats[i] = NULL;
 8014884:	68bb      	ldr	r3, [r7, #8]
 8014886:	697a      	ldr	r2, [r7, #20]
 8014888:	321e      	adds	r2, #30
 801488a:	2100      	movs	r1, #0
 801488c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 8014890:	697b      	ldr	r3, [r7, #20]
 8014892:	3301      	adds	r3, #1
 8014894:	617b      	str	r3, [r7, #20]
 8014896:	697b      	ldr	r3, [r7, #20]
 8014898:	2b0f      	cmp	r3, #15
 801489a:	dded      	ble.n	8014878 <jinit_arith_decoder+0x2c>
  }

  /* Initialize index for fixed probability estimation */
  entropy->fixed_bin[0] = 113;
 801489c:	68bb      	ldr	r3, [r7, #8]
 801489e:	2271      	movs	r2, #113	@ 0x71
 80148a0:	f883 20b8 	strb.w	r2, [r3, #184]	@ 0xb8

  if (cinfo->progressive_mode) {
 80148a4:	687b      	ldr	r3, [r7, #4]
 80148a6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80148aa:	2b00      	cmp	r3, #0
 80148ac:	d02a      	beq.n	8014904 <jinit_arith_decoder+0xb8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80148ae:	687b      	ldr	r3, [r7, #4]
 80148b0:	685b      	ldr	r3, [r3, #4]
 80148b2:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 80148b4:	687a      	ldr	r2, [r7, #4]
 80148b6:	6a52      	ldr	r2, [r2, #36]	@ 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80148b8:	0212      	lsls	r2, r2, #8
 80148ba:	2101      	movs	r1, #1
 80148bc:	6878      	ldr	r0, [r7, #4]
 80148be:	4798      	blx	r3
 80148c0:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 80148c2:	687b      	ldr	r3, [r7, #4]
 80148c4:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 80148c8:	687b      	ldr	r3, [r7, #4]
 80148ca:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80148ce:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++) 
 80148d0:	2300      	movs	r3, #0
 80148d2:	60fb      	str	r3, [r7, #12]
 80148d4:	e011      	b.n	80148fa <jinit_arith_decoder+0xae>
      for (i = 0; i < DCTSIZE2; i++)
 80148d6:	2300      	movs	r3, #0
 80148d8:	617b      	str	r3, [r7, #20]
 80148da:	e008      	b.n	80148ee <jinit_arith_decoder+0xa2>
	*coef_bit_ptr++ = -1;
 80148dc:	693b      	ldr	r3, [r7, #16]
 80148de:	1d1a      	adds	r2, r3, #4
 80148e0:	613a      	str	r2, [r7, #16]
 80148e2:	f04f 32ff 	mov.w	r2, #4294967295
 80148e6:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 80148e8:	697b      	ldr	r3, [r7, #20]
 80148ea:	3301      	adds	r3, #1
 80148ec:	617b      	str	r3, [r7, #20]
 80148ee:	697b      	ldr	r3, [r7, #20]
 80148f0:	2b3f      	cmp	r3, #63	@ 0x3f
 80148f2:	ddf3      	ble.n	80148dc <jinit_arith_decoder+0x90>
    for (ci = 0; ci < cinfo->num_components; ci++) 
 80148f4:	68fb      	ldr	r3, [r7, #12]
 80148f6:	3301      	adds	r3, #1
 80148f8:	60fb      	str	r3, [r7, #12]
 80148fa:	687b      	ldr	r3, [r7, #4]
 80148fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80148fe:	68fa      	ldr	r2, [r7, #12]
 8014900:	429a      	cmp	r2, r3
 8014902:	dbe8      	blt.n	80148d6 <jinit_arith_decoder+0x8a>
  }
}
 8014904:	bf00      	nop
 8014906:	3718      	adds	r7, #24
 8014908:	46bd      	mov	sp, r7
 801490a:	bd80      	pop	{r7, pc}
 801490c:	08014475 	.word	0x08014475

08014910 <init_mem_source>:
}
#endif /* 0 */

METHODDEF(void)
init_mem_source (j_decompress_ptr cinfo)
{
 8014910:	b480      	push	{r7}
 8014912:	b083      	sub	sp, #12
 8014914:	af00      	add	r7, sp, #0
 8014916:	6078      	str	r0, [r7, #4]
  /* no work necessary here */
}
 8014918:	bf00      	nop
 801491a:	370c      	adds	r7, #12
 801491c:	46bd      	mov	sp, r7
 801491e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014922:	4770      	bx	lr

08014924 <fill_mem_input_buffer>:
}
#endif /* JFILE */

METHODDEF(boolean)
fill_mem_input_buffer (j_decompress_ptr cinfo)
{
 8014924:	b580      	push	{r7, lr}
 8014926:	b082      	sub	sp, #8
 8014928:	af00      	add	r7, sp, #0
 801492a:	6078      	str	r0, [r7, #4]

  /* The whole JPEG data is expected to reside in the supplied memory
   * buffer, so any request for more data beyond the given buffer size
   * is treated as an error.
   */
  WARNMS(cinfo, JWRN_JPEG_EOF);
 801492c:	687b      	ldr	r3, [r7, #4]
 801492e:	681b      	ldr	r3, [r3, #0]
 8014930:	227b      	movs	r2, #123	@ 0x7b
 8014932:	615a      	str	r2, [r3, #20]
 8014934:	687b      	ldr	r3, [r7, #4]
 8014936:	681b      	ldr	r3, [r3, #0]
 8014938:	685b      	ldr	r3, [r3, #4]
 801493a:	f04f 31ff 	mov.w	r1, #4294967295
 801493e:	6878      	ldr	r0, [r7, #4]
 8014940:	4798      	blx	r3

  /* Insert a fake EOI marker */

  cinfo->src->next_input_byte = mybuffer;
 8014942:	687b      	ldr	r3, [r7, #4]
 8014944:	699b      	ldr	r3, [r3, #24]
 8014946:	4a05      	ldr	r2, [pc, #20]	@ (801495c <fill_mem_input_buffer+0x38>)
 8014948:	601a      	str	r2, [r3, #0]
  cinfo->src->bytes_in_buffer = 2;
 801494a:	687b      	ldr	r3, [r7, #4]
 801494c:	699b      	ldr	r3, [r3, #24]
 801494e:	2202      	movs	r2, #2
 8014950:	605a      	str	r2, [r3, #4]

  return TRUE;
 8014952:	2301      	movs	r3, #1
}
 8014954:	4618      	mov	r0, r3
 8014956:	3708      	adds	r7, #8
 8014958:	46bd      	mov	sp, r7
 801495a:	bd80      	pop	{r7, pc}
 801495c:	08032000 	.word	0x08032000

08014960 <skip_input_data>:
 * buffer is the application writer's problem.
 */

METHODDEF(void)
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
 8014960:	b580      	push	{r7, lr}
 8014962:	b084      	sub	sp, #16
 8014964:	af00      	add	r7, sp, #0
 8014966:	6078      	str	r0, [r7, #4]
 8014968:	6039      	str	r1, [r7, #0]
  struct jpeg_source_mgr * src = cinfo->src;
 801496a:	687b      	ldr	r3, [r7, #4]
 801496c:	699b      	ldr	r3, [r3, #24]
 801496e:	60fb      	str	r3, [r7, #12]

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
 8014970:	683b      	ldr	r3, [r7, #0]
 8014972:	2b00      	cmp	r3, #0
 8014974:	dd1c      	ble.n	80149b0 <skip_input_data+0x50>
    while (num_bytes > (long) src->bytes_in_buffer) {
 8014976:	e009      	b.n	801498c <skip_input_data+0x2c>
      num_bytes -= (long) src->bytes_in_buffer;
 8014978:	68fb      	ldr	r3, [r7, #12]
 801497a:	685b      	ldr	r3, [r3, #4]
 801497c:	461a      	mov	r2, r3
 801497e:	683b      	ldr	r3, [r7, #0]
 8014980:	1a9b      	subs	r3, r3, r2
 8014982:	603b      	str	r3, [r7, #0]
      (void) (*src->fill_input_buffer) (cinfo);
 8014984:	68fb      	ldr	r3, [r7, #12]
 8014986:	68db      	ldr	r3, [r3, #12]
 8014988:	6878      	ldr	r0, [r7, #4]
 801498a:	4798      	blx	r3
    while (num_bytes > (long) src->bytes_in_buffer) {
 801498c:	68fb      	ldr	r3, [r7, #12]
 801498e:	685b      	ldr	r3, [r3, #4]
 8014990:	461a      	mov	r2, r3
 8014992:	683b      	ldr	r3, [r7, #0]
 8014994:	4293      	cmp	r3, r2
 8014996:	dcef      	bgt.n	8014978 <skip_input_data+0x18>
      /* note we assume that fill_input_buffer will never return FALSE,
       * so suspension need not be handled.
       */
    }
    src->next_input_byte += (size_t) num_bytes;
 8014998:	68fb      	ldr	r3, [r7, #12]
 801499a:	681a      	ldr	r2, [r3, #0]
 801499c:	683b      	ldr	r3, [r7, #0]
 801499e:	441a      	add	r2, r3
 80149a0:	68fb      	ldr	r3, [r7, #12]
 80149a2:	601a      	str	r2, [r3, #0]
    src->bytes_in_buffer -= (size_t) num_bytes;
 80149a4:	68fb      	ldr	r3, [r7, #12]
 80149a6:	685a      	ldr	r2, [r3, #4]
 80149a8:	683b      	ldr	r3, [r7, #0]
 80149aa:	1ad2      	subs	r2, r2, r3
 80149ac:	68fb      	ldr	r3, [r7, #12]
 80149ae:	605a      	str	r2, [r3, #4]
  }
}
 80149b0:	bf00      	nop
 80149b2:	3710      	adds	r7, #16
 80149b4:	46bd      	mov	sp, r7
 80149b6:	bd80      	pop	{r7, pc}

080149b8 <term_source>:
 * for error exit.
 */

METHODDEF(void)
term_source (j_decompress_ptr cinfo)
{
 80149b8:	b480      	push	{r7}
 80149ba:	b083      	sub	sp, #12
 80149bc:	af00      	add	r7, sp, #0
 80149be:	6078      	str	r0, [r7, #4]
  /* no work necessary here */
}
 80149c0:	bf00      	nop
 80149c2:	370c      	adds	r7, #12
 80149c4:	46bd      	mov	sp, r7
 80149c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80149ca:	4770      	bx	lr

080149cc <jpeg_mem_src>:
 */

GLOBAL(void)
jpeg_mem_src (j_decompress_ptr cinfo,
	      unsigned char * inbuffer, unsigned long insize)
{
 80149cc:	b580      	push	{r7, lr}
 80149ce:	b086      	sub	sp, #24
 80149d0:	af00      	add	r7, sp, #0
 80149d2:	60f8      	str	r0, [r7, #12]
 80149d4:	60b9      	str	r1, [r7, #8]
 80149d6:	607a      	str	r2, [r7, #4]
  struct jpeg_source_mgr * src;

  if (inbuffer == NULL || insize == 0)	/* Treat empty input as fatal error */
 80149d8:	68bb      	ldr	r3, [r7, #8]
 80149da:	2b00      	cmp	r3, #0
 80149dc:	d002      	beq.n	80149e4 <jpeg_mem_src+0x18>
 80149de:	687b      	ldr	r3, [r7, #4]
 80149e0:	2b00      	cmp	r3, #0
 80149e2:	d108      	bne.n	80149f6 <jpeg_mem_src+0x2a>
    ERREXIT(cinfo, JERR_INPUT_EMPTY);
 80149e4:	68fb      	ldr	r3, [r7, #12]
 80149e6:	681b      	ldr	r3, [r3, #0]
 80149e8:	222b      	movs	r2, #43	@ 0x2b
 80149ea:	615a      	str	r2, [r3, #20]
 80149ec:	68fb      	ldr	r3, [r7, #12]
 80149ee:	681b      	ldr	r3, [r3, #0]
 80149f0:	681b      	ldr	r3, [r3, #0]
 80149f2:	68f8      	ldr	r0, [r7, #12]
 80149f4:	4798      	blx	r3

  /* The source object is made permanent so that a series of JPEG images
   * can be read from the same buffer by calling jpeg_mem_src only before
   * the first one.
   */
  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
 80149f6:	68fb      	ldr	r3, [r7, #12]
 80149f8:	699b      	ldr	r3, [r3, #24]
 80149fa:	2b00      	cmp	r3, #0
 80149fc:	d109      	bne.n	8014a12 <jpeg_mem_src+0x46>
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 80149fe:	68fb      	ldr	r3, [r7, #12]
 8014a00:	685b      	ldr	r3, [r3, #4]
 8014a02:	681b      	ldr	r3, [r3, #0]
 8014a04:	221c      	movs	r2, #28
 8014a06:	2100      	movs	r1, #0
 8014a08:	68f8      	ldr	r0, [r7, #12]
 8014a0a:	4798      	blx	r3
 8014a0c:	4602      	mov	r2, r0
    cinfo->src = (struct jpeg_source_mgr *)
 8014a0e:	68fb      	ldr	r3, [r7, #12]
 8014a10:	619a      	str	r2, [r3, #24]
				  SIZEOF(struct jpeg_source_mgr));
  }

  src = cinfo->src;
 8014a12:	68fb      	ldr	r3, [r7, #12]
 8014a14:	699b      	ldr	r3, [r3, #24]
 8014a16:	617b      	str	r3, [r7, #20]
  src->init_source = init_mem_source;
 8014a18:	697b      	ldr	r3, [r7, #20]
 8014a1a:	4a0c      	ldr	r2, [pc, #48]	@ (8014a4c <jpeg_mem_src+0x80>)
 8014a1c:	609a      	str	r2, [r3, #8]
  src->fill_input_buffer = fill_mem_input_buffer;
 8014a1e:	697b      	ldr	r3, [r7, #20]
 8014a20:	4a0b      	ldr	r2, [pc, #44]	@ (8014a50 <jpeg_mem_src+0x84>)
 8014a22:	60da      	str	r2, [r3, #12]
  src->skip_input_data = skip_input_data;
 8014a24:	697b      	ldr	r3, [r7, #20]
 8014a26:	4a0b      	ldr	r2, [pc, #44]	@ (8014a54 <jpeg_mem_src+0x88>)
 8014a28:	611a      	str	r2, [r3, #16]
  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */
 8014a2a:	697b      	ldr	r3, [r7, #20]
 8014a2c:	4a0a      	ldr	r2, [pc, #40]	@ (8014a58 <jpeg_mem_src+0x8c>)
 8014a2e:	615a      	str	r2, [r3, #20]
  src->term_source = term_source;
 8014a30:	697b      	ldr	r3, [r7, #20]
 8014a32:	4a0a      	ldr	r2, [pc, #40]	@ (8014a5c <jpeg_mem_src+0x90>)
 8014a34:	619a      	str	r2, [r3, #24]
  src->bytes_in_buffer = (size_t) insize;
 8014a36:	697b      	ldr	r3, [r7, #20]
 8014a38:	687a      	ldr	r2, [r7, #4]
 8014a3a:	605a      	str	r2, [r3, #4]
  src->next_input_byte = (JOCTET *) inbuffer;
 8014a3c:	697b      	ldr	r3, [r7, #20]
 8014a3e:	68ba      	ldr	r2, [r7, #8]
 8014a40:	601a      	str	r2, [r3, #0]
}
 8014a42:	bf00      	nop
 8014a44:	3718      	adds	r7, #24
 8014a46:	46bd      	mov	sp, r7
 8014a48:	bd80      	pop	{r7, pc}
 8014a4a:	bf00      	nop
 8014a4c:	08014911 	.word	0x08014911
 8014a50:	08014925 	.word	0x08014925
 8014a54:	08014961 	.word	0x08014961
 8014a58:	0801caa5 	.word	0x0801caa5
 8014a5c:	080149b9 	.word	0x080149b9

08014a60 <start_iMCU_row>:


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
 8014a60:	b480      	push	{r7}
 8014a62:	b085      	sub	sp, #20
 8014a64:	af00      	add	r7, sp, #0
 8014a66:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8014a68:	687b      	ldr	r3, [r7, #4]
 8014a6a:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8014a6e:	60fb      	str	r3, [r7, #12]

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
 8014a70:	687b      	ldr	r3, [r7, #4]
 8014a72:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8014a76:	2b01      	cmp	r3, #1
 8014a78:	dd03      	ble.n	8014a82 <start_iMCU_row+0x22>
    coef->MCU_rows_per_iMCU_row = 1;
 8014a7a:	68fb      	ldr	r3, [r7, #12]
 8014a7c:	2201      	movs	r2, #1
 8014a7e:	61da      	str	r2, [r3, #28]
 8014a80:	e015      	b.n	8014aae <start_iMCU_row+0x4e>
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
 8014a82:	687b      	ldr	r3, [r7, #4]
 8014a84:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8014a88:	687b      	ldr	r3, [r7, #4]
 8014a8a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8014a8e:	3b01      	subs	r3, #1
 8014a90:	429a      	cmp	r2, r3
 8014a92:	d206      	bcs.n	8014aa2 <start_iMCU_row+0x42>
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
 8014a94:	687b      	ldr	r3, [r7, #4]
 8014a96:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8014a9a:	68da      	ldr	r2, [r3, #12]
 8014a9c:	68fb      	ldr	r3, [r7, #12]
 8014a9e:	61da      	str	r2, [r3, #28]
 8014aa0:	e005      	b.n	8014aae <start_iMCU_row+0x4e>
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
 8014aa2:	687b      	ldr	r3, [r7, #4]
 8014aa4:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8014aa8:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8014aaa:	68fb      	ldr	r3, [r7, #12]
 8014aac:	61da      	str	r2, [r3, #28]
  }

  coef->MCU_ctr = 0;
 8014aae:	68fb      	ldr	r3, [r7, #12]
 8014ab0:	2200      	movs	r2, #0
 8014ab2:	615a      	str	r2, [r3, #20]
  coef->MCU_vert_offset = 0;
 8014ab4:	68fb      	ldr	r3, [r7, #12]
 8014ab6:	2200      	movs	r2, #0
 8014ab8:	619a      	str	r2, [r3, #24]
}
 8014aba:	bf00      	nop
 8014abc:	3714      	adds	r7, #20
 8014abe:	46bd      	mov	sp, r7
 8014ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ac4:	4770      	bx	lr

08014ac6 <start_input_pass>:
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 8014ac6:	b580      	push	{r7, lr}
 8014ac8:	b082      	sub	sp, #8
 8014aca:	af00      	add	r7, sp, #0
 8014acc:	6078      	str	r0, [r7, #4]
  cinfo->input_iMCU_row = 0;
 8014ace:	687b      	ldr	r3, [r7, #4]
 8014ad0:	2200      	movs	r2, #0
 8014ad2:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  start_iMCU_row(cinfo);
 8014ad6:	6878      	ldr	r0, [r7, #4]
 8014ad8:	f7ff ffc2 	bl	8014a60 <start_iMCU_row>
}
 8014adc:	bf00      	nop
 8014ade:	3708      	adds	r7, #8
 8014ae0:	46bd      	mov	sp, r7
 8014ae2:	bd80      	pop	{r7, pc}

08014ae4 <start_output_pass>:
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
 8014ae4:	b580      	push	{r7, lr}
 8014ae6:	b084      	sub	sp, #16
 8014ae8:	af00      	add	r7, sp, #0
 8014aea:	6078      	str	r0, [r7, #4]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8014aec:	687b      	ldr	r3, [r7, #4]
 8014aee:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8014af2:	60fb      	str	r3, [r7, #12]

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
 8014af4:	68fb      	ldr	r3, [r7, #12]
 8014af6:	691b      	ldr	r3, [r3, #16]
 8014af8:	2b00      	cmp	r3, #0
 8014afa:	d010      	beq.n	8014b1e <start_output_pass+0x3a>
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
 8014afc:	687b      	ldr	r3, [r7, #4]
 8014afe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8014b00:	2b00      	cmp	r3, #0
 8014b02:	d009      	beq.n	8014b18 <start_output_pass+0x34>
 8014b04:	6878      	ldr	r0, [r7, #4]
 8014b06:	f000 fad0 	bl	80150aa <smoothing_ok>
 8014b0a:	4603      	mov	r3, r0
 8014b0c:	2b00      	cmp	r3, #0
 8014b0e:	d003      	beq.n	8014b18 <start_output_pass+0x34>
      coef->pub.decompress_data = decompress_smooth_data;
 8014b10:	68fb      	ldr	r3, [r7, #12]
 8014b12:	4a07      	ldr	r2, [pc, #28]	@ (8014b30 <start_output_pass+0x4c>)
 8014b14:	60da      	str	r2, [r3, #12]
 8014b16:	e002      	b.n	8014b1e <start_output_pass+0x3a>
    else
      coef->pub.decompress_data = decompress_data;
 8014b18:	68fb      	ldr	r3, [r7, #12]
 8014b1a:	4a06      	ldr	r2, [pc, #24]	@ (8014b34 <start_output_pass+0x50>)
 8014b1c:	60da      	str	r2, [r3, #12]
  }
#endif
  cinfo->output_iMCU_row = 0;
 8014b1e:	687b      	ldr	r3, [r7, #4]
 8014b20:	2200      	movs	r2, #0
 8014b22:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
}
 8014b26:	bf00      	nop
 8014b28:	3710      	adds	r7, #16
 8014b2a:	46bd      	mov	sp, r7
 8014b2c:	bd80      	pop	{r7, pc}
 8014b2e:	bf00      	nop
 8014b30:	080151d1 	.word	0x080151d1
 8014b34:	08014f01 	.word	0x08014f01

08014b38 <decompress_onepass>:
 * which we index according to the component's SOF position.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 8014b38:	b590      	push	{r4, r7, lr}
 8014b3a:	b095      	sub	sp, #84	@ 0x54
 8014b3c:	af02      	add	r7, sp, #8
 8014b3e:	6078      	str	r0, [r7, #4]
 8014b40:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8014b42:	687b      	ldr	r3, [r7, #4]
 8014b44:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8014b48:	627b      	str	r3, [r7, #36]	@ 0x24
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
 8014b4a:	687b      	ldr	r3, [r7, #4]
 8014b4c:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8014b50:	3b01      	subs	r3, #1
 8014b52:	623b      	str	r3, [r7, #32]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 8014b54:	687b      	ldr	r3, [r7, #4]
 8014b56:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8014b5a:	3b01      	subs	r3, #1
 8014b5c:	61fb      	str	r3, [r7, #28]
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8014b5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b60:	699b      	ldr	r3, [r3, #24]
 8014b62:	633b      	str	r3, [r7, #48]	@ 0x30
 8014b64:	e0bf      	b.n	8014ce6 <decompress_onepass+0x1ae>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 8014b66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b68:	695b      	ldr	r3, [r3, #20]
 8014b6a:	647b      	str	r3, [r7, #68]	@ 0x44
 8014b6c:	e0b0      	b.n	8014cd0 <decompress_onepass+0x198>
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      if (cinfo->lim_Se)	/* can bypass in DC only case */
 8014b6e:	687b      	ldr	r3, [r7, #4]
 8014b70:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8014b74:	2b00      	cmp	r3, #0
 8014b76:	d009      	beq.n	8014b8c <decompress_onepass+0x54>
	FMEMZERO((void FAR *) coef->MCU_buffer[0],
 8014b78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b7a:	6a18      	ldr	r0, [r3, #32]
 8014b7c:	687b      	ldr	r3, [r7, #4]
 8014b7e:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8014b82:	01db      	lsls	r3, r3, #7
 8014b84:	461a      	mov	r2, r3
 8014b86:	2100      	movs	r1, #0
 8014b88:	f01a ff0a 	bl	802f9a0 <memset>
		 (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 8014b8c:	687b      	ldr	r3, [r7, #4]
 8014b8e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014b92:	685b      	ldr	r3, [r3, #4]
 8014b94:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8014b96:	3220      	adds	r2, #32
 8014b98:	4611      	mov	r1, r2
 8014b9a:	6878      	ldr	r0, [r7, #4]
 8014b9c:	4798      	blx	r3
 8014b9e:	4603      	mov	r3, r0
 8014ba0:	2b00      	cmp	r3, #0
 8014ba2:	d107      	bne.n	8014bb4 <decompress_onepass+0x7c>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 8014ba4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014ba6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014ba8:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 8014baa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014bac:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8014bae:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 8014bb0:	2300      	movs	r3, #0
 8014bb2:	e0c0      	b.n	8014d36 <decompress_onepass+0x1fe>
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
 8014bb4:	2300      	movs	r3, #0
 8014bb6:	643b      	str	r3, [r7, #64]	@ 0x40
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014bb8:	2300      	movs	r3, #0
 8014bba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8014bbc:	e07e      	b.n	8014cbc <decompress_onepass+0x184>
	compptr = cinfo->cur_comp_info[ci];
 8014bbe:	687a      	ldr	r2, [r7, #4]
 8014bc0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014bc2:	3354      	adds	r3, #84	@ 0x54
 8014bc4:	009b      	lsls	r3, r3, #2
 8014bc6:	4413      	add	r3, r2
 8014bc8:	685b      	ldr	r3, [r3, #4]
 8014bca:	61bb      	str	r3, [r7, #24]
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
 8014bcc:	69bb      	ldr	r3, [r7, #24]
 8014bce:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8014bd0:	2b00      	cmp	r3, #0
 8014bd2:	d105      	bne.n	8014be0 <decompress_onepass+0xa8>
	  blkn += compptr->MCU_blocks;
 8014bd4:	69bb      	ldr	r3, [r7, #24]
 8014bd6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8014bd8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014bda:	4413      	add	r3, r2
 8014bdc:	643b      	str	r3, [r7, #64]	@ 0x40
	  continue;
 8014bde:	e06a      	b.n	8014cb6 <decompress_onepass+0x17e>
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
 8014be0:	687b      	ldr	r3, [r7, #4]
 8014be2:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 8014be6:	69bb      	ldr	r3, [r7, #24]
 8014be8:	685b      	ldr	r3, [r3, #4]
 8014bea:	009b      	lsls	r3, r3, #2
 8014bec:	4413      	add	r3, r2
 8014bee:	685b      	ldr	r3, [r3, #4]
 8014bf0:	617b      	str	r3, [r7, #20]
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
 8014bf2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8014bf4:	6a3b      	ldr	r3, [r7, #32]
 8014bf6:	429a      	cmp	r2, r3
 8014bf8:	d202      	bcs.n	8014c00 <decompress_onepass+0xc8>
 8014bfa:	69bb      	ldr	r3, [r7, #24]
 8014bfc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8014bfe:	e001      	b.n	8014c04 <decompress_onepass+0xcc>
 8014c00:	69bb      	ldr	r3, [r7, #24]
 8014c02:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
 8014c04:	613b      	str	r3, [r7, #16]
	output_ptr = output_buf[compptr->component_index] +
 8014c06:	69bb      	ldr	r3, [r7, #24]
 8014c08:	685b      	ldr	r3, [r3, #4]
 8014c0a:	009b      	lsls	r3, r3, #2
 8014c0c:	683a      	ldr	r2, [r7, #0]
 8014c0e:	4413      	add	r3, r2
 8014c10:	681a      	ldr	r2, [r3, #0]
	  yoffset * compptr->DCT_v_scaled_size;
 8014c12:	69bb      	ldr	r3, [r7, #24]
 8014c14:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014c16:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8014c18:	fb01 f303 	mul.w	r3, r1, r3
	output_ptr = output_buf[compptr->component_index] +
 8014c1c:	009b      	lsls	r3, r3, #2
 8014c1e:	4413      	add	r3, r2
 8014c20:	62fb      	str	r3, [r7, #44]	@ 0x2c
	start_col = MCU_col_num * compptr->MCU_sample_width;
 8014c22:	69bb      	ldr	r3, [r7, #24]
 8014c24:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8014c26:	461a      	mov	r2, r3
 8014c28:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014c2a:	fb02 f303 	mul.w	r3, r2, r3
 8014c2e:	60fb      	str	r3, [r7, #12]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8014c30:	2300      	movs	r3, #0
 8014c32:	637b      	str	r3, [r7, #52]	@ 0x34
 8014c34:	e03a      	b.n	8014cac <decompress_onepass+0x174>
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 8014c36:	687b      	ldr	r3, [r7, #4]
 8014c38:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8014c3c:	69fa      	ldr	r2, [r7, #28]
 8014c3e:	429a      	cmp	r2, r3
 8014c40:	d806      	bhi.n	8014c50 <decompress_onepass+0x118>
	      yoffset+yindex < compptr->last_row_height) {
 8014c42:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014c44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014c46:	441a      	add	r2, r3
 8014c48:	69bb      	ldr	r3, [r7, #24]
 8014c4a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 8014c4c:	429a      	cmp	r2, r3
 8014c4e:	da1f      	bge.n	8014c90 <decompress_onepass+0x158>
	    output_col = start_col;
 8014c50:	68fb      	ldr	r3, [r7, #12]
 8014c52:	62bb      	str	r3, [r7, #40]	@ 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 8014c54:	2300      	movs	r3, #0
 8014c56:	63bb      	str	r3, [r7, #56]	@ 0x38
 8014c58:	e016      	b.n	8014c88 <decompress_onepass+0x150>
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
 8014c5a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014c5c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014c5e:	441a      	add	r2, r3
 8014c60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014c62:	3208      	adds	r2, #8
 8014c64:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	      (*inverse_DCT) (cinfo, compptr,
 8014c68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c6a:	9300      	str	r3, [sp, #0]
 8014c6c:	697c      	ldr	r4, [r7, #20]
 8014c6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014c70:	69b9      	ldr	r1, [r7, #24]
 8014c72:	6878      	ldr	r0, [r7, #4]
 8014c74:	47a0      	blx	r4
			      output_ptr, output_col);
	      output_col += compptr->DCT_h_scaled_size;
 8014c76:	69bb      	ldr	r3, [r7, #24]
 8014c78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014c7a:	461a      	mov	r2, r3
 8014c7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c7e:	4413      	add	r3, r2
 8014c80:	62bb      	str	r3, [r7, #40]	@ 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 8014c82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014c84:	3301      	adds	r3, #1
 8014c86:	63bb      	str	r3, [r7, #56]	@ 0x38
 8014c88:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8014c8a:	693b      	ldr	r3, [r7, #16]
 8014c8c:	429a      	cmp	r2, r3
 8014c8e:	dbe4      	blt.n	8014c5a <decompress_onepass+0x122>
	    }
	  }
	  blkn += compptr->MCU_width;
 8014c90:	69bb      	ldr	r3, [r7, #24]
 8014c92:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8014c94:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014c96:	4413      	add	r3, r2
 8014c98:	643b      	str	r3, [r7, #64]	@ 0x40
	  output_ptr += compptr->DCT_v_scaled_size;
 8014c9a:	69bb      	ldr	r3, [r7, #24]
 8014c9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014c9e:	009b      	lsls	r3, r3, #2
 8014ca0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8014ca2:	4413      	add	r3, r2
 8014ca4:	62fb      	str	r3, [r7, #44]	@ 0x2c
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8014ca6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014ca8:	3301      	adds	r3, #1
 8014caa:	637b      	str	r3, [r7, #52]	@ 0x34
 8014cac:	69bb      	ldr	r3, [r7, #24]
 8014cae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8014cb0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014cb2:	429a      	cmp	r2, r3
 8014cb4:	dbbf      	blt.n	8014c36 <decompress_onepass+0xfe>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014cb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cb8:	3301      	adds	r3, #1
 8014cba:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8014cbc:	687b      	ldr	r3, [r7, #4]
 8014cbe:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8014cc2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014cc4:	429a      	cmp	r2, r3
 8014cc6:	f6ff af7a 	blt.w	8014bbe <decompress_onepass+0x86>
	 MCU_col_num++) {
 8014cca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014ccc:	3301      	adds	r3, #1
 8014cce:	647b      	str	r3, [r7, #68]	@ 0x44
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 8014cd0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8014cd2:	6a3b      	ldr	r3, [r7, #32]
 8014cd4:	429a      	cmp	r2, r3
 8014cd6:	f67f af4a 	bls.w	8014b6e <decompress_onepass+0x36>
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 8014cda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014cdc:	2200      	movs	r2, #0
 8014cde:	615a      	str	r2, [r3, #20]
       yoffset++) {
 8014ce0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ce2:	3301      	adds	r3, #1
 8014ce4:	633b      	str	r3, [r7, #48]	@ 0x30
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8014ce6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014ce8:	69db      	ldr	r3, [r3, #28]
 8014cea:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014cec:	429a      	cmp	r2, r3
 8014cee:	f6ff af3a 	blt.w	8014b66 <decompress_onepass+0x2e>
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
 8014cf2:	687b      	ldr	r3, [r7, #4]
 8014cf4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8014cf8:	1c5a      	adds	r2, r3, #1
 8014cfa:	687b      	ldr	r3, [r7, #4]
 8014cfc:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 8014d00:	687b      	ldr	r3, [r7, #4]
 8014d02:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8014d06:	1c5a      	adds	r2, r3, #1
 8014d08:	687b      	ldr	r3, [r7, #4]
 8014d0a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 8014d0e:	687b      	ldr	r3, [r7, #4]
 8014d10:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8014d14:	687b      	ldr	r3, [r7, #4]
 8014d16:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8014d1a:	429a      	cmp	r2, r3
 8014d1c:	d204      	bcs.n	8014d28 <decompress_onepass+0x1f0>
    start_iMCU_row(cinfo);
 8014d1e:	6878      	ldr	r0, [r7, #4]
 8014d20:	f7ff fe9e 	bl	8014a60 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 8014d24:	2303      	movs	r3, #3
 8014d26:	e006      	b.n	8014d36 <decompress_onepass+0x1fe>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 8014d28:	687b      	ldr	r3, [r7, #4]
 8014d2a:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8014d2e:	68db      	ldr	r3, [r3, #12]
 8014d30:	6878      	ldr	r0, [r7, #4]
 8014d32:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 8014d34:	2304      	movs	r3, #4
}
 8014d36:	4618      	mov	r0, r3
 8014d38:	374c      	adds	r7, #76	@ 0x4c
 8014d3a:	46bd      	mov	sp, r7
 8014d3c:	bd90      	pop	{r4, r7, pc}

08014d3e <dummy_consume_data>:
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
 8014d3e:	b480      	push	{r7}
 8014d40:	b083      	sub	sp, #12
 8014d42:	af00      	add	r7, sp, #0
 8014d44:	6078      	str	r0, [r7, #4]
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
 8014d46:	2300      	movs	r3, #0
}
 8014d48:	4618      	mov	r0, r3
 8014d4a:	370c      	adds	r7, #12
 8014d4c:	46bd      	mov	sp, r7
 8014d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d52:	4770      	bx	lr

08014d54 <consume_data>:
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
 8014d54:	b590      	push	{r4, r7, lr}
 8014d56:	b093      	sub	sp, #76	@ 0x4c
 8014d58:	af02      	add	r7, sp, #8
 8014d5a:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8014d5c:	687b      	ldr	r3, [r7, #4]
 8014d5e:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8014d62:	623b      	str	r3, [r7, #32]
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014d64:	2300      	movs	r3, #0
 8014d66:	637b      	str	r3, [r7, #52]	@ 0x34
 8014d68:	e028      	b.n	8014dbc <consume_data+0x68>
    compptr = cinfo->cur_comp_info[ci];
 8014d6a:	687a      	ldr	r2, [r7, #4]
 8014d6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d6e:	3354      	adds	r3, #84	@ 0x54
 8014d70:	009b      	lsls	r3, r3, #2
 8014d72:	4413      	add	r3, r2
 8014d74:	685b      	ldr	r3, [r3, #4]
 8014d76:	61fb      	str	r3, [r7, #28]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 8014d78:	687b      	ldr	r3, [r7, #4]
 8014d7a:	685b      	ldr	r3, [r3, #4]
 8014d7c:	6a1c      	ldr	r4, [r3, #32]
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
 8014d7e:	69fb      	ldr	r3, [r7, #28]
 8014d80:	685a      	ldr	r2, [r3, #4]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 8014d82:	6a3b      	ldr	r3, [r7, #32]
 8014d84:	3212      	adds	r2, #18
 8014d86:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
       cinfo->input_iMCU_row * compptr->v_samp_factor,
 8014d8a:	687b      	ldr	r3, [r7, #4]
 8014d8c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8014d90:	69fa      	ldr	r2, [r7, #28]
 8014d92:	68d2      	ldr	r2, [r2, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 8014d94:	fb03 f202 	mul.w	r2, r3, r2
       (JDIMENSION) compptr->v_samp_factor, TRUE);
 8014d98:	69fb      	ldr	r3, [r7, #28]
 8014d9a:	68db      	ldr	r3, [r3, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 8014d9c:	4618      	mov	r0, r3
 8014d9e:	2301      	movs	r3, #1
 8014da0:	9300      	str	r3, [sp, #0]
 8014da2:	4603      	mov	r3, r0
 8014da4:	6878      	ldr	r0, [r7, #4]
 8014da6:	47a0      	blx	r4
 8014da8:	4602      	mov	r2, r0
 8014daa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014dac:	009b      	lsls	r3, r3, #2
 8014dae:	3340      	adds	r3, #64	@ 0x40
 8014db0:	443b      	add	r3, r7
 8014db2:	f843 2c38 	str.w	r2, [r3, #-56]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014db6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014db8:	3301      	adds	r3, #1
 8014dba:	637b      	str	r3, [r7, #52]	@ 0x34
 8014dbc:	687b      	ldr	r3, [r7, #4]
 8014dbe:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8014dc2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014dc4:	429a      	cmp	r2, r3
 8014dc6:	dbd0      	blt.n	8014d6a <consume_data+0x16>
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8014dc8:	6a3b      	ldr	r3, [r7, #32]
 8014dca:	699b      	ldr	r3, [r3, #24]
 8014dcc:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014dce:	e073      	b.n	8014eb8 <consume_data+0x164>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 8014dd0:	6a3b      	ldr	r3, [r7, #32]
 8014dd2:	695b      	ldr	r3, [r3, #20]
 8014dd4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8014dd6:	e063      	b.n	8014ea0 <consume_data+0x14c>
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
 8014dd8:	2300      	movs	r3, #0
 8014dda:	63bb      	str	r3, [r7, #56]	@ 0x38
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014ddc:	2300      	movs	r3, #0
 8014dde:	637b      	str	r3, [r7, #52]	@ 0x34
 8014de0:	e041      	b.n	8014e66 <consume_data+0x112>
	compptr = cinfo->cur_comp_info[ci];
 8014de2:	687a      	ldr	r2, [r7, #4]
 8014de4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014de6:	3354      	adds	r3, #84	@ 0x54
 8014de8:	009b      	lsls	r3, r3, #2
 8014dea:	4413      	add	r3, r2
 8014dec:	685b      	ldr	r3, [r3, #4]
 8014dee:	61fb      	str	r3, [r7, #28]
	start_col = MCU_col_num * compptr->MCU_width;
 8014df0:	69fb      	ldr	r3, [r7, #28]
 8014df2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8014df4:	461a      	mov	r2, r3
 8014df6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014df8:	fb02 f303 	mul.w	r3, r2, r3
 8014dfc:	61bb      	str	r3, [r7, #24]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8014dfe:	2300      	movs	r3, #0
 8014e00:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8014e02:	e028      	b.n	8014e56 <consume_data+0x102>
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
 8014e04:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014e06:	009b      	lsls	r3, r3, #2
 8014e08:	3340      	adds	r3, #64	@ 0x40
 8014e0a:	443b      	add	r3, r7
 8014e0c:	f853 2c38 	ldr.w	r2, [r3, #-56]
 8014e10:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014e12:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014e14:	440b      	add	r3, r1
 8014e16:	009b      	lsls	r3, r3, #2
 8014e18:	4413      	add	r3, r2
 8014e1a:	681a      	ldr	r2, [r3, #0]
 8014e1c:	69bb      	ldr	r3, [r7, #24]
 8014e1e:	01db      	lsls	r3, r3, #7
 8014e20:	4413      	add	r3, r2
 8014e22:	627b      	str	r3, [r7, #36]	@ 0x24
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 8014e24:	2300      	movs	r3, #0
 8014e26:	633b      	str	r3, [r7, #48]	@ 0x30
 8014e28:	e00d      	b.n	8014e46 <consume_data+0xf2>
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
 8014e2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014e2c:	f103 0280 	add.w	r2, r3, #128	@ 0x80
 8014e30:	627a      	str	r2, [r7, #36]	@ 0x24
 8014e32:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8014e34:	1c51      	adds	r1, r2, #1
 8014e36:	63b9      	str	r1, [r7, #56]	@ 0x38
 8014e38:	6a39      	ldr	r1, [r7, #32]
 8014e3a:	3208      	adds	r2, #8
 8014e3c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 8014e40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014e42:	3301      	adds	r3, #1
 8014e44:	633b      	str	r3, [r7, #48]	@ 0x30
 8014e46:	69fb      	ldr	r3, [r7, #28]
 8014e48:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8014e4a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014e4c:	429a      	cmp	r2, r3
 8014e4e:	dbec      	blt.n	8014e2a <consume_data+0xd6>
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 8014e50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014e52:	3301      	adds	r3, #1
 8014e54:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8014e56:	69fb      	ldr	r3, [r7, #28]
 8014e58:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8014e5a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8014e5c:	429a      	cmp	r2, r3
 8014e5e:	dbd1      	blt.n	8014e04 <consume_data+0xb0>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8014e60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014e62:	3301      	adds	r3, #1
 8014e64:	637b      	str	r3, [r7, #52]	@ 0x34
 8014e66:	687b      	ldr	r3, [r7, #4]
 8014e68:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8014e6c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014e6e:	429a      	cmp	r2, r3
 8014e70:	dbb7      	blt.n	8014de2 <consume_data+0x8e>
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 8014e72:	687b      	ldr	r3, [r7, #4]
 8014e74:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8014e78:	685b      	ldr	r3, [r3, #4]
 8014e7a:	6a3a      	ldr	r2, [r7, #32]
 8014e7c:	3220      	adds	r2, #32
 8014e7e:	4611      	mov	r1, r2
 8014e80:	6878      	ldr	r0, [r7, #4]
 8014e82:	4798      	blx	r3
 8014e84:	4603      	mov	r3, r0
 8014e86:	2b00      	cmp	r3, #0
 8014e88:	d107      	bne.n	8014e9a <consume_data+0x146>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 8014e8a:	6a3b      	ldr	r3, [r7, #32]
 8014e8c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014e8e:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 8014e90:	6a3b      	ldr	r3, [r7, #32]
 8014e92:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014e94:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 8014e96:	2300      	movs	r3, #0
 8014e98:	e02e      	b.n	8014ef8 <consume_data+0x1a4>
	 MCU_col_num++) {
 8014e9a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e9c:	3301      	adds	r3, #1
 8014e9e:	63fb      	str	r3, [r7, #60]	@ 0x3c
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 8014ea0:	687b      	ldr	r3, [r7, #4]
 8014ea2:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8014ea6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014ea8:	429a      	cmp	r2, r3
 8014eaa:	d395      	bcc.n	8014dd8 <consume_data+0x84>
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 8014eac:	6a3b      	ldr	r3, [r7, #32]
 8014eae:	2200      	movs	r2, #0
 8014eb0:	615a      	str	r2, [r3, #20]
       yoffset++) {
 8014eb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014eb4:	3301      	adds	r3, #1
 8014eb6:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 8014eb8:	6a3b      	ldr	r3, [r7, #32]
 8014eba:	69db      	ldr	r3, [r3, #28]
 8014ebc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8014ebe:	429a      	cmp	r2, r3
 8014ec0:	db86      	blt.n	8014dd0 <consume_data+0x7c>
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 8014ec2:	687b      	ldr	r3, [r7, #4]
 8014ec4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8014ec8:	1c5a      	adds	r2, r3, #1
 8014eca:	687b      	ldr	r3, [r7, #4]
 8014ecc:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 8014ed0:	687b      	ldr	r3, [r7, #4]
 8014ed2:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8014ed6:	687b      	ldr	r3, [r7, #4]
 8014ed8:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8014edc:	429a      	cmp	r2, r3
 8014ede:	d204      	bcs.n	8014eea <consume_data+0x196>
    start_iMCU_row(cinfo);
 8014ee0:	6878      	ldr	r0, [r7, #4]
 8014ee2:	f7ff fdbd 	bl	8014a60 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 8014ee6:	2303      	movs	r3, #3
 8014ee8:	e006      	b.n	8014ef8 <consume_data+0x1a4>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 8014eea:	687b      	ldr	r3, [r7, #4]
 8014eec:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8014ef0:	68db      	ldr	r3, [r3, #12]
 8014ef2:	6878      	ldr	r0, [r7, #4]
 8014ef4:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 8014ef6:	2304      	movs	r3, #4
}
 8014ef8:	4618      	mov	r0, r3
 8014efa:	3744      	adds	r7, #68	@ 0x44
 8014efc:	46bd      	mov	sp, r7
 8014efe:	bd90      	pop	{r4, r7, pc}

08014f00 <decompress_data>:
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 8014f00:	b590      	push	{r4, r7, lr}
 8014f02:	b091      	sub	sp, #68	@ 0x44
 8014f04:	af02      	add	r7, sp, #8
 8014f06:	6078      	str	r0, [r7, #4]
 8014f08:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 8014f0a:	687b      	ldr	r3, [r7, #4]
 8014f0c:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8014f10:	617b      	str	r3, [r7, #20]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 8014f12:	687b      	ldr	r3, [r7, #4]
 8014f14:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8014f18:	3b01      	subs	r3, #1
 8014f1a:	613b      	str	r3, [r7, #16]
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8014f1c:	e00a      	b.n	8014f34 <decompress_data+0x34>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 8014f1e:	687b      	ldr	r3, [r7, #4]
 8014f20:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8014f24:	681b      	ldr	r3, [r3, #0]
 8014f26:	6878      	ldr	r0, [r7, #4]
 8014f28:	4798      	blx	r3
 8014f2a:	4603      	mov	r3, r0
 8014f2c:	2b00      	cmp	r3, #0
 8014f2e:	d101      	bne.n	8014f34 <decompress_data+0x34>
      return JPEG_SUSPENDED;
 8014f30:	2300      	movs	r3, #0
 8014f32:	e0b6      	b.n	80150a2 <decompress_data+0x1a2>
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8014f34:	687b      	ldr	r3, [r7, #4]
 8014f36:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8014f3a:	687b      	ldr	r3, [r7, #4]
 8014f3c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8014f40:	429a      	cmp	r2, r3
 8014f42:	dbec      	blt.n	8014f1e <decompress_data+0x1e>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 8014f44:	687b      	ldr	r3, [r7, #4]
 8014f46:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8014f4a:	687b      	ldr	r3, [r7, #4]
 8014f4c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 8014f50:	429a      	cmp	r2, r3
 8014f52:	d107      	bne.n	8014f64 <decompress_data+0x64>
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
 8014f54:	687b      	ldr	r3, [r7, #4]
 8014f56:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8014f5a:	687b      	ldr	r3, [r7, #4]
 8014f5c:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 8014f60:	429a      	cmp	r2, r3
 8014f62:	d9dc      	bls.n	8014f1e <decompress_data+0x1e>
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8014f64:	2300      	movs	r3, #0
 8014f66:	633b      	str	r3, [r7, #48]	@ 0x30
 8014f68:	687b      	ldr	r3, [r7, #4]
 8014f6a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8014f6e:	61bb      	str	r3, [r7, #24]
 8014f70:	e07f      	b.n	8015072 <decompress_data+0x172>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 8014f72:	69bb      	ldr	r3, [r7, #24]
 8014f74:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8014f76:	2b00      	cmp	r3, #0
 8014f78:	d074      	beq.n	8015064 <decompress_data+0x164>
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
 8014f7a:	687b      	ldr	r3, [r7, #4]
 8014f7c:	685b      	ldr	r3, [r3, #4]
 8014f7e:	6a1c      	ldr	r4, [r3, #32]
 8014f80:	697b      	ldr	r3, [r7, #20]
 8014f82:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8014f84:	3212      	adds	r2, #18
 8014f86:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
 8014f8a:	687b      	ldr	r3, [r7, #4]
 8014f8c:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8014f90:	69ba      	ldr	r2, [r7, #24]
 8014f92:	68d2      	ldr	r2, [r2, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 8014f94:	fb03 f202 	mul.w	r2, r3, r2
       (JDIMENSION) compptr->v_samp_factor, FALSE);
 8014f98:	69bb      	ldr	r3, [r7, #24]
 8014f9a:	68db      	ldr	r3, [r3, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 8014f9c:	4618      	mov	r0, r3
 8014f9e:	2300      	movs	r3, #0
 8014fa0:	9300      	str	r3, [sp, #0]
 8014fa2:	4603      	mov	r3, r0
 8014fa4:	6878      	ldr	r0, [r7, #4]
 8014fa6:	47a0      	blx	r4
 8014fa8:	60f8      	str	r0, [r7, #12]
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
 8014faa:	687b      	ldr	r3, [r7, #4]
 8014fac:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8014fb0:	693a      	ldr	r2, [r7, #16]
 8014fb2:	429a      	cmp	r2, r3
 8014fb4:	d903      	bls.n	8014fbe <decompress_data+0xbe>
      block_rows = compptr->v_samp_factor;
 8014fb6:	69bb      	ldr	r3, [r7, #24]
 8014fb8:	68db      	ldr	r3, [r3, #12]
 8014fba:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014fbc:	e00f      	b.n	8014fde <decompress_data+0xde>
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 8014fbe:	69bb      	ldr	r3, [r7, #24]
 8014fc0:	6a1b      	ldr	r3, [r3, #32]
 8014fc2:	69ba      	ldr	r2, [r7, #24]
 8014fc4:	68d2      	ldr	r2, [r2, #12]
 8014fc6:	fbb3 f1f2 	udiv	r1, r3, r2
 8014fca:	fb01 f202 	mul.w	r2, r1, r2
 8014fce:	1a9b      	subs	r3, r3, r2
 8014fd0:	62bb      	str	r3, [r7, #40]	@ 0x28
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 8014fd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014fd4:	2b00      	cmp	r3, #0
 8014fd6:	d102      	bne.n	8014fde <decompress_data+0xde>
 8014fd8:	69bb      	ldr	r3, [r7, #24]
 8014fda:	68db      	ldr	r3, [r3, #12]
 8014fdc:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 8014fde:	687b      	ldr	r3, [r7, #4]
 8014fe0:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 8014fe4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fe6:	009b      	lsls	r3, r3, #2
 8014fe8:	4413      	add	r3, r2
 8014fea:	685b      	ldr	r3, [r3, #4]
 8014fec:	60bb      	str	r3, [r7, #8]
    output_ptr = output_buf[ci];
 8014fee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ff0:	009b      	lsls	r3, r3, #2
 8014ff2:	683a      	ldr	r2, [r7, #0]
 8014ff4:	4413      	add	r3, r2
 8014ff6:	681b      	ldr	r3, [r3, #0]
 8014ff8:	623b      	str	r3, [r7, #32]
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 8014ffa:	2300      	movs	r3, #0
 8014ffc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8014ffe:	e02c      	b.n	801505a <decompress_data+0x15a>
      buffer_ptr = buffer[block_row];
 8015000:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015002:	009b      	lsls	r3, r3, #2
 8015004:	68fa      	ldr	r2, [r7, #12]
 8015006:	4413      	add	r3, r2
 8015008:	681b      	ldr	r3, [r3, #0]
 801500a:	627b      	str	r3, [r7, #36]	@ 0x24
      output_col = 0;
 801500c:	2300      	movs	r3, #0
 801500e:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 8015010:	2300      	movs	r3, #0
 8015012:	637b      	str	r3, [r7, #52]	@ 0x34
 8015014:	e013      	b.n	801503e <decompress_data+0x13e>
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
 8015016:	69fb      	ldr	r3, [r7, #28]
 8015018:	9300      	str	r3, [sp, #0]
 801501a:	68bc      	ldr	r4, [r7, #8]
 801501c:	6a3b      	ldr	r3, [r7, #32]
 801501e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8015020:	69b9      	ldr	r1, [r7, #24]
 8015022:	6878      	ldr	r0, [r7, #4]
 8015024:	47a0      	blx	r4
			output_ptr, output_col);
	buffer_ptr++;
 8015026:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015028:	3380      	adds	r3, #128	@ 0x80
 801502a:	627b      	str	r3, [r7, #36]	@ 0x24
	output_col += compptr->DCT_h_scaled_size;
 801502c:	69bb      	ldr	r3, [r7, #24]
 801502e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015030:	461a      	mov	r2, r3
 8015032:	69fb      	ldr	r3, [r7, #28]
 8015034:	4413      	add	r3, r2
 8015036:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 8015038:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801503a:	3301      	adds	r3, #1
 801503c:	637b      	str	r3, [r7, #52]	@ 0x34
 801503e:	69bb      	ldr	r3, [r7, #24]
 8015040:	69db      	ldr	r3, [r3, #28]
 8015042:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015044:	429a      	cmp	r2, r3
 8015046:	d3e6      	bcc.n	8015016 <decompress_data+0x116>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 8015048:	69bb      	ldr	r3, [r7, #24]
 801504a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801504c:	009b      	lsls	r3, r3, #2
 801504e:	6a3a      	ldr	r2, [r7, #32]
 8015050:	4413      	add	r3, r2
 8015052:	623b      	str	r3, [r7, #32]
    for (block_row = 0; block_row < block_rows; block_row++) {
 8015054:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015056:	3301      	adds	r3, #1
 8015058:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801505a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801505c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801505e:	429a      	cmp	r2, r3
 8015060:	dbce      	blt.n	8015000 <decompress_data+0x100>
 8015062:	e000      	b.n	8015066 <decompress_data+0x166>
      continue;
 8015064:	bf00      	nop
       ci++, compptr++) {
 8015066:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015068:	3301      	adds	r3, #1
 801506a:	633b      	str	r3, [r7, #48]	@ 0x30
 801506c:	69bb      	ldr	r3, [r7, #24]
 801506e:	3358      	adds	r3, #88	@ 0x58
 8015070:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015072:	687b      	ldr	r3, [r7, #4]
 8015074:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015076:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015078:	429a      	cmp	r2, r3
 801507a:	f6ff af7a 	blt.w	8014f72 <decompress_data+0x72>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 801507e:	687b      	ldr	r3, [r7, #4]
 8015080:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8015084:	1c5a      	adds	r2, r3, #1
 8015086:	687b      	ldr	r3, [r7, #4]
 8015088:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
 801508c:	687b      	ldr	r3, [r7, #4]
 801508e:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 8015092:	687b      	ldr	r3, [r7, #4]
 8015094:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8015098:	429a      	cmp	r2, r3
 801509a:	d201      	bcs.n	80150a0 <decompress_data+0x1a0>
    return JPEG_ROW_COMPLETED;
 801509c:	2303      	movs	r3, #3
 801509e:	e000      	b.n	80150a2 <decompress_data+0x1a2>
  return JPEG_SCAN_COMPLETED;
 80150a0:	2304      	movs	r3, #4
}
 80150a2:	4618      	mov	r0, r3
 80150a4:	373c      	adds	r7, #60	@ 0x3c
 80150a6:	46bd      	mov	sp, r7
 80150a8:	bd90      	pop	{r4, r7, pc}

080150aa <smoothing_ok>:
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
 80150aa:	b590      	push	{r4, r7, lr}
 80150ac:	b08b      	sub	sp, #44	@ 0x2c
 80150ae:	af00      	add	r7, sp, #0
 80150b0:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 80150b2:	687b      	ldr	r3, [r7, #4]
 80150b4:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 80150b8:	613b      	str	r3, [r7, #16]
  boolean smoothing_useful = FALSE;
 80150ba:	2300      	movs	r3, #0
 80150bc:	627b      	str	r3, [r7, #36]	@ 0x24
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
 80150be:	687b      	ldr	r3, [r7, #4]
 80150c0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80150c4:	2b00      	cmp	r3, #0
 80150c6:	d004      	beq.n	80150d2 <smoothing_ok+0x28>
 80150c8:	687b      	ldr	r3, [r7, #4]
 80150ca:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80150ce:	2b00      	cmp	r3, #0
 80150d0:	d101      	bne.n	80150d6 <smoothing_ok+0x2c>
    return FALSE;
 80150d2:	2300      	movs	r3, #0
 80150d4:	e078      	b.n	80151c8 <smoothing_ok+0x11e>

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
 80150d6:	693b      	ldr	r3, [r7, #16]
 80150d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80150da:	2b00      	cmp	r3, #0
 80150dc:	d110      	bne.n	8015100 <smoothing_ok+0x56>
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80150de:	687b      	ldr	r3, [r7, #4]
 80150e0:	685b      	ldr	r3, [r3, #4]
 80150e2:	681c      	ldr	r4, [r3, #0]
				  cinfo->num_components *
 80150e4:	687b      	ldr	r3, [r7, #4]
 80150e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80150e8:	461a      	mov	r2, r3
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80150ea:	4613      	mov	r3, r2
 80150ec:	005b      	lsls	r3, r3, #1
 80150ee:	4413      	add	r3, r2
 80150f0:	00db      	lsls	r3, r3, #3
 80150f2:	461a      	mov	r2, r3
 80150f4:	2101      	movs	r1, #1
 80150f6:	6878      	ldr	r0, [r7, #4]
 80150f8:	47a0      	blx	r4
 80150fa:	4602      	mov	r2, r0
    coef->coef_bits_latch = (int *)
 80150fc:	693b      	ldr	r3, [r7, #16]
 80150fe:	671a      	str	r2, [r3, #112]	@ 0x70
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;
 8015100:	693b      	ldr	r3, [r7, #16]
 8015102:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8015104:	617b      	str	r3, [r7, #20]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015106:	2300      	movs	r3, #0
 8015108:	623b      	str	r3, [r7, #32]
 801510a:	687b      	ldr	r3, [r7, #4]
 801510c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8015110:	61bb      	str	r3, [r7, #24]
 8015112:	e053      	b.n	80151bc <smoothing_ok+0x112>
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
 8015114:	69bb      	ldr	r3, [r7, #24]
 8015116:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8015118:	60fb      	str	r3, [r7, #12]
 801511a:	68fb      	ldr	r3, [r7, #12]
 801511c:	2b00      	cmp	r3, #0
 801511e:	d101      	bne.n	8015124 <smoothing_ok+0x7a>
      return FALSE;
 8015120:	2300      	movs	r3, #0
 8015122:	e051      	b.n	80151c8 <smoothing_ok+0x11e>
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
 8015124:	68fb      	ldr	r3, [r7, #12]
 8015126:	881b      	ldrh	r3, [r3, #0]
 8015128:	2b00      	cmp	r3, #0
 801512a:	d013      	beq.n	8015154 <smoothing_ok+0xaa>
	qtable->quantval[Q01_POS] == 0 ||
 801512c:	68fb      	ldr	r3, [r7, #12]
 801512e:	885b      	ldrh	r3, [r3, #2]
    if (qtable->quantval[0] == 0 ||
 8015130:	2b00      	cmp	r3, #0
 8015132:	d00f      	beq.n	8015154 <smoothing_ok+0xaa>
	qtable->quantval[Q10_POS] == 0 ||
 8015134:	68fb      	ldr	r3, [r7, #12]
 8015136:	8a1b      	ldrh	r3, [r3, #16]
	qtable->quantval[Q01_POS] == 0 ||
 8015138:	2b00      	cmp	r3, #0
 801513a:	d00b      	beq.n	8015154 <smoothing_ok+0xaa>
	qtable->quantval[Q20_POS] == 0 ||
 801513c:	68fb      	ldr	r3, [r7, #12]
 801513e:	8c1b      	ldrh	r3, [r3, #32]
	qtable->quantval[Q10_POS] == 0 ||
 8015140:	2b00      	cmp	r3, #0
 8015142:	d007      	beq.n	8015154 <smoothing_ok+0xaa>
	qtable->quantval[Q11_POS] == 0 ||
 8015144:	68fb      	ldr	r3, [r7, #12]
 8015146:	8a5b      	ldrh	r3, [r3, #18]
	qtable->quantval[Q20_POS] == 0 ||
 8015148:	2b00      	cmp	r3, #0
 801514a:	d003      	beq.n	8015154 <smoothing_ok+0xaa>
	qtable->quantval[Q02_POS] == 0)
 801514c:	68fb      	ldr	r3, [r7, #12]
 801514e:	889b      	ldrh	r3, [r3, #4]
	qtable->quantval[Q11_POS] == 0 ||
 8015150:	2b00      	cmp	r3, #0
 8015152:	d101      	bne.n	8015158 <smoothing_ok+0xae>
      return FALSE;
 8015154:	2300      	movs	r3, #0
 8015156:	e037      	b.n	80151c8 <smoothing_ok+0x11e>
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
 8015158:	687b      	ldr	r3, [r7, #4]
 801515a:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 801515e:	6a3b      	ldr	r3, [r7, #32]
 8015160:	021b      	lsls	r3, r3, #8
 8015162:	4413      	add	r3, r2
 8015164:	60bb      	str	r3, [r7, #8]
    if (coef_bits[0] < 0)
 8015166:	68bb      	ldr	r3, [r7, #8]
 8015168:	681b      	ldr	r3, [r3, #0]
 801516a:	2b00      	cmp	r3, #0
 801516c:	da01      	bge.n	8015172 <smoothing_ok+0xc8>
      return FALSE;
 801516e:	2300      	movs	r3, #0
 8015170:	e02a      	b.n	80151c8 <smoothing_ok+0x11e>
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
 8015172:	2301      	movs	r3, #1
 8015174:	61fb      	str	r3, [r7, #28]
 8015176:	e015      	b.n	80151a4 <smoothing_ok+0xfa>
      coef_bits_latch[coefi] = coef_bits[coefi];
 8015178:	69fb      	ldr	r3, [r7, #28]
 801517a:	009b      	lsls	r3, r3, #2
 801517c:	68ba      	ldr	r2, [r7, #8]
 801517e:	441a      	add	r2, r3
 8015180:	69fb      	ldr	r3, [r7, #28]
 8015182:	009b      	lsls	r3, r3, #2
 8015184:	6979      	ldr	r1, [r7, #20]
 8015186:	440b      	add	r3, r1
 8015188:	6812      	ldr	r2, [r2, #0]
 801518a:	601a      	str	r2, [r3, #0]
      if (coef_bits[coefi] != 0)
 801518c:	69fb      	ldr	r3, [r7, #28]
 801518e:	009b      	lsls	r3, r3, #2
 8015190:	68ba      	ldr	r2, [r7, #8]
 8015192:	4413      	add	r3, r2
 8015194:	681b      	ldr	r3, [r3, #0]
 8015196:	2b00      	cmp	r3, #0
 8015198:	d001      	beq.n	801519e <smoothing_ok+0xf4>
	smoothing_useful = TRUE;
 801519a:	2301      	movs	r3, #1
 801519c:	627b      	str	r3, [r7, #36]	@ 0x24
    for (coefi = 1; coefi <= 5; coefi++) {
 801519e:	69fb      	ldr	r3, [r7, #28]
 80151a0:	3301      	adds	r3, #1
 80151a2:	61fb      	str	r3, [r7, #28]
 80151a4:	69fb      	ldr	r3, [r7, #28]
 80151a6:	2b05      	cmp	r3, #5
 80151a8:	dde6      	ble.n	8015178 <smoothing_ok+0xce>
    }
    coef_bits_latch += SAVED_COEFS;
 80151aa:	697b      	ldr	r3, [r7, #20]
 80151ac:	3318      	adds	r3, #24
 80151ae:	617b      	str	r3, [r7, #20]
       ci++, compptr++) {
 80151b0:	6a3b      	ldr	r3, [r7, #32]
 80151b2:	3301      	adds	r3, #1
 80151b4:	623b      	str	r3, [r7, #32]
 80151b6:	69bb      	ldr	r3, [r7, #24]
 80151b8:	3358      	adds	r3, #88	@ 0x58
 80151ba:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80151bc:	687b      	ldr	r3, [r7, #4]
 80151be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80151c0:	6a3a      	ldr	r2, [r7, #32]
 80151c2:	429a      	cmp	r2, r3
 80151c4:	dba6      	blt.n	8015114 <smoothing_ok+0x6a>
  }

  return smoothing_useful;
 80151c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80151c8:	4618      	mov	r0, r3
 80151ca:	372c      	adds	r7, #44	@ 0x2c
 80151cc:	46bd      	mov	sp, r7
 80151ce:	bd90      	pop	{r4, r7, pc}

080151d0 <decompress_smooth_data>:
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 80151d0:	b5b0      	push	{r4, r5, r7, lr}
 80151d2:	b0cc      	sub	sp, #304	@ 0x130
 80151d4:	af02      	add	r7, sp, #8
 80151d6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80151da:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80151de:	6018      	str	r0, [r3, #0]
 80151e0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80151e4:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80151e8:	6019      	str	r1, [r3, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 80151ea:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80151ee:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80151f2:	681b      	ldr	r3, [r3, #0]
 80151f4:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 80151f8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 80151fc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015200:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015204:	681b      	ldr	r3, [r3, #0]
 8015206:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801520a:	3b01      	subs	r3, #1
 801520c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 8015210:	e044      	b.n	801529c <decompress_smooth_data+0xcc>
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
 8015212:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015216:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801521a:	681b      	ldr	r3, [r3, #0]
 801521c:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8015220:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015224:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015228:	681b      	ldr	r3, [r3, #0]
 801522a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 801522e:	429a      	cmp	r2, r3
 8015230:	d120      	bne.n	8015274 <decompress_smooth_data+0xa4>
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
 8015232:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015236:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801523a:	681b      	ldr	r3, [r3, #0]
 801523c:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8015240:	2b00      	cmp	r3, #0
 8015242:	bf0c      	ite	eq
 8015244:	2301      	moveq	r3, #1
 8015246:	2300      	movne	r3, #0
 8015248:	b2db      	uxtb	r3, r3
 801524a:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
 801524e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015252:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015256:	681b      	ldr	r3, [r3, #0]
 8015258:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 801525c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015260:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015264:	681b      	ldr	r3, [r3, #0]
 8015266:	f8d3 109c 	ldr.w	r1, [r3, #156]	@ 0x9c
 801526a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801526e:	440b      	add	r3, r1
 8015270:	429a      	cmp	r2, r3
 8015272:	d82e      	bhi.n	80152d2 <decompress_smooth_data+0x102>
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 8015274:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015278:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801527c:	681b      	ldr	r3, [r3, #0]
 801527e:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8015282:	681b      	ldr	r3, [r3, #0]
 8015284:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8015288:	f5a2 7292 	sub.w	r2, r2, #292	@ 0x124
 801528c:	6810      	ldr	r0, [r2, #0]
 801528e:	4798      	blx	r3
 8015290:	4603      	mov	r3, r0
 8015292:	2b00      	cmp	r3, #0
 8015294:	d102      	bne.n	801529c <decompress_smooth_data+0xcc>
      return JPEG_SUSPENDED;
 8015296:	2300      	movs	r3, #0
 8015298:	f000 bca0 	b.w	8015bdc <decompress_smooth_data+0xa0c>
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 801529c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80152a0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80152a4:	681b      	ldr	r3, [r3, #0]
 80152a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 80152aa:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80152ae:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80152b2:	681b      	ldr	r3, [r3, #0]
 80152b4:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 80152b8:	429a      	cmp	r2, r3
 80152ba:	dc0b      	bgt.n	80152d4 <decompress_smooth_data+0x104>
	 ! cinfo->inputctl->eoi_reached) {
 80152bc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80152c0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80152c4:	681b      	ldr	r3, [r3, #0]
 80152c6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 80152ca:	695b      	ldr	r3, [r3, #20]
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 80152cc:	2b00      	cmp	r3, #0
 80152ce:	d0a0      	beq.n	8015212 <decompress_smooth_data+0x42>
 80152d0:	e000      	b.n	80152d4 <decompress_smooth_data+0x104>
	break;
 80152d2:	bf00      	nop
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80152d4:	2300      	movs	r3, #0
 80152d6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 80152da:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80152de:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80152e2:	681b      	ldr	r3, [r3, #0]
 80152e4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80152e8:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 80152ec:	f000 bc49 	b.w	8015b82 <decompress_smooth_data+0x9b2>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 80152f0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80152f4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80152f6:	2b00      	cmp	r3, #0
 80152f8:	f000 8438 	beq.w	8015b6c <decompress_smooth_data+0x99c>
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
 80152fc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015300:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015304:	681b      	ldr	r3, [r3, #0]
 8015306:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 801530a:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 801530e:	429a      	cmp	r2, r3
 8015310:	d90d      	bls.n	801532e <decompress_smooth_data+0x15e>
      block_rows = compptr->v_samp_factor;
 8015312:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015316:	68db      	ldr	r3, [r3, #12]
 8015318:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      access_rows = block_rows * 2; /* this and next iMCU row */
 801531c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8015320:	005b      	lsls	r3, r3, #1
 8015322:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      last_row = FALSE;
 8015326:	2300      	movs	r3, #0
 8015328:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 801532c:	e01c      	b.n	8015368 <decompress_smooth_data+0x198>
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 801532e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015332:	6a1b      	ldr	r3, [r3, #32]
 8015334:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8015338:	68d2      	ldr	r2, [r2, #12]
 801533a:	fbb3 f1f2 	udiv	r1, r3, r2
 801533e:	fb01 f202 	mul.w	r2, r1, r2
 8015342:	1a9b      	subs	r3, r3, r2
 8015344:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 8015348:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801534c:	2b00      	cmp	r3, #0
 801534e:	d104      	bne.n	801535a <decompress_smooth_data+0x18a>
 8015350:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015354:	68db      	ldr	r3, [r3, #12]
 8015356:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
      access_rows = block_rows; /* this iMCU row only */
 801535a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801535e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      last_row = TRUE;
 8015362:	2301      	movs	r3, #1
 8015364:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
 8015368:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801536c:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015370:	681b      	ldr	r3, [r3, #0]
 8015372:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8015376:	2b00      	cmp	r3, #0
 8015378:	d03b      	beq.n	80153f2 <decompress_smooth_data+0x222>
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
 801537a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801537e:	68db      	ldr	r3, [r3, #12]
 8015380:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8015384:	4413      	add	r3, r2
 8015386:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      buffer = (*cinfo->mem->access_virt_barray)
 801538a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801538e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015392:	681b      	ldr	r3, [r3, #0]
 8015394:	685b      	ldr	r3, [r3, #4]
 8015396:	6a1c      	ldr	r4, [r3, #32]
 8015398:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801539c:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80153a0:	3212      	adds	r2, #18
 80153a2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
 80153a6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80153aa:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80153ae:	681b      	ldr	r3, [r3, #0]
 80153b0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 80153b4:	3b01      	subs	r3, #1
 80153b6:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80153ba:	68d2      	ldr	r2, [r2, #12]
      buffer = (*cinfo->mem->access_virt_barray)
 80153bc:	fb03 f202 	mul.w	r2, r3, r2
 80153c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80153c4:	f507 7094 	add.w	r0, r7, #296	@ 0x128
 80153c8:	f5a0 7092 	sub.w	r0, r0, #292	@ 0x124
 80153cc:	2500      	movs	r5, #0
 80153ce:	9500      	str	r5, [sp, #0]
 80153d0:	6800      	ldr	r0, [r0, #0]
 80153d2:	47a0      	blx	r4
 80153d4:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
 80153d8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80153dc:	68db      	ldr	r3, [r3, #12]
 80153de:	009b      	lsls	r3, r3, #2
 80153e0:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80153e4:	4413      	add	r3, r2
 80153e6:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
      first_row = FALSE;
 80153ea:	2300      	movs	r3, #0
 80153ec:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 80153f0:	e01d      	b.n	801542e <decompress_smooth_data+0x25e>
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
 80153f2:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80153f6:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80153fa:	681b      	ldr	r3, [r3, #0]
 80153fc:	685b      	ldr	r3, [r3, #4]
 80153fe:	6a1c      	ldr	r4, [r3, #32]
 8015400:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8015404:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8015408:	3212      	adds	r2, #18
 801540a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801540e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8015412:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8015416:	f5a2 7092 	sub.w	r0, r2, #292	@ 0x124
 801541a:	2200      	movs	r2, #0
 801541c:	9200      	str	r2, [sp, #0]
 801541e:	2200      	movs	r2, #0
 8015420:	6800      	ldr	r0, [r0, #0]
 8015422:	47a0      	blx	r4
 8015424:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
 8015428:	2301      	movs	r3, #1
 801542a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
 801542e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8015432:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 8015434:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8015438:	4613      	mov	r3, r2
 801543a:	005b      	lsls	r3, r3, #1
 801543c:	4413      	add	r3, r2
 801543e:	00db      	lsls	r3, r3, #3
 8015440:	440b      	add	r3, r1
 8015442:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    quanttbl = compptr->quant_table;
 8015446:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801544a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801544c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    Q00 = quanttbl->quantval[0];
 8015450:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015454:	881b      	ldrh	r3, [r3, #0]
 8015456:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    Q01 = quanttbl->quantval[Q01_POS];
 801545a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801545e:	885b      	ldrh	r3, [r3, #2]
 8015460:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    Q10 = quanttbl->quantval[Q10_POS];
 8015464:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015468:	8a1b      	ldrh	r3, [r3, #16]
 801546a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    Q20 = quanttbl->quantval[Q20_POS];
 801546e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015472:	8c1b      	ldrh	r3, [r3, #32]
 8015474:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    Q11 = quanttbl->quantval[Q11_POS];
 8015478:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801547c:	8a5b      	ldrh	r3, [r3, #18]
 801547e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    Q02 = quanttbl->quantval[Q02_POS];
 8015482:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015486:	889b      	ldrh	r3, [r3, #4]
 8015488:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 801548c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015490:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015494:	681b      	ldr	r3, [r3, #0]
 8015496:	f8d3 21d4 	ldr.w	r2, [r3, #468]	@ 0x1d4
 801549a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801549e:	009b      	lsls	r3, r3, #2
 80154a0:	4413      	add	r3, r2
 80154a2:	685b      	ldr	r3, [r3, #4]
 80154a4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    output_ptr = output_buf[ci];
 80154a8:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80154ac:	009b      	lsls	r3, r3, #2
 80154ae:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 80154b2:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 80154b6:	6812      	ldr	r2, [r2, #0]
 80154b8:	4413      	add	r3, r2
 80154ba:	681b      	ldr	r3, [r3, #0]
 80154bc:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 80154c0:	2300      	movs	r3, #0
 80154c2:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 80154c6:	e349      	b.n	8015b5c <decompress_smooth_data+0x98c>
      buffer_ptr = buffer[block_row];
 80154c8:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154cc:	009b      	lsls	r3, r3, #2
 80154ce:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80154d2:	4413      	add	r3, r2
 80154d4:	681b      	ldr	r3, [r3, #0]
 80154d6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
      if (first_row && block_row == 0)
 80154da:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80154de:	2b00      	cmp	r3, #0
 80154e0:	d008      	beq.n	80154f4 <decompress_smooth_data+0x324>
 80154e2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154e6:	2b00      	cmp	r3, #0
 80154e8:	d104      	bne.n	80154f4 <decompress_smooth_data+0x324>
	prev_block_row = buffer_ptr;
 80154ea:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80154ee:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 80154f2:	e00b      	b.n	801550c <decompress_smooth_data+0x33c>
      else
	prev_block_row = buffer[block_row-1];
 80154f4:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154f8:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80154fc:	3b01      	subs	r3, #1
 80154fe:	009b      	lsls	r3, r3, #2
 8015500:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8015504:	4413      	add	r3, r2
 8015506:	681b      	ldr	r3, [r3, #0]
 8015508:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
      if (last_row && block_row == block_rows-1)
 801550c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8015510:	2b00      	cmp	r3, #0
 8015512:	d00b      	beq.n	801552c <decompress_smooth_data+0x35c>
 8015514:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8015518:	3b01      	subs	r3, #1
 801551a:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801551e:	429a      	cmp	r2, r3
 8015520:	d104      	bne.n	801552c <decompress_smooth_data+0x35c>
	next_block_row = buffer_ptr;
 8015522:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8015526:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 801552a:	e009      	b.n	8015540 <decompress_smooth_data+0x370>
      else
	next_block_row = buffer[block_row+1];
 801552c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015530:	3301      	adds	r3, #1
 8015532:	009b      	lsls	r3, r3, #2
 8015534:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8015538:	4413      	add	r3, r2
 801553a:	681b      	ldr	r3, [r3, #0]
 801553c:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
 8015540:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8015544:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015548:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 801554c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8015550:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 8015554:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8015558:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
 801555c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8015560:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015564:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8015568:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801556c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 8015570:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8015574:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
 8015578:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801557c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015580:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8015584:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015588:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801558c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8015590:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      output_col = 0;
 8015594:	2300      	movs	r3, #0
 8015596:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
      last_block_column = compptr->width_in_blocks - 1;
 801559a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801559e:	69db      	ldr	r3, [r3, #28]
 80155a0:	3b01      	subs	r3, #1
 80155a2:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 80155a6:	2300      	movs	r3, #0
 80155a8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 80155ac:	e2c1      	b.n	8015b32 <decompress_smooth_data+0x962>
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
 80155ae:	f107 030c 	add.w	r3, r7, #12
 80155b2:	2201      	movs	r2, #1
 80155b4:	4619      	mov	r1, r3
 80155b6:	f8d7 010c 	ldr.w	r0, [r7, #268]	@ 0x10c
 80155ba:	f019 fdbb 	bl	802f134 <jcopy_block_row>
	/* Update DC values */
	if (block_num < last_block_column) {
 80155be:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80155c2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80155c6:	429a      	cmp	r2, r3
 80155c8:	d214      	bcs.n	80155f4 <decompress_smooth_data+0x424>
	  DC3 = (int) prev_block_row[1][0];
 80155ca:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80155ce:	3380      	adds	r3, #128	@ 0x80
 80155d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80155d4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
	  DC6 = (int) buffer_ptr[1][0];
 80155d8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80155dc:	3380      	adds	r3, #128	@ 0x80
 80155de:	f9b3 3000 	ldrsh.w	r3, [r3]
 80155e2:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
	  DC9 = (int) next_block_row[1][0];
 80155e6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80155ea:	3380      	adds	r3, #128	@ 0x80
 80155ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 80155f0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
 80155f4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80155f8:	685b      	ldr	r3, [r3, #4]
 80155fa:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80155fe:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015602:	2b00      	cmp	r3, #0
 8015604:	d06c      	beq.n	80156e0 <decompress_smooth_data+0x510>
 8015606:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801560a:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801560e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015612:	2b00      	cmp	r3, #0
 8015614:	d164      	bne.n	80156e0 <decompress_smooth_data+0x510>
	  num = 36 * Q00 * (DC4 - DC6);
 8015616:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 801561a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801561e:	1ad3      	subs	r3, r2, r3
 8015620:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8015624:	fb03 f202 	mul.w	r2, r3, r2
 8015628:	4613      	mov	r3, r2
 801562a:	00db      	lsls	r3, r3, #3
 801562c:	4413      	add	r3, r2
 801562e:	009b      	lsls	r3, r3, #2
 8015630:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8015634:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015638:	2b00      	cmp	r3, #0
 801563a:	db22      	blt.n	8015682 <decompress_smooth_data+0x4b2>
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
 801563c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015640:	01da      	lsls	r2, r3, #7
 8015642:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015646:	441a      	add	r2, r3
 8015648:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801564c:	021b      	lsls	r3, r3, #8
 801564e:	fb92 f3f3 	sdiv	r3, r2, r3
 8015652:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015656:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801565a:	2b00      	cmp	r3, #0
 801565c:	dd38      	ble.n	80156d0 <decompress_smooth_data+0x500>
 801565e:	2201      	movs	r2, #1
 8015660:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015664:	fa02 f303 	lsl.w	r3, r2, r3
 8015668:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801566c:	429a      	cmp	r2, r3
 801566e:	db2f      	blt.n	80156d0 <decompress_smooth_data+0x500>
	      pred = (1<<Al)-1;
 8015670:	2201      	movs	r2, #1
 8015672:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015676:	fa02 f303 	lsl.w	r3, r2, r3
 801567a:	3b01      	subs	r3, #1
 801567c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8015680:	e026      	b.n	80156d0 <decompress_smooth_data+0x500>
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
 8015682:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015686:	01da      	lsls	r2, r3, #7
 8015688:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801568c:	1ad2      	subs	r2, r2, r3
 801568e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015692:	021b      	lsls	r3, r3, #8
 8015694:	fb92 f3f3 	sdiv	r3, r2, r3
 8015698:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801569c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80156a0:	2b00      	cmp	r3, #0
 80156a2:	dd10      	ble.n	80156c6 <decompress_smooth_data+0x4f6>
 80156a4:	2201      	movs	r2, #1
 80156a6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80156aa:	fa02 f303 	lsl.w	r3, r2, r3
 80156ae:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80156b2:	429a      	cmp	r2, r3
 80156b4:	db07      	blt.n	80156c6 <decompress_smooth_data+0x4f6>
	      pred = (1<<Al)-1;
 80156b6:	2201      	movs	r2, #1
 80156b8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80156bc:	fa02 f303 	lsl.w	r3, r2, r3
 80156c0:	3b01      	subs	r3, #1
 80156c2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80156c6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80156ca:	425b      	negs	r3, r3
 80156cc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[1] = (JCOEF) pred;
 80156d0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80156d4:	b21a      	sxth	r2, r3
 80156d6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80156da:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80156de:	805a      	strh	r2, [r3, #2]
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
 80156e0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80156e4:	689b      	ldr	r3, [r3, #8]
 80156e6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80156ea:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80156ee:	2b00      	cmp	r3, #0
 80156f0:	d06c      	beq.n	80157cc <decompress_smooth_data+0x5fc>
 80156f2:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80156f6:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80156fa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80156fe:	2b00      	cmp	r3, #0
 8015700:	d164      	bne.n	80157cc <decompress_smooth_data+0x5fc>
	  num = 36 * Q00 * (DC2 - DC8);
 8015702:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8015706:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801570a:	1ad3      	subs	r3, r2, r3
 801570c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8015710:	fb03 f202 	mul.w	r2, r3, r2
 8015714:	4613      	mov	r3, r2
 8015716:	00db      	lsls	r3, r3, #3
 8015718:	4413      	add	r3, r2
 801571a:	009b      	lsls	r3, r3, #2
 801571c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8015720:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015724:	2b00      	cmp	r3, #0
 8015726:	db22      	blt.n	801576e <decompress_smooth_data+0x59e>
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
 8015728:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801572c:	01da      	lsls	r2, r3, #7
 801572e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015732:	441a      	add	r2, r3
 8015734:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8015738:	021b      	lsls	r3, r3, #8
 801573a:	fb92 f3f3 	sdiv	r3, r2, r3
 801573e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015742:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015746:	2b00      	cmp	r3, #0
 8015748:	dd38      	ble.n	80157bc <decompress_smooth_data+0x5ec>
 801574a:	2201      	movs	r2, #1
 801574c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015750:	fa02 f303 	lsl.w	r3, r2, r3
 8015754:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015758:	429a      	cmp	r2, r3
 801575a:	db2f      	blt.n	80157bc <decompress_smooth_data+0x5ec>
	      pred = (1<<Al)-1;
 801575c:	2201      	movs	r2, #1
 801575e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015762:	fa02 f303 	lsl.w	r3, r2, r3
 8015766:	3b01      	subs	r3, #1
 8015768:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 801576c:	e026      	b.n	80157bc <decompress_smooth_data+0x5ec>
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
 801576e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8015772:	01da      	lsls	r2, r3, #7
 8015774:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015778:	1ad2      	subs	r2, r2, r3
 801577a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801577e:	021b      	lsls	r3, r3, #8
 8015780:	fb92 f3f3 	sdiv	r3, r2, r3
 8015784:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015788:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801578c:	2b00      	cmp	r3, #0
 801578e:	dd10      	ble.n	80157b2 <decompress_smooth_data+0x5e2>
 8015790:	2201      	movs	r2, #1
 8015792:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015796:	fa02 f303 	lsl.w	r3, r2, r3
 801579a:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801579e:	429a      	cmp	r2, r3
 80157a0:	db07      	blt.n	80157b2 <decompress_smooth_data+0x5e2>
	      pred = (1<<Al)-1;
 80157a2:	2201      	movs	r2, #1
 80157a4:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80157a8:	fa02 f303 	lsl.w	r3, r2, r3
 80157ac:	3b01      	subs	r3, #1
 80157ae:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80157b2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80157b6:	425b      	negs	r3, r3
 80157b8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[8] = (JCOEF) pred;
 80157bc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80157c0:	b21a      	sxth	r2, r3
 80157c2:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80157c6:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80157ca:	821a      	strh	r2, [r3, #16]
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
 80157cc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80157d0:	68db      	ldr	r3, [r3, #12]
 80157d2:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80157d6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80157da:	2b00      	cmp	r3, #0
 80157dc:	d06f      	beq.n	80158be <decompress_smooth_data+0x6ee>
 80157de:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80157e2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80157e6:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80157ea:	2b00      	cmp	r3, #0
 80157ec:	d167      	bne.n	80158be <decompress_smooth_data+0x6ee>
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
 80157ee:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 80157f2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80157f6:	441a      	add	r2, r3
 80157f8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80157fc:	005b      	lsls	r3, r3, #1
 80157fe:	1ad3      	subs	r3, r2, r3
 8015800:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8015804:	fb03 f202 	mul.w	r2, r3, r2
 8015808:	4613      	mov	r3, r2
 801580a:	00db      	lsls	r3, r3, #3
 801580c:	4413      	add	r3, r2
 801580e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8015812:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015816:	2b00      	cmp	r3, #0
 8015818:	db22      	blt.n	8015860 <decompress_smooth_data+0x690>
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
 801581a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801581e:	01da      	lsls	r2, r3, #7
 8015820:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015824:	441a      	add	r2, r3
 8015826:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801582a:	021b      	lsls	r3, r3, #8
 801582c:	fb92 f3f3 	sdiv	r3, r2, r3
 8015830:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015834:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015838:	2b00      	cmp	r3, #0
 801583a:	dd38      	ble.n	80158ae <decompress_smooth_data+0x6de>
 801583c:	2201      	movs	r2, #1
 801583e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015842:	fa02 f303 	lsl.w	r3, r2, r3
 8015846:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 801584a:	429a      	cmp	r2, r3
 801584c:	db2f      	blt.n	80158ae <decompress_smooth_data+0x6de>
	      pred = (1<<Al)-1;
 801584e:	2201      	movs	r2, #1
 8015850:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015854:	fa02 f303 	lsl.w	r3, r2, r3
 8015858:	3b01      	subs	r3, #1
 801585a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 801585e:	e026      	b.n	80158ae <decompress_smooth_data+0x6de>
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
 8015860:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8015864:	01da      	lsls	r2, r3, #7
 8015866:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801586a:	1ad2      	subs	r2, r2, r3
 801586c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8015870:	021b      	lsls	r3, r3, #8
 8015872:	fb92 f3f3 	sdiv	r3, r2, r3
 8015876:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801587a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801587e:	2b00      	cmp	r3, #0
 8015880:	dd10      	ble.n	80158a4 <decompress_smooth_data+0x6d4>
 8015882:	2201      	movs	r2, #1
 8015884:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015888:	fa02 f303 	lsl.w	r3, r2, r3
 801588c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015890:	429a      	cmp	r2, r3
 8015892:	db07      	blt.n	80158a4 <decompress_smooth_data+0x6d4>
	      pred = (1<<Al)-1;
 8015894:	2201      	movs	r2, #1
 8015896:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801589a:	fa02 f303 	lsl.w	r3, r2, r3
 801589e:	3b01      	subs	r3, #1
 80158a0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 80158a4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80158a8:	425b      	negs	r3, r3
 80158aa:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[16] = (JCOEF) pred;
 80158ae:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80158b2:	b21a      	sxth	r2, r3
 80158b4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80158b8:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80158bc:	841a      	strh	r2, [r3, #32]
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
 80158be:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80158c2:	691b      	ldr	r3, [r3, #16]
 80158c4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80158c8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80158cc:	2b00      	cmp	r3, #0
 80158ce:	d071      	beq.n	80159b4 <decompress_smooth_data+0x7e4>
 80158d0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80158d4:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80158d8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80158dc:	2b00      	cmp	r3, #0
 80158de:	d169      	bne.n	80159b4 <decompress_smooth_data+0x7e4>
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
 80158e0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80158e4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80158e8:	1ad2      	subs	r2, r2, r3
 80158ea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80158ee:	1ad2      	subs	r2, r2, r3
 80158f0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80158f4:	4413      	add	r3, r2
 80158f6:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80158fa:	fb03 f202 	mul.w	r2, r3, r2
 80158fe:	4613      	mov	r3, r2
 8015900:	009b      	lsls	r3, r3, #2
 8015902:	4413      	add	r3, r2
 8015904:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 8015908:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801590c:	2b00      	cmp	r3, #0
 801590e:	db22      	blt.n	8015956 <decompress_smooth_data+0x786>
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
 8015910:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8015914:	01da      	lsls	r2, r3, #7
 8015916:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801591a:	441a      	add	r2, r3
 801591c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8015920:	021b      	lsls	r3, r3, #8
 8015922:	fb92 f3f3 	sdiv	r3, r2, r3
 8015926:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 801592a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801592e:	2b00      	cmp	r3, #0
 8015930:	dd38      	ble.n	80159a4 <decompress_smooth_data+0x7d4>
 8015932:	2201      	movs	r2, #1
 8015934:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015938:	fa02 f303 	lsl.w	r3, r2, r3
 801593c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015940:	429a      	cmp	r2, r3
 8015942:	db2f      	blt.n	80159a4 <decompress_smooth_data+0x7d4>
	      pred = (1<<Al)-1;
 8015944:	2201      	movs	r2, #1
 8015946:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801594a:	fa02 f303 	lsl.w	r3, r2, r3
 801594e:	3b01      	subs	r3, #1
 8015950:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8015954:	e026      	b.n	80159a4 <decompress_smooth_data+0x7d4>
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
 8015956:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801595a:	01da      	lsls	r2, r3, #7
 801595c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015960:	1ad2      	subs	r2, r2, r3
 8015962:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8015966:	021b      	lsls	r3, r3, #8
 8015968:	fb92 f3f3 	sdiv	r3, r2, r3
 801596c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015970:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015974:	2b00      	cmp	r3, #0
 8015976:	dd10      	ble.n	801599a <decompress_smooth_data+0x7ca>
 8015978:	2201      	movs	r2, #1
 801597a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801597e:	fa02 f303 	lsl.w	r3, r2, r3
 8015982:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015986:	429a      	cmp	r2, r3
 8015988:	db07      	blt.n	801599a <decompress_smooth_data+0x7ca>
	      pred = (1<<Al)-1;
 801598a:	2201      	movs	r2, #1
 801598c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015990:	fa02 f303 	lsl.w	r3, r2, r3
 8015994:	3b01      	subs	r3, #1
 8015996:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 801599a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801599e:	425b      	negs	r3, r3
 80159a0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[9] = (JCOEF) pred;
 80159a4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80159a8:	b21a      	sxth	r2, r3
 80159aa:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80159ae:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80159b2:	825a      	strh	r2, [r3, #18]
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
 80159b4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80159b8:	695b      	ldr	r3, [r3, #20]
 80159ba:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80159be:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80159c2:	2b00      	cmp	r3, #0
 80159c4:	d06f      	beq.n	8015aa6 <decompress_smooth_data+0x8d6>
 80159c6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80159ca:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80159ce:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80159d2:	2b00      	cmp	r3, #0
 80159d4:	d167      	bne.n	8015aa6 <decompress_smooth_data+0x8d6>
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
 80159d6:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80159da:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80159de:	441a      	add	r2, r3
 80159e0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80159e4:	005b      	lsls	r3, r3, #1
 80159e6:	1ad3      	subs	r3, r2, r3
 80159e8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80159ec:	fb03 f202 	mul.w	r2, r3, r2
 80159f0:	4613      	mov	r3, r2
 80159f2:	00db      	lsls	r3, r3, #3
 80159f4:	4413      	add	r3, r2
 80159f6:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
	  if (num >= 0) {
 80159fa:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80159fe:	2b00      	cmp	r3, #0
 8015a00:	db22      	blt.n	8015a48 <decompress_smooth_data+0x878>
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
 8015a02:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8015a06:	01da      	lsls	r2, r3, #7
 8015a08:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015a0c:	441a      	add	r2, r3
 8015a0e:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8015a12:	021b      	lsls	r3, r3, #8
 8015a14:	fb92 f3f3 	sdiv	r3, r2, r3
 8015a18:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015a1c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a20:	2b00      	cmp	r3, #0
 8015a22:	dd38      	ble.n	8015a96 <decompress_smooth_data+0x8c6>
 8015a24:	2201      	movs	r2, #1
 8015a26:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a2a:	fa02 f303 	lsl.w	r3, r2, r3
 8015a2e:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015a32:	429a      	cmp	r2, r3
 8015a34:	db2f      	blt.n	8015a96 <decompress_smooth_data+0x8c6>
	      pred = (1<<Al)-1;
 8015a36:	2201      	movs	r2, #1
 8015a38:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a3c:	fa02 f303 	lsl.w	r3, r2, r3
 8015a40:	3b01      	subs	r3, #1
 8015a42:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8015a46:	e026      	b.n	8015a96 <decompress_smooth_data+0x8c6>
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
 8015a48:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8015a4c:	01da      	lsls	r2, r3, #7
 8015a4e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015a52:	1ad2      	subs	r2, r2, r3
 8015a54:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8015a58:	021b      	lsls	r3, r3, #8
 8015a5a:	fb92 f3f3 	sdiv	r3, r2, r3
 8015a5e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 8015a62:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a66:	2b00      	cmp	r3, #0
 8015a68:	dd10      	ble.n	8015a8c <decompress_smooth_data+0x8bc>
 8015a6a:	2201      	movs	r2, #1
 8015a6c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a70:	fa02 f303 	lsl.w	r3, r2, r3
 8015a74:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015a78:	429a      	cmp	r2, r3
 8015a7a:	db07      	blt.n	8015a8c <decompress_smooth_data+0x8bc>
	      pred = (1<<Al)-1;
 8015a7c:	2201      	movs	r2, #1
 8015a7e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015a82:	fa02 f303 	lsl.w	r3, r2, r3
 8015a86:	3b01      	subs	r3, #1
 8015a88:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	    pred = -pred;
 8015a8c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015a90:	425b      	negs	r3, r3
 8015a92:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
	  }
	  workspace[2] = (JCOEF) pred;
 8015a96:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015a9a:	b21a      	sxth	r2, r3
 8015a9c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015aa0:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8015aa4:	809a      	strh	r2, [r3, #4]
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
 8015aa6:	f107 020c 	add.w	r2, r7, #12
 8015aaa:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015aae:	f5a3 7092 	sub.w	r0, r3, #292	@ 0x124
 8015ab2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015ab6:	9300      	str	r3, [sp, #0]
 8015ab8:	f8d7 4098 	ldr.w	r4, [r7, #152]	@ 0x98
 8015abc:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8015ac0:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8015ac4:	6800      	ldr	r0, [r0, #0]
 8015ac6:	47a0      	blx	r4
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
 8015ac8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8015acc:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 8015ad0:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8015ad4:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
	DC4 = DC5; DC5 = DC6;
 8015ad8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8015adc:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8015ae0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8015ae4:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
	DC7 = DC8; DC8 = DC9;
 8015ae8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8015aec:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8015af0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015af4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
	buffer_ptr++, prev_block_row++, next_block_row++;
 8015af8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8015afc:	3380      	adds	r3, #128	@ 0x80
 8015afe:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 8015b02:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8015b06:	3380      	adds	r3, #128	@ 0x80
 8015b08:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8015b0c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015b10:	3380      	adds	r3, #128	@ 0x80
 8015b12:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
	output_col += compptr->DCT_h_scaled_size;
 8015b16:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015b1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015b1c:	461a      	mov	r2, r3
 8015b1e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015b22:	4413      	add	r3, r2
 8015b24:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 8015b28:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8015b2c:	3301      	adds	r3, #1
 8015b2e:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 8015b32:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8015b36:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8015b3a:	429a      	cmp	r2, r3
 8015b3c:	f67f ad37 	bls.w	80155ae <decompress_smooth_data+0x3de>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 8015b40:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015b44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015b46:	009b      	lsls	r3, r3, #2
 8015b48:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8015b4c:	4413      	add	r3, r2
 8015b4e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    for (block_row = 0; block_row < block_rows; block_row++) {
 8015b52:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015b56:	3301      	adds	r3, #1
 8015b58:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015b5c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8015b60:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8015b64:	429a      	cmp	r2, r3
 8015b66:	f6ff acaf 	blt.w	80154c8 <decompress_smooth_data+0x2f8>
 8015b6a:	e000      	b.n	8015b6e <decompress_smooth_data+0x99e>
      continue;
 8015b6c:	bf00      	nop
       ci++, compptr++) {
 8015b6e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8015b72:	3301      	adds	r3, #1
 8015b74:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8015b78:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015b7c:	3358      	adds	r3, #88	@ 0x58
 8015b7e:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015b82:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015b86:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015b8a:	681b      	ldr	r3, [r3, #0]
 8015b8c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015b8e:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8015b92:	429a      	cmp	r2, r3
 8015b94:	f6ff abac 	blt.w	80152f0 <decompress_smooth_data+0x120>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 8015b98:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015b9c:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015ba0:	681b      	ldr	r3, [r3, #0]
 8015ba2:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8015ba6:	1c5a      	adds	r2, r3, #1
 8015ba8:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015bac:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015bb0:	681b      	ldr	r3, [r3, #0]
 8015bb2:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
 8015bb6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015bba:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015bbe:	681b      	ldr	r3, [r3, #0]
 8015bc0:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 8015bc4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8015bc8:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015bcc:	681b      	ldr	r3, [r3, #0]
 8015bce:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8015bd2:	429a      	cmp	r2, r3
 8015bd4:	d201      	bcs.n	8015bda <decompress_smooth_data+0xa0a>
    return JPEG_ROW_COMPLETED;
 8015bd6:	2303      	movs	r3, #3
 8015bd8:	e000      	b.n	8015bdc <decompress_smooth_data+0xa0c>
  return JPEG_SCAN_COMPLETED;
 8015bda:	2304      	movs	r3, #4
}
 8015bdc:	4618      	mov	r0, r3
 8015bde:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 8015be2:	46bd      	mov	sp, r7
 8015be4:	bdb0      	pop	{r4, r5, r7, pc}
	...

08015be8 <jinit_d_coef_controller>:
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 8015be8:	b5b0      	push	{r4, r5, r7, lr}
 8015bea:	b08a      	sub	sp, #40	@ 0x28
 8015bec:	af02      	add	r7, sp, #8
 8015bee:	6078      	str	r0, [r7, #4]
 8015bf0:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015bf2:	687b      	ldr	r3, [r7, #4]
 8015bf4:	685b      	ldr	r3, [r3, #4]
 8015bf6:	681b      	ldr	r3, [r3, #0]
 8015bf8:	2274      	movs	r2, #116	@ 0x74
 8015bfa:	2101      	movs	r1, #1
 8015bfc:	6878      	ldr	r0, [r7, #4]
 8015bfe:	4798      	blx	r3
 8015c00:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
 8015c02:	687b      	ldr	r3, [r7, #4]
 8015c04:	68fa      	ldr	r2, [r7, #12]
 8015c06:	f8c3 21c0 	str.w	r2, [r3, #448]	@ 0x1c0
  coef->pub.start_input_pass = start_input_pass;
 8015c0a:	68fb      	ldr	r3, [r7, #12]
 8015c0c:	4a47      	ldr	r2, [pc, #284]	@ (8015d2c <jinit_d_coef_controller+0x144>)
 8015c0e:	601a      	str	r2, [r3, #0]
  coef->pub.start_output_pass = start_output_pass;
 8015c10:	68fb      	ldr	r3, [r7, #12]
 8015c12:	4a47      	ldr	r2, [pc, #284]	@ (8015d30 <jinit_d_coef_controller+0x148>)
 8015c14:	609a      	str	r2, [r3, #8]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
 8015c16:	68fb      	ldr	r3, [r7, #12]
 8015c18:	2200      	movs	r2, #0
 8015c1a:	671a      	str	r2, [r3, #112]	@ 0x70
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
 8015c1c:	683b      	ldr	r3, [r7, #0]
 8015c1e:	2b00      	cmp	r3, #0
 8015c20:	d051      	beq.n	8015cc6 <jinit_d_coef_controller+0xde>
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015c22:	2300      	movs	r3, #0
 8015c24:	61fb      	str	r3, [r7, #28]
 8015c26:	687b      	ldr	r3, [r7, #4]
 8015c28:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8015c2c:	617b      	str	r3, [r7, #20]
 8015c2e:	e039      	b.n	8015ca4 <jinit_d_coef_controller+0xbc>
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
 8015c30:	697b      	ldr	r3, [r7, #20]
 8015c32:	68db      	ldr	r3, [r3, #12]
 8015c34:	61bb      	str	r3, [r7, #24]
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
 8015c36:	687b      	ldr	r3, [r7, #4]
 8015c38:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8015c3c:	2b00      	cmp	r3, #0
 8015c3e:	d004      	beq.n	8015c4a <jinit_d_coef_controller+0x62>
	access_rows *= 3;
 8015c40:	69ba      	ldr	r2, [r7, #24]
 8015c42:	4613      	mov	r3, r2
 8015c44:	005b      	lsls	r3, r3, #1
 8015c46:	4413      	add	r3, r2
 8015c48:	61bb      	str	r3, [r7, #24]
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 8015c4a:	687b      	ldr	r3, [r7, #4]
 8015c4c:	685b      	ldr	r3, [r3, #4]
 8015c4e:	695c      	ldr	r4, [r3, #20]
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 8015c50:	697b      	ldr	r3, [r7, #20]
 8015c52:	69db      	ldr	r3, [r3, #28]
 8015c54:	461a      	mov	r2, r3
				(long) compptr->h_samp_factor),
 8015c56:	697b      	ldr	r3, [r7, #20]
 8015c58:	689b      	ldr	r3, [r3, #8]
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 8015c5a:	4619      	mov	r1, r3
 8015c5c:	4610      	mov	r0, r2
 8015c5e:	f019 fa27 	bl	802f0b0 <jround_up>
 8015c62:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 8015c64:	461d      	mov	r5, r3
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 8015c66:	697b      	ldr	r3, [r7, #20]
 8015c68:	6a1b      	ldr	r3, [r3, #32]
 8015c6a:	461a      	mov	r2, r3
				(long) compptr->v_samp_factor),
 8015c6c:	697b      	ldr	r3, [r7, #20]
 8015c6e:	68db      	ldr	r3, [r3, #12]
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 8015c70:	4619      	mov	r1, r3
 8015c72:	4610      	mov	r0, r2
 8015c74:	f019 fa1c 	bl	802f0b0 <jround_up>
 8015c78:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 8015c7a:	461a      	mov	r2, r3
 8015c7c:	69bb      	ldr	r3, [r7, #24]
 8015c7e:	9301      	str	r3, [sp, #4]
 8015c80:	9200      	str	r2, [sp, #0]
 8015c82:	462b      	mov	r3, r5
 8015c84:	2201      	movs	r2, #1
 8015c86:	2101      	movs	r1, #1
 8015c88:	6878      	ldr	r0, [r7, #4]
 8015c8a:	47a0      	blx	r4
 8015c8c:	4601      	mov	r1, r0
 8015c8e:	68fb      	ldr	r3, [r7, #12]
 8015c90:	69fa      	ldr	r2, [r7, #28]
 8015c92:	3212      	adds	r2, #18
 8015c94:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	 ci++, compptr++) {
 8015c98:	69fb      	ldr	r3, [r7, #28]
 8015c9a:	3301      	adds	r3, #1
 8015c9c:	61fb      	str	r3, [r7, #28]
 8015c9e:	697b      	ldr	r3, [r7, #20]
 8015ca0:	3358      	adds	r3, #88	@ 0x58
 8015ca2:	617b      	str	r3, [r7, #20]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015ca4:	687b      	ldr	r3, [r7, #4]
 8015ca6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015ca8:	69fa      	ldr	r2, [r7, #28]
 8015caa:	429a      	cmp	r2, r3
 8015cac:	dbc0      	blt.n	8015c30 <jinit_d_coef_controller+0x48>
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
 8015cae:	68fb      	ldr	r3, [r7, #12]
 8015cb0:	4a20      	ldr	r2, [pc, #128]	@ (8015d34 <jinit_d_coef_controller+0x14c>)
 8015cb2:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_data;
 8015cb4:	68fb      	ldr	r3, [r7, #12]
 8015cb6:	4a20      	ldr	r2, [pc, #128]	@ (8015d38 <jinit_d_coef_controller+0x150>)
 8015cb8:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
 8015cba:	68fb      	ldr	r3, [r7, #12]
 8015cbc:	f103 0248 	add.w	r2, r3, #72	@ 0x48
 8015cc0:	68fb      	ldr	r3, [r7, #12]
 8015cc2:	611a      	str	r2, [r3, #16]
	       (size_t) (D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK)));
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
 8015cc4:	e02e      	b.n	8015d24 <jinit_d_coef_controller+0x13c>
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015cc6:	687b      	ldr	r3, [r7, #4]
 8015cc8:	685b      	ldr	r3, [r3, #4]
 8015cca:	685b      	ldr	r3, [r3, #4]
 8015ccc:	f44f 62a0 	mov.w	r2, #1280	@ 0x500
 8015cd0:	2101      	movs	r1, #1
 8015cd2:	6878      	ldr	r0, [r7, #4]
 8015cd4:	4798      	blx	r3
 8015cd6:	60b8      	str	r0, [r7, #8]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 8015cd8:	2300      	movs	r3, #0
 8015cda:	613b      	str	r3, [r7, #16]
 8015cdc:	e00b      	b.n	8015cf6 <jinit_d_coef_controller+0x10e>
      coef->MCU_buffer[i] = buffer + i;
 8015cde:	693b      	ldr	r3, [r7, #16]
 8015ce0:	01db      	lsls	r3, r3, #7
 8015ce2:	68ba      	ldr	r2, [r7, #8]
 8015ce4:	18d1      	adds	r1, r2, r3
 8015ce6:	68fb      	ldr	r3, [r7, #12]
 8015ce8:	693a      	ldr	r2, [r7, #16]
 8015cea:	3208      	adds	r2, #8
 8015cec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 8015cf0:	693b      	ldr	r3, [r7, #16]
 8015cf2:	3301      	adds	r3, #1
 8015cf4:	613b      	str	r3, [r7, #16]
 8015cf6:	693b      	ldr	r3, [r7, #16]
 8015cf8:	2b09      	cmp	r3, #9
 8015cfa:	ddf0      	ble.n	8015cde <jinit_d_coef_controller+0xf6>
    if (cinfo->lim_Se == 0)	/* DC only case: want to bypass later */
 8015cfc:	687b      	ldr	r3, [r7, #4]
 8015cfe:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8015d02:	2b00      	cmp	r3, #0
 8015d04:	d105      	bne.n	8015d12 <jinit_d_coef_controller+0x12a>
      FMEMZERO((void FAR *) buffer,
 8015d06:	f44f 62a0 	mov.w	r2, #1280	@ 0x500
 8015d0a:	2100      	movs	r1, #0
 8015d0c:	68b8      	ldr	r0, [r7, #8]
 8015d0e:	f019 fe47 	bl	802f9a0 <memset>
    coef->pub.consume_data = dummy_consume_data;
 8015d12:	68fb      	ldr	r3, [r7, #12]
 8015d14:	4a09      	ldr	r2, [pc, #36]	@ (8015d3c <jinit_d_coef_controller+0x154>)
 8015d16:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_onepass;
 8015d18:	68fb      	ldr	r3, [r7, #12]
 8015d1a:	4a09      	ldr	r2, [pc, #36]	@ (8015d40 <jinit_d_coef_controller+0x158>)
 8015d1c:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
 8015d1e:	68fb      	ldr	r3, [r7, #12]
 8015d20:	2200      	movs	r2, #0
 8015d22:	611a      	str	r2, [r3, #16]
}
 8015d24:	bf00      	nop
 8015d26:	3720      	adds	r7, #32
 8015d28:	46bd      	mov	sp, r7
 8015d2a:	bdb0      	pop	{r4, r5, r7, pc}
 8015d2c:	08014ac7 	.word	0x08014ac7
 8015d30:	08014ae5 	.word	0x08014ae5
 8015d34:	08014d55 	.word	0x08014d55
 8015d38:	08014f01 	.word	0x08014f01
 8015d3c:	08014d3f 	.word	0x08014d3f
 8015d40:	08014b39 	.word	0x08014b39

08015d44 <build_ycc_rgb_table>:
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 8015d44:	b580      	push	{r7, lr}
 8015d46:	b086      	sub	sp, #24
 8015d48:	af00      	add	r7, sp, #0
 8015d4a:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8015d4c:	687b      	ldr	r3, [r7, #4]
 8015d4e:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8015d52:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015d54:	687b      	ldr	r3, [r7, #4]
 8015d56:	685b      	ldr	r3, [r3, #4]
 8015d58:	681b      	ldr	r3, [r3, #0]
 8015d5a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8015d5e:	2101      	movs	r1, #1
 8015d60:	6878      	ldr	r0, [r7, #4]
 8015d62:	4798      	blx	r3
 8015d64:	4602      	mov	r2, r0
  cconvert->Cr_r_tab = (int *)
 8015d66:	68fb      	ldr	r3, [r7, #12]
 8015d68:	609a      	str	r2, [r3, #8]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015d6a:	687b      	ldr	r3, [r7, #4]
 8015d6c:	685b      	ldr	r3, [r3, #4]
 8015d6e:	681b      	ldr	r3, [r3, #0]
 8015d70:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8015d74:	2101      	movs	r1, #1
 8015d76:	6878      	ldr	r0, [r7, #4]
 8015d78:	4798      	blx	r3
 8015d7a:	4602      	mov	r2, r0
  cconvert->Cb_b_tab = (int *)
 8015d7c:	68fb      	ldr	r3, [r7, #12]
 8015d7e:	60da      	str	r2, [r3, #12]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015d80:	687b      	ldr	r3, [r7, #4]
 8015d82:	685b      	ldr	r3, [r3, #4]
 8015d84:	681b      	ldr	r3, [r3, #0]
 8015d86:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8015d8a:	2101      	movs	r1, #1
 8015d8c:	6878      	ldr	r0, [r7, #4]
 8015d8e:	4798      	blx	r3
 8015d90:	4602      	mov	r2, r0
  cconvert->Cr_g_tab = (INT32 *)
 8015d92:	68fb      	ldr	r3, [r7, #12]
 8015d94:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015d96:	687b      	ldr	r3, [r7, #4]
 8015d98:	685b      	ldr	r3, [r3, #4]
 8015d9a:	681b      	ldr	r3, [r3, #0]
 8015d9c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8015da0:	2101      	movs	r1, #1
 8015da2:	6878      	ldr	r0, [r7, #4]
 8015da4:	4798      	blx	r3
 8015da6:	4602      	mov	r2, r0
  cconvert->Cb_g_tab = (INT32 *)
 8015da8:	68fb      	ldr	r3, [r7, #12]
 8015daa:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 8015dac:	2300      	movs	r3, #0
 8015dae:	617b      	str	r3, [r7, #20]
 8015db0:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 8015db4:	613b      	str	r3, [r7, #16]
 8015db6:	e035      	b.n	8015e24 <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 8015db8:	693b      	ldr	r3, [r7, #16]
 8015dba:	4a1e      	ldr	r2, [pc, #120]	@ (8015e34 <build_ycc_rgb_table+0xf0>)
 8015dbc:	fb02 f303 	mul.w	r3, r2, r3
 8015dc0:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    cconvert->Cr_r_tab[i] = (int)
 8015dc4:	68fb      	ldr	r3, [r7, #12]
 8015dc6:	6899      	ldr	r1, [r3, #8]
 8015dc8:	697b      	ldr	r3, [r7, #20]
 8015dca:	009b      	lsls	r3, r3, #2
 8015dcc:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 8015dce:	1412      	asrs	r2, r2, #16
    cconvert->Cr_r_tab[i] = (int)
 8015dd0:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 8015dd2:	693b      	ldr	r3, [r7, #16]
 8015dd4:	4a18      	ldr	r2, [pc, #96]	@ (8015e38 <build_ycc_rgb_table+0xf4>)
 8015dd6:	fb02 f303 	mul.w	r3, r2, r3
 8015dda:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    cconvert->Cb_b_tab[i] = (int)
 8015dde:	68fb      	ldr	r3, [r7, #12]
 8015de0:	68d9      	ldr	r1, [r3, #12]
 8015de2:	697b      	ldr	r3, [r7, #20]
 8015de4:	009b      	lsls	r3, r3, #2
 8015de6:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 8015de8:	1412      	asrs	r2, r2, #16
    cconvert->Cb_b_tab[i] = (int)
 8015dea:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 8015dec:	68fb      	ldr	r3, [r7, #12]
 8015dee:	691a      	ldr	r2, [r3, #16]
 8015df0:	697b      	ldr	r3, [r7, #20]
 8015df2:	009b      	lsls	r3, r3, #2
 8015df4:	4413      	add	r3, r2
 8015df6:	693a      	ldr	r2, [r7, #16]
 8015df8:	4910      	ldr	r1, [pc, #64]	@ (8015e3c <build_ycc_rgb_table+0xf8>)
 8015dfa:	fb01 f202 	mul.w	r2, r1, r2
 8015dfe:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 8015e00:	693b      	ldr	r3, [r7, #16]
 8015e02:	4a0f      	ldr	r2, [pc, #60]	@ (8015e40 <build_ycc_rgb_table+0xfc>)
 8015e04:	fb03 f202 	mul.w	r2, r3, r2
 8015e08:	68fb      	ldr	r3, [r7, #12]
 8015e0a:	6959      	ldr	r1, [r3, #20]
 8015e0c:	697b      	ldr	r3, [r7, #20]
 8015e0e:	009b      	lsls	r3, r3, #2
 8015e10:	440b      	add	r3, r1
 8015e12:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 8015e16:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 8015e18:	697b      	ldr	r3, [r7, #20]
 8015e1a:	3301      	adds	r3, #1
 8015e1c:	617b      	str	r3, [r7, #20]
 8015e1e:	693b      	ldr	r3, [r7, #16]
 8015e20:	3301      	adds	r3, #1
 8015e22:	613b      	str	r3, [r7, #16]
 8015e24:	697b      	ldr	r3, [r7, #20]
 8015e26:	2bff      	cmp	r3, #255	@ 0xff
 8015e28:	ddc6      	ble.n	8015db8 <build_ycc_rgb_table+0x74>
  }
}
 8015e2a:	bf00      	nop
 8015e2c:	bf00      	nop
 8015e2e:	3718      	adds	r7, #24
 8015e30:	46bd      	mov	sp, r7
 8015e32:	bd80      	pop	{r7, pc}
 8015e34:	000166e9 	.word	0x000166e9
 8015e38:	0001c5a2 	.word	0x0001c5a2
 8015e3c:	ffff492e 	.word	0xffff492e
 8015e40:	ffffa7e6 	.word	0xffffa7e6

08015e44 <ycc_rgb_convert>:

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
 8015e44:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8015e48:	b08d      	sub	sp, #52	@ 0x34
 8015e4a:	af00      	add	r7, sp, #0
 8015e4c:	6278      	str	r0, [r7, #36]	@ 0x24
 8015e4e:	6239      	str	r1, [r7, #32]
 8015e50:	61fa      	str	r2, [r7, #28]
 8015e52:	61bb      	str	r3, [r7, #24]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8015e54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015e56:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8015e5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8015e5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015e5e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8015e60:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 8015e62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015e64:	f8d3 614c 	ldr.w	r6, [r3, #332]	@ 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 8015e68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015e6a:	689b      	ldr	r3, [r3, #8]
 8015e6c:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 8015e6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015e70:	68db      	ldr	r3, [r3, #12]
 8015e72:	617b      	str	r3, [r7, #20]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 8015e74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015e76:	691b      	ldr	r3, [r3, #16]
 8015e78:	4619      	mov	r1, r3
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 8015e7a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015e7c:	695b      	ldr	r3, [r3, #20]
 8015e7e:	613b      	str	r3, [r7, #16]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 8015e80:	e053      	b.n	8015f2a <ycc_rgb_convert+0xe6>
    inptr0 = input_buf[0][input_row];
 8015e82:	6a3b      	ldr	r3, [r7, #32]
 8015e84:	681a      	ldr	r2, [r3, #0]
 8015e86:	69fb      	ldr	r3, [r7, #28]
 8015e88:	009b      	lsls	r3, r3, #2
 8015e8a:	4413      	add	r3, r2
 8015e8c:	681b      	ldr	r3, [r3, #0]
 8015e8e:	60fb      	str	r3, [r7, #12]
    inptr1 = input_buf[1][input_row];
 8015e90:	6a3b      	ldr	r3, [r7, #32]
 8015e92:	3304      	adds	r3, #4
 8015e94:	681a      	ldr	r2, [r3, #0]
 8015e96:	69fb      	ldr	r3, [r7, #28]
 8015e98:	009b      	lsls	r3, r3, #2
 8015e9a:	4413      	add	r3, r2
 8015e9c:	681b      	ldr	r3, [r3, #0]
 8015e9e:	60bb      	str	r3, [r7, #8]
    inptr2 = input_buf[2][input_row];
 8015ea0:	6a3b      	ldr	r3, [r7, #32]
 8015ea2:	3308      	adds	r3, #8
 8015ea4:	681a      	ldr	r2, [r3, #0]
 8015ea6:	69fb      	ldr	r3, [r7, #28]
 8015ea8:	009b      	lsls	r3, r3, #2
 8015eaa:	4413      	add	r3, r2
 8015eac:	681b      	ldr	r3, [r3, #0]
 8015eae:	607b      	str	r3, [r7, #4]
    input_row++;
 8015eb0:	69fb      	ldr	r3, [r7, #28]
 8015eb2:	3301      	adds	r3, #1
 8015eb4:	61fb      	str	r3, [r7, #28]
    outptr = *output_buf++;
 8015eb6:	69bb      	ldr	r3, [r7, #24]
 8015eb8:	1d1a      	adds	r2, r3, #4
 8015eba:	61ba      	str	r2, [r7, #24]
 8015ebc:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8015ebe:	2400      	movs	r4, #0
 8015ec0:	e030      	b.n	8015f24 <ycc_rgb_convert+0xe0>
      y  = GETJSAMPLE(inptr0[col]);
 8015ec2:	68fb      	ldr	r3, [r7, #12]
 8015ec4:	4423      	add	r3, r4
 8015ec6:	781b      	ldrb	r3, [r3, #0]
 8015ec8:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 8015eca:	68bb      	ldr	r3, [r7, #8]
 8015ecc:	4423      	add	r3, r4
 8015ece:	781b      	ldrb	r3, [r3, #0]
 8015ed0:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 8015ed2:	687b      	ldr	r3, [r7, #4]
 8015ed4:	4423      	add	r3, r4
 8015ed6:	781b      	ldrb	r3, [r3, #0]
 8015ed8:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
 8015eda:	464b      	mov	r3, r9
 8015edc:	009b      	lsls	r3, r3, #2
 8015ede:	4602      	mov	r2, r0
 8015ee0:	4413      	add	r3, r2
 8015ee2:	681b      	ldr	r3, [r3, #0]
 8015ee4:	4443      	add	r3, r8
 8015ee6:	4433      	add	r3, r6
 8015ee8:	781b      	ldrb	r3, [r3, #0]
 8015eea:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 8015eec:	4653      	mov	r3, sl
 8015eee:	009b      	lsls	r3, r3, #2
 8015ef0:	693a      	ldr	r2, [r7, #16]
 8015ef2:	4413      	add	r3, r2
 8015ef4:	681a      	ldr	r2, [r3, #0]
 8015ef6:	464b      	mov	r3, r9
 8015ef8:	009b      	lsls	r3, r3, #2
 8015efa:	440b      	add	r3, r1
 8015efc:	681b      	ldr	r3, [r3, #0]
 8015efe:	4413      	add	r3, r2
 8015f00:	141b      	asrs	r3, r3, #16
      outptr[RGB_GREEN] = range_limit[y +
 8015f02:	4443      	add	r3, r8
 8015f04:	4433      	add	r3, r6
 8015f06:	1c6a      	adds	r2, r5, #1
 8015f08:	781b      	ldrb	r3, [r3, #0]
 8015f0a:	7013      	strb	r3, [r2, #0]
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
 8015f0c:	4653      	mov	r3, sl
 8015f0e:	009b      	lsls	r3, r3, #2
 8015f10:	697a      	ldr	r2, [r7, #20]
 8015f12:	4413      	add	r3, r2
 8015f14:	681b      	ldr	r3, [r3, #0]
 8015f16:	4443      	add	r3, r8
 8015f18:	18f2      	adds	r2, r6, r3
 8015f1a:	1cab      	adds	r3, r5, #2
 8015f1c:	7812      	ldrb	r2, [r2, #0]
 8015f1e:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 8015f20:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 8015f22:	3401      	adds	r4, #1
 8015f24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015f26:	429c      	cmp	r4, r3
 8015f28:	d3cb      	bcc.n	8015ec2 <ycc_rgb_convert+0x7e>
  while (--num_rows >= 0) {
 8015f2a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015f2c:	3b01      	subs	r3, #1
 8015f2e:	653b      	str	r3, [r7, #80]	@ 0x50
 8015f30:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015f32:	2b00      	cmp	r3, #0
 8015f34:	daa5      	bge.n	8015e82 <ycc_rgb_convert+0x3e>
    }
  }
}
 8015f36:	bf00      	nop
 8015f38:	bf00      	nop
 8015f3a:	3734      	adds	r7, #52	@ 0x34
 8015f3c:	46bd      	mov	sp, r7
 8015f3e:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8015f42:	4770      	bx	lr

08015f44 <build_rgb_y_table>:
 * Initialize for RGB->grayscale colorspace conversion.
 */

LOCAL(void)
build_rgb_y_table (j_decompress_ptr cinfo)
{
 8015f44:	b580      	push	{r7, lr}
 8015f46:	b086      	sub	sp, #24
 8015f48:	af00      	add	r7, sp, #0
 8015f4a:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8015f4c:	687b      	ldr	r3, [r7, #4]
 8015f4e:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8015f52:	613b      	str	r3, [r7, #16]
  INT32 * rgb_y_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015f54:	687b      	ldr	r3, [r7, #4]
 8015f56:	685b      	ldr	r3, [r3, #4]
 8015f58:	681b      	ldr	r3, [r3, #0]
 8015f5a:	f44f 6240 	mov.w	r2, #3072	@ 0xc00
 8015f5e:	2101      	movs	r1, #1
 8015f60:	6878      	ldr	r0, [r7, #4]
 8015f62:	4798      	blx	r3
 8015f64:	60f8      	str	r0, [r7, #12]
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
 8015f66:	693b      	ldr	r3, [r7, #16]
 8015f68:	68fa      	ldr	r2, [r7, #12]
 8015f6a:	619a      	str	r2, [r3, #24]
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
 8015f6c:	2300      	movs	r3, #0
 8015f6e:	617b      	str	r3, [r7, #20]
 8015f70:	e026      	b.n	8015fc0 <build_rgb_y_table+0x7c>
    rgb_y_tab[i+R_Y_OFF] = FIX(0.29900) * i;
 8015f72:	697b      	ldr	r3, [r7, #20]
 8015f74:	009b      	lsls	r3, r3, #2
 8015f76:	68fa      	ldr	r2, [r7, #12]
 8015f78:	4413      	add	r3, r2
 8015f7a:	697a      	ldr	r2, [r7, #20]
 8015f7c:	f644 418b 	movw	r1, #19595	@ 0x4c8b
 8015f80:	fb01 f202 	mul.w	r2, r1, r2
 8015f84:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+G_Y_OFF] = FIX(0.58700) * i;
 8015f86:	697b      	ldr	r3, [r7, #20]
 8015f88:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8015f8c:	009b      	lsls	r3, r3, #2
 8015f8e:	68fa      	ldr	r2, [r7, #12]
 8015f90:	4413      	add	r3, r2
 8015f92:	697a      	ldr	r2, [r7, #20]
 8015f94:	f249 6146 	movw	r1, #38470	@ 0x9646
 8015f98:	fb01 f202 	mul.w	r2, r1, r2
 8015f9c:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;
 8015f9e:	697b      	ldr	r3, [r7, #20]
 8015fa0:	f641 522f 	movw	r2, #7471	@ 0x1d2f
 8015fa4:	fb03 f202 	mul.w	r2, r3, r2
 8015fa8:	697b      	ldr	r3, [r7, #20]
 8015faa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8015fae:	009b      	lsls	r3, r3, #2
 8015fb0:	68f9      	ldr	r1, [r7, #12]
 8015fb2:	440b      	add	r3, r1
 8015fb4:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 8015fb8:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++) {
 8015fba:	697b      	ldr	r3, [r7, #20]
 8015fbc:	3301      	adds	r3, #1
 8015fbe:	617b      	str	r3, [r7, #20]
 8015fc0:	697b      	ldr	r3, [r7, #20]
 8015fc2:	2bff      	cmp	r3, #255	@ 0xff
 8015fc4:	ddd5      	ble.n	8015f72 <build_rgb_y_table+0x2e>
  }
}
 8015fc6:	bf00      	nop
 8015fc8:	bf00      	nop
 8015fca:	3718      	adds	r7, #24
 8015fcc:	46bd      	mov	sp, r7
 8015fce:	bd80      	pop	{r7, pc}

08015fd0 <rgb_gray_convert>:

METHODDEF(void)
rgb_gray_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 8015fd0:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8015fd4:	b089      	sub	sp, #36	@ 0x24
 8015fd6:	af00      	add	r7, sp, #0
 8015fd8:	6178      	str	r0, [r7, #20]
 8015fda:	6139      	str	r1, [r7, #16]
 8015fdc:	60fa      	str	r2, [r7, #12]
 8015fde:	60bb      	str	r3, [r7, #8]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8015fe0:	697b      	ldr	r3, [r7, #20]
 8015fe2:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8015fe6:	61fb      	str	r3, [r7, #28]
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_y_tab;
 8015fe8:	69fb      	ldr	r3, [r7, #28]
 8015fea:	699d      	ldr	r5, [r3, #24]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 8015fec:	697b      	ldr	r3, [r7, #20]
 8015fee:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8015ff0:	61bb      	str	r3, [r7, #24]

  while (--num_rows >= 0) {
 8015ff2:	e045      	b.n	8016080 <rgb_gray_convert+0xb0>
    inptr0 = input_buf[0][input_row];
 8015ff4:	693b      	ldr	r3, [r7, #16]
 8015ff6:	681a      	ldr	r2, [r3, #0]
 8015ff8:	68fb      	ldr	r3, [r7, #12]
 8015ffa:	009b      	lsls	r3, r3, #2
 8015ffc:	4413      	add	r3, r2
 8015ffe:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 8016000:	693b      	ldr	r3, [r7, #16]
 8016002:	3304      	adds	r3, #4
 8016004:	681a      	ldr	r2, [r3, #0]
 8016006:	68fb      	ldr	r3, [r7, #12]
 8016008:	009b      	lsls	r3, r3, #2
 801600a:	4413      	add	r3, r2
 801600c:	681b      	ldr	r3, [r3, #0]
 801600e:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 8016010:	693b      	ldr	r3, [r7, #16]
 8016012:	3308      	adds	r3, #8
 8016014:	681a      	ldr	r2, [r3, #0]
 8016016:	68fb      	ldr	r3, [r7, #12]
 8016018:	009b      	lsls	r3, r3, #2
 801601a:	4413      	add	r3, r2
 801601c:	681b      	ldr	r3, [r3, #0]
 801601e:	4618      	mov	r0, r3
    input_row++;
 8016020:	68fb      	ldr	r3, [r7, #12]
 8016022:	3301      	adds	r3, #1
 8016024:	60fb      	str	r3, [r7, #12]
    outptr = *output_buf++;
 8016026:	68bb      	ldr	r3, [r7, #8]
 8016028:	1d1a      	adds	r2, r3, #4
 801602a:	60ba      	str	r2, [r7, #8]
 801602c:	681b      	ldr	r3, [r3, #0]
 801602e:	607b      	str	r3, [r7, #4]
    for (col = 0; col < num_cols; col++) {
 8016030:	2400      	movs	r4, #0
 8016032:	e022      	b.n	801607a <rgb_gray_convert+0xaa>
      r = GETJSAMPLE(inptr0[col]);
 8016034:	1933      	adds	r3, r6, r4
 8016036:	781b      	ldrb	r3, [r3, #0]
 8016038:	469a      	mov	sl, r3
      g = GETJSAMPLE(inptr1[col]);
 801603a:	460b      	mov	r3, r1
 801603c:	4423      	add	r3, r4
 801603e:	781b      	ldrb	r3, [r3, #0]
 8016040:	4699      	mov	r9, r3
      b = GETJSAMPLE(inptr2[col]);
 8016042:	4603      	mov	r3, r0
 8016044:	4423      	add	r3, r4
 8016046:	781b      	ldrb	r3, [r3, #0]
 8016048:	4698      	mov	r8, r3
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 801604a:	4653      	mov	r3, sl
 801604c:	009b      	lsls	r3, r3, #2
 801604e:	442b      	add	r3, r5
 8016050:	681a      	ldr	r2, [r3, #0]
 8016052:	464b      	mov	r3, r9
 8016054:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8016058:	009b      	lsls	r3, r3, #2
 801605a:	442b      	add	r3, r5
 801605c:	681b      	ldr	r3, [r3, #0]
 801605e:	441a      	add	r2, r3
 8016060:	4643      	mov	r3, r8
 8016062:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8016066:	009b      	lsls	r3, r3, #2
 8016068:	442b      	add	r3, r5
 801606a:	681b      	ldr	r3, [r3, #0]
 801606c:	4413      	add	r3, r2
		 >> SCALEBITS);
 801606e:	141a      	asrs	r2, r3, #16
      outptr[col] = (JSAMPLE)
 8016070:	687b      	ldr	r3, [r7, #4]
 8016072:	4423      	add	r3, r4
 8016074:	b2d2      	uxtb	r2, r2
 8016076:	701a      	strb	r2, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 8016078:	3401      	adds	r4, #1
 801607a:	69bb      	ldr	r3, [r7, #24]
 801607c:	429c      	cmp	r4, r3
 801607e:	d3d9      	bcc.n	8016034 <rgb_gray_convert+0x64>
  while (--num_rows >= 0) {
 8016080:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8016082:	3b01      	subs	r3, #1
 8016084:	643b      	str	r3, [r7, #64]	@ 0x40
 8016086:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8016088:	2b00      	cmp	r3, #0
 801608a:	dab3      	bge.n	8015ff4 <rgb_gray_convert+0x24>
    }
  }
}
 801608c:	bf00      	nop
 801608e:	bf00      	nop
 8016090:	3724      	adds	r7, #36	@ 0x24
 8016092:	46bd      	mov	sp, r7
 8016094:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8016098:	4770      	bx	lr

0801609a <rgb_convert>:

METHODDEF(void)
rgb_convert (j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION input_row,
	     JSAMPARRAY output_buf, int num_rows)
{
 801609a:	b4f0      	push	{r4, r5, r6, r7}
 801609c:	b086      	sub	sp, #24
 801609e:	af00      	add	r7, sp, #0
 80160a0:	60f8      	str	r0, [r7, #12]
 80160a2:	60b9      	str	r1, [r7, #8]
 80160a4:	607a      	str	r2, [r7, #4]
 80160a6:	603b      	str	r3, [r7, #0]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 80160a8:	68fb      	ldr	r3, [r7, #12]
 80160aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80160ac:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 80160ae:	e030      	b.n	8016112 <rgb_convert+0x78>
    inptr0 = input_buf[0][input_row];
 80160b0:	68bb      	ldr	r3, [r7, #8]
 80160b2:	681a      	ldr	r2, [r3, #0]
 80160b4:	687b      	ldr	r3, [r7, #4]
 80160b6:	009b      	lsls	r3, r3, #2
 80160b8:	4413      	add	r3, r2
 80160ba:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 80160bc:	68bb      	ldr	r3, [r7, #8]
 80160be:	3304      	adds	r3, #4
 80160c0:	681a      	ldr	r2, [r3, #0]
 80160c2:	687b      	ldr	r3, [r7, #4]
 80160c4:	009b      	lsls	r3, r3, #2
 80160c6:	4413      	add	r3, r2
 80160c8:	681b      	ldr	r3, [r3, #0]
 80160ca:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 80160cc:	68bb      	ldr	r3, [r7, #8]
 80160ce:	3308      	adds	r3, #8
 80160d0:	681a      	ldr	r2, [r3, #0]
 80160d2:	687b      	ldr	r3, [r7, #4]
 80160d4:	009b      	lsls	r3, r3, #2
 80160d6:	4413      	add	r3, r2
 80160d8:	681b      	ldr	r3, [r3, #0]
 80160da:	4618      	mov	r0, r3
    input_row++;
 80160dc:	687b      	ldr	r3, [r7, #4]
 80160de:	3301      	adds	r3, #1
 80160e0:	607b      	str	r3, [r7, #4]
    outptr = *output_buf++;
 80160e2:	683b      	ldr	r3, [r7, #0]
 80160e4:	1d1a      	adds	r2, r3, #4
 80160e6:	603a      	str	r2, [r7, #0]
 80160e8:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 80160ea:	2400      	movs	r4, #0
 80160ec:	e00e      	b.n	801610c <rgb_convert+0x72>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED]   = inptr0[col];
 80160ee:	1933      	adds	r3, r6, r4
 80160f0:	781b      	ldrb	r3, [r3, #0]
 80160f2:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = inptr1[col];
 80160f4:	460b      	mov	r3, r1
 80160f6:	191a      	adds	r2, r3, r4
 80160f8:	1c6b      	adds	r3, r5, #1
 80160fa:	7812      	ldrb	r2, [r2, #0]
 80160fc:	701a      	strb	r2, [r3, #0]
      outptr[RGB_BLUE]  = inptr2[col];
 80160fe:	4603      	mov	r3, r0
 8016100:	191a      	adds	r2, r3, r4
 8016102:	1cab      	adds	r3, r5, #2
 8016104:	7812      	ldrb	r2, [r2, #0]
 8016106:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 8016108:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 801610a:	3401      	adds	r4, #1
 801610c:	697b      	ldr	r3, [r7, #20]
 801610e:	429c      	cmp	r4, r3
 8016110:	d3ed      	bcc.n	80160ee <rgb_convert+0x54>
  while (--num_rows >= 0) {
 8016112:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016114:	3b01      	subs	r3, #1
 8016116:	62bb      	str	r3, [r7, #40]	@ 0x28
 8016118:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801611a:	2b00      	cmp	r3, #0
 801611c:	dac8      	bge.n	80160b0 <rgb_convert+0x16>
    }
  }
}
 801611e:	bf00      	nop
 8016120:	bf00      	nop
 8016122:	3718      	adds	r7, #24
 8016124:	46bd      	mov	sp, r7
 8016126:	bcf0      	pop	{r4, r5, r6, r7}
 8016128:	4770      	bx	lr

0801612a <null_convert>:

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
 801612a:	b4f0      	push	{r4, r5, r6, r7}
 801612c:	b086      	sub	sp, #24
 801612e:	af00      	add	r7, sp, #0
 8016130:	60f8      	str	r0, [r7, #12]
 8016132:	60b9      	str	r1, [r7, #8]
 8016134:	607a      	str	r2, [r7, #4]
 8016136:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
 8016138:	68fb      	ldr	r3, [r7, #12]
 801613a:	6a5e      	ldr	r6, [r3, #36]	@ 0x24
  JDIMENSION num_cols = cinfo->output_width;
 801613c:	68fb      	ldr	r3, [r7, #12]
 801613e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8016140:	613b      	str	r3, [r7, #16]
  int ci;

  while (--num_rows >= 0) {
 8016142:	e028      	b.n	8016196 <null_convert+0x6c>
    for (ci = 0; ci < num_components; ci++) {
 8016144:	2300      	movs	r3, #0
 8016146:	617b      	str	r3, [r7, #20]
 8016148:	e01c      	b.n	8016184 <null_convert+0x5a>
      inptr = input_buf[ci][input_row];
 801614a:	697b      	ldr	r3, [r7, #20]
 801614c:	009b      	lsls	r3, r3, #2
 801614e:	68ba      	ldr	r2, [r7, #8]
 8016150:	4413      	add	r3, r2
 8016152:	681a      	ldr	r2, [r3, #0]
 8016154:	687b      	ldr	r3, [r7, #4]
 8016156:	009b      	lsls	r3, r3, #2
 8016158:	4413      	add	r3, r2
 801615a:	681b      	ldr	r3, [r3, #0]
 801615c:	4619      	mov	r1, r3
      outptr = output_buf[0] + ci;
 801615e:	683b      	ldr	r3, [r7, #0]
 8016160:	681a      	ldr	r2, [r3, #0]
 8016162:	697b      	ldr	r3, [r7, #20]
 8016164:	18d5      	adds	r5, r2, r3
      for (count = num_cols; count > 0; count--) {
 8016166:	693c      	ldr	r4, [r7, #16]
 8016168:	e007      	b.n	801617a <null_convert+0x50>
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
 801616a:	460b      	mov	r3, r1
 801616c:	1c5a      	adds	r2, r3, #1
 801616e:	4611      	mov	r1, r2
 8016170:	781b      	ldrb	r3, [r3, #0]
 8016172:	702b      	strb	r3, [r5, #0]
	outptr += num_components;
 8016174:	4633      	mov	r3, r6
 8016176:	441d      	add	r5, r3
      for (count = num_cols; count > 0; count--) {
 8016178:	3c01      	subs	r4, #1
 801617a:	2c00      	cmp	r4, #0
 801617c:	d1f5      	bne.n	801616a <null_convert+0x40>
    for (ci = 0; ci < num_components; ci++) {
 801617e:	697b      	ldr	r3, [r7, #20]
 8016180:	3301      	adds	r3, #1
 8016182:	617b      	str	r3, [r7, #20]
 8016184:	697b      	ldr	r3, [r7, #20]
 8016186:	42b3      	cmp	r3, r6
 8016188:	dbdf      	blt.n	801614a <null_convert+0x20>
      }
    }
    input_row++;
 801618a:	687b      	ldr	r3, [r7, #4]
 801618c:	3301      	adds	r3, #1
 801618e:	607b      	str	r3, [r7, #4]
    output_buf++;
 8016190:	683b      	ldr	r3, [r7, #0]
 8016192:	3304      	adds	r3, #4
 8016194:	603b      	str	r3, [r7, #0]
  while (--num_rows >= 0) {
 8016196:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016198:	3b01      	subs	r3, #1
 801619a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801619c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801619e:	2b00      	cmp	r3, #0
 80161a0:	dad0      	bge.n	8016144 <null_convert+0x1a>
  }
}
 80161a2:	bf00      	nop
 80161a4:	bf00      	nop
 80161a6:	3718      	adds	r7, #24
 80161a8:	46bd      	mov	sp, r7
 80161aa:	bcf0      	pop	{r4, r5, r6, r7}
 80161ac:	4770      	bx	lr

080161ae <grayscale_convert>:

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 80161ae:	b580      	push	{r7, lr}
 80161b0:	b086      	sub	sp, #24
 80161b2:	af02      	add	r7, sp, #8
 80161b4:	60f8      	str	r0, [r7, #12]
 80161b6:	60b9      	str	r1, [r7, #8]
 80161b8:	607a      	str	r2, [r7, #4]
 80161ba:	603b      	str	r3, [r7, #0]
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
 80161bc:	68bb      	ldr	r3, [r7, #8]
 80161be:	6818      	ldr	r0, [r3, #0]
 80161c0:	6879      	ldr	r1, [r7, #4]
 80161c2:	68fb      	ldr	r3, [r7, #12]
 80161c4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80161c6:	9301      	str	r3, [sp, #4]
 80161c8:	69bb      	ldr	r3, [r7, #24]
 80161ca:	9300      	str	r3, [sp, #0]
 80161cc:	2300      	movs	r3, #0
 80161ce:	683a      	ldr	r2, [r7, #0]
 80161d0:	f018 ff88 	bl	802f0e4 <jcopy_sample_rows>
		    num_rows, cinfo->output_width);
}
 80161d4:	bf00      	nop
 80161d6:	3710      	adds	r7, #16
 80161d8:	46bd      	mov	sp, r7
 80161da:	bd80      	pop	{r7, pc}

080161dc <gray_rgb_convert>:

METHODDEF(void)
gray_rgb_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 80161dc:	b4f0      	push	{r4, r5, r6, r7}
 80161de:	b086      	sub	sp, #24
 80161e0:	af00      	add	r7, sp, #0
 80161e2:	60f8      	str	r0, [r7, #12]
 80161e4:	60b9      	str	r1, [r7, #8]
 80161e6:	607a      	str	r2, [r7, #4]
 80161e8:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 80161ea:	68fb      	ldr	r3, [r7, #12]
 80161ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80161ee:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 80161f0:	e01b      	b.n	801622a <gray_rgb_convert+0x4e>
    inptr = input_buf[0][input_row++];
 80161f2:	68bb      	ldr	r3, [r7, #8]
 80161f4:	681a      	ldr	r2, [r3, #0]
 80161f6:	687b      	ldr	r3, [r7, #4]
 80161f8:	1c59      	adds	r1, r3, #1
 80161fa:	6079      	str	r1, [r7, #4]
 80161fc:	009b      	lsls	r3, r3, #2
 80161fe:	4413      	add	r3, r2
 8016200:	681e      	ldr	r6, [r3, #0]
    outptr = *output_buf++;
 8016202:	683b      	ldr	r3, [r7, #0]
 8016204:	1d1a      	adds	r2, r3, #4
 8016206:	603a      	str	r2, [r7, #0]
 8016208:	681c      	ldr	r4, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 801620a:	2500      	movs	r5, #0
 801620c:	e00a      	b.n	8016224 <gray_rgb_convert+0x48>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
 801620e:	1973      	adds	r3, r6, r5
 8016210:	1ca2      	adds	r2, r4, #2
 8016212:	781b      	ldrb	r3, [r3, #0]
 8016214:	7013      	strb	r3, [r2, #0]
 8016216:	1c63      	adds	r3, r4, #1
 8016218:	7812      	ldrb	r2, [r2, #0]
 801621a:	701a      	strb	r2, [r3, #0]
 801621c:	781b      	ldrb	r3, [r3, #0]
 801621e:	7023      	strb	r3, [r4, #0]
      outptr += RGB_PIXELSIZE;
 8016220:	3403      	adds	r4, #3
    for (col = 0; col < num_cols; col++) {
 8016222:	3501      	adds	r5, #1
 8016224:	697b      	ldr	r3, [r7, #20]
 8016226:	429d      	cmp	r5, r3
 8016228:	d3f1      	bcc.n	801620e <gray_rgb_convert+0x32>
  while (--num_rows >= 0) {
 801622a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801622c:	3b01      	subs	r3, #1
 801622e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8016230:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016232:	2b00      	cmp	r3, #0
 8016234:	dadd      	bge.n	80161f2 <gray_rgb_convert+0x16>
    }
  }
}
 8016236:	bf00      	nop
 8016238:	bf00      	nop
 801623a:	3718      	adds	r7, #24
 801623c:	46bd      	mov	sp, r7
 801623e:	bcf0      	pop	{r4, r5, r6, r7}
 8016240:	4770      	bx	lr

08016242 <ycck_cmyk_convert>:

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 8016242:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8016246:	b08d      	sub	sp, #52	@ 0x34
 8016248:	af00      	add	r7, sp, #0
 801624a:	6278      	str	r0, [r7, #36]	@ 0x24
 801624c:	6239      	str	r1, [r7, #32]
 801624e:	61fa      	str	r2, [r7, #28]
 8016250:	61bb      	str	r3, [r7, #24]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 8016252:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016254:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 8016258:	62fb      	str	r3, [r7, #44]	@ 0x2c
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 801625a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801625c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801625e:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 8016260:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016262:	f8d3 614c 	ldr.w	r6, [r3, #332]	@ 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 8016266:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016268:	689b      	ldr	r3, [r3, #8]
 801626a:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 801626c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801626e:	68db      	ldr	r3, [r3, #12]
 8016270:	617b      	str	r3, [r7, #20]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 8016272:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016274:	691b      	ldr	r3, [r3, #16]
 8016276:	4619      	mov	r1, r3
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 8016278:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801627a:	695b      	ldr	r3, [r3, #20]
 801627c:	613b      	str	r3, [r7, #16]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 801627e:	e066      	b.n	801634e <ycck_cmyk_convert+0x10c>
    inptr0 = input_buf[0][input_row];
 8016280:	6a3b      	ldr	r3, [r7, #32]
 8016282:	681a      	ldr	r2, [r3, #0]
 8016284:	69fb      	ldr	r3, [r7, #28]
 8016286:	009b      	lsls	r3, r3, #2
 8016288:	4413      	add	r3, r2
 801628a:	681b      	ldr	r3, [r3, #0]
 801628c:	60fb      	str	r3, [r7, #12]
    inptr1 = input_buf[1][input_row];
 801628e:	6a3b      	ldr	r3, [r7, #32]
 8016290:	3304      	adds	r3, #4
 8016292:	681a      	ldr	r2, [r3, #0]
 8016294:	69fb      	ldr	r3, [r7, #28]
 8016296:	009b      	lsls	r3, r3, #2
 8016298:	4413      	add	r3, r2
 801629a:	681b      	ldr	r3, [r3, #0]
 801629c:	60bb      	str	r3, [r7, #8]
    inptr2 = input_buf[2][input_row];
 801629e:	6a3b      	ldr	r3, [r7, #32]
 80162a0:	3308      	adds	r3, #8
 80162a2:	681a      	ldr	r2, [r3, #0]
 80162a4:	69fb      	ldr	r3, [r7, #28]
 80162a6:	009b      	lsls	r3, r3, #2
 80162a8:	4413      	add	r3, r2
 80162aa:	681b      	ldr	r3, [r3, #0]
 80162ac:	607b      	str	r3, [r7, #4]
    inptr3 = input_buf[3][input_row];
 80162ae:	6a3b      	ldr	r3, [r7, #32]
 80162b0:	330c      	adds	r3, #12
 80162b2:	681a      	ldr	r2, [r3, #0]
 80162b4:	69fb      	ldr	r3, [r7, #28]
 80162b6:	009b      	lsls	r3, r3, #2
 80162b8:	4413      	add	r3, r2
 80162ba:	681b      	ldr	r3, [r3, #0]
 80162bc:	603b      	str	r3, [r7, #0]
    input_row++;
 80162be:	69fb      	ldr	r3, [r7, #28]
 80162c0:	3301      	adds	r3, #1
 80162c2:	61fb      	str	r3, [r7, #28]
    outptr = *output_buf++;
 80162c4:	69bb      	ldr	r3, [r7, #24]
 80162c6:	1d1a      	adds	r2, r3, #4
 80162c8:	61ba      	str	r2, [r7, #24]
 80162ca:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 80162cc:	2400      	movs	r4, #0
 80162ce:	e03b      	b.n	8016348 <ycck_cmyk_convert+0x106>
      y  = GETJSAMPLE(inptr0[col]);
 80162d0:	68fb      	ldr	r3, [r7, #12]
 80162d2:	4423      	add	r3, r4
 80162d4:	781b      	ldrb	r3, [r3, #0]
 80162d6:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 80162d8:	68bb      	ldr	r3, [r7, #8]
 80162da:	4423      	add	r3, r4
 80162dc:	781b      	ldrb	r3, [r3, #0]
 80162de:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 80162e0:	687b      	ldr	r3, [r7, #4]
 80162e2:	4423      	add	r3, r4
 80162e4:	781b      	ldrb	r3, [r3, #0]
 80162e6:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
 80162e8:	464b      	mov	r3, r9
 80162ea:	009b      	lsls	r3, r3, #2
 80162ec:	4602      	mov	r2, r0
 80162ee:	4413      	add	r3, r2
 80162f0:	681b      	ldr	r3, [r3, #0]
 80162f2:	4443      	add	r3, r8
 80162f4:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 80162f8:	4433      	add	r3, r6
 80162fa:	781b      	ldrb	r3, [r3, #0]
 80162fc:	702b      	strb	r3, [r5, #0]
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 80162fe:	4653      	mov	r3, sl
 8016300:	009b      	lsls	r3, r3, #2
 8016302:	693a      	ldr	r2, [r7, #16]
 8016304:	4413      	add	r3, r2
 8016306:	681a      	ldr	r2, [r3, #0]
 8016308:	464b      	mov	r3, r9
 801630a:	009b      	lsls	r3, r3, #2
 801630c:	440b      	add	r3, r1
 801630e:	681b      	ldr	r3, [r3, #0]
 8016310:	4413      	add	r3, r2
 8016312:	141b      	asrs	r3, r3, #16
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
 8016314:	4443      	add	r3, r8
 8016316:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801631a:	4433      	add	r3, r6
 801631c:	1c6a      	adds	r2, r5, #1
 801631e:	781b      	ldrb	r3, [r3, #0]
 8016320:	7013      	strb	r3, [r2, #0]
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
 8016322:	4653      	mov	r3, sl
 8016324:	009b      	lsls	r3, r3, #2
 8016326:	697a      	ldr	r2, [r7, #20]
 8016328:	4413      	add	r3, r2
 801632a:	681b      	ldr	r3, [r3, #0]
 801632c:	4443      	add	r3, r8
 801632e:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8016332:	18f2      	adds	r2, r6, r3
 8016334:	1cab      	adds	r3, r5, #2
 8016336:	7812      	ldrb	r2, [r2, #0]
 8016338:	701a      	strb	r2, [r3, #0]
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
 801633a:	683b      	ldr	r3, [r7, #0]
 801633c:	191a      	adds	r2, r3, r4
 801633e:	1ceb      	adds	r3, r5, #3
 8016340:	7812      	ldrb	r2, [r2, #0]
 8016342:	701a      	strb	r2, [r3, #0]
      outptr += 4;
 8016344:	3504      	adds	r5, #4
    for (col = 0; col < num_cols; col++) {
 8016346:	3401      	adds	r4, #1
 8016348:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801634a:	429c      	cmp	r4, r3
 801634c:	d3c0      	bcc.n	80162d0 <ycck_cmyk_convert+0x8e>
  while (--num_rows >= 0) {
 801634e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016350:	3b01      	subs	r3, #1
 8016352:	653b      	str	r3, [r7, #80]	@ 0x50
 8016354:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016356:	2b00      	cmp	r3, #0
 8016358:	da92      	bge.n	8016280 <ycck_cmyk_convert+0x3e>
    }
  }
}
 801635a:	bf00      	nop
 801635c:	bf00      	nop
 801635e:	3734      	adds	r7, #52	@ 0x34
 8016360:	46bd      	mov	sp, r7
 8016362:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8016366:	4770      	bx	lr

08016368 <start_pass_dcolor>:
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
 8016368:	b480      	push	{r7}
 801636a:	b083      	sub	sp, #12
 801636c:	af00      	add	r7, sp, #0
 801636e:	6078      	str	r0, [r7, #4]
  /* no work needed */
}
 8016370:	bf00      	nop
 8016372:	370c      	adds	r7, #12
 8016374:	46bd      	mov	sp, r7
 8016376:	f85d 7b04 	ldr.w	r7, [sp], #4
 801637a:	4770      	bx	lr

0801637c <jinit_color_deconverter>:
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
 801637c:	b580      	push	{r7, lr}
 801637e:	b084      	sub	sp, #16
 8016380:	af00      	add	r7, sp, #0
 8016382:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016384:	687b      	ldr	r3, [r7, #4]
 8016386:	685b      	ldr	r3, [r3, #4]
 8016388:	681b      	ldr	r3, [r3, #0]
 801638a:	221c      	movs	r2, #28
 801638c:	2101      	movs	r1, #1
 801638e:	6878      	ldr	r0, [r7, #4]
 8016390:	4798      	blx	r3
 8016392:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
 8016394:	687b      	ldr	r3, [r7, #4]
 8016396:	68ba      	ldr	r2, [r7, #8]
 8016398:	f8c3 21dc 	str.w	r2, [r3, #476]	@ 0x1dc
  cconvert->pub.start_pass = start_pass_dcolor;
 801639c:	68bb      	ldr	r3, [r7, #8]
 801639e:	4a88      	ldr	r2, [pc, #544]	@ (80165c0 <jinit_color_deconverter+0x244>)
 80163a0:	601a      	str	r2, [r3, #0]

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
 80163a2:	687b      	ldr	r3, [r7, #4]
 80163a4:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 80163a8:	2b05      	cmp	r3, #5
 80163aa:	dc33      	bgt.n	8016414 <jinit_color_deconverter+0x98>
 80163ac:	2b04      	cmp	r3, #4
 80163ae:	da23      	bge.n	80163f8 <jinit_color_deconverter+0x7c>
 80163b0:	2b01      	cmp	r3, #1
 80163b2:	d005      	beq.n	80163c0 <jinit_color_deconverter+0x44>
 80163b4:	2b00      	cmp	r3, #0
 80163b6:	dd2d      	ble.n	8016414 <jinit_color_deconverter+0x98>
 80163b8:	3b02      	subs	r3, #2
 80163ba:	2b01      	cmp	r3, #1
 80163bc:	d82a      	bhi.n	8016414 <jinit_color_deconverter+0x98>
 80163be:	e00d      	b.n	80163dc <jinit_color_deconverter+0x60>
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
 80163c0:	687b      	ldr	r3, [r7, #4]
 80163c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80163c4:	2b01      	cmp	r3, #1
 80163c6:	d033      	beq.n	8016430 <jinit_color_deconverter+0xb4>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 80163c8:	687b      	ldr	r3, [r7, #4]
 80163ca:	681b      	ldr	r3, [r3, #0]
 80163cc:	220b      	movs	r2, #11
 80163ce:	615a      	str	r2, [r3, #20]
 80163d0:	687b      	ldr	r3, [r7, #4]
 80163d2:	681b      	ldr	r3, [r3, #0]
 80163d4:	681b      	ldr	r3, [r3, #0]
 80163d6:	6878      	ldr	r0, [r7, #4]
 80163d8:	4798      	blx	r3
    break;
 80163da:	e029      	b.n	8016430 <jinit_color_deconverter+0xb4>

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
 80163dc:	687b      	ldr	r3, [r7, #4]
 80163de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80163e0:	2b03      	cmp	r3, #3
 80163e2:	d027      	beq.n	8016434 <jinit_color_deconverter+0xb8>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 80163e4:	687b      	ldr	r3, [r7, #4]
 80163e6:	681b      	ldr	r3, [r3, #0]
 80163e8:	220b      	movs	r2, #11
 80163ea:	615a      	str	r2, [r3, #20]
 80163ec:	687b      	ldr	r3, [r7, #4]
 80163ee:	681b      	ldr	r3, [r3, #0]
 80163f0:	681b      	ldr	r3, [r3, #0]
 80163f2:	6878      	ldr	r0, [r7, #4]
 80163f4:	4798      	blx	r3
    break;
 80163f6:	e01d      	b.n	8016434 <jinit_color_deconverter+0xb8>

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
 80163f8:	687b      	ldr	r3, [r7, #4]
 80163fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80163fc:	2b04      	cmp	r3, #4
 80163fe:	d01b      	beq.n	8016438 <jinit_color_deconverter+0xbc>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 8016400:	687b      	ldr	r3, [r7, #4]
 8016402:	681b      	ldr	r3, [r3, #0]
 8016404:	220b      	movs	r2, #11
 8016406:	615a      	str	r2, [r3, #20]
 8016408:	687b      	ldr	r3, [r7, #4]
 801640a:	681b      	ldr	r3, [r3, #0]
 801640c:	681b      	ldr	r3, [r3, #0]
 801640e:	6878      	ldr	r0, [r7, #4]
 8016410:	4798      	blx	r3
    break;
 8016412:	e011      	b.n	8016438 <jinit_color_deconverter+0xbc>

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
 8016414:	687b      	ldr	r3, [r7, #4]
 8016416:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8016418:	2b00      	cmp	r3, #0
 801641a:	dc0f      	bgt.n	801643c <jinit_color_deconverter+0xc0>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 801641c:	687b      	ldr	r3, [r7, #4]
 801641e:	681b      	ldr	r3, [r3, #0]
 8016420:	220b      	movs	r2, #11
 8016422:	615a      	str	r2, [r3, #20]
 8016424:	687b      	ldr	r3, [r7, #4]
 8016426:	681b      	ldr	r3, [r3, #0]
 8016428:	681b      	ldr	r3, [r3, #0]
 801642a:	6878      	ldr	r0, [r7, #4]
 801642c:	4798      	blx	r3
    break;
 801642e:	e005      	b.n	801643c <jinit_color_deconverter+0xc0>
    break;
 8016430:	bf00      	nop
 8016432:	e004      	b.n	801643e <jinit_color_deconverter+0xc2>
    break;
 8016434:	bf00      	nop
 8016436:	e002      	b.n	801643e <jinit_color_deconverter+0xc2>
    break;
 8016438:	bf00      	nop
 801643a:	e000      	b.n	801643e <jinit_color_deconverter+0xc2>
    break;
 801643c:	bf00      	nop
  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
 801643e:	687b      	ldr	r3, [r7, #4]
 8016440:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 8016444:	2b04      	cmp	r3, #4
 8016446:	d06f      	beq.n	8016528 <jinit_color_deconverter+0x1ac>
 8016448:	2b04      	cmp	r3, #4
 801644a:	f300 808f 	bgt.w	801656c <jinit_color_deconverter+0x1f0>
 801644e:	2b01      	cmp	r3, #1
 8016450:	d002      	beq.n	8016458 <jinit_color_deconverter+0xdc>
 8016452:	2b02      	cmp	r3, #2
 8016454:	d03d      	beq.n	80164d2 <jinit_color_deconverter+0x156>
 8016456:	e089      	b.n	801656c <jinit_color_deconverter+0x1f0>
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 8016458:	687b      	ldr	r3, [r7, #4]
 801645a:	2201      	movs	r2, #1
 801645c:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 801645e:	687b      	ldr	r3, [r7, #4]
 8016460:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8016464:	2b01      	cmp	r3, #1
 8016466:	d004      	beq.n	8016472 <jinit_color_deconverter+0xf6>
	cinfo->jpeg_color_space == JCS_YCbCr) {
 8016468:	687b      	ldr	r3, [r7, #4]
 801646a:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 801646e:	2b03      	cmp	r3, #3
 8016470:	d118      	bne.n	80164a4 <jinit_color_deconverter+0x128>
      cconvert->pub.color_convert = grayscale_convert;
 8016472:	68bb      	ldr	r3, [r7, #8]
 8016474:	4a53      	ldr	r2, [pc, #332]	@ (80165c4 <jinit_color_deconverter+0x248>)
 8016476:	605a      	str	r2, [r3, #4]
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
 8016478:	2301      	movs	r3, #1
 801647a:	60fb      	str	r3, [r7, #12]
 801647c:	e00c      	b.n	8016498 <jinit_color_deconverter+0x11c>
	cinfo->comp_info[ci].component_needed = FALSE;
 801647e:	687b      	ldr	r3, [r7, #4]
 8016480:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 8016484:	68fb      	ldr	r3, [r7, #12]
 8016486:	2158      	movs	r1, #88	@ 0x58
 8016488:	fb01 f303 	mul.w	r3, r1, r3
 801648c:	4413      	add	r3, r2
 801648e:	2200      	movs	r2, #0
 8016490:	635a      	str	r2, [r3, #52]	@ 0x34
      for (ci = 1; ci < cinfo->num_components; ci++)
 8016492:	68fb      	ldr	r3, [r7, #12]
 8016494:	3301      	adds	r3, #1
 8016496:	60fb      	str	r3, [r7, #12]
 8016498:	687b      	ldr	r3, [r7, #4]
 801649a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801649c:	68fa      	ldr	r2, [r7, #12]
 801649e:	429a      	cmp	r2, r3
 80164a0:	dbed      	blt.n	801647e <jinit_color_deconverter+0x102>
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 80164a2:	e015      	b.n	80164d0 <jinit_color_deconverter+0x154>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 80164a4:	687b      	ldr	r3, [r7, #4]
 80164a6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 80164aa:	2b02      	cmp	r3, #2
 80164ac:	d106      	bne.n	80164bc <jinit_color_deconverter+0x140>
      cconvert->pub.color_convert = rgb_gray_convert;
 80164ae:	68bb      	ldr	r3, [r7, #8]
 80164b0:	4a45      	ldr	r2, [pc, #276]	@ (80165c8 <jinit_color_deconverter+0x24c>)
 80164b2:	605a      	str	r2, [r3, #4]
      build_rgb_y_table(cinfo);
 80164b4:	6878      	ldr	r0, [r7, #4]
 80164b6:	f7ff fd45 	bl	8015f44 <build_rgb_y_table>
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 80164ba:	e071      	b.n	80165a0 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 80164bc:	687b      	ldr	r3, [r7, #4]
 80164be:	681b      	ldr	r3, [r3, #0]
 80164c0:	221c      	movs	r2, #28
 80164c2:	615a      	str	r2, [r3, #20]
 80164c4:	687b      	ldr	r3, [r7, #4]
 80164c6:	681b      	ldr	r3, [r3, #0]
 80164c8:	681b      	ldr	r3, [r3, #0]
 80164ca:	6878      	ldr	r0, [r7, #4]
 80164cc:	4798      	blx	r3
    break;
 80164ce:	e067      	b.n	80165a0 <jinit_color_deconverter+0x224>
 80164d0:	e066      	b.n	80165a0 <jinit_color_deconverter+0x224>

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 80164d2:	687b      	ldr	r3, [r7, #4]
 80164d4:	2203      	movs	r2, #3
 80164d6:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
 80164d8:	687b      	ldr	r3, [r7, #4]
 80164da:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 80164de:	2b03      	cmp	r3, #3
 80164e0:	d106      	bne.n	80164f0 <jinit_color_deconverter+0x174>
      cconvert->pub.color_convert = ycc_rgb_convert;
 80164e2:	68bb      	ldr	r3, [r7, #8]
 80164e4:	4a39      	ldr	r2, [pc, #228]	@ (80165cc <jinit_color_deconverter+0x250>)
 80164e6:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 80164e8:	6878      	ldr	r0, [r7, #4]
 80164ea:	f7ff fc2b 	bl	8015d44 <build_ycc_rgb_table>
      cconvert->pub.color_convert = gray_rgb_convert;
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
      cconvert->pub.color_convert = rgb_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 80164ee:	e057      	b.n	80165a0 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
 80164f0:	687b      	ldr	r3, [r7, #4]
 80164f2:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 80164f6:	2b01      	cmp	r3, #1
 80164f8:	d103      	bne.n	8016502 <jinit_color_deconverter+0x186>
      cconvert->pub.color_convert = gray_rgb_convert;
 80164fa:	68bb      	ldr	r3, [r7, #8]
 80164fc:	4a34      	ldr	r2, [pc, #208]	@ (80165d0 <jinit_color_deconverter+0x254>)
 80164fe:	605a      	str	r2, [r3, #4]
    break;
 8016500:	e04e      	b.n	80165a0 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 8016502:	687b      	ldr	r3, [r7, #4]
 8016504:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8016508:	2b02      	cmp	r3, #2
 801650a:	d103      	bne.n	8016514 <jinit_color_deconverter+0x198>
      cconvert->pub.color_convert = rgb_convert;
 801650c:	68bb      	ldr	r3, [r7, #8]
 801650e:	4a31      	ldr	r2, [pc, #196]	@ (80165d4 <jinit_color_deconverter+0x258>)
 8016510:	605a      	str	r2, [r3, #4]
    break;
 8016512:	e045      	b.n	80165a0 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 8016514:	687b      	ldr	r3, [r7, #4]
 8016516:	681b      	ldr	r3, [r3, #0]
 8016518:	221c      	movs	r2, #28
 801651a:	615a      	str	r2, [r3, #20]
 801651c:	687b      	ldr	r3, [r7, #4]
 801651e:	681b      	ldr	r3, [r3, #0]
 8016520:	681b      	ldr	r3, [r3, #0]
 8016522:	6878      	ldr	r0, [r7, #4]
 8016524:	4798      	blx	r3
    break;
 8016526:	e03b      	b.n	80165a0 <jinit_color_deconverter+0x224>

  case JCS_CMYK:
    cinfo->out_color_components = 4;
 8016528:	687b      	ldr	r3, [r7, #4]
 801652a:	2204      	movs	r2, #4
 801652c:	679a      	str	r2, [r3, #120]	@ 0x78
    if (cinfo->jpeg_color_space == JCS_YCCK) {
 801652e:	687b      	ldr	r3, [r7, #4]
 8016530:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8016534:	2b05      	cmp	r3, #5
 8016536:	d106      	bne.n	8016546 <jinit_color_deconverter+0x1ca>
      cconvert->pub.color_convert = ycck_cmyk_convert;
 8016538:	68bb      	ldr	r3, [r7, #8]
 801653a:	4a27      	ldr	r2, [pc, #156]	@ (80165d8 <jinit_color_deconverter+0x25c>)
 801653c:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 801653e:	6878      	ldr	r0, [r7, #4]
 8016540:	f7ff fc00 	bl	8015d44 <build_ycc_rgb_table>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 8016544:	e02c      	b.n	80165a0 <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
 8016546:	687b      	ldr	r3, [r7, #4]
 8016548:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801654c:	2b04      	cmp	r3, #4
 801654e:	d103      	bne.n	8016558 <jinit_color_deconverter+0x1dc>
      cconvert->pub.color_convert = null_convert;
 8016550:	68bb      	ldr	r3, [r7, #8]
 8016552:	4a22      	ldr	r2, [pc, #136]	@ (80165dc <jinit_color_deconverter+0x260>)
 8016554:	605a      	str	r2, [r3, #4]
    break;
 8016556:	e023      	b.n	80165a0 <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 8016558:	687b      	ldr	r3, [r7, #4]
 801655a:	681b      	ldr	r3, [r3, #0]
 801655c:	221c      	movs	r2, #28
 801655e:	615a      	str	r2, [r3, #20]
 8016560:	687b      	ldr	r3, [r7, #4]
 8016562:	681b      	ldr	r3, [r3, #0]
 8016564:	681b      	ldr	r3, [r3, #0]
 8016566:	6878      	ldr	r0, [r7, #4]
 8016568:	4798      	blx	r3
    break;
 801656a:	e019      	b.n	80165a0 <jinit_color_deconverter+0x224>

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
 801656c:	687b      	ldr	r3, [r7, #4]
 801656e:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 8016572:	687b      	ldr	r3, [r7, #4]
 8016574:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8016578:	429a      	cmp	r2, r3
 801657a:	d107      	bne.n	801658c <jinit_color_deconverter+0x210>
      cinfo->out_color_components = cinfo->num_components;
 801657c:	687b      	ldr	r3, [r7, #4]
 801657e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8016580:	687b      	ldr	r3, [r7, #4]
 8016582:	679a      	str	r2, [r3, #120]	@ 0x78
      cconvert->pub.color_convert = null_convert;
 8016584:	68bb      	ldr	r3, [r7, #8]
 8016586:	4a15      	ldr	r2, [pc, #84]	@ (80165dc <jinit_color_deconverter+0x260>)
 8016588:	605a      	str	r2, [r3, #4]
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 801658a:	e008      	b.n	801659e <jinit_color_deconverter+0x222>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 801658c:	687b      	ldr	r3, [r7, #4]
 801658e:	681b      	ldr	r3, [r3, #0]
 8016590:	221c      	movs	r2, #28
 8016592:	615a      	str	r2, [r3, #20]
 8016594:	687b      	ldr	r3, [r7, #4]
 8016596:	681b      	ldr	r3, [r3, #0]
 8016598:	681b      	ldr	r3, [r3, #0]
 801659a:	6878      	ldr	r0, [r7, #4]
 801659c:	4798      	blx	r3
    break;
 801659e:	bf00      	nop
  }

  if (cinfo->quantize_colors)
 80165a0:	687b      	ldr	r3, [r7, #4]
 80165a2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80165a4:	2b00      	cmp	r3, #0
 80165a6:	d003      	beq.n	80165b0 <jinit_color_deconverter+0x234>
    cinfo->output_components = 1; /* single colormapped output component */
 80165a8:	687b      	ldr	r3, [r7, #4]
 80165aa:	2201      	movs	r2, #1
 80165ac:	67da      	str	r2, [r3, #124]	@ 0x7c
  else
    cinfo->output_components = cinfo->out_color_components;
}
 80165ae:	e003      	b.n	80165b8 <jinit_color_deconverter+0x23c>
    cinfo->output_components = cinfo->out_color_components;
 80165b0:	687b      	ldr	r3, [r7, #4]
 80165b2:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 80165b4:	687b      	ldr	r3, [r7, #4]
 80165b6:	67da      	str	r2, [r3, #124]	@ 0x7c
}
 80165b8:	bf00      	nop
 80165ba:	3710      	adds	r7, #16
 80165bc:	46bd      	mov	sp, r7
 80165be:	bd80      	pop	{r7, pc}
 80165c0:	08016369 	.word	0x08016369
 80165c4:	080161af 	.word	0x080161af
 80165c8:	08015fd1 	.word	0x08015fd1
 80165cc:	08015e45 	.word	0x08015e45
 80165d0:	080161dd 	.word	0x080161dd
 80165d4:	0801609b 	.word	0x0801609b
 80165d8:	08016243 	.word	0x08016243
 80165dc:	0801612b 	.word	0x0801612b

080165e0 <start_pass>:
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 80165e0:	b590      	push	{r4, r7, lr}
 80165e2:	b08f      	sub	sp, #60	@ 0x3c
 80165e4:	af00      	add	r7, sp, #0
 80165e6:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
 80165e8:	687b      	ldr	r3, [r7, #4]
 80165ea:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
 80165ee:	61bb      	str	r3, [r7, #24]
  int ci, i;
  jpeg_component_info *compptr;
  int method = 0;
 80165f0:	2300      	movs	r3, #0
 80165f2:	62bb      	str	r3, [r7, #40]	@ 0x28
  inverse_DCT_method_ptr method_ptr = NULL;
 80165f4:	2300      	movs	r3, #0
 80165f6:	627b      	str	r3, [r7, #36]	@ 0x24
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80165f8:	2300      	movs	r3, #0
 80165fa:	637b      	str	r3, [r7, #52]	@ 0x34
 80165fc:	687b      	ldr	r3, [r7, #4]
 80165fe:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8016602:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8016604:	e30d      	b.n	8016c22 <start_pass+0x642>
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch ((compptr->DCT_h_scaled_size << 8) + compptr->DCT_v_scaled_size) {
 8016606:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016608:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801660a:	021a      	lsls	r2, r3, #8
 801660c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801660e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8016610:	4413      	add	r3, r2
 8016612:	f241 0210 	movw	r2, #4112	@ 0x1010
 8016616:	4293      	cmp	r3, r2
 8016618:	f000 8168 	beq.w	80168ec <start_pass+0x30c>
 801661c:	f241 0210 	movw	r2, #4112	@ 0x1010
 8016620:	4293      	cmp	r3, r2
 8016622:	f300 81de 	bgt.w	80169e2 <start_pass+0x402>
 8016626:	f241 0208 	movw	r2, #4104	@ 0x1008
 801662a:	4293      	cmp	r3, r2
 801662c:	f000 8163 	beq.w	80168f6 <start_pass+0x316>
 8016630:	f241 0208 	movw	r2, #4104	@ 0x1008
 8016634:	4293      	cmp	r3, r2
 8016636:	f300 81d4 	bgt.w	80169e2 <start_pass+0x402>
 801663a:	f640 720f 	movw	r2, #3855	@ 0xf0f
 801663e:	4293      	cmp	r3, r2
 8016640:	f000 814f 	beq.w	80168e2 <start_pass+0x302>
 8016644:	f5b3 6f71 	cmp.w	r3, #3856	@ 0xf10
 8016648:	f280 81cb 	bge.w	80169e2 <start_pass+0x402>
 801664c:	f640 620e 	movw	r2, #3598	@ 0xe0e
 8016650:	4293      	cmp	r3, r2
 8016652:	f000 8141 	beq.w	80168d8 <start_pass+0x2f8>
 8016656:	f640 620e 	movw	r2, #3598	@ 0xe0e
 801665a:	4293      	cmp	r3, r2
 801665c:	f300 81c1 	bgt.w	80169e2 <start_pass+0x402>
 8016660:	f640 6207 	movw	r2, #3591	@ 0xe07
 8016664:	4293      	cmp	r3, r2
 8016666:	f000 814b 	beq.w	8016900 <start_pass+0x320>
 801666a:	f640 6207 	movw	r2, #3591	@ 0xe07
 801666e:	4293      	cmp	r3, r2
 8016670:	f300 81b7 	bgt.w	80169e2 <start_pass+0x402>
 8016674:	f640 520d 	movw	r2, #3341	@ 0xd0d
 8016678:	4293      	cmp	r3, r2
 801667a:	f000 8128 	beq.w	80168ce <start_pass+0x2ee>
 801667e:	f640 520d 	movw	r2, #3341	@ 0xd0d
 8016682:	4293      	cmp	r3, r2
 8016684:	f300 81ad 	bgt.w	80169e2 <start_pass+0x402>
 8016688:	f640 420c 	movw	r2, #3084	@ 0xc0c
 801668c:	4293      	cmp	r3, r2
 801668e:	f000 8119 	beq.w	80168c4 <start_pass+0x2e4>
 8016692:	f640 420c 	movw	r2, #3084	@ 0xc0c
 8016696:	4293      	cmp	r3, r2
 8016698:	f300 81a3 	bgt.w	80169e2 <start_pass+0x402>
 801669c:	f640 4206 	movw	r2, #3078	@ 0xc06
 80166a0:	4293      	cmp	r3, r2
 80166a2:	f000 8132 	beq.w	801690a <start_pass+0x32a>
 80166a6:	f640 4206 	movw	r2, #3078	@ 0xc06
 80166aa:	4293      	cmp	r3, r2
 80166ac:	f300 8199 	bgt.w	80169e2 <start_pass+0x402>
 80166b0:	f640 320b 	movw	r2, #2827	@ 0xb0b
 80166b4:	4293      	cmp	r3, r2
 80166b6:	f000 8100 	beq.w	80168ba <start_pass+0x2da>
 80166ba:	f640 320b 	movw	r2, #2827	@ 0xb0b
 80166be:	4293      	cmp	r3, r2
 80166c0:	f300 818f 	bgt.w	80169e2 <start_pass+0x402>
 80166c4:	f640 220a 	movw	r2, #2570	@ 0xa0a
 80166c8:	4293      	cmp	r3, r2
 80166ca:	f000 80f1 	beq.w	80168b0 <start_pass+0x2d0>
 80166ce:	f640 220a 	movw	r2, #2570	@ 0xa0a
 80166d2:	4293      	cmp	r3, r2
 80166d4:	f300 8185 	bgt.w	80169e2 <start_pass+0x402>
 80166d8:	f640 2205 	movw	r2, #2565	@ 0xa05
 80166dc:	4293      	cmp	r3, r2
 80166de:	f000 8119 	beq.w	8016914 <start_pass+0x334>
 80166e2:	f640 2205 	movw	r2, #2565	@ 0xa05
 80166e6:	4293      	cmp	r3, r2
 80166e8:	f300 817b 	bgt.w	80169e2 <start_pass+0x402>
 80166ec:	f640 1209 	movw	r2, #2313	@ 0x909
 80166f0:	4293      	cmp	r3, r2
 80166f2:	f000 80d8 	beq.w	80168a6 <start_pass+0x2c6>
 80166f6:	f640 1209 	movw	r2, #2313	@ 0x909
 80166fa:	4293      	cmp	r3, r2
 80166fc:	f300 8171 	bgt.w	80169e2 <start_pass+0x402>
 8016700:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 8016704:	f000 811f 	beq.w	8016946 <start_pass+0x366>
 8016708:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 801670c:	f300 8169 	bgt.w	80169e2 <start_pass+0x402>
 8016710:	f640 0208 	movw	r2, #2056	@ 0x808
 8016714:	4293      	cmp	r3, r2
 8016716:	f000 813e 	beq.w	8016996 <start_pass+0x3b6>
 801671a:	f640 0208 	movw	r2, #2056	@ 0x808
 801671e:	4293      	cmp	r3, r2
 8016720:	f300 815f 	bgt.w	80169e2 <start_pass+0x402>
 8016724:	f640 0204 	movw	r2, #2052	@ 0x804
 8016728:	4293      	cmp	r3, r2
 801672a:	f000 80f8 	beq.w	801691e <start_pass+0x33e>
 801672e:	f640 0204 	movw	r2, #2052	@ 0x804
 8016732:	4293      	cmp	r3, r2
 8016734:	f300 8155 	bgt.w	80169e2 <start_pass+0x402>
 8016738:	f240 720e 	movw	r2, #1806	@ 0x70e
 801673c:	4293      	cmp	r3, r2
 801673e:	f000 8107 	beq.w	8016950 <start_pass+0x370>
 8016742:	f240 720e 	movw	r2, #1806	@ 0x70e
 8016746:	4293      	cmp	r3, r2
 8016748:	f300 814b 	bgt.w	80169e2 <start_pass+0x402>
 801674c:	f240 7207 	movw	r2, #1799	@ 0x707
 8016750:	4293      	cmp	r3, r2
 8016752:	f000 80a3 	beq.w	801689c <start_pass+0x2bc>
 8016756:	f5b3 6fe1 	cmp.w	r3, #1800	@ 0x708
 801675a:	f280 8142 	bge.w	80169e2 <start_pass+0x402>
 801675e:	f240 620c 	movw	r2, #1548	@ 0x60c
 8016762:	4293      	cmp	r3, r2
 8016764:	f000 80f9 	beq.w	801695a <start_pass+0x37a>
 8016768:	f240 620c 	movw	r2, #1548	@ 0x60c
 801676c:	4293      	cmp	r3, r2
 801676e:	f300 8138 	bgt.w	80169e2 <start_pass+0x402>
 8016772:	f240 6206 	movw	r2, #1542	@ 0x606
 8016776:	4293      	cmp	r3, r2
 8016778:	f000 808b 	beq.w	8016892 <start_pass+0x2b2>
 801677c:	f240 6206 	movw	r2, #1542	@ 0x606
 8016780:	4293      	cmp	r3, r2
 8016782:	f300 812e 	bgt.w	80169e2 <start_pass+0x402>
 8016786:	f240 6203 	movw	r2, #1539	@ 0x603
 801678a:	4293      	cmp	r3, r2
 801678c:	f000 80cc 	beq.w	8016928 <start_pass+0x348>
 8016790:	f240 6203 	movw	r2, #1539	@ 0x603
 8016794:	4293      	cmp	r3, r2
 8016796:	f300 8124 	bgt.w	80169e2 <start_pass+0x402>
 801679a:	f240 520a 	movw	r2, #1290	@ 0x50a
 801679e:	4293      	cmp	r3, r2
 80167a0:	f000 80e0 	beq.w	8016964 <start_pass+0x384>
 80167a4:	f240 520a 	movw	r2, #1290	@ 0x50a
 80167a8:	4293      	cmp	r3, r2
 80167aa:	f300 811a 	bgt.w	80169e2 <start_pass+0x402>
 80167ae:	f240 5205 	movw	r2, #1285	@ 0x505
 80167b2:	4293      	cmp	r3, r2
 80167b4:	d068      	beq.n	8016888 <start_pass+0x2a8>
 80167b6:	f240 5205 	movw	r2, #1285	@ 0x505
 80167ba:	4293      	cmp	r3, r2
 80167bc:	f300 8111 	bgt.w	80169e2 <start_pass+0x402>
 80167c0:	f5b3 6f81 	cmp.w	r3, #1032	@ 0x408
 80167c4:	f000 80d3 	beq.w	801696e <start_pass+0x38e>
 80167c8:	f5b3 6f81 	cmp.w	r3, #1032	@ 0x408
 80167cc:	f300 8109 	bgt.w	80169e2 <start_pass+0x402>
 80167d0:	f240 4204 	movw	r2, #1028	@ 0x404
 80167d4:	4293      	cmp	r3, r2
 80167d6:	d052      	beq.n	801687e <start_pass+0x29e>
 80167d8:	f240 4204 	movw	r2, #1028	@ 0x404
 80167dc:	4293      	cmp	r3, r2
 80167de:	f300 8100 	bgt.w	80169e2 <start_pass+0x402>
 80167e2:	f240 4202 	movw	r2, #1026	@ 0x402
 80167e6:	4293      	cmp	r3, r2
 80167e8:	f000 80a3 	beq.w	8016932 <start_pass+0x352>
 80167ec:	f240 4202 	movw	r2, #1026	@ 0x402
 80167f0:	4293      	cmp	r3, r2
 80167f2:	f300 80f6 	bgt.w	80169e2 <start_pass+0x402>
 80167f6:	f240 3206 	movw	r2, #774	@ 0x306
 80167fa:	4293      	cmp	r3, r2
 80167fc:	f000 80bc 	beq.w	8016978 <start_pass+0x398>
 8016800:	f240 3206 	movw	r2, #774	@ 0x306
 8016804:	4293      	cmp	r3, r2
 8016806:	f300 80ec 	bgt.w	80169e2 <start_pass+0x402>
 801680a:	f240 3203 	movw	r2, #771	@ 0x303
 801680e:	4293      	cmp	r3, r2
 8016810:	d030      	beq.n	8016874 <start_pass+0x294>
 8016812:	f5b3 7f41 	cmp.w	r3, #772	@ 0x304
 8016816:	f280 80e4 	bge.w	80169e2 <start_pass+0x402>
 801681a:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 801681e:	f000 80b0 	beq.w	8016982 <start_pass+0x3a2>
 8016822:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 8016826:	f300 80dc 	bgt.w	80169e2 <start_pass+0x402>
 801682a:	f240 2202 	movw	r2, #514	@ 0x202
 801682e:	4293      	cmp	r3, r2
 8016830:	d01b      	beq.n	801686a <start_pass+0x28a>
 8016832:	f240 2202 	movw	r2, #514	@ 0x202
 8016836:	4293      	cmp	r3, r2
 8016838:	f300 80d3 	bgt.w	80169e2 <start_pass+0x402>
 801683c:	f240 2201 	movw	r2, #513	@ 0x201
 8016840:	4293      	cmp	r3, r2
 8016842:	d07b      	beq.n	801693c <start_pass+0x35c>
 8016844:	f240 2201 	movw	r2, #513	@ 0x201
 8016848:	4293      	cmp	r3, r2
 801684a:	f300 80ca 	bgt.w	80169e2 <start_pass+0x402>
 801684e:	f240 1201 	movw	r2, #257	@ 0x101
 8016852:	4293      	cmp	r3, r2
 8016854:	d004      	beq.n	8016860 <start_pass+0x280>
 8016856:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801685a:	f000 8097 	beq.w	801698c <start_pass+0x3ac>
 801685e:	e0c0      	b.n	80169e2 <start_pass+0x402>
#ifdef IDCT_SCALING_SUPPORTED
    case ((1 << 8) + 1):
      method_ptr = jpeg_idct_1x1;
 8016860:	4b8e      	ldr	r3, [pc, #568]	@ (8016a9c <start_pass+0x4bc>)
 8016862:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016864:	2300      	movs	r3, #0
 8016866:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016868:	e0cf      	b.n	8016a0a <start_pass+0x42a>
    case ((2 << 8) + 2):
      method_ptr = jpeg_idct_2x2;
 801686a:	4b8d      	ldr	r3, [pc, #564]	@ (8016aa0 <start_pass+0x4c0>)
 801686c:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801686e:	2300      	movs	r3, #0
 8016870:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016872:	e0ca      	b.n	8016a0a <start_pass+0x42a>
    case ((3 << 8) + 3):
      method_ptr = jpeg_idct_3x3;
 8016874:	4b8b      	ldr	r3, [pc, #556]	@ (8016aa4 <start_pass+0x4c4>)
 8016876:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016878:	2300      	movs	r3, #0
 801687a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801687c:	e0c5      	b.n	8016a0a <start_pass+0x42a>
    case ((4 << 8) + 4):
      method_ptr = jpeg_idct_4x4;
 801687e:	4b8a      	ldr	r3, [pc, #552]	@ (8016aa8 <start_pass+0x4c8>)
 8016880:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016882:	2300      	movs	r3, #0
 8016884:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016886:	e0c0      	b.n	8016a0a <start_pass+0x42a>
    case ((5 << 8) + 5):
      method_ptr = jpeg_idct_5x5;
 8016888:	4b88      	ldr	r3, [pc, #544]	@ (8016aac <start_pass+0x4cc>)
 801688a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801688c:	2300      	movs	r3, #0
 801688e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016890:	e0bb      	b.n	8016a0a <start_pass+0x42a>
    case ((6 << 8) + 6):
      method_ptr = jpeg_idct_6x6;
 8016892:	4b87      	ldr	r3, [pc, #540]	@ (8016ab0 <start_pass+0x4d0>)
 8016894:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016896:	2300      	movs	r3, #0
 8016898:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801689a:	e0b6      	b.n	8016a0a <start_pass+0x42a>
    case ((7 << 8) + 7):
      method_ptr = jpeg_idct_7x7;
 801689c:	4b85      	ldr	r3, [pc, #532]	@ (8016ab4 <start_pass+0x4d4>)
 801689e:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168a0:	2300      	movs	r3, #0
 80168a2:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168a4:	e0b1      	b.n	8016a0a <start_pass+0x42a>
    case ((9 << 8) + 9):
      method_ptr = jpeg_idct_9x9;
 80168a6:	4b84      	ldr	r3, [pc, #528]	@ (8016ab8 <start_pass+0x4d8>)
 80168a8:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168aa:	2300      	movs	r3, #0
 80168ac:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168ae:	e0ac      	b.n	8016a0a <start_pass+0x42a>
    case ((10 << 8) + 10):
      method_ptr = jpeg_idct_10x10;
 80168b0:	4b82      	ldr	r3, [pc, #520]	@ (8016abc <start_pass+0x4dc>)
 80168b2:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168b4:	2300      	movs	r3, #0
 80168b6:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168b8:	e0a7      	b.n	8016a0a <start_pass+0x42a>
    case ((11 << 8) + 11):
      method_ptr = jpeg_idct_11x11;
 80168ba:	4b81      	ldr	r3, [pc, #516]	@ (8016ac0 <start_pass+0x4e0>)
 80168bc:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168be:	2300      	movs	r3, #0
 80168c0:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168c2:	e0a2      	b.n	8016a0a <start_pass+0x42a>
    case ((12 << 8) + 12):
      method_ptr = jpeg_idct_12x12;
 80168c4:	4b7f      	ldr	r3, [pc, #508]	@ (8016ac4 <start_pass+0x4e4>)
 80168c6:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168c8:	2300      	movs	r3, #0
 80168ca:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168cc:	e09d      	b.n	8016a0a <start_pass+0x42a>
    case ((13 << 8) + 13):
      method_ptr = jpeg_idct_13x13;
 80168ce:	4b7e      	ldr	r3, [pc, #504]	@ (8016ac8 <start_pass+0x4e8>)
 80168d0:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168d2:	2300      	movs	r3, #0
 80168d4:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168d6:	e098      	b.n	8016a0a <start_pass+0x42a>
    case ((14 << 8) + 14):
      method_ptr = jpeg_idct_14x14;
 80168d8:	4b7c      	ldr	r3, [pc, #496]	@ (8016acc <start_pass+0x4ec>)
 80168da:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168dc:	2300      	movs	r3, #0
 80168de:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168e0:	e093      	b.n	8016a0a <start_pass+0x42a>
    case ((15 << 8) + 15):
      method_ptr = jpeg_idct_15x15;
 80168e2:	4b7b      	ldr	r3, [pc, #492]	@ (8016ad0 <start_pass+0x4f0>)
 80168e4:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168e6:	2300      	movs	r3, #0
 80168e8:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168ea:	e08e      	b.n	8016a0a <start_pass+0x42a>
    case ((16 << 8) + 16):
      method_ptr = jpeg_idct_16x16;
 80168ec:	4b79      	ldr	r3, [pc, #484]	@ (8016ad4 <start_pass+0x4f4>)
 80168ee:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168f0:	2300      	movs	r3, #0
 80168f2:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168f4:	e089      	b.n	8016a0a <start_pass+0x42a>
    case ((16 << 8) + 8):
      method_ptr = jpeg_idct_16x8;
 80168f6:	4b78      	ldr	r3, [pc, #480]	@ (8016ad8 <start_pass+0x4f8>)
 80168f8:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 80168fa:	2300      	movs	r3, #0
 80168fc:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 80168fe:	e084      	b.n	8016a0a <start_pass+0x42a>
    case ((14 << 8) + 7):
      method_ptr = jpeg_idct_14x7;
 8016900:	4b76      	ldr	r3, [pc, #472]	@ (8016adc <start_pass+0x4fc>)
 8016902:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016904:	2300      	movs	r3, #0
 8016906:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016908:	e07f      	b.n	8016a0a <start_pass+0x42a>
    case ((12 << 8) + 6):
      method_ptr = jpeg_idct_12x6;
 801690a:	4b75      	ldr	r3, [pc, #468]	@ (8016ae0 <start_pass+0x500>)
 801690c:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801690e:	2300      	movs	r3, #0
 8016910:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016912:	e07a      	b.n	8016a0a <start_pass+0x42a>
    case ((10 << 8) + 5):
      method_ptr = jpeg_idct_10x5;
 8016914:	4b73      	ldr	r3, [pc, #460]	@ (8016ae4 <start_pass+0x504>)
 8016916:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016918:	2300      	movs	r3, #0
 801691a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801691c:	e075      	b.n	8016a0a <start_pass+0x42a>
    case ((8 << 8) + 4):
      method_ptr = jpeg_idct_8x4;
 801691e:	4b72      	ldr	r3, [pc, #456]	@ (8016ae8 <start_pass+0x508>)
 8016920:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016922:	2300      	movs	r3, #0
 8016924:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016926:	e070      	b.n	8016a0a <start_pass+0x42a>
    case ((6 << 8) + 3):
      method_ptr = jpeg_idct_6x3;
 8016928:	4b70      	ldr	r3, [pc, #448]	@ (8016aec <start_pass+0x50c>)
 801692a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801692c:	2300      	movs	r3, #0
 801692e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016930:	e06b      	b.n	8016a0a <start_pass+0x42a>
    case ((4 << 8) + 2):
      method_ptr = jpeg_idct_4x2;
 8016932:	4b6f      	ldr	r3, [pc, #444]	@ (8016af0 <start_pass+0x510>)
 8016934:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016936:	2300      	movs	r3, #0
 8016938:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801693a:	e066      	b.n	8016a0a <start_pass+0x42a>
    case ((2 << 8) + 1):
      method_ptr = jpeg_idct_2x1;
 801693c:	4b6d      	ldr	r3, [pc, #436]	@ (8016af4 <start_pass+0x514>)
 801693e:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016940:	2300      	movs	r3, #0
 8016942:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016944:	e061      	b.n	8016a0a <start_pass+0x42a>
    case ((8 << 8) + 16):
      method_ptr = jpeg_idct_8x16;
 8016946:	4b6c      	ldr	r3, [pc, #432]	@ (8016af8 <start_pass+0x518>)
 8016948:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801694a:	2300      	movs	r3, #0
 801694c:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801694e:	e05c      	b.n	8016a0a <start_pass+0x42a>
    case ((7 << 8) + 14):
      method_ptr = jpeg_idct_7x14;
 8016950:	4b6a      	ldr	r3, [pc, #424]	@ (8016afc <start_pass+0x51c>)
 8016952:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016954:	2300      	movs	r3, #0
 8016956:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016958:	e057      	b.n	8016a0a <start_pass+0x42a>
    case ((6 << 8) + 12):
      method_ptr = jpeg_idct_6x12;
 801695a:	4b69      	ldr	r3, [pc, #420]	@ (8016b00 <start_pass+0x520>)
 801695c:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801695e:	2300      	movs	r3, #0
 8016960:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016962:	e052      	b.n	8016a0a <start_pass+0x42a>
    case ((5 << 8) + 10):
      method_ptr = jpeg_idct_5x10;
 8016964:	4b67      	ldr	r3, [pc, #412]	@ (8016b04 <start_pass+0x524>)
 8016966:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016968:	2300      	movs	r3, #0
 801696a:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801696c:	e04d      	b.n	8016a0a <start_pass+0x42a>
    case ((4 << 8) + 8):
      method_ptr = jpeg_idct_4x8;
 801696e:	4b66      	ldr	r3, [pc, #408]	@ (8016b08 <start_pass+0x528>)
 8016970:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016972:	2300      	movs	r3, #0
 8016974:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016976:	e048      	b.n	8016a0a <start_pass+0x42a>
    case ((3 << 8) + 6):
      method_ptr = jpeg_idct_3x6;
 8016978:	4b64      	ldr	r3, [pc, #400]	@ (8016b0c <start_pass+0x52c>)
 801697a:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 801697c:	2300      	movs	r3, #0
 801697e:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016980:	e043      	b.n	8016a0a <start_pass+0x42a>
    case ((2 << 8) + 4):
      method_ptr = jpeg_idct_2x4;
 8016982:	4b63      	ldr	r3, [pc, #396]	@ (8016b10 <start_pass+0x530>)
 8016984:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016986:	2300      	movs	r3, #0
 8016988:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 801698a:	e03e      	b.n	8016a0a <start_pass+0x42a>
    case ((1 << 8) + 2):
      method_ptr = jpeg_idct_1x2;
 801698c:	4b61      	ldr	r3, [pc, #388]	@ (8016b14 <start_pass+0x534>)
 801698e:	627b      	str	r3, [r7, #36]	@ 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 8016990:	2300      	movs	r3, #0
 8016992:	62bb      	str	r3, [r7, #40]	@ 0x28
      break;
 8016994:	e039      	b.n	8016a0a <start_pass+0x42a>
#endif
    case ((DCTSIZE << 8) + DCTSIZE):
      switch (cinfo->dct_method) {
 8016996:	687b      	ldr	r3, [r7, #4]
 8016998:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 801699c:	2b02      	cmp	r3, #2
 801699e:	d010      	beq.n	80169c2 <start_pass+0x3e2>
 80169a0:	2b02      	cmp	r3, #2
 80169a2:	dc13      	bgt.n	80169cc <start_pass+0x3ec>
 80169a4:	2b00      	cmp	r3, #0
 80169a6:	d002      	beq.n	80169ae <start_pass+0x3ce>
 80169a8:	2b01      	cmp	r3, #1
 80169aa:	d005      	beq.n	80169b8 <start_pass+0x3d8>
 80169ac:	e00e      	b.n	80169cc <start_pass+0x3ec>
#ifdef DCT_ISLOW_SUPPORTED
      case JDCT_ISLOW:
	method_ptr = jpeg_idct_islow;
 80169ae:	4b5a      	ldr	r3, [pc, #360]	@ (8016b18 <start_pass+0x538>)
 80169b0:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_ISLOW;
 80169b2:	2300      	movs	r3, #0
 80169b4:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80169b6:	e013      	b.n	80169e0 <start_pass+0x400>
#endif
#ifdef DCT_IFAST_SUPPORTED
      case JDCT_IFAST:
	method_ptr = jpeg_idct_ifast;
 80169b8:	4b58      	ldr	r3, [pc, #352]	@ (8016b1c <start_pass+0x53c>)
 80169ba:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_IFAST;
 80169bc:	2301      	movs	r3, #1
 80169be:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80169c0:	e00e      	b.n	80169e0 <start_pass+0x400>
#endif
#ifdef DCT_FLOAT_SUPPORTED
      case JDCT_FLOAT:
	method_ptr = jpeg_idct_float;
 80169c2:	4b57      	ldr	r3, [pc, #348]	@ (8016b20 <start_pass+0x540>)
 80169c4:	627b      	str	r3, [r7, #36]	@ 0x24
	method = JDCT_FLOAT;
 80169c6:	2302      	movs	r3, #2
 80169c8:	62bb      	str	r3, [r7, #40]	@ 0x28
	break;
 80169ca:	e009      	b.n	80169e0 <start_pass+0x400>
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
 80169cc:	687b      	ldr	r3, [r7, #4]
 80169ce:	681b      	ldr	r3, [r3, #0]
 80169d0:	2231      	movs	r2, #49	@ 0x31
 80169d2:	615a      	str	r2, [r3, #20]
 80169d4:	687b      	ldr	r3, [r7, #4]
 80169d6:	681b      	ldr	r3, [r3, #0]
 80169d8:	681b      	ldr	r3, [r3, #0]
 80169da:	6878      	ldr	r0, [r7, #4]
 80169dc:	4798      	blx	r3
	break;
 80169de:	bf00      	nop
      }
      break;
 80169e0:	e013      	b.n	8016a0a <start_pass+0x42a>
    default:
      ERREXIT2(cinfo, JERR_BAD_DCTSIZE,
 80169e2:	687b      	ldr	r3, [r7, #4]
 80169e4:	681b      	ldr	r3, [r3, #0]
 80169e6:	2207      	movs	r2, #7
 80169e8:	615a      	str	r2, [r3, #20]
 80169ea:	687b      	ldr	r3, [r7, #4]
 80169ec:	681b      	ldr	r3, [r3, #0]
 80169ee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80169f0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80169f2:	619a      	str	r2, [r3, #24]
 80169f4:	687b      	ldr	r3, [r7, #4]
 80169f6:	681b      	ldr	r3, [r3, #0]
 80169f8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80169fa:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80169fc:	61da      	str	r2, [r3, #28]
 80169fe:	687b      	ldr	r3, [r7, #4]
 8016a00:	681b      	ldr	r3, [r3, #0]
 8016a02:	681b      	ldr	r3, [r3, #0]
 8016a04:	6878      	ldr	r0, [r7, #4]
 8016a06:	4798      	blx	r3
	       compptr->DCT_h_scaled_size, compptr->DCT_v_scaled_size);
      break;
 8016a08:	bf00      	nop
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
 8016a0a:	69ba      	ldr	r2, [r7, #24]
 8016a0c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016a0e:	009b      	lsls	r3, r3, #2
 8016a10:	4413      	add	r3, r2
 8016a12:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8016a14:	605a      	str	r2, [r3, #4]
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
 8016a16:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016a18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8016a1a:	2b00      	cmp	r3, #0
 8016a1c:	f000 80f8 	beq.w	8016c10 <start_pass+0x630>
 8016a20:	69ba      	ldr	r2, [r7, #24]
 8016a22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016a24:	330a      	adds	r3, #10
 8016a26:	009b      	lsls	r3, r3, #2
 8016a28:	4413      	add	r3, r2
 8016a2a:	685b      	ldr	r3, [r3, #4]
 8016a2c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016a2e:	429a      	cmp	r2, r3
 8016a30:	f000 80ee 	beq.w	8016c10 <start_pass+0x630>
      continue;
    qtbl = compptr->quant_table;
 8016a34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016a36:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8016a38:	617b      	str	r3, [r7, #20]
    if (qtbl == NULL)		/* happens if no data yet for component */
 8016a3a:	697b      	ldr	r3, [r7, #20]
 8016a3c:	2b00      	cmp	r3, #0
 8016a3e:	f000 80e9 	beq.w	8016c14 <start_pass+0x634>
      continue;
    idct->cur_method[ci] = method;
 8016a42:	69ba      	ldr	r2, [r7, #24]
 8016a44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016a46:	330a      	adds	r3, #10
 8016a48:	009b      	lsls	r3, r3, #2
 8016a4a:	4413      	add	r3, r2
 8016a4c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016a4e:	605a      	str	r2, [r3, #4]
    switch (method) {
 8016a50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016a52:	2b02      	cmp	r3, #2
 8016a54:	f000 8086 	beq.w	8016b64 <start_pass+0x584>
 8016a58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016a5a:	2b02      	cmp	r3, #2
 8016a5c:	f300 80ce 	bgt.w	8016bfc <start_pass+0x61c>
 8016a60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016a62:	2b00      	cmp	r3, #0
 8016a64:	d003      	beq.n	8016a6e <start_pass+0x48e>
 8016a66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016a68:	2b01      	cmp	r3, #1
 8016a6a:	d05b      	beq.n	8016b24 <start_pass+0x544>
 8016a6c:	e0c6      	b.n	8016bfc <start_pass+0x61c>
    case JDCT_ISLOW:
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8016a6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016a70:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8016a72:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < DCTSIZE2; i++) {
 8016a74:	2300      	movs	r3, #0
 8016a76:	633b      	str	r3, [r7, #48]	@ 0x30
 8016a78:	e00c      	b.n	8016a94 <start_pass+0x4b4>
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
 8016a7a:	697b      	ldr	r3, [r7, #20]
 8016a7c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8016a7e:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 8016a82:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a84:	009b      	lsls	r3, r3, #2
 8016a86:	68ba      	ldr	r2, [r7, #8]
 8016a88:	4413      	add	r3, r2
 8016a8a:	460a      	mov	r2, r1
 8016a8c:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 8016a8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a90:	3301      	adds	r3, #1
 8016a92:	633b      	str	r3, [r7, #48]	@ 0x30
 8016a94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a96:	2b3f      	cmp	r3, #63	@ 0x3f
 8016a98:	ddef      	ble.n	8016a7a <start_pass+0x49a>
	}
      }
      break;
 8016a9a:	e0bc      	b.n	8016c16 <start_pass+0x636>
 8016a9c:	08021537 	.word	0x08021537
 8016aa0:	08021421 	.word	0x08021421
 8016aa4:	08021271 	.word	0x08021271
 8016aa8:	08021035 	.word	0x08021035
 8016aac:	08020c69 	.word	0x08020c69
 8016ab0:	08020801 	.word	0x08020801
 8016ab4:	08020175 	.word	0x08020175
 8016ab8:	08021591 	.word	0x08021591
 8016abc:	08021cc1 	.word	0x08021cc1
 8016ac0:	080224bd 	.word	0x080224bd
 8016ac4:	08022e6d 	.word	0x08022e6d
 8016ac8:	080237ad 	.word	0x080237ad
 8016acc:	080242d1 	.word	0x080242d1
 8016ad0:	08024d71 	.word	0x08024d71
 8016ad4:	0802589d 	.word	0x0802589d
 8016ad8:	080265a1 	.word	0x080265a1
 8016adc:	08027111 	.word	0x08027111
 8016ae0:	080279c1 	.word	0x080279c1
 8016ae4:	080280c5 	.word	0x080280c5
 8016ae8:	080286b1 	.word	0x080286b1
 8016aec:	08028bc1 	.word	0x08028bc1
 8016af0:	08028e89 	.word	0x08028e89
 8016af4:	0802900d 	.word	0x0802900d
 8016af8:	0802909d 	.word	0x0802909d
 8016afc:	08029ab5 	.word	0x08029ab5
 8016b00:	0802a32d 	.word	0x0802a32d
 8016b04:	0802aa0d 	.word	0x0802aa0d
 8016b08:	0802b019 	.word	0x0802b019
 8016b0c:	0802b645 	.word	0x0802b645
 8016b10:	0802b915 	.word	0x0802b915
 8016b14:	0802baa5 	.word	0x0802baa5
 8016b18:	0801f815 	.word	0x0801f815
 8016b1c:	0801f005 	.word	0x0801f005
 8016b20:	0801e7a5 	.word	0x0801e7a5
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * For integer operation, the multiplier table is to be scaled by
	 * IFAST_SCALE_BITS.
	 */
	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
 8016b24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016b26:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8016b28:	60fb      	str	r3, [r7, #12]
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
 8016b2a:	2300      	movs	r3, #0
 8016b2c:	633b      	str	r3, [r7, #48]	@ 0x30
 8016b2e:	e015      	b.n	8016b5c <start_pass+0x57c>
	  ifmtbl[i] = (IFAST_MULT_TYPE)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 8016b30:	697b      	ldr	r3, [r7, #20]
 8016b32:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8016b34:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8016b38:	4619      	mov	r1, r3
 8016b3a:	4a3f      	ldr	r2, [pc, #252]	@ (8016c38 <start_pass+0x658>)
 8016b3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b3e:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 8016b42:	fb01 f303 	mul.w	r3, r1, r3
 8016b46:	f503 6200 	add.w	r2, r3, #2048	@ 0x800
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 8016b4a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b4c:	009b      	lsls	r3, r3, #2
 8016b4e:	68f9      	ldr	r1, [r7, #12]
 8016b50:	440b      	add	r3, r1
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 8016b52:	1312      	asrs	r2, r2, #12
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 8016b54:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 8016b56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b58:	3301      	adds	r3, #1
 8016b5a:	633b      	str	r3, [r7, #48]	@ 0x30
 8016b5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b5e:	2b3f      	cmp	r3, #63	@ 0x3f
 8016b60:	dde6      	ble.n	8016b30 <start_pass+0x550>
				  (INT32) aanscales[i]),
		    CONST_BITS-IFAST_SCALE_BITS);
	}
      }
      break;
 8016b62:	e058      	b.n	8016c16 <start_pass+0x636>
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 1/8.
	 */
	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
 8016b64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016b66:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8016b68:	613b      	str	r3, [r7, #16]
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	i = 0;
 8016b6a:	2300      	movs	r3, #0
 8016b6c:	633b      	str	r3, [r7, #48]	@ 0x30
	for (row = 0; row < DCTSIZE; row++) {
 8016b6e:	2300      	movs	r3, #0
 8016b70:	623b      	str	r3, [r7, #32]
 8016b72:	e03f      	b.n	8016bf4 <start_pass+0x614>
	  for (col = 0; col < DCTSIZE; col++) {
 8016b74:	2300      	movs	r3, #0
 8016b76:	61fb      	str	r3, [r7, #28]
 8016b78:	e036      	b.n	8016be8 <start_pass+0x608>
	    fmtbl[i] = (FLOAT_MULT_TYPE)
	      ((double) qtbl->quantval[i] *
 8016b7a:	697b      	ldr	r3, [r7, #20]
 8016b7c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8016b7e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8016b82:	4618      	mov	r0, r3
 8016b84:	f7e9 fcb6 	bl	80004f4 <__aeabi_ui2d>
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 8016b88:	4a2c      	ldr	r2, [pc, #176]	@ (8016c3c <start_pass+0x65c>)
 8016b8a:	6a3b      	ldr	r3, [r7, #32]
 8016b8c:	00db      	lsls	r3, r3, #3
 8016b8e:	4413      	add	r3, r2
 8016b90:	e9d3 2300 	ldrd	r2, r3, [r3]
	      ((double) qtbl->quantval[i] *
 8016b94:	f7e9 fd28 	bl	80005e8 <__aeabi_dmul>
 8016b98:	4602      	mov	r2, r0
 8016b9a:	460b      	mov	r3, r1
 8016b9c:	4610      	mov	r0, r2
 8016b9e:	4619      	mov	r1, r3
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 8016ba0:	4a26      	ldr	r2, [pc, #152]	@ (8016c3c <start_pass+0x65c>)
 8016ba2:	69fb      	ldr	r3, [r7, #28]
 8016ba4:	00db      	lsls	r3, r3, #3
 8016ba6:	4413      	add	r3, r2
 8016ba8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016bac:	f7e9 fd1c 	bl	80005e8 <__aeabi_dmul>
 8016bb0:	4602      	mov	r2, r0
 8016bb2:	460b      	mov	r3, r1
 8016bb4:	4610      	mov	r0, r2
 8016bb6:	4619      	mov	r1, r3
 8016bb8:	f04f 0200 	mov.w	r2, #0
 8016bbc:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 8016bc0:	f7e9 fd12 	bl	80005e8 <__aeabi_dmul>
 8016bc4:	4602      	mov	r2, r0
 8016bc6:	460b      	mov	r3, r1
 8016bc8:	4610      	mov	r0, r2
 8016bca:	4619      	mov	r1, r3
	    fmtbl[i] = (FLOAT_MULT_TYPE)
 8016bcc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016bce:	009b      	lsls	r3, r3, #2
 8016bd0:	693a      	ldr	r2, [r7, #16]
 8016bd2:	18d4      	adds	r4, r2, r3
 8016bd4:	f7e9 ff1a 	bl	8000a0c <__aeabi_d2f>
 8016bd8:	4603      	mov	r3, r0
 8016bda:	6023      	str	r3, [r4, #0]
	    i++;
 8016bdc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016bde:	3301      	adds	r3, #1
 8016be0:	633b      	str	r3, [r7, #48]	@ 0x30
	  for (col = 0; col < DCTSIZE; col++) {
 8016be2:	69fb      	ldr	r3, [r7, #28]
 8016be4:	3301      	adds	r3, #1
 8016be6:	61fb      	str	r3, [r7, #28]
 8016be8:	69fb      	ldr	r3, [r7, #28]
 8016bea:	2b07      	cmp	r3, #7
 8016bec:	ddc5      	ble.n	8016b7a <start_pass+0x59a>
	for (row = 0; row < DCTSIZE; row++) {
 8016bee:	6a3b      	ldr	r3, [r7, #32]
 8016bf0:	3301      	adds	r3, #1
 8016bf2:	623b      	str	r3, [r7, #32]
 8016bf4:	6a3b      	ldr	r3, [r7, #32]
 8016bf6:	2b07      	cmp	r3, #7
 8016bf8:	ddbc      	ble.n	8016b74 <start_pass+0x594>
	  }
	}
      }
      break;
 8016bfa:	e00c      	b.n	8016c16 <start_pass+0x636>
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
 8016bfc:	687b      	ldr	r3, [r7, #4]
 8016bfe:	681b      	ldr	r3, [r3, #0]
 8016c00:	2231      	movs	r2, #49	@ 0x31
 8016c02:	615a      	str	r2, [r3, #20]
 8016c04:	687b      	ldr	r3, [r7, #4]
 8016c06:	681b      	ldr	r3, [r3, #0]
 8016c08:	681b      	ldr	r3, [r3, #0]
 8016c0a:	6878      	ldr	r0, [r7, #4]
 8016c0c:	4798      	blx	r3
      break;
 8016c0e:	e002      	b.n	8016c16 <start_pass+0x636>
      continue;
 8016c10:	bf00      	nop
 8016c12:	e000      	b.n	8016c16 <start_pass+0x636>
      continue;
 8016c14:	bf00      	nop
       ci++, compptr++) {
 8016c16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016c18:	3301      	adds	r3, #1
 8016c1a:	637b      	str	r3, [r7, #52]	@ 0x34
 8016c1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016c1e:	3358      	adds	r3, #88	@ 0x58
 8016c20:	62fb      	str	r3, [r7, #44]	@ 0x2c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8016c22:	687b      	ldr	r3, [r7, #4]
 8016c24:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8016c26:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8016c28:	429a      	cmp	r2, r3
 8016c2a:	f6ff acec 	blt.w	8016606 <start_pass+0x26>
    }
  }
}
 8016c2e:	bf00      	nop
 8016c30:	bf00      	nop
 8016c32:	373c      	adds	r7, #60	@ 0x3c
 8016c34:	46bd      	mov	sp, r7
 8016c36:	bd90      	pop	{r4, r7, pc}
 8016c38:	08032004 	.word	0x08032004
 8016c3c:	08032088 	.word	0x08032088

08016c40 <jinit_inverse_dct>:
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
 8016c40:	b580      	push	{r7, lr}
 8016c42:	b086      	sub	sp, #24
 8016c44:	af00      	add	r7, sp, #0
 8016c46:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016c48:	687b      	ldr	r3, [r7, #4]
 8016c4a:	685b      	ldr	r3, [r3, #4]
 8016c4c:	681b      	ldr	r3, [r3, #0]
 8016c4e:	2254      	movs	r2, #84	@ 0x54
 8016c50:	2101      	movs	r1, #1
 8016c52:	6878      	ldr	r0, [r7, #4]
 8016c54:	4798      	blx	r3
 8016c56:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
 8016c58:	687b      	ldr	r3, [r7, #4]
 8016c5a:	68fa      	ldr	r2, [r7, #12]
 8016c5c:	f8c3 21d4 	str.w	r2, [r3, #468]	@ 0x1d4
  idct->pub.start_pass = start_pass;
 8016c60:	68fb      	ldr	r3, [r7, #12]
 8016c62:	4a1a      	ldr	r2, [pc, #104]	@ (8016ccc <jinit_inverse_dct+0x8c>)
 8016c64:	601a      	str	r2, [r3, #0]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8016c66:	2300      	movs	r3, #0
 8016c68:	617b      	str	r3, [r7, #20]
 8016c6a:	687b      	ldr	r3, [r7, #4]
 8016c6c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8016c70:	613b      	str	r3, [r7, #16]
 8016c72:	e020      	b.n	8016cb6 <jinit_inverse_dct+0x76>
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016c74:	687b      	ldr	r3, [r7, #4]
 8016c76:	685b      	ldr	r3, [r3, #4]
 8016c78:	681b      	ldr	r3, [r3, #0]
 8016c7a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8016c7e:	2101      	movs	r1, #1
 8016c80:	6878      	ldr	r0, [r7, #4]
 8016c82:	4798      	blx	r3
 8016c84:	4602      	mov	r2, r0
    compptr->dct_table =
 8016c86:	693b      	ldr	r3, [r7, #16]
 8016c88:	655a      	str	r2, [r3, #84]	@ 0x54
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
 8016c8a:	693b      	ldr	r3, [r7, #16]
 8016c8c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8016c8e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8016c92:	2100      	movs	r1, #0
 8016c94:	4618      	mov	r0, r3
 8016c96:	f018 fe83 	bl	802f9a0 <memset>
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
 8016c9a:	68fa      	ldr	r2, [r7, #12]
 8016c9c:	697b      	ldr	r3, [r7, #20]
 8016c9e:	330a      	adds	r3, #10
 8016ca0:	009b      	lsls	r3, r3, #2
 8016ca2:	4413      	add	r3, r2
 8016ca4:	f04f 32ff 	mov.w	r2, #4294967295
 8016ca8:	605a      	str	r2, [r3, #4]
       ci++, compptr++) {
 8016caa:	697b      	ldr	r3, [r7, #20]
 8016cac:	3301      	adds	r3, #1
 8016cae:	617b      	str	r3, [r7, #20]
 8016cb0:	693b      	ldr	r3, [r7, #16]
 8016cb2:	3358      	adds	r3, #88	@ 0x58
 8016cb4:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8016cb6:	687b      	ldr	r3, [r7, #4]
 8016cb8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8016cba:	697a      	ldr	r2, [r7, #20]
 8016cbc:	429a      	cmp	r2, r3
 8016cbe:	dbd9      	blt.n	8016c74 <jinit_inverse_dct+0x34>
  }
}
 8016cc0:	bf00      	nop
 8016cc2:	bf00      	nop
 8016cc4:	3718      	adds	r7, #24
 8016cc6:	46bd      	mov	sp, r7
 8016cc8:	bd80      	pop	{r7, pc}
 8016cca:	bf00      	nop
 8016ccc:	080165e1 	.word	0x080165e1

08016cd0 <jpeg_make_d_derived_tbl>:
 */

LOCAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
			 d_derived_tbl ** pdtbl)
{
 8016cd0:	b590      	push	{r4, r7, lr}
 8016cd2:	f2ad 5d4c 	subw	sp, sp, #1356	@ 0x54c
 8016cd6:	af00      	add	r7, sp, #0
 8016cd8:	f507 64a9 	add.w	r4, r7, #1352	@ 0x548
 8016cdc:	f2a4 543c 	subw	r4, r4, #1340	@ 0x53c
 8016ce0:	6020      	str	r0, [r4, #0]
 8016ce2:	f507 60a9 	add.w	r0, r7, #1352	@ 0x548
 8016ce6:	f5a0 60a8 	sub.w	r0, r0, #1344	@ 0x540
 8016cea:	6001      	str	r1, [r0, #0]
 8016cec:	f507 61a9 	add.w	r1, r7, #1352	@ 0x548
 8016cf0:	f2a1 5144 	subw	r1, r1, #1348	@ 0x544
 8016cf4:	600a      	str	r2, [r1, #0]
 8016cf6:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016cfa:	f5a2 62a9 	sub.w	r2, r2, #1352	@ 0x548
 8016cfe:	6013      	str	r3, [r2, #0]
  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
 8016d00:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d04:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 8016d08:	681b      	ldr	r3, [r3, #0]
 8016d0a:	2b00      	cmp	r3, #0
 8016d0c:	db06      	blt.n	8016d1c <jpeg_make_d_derived_tbl+0x4c>
 8016d0e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d12:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 8016d16:	681b      	ldr	r3, [r3, #0]
 8016d18:	2b03      	cmp	r3, #3
 8016d1a:	dd20      	ble.n	8016d5e <jpeg_make_d_derived_tbl+0x8e>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 8016d1c:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d20:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016d24:	681b      	ldr	r3, [r3, #0]
 8016d26:	681b      	ldr	r3, [r3, #0]
 8016d28:	2234      	movs	r2, #52	@ 0x34
 8016d2a:	615a      	str	r2, [r3, #20]
 8016d2c:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d30:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016d34:	681b      	ldr	r3, [r3, #0]
 8016d36:	681b      	ldr	r3, [r3, #0]
 8016d38:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016d3c:	f2a2 5244 	subw	r2, r2, #1348	@ 0x544
 8016d40:	6812      	ldr	r2, [r2, #0]
 8016d42:	619a      	str	r2, [r3, #24]
 8016d44:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d48:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016d4c:	681b      	ldr	r3, [r3, #0]
 8016d4e:	681b      	ldr	r3, [r3, #0]
 8016d50:	681b      	ldr	r3, [r3, #0]
 8016d52:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016d56:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8016d5a:	6810      	ldr	r0, [r2, #0]
 8016d5c:	4798      	blx	r3
  htbl =
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
 8016d5e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d62:	f5a3 63a8 	sub.w	r3, r3, #1344	@ 0x540
 8016d66:	681b      	ldr	r3, [r3, #0]
 8016d68:	2b00      	cmp	r3, #0
 8016d6a:	d00e      	beq.n	8016d8a <jpeg_make_d_derived_tbl+0xba>
 8016d6c:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d70:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016d74:	681a      	ldr	r2, [r3, #0]
 8016d76:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d7a:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 8016d7e:	681b      	ldr	r3, [r3, #0]
 8016d80:	332c      	adds	r3, #44	@ 0x2c
 8016d82:	009b      	lsls	r3, r3, #2
 8016d84:	4413      	add	r3, r2
 8016d86:	685b      	ldr	r3, [r3, #4]
 8016d88:	e00d      	b.n	8016da6 <jpeg_make_d_derived_tbl+0xd6>
 8016d8a:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d8e:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016d92:	681a      	ldr	r2, [r3, #0]
 8016d94:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016d98:	f2a3 5344 	subw	r3, r3, #1348	@ 0x544
 8016d9c:	681b      	ldr	r3, [r3, #0]
 8016d9e:	3330      	adds	r3, #48	@ 0x30
 8016da0:	009b      	lsls	r3, r3, #2
 8016da2:	4413      	add	r3, r2
 8016da4:	685b      	ldr	r3, [r3, #4]
  htbl =
 8016da6:	f8c7 3528 	str.w	r3, [r7, #1320]	@ 0x528
  if (htbl == NULL)
 8016daa:	f8d7 3528 	ldr.w	r3, [r7, #1320]	@ 0x528
 8016dae:	2b00      	cmp	r3, #0
 8016db0:	d120      	bne.n	8016df4 <jpeg_make_d_derived_tbl+0x124>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 8016db2:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016db6:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016dba:	681b      	ldr	r3, [r3, #0]
 8016dbc:	681b      	ldr	r3, [r3, #0]
 8016dbe:	2234      	movs	r2, #52	@ 0x34
 8016dc0:	615a      	str	r2, [r3, #20]
 8016dc2:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016dc6:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016dca:	681b      	ldr	r3, [r3, #0]
 8016dcc:	681b      	ldr	r3, [r3, #0]
 8016dce:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016dd2:	f2a2 5244 	subw	r2, r2, #1348	@ 0x544
 8016dd6:	6812      	ldr	r2, [r2, #0]
 8016dd8:	619a      	str	r2, [r3, #24]
 8016dda:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016dde:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016de2:	681b      	ldr	r3, [r3, #0]
 8016de4:	681b      	ldr	r3, [r3, #0]
 8016de6:	681b      	ldr	r3, [r3, #0]
 8016de8:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016dec:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8016df0:	6810      	ldr	r0, [r2, #0]
 8016df2:	4798      	blx	r3

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
 8016df4:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016df8:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8016dfc:	681b      	ldr	r3, [r3, #0]
 8016dfe:	681b      	ldr	r3, [r3, #0]
 8016e00:	2b00      	cmp	r3, #0
 8016e02:	d116      	bne.n	8016e32 <jpeg_make_d_derived_tbl+0x162>
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016e04:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016e08:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016e0c:	681b      	ldr	r3, [r3, #0]
 8016e0e:	685b      	ldr	r3, [r3, #4]
 8016e10:	681b      	ldr	r3, [r3, #0]
 8016e12:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016e16:	f2a2 503c 	subw	r0, r2, #1340	@ 0x53c
 8016e1a:	f44f 62b2 	mov.w	r2, #1424	@ 0x590
 8016e1e:	2101      	movs	r1, #1
 8016e20:	6800      	ldr	r0, [r0, #0]
 8016e22:	4798      	blx	r3
 8016e24:	4602      	mov	r2, r0
    *pdtbl = (d_derived_tbl *)
 8016e26:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016e2a:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8016e2e:	681b      	ldr	r3, [r3, #0]
 8016e30:	601a      	str	r2, [r3, #0]
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
 8016e32:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016e36:	f5a3 63a9 	sub.w	r3, r3, #1352	@ 0x548
 8016e3a:	681b      	ldr	r3, [r3, #0]
 8016e3c:	681b      	ldr	r3, [r3, #0]
 8016e3e:	f8c7 3524 	str.w	r3, [r7, #1316]	@ 0x524
  dtbl->pub = htbl;		/* fill in back link */
 8016e42:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8016e46:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8016e4a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  
  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
 8016e4e:	2300      	movs	r3, #0
 8016e50:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= 16; l++) {
 8016e54:	2301      	movs	r3, #1
 8016e56:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8016e5a:	e042      	b.n	8016ee2 <jpeg_make_d_derived_tbl+0x212>
    i = (int) htbl->bits[l];
 8016e5c:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8016e60:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8016e64:	4413      	add	r3, r2
 8016e66:	781b      	ldrb	r3, [r3, #0]
 8016e68:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
    if (i < 0 || p + i > 256)	/* protect against table overrun */
 8016e6c:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8016e70:	2b00      	cmp	r3, #0
 8016e72:	db07      	blt.n	8016e84 <jpeg_make_d_derived_tbl+0x1b4>
 8016e74:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 8016e78:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8016e7c:	4413      	add	r3, r2
 8016e7e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8016e82:	dd22      	ble.n	8016eca <jpeg_make_d_derived_tbl+0x1fa>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8016e84:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016e88:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016e8c:	681b      	ldr	r3, [r3, #0]
 8016e8e:	681b      	ldr	r3, [r3, #0]
 8016e90:	2209      	movs	r2, #9
 8016e92:	615a      	str	r2, [r3, #20]
 8016e94:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016e98:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016e9c:	681b      	ldr	r3, [r3, #0]
 8016e9e:	681b      	ldr	r3, [r3, #0]
 8016ea0:	681b      	ldr	r3, [r3, #0]
 8016ea2:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016ea6:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8016eaa:	6810      	ldr	r0, [r2, #0]
 8016eac:	4798      	blx	r3
    while (i--)
 8016eae:	e00c      	b.n	8016eca <jpeg_make_d_derived_tbl+0x1fa>
      huffsize[p++] = (char) l;
 8016eb0:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016eb4:	1c5a      	adds	r2, r3, #1
 8016eb6:	f8c7 2544 	str.w	r2, [r7, #1348]	@ 0x544
 8016eba:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8016ebe:	b2d1      	uxtb	r1, r2
 8016ec0:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016ec4:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 8016ec8:	54d1      	strb	r1, [r2, r3]
    while (i--)
 8016eca:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8016ece:	1e5a      	subs	r2, r3, #1
 8016ed0:	f8c7 2540 	str.w	r2, [r7, #1344]	@ 0x540
 8016ed4:	2b00      	cmp	r3, #0
 8016ed6:	d1eb      	bne.n	8016eb0 <jpeg_make_d_derived_tbl+0x1e0>
  for (l = 1; l <= 16; l++) {
 8016ed8:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8016edc:	3301      	adds	r3, #1
 8016ede:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8016ee2:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8016ee6:	2b10      	cmp	r3, #16
 8016ee8:	ddb8      	ble.n	8016e5c <jpeg_make_d_derived_tbl+0x18c>
  }
  huffsize[p] = 0;
 8016eea:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016eee:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8016ef2:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016ef6:	4413      	add	r3, r2
 8016ef8:	2200      	movs	r2, #0
 8016efa:	701a      	strb	r2, [r3, #0]
  numsymbols = p;
 8016efc:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016f00:	f8c7 3520 	str.w	r3, [r7, #1312]	@ 0x520
  
  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */
  
  code = 0;
 8016f04:	2300      	movs	r3, #0
 8016f06:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
  si = huffsize[0];
 8016f0a:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016f0e:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
 8016f12:	781b      	ldrb	r3, [r3, #0]
 8016f14:	f8c7 3538 	str.w	r3, [r7, #1336]	@ 0x538
  p = 0;
 8016f18:	2300      	movs	r3, #0
 8016f1a:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  while (huffsize[p]) {
 8016f1e:	e045      	b.n	8016fac <jpeg_make_d_derived_tbl+0x2dc>
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
 8016f20:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016f24:	1c5a      	adds	r2, r3, #1
 8016f26:	f8c7 2544 	str.w	r2, [r7, #1348]	@ 0x544
 8016f2a:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016f2e:	f2a2 5234 	subw	r2, r2, #1332	@ 0x534
 8016f32:	f8d7 152c 	ldr.w	r1, [r7, #1324]	@ 0x52c
 8016f36:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      code++;
 8016f3a:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8016f3e:	3301      	adds	r3, #1
 8016f40:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
    while (((int) huffsize[p]) == si) {
 8016f44:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016f48:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8016f4c:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016f50:	4413      	add	r3, r2
 8016f52:	781b      	ldrb	r3, [r3, #0]
 8016f54:	461a      	mov	r2, r3
 8016f56:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8016f5a:	4293      	cmp	r3, r2
 8016f5c:	d0e0      	beq.n	8016f20 <jpeg_make_d_derived_tbl+0x250>
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
 8016f5e:	2201      	movs	r2, #1
 8016f60:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8016f64:	409a      	lsls	r2, r3
 8016f66:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8016f6a:	429a      	cmp	r2, r3
 8016f6c:	dc14      	bgt.n	8016f98 <jpeg_make_d_derived_tbl+0x2c8>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8016f6e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016f72:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016f76:	681b      	ldr	r3, [r3, #0]
 8016f78:	681b      	ldr	r3, [r3, #0]
 8016f7a:	2209      	movs	r2, #9
 8016f7c:	615a      	str	r2, [r3, #20]
 8016f7e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016f82:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 8016f86:	681b      	ldr	r3, [r3, #0]
 8016f88:	681b      	ldr	r3, [r3, #0]
 8016f8a:	681b      	ldr	r3, [r3, #0]
 8016f8c:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 8016f90:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 8016f94:	6810      	ldr	r0, [r2, #0]
 8016f96:	4798      	blx	r3
    code <<= 1;
 8016f98:	f8d7 352c 	ldr.w	r3, [r7, #1324]	@ 0x52c
 8016f9c:	005b      	lsls	r3, r3, #1
 8016f9e:	f8c7 352c 	str.w	r3, [r7, #1324]	@ 0x52c
    si++;
 8016fa2:	f8d7 3538 	ldr.w	r3, [r7, #1336]	@ 0x538
 8016fa6:	3301      	adds	r3, #1
 8016fa8:	f8c7 3538 	str.w	r3, [r7, #1336]	@ 0x538
  while (huffsize[p]) {
 8016fac:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016fb0:	f5a3 7298 	sub.w	r2, r3, #304	@ 0x130
 8016fb4:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016fb8:	4413      	add	r3, r2
 8016fba:	781b      	ldrb	r3, [r3, #0]
 8016fbc:	2b00      	cmp	r3, #0
 8016fbe:	d1c1      	bne.n	8016f44 <jpeg_make_d_derived_tbl+0x274>
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
 8016fc0:	2300      	movs	r3, #0
 8016fc2:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= 16; l++) {
 8016fc6:	2301      	movs	r3, #1
 8016fc8:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8016fcc:	e044      	b.n	8017058 <jpeg_make_d_derived_tbl+0x388>
    if (htbl->bits[l]) {
 8016fce:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8016fd2:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8016fd6:	4413      	add	r3, r2
 8016fd8:	781b      	ldrb	r3, [r3, #0]
 8016fda:	2b00      	cmp	r3, #0
 8016fdc:	d02f      	beq.n	801703e <jpeg_make_d_derived_tbl+0x36e>
      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
       * minus the minimum code of length l
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
 8016fde:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8016fe2:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 8016fe6:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 8016fea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016fee:	461a      	mov	r2, r3
 8016ff0:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8016ff4:	1a99      	subs	r1, r3, r2
 8016ff6:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8016ffa:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8016ffe:	3212      	adds	r2, #18
 8017000:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      p += htbl->bits[l];
 8017004:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8017008:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 801700c:	4413      	add	r3, r2
 801700e:	781b      	ldrb	r3, [r3, #0]
 8017010:	461a      	mov	r2, r3
 8017012:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8017016:	4413      	add	r3, r2
 8017018:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
 801701c:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8017020:	1e5a      	subs	r2, r3, #1
 8017022:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8017026:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 801702a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801702e:	4619      	mov	r1, r3
 8017030:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8017034:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8017038:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801703c:	e007      	b.n	801704e <jpeg_make_d_derived_tbl+0x37e>
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
 801703e:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8017042:	f8d7 253c 	ldr.w	r2, [r7, #1340]	@ 0x53c
 8017046:	f04f 31ff 	mov.w	r1, #4294967295
 801704a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (l = 1; l <= 16; l++) {
 801704e:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8017052:	3301      	adds	r3, #1
 8017054:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8017058:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 801705c:	2b10      	cmp	r3, #16
 801705e:	ddb6      	ble.n	8016fce <jpeg_make_d_derived_tbl+0x2fe>
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
 8017060:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 8017064:	4a5a      	ldr	r2, [pc, #360]	@ (80171d0 <jpeg_make_d_derived_tbl+0x500>)
 8017066:	645a      	str	r2, [r3, #68]	@ 0x44
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
 8017068:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 801706c:	3390      	adds	r3, #144	@ 0x90
 801706e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8017072:	2100      	movs	r1, #0
 8017074:	4618      	mov	r0, r3
 8017076:	f018 fc93 	bl	802f9a0 <memset>

  p = 0;
 801707a:	2300      	movs	r3, #0
 801707c:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 8017080:	2301      	movs	r3, #1
 8017082:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8017086:	e05e      	b.n	8017146 <jpeg_make_d_derived_tbl+0x476>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 8017088:	2301      	movs	r3, #1
 801708a:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 801708e:	e04a      	b.n	8017126 <jpeg_make_d_derived_tbl+0x456>
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
 8017090:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8017094:	f2a3 5334 	subw	r3, r3, #1332	@ 0x534
 8017098:	f8d7 2544 	ldr.w	r2, [r7, #1348]	@ 0x544
 801709c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80170a0:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 80170a4:	f1c3 0308 	rsb	r3, r3, #8
 80170a8:	fa02 f303 	lsl.w	r3, r2, r3
 80170ac:	f8c7 3534 	str.w	r3, [r7, #1332]	@ 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 80170b0:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 80170b4:	f1c3 0308 	rsb	r3, r3, #8
 80170b8:	2201      	movs	r2, #1
 80170ba:	fa02 f303 	lsl.w	r3, r2, r3
 80170be:	f8c7 3530 	str.w	r3, [r7, #1328]	@ 0x530
 80170c2:	e022      	b.n	801710a <jpeg_make_d_derived_tbl+0x43a>
	dtbl->look_nbits[lookbits] = l;
 80170c4:	f8d7 3524 	ldr.w	r3, [r7, #1316]	@ 0x524
 80170c8:	f8d7 2534 	ldr.w	r2, [r7, #1332]	@ 0x534
 80170cc:	3224      	adds	r2, #36	@ 0x24
 80170ce:	f8d7 153c 	ldr.w	r1, [r7, #1340]	@ 0x53c
 80170d2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	dtbl->look_sym[lookbits] = htbl->huffval[p];
 80170d6:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 80170da:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 80170de:	4413      	add	r3, r2
 80170e0:	3311      	adds	r3, #17
 80170e2:	7819      	ldrb	r1, [r3, #0]
 80170e4:	f8d7 2524 	ldr.w	r2, [r7, #1316]	@ 0x524
 80170e8:	f8d7 3534 	ldr.w	r3, [r7, #1332]	@ 0x534
 80170ec:	4413      	add	r3, r2
 80170ee:	f503 6392 	add.w	r3, r3, #1168	@ 0x490
 80170f2:	460a      	mov	r2, r1
 80170f4:	701a      	strb	r2, [r3, #0]
	lookbits++;
 80170f6:	f8d7 3534 	ldr.w	r3, [r7, #1332]	@ 0x534
 80170fa:	3301      	adds	r3, #1
 80170fc:	f8c7 3534 	str.w	r3, [r7, #1332]	@ 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 8017100:	f8d7 3530 	ldr.w	r3, [r7, #1328]	@ 0x530
 8017104:	3b01      	subs	r3, #1
 8017106:	f8c7 3530 	str.w	r3, [r7, #1328]	@ 0x530
 801710a:	f8d7 3530 	ldr.w	r3, [r7, #1328]	@ 0x530
 801710e:	2b00      	cmp	r3, #0
 8017110:	dcd8      	bgt.n	80170c4 <jpeg_make_d_derived_tbl+0x3f4>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 8017112:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8017116:	3301      	adds	r3, #1
 8017118:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 801711c:	f8d7 3544 	ldr.w	r3, [r7, #1348]	@ 0x544
 8017120:	3301      	adds	r3, #1
 8017122:	f8c7 3544 	str.w	r3, [r7, #1348]	@ 0x544
 8017126:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 801712a:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 801712e:	4413      	add	r3, r2
 8017130:	781b      	ldrb	r3, [r3, #0]
 8017132:	461a      	mov	r2, r3
 8017134:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 8017138:	4293      	cmp	r3, r2
 801713a:	dda9      	ble.n	8017090 <jpeg_make_d_derived_tbl+0x3c0>
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 801713c:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 8017140:	3301      	adds	r3, #1
 8017142:	f8c7 353c 	str.w	r3, [r7, #1340]	@ 0x53c
 8017146:	f8d7 353c 	ldr.w	r3, [r7, #1340]	@ 0x53c
 801714a:	2b08      	cmp	r3, #8
 801714c:	dd9c      	ble.n	8017088 <jpeg_make_d_derived_tbl+0x3b8>
   * For AC tables, we make no check, but accept all byte values 0..255.
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
 801714e:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 8017152:	f5a3 63a8 	sub.w	r3, r3, #1344	@ 0x540
 8017156:	681b      	ldr	r3, [r3, #0]
 8017158:	2b00      	cmp	r3, #0
 801715a:	d034      	beq.n	80171c6 <jpeg_make_d_derived_tbl+0x4f6>
    for (i = 0; i < numsymbols; i++) {
 801715c:	2300      	movs	r3, #0
 801715e:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 8017162:	e02a      	b.n	80171ba <jpeg_make_d_derived_tbl+0x4ea>
      int sym = htbl->huffval[i];
 8017164:	f8d7 2528 	ldr.w	r2, [r7, #1320]	@ 0x528
 8017168:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 801716c:	4413      	add	r3, r2
 801716e:	3311      	adds	r3, #17
 8017170:	781b      	ldrb	r3, [r3, #0]
 8017172:	f8c7 351c 	str.w	r3, [r7, #1308]	@ 0x51c
      if (sym < 0 || sym > 15)
 8017176:	f8d7 351c 	ldr.w	r3, [r7, #1308]	@ 0x51c
 801717a:	2b00      	cmp	r3, #0
 801717c:	db03      	blt.n	8017186 <jpeg_make_d_derived_tbl+0x4b6>
 801717e:	f8d7 351c 	ldr.w	r3, [r7, #1308]	@ 0x51c
 8017182:	2b0f      	cmp	r3, #15
 8017184:	dd14      	ble.n	80171b0 <jpeg_make_d_derived_tbl+0x4e0>
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8017186:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 801718a:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 801718e:	681b      	ldr	r3, [r3, #0]
 8017190:	681b      	ldr	r3, [r3, #0]
 8017192:	2209      	movs	r2, #9
 8017194:	615a      	str	r2, [r3, #20]
 8017196:	f507 63a9 	add.w	r3, r7, #1352	@ 0x548
 801719a:	f2a3 533c 	subw	r3, r3, #1340	@ 0x53c
 801719e:	681b      	ldr	r3, [r3, #0]
 80171a0:	681b      	ldr	r3, [r3, #0]
 80171a2:	681b      	ldr	r3, [r3, #0]
 80171a4:	f507 62a9 	add.w	r2, r7, #1352	@ 0x548
 80171a8:	f2a2 523c 	subw	r2, r2, #1340	@ 0x53c
 80171ac:	6810      	ldr	r0, [r2, #0]
 80171ae:	4798      	blx	r3
    for (i = 0; i < numsymbols; i++) {
 80171b0:	f8d7 3540 	ldr.w	r3, [r7, #1344]	@ 0x540
 80171b4:	3301      	adds	r3, #1
 80171b6:	f8c7 3540 	str.w	r3, [r7, #1344]	@ 0x540
 80171ba:	f8d7 2540 	ldr.w	r2, [r7, #1344]	@ 0x540
 80171be:	f8d7 3520 	ldr.w	r3, [r7, #1312]	@ 0x520
 80171c2:	429a      	cmp	r2, r3
 80171c4:	dbce      	blt.n	8017164 <jpeg_make_d_derived_tbl+0x494>
    }
  }
}
 80171c6:	bf00      	nop
 80171c8:	f207 574c 	addw	r7, r7, #1356	@ 0x54c
 80171cc:	46bd      	mov	sp, r7
 80171ce:	bd90      	pop	{r4, r7, pc}
 80171d0:	000fffff 	.word	0x000fffff

080171d4 <jpeg_fill_bit_buffer>:
LOCAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
 80171d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80171d6:	b087      	sub	sp, #28
 80171d8:	af00      	add	r7, sp, #0
 80171da:	60f8      	str	r0, [r7, #12]
 80171dc:	6079      	str	r1, [r7, #4]
 80171de:	4615      	mov	r5, r2
 80171e0:	60bb      	str	r3, [r7, #8]
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
 80171e2:	68fb      	ldr	r3, [r7, #12]
 80171e4:	681e      	ldr	r6, [r3, #0]
  register size_t bytes_in_buffer = state->bytes_in_buffer;
 80171e6:	68fb      	ldr	r3, [r7, #12]
 80171e8:	685c      	ldr	r4, [r3, #4]
  j_decompress_ptr cinfo = state->cinfo;
 80171ea:	68fb      	ldr	r3, [r7, #12]
 80171ec:	691b      	ldr	r3, [r3, #16]
 80171ee:	617b      	str	r3, [r7, #20]

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
 80171f0:	697b      	ldr	r3, [r7, #20]
 80171f2:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 80171f6:	2b00      	cmp	r3, #0
 80171f8:	d143      	bne.n	8017282 <jpeg_fill_bit_buffer+0xae>
    while (bits_left < MIN_GET_BITS) {
 80171fa:	e03f      	b.n	801727c <jpeg_fill_bit_buffer+0xa8>
      register int c;

      /* Attempt to read a byte */
      if (bytes_in_buffer == 0) {
 80171fc:	2c00      	cmp	r4, #0
 80171fe:	d10f      	bne.n	8017220 <jpeg_fill_bit_buffer+0x4c>
	if (! (*cinfo->src->fill_input_buffer) (cinfo))
 8017200:	697b      	ldr	r3, [r7, #20]
 8017202:	699b      	ldr	r3, [r3, #24]
 8017204:	68db      	ldr	r3, [r3, #12]
 8017206:	6978      	ldr	r0, [r7, #20]
 8017208:	4798      	blx	r3
 801720a:	4603      	mov	r3, r0
 801720c:	2b00      	cmp	r3, #0
 801720e:	d101      	bne.n	8017214 <jpeg_fill_bit_buffer+0x40>
	  return FALSE;
 8017210:	2300      	movs	r3, #0
 8017212:	e060      	b.n	80172d6 <jpeg_fill_bit_buffer+0x102>
	next_input_byte = cinfo->src->next_input_byte;
 8017214:	697b      	ldr	r3, [r7, #20]
 8017216:	699b      	ldr	r3, [r3, #24]
 8017218:	681e      	ldr	r6, [r3, #0]
	bytes_in_buffer = cinfo->src->bytes_in_buffer;
 801721a:	697b      	ldr	r3, [r7, #20]
 801721c:	699b      	ldr	r3, [r3, #24]
 801721e:	685c      	ldr	r4, [r3, #4]
      }
      bytes_in_buffer--;
 8017220:	3c01      	subs	r4, #1
      c = GETJOCTET(*next_input_byte++);
 8017222:	4633      	mov	r3, r6
 8017224:	1c5e      	adds	r6, r3, #1
 8017226:	781b      	ldrb	r3, [r3, #0]
 8017228:	461a      	mov	r2, r3

      /* If it's 0xFF, check and discard stuffed zero byte */
      if (c == 0xFF) {
 801722a:	2bff      	cmp	r3, #255	@ 0xff
 801722c:	d121      	bne.n	8017272 <jpeg_fill_bit_buffer+0x9e>
	 * so that we can save a valid unread_marker value.  NOTE: we will
	 * accept multiple FF's followed by a 0 as meaning a single FF data
	 * byte.  This data pattern is not valid according to the standard.
	 */
	do {
	  if (bytes_in_buffer == 0) {
 801722e:	2c00      	cmp	r4, #0
 8017230:	d10f      	bne.n	8017252 <jpeg_fill_bit_buffer+0x7e>
	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
 8017232:	697b      	ldr	r3, [r7, #20]
 8017234:	699b      	ldr	r3, [r3, #24]
 8017236:	68db      	ldr	r3, [r3, #12]
 8017238:	6978      	ldr	r0, [r7, #20]
 801723a:	4798      	blx	r3
 801723c:	4603      	mov	r3, r0
 801723e:	2b00      	cmp	r3, #0
 8017240:	d101      	bne.n	8017246 <jpeg_fill_bit_buffer+0x72>
	      return FALSE;
 8017242:	2300      	movs	r3, #0
 8017244:	e047      	b.n	80172d6 <jpeg_fill_bit_buffer+0x102>
	    next_input_byte = cinfo->src->next_input_byte;
 8017246:	697b      	ldr	r3, [r7, #20]
 8017248:	699b      	ldr	r3, [r3, #24]
 801724a:	681e      	ldr	r6, [r3, #0]
	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
 801724c:	697b      	ldr	r3, [r7, #20]
 801724e:	699b      	ldr	r3, [r3, #24]
 8017250:	685c      	ldr	r4, [r3, #4]
	  }
	  bytes_in_buffer--;
 8017252:	3c01      	subs	r4, #1
	  c = GETJOCTET(*next_input_byte++);
 8017254:	4633      	mov	r3, r6
 8017256:	1c5e      	adds	r6, r3, #1
 8017258:	781b      	ldrb	r3, [r3, #0]
 801725a:	461a      	mov	r2, r3
	} while (c == 0xFF);
 801725c:	2bff      	cmp	r3, #255	@ 0xff
 801725e:	d0e6      	beq.n	801722e <jpeg_fill_bit_buffer+0x5a>

	if (c == 0) {
 8017260:	2b00      	cmp	r3, #0
 8017262:	d102      	bne.n	801726a <jpeg_fill_bit_buffer+0x96>
	  /* Found FF/00, which represents an FF data byte */
	  c = 0xFF;
 8017264:	23ff      	movs	r3, #255	@ 0xff
 8017266:	461a      	mov	r2, r3
 8017268:	e003      	b.n	8017272 <jpeg_fill_bit_buffer+0x9e>
	   * bitread working state, not straight into permanent state.  But
	   * once we have hit a marker, we cannot need to suspend within the
	   * current MCU, because we will read no more bytes from the data
	   * source.  So it is OK to update permanent state right away.
	   */
	  cinfo->unread_marker = c;
 801726a:	697b      	ldr	r3, [r7, #20]
 801726c:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
	  /* See if we need to insert some fake zero bits. */
	  goto no_more_bytes;
 8017270:	e008      	b.n	8017284 <jpeg_fill_bit_buffer+0xb0>
	}
      }

      /* OK, load c into get_buffer */
      get_buffer = (get_buffer << 8) | c;
 8017272:	687b      	ldr	r3, [r7, #4]
 8017274:	021b      	lsls	r3, r3, #8
 8017276:	431a      	orrs	r2, r3
 8017278:	607a      	str	r2, [r7, #4]
      bits_left += 8;
 801727a:	3508      	adds	r5, #8
    while (bits_left < MIN_GET_BITS) {
 801727c:	2d18      	cmp	r5, #24
 801727e:	ddbd      	ble.n	80171fc <jpeg_fill_bit_buffer+0x28>
 8017280:	e01f      	b.n	80172c2 <jpeg_fill_bit_buffer+0xee>
    } /* end while */
  } else {
  no_more_bytes:
 8017282:	bf00      	nop
    /* We get here if we've read the marker that terminates the compressed
     * data segment.  There should be enough bits in the buffer register
     * to satisfy the request; if so, no problem.
     */
    if (nbits > bits_left) {
 8017284:	68bb      	ldr	r3, [r7, #8]
 8017286:	42ab      	cmp	r3, r5
 8017288:	dd1b      	ble.n	80172c2 <jpeg_fill_bit_buffer+0xee>
      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
       * the data stream, so that we can produce some kind of image.
       * We use a nonvolatile flag to ensure that only one warning message
       * appears per data segment.
       */
      if (! ((huff_entropy_ptr) cinfo->entropy)->insufficient_data) {
 801728a:	697b      	ldr	r3, [r7, #20]
 801728c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8017290:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017292:	2b00      	cmp	r3, #0
 8017294:	d10f      	bne.n	80172b6 <jpeg_fill_bit_buffer+0xe2>
	WARNMS(cinfo, JWRN_HIT_MARKER);
 8017296:	697b      	ldr	r3, [r7, #20]
 8017298:	681b      	ldr	r3, [r3, #0]
 801729a:	2278      	movs	r2, #120	@ 0x78
 801729c:	615a      	str	r2, [r3, #20]
 801729e:	697b      	ldr	r3, [r7, #20]
 80172a0:	681b      	ldr	r3, [r3, #0]
 80172a2:	685b      	ldr	r3, [r3, #4]
 80172a4:	f04f 31ff 	mov.w	r1, #4294967295
 80172a8:	6978      	ldr	r0, [r7, #20]
 80172aa:	4798      	blx	r3
	((huff_entropy_ptr) cinfo->entropy)->insufficient_data = TRUE;
 80172ac:	697b      	ldr	r3, [r7, #20]
 80172ae:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80172b2:	2201      	movs	r2, #1
 80172b4:	625a      	str	r2, [r3, #36]	@ 0x24
      }
      /* Fill the buffer with zero bits */
      get_buffer <<= MIN_GET_BITS - bits_left;
 80172b6:	f1c5 0319 	rsb	r3, r5, #25
 80172ba:	687a      	ldr	r2, [r7, #4]
 80172bc:	409a      	lsls	r2, r3
 80172be:	607a      	str	r2, [r7, #4]
      bits_left = MIN_GET_BITS;
 80172c0:	2519      	movs	r5, #25
    }
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
 80172c2:	68fb      	ldr	r3, [r7, #12]
 80172c4:	601e      	str	r6, [r3, #0]
  state->bytes_in_buffer = bytes_in_buffer;
 80172c6:	68fb      	ldr	r3, [r7, #12]
 80172c8:	605c      	str	r4, [r3, #4]
  state->get_buffer = get_buffer;
 80172ca:	68fb      	ldr	r3, [r7, #12]
 80172cc:	687a      	ldr	r2, [r7, #4]
 80172ce:	609a      	str	r2, [r3, #8]
  state->bits_left = bits_left;
 80172d0:	68fb      	ldr	r3, [r7, #12]
 80172d2:	60dd      	str	r5, [r3, #12]

  return TRUE;
 80172d4:	2301      	movs	r3, #1
}
 80172d6:	4618      	mov	r0, r3
 80172d8:	371c      	adds	r7, #28
 80172da:	46bd      	mov	sp, r7
 80172dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080172e0 <jpeg_huff_decode>:

LOCAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
 80172e0:	b5b0      	push	{r4, r5, r7, lr}
 80172e2:	b082      	sub	sp, #8
 80172e4:	af00      	add	r7, sp, #0
 80172e6:	6078      	str	r0, [r7, #4]
 80172e8:	603b      	str	r3, [r7, #0]
  register int l = min_bits;
 80172ea:	69bc      	ldr	r4, [r7, #24]
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
 80172ec:	42a2      	cmp	r2, r4
 80172ee:	da0d      	bge.n	801730c <jpeg_huff_decode+0x2c>
 80172f0:	4623      	mov	r3, r4
 80172f2:	6878      	ldr	r0, [r7, #4]
 80172f4:	f7ff ff6e 	bl	80171d4 <jpeg_fill_bit_buffer>
 80172f8:	4603      	mov	r3, r0
 80172fa:	2b00      	cmp	r3, #0
 80172fc:	d102      	bne.n	8017304 <jpeg_huff_decode+0x24>
 80172fe:	f04f 33ff 	mov.w	r3, #4294967295
 8017302:	e04b      	b.n	801739c <jpeg_huff_decode+0xbc>
 8017304:	687b      	ldr	r3, [r7, #4]
 8017306:	6899      	ldr	r1, [r3, #8]
 8017308:	687b      	ldr	r3, [r7, #4]
 801730a:	68da      	ldr	r2, [r3, #12]
  code = GET_BITS(l);
 801730c:	1b12      	subs	r2, r2, r4
 801730e:	fa41 f002 	asr.w	r0, r1, r2
 8017312:	4b24      	ldr	r3, [pc, #144]	@ (80173a4 <jpeg_huff_decode+0xc4>)
 8017314:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8017318:	ea00 0503 	and.w	r5, r0, r3

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
 801731c:	e017      	b.n	801734e <jpeg_huff_decode+0x6e>
    code <<= 1;
 801731e:	006d      	lsls	r5, r5, #1
    CHECK_BIT_BUFFER(*state, 1, return -1);
 8017320:	2a00      	cmp	r2, #0
 8017322:	dc0d      	bgt.n	8017340 <jpeg_huff_decode+0x60>
 8017324:	2301      	movs	r3, #1
 8017326:	6878      	ldr	r0, [r7, #4]
 8017328:	f7ff ff54 	bl	80171d4 <jpeg_fill_bit_buffer>
 801732c:	4603      	mov	r3, r0
 801732e:	2b00      	cmp	r3, #0
 8017330:	d102      	bne.n	8017338 <jpeg_huff_decode+0x58>
 8017332:	f04f 33ff 	mov.w	r3, #4294967295
 8017336:	e031      	b.n	801739c <jpeg_huff_decode+0xbc>
 8017338:	687b      	ldr	r3, [r7, #4]
 801733a:	6899      	ldr	r1, [r3, #8]
 801733c:	687b      	ldr	r3, [r7, #4]
 801733e:	68da      	ldr	r2, [r3, #12]
    code |= GET_BITS(1);
 8017340:	3a01      	subs	r2, #1
 8017342:	fa41 f302 	asr.w	r3, r1, r2
 8017346:	2001      	movs	r0, #1
 8017348:	4003      	ands	r3, r0
 801734a:	431d      	orrs	r5, r3
    l++;
 801734c:	3401      	adds	r4, #1
  while (code > htbl->maxcode[l]) {
 801734e:	683b      	ldr	r3, [r7, #0]
 8017350:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8017354:	429d      	cmp	r5, r3
 8017356:	dce2      	bgt.n	801731e <jpeg_huff_decode+0x3e>
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
 8017358:	687b      	ldr	r3, [r7, #4]
 801735a:	6099      	str	r1, [r3, #8]
  state->bits_left = bits_left;
 801735c:	687b      	ldr	r3, [r7, #4]
 801735e:	60da      	str	r2, [r3, #12]

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
 8017360:	2c10      	cmp	r4, #16
 8017362:	dd10      	ble.n	8017386 <jpeg_huff_decode+0xa6>
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
 8017364:	687b      	ldr	r3, [r7, #4]
 8017366:	691b      	ldr	r3, [r3, #16]
 8017368:	681b      	ldr	r3, [r3, #0]
 801736a:	2279      	movs	r2, #121	@ 0x79
 801736c:	615a      	str	r2, [r3, #20]
 801736e:	687b      	ldr	r3, [r7, #4]
 8017370:	691b      	ldr	r3, [r3, #16]
 8017372:	681b      	ldr	r3, [r3, #0]
 8017374:	685b      	ldr	r3, [r3, #4]
 8017376:	687a      	ldr	r2, [r7, #4]
 8017378:	6912      	ldr	r2, [r2, #16]
 801737a:	f04f 31ff 	mov.w	r1, #4294967295
 801737e:	4610      	mov	r0, r2
 8017380:	4798      	blx	r3
    return 0;			/* fake a zero as the safest result */
 8017382:	2300      	movs	r3, #0
 8017384:	e00a      	b.n	801739c <jpeg_huff_decode+0xbc>
  }

  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
 8017386:	683b      	ldr	r3, [r7, #0]
 8017388:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 801738c:	683b      	ldr	r3, [r7, #0]
 801738e:	f104 0112 	add.w	r1, r4, #18
 8017392:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8017396:	442b      	add	r3, r5
 8017398:	4413      	add	r3, r2
 801739a:	7c5b      	ldrb	r3, [r3, #17]
}
 801739c:	4618      	mov	r0, r3
 801739e:	3708      	adds	r7, #8
 80173a0:	46bd      	mov	sp, r7
 80173a2:	bdb0      	pop	{r4, r5, r7, pc}
 80173a4:	080323f4 	.word	0x080323f4

080173a8 <process_restart>:
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
 80173a8:	b580      	push	{r7, lr}
 80173aa:	b084      	sub	sp, #16
 80173ac:	af00      	add	r7, sp, #0
 80173ae:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 80173b0:	687b      	ldr	r3, [r7, #4]
 80173b2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 80173b6:	60bb      	str	r3, [r7, #8]
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
 80173b8:	687b      	ldr	r3, [r7, #4]
 80173ba:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80173be:	699a      	ldr	r2, [r3, #24]
 80173c0:	68bb      	ldr	r3, [r7, #8]
 80173c2:	68db      	ldr	r3, [r3, #12]
 80173c4:	2b00      	cmp	r3, #0
 80173c6:	da00      	bge.n	80173ca <process_restart+0x22>
 80173c8:	3307      	adds	r3, #7
 80173ca:	10db      	asrs	r3, r3, #3
 80173cc:	4619      	mov	r1, r3
 80173ce:	687b      	ldr	r3, [r7, #4]
 80173d0:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80173d4:	440a      	add	r2, r1
 80173d6:	619a      	str	r2, [r3, #24]
  entropy->bitstate.bits_left = 0;
 80173d8:	68bb      	ldr	r3, [r7, #8]
 80173da:	2200      	movs	r2, #0
 80173dc:	60da      	str	r2, [r3, #12]

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 80173de:	687b      	ldr	r3, [r7, #4]
 80173e0:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 80173e4:	689b      	ldr	r3, [r3, #8]
 80173e6:	6878      	ldr	r0, [r7, #4]
 80173e8:	4798      	blx	r3
 80173ea:	4603      	mov	r3, r0
 80173ec:	2b00      	cmp	r3, #0
 80173ee:	d101      	bne.n	80173f4 <process_restart+0x4c>
    return FALSE;
 80173f0:	2300      	movs	r3, #0
 80173f2:	e023      	b.n	801743c <process_restart+0x94>

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 80173f4:	2300      	movs	r3, #0
 80173f6:	60fb      	str	r3, [r7, #12]
 80173f8:	e009      	b.n	801740e <process_restart+0x66>
    entropy->saved.last_dc_val[ci] = 0;
 80173fa:	68ba      	ldr	r2, [r7, #8]
 80173fc:	68fb      	ldr	r3, [r7, #12]
 80173fe:	3304      	adds	r3, #4
 8017400:	009b      	lsls	r3, r3, #2
 8017402:	4413      	add	r3, r2
 8017404:	2200      	movs	r2, #0
 8017406:	605a      	str	r2, [r3, #4]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 8017408:	68fb      	ldr	r3, [r7, #12]
 801740a:	3301      	adds	r3, #1
 801740c:	60fb      	str	r3, [r7, #12]
 801740e:	687b      	ldr	r3, [r7, #4]
 8017410:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8017414:	68fa      	ldr	r2, [r7, #12]
 8017416:	429a      	cmp	r2, r3
 8017418:	dbef      	blt.n	80173fa <process_restart+0x52>
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;
 801741a:	68bb      	ldr	r3, [r7, #8]
 801741c:	2200      	movs	r2, #0
 801741e:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8017420:	687b      	ldr	r3, [r7, #4]
 8017422:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8017426:	68bb      	ldr	r3, [r7, #8]
 8017428:	629a      	str	r2, [r3, #40]	@ 0x28
  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
 801742a:	687b      	ldr	r3, [r7, #4]
 801742c:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 8017430:	2b00      	cmp	r3, #0
 8017432:	d102      	bne.n	801743a <process_restart+0x92>
    entropy->insufficient_data = FALSE;
 8017434:	68bb      	ldr	r3, [r7, #8]
 8017436:	2200      	movs	r2, #0
 8017438:	625a      	str	r2, [r3, #36]	@ 0x24

  return TRUE;
 801743a:	2301      	movs	r3, #1
}
 801743c:	4618      	mov	r0, r3
 801743e:	3710      	adds	r7, #16
 8017440:	46bd      	mov	sp, r7
 8017442:	bd80      	pop	{r7, pc}

08017444 <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8017444:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017448:	b096      	sub	sp, #88	@ 0x58
 801744a:	af02      	add	r7, sp, #8
 801744c:	6078      	str	r0, [r7, #4]
 801744e:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8017450:	687b      	ldr	r3, [r7, #4]
 8017452:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8017456:	64bb      	str	r3, [r7, #72]	@ 0x48
  int Al = cinfo->Al;
 8017458:	687b      	ldr	r3, [r7, #4]
 801745a:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 801745e:	647b      	str	r3, [r7, #68]	@ 0x44
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8017460:	687b      	ldr	r3, [r7, #4]
 8017462:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8017466:	2b00      	cmp	r3, #0
 8017468:	d00b      	beq.n	8017482 <decode_mcu_DC_first+0x3e>
    if (entropy->restarts_to_go == 0)
 801746a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801746c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801746e:	2b00      	cmp	r3, #0
 8017470:	d107      	bne.n	8017482 <decode_mcu_DC_first+0x3e>
      if (! process_restart(cinfo))
 8017472:	6878      	ldr	r0, [r7, #4]
 8017474:	f7ff ff98 	bl	80173a8 <process_restart>
 8017478:	4603      	mov	r3, r0
 801747a:	2b00      	cmp	r3, #0
 801747c:	d101      	bne.n	8017482 <decode_mcu_DC_first+0x3e>
	return FALSE;
 801747e:	2300      	movs	r3, #0
 8017480:	e0d4      	b.n	801762c <decode_mcu_DC_first+0x1e8>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8017482:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017484:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017486:	2b00      	cmp	r3, #0
 8017488:	f040 80ca 	bne.w	8017620 <decode_mcu_DC_first+0x1dc>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 801748c:	687b      	ldr	r3, [r7, #4]
 801748e:	633b      	str	r3, [r7, #48]	@ 0x30
 8017490:	687b      	ldr	r3, [r7, #4]
 8017492:	699b      	ldr	r3, [r3, #24]
 8017494:	681b      	ldr	r3, [r3, #0]
 8017496:	623b      	str	r3, [r7, #32]
 8017498:	687b      	ldr	r3, [r7, #4]
 801749a:	699b      	ldr	r3, [r3, #24]
 801749c:	685b      	ldr	r3, [r3, #4]
 801749e:	627b      	str	r3, [r7, #36]	@ 0x24
 80174a0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80174a2:	689e      	ldr	r6, [r3, #8]
 80174a4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80174a6:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 80174a8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80174aa:	f107 050c 	add.w	r5, r7, #12
 80174ae:	f103 0c10 	add.w	ip, r3, #16
 80174b2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80174b6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80174b8:	f8dc 3000 	ldr.w	r3, [ip]
 80174bc:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80174be:	2300      	movs	r3, #0
 80174c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80174c2:	e091      	b.n	80175e8 <decode_mcu_DC_first+0x1a4>
      block = MCU_data[blkn];
 80174c4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80174c6:	009b      	lsls	r3, r3, #2
 80174c8:	683a      	ldr	r2, [r7, #0]
 80174ca:	4413      	add	r3, r2
 80174cc:	681b      	ldr	r3, [r3, #0]
 80174ce:	643b      	str	r3, [r7, #64]	@ 0x40
      ci = cinfo->MCU_membership[blkn];
 80174d0:	687b      	ldr	r3, [r7, #4]
 80174d2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80174d4:	325c      	adds	r2, #92	@ 0x5c
 80174d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80174da:	63fb      	str	r3, [r7, #60]	@ 0x3c
      compptr = cinfo->cur_comp_info[ci];
 80174dc:	687a      	ldr	r2, [r7, #4]
 80174de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80174e0:	3354      	adds	r3, #84	@ 0x54
 80174e2:	009b      	lsls	r3, r3, #2
 80174e4:	4413      	add	r3, r2
 80174e6:	685b      	ldr	r3, [r3, #4]
 80174e8:	63bb      	str	r3, [r7, #56]	@ 0x38
      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
 80174ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174ec:	695b      	ldr	r3, [r3, #20]
 80174ee:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80174f0:	330a      	adds	r3, #10
 80174f2:	009b      	lsls	r3, r3, #2
 80174f4:	4413      	add	r3, r2
 80174f6:	685b      	ldr	r3, [r3, #4]
 80174f8:	637b      	str	r3, [r7, #52]	@ 0x34

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 80174fa:	2c07      	cmp	r4, #7
 80174fc:	dc11      	bgt.n	8017522 <decode_mcu_DC_first+0xde>
 80174fe:	f107 0020 	add.w	r0, r7, #32
 8017502:	2300      	movs	r3, #0
 8017504:	4622      	mov	r2, r4
 8017506:	4631      	mov	r1, r6
 8017508:	f7ff fe64 	bl	80171d4 <jpeg_fill_bit_buffer>
 801750c:	4603      	mov	r3, r0
 801750e:	2b00      	cmp	r3, #0
 8017510:	d101      	bne.n	8017516 <decode_mcu_DC_first+0xd2>
 8017512:	2300      	movs	r3, #0
 8017514:	e08a      	b.n	801762c <decode_mcu_DC_first+0x1e8>
 8017516:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 8017518:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
 801751a:	2c07      	cmp	r4, #7
 801751c:	dc01      	bgt.n	8017522 <decode_mcu_DC_first+0xde>
 801751e:	2501      	movs	r5, #1
 8017520:	e015      	b.n	801754e <decode_mcu_DC_first+0x10a>
 8017522:	f1a4 0308 	sub.w	r3, r4, #8
 8017526:	fa46 f303 	asr.w	r3, r6, r3
 801752a:	22ff      	movs	r2, #255	@ 0xff
 801752c:	ea03 0802 	and.w	r8, r3, r2
 8017530:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017532:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8017536:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801753a:	2d00      	cmp	r5, #0
 801753c:	d006      	beq.n	801754c <decode_mcu_DC_first+0x108>
 801753e:	1b64      	subs	r4, r4, r5
 8017540:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017542:	4443      	add	r3, r8
 8017544:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8017548:	461d      	mov	r5, r3
 801754a:	e00f      	b.n	801756c <decode_mcu_DC_first+0x128>
 801754c:	2509      	movs	r5, #9
 801754e:	f107 0020 	add.w	r0, r7, #32
 8017552:	9500      	str	r5, [sp, #0]
 8017554:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017556:	4622      	mov	r2, r4
 8017558:	4631      	mov	r1, r6
 801755a:	f7ff fec1 	bl	80172e0 <jpeg_huff_decode>
 801755e:	4605      	mov	r5, r0
 8017560:	2d00      	cmp	r5, #0
 8017562:	da01      	bge.n	8017568 <decode_mcu_DC_first+0x124>
 8017564:	2300      	movs	r3, #0
 8017566:	e061      	b.n	801762c <decode_mcu_DC_first+0x1e8>
 8017568:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 801756a:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
      if (s) {
 801756c:	2d00      	cmp	r5, #0
 801756e:	d025      	beq.n	80175bc <decode_mcu_DC_first+0x178>
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8017570:	42ac      	cmp	r4, r5
 8017572:	da0d      	bge.n	8017590 <decode_mcu_DC_first+0x14c>
 8017574:	f107 0020 	add.w	r0, r7, #32
 8017578:	462b      	mov	r3, r5
 801757a:	4622      	mov	r2, r4
 801757c:	4631      	mov	r1, r6
 801757e:	f7ff fe29 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017582:	4603      	mov	r3, r0
 8017584:	2b00      	cmp	r3, #0
 8017586:	d101      	bne.n	801758c <decode_mcu_DC_first+0x148>
 8017588:	2300      	movs	r3, #0
 801758a:	e04f      	b.n	801762c <decode_mcu_DC_first+0x1e8>
 801758c:	6abe      	ldr	r6, [r7, #40]	@ 0x28
 801758e:	6afc      	ldr	r4, [r7, #44]	@ 0x2c
	r = GET_BITS(s);
 8017590:	1b64      	subs	r4, r4, r5
 8017592:	fa46 f204 	asr.w	r2, r6, r4
 8017596:	4b28      	ldr	r3, [pc, #160]	@ (8017638 <decode_mcu_DC_first+0x1f4>)
 8017598:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 801759c:	ea02 0803 	and.w	r8, r2, r3
	s = HUFF_EXTEND(r, s);
 80175a0:	1e6b      	subs	r3, r5, #1
 80175a2:	4a25      	ldr	r2, [pc, #148]	@ (8017638 <decode_mcu_DC_first+0x1f4>)
 80175a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80175a8:	4598      	cmp	r8, r3
 80175aa:	dc05      	bgt.n	80175b8 <decode_mcu_DC_first+0x174>
 80175ac:	4b22      	ldr	r3, [pc, #136]	@ (8017638 <decode_mcu_DC_first+0x1f4>)
 80175ae:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80175b2:	eba8 0303 	sub.w	r3, r8, r3
 80175b6:	e000      	b.n	80175ba <decode_mcu_DC_first+0x176>
 80175b8:	4643      	mov	r3, r8
 80175ba:	461d      	mov	r5, r3
      }

      /* Convert DC difference to actual value, update last_dc_val */
      s += state.last_dc_val[ci];
 80175bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80175be:	009b      	lsls	r3, r3, #2
 80175c0:	3350      	adds	r3, #80	@ 0x50
 80175c2:	443b      	add	r3, r7
 80175c4:	f853 3c40 	ldr.w	r3, [r3, #-64]
 80175c8:	441d      	add	r5, r3
      state.last_dc_val[ci] = s;
 80175ca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80175cc:	009b      	lsls	r3, r3, #2
 80175ce:	3350      	adds	r3, #80	@ 0x50
 80175d0:	443b      	add	r3, r7
 80175d2:	f843 5c40 	str.w	r5, [r3, #-64]
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
 80175d6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80175d8:	fa05 f303 	lsl.w	r3, r5, r3
 80175dc:	b21a      	sxth	r2, r3
 80175de:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80175e0:	801a      	strh	r2, [r3, #0]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80175e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80175e4:	3301      	adds	r3, #1
 80175e6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80175e8:	687b      	ldr	r3, [r7, #4]
 80175ea:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 80175ee:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80175f0:	429a      	cmp	r2, r3
 80175f2:	f6ff af67 	blt.w	80174c4 <decode_mcu_DC_first+0x80>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 80175f6:	687b      	ldr	r3, [r7, #4]
 80175f8:	699b      	ldr	r3, [r3, #24]
 80175fa:	6a3a      	ldr	r2, [r7, #32]
 80175fc:	601a      	str	r2, [r3, #0]
 80175fe:	687b      	ldr	r3, [r7, #4]
 8017600:	699b      	ldr	r3, [r3, #24]
 8017602:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017604:	605a      	str	r2, [r3, #4]
 8017606:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017608:	609e      	str	r6, [r3, #8]
 801760a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801760c:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 801760e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017610:	f103 0410 	add.w	r4, r3, #16
 8017614:	f107 050c 	add.w	r5, r7, #12
 8017618:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801761a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801761c:	682b      	ldr	r3, [r5, #0]
 801761e:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8017620:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017622:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017624:	1e5a      	subs	r2, r3, #1
 8017626:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017628:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 801762a:	2301      	movs	r3, #1
}
 801762c:	4618      	mov	r0, r3
 801762e:	3750      	adds	r7, #80	@ 0x50
 8017630:	46bd      	mov	sp, r7
 8017632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017636:	bf00      	nop
 8017638:	080323f4 	.word	0x080323f4

0801763c <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 801763c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801763e:	b093      	sub	sp, #76	@ 0x4c
 8017640:	af02      	add	r7, sp, #8
 8017642:	60f8      	str	r0, [r7, #12]
 8017644:	60b9      	str	r1, [r7, #8]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8017646:	68fb      	ldr	r3, [r7, #12]
 8017648:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801764c:	63bb      	str	r3, [r7, #56]	@ 0x38
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 801764e:	68fb      	ldr	r3, [r7, #12]
 8017650:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8017654:	2b00      	cmp	r3, #0
 8017656:	d00b      	beq.n	8017670 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 8017658:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801765a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801765c:	2b00      	cmp	r3, #0
 801765e:	d107      	bne.n	8017670 <decode_mcu_AC_first+0x34>
      if (! process_restart(cinfo))
 8017660:	68f8      	ldr	r0, [r7, #12]
 8017662:	f7ff fea1 	bl	80173a8 <process_restart>
 8017666:	4603      	mov	r3, r0
 8017668:	2b00      	cmp	r3, #0
 801766a:	d101      	bne.n	8017670 <decode_mcu_AC_first+0x34>
	return FALSE;
 801766c:	2300      	movs	r3, #0
 801766e:	e0f7      	b.n	8017860 <decode_mcu_AC_first+0x224>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8017670:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017672:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017674:	2b00      	cmp	r3, #0
 8017676:	f040 80ed 	bne.w	8017854 <decode_mcu_AC_first+0x218>

    Se = cinfo->Se;
 801767a:	68fb      	ldr	r3, [r7, #12]
 801767c:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8017680:	637b      	str	r3, [r7, #52]	@ 0x34
    Al = cinfo->Al;
 8017682:	68fb      	ldr	r3, [r7, #12]
 8017684:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8017688:	633b      	str	r3, [r7, #48]	@ 0x30
    natural_order = cinfo->natural_order;
 801768a:	68fb      	ldr	r3, [r7, #12]
 801768c:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8017690:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Load up working state.
     * We can avoid loading/saving bitread state if in an EOB run.
     */
    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
 8017692:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017694:	691b      	ldr	r3, [r3, #16]
 8017696:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* There is always only one block per MCU */

    if (EOBRUN > 0)		/* if it's a band of zeroes... */
 8017698:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801769a:	2b00      	cmp	r3, #0
 801769c:	d003      	beq.n	80176a6 <decode_mcu_AC_first+0x6a>
      EOBRUN--;			/* ...process it now (we do nothing) */
 801769e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80176a0:	3b01      	subs	r3, #1
 80176a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80176a4:	e0d3      	b.n	801784e <decode_mcu_AC_first+0x212>
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80176a6:	68fb      	ldr	r3, [r7, #12]
 80176a8:	623b      	str	r3, [r7, #32]
 80176aa:	68fb      	ldr	r3, [r7, #12]
 80176ac:	699b      	ldr	r3, [r3, #24]
 80176ae:	681b      	ldr	r3, [r3, #0]
 80176b0:	613b      	str	r3, [r7, #16]
 80176b2:	68fb      	ldr	r3, [r7, #12]
 80176b4:	699b      	ldr	r3, [r3, #24]
 80176b6:	685b      	ldr	r3, [r3, #4]
 80176b8:	617b      	str	r3, [r7, #20]
 80176ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80176bc:	689b      	ldr	r3, [r3, #8]
 80176be:	607b      	str	r3, [r7, #4]
 80176c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80176c2:	68dc      	ldr	r4, [r3, #12]
      block = MCU_data[0];
 80176c4:	68bb      	ldr	r3, [r7, #8]
 80176c6:	681b      	ldr	r3, [r3, #0]
 80176c8:	62bb      	str	r3, [r7, #40]	@ 0x28
      tbl = entropy->ac_derived_tbl;
 80176ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80176cc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80176ce:	627b      	str	r3, [r7, #36]	@ 0x24

      for (k = cinfo->Ss; k <= Se; k++) {
 80176d0:	68fb      	ldr	r3, [r7, #12]
 80176d2:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80176d6:	603b      	str	r3, [r7, #0]
 80176d8:	e0a7      	b.n	801782a <decode_mcu_AC_first+0x1ee>
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 80176da:	2c07      	cmp	r4, #7
 80176dc:	dc12      	bgt.n	8017704 <decode_mcu_AC_first+0xc8>
 80176de:	f107 0010 	add.w	r0, r7, #16
 80176e2:	2300      	movs	r3, #0
 80176e4:	4622      	mov	r2, r4
 80176e6:	6879      	ldr	r1, [r7, #4]
 80176e8:	f7ff fd74 	bl	80171d4 <jpeg_fill_bit_buffer>
 80176ec:	4603      	mov	r3, r0
 80176ee:	2b00      	cmp	r3, #0
 80176f0:	d101      	bne.n	80176f6 <decode_mcu_AC_first+0xba>
 80176f2:	2300      	movs	r3, #0
 80176f4:	e0b4      	b.n	8017860 <decode_mcu_AC_first+0x224>
 80176f6:	69bb      	ldr	r3, [r7, #24]
 80176f8:	607b      	str	r3, [r7, #4]
 80176fa:	69fc      	ldr	r4, [r7, #28]
 80176fc:	2c07      	cmp	r4, #7
 80176fe:	dc01      	bgt.n	8017704 <decode_mcu_AC_first+0xc8>
 8017700:	2501      	movs	r5, #1
 8017702:	e016      	b.n	8017732 <decode_mcu_AC_first+0xf6>
 8017704:	f1a4 0308 	sub.w	r3, r4, #8
 8017708:	687a      	ldr	r2, [r7, #4]
 801770a:	fa42 f303 	asr.w	r3, r2, r3
 801770e:	22ff      	movs	r2, #255	@ 0xff
 8017710:	ea03 0602 	and.w	r6, r3, r2
 8017714:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017716:	f106 0224 	add.w	r2, r6, #36	@ 0x24
 801771a:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801771e:	2d00      	cmp	r5, #0
 8017720:	d006      	beq.n	8017730 <decode_mcu_AC_first+0xf4>
 8017722:	1b64      	subs	r4, r4, r5
 8017724:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017726:	4433      	add	r3, r6
 8017728:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801772c:	461e      	mov	r6, r3
 801772e:	e010      	b.n	8017752 <decode_mcu_AC_first+0x116>
 8017730:	2509      	movs	r5, #9
 8017732:	f107 0010 	add.w	r0, r7, #16
 8017736:	9500      	str	r5, [sp, #0]
 8017738:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801773a:	4622      	mov	r2, r4
 801773c:	6879      	ldr	r1, [r7, #4]
 801773e:	f7ff fdcf 	bl	80172e0 <jpeg_huff_decode>
 8017742:	4606      	mov	r6, r0
 8017744:	2e00      	cmp	r6, #0
 8017746:	da01      	bge.n	801774c <decode_mcu_AC_first+0x110>
 8017748:	2300      	movs	r3, #0
 801774a:	e089      	b.n	8017860 <decode_mcu_AC_first+0x224>
 801774c:	69bb      	ldr	r3, [r7, #24]
 801774e:	607b      	str	r3, [r7, #4]
 8017750:	69fc      	ldr	r4, [r7, #28]
	r = s >> 4;
 8017752:	1135      	asrs	r5, r6, #4
	s &= 15;
 8017754:	f006 060f 	and.w	r6, r6, #15
	if (s) {
 8017758:	2e00      	cmp	r6, #0
 801775a:	d036      	beq.n	80177ca <decode_mcu_AC_first+0x18e>
	  k += r;
 801775c:	683b      	ldr	r3, [r7, #0]
 801775e:	442b      	add	r3, r5
 8017760:	603b      	str	r3, [r7, #0]
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8017762:	42b4      	cmp	r4, r6
 8017764:	da0e      	bge.n	8017784 <decode_mcu_AC_first+0x148>
 8017766:	f107 0010 	add.w	r0, r7, #16
 801776a:	4633      	mov	r3, r6
 801776c:	4622      	mov	r2, r4
 801776e:	6879      	ldr	r1, [r7, #4]
 8017770:	f7ff fd30 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017774:	4603      	mov	r3, r0
 8017776:	2b00      	cmp	r3, #0
 8017778:	d101      	bne.n	801777e <decode_mcu_AC_first+0x142>
 801777a:	2300      	movs	r3, #0
 801777c:	e070      	b.n	8017860 <decode_mcu_AC_first+0x224>
 801777e:	69bb      	ldr	r3, [r7, #24]
 8017780:	607b      	str	r3, [r7, #4]
 8017782:	69fc      	ldr	r4, [r7, #28]
	  r = GET_BITS(s);
 8017784:	1ba4      	subs	r4, r4, r6
 8017786:	687b      	ldr	r3, [r7, #4]
 8017788:	fa43 f204 	asr.w	r2, r3, r4
 801778c:	4b36      	ldr	r3, [pc, #216]	@ (8017868 <decode_mcu_AC_first+0x22c>)
 801778e:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8017792:	ea02 0503 	and.w	r5, r2, r3
	  s = HUFF_EXTEND(r, s);
 8017796:	1e73      	subs	r3, r6, #1
 8017798:	4a33      	ldr	r2, [pc, #204]	@ (8017868 <decode_mcu_AC_first+0x22c>)
 801779a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801779e:	429d      	cmp	r5, r3
 80177a0:	dc04      	bgt.n	80177ac <decode_mcu_AC_first+0x170>
 80177a2:	4b31      	ldr	r3, [pc, #196]	@ (8017868 <decode_mcu_AC_first+0x22c>)
 80177a4:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 80177a8:	1aeb      	subs	r3, r5, r3
 80177aa:	e000      	b.n	80177ae <decode_mcu_AC_first+0x172>
 80177ac:	462b      	mov	r3, r5
 80177ae:	461e      	mov	r6, r3
	  /* Scale and output coefficient in natural (dezigzagged) order */
	  (*block)[natural_order[k]] = (JCOEF) (s << Al);
 80177b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80177b2:	fa06 f103 	lsl.w	r1, r6, r3
 80177b6:	683b      	ldr	r3, [r7, #0]
 80177b8:	009b      	lsls	r3, r3, #2
 80177ba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80177bc:	4413      	add	r3, r2
 80177be:	681a      	ldr	r2, [r3, #0]
 80177c0:	b209      	sxth	r1, r1
 80177c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80177c4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 80177c8:	e02c      	b.n	8017824 <decode_mcu_AC_first+0x1e8>
	} else {
	  if (r == 15) {	/* ZRL */
 80177ca:	2d0f      	cmp	r5, #15
 80177cc:	d103      	bne.n	80177d6 <decode_mcu_AC_first+0x19a>
	    k += 15;		/* skip 15 zeroes in band */
 80177ce:	683b      	ldr	r3, [r7, #0]
 80177d0:	330f      	adds	r3, #15
 80177d2:	603b      	str	r3, [r7, #0]
 80177d4:	e026      	b.n	8017824 <decode_mcu_AC_first+0x1e8>
	  } else {		/* EOBr, run length is 2^r + appended bits */
	    EOBRUN = 1 << r;
 80177d6:	2301      	movs	r3, #1
 80177d8:	40ab      	lsls	r3, r5
 80177da:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    if (r) {		/* EOBr, r > 0 */
 80177dc:	2d00      	cmp	r5, #0
 80177de:	d01d      	beq.n	801781c <decode_mcu_AC_first+0x1e0>
	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
 80177e0:	42ac      	cmp	r4, r5
 80177e2:	da0e      	bge.n	8017802 <decode_mcu_AC_first+0x1c6>
 80177e4:	f107 0010 	add.w	r0, r7, #16
 80177e8:	462b      	mov	r3, r5
 80177ea:	4622      	mov	r2, r4
 80177ec:	6879      	ldr	r1, [r7, #4]
 80177ee:	f7ff fcf1 	bl	80171d4 <jpeg_fill_bit_buffer>
 80177f2:	4603      	mov	r3, r0
 80177f4:	2b00      	cmp	r3, #0
 80177f6:	d101      	bne.n	80177fc <decode_mcu_AC_first+0x1c0>
 80177f8:	2300      	movs	r3, #0
 80177fa:	e031      	b.n	8017860 <decode_mcu_AC_first+0x224>
 80177fc:	69bb      	ldr	r3, [r7, #24]
 80177fe:	607b      	str	r3, [r7, #4]
 8017800:	69fc      	ldr	r4, [r7, #28]
	      r = GET_BITS(r);
 8017802:	1b64      	subs	r4, r4, r5
 8017804:	687b      	ldr	r3, [r7, #4]
 8017806:	fa43 f204 	asr.w	r2, r3, r4
 801780a:	4b17      	ldr	r3, [pc, #92]	@ (8017868 <decode_mcu_AC_first+0x22c>)
 801780c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8017810:	ea02 0503 	and.w	r5, r2, r3
	      EOBRUN += r;
 8017814:	462a      	mov	r2, r5
 8017816:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017818:	4413      	add	r3, r2
 801781a:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    }
	    EOBRUN--;		/* this band is processed at this moment */
 801781c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801781e:	3b01      	subs	r3, #1
 8017820:	63fb      	str	r3, [r7, #60]	@ 0x3c
	    break;		/* force end-of-band */
 8017822:	e007      	b.n	8017834 <decode_mcu_AC_first+0x1f8>
      for (k = cinfo->Ss; k <= Se; k++) {
 8017824:	683b      	ldr	r3, [r7, #0]
 8017826:	3301      	adds	r3, #1
 8017828:	603b      	str	r3, [r7, #0]
 801782a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801782c:	683a      	ldr	r2, [r7, #0]
 801782e:	429a      	cmp	r2, r3
 8017830:	f77f af53 	ble.w	80176da <decode_mcu_AC_first+0x9e>
	  }
	}
      }

      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8017834:	68fb      	ldr	r3, [r7, #12]
 8017836:	699b      	ldr	r3, [r3, #24]
 8017838:	693a      	ldr	r2, [r7, #16]
 801783a:	601a      	str	r2, [r3, #0]
 801783c:	68fb      	ldr	r3, [r7, #12]
 801783e:	699b      	ldr	r3, [r3, #24]
 8017840:	697a      	ldr	r2, [r7, #20]
 8017842:	605a      	str	r2, [r3, #4]
 8017844:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017846:	687a      	ldr	r2, [r7, #4]
 8017848:	609a      	str	r2, [r3, #8]
 801784a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801784c:	60dc      	str	r4, [r3, #12]
    }

    /* Completed MCU, so update state */
    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
 801784e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017850:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8017852:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8017854:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017856:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017858:	1e5a      	subs	r2, r3, #1
 801785a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801785c:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 801785e:	2301      	movs	r3, #1
}
 8017860:	4618      	mov	r0, r3
 8017862:	3744      	adds	r7, #68	@ 0x44
 8017864:	46bd      	mov	sp, r7
 8017866:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017868:	080323f4 	.word	0x080323f4

0801786c <decode_mcu_DC_refine>:
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 801786c:	b5b0      	push	{r4, r5, r7, lr}
 801786e:	b08c      	sub	sp, #48	@ 0x30
 8017870:	af00      	add	r7, sp, #0
 8017872:	6078      	str	r0, [r7, #4]
 8017874:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8017876:	687b      	ldr	r3, [r7, #4]
 8017878:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801787c:	62bb      	str	r3, [r7, #40]	@ 0x28
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 801787e:	687b      	ldr	r3, [r7, #4]
 8017880:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8017884:	2201      	movs	r2, #1
 8017886:	fa02 f303 	lsl.w	r3, r2, r3
 801788a:	627b      	str	r3, [r7, #36]	@ 0x24
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 801788c:	687b      	ldr	r3, [r7, #4]
 801788e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8017892:	2b00      	cmp	r3, #0
 8017894:	d00b      	beq.n	80178ae <decode_mcu_DC_refine+0x42>
    if (entropy->restarts_to_go == 0)
 8017896:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017898:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801789a:	2b00      	cmp	r3, #0
 801789c:	d107      	bne.n	80178ae <decode_mcu_DC_refine+0x42>
      if (! process_restart(cinfo))
 801789e:	6878      	ldr	r0, [r7, #4]
 80178a0:	f7ff fd82 	bl	80173a8 <process_restart>
 80178a4:	4603      	mov	r3, r0
 80178a6:	2b00      	cmp	r3, #0
 80178a8:	d101      	bne.n	80178ae <decode_mcu_DC_refine+0x42>
	return FALSE;
 80178aa:	2300      	movs	r3, #0
 80178ac:	e051      	b.n	8017952 <decode_mcu_DC_refine+0xe6>
  /* Not worth the cycles to check insufficient_data here,
   * since we will not change the data anyway if we read zeroes.
   */

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80178ae:	687b      	ldr	r3, [r7, #4]
 80178b0:	61fb      	str	r3, [r7, #28]
 80178b2:	687b      	ldr	r3, [r7, #4]
 80178b4:	699b      	ldr	r3, [r3, #24]
 80178b6:	681b      	ldr	r3, [r3, #0]
 80178b8:	60fb      	str	r3, [r7, #12]
 80178ba:	687b      	ldr	r3, [r7, #4]
 80178bc:	699b      	ldr	r3, [r3, #24]
 80178be:	685b      	ldr	r3, [r3, #4]
 80178c0:	613b      	str	r3, [r7, #16]
 80178c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80178c4:	689d      	ldr	r5, [r3, #8]
 80178c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80178c8:	68dc      	ldr	r4, [r3, #12]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80178ca:	2300      	movs	r3, #0
 80178cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80178ce:	e028      	b.n	8017922 <decode_mcu_DC_refine+0xb6>
    block = MCU_data[blkn];
 80178d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80178d2:	009b      	lsls	r3, r3, #2
 80178d4:	683a      	ldr	r2, [r7, #0]
 80178d6:	4413      	add	r3, r2
 80178d8:	681b      	ldr	r3, [r3, #0]
 80178da:	623b      	str	r3, [r7, #32]

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 80178dc:	2c00      	cmp	r4, #0
 80178de:	dc0d      	bgt.n	80178fc <decode_mcu_DC_refine+0x90>
 80178e0:	f107 000c 	add.w	r0, r7, #12
 80178e4:	2301      	movs	r3, #1
 80178e6:	4622      	mov	r2, r4
 80178e8:	4629      	mov	r1, r5
 80178ea:	f7ff fc73 	bl	80171d4 <jpeg_fill_bit_buffer>
 80178ee:	4603      	mov	r3, r0
 80178f0:	2b00      	cmp	r3, #0
 80178f2:	d101      	bne.n	80178f8 <decode_mcu_DC_refine+0x8c>
 80178f4:	2300      	movs	r3, #0
 80178f6:	e02c      	b.n	8017952 <decode_mcu_DC_refine+0xe6>
 80178f8:	697d      	ldr	r5, [r7, #20]
 80178fa:	69bc      	ldr	r4, [r7, #24]
    if (GET_BITS(1))
 80178fc:	3c01      	subs	r4, #1
 80178fe:	fa45 f304 	asr.w	r3, r5, r4
 8017902:	2201      	movs	r2, #1
 8017904:	4013      	ands	r3, r2
 8017906:	2b00      	cmp	r3, #0
 8017908:	d008      	beq.n	801791c <decode_mcu_DC_refine+0xb0>
      (*block)[0] |= p1;
 801790a:	6a3b      	ldr	r3, [r7, #32]
 801790c:	f9b3 2000 	ldrsh.w	r2, [r3]
 8017910:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017912:	b21b      	sxth	r3, r3
 8017914:	4313      	orrs	r3, r2
 8017916:	b21a      	sxth	r2, r3
 8017918:	6a3b      	ldr	r3, [r7, #32]
 801791a:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801791c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801791e:	3301      	adds	r3, #1
 8017920:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8017922:	687b      	ldr	r3, [r7, #4]
 8017924:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8017928:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801792a:	429a      	cmp	r2, r3
 801792c:	dbd0      	blt.n	80178d0 <decode_mcu_DC_refine+0x64>
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 801792e:	687b      	ldr	r3, [r7, #4]
 8017930:	699b      	ldr	r3, [r3, #24]
 8017932:	68fa      	ldr	r2, [r7, #12]
 8017934:	601a      	str	r2, [r3, #0]
 8017936:	687b      	ldr	r3, [r7, #4]
 8017938:	699b      	ldr	r3, [r3, #24]
 801793a:	693a      	ldr	r2, [r7, #16]
 801793c:	605a      	str	r2, [r3, #4]
 801793e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017940:	609d      	str	r5, [r3, #8]
 8017942:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017944:	60dc      	str	r4, [r3, #12]

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8017946:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017948:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801794a:	1e5a      	subs	r2, r3, #1
 801794c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801794e:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8017950:	2301      	movs	r3, #1
}
 8017952:	4618      	mov	r0, r3
 8017954:	3730      	adds	r7, #48	@ 0x30
 8017956:	46bd      	mov	sp, r7
 8017958:	bdb0      	pop	{r4, r5, r7, pc}
	...

0801795c <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 801795c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017960:	b0d6      	sub	sp, #344	@ 0x158
 8017962:	af02      	add	r7, sp, #8
 8017964:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017968:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801796c:	6018      	str	r0, [r3, #0]
 801796e:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017972:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 8017976:	6019      	str	r1, [r3, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8017978:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801797c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017980:	681b      	ldr	r3, [r3, #0]
 8017982:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8017986:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 801798a:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 801798e:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017992:	681b      	ldr	r3, [r3, #0]
 8017994:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8017998:	2b00      	cmp	r3, #0
 801799a:	d010      	beq.n	80179be <decode_mcu_AC_refine+0x62>
    if (entropy->restarts_to_go == 0)
 801799c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80179a0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80179a2:	2b00      	cmp	r3, #0
 80179a4:	d10b      	bne.n	80179be <decode_mcu_AC_refine+0x62>
      if (! process_restart(cinfo))
 80179a6:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80179aa:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80179ae:	6818      	ldr	r0, [r3, #0]
 80179b0:	f7ff fcfa 	bl	80173a8 <process_restart>
 80179b4:	4603      	mov	r3, r0
 80179b6:	2b00      	cmp	r3, #0
 80179b8:	d101      	bne.n	80179be <decode_mcu_AC_refine+0x62>
	return FALSE;
 80179ba:	2300      	movs	r3, #0
 80179bc:	e24f      	b.n	8017e5e <decode_mcu_AC_refine+0x502>
  }

  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->insufficient_data) {
 80179be:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80179c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80179c4:	2b00      	cmp	r3, #0
 80179c6:	f040 8229 	bne.w	8017e1c <decode_mcu_AC_refine+0x4c0>

    Se = cinfo->Se;
 80179ca:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80179ce:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80179d2:	681b      	ldr	r3, [r3, #0]
 80179d4:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80179d8:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 80179dc:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80179e0:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80179e4:	681b      	ldr	r3, [r3, #0]
 80179e6:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80179ea:	2201      	movs	r2, #1
 80179ec:	fa02 f303 	lsl.w	r3, r2, r3
 80179f0:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 80179f4:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 80179f8:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80179fc:	681b      	ldr	r3, [r3, #0]
 80179fe:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 8017a02:	f04f 32ff 	mov.w	r2, #4294967295
 8017a06:	fa02 f303 	lsl.w	r3, r2, r3
 8017a0a:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    natural_order = cinfo->natural_order;
 8017a0e:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a12:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017a16:	681b      	ldr	r3, [r3, #0]
 8017a18:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8017a1c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8017a20:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a24:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017a28:	681b      	ldr	r3, [r3, #0]
 8017a2a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8017a2e:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a32:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017a36:	681b      	ldr	r3, [r3, #0]
 8017a38:	699b      	ldr	r3, [r3, #24]
 8017a3a:	681b      	ldr	r3, [r3, #0]
 8017a3c:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 8017a40:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a44:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017a48:	681b      	ldr	r3, [r3, #0]
 8017a4a:	699b      	ldr	r3, [r3, #24]
 8017a4c:	685b      	ldr	r3, [r3, #4]
 8017a4e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 8017a52:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017a56:	689d      	ldr	r5, [r3, #8]
 8017a58:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017a5c:	68dc      	ldr	r4, [r3, #12]
    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
 8017a5e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017a62:	691b      	ldr	r3, [r3, #16]
 8017a64:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    /* There is always only one block per MCU */
    block = MCU_data[0];
 8017a68:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a6c:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 8017a70:	681b      	ldr	r3, [r3, #0]
 8017a72:	681b      	ldr	r3, [r3, #0]
 8017a74:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tbl = entropy->ac_derived_tbl;
 8017a78:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017a7c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8017a7e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
     * nonzero coefficients in the block, because otherwise we'd get confused
     * next time about which coefficients were already nonzero.
     * But we need not undo addition of bits to already-nonzero coefficients;
     * instead, we can test the current bit to see if we already did it.
     */
    num_newnz = 0;
 8017a82:	2300      	movs	r3, #0
 8017a84:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;
 8017a88:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017a8c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017a90:	681b      	ldr	r3, [r3, #0]
 8017a92:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8017a96:	607b      	str	r3, [r7, #4]

    if (EOBRUN == 0) {
 8017a98:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017a9c:	2b00      	cmp	r3, #0
 8017a9e:	f040 8138 	bne.w	8017d12 <decode_mcu_AC_refine+0x3b6>
      for (; k <= Se; k++) {
 8017aa2:	e12e      	b.n	8017d02 <decode_mcu_AC_refine+0x3a6>
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
 8017aa4:	2c07      	cmp	r4, #7
 8017aa6:	dc12      	bgt.n	8017ace <decode_mcu_AC_refine+0x172>
 8017aa8:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017aac:	2300      	movs	r3, #0
 8017aae:	4622      	mov	r2, r4
 8017ab0:	4629      	mov	r1, r5
 8017ab2:	f7ff fb8f 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017ab6:	4603      	mov	r3, r0
 8017ab8:	2b00      	cmp	r3, #0
 8017aba:	f000 81b8 	beq.w	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017abe:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017ac2:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
 8017ac6:	2c07      	cmp	r4, #7
 8017ac8:	dc01      	bgt.n	8017ace <decode_mcu_AC_refine+0x172>
 8017aca:	2601      	movs	r6, #1
 8017acc:	e017      	b.n	8017afe <decode_mcu_AC_refine+0x1a2>
 8017ace:	f1a4 0308 	sub.w	r3, r4, #8
 8017ad2:	fa45 f303 	asr.w	r3, r5, r3
 8017ad6:	22ff      	movs	r2, #255	@ 0xff
 8017ad8:	ea03 0802 	and.w	r8, r3, r2
 8017adc:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8017ae0:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8017ae4:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
 8017ae8:	2e00      	cmp	r6, #0
 8017aea:	d007      	beq.n	8017afc <decode_mcu_AC_refine+0x1a0>
 8017aec:	1ba4      	subs	r4, r4, r6
 8017aee:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8017af2:	4443      	add	r3, r8
 8017af4:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8017af8:	603b      	str	r3, [r7, #0]
 8017afa:	e012      	b.n	8017b22 <decode_mcu_AC_refine+0x1c6>
 8017afc:	2609      	movs	r6, #9
 8017afe:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017b02:	9600      	str	r6, [sp, #0]
 8017b04:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8017b08:	4622      	mov	r2, r4
 8017b0a:	4629      	mov	r1, r5
 8017b0c:	f7ff fbe8 	bl	80172e0 <jpeg_huff_decode>
 8017b10:	4603      	mov	r3, r0
 8017b12:	603b      	str	r3, [r7, #0]
 8017b14:	2b00      	cmp	r3, #0
 8017b16:	f2c0 818a 	blt.w	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017b1a:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017b1e:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	r = s >> 4;
 8017b22:	683b      	ldr	r3, [r7, #0]
 8017b24:	111e      	asrs	r6, r3, #4
	s &= 15;
 8017b26:	f003 030f 	and.w	r3, r3, #15
 8017b2a:	603b      	str	r3, [r7, #0]
	if (s) {
 8017b2c:	2b00      	cmp	r3, #0
 8017b2e:	d038      	beq.n	8017ba2 <decode_mcu_AC_refine+0x246>
	  if (s != 1)		/* size of new coef should always be 1 */
 8017b30:	2b01      	cmp	r3, #1
 8017b32:	d016      	beq.n	8017b62 <decode_mcu_AC_refine+0x206>
	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
 8017b34:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017b38:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017b3c:	681b      	ldr	r3, [r3, #0]
 8017b3e:	681b      	ldr	r3, [r3, #0]
 8017b40:	2279      	movs	r2, #121	@ 0x79
 8017b42:	615a      	str	r2, [r3, #20]
 8017b44:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017b48:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017b4c:	681b      	ldr	r3, [r3, #0]
 8017b4e:	681b      	ldr	r3, [r3, #0]
 8017b50:	685b      	ldr	r3, [r3, #4]
 8017b52:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 8017b56:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 8017b5a:	f04f 31ff 	mov.w	r1, #4294967295
 8017b5e:	6810      	ldr	r0, [r2, #0]
 8017b60:	4798      	blx	r3
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8017b62:	2c00      	cmp	r4, #0
 8017b64:	dc0e      	bgt.n	8017b84 <decode_mcu_AC_refine+0x228>
 8017b66:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017b6a:	2301      	movs	r3, #1
 8017b6c:	4622      	mov	r2, r4
 8017b6e:	4629      	mov	r1, r5
 8017b70:	f7ff fb30 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017b74:	4603      	mov	r3, r0
 8017b76:	2b00      	cmp	r3, #0
 8017b78:	f000 8159 	beq.w	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017b7c:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017b80:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	  if (GET_BITS(1))
 8017b84:	3c01      	subs	r4, #1
 8017b86:	fa45 f304 	asr.w	r3, r5, r4
 8017b8a:	2201      	movs	r2, #1
 8017b8c:	4013      	ands	r3, r2
 8017b8e:	2b00      	cmp	r3, #0
 8017b90:	d003      	beq.n	8017b9a <decode_mcu_AC_refine+0x23e>
	    s = p1;		/* newly nonzero coef is positive */
 8017b92:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8017b96:	603b      	str	r3, [r7, #0]
 8017b98:	e02c      	b.n	8017bf4 <decode_mcu_AC_refine+0x298>
	  else
	    s = m1;		/* newly nonzero coef is negative */
 8017b9a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017b9e:	603b      	str	r3, [r7, #0]
 8017ba0:	e028      	b.n	8017bf4 <decode_mcu_AC_refine+0x298>
	} else {
	  if (r != 15) {
 8017ba2:	2e0f      	cmp	r6, #15
 8017ba4:	d026      	beq.n	8017bf4 <decode_mcu_AC_refine+0x298>
	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
 8017ba6:	2301      	movs	r3, #1
 8017ba8:	40b3      	lsls	r3, r6
 8017baa:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    if (r) {
 8017bae:	2e00      	cmp	r6, #0
 8017bb0:	f000 80ae 	beq.w	8017d10 <decode_mcu_AC_refine+0x3b4>
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
 8017bb4:	42b4      	cmp	r4, r6
 8017bb6:	da0e      	bge.n	8017bd6 <decode_mcu_AC_refine+0x27a>
 8017bb8:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017bbc:	4633      	mov	r3, r6
 8017bbe:	4622      	mov	r2, r4
 8017bc0:	4629      	mov	r1, r5
 8017bc2:	f7ff fb07 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017bc6:	4603      	mov	r3, r0
 8017bc8:	2b00      	cmp	r3, #0
 8017bca:	f000 8130 	beq.w	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017bce:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017bd2:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	      r = GET_BITS(r);
 8017bd6:	1ba4      	subs	r4, r4, r6
 8017bd8:	fa45 f204 	asr.w	r2, r5, r4
 8017bdc:	4ba3      	ldr	r3, [pc, #652]	@ (8017e6c <decode_mcu_AC_refine+0x510>)
 8017bde:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8017be2:	ea02 0603 	and.w	r6, r2, r3
	      EOBRUN += r;
 8017be6:	4632      	mov	r2, r6
 8017be8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017bec:	4413      	add	r3, r2
 8017bee:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    }
	    break;		/* rest of block is handled by EOB logic */
 8017bf2:	e08d      	b.n	8017d10 <decode_mcu_AC_refine+0x3b4>
	/* Advance over already-nonzero coefs and r still-zero coefs,
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + natural_order[k];
 8017bf4:	687b      	ldr	r3, [r7, #4]
 8017bf6:	009b      	lsls	r3, r3, #2
 8017bf8:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8017bfc:	4413      	add	r3, r2
 8017bfe:	681b      	ldr	r3, [r3, #0]
 8017c00:	005b      	lsls	r3, r3, #1
 8017c02:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8017c06:	4413      	add	r3, r2
 8017c08:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
	  if (*thiscoef != 0) {
 8017c0c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c10:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017c14:	2b00      	cmp	r3, #0
 8017c16:	d045      	beq.n	8017ca4 <decode_mcu_AC_refine+0x348>
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8017c18:	2c00      	cmp	r4, #0
 8017c1a:	dc0e      	bgt.n	8017c3a <decode_mcu_AC_refine+0x2de>
 8017c1c:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017c20:	2301      	movs	r3, #1
 8017c22:	4622      	mov	r2, r4
 8017c24:	4629      	mov	r1, r5
 8017c26:	f7ff fad5 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017c2a:	4603      	mov	r3, r0
 8017c2c:	2b00      	cmp	r3, #0
 8017c2e:	f000 80fe 	beq.w	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017c32:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017c36:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	    if (GET_BITS(1)) {
 8017c3a:	3c01      	subs	r4, #1
 8017c3c:	fa45 f304 	asr.w	r3, r5, r4
 8017c40:	2201      	movs	r2, #1
 8017c42:	4013      	ands	r3, r2
 8017c44:	2b00      	cmp	r3, #0
 8017c46:	d030      	beq.n	8017caa <decode_mcu_AC_refine+0x34e>
	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
 8017c48:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c4c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017c50:	461a      	mov	r2, r3
 8017c52:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8017c56:	4013      	ands	r3, r2
 8017c58:	2b00      	cmp	r3, #0
 8017c5a:	d126      	bne.n	8017caa <decode_mcu_AC_refine+0x34e>
		if (*thiscoef >= 0)
 8017c5c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c60:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017c64:	2b00      	cmp	r3, #0
 8017c66:	db0e      	blt.n	8017c86 <decode_mcu_AC_refine+0x32a>
		  *thiscoef += p1;
 8017c68:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c6c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017c70:	b29a      	uxth	r2, r3
 8017c72:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8017c76:	b29b      	uxth	r3, r3
 8017c78:	4413      	add	r3, r2
 8017c7a:	b29b      	uxth	r3, r3
 8017c7c:	b21a      	sxth	r2, r3
 8017c7e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c82:	801a      	strh	r2, [r3, #0]
 8017c84:	e011      	b.n	8017caa <decode_mcu_AC_refine+0x34e>
		else
		  *thiscoef += m1;
 8017c86:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017c8a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017c8e:	b29a      	uxth	r2, r3
 8017c90:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017c94:	b29b      	uxth	r3, r3
 8017c96:	4413      	add	r3, r2
 8017c98:	b29b      	uxth	r3, r3
 8017c9a:	b21a      	sxth	r2, r3
 8017c9c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017ca0:	801a      	strh	r2, [r3, #0]
 8017ca2:	e002      	b.n	8017caa <decode_mcu_AC_refine+0x34e>
	      }
	    }
	  } else {
	    if (--r < 0)
 8017ca4:	3e01      	subs	r6, #1
 8017ca6:	2e00      	cmp	r6, #0
 8017ca8:	db08      	blt.n	8017cbc <decode_mcu_AC_refine+0x360>
	      break;		/* reached target zero coefficient */
	  }
	  k++;
 8017caa:	687b      	ldr	r3, [r7, #4]
 8017cac:	3301      	adds	r3, #1
 8017cae:	461a      	mov	r2, r3
 8017cb0:	607a      	str	r2, [r7, #4]
	} while (k <= Se);
 8017cb2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017cb6:	429a      	cmp	r2, r3
 8017cb8:	dd9c      	ble.n	8017bf4 <decode_mcu_AC_refine+0x298>
 8017cba:	e000      	b.n	8017cbe <decode_mcu_AC_refine+0x362>
	      break;		/* reached target zero coefficient */
 8017cbc:	bf00      	nop
	if (s) {
 8017cbe:	6839      	ldr	r1, [r7, #0]
 8017cc0:	2900      	cmp	r1, #0
 8017cc2:	d01b      	beq.n	8017cfc <decode_mcu_AC_refine+0x3a0>
	  int pos = natural_order[k];
 8017cc4:	687b      	ldr	r3, [r7, #4]
 8017cc6:	009b      	lsls	r3, r3, #2
 8017cc8:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8017ccc:	4413      	add	r3, r2
 8017cce:	681b      	ldr	r3, [r3, #0]
 8017cd0:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
	  /* Output newly nonzero coefficient */
	  (*block)[pos] = (JCOEF) s;
 8017cd4:	b209      	sxth	r1, r1
 8017cd6:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8017cda:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8017cde:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	  /* Remember its position in case we have to suspend */
	  newnz_pos[num_newnz++] = pos;
 8017ce2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8017ce6:	1c5a      	adds	r2, r3, #1
 8017ce8:	f8c7 2148 	str.w	r2, [r7, #328]	@ 0x148
 8017cec:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 8017cf0:	f5a2 72a0 	sub.w	r2, r2, #320	@ 0x140
 8017cf4:	f8d7 1124 	ldr.w	r1, [r7, #292]	@ 0x124
 8017cf8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      for (; k <= Se; k++) {
 8017cfc:	687b      	ldr	r3, [r7, #4]
 8017cfe:	3301      	adds	r3, #1
 8017d00:	607b      	str	r3, [r7, #4]
 8017d02:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017d06:	687a      	ldr	r2, [r7, #4]
 8017d08:	429a      	cmp	r2, r3
 8017d0a:	f77f aecb 	ble.w	8017aa4 <decode_mcu_AC_refine+0x148>
 8017d0e:	e000      	b.n	8017d12 <decode_mcu_AC_refine+0x3b6>
	    break;		/* rest of block is handled by EOB logic */
 8017d10:	bf00      	nop
	}
      }
    }

    if (EOBRUN > 0) {
 8017d12:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017d16:	2b00      	cmp	r3, #0
 8017d18:	d063      	beq.n	8017de2 <decode_mcu_AC_refine+0x486>
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
 8017d1a:	e058      	b.n	8017dce <decode_mcu_AC_refine+0x472>
	thiscoef = *block + natural_order[k];
 8017d1c:	687b      	ldr	r3, [r7, #4]
 8017d1e:	009b      	lsls	r3, r3, #2
 8017d20:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8017d24:	4413      	add	r3, r2
 8017d26:	681b      	ldr	r3, [r3, #0]
 8017d28:	005b      	lsls	r3, r3, #1
 8017d2a:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 8017d2e:	4413      	add	r3, r2
 8017d30:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
	if (*thiscoef != 0) {
 8017d34:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017d38:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017d3c:	2b00      	cmp	r3, #0
 8017d3e:	d043      	beq.n	8017dc8 <decode_mcu_AC_refine+0x46c>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8017d40:	2c00      	cmp	r4, #0
 8017d42:	dc0d      	bgt.n	8017d60 <decode_mcu_AC_refine+0x404>
 8017d44:	f507 7088 	add.w	r0, r7, #272	@ 0x110
 8017d48:	2301      	movs	r3, #1
 8017d4a:	4622      	mov	r2, r4
 8017d4c:	4629      	mov	r1, r5
 8017d4e:	f7ff fa41 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017d52:	4603      	mov	r3, r0
 8017d54:	2b00      	cmp	r3, #0
 8017d56:	d06a      	beq.n	8017e2e <decode_mcu_AC_refine+0x4d2>
 8017d58:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 8017d5c:	f8d7 411c 	ldr.w	r4, [r7, #284]	@ 0x11c
	  if (GET_BITS(1)) {
 8017d60:	3c01      	subs	r4, #1
 8017d62:	fa45 f304 	asr.w	r3, r5, r4
 8017d66:	2201      	movs	r2, #1
 8017d68:	4013      	ands	r3, r2
 8017d6a:	2b00      	cmp	r3, #0
 8017d6c:	d02c      	beq.n	8017dc8 <decode_mcu_AC_refine+0x46c>
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
 8017d6e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017d72:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017d76:	461a      	mov	r2, r3
 8017d78:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8017d7c:	4013      	ands	r3, r2
 8017d7e:	2b00      	cmp	r3, #0
 8017d80:	d122      	bne.n	8017dc8 <decode_mcu_AC_refine+0x46c>
	      if (*thiscoef >= 0)
 8017d82:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017d86:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017d8a:	2b00      	cmp	r3, #0
 8017d8c:	db0e      	blt.n	8017dac <decode_mcu_AC_refine+0x450>
		*thiscoef += p1;
 8017d8e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017d92:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017d96:	b29a      	uxth	r2, r3
 8017d98:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8017d9c:	b29b      	uxth	r3, r3
 8017d9e:	4413      	add	r3, r2
 8017da0:	b29b      	uxth	r3, r3
 8017da2:	b21a      	sxth	r2, r3
 8017da4:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017da8:	801a      	strh	r2, [r3, #0]
 8017daa:	e00d      	b.n	8017dc8 <decode_mcu_AC_refine+0x46c>
	      else
		*thiscoef += m1;
 8017dac:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017db0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017db4:	b29a      	uxth	r2, r3
 8017db6:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017dba:	b29b      	uxth	r3, r3
 8017dbc:	4413      	add	r3, r2
 8017dbe:	b29b      	uxth	r3, r3
 8017dc0:	b21a      	sxth	r2, r3
 8017dc2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8017dc6:	801a      	strh	r2, [r3, #0]
      for (; k <= Se; k++) {
 8017dc8:	687b      	ldr	r3, [r7, #4]
 8017dca:	3301      	adds	r3, #1
 8017dcc:	607b      	str	r3, [r7, #4]
 8017dce:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017dd2:	687a      	ldr	r2, [r7, #4]
 8017dd4:	429a      	cmp	r2, r3
 8017dd6:	dda1      	ble.n	8017d1c <decode_mcu_AC_refine+0x3c0>
	    }
	  }
	}
      }
      /* Count one block completed in EOB run */
      EOBRUN--;
 8017dd8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017ddc:	3b01      	subs	r3, #1
 8017dde:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8017de2:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017de6:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017dea:	681b      	ldr	r3, [r3, #0]
 8017dec:	699b      	ldr	r3, [r3, #24]
 8017dee:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8017df2:	601a      	str	r2, [r3, #0]
 8017df4:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017df8:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8017dfc:	681b      	ldr	r3, [r3, #0]
 8017dfe:	699b      	ldr	r3, [r3, #24]
 8017e00:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8017e04:	605a      	str	r2, [r3, #4]
 8017e06:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017e0a:	609d      	str	r5, [r3, #8]
 8017e0c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017e10:	60dc      	str	r4, [r3, #12]
    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
 8017e12:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017e16:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8017e1a:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8017e1c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017e20:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017e22:	1e5a      	subs	r2, r3, #1
 8017e24:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8017e28:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8017e2a:	2301      	movs	r3, #1
 8017e2c:	e017      	b.n	8017e5e <decode_mcu_AC_refine+0x502>

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
 8017e2e:	e011      	b.n	8017e54 <decode_mcu_AC_refine+0x4f8>
    (*block)[newnz_pos[--num_newnz]] = 0;
 8017e30:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8017e34:	3b01      	subs	r3, #1
 8017e36:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 8017e3a:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8017e3e:	f5a3 73a0 	sub.w	r3, r3, #320	@ 0x140
 8017e42:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017e46:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8017e4a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8017e4e:	2100      	movs	r1, #0
 8017e50:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  while (num_newnz > 0)
 8017e54:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8017e58:	2b00      	cmp	r3, #0
 8017e5a:	dce9      	bgt.n	8017e30 <decode_mcu_AC_refine+0x4d4>

  return FALSE;
 8017e5c:	2300      	movs	r3, #0
}
 8017e5e:	4618      	mov	r0, r3
 8017e60:	f507 77a8 	add.w	r7, r7, #336	@ 0x150
 8017e64:	46bd      	mov	sp, r7
 8017e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017e6a:	bf00      	nop
 8017e6c:	080323f4 	.word	0x080323f4

08017e70 <decode_mcu_sub>:
 * partial blocks.
 */

METHODDEF(boolean)
decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8017e70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8017e74:	b097      	sub	sp, #92	@ 0x5c
 8017e76:	af02      	add	r7, sp, #8
 8017e78:	6078      	str	r0, [r7, #4]
 8017e7a:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8017e7c:	687b      	ldr	r3, [r7, #4]
 8017e7e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8017e82:	64bb      	str	r3, [r7, #72]	@ 0x48
  int Se, blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8017e84:	687b      	ldr	r3, [r7, #4]
 8017e86:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8017e8a:	2b00      	cmp	r3, #0
 8017e8c:	d00b      	beq.n	8017ea6 <decode_mcu_sub+0x36>
    if (entropy->restarts_to_go == 0)
 8017e8e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017e90:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017e92:	2b00      	cmp	r3, #0
 8017e94:	d107      	bne.n	8017ea6 <decode_mcu_sub+0x36>
      if (! process_restart(cinfo))
 8017e96:	6878      	ldr	r0, [r7, #4]
 8017e98:	f7ff fa86 	bl	80173a8 <process_restart>
 8017e9c:	4603      	mov	r3, r0
 8017e9e:	2b00      	cmp	r3, #0
 8017ea0:	d101      	bne.n	8017ea6 <decode_mcu_sub+0x36>
	return FALSE;
 8017ea2:	2300      	movs	r3, #0
 8017ea4:	e1d2      	b.n	801824c <decode_mcu_sub+0x3dc>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8017ea6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017ea8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017eaa:	2b00      	cmp	r3, #0
 8017eac:	f040 81c8 	bne.w	8018240 <decode_mcu_sub+0x3d0>

    natural_order = cinfo->natural_order;
 8017eb0:	687b      	ldr	r3, [r7, #4]
 8017eb2:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8017eb6:	647b      	str	r3, [r7, #68]	@ 0x44
    Se = cinfo->lim_Se;
 8017eb8:	687b      	ldr	r3, [r7, #4]
 8017eba:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8017ebe:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8017ec0:	687b      	ldr	r3, [r7, #4]
 8017ec2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8017ec4:	687b      	ldr	r3, [r7, #4]
 8017ec6:	699b      	ldr	r3, [r3, #24]
 8017ec8:	681b      	ldr	r3, [r3, #0]
 8017eca:	61fb      	str	r3, [r7, #28]
 8017ecc:	687b      	ldr	r3, [r7, #4]
 8017ece:	699b      	ldr	r3, [r3, #24]
 8017ed0:	685b      	ldr	r3, [r3, #4]
 8017ed2:	623b      	str	r3, [r7, #32]
 8017ed4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017ed6:	689e      	ldr	r6, [r3, #8]
 8017ed8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017eda:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 8017edc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017ede:	f107 0508 	add.w	r5, r7, #8
 8017ee2:	f103 0c10 	add.w	ip, r3, #16
 8017ee6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017eea:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8017eec:	f8dc 3000 	ldr.w	r3, [ip]
 8017ef0:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8017ef2:	2300      	movs	r3, #0
 8017ef4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8017ef6:	e187      	b.n	8018208 <decode_mcu_sub+0x398>
      JBLOCKROW block = MCU_data[blkn];
 8017ef8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017efa:	009b      	lsls	r3, r3, #2
 8017efc:	683a      	ldr	r2, [r7, #0]
 8017efe:	4413      	add	r3, r2
 8017f00:	681b      	ldr	r3, [r3, #0]
 8017f02:	63fb      	str	r3, [r7, #60]	@ 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 8017f04:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017f06:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8017f08:	3218      	adds	r2, #24
 8017f0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017f0e:	63bb      	str	r3, [r7, #56]	@ 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 8017f10:	2c07      	cmp	r4, #7
 8017f12:	dc11      	bgt.n	8017f38 <decode_mcu_sub+0xc8>
 8017f14:	f107 001c 	add.w	r0, r7, #28
 8017f18:	2300      	movs	r3, #0
 8017f1a:	4622      	mov	r2, r4
 8017f1c:	4631      	mov	r1, r6
 8017f1e:	f7ff f959 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017f22:	4603      	mov	r3, r0
 8017f24:	2b00      	cmp	r3, #0
 8017f26:	d101      	bne.n	8017f2c <decode_mcu_sub+0xbc>
 8017f28:	2300      	movs	r3, #0
 8017f2a:	e18f      	b.n	801824c <decode_mcu_sub+0x3dc>
 8017f2c:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8017f2e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8017f30:	2c07      	cmp	r4, #7
 8017f32:	dc01      	bgt.n	8017f38 <decode_mcu_sub+0xc8>
 8017f34:	2501      	movs	r5, #1
 8017f36:	e015      	b.n	8017f64 <decode_mcu_sub+0xf4>
 8017f38:	f1a4 0308 	sub.w	r3, r4, #8
 8017f3c:	fa46 f303 	asr.w	r3, r6, r3
 8017f40:	22ff      	movs	r2, #255	@ 0xff
 8017f42:	ea03 0802 	and.w	r8, r3, r2
 8017f46:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017f48:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8017f4c:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8017f50:	2d00      	cmp	r5, #0
 8017f52:	d006      	beq.n	8017f62 <decode_mcu_sub+0xf2>
 8017f54:	1b64      	subs	r4, r4, r5
 8017f56:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017f58:	4443      	add	r3, r8
 8017f5a:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8017f5e:	461d      	mov	r5, r3
 8017f60:	e00f      	b.n	8017f82 <decode_mcu_sub+0x112>
 8017f62:	2509      	movs	r5, #9
 8017f64:	f107 001c 	add.w	r0, r7, #28
 8017f68:	9500      	str	r5, [sp, #0]
 8017f6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017f6c:	4622      	mov	r2, r4
 8017f6e:	4631      	mov	r1, r6
 8017f70:	f7ff f9b6 	bl	80172e0 <jpeg_huff_decode>
 8017f74:	4605      	mov	r5, r0
 8017f76:	2d00      	cmp	r5, #0
 8017f78:	da01      	bge.n	8017f7e <decode_mcu_sub+0x10e>
 8017f7a:	2300      	movs	r3, #0
 8017f7c:	e166      	b.n	801824c <decode_mcu_sub+0x3dc>
 8017f7e:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8017f80:	6abc      	ldr	r4, [r7, #40]	@ 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 8017f82:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017f84:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8017f86:	3222      	adds	r2, #34	@ 0x22
 8017f88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017f8c:	63bb      	str	r3, [r7, #56]	@ 0x38
      k = 1;
 8017f8e:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 8017f92:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017f94:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8017f96:	322c      	adds	r2, #44	@ 0x2c
 8017f98:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017f9c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (coef_limit) {
 8017f9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017fa0:	2b00      	cmp	r3, #0
 8017fa2:	f000 80ba 	beq.w	801811a <decode_mcu_sub+0x2aa>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 8017fa6:	2d00      	cmp	r5, #0
 8017fa8:	d025      	beq.n	8017ff6 <decode_mcu_sub+0x186>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8017faa:	42ac      	cmp	r4, r5
 8017fac:	da0d      	bge.n	8017fca <decode_mcu_sub+0x15a>
 8017fae:	f107 001c 	add.w	r0, r7, #28
 8017fb2:	462b      	mov	r3, r5
 8017fb4:	4622      	mov	r2, r4
 8017fb6:	4631      	mov	r1, r6
 8017fb8:	f7ff f90c 	bl	80171d4 <jpeg_fill_bit_buffer>
 8017fbc:	4603      	mov	r3, r0
 8017fbe:	2b00      	cmp	r3, #0
 8017fc0:	d101      	bne.n	8017fc6 <decode_mcu_sub+0x156>
 8017fc2:	2300      	movs	r3, #0
 8017fc4:	e142      	b.n	801824c <decode_mcu_sub+0x3dc>
 8017fc6:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8017fc8:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  r = GET_BITS(s);
 8017fca:	1b64      	subs	r4, r4, r5
 8017fcc:	fa46 f204 	asr.w	r2, r6, r4
 8017fd0:	4ba1      	ldr	r3, [pc, #644]	@ (8018258 <decode_mcu_sub+0x3e8>)
 8017fd2:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8017fd6:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 8017fda:	1e6b      	subs	r3, r5, #1
 8017fdc:	4a9e      	ldr	r2, [pc, #632]	@ (8018258 <decode_mcu_sub+0x3e8>)
 8017fde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8017fe2:	4599      	cmp	r9, r3
 8017fe4:	dc05      	bgt.n	8017ff2 <decode_mcu_sub+0x182>
 8017fe6:	4b9c      	ldr	r3, [pc, #624]	@ (8018258 <decode_mcu_sub+0x3e8>)
 8017fe8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8017fec:	eba9 0303 	sub.w	r3, r9, r3
 8017ff0:	e000      	b.n	8017ff4 <decode_mcu_sub+0x184>
 8017ff2:	464b      	mov	r3, r9
 8017ff4:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 8017ff6:	687b      	ldr	r3, [r7, #4]
 8017ff8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8017ffa:	325c      	adds	r2, #92	@ 0x5c
 8017ffc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018000:	633b      	str	r3, [r7, #48]	@ 0x30
	s += state.last_dc_val[ci];
 8018002:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018004:	009b      	lsls	r3, r3, #2
 8018006:	3350      	adds	r3, #80	@ 0x50
 8018008:	443b      	add	r3, r7
 801800a:	f853 3c44 	ldr.w	r3, [r3, #-68]
 801800e:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 8018010:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018012:	009b      	lsls	r3, r3, #2
 8018014:	3350      	adds	r3, #80	@ 0x50
 8018016:	443b      	add	r3, r7
 8018018:	f843 5c44 	str.w	r5, [r3, #-68]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 801801c:	b22a      	sxth	r2, r5
 801801e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018020:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 8018022:	e076      	b.n	8018112 <decode_mcu_sub+0x2a2>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8018024:	2c07      	cmp	r4, #7
 8018026:	dc11      	bgt.n	801804c <decode_mcu_sub+0x1dc>
 8018028:	f107 001c 	add.w	r0, r7, #28
 801802c:	2300      	movs	r3, #0
 801802e:	4622      	mov	r2, r4
 8018030:	4631      	mov	r1, r6
 8018032:	f7ff f8cf 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018036:	4603      	mov	r3, r0
 8018038:	2b00      	cmp	r3, #0
 801803a:	d101      	bne.n	8018040 <decode_mcu_sub+0x1d0>
 801803c:	2300      	movs	r3, #0
 801803e:	e105      	b.n	801824c <decode_mcu_sub+0x3dc>
 8018040:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018042:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8018044:	2c07      	cmp	r4, #7
 8018046:	dc01      	bgt.n	801804c <decode_mcu_sub+0x1dc>
 8018048:	2501      	movs	r5, #1
 801804a:	e015      	b.n	8018078 <decode_mcu_sub+0x208>
 801804c:	f1a4 0308 	sub.w	r3, r4, #8
 8018050:	fa46 f303 	asr.w	r3, r6, r3
 8018054:	22ff      	movs	r2, #255	@ 0xff
 8018056:	ea03 0902 	and.w	r9, r3, r2
 801805a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801805c:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 8018060:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8018064:	2d00      	cmp	r5, #0
 8018066:	d006      	beq.n	8018076 <decode_mcu_sub+0x206>
 8018068:	1b64      	subs	r4, r4, r5
 801806a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801806c:	444b      	add	r3, r9
 801806e:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8018072:	461d      	mov	r5, r3
 8018074:	e00f      	b.n	8018096 <decode_mcu_sub+0x226>
 8018076:	2509      	movs	r5, #9
 8018078:	f107 001c 	add.w	r0, r7, #28
 801807c:	9500      	str	r5, [sp, #0]
 801807e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018080:	4622      	mov	r2, r4
 8018082:	4631      	mov	r1, r6
 8018084:	f7ff f92c 	bl	80172e0 <jpeg_huff_decode>
 8018088:	4605      	mov	r5, r0
 801808a:	2d00      	cmp	r5, #0
 801808c:	da01      	bge.n	8018092 <decode_mcu_sub+0x222>
 801808e:	2300      	movs	r3, #0
 8018090:	e0dc      	b.n	801824c <decode_mcu_sub+0x3dc>
 8018092:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018094:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	  r = s >> 4;
 8018096:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 801809a:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 801809e:	2d00      	cmp	r5, #0
 80180a0:	d030      	beq.n	8018104 <decode_mcu_sub+0x294>
	    k += r;
 80180a2:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 80180a4:	42ac      	cmp	r4, r5
 80180a6:	da0d      	bge.n	80180c4 <decode_mcu_sub+0x254>
 80180a8:	f107 001c 	add.w	r0, r7, #28
 80180ac:	462b      	mov	r3, r5
 80180ae:	4622      	mov	r2, r4
 80180b0:	4631      	mov	r1, r6
 80180b2:	f7ff f88f 	bl	80171d4 <jpeg_fill_bit_buffer>
 80180b6:	4603      	mov	r3, r0
 80180b8:	2b00      	cmp	r3, #0
 80180ba:	d101      	bne.n	80180c0 <decode_mcu_sub+0x250>
 80180bc:	2300      	movs	r3, #0
 80180be:	e0c5      	b.n	801824c <decode_mcu_sub+0x3dc>
 80180c0:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80180c2:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	    r = GET_BITS(s);
 80180c4:	1b64      	subs	r4, r4, r5
 80180c6:	fa46 f204 	asr.w	r2, r6, r4
 80180ca:	4b63      	ldr	r3, [pc, #396]	@ (8018258 <decode_mcu_sub+0x3e8>)
 80180cc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80180d0:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 80180d4:	1e6b      	subs	r3, r5, #1
 80180d6:	4a60      	ldr	r2, [pc, #384]	@ (8018258 <decode_mcu_sub+0x3e8>)
 80180d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80180dc:	4599      	cmp	r9, r3
 80180de:	dc05      	bgt.n	80180ec <decode_mcu_sub+0x27c>
 80180e0:	4b5d      	ldr	r3, [pc, #372]	@ (8018258 <decode_mcu_sub+0x3e8>)
 80180e2:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80180e6:	eba9 0303 	sub.w	r3, r9, r3
 80180ea:	e000      	b.n	80180ee <decode_mcu_sub+0x27e>
 80180ec:	464b      	mov	r3, r9
 80180ee:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in natural_order[] will save us
	     * if k > Se, which could happen if the data is corrupted.
	     */
	    (*block)[natural_order[k]] = (JCOEF) s;
 80180f0:	4643      	mov	r3, r8
 80180f2:	009b      	lsls	r3, r3, #2
 80180f4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80180f6:	4413      	add	r3, r2
 80180f8:	681a      	ldr	r2, [r3, #0]
 80180fa:	b229      	sxth	r1, r5
 80180fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80180fe:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 8018102:	e004      	b.n	801810e <decode_mcu_sub+0x29e>
	  } else {
	    if (r != 15)
 8018104:	f1b9 0f0f 	cmp.w	r9, #15
 8018108:	d178      	bne.n	80181fc <decode_mcu_sub+0x38c>
	      goto EndOfBlock;
	    k += 15;
 801810a:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 801810e:	f108 0801 	add.w	r8, r8, #1
 8018112:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8018114:	4598      	cmp	r8, r3
 8018116:	db85      	blt.n	8018024 <decode_mcu_sub+0x1b4>
 8018118:	e06c      	b.n	80181f4 <decode_mcu_sub+0x384>
	  }
	}
      } else {
	if (s) {
 801811a:	2d00      	cmp	r5, #0
 801811c:	d06a      	beq.n	80181f4 <decode_mcu_sub+0x384>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801811e:	42ac      	cmp	r4, r5
 8018120:	da0d      	bge.n	801813e <decode_mcu_sub+0x2ce>
 8018122:	f107 001c 	add.w	r0, r7, #28
 8018126:	462b      	mov	r3, r5
 8018128:	4622      	mov	r2, r4
 801812a:	4631      	mov	r1, r6
 801812c:	f7ff f852 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018130:	4603      	mov	r3, r0
 8018132:	2b00      	cmp	r3, #0
 8018134:	d101      	bne.n	801813a <decode_mcu_sub+0x2ca>
 8018136:	2300      	movs	r3, #0
 8018138:	e088      	b.n	801824c <decode_mcu_sub+0x3dc>
 801813a:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801813c:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 801813e:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k <= Se; k++) {
 8018140:	e058      	b.n	80181f4 <decode_mcu_sub+0x384>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 8018142:	2c07      	cmp	r4, #7
 8018144:	dc11      	bgt.n	801816a <decode_mcu_sub+0x2fa>
 8018146:	f107 001c 	add.w	r0, r7, #28
 801814a:	2300      	movs	r3, #0
 801814c:	4622      	mov	r2, r4
 801814e:	4631      	mov	r1, r6
 8018150:	f7ff f840 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018154:	4603      	mov	r3, r0
 8018156:	2b00      	cmp	r3, #0
 8018158:	d101      	bne.n	801815e <decode_mcu_sub+0x2ee>
 801815a:	2300      	movs	r3, #0
 801815c:	e076      	b.n	801824c <decode_mcu_sub+0x3dc>
 801815e:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018160:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8018162:	2c07      	cmp	r4, #7
 8018164:	dc01      	bgt.n	801816a <decode_mcu_sub+0x2fa>
 8018166:	2501      	movs	r5, #1
 8018168:	e015      	b.n	8018196 <decode_mcu_sub+0x326>
 801816a:	f1a4 0308 	sub.w	r3, r4, #8
 801816e:	fa46 f303 	asr.w	r3, r6, r3
 8018172:	22ff      	movs	r2, #255	@ 0xff
 8018174:	ea03 0902 	and.w	r9, r3, r2
 8018178:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801817a:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 801817e:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8018182:	2d00      	cmp	r5, #0
 8018184:	d006      	beq.n	8018194 <decode_mcu_sub+0x324>
 8018186:	1b64      	subs	r4, r4, r5
 8018188:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801818a:	444b      	add	r3, r9
 801818c:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8018190:	461d      	mov	r5, r3
 8018192:	e00f      	b.n	80181b4 <decode_mcu_sub+0x344>
 8018194:	2509      	movs	r5, #9
 8018196:	f107 001c 	add.w	r0, r7, #28
 801819a:	9500      	str	r5, [sp, #0]
 801819c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801819e:	4622      	mov	r2, r4
 80181a0:	4631      	mov	r1, r6
 80181a2:	f7ff f89d 	bl	80172e0 <jpeg_huff_decode>
 80181a6:	4605      	mov	r5, r0
 80181a8:	2d00      	cmp	r5, #0
 80181aa:	da01      	bge.n	80181b0 <decode_mcu_sub+0x340>
 80181ac:	2300      	movs	r3, #0
 80181ae:	e04d      	b.n	801824c <decode_mcu_sub+0x3dc>
 80181b0:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80181b2:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	r = s >> 4;
 80181b4:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 80181b8:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 80181bc:	2d00      	cmp	r5, #0
 80181be:	d012      	beq.n	80181e6 <decode_mcu_sub+0x376>
	  k += r;
 80181c0:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 80181c2:	42ac      	cmp	r4, r5
 80181c4:	da0d      	bge.n	80181e2 <decode_mcu_sub+0x372>
 80181c6:	f107 001c 	add.w	r0, r7, #28
 80181ca:	462b      	mov	r3, r5
 80181cc:	4622      	mov	r2, r4
 80181ce:	4631      	mov	r1, r6
 80181d0:	f7ff f800 	bl	80171d4 <jpeg_fill_bit_buffer>
 80181d4:	4603      	mov	r3, r0
 80181d6:	2b00      	cmp	r3, #0
 80181d8:	d101      	bne.n	80181de <decode_mcu_sub+0x36e>
 80181da:	2300      	movs	r3, #0
 80181dc:	e036      	b.n	801824c <decode_mcu_sub+0x3dc>
 80181de:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80181e0:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 80181e2:	1b64      	subs	r4, r4, r5
 80181e4:	e004      	b.n	80181f0 <decode_mcu_sub+0x380>
	} else {
	  if (r != 15)
 80181e6:	f1b9 0f0f 	cmp.w	r9, #15
 80181ea:	d109      	bne.n	8018200 <decode_mcu_sub+0x390>
	    break;
	  k += 15;
 80181ec:	f108 080f 	add.w	r8, r8, #15
      for (; k <= Se; k++) {
 80181f0:	f108 0801 	add.w	r8, r8, #1
 80181f4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80181f6:	4598      	cmp	r8, r3
 80181f8:	dda3      	ble.n	8018142 <decode_mcu_sub+0x2d2>
	}
      }

      EndOfBlock: ;
 80181fa:	e002      	b.n	8018202 <decode_mcu_sub+0x392>
	      goto EndOfBlock;
 80181fc:	bf00      	nop
 80181fe:	e000      	b.n	8018202 <decode_mcu_sub+0x392>
	    break;
 8018200:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8018202:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8018204:	3301      	adds	r3, #1
 8018206:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8018208:	687b      	ldr	r3, [r7, #4]
 801820a:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 801820e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8018210:	429a      	cmp	r2, r3
 8018212:	f6ff ae71 	blt.w	8017ef8 <decode_mcu_sub+0x88>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8018216:	687b      	ldr	r3, [r7, #4]
 8018218:	699b      	ldr	r3, [r3, #24]
 801821a:	69fa      	ldr	r2, [r7, #28]
 801821c:	601a      	str	r2, [r3, #0]
 801821e:	687b      	ldr	r3, [r7, #4]
 8018220:	699b      	ldr	r3, [r3, #24]
 8018222:	6a3a      	ldr	r2, [r7, #32]
 8018224:	605a      	str	r2, [r3, #4]
 8018226:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018228:	609e      	str	r6, [r3, #8]
 801822a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801822c:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 801822e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018230:	f103 0410 	add.w	r4, r3, #16
 8018234:	f107 0508 	add.w	r5, r7, #8
 8018238:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801823a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801823c:	682b      	ldr	r3, [r5, #0]
 801823e:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8018240:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018242:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018244:	1e5a      	subs	r2, r3, #1
 8018246:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018248:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 801824a:	2301      	movs	r3, #1
}
 801824c:	4618      	mov	r0, r3
 801824e:	3754      	adds	r7, #84	@ 0x54
 8018250:	46bd      	mov	sp, r7
 8018252:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8018256:	bf00      	nop
 8018258:	080323f4 	.word	0x080323f4

0801825c <decode_mcu>:
 * full-size blocks.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 801825c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8018260:	b095      	sub	sp, #84	@ 0x54
 8018262:	af02      	add	r7, sp, #8
 8018264:	6078      	str	r0, [r7, #4]
 8018266:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8018268:	687b      	ldr	r3, [r7, #4]
 801826a:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 801826e:	643b      	str	r3, [r7, #64]	@ 0x40
  int blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8018270:	687b      	ldr	r3, [r7, #4]
 8018272:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 8018276:	2b00      	cmp	r3, #0
 8018278:	d00b      	beq.n	8018292 <decode_mcu+0x36>
    if (entropy->restarts_to_go == 0)
 801827a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801827c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801827e:	2b00      	cmp	r3, #0
 8018280:	d107      	bne.n	8018292 <decode_mcu+0x36>
      if (! process_restart(cinfo))
 8018282:	6878      	ldr	r0, [r7, #4]
 8018284:	f7ff f890 	bl	80173a8 <process_restart>
 8018288:	4603      	mov	r3, r0
 801828a:	2b00      	cmp	r3, #0
 801828c:	d101      	bne.n	8018292 <decode_mcu+0x36>
	return FALSE;
 801828e:	2300      	movs	r3, #0
 8018290:	e1c8      	b.n	8018624 <decode_mcu+0x3c8>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8018292:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018294:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018296:	2b00      	cmp	r3, #0
 8018298:	f040 81be 	bne.w	8018618 <decode_mcu+0x3bc>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 801829c:	687b      	ldr	r3, [r7, #4]
 801829e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80182a0:	687b      	ldr	r3, [r7, #4]
 80182a2:	699b      	ldr	r3, [r3, #24]
 80182a4:	681b      	ldr	r3, [r3, #0]
 80182a6:	61fb      	str	r3, [r7, #28]
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	699b      	ldr	r3, [r3, #24]
 80182ac:	685b      	ldr	r3, [r3, #4]
 80182ae:	623b      	str	r3, [r7, #32]
 80182b0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80182b2:	689e      	ldr	r6, [r3, #8]
 80182b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80182b6:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 80182b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80182ba:	f107 0508 	add.w	r5, r7, #8
 80182be:	f103 0c10 	add.w	ip, r3, #16
 80182c2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80182c6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80182c8:	f8dc 3000 	ldr.w	r3, [ip]
 80182cc:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80182ce:	2300      	movs	r3, #0
 80182d0:	647b      	str	r3, [r7, #68]	@ 0x44
 80182d2:	e185      	b.n	80185e0 <decode_mcu+0x384>
      JBLOCKROW block = MCU_data[blkn];
 80182d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80182d6:	009b      	lsls	r3, r3, #2
 80182d8:	683a      	ldr	r2, [r7, #0]
 80182da:	4413      	add	r3, r2
 80182dc:	681b      	ldr	r3, [r3, #0]
 80182de:	63fb      	str	r3, [r7, #60]	@ 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 80182e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80182e2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80182e4:	3218      	adds	r2, #24
 80182e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80182ea:	63bb      	str	r3, [r7, #56]	@ 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 80182ec:	2c07      	cmp	r4, #7
 80182ee:	dc11      	bgt.n	8018314 <decode_mcu+0xb8>
 80182f0:	f107 001c 	add.w	r0, r7, #28
 80182f4:	2300      	movs	r3, #0
 80182f6:	4622      	mov	r2, r4
 80182f8:	4631      	mov	r1, r6
 80182fa:	f7fe ff6b 	bl	80171d4 <jpeg_fill_bit_buffer>
 80182fe:	4603      	mov	r3, r0
 8018300:	2b00      	cmp	r3, #0
 8018302:	d101      	bne.n	8018308 <decode_mcu+0xac>
 8018304:	2300      	movs	r3, #0
 8018306:	e18d      	b.n	8018624 <decode_mcu+0x3c8>
 8018308:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801830a:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 801830c:	2c07      	cmp	r4, #7
 801830e:	dc01      	bgt.n	8018314 <decode_mcu+0xb8>
 8018310:	2501      	movs	r5, #1
 8018312:	e015      	b.n	8018340 <decode_mcu+0xe4>
 8018314:	f1a4 0308 	sub.w	r3, r4, #8
 8018318:	fa46 f303 	asr.w	r3, r6, r3
 801831c:	22ff      	movs	r2, #255	@ 0xff
 801831e:	ea03 0802 	and.w	r8, r3, r2
 8018322:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018324:	f108 0224 	add.w	r2, r8, #36	@ 0x24
 8018328:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801832c:	2d00      	cmp	r5, #0
 801832e:	d006      	beq.n	801833e <decode_mcu+0xe2>
 8018330:	1b64      	subs	r4, r4, r5
 8018332:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018334:	4443      	add	r3, r8
 8018336:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801833a:	461d      	mov	r5, r3
 801833c:	e00f      	b.n	801835e <decode_mcu+0x102>
 801833e:	2509      	movs	r5, #9
 8018340:	f107 001c 	add.w	r0, r7, #28
 8018344:	9500      	str	r5, [sp, #0]
 8018346:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018348:	4622      	mov	r2, r4
 801834a:	4631      	mov	r1, r6
 801834c:	f7fe ffc8 	bl	80172e0 <jpeg_huff_decode>
 8018350:	4605      	mov	r5, r0
 8018352:	2d00      	cmp	r5, #0
 8018354:	da01      	bge.n	801835a <decode_mcu+0xfe>
 8018356:	2300      	movs	r3, #0
 8018358:	e164      	b.n	8018624 <decode_mcu+0x3c8>
 801835a:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801835c:	6abc      	ldr	r4, [r7, #40]	@ 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 801835e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018360:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8018362:	3222      	adds	r2, #34	@ 0x22
 8018364:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018368:	63bb      	str	r3, [r7, #56]	@ 0x38
      k = 1;
 801836a:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 801836e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018370:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8018372:	322c      	adds	r2, #44	@ 0x2c
 8018374:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8018378:	637b      	str	r3, [r7, #52]	@ 0x34
      if (coef_limit) {
 801837a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801837c:	2b00      	cmp	r3, #0
 801837e:	f000 80b8 	beq.w	80184f2 <decode_mcu+0x296>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 8018382:	2d00      	cmp	r5, #0
 8018384:	d025      	beq.n	80183d2 <decode_mcu+0x176>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8018386:	42ac      	cmp	r4, r5
 8018388:	da0d      	bge.n	80183a6 <decode_mcu+0x14a>
 801838a:	f107 001c 	add.w	r0, r7, #28
 801838e:	462b      	mov	r3, r5
 8018390:	4622      	mov	r2, r4
 8018392:	4631      	mov	r1, r6
 8018394:	f7fe ff1e 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018398:	4603      	mov	r3, r0
 801839a:	2b00      	cmp	r3, #0
 801839c:	d101      	bne.n	80183a2 <decode_mcu+0x146>
 801839e:	2300      	movs	r3, #0
 80183a0:	e140      	b.n	8018624 <decode_mcu+0x3c8>
 80183a2:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80183a4:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  r = GET_BITS(s);
 80183a6:	1b64      	subs	r4, r4, r5
 80183a8:	fa46 f204 	asr.w	r2, r6, r4
 80183ac:	4ba0      	ldr	r3, [pc, #640]	@ (8018630 <decode_mcu+0x3d4>)
 80183ae:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80183b2:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 80183b6:	1e6b      	subs	r3, r5, #1
 80183b8:	4a9d      	ldr	r2, [pc, #628]	@ (8018630 <decode_mcu+0x3d4>)
 80183ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80183be:	4599      	cmp	r9, r3
 80183c0:	dc05      	bgt.n	80183ce <decode_mcu+0x172>
 80183c2:	4b9b      	ldr	r3, [pc, #620]	@ (8018630 <decode_mcu+0x3d4>)
 80183c4:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80183c8:	eba9 0303 	sub.w	r3, r9, r3
 80183cc:	e000      	b.n	80183d0 <decode_mcu+0x174>
 80183ce:	464b      	mov	r3, r9
 80183d0:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 80183d2:	687b      	ldr	r3, [r7, #4]
 80183d4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80183d6:	325c      	adds	r2, #92	@ 0x5c
 80183d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80183dc:	633b      	str	r3, [r7, #48]	@ 0x30
	s += state.last_dc_val[ci];
 80183de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80183e0:	009b      	lsls	r3, r3, #2
 80183e2:	3348      	adds	r3, #72	@ 0x48
 80183e4:	443b      	add	r3, r7
 80183e6:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 80183ea:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 80183ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80183ee:	009b      	lsls	r3, r3, #2
 80183f0:	3348      	adds	r3, #72	@ 0x48
 80183f2:	443b      	add	r3, r7
 80183f4:	f843 5c3c 	str.w	r5, [r3, #-60]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 80183f8:	b22a      	sxth	r2, r5
 80183fa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80183fc:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 80183fe:	e074      	b.n	80184ea <decode_mcu+0x28e>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8018400:	2c07      	cmp	r4, #7
 8018402:	dc11      	bgt.n	8018428 <decode_mcu+0x1cc>
 8018404:	f107 001c 	add.w	r0, r7, #28
 8018408:	2300      	movs	r3, #0
 801840a:	4622      	mov	r2, r4
 801840c:	4631      	mov	r1, r6
 801840e:	f7fe fee1 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018412:	4603      	mov	r3, r0
 8018414:	2b00      	cmp	r3, #0
 8018416:	d101      	bne.n	801841c <decode_mcu+0x1c0>
 8018418:	2300      	movs	r3, #0
 801841a:	e103      	b.n	8018624 <decode_mcu+0x3c8>
 801841c:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801841e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8018420:	2c07      	cmp	r4, #7
 8018422:	dc01      	bgt.n	8018428 <decode_mcu+0x1cc>
 8018424:	2501      	movs	r5, #1
 8018426:	e015      	b.n	8018454 <decode_mcu+0x1f8>
 8018428:	f1a4 0308 	sub.w	r3, r4, #8
 801842c:	fa46 f303 	asr.w	r3, r6, r3
 8018430:	22ff      	movs	r2, #255	@ 0xff
 8018432:	ea03 0902 	and.w	r9, r3, r2
 8018436:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018438:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 801843c:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8018440:	2d00      	cmp	r5, #0
 8018442:	d006      	beq.n	8018452 <decode_mcu+0x1f6>
 8018444:	1b64      	subs	r4, r4, r5
 8018446:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018448:	444b      	add	r3, r9
 801844a:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 801844e:	461d      	mov	r5, r3
 8018450:	e00f      	b.n	8018472 <decode_mcu+0x216>
 8018452:	2509      	movs	r5, #9
 8018454:	f107 001c 	add.w	r0, r7, #28
 8018458:	9500      	str	r5, [sp, #0]
 801845a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801845c:	4622      	mov	r2, r4
 801845e:	4631      	mov	r1, r6
 8018460:	f7fe ff3e 	bl	80172e0 <jpeg_huff_decode>
 8018464:	4605      	mov	r5, r0
 8018466:	2d00      	cmp	r5, #0
 8018468:	da01      	bge.n	801846e <decode_mcu+0x212>
 801846a:	2300      	movs	r3, #0
 801846c:	e0da      	b.n	8018624 <decode_mcu+0x3c8>
 801846e:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018470:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	  r = s >> 4;
 8018472:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 8018476:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 801847a:	2d00      	cmp	r5, #0
 801847c:	d02e      	beq.n	80184dc <decode_mcu+0x280>
	    k += r;
 801847e:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8018480:	42ac      	cmp	r4, r5
 8018482:	da0d      	bge.n	80184a0 <decode_mcu+0x244>
 8018484:	f107 001c 	add.w	r0, r7, #28
 8018488:	462b      	mov	r3, r5
 801848a:	4622      	mov	r2, r4
 801848c:	4631      	mov	r1, r6
 801848e:	f7fe fea1 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018492:	4603      	mov	r3, r0
 8018494:	2b00      	cmp	r3, #0
 8018496:	d101      	bne.n	801849c <decode_mcu+0x240>
 8018498:	2300      	movs	r3, #0
 801849a:	e0c3      	b.n	8018624 <decode_mcu+0x3c8>
 801849c:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801849e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	    r = GET_BITS(s);
 80184a0:	1b64      	subs	r4, r4, r5
 80184a2:	fa46 f204 	asr.w	r2, r6, r4
 80184a6:	4b62      	ldr	r3, [pc, #392]	@ (8018630 <decode_mcu+0x3d4>)
 80184a8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80184ac:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 80184b0:	1e6b      	subs	r3, r5, #1
 80184b2:	4a5f      	ldr	r2, [pc, #380]	@ (8018630 <decode_mcu+0x3d4>)
 80184b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80184b8:	4599      	cmp	r9, r3
 80184ba:	dc05      	bgt.n	80184c8 <decode_mcu+0x26c>
 80184bc:	4b5c      	ldr	r3, [pc, #368]	@ (8018630 <decode_mcu+0x3d4>)
 80184be:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80184c2:	eba9 0303 	sub.w	r3, r9, r3
 80184c6:	e000      	b.n	80184ca <decode_mcu+0x26e>
 80184c8:	464b      	mov	r3, r9
 80184ca:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
 80184cc:	4b59      	ldr	r3, [pc, #356]	@ (8018634 <decode_mcu+0x3d8>)
 80184ce:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
 80184d2:	b229      	sxth	r1, r5
 80184d4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80184d6:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 80184da:	e004      	b.n	80184e6 <decode_mcu+0x28a>
	  } else {
	    if (r != 15)
 80184dc:	f1b9 0f0f 	cmp.w	r9, #15
 80184e0:	d178      	bne.n	80185d4 <decode_mcu+0x378>
	      goto EndOfBlock;
	    k += 15;
 80184e2:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 80184e6:	f108 0801 	add.w	r8, r8, #1
 80184ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80184ec:	4598      	cmp	r8, r3
 80184ee:	db87      	blt.n	8018400 <decode_mcu+0x1a4>
 80184f0:	e06c      	b.n	80185cc <decode_mcu+0x370>
	  }
	}
      } else {
	if (s) {
 80184f2:	2d00      	cmp	r5, #0
 80184f4:	d06a      	beq.n	80185cc <decode_mcu+0x370>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 80184f6:	42ac      	cmp	r4, r5
 80184f8:	da0d      	bge.n	8018516 <decode_mcu+0x2ba>
 80184fa:	f107 001c 	add.w	r0, r7, #28
 80184fe:	462b      	mov	r3, r5
 8018500:	4622      	mov	r2, r4
 8018502:	4631      	mov	r1, r6
 8018504:	f7fe fe66 	bl	80171d4 <jpeg_fill_bit_buffer>
 8018508:	4603      	mov	r3, r0
 801850a:	2b00      	cmp	r3, #0
 801850c:	d101      	bne.n	8018512 <decode_mcu+0x2b6>
 801850e:	2300      	movs	r3, #0
 8018510:	e088      	b.n	8018624 <decode_mcu+0x3c8>
 8018512:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018514:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 8018516:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k < DCTSIZE2; k++) {
 8018518:	e058      	b.n	80185cc <decode_mcu+0x370>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 801851a:	2c07      	cmp	r4, #7
 801851c:	dc11      	bgt.n	8018542 <decode_mcu+0x2e6>
 801851e:	f107 001c 	add.w	r0, r7, #28
 8018522:	2300      	movs	r3, #0
 8018524:	4622      	mov	r2, r4
 8018526:	4631      	mov	r1, r6
 8018528:	f7fe fe54 	bl	80171d4 <jpeg_fill_bit_buffer>
 801852c:	4603      	mov	r3, r0
 801852e:	2b00      	cmp	r3, #0
 8018530:	d101      	bne.n	8018536 <decode_mcu+0x2da>
 8018532:	2300      	movs	r3, #0
 8018534:	e076      	b.n	8018624 <decode_mcu+0x3c8>
 8018536:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 8018538:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 801853a:	2c07      	cmp	r4, #7
 801853c:	dc01      	bgt.n	8018542 <decode_mcu+0x2e6>
 801853e:	2501      	movs	r5, #1
 8018540:	e015      	b.n	801856e <decode_mcu+0x312>
 8018542:	f1a4 0308 	sub.w	r3, r4, #8
 8018546:	fa46 f303 	asr.w	r3, r6, r3
 801854a:	22ff      	movs	r2, #255	@ 0xff
 801854c:	ea03 0902 	and.w	r9, r3, r2
 8018550:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018552:	f109 0224 	add.w	r2, r9, #36	@ 0x24
 8018556:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 801855a:	2d00      	cmp	r5, #0
 801855c:	d006      	beq.n	801856c <decode_mcu+0x310>
 801855e:	1b64      	subs	r4, r4, r5
 8018560:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018562:	444b      	add	r3, r9
 8018564:	f893 3490 	ldrb.w	r3, [r3, #1168]	@ 0x490
 8018568:	461d      	mov	r5, r3
 801856a:	e00f      	b.n	801858c <decode_mcu+0x330>
 801856c:	2509      	movs	r5, #9
 801856e:	f107 001c 	add.w	r0, r7, #28
 8018572:	9500      	str	r5, [sp, #0]
 8018574:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018576:	4622      	mov	r2, r4
 8018578:	4631      	mov	r1, r6
 801857a:	f7fe feb1 	bl	80172e0 <jpeg_huff_decode>
 801857e:	4605      	mov	r5, r0
 8018580:	2d00      	cmp	r5, #0
 8018582:	da01      	bge.n	8018588 <decode_mcu+0x32c>
 8018584:	2300      	movs	r3, #0
 8018586:	e04d      	b.n	8018624 <decode_mcu+0x3c8>
 8018588:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 801858a:	6abc      	ldr	r4, [r7, #40]	@ 0x28

	r = s >> 4;
 801858c:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 8018590:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 8018594:	2d00      	cmp	r5, #0
 8018596:	d012      	beq.n	80185be <decode_mcu+0x362>
	  k += r;
 8018598:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801859a:	42ac      	cmp	r4, r5
 801859c:	da0d      	bge.n	80185ba <decode_mcu+0x35e>
 801859e:	f107 001c 	add.w	r0, r7, #28
 80185a2:	462b      	mov	r3, r5
 80185a4:	4622      	mov	r2, r4
 80185a6:	4631      	mov	r1, r6
 80185a8:	f7fe fe14 	bl	80171d4 <jpeg_fill_bit_buffer>
 80185ac:	4603      	mov	r3, r0
 80185ae:	2b00      	cmp	r3, #0
 80185b0:	d101      	bne.n	80185b6 <decode_mcu+0x35a>
 80185b2:	2300      	movs	r3, #0
 80185b4:	e036      	b.n	8018624 <decode_mcu+0x3c8>
 80185b6:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
 80185b8:	6abc      	ldr	r4, [r7, #40]	@ 0x28
	  DROP_BITS(s);
 80185ba:	1b64      	subs	r4, r4, r5
 80185bc:	e004      	b.n	80185c8 <decode_mcu+0x36c>
	} else {
	  if (r != 15)
 80185be:	f1b9 0f0f 	cmp.w	r9, #15
 80185c2:	d109      	bne.n	80185d8 <decode_mcu+0x37c>
	    break;
	  k += 15;
 80185c4:	f108 080f 	add.w	r8, r8, #15
      for (; k < DCTSIZE2; k++) {
 80185c8:	f108 0801 	add.w	r8, r8, #1
 80185cc:	f1b8 0f3f 	cmp.w	r8, #63	@ 0x3f
 80185d0:	dda3      	ble.n	801851a <decode_mcu+0x2be>
	}
      }

      EndOfBlock: ;
 80185d2:	e002      	b.n	80185da <decode_mcu+0x37e>
	      goto EndOfBlock;
 80185d4:	bf00      	nop
 80185d6:	e000      	b.n	80185da <decode_mcu+0x37e>
	    break;
 80185d8:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80185da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80185dc:	3301      	adds	r3, #1
 80185de:	647b      	str	r3, [r7, #68]	@ 0x44
 80185e0:	687b      	ldr	r3, [r7, #4]
 80185e2:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 80185e6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80185e8:	429a      	cmp	r2, r3
 80185ea:	f6ff ae73 	blt.w	80182d4 <decode_mcu+0x78>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 80185ee:	687b      	ldr	r3, [r7, #4]
 80185f0:	699b      	ldr	r3, [r3, #24]
 80185f2:	69fa      	ldr	r2, [r7, #28]
 80185f4:	601a      	str	r2, [r3, #0]
 80185f6:	687b      	ldr	r3, [r7, #4]
 80185f8:	699b      	ldr	r3, [r3, #24]
 80185fa:	6a3a      	ldr	r2, [r7, #32]
 80185fc:	605a      	str	r2, [r3, #4]
 80185fe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018600:	609e      	str	r6, [r3, #8]
 8018602:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018604:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 8018606:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018608:	f103 0410 	add.w	r4, r3, #16
 801860c:	f107 0508 	add.w	r5, r7, #8
 8018610:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018612:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018614:	682b      	ldr	r3, [r5, #0]
 8018616:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8018618:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801861a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801861c:	1e5a      	subs	r2, r3, #1
 801861e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018620:	629a      	str	r2, [r3, #40]	@ 0x28

  return TRUE;
 8018622:	2301      	movs	r3, #1
}
 8018624:	4618      	mov	r0, r3
 8018626:	374c      	adds	r7, #76	@ 0x4c
 8018628:	46bd      	mov	sp, r7
 801862a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801862e:	bf00      	nop
 8018630:	080323f4 	.word	0x080323f4
 8018634:	08032750 	.word	0x08032750

08018638 <start_pass_huff_decoder>:
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
 8018638:	b580      	push	{r7, lr}
 801863a:	b08c      	sub	sp, #48	@ 0x30
 801863c:	af00      	add	r7, sp, #0
 801863e:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8018640:	687b      	ldr	r3, [r7, #4]
 8018642:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8018646:	61fb      	str	r3, [r7, #28]
  int ci, blkn, tbl, i;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 8018648:	687b      	ldr	r3, [r7, #4]
 801864a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801864e:	2b00      	cmp	r3, #0
 8018650:	f000 8133 	beq.w	80188ba <start_pass_huff_decoder+0x282>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 8018654:	687b      	ldr	r3, [r7, #4]
 8018656:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801865a:	2b00      	cmp	r3, #0
 801865c:	d105      	bne.n	801866a <start_pass_huff_decoder+0x32>
      if (cinfo->Se != 0)
 801865e:	687b      	ldr	r3, [r7, #4]
 8018660:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 8018664:	2b00      	cmp	r3, #0
 8018666:	d015      	beq.n	8018694 <start_pass_huff_decoder+0x5c>
	goto bad;
 8018668:	e02d      	b.n	80186c6 <start_pass_huff_decoder+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 801866a:	687b      	ldr	r3, [r7, #4]
 801866c:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8018670:	687b      	ldr	r3, [r7, #4]
 8018672:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8018676:	429a      	cmp	r2, r3
 8018678:	db20      	blt.n	80186bc <start_pass_huff_decoder+0x84>
 801867a:	687b      	ldr	r3, [r7, #4]
 801867c:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8018680:	687b      	ldr	r3, [r7, #4]
 8018682:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8018686:	429a      	cmp	r2, r3
 8018688:	dc18      	bgt.n	80186bc <start_pass_huff_decoder+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 801868a:	687b      	ldr	r3, [r7, #4]
 801868c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8018690:	2b01      	cmp	r3, #1
 8018692:	d115      	bne.n	80186c0 <start_pass_huff_decoder+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 8018694:	687b      	ldr	r3, [r7, #4]
 8018696:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 801869a:	2b00      	cmp	r3, #0
 801869c:	d008      	beq.n	80186b0 <start_pass_huff_decoder+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 801869e:	687b      	ldr	r3, [r7, #4]
 80186a0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80186a4:	1e5a      	subs	r2, r3, #1
 80186a6:	687b      	ldr	r3, [r7, #4]
 80186a8:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80186ac:	429a      	cmp	r2, r3
 80186ae:	d109      	bne.n	80186c4 <start_pass_huff_decoder+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 80186b0:	687b      	ldr	r3, [r7, #4]
 80186b2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80186b6:	2b0d      	cmp	r3, #13
 80186b8:	dd26      	ble.n	8018708 <start_pass_huff_decoder+0xd0>
       * but the spec doesn't say so, and we try to be liberal about what we
       * accept.  Note: large Al values could result in out-of-range DC
       * coefficients during early scans, leading to bizarre displays due to
       * overflows in the IDCT math.  But we won't crash.
       */
      bad:
 80186ba:	e004      	b.n	80186c6 <start_pass_huff_decoder+0x8e>
	goto bad;
 80186bc:	bf00      	nop
 80186be:	e002      	b.n	80186c6 <start_pass_huff_decoder+0x8e>
	goto bad;
 80186c0:	bf00      	nop
 80186c2:	e000      	b.n	80186c6 <start_pass_huff_decoder+0x8e>
	goto bad;
 80186c4:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 80186c6:	687b      	ldr	r3, [r7, #4]
 80186c8:	681b      	ldr	r3, [r3, #0]
 80186ca:	2211      	movs	r2, #17
 80186cc:	615a      	str	r2, [r3, #20]
 80186ce:	687b      	ldr	r3, [r7, #4]
 80186d0:	681b      	ldr	r3, [r3, #0]
 80186d2:	687a      	ldr	r2, [r7, #4]
 80186d4:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 80186d8:	619a      	str	r2, [r3, #24]
 80186da:	687b      	ldr	r3, [r7, #4]
 80186dc:	681b      	ldr	r3, [r3, #0]
 80186de:	687a      	ldr	r2, [r7, #4]
 80186e0:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 80186e4:	61da      	str	r2, [r3, #28]
 80186e6:	687b      	ldr	r3, [r7, #4]
 80186e8:	681b      	ldr	r3, [r3, #0]
 80186ea:	687a      	ldr	r2, [r7, #4]
 80186ec:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 80186f0:	621a      	str	r2, [r3, #32]
 80186f2:	687b      	ldr	r3, [r7, #4]
 80186f4:	681b      	ldr	r3, [r3, #0]
 80186f6:	687a      	ldr	r2, [r7, #4]
 80186f8:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 80186fc:	625a      	str	r2, [r3, #36]	@ 0x24
 80186fe:	687b      	ldr	r3, [r7, #4]
 8018700:	681b      	ldr	r3, [r3, #0]
 8018702:	681b      	ldr	r3, [r3, #0]
 8018704:	6878      	ldr	r0, [r7, #4]
 8018706:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8018708:	2300      	movs	r3, #0
 801870a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801870c:	e064      	b.n	80187d8 <start_pass_huff_decoder+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 801870e:	687a      	ldr	r2, [r7, #4]
 8018710:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018712:	3354      	adds	r3, #84	@ 0x54
 8018714:	009b      	lsls	r3, r3, #2
 8018716:	4413      	add	r3, r2
 8018718:	685b      	ldr	r3, [r3, #4]
 801871a:	685b      	ldr	r3, [r3, #4]
 801871c:	613b      	str	r3, [r7, #16]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 801871e:	687b      	ldr	r3, [r7, #4]
 8018720:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8018724:	693b      	ldr	r3, [r7, #16]
 8018726:	021b      	lsls	r3, r3, #8
 8018728:	4413      	add	r3, r2
 801872a:	60fb      	str	r3, [r7, #12]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 801872c:	687b      	ldr	r3, [r7, #4]
 801872e:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8018732:	2b00      	cmp	r3, #0
 8018734:	d016      	beq.n	8018764 <start_pass_huff_decoder+0x12c>
 8018736:	68fb      	ldr	r3, [r7, #12]
 8018738:	681b      	ldr	r3, [r3, #0]
 801873a:	2b00      	cmp	r3, #0
 801873c:	da12      	bge.n	8018764 <start_pass_huff_decoder+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 801873e:	687b      	ldr	r3, [r7, #4]
 8018740:	681b      	ldr	r3, [r3, #0]
 8018742:	2276      	movs	r2, #118	@ 0x76
 8018744:	615a      	str	r2, [r3, #20]
 8018746:	687b      	ldr	r3, [r7, #4]
 8018748:	681b      	ldr	r3, [r3, #0]
 801874a:	693a      	ldr	r2, [r7, #16]
 801874c:	619a      	str	r2, [r3, #24]
 801874e:	687b      	ldr	r3, [r7, #4]
 8018750:	681b      	ldr	r3, [r3, #0]
 8018752:	2200      	movs	r2, #0
 8018754:	61da      	str	r2, [r3, #28]
 8018756:	687b      	ldr	r3, [r7, #4]
 8018758:	681b      	ldr	r3, [r3, #0]
 801875a:	685b      	ldr	r3, [r3, #4]
 801875c:	f04f 31ff 	mov.w	r1, #4294967295
 8018760:	6878      	ldr	r0, [r7, #4]
 8018762:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 8018764:	687b      	ldr	r3, [r7, #4]
 8018766:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801876a:	623b      	str	r3, [r7, #32]
 801876c:	e02b      	b.n	80187c6 <start_pass_huff_decoder+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 801876e:	6a3b      	ldr	r3, [r7, #32]
 8018770:	009b      	lsls	r3, r3, #2
 8018772:	68fa      	ldr	r2, [r7, #12]
 8018774:	4413      	add	r3, r2
 8018776:	681b      	ldr	r3, [r3, #0]
 8018778:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801877c:	60bb      	str	r3, [r7, #8]
	if (cinfo->Ah != expected)
 801877e:	687b      	ldr	r3, [r7, #4]
 8018780:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8018784:	68ba      	ldr	r2, [r7, #8]
 8018786:	429a      	cmp	r2, r3
 8018788:	d012      	beq.n	80187b0 <start_pass_huff_decoder+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 801878a:	687b      	ldr	r3, [r7, #4]
 801878c:	681b      	ldr	r3, [r3, #0]
 801878e:	2276      	movs	r2, #118	@ 0x76
 8018790:	615a      	str	r2, [r3, #20]
 8018792:	687b      	ldr	r3, [r7, #4]
 8018794:	681b      	ldr	r3, [r3, #0]
 8018796:	693a      	ldr	r2, [r7, #16]
 8018798:	619a      	str	r2, [r3, #24]
 801879a:	687b      	ldr	r3, [r7, #4]
 801879c:	681b      	ldr	r3, [r3, #0]
 801879e:	6a3a      	ldr	r2, [r7, #32]
 80187a0:	61da      	str	r2, [r3, #28]
 80187a2:	687b      	ldr	r3, [r7, #4]
 80187a4:	681b      	ldr	r3, [r3, #0]
 80187a6:	685b      	ldr	r3, [r3, #4]
 80187a8:	f04f 31ff 	mov.w	r1, #4294967295
 80187ac:	6878      	ldr	r0, [r7, #4]
 80187ae:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 80187b0:	6a3b      	ldr	r3, [r7, #32]
 80187b2:	009b      	lsls	r3, r3, #2
 80187b4:	68fa      	ldr	r2, [r7, #12]
 80187b6:	4413      	add	r3, r2
 80187b8:	687a      	ldr	r2, [r7, #4]
 80187ba:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 80187be:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80187c0:	6a3b      	ldr	r3, [r7, #32]
 80187c2:	3301      	adds	r3, #1
 80187c4:	623b      	str	r3, [r7, #32]
 80187c6:	687b      	ldr	r3, [r7, #4]
 80187c8:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80187cc:	6a3a      	ldr	r2, [r7, #32]
 80187ce:	429a      	cmp	r2, r3
 80187d0:	ddcd      	ble.n	801876e <start_pass_huff_decoder+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80187d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80187d4:	3301      	adds	r3, #1
 80187d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80187d8:	687b      	ldr	r3, [r7, #4]
 80187da:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80187de:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80187e0:	429a      	cmp	r2, r3
 80187e2:	db94      	blt.n	801870e <start_pass_huff_decoder+0xd6>
      }
    }

    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 80187e4:	687b      	ldr	r3, [r7, #4]
 80187e6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80187ea:	2b00      	cmp	r3, #0
 80187ec:	d10c      	bne.n	8018808 <start_pass_huff_decoder+0x1d0>
      if (cinfo->Ss == 0)
 80187ee:	687b      	ldr	r3, [r7, #4]
 80187f0:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80187f4:	2b00      	cmp	r3, #0
 80187f6:	d103      	bne.n	8018800 <start_pass_huff_decoder+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 80187f8:	69fb      	ldr	r3, [r7, #28]
 80187fa:	4a6a      	ldr	r2, [pc, #424]	@ (80189a4 <start_pass_huff_decoder+0x36c>)
 80187fc:	605a      	str	r2, [r3, #4]
 80187fe:	e00f      	b.n	8018820 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 8018800:	69fb      	ldr	r3, [r7, #28]
 8018802:	4a69      	ldr	r2, [pc, #420]	@ (80189a8 <start_pass_huff_decoder+0x370>)
 8018804:	605a      	str	r2, [r3, #4]
 8018806:	e00b      	b.n	8018820 <start_pass_huff_decoder+0x1e8>
    } else {
      if (cinfo->Ss == 0)
 8018808:	687b      	ldr	r3, [r7, #4]
 801880a:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801880e:	2b00      	cmp	r3, #0
 8018810:	d103      	bne.n	801881a <start_pass_huff_decoder+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 8018812:	69fb      	ldr	r3, [r7, #28]
 8018814:	4a65      	ldr	r2, [pc, #404]	@ (80189ac <start_pass_huff_decoder+0x374>)
 8018816:	605a      	str	r2, [r3, #4]
 8018818:	e002      	b.n	8018820 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 801881a:	69fb      	ldr	r3, [r7, #28]
 801881c:	4a64      	ldr	r2, [pc, #400]	@ (80189b0 <start_pass_huff_decoder+0x378>)
 801881e:	605a      	str	r2, [r3, #4]
    }

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8018820:	2300      	movs	r3, #0
 8018822:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018824:	e03f      	b.n	80188a6 <start_pass_huff_decoder+0x26e>
      compptr = cinfo->cur_comp_info[ci];
 8018826:	687a      	ldr	r2, [r7, #4]
 8018828:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801882a:	3354      	adds	r3, #84	@ 0x54
 801882c:	009b      	lsls	r3, r3, #2
 801882e:	4413      	add	r3, r2
 8018830:	685b      	ldr	r3, [r3, #4]
 8018832:	61bb      	str	r3, [r7, #24]
      /* Make sure requested tables are present, and compute derived tables.
       * We may build same derived table more than once, but it's not expensive.
       */
      if (cinfo->Ss == 0) {
 8018834:	687b      	ldr	r3, [r7, #4]
 8018836:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 801883a:	2b00      	cmp	r3, #0
 801883c:	d113      	bne.n	8018866 <start_pass_huff_decoder+0x22e>
	if (cinfo->Ah == 0) {	/* DC refinement needs no table */
 801883e:	687b      	ldr	r3, [r7, #4]
 8018840:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8018844:	2b00      	cmp	r3, #0
 8018846:	d124      	bne.n	8018892 <start_pass_huff_decoder+0x25a>
	  tbl = compptr->dc_tbl_no;
 8018848:	69bb      	ldr	r3, [r7, #24]
 801884a:	695b      	ldr	r3, [r3, #20]
 801884c:	617b      	str	r3, [r7, #20]
	  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 801884e:	697b      	ldr	r3, [r7, #20]
 8018850:	330a      	adds	r3, #10
 8018852:	009b      	lsls	r3, r3, #2
 8018854:	69fa      	ldr	r2, [r7, #28]
 8018856:	4413      	add	r3, r2
 8018858:	3304      	adds	r3, #4
 801885a:	697a      	ldr	r2, [r7, #20]
 801885c:	2101      	movs	r1, #1
 801885e:	6878      	ldr	r0, [r7, #4]
 8018860:	f7fe fa36 	bl	8016cd0 <jpeg_make_d_derived_tbl>
 8018864:	e015      	b.n	8018892 <start_pass_huff_decoder+0x25a>
				  & entropy->derived_tbls[tbl]);
	}
      } else {
	tbl = compptr->ac_tbl_no;
 8018866:	69bb      	ldr	r3, [r7, #24]
 8018868:	699b      	ldr	r3, [r3, #24]
 801886a:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 801886c:	697b      	ldr	r3, [r7, #20]
 801886e:	330a      	adds	r3, #10
 8018870:	009b      	lsls	r3, r3, #2
 8018872:	69fa      	ldr	r2, [r7, #28]
 8018874:	4413      	add	r3, r2
 8018876:	3304      	adds	r3, #4
 8018878:	697a      	ldr	r2, [r7, #20]
 801887a:	2100      	movs	r1, #0
 801887c:	6878      	ldr	r0, [r7, #4]
 801887e:	f7fe fa27 	bl	8016cd0 <jpeg_make_d_derived_tbl>
				& entropy->derived_tbls[tbl]);
	/* remember the single active table */
	entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
 8018882:	69fa      	ldr	r2, [r7, #28]
 8018884:	697b      	ldr	r3, [r7, #20]
 8018886:	330a      	adds	r3, #10
 8018888:	009b      	lsls	r3, r3, #2
 801888a:	4413      	add	r3, r2
 801888c:	685a      	ldr	r2, [r3, #4]
 801888e:	69fb      	ldr	r3, [r7, #28]
 8018890:	63da      	str	r2, [r3, #60]	@ 0x3c
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 8018892:	69fa      	ldr	r2, [r7, #28]
 8018894:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018896:	3304      	adds	r3, #4
 8018898:	009b      	lsls	r3, r3, #2
 801889a:	4413      	add	r3, r2
 801889c:	2200      	movs	r2, #0
 801889e:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80188a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80188a2:	3301      	adds	r3, #1
 80188a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80188a6:	687b      	ldr	r3, [r7, #4]
 80188a8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80188ac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80188ae:	429a      	cmp	r2, r3
 80188b0:	dbb9      	blt.n	8018826 <start_pass_huff_decoder+0x1ee>
    }

    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
 80188b2:	69fb      	ldr	r3, [r7, #28]
 80188b4:	2200      	movs	r2, #0
 80188b6:	611a      	str	r2, [r3, #16]
 80188b8:	e21a      	b.n	8018cf0 <start_pass_huff_decoder+0x6b8>
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning because
     * there are some baseline files out there with all zeroes in these bytes.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 80188ba:	687b      	ldr	r3, [r7, #4]
 80188bc:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 80188c0:	2b00      	cmp	r3, #0
 80188c2:	d11b      	bne.n	80188fc <start_pass_huff_decoder+0x2c4>
 80188c4:	687b      	ldr	r3, [r7, #4]
 80188c6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 80188ca:	2b00      	cmp	r3, #0
 80188cc:	d116      	bne.n	80188fc <start_pass_huff_decoder+0x2c4>
 80188ce:	687b      	ldr	r3, [r7, #4]
 80188d0:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 80188d4:	2b00      	cmp	r3, #0
 80188d6:	d111      	bne.n	80188fc <start_pass_huff_decoder+0x2c4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 80188d8:	687b      	ldr	r3, [r7, #4]
 80188da:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 80188de:	2b00      	cmp	r3, #0
 80188e0:	d104      	bne.n	80188ec <start_pass_huff_decoder+0x2b4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 80188e2:	687b      	ldr	r3, [r7, #4]
 80188e4:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80188e8:	2b3f      	cmp	r3, #63	@ 0x3f
 80188ea:	dc12      	bgt.n	8018912 <start_pass_huff_decoder+0x2da>
	cinfo->Se != cinfo->lim_Se))
 80188ec:	687b      	ldr	r3, [r7, #4]
 80188ee:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80188f2:	687b      	ldr	r3, [r7, #4]
 80188f4:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 80188f8:	429a      	cmp	r2, r3
 80188fa:	d00a      	beq.n	8018912 <start_pass_huff_decoder+0x2da>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 80188fc:	687b      	ldr	r3, [r7, #4]
 80188fe:	681b      	ldr	r3, [r3, #0]
 8018900:	227d      	movs	r2, #125	@ 0x7d
 8018902:	615a      	str	r2, [r3, #20]
 8018904:	687b      	ldr	r3, [r7, #4]
 8018906:	681b      	ldr	r3, [r3, #0]
 8018908:	685b      	ldr	r3, [r3, #4]
 801890a:	f04f 31ff 	mov.w	r1, #4294967295
 801890e:	6878      	ldr	r0, [r7, #4]
 8018910:	4798      	blx	r3
     * This is not necessary, but it appears that this version is slightly
     * more performant in the given implementation.
     * With an improved implementation we would prefer a single optimized
     * function.
     */
    if (cinfo->lim_Se != DCTSIZE2-1)
 8018912:	687b      	ldr	r3, [r7, #4]
 8018914:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8018918:	2b3f      	cmp	r3, #63	@ 0x3f
 801891a:	d003      	beq.n	8018924 <start_pass_huff_decoder+0x2ec>
      entropy->pub.decode_mcu = decode_mcu_sub;
 801891c:	69fb      	ldr	r3, [r7, #28]
 801891e:	4a25      	ldr	r2, [pc, #148]	@ (80189b4 <start_pass_huff_decoder+0x37c>)
 8018920:	605a      	str	r2, [r3, #4]
 8018922:	e002      	b.n	801892a <start_pass_huff_decoder+0x2f2>
    else
      entropy->pub.decode_mcu = decode_mcu;
 8018924:	69fb      	ldr	r3, [r7, #28]
 8018926:	4a24      	ldr	r2, [pc, #144]	@ (80189b8 <start_pass_huff_decoder+0x380>)
 8018928:	605a      	str	r2, [r3, #4]

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801892a:	2300      	movs	r3, #0
 801892c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801892e:	e02f      	b.n	8018990 <start_pass_huff_decoder+0x358>
      compptr = cinfo->cur_comp_info[ci];
 8018930:	687a      	ldr	r2, [r7, #4]
 8018932:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018934:	3354      	adds	r3, #84	@ 0x54
 8018936:	009b      	lsls	r3, r3, #2
 8018938:	4413      	add	r3, r2
 801893a:	685b      	ldr	r3, [r3, #4]
 801893c:	61bb      	str	r3, [r7, #24]
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      tbl = compptr->dc_tbl_no;
 801893e:	69bb      	ldr	r3, [r7, #24]
 8018940:	695b      	ldr	r3, [r3, #20]
 8018942:	617b      	str	r3, [r7, #20]
      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 8018944:	697b      	ldr	r3, [r7, #20]
 8018946:	3310      	adds	r3, #16
 8018948:	009b      	lsls	r3, r3, #2
 801894a:	69fa      	ldr	r2, [r7, #28]
 801894c:	4413      	add	r3, r2
 801894e:	697a      	ldr	r2, [r7, #20]
 8018950:	2101      	movs	r1, #1
 8018952:	6878      	ldr	r0, [r7, #4]
 8018954:	f7fe f9bc 	bl	8016cd0 <jpeg_make_d_derived_tbl>
			      & entropy->dc_derived_tbls[tbl]);
      if (cinfo->lim_Se) {	/* AC needs no table when not present */
 8018958:	687b      	ldr	r3, [r7, #4]
 801895a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801895e:	2b00      	cmp	r3, #0
 8018960:	d00c      	beq.n	801897c <start_pass_huff_decoder+0x344>
	tbl = compptr->ac_tbl_no;
 8018962:	69bb      	ldr	r3, [r7, #24]
 8018964:	699b      	ldr	r3, [r3, #24]
 8018966:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 8018968:	697b      	ldr	r3, [r7, #20]
 801896a:	3314      	adds	r3, #20
 801896c:	009b      	lsls	r3, r3, #2
 801896e:	69fa      	ldr	r2, [r7, #28]
 8018970:	4413      	add	r3, r2
 8018972:	697a      	ldr	r2, [r7, #20]
 8018974:	2100      	movs	r1, #0
 8018976:	6878      	ldr	r0, [r7, #4]
 8018978:	f7fe f9aa 	bl	8016cd0 <jpeg_make_d_derived_tbl>
				& entropy->ac_derived_tbls[tbl]);
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 801897c:	69fa      	ldr	r2, [r7, #28]
 801897e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018980:	3304      	adds	r3, #4
 8018982:	009b      	lsls	r3, r3, #2
 8018984:	4413      	add	r3, r2
 8018986:	2200      	movs	r2, #0
 8018988:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801898a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801898c:	3301      	adds	r3, #1
 801898e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018990:	687b      	ldr	r3, [r7, #4]
 8018992:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8018996:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018998:	429a      	cmp	r2, r3
 801899a:	dbc9      	blt.n	8018930 <start_pass_huff_decoder+0x2f8>
    }

    /* Precalculate decoding info for each block in an MCU of this scan */
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801899c:	2300      	movs	r3, #0
 801899e:	62bb      	str	r3, [r7, #40]	@ 0x28
 80189a0:	e19f      	b.n	8018ce2 <start_pass_huff_decoder+0x6aa>
 80189a2:	bf00      	nop
 80189a4:	08017445 	.word	0x08017445
 80189a8:	0801763d 	.word	0x0801763d
 80189ac:	0801786d 	.word	0x0801786d
 80189b0:	0801795d 	.word	0x0801795d
 80189b4:	08017e71 	.word	0x08017e71
 80189b8:	0801825d 	.word	0x0801825d
      ci = cinfo->MCU_membership[blkn];
 80189bc:	687b      	ldr	r3, [r7, #4]
 80189be:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80189c0:	325c      	adds	r2, #92	@ 0x5c
 80189c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80189c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
      compptr = cinfo->cur_comp_info[ci];
 80189c8:	687a      	ldr	r2, [r7, #4]
 80189ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80189cc:	3354      	adds	r3, #84	@ 0x54
 80189ce:	009b      	lsls	r3, r3, #2
 80189d0:	4413      	add	r3, r2
 80189d2:	685b      	ldr	r3, [r3, #4]
 80189d4:	61bb      	str	r3, [r7, #24]
      /* Precalculate which table to use for each block */
      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
 80189d6:	69bb      	ldr	r3, [r7, #24]
 80189d8:	695a      	ldr	r2, [r3, #20]
 80189da:	69fb      	ldr	r3, [r7, #28]
 80189dc:	3210      	adds	r2, #16
 80189de:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80189e2:	69fb      	ldr	r3, [r7, #28]
 80189e4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80189e6:	3218      	adds	r2, #24
 80189e8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
 80189ec:	69bb      	ldr	r3, [r7, #24]
 80189ee:	699a      	ldr	r2, [r3, #24]
 80189f0:	69fb      	ldr	r3, [r7, #28]
 80189f2:	3214      	adds	r2, #20
 80189f4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80189f8:	69fb      	ldr	r3, [r7, #28]
 80189fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80189fc:	3222      	adds	r2, #34	@ 0x22
 80189fe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      /* Decide whether we really care about the coefficient values */
      if (compptr->component_needed) {
 8018a02:	69bb      	ldr	r3, [r7, #24]
 8018a04:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8018a06:	2b00      	cmp	r3, #0
 8018a08:	f000 8162 	beq.w	8018cd0 <start_pass_huff_decoder+0x698>
	ci = compptr->DCT_v_scaled_size;
 8018a0c:	69bb      	ldr	r3, [r7, #24]
 8018a0e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018a10:	62fb      	str	r3, [r7, #44]	@ 0x2c
	i = compptr->DCT_h_scaled_size;
 8018a12:	69bb      	ldr	r3, [r7, #24]
 8018a14:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018a16:	627b      	str	r3, [r7, #36]	@ 0x24
	switch (cinfo->lim_Se) {
 8018a18:	687b      	ldr	r3, [r7, #4]
 8018a1a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8018a1e:	2b30      	cmp	r3, #48	@ 0x30
 8018a20:	f200 8136 	bhi.w	8018c90 <start_pass_huff_decoder+0x658>
 8018a24:	a201      	add	r2, pc, #4	@ (adr r2, 8018a2c <start_pass_huff_decoder+0x3f4>)
 8018a26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018a2a:	bf00      	nop
 8018a2c:	08018af1 	.word	0x08018af1
 8018a30:	08018c91 	.word	0x08018c91
 8018a34:	08018c91 	.word	0x08018c91
 8018a38:	08018aff 	.word	0x08018aff
 8018a3c:	08018c91 	.word	0x08018c91
 8018a40:	08018c91 	.word	0x08018c91
 8018a44:	08018c91 	.word	0x08018c91
 8018a48:	08018c91 	.word	0x08018c91
 8018a4c:	08018b3f 	.word	0x08018b3f
 8018a50:	08018c91 	.word	0x08018c91
 8018a54:	08018c91 	.word	0x08018c91
 8018a58:	08018c91 	.word	0x08018c91
 8018a5c:	08018c91 	.word	0x08018c91
 8018a60:	08018c91 	.word	0x08018c91
 8018a64:	08018c91 	.word	0x08018c91
 8018a68:	08018b83 	.word	0x08018b83
 8018a6c:	08018c91 	.word	0x08018c91
 8018a70:	08018c91 	.word	0x08018c91
 8018a74:	08018c91 	.word	0x08018c91
 8018a78:	08018c91 	.word	0x08018c91
 8018a7c:	08018c91 	.word	0x08018c91
 8018a80:	08018c91 	.word	0x08018c91
 8018a84:	08018c91 	.word	0x08018c91
 8018a88:	08018c91 	.word	0x08018c91
 8018a8c:	08018bc3 	.word	0x08018bc3
 8018a90:	08018c91 	.word	0x08018c91
 8018a94:	08018c91 	.word	0x08018c91
 8018a98:	08018c91 	.word	0x08018c91
 8018a9c:	08018c91 	.word	0x08018c91
 8018aa0:	08018c91 	.word	0x08018c91
 8018aa4:	08018c91 	.word	0x08018c91
 8018aa8:	08018c91 	.word	0x08018c91
 8018aac:	08018c91 	.word	0x08018c91
 8018ab0:	08018c91 	.word	0x08018c91
 8018ab4:	08018c91 	.word	0x08018c91
 8018ab8:	08018c07 	.word	0x08018c07
 8018abc:	08018c91 	.word	0x08018c91
 8018ac0:	08018c91 	.word	0x08018c91
 8018ac4:	08018c91 	.word	0x08018c91
 8018ac8:	08018c91 	.word	0x08018c91
 8018acc:	08018c91 	.word	0x08018c91
 8018ad0:	08018c91 	.word	0x08018c91
 8018ad4:	08018c91 	.word	0x08018c91
 8018ad8:	08018c91 	.word	0x08018c91
 8018adc:	08018c91 	.word	0x08018c91
 8018ae0:	08018c91 	.word	0x08018c91
 8018ae4:	08018c91 	.word	0x08018c91
 8018ae8:	08018c91 	.word	0x08018c91
 8018aec:	08018c4d 	.word	0x08018c4d
	case (1*1-1):
	  entropy->coef_limit[blkn] = 1;
 8018af0:	69fb      	ldr	r3, [r7, #28]
 8018af2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018af4:	322c      	adds	r2, #44	@ 0x2c
 8018af6:	2101      	movs	r1, #1
 8018af8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018afc:	e0ee      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (2*2-1):
	  if (ci <= 0 || ci > 2) ci = 2;
 8018afe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b00:	2b00      	cmp	r3, #0
 8018b02:	dd02      	ble.n	8018b0a <start_pass_huff_decoder+0x4d2>
 8018b04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b06:	2b02      	cmp	r3, #2
 8018b08:	dd01      	ble.n	8018b0e <start_pass_huff_decoder+0x4d6>
 8018b0a:	2302      	movs	r3, #2
 8018b0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 2) i = 2;
 8018b0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b10:	2b00      	cmp	r3, #0
 8018b12:	dd02      	ble.n	8018b1a <start_pass_huff_decoder+0x4e2>
 8018b14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b16:	2b02      	cmp	r3, #2
 8018b18:	dd01      	ble.n	8018b1e <start_pass_huff_decoder+0x4e6>
 8018b1a:	2302      	movs	r3, #2
 8018b1c:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
 8018b1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b20:	1e5a      	subs	r2, r3, #1
 8018b22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b24:	3b01      	subs	r3, #1
 8018b26:	497b      	ldr	r1, [pc, #492]	@ (8018d14 <start_pass_huff_decoder+0x6dc>)
 8018b28:	0052      	lsls	r2, r2, #1
 8018b2a:	4413      	add	r3, r2
 8018b2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8018b30:	1c59      	adds	r1, r3, #1
 8018b32:	69fb      	ldr	r3, [r7, #28]
 8018b34:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018b36:	322c      	adds	r2, #44	@ 0x2c
 8018b38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018b3c:	e0ce      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (3*3-1):
	  if (ci <= 0 || ci > 3) ci = 3;
 8018b3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b40:	2b00      	cmp	r3, #0
 8018b42:	dd02      	ble.n	8018b4a <start_pass_huff_decoder+0x512>
 8018b44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b46:	2b03      	cmp	r3, #3
 8018b48:	dd01      	ble.n	8018b4e <start_pass_huff_decoder+0x516>
 8018b4a:	2303      	movs	r3, #3
 8018b4c:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 3) i = 3;
 8018b4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b50:	2b00      	cmp	r3, #0
 8018b52:	dd02      	ble.n	8018b5a <start_pass_huff_decoder+0x522>
 8018b54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b56:	2b03      	cmp	r3, #3
 8018b58:	dd01      	ble.n	8018b5e <start_pass_huff_decoder+0x526>
 8018b5a:	2303      	movs	r3, #3
 8018b5c:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
 8018b5e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b60:	1e5a      	subs	r2, r3, #1
 8018b62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b64:	1e59      	subs	r1, r3, #1
 8018b66:	486c      	ldr	r0, [pc, #432]	@ (8018d18 <start_pass_huff_decoder+0x6e0>)
 8018b68:	4613      	mov	r3, r2
 8018b6a:	005b      	lsls	r3, r3, #1
 8018b6c:	4413      	add	r3, r2
 8018b6e:	440b      	add	r3, r1
 8018b70:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8018b74:	1c59      	adds	r1, r3, #1
 8018b76:	69fb      	ldr	r3, [r7, #28]
 8018b78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018b7a:	322c      	adds	r2, #44	@ 0x2c
 8018b7c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018b80:	e0ac      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (4*4-1):
	  if (ci <= 0 || ci > 4) ci = 4;
 8018b82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b84:	2b00      	cmp	r3, #0
 8018b86:	dd02      	ble.n	8018b8e <start_pass_huff_decoder+0x556>
 8018b88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b8a:	2b04      	cmp	r3, #4
 8018b8c:	dd01      	ble.n	8018b92 <start_pass_huff_decoder+0x55a>
 8018b8e:	2304      	movs	r3, #4
 8018b90:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 4) i = 4;
 8018b92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b94:	2b00      	cmp	r3, #0
 8018b96:	dd02      	ble.n	8018b9e <start_pass_huff_decoder+0x566>
 8018b98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b9a:	2b04      	cmp	r3, #4
 8018b9c:	dd01      	ble.n	8018ba2 <start_pass_huff_decoder+0x56a>
 8018b9e:	2304      	movs	r3, #4
 8018ba0:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];
 8018ba2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018ba4:	1e5a      	subs	r2, r3, #1
 8018ba6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ba8:	3b01      	subs	r3, #1
 8018baa:	495c      	ldr	r1, [pc, #368]	@ (8018d1c <start_pass_huff_decoder+0x6e4>)
 8018bac:	0092      	lsls	r2, r2, #2
 8018bae:	4413      	add	r3, r2
 8018bb0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8018bb4:	1c59      	adds	r1, r3, #1
 8018bb6:	69fb      	ldr	r3, [r7, #28]
 8018bb8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018bba:	322c      	adds	r2, #44	@ 0x2c
 8018bbc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018bc0:	e08c      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (5*5-1):
	  if (ci <= 0 || ci > 5) ci = 5;
 8018bc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018bc4:	2b00      	cmp	r3, #0
 8018bc6:	dd02      	ble.n	8018bce <start_pass_huff_decoder+0x596>
 8018bc8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018bca:	2b05      	cmp	r3, #5
 8018bcc:	dd01      	ble.n	8018bd2 <start_pass_huff_decoder+0x59a>
 8018bce:	2305      	movs	r3, #5
 8018bd0:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 5) i = 5;
 8018bd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bd4:	2b00      	cmp	r3, #0
 8018bd6:	dd02      	ble.n	8018bde <start_pass_huff_decoder+0x5a6>
 8018bd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bda:	2b05      	cmp	r3, #5
 8018bdc:	dd01      	ble.n	8018be2 <start_pass_huff_decoder+0x5aa>
 8018bde:	2305      	movs	r3, #5
 8018be0:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
 8018be2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018be4:	1e5a      	subs	r2, r3, #1
 8018be6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018be8:	1e59      	subs	r1, r3, #1
 8018bea:	484d      	ldr	r0, [pc, #308]	@ (8018d20 <start_pass_huff_decoder+0x6e8>)
 8018bec:	4613      	mov	r3, r2
 8018bee:	009b      	lsls	r3, r3, #2
 8018bf0:	4413      	add	r3, r2
 8018bf2:	440b      	add	r3, r1
 8018bf4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8018bf8:	1c59      	adds	r1, r3, #1
 8018bfa:	69fb      	ldr	r3, [r7, #28]
 8018bfc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018bfe:	322c      	adds	r2, #44	@ 0x2c
 8018c00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018c04:	e06a      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (6*6-1):
	  if (ci <= 0 || ci > 6) ci = 6;
 8018c06:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c08:	2b00      	cmp	r3, #0
 8018c0a:	dd02      	ble.n	8018c12 <start_pass_huff_decoder+0x5da>
 8018c0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c0e:	2b06      	cmp	r3, #6
 8018c10:	dd01      	ble.n	8018c16 <start_pass_huff_decoder+0x5de>
 8018c12:	2306      	movs	r3, #6
 8018c14:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 6) i = 6;
 8018c16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c18:	2b00      	cmp	r3, #0
 8018c1a:	dd02      	ble.n	8018c22 <start_pass_huff_decoder+0x5ea>
 8018c1c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c1e:	2b06      	cmp	r3, #6
 8018c20:	dd01      	ble.n	8018c26 <start_pass_huff_decoder+0x5ee>
 8018c22:	2306      	movs	r3, #6
 8018c24:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
 8018c26:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c28:	1e5a      	subs	r2, r3, #1
 8018c2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c2c:	1e59      	subs	r1, r3, #1
 8018c2e:	483d      	ldr	r0, [pc, #244]	@ (8018d24 <start_pass_huff_decoder+0x6ec>)
 8018c30:	4613      	mov	r3, r2
 8018c32:	005b      	lsls	r3, r3, #1
 8018c34:	4413      	add	r3, r2
 8018c36:	005b      	lsls	r3, r3, #1
 8018c38:	440b      	add	r3, r1
 8018c3a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8018c3e:	1c59      	adds	r1, r3, #1
 8018c40:	69fb      	ldr	r3, [r7, #28]
 8018c42:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c44:	322c      	adds	r2, #44	@ 0x2c
 8018c46:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018c4a:	e047      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	case (7*7-1):
	  if (ci <= 0 || ci > 7) ci = 7;
 8018c4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c4e:	2b00      	cmp	r3, #0
 8018c50:	dd02      	ble.n	8018c58 <start_pass_huff_decoder+0x620>
 8018c52:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c54:	2b07      	cmp	r3, #7
 8018c56:	dd01      	ble.n	8018c5c <start_pass_huff_decoder+0x624>
 8018c58:	2307      	movs	r3, #7
 8018c5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 7) i = 7;
 8018c5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c5e:	2b00      	cmp	r3, #0
 8018c60:	dd02      	ble.n	8018c68 <start_pass_huff_decoder+0x630>
 8018c62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c64:	2b07      	cmp	r3, #7
 8018c66:	dd01      	ble.n	8018c6c <start_pass_huff_decoder+0x634>
 8018c68:	2307      	movs	r3, #7
 8018c6a:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
 8018c6c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c6e:	1e5a      	subs	r2, r3, #1
 8018c70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c72:	1e59      	subs	r1, r3, #1
 8018c74:	482c      	ldr	r0, [pc, #176]	@ (8018d28 <start_pass_huff_decoder+0x6f0>)
 8018c76:	4613      	mov	r3, r2
 8018c78:	00db      	lsls	r3, r3, #3
 8018c7a:	1a9b      	subs	r3, r3, r2
 8018c7c:	440b      	add	r3, r1
 8018c7e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8018c82:	1c59      	adds	r1, r3, #1
 8018c84:	69fb      	ldr	r3, [r7, #28]
 8018c86:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c88:	322c      	adds	r2, #44	@ 0x2c
 8018c8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018c8e:	e025      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	default:
	  if (ci <= 0 || ci > 8) ci = 8;
 8018c90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c92:	2b00      	cmp	r3, #0
 8018c94:	dd02      	ble.n	8018c9c <start_pass_huff_decoder+0x664>
 8018c96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018c98:	2b08      	cmp	r3, #8
 8018c9a:	dd01      	ble.n	8018ca0 <start_pass_huff_decoder+0x668>
 8018c9c:	2308      	movs	r3, #8
 8018c9e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	  if (i <= 0 || i > 8) i = 8;
 8018ca0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ca2:	2b00      	cmp	r3, #0
 8018ca4:	dd02      	ble.n	8018cac <start_pass_huff_decoder+0x674>
 8018ca6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ca8:	2b08      	cmp	r3, #8
 8018caa:	dd01      	ble.n	8018cb0 <start_pass_huff_decoder+0x678>
 8018cac:	2308      	movs	r3, #8
 8018cae:	627b      	str	r3, [r7, #36]	@ 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
 8018cb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018cb2:	1e5a      	subs	r2, r3, #1
 8018cb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018cb6:	3b01      	subs	r3, #1
 8018cb8:	491c      	ldr	r1, [pc, #112]	@ (8018d2c <start_pass_huff_decoder+0x6f4>)
 8018cba:	00d2      	lsls	r2, r2, #3
 8018cbc:	4413      	add	r3, r2
 8018cbe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8018cc2:	1c59      	adds	r1, r3, #1
 8018cc4:	69fb      	ldr	r3, [r7, #28]
 8018cc6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018cc8:	322c      	adds	r2, #44	@ 0x2c
 8018cca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8018cce:	e005      	b.n	8018cdc <start_pass_huff_decoder+0x6a4>
	}
      } else {
	entropy->coef_limit[blkn] = 0;
 8018cd0:	69fb      	ldr	r3, [r7, #28]
 8018cd2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018cd4:	322c      	adds	r2, #44	@ 0x2c
 8018cd6:	2100      	movs	r1, #0
 8018cd8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8018cdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018cde:	3301      	adds	r3, #1
 8018ce0:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018ce2:	687b      	ldr	r3, [r7, #4]
 8018ce4:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8018ce8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018cea:	429a      	cmp	r2, r3
 8018cec:	f6ff ae66 	blt.w	80189bc <start_pass_huff_decoder+0x384>
      }
    }
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
 8018cf0:	69fb      	ldr	r3, [r7, #28]
 8018cf2:	2200      	movs	r2, #0
 8018cf4:	60da      	str	r2, [r3, #12]
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
 8018cf6:	69fb      	ldr	r3, [r7, #28]
 8018cf8:	2200      	movs	r2, #0
 8018cfa:	609a      	str	r2, [r3, #8]
  entropy->insufficient_data = FALSE;
 8018cfc:	69fb      	ldr	r3, [r7, #28]
 8018cfe:	2200      	movs	r2, #0
 8018d00:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8018d02:	687b      	ldr	r3, [r7, #4]
 8018d04:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 8018d08:	69fb      	ldr	r3, [r7, #28]
 8018d0a:	629a      	str	r2, [r3, #40]	@ 0x28
}
 8018d0c:	bf00      	nop
 8018d0e:	3730      	adds	r7, #48	@ 0x30
 8018d10:	46bd      	mov	sp, r7
 8018d12:	bd80      	pop	{r7, pc}
 8018d14:	080323e4 	.word	0x080323e4
 8018d18:	080323c0 	.word	0x080323c0
 8018d1c:	08032380 	.word	0x08032380
 8018d20:	0803231c 	.word	0x0803231c
 8018d24:	0803228c 	.word	0x0803228c
 8018d28:	080321c8 	.word	0x080321c8
 8018d2c:	080320c8 	.word	0x080320c8

08018d30 <jinit_huff_decoder>:
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
 8018d30:	b580      	push	{r7, lr}
 8018d32:	b086      	sub	sp, #24
 8018d34:	af00      	add	r7, sp, #0
 8018d36:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8018d38:	687b      	ldr	r3, [r7, #4]
 8018d3a:	685b      	ldr	r3, [r3, #4]
 8018d3c:	681b      	ldr	r3, [r3, #0]
 8018d3e:	22d8      	movs	r2, #216	@ 0xd8
 8018d40:	2101      	movs	r1, #1
 8018d42:	6878      	ldr	r0, [r7, #4]
 8018d44:	4798      	blx	r3
 8018d46:	60b8      	str	r0, [r7, #8]
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 8018d48:	687b      	ldr	r3, [r7, #4]
 8018d4a:	68ba      	ldr	r2, [r7, #8]
 8018d4c:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
  entropy->pub.start_pass = start_pass_huff_decoder;
 8018d50:	68bb      	ldr	r3, [r7, #8]
 8018d52:	4a30      	ldr	r2, [pc, #192]	@ (8018e14 <jinit_huff_decoder+0xe4>)
 8018d54:	601a      	str	r2, [r3, #0]

  if (cinfo->progressive_mode) {
 8018d56:	687b      	ldr	r3, [r7, #4]
 8018d58:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8018d5c:	2b00      	cmp	r3, #0
 8018d5e:	d03b      	beq.n	8018dd8 <jinit_huff_decoder+0xa8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8018d60:	687b      	ldr	r3, [r7, #4]
 8018d62:	685b      	ldr	r3, [r3, #4]
 8018d64:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 8018d66:	687a      	ldr	r2, [r7, #4]
 8018d68:	6a52      	ldr	r2, [r2, #36]	@ 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8018d6a:	0212      	lsls	r2, r2, #8
 8018d6c:	2101      	movs	r1, #1
 8018d6e:	6878      	ldr	r0, [r7, #4]
 8018d70:	4798      	blx	r3
 8018d72:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 8018d74:	687b      	ldr	r3, [r7, #4]
 8018d76:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 8018d7a:	687b      	ldr	r3, [r7, #4]
 8018d7c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8018d80:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++)
 8018d82:	2300      	movs	r3, #0
 8018d84:	60fb      	str	r3, [r7, #12]
 8018d86:	e011      	b.n	8018dac <jinit_huff_decoder+0x7c>
      for (i = 0; i < DCTSIZE2; i++)
 8018d88:	2300      	movs	r3, #0
 8018d8a:	617b      	str	r3, [r7, #20]
 8018d8c:	e008      	b.n	8018da0 <jinit_huff_decoder+0x70>
	*coef_bit_ptr++ = -1;
 8018d8e:	693b      	ldr	r3, [r7, #16]
 8018d90:	1d1a      	adds	r2, r3, #4
 8018d92:	613a      	str	r2, [r7, #16]
 8018d94:	f04f 32ff 	mov.w	r2, #4294967295
 8018d98:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 8018d9a:	697b      	ldr	r3, [r7, #20]
 8018d9c:	3301      	adds	r3, #1
 8018d9e:	617b      	str	r3, [r7, #20]
 8018da0:	697b      	ldr	r3, [r7, #20]
 8018da2:	2b3f      	cmp	r3, #63	@ 0x3f
 8018da4:	ddf3      	ble.n	8018d8e <jinit_huff_decoder+0x5e>
    for (ci = 0; ci < cinfo->num_components; ci++)
 8018da6:	68fb      	ldr	r3, [r7, #12]
 8018da8:	3301      	adds	r3, #1
 8018daa:	60fb      	str	r3, [r7, #12]
 8018dac:	687b      	ldr	r3, [r7, #4]
 8018dae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018db0:	68fa      	ldr	r2, [r7, #12]
 8018db2:	429a      	cmp	r2, r3
 8018db4:	dbe8      	blt.n	8018d88 <jinit_huff_decoder+0x58>

    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8018db6:	2300      	movs	r3, #0
 8018db8:	617b      	str	r3, [r7, #20]
 8018dba:	e009      	b.n	8018dd0 <jinit_huff_decoder+0xa0>
      entropy->derived_tbls[i] = NULL;
 8018dbc:	68ba      	ldr	r2, [r7, #8]
 8018dbe:	697b      	ldr	r3, [r7, #20]
 8018dc0:	330a      	adds	r3, #10
 8018dc2:	009b      	lsls	r3, r3, #2
 8018dc4:	4413      	add	r3, r2
 8018dc6:	2200      	movs	r2, #0
 8018dc8:	605a      	str	r2, [r3, #4]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8018dca:	697b      	ldr	r3, [r7, #20]
 8018dcc:	3301      	adds	r3, #1
 8018dce:	617b      	str	r3, [r7, #20]
 8018dd0:	697b      	ldr	r3, [r7, #20]
 8018dd2:	2b03      	cmp	r3, #3
 8018dd4:	ddf2      	ble.n	8018dbc <jinit_huff_decoder+0x8c>
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
    }
  }
}
 8018dd6:	e018      	b.n	8018e0a <jinit_huff_decoder+0xda>
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8018dd8:	2300      	movs	r3, #0
 8018dda:	617b      	str	r3, [r7, #20]
 8018ddc:	e012      	b.n	8018e04 <jinit_huff_decoder+0xd4>
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
 8018dde:	68bb      	ldr	r3, [r7, #8]
 8018de0:	697a      	ldr	r2, [r7, #20]
 8018de2:	3214      	adds	r2, #20
 8018de4:	2100      	movs	r1, #0
 8018de6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8018dea:	68bb      	ldr	r3, [r7, #8]
 8018dec:	697a      	ldr	r2, [r7, #20]
 8018dee:	3214      	adds	r2, #20
 8018df0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8018df4:	68bb      	ldr	r3, [r7, #8]
 8018df6:	697a      	ldr	r2, [r7, #20]
 8018df8:	3210      	adds	r2, #16
 8018dfa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8018dfe:	697b      	ldr	r3, [r7, #20]
 8018e00:	3301      	adds	r3, #1
 8018e02:	617b      	str	r3, [r7, #20]
 8018e04:	697b      	ldr	r3, [r7, #20]
 8018e06:	2b03      	cmp	r3, #3
 8018e08:	dde9      	ble.n	8018dde <jinit_huff_decoder+0xae>
}
 8018e0a:	bf00      	nop
 8018e0c:	3718      	adds	r7, #24
 8018e0e:	46bd      	mov	sp, r7
 8018e10:	bd80      	pop	{r7, pc}
 8018e12:	bf00      	nop
 8018e14:	08018639 	.word	0x08018639

08018e18 <jpeg_core_output_dimensions>:
GLOBAL(void)
jpeg_core_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for transcoding and full decompression.
 */
{
 8018e18:	b580      	push	{r7, lr}
 8018e1a:	b084      	sub	sp, #16
 8018e1c:	af00      	add	r7, sp, #0
 8018e1e:	6078      	str	r0, [r7, #4]
#ifdef IDCT_SCALING_SUPPORTED
  int ci;
  jpeg_component_info *compptr;

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom) {
 8018e20:	687b      	ldr	r3, [r7, #4]
 8018e22:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018e24:	687a      	ldr	r2, [r7, #4]
 8018e26:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8018e2a:	fb03 f202 	mul.w	r2, r3, r2
 8018e2e:	687b      	ldr	r3, [r7, #4]
 8018e30:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018e32:	429a      	cmp	r2, r3
 8018e34:	d824      	bhi.n	8018e80 <jpeg_core_output_dimensions+0x68>
    /* Provide 1/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, (long) cinfo->block_size);
 8018e36:	687b      	ldr	r3, [r7, #4]
 8018e38:	69db      	ldr	r3, [r3, #28]
 8018e3a:	461a      	mov	r2, r3
 8018e3c:	687b      	ldr	r3, [r7, #4]
 8018e3e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018e42:	4619      	mov	r1, r3
 8018e44:	4610      	mov	r0, r2
 8018e46:	f016 f921 	bl	802f08c <jdiv_round_up>
 8018e4a:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8018e4c:	461a      	mov	r2, r3
 8018e4e:	687b      	ldr	r3, [r7, #4]
 8018e50:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, (long) cinfo->block_size);
 8018e52:	687b      	ldr	r3, [r7, #4]
 8018e54:	6a1b      	ldr	r3, [r3, #32]
 8018e56:	461a      	mov	r2, r3
 8018e58:	687b      	ldr	r3, [r7, #4]
 8018e5a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018e5e:	4619      	mov	r1, r3
 8018e60:	4610      	mov	r0, r2
 8018e62:	f016 f913 	bl	802f08c <jdiv_round_up>
 8018e66:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8018e68:	461a      	mov	r2, r3
 8018e6a:	687b      	ldr	r3, [r7, #4]
 8018e6c:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 1;
 8018e6e:	687b      	ldr	r3, [r7, #4]
 8018e70:	2201      	movs	r2, #1
 8018e72:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 1;
 8018e76:	687b      	ldr	r3, [r7, #4]
 8018e78:	2201      	movs	r2, #1
 8018e7a:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8018e7e:	e349      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 2) {
 8018e80:	687b      	ldr	r3, [r7, #4]
 8018e82:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018e84:	687a      	ldr	r2, [r7, #4]
 8018e86:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8018e8a:	fb03 f202 	mul.w	r2, r3, r2
 8018e8e:	687b      	ldr	r3, [r7, #4]
 8018e90:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018e92:	005b      	lsls	r3, r3, #1
 8018e94:	429a      	cmp	r2, r3
 8018e96:	d824      	bhi.n	8018ee2 <jpeg_core_output_dimensions+0xca>
    /* Provide 2/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 2L, (long) cinfo->block_size);
 8018e98:	687b      	ldr	r3, [r7, #4]
 8018e9a:	69db      	ldr	r3, [r3, #28]
 8018e9c:	005a      	lsls	r2, r3, #1
 8018e9e:	687b      	ldr	r3, [r7, #4]
 8018ea0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018ea4:	4619      	mov	r1, r3
 8018ea6:	4610      	mov	r0, r2
 8018ea8:	f016 f8f0 	bl	802f08c <jdiv_round_up>
 8018eac:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8018eae:	461a      	mov	r2, r3
 8018eb0:	687b      	ldr	r3, [r7, #4]
 8018eb2:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 2L, (long) cinfo->block_size);
 8018eb4:	687b      	ldr	r3, [r7, #4]
 8018eb6:	6a1b      	ldr	r3, [r3, #32]
 8018eb8:	005a      	lsls	r2, r3, #1
 8018eba:	687b      	ldr	r3, [r7, #4]
 8018ebc:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018ec0:	4619      	mov	r1, r3
 8018ec2:	4610      	mov	r0, r2
 8018ec4:	f016 f8e2 	bl	802f08c <jdiv_round_up>
 8018ec8:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8018eca:	461a      	mov	r2, r3
 8018ecc:	687b      	ldr	r3, [r7, #4]
 8018ece:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 2;
 8018ed0:	687b      	ldr	r3, [r7, #4]
 8018ed2:	2202      	movs	r2, #2
 8018ed4:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 2;
 8018ed8:	687b      	ldr	r3, [r7, #4]
 8018eda:	2202      	movs	r2, #2
 8018edc:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8018ee0:	e318      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 3) {
 8018ee2:	687b      	ldr	r3, [r7, #4]
 8018ee4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018ee6:	687a      	ldr	r2, [r7, #4]
 8018ee8:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8018eec:	fb02 f103 	mul.w	r1, r2, r3
 8018ef0:	687b      	ldr	r3, [r7, #4]
 8018ef2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8018ef4:	4613      	mov	r3, r2
 8018ef6:	005b      	lsls	r3, r3, #1
 8018ef8:	4413      	add	r3, r2
 8018efa:	4299      	cmp	r1, r3
 8018efc:	d82a      	bhi.n	8018f54 <jpeg_core_output_dimensions+0x13c>
    /* Provide 3/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 3L, (long) cinfo->block_size);
 8018efe:	687b      	ldr	r3, [r7, #4]
 8018f00:	69db      	ldr	r3, [r3, #28]
 8018f02:	461a      	mov	r2, r3
 8018f04:	4613      	mov	r3, r2
 8018f06:	005b      	lsls	r3, r3, #1
 8018f08:	441a      	add	r2, r3
 8018f0a:	687b      	ldr	r3, [r7, #4]
 8018f0c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018f10:	4619      	mov	r1, r3
 8018f12:	4610      	mov	r0, r2
 8018f14:	f016 f8ba 	bl	802f08c <jdiv_round_up>
 8018f18:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8018f1a:	461a      	mov	r2, r3
 8018f1c:	687b      	ldr	r3, [r7, #4]
 8018f1e:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 3L, (long) cinfo->block_size);
 8018f20:	687b      	ldr	r3, [r7, #4]
 8018f22:	6a1b      	ldr	r3, [r3, #32]
 8018f24:	461a      	mov	r2, r3
 8018f26:	4613      	mov	r3, r2
 8018f28:	005b      	lsls	r3, r3, #1
 8018f2a:	441a      	add	r2, r3
 8018f2c:	687b      	ldr	r3, [r7, #4]
 8018f2e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018f32:	4619      	mov	r1, r3
 8018f34:	4610      	mov	r0, r2
 8018f36:	f016 f8a9 	bl	802f08c <jdiv_round_up>
 8018f3a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8018f3c:	461a      	mov	r2, r3
 8018f3e:	687b      	ldr	r3, [r7, #4]
 8018f40:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 3;
 8018f42:	687b      	ldr	r3, [r7, #4]
 8018f44:	2203      	movs	r2, #3
 8018f46:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 3;
 8018f4a:	687b      	ldr	r3, [r7, #4]
 8018f4c:	2203      	movs	r2, #3
 8018f4e:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8018f52:	e2df      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 4) {
 8018f54:	687b      	ldr	r3, [r7, #4]
 8018f56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018f58:	687a      	ldr	r2, [r7, #4]
 8018f5a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8018f5e:	fb03 f202 	mul.w	r2, r3, r2
 8018f62:	687b      	ldr	r3, [r7, #4]
 8018f64:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018f66:	009b      	lsls	r3, r3, #2
 8018f68:	429a      	cmp	r2, r3
 8018f6a:	d824      	bhi.n	8018fb6 <jpeg_core_output_dimensions+0x19e>
    /* Provide 4/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 4L, (long) cinfo->block_size);
 8018f6c:	687b      	ldr	r3, [r7, #4]
 8018f6e:	69db      	ldr	r3, [r3, #28]
 8018f70:	009a      	lsls	r2, r3, #2
 8018f72:	687b      	ldr	r3, [r7, #4]
 8018f74:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018f78:	4619      	mov	r1, r3
 8018f7a:	4610      	mov	r0, r2
 8018f7c:	f016 f886 	bl	802f08c <jdiv_round_up>
 8018f80:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8018f82:	461a      	mov	r2, r3
 8018f84:	687b      	ldr	r3, [r7, #4]
 8018f86:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 4L, (long) cinfo->block_size);
 8018f88:	687b      	ldr	r3, [r7, #4]
 8018f8a:	6a1b      	ldr	r3, [r3, #32]
 8018f8c:	009a      	lsls	r2, r3, #2
 8018f8e:	687b      	ldr	r3, [r7, #4]
 8018f90:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018f94:	4619      	mov	r1, r3
 8018f96:	4610      	mov	r0, r2
 8018f98:	f016 f878 	bl	802f08c <jdiv_round_up>
 8018f9c:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8018f9e:	461a      	mov	r2, r3
 8018fa0:	687b      	ldr	r3, [r7, #4]
 8018fa2:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 4;
 8018fa4:	687b      	ldr	r3, [r7, #4]
 8018fa6:	2204      	movs	r2, #4
 8018fa8:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 4;
 8018fac:	687b      	ldr	r3, [r7, #4]
 8018fae:	2204      	movs	r2, #4
 8018fb0:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8018fb4:	e2ae      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 5) {
 8018fb6:	687b      	ldr	r3, [r7, #4]
 8018fb8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018fba:	687a      	ldr	r2, [r7, #4]
 8018fbc:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8018fc0:	fb02 f103 	mul.w	r1, r2, r3
 8018fc4:	687b      	ldr	r3, [r7, #4]
 8018fc6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8018fc8:	4613      	mov	r3, r2
 8018fca:	009b      	lsls	r3, r3, #2
 8018fcc:	4413      	add	r3, r2
 8018fce:	4299      	cmp	r1, r3
 8018fd0:	d82a      	bhi.n	8019028 <jpeg_core_output_dimensions+0x210>
    /* Provide 5/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 5L, (long) cinfo->block_size);
 8018fd2:	687b      	ldr	r3, [r7, #4]
 8018fd4:	69db      	ldr	r3, [r3, #28]
 8018fd6:	461a      	mov	r2, r3
 8018fd8:	4613      	mov	r3, r2
 8018fda:	009b      	lsls	r3, r3, #2
 8018fdc:	441a      	add	r2, r3
 8018fde:	687b      	ldr	r3, [r7, #4]
 8018fe0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8018fe4:	4619      	mov	r1, r3
 8018fe6:	4610      	mov	r0, r2
 8018fe8:	f016 f850 	bl	802f08c <jdiv_round_up>
 8018fec:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8018fee:	461a      	mov	r2, r3
 8018ff0:	687b      	ldr	r3, [r7, #4]
 8018ff2:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 5L, (long) cinfo->block_size);
 8018ff4:	687b      	ldr	r3, [r7, #4]
 8018ff6:	6a1b      	ldr	r3, [r3, #32]
 8018ff8:	461a      	mov	r2, r3
 8018ffa:	4613      	mov	r3, r2
 8018ffc:	009b      	lsls	r3, r3, #2
 8018ffe:	441a      	add	r2, r3
 8019000:	687b      	ldr	r3, [r7, #4]
 8019002:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019006:	4619      	mov	r1, r3
 8019008:	4610      	mov	r0, r2
 801900a:	f016 f83f 	bl	802f08c <jdiv_round_up>
 801900e:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8019010:	461a      	mov	r2, r3
 8019012:	687b      	ldr	r3, [r7, #4]
 8019014:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 5;
 8019016:	687b      	ldr	r3, [r7, #4]
 8019018:	2205      	movs	r2, #5
 801901a:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 5;
 801901e:	687b      	ldr	r3, [r7, #4]
 8019020:	2205      	movs	r2, #5
 8019022:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8019026:	e275      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 6) {
 8019028:	687b      	ldr	r3, [r7, #4]
 801902a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801902c:	687a      	ldr	r2, [r7, #4]
 801902e:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019032:	fb02 f103 	mul.w	r1, r2, r3
 8019036:	687b      	ldr	r3, [r7, #4]
 8019038:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801903a:	4613      	mov	r3, r2
 801903c:	005b      	lsls	r3, r3, #1
 801903e:	4413      	add	r3, r2
 8019040:	005b      	lsls	r3, r3, #1
 8019042:	4299      	cmp	r1, r3
 8019044:	d82e      	bhi.n	80190a4 <jpeg_core_output_dimensions+0x28c>
    /* Provide 6/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 6L, (long) cinfo->block_size);
 8019046:	687b      	ldr	r3, [r7, #4]
 8019048:	69db      	ldr	r3, [r3, #28]
 801904a:	461a      	mov	r2, r3
 801904c:	4613      	mov	r3, r2
 801904e:	005b      	lsls	r3, r3, #1
 8019050:	4413      	add	r3, r2
 8019052:	005b      	lsls	r3, r3, #1
 8019054:	461a      	mov	r2, r3
 8019056:	687b      	ldr	r3, [r7, #4]
 8019058:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801905c:	4619      	mov	r1, r3
 801905e:	4610      	mov	r0, r2
 8019060:	f016 f814 	bl	802f08c <jdiv_round_up>
 8019064:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8019066:	461a      	mov	r2, r3
 8019068:	687b      	ldr	r3, [r7, #4]
 801906a:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 6L, (long) cinfo->block_size);
 801906c:	687b      	ldr	r3, [r7, #4]
 801906e:	6a1b      	ldr	r3, [r3, #32]
 8019070:	461a      	mov	r2, r3
 8019072:	4613      	mov	r3, r2
 8019074:	005b      	lsls	r3, r3, #1
 8019076:	4413      	add	r3, r2
 8019078:	005b      	lsls	r3, r3, #1
 801907a:	461a      	mov	r2, r3
 801907c:	687b      	ldr	r3, [r7, #4]
 801907e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019082:	4619      	mov	r1, r3
 8019084:	4610      	mov	r0, r2
 8019086:	f016 f801 	bl	802f08c <jdiv_round_up>
 801908a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801908c:	461a      	mov	r2, r3
 801908e:	687b      	ldr	r3, [r7, #4]
 8019090:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 6;
 8019092:	687b      	ldr	r3, [r7, #4]
 8019094:	2206      	movs	r2, #6
 8019096:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 6;
 801909a:	687b      	ldr	r3, [r7, #4]
 801909c:	2206      	movs	r2, #6
 801909e:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80190a2:	e237      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 7) {
 80190a4:	687b      	ldr	r3, [r7, #4]
 80190a6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80190a8:	687a      	ldr	r2, [r7, #4]
 80190aa:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80190ae:	fb02 f103 	mul.w	r1, r2, r3
 80190b2:	687b      	ldr	r3, [r7, #4]
 80190b4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80190b6:	4613      	mov	r3, r2
 80190b8:	00db      	lsls	r3, r3, #3
 80190ba:	1a9b      	subs	r3, r3, r2
 80190bc:	4299      	cmp	r1, r3
 80190be:	d82a      	bhi.n	8019116 <jpeg_core_output_dimensions+0x2fe>
    /* Provide 7/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 7L, (long) cinfo->block_size);
 80190c0:	687b      	ldr	r3, [r7, #4]
 80190c2:	69db      	ldr	r3, [r3, #28]
 80190c4:	461a      	mov	r2, r3
 80190c6:	4613      	mov	r3, r2
 80190c8:	00db      	lsls	r3, r3, #3
 80190ca:	1a9a      	subs	r2, r3, r2
 80190cc:	687b      	ldr	r3, [r7, #4]
 80190ce:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80190d2:	4619      	mov	r1, r3
 80190d4:	4610      	mov	r0, r2
 80190d6:	f015 ffd9 	bl	802f08c <jdiv_round_up>
 80190da:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80190dc:	461a      	mov	r2, r3
 80190de:	687b      	ldr	r3, [r7, #4]
 80190e0:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 7L, (long) cinfo->block_size);
 80190e2:	687b      	ldr	r3, [r7, #4]
 80190e4:	6a1b      	ldr	r3, [r3, #32]
 80190e6:	461a      	mov	r2, r3
 80190e8:	4613      	mov	r3, r2
 80190ea:	00db      	lsls	r3, r3, #3
 80190ec:	1a9a      	subs	r2, r3, r2
 80190ee:	687b      	ldr	r3, [r7, #4]
 80190f0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80190f4:	4619      	mov	r1, r3
 80190f6:	4610      	mov	r0, r2
 80190f8:	f015 ffc8 	bl	802f08c <jdiv_round_up>
 80190fc:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80190fe:	461a      	mov	r2, r3
 8019100:	687b      	ldr	r3, [r7, #4]
 8019102:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 7;
 8019104:	687b      	ldr	r3, [r7, #4]
 8019106:	2207      	movs	r2, #7
 8019108:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 7;
 801910c:	687b      	ldr	r3, [r7, #4]
 801910e:	2207      	movs	r2, #7
 8019110:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8019114:	e1fe      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 8) {
 8019116:	687b      	ldr	r3, [r7, #4]
 8019118:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801911a:	687a      	ldr	r2, [r7, #4]
 801911c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019120:	fb03 f202 	mul.w	r2, r3, r2
 8019124:	687b      	ldr	r3, [r7, #4]
 8019126:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8019128:	00db      	lsls	r3, r3, #3
 801912a:	429a      	cmp	r2, r3
 801912c:	d824      	bhi.n	8019178 <jpeg_core_output_dimensions+0x360>
    /* Provide 8/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 8L, (long) cinfo->block_size);
 801912e:	687b      	ldr	r3, [r7, #4]
 8019130:	69db      	ldr	r3, [r3, #28]
 8019132:	00da      	lsls	r2, r3, #3
 8019134:	687b      	ldr	r3, [r7, #4]
 8019136:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801913a:	4619      	mov	r1, r3
 801913c:	4610      	mov	r0, r2
 801913e:	f015 ffa5 	bl	802f08c <jdiv_round_up>
 8019142:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8019144:	461a      	mov	r2, r3
 8019146:	687b      	ldr	r3, [r7, #4]
 8019148:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 8L, (long) cinfo->block_size);
 801914a:	687b      	ldr	r3, [r7, #4]
 801914c:	6a1b      	ldr	r3, [r3, #32]
 801914e:	00da      	lsls	r2, r3, #3
 8019150:	687b      	ldr	r3, [r7, #4]
 8019152:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019156:	4619      	mov	r1, r3
 8019158:	4610      	mov	r0, r2
 801915a:	f015 ff97 	bl	802f08c <jdiv_round_up>
 801915e:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8019160:	461a      	mov	r2, r3
 8019162:	687b      	ldr	r3, [r7, #4]
 8019164:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 8;
 8019166:	687b      	ldr	r3, [r7, #4]
 8019168:	2208      	movs	r2, #8
 801916a:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 8;
 801916e:	687b      	ldr	r3, [r7, #4]
 8019170:	2208      	movs	r2, #8
 8019172:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8019176:	e1cd      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 9) {
 8019178:	687b      	ldr	r3, [r7, #4]
 801917a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801917c:	687a      	ldr	r2, [r7, #4]
 801917e:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019182:	fb02 f103 	mul.w	r1, r2, r3
 8019186:	687b      	ldr	r3, [r7, #4]
 8019188:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801918a:	4613      	mov	r3, r2
 801918c:	00db      	lsls	r3, r3, #3
 801918e:	4413      	add	r3, r2
 8019190:	4299      	cmp	r1, r3
 8019192:	d82a      	bhi.n	80191ea <jpeg_core_output_dimensions+0x3d2>
    /* Provide 9/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 9L, (long) cinfo->block_size);
 8019194:	687b      	ldr	r3, [r7, #4]
 8019196:	69db      	ldr	r3, [r3, #28]
 8019198:	461a      	mov	r2, r3
 801919a:	4613      	mov	r3, r2
 801919c:	00db      	lsls	r3, r3, #3
 801919e:	441a      	add	r2, r3
 80191a0:	687b      	ldr	r3, [r7, #4]
 80191a2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80191a6:	4619      	mov	r1, r3
 80191a8:	4610      	mov	r0, r2
 80191aa:	f015 ff6f 	bl	802f08c <jdiv_round_up>
 80191ae:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80191b0:	461a      	mov	r2, r3
 80191b2:	687b      	ldr	r3, [r7, #4]
 80191b4:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 9L, (long) cinfo->block_size);
 80191b6:	687b      	ldr	r3, [r7, #4]
 80191b8:	6a1b      	ldr	r3, [r3, #32]
 80191ba:	461a      	mov	r2, r3
 80191bc:	4613      	mov	r3, r2
 80191be:	00db      	lsls	r3, r3, #3
 80191c0:	441a      	add	r2, r3
 80191c2:	687b      	ldr	r3, [r7, #4]
 80191c4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80191c8:	4619      	mov	r1, r3
 80191ca:	4610      	mov	r0, r2
 80191cc:	f015 ff5e 	bl	802f08c <jdiv_round_up>
 80191d0:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80191d2:	461a      	mov	r2, r3
 80191d4:	687b      	ldr	r3, [r7, #4]
 80191d6:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 9;
 80191d8:	687b      	ldr	r3, [r7, #4]
 80191da:	2209      	movs	r2, #9
 80191dc:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 9;
 80191e0:	687b      	ldr	r3, [r7, #4]
 80191e2:	2209      	movs	r2, #9
 80191e4:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80191e8:	e194      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 10) {
 80191ea:	687b      	ldr	r3, [r7, #4]
 80191ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80191ee:	687a      	ldr	r2, [r7, #4]
 80191f0:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80191f4:	fb02 f103 	mul.w	r1, r2, r3
 80191f8:	687b      	ldr	r3, [r7, #4]
 80191fa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80191fc:	4613      	mov	r3, r2
 80191fe:	009b      	lsls	r3, r3, #2
 8019200:	4413      	add	r3, r2
 8019202:	005b      	lsls	r3, r3, #1
 8019204:	4299      	cmp	r1, r3
 8019206:	d82e      	bhi.n	8019266 <jpeg_core_output_dimensions+0x44e>
    /* Provide 10/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 10L, (long) cinfo->block_size);
 8019208:	687b      	ldr	r3, [r7, #4]
 801920a:	69db      	ldr	r3, [r3, #28]
 801920c:	461a      	mov	r2, r3
 801920e:	4613      	mov	r3, r2
 8019210:	009b      	lsls	r3, r3, #2
 8019212:	4413      	add	r3, r2
 8019214:	005b      	lsls	r3, r3, #1
 8019216:	461a      	mov	r2, r3
 8019218:	687b      	ldr	r3, [r7, #4]
 801921a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801921e:	4619      	mov	r1, r3
 8019220:	4610      	mov	r0, r2
 8019222:	f015 ff33 	bl	802f08c <jdiv_round_up>
 8019226:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8019228:	461a      	mov	r2, r3
 801922a:	687b      	ldr	r3, [r7, #4]
 801922c:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 10L, (long) cinfo->block_size);
 801922e:	687b      	ldr	r3, [r7, #4]
 8019230:	6a1b      	ldr	r3, [r3, #32]
 8019232:	461a      	mov	r2, r3
 8019234:	4613      	mov	r3, r2
 8019236:	009b      	lsls	r3, r3, #2
 8019238:	4413      	add	r3, r2
 801923a:	005b      	lsls	r3, r3, #1
 801923c:	461a      	mov	r2, r3
 801923e:	687b      	ldr	r3, [r7, #4]
 8019240:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019244:	4619      	mov	r1, r3
 8019246:	4610      	mov	r0, r2
 8019248:	f015 ff20 	bl	802f08c <jdiv_round_up>
 801924c:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801924e:	461a      	mov	r2, r3
 8019250:	687b      	ldr	r3, [r7, #4]
 8019252:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 10;
 8019254:	687b      	ldr	r3, [r7, #4]
 8019256:	220a      	movs	r2, #10
 8019258:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 10;
 801925c:	687b      	ldr	r3, [r7, #4]
 801925e:	220a      	movs	r2, #10
 8019260:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8019264:	e156      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 11) {
 8019266:	687b      	ldr	r3, [r7, #4]
 8019268:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801926a:	687a      	ldr	r2, [r7, #4]
 801926c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019270:	fb02 f103 	mul.w	r1, r2, r3
 8019274:	687b      	ldr	r3, [r7, #4]
 8019276:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8019278:	4613      	mov	r3, r2
 801927a:	009b      	lsls	r3, r3, #2
 801927c:	4413      	add	r3, r2
 801927e:	005b      	lsls	r3, r3, #1
 8019280:	4413      	add	r3, r2
 8019282:	4299      	cmp	r1, r3
 8019284:	d82e      	bhi.n	80192e4 <jpeg_core_output_dimensions+0x4cc>
    /* Provide 11/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 11L, (long) cinfo->block_size);
 8019286:	687b      	ldr	r3, [r7, #4]
 8019288:	69db      	ldr	r3, [r3, #28]
 801928a:	461a      	mov	r2, r3
 801928c:	4613      	mov	r3, r2
 801928e:	009b      	lsls	r3, r3, #2
 8019290:	4413      	add	r3, r2
 8019292:	005b      	lsls	r3, r3, #1
 8019294:	441a      	add	r2, r3
 8019296:	687b      	ldr	r3, [r7, #4]
 8019298:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801929c:	4619      	mov	r1, r3
 801929e:	4610      	mov	r0, r2
 80192a0:	f015 fef4 	bl	802f08c <jdiv_round_up>
 80192a4:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80192a6:	461a      	mov	r2, r3
 80192a8:	687b      	ldr	r3, [r7, #4]
 80192aa:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 11L, (long) cinfo->block_size);
 80192ac:	687b      	ldr	r3, [r7, #4]
 80192ae:	6a1b      	ldr	r3, [r3, #32]
 80192b0:	461a      	mov	r2, r3
 80192b2:	4613      	mov	r3, r2
 80192b4:	009b      	lsls	r3, r3, #2
 80192b6:	4413      	add	r3, r2
 80192b8:	005b      	lsls	r3, r3, #1
 80192ba:	441a      	add	r2, r3
 80192bc:	687b      	ldr	r3, [r7, #4]
 80192be:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80192c2:	4619      	mov	r1, r3
 80192c4:	4610      	mov	r0, r2
 80192c6:	f015 fee1 	bl	802f08c <jdiv_round_up>
 80192ca:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80192cc:	461a      	mov	r2, r3
 80192ce:	687b      	ldr	r3, [r7, #4]
 80192d0:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 11;
 80192d2:	687b      	ldr	r3, [r7, #4]
 80192d4:	220b      	movs	r2, #11
 80192d6:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 11;
 80192da:	687b      	ldr	r3, [r7, #4]
 80192dc:	220b      	movs	r2, #11
 80192de:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80192e2:	e117      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 12) {
 80192e4:	687b      	ldr	r3, [r7, #4]
 80192e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80192e8:	687a      	ldr	r2, [r7, #4]
 80192ea:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80192ee:	fb02 f103 	mul.w	r1, r2, r3
 80192f2:	687b      	ldr	r3, [r7, #4]
 80192f4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80192f6:	4613      	mov	r3, r2
 80192f8:	005b      	lsls	r3, r3, #1
 80192fa:	4413      	add	r3, r2
 80192fc:	009b      	lsls	r3, r3, #2
 80192fe:	4299      	cmp	r1, r3
 8019300:	d82e      	bhi.n	8019360 <jpeg_core_output_dimensions+0x548>
    /* Provide 12/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 12L, (long) cinfo->block_size);
 8019302:	687b      	ldr	r3, [r7, #4]
 8019304:	69db      	ldr	r3, [r3, #28]
 8019306:	461a      	mov	r2, r3
 8019308:	4613      	mov	r3, r2
 801930a:	005b      	lsls	r3, r3, #1
 801930c:	4413      	add	r3, r2
 801930e:	009b      	lsls	r3, r3, #2
 8019310:	461a      	mov	r2, r3
 8019312:	687b      	ldr	r3, [r7, #4]
 8019314:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019318:	4619      	mov	r1, r3
 801931a:	4610      	mov	r0, r2
 801931c:	f015 feb6 	bl	802f08c <jdiv_round_up>
 8019320:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8019322:	461a      	mov	r2, r3
 8019324:	687b      	ldr	r3, [r7, #4]
 8019326:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 12L, (long) cinfo->block_size);
 8019328:	687b      	ldr	r3, [r7, #4]
 801932a:	6a1b      	ldr	r3, [r3, #32]
 801932c:	461a      	mov	r2, r3
 801932e:	4613      	mov	r3, r2
 8019330:	005b      	lsls	r3, r3, #1
 8019332:	4413      	add	r3, r2
 8019334:	009b      	lsls	r3, r3, #2
 8019336:	461a      	mov	r2, r3
 8019338:	687b      	ldr	r3, [r7, #4]
 801933a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801933e:	4619      	mov	r1, r3
 8019340:	4610      	mov	r0, r2
 8019342:	f015 fea3 	bl	802f08c <jdiv_round_up>
 8019346:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8019348:	461a      	mov	r2, r3
 801934a:	687b      	ldr	r3, [r7, #4]
 801934c:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 12;
 801934e:	687b      	ldr	r3, [r7, #4]
 8019350:	220c      	movs	r2, #12
 8019352:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 12;
 8019356:	687b      	ldr	r3, [r7, #4]
 8019358:	220c      	movs	r2, #12
 801935a:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 801935e:	e0d9      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 13) {
 8019360:	687b      	ldr	r3, [r7, #4]
 8019362:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019364:	687a      	ldr	r2, [r7, #4]
 8019366:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801936a:	fb02 f103 	mul.w	r1, r2, r3
 801936e:	687b      	ldr	r3, [r7, #4]
 8019370:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8019372:	4613      	mov	r3, r2
 8019374:	005b      	lsls	r3, r3, #1
 8019376:	4413      	add	r3, r2
 8019378:	009b      	lsls	r3, r3, #2
 801937a:	4413      	add	r3, r2
 801937c:	4299      	cmp	r1, r3
 801937e:	d82e      	bhi.n	80193de <jpeg_core_output_dimensions+0x5c6>
    /* Provide 13/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 13L, (long) cinfo->block_size);
 8019380:	687b      	ldr	r3, [r7, #4]
 8019382:	69db      	ldr	r3, [r3, #28]
 8019384:	461a      	mov	r2, r3
 8019386:	4613      	mov	r3, r2
 8019388:	005b      	lsls	r3, r3, #1
 801938a:	4413      	add	r3, r2
 801938c:	009b      	lsls	r3, r3, #2
 801938e:	441a      	add	r2, r3
 8019390:	687b      	ldr	r3, [r7, #4]
 8019392:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019396:	4619      	mov	r1, r3
 8019398:	4610      	mov	r0, r2
 801939a:	f015 fe77 	bl	802f08c <jdiv_round_up>
 801939e:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80193a0:	461a      	mov	r2, r3
 80193a2:	687b      	ldr	r3, [r7, #4]
 80193a4:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 13L, (long) cinfo->block_size);
 80193a6:	687b      	ldr	r3, [r7, #4]
 80193a8:	6a1b      	ldr	r3, [r3, #32]
 80193aa:	461a      	mov	r2, r3
 80193ac:	4613      	mov	r3, r2
 80193ae:	005b      	lsls	r3, r3, #1
 80193b0:	4413      	add	r3, r2
 80193b2:	009b      	lsls	r3, r3, #2
 80193b4:	441a      	add	r2, r3
 80193b6:	687b      	ldr	r3, [r7, #4]
 80193b8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80193bc:	4619      	mov	r1, r3
 80193be:	4610      	mov	r0, r2
 80193c0:	f015 fe64 	bl	802f08c <jdiv_round_up>
 80193c4:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80193c6:	461a      	mov	r2, r3
 80193c8:	687b      	ldr	r3, [r7, #4]
 80193ca:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 13;
 80193cc:	687b      	ldr	r3, [r7, #4]
 80193ce:	220d      	movs	r2, #13
 80193d0:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 13;
 80193d4:	687b      	ldr	r3, [r7, #4]
 80193d6:	220d      	movs	r2, #13
 80193d8:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80193dc:	e09a      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 14) {
 80193de:	687b      	ldr	r3, [r7, #4]
 80193e0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80193e2:	687a      	ldr	r2, [r7, #4]
 80193e4:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 80193e8:	fb02 f103 	mul.w	r1, r2, r3
 80193ec:	687b      	ldr	r3, [r7, #4]
 80193ee:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80193f0:	4613      	mov	r3, r2
 80193f2:	00db      	lsls	r3, r3, #3
 80193f4:	1a9b      	subs	r3, r3, r2
 80193f6:	005b      	lsls	r3, r3, #1
 80193f8:	4299      	cmp	r1, r3
 80193fa:	d82e      	bhi.n	801945a <jpeg_core_output_dimensions+0x642>
    /* Provide 14/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 14L, (long) cinfo->block_size);
 80193fc:	687b      	ldr	r3, [r7, #4]
 80193fe:	69db      	ldr	r3, [r3, #28]
 8019400:	461a      	mov	r2, r3
 8019402:	4613      	mov	r3, r2
 8019404:	00db      	lsls	r3, r3, #3
 8019406:	1a9b      	subs	r3, r3, r2
 8019408:	005b      	lsls	r3, r3, #1
 801940a:	461a      	mov	r2, r3
 801940c:	687b      	ldr	r3, [r7, #4]
 801940e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019412:	4619      	mov	r1, r3
 8019414:	4610      	mov	r0, r2
 8019416:	f015 fe39 	bl	802f08c <jdiv_round_up>
 801941a:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 801941c:	461a      	mov	r2, r3
 801941e:	687b      	ldr	r3, [r7, #4]
 8019420:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 14L, (long) cinfo->block_size);
 8019422:	687b      	ldr	r3, [r7, #4]
 8019424:	6a1b      	ldr	r3, [r3, #32]
 8019426:	461a      	mov	r2, r3
 8019428:	4613      	mov	r3, r2
 801942a:	00db      	lsls	r3, r3, #3
 801942c:	1a9b      	subs	r3, r3, r2
 801942e:	005b      	lsls	r3, r3, #1
 8019430:	461a      	mov	r2, r3
 8019432:	687b      	ldr	r3, [r7, #4]
 8019434:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019438:	4619      	mov	r1, r3
 801943a:	4610      	mov	r0, r2
 801943c:	f015 fe26 	bl	802f08c <jdiv_round_up>
 8019440:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8019442:	461a      	mov	r2, r3
 8019444:	687b      	ldr	r3, [r7, #4]
 8019446:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 14;
 8019448:	687b      	ldr	r3, [r7, #4]
 801944a:	220e      	movs	r2, #14
 801944c:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 14;
 8019450:	687b      	ldr	r3, [r7, #4]
 8019452:	220e      	movs	r2, #14
 8019454:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 8019458:	e05c      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 15) {
 801945a:	687b      	ldr	r3, [r7, #4]
 801945c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801945e:	687a      	ldr	r2, [r7, #4]
 8019460:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019464:	fb02 f103 	mul.w	r1, r2, r3
 8019468:	687b      	ldr	r3, [r7, #4]
 801946a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801946c:	4613      	mov	r3, r2
 801946e:	011b      	lsls	r3, r3, #4
 8019470:	1a9b      	subs	r3, r3, r2
 8019472:	4299      	cmp	r1, r3
 8019474:	d82a      	bhi.n	80194cc <jpeg_core_output_dimensions+0x6b4>
    /* Provide 15/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 15L, (long) cinfo->block_size);
 8019476:	687b      	ldr	r3, [r7, #4]
 8019478:	69db      	ldr	r3, [r3, #28]
 801947a:	461a      	mov	r2, r3
 801947c:	4613      	mov	r3, r2
 801947e:	011b      	lsls	r3, r3, #4
 8019480:	1a9a      	subs	r2, r3, r2
 8019482:	687b      	ldr	r3, [r7, #4]
 8019484:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8019488:	4619      	mov	r1, r3
 801948a:	4610      	mov	r0, r2
 801948c:	f015 fdfe 	bl	802f08c <jdiv_round_up>
 8019490:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8019492:	461a      	mov	r2, r3
 8019494:	687b      	ldr	r3, [r7, #4]
 8019496:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 15L, (long) cinfo->block_size);
 8019498:	687b      	ldr	r3, [r7, #4]
 801949a:	6a1b      	ldr	r3, [r3, #32]
 801949c:	461a      	mov	r2, r3
 801949e:	4613      	mov	r3, r2
 80194a0:	011b      	lsls	r3, r3, #4
 80194a2:	1a9a      	subs	r2, r3, r2
 80194a4:	687b      	ldr	r3, [r7, #4]
 80194a6:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80194aa:	4619      	mov	r1, r3
 80194ac:	4610      	mov	r0, r2
 80194ae:	f015 fded 	bl	802f08c <jdiv_round_up>
 80194b2:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80194b4:	461a      	mov	r2, r3
 80194b6:	687b      	ldr	r3, [r7, #4]
 80194b8:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 15;
 80194ba:	687b      	ldr	r3, [r7, #4]
 80194bc:	220f      	movs	r2, #15
 80194be:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 15;
 80194c2:	687b      	ldr	r3, [r7, #4]
 80194c4:	220f      	movs	r2, #15
 80194c6:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
 80194ca:	e023      	b.n	8019514 <jpeg_core_output_dimensions+0x6fc>
  } else {
    /* Provide 16/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 16L, (long) cinfo->block_size);
 80194cc:	687b      	ldr	r3, [r7, #4]
 80194ce:	69db      	ldr	r3, [r3, #28]
 80194d0:	011a      	lsls	r2, r3, #4
 80194d2:	687b      	ldr	r3, [r7, #4]
 80194d4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80194d8:	4619      	mov	r1, r3
 80194da:	4610      	mov	r0, r2
 80194dc:	f015 fdd6 	bl	802f08c <jdiv_round_up>
 80194e0:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80194e2:	461a      	mov	r2, r3
 80194e4:	687b      	ldr	r3, [r7, #4]
 80194e6:	671a      	str	r2, [r3, #112]	@ 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 16L, (long) cinfo->block_size);
 80194e8:	687b      	ldr	r3, [r7, #4]
 80194ea:	6a1b      	ldr	r3, [r3, #32]
 80194ec:	011a      	lsls	r2, r3, #4
 80194ee:	687b      	ldr	r3, [r7, #4]
 80194f0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 80194f4:	4619      	mov	r1, r3
 80194f6:	4610      	mov	r0, r2
 80194f8:	f015 fdc8 	bl	802f08c <jdiv_round_up>
 80194fc:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80194fe:	461a      	mov	r2, r3
 8019500:	687b      	ldr	r3, [r7, #4]
 8019502:	675a      	str	r2, [r3, #116]	@ 0x74
    cinfo->min_DCT_h_scaled_size = 16;
 8019504:	687b      	ldr	r3, [r7, #4]
 8019506:	2210      	movs	r2, #16
 8019508:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    cinfo->min_DCT_v_scaled_size = 16;
 801950c:	687b      	ldr	r3, [r7, #4]
 801950e:	2210      	movs	r2, #16
 8019510:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
  }

  /* Recompute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8019514:	2300      	movs	r3, #0
 8019516:	60fb      	str	r3, [r7, #12]
 8019518:	687b      	ldr	r3, [r7, #4]
 801951a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801951e:	60bb      	str	r3, [r7, #8]
 8019520:	e00f      	b.n	8019542 <jpeg_core_output_dimensions+0x72a>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size;
 8019522:	687b      	ldr	r3, [r7, #4]
 8019524:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
 8019528:	68bb      	ldr	r3, [r7, #8]
 801952a:	625a      	str	r2, [r3, #36]	@ 0x24
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size;
 801952c:	687b      	ldr	r3, [r7, #4]
 801952e:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
 8019532:	68bb      	ldr	r3, [r7, #8]
 8019534:	629a      	str	r2, [r3, #40]	@ 0x28
       ci++, compptr++) {
 8019536:	68fb      	ldr	r3, [r7, #12]
 8019538:	3301      	adds	r3, #1
 801953a:	60fb      	str	r3, [r7, #12]
 801953c:	68bb      	ldr	r3, [r7, #8]
 801953e:	3358      	adds	r3, #88	@ 0x58
 8019540:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8019542:	687b      	ldr	r3, [r7, #4]
 8019544:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8019546:	68fa      	ldr	r2, [r7, #12]
 8019548:	429a      	cmp	r2, r3
 801954a:	dbea      	blt.n	8019522 <jpeg_core_output_dimensions+0x70a>
  /* jdinput.c has already initialized DCT_scaled_size,
   * and has computed unscaled downsampled_width and downsampled_height.
   */

#endif /* IDCT_SCALING_SUPPORTED */
}
 801954c:	bf00      	nop
 801954e:	bf00      	nop
 8019550:	3710      	adds	r7, #16
 8019552:	46bd      	mov	sp, r7
 8019554:	bd80      	pop	{r7, pc}
	...

08019558 <initial_setup>:


LOCAL(void)
initial_setup (j_decompress_ptr cinfo)
/* Called once, when first SOS marker is reached */
{
 8019558:	b580      	push	{r7, lr}
 801955a:	b084      	sub	sp, #16
 801955c:	af00      	add	r7, sp, #0
 801955e:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 8019560:	687b      	ldr	r3, [r7, #4]
 8019562:	6a1b      	ldr	r3, [r3, #32]
 8019564:	461a      	mov	r2, r3
 8019566:	f64f 73dc 	movw	r3, #65500	@ 0xffdc
 801956a:	429a      	cmp	r2, r3
 801956c:	dc06      	bgt.n	801957c <initial_setup+0x24>
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
 801956e:	687b      	ldr	r3, [r7, #4]
 8019570:	69db      	ldr	r3, [r3, #28]
 8019572:	461a      	mov	r2, r3
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 8019574:	f64f 73dc 	movw	r3, #65500	@ 0xffdc
 8019578:	429a      	cmp	r2, r3
 801957a:	dd0d      	ble.n	8019598 <initial_setup+0x40>
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
 801957c:	687b      	ldr	r3, [r7, #4]
 801957e:	681b      	ldr	r3, [r3, #0]
 8019580:	222a      	movs	r2, #42	@ 0x2a
 8019582:	615a      	str	r2, [r3, #20]
 8019584:	687b      	ldr	r3, [r7, #4]
 8019586:	681b      	ldr	r3, [r3, #0]
 8019588:	f64f 72dc 	movw	r2, #65500	@ 0xffdc
 801958c:	619a      	str	r2, [r3, #24]
 801958e:	687b      	ldr	r3, [r7, #4]
 8019590:	681b      	ldr	r3, [r3, #0]
 8019592:	681b      	ldr	r3, [r3, #0]
 8019594:	6878      	ldr	r0, [r7, #4]
 8019596:	4798      	blx	r3

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
 8019598:	687b      	ldr	r3, [r7, #4]
 801959a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 801959e:	2b08      	cmp	r3, #8
 80195a0:	d00e      	beq.n	80195c0 <initial_setup+0x68>
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 80195a2:	687b      	ldr	r3, [r7, #4]
 80195a4:	681b      	ldr	r3, [r3, #0]
 80195a6:	2210      	movs	r2, #16
 80195a8:	615a      	str	r2, [r3, #20]
 80195aa:	687b      	ldr	r3, [r7, #4]
 80195ac:	681b      	ldr	r3, [r3, #0]
 80195ae:	687a      	ldr	r2, [r7, #4]
 80195b0:	f8d2 20d4 	ldr.w	r2, [r2, #212]	@ 0xd4
 80195b4:	619a      	str	r2, [r3, #24]
 80195b6:	687b      	ldr	r3, [r7, #4]
 80195b8:	681b      	ldr	r3, [r3, #0]
 80195ba:	681b      	ldr	r3, [r3, #0]
 80195bc:	6878      	ldr	r0, [r7, #4]
 80195be:	4798      	blx	r3

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
 80195c0:	687b      	ldr	r3, [r7, #4]
 80195c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80195c4:	2b0a      	cmp	r3, #10
 80195c6:	dd11      	ble.n	80195ec <initial_setup+0x94>
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
 80195c8:	687b      	ldr	r3, [r7, #4]
 80195ca:	681b      	ldr	r3, [r3, #0]
 80195cc:	221b      	movs	r2, #27
 80195ce:	615a      	str	r2, [r3, #20]
 80195d0:	687b      	ldr	r3, [r7, #4]
 80195d2:	681b      	ldr	r3, [r3, #0]
 80195d4:	687a      	ldr	r2, [r7, #4]
 80195d6:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80195d8:	619a      	str	r2, [r3, #24]
 80195da:	687b      	ldr	r3, [r7, #4]
 80195dc:	681b      	ldr	r3, [r3, #0]
 80195de:	220a      	movs	r2, #10
 80195e0:	61da      	str	r2, [r3, #28]
 80195e2:	687b      	ldr	r3, [r7, #4]
 80195e4:	681b      	ldr	r3, [r3, #0]
 80195e6:	681b      	ldr	r3, [r3, #0]
 80195e8:	6878      	ldr	r0, [r7, #4]
 80195ea:	4798      	blx	r3
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
 80195ec:	687b      	ldr	r3, [r7, #4]
 80195ee:	2201      	movs	r2, #1
 80195f0:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
  cinfo->max_v_samp_factor = 1;
 80195f4:	687b      	ldr	r3, [r7, #4]
 80195f6:	2201      	movs	r2, #1
 80195f8:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80195fc:	2300      	movs	r3, #0
 80195fe:	60fb      	str	r3, [r7, #12]
 8019600:	687b      	ldr	r3, [r7, #4]
 8019602:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8019606:	60bb      	str	r3, [r7, #8]
 8019608:	e034      	b.n	8019674 <initial_setup+0x11c>
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 801960a:	68bb      	ldr	r3, [r7, #8]
 801960c:	689b      	ldr	r3, [r3, #8]
 801960e:	2b00      	cmp	r3, #0
 8019610:	dd0b      	ble.n	801962a <initial_setup+0xd2>
 8019612:	68bb      	ldr	r3, [r7, #8]
 8019614:	689b      	ldr	r3, [r3, #8]
 8019616:	2b04      	cmp	r3, #4
 8019618:	dc07      	bgt.n	801962a <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 801961a:	68bb      	ldr	r3, [r7, #8]
 801961c:	68db      	ldr	r3, [r3, #12]
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 801961e:	2b00      	cmp	r3, #0
 8019620:	dd03      	ble.n	801962a <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 8019622:	68bb      	ldr	r3, [r7, #8]
 8019624:	68db      	ldr	r3, [r3, #12]
 8019626:	2b04      	cmp	r3, #4
 8019628:	dd08      	ble.n	801963c <initial_setup+0xe4>
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
 801962a:	687b      	ldr	r3, [r7, #4]
 801962c:	681b      	ldr	r3, [r3, #0]
 801962e:	2213      	movs	r2, #19
 8019630:	615a      	str	r2, [r3, #20]
 8019632:	687b      	ldr	r3, [r7, #4]
 8019634:	681b      	ldr	r3, [r3, #0]
 8019636:	681b      	ldr	r3, [r3, #0]
 8019638:	6878      	ldr	r0, [r7, #4]
 801963a:	4798      	blx	r3
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
 801963c:	68bb      	ldr	r3, [r7, #8]
 801963e:	689a      	ldr	r2, [r3, #8]
 8019640:	687b      	ldr	r3, [r7, #4]
 8019642:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8019646:	429a      	cmp	r2, r3
 8019648:	bfb8      	it	lt
 801964a:	461a      	movlt	r2, r3
 801964c:	687b      	ldr	r3, [r7, #4]
 801964e:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
 8019652:	68bb      	ldr	r3, [r7, #8]
 8019654:	68da      	ldr	r2, [r3, #12]
 8019656:	687b      	ldr	r3, [r7, #4]
 8019658:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801965c:	429a      	cmp	r2, r3
 801965e:	bfb8      	it	lt
 8019660:	461a      	movlt	r2, r3
 8019662:	687b      	ldr	r3, [r7, #4]
 8019664:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
       ci++, compptr++) {
 8019668:	68fb      	ldr	r3, [r7, #12]
 801966a:	3301      	adds	r3, #1
 801966c:	60fb      	str	r3, [r7, #12]
 801966e:	68bb      	ldr	r3, [r7, #8]
 8019670:	3358      	adds	r3, #88	@ 0x58
 8019672:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8019674:	687b      	ldr	r3, [r7, #4]
 8019676:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8019678:	68fa      	ldr	r2, [r7, #12]
 801967a:	429a      	cmp	r2, r3
 801967c:	dbc5      	blt.n	801960a <initial_setup+0xb2>
				   compptr->v_samp_factor);
  }

  /* Derive block_size, natural_order, and lim_Se */
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 801967e:	687b      	ldr	r3, [r7, #4]
 8019680:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8019684:	2b00      	cmp	r3, #0
 8019686:	d109      	bne.n	801969c <initial_setup+0x144>
 8019688:	687b      	ldr	r3, [r7, #4]
 801968a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801968e:	2b00      	cmp	r3, #0
 8019690:	d011      	beq.n	80196b6 <initial_setup+0x15e>
      cinfo->comps_in_scan)) { /* no pseudo SOS marker */
 8019692:	687b      	ldr	r3, [r7, #4]
 8019694:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 8019698:	2b00      	cmp	r3, #0
 801969a:	d00c      	beq.n	80196b6 <initial_setup+0x15e>
    cinfo->block_size = DCTSIZE;
 801969c:	687b      	ldr	r3, [r7, #4]
 801969e:	2208      	movs	r2, #8
 80196a0:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
    cinfo->natural_order = jpeg_natural_order;
 80196a4:	687b      	ldr	r3, [r7, #4]
 80196a6:	4ac4      	ldr	r2, [pc, #784]	@ (80199b8 <initial_setup+0x460>)
 80196a8:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
    cinfo->lim_Se = DCTSIZE2-1;
 80196ac:	687b      	ldr	r3, [r7, #4]
 80196ae:	223f      	movs	r2, #63	@ 0x3f
 80196b0:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
 80196b4:	e1ca      	b.n	8019a4c <initial_setup+0x4f4>
  } else
    switch (cinfo->Se) {
 80196b6:	687b      	ldr	r3, [r7, #4]
 80196b8:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80196bc:	2bff      	cmp	r3, #255	@ 0xff
 80196be:	f000 8196 	beq.w	80199ee <initial_setup+0x496>
 80196c2:	2bff      	cmp	r3, #255	@ 0xff
 80196c4:	f300 81a0 	bgt.w	8019a08 <initial_setup+0x4b0>
 80196c8:	2be0      	cmp	r3, #224	@ 0xe0
 80196ca:	f000 8183 	beq.w	80199d4 <initial_setup+0x47c>
 80196ce:	2be0      	cmp	r3, #224	@ 0xe0
 80196d0:	f300 819a 	bgt.w	8019a08 <initial_setup+0x4b0>
 80196d4:	2bc3      	cmp	r3, #195	@ 0xc3
 80196d6:	f000 8161 	beq.w	801999c <initial_setup+0x444>
 80196da:	2bc3      	cmp	r3, #195	@ 0xc3
 80196dc:	f300 8194 	bgt.w	8019a08 <initial_setup+0x4b0>
 80196e0:	2ba8      	cmp	r3, #168	@ 0xa8
 80196e2:	f000 814e 	beq.w	8019982 <initial_setup+0x42a>
 80196e6:	2ba8      	cmp	r3, #168	@ 0xa8
 80196e8:	f300 818e 	bgt.w	8019a08 <initial_setup+0x4b0>
 80196ec:	2b8f      	cmp	r3, #143	@ 0x8f
 80196ee:	f000 813b 	beq.w	8019968 <initial_setup+0x410>
 80196f2:	2b8f      	cmp	r3, #143	@ 0x8f
 80196f4:	f300 8188 	bgt.w	8019a08 <initial_setup+0x4b0>
 80196f8:	2b78      	cmp	r3, #120	@ 0x78
 80196fa:	f000 8128 	beq.w	801994e <initial_setup+0x3f6>
 80196fe:	2b78      	cmp	r3, #120	@ 0x78
 8019700:	f300 8182 	bgt.w	8019a08 <initial_setup+0x4b0>
 8019704:	2b63      	cmp	r3, #99	@ 0x63
 8019706:	f000 8115 	beq.w	8019934 <initial_setup+0x3dc>
 801970a:	2b63      	cmp	r3, #99	@ 0x63
 801970c:	f300 817c 	bgt.w	8019a08 <initial_setup+0x4b0>
 8019710:	2b3f      	cmp	r3, #63	@ 0x3f
 8019712:	f300 8089 	bgt.w	8019828 <initial_setup+0x2d0>
 8019716:	2b00      	cmp	r3, #0
 8019718:	f2c0 8176 	blt.w	8019a08 <initial_setup+0x4b0>
 801971c:	2b3f      	cmp	r3, #63	@ 0x3f
 801971e:	f200 8173 	bhi.w	8019a08 <initial_setup+0x4b0>
 8019722:	a201      	add	r2, pc, #4	@ (adr r2, 8019728 <initial_setup+0x1d0>)
 8019724:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019728:	0801982f 	.word	0x0801982f
 801972c:	08019a09 	.word	0x08019a09
 8019730:	08019a09 	.word	0x08019a09
 8019734:	0801984d 	.word	0x0801984d
 8019738:	08019a09 	.word	0x08019a09
 801973c:	08019a09 	.word	0x08019a09
 8019740:	08019a09 	.word	0x08019a09
 8019744:	08019a09 	.word	0x08019a09
 8019748:	0801986b 	.word	0x0801986b
 801974c:	08019a09 	.word	0x08019a09
 8019750:	08019a09 	.word	0x08019a09
 8019754:	08019a09 	.word	0x08019a09
 8019758:	08019a09 	.word	0x08019a09
 801975c:	08019a09 	.word	0x08019a09
 8019760:	08019a09 	.word	0x08019a09
 8019764:	08019889 	.word	0x08019889
 8019768:	08019a09 	.word	0x08019a09
 801976c:	08019a09 	.word	0x08019a09
 8019770:	08019a09 	.word	0x08019a09
 8019774:	08019a09 	.word	0x08019a09
 8019778:	08019a09 	.word	0x08019a09
 801977c:	08019a09 	.word	0x08019a09
 8019780:	08019a09 	.word	0x08019a09
 8019784:	08019a09 	.word	0x08019a09
 8019788:	080198a7 	.word	0x080198a7
 801978c:	08019a09 	.word	0x08019a09
 8019790:	08019a09 	.word	0x08019a09
 8019794:	08019a09 	.word	0x08019a09
 8019798:	08019a09 	.word	0x08019a09
 801979c:	08019a09 	.word	0x08019a09
 80197a0:	08019a09 	.word	0x08019a09
 80197a4:	08019a09 	.word	0x08019a09
 80197a8:	08019a09 	.word	0x08019a09
 80197ac:	08019a09 	.word	0x08019a09
 80197b0:	08019a09 	.word	0x08019a09
 80197b4:	080198c5 	.word	0x080198c5
 80197b8:	08019a09 	.word	0x08019a09
 80197bc:	08019a09 	.word	0x08019a09
 80197c0:	08019a09 	.word	0x08019a09
 80197c4:	08019a09 	.word	0x08019a09
 80197c8:	08019a09 	.word	0x08019a09
 80197cc:	08019a09 	.word	0x08019a09
 80197d0:	08019a09 	.word	0x08019a09
 80197d4:	08019a09 	.word	0x08019a09
 80197d8:	08019a09 	.word	0x08019a09
 80197dc:	08019a09 	.word	0x08019a09
 80197e0:	08019a09 	.word	0x08019a09
 80197e4:	08019a09 	.word	0x08019a09
 80197e8:	080198e3 	.word	0x080198e3
 80197ec:	08019a09 	.word	0x08019a09
 80197f0:	08019a09 	.word	0x08019a09
 80197f4:	08019a09 	.word	0x08019a09
 80197f8:	08019a09 	.word	0x08019a09
 80197fc:	08019a09 	.word	0x08019a09
 8019800:	08019a09 	.word	0x08019a09
 8019804:	08019a09 	.word	0x08019a09
 8019808:	08019a09 	.word	0x08019a09
 801980c:	08019a09 	.word	0x08019a09
 8019810:	08019a09 	.word	0x08019a09
 8019814:	08019a09 	.word	0x08019a09
 8019818:	08019a09 	.word	0x08019a09
 801981c:	08019a09 	.word	0x08019a09
 8019820:	08019a09 	.word	0x08019a09
 8019824:	08019901 	.word	0x08019901
 8019828:	2b50      	cmp	r3, #80	@ 0x50
 801982a:	d076      	beq.n	801991a <initial_setup+0x3c2>
 801982c:	e0ec      	b.n	8019a08 <initial_setup+0x4b0>
    case (1*1-1):
      cinfo->block_size = 1;
 801982e:	687b      	ldr	r3, [r7, #4]
 8019830:	2201      	movs	r2, #1
 8019832:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order; /* not needed */
 8019836:	687b      	ldr	r3, [r7, #4]
 8019838:	4a5f      	ldr	r2, [pc, #380]	@ (80199b8 <initial_setup+0x460>)
 801983a:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 801983e:	687b      	ldr	r3, [r7, #4]
 8019840:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8019844:	687b      	ldr	r3, [r7, #4]
 8019846:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801984a:	e0ff      	b.n	8019a4c <initial_setup+0x4f4>
    case (2*2-1):
      cinfo->block_size = 2;
 801984c:	687b      	ldr	r3, [r7, #4]
 801984e:	2202      	movs	r2, #2
 8019850:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order2;
 8019854:	687b      	ldr	r3, [r7, #4]
 8019856:	4a59      	ldr	r2, [pc, #356]	@ (80199bc <initial_setup+0x464>)
 8019858:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 801985c:	687b      	ldr	r3, [r7, #4]
 801985e:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8019862:	687b      	ldr	r3, [r7, #4]
 8019864:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019868:	e0f0      	b.n	8019a4c <initial_setup+0x4f4>
    case (3*3-1):
      cinfo->block_size = 3;
 801986a:	687b      	ldr	r3, [r7, #4]
 801986c:	2203      	movs	r2, #3
 801986e:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order3;
 8019872:	687b      	ldr	r3, [r7, #4]
 8019874:	4a52      	ldr	r2, [pc, #328]	@ (80199c0 <initial_setup+0x468>)
 8019876:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 801987a:	687b      	ldr	r3, [r7, #4]
 801987c:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 8019880:	687b      	ldr	r3, [r7, #4]
 8019882:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019886:	e0e1      	b.n	8019a4c <initial_setup+0x4f4>
    case (4*4-1):
      cinfo->block_size = 4;
 8019888:	687b      	ldr	r3, [r7, #4]
 801988a:	2204      	movs	r2, #4
 801988c:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order4;
 8019890:	687b      	ldr	r3, [r7, #4]
 8019892:	4a4c      	ldr	r2, [pc, #304]	@ (80199c4 <initial_setup+0x46c>)
 8019894:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8019898:	687b      	ldr	r3, [r7, #4]
 801989a:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 801989e:	687b      	ldr	r3, [r7, #4]
 80198a0:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80198a4:	e0d2      	b.n	8019a4c <initial_setup+0x4f4>
    case (5*5-1):
      cinfo->block_size = 5;
 80198a6:	687b      	ldr	r3, [r7, #4]
 80198a8:	2205      	movs	r2, #5
 80198aa:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order5;
 80198ae:	687b      	ldr	r3, [r7, #4]
 80198b0:	4a45      	ldr	r2, [pc, #276]	@ (80199c8 <initial_setup+0x470>)
 80198b2:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80198b6:	687b      	ldr	r3, [r7, #4]
 80198b8:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80198bc:	687b      	ldr	r3, [r7, #4]
 80198be:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80198c2:	e0c3      	b.n	8019a4c <initial_setup+0x4f4>
    case (6*6-1):
      cinfo->block_size = 6;
 80198c4:	687b      	ldr	r3, [r7, #4]
 80198c6:	2206      	movs	r2, #6
 80198c8:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order6;
 80198cc:	687b      	ldr	r3, [r7, #4]
 80198ce:	4a3f      	ldr	r2, [pc, #252]	@ (80199cc <initial_setup+0x474>)
 80198d0:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80198d4:	687b      	ldr	r3, [r7, #4]
 80198d6:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80198da:	687b      	ldr	r3, [r7, #4]
 80198dc:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80198e0:	e0b4      	b.n	8019a4c <initial_setup+0x4f4>
    case (7*7-1):
      cinfo->block_size = 7;
 80198e2:	687b      	ldr	r3, [r7, #4]
 80198e4:	2207      	movs	r2, #7
 80198e6:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order7;
 80198ea:	687b      	ldr	r3, [r7, #4]
 80198ec:	4a38      	ldr	r2, [pc, #224]	@ (80199d0 <initial_setup+0x478>)
 80198ee:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80198f2:	687b      	ldr	r3, [r7, #4]
 80198f4:	f8d3 219c 	ldr.w	r2, [r3, #412]	@ 0x19c
 80198f8:	687b      	ldr	r3, [r7, #4]
 80198fa:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80198fe:	e0a5      	b.n	8019a4c <initial_setup+0x4f4>
    case (8*8-1):
      cinfo->block_size = 8;
 8019900:	687b      	ldr	r3, [r7, #4]
 8019902:	2208      	movs	r2, #8
 8019904:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8019908:	687b      	ldr	r3, [r7, #4]
 801990a:	4a2b      	ldr	r2, [pc, #172]	@ (80199b8 <initial_setup+0x460>)
 801990c:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8019910:	687b      	ldr	r3, [r7, #4]
 8019912:	223f      	movs	r2, #63	@ 0x3f
 8019914:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019918:	e098      	b.n	8019a4c <initial_setup+0x4f4>
    case (9*9-1):
      cinfo->block_size = 9;
 801991a:	687b      	ldr	r3, [r7, #4]
 801991c:	2209      	movs	r2, #9
 801991e:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8019922:	687b      	ldr	r3, [r7, #4]
 8019924:	4a24      	ldr	r2, [pc, #144]	@ (80199b8 <initial_setup+0x460>)
 8019926:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801992a:	687b      	ldr	r3, [r7, #4]
 801992c:	223f      	movs	r2, #63	@ 0x3f
 801992e:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019932:	e08b      	b.n	8019a4c <initial_setup+0x4f4>
    case (10*10-1):
      cinfo->block_size = 10;
 8019934:	687b      	ldr	r3, [r7, #4]
 8019936:	220a      	movs	r2, #10
 8019938:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801993c:	687b      	ldr	r3, [r7, #4]
 801993e:	4a1e      	ldr	r2, [pc, #120]	@ (80199b8 <initial_setup+0x460>)
 8019940:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8019944:	687b      	ldr	r3, [r7, #4]
 8019946:	223f      	movs	r2, #63	@ 0x3f
 8019948:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801994c:	e07e      	b.n	8019a4c <initial_setup+0x4f4>
    case (11*11-1):
      cinfo->block_size = 11;
 801994e:	687b      	ldr	r3, [r7, #4]
 8019950:	220b      	movs	r2, #11
 8019952:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8019956:	687b      	ldr	r3, [r7, #4]
 8019958:	4a17      	ldr	r2, [pc, #92]	@ (80199b8 <initial_setup+0x460>)
 801995a:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801995e:	687b      	ldr	r3, [r7, #4]
 8019960:	223f      	movs	r2, #63	@ 0x3f
 8019962:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019966:	e071      	b.n	8019a4c <initial_setup+0x4f4>
    case (12*12-1):
      cinfo->block_size = 12;
 8019968:	687b      	ldr	r3, [r7, #4]
 801996a:	220c      	movs	r2, #12
 801996c:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8019970:	687b      	ldr	r3, [r7, #4]
 8019972:	4a11      	ldr	r2, [pc, #68]	@ (80199b8 <initial_setup+0x460>)
 8019974:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8019978:	687b      	ldr	r3, [r7, #4]
 801997a:	223f      	movs	r2, #63	@ 0x3f
 801997c:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019980:	e064      	b.n	8019a4c <initial_setup+0x4f4>
    case (13*13-1):
      cinfo->block_size = 13;
 8019982:	687b      	ldr	r3, [r7, #4]
 8019984:	220d      	movs	r2, #13
 8019986:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801998a:	687b      	ldr	r3, [r7, #4]
 801998c:	4a0a      	ldr	r2, [pc, #40]	@ (80199b8 <initial_setup+0x460>)
 801998e:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8019992:	687b      	ldr	r3, [r7, #4]
 8019994:	223f      	movs	r2, #63	@ 0x3f
 8019996:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 801999a:	e057      	b.n	8019a4c <initial_setup+0x4f4>
    case (14*14-1):
      cinfo->block_size = 14;
 801999c:	687b      	ldr	r3, [r7, #4]
 801999e:	220e      	movs	r2, #14
 80199a0:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80199a4:	687b      	ldr	r3, [r7, #4]
 80199a6:	4a04      	ldr	r2, [pc, #16]	@ (80199b8 <initial_setup+0x460>)
 80199a8:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80199ac:	687b      	ldr	r3, [r7, #4]
 80199ae:	223f      	movs	r2, #63	@ 0x3f
 80199b0:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80199b4:	e04a      	b.n	8019a4c <initial_setup+0x4f4>
 80199b6:	bf00      	nop
 80199b8:	08032750 	.word	0x08032750
 80199bc:	08032bec 	.word	0x08032bec
 80199c0:	08032b88 	.word	0x08032b88
 80199c4:	08032b08 	.word	0x08032b08
 80199c8:	08032a64 	.word	0x08032a64
 80199cc:	08032994 	.word	0x08032994
 80199d0:	08032890 	.word	0x08032890
    case (15*15-1):
      cinfo->block_size = 15;
 80199d4:	687b      	ldr	r3, [r7, #4]
 80199d6:	220f      	movs	r2, #15
 80199d8:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80199dc:	687b      	ldr	r3, [r7, #4]
 80199de:	4a72      	ldr	r2, [pc, #456]	@ (8019ba8 <initial_setup+0x650>)
 80199e0:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80199e4:	687b      	ldr	r3, [r7, #4]
 80199e6:	223f      	movs	r2, #63	@ 0x3f
 80199e8:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 80199ec:	e02e      	b.n	8019a4c <initial_setup+0x4f4>
    case (16*16-1):
      cinfo->block_size = 16;
 80199ee:	687b      	ldr	r3, [r7, #4]
 80199f0:	2210      	movs	r2, #16
 80199f2:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80199f6:	687b      	ldr	r3, [r7, #4]
 80199f8:	4a6b      	ldr	r2, [pc, #428]	@ (8019ba8 <initial_setup+0x650>)
 80199fa:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80199fe:	687b      	ldr	r3, [r7, #4]
 8019a00:	223f      	movs	r2, #63	@ 0x3f
 8019a02:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
      break;
 8019a06:	e021      	b.n	8019a4c <initial_setup+0x4f4>
    default:
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 8019a08:	687b      	ldr	r3, [r7, #4]
 8019a0a:	681b      	ldr	r3, [r3, #0]
 8019a0c:	2211      	movs	r2, #17
 8019a0e:	615a      	str	r2, [r3, #20]
 8019a10:	687b      	ldr	r3, [r7, #4]
 8019a12:	681b      	ldr	r3, [r3, #0]
 8019a14:	687a      	ldr	r2, [r7, #4]
 8019a16:	f8d2 2198 	ldr.w	r2, [r2, #408]	@ 0x198
 8019a1a:	619a      	str	r2, [r3, #24]
 8019a1c:	687b      	ldr	r3, [r7, #4]
 8019a1e:	681b      	ldr	r3, [r3, #0]
 8019a20:	687a      	ldr	r2, [r7, #4]
 8019a22:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 8019a26:	61da      	str	r2, [r3, #28]
 8019a28:	687b      	ldr	r3, [r7, #4]
 8019a2a:	681b      	ldr	r3, [r3, #0]
 8019a2c:	687a      	ldr	r2, [r7, #4]
 8019a2e:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 8019a32:	621a      	str	r2, [r3, #32]
 8019a34:	687b      	ldr	r3, [r7, #4]
 8019a36:	681b      	ldr	r3, [r3, #0]
 8019a38:	687a      	ldr	r2, [r7, #4]
 8019a3a:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 8019a3e:	625a      	str	r2, [r3, #36]	@ 0x24
 8019a40:	687b      	ldr	r3, [r7, #4]
 8019a42:	681b      	ldr	r3, [r3, #0]
 8019a44:	681b      	ldr	r3, [r3, #0]
 8019a46:	6878      	ldr	r0, [r7, #4]
 8019a48:	4798      	blx	r3
	       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
      break;
 8019a4a:	bf00      	nop
   * In the full decompressor,
   * this will be overridden by jpeg_calc_output_dimensions in jdmaster.c;
   * but in the transcoder,
   * jpeg_calc_output_dimensions is not used, so we must do it here.
   */
  cinfo->min_DCT_h_scaled_size = cinfo->block_size;
 8019a4c:	687b      	ldr	r3, [r7, #4]
 8019a4e:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8019a52:	687b      	ldr	r3, [r7, #4]
 8019a54:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
  cinfo->min_DCT_v_scaled_size = cinfo->block_size;
 8019a58:	687b      	ldr	r3, [r7, #4]
 8019a5a:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8019a5e:	687b      	ldr	r3, [r7, #4]
 8019a60:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8019a64:	2300      	movs	r3, #0
 8019a66:	60fb      	str	r3, [r7, #12]
 8019a68:	687b      	ldr	r3, [r7, #4]
 8019a6a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8019a6e:	60bb      	str	r3, [r7, #8]
 8019a70:	e065      	b.n	8019b3e <initial_setup+0x5e6>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->block_size;
 8019a72:	687b      	ldr	r3, [r7, #4]
 8019a74:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8019a78:	68bb      	ldr	r3, [r7, #8]
 8019a7a:	625a      	str	r2, [r3, #36]	@ 0x24
    compptr->DCT_v_scaled_size = cinfo->block_size;
 8019a7c:	687b      	ldr	r3, [r7, #4]
 8019a7e:	f8d3 21a8 	ldr.w	r2, [r3, #424]	@ 0x1a8
 8019a82:	68bb      	ldr	r3, [r7, #8]
 8019a84:	629a      	str	r2, [r3, #40]	@ 0x28
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8019a86:	687b      	ldr	r3, [r7, #4]
 8019a88:	69db      	ldr	r3, [r3, #28]
 8019a8a:	461a      	mov	r2, r3
 8019a8c:	68bb      	ldr	r3, [r7, #8]
 8019a8e:	689b      	ldr	r3, [r3, #8]
 8019a90:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8019a94:	687b      	ldr	r3, [r7, #4]
 8019a96:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8019a9a:	687a      	ldr	r2, [r7, #4]
 8019a9c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019aa0:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8019aa4:	4619      	mov	r1, r3
 8019aa6:	f015 faf1 	bl	802f08c <jdiv_round_up>
 8019aaa:	4603      	mov	r3, r0
    compptr->width_in_blocks = (JDIMENSION)
 8019aac:	461a      	mov	r2, r3
 8019aae:	68bb      	ldr	r3, [r7, #8]
 8019ab0:	61da      	str	r2, [r3, #28]
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8019ab2:	687b      	ldr	r3, [r7, #4]
 8019ab4:	6a1b      	ldr	r3, [r3, #32]
 8019ab6:	461a      	mov	r2, r3
 8019ab8:	68bb      	ldr	r3, [r7, #8]
 8019aba:	68db      	ldr	r3, [r3, #12]
 8019abc:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8019ac0:	687b      	ldr	r3, [r7, #4]
 8019ac2:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8019ac6:	687a      	ldr	r2, [r7, #4]
 8019ac8:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019acc:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8019ad0:	4619      	mov	r1, r3
 8019ad2:	f015 fadb 	bl	802f08c <jdiv_round_up>
 8019ad6:	4603      	mov	r3, r0
    compptr->height_in_blocks = (JDIMENSION)
 8019ad8:	461a      	mov	r2, r3
 8019ada:	68bb      	ldr	r3, [r7, #8]
 8019adc:	621a      	str	r2, [r3, #32]
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8019ade:	687b      	ldr	r3, [r7, #4]
 8019ae0:	69db      	ldr	r3, [r3, #28]
 8019ae2:	461a      	mov	r2, r3
 8019ae4:	68bb      	ldr	r3, [r7, #8]
 8019ae6:	689b      	ldr	r3, [r3, #8]
 8019ae8:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_h_samp_factor);
 8019aec:	687b      	ldr	r3, [r7, #4]
 8019aee:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8019af2:	4619      	mov	r1, r3
 8019af4:	4610      	mov	r0, r2
 8019af6:	f015 fac9 	bl	802f08c <jdiv_round_up>
 8019afa:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 8019afc:	461a      	mov	r2, r3
 8019afe:	68bb      	ldr	r3, [r7, #8]
 8019b00:	62da      	str	r2, [r3, #44]	@ 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8019b02:	687b      	ldr	r3, [r7, #4]
 8019b04:	6a1b      	ldr	r3, [r3, #32]
 8019b06:	461a      	mov	r2, r3
 8019b08:	68bb      	ldr	r3, [r7, #8]
 8019b0a:	68db      	ldr	r3, [r3, #12]
 8019b0c:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_v_samp_factor);
 8019b10:	687b      	ldr	r3, [r7, #4]
 8019b12:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8019b16:	4619      	mov	r1, r3
 8019b18:	4610      	mov	r0, r2
 8019b1a:	f015 fab7 	bl	802f08c <jdiv_round_up>
 8019b1e:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 8019b20:	461a      	mov	r2, r3
 8019b22:	68bb      	ldr	r3, [r7, #8]
 8019b24:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
 8019b26:	68bb      	ldr	r3, [r7, #8]
 8019b28:	2201      	movs	r2, #1
 8019b2a:	635a      	str	r2, [r3, #52]	@ 0x34
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
 8019b2c:	68bb      	ldr	r3, [r7, #8]
 8019b2e:	2200      	movs	r2, #0
 8019b30:	651a      	str	r2, [r3, #80]	@ 0x50
       ci++, compptr++) {
 8019b32:	68fb      	ldr	r3, [r7, #12]
 8019b34:	3301      	adds	r3, #1
 8019b36:	60fb      	str	r3, [r7, #12]
 8019b38:	68bb      	ldr	r3, [r7, #8]
 8019b3a:	3358      	adds	r3, #88	@ 0x58
 8019b3c:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8019b3e:	687b      	ldr	r3, [r7, #4]
 8019b40:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8019b42:	68fa      	ldr	r2, [r7, #12]
 8019b44:	429a      	cmp	r2, r3
 8019b46:	db94      	blt.n	8019a72 <initial_setup+0x51a>
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
 8019b48:	687b      	ldr	r3, [r7, #4]
 8019b4a:	6a1b      	ldr	r3, [r3, #32]
 8019b4c:	4618      	mov	r0, r3
	          (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8019b4e:	687b      	ldr	r3, [r7, #4]
 8019b50:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8019b54:	687a      	ldr	r2, [r7, #4]
 8019b56:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019b5a:	fb02 f303 	mul.w	r3, r2, r3
    jdiv_round_up((long) cinfo->image_height,
 8019b5e:	4619      	mov	r1, r3
 8019b60:	f015 fa94 	bl	802f08c <jdiv_round_up>
 8019b64:	4603      	mov	r3, r0
  cinfo->total_iMCU_rows = (JDIMENSION)
 8019b66:	461a      	mov	r2, r3
 8019b68:	687b      	ldr	r3, [r7, #4]
 8019b6a:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
 8019b6e:	687b      	ldr	r3, [r7, #4]
 8019b70:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
 8019b74:	687b      	ldr	r3, [r7, #4]
 8019b76:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8019b78:	429a      	cmp	r2, r3
 8019b7a:	db04      	blt.n	8019b86 <initial_setup+0x62e>
 8019b7c:	687b      	ldr	r3, [r7, #4]
 8019b7e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8019b82:	2b00      	cmp	r3, #0
 8019b84:	d005      	beq.n	8019b92 <initial_setup+0x63a>
    cinfo->inputctl->has_multiple_scans = TRUE;
 8019b86:	687b      	ldr	r3, [r7, #4]
 8019b88:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019b8c:	2201      	movs	r2, #1
 8019b8e:	611a      	str	r2, [r3, #16]
 8019b90:	e005      	b.n	8019b9e <initial_setup+0x646>
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
 8019b92:	687b      	ldr	r3, [r7, #4]
 8019b94:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019b98:	2200      	movs	r2, #0
 8019b9a:	611a      	str	r2, [r3, #16]
}
 8019b9c:	bf00      	nop
 8019b9e:	bf00      	nop
 8019ba0:	3710      	adds	r7, #16
 8019ba2:	46bd      	mov	sp, r7
 8019ba4:	bd80      	pop	{r7, pc}
 8019ba6:	bf00      	nop
 8019ba8:	08032750 	.word	0x08032750

08019bac <per_scan_setup>:

LOCAL(void)
per_scan_setup (j_decompress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
 8019bac:	b580      	push	{r7, lr}
 8019bae:	b086      	sub	sp, #24
 8019bb0:	af00      	add	r7, sp, #0
 8019bb2:	6078      	str	r0, [r7, #4]
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
 8019bb4:	687b      	ldr	r3, [r7, #4]
 8019bb6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019bba:	2b01      	cmp	r3, #1
 8019bbc:	d139      	bne.n	8019c32 <per_scan_setup+0x86>
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
 8019bbe:	687b      	ldr	r3, [r7, #4]
 8019bc0:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8019bc4:	60bb      	str	r3, [r7, #8]
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
 8019bc6:	68bb      	ldr	r3, [r7, #8]
 8019bc8:	69da      	ldr	r2, [r3, #28]
 8019bca:	687b      	ldr	r3, [r7, #4]
 8019bcc:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
 8019bd0:	68bb      	ldr	r3, [r7, #8]
 8019bd2:	6a1a      	ldr	r2, [r3, #32]
 8019bd4:	687b      	ldr	r3, [r7, #4]
 8019bd6:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
 8019bda:	68bb      	ldr	r3, [r7, #8]
 8019bdc:	2201      	movs	r2, #1
 8019bde:	639a      	str	r2, [r3, #56]	@ 0x38
    compptr->MCU_height = 1;
 8019be0:	68bb      	ldr	r3, [r7, #8]
 8019be2:	2201      	movs	r2, #1
 8019be4:	63da      	str	r2, [r3, #60]	@ 0x3c
    compptr->MCU_blocks = 1;
 8019be6:	68bb      	ldr	r3, [r7, #8]
 8019be8:	2201      	movs	r2, #1
 8019bea:	641a      	str	r2, [r3, #64]	@ 0x40
    compptr->MCU_sample_width = compptr->DCT_h_scaled_size;
 8019bec:	68bb      	ldr	r3, [r7, #8]
 8019bee:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8019bf0:	68bb      	ldr	r3, [r7, #8]
 8019bf2:	645a      	str	r2, [r3, #68]	@ 0x44
    compptr->last_col_width = 1;
 8019bf4:	68bb      	ldr	r3, [r7, #8]
 8019bf6:	2201      	movs	r2, #1
 8019bf8:	649a      	str	r2, [r3, #72]	@ 0x48
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 8019bfa:	68bb      	ldr	r3, [r7, #8]
 8019bfc:	6a1b      	ldr	r3, [r3, #32]
 8019bfe:	68ba      	ldr	r2, [r7, #8]
 8019c00:	68d2      	ldr	r2, [r2, #12]
 8019c02:	fbb3 f1f2 	udiv	r1, r3, r2
 8019c06:	fb01 f202 	mul.w	r2, r1, r2
 8019c0a:	1a9b      	subs	r3, r3, r2
 8019c0c:	60fb      	str	r3, [r7, #12]
    if (tmp == 0) tmp = compptr->v_samp_factor;
 8019c0e:	68fb      	ldr	r3, [r7, #12]
 8019c10:	2b00      	cmp	r3, #0
 8019c12:	d102      	bne.n	8019c1a <per_scan_setup+0x6e>
 8019c14:	68bb      	ldr	r3, [r7, #8]
 8019c16:	68db      	ldr	r3, [r3, #12]
 8019c18:	60fb      	str	r3, [r7, #12]
    compptr->last_row_height = tmp;
 8019c1a:	68bb      	ldr	r3, [r7, #8]
 8019c1c:	68fa      	ldr	r2, [r7, #12]
 8019c1e:	64da      	str	r2, [r3, #76]	@ 0x4c
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
 8019c20:	687b      	ldr	r3, [r7, #4]
 8019c22:	2201      	movs	r2, #1
 8019c24:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
    cinfo->MCU_membership[0] = 0;
 8019c28:	687b      	ldr	r3, [r7, #4]
 8019c2a:	2200      	movs	r2, #0
 8019c2c:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }
}
 8019c30:	e0bc      	b.n	8019dac <per_scan_setup+0x200>
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
 8019c32:	687b      	ldr	r3, [r7, #4]
 8019c34:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019c38:	2b00      	cmp	r3, #0
 8019c3a:	dd04      	ble.n	8019c46 <per_scan_setup+0x9a>
 8019c3c:	687b      	ldr	r3, [r7, #4]
 8019c3e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019c42:	2b04      	cmp	r3, #4
 8019c44:	dd12      	ble.n	8019c6c <per_scan_setup+0xc0>
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
 8019c46:	687b      	ldr	r3, [r7, #4]
 8019c48:	681b      	ldr	r3, [r3, #0]
 8019c4a:	221b      	movs	r2, #27
 8019c4c:	615a      	str	r2, [r3, #20]
 8019c4e:	687b      	ldr	r3, [r7, #4]
 8019c50:	681b      	ldr	r3, [r3, #0]
 8019c52:	687a      	ldr	r2, [r7, #4]
 8019c54:	f8d2 2150 	ldr.w	r2, [r2, #336]	@ 0x150
 8019c58:	619a      	str	r2, [r3, #24]
 8019c5a:	687b      	ldr	r3, [r7, #4]
 8019c5c:	681b      	ldr	r3, [r3, #0]
 8019c5e:	2204      	movs	r2, #4
 8019c60:	61da      	str	r2, [r3, #28]
 8019c62:	687b      	ldr	r3, [r7, #4]
 8019c64:	681b      	ldr	r3, [r3, #0]
 8019c66:	681b      	ldr	r3, [r3, #0]
 8019c68:	6878      	ldr	r0, [r7, #4]
 8019c6a:	4798      	blx	r3
      jdiv_round_up((long) cinfo->image_width,
 8019c6c:	687b      	ldr	r3, [r7, #4]
 8019c6e:	69db      	ldr	r3, [r3, #28]
 8019c70:	4618      	mov	r0, r3
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8019c72:	687b      	ldr	r3, [r7, #4]
 8019c74:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8019c78:	687a      	ldr	r2, [r7, #4]
 8019c7a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019c7e:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width,
 8019c82:	4619      	mov	r1, r3
 8019c84:	f015 fa02 	bl	802f08c <jdiv_round_up>
 8019c88:	4603      	mov	r3, r0
    cinfo->MCUs_per_row = (JDIMENSION)
 8019c8a:	461a      	mov	r2, r3
 8019c8c:	687b      	ldr	r3, [r7, #4]
 8019c8e:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
      jdiv_round_up((long) cinfo->image_height,
 8019c92:	687b      	ldr	r3, [r7, #4]
 8019c94:	6a1b      	ldr	r3, [r3, #32]
 8019c96:	4618      	mov	r0, r3
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8019c98:	687b      	ldr	r3, [r7, #4]
 8019c9a:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8019c9e:	687a      	ldr	r2, [r7, #4]
 8019ca0:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 8019ca4:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height,
 8019ca8:	4619      	mov	r1, r3
 8019caa:	f015 f9ef 	bl	802f08c <jdiv_round_up>
 8019cae:	4603      	mov	r3, r0
    cinfo->MCU_rows_in_scan = (JDIMENSION)
 8019cb0:	461a      	mov	r2, r3
 8019cb2:	687b      	ldr	r3, [r7, #4]
 8019cb4:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
    cinfo->blocks_in_MCU = 0;
 8019cb8:	687b      	ldr	r3, [r7, #4]
 8019cba:	2200      	movs	r2, #0
 8019cbc:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8019cc0:	2300      	movs	r3, #0
 8019cc2:	617b      	str	r3, [r7, #20]
 8019cc4:	e06c      	b.n	8019da0 <per_scan_setup+0x1f4>
      compptr = cinfo->cur_comp_info[ci];
 8019cc6:	687a      	ldr	r2, [r7, #4]
 8019cc8:	697b      	ldr	r3, [r7, #20]
 8019cca:	3354      	adds	r3, #84	@ 0x54
 8019ccc:	009b      	lsls	r3, r3, #2
 8019cce:	4413      	add	r3, r2
 8019cd0:	685b      	ldr	r3, [r3, #4]
 8019cd2:	60bb      	str	r3, [r7, #8]
      compptr->MCU_width = compptr->h_samp_factor;
 8019cd4:	68bb      	ldr	r3, [r7, #8]
 8019cd6:	689a      	ldr	r2, [r3, #8]
 8019cd8:	68bb      	ldr	r3, [r7, #8]
 8019cda:	639a      	str	r2, [r3, #56]	@ 0x38
      compptr->MCU_height = compptr->v_samp_factor;
 8019cdc:	68bb      	ldr	r3, [r7, #8]
 8019cde:	68da      	ldr	r2, [r3, #12]
 8019ce0:	68bb      	ldr	r3, [r7, #8]
 8019ce2:	63da      	str	r2, [r3, #60]	@ 0x3c
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
 8019ce4:	68bb      	ldr	r3, [r7, #8]
 8019ce6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8019ce8:	68ba      	ldr	r2, [r7, #8]
 8019cea:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8019cec:	fb03 f202 	mul.w	r2, r3, r2
 8019cf0:	68bb      	ldr	r3, [r7, #8]
 8019cf2:	641a      	str	r2, [r3, #64]	@ 0x40
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_h_scaled_size;
 8019cf4:	68bb      	ldr	r3, [r7, #8]
 8019cf6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8019cf8:	68ba      	ldr	r2, [r7, #8]
 8019cfa:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8019cfc:	fb03 f202 	mul.w	r2, r3, r2
 8019d00:	68bb      	ldr	r3, [r7, #8]
 8019d02:	645a      	str	r2, [r3, #68]	@ 0x44
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
 8019d04:	68bb      	ldr	r3, [r7, #8]
 8019d06:	69db      	ldr	r3, [r3, #28]
 8019d08:	68ba      	ldr	r2, [r7, #8]
 8019d0a:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8019d0c:	fbb3 f1f2 	udiv	r1, r3, r2
 8019d10:	fb01 f202 	mul.w	r2, r1, r2
 8019d14:	1a9b      	subs	r3, r3, r2
 8019d16:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_width;
 8019d18:	68fb      	ldr	r3, [r7, #12]
 8019d1a:	2b00      	cmp	r3, #0
 8019d1c:	d102      	bne.n	8019d24 <per_scan_setup+0x178>
 8019d1e:	68bb      	ldr	r3, [r7, #8]
 8019d20:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8019d22:	60fb      	str	r3, [r7, #12]
      compptr->last_col_width = tmp;
 8019d24:	68bb      	ldr	r3, [r7, #8]
 8019d26:	68fa      	ldr	r2, [r7, #12]
 8019d28:	649a      	str	r2, [r3, #72]	@ 0x48
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
 8019d2a:	68bb      	ldr	r3, [r7, #8]
 8019d2c:	6a1b      	ldr	r3, [r3, #32]
 8019d2e:	68ba      	ldr	r2, [r7, #8]
 8019d30:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8019d32:	fbb3 f1f2 	udiv	r1, r3, r2
 8019d36:	fb01 f202 	mul.w	r2, r1, r2
 8019d3a:	1a9b      	subs	r3, r3, r2
 8019d3c:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_height;
 8019d3e:	68fb      	ldr	r3, [r7, #12]
 8019d40:	2b00      	cmp	r3, #0
 8019d42:	d102      	bne.n	8019d4a <per_scan_setup+0x19e>
 8019d44:	68bb      	ldr	r3, [r7, #8]
 8019d46:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8019d48:	60fb      	str	r3, [r7, #12]
      compptr->last_row_height = tmp;
 8019d4a:	68bb      	ldr	r3, [r7, #8]
 8019d4c:	68fa      	ldr	r2, [r7, #12]
 8019d4e:	64da      	str	r2, [r3, #76]	@ 0x4c
      mcublks = compptr->MCU_blocks;
 8019d50:	68bb      	ldr	r3, [r7, #8]
 8019d52:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8019d54:	613b      	str	r3, [r7, #16]
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
 8019d56:	687b      	ldr	r3, [r7, #4]
 8019d58:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
 8019d5c:	693b      	ldr	r3, [r7, #16]
 8019d5e:	4413      	add	r3, r2
 8019d60:	2b0a      	cmp	r3, #10
 8019d62:	dd15      	ble.n	8019d90 <per_scan_setup+0x1e4>
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
 8019d64:	687b      	ldr	r3, [r7, #4]
 8019d66:	681b      	ldr	r3, [r3, #0]
 8019d68:	220e      	movs	r2, #14
 8019d6a:	615a      	str	r2, [r3, #20]
 8019d6c:	687b      	ldr	r3, [r7, #4]
 8019d6e:	681b      	ldr	r3, [r3, #0]
 8019d70:	681b      	ldr	r3, [r3, #0]
 8019d72:	6878      	ldr	r0, [r7, #4]
 8019d74:	4798      	blx	r3
      while (mcublks-- > 0) {
 8019d76:	e00b      	b.n	8019d90 <per_scan_setup+0x1e4>
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
 8019d78:	687b      	ldr	r3, [r7, #4]
 8019d7a:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8019d7e:	1c59      	adds	r1, r3, #1
 8019d80:	687a      	ldr	r2, [r7, #4]
 8019d82:	f8c2 116c 	str.w	r1, [r2, #364]	@ 0x16c
 8019d86:	687a      	ldr	r2, [r7, #4]
 8019d88:	335c      	adds	r3, #92	@ 0x5c
 8019d8a:	6979      	ldr	r1, [r7, #20]
 8019d8c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      while (mcublks-- > 0) {
 8019d90:	693b      	ldr	r3, [r7, #16]
 8019d92:	1e5a      	subs	r2, r3, #1
 8019d94:	613a      	str	r2, [r7, #16]
 8019d96:	2b00      	cmp	r3, #0
 8019d98:	dcee      	bgt.n	8019d78 <per_scan_setup+0x1cc>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8019d9a:	697b      	ldr	r3, [r7, #20]
 8019d9c:	3301      	adds	r3, #1
 8019d9e:	617b      	str	r3, [r7, #20]
 8019da0:	687b      	ldr	r3, [r7, #4]
 8019da2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019da6:	697a      	ldr	r2, [r7, #20]
 8019da8:	429a      	cmp	r2, r3
 8019daa:	db8c      	blt.n	8019cc6 <per_scan_setup+0x11a>
}
 8019dac:	bf00      	nop
 8019dae:	3718      	adds	r7, #24
 8019db0:	46bd      	mov	sp, r7
 8019db2:	bd80      	pop	{r7, pc}

08019db4 <latch_quant_tables>:
 * not at the current Q-table slots.
 */

LOCAL(void)
latch_quant_tables (j_decompress_ptr cinfo)
{
 8019db4:	b580      	push	{r7, lr}
 8019db6:	b086      	sub	sp, #24
 8019db8:	af00      	add	r7, sp, #0
 8019dba:	6078      	str	r0, [r7, #4]
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8019dbc:	2300      	movs	r3, #0
 8019dbe:	617b      	str	r3, [r7, #20]
 8019dc0:	e043      	b.n	8019e4a <latch_quant_tables+0x96>
    compptr = cinfo->cur_comp_info[ci];
 8019dc2:	687a      	ldr	r2, [r7, #4]
 8019dc4:	697b      	ldr	r3, [r7, #20]
 8019dc6:	3354      	adds	r3, #84	@ 0x54
 8019dc8:	009b      	lsls	r3, r3, #2
 8019dca:	4413      	add	r3, r2
 8019dcc:	685b      	ldr	r3, [r3, #4]
 8019dce:	613b      	str	r3, [r7, #16]
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
 8019dd0:	693b      	ldr	r3, [r7, #16]
 8019dd2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8019dd4:	2b00      	cmp	r3, #0
 8019dd6:	d134      	bne.n	8019e42 <latch_quant_tables+0x8e>
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
 8019dd8:	693b      	ldr	r3, [r7, #16]
 8019dda:	691b      	ldr	r3, [r3, #16]
 8019ddc:	60fb      	str	r3, [r7, #12]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8019dde:	68fb      	ldr	r3, [r7, #12]
 8019de0:	2b00      	cmp	r3, #0
 8019de2:	db0a      	blt.n	8019dfa <latch_quant_tables+0x46>
 8019de4:	68fb      	ldr	r3, [r7, #12]
 8019de6:	2b03      	cmp	r3, #3
 8019de8:	dc07      	bgt.n	8019dfa <latch_quant_tables+0x46>
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
 8019dea:	687a      	ldr	r2, [r7, #4]
 8019dec:	68fb      	ldr	r3, [r7, #12]
 8019dee:	3328      	adds	r3, #40	@ 0x28
 8019df0:	009b      	lsls	r3, r3, #2
 8019df2:	4413      	add	r3, r2
 8019df4:	685b      	ldr	r3, [r3, #4]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8019df6:	2b00      	cmp	r3, #0
 8019df8:	d10c      	bne.n	8019e14 <latch_quant_tables+0x60>
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
 8019dfa:	687b      	ldr	r3, [r7, #4]
 8019dfc:	681b      	ldr	r3, [r3, #0]
 8019dfe:	2236      	movs	r2, #54	@ 0x36
 8019e00:	615a      	str	r2, [r3, #20]
 8019e02:	687b      	ldr	r3, [r7, #4]
 8019e04:	681b      	ldr	r3, [r3, #0]
 8019e06:	68fa      	ldr	r2, [r7, #12]
 8019e08:	619a      	str	r2, [r3, #24]
 8019e0a:	687b      	ldr	r3, [r7, #4]
 8019e0c:	681b      	ldr	r3, [r3, #0]
 8019e0e:	681b      	ldr	r3, [r3, #0]
 8019e10:	6878      	ldr	r0, [r7, #4]
 8019e12:	4798      	blx	r3
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8019e14:	687b      	ldr	r3, [r7, #4]
 8019e16:	685b      	ldr	r3, [r3, #4]
 8019e18:	681b      	ldr	r3, [r3, #0]
 8019e1a:	2284      	movs	r2, #132	@ 0x84
 8019e1c:	2101      	movs	r1, #1
 8019e1e:	6878      	ldr	r0, [r7, #4]
 8019e20:	4798      	blx	r3
 8019e22:	60b8      	str	r0, [r7, #8]
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
 8019e24:	687a      	ldr	r2, [r7, #4]
 8019e26:	68fb      	ldr	r3, [r7, #12]
 8019e28:	3328      	adds	r3, #40	@ 0x28
 8019e2a:	009b      	lsls	r3, r3, #2
 8019e2c:	4413      	add	r3, r2
 8019e2e:	685b      	ldr	r3, [r3, #4]
 8019e30:	2284      	movs	r2, #132	@ 0x84
 8019e32:	4619      	mov	r1, r3
 8019e34:	68b8      	ldr	r0, [r7, #8]
 8019e36:	f015 fdf7 	bl	802fa28 <memcpy>
    compptr->quant_table = qtbl;
 8019e3a:	693b      	ldr	r3, [r7, #16]
 8019e3c:	68ba      	ldr	r2, [r7, #8]
 8019e3e:	651a      	str	r2, [r3, #80]	@ 0x50
 8019e40:	e000      	b.n	8019e44 <latch_quant_tables+0x90>
      continue;
 8019e42:	bf00      	nop
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8019e44:	697b      	ldr	r3, [r7, #20]
 8019e46:	3301      	adds	r3, #1
 8019e48:	617b      	str	r3, [r7, #20]
 8019e4a:	687b      	ldr	r3, [r7, #4]
 8019e4c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019e50:	697a      	ldr	r2, [r7, #20]
 8019e52:	429a      	cmp	r2, r3
 8019e54:	dbb5      	blt.n	8019dc2 <latch_quant_tables+0xe>
  }
}
 8019e56:	bf00      	nop
 8019e58:	bf00      	nop
 8019e5a:	3718      	adds	r7, #24
 8019e5c:	46bd      	mov	sp, r7
 8019e5e:	bd80      	pop	{r7, pc}

08019e60 <start_input_pass>:
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 8019e60:	b580      	push	{r7, lr}
 8019e62:	b082      	sub	sp, #8
 8019e64:	af00      	add	r7, sp, #0
 8019e66:	6078      	str	r0, [r7, #4]
  per_scan_setup(cinfo);
 8019e68:	6878      	ldr	r0, [r7, #4]
 8019e6a:	f7ff fe9f 	bl	8019bac <per_scan_setup>
  latch_quant_tables(cinfo);
 8019e6e:	6878      	ldr	r0, [r7, #4]
 8019e70:	f7ff ffa0 	bl	8019db4 <latch_quant_tables>
  (*cinfo->entropy->start_pass) (cinfo);
 8019e74:	687b      	ldr	r3, [r7, #4]
 8019e76:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 8019e7a:	681b      	ldr	r3, [r3, #0]
 8019e7c:	6878      	ldr	r0, [r7, #4]
 8019e7e:	4798      	blx	r3
  (*cinfo->coef->start_input_pass) (cinfo);
 8019e80:	687b      	ldr	r3, [r7, #4]
 8019e82:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 8019e86:	681b      	ldr	r3, [r3, #0]
 8019e88:	6878      	ldr	r0, [r7, #4]
 8019e8a:	4798      	blx	r3
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
 8019e8c:	687b      	ldr	r3, [r7, #4]
 8019e8e:	f8d3 21c0 	ldr.w	r2, [r3, #448]	@ 0x1c0
 8019e92:	687b      	ldr	r3, [r7, #4]
 8019e94:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019e98:	6852      	ldr	r2, [r2, #4]
 8019e9a:	601a      	str	r2, [r3, #0]
}
 8019e9c:	bf00      	nop
 8019e9e:	3708      	adds	r7, #8
 8019ea0:	46bd      	mov	sp, r7
 8019ea2:	bd80      	pop	{r7, pc}

08019ea4 <finish_input_pass>:
 * the expected data of the scan.
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
 8019ea4:	b480      	push	{r7}
 8019ea6:	b083      	sub	sp, #12
 8019ea8:	af00      	add	r7, sp, #0
 8019eaa:	6078      	str	r0, [r7, #4]
  cinfo->inputctl->consume_input = consume_markers;
 8019eac:	687b      	ldr	r3, [r7, #4]
 8019eae:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019eb2:	4a04      	ldr	r2, [pc, #16]	@ (8019ec4 <finish_input_pass+0x20>)
 8019eb4:	601a      	str	r2, [r3, #0]
}
 8019eb6:	bf00      	nop
 8019eb8:	370c      	adds	r7, #12
 8019eba:	46bd      	mov	sp, r7
 8019ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019ec0:	4770      	bx	lr
 8019ec2:	bf00      	nop
 8019ec4:	08019ec9 	.word	0x08019ec9

08019ec8 <consume_markers>:
 * read_markers is processed and then skipped for other markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
 8019ec8:	b580      	push	{r7, lr}
 8019eca:	b084      	sub	sp, #16
 8019ecc:	af00      	add	r7, sp, #0
 8019ece:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8019ed0:	687b      	ldr	r3, [r7, #4]
 8019ed2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019ed6:	60fb      	str	r3, [r7, #12]
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
 8019ed8:	68fb      	ldr	r3, [r7, #12]
 8019eda:	695b      	ldr	r3, [r3, #20]
 8019edc:	2b00      	cmp	r3, #0
 8019ede:	d001      	beq.n	8019ee4 <consume_markers+0x1c>
    return JPEG_REACHED_EOI;
 8019ee0:	2302      	movs	r3, #2
 8019ee2:	e06e      	b.n	8019fc2 <consume_markers+0xfa>

  for (;;) {			/* Loop to pass pseudo SOS marker */
    val = (*cinfo->marker->read_markers) (cinfo);
 8019ee4:	687b      	ldr	r3, [r7, #4]
 8019ee6:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8019eea:	685b      	ldr	r3, [r3, #4]
 8019eec:	6878      	ldr	r0, [r7, #4]
 8019eee:	4798      	blx	r3
 8019ef0:	60b8      	str	r0, [r7, #8]

    switch (val) {
 8019ef2:	68bb      	ldr	r3, [r7, #8]
 8019ef4:	2b02      	cmp	r3, #2
 8019ef6:	d037      	beq.n	8019f68 <consume_markers+0xa0>
 8019ef8:	68bb      	ldr	r3, [r7, #8]
 8019efa:	2b02      	cmp	r3, #2
 8019efc:	dc5d      	bgt.n	8019fba <consume_markers+0xf2>
 8019efe:	68bb      	ldr	r3, [r7, #8]
 8019f00:	2b00      	cmp	r3, #0
 8019f02:	d058      	beq.n	8019fb6 <consume_markers+0xee>
 8019f04:	68bb      	ldr	r3, [r7, #8]
 8019f06:	2b01      	cmp	r3, #1
 8019f08:	d157      	bne.n	8019fba <consume_markers+0xf2>
    case JPEG_REACHED_SOS:	/* Found SOS */
      if (inputctl->inheaders) { /* 1st SOS */
 8019f0a:	68fb      	ldr	r3, [r7, #12]
 8019f0c:	699b      	ldr	r3, [r3, #24]
 8019f0e:	2b00      	cmp	r3, #0
 8019f10:	d013      	beq.n	8019f3a <consume_markers+0x72>
	if (inputctl->inheaders == 1)
 8019f12:	68fb      	ldr	r3, [r7, #12]
 8019f14:	699b      	ldr	r3, [r3, #24]
 8019f16:	2b01      	cmp	r3, #1
 8019f18:	d102      	bne.n	8019f20 <consume_markers+0x58>
	  initial_setup(cinfo);
 8019f1a:	6878      	ldr	r0, [r7, #4]
 8019f1c:	f7ff fb1c 	bl	8019558 <initial_setup>
	if (cinfo->comps_in_scan == 0) { /* pseudo SOS marker */
 8019f20:	687b      	ldr	r3, [r7, #4]
 8019f22:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019f26:	2b00      	cmp	r3, #0
 8019f28:	d103      	bne.n	8019f32 <consume_markers+0x6a>
	  inputctl->inheaders = 2;
 8019f2a:	68fb      	ldr	r3, [r7, #12]
 8019f2c:	2202      	movs	r2, #2
 8019f2e:	619a      	str	r2, [r3, #24]
	  break;
 8019f30:	e046      	b.n	8019fc0 <consume_markers+0xf8>
	}
	inputctl->inheaders = 0;
 8019f32:	68fb      	ldr	r3, [r7, #12]
 8019f34:	2200      	movs	r2, #0
 8019f36:	619a      	str	r2, [r3, #24]
 8019f38:	e014      	b.n	8019f64 <consume_markers+0x9c>
	/* Note: start_input_pass must be called by jdmaster.c
	 * before any more input can be consumed.  jdapimin.c is
	 * responsible for enforcing this sequencing.
	 */
      } else {			/* 2nd or later SOS marker */
	if (! inputctl->pub.has_multiple_scans)
 8019f3a:	68fb      	ldr	r3, [r7, #12]
 8019f3c:	691b      	ldr	r3, [r3, #16]
 8019f3e:	2b00      	cmp	r3, #0
 8019f40:	d108      	bne.n	8019f54 <consume_markers+0x8c>
	  ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
 8019f42:	687b      	ldr	r3, [r7, #4]
 8019f44:	681b      	ldr	r3, [r3, #0]
 8019f46:	2224      	movs	r2, #36	@ 0x24
 8019f48:	615a      	str	r2, [r3, #20]
 8019f4a:	687b      	ldr	r3, [r7, #4]
 8019f4c:	681b      	ldr	r3, [r3, #0]
 8019f4e:	681b      	ldr	r3, [r3, #0]
 8019f50:	6878      	ldr	r0, [r7, #4]
 8019f52:	4798      	blx	r3
	if (cinfo->comps_in_scan == 0) /* unexpected pseudo SOS marker */
 8019f54:	687b      	ldr	r3, [r7, #4]
 8019f56:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8019f5a:	2b00      	cmp	r3, #0
 8019f5c:	d02f      	beq.n	8019fbe <consume_markers+0xf6>
	  break;
	start_input_pass(cinfo);
 8019f5e:	6878      	ldr	r0, [r7, #4]
 8019f60:	f7ff ff7e 	bl	8019e60 <start_input_pass>
      }
      return val;
 8019f64:	68bb      	ldr	r3, [r7, #8]
 8019f66:	e02c      	b.n	8019fc2 <consume_markers+0xfa>
    case JPEG_REACHED_EOI:	/* Found EOI */
      inputctl->pub.eoi_reached = TRUE;
 8019f68:	68fb      	ldr	r3, [r7, #12]
 8019f6a:	2201      	movs	r2, #1
 8019f6c:	615a      	str	r2, [r3, #20]
      if (inputctl->inheaders) { /* Tables-only datastream, apparently */
 8019f6e:	68fb      	ldr	r3, [r7, #12]
 8019f70:	699b      	ldr	r3, [r3, #24]
 8019f72:	2b00      	cmp	r3, #0
 8019f74:	d00f      	beq.n	8019f96 <consume_markers+0xce>
	if (cinfo->marker->saw_SOF)
 8019f76:	687b      	ldr	r3, [r7, #4]
 8019f78:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 8019f7c:	691b      	ldr	r3, [r3, #16]
 8019f7e:	2b00      	cmp	r3, #0
 8019f80:	d017      	beq.n	8019fb2 <consume_markers+0xea>
	  ERREXIT(cinfo, JERR_SOF_NO_SOS);
 8019f82:	687b      	ldr	r3, [r7, #4]
 8019f84:	681b      	ldr	r3, [r3, #0]
 8019f86:	223d      	movs	r2, #61	@ 0x3d
 8019f88:	615a      	str	r2, [r3, #20]
 8019f8a:	687b      	ldr	r3, [r7, #4]
 8019f8c:	681b      	ldr	r3, [r3, #0]
 8019f8e:	681b      	ldr	r3, [r3, #0]
 8019f90:	6878      	ldr	r0, [r7, #4]
 8019f92:	4798      	blx	r3
 8019f94:	e00d      	b.n	8019fb2 <consume_markers+0xea>
      } else {
	/* Prevent infinite loop in coef ctlr's decompress_data routine
	 * if user set output_scan_number larger than number of scans.
	 */
	if (cinfo->output_scan_number > cinfo->input_scan_number)
 8019f96:	687b      	ldr	r3, [r7, #4]
 8019f98:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 8019f9c:	687b      	ldr	r3, [r7, #4]
 8019f9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8019fa2:	429a      	cmp	r2, r3
 8019fa4:	dd05      	ble.n	8019fb2 <consume_markers+0xea>
	  cinfo->output_scan_number = cinfo->input_scan_number;
 8019fa6:	687b      	ldr	r3, [r7, #4]
 8019fa8:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8019fac:	687b      	ldr	r3, [r7, #4]
 8019fae:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
      }
      return val;
 8019fb2:	68bb      	ldr	r3, [r7, #8]
 8019fb4:	e005      	b.n	8019fc2 <consume_markers+0xfa>
    case JPEG_SUSPENDED:
      return val;
 8019fb6:	68bb      	ldr	r3, [r7, #8]
 8019fb8:	e003      	b.n	8019fc2 <consume_markers+0xfa>
    default:
      return val;
 8019fba:	68bb      	ldr	r3, [r7, #8]
 8019fbc:	e001      	b.n	8019fc2 <consume_markers+0xfa>
	  break;
 8019fbe:	bf00      	nop
    val = (*cinfo->marker->read_markers) (cinfo);
 8019fc0:	e790      	b.n	8019ee4 <consume_markers+0x1c>
    }
  }
}
 8019fc2:	4618      	mov	r0, r3
 8019fc4:	3710      	adds	r7, #16
 8019fc6:	46bd      	mov	sp, r7
 8019fc8:	bd80      	pop	{r7, pc}
	...

08019fcc <reset_input_controller>:
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
 8019fcc:	b580      	push	{r7, lr}
 8019fce:	b084      	sub	sp, #16
 8019fd0:	af00      	add	r7, sp, #0
 8019fd2:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8019fd4:	687b      	ldr	r3, [r7, #4]
 8019fd6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 8019fda:	60fb      	str	r3, [r7, #12]

  inputctl->pub.consume_input = consume_markers;
 8019fdc:	68fb      	ldr	r3, [r7, #12]
 8019fde:	4a0f      	ldr	r2, [pc, #60]	@ (801a01c <reset_input_controller+0x50>)
 8019fe0:	601a      	str	r2, [r3, #0]
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 8019fe2:	68fb      	ldr	r3, [r7, #12]
 8019fe4:	2200      	movs	r2, #0
 8019fe6:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 8019fe8:	68fb      	ldr	r3, [r7, #12]
 8019fea:	2200      	movs	r2, #0
 8019fec:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 8019fee:	68fb      	ldr	r3, [r7, #12]
 8019ff0:	2201      	movs	r2, #1
 8019ff2:	619a      	str	r2, [r3, #24]
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
 8019ff4:	687b      	ldr	r3, [r7, #4]
 8019ff6:	681b      	ldr	r3, [r3, #0]
 8019ff8:	691b      	ldr	r3, [r3, #16]
 8019ffa:	6878      	ldr	r0, [r7, #4]
 8019ffc:	4798      	blx	r3
  (*cinfo->marker->reset_marker_reader) (cinfo);
 8019ffe:	687b      	ldr	r3, [r7, #4]
 801a000:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a004:	681b      	ldr	r3, [r3, #0]
 801a006:	6878      	ldr	r0, [r7, #4]
 801a008:	4798      	blx	r3
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
 801a00a:	687b      	ldr	r3, [r7, #4]
 801a00c:	2200      	movs	r2, #0
 801a00e:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
}
 801a012:	bf00      	nop
 801a014:	3710      	adds	r7, #16
 801a016:	46bd      	mov	sp, r7
 801a018:	bd80      	pop	{r7, pc}
 801a01a:	bf00      	nop
 801a01c:	08019ec9 	.word	0x08019ec9

0801a020 <jinit_input_controller>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
 801a020:	b580      	push	{r7, lr}
 801a022:	b084      	sub	sp, #16
 801a024:	af00      	add	r7, sp, #0
 801a026:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 801a028:	687b      	ldr	r3, [r7, #4]
 801a02a:	685b      	ldr	r3, [r3, #4]
 801a02c:	681b      	ldr	r3, [r3, #0]
 801a02e:	221c      	movs	r2, #28
 801a030:	2100      	movs	r1, #0
 801a032:	6878      	ldr	r0, [r7, #4]
 801a034:	4798      	blx	r3
 801a036:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
 801a038:	687b      	ldr	r3, [r7, #4]
 801a03a:	68fa      	ldr	r2, [r7, #12]
 801a03c:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
 801a040:	68fb      	ldr	r3, [r7, #12]
 801a042:	4a0c      	ldr	r2, [pc, #48]	@ (801a074 <jinit_input_controller+0x54>)
 801a044:	601a      	str	r2, [r3, #0]
  inputctl->pub.reset_input_controller = reset_input_controller;
 801a046:	68fb      	ldr	r3, [r7, #12]
 801a048:	4a0b      	ldr	r2, [pc, #44]	@ (801a078 <jinit_input_controller+0x58>)
 801a04a:	605a      	str	r2, [r3, #4]
  inputctl->pub.start_input_pass = start_input_pass;
 801a04c:	68fb      	ldr	r3, [r7, #12]
 801a04e:	4a0b      	ldr	r2, [pc, #44]	@ (801a07c <jinit_input_controller+0x5c>)
 801a050:	609a      	str	r2, [r3, #8]
  inputctl->pub.finish_input_pass = finish_input_pass;
 801a052:	68fb      	ldr	r3, [r7, #12]
 801a054:	4a0a      	ldr	r2, [pc, #40]	@ (801a080 <jinit_input_controller+0x60>)
 801a056:	60da      	str	r2, [r3, #12]
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 801a058:	68fb      	ldr	r3, [r7, #12]
 801a05a:	2200      	movs	r2, #0
 801a05c:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 801a05e:	68fb      	ldr	r3, [r7, #12]
 801a060:	2200      	movs	r2, #0
 801a062:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 801a064:	68fb      	ldr	r3, [r7, #12]
 801a066:	2201      	movs	r2, #1
 801a068:	619a      	str	r2, [r3, #24]
}
 801a06a:	bf00      	nop
 801a06c:	3710      	adds	r7, #16
 801a06e:	46bd      	mov	sp, r7
 801a070:	bd80      	pop	{r7, pc}
 801a072:	bf00      	nop
 801a074:	08019ec9 	.word	0x08019ec9
 801a078:	08019fcd 	.word	0x08019fcd
 801a07c:	08019e61 	.word	0x08019e61
 801a080:	08019ea5 	.word	0x08019ea5

0801a084 <alloc_funny_pointers>:
LOCAL(void)
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
 801a084:	b580      	push	{r7, lr}
 801a086:	b088      	sub	sp, #32
 801a088:	af00      	add	r7, sp, #0
 801a08a:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a08c:	687b      	ldr	r3, [r7, #4]
 801a08e:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a092:	617b      	str	r3, [r7, #20]
  int ci, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 801a094:	687b      	ldr	r3, [r7, #4]
 801a096:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a09a:	613b      	str	r3, [r7, #16]

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801a09c:	687b      	ldr	r3, [r7, #4]
 801a09e:	685b      	ldr	r3, [r3, #4]
 801a0a0:	681b      	ldr	r3, [r3, #0]
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
 801a0a2:	687a      	ldr	r2, [r7, #4]
 801a0a4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801a0a6:	00d2      	lsls	r2, r2, #3
 801a0a8:	2101      	movs	r1, #1
 801a0aa:	6878      	ldr	r0, [r7, #4]
 801a0ac:	4798      	blx	r3
 801a0ae:	4602      	mov	r2, r0
  main->xbuffer[0] = (JSAMPIMAGE)
 801a0b0:	697b      	ldr	r3, [r7, #20]
 801a0b2:	639a      	str	r2, [r3, #56]	@ 0x38
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
 801a0b4:	697b      	ldr	r3, [r7, #20]
 801a0b6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801a0b8:	687b      	ldr	r3, [r7, #4]
 801a0ba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a0bc:	009b      	lsls	r3, r3, #2
 801a0be:	441a      	add	r2, r3
 801a0c0:	697b      	ldr	r3, [r7, #20]
 801a0c2:	63da      	str	r2, [r3, #60]	@ 0x3c

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a0c4:	2300      	movs	r3, #0
 801a0c6:	61fb      	str	r3, [r7, #28]
 801a0c8:	687b      	ldr	r3, [r7, #4]
 801a0ca:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a0ce:	61bb      	str	r3, [r7, #24]
 801a0d0:	e03a      	b.n	801a148 <alloc_funny_pointers+0xc4>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a0d2:	69bb      	ldr	r3, [r7, #24]
 801a0d4:	68db      	ldr	r3, [r3, #12]
 801a0d6:	69ba      	ldr	r2, [r7, #24]
 801a0d8:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801a0da:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801a0de:	687b      	ldr	r3, [r7, #4]
 801a0e0:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a0e4:	fb92 f3f3 	sdiv	r3, r2, r3
 801a0e8:	60fb      	str	r3, [r7, #12]
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801a0ea:	687b      	ldr	r3, [r7, #4]
 801a0ec:	685b      	ldr	r3, [r3, #4]
 801a0ee:	681b      	ldr	r3, [r3, #0]
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
 801a0f0:	693a      	ldr	r2, [r7, #16]
 801a0f2:	3204      	adds	r2, #4
 801a0f4:	68f9      	ldr	r1, [r7, #12]
 801a0f6:	fb01 f202 	mul.w	r2, r1, r2
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801a0fa:	00d2      	lsls	r2, r2, #3
 801a0fc:	2101      	movs	r1, #1
 801a0fe:	6878      	ldr	r0, [r7, #4]
 801a100:	4798      	blx	r3
 801a102:	60b8      	str	r0, [r7, #8]
    xbuf += rgroup;		/* want one row group at negative offsets */
 801a104:	68fb      	ldr	r3, [r7, #12]
 801a106:	009b      	lsls	r3, r3, #2
 801a108:	68ba      	ldr	r2, [r7, #8]
 801a10a:	4413      	add	r3, r2
 801a10c:	60bb      	str	r3, [r7, #8]
    main->xbuffer[0][ci] = xbuf;
 801a10e:	697b      	ldr	r3, [r7, #20]
 801a110:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801a112:	69fb      	ldr	r3, [r7, #28]
 801a114:	009b      	lsls	r3, r3, #2
 801a116:	4413      	add	r3, r2
 801a118:	68ba      	ldr	r2, [r7, #8]
 801a11a:	601a      	str	r2, [r3, #0]
    xbuf += rgroup * (M + 4);
 801a11c:	693b      	ldr	r3, [r7, #16]
 801a11e:	3304      	adds	r3, #4
 801a120:	68fa      	ldr	r2, [r7, #12]
 801a122:	fb02 f303 	mul.w	r3, r2, r3
 801a126:	009b      	lsls	r3, r3, #2
 801a128:	68ba      	ldr	r2, [r7, #8]
 801a12a:	4413      	add	r3, r2
 801a12c:	60bb      	str	r3, [r7, #8]
    main->xbuffer[1][ci] = xbuf;
 801a12e:	697b      	ldr	r3, [r7, #20]
 801a130:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801a132:	69fb      	ldr	r3, [r7, #28]
 801a134:	009b      	lsls	r3, r3, #2
 801a136:	4413      	add	r3, r2
 801a138:	68ba      	ldr	r2, [r7, #8]
 801a13a:	601a      	str	r2, [r3, #0]
       ci++, compptr++) {
 801a13c:	69fb      	ldr	r3, [r7, #28]
 801a13e:	3301      	adds	r3, #1
 801a140:	61fb      	str	r3, [r7, #28]
 801a142:	69bb      	ldr	r3, [r7, #24]
 801a144:	3358      	adds	r3, #88	@ 0x58
 801a146:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a148:	687b      	ldr	r3, [r7, #4]
 801a14a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a14c:	69fa      	ldr	r2, [r7, #28]
 801a14e:	429a      	cmp	r2, r3
 801a150:	dbbf      	blt.n	801a0d2 <alloc_funny_pointers+0x4e>
  }
}
 801a152:	bf00      	nop
 801a154:	bf00      	nop
 801a156:	3720      	adds	r7, #32
 801a158:	46bd      	mov	sp, r7
 801a15a:	bd80      	pop	{r7, pc}

0801a15c <make_funny_pointers>:
 * The actual workspace is already allocated (in main->buffer),
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
 801a15c:	b480      	push	{r7}
 801a15e:	b08d      	sub	sp, #52	@ 0x34
 801a160:	af00      	add	r7, sp, #0
 801a162:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a164:	687b      	ldr	r3, [r7, #4]
 801a166:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a16a:	623b      	str	r3, [r7, #32]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 801a16c:	687b      	ldr	r3, [r7, #4]
 801a16e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a172:	61fb      	str	r3, [r7, #28]
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a174:	2300      	movs	r3, #0
 801a176:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801a178:	687b      	ldr	r3, [r7, #4]
 801a17a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a17e:	627b      	str	r3, [r7, #36]	@ 0x24
 801a180:	e08b      	b.n	801a29a <make_funny_pointers+0x13e>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a182:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a184:	68db      	ldr	r3, [r3, #12]
 801a186:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801a188:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801a18a:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801a18e:	687b      	ldr	r3, [r7, #4]
 801a190:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a194:	fb92 f3f3 	sdiv	r3, r2, r3
 801a198:	61bb      	str	r3, [r7, #24]
    xbuf0 = main->xbuffer[0][ci];
 801a19a:	6a3b      	ldr	r3, [r7, #32]
 801a19c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801a19e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a1a0:	009b      	lsls	r3, r3, #2
 801a1a2:	4413      	add	r3, r2
 801a1a4:	681b      	ldr	r3, [r3, #0]
 801a1a6:	617b      	str	r3, [r7, #20]
    xbuf1 = main->xbuffer[1][ci];
 801a1a8:	6a3b      	ldr	r3, [r7, #32]
 801a1aa:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801a1ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a1ae:	009b      	lsls	r3, r3, #2
 801a1b0:	4413      	add	r3, r2
 801a1b2:	681b      	ldr	r3, [r3, #0]
 801a1b4:	613b      	str	r3, [r7, #16]
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
 801a1b6:	6a3b      	ldr	r3, [r7, #32]
 801a1b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801a1ba:	3202      	adds	r2, #2
 801a1bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a1c0:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < rgroup * (M + 2); i++) {
 801a1c2:	2300      	movs	r3, #0
 801a1c4:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a1c6:	e012      	b.n	801a1ee <make_funny_pointers+0x92>
      xbuf0[i] = xbuf1[i] = buf[i];
 801a1c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a1ca:	009b      	lsls	r3, r3, #2
 801a1cc:	68fa      	ldr	r2, [r7, #12]
 801a1ce:	441a      	add	r2, r3
 801a1d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a1d2:	009b      	lsls	r3, r3, #2
 801a1d4:	6939      	ldr	r1, [r7, #16]
 801a1d6:	440b      	add	r3, r1
 801a1d8:	6812      	ldr	r2, [r2, #0]
 801a1da:	601a      	str	r2, [r3, #0]
 801a1dc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a1de:	0092      	lsls	r2, r2, #2
 801a1e0:	6979      	ldr	r1, [r7, #20]
 801a1e2:	440a      	add	r2, r1
 801a1e4:	681b      	ldr	r3, [r3, #0]
 801a1e6:	6013      	str	r3, [r2, #0]
    for (i = 0; i < rgroup * (M + 2); i++) {
 801a1e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a1ea:	3301      	adds	r3, #1
 801a1ec:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a1ee:	69fb      	ldr	r3, [r7, #28]
 801a1f0:	3302      	adds	r3, #2
 801a1f2:	69ba      	ldr	r2, [r7, #24]
 801a1f4:	fb02 f303 	mul.w	r3, r2, r3
 801a1f8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a1fa:	429a      	cmp	r2, r3
 801a1fc:	dbe4      	blt.n	801a1c8 <make_funny_pointers+0x6c>
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
 801a1fe:	2300      	movs	r3, #0
 801a200:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a202:	e02c      	b.n	801a25e <make_funny_pointers+0x102>
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
 801a204:	69bb      	ldr	r3, [r7, #24]
 801a206:	69fa      	ldr	r2, [r7, #28]
 801a208:	fb03 f202 	mul.w	r2, r3, r2
 801a20c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a20e:	4413      	add	r3, r2
 801a210:	009b      	lsls	r3, r3, #2
 801a212:	68fa      	ldr	r2, [r7, #12]
 801a214:	441a      	add	r2, r3
 801a216:	69fb      	ldr	r3, [r7, #28]
 801a218:	3b02      	subs	r3, #2
 801a21a:	69b9      	ldr	r1, [r7, #24]
 801a21c:	fb03 f101 	mul.w	r1, r3, r1
 801a220:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a222:	440b      	add	r3, r1
 801a224:	009b      	lsls	r3, r3, #2
 801a226:	6939      	ldr	r1, [r7, #16]
 801a228:	440b      	add	r3, r1
 801a22a:	6812      	ldr	r2, [r2, #0]
 801a22c:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
 801a22e:	69fb      	ldr	r3, [r7, #28]
 801a230:	3b02      	subs	r3, #2
 801a232:	69ba      	ldr	r2, [r7, #24]
 801a234:	fb03 f202 	mul.w	r2, r3, r2
 801a238:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a23a:	4413      	add	r3, r2
 801a23c:	009b      	lsls	r3, r3, #2
 801a23e:	68fa      	ldr	r2, [r7, #12]
 801a240:	441a      	add	r2, r3
 801a242:	69bb      	ldr	r3, [r7, #24]
 801a244:	69f9      	ldr	r1, [r7, #28]
 801a246:	fb03 f101 	mul.w	r1, r3, r1
 801a24a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a24c:	440b      	add	r3, r1
 801a24e:	009b      	lsls	r3, r3, #2
 801a250:	6939      	ldr	r1, [r7, #16]
 801a252:	440b      	add	r3, r1
 801a254:	6812      	ldr	r2, [r2, #0]
 801a256:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 801a258:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a25a:	3301      	adds	r3, #1
 801a25c:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a25e:	69bb      	ldr	r3, [r7, #24]
 801a260:	005b      	lsls	r3, r3, #1
 801a262:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a264:	429a      	cmp	r2, r3
 801a266:	dbcd      	blt.n	801a204 <make_funny_pointers+0xa8>
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
 801a268:	2300      	movs	r3, #0
 801a26a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a26c:	e00b      	b.n	801a286 <make_funny_pointers+0x12a>
      xbuf0[i - rgroup] = xbuf0[0];
 801a26e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a270:	69bb      	ldr	r3, [r7, #24]
 801a272:	1ad3      	subs	r3, r2, r3
 801a274:	009b      	lsls	r3, r3, #2
 801a276:	697a      	ldr	r2, [r7, #20]
 801a278:	4413      	add	r3, r2
 801a27a:	697a      	ldr	r2, [r7, #20]
 801a27c:	6812      	ldr	r2, [r2, #0]
 801a27e:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 801a280:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a282:	3301      	adds	r3, #1
 801a284:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a286:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a288:	69bb      	ldr	r3, [r7, #24]
 801a28a:	429a      	cmp	r2, r3
 801a28c:	dbef      	blt.n	801a26e <make_funny_pointers+0x112>
       ci++, compptr++) {
 801a28e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a290:	3301      	adds	r3, #1
 801a292:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801a294:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a296:	3358      	adds	r3, #88	@ 0x58
 801a298:	627b      	str	r3, [r7, #36]	@ 0x24
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a29a:	687b      	ldr	r3, [r7, #4]
 801a29c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a29e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801a2a0:	429a      	cmp	r2, r3
 801a2a2:	f6ff af6e 	blt.w	801a182 <make_funny_pointers+0x26>
    }
  }
}
 801a2a6:	bf00      	nop
 801a2a8:	bf00      	nop
 801a2aa:	3734      	adds	r7, #52	@ 0x34
 801a2ac:	46bd      	mov	sp, r7
 801a2ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a2b2:	4770      	bx	lr

0801a2b4 <set_wraparound_pointers>:
LOCAL(void)
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
 801a2b4:	b480      	push	{r7}
 801a2b6:	b08b      	sub	sp, #44	@ 0x2c
 801a2b8:	af00      	add	r7, sp, #0
 801a2ba:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a2bc:	687b      	ldr	r3, [r7, #4]
 801a2be:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a2c2:	61bb      	str	r3, [r7, #24]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 801a2c4:	687b      	ldr	r3, [r7, #4]
 801a2c6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a2ca:	617b      	str	r3, [r7, #20]
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a2cc:	2300      	movs	r3, #0
 801a2ce:	627b      	str	r3, [r7, #36]	@ 0x24
 801a2d0:	687b      	ldr	r3, [r7, #4]
 801a2d2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a2d6:	61fb      	str	r3, [r7, #28]
 801a2d8:	e06d      	b.n	801a3b6 <set_wraparound_pointers+0x102>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a2da:	69fb      	ldr	r3, [r7, #28]
 801a2dc:	68db      	ldr	r3, [r3, #12]
 801a2de:	69fa      	ldr	r2, [r7, #28]
 801a2e0:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801a2e2:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801a2e6:	687b      	ldr	r3, [r7, #4]
 801a2e8:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a2ec:	fb92 f3f3 	sdiv	r3, r2, r3
 801a2f0:	613b      	str	r3, [r7, #16]
    xbuf0 = main->xbuffer[0][ci];
 801a2f2:	69bb      	ldr	r3, [r7, #24]
 801a2f4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801a2f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a2f8:	009b      	lsls	r3, r3, #2
 801a2fa:	4413      	add	r3, r2
 801a2fc:	681b      	ldr	r3, [r3, #0]
 801a2fe:	60fb      	str	r3, [r7, #12]
    xbuf1 = main->xbuffer[1][ci];
 801a300:	69bb      	ldr	r3, [r7, #24]
 801a302:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801a304:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a306:	009b      	lsls	r3, r3, #2
 801a308:	4413      	add	r3, r2
 801a30a:	681b      	ldr	r3, [r3, #0]
 801a30c:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup; i++) {
 801a30e:	2300      	movs	r3, #0
 801a310:	623b      	str	r3, [r7, #32]
 801a312:	e046      	b.n	801a3a2 <set_wraparound_pointers+0xee>
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
 801a314:	697b      	ldr	r3, [r7, #20]
 801a316:	3301      	adds	r3, #1
 801a318:	693a      	ldr	r2, [r7, #16]
 801a31a:	fb03 f202 	mul.w	r2, r3, r2
 801a31e:	6a3b      	ldr	r3, [r7, #32]
 801a320:	4413      	add	r3, r2
 801a322:	009b      	lsls	r3, r3, #2
 801a324:	68fa      	ldr	r2, [r7, #12]
 801a326:	441a      	add	r2, r3
 801a328:	6a39      	ldr	r1, [r7, #32]
 801a32a:	693b      	ldr	r3, [r7, #16]
 801a32c:	1acb      	subs	r3, r1, r3
 801a32e:	009b      	lsls	r3, r3, #2
 801a330:	68f9      	ldr	r1, [r7, #12]
 801a332:	440b      	add	r3, r1
 801a334:	6812      	ldr	r2, [r2, #0]
 801a336:	601a      	str	r2, [r3, #0]
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
 801a338:	697b      	ldr	r3, [r7, #20]
 801a33a:	3301      	adds	r3, #1
 801a33c:	693a      	ldr	r2, [r7, #16]
 801a33e:	fb03 f202 	mul.w	r2, r3, r2
 801a342:	6a3b      	ldr	r3, [r7, #32]
 801a344:	4413      	add	r3, r2
 801a346:	009b      	lsls	r3, r3, #2
 801a348:	68ba      	ldr	r2, [r7, #8]
 801a34a:	441a      	add	r2, r3
 801a34c:	6a39      	ldr	r1, [r7, #32]
 801a34e:	693b      	ldr	r3, [r7, #16]
 801a350:	1acb      	subs	r3, r1, r3
 801a352:	009b      	lsls	r3, r3, #2
 801a354:	68b9      	ldr	r1, [r7, #8]
 801a356:	440b      	add	r3, r1
 801a358:	6812      	ldr	r2, [r2, #0]
 801a35a:	601a      	str	r2, [r3, #0]
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
 801a35c:	6a3b      	ldr	r3, [r7, #32]
 801a35e:	009b      	lsls	r3, r3, #2
 801a360:	68fa      	ldr	r2, [r7, #12]
 801a362:	441a      	add	r2, r3
 801a364:	697b      	ldr	r3, [r7, #20]
 801a366:	3302      	adds	r3, #2
 801a368:	6939      	ldr	r1, [r7, #16]
 801a36a:	fb03 f101 	mul.w	r1, r3, r1
 801a36e:	6a3b      	ldr	r3, [r7, #32]
 801a370:	440b      	add	r3, r1
 801a372:	009b      	lsls	r3, r3, #2
 801a374:	68f9      	ldr	r1, [r7, #12]
 801a376:	440b      	add	r3, r1
 801a378:	6812      	ldr	r2, [r2, #0]
 801a37a:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
 801a37c:	6a3b      	ldr	r3, [r7, #32]
 801a37e:	009b      	lsls	r3, r3, #2
 801a380:	68ba      	ldr	r2, [r7, #8]
 801a382:	441a      	add	r2, r3
 801a384:	697b      	ldr	r3, [r7, #20]
 801a386:	3302      	adds	r3, #2
 801a388:	6939      	ldr	r1, [r7, #16]
 801a38a:	fb03 f101 	mul.w	r1, r3, r1
 801a38e:	6a3b      	ldr	r3, [r7, #32]
 801a390:	440b      	add	r3, r1
 801a392:	009b      	lsls	r3, r3, #2
 801a394:	68b9      	ldr	r1, [r7, #8]
 801a396:	440b      	add	r3, r1
 801a398:	6812      	ldr	r2, [r2, #0]
 801a39a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 801a39c:	6a3b      	ldr	r3, [r7, #32]
 801a39e:	3301      	adds	r3, #1
 801a3a0:	623b      	str	r3, [r7, #32]
 801a3a2:	6a3a      	ldr	r2, [r7, #32]
 801a3a4:	693b      	ldr	r3, [r7, #16]
 801a3a6:	429a      	cmp	r2, r3
 801a3a8:	dbb4      	blt.n	801a314 <set_wraparound_pointers+0x60>
       ci++, compptr++) {
 801a3aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a3ac:	3301      	adds	r3, #1
 801a3ae:	627b      	str	r3, [r7, #36]	@ 0x24
 801a3b0:	69fb      	ldr	r3, [r7, #28]
 801a3b2:	3358      	adds	r3, #88	@ 0x58
 801a3b4:	61fb      	str	r3, [r7, #28]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a3b6:	687b      	ldr	r3, [r7, #4]
 801a3b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a3ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801a3bc:	429a      	cmp	r2, r3
 801a3be:	db8c      	blt.n	801a2da <set_wraparound_pointers+0x26>
    }
  }
}
 801a3c0:	bf00      	nop
 801a3c2:	bf00      	nop
 801a3c4:	372c      	adds	r7, #44	@ 0x2c
 801a3c6:	46bd      	mov	sp, r7
 801a3c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a3cc:	4770      	bx	lr

0801a3ce <set_bottom_pointers>:
set_bottom_pointers (j_decompress_ptr cinfo)
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
 801a3ce:	b480      	push	{r7}
 801a3d0:	b08b      	sub	sp, #44	@ 0x2c
 801a3d2:	af00      	add	r7, sp, #0
 801a3d4:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a3d6:	687b      	ldr	r3, [r7, #4]
 801a3d8:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a3dc:	617b      	str	r3, [r7, #20]
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a3de:	2300      	movs	r3, #0
 801a3e0:	627b      	str	r3, [r7, #36]	@ 0x24
 801a3e2:	687b      	ldr	r3, [r7, #4]
 801a3e4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a3e8:	61bb      	str	r3, [r7, #24]
 801a3ea:	e052      	b.n	801a492 <set_bottom_pointers+0xc4>
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_v_scaled_size;
 801a3ec:	69bb      	ldr	r3, [r7, #24]
 801a3ee:	68db      	ldr	r3, [r3, #12]
 801a3f0:	69ba      	ldr	r2, [r7, #24]
 801a3f2:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801a3f4:	fb02 f303 	mul.w	r3, r2, r3
 801a3f8:	613b      	str	r3, [r7, #16]
    rgroup = iMCUheight / cinfo->min_DCT_v_scaled_size;
 801a3fa:	687b      	ldr	r3, [r7, #4]
 801a3fc:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a400:	693a      	ldr	r2, [r7, #16]
 801a402:	fb92 f3f3 	sdiv	r3, r2, r3
 801a406:	60fb      	str	r3, [r7, #12]
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
 801a408:	69bb      	ldr	r3, [r7, #24]
 801a40a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a40c:	693a      	ldr	r2, [r7, #16]
 801a40e:	fbb3 f1f2 	udiv	r1, r3, r2
 801a412:	fb01 f202 	mul.w	r2, r1, r2
 801a416:	1a9b      	subs	r3, r3, r2
 801a418:	61fb      	str	r3, [r7, #28]
    if (rows_left == 0) rows_left = iMCUheight;
 801a41a:	69fb      	ldr	r3, [r7, #28]
 801a41c:	2b00      	cmp	r3, #0
 801a41e:	d101      	bne.n	801a424 <set_bottom_pointers+0x56>
 801a420:	693b      	ldr	r3, [r7, #16]
 801a422:	61fb      	str	r3, [r7, #28]
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
 801a424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a426:	2b00      	cmp	r3, #0
 801a428:	d108      	bne.n	801a43c <set_bottom_pointers+0x6e>
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
 801a42a:	69fb      	ldr	r3, [r7, #28]
 801a42c:	1e5a      	subs	r2, r3, #1
 801a42e:	68fb      	ldr	r3, [r7, #12]
 801a430:	fb92 f3f3 	sdiv	r3, r2, r3
 801a434:	3301      	adds	r3, #1
 801a436:	461a      	mov	r2, r3
 801a438:	697b      	ldr	r3, [r7, #20]
 801a43a:	649a      	str	r2, [r3, #72]	@ 0x48
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
 801a43c:	697b      	ldr	r3, [r7, #20]
 801a43e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801a440:	697b      	ldr	r3, [r7, #20]
 801a442:	320e      	adds	r2, #14
 801a444:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801a448:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a44a:	009b      	lsls	r3, r3, #2
 801a44c:	4413      	add	r3, r2
 801a44e:	681b      	ldr	r3, [r3, #0]
 801a450:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup * 2; i++) {
 801a452:	2300      	movs	r3, #0
 801a454:	623b      	str	r3, [r7, #32]
 801a456:	e011      	b.n	801a47c <set_bottom_pointers+0xae>
      xbuf[rows_left + i] = xbuf[rows_left-1];
 801a458:	69fb      	ldr	r3, [r7, #28]
 801a45a:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801a45e:	3b01      	subs	r3, #1
 801a460:	009b      	lsls	r3, r3, #2
 801a462:	68ba      	ldr	r2, [r7, #8]
 801a464:	441a      	add	r2, r3
 801a466:	69f9      	ldr	r1, [r7, #28]
 801a468:	6a3b      	ldr	r3, [r7, #32]
 801a46a:	440b      	add	r3, r1
 801a46c:	009b      	lsls	r3, r3, #2
 801a46e:	68b9      	ldr	r1, [r7, #8]
 801a470:	440b      	add	r3, r1
 801a472:	6812      	ldr	r2, [r2, #0]
 801a474:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 801a476:	6a3b      	ldr	r3, [r7, #32]
 801a478:	3301      	adds	r3, #1
 801a47a:	623b      	str	r3, [r7, #32]
 801a47c:	68fb      	ldr	r3, [r7, #12]
 801a47e:	005b      	lsls	r3, r3, #1
 801a480:	6a3a      	ldr	r2, [r7, #32]
 801a482:	429a      	cmp	r2, r3
 801a484:	dbe8      	blt.n	801a458 <set_bottom_pointers+0x8a>
       ci++, compptr++) {
 801a486:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a488:	3301      	adds	r3, #1
 801a48a:	627b      	str	r3, [r7, #36]	@ 0x24
 801a48c:	69bb      	ldr	r3, [r7, #24]
 801a48e:	3358      	adds	r3, #88	@ 0x58
 801a490:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a492:	687b      	ldr	r3, [r7, #4]
 801a494:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a496:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801a498:	429a      	cmp	r2, r3
 801a49a:	dba7      	blt.n	801a3ec <set_bottom_pointers+0x1e>
    }
  }
}
 801a49c:	bf00      	nop
 801a49e:	bf00      	nop
 801a4a0:	372c      	adds	r7, #44	@ 0x2c
 801a4a2:	46bd      	mov	sp, r7
 801a4a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a4a8:	4770      	bx	lr
	...

0801a4ac <start_pass_main>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 801a4ac:	b580      	push	{r7, lr}
 801a4ae:	b084      	sub	sp, #16
 801a4b0:	af00      	add	r7, sp, #0
 801a4b2:	6078      	str	r0, [r7, #4]
 801a4b4:	460b      	mov	r3, r1
 801a4b6:	70fb      	strb	r3, [r7, #3]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a4b8:	687b      	ldr	r3, [r7, #4]
 801a4ba:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a4be:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 801a4c0:	78fb      	ldrb	r3, [r7, #3]
 801a4c2:	2b00      	cmp	r3, #0
 801a4c4:	d002      	beq.n	801a4cc <start_pass_main+0x20>
 801a4c6:	2b02      	cmp	r3, #2
 801a4c8:	d020      	beq.n	801a50c <start_pass_main+0x60>
 801a4ca:	e023      	b.n	801a514 <start_pass_main+0x68>
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
 801a4cc:	687b      	ldr	r3, [r7, #4]
 801a4ce:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801a4d2:	689b      	ldr	r3, [r3, #8]
 801a4d4:	2b00      	cmp	r3, #0
 801a4d6:	d00f      	beq.n	801a4f8 <start_pass_main+0x4c>
      main->pub.process_data = process_data_context_main;
 801a4d8:	68fb      	ldr	r3, [r7, #12]
 801a4da:	4a15      	ldr	r2, [pc, #84]	@ (801a530 <start_pass_main+0x84>)
 801a4dc:	605a      	str	r2, [r3, #4]
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
 801a4de:	6878      	ldr	r0, [r7, #4]
 801a4e0:	f7ff fe3c 	bl	801a15c <make_funny_pointers>
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
 801a4e4:	68fb      	ldr	r3, [r7, #12]
 801a4e6:	2200      	movs	r2, #0
 801a4e8:	641a      	str	r2, [r3, #64]	@ 0x40
      main->context_state = CTX_PREPARE_FOR_IMCU;
 801a4ea:	68fb      	ldr	r3, [r7, #12]
 801a4ec:	2200      	movs	r2, #0
 801a4ee:	645a      	str	r2, [r3, #68]	@ 0x44
      main->iMCU_row_ctr = 0;
 801a4f0:	68fb      	ldr	r3, [r7, #12]
 801a4f2:	2200      	movs	r2, #0
 801a4f4:	64da      	str	r2, [r3, #76]	@ 0x4c
 801a4f6:	e002      	b.n	801a4fe <start_pass_main+0x52>
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
 801a4f8:	68fb      	ldr	r3, [r7, #12]
 801a4fa:	4a0e      	ldr	r2, [pc, #56]	@ (801a534 <start_pass_main+0x88>)
 801a4fc:	605a      	str	r2, [r3, #4]
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
 801a4fe:	68fb      	ldr	r3, [r7, #12]
 801a500:	2200      	movs	r2, #0
 801a502:	631a      	str	r2, [r3, #48]	@ 0x30
    main->rowgroup_ctr = 0;
 801a504:	68fb      	ldr	r3, [r7, #12]
 801a506:	2200      	movs	r2, #0
 801a508:	635a      	str	r2, [r3, #52]	@ 0x34
    break;
 801a50a:	e00d      	b.n	801a528 <start_pass_main+0x7c>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
 801a50c:	68fb      	ldr	r3, [r7, #12]
 801a50e:	4a0a      	ldr	r2, [pc, #40]	@ (801a538 <start_pass_main+0x8c>)
 801a510:	605a      	str	r2, [r3, #4]
    break;
 801a512:	e009      	b.n	801a528 <start_pass_main+0x7c>
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801a514:	687b      	ldr	r3, [r7, #4]
 801a516:	681b      	ldr	r3, [r3, #0]
 801a518:	2203      	movs	r2, #3
 801a51a:	615a      	str	r2, [r3, #20]
 801a51c:	687b      	ldr	r3, [r7, #4]
 801a51e:	681b      	ldr	r3, [r3, #0]
 801a520:	681b      	ldr	r3, [r3, #0]
 801a522:	6878      	ldr	r0, [r7, #4]
 801a524:	4798      	blx	r3
    break;
 801a526:	bf00      	nop
  }
}
 801a528:	bf00      	nop
 801a52a:	3710      	adds	r7, #16
 801a52c:	46bd      	mov	sp, r7
 801a52e:	bd80      	pop	{r7, pc}
 801a530:	0801a5c7 	.word	0x0801a5c7
 801a534:	0801a53d 	.word	0x0801a53d
 801a538:	0801a73d 	.word	0x0801a73d

0801a53c <process_data_simple_main>:

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
 801a53c:	b590      	push	{r4, r7, lr}
 801a53e:	b08b      	sub	sp, #44	@ 0x2c
 801a540:	af04      	add	r7, sp, #16
 801a542:	60f8      	str	r0, [r7, #12]
 801a544:	60b9      	str	r1, [r7, #8]
 801a546:	607a      	str	r2, [r7, #4]
 801a548:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a54a:	68fb      	ldr	r3, [r7, #12]
 801a54c:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a550:	617b      	str	r3, [r7, #20]
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 801a552:	697b      	ldr	r3, [r7, #20]
 801a554:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a556:	2b00      	cmp	r3, #0
 801a558:	d10e      	bne.n	801a578 <process_data_simple_main+0x3c>
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
 801a55a:	68fb      	ldr	r3, [r7, #12]
 801a55c:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801a560:	68db      	ldr	r3, [r3, #12]
 801a562:	697a      	ldr	r2, [r7, #20]
 801a564:	3208      	adds	r2, #8
 801a566:	4611      	mov	r1, r2
 801a568:	68f8      	ldr	r0, [r7, #12]
 801a56a:	4798      	blx	r3
 801a56c:	4603      	mov	r3, r0
 801a56e:	2b00      	cmp	r3, #0
 801a570:	d025      	beq.n	801a5be <process_data_simple_main+0x82>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 801a572:	697b      	ldr	r3, [r7, #20]
 801a574:	2201      	movs	r2, #1
 801a576:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;
 801a578:	68fb      	ldr	r3, [r7, #12]
 801a57a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a57e:	613b      	str	r3, [r7, #16]
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
 801a580:	68fb      	ldr	r3, [r7, #12]
 801a582:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801a586:	685c      	ldr	r4, [r3, #4]
 801a588:	697b      	ldr	r3, [r7, #20]
 801a58a:	f103 0108 	add.w	r1, r3, #8
 801a58e:	697b      	ldr	r3, [r7, #20]
 801a590:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801a594:	683b      	ldr	r3, [r7, #0]
 801a596:	9302      	str	r3, [sp, #8]
 801a598:	687b      	ldr	r3, [r7, #4]
 801a59a:	9301      	str	r3, [sp, #4]
 801a59c:	68bb      	ldr	r3, [r7, #8]
 801a59e:	9300      	str	r3, [sp, #0]
 801a5a0:	693b      	ldr	r3, [r7, #16]
 801a5a2:	68f8      	ldr	r0, [r7, #12]
 801a5a4:	47a0      	blx	r4
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
 801a5a6:	697b      	ldr	r3, [r7, #20]
 801a5a8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801a5aa:	693a      	ldr	r2, [r7, #16]
 801a5ac:	429a      	cmp	r2, r3
 801a5ae:	d807      	bhi.n	801a5c0 <process_data_simple_main+0x84>
    main->buffer_full = FALSE;
 801a5b0:	697b      	ldr	r3, [r7, #20]
 801a5b2:	2200      	movs	r2, #0
 801a5b4:	631a      	str	r2, [r3, #48]	@ 0x30
    main->rowgroup_ctr = 0;
 801a5b6:	697b      	ldr	r3, [r7, #20]
 801a5b8:	2200      	movs	r2, #0
 801a5ba:	635a      	str	r2, [r3, #52]	@ 0x34
 801a5bc:	e000      	b.n	801a5c0 <process_data_simple_main+0x84>
      return;			/* suspension forced, can do nothing more */
 801a5be:	bf00      	nop
  }
}
 801a5c0:	371c      	adds	r7, #28
 801a5c2:	46bd      	mov	sp, r7
 801a5c4:	bd90      	pop	{r4, r7, pc}

0801a5c6 <process_data_context_main>:

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
 801a5c6:	b590      	push	{r4, r7, lr}
 801a5c8:	b08b      	sub	sp, #44	@ 0x2c
 801a5ca:	af04      	add	r7, sp, #16
 801a5cc:	60f8      	str	r0, [r7, #12]
 801a5ce:	60b9      	str	r1, [r7, #8]
 801a5d0:	607a      	str	r2, [r7, #4]
 801a5d2:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 801a5d4:	68fb      	ldr	r3, [r7, #12]
 801a5d6:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801a5da:	617b      	str	r3, [r7, #20]

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 801a5dc:	697b      	ldr	r3, [r7, #20]
 801a5de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a5e0:	2b00      	cmp	r3, #0
 801a5e2:	d118      	bne.n	801a616 <process_data_context_main+0x50>
    if (! (*cinfo->coef->decompress_data) (cinfo,
 801a5e4:	68fb      	ldr	r3, [r7, #12]
 801a5e6:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801a5ea:	68db      	ldr	r3, [r3, #12]
					   main->xbuffer[main->whichptr]))
 801a5ec:	697a      	ldr	r2, [r7, #20]
 801a5ee:	6c11      	ldr	r1, [r2, #64]	@ 0x40
    if (! (*cinfo->coef->decompress_data) (cinfo,
 801a5f0:	697a      	ldr	r2, [r7, #20]
 801a5f2:	310e      	adds	r1, #14
 801a5f4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 801a5f8:	4611      	mov	r1, r2
 801a5fa:	68f8      	ldr	r0, [r7, #12]
 801a5fc:	4798      	blx	r3
 801a5fe:	4603      	mov	r3, r0
 801a600:	2b00      	cmp	r3, #0
 801a602:	f000 8091 	beq.w	801a728 <process_data_context_main+0x162>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 801a606:	697b      	ldr	r3, [r7, #20]
 801a608:	2201      	movs	r2, #1
 801a60a:	631a      	str	r2, [r3, #48]	@ 0x30
    main->iMCU_row_ctr++;	/* count rows received */
 801a60c:	697b      	ldr	r3, [r7, #20]
 801a60e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801a610:	1c5a      	adds	r2, r3, #1
 801a612:	697b      	ldr	r3, [r7, #20]
 801a614:	64da      	str	r2, [r3, #76]	@ 0x4c
  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
 801a616:	697b      	ldr	r3, [r7, #20]
 801a618:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801a61a:	2b02      	cmp	r3, #2
 801a61c:	d007      	beq.n	801a62e <process_data_context_main+0x68>
 801a61e:	2b02      	cmp	r3, #2
 801a620:	f300 8089 	bgt.w	801a736 <process_data_context_main+0x170>
 801a624:	2b00      	cmp	r3, #0
 801a626:	d028      	beq.n	801a67a <process_data_context_main+0xb4>
 801a628:	2b01      	cmp	r3, #1
 801a62a:	d03d      	beq.n	801a6a8 <process_data_context_main+0xe2>
 801a62c:	e083      	b.n	801a736 <process_data_context_main+0x170>
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 801a62e:	68fb      	ldr	r3, [r7, #12]
 801a630:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801a634:	685c      	ldr	r4, [r3, #4]
 801a636:	697b      	ldr	r3, [r7, #20]
 801a638:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801a63a:	697b      	ldr	r3, [r7, #20]
 801a63c:	320e      	adds	r2, #14
 801a63e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801a642:	697b      	ldr	r3, [r7, #20]
 801a644:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801a648:	697b      	ldr	r3, [r7, #20]
 801a64a:	6c98      	ldr	r0, [r3, #72]	@ 0x48
 801a64c:	683b      	ldr	r3, [r7, #0]
 801a64e:	9302      	str	r3, [sp, #8]
 801a650:	687b      	ldr	r3, [r7, #4]
 801a652:	9301      	str	r3, [sp, #4]
 801a654:	68bb      	ldr	r3, [r7, #8]
 801a656:	9300      	str	r3, [sp, #0]
 801a658:	4603      	mov	r3, r0
 801a65a:	68f8      	ldr	r0, [r7, #12]
 801a65c:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 801a65e:	697b      	ldr	r3, [r7, #20]
 801a660:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801a662:	697b      	ldr	r3, [r7, #20]
 801a664:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801a666:	429a      	cmp	r2, r3
 801a668:	d360      	bcc.n	801a72c <process_data_context_main+0x166>
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
 801a66a:	697b      	ldr	r3, [r7, #20]
 801a66c:	2200      	movs	r2, #0
 801a66e:	645a      	str	r2, [r3, #68]	@ 0x44
    if (*out_row_ctr >= out_rows_avail)
 801a670:	687b      	ldr	r3, [r7, #4]
 801a672:	681b      	ldr	r3, [r3, #0]
 801a674:	683a      	ldr	r2, [r7, #0]
 801a676:	429a      	cmp	r2, r3
 801a678:	d95a      	bls.n	801a730 <process_data_context_main+0x16a>
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
 801a67a:	697b      	ldr	r3, [r7, #20]
 801a67c:	2200      	movs	r2, #0
 801a67e:	635a      	str	r2, [r3, #52]	@ 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
 801a680:	68fb      	ldr	r3, [r7, #12]
 801a682:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a686:	3b01      	subs	r3, #1
 801a688:	461a      	mov	r2, r3
 801a68a:	697b      	ldr	r3, [r7, #20]
 801a68c:	649a      	str	r2, [r3, #72]	@ 0x48
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
 801a68e:	697b      	ldr	r3, [r7, #20]
 801a690:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 801a692:	68fb      	ldr	r3, [r7, #12]
 801a694:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801a698:	429a      	cmp	r2, r3
 801a69a:	d102      	bne.n	801a6a2 <process_data_context_main+0xdc>
      set_bottom_pointers(cinfo);
 801a69c:	68f8      	ldr	r0, [r7, #12]
 801a69e:	f7ff fe96 	bl	801a3ce <set_bottom_pointers>
    main->context_state = CTX_PROCESS_IMCU;
 801a6a2:	697b      	ldr	r3, [r7, #20]
 801a6a4:	2201      	movs	r2, #1
 801a6a6:	645a      	str	r2, [r3, #68]	@ 0x44
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 801a6a8:	68fb      	ldr	r3, [r7, #12]
 801a6aa:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801a6ae:	685c      	ldr	r4, [r3, #4]
 801a6b0:	697b      	ldr	r3, [r7, #20]
 801a6b2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801a6b4:	697b      	ldr	r3, [r7, #20]
 801a6b6:	320e      	adds	r2, #14
 801a6b8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801a6bc:	697b      	ldr	r3, [r7, #20]
 801a6be:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801a6c2:	697b      	ldr	r3, [r7, #20]
 801a6c4:	6c98      	ldr	r0, [r3, #72]	@ 0x48
 801a6c6:	683b      	ldr	r3, [r7, #0]
 801a6c8:	9302      	str	r3, [sp, #8]
 801a6ca:	687b      	ldr	r3, [r7, #4]
 801a6cc:	9301      	str	r3, [sp, #4]
 801a6ce:	68bb      	ldr	r3, [r7, #8]
 801a6d0:	9300      	str	r3, [sp, #0]
 801a6d2:	4603      	mov	r3, r0
 801a6d4:	68f8      	ldr	r0, [r7, #12]
 801a6d6:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 801a6d8:	697b      	ldr	r3, [r7, #20]
 801a6da:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801a6dc:	697b      	ldr	r3, [r7, #20]
 801a6de:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801a6e0:	429a      	cmp	r2, r3
 801a6e2:	d327      	bcc.n	801a734 <process_data_context_main+0x16e>
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
 801a6e4:	697b      	ldr	r3, [r7, #20]
 801a6e6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801a6e8:	2b01      	cmp	r3, #1
 801a6ea:	d102      	bne.n	801a6f2 <process_data_context_main+0x12c>
      set_wraparound_pointers(cinfo);
 801a6ec:	68f8      	ldr	r0, [r7, #12]
 801a6ee:	f7ff fde1 	bl	801a2b4 <set_wraparound_pointers>
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
 801a6f2:	697b      	ldr	r3, [r7, #20]
 801a6f4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801a6f6:	f083 0201 	eor.w	r2, r3, #1
 801a6fa:	697b      	ldr	r3, [r7, #20]
 801a6fc:	641a      	str	r2, [r3, #64]	@ 0x40
    main->buffer_full = FALSE;
 801a6fe:	697b      	ldr	r3, [r7, #20]
 801a700:	2200      	movs	r2, #0
 801a702:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
 801a704:	68fb      	ldr	r3, [r7, #12]
 801a706:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a70a:	3301      	adds	r3, #1
 801a70c:	461a      	mov	r2, r3
 801a70e:	697b      	ldr	r3, [r7, #20]
 801a710:	635a      	str	r2, [r3, #52]	@ 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
 801a712:	68fb      	ldr	r3, [r7, #12]
 801a714:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a718:	3302      	adds	r3, #2
 801a71a:	461a      	mov	r2, r3
 801a71c:	697b      	ldr	r3, [r7, #20]
 801a71e:	649a      	str	r2, [r3, #72]	@ 0x48
    main->context_state = CTX_POSTPONED_ROW;
 801a720:	697b      	ldr	r3, [r7, #20]
 801a722:	2202      	movs	r2, #2
 801a724:	645a      	str	r2, [r3, #68]	@ 0x44
 801a726:	e006      	b.n	801a736 <process_data_context_main+0x170>
      return;			/* suspension forced, can do nothing more */
 801a728:	bf00      	nop
 801a72a:	e004      	b.n	801a736 <process_data_context_main+0x170>
      return;			/* Need to suspend */
 801a72c:	bf00      	nop
 801a72e:	e002      	b.n	801a736 <process_data_context_main+0x170>
      return;			/* Postprocessor exactly filled output buf */
 801a730:	bf00      	nop
 801a732:	e000      	b.n	801a736 <process_data_context_main+0x170>
      return;			/* Need to suspend */
 801a734:	bf00      	nop
  }
}
 801a736:	371c      	adds	r7, #28
 801a738:	46bd      	mov	sp, r7
 801a73a:	bd90      	pop	{r4, r7, pc}

0801a73c <process_data_crank_post>:

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
 801a73c:	b590      	push	{r4, r7, lr}
 801a73e:	b089      	sub	sp, #36	@ 0x24
 801a740:	af04      	add	r7, sp, #16
 801a742:	60f8      	str	r0, [r7, #12]
 801a744:	60b9      	str	r1, [r7, #8]
 801a746:	607a      	str	r2, [r7, #4]
 801a748:	603b      	str	r3, [r7, #0]
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
 801a74a:	68fb      	ldr	r3, [r7, #12]
 801a74c:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801a750:	685c      	ldr	r4, [r3, #4]
 801a752:	683b      	ldr	r3, [r7, #0]
 801a754:	9302      	str	r3, [sp, #8]
 801a756:	687b      	ldr	r3, [r7, #4]
 801a758:	9301      	str	r3, [sp, #4]
 801a75a:	68bb      	ldr	r3, [r7, #8]
 801a75c:	9300      	str	r3, [sp, #0]
 801a75e:	2300      	movs	r3, #0
 801a760:	2200      	movs	r2, #0
 801a762:	2100      	movs	r1, #0
 801a764:	68f8      	ldr	r0, [r7, #12]
 801a766:	47a0      	blx	r4
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}
 801a768:	bf00      	nop
 801a76a:	3714      	adds	r7, #20
 801a76c:	46bd      	mov	sp, r7
 801a76e:	bd90      	pop	{r4, r7, pc}

0801a770 <jinit_d_main_controller>:
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 801a770:	b590      	push	{r4, r7, lr}
 801a772:	b089      	sub	sp, #36	@ 0x24
 801a774:	af00      	add	r7, sp, #0
 801a776:	6078      	str	r0, [r7, #4]
 801a778:	6039      	str	r1, [r7, #0]
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801a77a:	687b      	ldr	r3, [r7, #4]
 801a77c:	685b      	ldr	r3, [r3, #4]
 801a77e:	681b      	ldr	r3, [r3, #0]
 801a780:	2250      	movs	r2, #80	@ 0x50
 801a782:	2101      	movs	r1, #1
 801a784:	6878      	ldr	r0, [r7, #4]
 801a786:	4798      	blx	r3
 801a788:	6138      	str	r0, [r7, #16]
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
 801a78a:	687b      	ldr	r3, [r7, #4]
 801a78c:	693a      	ldr	r2, [r7, #16]
 801a78e:	f8c3 21bc 	str.w	r2, [r3, #444]	@ 0x1bc
  main->pub.start_pass = start_pass_main;
 801a792:	693b      	ldr	r3, [r7, #16]
 801a794:	4a34      	ldr	r2, [pc, #208]	@ (801a868 <jinit_d_main_controller+0xf8>)
 801a796:	601a      	str	r2, [r3, #0]

  if (need_full_buffer)		/* shouldn't happen */
 801a798:	683b      	ldr	r3, [r7, #0]
 801a79a:	2b00      	cmp	r3, #0
 801a79c:	d008      	beq.n	801a7b0 <jinit_d_main_controller+0x40>
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801a79e:	687b      	ldr	r3, [r7, #4]
 801a7a0:	681b      	ldr	r3, [r3, #0]
 801a7a2:	2203      	movs	r2, #3
 801a7a4:	615a      	str	r2, [r3, #20]
 801a7a6:	687b      	ldr	r3, [r7, #4]
 801a7a8:	681b      	ldr	r3, [r3, #0]
 801a7aa:	681b      	ldr	r3, [r3, #0]
 801a7ac:	6878      	ldr	r0, [r7, #4]
 801a7ae:	4798      	blx	r3

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
 801a7b0:	687b      	ldr	r3, [r7, #4]
 801a7b2:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801a7b6:	689b      	ldr	r3, [r3, #8]
 801a7b8:	2b00      	cmp	r3, #0
 801a7ba:	d016      	beq.n	801a7ea <jinit_d_main_controller+0x7a>
    if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */
 801a7bc:	687b      	ldr	r3, [r7, #4]
 801a7be:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a7c2:	2b01      	cmp	r3, #1
 801a7c4:	dc08      	bgt.n	801a7d8 <jinit_d_main_controller+0x68>
      ERREXIT(cinfo, JERR_NOTIMPL);
 801a7c6:	687b      	ldr	r3, [r7, #4]
 801a7c8:	681b      	ldr	r3, [r3, #0]
 801a7ca:	2230      	movs	r2, #48	@ 0x30
 801a7cc:	615a      	str	r2, [r3, #20]
 801a7ce:	687b      	ldr	r3, [r7, #4]
 801a7d0:	681b      	ldr	r3, [r3, #0]
 801a7d2:	681b      	ldr	r3, [r3, #0]
 801a7d4:	6878      	ldr	r0, [r7, #4]
 801a7d6:	4798      	blx	r3
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
 801a7d8:	6878      	ldr	r0, [r7, #4]
 801a7da:	f7ff fc53 	bl	801a084 <alloc_funny_pointers>
    ngroups = cinfo->min_DCT_v_scaled_size + 2;
 801a7de:	687b      	ldr	r3, [r7, #4]
 801a7e0:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a7e4:	3302      	adds	r3, #2
 801a7e6:	61bb      	str	r3, [r7, #24]
 801a7e8:	e003      	b.n	801a7f2 <jinit_d_main_controller+0x82>
  } else {
    ngroups = cinfo->min_DCT_v_scaled_size;
 801a7ea:	687b      	ldr	r3, [r7, #4]
 801a7ec:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801a7f0:	61bb      	str	r3, [r7, #24]
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a7f2:	2300      	movs	r3, #0
 801a7f4:	61fb      	str	r3, [r7, #28]
 801a7f6:	687b      	ldr	r3, [r7, #4]
 801a7f8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801a7fc:	617b      	str	r3, [r7, #20]
 801a7fe:	e028      	b.n	801a852 <jinit_d_main_controller+0xe2>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a800:	697b      	ldr	r3, [r7, #20]
 801a802:	68db      	ldr	r3, [r3, #12]
 801a804:	697a      	ldr	r2, [r7, #20]
 801a806:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801a808:	fb03 f202 	mul.w	r2, r3, r2
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801a80c:	687b      	ldr	r3, [r7, #4]
 801a80e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801a812:	fb92 f3f3 	sdiv	r3, r2, r3
 801a816:	60fb      	str	r3, [r7, #12]
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 801a818:	687b      	ldr	r3, [r7, #4]
 801a81a:	685b      	ldr	r3, [r3, #4]
 801a81c:	689c      	ldr	r4, [r3, #8]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 801a81e:	697b      	ldr	r3, [r7, #20]
 801a820:	69db      	ldr	r3, [r3, #28]
 801a822:	697a      	ldr	r2, [r7, #20]
 801a824:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 801a826:	fb02 f103 	mul.w	r1, r2, r3
			 (JDIMENSION) (rgroup * ngroups));
 801a82a:	68fb      	ldr	r3, [r7, #12]
 801a82c:	69ba      	ldr	r2, [r7, #24]
 801a82e:	fb02 f303 	mul.w	r3, r2, r3
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 801a832:	460a      	mov	r2, r1
 801a834:	2101      	movs	r1, #1
 801a836:	6878      	ldr	r0, [r7, #4]
 801a838:	47a0      	blx	r4
 801a83a:	4601      	mov	r1, r0
 801a83c:	693b      	ldr	r3, [r7, #16]
 801a83e:	69fa      	ldr	r2, [r7, #28]
 801a840:	3202      	adds	r2, #2
 801a842:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
       ci++, compptr++) {
 801a846:	69fb      	ldr	r3, [r7, #28]
 801a848:	3301      	adds	r3, #1
 801a84a:	61fb      	str	r3, [r7, #28]
 801a84c:	697b      	ldr	r3, [r7, #20]
 801a84e:	3358      	adds	r3, #88	@ 0x58
 801a850:	617b      	str	r3, [r7, #20]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801a852:	687b      	ldr	r3, [r7, #4]
 801a854:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a856:	69fa      	ldr	r2, [r7, #28]
 801a858:	429a      	cmp	r2, r3
 801a85a:	dbd1      	blt.n	801a800 <jinit_d_main_controller+0x90>
  }
}
 801a85c:	bf00      	nop
 801a85e:	bf00      	nop
 801a860:	3724      	adds	r7, #36	@ 0x24
 801a862:	46bd      	mov	sp, r7
 801a864:	bd90      	pop	{r4, r7, pc}
 801a866:	bf00      	nop
 801a868:	0801a4ad 	.word	0x0801a4ad

0801a86c <get_soi>:


LOCAL(boolean)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
 801a86c:	b580      	push	{r7, lr}
 801a86e:	b084      	sub	sp, #16
 801a870:	af00      	add	r7, sp, #0
 801a872:	6078      	str	r0, [r7, #4]
  int i;
  
  TRACEMS(cinfo, 1, JTRC_SOI);
 801a874:	687b      	ldr	r3, [r7, #4]
 801a876:	681b      	ldr	r3, [r3, #0]
 801a878:	2268      	movs	r2, #104	@ 0x68
 801a87a:	615a      	str	r2, [r3, #20]
 801a87c:	687b      	ldr	r3, [r7, #4]
 801a87e:	681b      	ldr	r3, [r3, #0]
 801a880:	685b      	ldr	r3, [r3, #4]
 801a882:	2101      	movs	r1, #1
 801a884:	6878      	ldr	r0, [r7, #4]
 801a886:	4798      	blx	r3

  if (cinfo->marker->saw_SOI)
 801a888:	687b      	ldr	r3, [r7, #4]
 801a88a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a88e:	68db      	ldr	r3, [r3, #12]
 801a890:	2b00      	cmp	r3, #0
 801a892:	d008      	beq.n	801a8a6 <get_soi+0x3a>
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);
 801a894:	687b      	ldr	r3, [r7, #4]
 801a896:	681b      	ldr	r3, [r3, #0]
 801a898:	223f      	movs	r2, #63	@ 0x3f
 801a89a:	615a      	str	r2, [r3, #20]
 801a89c:	687b      	ldr	r3, [r7, #4]
 801a89e:	681b      	ldr	r3, [r3, #0]
 801a8a0:	681b      	ldr	r3, [r3, #0]
 801a8a2:	6878      	ldr	r0, [r7, #4]
 801a8a4:	4798      	blx	r3

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 801a8a6:	2300      	movs	r3, #0
 801a8a8:	60fb      	str	r3, [r7, #12]
 801a8aa:	e015      	b.n	801a8d8 <get_soi+0x6c>
    cinfo->arith_dc_L[i] = 0;
 801a8ac:	687a      	ldr	r2, [r7, #4]
 801a8ae:	68fb      	ldr	r3, [r7, #12]
 801a8b0:	4413      	add	r3, r2
 801a8b2:	33e8      	adds	r3, #232	@ 0xe8
 801a8b4:	2200      	movs	r2, #0
 801a8b6:	701a      	strb	r2, [r3, #0]
    cinfo->arith_dc_U[i] = 1;
 801a8b8:	687a      	ldr	r2, [r7, #4]
 801a8ba:	68fb      	ldr	r3, [r7, #12]
 801a8bc:	4413      	add	r3, r2
 801a8be:	33f8      	adds	r3, #248	@ 0xf8
 801a8c0:	2201      	movs	r2, #1
 801a8c2:	701a      	strb	r2, [r3, #0]
    cinfo->arith_ac_K[i] = 5;
 801a8c4:	687a      	ldr	r2, [r7, #4]
 801a8c6:	68fb      	ldr	r3, [r7, #12]
 801a8c8:	4413      	add	r3, r2
 801a8ca:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 801a8ce:	2205      	movs	r2, #5
 801a8d0:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 801a8d2:	68fb      	ldr	r3, [r7, #12]
 801a8d4:	3301      	adds	r3, #1
 801a8d6:	60fb      	str	r3, [r7, #12]
 801a8d8:	68fb      	ldr	r3, [r7, #12]
 801a8da:	2b0f      	cmp	r3, #15
 801a8dc:	dde6      	ble.n	801a8ac <get_soi+0x40>
  }
  cinfo->restart_interval = 0;
 801a8de:	687b      	ldr	r3, [r7, #4]
 801a8e0:	2200      	movs	r2, #0
 801a8e2:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
 801a8e6:	687b      	ldr	r3, [r7, #4]
 801a8e8:	2200      	movs	r2, #0
 801a8ea:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
 801a8ee:	687b      	ldr	r3, [r7, #4]
 801a8f0:	2200      	movs	r2, #0
 801a8f2:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

  cinfo->saw_JFIF_marker = FALSE;
 801a8f6:	687b      	ldr	r3, [r7, #4]
 801a8f8:	2200      	movs	r2, #0
 801a8fa:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
 801a8fe:	687b      	ldr	r3, [r7, #4]
 801a900:	2201      	movs	r2, #1
 801a902:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
  cinfo->JFIF_minor_version = 1;
 801a906:	687b      	ldr	r3, [r7, #4]
 801a908:	2201      	movs	r2, #1
 801a90a:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
  cinfo->density_unit = 0;
 801a90e:	687b      	ldr	r3, [r7, #4]
 801a910:	2200      	movs	r2, #0
 801a912:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
  cinfo->X_density = 1;
 801a916:	687b      	ldr	r3, [r7, #4]
 801a918:	2201      	movs	r2, #1
 801a91a:	f8a3 2124 	strh.w	r2, [r3, #292]	@ 0x124
  cinfo->Y_density = 1;
 801a91e:	687b      	ldr	r3, [r7, #4]
 801a920:	2201      	movs	r2, #1
 801a922:	f8a3 2126 	strh.w	r2, [r3, #294]	@ 0x126
  cinfo->saw_Adobe_marker = FALSE;
 801a926:	687b      	ldr	r3, [r7, #4]
 801a928:	2200      	movs	r2, #0
 801a92a:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
  cinfo->Adobe_transform = 0;
 801a92e:	687b      	ldr	r3, [r7, #4]
 801a930:	2200      	movs	r2, #0
 801a932:	f883 212c 	strb.w	r2, [r3, #300]	@ 0x12c

  cinfo->marker->saw_SOI = TRUE;
 801a936:	687b      	ldr	r3, [r7, #4]
 801a938:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801a93c:	2201      	movs	r2, #1
 801a93e:	60da      	str	r2, [r3, #12]

  return TRUE;
 801a940:	2301      	movs	r3, #1
}
 801a942:	4618      	mov	r0, r3
 801a944:	3710      	adds	r7, #16
 801a946:	46bd      	mov	sp, r7
 801a948:	bd80      	pop	{r7, pc}

0801a94a <get_sof>:

LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_baseline, boolean is_prog,
	 boolean is_arith)
/* Process a SOFn marker */
{
 801a94a:	b580      	push	{r7, lr}
 801a94c:	b08e      	sub	sp, #56	@ 0x38
 801a94e:	af00      	add	r7, sp, #0
 801a950:	60f8      	str	r0, [r7, #12]
 801a952:	60b9      	str	r1, [r7, #8]
 801a954:	607a      	str	r2, [r7, #4]
 801a956:	603b      	str	r3, [r7, #0]
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 801a958:	68fb      	ldr	r3, [r7, #12]
 801a95a:	699b      	ldr	r3, [r3, #24]
 801a95c:	627b      	str	r3, [r7, #36]	@ 0x24
 801a95e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a960:	681b      	ldr	r3, [r3, #0]
 801a962:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801a964:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a966:	685b      	ldr	r3, [r3, #4]
 801a968:	62bb      	str	r3, [r7, #40]	@ 0x28

  cinfo->is_baseline = is_baseline;
 801a96a:	68fb      	ldr	r3, [r7, #12]
 801a96c:	68ba      	ldr	r2, [r7, #8]
 801a96e:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  cinfo->progressive_mode = is_prog;
 801a972:	68fb      	ldr	r3, [r7, #12]
 801a974:	687a      	ldr	r2, [r7, #4]
 801a976:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  cinfo->arith_code = is_arith;
 801a97a:	68fb      	ldr	r3, [r7, #12]
 801a97c:	683a      	ldr	r2, [r7, #0]
 801a97e:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4

  INPUT_2BYTES(cinfo, length, return FALSE);
 801a982:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a984:	2b00      	cmp	r3, #0
 801a986:	d10e      	bne.n	801a9a6 <get_sof+0x5c>
 801a988:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a98a:	68db      	ldr	r3, [r3, #12]
 801a98c:	68f8      	ldr	r0, [r7, #12]
 801a98e:	4798      	blx	r3
 801a990:	4603      	mov	r3, r0
 801a992:	2b00      	cmp	r3, #0
 801a994:	d101      	bne.n	801a99a <get_sof+0x50>
 801a996:	2300      	movs	r3, #0
 801a998:	e1e7      	b.n	801ad6a <get_sof+0x420>
 801a99a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a99c:	681b      	ldr	r3, [r3, #0]
 801a99e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801a9a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a9a2:	685b      	ldr	r3, [r3, #4]
 801a9a4:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a9a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a9a8:	3b01      	subs	r3, #1
 801a9aa:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a9ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a9ae:	1c5a      	adds	r2, r3, #1
 801a9b0:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801a9b2:	781b      	ldrb	r3, [r3, #0]
 801a9b4:	021b      	lsls	r3, r3, #8
 801a9b6:	623b      	str	r3, [r7, #32]
 801a9b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a9ba:	2b00      	cmp	r3, #0
 801a9bc:	d10e      	bne.n	801a9dc <get_sof+0x92>
 801a9be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a9c0:	68db      	ldr	r3, [r3, #12]
 801a9c2:	68f8      	ldr	r0, [r7, #12]
 801a9c4:	4798      	blx	r3
 801a9c6:	4603      	mov	r3, r0
 801a9c8:	2b00      	cmp	r3, #0
 801a9ca:	d101      	bne.n	801a9d0 <get_sof+0x86>
 801a9cc:	2300      	movs	r3, #0
 801a9ce:	e1cc      	b.n	801ad6a <get_sof+0x420>
 801a9d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a9d2:	681b      	ldr	r3, [r3, #0]
 801a9d4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801a9d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a9d8:	685b      	ldr	r3, [r3, #4]
 801a9da:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a9dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a9de:	3b01      	subs	r3, #1
 801a9e0:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a9e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a9e4:	1c5a      	adds	r2, r3, #1
 801a9e6:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801a9e8:	781b      	ldrb	r3, [r3, #0]
 801a9ea:	461a      	mov	r2, r3
 801a9ec:	6a3b      	ldr	r3, [r7, #32]
 801a9ee:	4413      	add	r3, r2
 801a9f0:	623b      	str	r3, [r7, #32]

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
 801a9f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a9f4:	2b00      	cmp	r3, #0
 801a9f6:	d10e      	bne.n	801aa16 <get_sof+0xcc>
 801a9f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a9fa:	68db      	ldr	r3, [r3, #12]
 801a9fc:	68f8      	ldr	r0, [r7, #12]
 801a9fe:	4798      	blx	r3
 801aa00:	4603      	mov	r3, r0
 801aa02:	2b00      	cmp	r3, #0
 801aa04:	d101      	bne.n	801aa0a <get_sof+0xc0>
 801aa06:	2300      	movs	r3, #0
 801aa08:	e1af      	b.n	801ad6a <get_sof+0x420>
 801aa0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa0c:	681b      	ldr	r3, [r3, #0]
 801aa0e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801aa10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa12:	685b      	ldr	r3, [r3, #4]
 801aa14:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aa18:	3b01      	subs	r3, #1
 801aa1a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801aa1e:	1c5a      	adds	r2, r3, #1
 801aa20:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801aa22:	781b      	ldrb	r3, [r3, #0]
 801aa24:	461a      	mov	r2, r3
 801aa26:	68fb      	ldr	r3, [r7, #12]
 801aa28:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
 801aa2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aa2e:	2b00      	cmp	r3, #0
 801aa30:	d10e      	bne.n	801aa50 <get_sof+0x106>
 801aa32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa34:	68db      	ldr	r3, [r3, #12]
 801aa36:	68f8      	ldr	r0, [r7, #12]
 801aa38:	4798      	blx	r3
 801aa3a:	4603      	mov	r3, r0
 801aa3c:	2b00      	cmp	r3, #0
 801aa3e:	d101      	bne.n	801aa44 <get_sof+0xfa>
 801aa40:	2300      	movs	r3, #0
 801aa42:	e192      	b.n	801ad6a <get_sof+0x420>
 801aa44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa46:	681b      	ldr	r3, [r3, #0]
 801aa48:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801aa4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa4c:	685b      	ldr	r3, [r3, #4]
 801aa4e:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aa52:	3b01      	subs	r3, #1
 801aa54:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801aa58:	1c5a      	adds	r2, r3, #1
 801aa5a:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801aa5c:	781b      	ldrb	r3, [r3, #0]
 801aa5e:	021a      	lsls	r2, r3, #8
 801aa60:	68fb      	ldr	r3, [r7, #12]
 801aa62:	621a      	str	r2, [r3, #32]
 801aa64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aa66:	2b00      	cmp	r3, #0
 801aa68:	d10e      	bne.n	801aa88 <get_sof+0x13e>
 801aa6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa6c:	68db      	ldr	r3, [r3, #12]
 801aa6e:	68f8      	ldr	r0, [r7, #12]
 801aa70:	4798      	blx	r3
 801aa72:	4603      	mov	r3, r0
 801aa74:	2b00      	cmp	r3, #0
 801aa76:	d101      	bne.n	801aa7c <get_sof+0x132>
 801aa78:	2300      	movs	r3, #0
 801aa7a:	e176      	b.n	801ad6a <get_sof+0x420>
 801aa7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa7e:	681b      	ldr	r3, [r3, #0]
 801aa80:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801aa82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aa84:	685b      	ldr	r3, [r3, #4]
 801aa86:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aa8a:	3b01      	subs	r3, #1
 801aa8c:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aa8e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801aa90:	1c5a      	adds	r2, r3, #1
 801aa92:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801aa94:	781a      	ldrb	r2, [r3, #0]
 801aa96:	68fb      	ldr	r3, [r7, #12]
 801aa98:	6a1b      	ldr	r3, [r3, #32]
 801aa9a:	441a      	add	r2, r3
 801aa9c:	68fb      	ldr	r3, [r7, #12]
 801aa9e:	621a      	str	r2, [r3, #32]
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
 801aaa0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aaa2:	2b00      	cmp	r3, #0
 801aaa4:	d10e      	bne.n	801aac4 <get_sof+0x17a>
 801aaa6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aaa8:	68db      	ldr	r3, [r3, #12]
 801aaaa:	68f8      	ldr	r0, [r7, #12]
 801aaac:	4798      	blx	r3
 801aaae:	4603      	mov	r3, r0
 801aab0:	2b00      	cmp	r3, #0
 801aab2:	d101      	bne.n	801aab8 <get_sof+0x16e>
 801aab4:	2300      	movs	r3, #0
 801aab6:	e158      	b.n	801ad6a <get_sof+0x420>
 801aab8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aaba:	681b      	ldr	r3, [r3, #0]
 801aabc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801aabe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aac0:	685b      	ldr	r3, [r3, #4]
 801aac2:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aac4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aac6:	3b01      	subs	r3, #1
 801aac8:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aaca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801aacc:	1c5a      	adds	r2, r3, #1
 801aace:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801aad0:	781b      	ldrb	r3, [r3, #0]
 801aad2:	021a      	lsls	r2, r3, #8
 801aad4:	68fb      	ldr	r3, [r7, #12]
 801aad6:	61da      	str	r2, [r3, #28]
 801aad8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aada:	2b00      	cmp	r3, #0
 801aadc:	d10e      	bne.n	801aafc <get_sof+0x1b2>
 801aade:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aae0:	68db      	ldr	r3, [r3, #12]
 801aae2:	68f8      	ldr	r0, [r7, #12]
 801aae4:	4798      	blx	r3
 801aae6:	4603      	mov	r3, r0
 801aae8:	2b00      	cmp	r3, #0
 801aaea:	d101      	bne.n	801aaf0 <get_sof+0x1a6>
 801aaec:	2300      	movs	r3, #0
 801aaee:	e13c      	b.n	801ad6a <get_sof+0x420>
 801aaf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aaf2:	681b      	ldr	r3, [r3, #0]
 801aaf4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801aaf6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aaf8:	685b      	ldr	r3, [r3, #4]
 801aafa:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aafc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aafe:	3b01      	subs	r3, #1
 801ab00:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ab02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ab04:	1c5a      	adds	r2, r3, #1
 801ab06:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801ab08:	781a      	ldrb	r2, [r3, #0]
 801ab0a:	68fb      	ldr	r3, [r7, #12]
 801ab0c:	69db      	ldr	r3, [r3, #28]
 801ab0e:	441a      	add	r2, r3
 801ab10:	68fb      	ldr	r3, [r7, #12]
 801ab12:	61da      	str	r2, [r3, #28]
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
 801ab14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ab16:	2b00      	cmp	r3, #0
 801ab18:	d10e      	bne.n	801ab38 <get_sof+0x1ee>
 801ab1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ab1c:	68db      	ldr	r3, [r3, #12]
 801ab1e:	68f8      	ldr	r0, [r7, #12]
 801ab20:	4798      	blx	r3
 801ab22:	4603      	mov	r3, r0
 801ab24:	2b00      	cmp	r3, #0
 801ab26:	d101      	bne.n	801ab2c <get_sof+0x1e2>
 801ab28:	2300      	movs	r3, #0
 801ab2a:	e11e      	b.n	801ad6a <get_sof+0x420>
 801ab2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ab2e:	681b      	ldr	r3, [r3, #0]
 801ab30:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ab32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ab34:	685b      	ldr	r3, [r3, #4]
 801ab36:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ab38:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ab3a:	3b01      	subs	r3, #1
 801ab3c:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ab3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ab40:	1c5a      	adds	r2, r3, #1
 801ab42:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801ab44:	781b      	ldrb	r3, [r3, #0]
 801ab46:	461a      	mov	r2, r3
 801ab48:	68fb      	ldr	r3, [r7, #12]
 801ab4a:	625a      	str	r2, [r3, #36]	@ 0x24

  length -= 8;
 801ab4c:	6a3b      	ldr	r3, [r7, #32]
 801ab4e:	3b08      	subs	r3, #8
 801ab50:	623b      	str	r3, [r7, #32]

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
 801ab52:	68fb      	ldr	r3, [r7, #12]
 801ab54:	681b      	ldr	r3, [r3, #0]
 801ab56:	3318      	adds	r3, #24
 801ab58:	61fb      	str	r3, [r7, #28]
 801ab5a:	68fb      	ldr	r3, [r7, #12]
 801ab5c:	f8d3 21b4 	ldr.w	r2, [r3, #436]	@ 0x1b4
 801ab60:	69fb      	ldr	r3, [r7, #28]
 801ab62:	601a      	str	r2, [r3, #0]
 801ab64:	68fb      	ldr	r3, [r7, #12]
 801ab66:	69da      	ldr	r2, [r3, #28]
 801ab68:	69fb      	ldr	r3, [r7, #28]
 801ab6a:	3304      	adds	r3, #4
 801ab6c:	601a      	str	r2, [r3, #0]
 801ab6e:	68fb      	ldr	r3, [r7, #12]
 801ab70:	6a1a      	ldr	r2, [r3, #32]
 801ab72:	69fb      	ldr	r3, [r7, #28]
 801ab74:	3308      	adds	r3, #8
 801ab76:	601a      	str	r2, [r3, #0]
 801ab78:	69fb      	ldr	r3, [r7, #28]
 801ab7a:	330c      	adds	r3, #12
 801ab7c:	68fa      	ldr	r2, [r7, #12]
 801ab7e:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801ab80:	601a      	str	r2, [r3, #0]
 801ab82:	68fb      	ldr	r3, [r7, #12]
 801ab84:	681b      	ldr	r3, [r3, #0]
 801ab86:	2266      	movs	r2, #102	@ 0x66
 801ab88:	615a      	str	r2, [r3, #20]
 801ab8a:	68fb      	ldr	r3, [r7, #12]
 801ab8c:	681b      	ldr	r3, [r3, #0]
 801ab8e:	685b      	ldr	r3, [r3, #4]
 801ab90:	2101      	movs	r1, #1
 801ab92:	68f8      	ldr	r0, [r7, #12]
 801ab94:	4798      	blx	r3
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
 801ab96:	68fb      	ldr	r3, [r7, #12]
 801ab98:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ab9c:	691b      	ldr	r3, [r3, #16]
 801ab9e:	2b00      	cmp	r3, #0
 801aba0:	d008      	beq.n	801abb4 <get_sof+0x26a>
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);
 801aba2:	68fb      	ldr	r3, [r7, #12]
 801aba4:	681b      	ldr	r3, [r3, #0]
 801aba6:	223c      	movs	r2, #60	@ 0x3c
 801aba8:	615a      	str	r2, [r3, #20]
 801abaa:	68fb      	ldr	r3, [r7, #12]
 801abac:	681b      	ldr	r3, [r3, #0]
 801abae:	681b      	ldr	r3, [r3, #0]
 801abb0:	68f8      	ldr	r0, [r7, #12]
 801abb2:	4798      	blx	r3

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
 801abb4:	68fb      	ldr	r3, [r7, #12]
 801abb6:	6a1b      	ldr	r3, [r3, #32]
 801abb8:	2b00      	cmp	r3, #0
 801abba:	d007      	beq.n	801abcc <get_sof+0x282>
 801abbc:	68fb      	ldr	r3, [r7, #12]
 801abbe:	69db      	ldr	r3, [r3, #28]
 801abc0:	2b00      	cmp	r3, #0
 801abc2:	d003      	beq.n	801abcc <get_sof+0x282>
      || cinfo->num_components <= 0)
 801abc4:	68fb      	ldr	r3, [r7, #12]
 801abc6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801abc8:	2b00      	cmp	r3, #0
 801abca:	dc08      	bgt.n	801abde <get_sof+0x294>
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);
 801abcc:	68fb      	ldr	r3, [r7, #12]
 801abce:	681b      	ldr	r3, [r3, #0]
 801abd0:	2221      	movs	r2, #33	@ 0x21
 801abd2:	615a      	str	r2, [r3, #20]
 801abd4:	68fb      	ldr	r3, [r7, #12]
 801abd6:	681b      	ldr	r3, [r3, #0]
 801abd8:	681b      	ldr	r3, [r3, #0]
 801abda:	68f8      	ldr	r0, [r7, #12]
 801abdc:	4798      	blx	r3

  if (length != (cinfo->num_components * 3))
 801abde:	68fb      	ldr	r3, [r7, #12]
 801abe0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801abe2:	4613      	mov	r3, r2
 801abe4:	005b      	lsls	r3, r3, #1
 801abe6:	4413      	add	r3, r2
 801abe8:	6a3a      	ldr	r2, [r7, #32]
 801abea:	429a      	cmp	r2, r3
 801abec:	d008      	beq.n	801ac00 <get_sof+0x2b6>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801abee:	68fb      	ldr	r3, [r7, #12]
 801abf0:	681b      	ldr	r3, [r3, #0]
 801abf2:	220c      	movs	r2, #12
 801abf4:	615a      	str	r2, [r3, #20]
 801abf6:	68fb      	ldr	r3, [r7, #12]
 801abf8:	681b      	ldr	r3, [r3, #0]
 801abfa:	681b      	ldr	r3, [r3, #0]
 801abfc:	68f8      	ldr	r0, [r7, #12]
 801abfe:	4798      	blx	r3

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
 801ac00:	68fb      	ldr	r3, [r7, #12]
 801ac02:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801ac06:	2b00      	cmp	r3, #0
 801ac08:	d10f      	bne.n	801ac2a <get_sof+0x2e0>
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 801ac0a:	68fb      	ldr	r3, [r7, #12]
 801ac0c:	685b      	ldr	r3, [r3, #4]
 801ac0e:	681b      	ldr	r3, [r3, #0]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));
 801ac10:	68fa      	ldr	r2, [r7, #12]
 801ac12:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801ac14:	4611      	mov	r1, r2
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 801ac16:	2258      	movs	r2, #88	@ 0x58
 801ac18:	fb01 f202 	mul.w	r2, r1, r2
 801ac1c:	2101      	movs	r1, #1
 801ac1e:	68f8      	ldr	r0, [r7, #12]
 801ac20:	4798      	blx	r3
 801ac22:	4602      	mov	r2, r0
 801ac24:	68fb      	ldr	r3, [r7, #12]
 801ac26:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801ac2a:	2300      	movs	r3, #0
 801ac2c:	637b      	str	r3, [r7, #52]	@ 0x34
 801ac2e:	68fb      	ldr	r3, [r7, #12]
 801ac30:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801ac34:	633b      	str	r3, [r7, #48]	@ 0x30
 801ac36:	e086      	b.n	801ad46 <get_sof+0x3fc>
       ci++, compptr++) {
    compptr->component_index = ci;
 801ac38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ac3a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801ac3c:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
 801ac3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac40:	2b00      	cmp	r3, #0
 801ac42:	d10e      	bne.n	801ac62 <get_sof+0x318>
 801ac44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac46:	68db      	ldr	r3, [r3, #12]
 801ac48:	68f8      	ldr	r0, [r7, #12]
 801ac4a:	4798      	blx	r3
 801ac4c:	4603      	mov	r3, r0
 801ac4e:	2b00      	cmp	r3, #0
 801ac50:	d101      	bne.n	801ac56 <get_sof+0x30c>
 801ac52:	2300      	movs	r3, #0
 801ac54:	e089      	b.n	801ad6a <get_sof+0x420>
 801ac56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac58:	681b      	ldr	r3, [r3, #0]
 801ac5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ac5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac5e:	685b      	ldr	r3, [r3, #4]
 801ac60:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ac62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac64:	3b01      	subs	r3, #1
 801ac66:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ac68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ac6a:	1c5a      	adds	r2, r3, #1
 801ac6c:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801ac6e:	781b      	ldrb	r3, [r3, #0]
 801ac70:	461a      	mov	r2, r3
 801ac72:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ac74:	601a      	str	r2, [r3, #0]
    INPUT_BYTE(cinfo, c, return FALSE);
 801ac76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac78:	2b00      	cmp	r3, #0
 801ac7a:	d10e      	bne.n	801ac9a <get_sof+0x350>
 801ac7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac7e:	68db      	ldr	r3, [r3, #12]
 801ac80:	68f8      	ldr	r0, [r7, #12]
 801ac82:	4798      	blx	r3
 801ac84:	4603      	mov	r3, r0
 801ac86:	2b00      	cmp	r3, #0
 801ac88:	d101      	bne.n	801ac8e <get_sof+0x344>
 801ac8a:	2300      	movs	r3, #0
 801ac8c:	e06d      	b.n	801ad6a <get_sof+0x420>
 801ac8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac90:	681b      	ldr	r3, [r3, #0]
 801ac92:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ac94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ac96:	685b      	ldr	r3, [r3, #4]
 801ac98:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ac9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac9c:	3b01      	subs	r3, #1
 801ac9e:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aca0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801aca2:	1c5a      	adds	r2, r3, #1
 801aca4:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801aca6:	781b      	ldrb	r3, [r3, #0]
 801aca8:	61bb      	str	r3, [r7, #24]
    compptr->h_samp_factor = (c >> 4) & 15;
 801acaa:	69bb      	ldr	r3, [r7, #24]
 801acac:	111b      	asrs	r3, r3, #4
 801acae:	f003 020f 	and.w	r2, r3, #15
 801acb2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801acb4:	609a      	str	r2, [r3, #8]
    compptr->v_samp_factor = (c     ) & 15;
 801acb6:	69bb      	ldr	r3, [r7, #24]
 801acb8:	f003 020f 	and.w	r2, r3, #15
 801acbc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801acbe:	60da      	str	r2, [r3, #12]
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
 801acc0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801acc2:	2b00      	cmp	r3, #0
 801acc4:	d10e      	bne.n	801ace4 <get_sof+0x39a>
 801acc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801acc8:	68db      	ldr	r3, [r3, #12]
 801acca:	68f8      	ldr	r0, [r7, #12]
 801accc:	4798      	blx	r3
 801acce:	4603      	mov	r3, r0
 801acd0:	2b00      	cmp	r3, #0
 801acd2:	d101      	bne.n	801acd8 <get_sof+0x38e>
 801acd4:	2300      	movs	r3, #0
 801acd6:	e048      	b.n	801ad6a <get_sof+0x420>
 801acd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801acda:	681b      	ldr	r3, [r3, #0]
 801acdc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801acde:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ace0:	685b      	ldr	r3, [r3, #4]
 801ace2:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ace4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ace6:	3b01      	subs	r3, #1
 801ace8:	62bb      	str	r3, [r7, #40]	@ 0x28
 801acea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801acec:	1c5a      	adds	r2, r3, #1
 801acee:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801acf0:	781b      	ldrb	r3, [r3, #0]
 801acf2:	461a      	mov	r2, r3
 801acf4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801acf6:	611a      	str	r2, [r3, #16]

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
 801acf8:	68fb      	ldr	r3, [r7, #12]
 801acfa:	681b      	ldr	r3, [r3, #0]
 801acfc:	3318      	adds	r3, #24
 801acfe:	617b      	str	r3, [r7, #20]
 801ad00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ad02:	681a      	ldr	r2, [r3, #0]
 801ad04:	697b      	ldr	r3, [r7, #20]
 801ad06:	601a      	str	r2, [r3, #0]
 801ad08:	697b      	ldr	r3, [r7, #20]
 801ad0a:	3304      	adds	r3, #4
 801ad0c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ad0e:	6892      	ldr	r2, [r2, #8]
 801ad10:	601a      	str	r2, [r3, #0]
 801ad12:	697b      	ldr	r3, [r7, #20]
 801ad14:	3308      	adds	r3, #8
 801ad16:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ad18:	68d2      	ldr	r2, [r2, #12]
 801ad1a:	601a      	str	r2, [r3, #0]
 801ad1c:	697b      	ldr	r3, [r7, #20]
 801ad1e:	330c      	adds	r3, #12
 801ad20:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ad22:	6912      	ldr	r2, [r2, #16]
 801ad24:	601a      	str	r2, [r3, #0]
 801ad26:	68fb      	ldr	r3, [r7, #12]
 801ad28:	681b      	ldr	r3, [r3, #0]
 801ad2a:	2267      	movs	r2, #103	@ 0x67
 801ad2c:	615a      	str	r2, [r3, #20]
 801ad2e:	68fb      	ldr	r3, [r7, #12]
 801ad30:	681b      	ldr	r3, [r3, #0]
 801ad32:	685b      	ldr	r3, [r3, #4]
 801ad34:	2101      	movs	r1, #1
 801ad36:	68f8      	ldr	r0, [r7, #12]
 801ad38:	4798      	blx	r3
       ci++, compptr++) {
 801ad3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ad3c:	3301      	adds	r3, #1
 801ad3e:	637b      	str	r3, [r7, #52]	@ 0x34
 801ad40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ad42:	3358      	adds	r3, #88	@ 0x58
 801ad44:	633b      	str	r3, [r7, #48]	@ 0x30
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801ad46:	68fb      	ldr	r3, [r7, #12]
 801ad48:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801ad4a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801ad4c:	429a      	cmp	r2, r3
 801ad4e:	f6ff af73 	blt.w	801ac38 <get_sof+0x2ee>
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;
 801ad52:	68fb      	ldr	r3, [r7, #12]
 801ad54:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ad58:	2201      	movs	r2, #1
 801ad5a:	611a      	str	r2, [r3, #16]

  INPUT_SYNC(cinfo);
 801ad5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ad5e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801ad60:	601a      	str	r2, [r3, #0]
 801ad62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ad64:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ad66:	605a      	str	r2, [r3, #4]
  return TRUE;
 801ad68:	2301      	movs	r3, #1
}
 801ad6a:	4618      	mov	r0, r3
 801ad6c:	3738      	adds	r7, #56	@ 0x38
 801ad6e:	46bd      	mov	sp, r7
 801ad70:	bd80      	pop	{r7, pc}

0801ad72 <get_sos>:


LOCAL(boolean)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
 801ad72:	b580      	push	{r7, lr}
 801ad74:	b08e      	sub	sp, #56	@ 0x38
 801ad76:	af00      	add	r7, sp, #0
 801ad78:	6078      	str	r0, [r7, #4]
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 801ad7a:	687b      	ldr	r3, [r7, #4]
 801ad7c:	699b      	ldr	r3, [r3, #24]
 801ad7e:	623b      	str	r3, [r7, #32]
 801ad80:	6a3b      	ldr	r3, [r7, #32]
 801ad82:	681b      	ldr	r3, [r3, #0]
 801ad84:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ad86:	6a3b      	ldr	r3, [r7, #32]
 801ad88:	685b      	ldr	r3, [r3, #4]
 801ad8a:	627b      	str	r3, [r7, #36]	@ 0x24

  if (! cinfo->marker->saw_SOF)
 801ad8c:	687b      	ldr	r3, [r7, #4]
 801ad8e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ad92:	691b      	ldr	r3, [r3, #16]
 801ad94:	2b00      	cmp	r3, #0
 801ad96:	d108      	bne.n	801adaa <get_sos+0x38>
    ERREXIT(cinfo, JERR_SOS_NO_SOF);
 801ad98:	687b      	ldr	r3, [r7, #4]
 801ad9a:	681b      	ldr	r3, [r3, #0]
 801ad9c:	2240      	movs	r2, #64	@ 0x40
 801ad9e:	615a      	str	r2, [r3, #20]
 801ada0:	687b      	ldr	r3, [r7, #4]
 801ada2:	681b      	ldr	r3, [r3, #0]
 801ada4:	681b      	ldr	r3, [r3, #0]
 801ada6:	6878      	ldr	r0, [r7, #4]
 801ada8:	4798      	blx	r3

  INPUT_2BYTES(cinfo, length, return FALSE);
 801adaa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801adac:	2b00      	cmp	r3, #0
 801adae:	d10e      	bne.n	801adce <get_sos+0x5c>
 801adb0:	6a3b      	ldr	r3, [r7, #32]
 801adb2:	68db      	ldr	r3, [r3, #12]
 801adb4:	6878      	ldr	r0, [r7, #4]
 801adb6:	4798      	blx	r3
 801adb8:	4603      	mov	r3, r0
 801adba:	2b00      	cmp	r3, #0
 801adbc:	d101      	bne.n	801adc2 <get_sos+0x50>
 801adbe:	2300      	movs	r3, #0
 801adc0:	e1a1      	b.n	801b106 <get_sos+0x394>
 801adc2:	6a3b      	ldr	r3, [r7, #32]
 801adc4:	681b      	ldr	r3, [r3, #0]
 801adc6:	62bb      	str	r3, [r7, #40]	@ 0x28
 801adc8:	6a3b      	ldr	r3, [r7, #32]
 801adca:	685b      	ldr	r3, [r3, #4]
 801adcc:	627b      	str	r3, [r7, #36]	@ 0x24
 801adce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801add0:	3b01      	subs	r3, #1
 801add2:	627b      	str	r3, [r7, #36]	@ 0x24
 801add4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801add6:	1c5a      	adds	r2, r3, #1
 801add8:	62ba      	str	r2, [r7, #40]	@ 0x28
 801adda:	781b      	ldrb	r3, [r3, #0]
 801addc:	021b      	lsls	r3, r3, #8
 801adde:	61fb      	str	r3, [r7, #28]
 801ade0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ade2:	2b00      	cmp	r3, #0
 801ade4:	d10e      	bne.n	801ae04 <get_sos+0x92>
 801ade6:	6a3b      	ldr	r3, [r7, #32]
 801ade8:	68db      	ldr	r3, [r3, #12]
 801adea:	6878      	ldr	r0, [r7, #4]
 801adec:	4798      	blx	r3
 801adee:	4603      	mov	r3, r0
 801adf0:	2b00      	cmp	r3, #0
 801adf2:	d101      	bne.n	801adf8 <get_sos+0x86>
 801adf4:	2300      	movs	r3, #0
 801adf6:	e186      	b.n	801b106 <get_sos+0x394>
 801adf8:	6a3b      	ldr	r3, [r7, #32]
 801adfa:	681b      	ldr	r3, [r3, #0]
 801adfc:	62bb      	str	r3, [r7, #40]	@ 0x28
 801adfe:	6a3b      	ldr	r3, [r7, #32]
 801ae00:	685b      	ldr	r3, [r3, #4]
 801ae02:	627b      	str	r3, [r7, #36]	@ 0x24
 801ae04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ae06:	3b01      	subs	r3, #1
 801ae08:	627b      	str	r3, [r7, #36]	@ 0x24
 801ae0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ae0c:	1c5a      	adds	r2, r3, #1
 801ae0e:	62ba      	str	r2, [r7, #40]	@ 0x28
 801ae10:	781b      	ldrb	r3, [r3, #0]
 801ae12:	461a      	mov	r2, r3
 801ae14:	69fb      	ldr	r3, [r7, #28]
 801ae16:	4413      	add	r3, r2
 801ae18:	61fb      	str	r3, [r7, #28]

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
 801ae1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ae1c:	2b00      	cmp	r3, #0
 801ae1e:	d10e      	bne.n	801ae3e <get_sos+0xcc>
 801ae20:	6a3b      	ldr	r3, [r7, #32]
 801ae22:	68db      	ldr	r3, [r3, #12]
 801ae24:	6878      	ldr	r0, [r7, #4]
 801ae26:	4798      	blx	r3
 801ae28:	4603      	mov	r3, r0
 801ae2a:	2b00      	cmp	r3, #0
 801ae2c:	d101      	bne.n	801ae32 <get_sos+0xc0>
 801ae2e:	2300      	movs	r3, #0
 801ae30:	e169      	b.n	801b106 <get_sos+0x394>
 801ae32:	6a3b      	ldr	r3, [r7, #32]
 801ae34:	681b      	ldr	r3, [r3, #0]
 801ae36:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ae38:	6a3b      	ldr	r3, [r7, #32]
 801ae3a:	685b      	ldr	r3, [r3, #4]
 801ae3c:	627b      	str	r3, [r7, #36]	@ 0x24
 801ae3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ae40:	3b01      	subs	r3, #1
 801ae42:	627b      	str	r3, [r7, #36]	@ 0x24
 801ae44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ae46:	1c5a      	adds	r2, r3, #1
 801ae48:	62ba      	str	r2, [r7, #40]	@ 0x28
 801ae4a:	781b      	ldrb	r3, [r3, #0]
 801ae4c:	61bb      	str	r3, [r7, #24]

  TRACEMS1(cinfo, 1, JTRC_SOS, n);
 801ae4e:	687b      	ldr	r3, [r7, #4]
 801ae50:	681b      	ldr	r3, [r3, #0]
 801ae52:	2269      	movs	r2, #105	@ 0x69
 801ae54:	615a      	str	r2, [r3, #20]
 801ae56:	687b      	ldr	r3, [r7, #4]
 801ae58:	681b      	ldr	r3, [r3, #0]
 801ae5a:	69ba      	ldr	r2, [r7, #24]
 801ae5c:	619a      	str	r2, [r3, #24]
 801ae5e:	687b      	ldr	r3, [r7, #4]
 801ae60:	681b      	ldr	r3, [r3, #0]
 801ae62:	685b      	ldr	r3, [r3, #4]
 801ae64:	2101      	movs	r1, #1
 801ae66:	6878      	ldr	r0, [r7, #4]
 801ae68:	4798      	blx	r3

  if (length != (n * 2 + 6) || n > MAX_COMPS_IN_SCAN ||
 801ae6a:	69bb      	ldr	r3, [r7, #24]
 801ae6c:	3303      	adds	r3, #3
 801ae6e:	005b      	lsls	r3, r3, #1
 801ae70:	69fa      	ldr	r2, [r7, #28]
 801ae72:	429a      	cmp	r2, r3
 801ae74:	d10a      	bne.n	801ae8c <get_sos+0x11a>
 801ae76:	69bb      	ldr	r3, [r7, #24]
 801ae78:	2b04      	cmp	r3, #4
 801ae7a:	dc07      	bgt.n	801ae8c <get_sos+0x11a>
 801ae7c:	69bb      	ldr	r3, [r7, #24]
 801ae7e:	2b00      	cmp	r3, #0
 801ae80:	d10d      	bne.n	801ae9e <get_sos+0x12c>
      (n == 0 && !cinfo->progressive_mode))
 801ae82:	687b      	ldr	r3, [r7, #4]
 801ae84:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801ae88:	2b00      	cmp	r3, #0
 801ae8a:	d108      	bne.n	801ae9e <get_sos+0x12c>
      /* pseudo SOS marker only allowed in progressive mode */
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801ae8c:	687b      	ldr	r3, [r7, #4]
 801ae8e:	681b      	ldr	r3, [r3, #0]
 801ae90:	220c      	movs	r2, #12
 801ae92:	615a      	str	r2, [r3, #20]
 801ae94:	687b      	ldr	r3, [r7, #4]
 801ae96:	681b      	ldr	r3, [r3, #0]
 801ae98:	681b      	ldr	r3, [r3, #0]
 801ae9a:	6878      	ldr	r0, [r7, #4]
 801ae9c:	4798      	blx	r3

  cinfo->comps_in_scan = n;
 801ae9e:	687b      	ldr	r3, [r7, #4]
 801aea0:	69ba      	ldr	r2, [r7, #24]
 801aea2:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
 801aea6:	2300      	movs	r3, #0
 801aea8:	637b      	str	r3, [r7, #52]	@ 0x34
 801aeaa:	e089      	b.n	801afc0 <get_sos+0x24e>
    INPUT_BYTE(cinfo, cc, return FALSE);
 801aeac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aeae:	2b00      	cmp	r3, #0
 801aeb0:	d10e      	bne.n	801aed0 <get_sos+0x15e>
 801aeb2:	6a3b      	ldr	r3, [r7, #32]
 801aeb4:	68db      	ldr	r3, [r3, #12]
 801aeb6:	6878      	ldr	r0, [r7, #4]
 801aeb8:	4798      	blx	r3
 801aeba:	4603      	mov	r3, r0
 801aebc:	2b00      	cmp	r3, #0
 801aebe:	d101      	bne.n	801aec4 <get_sos+0x152>
 801aec0:	2300      	movs	r3, #0
 801aec2:	e120      	b.n	801b106 <get_sos+0x394>
 801aec4:	6a3b      	ldr	r3, [r7, #32]
 801aec6:	681b      	ldr	r3, [r3, #0]
 801aec8:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aeca:	6a3b      	ldr	r3, [r7, #32]
 801aecc:	685b      	ldr	r3, [r3, #4]
 801aece:	627b      	str	r3, [r7, #36]	@ 0x24
 801aed0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aed2:	3b01      	subs	r3, #1
 801aed4:	627b      	str	r3, [r7, #36]	@ 0x24
 801aed6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aed8:	1c5a      	adds	r2, r3, #1
 801aeda:	62ba      	str	r2, [r7, #40]	@ 0x28
 801aedc:	781b      	ldrb	r3, [r3, #0]
 801aede:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, c, return FALSE);
 801aee0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aee2:	2b00      	cmp	r3, #0
 801aee4:	d10e      	bne.n	801af04 <get_sos+0x192>
 801aee6:	6a3b      	ldr	r3, [r7, #32]
 801aee8:	68db      	ldr	r3, [r3, #12]
 801aeea:	6878      	ldr	r0, [r7, #4]
 801aeec:	4798      	blx	r3
 801aeee:	4603      	mov	r3, r0
 801aef0:	2b00      	cmp	r3, #0
 801aef2:	d101      	bne.n	801aef8 <get_sos+0x186>
 801aef4:	2300      	movs	r3, #0
 801aef6:	e106      	b.n	801b106 <get_sos+0x394>
 801aef8:	6a3b      	ldr	r3, [r7, #32]
 801aefa:	681b      	ldr	r3, [r3, #0]
 801aefc:	62bb      	str	r3, [r7, #40]	@ 0x28
 801aefe:	6a3b      	ldr	r3, [r7, #32]
 801af00:	685b      	ldr	r3, [r3, #4]
 801af02:	627b      	str	r3, [r7, #36]	@ 0x24
 801af04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801af06:	3b01      	subs	r3, #1
 801af08:	627b      	str	r3, [r7, #36]	@ 0x24
 801af0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801af0c:	1c5a      	adds	r2, r3, #1
 801af0e:	62ba      	str	r2, [r7, #40]	@ 0x28
 801af10:	781b      	ldrb	r3, [r3, #0]
 801af12:	617b      	str	r3, [r7, #20]
    
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801af14:	2300      	movs	r3, #0
 801af16:	633b      	str	r3, [r7, #48]	@ 0x30
 801af18:	687b      	ldr	r3, [r7, #4]
 801af1a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801af1e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801af20:	e00a      	b.n	801af38 <get_sos+0x1c6>
	 ci++, compptr++) {
      if (cc == compptr->component_id)
 801af22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801af24:	681b      	ldr	r3, [r3, #0]
 801af26:	68fa      	ldr	r2, [r7, #12]
 801af28:	429a      	cmp	r2, r3
 801af2a:	d018      	beq.n	801af5e <get_sos+0x1ec>
	 ci++, compptr++) {
 801af2c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801af2e:	3301      	adds	r3, #1
 801af30:	633b      	str	r3, [r7, #48]	@ 0x30
 801af32:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801af34:	3358      	adds	r3, #88	@ 0x58
 801af36:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801af38:	687b      	ldr	r3, [r7, #4]
 801af3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801af3c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801af3e:	429a      	cmp	r2, r3
 801af40:	dbef      	blt.n	801af22 <get_sos+0x1b0>
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
 801af42:	687b      	ldr	r3, [r7, #4]
 801af44:	681b      	ldr	r3, [r3, #0]
 801af46:	2204      	movs	r2, #4
 801af48:	615a      	str	r2, [r3, #20]
 801af4a:	687b      	ldr	r3, [r7, #4]
 801af4c:	681b      	ldr	r3, [r3, #0]
 801af4e:	68fa      	ldr	r2, [r7, #12]
 801af50:	619a      	str	r2, [r3, #24]
 801af52:	687b      	ldr	r3, [r7, #4]
 801af54:	681b      	ldr	r3, [r3, #0]
 801af56:	681b      	ldr	r3, [r3, #0]
 801af58:	6878      	ldr	r0, [r7, #4]
 801af5a:	4798      	blx	r3
 801af5c:	e000      	b.n	801af60 <get_sos+0x1ee>
	goto id_found;
 801af5e:	bf00      	nop

  id_found:

    cinfo->cur_comp_info[i] = compptr;
 801af60:	687a      	ldr	r2, [r7, #4]
 801af62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801af64:	3354      	adds	r3, #84	@ 0x54
 801af66:	009b      	lsls	r3, r3, #2
 801af68:	4413      	add	r3, r2
 801af6a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801af6c:	605a      	str	r2, [r3, #4]
    compptr->dc_tbl_no = (c >> 4) & 15;
 801af6e:	697b      	ldr	r3, [r7, #20]
 801af70:	111b      	asrs	r3, r3, #4
 801af72:	f003 020f 	and.w	r2, r3, #15
 801af76:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801af78:	615a      	str	r2, [r3, #20]
    compptr->ac_tbl_no = (c     ) & 15;
 801af7a:	697b      	ldr	r3, [r7, #20]
 801af7c:	f003 020f 	and.w	r2, r3, #15
 801af80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801af82:	619a      	str	r2, [r3, #24]
    
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
 801af84:	687b      	ldr	r3, [r7, #4]
 801af86:	681b      	ldr	r3, [r3, #0]
 801af88:	3318      	adds	r3, #24
 801af8a:	60bb      	str	r3, [r7, #8]
 801af8c:	68bb      	ldr	r3, [r7, #8]
 801af8e:	68fa      	ldr	r2, [r7, #12]
 801af90:	601a      	str	r2, [r3, #0]
 801af92:	68bb      	ldr	r3, [r7, #8]
 801af94:	3304      	adds	r3, #4
 801af96:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801af98:	6952      	ldr	r2, [r2, #20]
 801af9a:	601a      	str	r2, [r3, #0]
 801af9c:	68bb      	ldr	r3, [r7, #8]
 801af9e:	3308      	adds	r3, #8
 801afa0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801afa2:	6992      	ldr	r2, [r2, #24]
 801afa4:	601a      	str	r2, [r3, #0]
 801afa6:	687b      	ldr	r3, [r7, #4]
 801afa8:	681b      	ldr	r3, [r3, #0]
 801afaa:	226a      	movs	r2, #106	@ 0x6a
 801afac:	615a      	str	r2, [r3, #20]
 801afae:	687b      	ldr	r3, [r7, #4]
 801afb0:	681b      	ldr	r3, [r3, #0]
 801afb2:	685b      	ldr	r3, [r3, #4]
 801afb4:	2101      	movs	r1, #1
 801afb6:	6878      	ldr	r0, [r7, #4]
 801afb8:	4798      	blx	r3
  for (i = 0; i < n; i++) {
 801afba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801afbc:	3301      	adds	r3, #1
 801afbe:	637b      	str	r3, [r7, #52]	@ 0x34
 801afc0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801afc2:	69bb      	ldr	r3, [r7, #24]
 801afc4:	429a      	cmp	r2, r3
 801afc6:	f6ff af71 	blt.w	801aeac <get_sos+0x13a>
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
 801afca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801afcc:	2b00      	cmp	r3, #0
 801afce:	d10e      	bne.n	801afee <get_sos+0x27c>
 801afd0:	6a3b      	ldr	r3, [r7, #32]
 801afd2:	68db      	ldr	r3, [r3, #12]
 801afd4:	6878      	ldr	r0, [r7, #4]
 801afd6:	4798      	blx	r3
 801afd8:	4603      	mov	r3, r0
 801afda:	2b00      	cmp	r3, #0
 801afdc:	d101      	bne.n	801afe2 <get_sos+0x270>
 801afde:	2300      	movs	r3, #0
 801afe0:	e091      	b.n	801b106 <get_sos+0x394>
 801afe2:	6a3b      	ldr	r3, [r7, #32]
 801afe4:	681b      	ldr	r3, [r3, #0]
 801afe6:	62bb      	str	r3, [r7, #40]	@ 0x28
 801afe8:	6a3b      	ldr	r3, [r7, #32]
 801afea:	685b      	ldr	r3, [r3, #4]
 801afec:	627b      	str	r3, [r7, #36]	@ 0x24
 801afee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801aff0:	3b01      	subs	r3, #1
 801aff2:	627b      	str	r3, [r7, #36]	@ 0x24
 801aff4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801aff6:	1c5a      	adds	r2, r3, #1
 801aff8:	62ba      	str	r2, [r7, #40]	@ 0x28
 801affa:	781b      	ldrb	r3, [r3, #0]
 801affc:	617b      	str	r3, [r7, #20]
  cinfo->Ss = c;
 801affe:	687b      	ldr	r3, [r7, #4]
 801b000:	697a      	ldr	r2, [r7, #20]
 801b002:	f8c3 2198 	str.w	r2, [r3, #408]	@ 0x198
  INPUT_BYTE(cinfo, c, return FALSE);
 801b006:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b008:	2b00      	cmp	r3, #0
 801b00a:	d10e      	bne.n	801b02a <get_sos+0x2b8>
 801b00c:	6a3b      	ldr	r3, [r7, #32]
 801b00e:	68db      	ldr	r3, [r3, #12]
 801b010:	6878      	ldr	r0, [r7, #4]
 801b012:	4798      	blx	r3
 801b014:	4603      	mov	r3, r0
 801b016:	2b00      	cmp	r3, #0
 801b018:	d101      	bne.n	801b01e <get_sos+0x2ac>
 801b01a:	2300      	movs	r3, #0
 801b01c:	e073      	b.n	801b106 <get_sos+0x394>
 801b01e:	6a3b      	ldr	r3, [r7, #32]
 801b020:	681b      	ldr	r3, [r3, #0]
 801b022:	62bb      	str	r3, [r7, #40]	@ 0x28
 801b024:	6a3b      	ldr	r3, [r7, #32]
 801b026:	685b      	ldr	r3, [r3, #4]
 801b028:	627b      	str	r3, [r7, #36]	@ 0x24
 801b02a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b02c:	3b01      	subs	r3, #1
 801b02e:	627b      	str	r3, [r7, #36]	@ 0x24
 801b030:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b032:	1c5a      	adds	r2, r3, #1
 801b034:	62ba      	str	r2, [r7, #40]	@ 0x28
 801b036:	781b      	ldrb	r3, [r3, #0]
 801b038:	617b      	str	r3, [r7, #20]
  cinfo->Se = c;
 801b03a:	687b      	ldr	r3, [r7, #4]
 801b03c:	697a      	ldr	r2, [r7, #20]
 801b03e:	f8c3 219c 	str.w	r2, [r3, #412]	@ 0x19c
  INPUT_BYTE(cinfo, c, return FALSE);
 801b042:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b044:	2b00      	cmp	r3, #0
 801b046:	d10e      	bne.n	801b066 <get_sos+0x2f4>
 801b048:	6a3b      	ldr	r3, [r7, #32]
 801b04a:	68db      	ldr	r3, [r3, #12]
 801b04c:	6878      	ldr	r0, [r7, #4]
 801b04e:	4798      	blx	r3
 801b050:	4603      	mov	r3, r0
 801b052:	2b00      	cmp	r3, #0
 801b054:	d101      	bne.n	801b05a <get_sos+0x2e8>
 801b056:	2300      	movs	r3, #0
 801b058:	e055      	b.n	801b106 <get_sos+0x394>
 801b05a:	6a3b      	ldr	r3, [r7, #32]
 801b05c:	681b      	ldr	r3, [r3, #0]
 801b05e:	62bb      	str	r3, [r7, #40]	@ 0x28
 801b060:	6a3b      	ldr	r3, [r7, #32]
 801b062:	685b      	ldr	r3, [r3, #4]
 801b064:	627b      	str	r3, [r7, #36]	@ 0x24
 801b066:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b068:	3b01      	subs	r3, #1
 801b06a:	627b      	str	r3, [r7, #36]	@ 0x24
 801b06c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b06e:	1c5a      	adds	r2, r3, #1
 801b070:	62ba      	str	r2, [r7, #40]	@ 0x28
 801b072:	781b      	ldrb	r3, [r3, #0]
 801b074:	617b      	str	r3, [r7, #20]
  cinfo->Ah = (c >> 4) & 15;
 801b076:	697b      	ldr	r3, [r7, #20]
 801b078:	111b      	asrs	r3, r3, #4
 801b07a:	f003 020f 	and.w	r2, r3, #15
 801b07e:	687b      	ldr	r3, [r7, #4]
 801b080:	f8c3 21a0 	str.w	r2, [r3, #416]	@ 0x1a0
  cinfo->Al = (c     ) & 15;
 801b084:	697b      	ldr	r3, [r7, #20]
 801b086:	f003 020f 	and.w	r2, r3, #15
 801b08a:	687b      	ldr	r3, [r7, #4]
 801b08c:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
 801b090:	687b      	ldr	r3, [r7, #4]
 801b092:	681b      	ldr	r3, [r3, #0]
 801b094:	3318      	adds	r3, #24
 801b096:	613b      	str	r3, [r7, #16]
 801b098:	687b      	ldr	r3, [r7, #4]
 801b09a:	f8d3 2198 	ldr.w	r2, [r3, #408]	@ 0x198
 801b09e:	693b      	ldr	r3, [r7, #16]
 801b0a0:	601a      	str	r2, [r3, #0]
 801b0a2:	693b      	ldr	r3, [r7, #16]
 801b0a4:	3304      	adds	r3, #4
 801b0a6:	687a      	ldr	r2, [r7, #4]
 801b0a8:	f8d2 219c 	ldr.w	r2, [r2, #412]	@ 0x19c
 801b0ac:	601a      	str	r2, [r3, #0]
 801b0ae:	693b      	ldr	r3, [r7, #16]
 801b0b0:	3308      	adds	r3, #8
 801b0b2:	687a      	ldr	r2, [r7, #4]
 801b0b4:	f8d2 21a0 	ldr.w	r2, [r2, #416]	@ 0x1a0
 801b0b8:	601a      	str	r2, [r3, #0]
 801b0ba:	693b      	ldr	r3, [r7, #16]
 801b0bc:	330c      	adds	r3, #12
 801b0be:	687a      	ldr	r2, [r7, #4]
 801b0c0:	f8d2 21a4 	ldr.w	r2, [r2, #420]	@ 0x1a4
 801b0c4:	601a      	str	r2, [r3, #0]
 801b0c6:	687b      	ldr	r3, [r7, #4]
 801b0c8:	681b      	ldr	r3, [r3, #0]
 801b0ca:	226b      	movs	r2, #107	@ 0x6b
 801b0cc:	615a      	str	r2, [r3, #20]
 801b0ce:	687b      	ldr	r3, [r7, #4]
 801b0d0:	681b      	ldr	r3, [r3, #0]
 801b0d2:	685b      	ldr	r3, [r3, #4]
 801b0d4:	2101      	movs	r1, #1
 801b0d6:	6878      	ldr	r0, [r7, #4]
 801b0d8:	4798      	blx	r3
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;
 801b0da:	687b      	ldr	r3, [r7, #4]
 801b0dc:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801b0e0:	2200      	movs	r2, #0
 801b0e2:	615a      	str	r2, [r3, #20]

  /* Count another (non-pseudo) SOS marker */
  if (n) cinfo->input_scan_number++;
 801b0e4:	69bb      	ldr	r3, [r7, #24]
 801b0e6:	2b00      	cmp	r3, #0
 801b0e8:	d006      	beq.n	801b0f8 <get_sos+0x386>
 801b0ea:	687b      	ldr	r3, [r7, #4]
 801b0ec:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801b0f0:	1c5a      	adds	r2, r3, #1
 801b0f2:	687b      	ldr	r3, [r7, #4]
 801b0f4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  INPUT_SYNC(cinfo);
 801b0f8:	6a3b      	ldr	r3, [r7, #32]
 801b0fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b0fc:	601a      	str	r2, [r3, #0]
 801b0fe:	6a3b      	ldr	r3, [r7, #32]
 801b100:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b102:	605a      	str	r2, [r3, #4]
  return TRUE;
 801b104:	2301      	movs	r3, #1
}
 801b106:	4618      	mov	r0, r3
 801b108:	3738      	adds	r7, #56	@ 0x38
 801b10a:	46bd      	mov	sp, r7
 801b10c:	bd80      	pop	{r7, pc}

0801b10e <get_dac>:
#ifdef D_ARITH_CODING_SUPPORTED

LOCAL(boolean)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
 801b10e:	b580      	push	{r7, lr}
 801b110:	b088      	sub	sp, #32
 801b112:	af00      	add	r7, sp, #0
 801b114:	6078      	str	r0, [r7, #4]
  INT32 length;
  int index, val;
  INPUT_VARS(cinfo);
 801b116:	687b      	ldr	r3, [r7, #4]
 801b118:	699b      	ldr	r3, [r3, #24]
 801b11a:	613b      	str	r3, [r7, #16]
 801b11c:	693b      	ldr	r3, [r7, #16]
 801b11e:	681b      	ldr	r3, [r3, #0]
 801b120:	61bb      	str	r3, [r7, #24]
 801b122:	693b      	ldr	r3, [r7, #16]
 801b124:	685b      	ldr	r3, [r3, #4]
 801b126:	617b      	str	r3, [r7, #20]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801b128:	697b      	ldr	r3, [r7, #20]
 801b12a:	2b00      	cmp	r3, #0
 801b12c:	d10e      	bne.n	801b14c <get_dac+0x3e>
 801b12e:	693b      	ldr	r3, [r7, #16]
 801b130:	68db      	ldr	r3, [r3, #12]
 801b132:	6878      	ldr	r0, [r7, #4]
 801b134:	4798      	blx	r3
 801b136:	4603      	mov	r3, r0
 801b138:	2b00      	cmp	r3, #0
 801b13a:	d101      	bne.n	801b140 <get_dac+0x32>
 801b13c:	2300      	movs	r3, #0
 801b13e:	e0dc      	b.n	801b2fa <get_dac+0x1ec>
 801b140:	693b      	ldr	r3, [r7, #16]
 801b142:	681b      	ldr	r3, [r3, #0]
 801b144:	61bb      	str	r3, [r7, #24]
 801b146:	693b      	ldr	r3, [r7, #16]
 801b148:	685b      	ldr	r3, [r3, #4]
 801b14a:	617b      	str	r3, [r7, #20]
 801b14c:	697b      	ldr	r3, [r7, #20]
 801b14e:	3b01      	subs	r3, #1
 801b150:	617b      	str	r3, [r7, #20]
 801b152:	69bb      	ldr	r3, [r7, #24]
 801b154:	1c5a      	adds	r2, r3, #1
 801b156:	61ba      	str	r2, [r7, #24]
 801b158:	781b      	ldrb	r3, [r3, #0]
 801b15a:	021b      	lsls	r3, r3, #8
 801b15c:	61fb      	str	r3, [r7, #28]
 801b15e:	697b      	ldr	r3, [r7, #20]
 801b160:	2b00      	cmp	r3, #0
 801b162:	d10e      	bne.n	801b182 <get_dac+0x74>
 801b164:	693b      	ldr	r3, [r7, #16]
 801b166:	68db      	ldr	r3, [r3, #12]
 801b168:	6878      	ldr	r0, [r7, #4]
 801b16a:	4798      	blx	r3
 801b16c:	4603      	mov	r3, r0
 801b16e:	2b00      	cmp	r3, #0
 801b170:	d101      	bne.n	801b176 <get_dac+0x68>
 801b172:	2300      	movs	r3, #0
 801b174:	e0c1      	b.n	801b2fa <get_dac+0x1ec>
 801b176:	693b      	ldr	r3, [r7, #16]
 801b178:	681b      	ldr	r3, [r3, #0]
 801b17a:	61bb      	str	r3, [r7, #24]
 801b17c:	693b      	ldr	r3, [r7, #16]
 801b17e:	685b      	ldr	r3, [r3, #4]
 801b180:	617b      	str	r3, [r7, #20]
 801b182:	697b      	ldr	r3, [r7, #20]
 801b184:	3b01      	subs	r3, #1
 801b186:	617b      	str	r3, [r7, #20]
 801b188:	69bb      	ldr	r3, [r7, #24]
 801b18a:	1c5a      	adds	r2, r3, #1
 801b18c:	61ba      	str	r2, [r7, #24]
 801b18e:	781b      	ldrb	r3, [r3, #0]
 801b190:	461a      	mov	r2, r3
 801b192:	69fb      	ldr	r3, [r7, #28]
 801b194:	4413      	add	r3, r2
 801b196:	61fb      	str	r3, [r7, #28]
  length -= 2;
 801b198:	69fb      	ldr	r3, [r7, #28]
 801b19a:	3b02      	subs	r3, #2
 801b19c:	61fb      	str	r3, [r7, #28]
  
  while (length > 0) {
 801b19e:	e095      	b.n	801b2cc <get_dac+0x1be>
    INPUT_BYTE(cinfo, index, return FALSE);
 801b1a0:	697b      	ldr	r3, [r7, #20]
 801b1a2:	2b00      	cmp	r3, #0
 801b1a4:	d10e      	bne.n	801b1c4 <get_dac+0xb6>
 801b1a6:	693b      	ldr	r3, [r7, #16]
 801b1a8:	68db      	ldr	r3, [r3, #12]
 801b1aa:	6878      	ldr	r0, [r7, #4]
 801b1ac:	4798      	blx	r3
 801b1ae:	4603      	mov	r3, r0
 801b1b0:	2b00      	cmp	r3, #0
 801b1b2:	d101      	bne.n	801b1b8 <get_dac+0xaa>
 801b1b4:	2300      	movs	r3, #0
 801b1b6:	e0a0      	b.n	801b2fa <get_dac+0x1ec>
 801b1b8:	693b      	ldr	r3, [r7, #16]
 801b1ba:	681b      	ldr	r3, [r3, #0]
 801b1bc:	61bb      	str	r3, [r7, #24]
 801b1be:	693b      	ldr	r3, [r7, #16]
 801b1c0:	685b      	ldr	r3, [r3, #4]
 801b1c2:	617b      	str	r3, [r7, #20]
 801b1c4:	697b      	ldr	r3, [r7, #20]
 801b1c6:	3b01      	subs	r3, #1
 801b1c8:	617b      	str	r3, [r7, #20]
 801b1ca:	69bb      	ldr	r3, [r7, #24]
 801b1cc:	1c5a      	adds	r2, r3, #1
 801b1ce:	61ba      	str	r2, [r7, #24]
 801b1d0:	781b      	ldrb	r3, [r3, #0]
 801b1d2:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, val, return FALSE);
 801b1d4:	697b      	ldr	r3, [r7, #20]
 801b1d6:	2b00      	cmp	r3, #0
 801b1d8:	d10e      	bne.n	801b1f8 <get_dac+0xea>
 801b1da:	693b      	ldr	r3, [r7, #16]
 801b1dc:	68db      	ldr	r3, [r3, #12]
 801b1de:	6878      	ldr	r0, [r7, #4]
 801b1e0:	4798      	blx	r3
 801b1e2:	4603      	mov	r3, r0
 801b1e4:	2b00      	cmp	r3, #0
 801b1e6:	d101      	bne.n	801b1ec <get_dac+0xde>
 801b1e8:	2300      	movs	r3, #0
 801b1ea:	e086      	b.n	801b2fa <get_dac+0x1ec>
 801b1ec:	693b      	ldr	r3, [r7, #16]
 801b1ee:	681b      	ldr	r3, [r3, #0]
 801b1f0:	61bb      	str	r3, [r7, #24]
 801b1f2:	693b      	ldr	r3, [r7, #16]
 801b1f4:	685b      	ldr	r3, [r3, #4]
 801b1f6:	617b      	str	r3, [r7, #20]
 801b1f8:	697b      	ldr	r3, [r7, #20]
 801b1fa:	3b01      	subs	r3, #1
 801b1fc:	617b      	str	r3, [r7, #20]
 801b1fe:	69bb      	ldr	r3, [r7, #24]
 801b200:	1c5a      	adds	r2, r3, #1
 801b202:	61ba      	str	r2, [r7, #24]
 801b204:	781b      	ldrb	r3, [r3, #0]
 801b206:	60bb      	str	r3, [r7, #8]

    length -= 2;
 801b208:	69fb      	ldr	r3, [r7, #28]
 801b20a:	3b02      	subs	r3, #2
 801b20c:	61fb      	str	r3, [r7, #28]

    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);
 801b20e:	687b      	ldr	r3, [r7, #4]
 801b210:	681b      	ldr	r3, [r3, #0]
 801b212:	2251      	movs	r2, #81	@ 0x51
 801b214:	615a      	str	r2, [r3, #20]
 801b216:	687b      	ldr	r3, [r7, #4]
 801b218:	681b      	ldr	r3, [r3, #0]
 801b21a:	68fa      	ldr	r2, [r7, #12]
 801b21c:	619a      	str	r2, [r3, #24]
 801b21e:	687b      	ldr	r3, [r7, #4]
 801b220:	681b      	ldr	r3, [r3, #0]
 801b222:	68ba      	ldr	r2, [r7, #8]
 801b224:	61da      	str	r2, [r3, #28]
 801b226:	687b      	ldr	r3, [r7, #4]
 801b228:	681b      	ldr	r3, [r3, #0]
 801b22a:	685b      	ldr	r3, [r3, #4]
 801b22c:	2101      	movs	r1, #1
 801b22e:	6878      	ldr	r0, [r7, #4]
 801b230:	4798      	blx	r3

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
 801b232:	68fb      	ldr	r3, [r7, #12]
 801b234:	2b00      	cmp	r3, #0
 801b236:	db02      	blt.n	801b23e <get_dac+0x130>
 801b238:	68fb      	ldr	r3, [r7, #12]
 801b23a:	2b1f      	cmp	r3, #31
 801b23c:	dd0c      	ble.n	801b258 <get_dac+0x14a>
      ERREXIT1(cinfo, JERR_DAC_INDEX, index);
 801b23e:	687b      	ldr	r3, [r7, #4]
 801b240:	681b      	ldr	r3, [r3, #0]
 801b242:	221d      	movs	r2, #29
 801b244:	615a      	str	r2, [r3, #20]
 801b246:	687b      	ldr	r3, [r7, #4]
 801b248:	681b      	ldr	r3, [r3, #0]
 801b24a:	68fa      	ldr	r2, [r7, #12]
 801b24c:	619a      	str	r2, [r3, #24]
 801b24e:	687b      	ldr	r3, [r7, #4]
 801b250:	681b      	ldr	r3, [r3, #0]
 801b252:	681b      	ldr	r3, [r3, #0]
 801b254:	6878      	ldr	r0, [r7, #4]
 801b256:	4798      	blx	r3

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
 801b258:	68fb      	ldr	r3, [r7, #12]
 801b25a:	2b0f      	cmp	r3, #15
 801b25c:	dd09      	ble.n	801b272 <get_dac+0x164>
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
 801b25e:	68fb      	ldr	r3, [r7, #12]
 801b260:	3b10      	subs	r3, #16
 801b262:	68ba      	ldr	r2, [r7, #8]
 801b264:	b2d1      	uxtb	r1, r2
 801b266:	687a      	ldr	r2, [r7, #4]
 801b268:	4413      	add	r3, r2
 801b26a:	460a      	mov	r2, r1
 801b26c:	f883 2108 	strb.w	r2, [r3, #264]	@ 0x108
 801b270:	e02c      	b.n	801b2cc <get_dac+0x1be>
    } else {			/* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
 801b272:	68bb      	ldr	r3, [r7, #8]
 801b274:	b2db      	uxtb	r3, r3
 801b276:	f003 030f 	and.w	r3, r3, #15
 801b27a:	b2d9      	uxtb	r1, r3
 801b27c:	687a      	ldr	r2, [r7, #4]
 801b27e:	68fb      	ldr	r3, [r7, #12]
 801b280:	4413      	add	r3, r2
 801b282:	33e8      	adds	r3, #232	@ 0xe8
 801b284:	460a      	mov	r2, r1
 801b286:	701a      	strb	r2, [r3, #0]
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
 801b288:	68bb      	ldr	r3, [r7, #8]
 801b28a:	111b      	asrs	r3, r3, #4
 801b28c:	b2d9      	uxtb	r1, r3
 801b28e:	687a      	ldr	r2, [r7, #4]
 801b290:	68fb      	ldr	r3, [r7, #12]
 801b292:	4413      	add	r3, r2
 801b294:	33f8      	adds	r3, #248	@ 0xf8
 801b296:	460a      	mov	r2, r1
 801b298:	701a      	strb	r2, [r3, #0]
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
 801b29a:	687a      	ldr	r2, [r7, #4]
 801b29c:	68fb      	ldr	r3, [r7, #12]
 801b29e:	4413      	add	r3, r2
 801b2a0:	33e8      	adds	r3, #232	@ 0xe8
 801b2a2:	781a      	ldrb	r2, [r3, #0]
 801b2a4:	6879      	ldr	r1, [r7, #4]
 801b2a6:	68fb      	ldr	r3, [r7, #12]
 801b2a8:	440b      	add	r3, r1
 801b2aa:	33f8      	adds	r3, #248	@ 0xf8
 801b2ac:	781b      	ldrb	r3, [r3, #0]
 801b2ae:	429a      	cmp	r2, r3
 801b2b0:	d90c      	bls.n	801b2cc <get_dac+0x1be>
	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
 801b2b2:	687b      	ldr	r3, [r7, #4]
 801b2b4:	681b      	ldr	r3, [r3, #0]
 801b2b6:	221e      	movs	r2, #30
 801b2b8:	615a      	str	r2, [r3, #20]
 801b2ba:	687b      	ldr	r3, [r7, #4]
 801b2bc:	681b      	ldr	r3, [r3, #0]
 801b2be:	68ba      	ldr	r2, [r7, #8]
 801b2c0:	619a      	str	r2, [r3, #24]
 801b2c2:	687b      	ldr	r3, [r7, #4]
 801b2c4:	681b      	ldr	r3, [r3, #0]
 801b2c6:	681b      	ldr	r3, [r3, #0]
 801b2c8:	6878      	ldr	r0, [r7, #4]
 801b2ca:	4798      	blx	r3
  while (length > 0) {
 801b2cc:	69fb      	ldr	r3, [r7, #28]
 801b2ce:	2b00      	cmp	r3, #0
 801b2d0:	f73f af66 	bgt.w	801b1a0 <get_dac+0x92>
    }
  }

  if (length != 0)
 801b2d4:	69fb      	ldr	r3, [r7, #28]
 801b2d6:	2b00      	cmp	r3, #0
 801b2d8:	d008      	beq.n	801b2ec <get_dac+0x1de>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801b2da:	687b      	ldr	r3, [r7, #4]
 801b2dc:	681b      	ldr	r3, [r3, #0]
 801b2de:	220c      	movs	r2, #12
 801b2e0:	615a      	str	r2, [r3, #20]
 801b2e2:	687b      	ldr	r3, [r7, #4]
 801b2e4:	681b      	ldr	r3, [r3, #0]
 801b2e6:	681b      	ldr	r3, [r3, #0]
 801b2e8:	6878      	ldr	r0, [r7, #4]
 801b2ea:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 801b2ec:	693b      	ldr	r3, [r7, #16]
 801b2ee:	69ba      	ldr	r2, [r7, #24]
 801b2f0:	601a      	str	r2, [r3, #0]
 801b2f2:	693b      	ldr	r3, [r7, #16]
 801b2f4:	697a      	ldr	r2, [r7, #20]
 801b2f6:	605a      	str	r2, [r3, #4]
  return TRUE;
 801b2f8:	2301      	movs	r3, #1
}
 801b2fa:	4618      	mov	r0, r3
 801b2fc:	3720      	adds	r7, #32
 801b2fe:	46bd      	mov	sp, r7
 801b300:	bd80      	pop	{r7, pc}

0801b302 <get_dht>:


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
 801b302:	b5b0      	push	{r4, r5, r7, lr}
 801b304:	b0d2      	sub	sp, #328	@ 0x148
 801b306:	af00      	add	r7, sp, #0
 801b308:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b30c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b310:	6018      	str	r0, [r3, #0]
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);
 801b312:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b316:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b31a:	681b      	ldr	r3, [r3, #0]
 801b31c:	699b      	ldr	r3, [r3, #24]
 801b31e:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 801b322:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b326:	681b      	ldr	r3, [r3, #0]
 801b328:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b32c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b330:	685b      	ldr	r3, [r3, #4]
 801b332:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

  INPUT_2BYTES(cinfo, length, return FALSE);
 801b336:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b33a:	2b00      	cmp	r3, #0
 801b33c:	d117      	bne.n	801b36e <get_dht+0x6c>
 801b33e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b342:	68db      	ldr	r3, [r3, #12]
 801b344:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b348:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b34c:	6810      	ldr	r0, [r2, #0]
 801b34e:	4798      	blx	r3
 801b350:	4603      	mov	r3, r0
 801b352:	2b00      	cmp	r3, #0
 801b354:	d101      	bne.n	801b35a <get_dht+0x58>
 801b356:	2300      	movs	r3, #0
 801b358:	e28a      	b.n	801b870 <get_dht+0x56e>
 801b35a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b35e:	681b      	ldr	r3, [r3, #0]
 801b360:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b364:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b368:	685b      	ldr	r3, [r3, #4]
 801b36a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b36e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b372:	3b01      	subs	r3, #1
 801b374:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b378:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801b37c:	1c5a      	adds	r2, r3, #1
 801b37e:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 801b382:	781b      	ldrb	r3, [r3, #0]
 801b384:	021b      	lsls	r3, r3, #8
 801b386:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 801b38a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b38e:	2b00      	cmp	r3, #0
 801b390:	d117      	bne.n	801b3c2 <get_dht+0xc0>
 801b392:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b396:	68db      	ldr	r3, [r3, #12]
 801b398:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b39c:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b3a0:	6810      	ldr	r0, [r2, #0]
 801b3a2:	4798      	blx	r3
 801b3a4:	4603      	mov	r3, r0
 801b3a6:	2b00      	cmp	r3, #0
 801b3a8:	d101      	bne.n	801b3ae <get_dht+0xac>
 801b3aa:	2300      	movs	r3, #0
 801b3ac:	e260      	b.n	801b870 <get_dht+0x56e>
 801b3ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b3b2:	681b      	ldr	r3, [r3, #0]
 801b3b4:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b3b8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b3bc:	685b      	ldr	r3, [r3, #4]
 801b3be:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b3c2:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b3c6:	3b01      	subs	r3, #1
 801b3c8:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b3cc:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801b3d0:	1c5a      	adds	r2, r3, #1
 801b3d2:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 801b3d6:	781b      	ldrb	r3, [r3, #0]
 801b3d8:	461a      	mov	r2, r3
 801b3da:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b3de:	4413      	add	r3, r2
 801b3e0:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  length -= 2;
 801b3e4:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b3e8:	3b02      	subs	r3, #2
 801b3ea:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  
  while (length > 16) {
 801b3ee:	e216      	b.n	801b81e <get_dht+0x51c>
    INPUT_BYTE(cinfo, index, return FALSE);
 801b3f0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b3f4:	2b00      	cmp	r3, #0
 801b3f6:	d117      	bne.n	801b428 <get_dht+0x126>
 801b3f8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b3fc:	68db      	ldr	r3, [r3, #12]
 801b3fe:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b402:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b406:	6810      	ldr	r0, [r2, #0]
 801b408:	4798      	blx	r3
 801b40a:	4603      	mov	r3, r0
 801b40c:	2b00      	cmp	r3, #0
 801b40e:	d101      	bne.n	801b414 <get_dht+0x112>
 801b410:	2300      	movs	r3, #0
 801b412:	e22d      	b.n	801b870 <get_dht+0x56e>
 801b414:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b418:	681b      	ldr	r3, [r3, #0]
 801b41a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b41e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b422:	685b      	ldr	r3, [r3, #4]
 801b424:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b428:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b42c:	3b01      	subs	r3, #1
 801b42e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b432:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801b436:	1c5a      	adds	r2, r3, #1
 801b438:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 801b43c:	781b      	ldrb	r3, [r3, #0]
 801b43e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
 801b442:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b446:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b44a:	681b      	ldr	r3, [r3, #0]
 801b44c:	681b      	ldr	r3, [r3, #0]
 801b44e:	2252      	movs	r2, #82	@ 0x52
 801b450:	615a      	str	r2, [r3, #20]
 801b452:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b456:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b45a:	681b      	ldr	r3, [r3, #0]
 801b45c:	681b      	ldr	r3, [r3, #0]
 801b45e:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801b462:	619a      	str	r2, [r3, #24]
 801b464:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b468:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b46c:	681b      	ldr	r3, [r3, #0]
 801b46e:	681b      	ldr	r3, [r3, #0]
 801b470:	685b      	ldr	r3, [r3, #4]
 801b472:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b476:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b47a:	2101      	movs	r1, #1
 801b47c:	6810      	ldr	r0, [r2, #0]
 801b47e:	4798      	blx	r3
      
    bits[0] = 0;
 801b480:	2300      	movs	r3, #0
 801b482:	f887 310c 	strb.w	r3, [r7, #268]	@ 0x10c
    count = 0;
 801b486:	2300      	movs	r3, #0
 801b488:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    for (i = 1; i <= 16; i++) {
 801b48c:	2301      	movs	r3, #1
 801b48e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 801b492:	e03e      	b.n	801b512 <get_dht+0x210>
      INPUT_BYTE(cinfo, bits[i], return FALSE);
 801b494:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b498:	2b00      	cmp	r3, #0
 801b49a:	d117      	bne.n	801b4cc <get_dht+0x1ca>
 801b49c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b4a0:	68db      	ldr	r3, [r3, #12]
 801b4a2:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b4a6:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b4aa:	6810      	ldr	r0, [r2, #0]
 801b4ac:	4798      	blx	r3
 801b4ae:	4603      	mov	r3, r0
 801b4b0:	2b00      	cmp	r3, #0
 801b4b2:	d101      	bne.n	801b4b8 <get_dht+0x1b6>
 801b4b4:	2300      	movs	r3, #0
 801b4b6:	e1db      	b.n	801b870 <get_dht+0x56e>
 801b4b8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b4bc:	681b      	ldr	r3, [r3, #0]
 801b4be:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b4c2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b4c6:	685b      	ldr	r3, [r3, #4]
 801b4c8:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b4cc:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b4d0:	3b01      	subs	r3, #1
 801b4d2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b4d6:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801b4da:	1c5a      	adds	r2, r3, #1
 801b4dc:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 801b4e0:	7819      	ldrb	r1, [r3, #0]
 801b4e2:	f507 7286 	add.w	r2, r7, #268	@ 0x10c
 801b4e6:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b4ea:	4413      	add	r3, r2
 801b4ec:	460a      	mov	r2, r1
 801b4ee:	701a      	strb	r2, [r3, #0]
      count += bits[i];
 801b4f0:	f507 7286 	add.w	r2, r7, #268	@ 0x10c
 801b4f4:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b4f8:	4413      	add	r3, r2
 801b4fa:	781b      	ldrb	r3, [r3, #0]
 801b4fc:	461a      	mov	r2, r3
 801b4fe:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801b502:	4413      	add	r3, r2
 801b504:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    for (i = 1; i <= 16; i++) {
 801b508:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b50c:	3301      	adds	r3, #1
 801b50e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 801b512:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b516:	2b10      	cmp	r3, #16
 801b518:	ddbc      	ble.n	801b494 <get_dht+0x192>
    }

    length -= 1 + 16;
 801b51a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b51e:	3b11      	subs	r3, #17
 801b520:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 801b524:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b528:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b52c:	681b      	ldr	r3, [r3, #0]
 801b52e:	681b      	ldr	r3, [r3, #0]
 801b530:	3318      	adds	r3, #24
 801b532:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 801b536:	f897 310d 	ldrb.w	r3, [r7, #269]	@ 0x10d
 801b53a:	461a      	mov	r2, r3
 801b53c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b540:	601a      	str	r2, [r3, #0]
 801b542:	f897 210e 	ldrb.w	r2, [r7, #270]	@ 0x10e
 801b546:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b54a:	3304      	adds	r3, #4
 801b54c:	601a      	str	r2, [r3, #0]
 801b54e:	f897 210f 	ldrb.w	r2, [r7, #271]	@ 0x10f
 801b552:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b556:	3308      	adds	r3, #8
 801b558:	601a      	str	r2, [r3, #0]
 801b55a:	f897 2110 	ldrb.w	r2, [r7, #272]	@ 0x110
 801b55e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b562:	330c      	adds	r3, #12
 801b564:	601a      	str	r2, [r3, #0]
 801b566:	f897 2111 	ldrb.w	r2, [r7, #273]	@ 0x111
 801b56a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b56e:	3310      	adds	r3, #16
 801b570:	601a      	str	r2, [r3, #0]
 801b572:	f897 2112 	ldrb.w	r2, [r7, #274]	@ 0x112
 801b576:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b57a:	3314      	adds	r3, #20
 801b57c:	601a      	str	r2, [r3, #0]
 801b57e:	f897 2113 	ldrb.w	r2, [r7, #275]	@ 0x113
 801b582:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b586:	3318      	adds	r3, #24
 801b588:	601a      	str	r2, [r3, #0]
 801b58a:	f897 2114 	ldrb.w	r2, [r7, #276]	@ 0x114
 801b58e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801b592:	331c      	adds	r3, #28
 801b594:	601a      	str	r2, [r3, #0]
 801b596:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b59a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b59e:	681b      	ldr	r3, [r3, #0]
 801b5a0:	681b      	ldr	r3, [r3, #0]
 801b5a2:	2258      	movs	r2, #88	@ 0x58
 801b5a4:	615a      	str	r2, [r3, #20]
 801b5a6:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b5aa:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b5ae:	681b      	ldr	r3, [r3, #0]
 801b5b0:	681b      	ldr	r3, [r3, #0]
 801b5b2:	685b      	ldr	r3, [r3, #4]
 801b5b4:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b5b8:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b5bc:	2102      	movs	r1, #2
 801b5be:	6810      	ldr	r0, [r2, #0]
 801b5c0:	4798      	blx	r3
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 801b5c2:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b5c6:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b5ca:	681b      	ldr	r3, [r3, #0]
 801b5cc:	681b      	ldr	r3, [r3, #0]
 801b5ce:	3318      	adds	r3, #24
 801b5d0:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 801b5d4:	f897 3115 	ldrb.w	r3, [r7, #277]	@ 0x115
 801b5d8:	461a      	mov	r2, r3
 801b5da:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b5de:	601a      	str	r2, [r3, #0]
 801b5e0:	f897 2116 	ldrb.w	r2, [r7, #278]	@ 0x116
 801b5e4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b5e8:	3304      	adds	r3, #4
 801b5ea:	601a      	str	r2, [r3, #0]
 801b5ec:	f897 2117 	ldrb.w	r2, [r7, #279]	@ 0x117
 801b5f0:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b5f4:	3308      	adds	r3, #8
 801b5f6:	601a      	str	r2, [r3, #0]
 801b5f8:	f897 2118 	ldrb.w	r2, [r7, #280]	@ 0x118
 801b5fc:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b600:	330c      	adds	r3, #12
 801b602:	601a      	str	r2, [r3, #0]
 801b604:	f897 2119 	ldrb.w	r2, [r7, #281]	@ 0x119
 801b608:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b60c:	3310      	adds	r3, #16
 801b60e:	601a      	str	r2, [r3, #0]
 801b610:	f897 211a 	ldrb.w	r2, [r7, #282]	@ 0x11a
 801b614:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b618:	3314      	adds	r3, #20
 801b61a:	601a      	str	r2, [r3, #0]
 801b61c:	f897 211b 	ldrb.w	r2, [r7, #283]	@ 0x11b
 801b620:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b624:	3318      	adds	r3, #24
 801b626:	601a      	str	r2, [r3, #0]
 801b628:	f897 211c 	ldrb.w	r2, [r7, #284]	@ 0x11c
 801b62c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801b630:	331c      	adds	r3, #28
 801b632:	601a      	str	r2, [r3, #0]
 801b634:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b638:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b63c:	681b      	ldr	r3, [r3, #0]
 801b63e:	681b      	ldr	r3, [r3, #0]
 801b640:	2258      	movs	r2, #88	@ 0x58
 801b642:	615a      	str	r2, [r3, #20]
 801b644:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b648:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b64c:	681b      	ldr	r3, [r3, #0]
 801b64e:	681b      	ldr	r3, [r3, #0]
 801b650:	685b      	ldr	r3, [r3, #4]
 801b652:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b656:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b65a:	2102      	movs	r1, #2
 801b65c:	6810      	ldr	r0, [r2, #0]
 801b65e:	4798      	blx	r3
	     bits[13], bits[14], bits[15], bits[16]);

    /* Here we just do minimal validation of the counts to avoid walking
     * off the end of our table space.  jdhuff.c will check more carefully.
     */
    if (count > 256 || ((INT32) count) > length)
 801b660:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801b664:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801b668:	dc05      	bgt.n	801b676 <get_dht+0x374>
 801b66a:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801b66e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b672:	429a      	cmp	r2, r3
 801b674:	dd14      	ble.n	801b6a0 <get_dht+0x39e>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 801b676:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b67a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b67e:	681b      	ldr	r3, [r3, #0]
 801b680:	681b      	ldr	r3, [r3, #0]
 801b682:	2209      	movs	r2, #9
 801b684:	615a      	str	r2, [r3, #20]
 801b686:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b68a:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b68e:	681b      	ldr	r3, [r3, #0]
 801b690:	681b      	ldr	r3, [r3, #0]
 801b692:	681b      	ldr	r3, [r3, #0]
 801b694:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b698:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b69c:	6810      	ldr	r0, [r2, #0]
 801b69e:	4798      	blx	r3

    for (i = 0; i < count; i++)
 801b6a0:	2300      	movs	r3, #0
 801b6a2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 801b6a6:	e034      	b.n	801b712 <get_dht+0x410>
      INPUT_BYTE(cinfo, huffval[i], return FALSE);
 801b6a8:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b6ac:	2b00      	cmp	r3, #0
 801b6ae:	d117      	bne.n	801b6e0 <get_dht+0x3de>
 801b6b0:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b6b4:	68db      	ldr	r3, [r3, #12]
 801b6b6:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b6ba:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b6be:	6810      	ldr	r0, [r2, #0]
 801b6c0:	4798      	blx	r3
 801b6c2:	4603      	mov	r3, r0
 801b6c4:	2b00      	cmp	r3, #0
 801b6c6:	d101      	bne.n	801b6cc <get_dht+0x3ca>
 801b6c8:	2300      	movs	r3, #0
 801b6ca:	e0d1      	b.n	801b870 <get_dht+0x56e>
 801b6cc:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b6d0:	681b      	ldr	r3, [r3, #0]
 801b6d2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 801b6d6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b6da:	685b      	ldr	r3, [r3, #4]
 801b6dc:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b6e0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801b6e4:	3b01      	subs	r3, #1
 801b6e6:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 801b6ea:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801b6ee:	1c5a      	adds	r2, r3, #1
 801b6f0:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 801b6f4:	7819      	ldrb	r1, [r3, #0]
 801b6f6:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b6fa:	f5a3 729e 	sub.w	r2, r3, #316	@ 0x13c
 801b6fe:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b702:	4413      	add	r3, r2
 801b704:	460a      	mov	r2, r1
 801b706:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 801b708:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801b70c:	3301      	adds	r3, #1
 801b70e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 801b712:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801b716:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801b71a:	429a      	cmp	r2, r3
 801b71c:	dbc4      	blt.n	801b6a8 <get_dht+0x3a6>

    length -= count;
 801b71e:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801b722:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801b726:	1ad3      	subs	r3, r2, r3
 801b728:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    if (index & 0x10) {		/* AC table definition */
 801b72c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b730:	f003 0310 	and.w	r3, r3, #16
 801b734:	2b00      	cmp	r3, #0
 801b736:	d012      	beq.n	801b75e <get_dht+0x45c>
      index -= 0x10;
 801b738:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b73c:	3b10      	subs	r3, #16
 801b73e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
 801b742:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b746:	f5a3 72a2 	sub.w	r2, r3, #324	@ 0x144
 801b74a:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b74e:	3330      	adds	r3, #48	@ 0x30
 801b750:	009b      	lsls	r3, r3, #2
 801b752:	6812      	ldr	r2, [r2, #0]
 801b754:	4413      	add	r3, r2
 801b756:	3304      	adds	r3, #4
 801b758:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
 801b75c:	e00c      	b.n	801b778 <get_dht+0x476>
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
 801b75e:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b762:	f5a3 72a2 	sub.w	r2, r3, #324	@ 0x144
 801b766:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b76a:	332c      	adds	r3, #44	@ 0x2c
 801b76c:	009b      	lsls	r3, r3, #2
 801b76e:	6812      	ldr	r2, [r2, #0]
 801b770:	4413      	add	r3, r2
 801b772:	3304      	adds	r3, #4
 801b774:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
 801b778:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b77c:	2b00      	cmp	r3, #0
 801b77e:	db03      	blt.n	801b788 <get_dht+0x486>
 801b780:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801b784:	2b03      	cmp	r3, #3
 801b786:	dd1d      	ble.n	801b7c4 <get_dht+0x4c2>
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);
 801b788:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b78c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b790:	681b      	ldr	r3, [r3, #0]
 801b792:	681b      	ldr	r3, [r3, #0]
 801b794:	221f      	movs	r2, #31
 801b796:	615a      	str	r2, [r3, #20]
 801b798:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b79c:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b7a0:	681b      	ldr	r3, [r3, #0]
 801b7a2:	681b      	ldr	r3, [r3, #0]
 801b7a4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801b7a8:	619a      	str	r2, [r3, #24]
 801b7aa:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b7ae:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b7b2:	681b      	ldr	r3, [r3, #0]
 801b7b4:	681b      	ldr	r3, [r3, #0]
 801b7b6:	681b      	ldr	r3, [r3, #0]
 801b7b8:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b7bc:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b7c0:	6810      	ldr	r0, [r2, #0]
 801b7c2:	4798      	blx	r3

    if (*htblptr == NULL)
 801b7c4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b7c8:	681b      	ldr	r3, [r3, #0]
 801b7ca:	2b00      	cmp	r3, #0
 801b7cc:	d10a      	bne.n	801b7e4 <get_dht+0x4e2>
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 801b7ce:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b7d2:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b7d6:	6818      	ldr	r0, [r3, #0]
 801b7d8:	f7f7 fbab 	bl	8012f32 <jpeg_alloc_huff_table>
 801b7dc:	4602      	mov	r2, r0
 801b7de:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b7e2:	601a      	str	r2, [r3, #0]
  
    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
 801b7e4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b7e8:	681b      	ldr	r3, [r3, #0]
 801b7ea:	461d      	mov	r5, r3
 801b7ec:	f507 7486 	add.w	r4, r7, #268	@ 0x10c
 801b7f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801b7f2:	6028      	str	r0, [r5, #0]
 801b7f4:	6069      	str	r1, [r5, #4]
 801b7f6:	60aa      	str	r2, [r5, #8]
 801b7f8:	60eb      	str	r3, [r5, #12]
 801b7fa:	7823      	ldrb	r3, [r4, #0]
 801b7fc:	742b      	strb	r3, [r5, #16]
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
 801b7fe:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b802:	681b      	ldr	r3, [r3, #0]
 801b804:	f103 0211 	add.w	r2, r3, #17
 801b808:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b80c:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
 801b810:	4610      	mov	r0, r2
 801b812:	4619      	mov	r1, r3
 801b814:	f44f 7380 	mov.w	r3, #256	@ 0x100
 801b818:	461a      	mov	r2, r3
 801b81a:	f014 f905 	bl	802fa28 <memcpy>
  while (length > 16) {
 801b81e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b822:	2b10      	cmp	r3, #16
 801b824:	f73f ade4 	bgt.w	801b3f0 <get_dht+0xee>
  }

  if (length != 0)
 801b828:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801b82c:	2b00      	cmp	r3, #0
 801b82e:	d014      	beq.n	801b85a <get_dht+0x558>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801b830:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b834:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b838:	681b      	ldr	r3, [r3, #0]
 801b83a:	681b      	ldr	r3, [r3, #0]
 801b83c:	220c      	movs	r2, #12
 801b83e:	615a      	str	r2, [r3, #20]
 801b840:	f507 73a4 	add.w	r3, r7, #328	@ 0x148
 801b844:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 801b848:	681b      	ldr	r3, [r3, #0]
 801b84a:	681b      	ldr	r3, [r3, #0]
 801b84c:	681b      	ldr	r3, [r3, #0]
 801b84e:	f507 72a4 	add.w	r2, r7, #328	@ 0x148
 801b852:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
 801b856:	6810      	ldr	r0, [r2, #0]
 801b858:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 801b85a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b85e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801b862:	601a      	str	r2, [r3, #0]
 801b864:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801b868:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801b86c:	605a      	str	r2, [r3, #4]
  return TRUE;
 801b86e:	2301      	movs	r3, #1
}
 801b870:	4618      	mov	r0, r3
 801b872:	f507 77a4 	add.w	r7, r7, #328	@ 0x148
 801b876:	46bd      	mov	sp, r7
 801b878:	bdb0      	pop	{r4, r5, r7, pc}
	...

0801b87c <get_dqt>:


LOCAL(boolean)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
 801b87c:	b580      	push	{r7, lr}
 801b87e:	b08e      	sub	sp, #56	@ 0x38
 801b880:	af00      	add	r7, sp, #0
 801b882:	6078      	str	r0, [r7, #4]
  INT32 length, count, i;
  int n, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  const int *natural_order;
  INPUT_VARS(cinfo);
 801b884:	687b      	ldr	r3, [r7, #4]
 801b886:	699b      	ldr	r3, [r3, #24]
 801b888:	61bb      	str	r3, [r7, #24]
 801b88a:	69bb      	ldr	r3, [r7, #24]
 801b88c:	681b      	ldr	r3, [r3, #0]
 801b88e:	623b      	str	r3, [r7, #32]
 801b890:	69bb      	ldr	r3, [r7, #24]
 801b892:	685b      	ldr	r3, [r3, #4]
 801b894:	61fb      	str	r3, [r7, #28]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801b896:	69fb      	ldr	r3, [r7, #28]
 801b898:	2b00      	cmp	r3, #0
 801b89a:	d10e      	bne.n	801b8ba <get_dqt+0x3e>
 801b89c:	69bb      	ldr	r3, [r7, #24]
 801b89e:	68db      	ldr	r3, [r3, #12]
 801b8a0:	6878      	ldr	r0, [r7, #4]
 801b8a2:	4798      	blx	r3
 801b8a4:	4603      	mov	r3, r0
 801b8a6:	2b00      	cmp	r3, #0
 801b8a8:	d101      	bne.n	801b8ae <get_dqt+0x32>
 801b8aa:	2300      	movs	r3, #0
 801b8ac:	e21e      	b.n	801bcec <get_dqt+0x470>
 801b8ae:	69bb      	ldr	r3, [r7, #24]
 801b8b0:	681b      	ldr	r3, [r3, #0]
 801b8b2:	623b      	str	r3, [r7, #32]
 801b8b4:	69bb      	ldr	r3, [r7, #24]
 801b8b6:	685b      	ldr	r3, [r3, #4]
 801b8b8:	61fb      	str	r3, [r7, #28]
 801b8ba:	69fb      	ldr	r3, [r7, #28]
 801b8bc:	3b01      	subs	r3, #1
 801b8be:	61fb      	str	r3, [r7, #28]
 801b8c0:	6a3b      	ldr	r3, [r7, #32]
 801b8c2:	1c5a      	adds	r2, r3, #1
 801b8c4:	623a      	str	r2, [r7, #32]
 801b8c6:	781b      	ldrb	r3, [r3, #0]
 801b8c8:	021b      	lsls	r3, r3, #8
 801b8ca:	637b      	str	r3, [r7, #52]	@ 0x34
 801b8cc:	69fb      	ldr	r3, [r7, #28]
 801b8ce:	2b00      	cmp	r3, #0
 801b8d0:	d10e      	bne.n	801b8f0 <get_dqt+0x74>
 801b8d2:	69bb      	ldr	r3, [r7, #24]
 801b8d4:	68db      	ldr	r3, [r3, #12]
 801b8d6:	6878      	ldr	r0, [r7, #4]
 801b8d8:	4798      	blx	r3
 801b8da:	4603      	mov	r3, r0
 801b8dc:	2b00      	cmp	r3, #0
 801b8de:	d101      	bne.n	801b8e4 <get_dqt+0x68>
 801b8e0:	2300      	movs	r3, #0
 801b8e2:	e203      	b.n	801bcec <get_dqt+0x470>
 801b8e4:	69bb      	ldr	r3, [r7, #24]
 801b8e6:	681b      	ldr	r3, [r3, #0]
 801b8e8:	623b      	str	r3, [r7, #32]
 801b8ea:	69bb      	ldr	r3, [r7, #24]
 801b8ec:	685b      	ldr	r3, [r3, #4]
 801b8ee:	61fb      	str	r3, [r7, #28]
 801b8f0:	69fb      	ldr	r3, [r7, #28]
 801b8f2:	3b01      	subs	r3, #1
 801b8f4:	61fb      	str	r3, [r7, #28]
 801b8f6:	6a3b      	ldr	r3, [r7, #32]
 801b8f8:	1c5a      	adds	r2, r3, #1
 801b8fa:	623a      	str	r2, [r7, #32]
 801b8fc:	781b      	ldrb	r3, [r3, #0]
 801b8fe:	461a      	mov	r2, r3
 801b900:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b902:	4413      	add	r3, r2
 801b904:	637b      	str	r3, [r7, #52]	@ 0x34
  length -= 2;
 801b906:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b908:	3b02      	subs	r3, #2
 801b90a:	637b      	str	r3, [r7, #52]	@ 0x34

  while (length > 0) {
 801b90c:	e1d7      	b.n	801bcbe <get_dqt+0x442>
    length--;
 801b90e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b910:	3b01      	subs	r3, #1
 801b912:	637b      	str	r3, [r7, #52]	@ 0x34
    INPUT_BYTE(cinfo, n, return FALSE);
 801b914:	69fb      	ldr	r3, [r7, #28]
 801b916:	2b00      	cmp	r3, #0
 801b918:	d10e      	bne.n	801b938 <get_dqt+0xbc>
 801b91a:	69bb      	ldr	r3, [r7, #24]
 801b91c:	68db      	ldr	r3, [r3, #12]
 801b91e:	6878      	ldr	r0, [r7, #4]
 801b920:	4798      	blx	r3
 801b922:	4603      	mov	r3, r0
 801b924:	2b00      	cmp	r3, #0
 801b926:	d101      	bne.n	801b92c <get_dqt+0xb0>
 801b928:	2300      	movs	r3, #0
 801b92a:	e1df      	b.n	801bcec <get_dqt+0x470>
 801b92c:	69bb      	ldr	r3, [r7, #24]
 801b92e:	681b      	ldr	r3, [r3, #0]
 801b930:	623b      	str	r3, [r7, #32]
 801b932:	69bb      	ldr	r3, [r7, #24]
 801b934:	685b      	ldr	r3, [r3, #4]
 801b936:	61fb      	str	r3, [r7, #28]
 801b938:	69fb      	ldr	r3, [r7, #28]
 801b93a:	3b01      	subs	r3, #1
 801b93c:	61fb      	str	r3, [r7, #28]
 801b93e:	6a3b      	ldr	r3, [r7, #32]
 801b940:	1c5a      	adds	r2, r3, #1
 801b942:	623a      	str	r2, [r7, #32]
 801b944:	781b      	ldrb	r3, [r3, #0]
 801b946:	617b      	str	r3, [r7, #20]
    prec = n >> 4;
 801b948:	697b      	ldr	r3, [r7, #20]
 801b94a:	111b      	asrs	r3, r3, #4
 801b94c:	613b      	str	r3, [r7, #16]
    n &= 0x0F;
 801b94e:	697b      	ldr	r3, [r7, #20]
 801b950:	f003 030f 	and.w	r3, r3, #15
 801b954:	617b      	str	r3, [r7, #20]

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);
 801b956:	687b      	ldr	r3, [r7, #4]
 801b958:	681b      	ldr	r3, [r3, #0]
 801b95a:	2253      	movs	r2, #83	@ 0x53
 801b95c:	615a      	str	r2, [r3, #20]
 801b95e:	687b      	ldr	r3, [r7, #4]
 801b960:	681b      	ldr	r3, [r3, #0]
 801b962:	697a      	ldr	r2, [r7, #20]
 801b964:	619a      	str	r2, [r3, #24]
 801b966:	687b      	ldr	r3, [r7, #4]
 801b968:	681b      	ldr	r3, [r3, #0]
 801b96a:	693a      	ldr	r2, [r7, #16]
 801b96c:	61da      	str	r2, [r3, #28]
 801b96e:	687b      	ldr	r3, [r7, #4]
 801b970:	681b      	ldr	r3, [r3, #0]
 801b972:	685b      	ldr	r3, [r3, #4]
 801b974:	2101      	movs	r1, #1
 801b976:	6878      	ldr	r0, [r7, #4]
 801b978:	4798      	blx	r3

    if (n >= NUM_QUANT_TBLS)
 801b97a:	697b      	ldr	r3, [r7, #20]
 801b97c:	2b03      	cmp	r3, #3
 801b97e:	dd0c      	ble.n	801b99a <get_dqt+0x11e>
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
 801b980:	687b      	ldr	r3, [r7, #4]
 801b982:	681b      	ldr	r3, [r3, #0]
 801b984:	2220      	movs	r2, #32
 801b986:	615a      	str	r2, [r3, #20]
 801b988:	687b      	ldr	r3, [r7, #4]
 801b98a:	681b      	ldr	r3, [r3, #0]
 801b98c:	697a      	ldr	r2, [r7, #20]
 801b98e:	619a      	str	r2, [r3, #24]
 801b990:	687b      	ldr	r3, [r7, #4]
 801b992:	681b      	ldr	r3, [r3, #0]
 801b994:	681b      	ldr	r3, [r3, #0]
 801b996:	6878      	ldr	r0, [r7, #4]
 801b998:	4798      	blx	r3
      
    if (cinfo->quant_tbl_ptrs[n] == NULL)
 801b99a:	687a      	ldr	r2, [r7, #4]
 801b99c:	697b      	ldr	r3, [r7, #20]
 801b99e:	3328      	adds	r3, #40	@ 0x28
 801b9a0:	009b      	lsls	r3, r3, #2
 801b9a2:	4413      	add	r3, r2
 801b9a4:	685b      	ldr	r3, [r3, #4]
 801b9a6:	2b00      	cmp	r3, #0
 801b9a8:	d109      	bne.n	801b9be <get_dqt+0x142>
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
 801b9aa:	6878      	ldr	r0, [r7, #4]
 801b9ac:	f7f7 faac 	bl	8012f08 <jpeg_alloc_quant_table>
 801b9b0:	4601      	mov	r1, r0
 801b9b2:	687a      	ldr	r2, [r7, #4]
 801b9b4:	697b      	ldr	r3, [r7, #20]
 801b9b6:	3328      	adds	r3, #40	@ 0x28
 801b9b8:	009b      	lsls	r3, r3, #2
 801b9ba:	4413      	add	r3, r2
 801b9bc:	6059      	str	r1, [r3, #4]
    quant_ptr = cinfo->quant_tbl_ptrs[n];
 801b9be:	687a      	ldr	r2, [r7, #4]
 801b9c0:	697b      	ldr	r3, [r7, #20]
 801b9c2:	3328      	adds	r3, #40	@ 0x28
 801b9c4:	009b      	lsls	r3, r3, #2
 801b9c6:	4413      	add	r3, r2
 801b9c8:	685b      	ldr	r3, [r3, #4]
 801b9ca:	60fb      	str	r3, [r7, #12]

    if (prec) {
 801b9cc:	693b      	ldr	r3, [r7, #16]
 801b9ce:	2b00      	cmp	r3, #0
 801b9d0:	d017      	beq.n	801ba02 <get_dqt+0x186>
      if (length < DCTSIZE2 * 2) {
 801b9d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b9d4:	2b7f      	cmp	r3, #127	@ 0x7f
 801b9d6:	dc11      	bgt.n	801b9fc <get_dqt+0x180>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 801b9d8:	2300      	movs	r3, #0
 801b9da:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801b9dc:	e007      	b.n	801b9ee <get_dqt+0x172>
	  quant_ptr->quantval[i] = 1;
 801b9de:	68fb      	ldr	r3, [r7, #12]
 801b9e0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b9e2:	2101      	movs	r1, #1
 801b9e4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 801b9e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b9ea:	3301      	adds	r3, #1
 801b9ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801b9ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b9f0:	2b3f      	cmp	r3, #63	@ 0x3f
 801b9f2:	ddf4      	ble.n	801b9de <get_dqt+0x162>
	}
	count = length >> 1;
 801b9f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b9f6:	105b      	asrs	r3, r3, #1
 801b9f8:	633b      	str	r3, [r7, #48]	@ 0x30
 801b9fa:	e018      	b.n	801ba2e <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 801b9fc:	2340      	movs	r3, #64	@ 0x40
 801b9fe:	633b      	str	r3, [r7, #48]	@ 0x30
 801ba00:	e015      	b.n	801ba2e <get_dqt+0x1b2>
    } else {
      if (length < DCTSIZE2) {
 801ba02:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ba04:	2b3f      	cmp	r3, #63	@ 0x3f
 801ba06:	dc10      	bgt.n	801ba2a <get_dqt+0x1ae>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 801ba08:	2300      	movs	r3, #0
 801ba0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ba0c:	e007      	b.n	801ba1e <get_dqt+0x1a2>
	  quant_ptr->quantval[i] = 1;
 801ba0e:	68fb      	ldr	r3, [r7, #12]
 801ba10:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801ba12:	2101      	movs	r1, #1
 801ba14:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 801ba18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ba1a:	3301      	adds	r3, #1
 801ba1c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ba1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ba20:	2b3f      	cmp	r3, #63	@ 0x3f
 801ba22:	ddf4      	ble.n	801ba0e <get_dqt+0x192>
	}
	count = length;
 801ba24:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ba26:	633b      	str	r3, [r7, #48]	@ 0x30
 801ba28:	e001      	b.n	801ba2e <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 801ba2a:	2340      	movs	r3, #64	@ 0x40
 801ba2c:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    switch (count) {
 801ba2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ba30:	3b04      	subs	r3, #4
 801ba32:	2b2d      	cmp	r3, #45	@ 0x2d
 801ba34:	d870      	bhi.n	801bb18 <get_dqt+0x29c>
 801ba36:	a201      	add	r2, pc, #4	@ (adr r2, 801ba3c <get_dqt+0x1c0>)
 801ba38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ba3c:	0801baf5 	.word	0x0801baf5
 801ba40:	0801bb19 	.word	0x0801bb19
 801ba44:	0801bb19 	.word	0x0801bb19
 801ba48:	0801bb19 	.word	0x0801bb19
 801ba4c:	0801bb19 	.word	0x0801bb19
 801ba50:	0801bafb 	.word	0x0801bafb
 801ba54:	0801bb19 	.word	0x0801bb19
 801ba58:	0801bb19 	.word	0x0801bb19
 801ba5c:	0801bb19 	.word	0x0801bb19
 801ba60:	0801bb19 	.word	0x0801bb19
 801ba64:	0801bb19 	.word	0x0801bb19
 801ba68:	0801bb19 	.word	0x0801bb19
 801ba6c:	0801bb01 	.word	0x0801bb01
 801ba70:	0801bb19 	.word	0x0801bb19
 801ba74:	0801bb19 	.word	0x0801bb19
 801ba78:	0801bb19 	.word	0x0801bb19
 801ba7c:	0801bb19 	.word	0x0801bb19
 801ba80:	0801bb19 	.word	0x0801bb19
 801ba84:	0801bb19 	.word	0x0801bb19
 801ba88:	0801bb19 	.word	0x0801bb19
 801ba8c:	0801bb19 	.word	0x0801bb19
 801ba90:	0801bb07 	.word	0x0801bb07
 801ba94:	0801bb19 	.word	0x0801bb19
 801ba98:	0801bb19 	.word	0x0801bb19
 801ba9c:	0801bb19 	.word	0x0801bb19
 801baa0:	0801bb19 	.word	0x0801bb19
 801baa4:	0801bb19 	.word	0x0801bb19
 801baa8:	0801bb19 	.word	0x0801bb19
 801baac:	0801bb19 	.word	0x0801bb19
 801bab0:	0801bb19 	.word	0x0801bb19
 801bab4:	0801bb19 	.word	0x0801bb19
 801bab8:	0801bb19 	.word	0x0801bb19
 801babc:	0801bb0d 	.word	0x0801bb0d
 801bac0:	0801bb19 	.word	0x0801bb19
 801bac4:	0801bb19 	.word	0x0801bb19
 801bac8:	0801bb19 	.word	0x0801bb19
 801bacc:	0801bb19 	.word	0x0801bb19
 801bad0:	0801bb19 	.word	0x0801bb19
 801bad4:	0801bb19 	.word	0x0801bb19
 801bad8:	0801bb19 	.word	0x0801bb19
 801badc:	0801bb19 	.word	0x0801bb19
 801bae0:	0801bb19 	.word	0x0801bb19
 801bae4:	0801bb19 	.word	0x0801bb19
 801bae8:	0801bb19 	.word	0x0801bb19
 801baec:	0801bb19 	.word	0x0801bb19
 801baf0:	0801bb13 	.word	0x0801bb13
    case (2*2): natural_order = jpeg_natural_order2; break;
 801baf4:	4b7f      	ldr	r3, [pc, #508]	@ (801bcf4 <get_dqt+0x478>)
 801baf6:	627b      	str	r3, [r7, #36]	@ 0x24
 801baf8:	e011      	b.n	801bb1e <get_dqt+0x2a2>
    case (3*3): natural_order = jpeg_natural_order3; break;
 801bafa:	4b7f      	ldr	r3, [pc, #508]	@ (801bcf8 <get_dqt+0x47c>)
 801bafc:	627b      	str	r3, [r7, #36]	@ 0x24
 801bafe:	e00e      	b.n	801bb1e <get_dqt+0x2a2>
    case (4*4): natural_order = jpeg_natural_order4; break;
 801bb00:	4b7e      	ldr	r3, [pc, #504]	@ (801bcfc <get_dqt+0x480>)
 801bb02:	627b      	str	r3, [r7, #36]	@ 0x24
 801bb04:	e00b      	b.n	801bb1e <get_dqt+0x2a2>
    case (5*5): natural_order = jpeg_natural_order5; break;
 801bb06:	4b7e      	ldr	r3, [pc, #504]	@ (801bd00 <get_dqt+0x484>)
 801bb08:	627b      	str	r3, [r7, #36]	@ 0x24
 801bb0a:	e008      	b.n	801bb1e <get_dqt+0x2a2>
    case (6*6): natural_order = jpeg_natural_order6; break;
 801bb0c:	4b7d      	ldr	r3, [pc, #500]	@ (801bd04 <get_dqt+0x488>)
 801bb0e:	627b      	str	r3, [r7, #36]	@ 0x24
 801bb10:	e005      	b.n	801bb1e <get_dqt+0x2a2>
    case (7*7): natural_order = jpeg_natural_order7; break;
 801bb12:	4b7d      	ldr	r3, [pc, #500]	@ (801bd08 <get_dqt+0x48c>)
 801bb14:	627b      	str	r3, [r7, #36]	@ 0x24
 801bb16:	e002      	b.n	801bb1e <get_dqt+0x2a2>
    default:    natural_order = jpeg_natural_order;  break;
 801bb18:	4b7c      	ldr	r3, [pc, #496]	@ (801bd0c <get_dqt+0x490>)
 801bb1a:	627b      	str	r3, [r7, #36]	@ 0x24
 801bb1c:	bf00      	nop
    }

    for (i = 0; i < count; i++) {
 801bb1e:	2300      	movs	r3, #0
 801bb20:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bb22:	e062      	b.n	801bbea <get_dqt+0x36e>
      if (prec)
 801bb24:	693b      	ldr	r3, [r7, #16]
 801bb26:	2b00      	cmp	r3, #0
 801bb28:	d038      	beq.n	801bb9c <get_dqt+0x320>
	INPUT_2BYTES(cinfo, tmp, return FALSE);
 801bb2a:	69fb      	ldr	r3, [r7, #28]
 801bb2c:	2b00      	cmp	r3, #0
 801bb2e:	d10e      	bne.n	801bb4e <get_dqt+0x2d2>
 801bb30:	69bb      	ldr	r3, [r7, #24]
 801bb32:	68db      	ldr	r3, [r3, #12]
 801bb34:	6878      	ldr	r0, [r7, #4]
 801bb36:	4798      	blx	r3
 801bb38:	4603      	mov	r3, r0
 801bb3a:	2b00      	cmp	r3, #0
 801bb3c:	d101      	bne.n	801bb42 <get_dqt+0x2c6>
 801bb3e:	2300      	movs	r3, #0
 801bb40:	e0d4      	b.n	801bcec <get_dqt+0x470>
 801bb42:	69bb      	ldr	r3, [r7, #24]
 801bb44:	681b      	ldr	r3, [r3, #0]
 801bb46:	623b      	str	r3, [r7, #32]
 801bb48:	69bb      	ldr	r3, [r7, #24]
 801bb4a:	685b      	ldr	r3, [r3, #4]
 801bb4c:	61fb      	str	r3, [r7, #28]
 801bb4e:	69fb      	ldr	r3, [r7, #28]
 801bb50:	3b01      	subs	r3, #1
 801bb52:	61fb      	str	r3, [r7, #28]
 801bb54:	6a3b      	ldr	r3, [r7, #32]
 801bb56:	1c5a      	adds	r2, r3, #1
 801bb58:	623a      	str	r2, [r7, #32]
 801bb5a:	781b      	ldrb	r3, [r3, #0]
 801bb5c:	021b      	lsls	r3, r3, #8
 801bb5e:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bb60:	69fb      	ldr	r3, [r7, #28]
 801bb62:	2b00      	cmp	r3, #0
 801bb64:	d10e      	bne.n	801bb84 <get_dqt+0x308>
 801bb66:	69bb      	ldr	r3, [r7, #24]
 801bb68:	68db      	ldr	r3, [r3, #12]
 801bb6a:	6878      	ldr	r0, [r7, #4]
 801bb6c:	4798      	blx	r3
 801bb6e:	4603      	mov	r3, r0
 801bb70:	2b00      	cmp	r3, #0
 801bb72:	d101      	bne.n	801bb78 <get_dqt+0x2fc>
 801bb74:	2300      	movs	r3, #0
 801bb76:	e0b9      	b.n	801bcec <get_dqt+0x470>
 801bb78:	69bb      	ldr	r3, [r7, #24]
 801bb7a:	681b      	ldr	r3, [r3, #0]
 801bb7c:	623b      	str	r3, [r7, #32]
 801bb7e:	69bb      	ldr	r3, [r7, #24]
 801bb80:	685b      	ldr	r3, [r3, #4]
 801bb82:	61fb      	str	r3, [r7, #28]
 801bb84:	69fb      	ldr	r3, [r7, #28]
 801bb86:	3b01      	subs	r3, #1
 801bb88:	61fb      	str	r3, [r7, #28]
 801bb8a:	6a3b      	ldr	r3, [r7, #32]
 801bb8c:	1c5a      	adds	r2, r3, #1
 801bb8e:	623a      	str	r2, [r7, #32]
 801bb90:	781b      	ldrb	r3, [r3, #0]
 801bb92:	461a      	mov	r2, r3
 801bb94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bb96:	4413      	add	r3, r2
 801bb98:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bb9a:	e019      	b.n	801bbd0 <get_dqt+0x354>
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
 801bb9c:	69fb      	ldr	r3, [r7, #28]
 801bb9e:	2b00      	cmp	r3, #0
 801bba0:	d10e      	bne.n	801bbc0 <get_dqt+0x344>
 801bba2:	69bb      	ldr	r3, [r7, #24]
 801bba4:	68db      	ldr	r3, [r3, #12]
 801bba6:	6878      	ldr	r0, [r7, #4]
 801bba8:	4798      	blx	r3
 801bbaa:	4603      	mov	r3, r0
 801bbac:	2b00      	cmp	r3, #0
 801bbae:	d101      	bne.n	801bbb4 <get_dqt+0x338>
 801bbb0:	2300      	movs	r3, #0
 801bbb2:	e09b      	b.n	801bcec <get_dqt+0x470>
 801bbb4:	69bb      	ldr	r3, [r7, #24]
 801bbb6:	681b      	ldr	r3, [r3, #0]
 801bbb8:	623b      	str	r3, [r7, #32]
 801bbba:	69bb      	ldr	r3, [r7, #24]
 801bbbc:	685b      	ldr	r3, [r3, #4]
 801bbbe:	61fb      	str	r3, [r7, #28]
 801bbc0:	69fb      	ldr	r3, [r7, #28]
 801bbc2:	3b01      	subs	r3, #1
 801bbc4:	61fb      	str	r3, [r7, #28]
 801bbc6:	6a3b      	ldr	r3, [r7, #32]
 801bbc8:	1c5a      	adds	r2, r3, #1
 801bbca:	623a      	str	r2, [r7, #32]
 801bbcc:	781b      	ldrb	r3, [r3, #0]
 801bbce:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[natural_order[i]] = (UINT16) tmp;
 801bbd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bbd2:	009b      	lsls	r3, r3, #2
 801bbd4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801bbd6:	4413      	add	r3, r2
 801bbd8:	681a      	ldr	r2, [r3, #0]
 801bbda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bbdc:	b299      	uxth	r1, r3
 801bbde:	68fb      	ldr	r3, [r7, #12]
 801bbe0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < count; i++) {
 801bbe4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bbe6:	3301      	adds	r3, #1
 801bbe8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bbea:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801bbec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bbee:	429a      	cmp	r2, r3
 801bbf0:	db98      	blt.n	801bb24 <get_dqt+0x2a8>
    }

    if (cinfo->err->trace_level >= 2) {
 801bbf2:	687b      	ldr	r3, [r7, #4]
 801bbf4:	681b      	ldr	r3, [r3, #0]
 801bbf6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801bbf8:	2b01      	cmp	r3, #1
 801bbfa:	dd55      	ble.n	801bca8 <get_dqt+0x42c>
      for (i = 0; i < DCTSIZE2; i += 8) {
 801bbfc:	2300      	movs	r3, #0
 801bbfe:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bc00:	e04f      	b.n	801bca2 <get_dqt+0x426>
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
 801bc02:	687b      	ldr	r3, [r7, #4]
 801bc04:	681b      	ldr	r3, [r3, #0]
 801bc06:	3318      	adds	r3, #24
 801bc08:	60bb      	str	r3, [r7, #8]
 801bc0a:	68fb      	ldr	r3, [r7, #12]
 801bc0c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801bc0e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 801bc12:	461a      	mov	r2, r3
 801bc14:	68bb      	ldr	r3, [r7, #8]
 801bc16:	601a      	str	r2, [r3, #0]
 801bc18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc1a:	1c5a      	adds	r2, r3, #1
 801bc1c:	68fb      	ldr	r3, [r7, #12]
 801bc1e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc22:	68bb      	ldr	r3, [r7, #8]
 801bc24:	3304      	adds	r3, #4
 801bc26:	601a      	str	r2, [r3, #0]
 801bc28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc2a:	1c9a      	adds	r2, r3, #2
 801bc2c:	68fb      	ldr	r3, [r7, #12]
 801bc2e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc32:	68bb      	ldr	r3, [r7, #8]
 801bc34:	3308      	adds	r3, #8
 801bc36:	601a      	str	r2, [r3, #0]
 801bc38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc3a:	1cda      	adds	r2, r3, #3
 801bc3c:	68fb      	ldr	r3, [r7, #12]
 801bc3e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc42:	68bb      	ldr	r3, [r7, #8]
 801bc44:	330c      	adds	r3, #12
 801bc46:	601a      	str	r2, [r3, #0]
 801bc48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc4a:	1d1a      	adds	r2, r3, #4
 801bc4c:	68fb      	ldr	r3, [r7, #12]
 801bc4e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc52:	68bb      	ldr	r3, [r7, #8]
 801bc54:	3310      	adds	r3, #16
 801bc56:	601a      	str	r2, [r3, #0]
 801bc58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc5a:	1d5a      	adds	r2, r3, #5
 801bc5c:	68fb      	ldr	r3, [r7, #12]
 801bc5e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc62:	68bb      	ldr	r3, [r7, #8]
 801bc64:	3314      	adds	r3, #20
 801bc66:	601a      	str	r2, [r3, #0]
 801bc68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc6a:	1d9a      	adds	r2, r3, #6
 801bc6c:	68fb      	ldr	r3, [r7, #12]
 801bc6e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc72:	68bb      	ldr	r3, [r7, #8]
 801bc74:	3318      	adds	r3, #24
 801bc76:	601a      	str	r2, [r3, #0]
 801bc78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc7a:	1dda      	adds	r2, r3, #7
 801bc7c:	68fb      	ldr	r3, [r7, #12]
 801bc7e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 801bc82:	68bb      	ldr	r3, [r7, #8]
 801bc84:	331c      	adds	r3, #28
 801bc86:	601a      	str	r2, [r3, #0]
 801bc88:	687b      	ldr	r3, [r7, #4]
 801bc8a:	681b      	ldr	r3, [r3, #0]
 801bc8c:	225f      	movs	r2, #95	@ 0x5f
 801bc8e:	615a      	str	r2, [r3, #20]
 801bc90:	687b      	ldr	r3, [r7, #4]
 801bc92:	681b      	ldr	r3, [r3, #0]
 801bc94:	685b      	ldr	r3, [r3, #4]
 801bc96:	2102      	movs	r1, #2
 801bc98:	6878      	ldr	r0, [r7, #4]
 801bc9a:	4798      	blx	r3
      for (i = 0; i < DCTSIZE2; i += 8) {
 801bc9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bc9e:	3308      	adds	r3, #8
 801bca0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bca2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bca4:	2b3f      	cmp	r3, #63	@ 0x3f
 801bca6:	ddac      	ble.n	801bc02 <get_dqt+0x386>
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= count;
 801bca8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801bcaa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bcac:	1ad3      	subs	r3, r2, r3
 801bcae:	637b      	str	r3, [r7, #52]	@ 0x34
    if (prec) length -= count;
 801bcb0:	693b      	ldr	r3, [r7, #16]
 801bcb2:	2b00      	cmp	r3, #0
 801bcb4:	d003      	beq.n	801bcbe <get_dqt+0x442>
 801bcb6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801bcb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bcba:	1ad3      	subs	r3, r2, r3
 801bcbc:	637b      	str	r3, [r7, #52]	@ 0x34
  while (length > 0) {
 801bcbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bcc0:	2b00      	cmp	r3, #0
 801bcc2:	f73f ae24 	bgt.w	801b90e <get_dqt+0x92>
  }

  if (length != 0)
 801bcc6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bcc8:	2b00      	cmp	r3, #0
 801bcca:	d008      	beq.n	801bcde <get_dqt+0x462>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801bccc:	687b      	ldr	r3, [r7, #4]
 801bcce:	681b      	ldr	r3, [r3, #0]
 801bcd0:	220c      	movs	r2, #12
 801bcd2:	615a      	str	r2, [r3, #20]
 801bcd4:	687b      	ldr	r3, [r7, #4]
 801bcd6:	681b      	ldr	r3, [r3, #0]
 801bcd8:	681b      	ldr	r3, [r3, #0]
 801bcda:	6878      	ldr	r0, [r7, #4]
 801bcdc:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 801bcde:	69bb      	ldr	r3, [r7, #24]
 801bce0:	6a3a      	ldr	r2, [r7, #32]
 801bce2:	601a      	str	r2, [r3, #0]
 801bce4:	69bb      	ldr	r3, [r7, #24]
 801bce6:	69fa      	ldr	r2, [r7, #28]
 801bce8:	605a      	str	r2, [r3, #4]
  return TRUE;
 801bcea:	2301      	movs	r3, #1
}
 801bcec:	4618      	mov	r0, r3
 801bcee:	3738      	adds	r7, #56	@ 0x38
 801bcf0:	46bd      	mov	sp, r7
 801bcf2:	bd80      	pop	{r7, pc}
 801bcf4:	08032bec 	.word	0x08032bec
 801bcf8:	08032b88 	.word	0x08032b88
 801bcfc:	08032b08 	.word	0x08032b08
 801bd00:	08032a64 	.word	0x08032a64
 801bd04:	08032994 	.word	0x08032994
 801bd08:	08032890 	.word	0x08032890
 801bd0c:	08032750 	.word	0x08032750

0801bd10 <get_dri>:


LOCAL(boolean)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
 801bd10:	b580      	push	{r7, lr}
 801bd12:	b088      	sub	sp, #32
 801bd14:	af00      	add	r7, sp, #0
 801bd16:	6078      	str	r0, [r7, #4]
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);
 801bd18:	687b      	ldr	r3, [r7, #4]
 801bd1a:	699b      	ldr	r3, [r3, #24]
 801bd1c:	617b      	str	r3, [r7, #20]
 801bd1e:	697b      	ldr	r3, [r7, #20]
 801bd20:	681b      	ldr	r3, [r3, #0]
 801bd22:	61fb      	str	r3, [r7, #28]
 801bd24:	697b      	ldr	r3, [r7, #20]
 801bd26:	685b      	ldr	r3, [r3, #4]
 801bd28:	61bb      	str	r3, [r7, #24]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801bd2a:	69bb      	ldr	r3, [r7, #24]
 801bd2c:	2b00      	cmp	r3, #0
 801bd2e:	d10e      	bne.n	801bd4e <get_dri+0x3e>
 801bd30:	697b      	ldr	r3, [r7, #20]
 801bd32:	68db      	ldr	r3, [r3, #12]
 801bd34:	6878      	ldr	r0, [r7, #4]
 801bd36:	4798      	blx	r3
 801bd38:	4603      	mov	r3, r0
 801bd3a:	2b00      	cmp	r3, #0
 801bd3c:	d101      	bne.n	801bd42 <get_dri+0x32>
 801bd3e:	2300      	movs	r3, #0
 801bd40:	e088      	b.n	801be54 <get_dri+0x144>
 801bd42:	697b      	ldr	r3, [r7, #20]
 801bd44:	681b      	ldr	r3, [r3, #0]
 801bd46:	61fb      	str	r3, [r7, #28]
 801bd48:	697b      	ldr	r3, [r7, #20]
 801bd4a:	685b      	ldr	r3, [r3, #4]
 801bd4c:	61bb      	str	r3, [r7, #24]
 801bd4e:	69bb      	ldr	r3, [r7, #24]
 801bd50:	3b01      	subs	r3, #1
 801bd52:	61bb      	str	r3, [r7, #24]
 801bd54:	69fb      	ldr	r3, [r7, #28]
 801bd56:	1c5a      	adds	r2, r3, #1
 801bd58:	61fa      	str	r2, [r7, #28]
 801bd5a:	781b      	ldrb	r3, [r3, #0]
 801bd5c:	021b      	lsls	r3, r3, #8
 801bd5e:	613b      	str	r3, [r7, #16]
 801bd60:	69bb      	ldr	r3, [r7, #24]
 801bd62:	2b00      	cmp	r3, #0
 801bd64:	d10e      	bne.n	801bd84 <get_dri+0x74>
 801bd66:	697b      	ldr	r3, [r7, #20]
 801bd68:	68db      	ldr	r3, [r3, #12]
 801bd6a:	6878      	ldr	r0, [r7, #4]
 801bd6c:	4798      	blx	r3
 801bd6e:	4603      	mov	r3, r0
 801bd70:	2b00      	cmp	r3, #0
 801bd72:	d101      	bne.n	801bd78 <get_dri+0x68>
 801bd74:	2300      	movs	r3, #0
 801bd76:	e06d      	b.n	801be54 <get_dri+0x144>
 801bd78:	697b      	ldr	r3, [r7, #20]
 801bd7a:	681b      	ldr	r3, [r3, #0]
 801bd7c:	61fb      	str	r3, [r7, #28]
 801bd7e:	697b      	ldr	r3, [r7, #20]
 801bd80:	685b      	ldr	r3, [r3, #4]
 801bd82:	61bb      	str	r3, [r7, #24]
 801bd84:	69bb      	ldr	r3, [r7, #24]
 801bd86:	3b01      	subs	r3, #1
 801bd88:	61bb      	str	r3, [r7, #24]
 801bd8a:	69fb      	ldr	r3, [r7, #28]
 801bd8c:	1c5a      	adds	r2, r3, #1
 801bd8e:	61fa      	str	r2, [r7, #28]
 801bd90:	781b      	ldrb	r3, [r3, #0]
 801bd92:	461a      	mov	r2, r3
 801bd94:	693b      	ldr	r3, [r7, #16]
 801bd96:	4413      	add	r3, r2
 801bd98:	613b      	str	r3, [r7, #16]
  
  if (length != 4)
 801bd9a:	693b      	ldr	r3, [r7, #16]
 801bd9c:	2b04      	cmp	r3, #4
 801bd9e:	d008      	beq.n	801bdb2 <get_dri+0xa2>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 801bda0:	687b      	ldr	r3, [r7, #4]
 801bda2:	681b      	ldr	r3, [r3, #0]
 801bda4:	220c      	movs	r2, #12
 801bda6:	615a      	str	r2, [r3, #20]
 801bda8:	687b      	ldr	r3, [r7, #4]
 801bdaa:	681b      	ldr	r3, [r3, #0]
 801bdac:	681b      	ldr	r3, [r3, #0]
 801bdae:	6878      	ldr	r0, [r7, #4]
 801bdb0:	4798      	blx	r3

  INPUT_2BYTES(cinfo, tmp, return FALSE);
 801bdb2:	69bb      	ldr	r3, [r7, #24]
 801bdb4:	2b00      	cmp	r3, #0
 801bdb6:	d10e      	bne.n	801bdd6 <get_dri+0xc6>
 801bdb8:	697b      	ldr	r3, [r7, #20]
 801bdba:	68db      	ldr	r3, [r3, #12]
 801bdbc:	6878      	ldr	r0, [r7, #4]
 801bdbe:	4798      	blx	r3
 801bdc0:	4603      	mov	r3, r0
 801bdc2:	2b00      	cmp	r3, #0
 801bdc4:	d101      	bne.n	801bdca <get_dri+0xba>
 801bdc6:	2300      	movs	r3, #0
 801bdc8:	e044      	b.n	801be54 <get_dri+0x144>
 801bdca:	697b      	ldr	r3, [r7, #20]
 801bdcc:	681b      	ldr	r3, [r3, #0]
 801bdce:	61fb      	str	r3, [r7, #28]
 801bdd0:	697b      	ldr	r3, [r7, #20]
 801bdd2:	685b      	ldr	r3, [r3, #4]
 801bdd4:	61bb      	str	r3, [r7, #24]
 801bdd6:	69bb      	ldr	r3, [r7, #24]
 801bdd8:	3b01      	subs	r3, #1
 801bdda:	61bb      	str	r3, [r7, #24]
 801bddc:	69fb      	ldr	r3, [r7, #28]
 801bdde:	1c5a      	adds	r2, r3, #1
 801bde0:	61fa      	str	r2, [r7, #28]
 801bde2:	781b      	ldrb	r3, [r3, #0]
 801bde4:	021b      	lsls	r3, r3, #8
 801bde6:	60fb      	str	r3, [r7, #12]
 801bde8:	69bb      	ldr	r3, [r7, #24]
 801bdea:	2b00      	cmp	r3, #0
 801bdec:	d10e      	bne.n	801be0c <get_dri+0xfc>
 801bdee:	697b      	ldr	r3, [r7, #20]
 801bdf0:	68db      	ldr	r3, [r3, #12]
 801bdf2:	6878      	ldr	r0, [r7, #4]
 801bdf4:	4798      	blx	r3
 801bdf6:	4603      	mov	r3, r0
 801bdf8:	2b00      	cmp	r3, #0
 801bdfa:	d101      	bne.n	801be00 <get_dri+0xf0>
 801bdfc:	2300      	movs	r3, #0
 801bdfe:	e029      	b.n	801be54 <get_dri+0x144>
 801be00:	697b      	ldr	r3, [r7, #20]
 801be02:	681b      	ldr	r3, [r3, #0]
 801be04:	61fb      	str	r3, [r7, #28]
 801be06:	697b      	ldr	r3, [r7, #20]
 801be08:	685b      	ldr	r3, [r3, #4]
 801be0a:	61bb      	str	r3, [r7, #24]
 801be0c:	69bb      	ldr	r3, [r7, #24]
 801be0e:	3b01      	subs	r3, #1
 801be10:	61bb      	str	r3, [r7, #24]
 801be12:	69fb      	ldr	r3, [r7, #28]
 801be14:	1c5a      	adds	r2, r3, #1
 801be16:	61fa      	str	r2, [r7, #28]
 801be18:	781b      	ldrb	r3, [r3, #0]
 801be1a:	461a      	mov	r2, r3
 801be1c:	68fb      	ldr	r3, [r7, #12]
 801be1e:	4413      	add	r3, r2
 801be20:	60fb      	str	r3, [r7, #12]

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);
 801be22:	687b      	ldr	r3, [r7, #4]
 801be24:	681b      	ldr	r3, [r3, #0]
 801be26:	2254      	movs	r2, #84	@ 0x54
 801be28:	615a      	str	r2, [r3, #20]
 801be2a:	687b      	ldr	r3, [r7, #4]
 801be2c:	681b      	ldr	r3, [r3, #0]
 801be2e:	68fa      	ldr	r2, [r7, #12]
 801be30:	619a      	str	r2, [r3, #24]
 801be32:	687b      	ldr	r3, [r7, #4]
 801be34:	681b      	ldr	r3, [r3, #0]
 801be36:	685b      	ldr	r3, [r3, #4]
 801be38:	2101      	movs	r1, #1
 801be3a:	6878      	ldr	r0, [r7, #4]
 801be3c:	4798      	blx	r3

  cinfo->restart_interval = tmp;
 801be3e:	687b      	ldr	r3, [r7, #4]
 801be40:	68fa      	ldr	r2, [r7, #12]
 801be42:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118

  INPUT_SYNC(cinfo);
 801be46:	697b      	ldr	r3, [r7, #20]
 801be48:	69fa      	ldr	r2, [r7, #28]
 801be4a:	601a      	str	r2, [r3, #0]
 801be4c:	697b      	ldr	r3, [r7, #20]
 801be4e:	69ba      	ldr	r2, [r7, #24]
 801be50:	605a      	str	r2, [r3, #4]
  return TRUE;
 801be52:	2301      	movs	r3, #1
}
 801be54:	4618      	mov	r0, r3
 801be56:	3720      	adds	r7, #32
 801be58:	46bd      	mov	sp, r7
 801be5a:	bd80      	pop	{r7, pc}

0801be5c <examine_app0>:
	      unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP0.
 * Take appropriate action if it is a JFIF marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 801be5c:	b580      	push	{r7, lr}
 801be5e:	b086      	sub	sp, #24
 801be60:	af00      	add	r7, sp, #0
 801be62:	60f8      	str	r0, [r7, #12]
 801be64:	60b9      	str	r1, [r7, #8]
 801be66:	607a      	str	r2, [r7, #4]
 801be68:	603b      	str	r3, [r7, #0]
  INT32 totallen = (INT32) datalen + remaining;
 801be6a:	687b      	ldr	r3, [r7, #4]
 801be6c:	683a      	ldr	r2, [r7, #0]
 801be6e:	4413      	add	r3, r2
 801be70:	617b      	str	r3, [r7, #20]

  if (datalen >= APP0_DATA_LEN &&
 801be72:	687b      	ldr	r3, [r7, #4]
 801be74:	2b0d      	cmp	r3, #13
 801be76:	f240 80d4 	bls.w	801c022 <examine_app0+0x1c6>
      GETJOCTET(data[0]) == 0x4A &&
 801be7a:	68bb      	ldr	r3, [r7, #8]
 801be7c:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP0_DATA_LEN &&
 801be7e:	2b4a      	cmp	r3, #74	@ 0x4a
 801be80:	f040 80cf 	bne.w	801c022 <examine_app0+0x1c6>
      GETJOCTET(data[1]) == 0x46 &&
 801be84:	68bb      	ldr	r3, [r7, #8]
 801be86:	3301      	adds	r3, #1
 801be88:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 801be8a:	2b46      	cmp	r3, #70	@ 0x46
 801be8c:	f040 80c9 	bne.w	801c022 <examine_app0+0x1c6>
      GETJOCTET(data[2]) == 0x49 &&
 801be90:	68bb      	ldr	r3, [r7, #8]
 801be92:	3302      	adds	r3, #2
 801be94:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 801be96:	2b49      	cmp	r3, #73	@ 0x49
 801be98:	f040 80c3 	bne.w	801c022 <examine_app0+0x1c6>
      GETJOCTET(data[3]) == 0x46 &&
 801be9c:	68bb      	ldr	r3, [r7, #8]
 801be9e:	3303      	adds	r3, #3
 801bea0:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x49 &&
 801bea2:	2b46      	cmp	r3, #70	@ 0x46
 801bea4:	f040 80bd 	bne.w	801c022 <examine_app0+0x1c6>
      GETJOCTET(data[4]) == 0) {
 801bea8:	68bb      	ldr	r3, [r7, #8]
 801beaa:	3304      	adds	r3, #4
 801beac:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x46 &&
 801beae:	2b00      	cmp	r3, #0
 801beb0:	f040 80b7 	bne.w	801c022 <examine_app0+0x1c6>
    /* Found JFIF APP0 marker: save info */
    cinfo->saw_JFIF_marker = TRUE;
 801beb4:	68fb      	ldr	r3, [r7, #12]
 801beb6:	2201      	movs	r2, #1
 801beb8:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
    cinfo->JFIF_major_version = GETJOCTET(data[5]);
 801bebc:	68bb      	ldr	r3, [r7, #8]
 801bebe:	795a      	ldrb	r2, [r3, #5]
 801bec0:	68fb      	ldr	r3, [r7, #12]
 801bec2:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
 801bec6:	68bb      	ldr	r3, [r7, #8]
 801bec8:	799a      	ldrb	r2, [r3, #6]
 801beca:	68fb      	ldr	r3, [r7, #12]
 801becc:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
    cinfo->density_unit = GETJOCTET(data[7]);
 801bed0:	68bb      	ldr	r3, [r7, #8]
 801bed2:	79da      	ldrb	r2, [r3, #7]
 801bed4:	68fb      	ldr	r3, [r7, #12]
 801bed6:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
 801beda:	68bb      	ldr	r3, [r7, #8]
 801bedc:	3308      	adds	r3, #8
 801bede:	781b      	ldrb	r3, [r3, #0]
 801bee0:	021b      	lsls	r3, r3, #8
 801bee2:	b29b      	uxth	r3, r3
 801bee4:	68ba      	ldr	r2, [r7, #8]
 801bee6:	3209      	adds	r2, #9
 801bee8:	7812      	ldrb	r2, [r2, #0]
 801beea:	4413      	add	r3, r2
 801beec:	b29a      	uxth	r2, r3
 801beee:	68fb      	ldr	r3, [r7, #12]
 801bef0:	f8a3 2124 	strh.w	r2, [r3, #292]	@ 0x124
    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
 801bef4:	68bb      	ldr	r3, [r7, #8]
 801bef6:	330a      	adds	r3, #10
 801bef8:	781b      	ldrb	r3, [r3, #0]
 801befa:	021b      	lsls	r3, r3, #8
 801befc:	b29b      	uxth	r3, r3
 801befe:	68ba      	ldr	r2, [r7, #8]
 801bf00:	320b      	adds	r2, #11
 801bf02:	7812      	ldrb	r2, [r2, #0]
 801bf04:	4413      	add	r3, r2
 801bf06:	b29a      	uxth	r2, r3
 801bf08:	68fb      	ldr	r3, [r7, #12]
 801bf0a:	f8a3 2126 	strh.w	r2, [r3, #294]	@ 0x126
     * Major version must be 1, anything else signals an incompatible change.
     * (We used to treat this as an error, but now it's a nonfatal warning,
     * because some bozo at Hijaak couldn't read the spec.)
     * Minor version should be 0..2, but process anyway if newer.
     */
    if (cinfo->JFIF_major_version != 1)
 801bf0e:	68fb      	ldr	r3, [r7, #12]
 801bf10:	f893 3120 	ldrb.w	r3, [r3, #288]	@ 0x120
 801bf14:	2b01      	cmp	r3, #1
 801bf16:	d016      	beq.n	801bf46 <examine_app0+0xea>
      WARNMS2(cinfo, JWRN_JFIF_MAJOR,
 801bf18:	68fb      	ldr	r3, [r7, #12]
 801bf1a:	681b      	ldr	r3, [r3, #0]
 801bf1c:	227a      	movs	r2, #122	@ 0x7a
 801bf1e:	615a      	str	r2, [r3, #20]
 801bf20:	68fb      	ldr	r3, [r7, #12]
 801bf22:	f893 2120 	ldrb.w	r2, [r3, #288]	@ 0x120
 801bf26:	68fb      	ldr	r3, [r7, #12]
 801bf28:	681b      	ldr	r3, [r3, #0]
 801bf2a:	619a      	str	r2, [r3, #24]
 801bf2c:	68fb      	ldr	r3, [r7, #12]
 801bf2e:	f893 2121 	ldrb.w	r2, [r3, #289]	@ 0x121
 801bf32:	68fb      	ldr	r3, [r7, #12]
 801bf34:	681b      	ldr	r3, [r3, #0]
 801bf36:	61da      	str	r2, [r3, #28]
 801bf38:	68fb      	ldr	r3, [r7, #12]
 801bf3a:	681b      	ldr	r3, [r3, #0]
 801bf3c:	685b      	ldr	r3, [r3, #4]
 801bf3e:	f04f 31ff 	mov.w	r1, #4294967295
 801bf42:	68f8      	ldr	r0, [r7, #12]
 801bf44:	4798      	blx	r3
	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
    /* Generate trace messages */
    TRACEMS5(cinfo, 1, JTRC_JFIF,
 801bf46:	68fb      	ldr	r3, [r7, #12]
 801bf48:	681b      	ldr	r3, [r3, #0]
 801bf4a:	3318      	adds	r3, #24
 801bf4c:	613b      	str	r3, [r7, #16]
 801bf4e:	68fb      	ldr	r3, [r7, #12]
 801bf50:	f893 3120 	ldrb.w	r3, [r3, #288]	@ 0x120
 801bf54:	461a      	mov	r2, r3
 801bf56:	693b      	ldr	r3, [r7, #16]
 801bf58:	601a      	str	r2, [r3, #0]
 801bf5a:	68fb      	ldr	r3, [r7, #12]
 801bf5c:	f893 2121 	ldrb.w	r2, [r3, #289]	@ 0x121
 801bf60:	693b      	ldr	r3, [r7, #16]
 801bf62:	3304      	adds	r3, #4
 801bf64:	601a      	str	r2, [r3, #0]
 801bf66:	68fb      	ldr	r3, [r7, #12]
 801bf68:	f8b3 2124 	ldrh.w	r2, [r3, #292]	@ 0x124
 801bf6c:	693b      	ldr	r3, [r7, #16]
 801bf6e:	3308      	adds	r3, #8
 801bf70:	601a      	str	r2, [r3, #0]
 801bf72:	68fb      	ldr	r3, [r7, #12]
 801bf74:	f8b3 2126 	ldrh.w	r2, [r3, #294]	@ 0x126
 801bf78:	693b      	ldr	r3, [r7, #16]
 801bf7a:	330c      	adds	r3, #12
 801bf7c:	601a      	str	r2, [r3, #0]
 801bf7e:	68fb      	ldr	r3, [r7, #12]
 801bf80:	f893 2122 	ldrb.w	r2, [r3, #290]	@ 0x122
 801bf84:	693b      	ldr	r3, [r7, #16]
 801bf86:	3310      	adds	r3, #16
 801bf88:	601a      	str	r2, [r3, #0]
 801bf8a:	68fb      	ldr	r3, [r7, #12]
 801bf8c:	681b      	ldr	r3, [r3, #0]
 801bf8e:	2259      	movs	r2, #89	@ 0x59
 801bf90:	615a      	str	r2, [r3, #20]
 801bf92:	68fb      	ldr	r3, [r7, #12]
 801bf94:	681b      	ldr	r3, [r3, #0]
 801bf96:	685b      	ldr	r3, [r3, #4]
 801bf98:	2101      	movs	r1, #1
 801bf9a:	68f8      	ldr	r0, [r7, #12]
 801bf9c:	4798      	blx	r3
	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
    /* Validate thumbnail dimensions and issue appropriate messages */
    if (GETJOCTET(data[12]) | GETJOCTET(data[13]))
 801bf9e:	68bb      	ldr	r3, [r7, #8]
 801bfa0:	330c      	adds	r3, #12
 801bfa2:	781a      	ldrb	r2, [r3, #0]
 801bfa4:	68bb      	ldr	r3, [r7, #8]
 801bfa6:	330d      	adds	r3, #13
 801bfa8:	781b      	ldrb	r3, [r3, #0]
 801bfaa:	4313      	orrs	r3, r2
 801bfac:	b2db      	uxtb	r3, r3
 801bfae:	2b00      	cmp	r3, #0
 801bfb0:	d015      	beq.n	801bfde <examine_app0+0x182>
      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,
 801bfb2:	68fb      	ldr	r3, [r7, #12]
 801bfb4:	681b      	ldr	r3, [r3, #0]
 801bfb6:	225c      	movs	r2, #92	@ 0x5c
 801bfb8:	615a      	str	r2, [r3, #20]
 801bfba:	68bb      	ldr	r3, [r7, #8]
 801bfbc:	330c      	adds	r3, #12
 801bfbe:	781a      	ldrb	r2, [r3, #0]
 801bfc0:	68fb      	ldr	r3, [r7, #12]
 801bfc2:	681b      	ldr	r3, [r3, #0]
 801bfc4:	619a      	str	r2, [r3, #24]
 801bfc6:	68bb      	ldr	r3, [r7, #8]
 801bfc8:	330d      	adds	r3, #13
 801bfca:	781a      	ldrb	r2, [r3, #0]
 801bfcc:	68fb      	ldr	r3, [r7, #12]
 801bfce:	681b      	ldr	r3, [r3, #0]
 801bfd0:	61da      	str	r2, [r3, #28]
 801bfd2:	68fb      	ldr	r3, [r7, #12]
 801bfd4:	681b      	ldr	r3, [r3, #0]
 801bfd6:	685b      	ldr	r3, [r3, #4]
 801bfd8:	2101      	movs	r1, #1
 801bfda:	68f8      	ldr	r0, [r7, #12]
 801bfdc:	4798      	blx	r3
	       GETJOCTET(data[12]), GETJOCTET(data[13]));
    totallen -= APP0_DATA_LEN;
 801bfde:	697b      	ldr	r3, [r7, #20]
 801bfe0:	3b0e      	subs	r3, #14
 801bfe2:	617b      	str	r3, [r7, #20]
    if (totallen !=
	((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))
 801bfe4:	68bb      	ldr	r3, [r7, #8]
 801bfe6:	330c      	adds	r3, #12
 801bfe8:	781b      	ldrb	r3, [r3, #0]
 801bfea:	461a      	mov	r2, r3
 801bfec:	68bb      	ldr	r3, [r7, #8]
 801bfee:	330d      	adds	r3, #13
 801bff0:	781b      	ldrb	r3, [r3, #0]
 801bff2:	fb03 f202 	mul.w	r2, r3, r2
 801bff6:	4613      	mov	r3, r2
 801bff8:	005b      	lsls	r3, r3, #1
 801bffa:	4413      	add	r3, r2
    if (totallen !=
 801bffc:	697a      	ldr	r2, [r7, #20]
 801bffe:	429a      	cmp	r2, r3
 801c000:	f000 8088 	beq.w	801c114 <examine_app0+0x2b8>
      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);
 801c004:	68fb      	ldr	r3, [r7, #12]
 801c006:	681b      	ldr	r3, [r3, #0]
 801c008:	225a      	movs	r2, #90	@ 0x5a
 801c00a:	615a      	str	r2, [r3, #20]
 801c00c:	68fb      	ldr	r3, [r7, #12]
 801c00e:	681b      	ldr	r3, [r3, #0]
 801c010:	697a      	ldr	r2, [r7, #20]
 801c012:	619a      	str	r2, [r3, #24]
 801c014:	68fb      	ldr	r3, [r7, #12]
 801c016:	681b      	ldr	r3, [r3, #0]
 801c018:	685b      	ldr	r3, [r3, #4]
 801c01a:	2101      	movs	r1, #1
 801c01c:	68f8      	ldr	r0, [r7, #12]
 801c01e:	4798      	blx	r3
    if (totallen !=
 801c020:	e078      	b.n	801c114 <examine_app0+0x2b8>
  } else if (datalen >= 6 &&
 801c022:	687b      	ldr	r3, [r7, #4]
 801c024:	2b05      	cmp	r3, #5
 801c026:	d966      	bls.n	801c0f6 <examine_app0+0x29a>
      GETJOCTET(data[0]) == 0x4A &&
 801c028:	68bb      	ldr	r3, [r7, #8]
 801c02a:	781b      	ldrb	r3, [r3, #0]
  } else if (datalen >= 6 &&
 801c02c:	2b4a      	cmp	r3, #74	@ 0x4a
 801c02e:	d162      	bne.n	801c0f6 <examine_app0+0x29a>
      GETJOCTET(data[1]) == 0x46 &&
 801c030:	68bb      	ldr	r3, [r7, #8]
 801c032:	3301      	adds	r3, #1
 801c034:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 801c036:	2b46      	cmp	r3, #70	@ 0x46
 801c038:	d15d      	bne.n	801c0f6 <examine_app0+0x29a>
      GETJOCTET(data[2]) == 0x58 &&
 801c03a:	68bb      	ldr	r3, [r7, #8]
 801c03c:	3302      	adds	r3, #2
 801c03e:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 801c040:	2b58      	cmp	r3, #88	@ 0x58
 801c042:	d158      	bne.n	801c0f6 <examine_app0+0x29a>
      GETJOCTET(data[3]) == 0x58 &&
 801c044:	68bb      	ldr	r3, [r7, #8]
 801c046:	3303      	adds	r3, #3
 801c048:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x58 &&
 801c04a:	2b58      	cmp	r3, #88	@ 0x58
 801c04c:	d153      	bne.n	801c0f6 <examine_app0+0x29a>
      GETJOCTET(data[4]) == 0) {
 801c04e:	68bb      	ldr	r3, [r7, #8]
 801c050:	3304      	adds	r3, #4
 801c052:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x58 &&
 801c054:	2b00      	cmp	r3, #0
 801c056:	d14e      	bne.n	801c0f6 <examine_app0+0x29a>
    /* Found JFIF "JFXX" extension APP0 marker */
    /* The library doesn't actually do anything with these,
     * but we try to produce a helpful trace message.
     */
    switch (GETJOCTET(data[5])) {
 801c058:	68bb      	ldr	r3, [r7, #8]
 801c05a:	3305      	adds	r3, #5
 801c05c:	781b      	ldrb	r3, [r3, #0]
 801c05e:	2b13      	cmp	r3, #19
 801c060:	d024      	beq.n	801c0ac <examine_app0+0x250>
 801c062:	2b13      	cmp	r3, #19
 801c064:	dc31      	bgt.n	801c0ca <examine_app0+0x26e>
 801c066:	2b10      	cmp	r3, #16
 801c068:	d002      	beq.n	801c070 <examine_app0+0x214>
 801c06a:	2b11      	cmp	r3, #17
 801c06c:	d00f      	beq.n	801c08e <examine_app0+0x232>
 801c06e:	e02c      	b.n	801c0ca <examine_app0+0x26e>
    case 0x10:
      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
 801c070:	68fb      	ldr	r3, [r7, #12]
 801c072:	681b      	ldr	r3, [r3, #0]
 801c074:	226e      	movs	r2, #110	@ 0x6e
 801c076:	615a      	str	r2, [r3, #20]
 801c078:	68fb      	ldr	r3, [r7, #12]
 801c07a:	681b      	ldr	r3, [r3, #0]
 801c07c:	697a      	ldr	r2, [r7, #20]
 801c07e:	619a      	str	r2, [r3, #24]
 801c080:	68fb      	ldr	r3, [r7, #12]
 801c082:	681b      	ldr	r3, [r3, #0]
 801c084:	685b      	ldr	r3, [r3, #4]
 801c086:	2101      	movs	r1, #1
 801c088:	68f8      	ldr	r0, [r7, #12]
 801c08a:	4798      	blx	r3
      break;
 801c08c:	e032      	b.n	801c0f4 <examine_app0+0x298>
    case 0x11:
      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
 801c08e:	68fb      	ldr	r3, [r7, #12]
 801c090:	681b      	ldr	r3, [r3, #0]
 801c092:	226f      	movs	r2, #111	@ 0x6f
 801c094:	615a      	str	r2, [r3, #20]
 801c096:	68fb      	ldr	r3, [r7, #12]
 801c098:	681b      	ldr	r3, [r3, #0]
 801c09a:	697a      	ldr	r2, [r7, #20]
 801c09c:	619a      	str	r2, [r3, #24]
 801c09e:	68fb      	ldr	r3, [r7, #12]
 801c0a0:	681b      	ldr	r3, [r3, #0]
 801c0a2:	685b      	ldr	r3, [r3, #4]
 801c0a4:	2101      	movs	r1, #1
 801c0a6:	68f8      	ldr	r0, [r7, #12]
 801c0a8:	4798      	blx	r3
      break;
 801c0aa:	e023      	b.n	801c0f4 <examine_app0+0x298>
    case 0x13:
      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
 801c0ac:	68fb      	ldr	r3, [r7, #12]
 801c0ae:	681b      	ldr	r3, [r3, #0]
 801c0b0:	2270      	movs	r2, #112	@ 0x70
 801c0b2:	615a      	str	r2, [r3, #20]
 801c0b4:	68fb      	ldr	r3, [r7, #12]
 801c0b6:	681b      	ldr	r3, [r3, #0]
 801c0b8:	697a      	ldr	r2, [r7, #20]
 801c0ba:	619a      	str	r2, [r3, #24]
 801c0bc:	68fb      	ldr	r3, [r7, #12]
 801c0be:	681b      	ldr	r3, [r3, #0]
 801c0c0:	685b      	ldr	r3, [r3, #4]
 801c0c2:	2101      	movs	r1, #1
 801c0c4:	68f8      	ldr	r0, [r7, #12]
 801c0c6:	4798      	blx	r3
      break;
 801c0c8:	e014      	b.n	801c0f4 <examine_app0+0x298>
    default:
      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
 801c0ca:	68fb      	ldr	r3, [r7, #12]
 801c0cc:	681b      	ldr	r3, [r3, #0]
 801c0ce:	225b      	movs	r2, #91	@ 0x5b
 801c0d0:	615a      	str	r2, [r3, #20]
 801c0d2:	68bb      	ldr	r3, [r7, #8]
 801c0d4:	3305      	adds	r3, #5
 801c0d6:	781a      	ldrb	r2, [r3, #0]
 801c0d8:	68fb      	ldr	r3, [r7, #12]
 801c0da:	681b      	ldr	r3, [r3, #0]
 801c0dc:	619a      	str	r2, [r3, #24]
 801c0de:	68fb      	ldr	r3, [r7, #12]
 801c0e0:	681b      	ldr	r3, [r3, #0]
 801c0e2:	697a      	ldr	r2, [r7, #20]
 801c0e4:	61da      	str	r2, [r3, #28]
 801c0e6:	68fb      	ldr	r3, [r7, #12]
 801c0e8:	681b      	ldr	r3, [r3, #0]
 801c0ea:	685b      	ldr	r3, [r3, #4]
 801c0ec:	2101      	movs	r1, #1
 801c0ee:	68f8      	ldr	r0, [r7, #12]
 801c0f0:	4798      	blx	r3
	       GETJOCTET(data[5]), (int) totallen);
      break;
 801c0f2:	bf00      	nop
    switch (GETJOCTET(data[5])) {
 801c0f4:	e00e      	b.n	801c114 <examine_app0+0x2b8>
    }
  } else {
    /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
 801c0f6:	68fb      	ldr	r3, [r7, #12]
 801c0f8:	681b      	ldr	r3, [r3, #0]
 801c0fa:	224f      	movs	r2, #79	@ 0x4f
 801c0fc:	615a      	str	r2, [r3, #20]
 801c0fe:	68fb      	ldr	r3, [r7, #12]
 801c100:	681b      	ldr	r3, [r3, #0]
 801c102:	697a      	ldr	r2, [r7, #20]
 801c104:	619a      	str	r2, [r3, #24]
 801c106:	68fb      	ldr	r3, [r7, #12]
 801c108:	681b      	ldr	r3, [r3, #0]
 801c10a:	685b      	ldr	r3, [r3, #4]
 801c10c:	2101      	movs	r1, #1
 801c10e:	68f8      	ldr	r0, [r7, #12]
 801c110:	4798      	blx	r3
  }
}
 801c112:	bf00      	nop
 801c114:	bf00      	nop
 801c116:	3718      	adds	r7, #24
 801c118:	46bd      	mov	sp, r7
 801c11a:	bd80      	pop	{r7, pc}

0801c11c <examine_app14>:
	       unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP14.
 * Take appropriate action if it is an Adobe marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 801c11c:	b580      	push	{r7, lr}
 801c11e:	b08a      	sub	sp, #40	@ 0x28
 801c120:	af00      	add	r7, sp, #0
 801c122:	60f8      	str	r0, [r7, #12]
 801c124:	60b9      	str	r1, [r7, #8]
 801c126:	607a      	str	r2, [r7, #4]
 801c128:	603b      	str	r3, [r7, #0]
  unsigned int version, flags0, flags1, transform;

  if (datalen >= APP14_DATA_LEN &&
 801c12a:	687b      	ldr	r3, [r7, #4]
 801c12c:	2b0b      	cmp	r3, #11
 801c12e:	d95d      	bls.n	801c1ec <examine_app14+0xd0>
      GETJOCTET(data[0]) == 0x41 &&
 801c130:	68bb      	ldr	r3, [r7, #8]
 801c132:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP14_DATA_LEN &&
 801c134:	2b41      	cmp	r3, #65	@ 0x41
 801c136:	d159      	bne.n	801c1ec <examine_app14+0xd0>
      GETJOCTET(data[1]) == 0x64 &&
 801c138:	68bb      	ldr	r3, [r7, #8]
 801c13a:	3301      	adds	r3, #1
 801c13c:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x41 &&
 801c13e:	2b64      	cmp	r3, #100	@ 0x64
 801c140:	d154      	bne.n	801c1ec <examine_app14+0xd0>
      GETJOCTET(data[2]) == 0x6F &&
 801c142:	68bb      	ldr	r3, [r7, #8]
 801c144:	3302      	adds	r3, #2
 801c146:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x64 &&
 801c148:	2b6f      	cmp	r3, #111	@ 0x6f
 801c14a:	d14f      	bne.n	801c1ec <examine_app14+0xd0>
      GETJOCTET(data[3]) == 0x62 &&
 801c14c:	68bb      	ldr	r3, [r7, #8]
 801c14e:	3303      	adds	r3, #3
 801c150:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x6F &&
 801c152:	2b62      	cmp	r3, #98	@ 0x62
 801c154:	d14a      	bne.n	801c1ec <examine_app14+0xd0>
      GETJOCTET(data[4]) == 0x65) {
 801c156:	68bb      	ldr	r3, [r7, #8]
 801c158:	3304      	adds	r3, #4
 801c15a:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x62 &&
 801c15c:	2b65      	cmp	r3, #101	@ 0x65
 801c15e:	d145      	bne.n	801c1ec <examine_app14+0xd0>
    /* Found Adobe APP14 marker */
    version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
 801c160:	68bb      	ldr	r3, [r7, #8]
 801c162:	3305      	adds	r3, #5
 801c164:	781b      	ldrb	r3, [r3, #0]
 801c166:	021b      	lsls	r3, r3, #8
 801c168:	68ba      	ldr	r2, [r7, #8]
 801c16a:	3206      	adds	r2, #6
 801c16c:	7812      	ldrb	r2, [r2, #0]
 801c16e:	4413      	add	r3, r2
 801c170:	627b      	str	r3, [r7, #36]	@ 0x24
    flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
 801c172:	68bb      	ldr	r3, [r7, #8]
 801c174:	3307      	adds	r3, #7
 801c176:	781b      	ldrb	r3, [r3, #0]
 801c178:	021b      	lsls	r3, r3, #8
 801c17a:	68ba      	ldr	r2, [r7, #8]
 801c17c:	3208      	adds	r2, #8
 801c17e:	7812      	ldrb	r2, [r2, #0]
 801c180:	4413      	add	r3, r2
 801c182:	623b      	str	r3, [r7, #32]
    flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
 801c184:	68bb      	ldr	r3, [r7, #8]
 801c186:	3309      	adds	r3, #9
 801c188:	781b      	ldrb	r3, [r3, #0]
 801c18a:	021b      	lsls	r3, r3, #8
 801c18c:	68ba      	ldr	r2, [r7, #8]
 801c18e:	320a      	adds	r2, #10
 801c190:	7812      	ldrb	r2, [r2, #0]
 801c192:	4413      	add	r3, r2
 801c194:	61fb      	str	r3, [r7, #28]
    transform = GETJOCTET(data[11]);
 801c196:	68bb      	ldr	r3, [r7, #8]
 801c198:	330b      	adds	r3, #11
 801c19a:	781b      	ldrb	r3, [r3, #0]
 801c19c:	61bb      	str	r3, [r7, #24]
    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
 801c19e:	68fb      	ldr	r3, [r7, #12]
 801c1a0:	681b      	ldr	r3, [r3, #0]
 801c1a2:	3318      	adds	r3, #24
 801c1a4:	617b      	str	r3, [r7, #20]
 801c1a6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c1a8:	697b      	ldr	r3, [r7, #20]
 801c1aa:	601a      	str	r2, [r3, #0]
 801c1ac:	697b      	ldr	r3, [r7, #20]
 801c1ae:	3304      	adds	r3, #4
 801c1b0:	6a3a      	ldr	r2, [r7, #32]
 801c1b2:	601a      	str	r2, [r3, #0]
 801c1b4:	697b      	ldr	r3, [r7, #20]
 801c1b6:	3308      	adds	r3, #8
 801c1b8:	69fa      	ldr	r2, [r7, #28]
 801c1ba:	601a      	str	r2, [r3, #0]
 801c1bc:	697b      	ldr	r3, [r7, #20]
 801c1be:	330c      	adds	r3, #12
 801c1c0:	69ba      	ldr	r2, [r7, #24]
 801c1c2:	601a      	str	r2, [r3, #0]
 801c1c4:	68fb      	ldr	r3, [r7, #12]
 801c1c6:	681b      	ldr	r3, [r3, #0]
 801c1c8:	224e      	movs	r2, #78	@ 0x4e
 801c1ca:	615a      	str	r2, [r3, #20]
 801c1cc:	68fb      	ldr	r3, [r7, #12]
 801c1ce:	681b      	ldr	r3, [r3, #0]
 801c1d0:	685b      	ldr	r3, [r3, #4]
 801c1d2:	2101      	movs	r1, #1
 801c1d4:	68f8      	ldr	r0, [r7, #12]
 801c1d6:	4798      	blx	r3
    cinfo->saw_Adobe_marker = TRUE;
 801c1d8:	68fb      	ldr	r3, [r7, #12]
 801c1da:	2201      	movs	r2, #1
 801c1dc:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
    cinfo->Adobe_transform = (UINT8) transform;
 801c1e0:	69bb      	ldr	r3, [r7, #24]
 801c1e2:	b2da      	uxtb	r2, r3
 801c1e4:	68fb      	ldr	r3, [r7, #12]
 801c1e6:	f883 212c 	strb.w	r2, [r3, #300]	@ 0x12c
 801c1ea:	e010      	b.n	801c20e <examine_app14+0xf2>
  } else {
    /* Start of APP14 does not match "Adobe", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));
 801c1ec:	68fb      	ldr	r3, [r7, #12]
 801c1ee:	681b      	ldr	r3, [r3, #0]
 801c1f0:	2250      	movs	r2, #80	@ 0x50
 801c1f2:	615a      	str	r2, [r3, #20]
 801c1f4:	683a      	ldr	r2, [r7, #0]
 801c1f6:	687b      	ldr	r3, [r7, #4]
 801c1f8:	441a      	add	r2, r3
 801c1fa:	68fb      	ldr	r3, [r7, #12]
 801c1fc:	681b      	ldr	r3, [r3, #0]
 801c1fe:	619a      	str	r2, [r3, #24]
 801c200:	68fb      	ldr	r3, [r7, #12]
 801c202:	681b      	ldr	r3, [r3, #0]
 801c204:	685b      	ldr	r3, [r3, #4]
 801c206:	2101      	movs	r1, #1
 801c208:	68f8      	ldr	r0, [r7, #12]
 801c20a:	4798      	blx	r3
  }
}
 801c20c:	bf00      	nop
 801c20e:	bf00      	nop
 801c210:	3728      	adds	r7, #40	@ 0x28
 801c212:	46bd      	mov	sp, r7
 801c214:	bd80      	pop	{r7, pc}

0801c216 <get_interesting_appn>:


METHODDEF(boolean)
get_interesting_appn (j_decompress_ptr cinfo)
/* Process an APP0 or APP14 marker without saving it */
{
 801c216:	b580      	push	{r7, lr}
 801c218:	b08c      	sub	sp, #48	@ 0x30
 801c21a:	af00      	add	r7, sp, #0
 801c21c:	6078      	str	r0, [r7, #4]
  INT32 length;
  JOCTET b[APPN_DATA_LEN];
  unsigned int i, numtoread;
  INPUT_VARS(cinfo);
 801c21e:	687b      	ldr	r3, [r7, #4]
 801c220:	699b      	ldr	r3, [r3, #24]
 801c222:	61fb      	str	r3, [r7, #28]
 801c224:	69fb      	ldr	r3, [r7, #28]
 801c226:	681b      	ldr	r3, [r3, #0]
 801c228:	627b      	str	r3, [r7, #36]	@ 0x24
 801c22a:	69fb      	ldr	r3, [r7, #28]
 801c22c:	685b      	ldr	r3, [r3, #4]
 801c22e:	623b      	str	r3, [r7, #32]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801c230:	6a3b      	ldr	r3, [r7, #32]
 801c232:	2b00      	cmp	r3, #0
 801c234:	d10e      	bne.n	801c254 <get_interesting_appn+0x3e>
 801c236:	69fb      	ldr	r3, [r7, #28]
 801c238:	68db      	ldr	r3, [r3, #12]
 801c23a:	6878      	ldr	r0, [r7, #4]
 801c23c:	4798      	blx	r3
 801c23e:	4603      	mov	r3, r0
 801c240:	2b00      	cmp	r3, #0
 801c242:	d101      	bne.n	801c248 <get_interesting_appn+0x32>
 801c244:	2300      	movs	r3, #0
 801c246:	e0a1      	b.n	801c38c <get_interesting_appn+0x176>
 801c248:	69fb      	ldr	r3, [r7, #28]
 801c24a:	681b      	ldr	r3, [r3, #0]
 801c24c:	627b      	str	r3, [r7, #36]	@ 0x24
 801c24e:	69fb      	ldr	r3, [r7, #28]
 801c250:	685b      	ldr	r3, [r3, #4]
 801c252:	623b      	str	r3, [r7, #32]
 801c254:	6a3b      	ldr	r3, [r7, #32]
 801c256:	3b01      	subs	r3, #1
 801c258:	623b      	str	r3, [r7, #32]
 801c25a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c25c:	1c5a      	adds	r2, r3, #1
 801c25e:	627a      	str	r2, [r7, #36]	@ 0x24
 801c260:	781b      	ldrb	r3, [r3, #0]
 801c262:	021b      	lsls	r3, r3, #8
 801c264:	61bb      	str	r3, [r7, #24]
 801c266:	6a3b      	ldr	r3, [r7, #32]
 801c268:	2b00      	cmp	r3, #0
 801c26a:	d10e      	bne.n	801c28a <get_interesting_appn+0x74>
 801c26c:	69fb      	ldr	r3, [r7, #28]
 801c26e:	68db      	ldr	r3, [r3, #12]
 801c270:	6878      	ldr	r0, [r7, #4]
 801c272:	4798      	blx	r3
 801c274:	4603      	mov	r3, r0
 801c276:	2b00      	cmp	r3, #0
 801c278:	d101      	bne.n	801c27e <get_interesting_appn+0x68>
 801c27a:	2300      	movs	r3, #0
 801c27c:	e086      	b.n	801c38c <get_interesting_appn+0x176>
 801c27e:	69fb      	ldr	r3, [r7, #28]
 801c280:	681b      	ldr	r3, [r3, #0]
 801c282:	627b      	str	r3, [r7, #36]	@ 0x24
 801c284:	69fb      	ldr	r3, [r7, #28]
 801c286:	685b      	ldr	r3, [r3, #4]
 801c288:	623b      	str	r3, [r7, #32]
 801c28a:	6a3b      	ldr	r3, [r7, #32]
 801c28c:	3b01      	subs	r3, #1
 801c28e:	623b      	str	r3, [r7, #32]
 801c290:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c292:	1c5a      	adds	r2, r3, #1
 801c294:	627a      	str	r2, [r7, #36]	@ 0x24
 801c296:	781b      	ldrb	r3, [r3, #0]
 801c298:	461a      	mov	r2, r3
 801c29a:	69bb      	ldr	r3, [r7, #24]
 801c29c:	4413      	add	r3, r2
 801c29e:	61bb      	str	r3, [r7, #24]
  length -= 2;
 801c2a0:	69bb      	ldr	r3, [r7, #24]
 801c2a2:	3b02      	subs	r3, #2
 801c2a4:	61bb      	str	r3, [r7, #24]

  /* get the interesting part of the marker data */
  if (length >= APPN_DATA_LEN)
 801c2a6:	69bb      	ldr	r3, [r7, #24]
 801c2a8:	2b0d      	cmp	r3, #13
 801c2aa:	dd02      	ble.n	801c2b2 <get_interesting_appn+0x9c>
    numtoread = APPN_DATA_LEN;
 801c2ac:	230e      	movs	r3, #14
 801c2ae:	62bb      	str	r3, [r7, #40]	@ 0x28
 801c2b0:	e007      	b.n	801c2c2 <get_interesting_appn+0xac>
  else if (length > 0)
 801c2b2:	69bb      	ldr	r3, [r7, #24]
 801c2b4:	2b00      	cmp	r3, #0
 801c2b6:	dd02      	ble.n	801c2be <get_interesting_appn+0xa8>
    numtoread = (unsigned int) length;
 801c2b8:	69bb      	ldr	r3, [r7, #24]
 801c2ba:	62bb      	str	r3, [r7, #40]	@ 0x28
 801c2bc:	e001      	b.n	801c2c2 <get_interesting_appn+0xac>
  else
    numtoread = 0;
 801c2be:	2300      	movs	r3, #0
 801c2c0:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = 0; i < numtoread; i++)
 801c2c2:	2300      	movs	r3, #0
 801c2c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c2c6:	e021      	b.n	801c30c <get_interesting_appn+0xf6>
    INPUT_BYTE(cinfo, b[i], return FALSE);
 801c2c8:	6a3b      	ldr	r3, [r7, #32]
 801c2ca:	2b00      	cmp	r3, #0
 801c2cc:	d10e      	bne.n	801c2ec <get_interesting_appn+0xd6>
 801c2ce:	69fb      	ldr	r3, [r7, #28]
 801c2d0:	68db      	ldr	r3, [r3, #12]
 801c2d2:	6878      	ldr	r0, [r7, #4]
 801c2d4:	4798      	blx	r3
 801c2d6:	4603      	mov	r3, r0
 801c2d8:	2b00      	cmp	r3, #0
 801c2da:	d101      	bne.n	801c2e0 <get_interesting_appn+0xca>
 801c2dc:	2300      	movs	r3, #0
 801c2de:	e055      	b.n	801c38c <get_interesting_appn+0x176>
 801c2e0:	69fb      	ldr	r3, [r7, #28]
 801c2e2:	681b      	ldr	r3, [r3, #0]
 801c2e4:	627b      	str	r3, [r7, #36]	@ 0x24
 801c2e6:	69fb      	ldr	r3, [r7, #28]
 801c2e8:	685b      	ldr	r3, [r3, #4]
 801c2ea:	623b      	str	r3, [r7, #32]
 801c2ec:	6a3b      	ldr	r3, [r7, #32]
 801c2ee:	3b01      	subs	r3, #1
 801c2f0:	623b      	str	r3, [r7, #32]
 801c2f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c2f4:	1c5a      	adds	r2, r3, #1
 801c2f6:	627a      	str	r2, [r7, #36]	@ 0x24
 801c2f8:	7819      	ldrb	r1, [r3, #0]
 801c2fa:	f107 0208 	add.w	r2, r7, #8
 801c2fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c300:	4413      	add	r3, r2
 801c302:	460a      	mov	r2, r1
 801c304:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numtoread; i++)
 801c306:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c308:	3301      	adds	r3, #1
 801c30a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c30c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801c30e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c310:	429a      	cmp	r2, r3
 801c312:	d3d9      	bcc.n	801c2c8 <get_interesting_appn+0xb2>
  length -= numtoread;
 801c314:	69ba      	ldr	r2, [r7, #24]
 801c316:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c318:	1ad3      	subs	r3, r2, r3
 801c31a:	61bb      	str	r3, [r7, #24]

  /* process it */
  switch (cinfo->unread_marker) {
 801c31c:	687b      	ldr	r3, [r7, #4]
 801c31e:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801c322:	2be0      	cmp	r3, #224	@ 0xe0
 801c324:	d002      	beq.n	801c32c <get_interesting_appn+0x116>
 801c326:	2bee      	cmp	r3, #238	@ 0xee
 801c328:	d008      	beq.n	801c33c <get_interesting_appn+0x126>
 801c32a:	e00f      	b.n	801c34c <get_interesting_appn+0x136>
  case M_APP0:
    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
 801c32c:	f107 0108 	add.w	r1, r7, #8
 801c330:	69bb      	ldr	r3, [r7, #24]
 801c332:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801c334:	6878      	ldr	r0, [r7, #4]
 801c336:	f7ff fd91 	bl	801be5c <examine_app0>
    break;
 801c33a:	e017      	b.n	801c36c <get_interesting_appn+0x156>
  case M_APP14:
    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
 801c33c:	f107 0108 	add.w	r1, r7, #8
 801c340:	69bb      	ldr	r3, [r7, #24]
 801c342:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801c344:	6878      	ldr	r0, [r7, #4]
 801c346:	f7ff fee9 	bl	801c11c <examine_app14>
    break;
 801c34a:	e00f      	b.n	801c36c <get_interesting_appn+0x156>
  default:
    /* can't get here unless jpeg_save_markers chooses wrong processor */
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 801c34c:	687b      	ldr	r3, [r7, #4]
 801c34e:	681b      	ldr	r3, [r3, #0]
 801c350:	2246      	movs	r2, #70	@ 0x46
 801c352:	615a      	str	r2, [r3, #20]
 801c354:	687b      	ldr	r3, [r7, #4]
 801c356:	681b      	ldr	r3, [r3, #0]
 801c358:	687a      	ldr	r2, [r7, #4]
 801c35a:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c35e:	619a      	str	r2, [r3, #24]
 801c360:	687b      	ldr	r3, [r7, #4]
 801c362:	681b      	ldr	r3, [r3, #0]
 801c364:	681b      	ldr	r3, [r3, #0]
 801c366:	6878      	ldr	r0, [r7, #4]
 801c368:	4798      	blx	r3
    break;
 801c36a:	bf00      	nop
  }

  /* skip any remaining data -- could be lots */
  INPUT_SYNC(cinfo);
 801c36c:	69fb      	ldr	r3, [r7, #28]
 801c36e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c370:	601a      	str	r2, [r3, #0]
 801c372:	69fb      	ldr	r3, [r7, #28]
 801c374:	6a3a      	ldr	r2, [r7, #32]
 801c376:	605a      	str	r2, [r3, #4]
  if (length > 0)
 801c378:	69bb      	ldr	r3, [r7, #24]
 801c37a:	2b00      	cmp	r3, #0
 801c37c:	dd05      	ble.n	801c38a <get_interesting_appn+0x174>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 801c37e:	687b      	ldr	r3, [r7, #4]
 801c380:	699b      	ldr	r3, [r3, #24]
 801c382:	691b      	ldr	r3, [r3, #16]
 801c384:	69b9      	ldr	r1, [r7, #24]
 801c386:	6878      	ldr	r0, [r7, #4]
 801c388:	4798      	blx	r3

  return TRUE;
 801c38a:	2301      	movs	r3, #1
}
 801c38c:	4618      	mov	r0, r3
 801c38e:	3730      	adds	r7, #48	@ 0x30
 801c390:	46bd      	mov	sp, r7
 801c392:	bd80      	pop	{r7, pc}

0801c394 <skip_variable>:


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
 801c394:	b580      	push	{r7, lr}
 801c396:	b086      	sub	sp, #24
 801c398:	af00      	add	r7, sp, #0
 801c39a:	6078      	str	r0, [r7, #4]
  INT32 length;
  INPUT_VARS(cinfo);
 801c39c:	687b      	ldr	r3, [r7, #4]
 801c39e:	699b      	ldr	r3, [r3, #24]
 801c3a0:	60fb      	str	r3, [r7, #12]
 801c3a2:	68fb      	ldr	r3, [r7, #12]
 801c3a4:	681b      	ldr	r3, [r3, #0]
 801c3a6:	617b      	str	r3, [r7, #20]
 801c3a8:	68fb      	ldr	r3, [r7, #12]
 801c3aa:	685b      	ldr	r3, [r3, #4]
 801c3ac:	613b      	str	r3, [r7, #16]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801c3ae:	693b      	ldr	r3, [r7, #16]
 801c3b0:	2b00      	cmp	r3, #0
 801c3b2:	d10e      	bne.n	801c3d2 <skip_variable+0x3e>
 801c3b4:	68fb      	ldr	r3, [r7, #12]
 801c3b6:	68db      	ldr	r3, [r3, #12]
 801c3b8:	6878      	ldr	r0, [r7, #4]
 801c3ba:	4798      	blx	r3
 801c3bc:	4603      	mov	r3, r0
 801c3be:	2b00      	cmp	r3, #0
 801c3c0:	d101      	bne.n	801c3c6 <skip_variable+0x32>
 801c3c2:	2300      	movs	r3, #0
 801c3c4:	e052      	b.n	801c46c <skip_variable+0xd8>
 801c3c6:	68fb      	ldr	r3, [r7, #12]
 801c3c8:	681b      	ldr	r3, [r3, #0]
 801c3ca:	617b      	str	r3, [r7, #20]
 801c3cc:	68fb      	ldr	r3, [r7, #12]
 801c3ce:	685b      	ldr	r3, [r3, #4]
 801c3d0:	613b      	str	r3, [r7, #16]
 801c3d2:	693b      	ldr	r3, [r7, #16]
 801c3d4:	3b01      	subs	r3, #1
 801c3d6:	613b      	str	r3, [r7, #16]
 801c3d8:	697b      	ldr	r3, [r7, #20]
 801c3da:	1c5a      	adds	r2, r3, #1
 801c3dc:	617a      	str	r2, [r7, #20]
 801c3de:	781b      	ldrb	r3, [r3, #0]
 801c3e0:	021b      	lsls	r3, r3, #8
 801c3e2:	60bb      	str	r3, [r7, #8]
 801c3e4:	693b      	ldr	r3, [r7, #16]
 801c3e6:	2b00      	cmp	r3, #0
 801c3e8:	d10e      	bne.n	801c408 <skip_variable+0x74>
 801c3ea:	68fb      	ldr	r3, [r7, #12]
 801c3ec:	68db      	ldr	r3, [r3, #12]
 801c3ee:	6878      	ldr	r0, [r7, #4]
 801c3f0:	4798      	blx	r3
 801c3f2:	4603      	mov	r3, r0
 801c3f4:	2b00      	cmp	r3, #0
 801c3f6:	d101      	bne.n	801c3fc <skip_variable+0x68>
 801c3f8:	2300      	movs	r3, #0
 801c3fa:	e037      	b.n	801c46c <skip_variable+0xd8>
 801c3fc:	68fb      	ldr	r3, [r7, #12]
 801c3fe:	681b      	ldr	r3, [r3, #0]
 801c400:	617b      	str	r3, [r7, #20]
 801c402:	68fb      	ldr	r3, [r7, #12]
 801c404:	685b      	ldr	r3, [r3, #4]
 801c406:	613b      	str	r3, [r7, #16]
 801c408:	693b      	ldr	r3, [r7, #16]
 801c40a:	3b01      	subs	r3, #1
 801c40c:	613b      	str	r3, [r7, #16]
 801c40e:	697b      	ldr	r3, [r7, #20]
 801c410:	1c5a      	adds	r2, r3, #1
 801c412:	617a      	str	r2, [r7, #20]
 801c414:	781b      	ldrb	r3, [r3, #0]
 801c416:	461a      	mov	r2, r3
 801c418:	68bb      	ldr	r3, [r7, #8]
 801c41a:	4413      	add	r3, r2
 801c41c:	60bb      	str	r3, [r7, #8]
  length -= 2;
 801c41e:	68bb      	ldr	r3, [r7, #8]
 801c420:	3b02      	subs	r3, #2
 801c422:	60bb      	str	r3, [r7, #8]
  
  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
 801c424:	687b      	ldr	r3, [r7, #4]
 801c426:	681b      	ldr	r3, [r3, #0]
 801c428:	225d      	movs	r2, #93	@ 0x5d
 801c42a:	615a      	str	r2, [r3, #20]
 801c42c:	687b      	ldr	r3, [r7, #4]
 801c42e:	681b      	ldr	r3, [r3, #0]
 801c430:	687a      	ldr	r2, [r7, #4]
 801c432:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c436:	619a      	str	r2, [r3, #24]
 801c438:	687b      	ldr	r3, [r7, #4]
 801c43a:	681b      	ldr	r3, [r3, #0]
 801c43c:	68ba      	ldr	r2, [r7, #8]
 801c43e:	61da      	str	r2, [r3, #28]
 801c440:	687b      	ldr	r3, [r7, #4]
 801c442:	681b      	ldr	r3, [r3, #0]
 801c444:	685b      	ldr	r3, [r3, #4]
 801c446:	2101      	movs	r1, #1
 801c448:	6878      	ldr	r0, [r7, #4]
 801c44a:	4798      	blx	r3

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
 801c44c:	68fb      	ldr	r3, [r7, #12]
 801c44e:	697a      	ldr	r2, [r7, #20]
 801c450:	601a      	str	r2, [r3, #0]
 801c452:	68fb      	ldr	r3, [r7, #12]
 801c454:	693a      	ldr	r2, [r7, #16]
 801c456:	605a      	str	r2, [r3, #4]
  if (length > 0)
 801c458:	68bb      	ldr	r3, [r7, #8]
 801c45a:	2b00      	cmp	r3, #0
 801c45c:	dd05      	ble.n	801c46a <skip_variable+0xd6>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 801c45e:	687b      	ldr	r3, [r7, #4]
 801c460:	699b      	ldr	r3, [r3, #24]
 801c462:	691b      	ldr	r3, [r3, #16]
 801c464:	68b9      	ldr	r1, [r7, #8]
 801c466:	6878      	ldr	r0, [r7, #4]
 801c468:	4798      	blx	r3

  return TRUE;
 801c46a:	2301      	movs	r3, #1
}
 801c46c:	4618      	mov	r0, r3
 801c46e:	3718      	adds	r7, #24
 801c470:	46bd      	mov	sp, r7
 801c472:	bd80      	pop	{r7, pc}

0801c474 <next_marker>:
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
 801c474:	b580      	push	{r7, lr}
 801c476:	b086      	sub	sp, #24
 801c478:	af00      	add	r7, sp, #0
 801c47a:	6078      	str	r0, [r7, #4]
  int c;
  INPUT_VARS(cinfo);
 801c47c:	687b      	ldr	r3, [r7, #4]
 801c47e:	699b      	ldr	r3, [r3, #24]
 801c480:	60bb      	str	r3, [r7, #8]
 801c482:	68bb      	ldr	r3, [r7, #8]
 801c484:	681b      	ldr	r3, [r3, #0]
 801c486:	613b      	str	r3, [r7, #16]
 801c488:	68bb      	ldr	r3, [r7, #8]
 801c48a:	685b      	ldr	r3, [r3, #4]
 801c48c:	60fb      	str	r3, [r7, #12]

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
 801c48e:	68fb      	ldr	r3, [r7, #12]
 801c490:	2b00      	cmp	r3, #0
 801c492:	d10e      	bne.n	801c4b2 <next_marker+0x3e>
 801c494:	68bb      	ldr	r3, [r7, #8]
 801c496:	68db      	ldr	r3, [r3, #12]
 801c498:	6878      	ldr	r0, [r7, #4]
 801c49a:	4798      	blx	r3
 801c49c:	4603      	mov	r3, r0
 801c49e:	2b00      	cmp	r3, #0
 801c4a0:	d101      	bne.n	801c4a6 <next_marker+0x32>
 801c4a2:	2300      	movs	r3, #0
 801c4a4:	e094      	b.n	801c5d0 <next_marker+0x15c>
 801c4a6:	68bb      	ldr	r3, [r7, #8]
 801c4a8:	681b      	ldr	r3, [r3, #0]
 801c4aa:	613b      	str	r3, [r7, #16]
 801c4ac:	68bb      	ldr	r3, [r7, #8]
 801c4ae:	685b      	ldr	r3, [r3, #4]
 801c4b0:	60fb      	str	r3, [r7, #12]
 801c4b2:	68fb      	ldr	r3, [r7, #12]
 801c4b4:	3b01      	subs	r3, #1
 801c4b6:	60fb      	str	r3, [r7, #12]
 801c4b8:	693b      	ldr	r3, [r7, #16]
 801c4ba:	1c5a      	adds	r2, r3, #1
 801c4bc:	613a      	str	r2, [r7, #16]
 801c4be:	781b      	ldrb	r3, [r3, #0]
 801c4c0:	617b      	str	r3, [r7, #20]
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
 801c4c2:	e025      	b.n	801c510 <next_marker+0x9c>
      cinfo->marker->discarded_bytes++;
 801c4c4:	687b      	ldr	r3, [r7, #4]
 801c4c6:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c4ca:	699a      	ldr	r2, [r3, #24]
 801c4cc:	3201      	adds	r2, #1
 801c4ce:	619a      	str	r2, [r3, #24]
      INPUT_SYNC(cinfo);
 801c4d0:	68bb      	ldr	r3, [r7, #8]
 801c4d2:	693a      	ldr	r2, [r7, #16]
 801c4d4:	601a      	str	r2, [r3, #0]
 801c4d6:	68bb      	ldr	r3, [r7, #8]
 801c4d8:	68fa      	ldr	r2, [r7, #12]
 801c4da:	605a      	str	r2, [r3, #4]
      INPUT_BYTE(cinfo, c, return FALSE);
 801c4dc:	68fb      	ldr	r3, [r7, #12]
 801c4de:	2b00      	cmp	r3, #0
 801c4e0:	d10e      	bne.n	801c500 <next_marker+0x8c>
 801c4e2:	68bb      	ldr	r3, [r7, #8]
 801c4e4:	68db      	ldr	r3, [r3, #12]
 801c4e6:	6878      	ldr	r0, [r7, #4]
 801c4e8:	4798      	blx	r3
 801c4ea:	4603      	mov	r3, r0
 801c4ec:	2b00      	cmp	r3, #0
 801c4ee:	d101      	bne.n	801c4f4 <next_marker+0x80>
 801c4f0:	2300      	movs	r3, #0
 801c4f2:	e06d      	b.n	801c5d0 <next_marker+0x15c>
 801c4f4:	68bb      	ldr	r3, [r7, #8]
 801c4f6:	681b      	ldr	r3, [r3, #0]
 801c4f8:	613b      	str	r3, [r7, #16]
 801c4fa:	68bb      	ldr	r3, [r7, #8]
 801c4fc:	685b      	ldr	r3, [r3, #4]
 801c4fe:	60fb      	str	r3, [r7, #12]
 801c500:	68fb      	ldr	r3, [r7, #12]
 801c502:	3b01      	subs	r3, #1
 801c504:	60fb      	str	r3, [r7, #12]
 801c506:	693b      	ldr	r3, [r7, #16]
 801c508:	1c5a      	adds	r2, r3, #1
 801c50a:	613a      	str	r2, [r7, #16]
 801c50c:	781b      	ldrb	r3, [r3, #0]
 801c50e:	617b      	str	r3, [r7, #20]
    while (c != 0xFF) {
 801c510:	697b      	ldr	r3, [r7, #20]
 801c512:	2bff      	cmp	r3, #255	@ 0xff
 801c514:	d1d6      	bne.n	801c4c4 <next_marker+0x50>
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
 801c516:	68fb      	ldr	r3, [r7, #12]
 801c518:	2b00      	cmp	r3, #0
 801c51a:	d10e      	bne.n	801c53a <next_marker+0xc6>
 801c51c:	68bb      	ldr	r3, [r7, #8]
 801c51e:	68db      	ldr	r3, [r3, #12]
 801c520:	6878      	ldr	r0, [r7, #4]
 801c522:	4798      	blx	r3
 801c524:	4603      	mov	r3, r0
 801c526:	2b00      	cmp	r3, #0
 801c528:	d101      	bne.n	801c52e <next_marker+0xba>
 801c52a:	2300      	movs	r3, #0
 801c52c:	e050      	b.n	801c5d0 <next_marker+0x15c>
 801c52e:	68bb      	ldr	r3, [r7, #8]
 801c530:	681b      	ldr	r3, [r3, #0]
 801c532:	613b      	str	r3, [r7, #16]
 801c534:	68bb      	ldr	r3, [r7, #8]
 801c536:	685b      	ldr	r3, [r3, #4]
 801c538:	60fb      	str	r3, [r7, #12]
 801c53a:	68fb      	ldr	r3, [r7, #12]
 801c53c:	3b01      	subs	r3, #1
 801c53e:	60fb      	str	r3, [r7, #12]
 801c540:	693b      	ldr	r3, [r7, #16]
 801c542:	1c5a      	adds	r2, r3, #1
 801c544:	613a      	str	r2, [r7, #16]
 801c546:	781b      	ldrb	r3, [r3, #0]
 801c548:	617b      	str	r3, [r7, #20]
    } while (c == 0xFF);
 801c54a:	697b      	ldr	r3, [r7, #20]
 801c54c:	2bff      	cmp	r3, #255	@ 0xff
 801c54e:	d0e2      	beq.n	801c516 <next_marker+0xa2>
    if (c != 0)
 801c550:	697b      	ldr	r3, [r7, #20]
 801c552:	2b00      	cmp	r3, #0
 801c554:	d10f      	bne.n	801c576 <next_marker+0x102>
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
 801c556:	687b      	ldr	r3, [r7, #4]
 801c558:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c55c:	699a      	ldr	r2, [r3, #24]
 801c55e:	687b      	ldr	r3, [r7, #4]
 801c560:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c564:	3202      	adds	r2, #2
 801c566:	619a      	str	r2, [r3, #24]
    INPUT_SYNC(cinfo);
 801c568:	68bb      	ldr	r3, [r7, #8]
 801c56a:	693a      	ldr	r2, [r7, #16]
 801c56c:	601a      	str	r2, [r3, #0]
 801c56e:	68bb      	ldr	r3, [r7, #8]
 801c570:	68fa      	ldr	r2, [r7, #12]
 801c572:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, c, return FALSE);
 801c574:	e78b      	b.n	801c48e <next_marker+0x1a>
      break;			/* found a valid marker, exit loop */
 801c576:	bf00      	nop
  }

  if (cinfo->marker->discarded_bytes != 0) {
 801c578:	687b      	ldr	r3, [r7, #4]
 801c57a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c57e:	699b      	ldr	r3, [r3, #24]
 801c580:	2b00      	cmp	r3, #0
 801c582:	d01a      	beq.n	801c5ba <next_marker+0x146>
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
 801c584:	687b      	ldr	r3, [r7, #4]
 801c586:	681b      	ldr	r3, [r3, #0]
 801c588:	2277      	movs	r2, #119	@ 0x77
 801c58a:	615a      	str	r2, [r3, #20]
 801c58c:	687b      	ldr	r3, [r7, #4]
 801c58e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c592:	699a      	ldr	r2, [r3, #24]
 801c594:	687b      	ldr	r3, [r7, #4]
 801c596:	681b      	ldr	r3, [r3, #0]
 801c598:	619a      	str	r2, [r3, #24]
 801c59a:	687b      	ldr	r3, [r7, #4]
 801c59c:	681b      	ldr	r3, [r3, #0]
 801c59e:	697a      	ldr	r2, [r7, #20]
 801c5a0:	61da      	str	r2, [r3, #28]
 801c5a2:	687b      	ldr	r3, [r7, #4]
 801c5a4:	681b      	ldr	r3, [r3, #0]
 801c5a6:	685b      	ldr	r3, [r3, #4]
 801c5a8:	f04f 31ff 	mov.w	r1, #4294967295
 801c5ac:	6878      	ldr	r0, [r7, #4]
 801c5ae:	4798      	blx	r3
    cinfo->marker->discarded_bytes = 0;
 801c5b0:	687b      	ldr	r3, [r7, #4]
 801c5b2:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c5b6:	2200      	movs	r2, #0
 801c5b8:	619a      	str	r2, [r3, #24]
  }

  cinfo->unread_marker = c;
 801c5ba:	687b      	ldr	r3, [r7, #4]
 801c5bc:	697a      	ldr	r2, [r7, #20]
 801c5be:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4

  INPUT_SYNC(cinfo);
 801c5c2:	68bb      	ldr	r3, [r7, #8]
 801c5c4:	693a      	ldr	r2, [r7, #16]
 801c5c6:	601a      	str	r2, [r3, #0]
 801c5c8:	68bb      	ldr	r3, [r7, #8]
 801c5ca:	68fa      	ldr	r2, [r7, #12]
 801c5cc:	605a      	str	r2, [r3, #4]
  return TRUE;
 801c5ce:	2301      	movs	r3, #1
}
 801c5d0:	4618      	mov	r0, r3
 801c5d2:	3718      	adds	r7, #24
 801c5d4:	46bd      	mov	sp, r7
 801c5d6:	bd80      	pop	{r7, pc}

0801c5d8 <first_marker>:
/* For this marker, we do not allow preceding garbage or fill; otherwise,
 * we might well scan an entire input file before realizing it ain't JPEG.
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
 801c5d8:	b580      	push	{r7, lr}
 801c5da:	b088      	sub	sp, #32
 801c5dc:	af00      	add	r7, sp, #0
 801c5de:	6078      	str	r0, [r7, #4]
  int c, c2;
  INPUT_VARS(cinfo);
 801c5e0:	687b      	ldr	r3, [r7, #4]
 801c5e2:	699b      	ldr	r3, [r3, #24]
 801c5e4:	617b      	str	r3, [r7, #20]
 801c5e6:	697b      	ldr	r3, [r7, #20]
 801c5e8:	681b      	ldr	r3, [r3, #0]
 801c5ea:	61fb      	str	r3, [r7, #28]
 801c5ec:	697b      	ldr	r3, [r7, #20]
 801c5ee:	685b      	ldr	r3, [r3, #4]
 801c5f0:	61bb      	str	r3, [r7, #24]

  INPUT_BYTE(cinfo, c, return FALSE);
 801c5f2:	69bb      	ldr	r3, [r7, #24]
 801c5f4:	2b00      	cmp	r3, #0
 801c5f6:	d10e      	bne.n	801c616 <first_marker+0x3e>
 801c5f8:	697b      	ldr	r3, [r7, #20]
 801c5fa:	68db      	ldr	r3, [r3, #12]
 801c5fc:	6878      	ldr	r0, [r7, #4]
 801c5fe:	4798      	blx	r3
 801c600:	4603      	mov	r3, r0
 801c602:	2b00      	cmp	r3, #0
 801c604:	d101      	bne.n	801c60a <first_marker+0x32>
 801c606:	2300      	movs	r3, #0
 801c608:	e049      	b.n	801c69e <first_marker+0xc6>
 801c60a:	697b      	ldr	r3, [r7, #20]
 801c60c:	681b      	ldr	r3, [r3, #0]
 801c60e:	61fb      	str	r3, [r7, #28]
 801c610:	697b      	ldr	r3, [r7, #20]
 801c612:	685b      	ldr	r3, [r3, #4]
 801c614:	61bb      	str	r3, [r7, #24]
 801c616:	69bb      	ldr	r3, [r7, #24]
 801c618:	3b01      	subs	r3, #1
 801c61a:	61bb      	str	r3, [r7, #24]
 801c61c:	69fb      	ldr	r3, [r7, #28]
 801c61e:	1c5a      	adds	r2, r3, #1
 801c620:	61fa      	str	r2, [r7, #28]
 801c622:	781b      	ldrb	r3, [r3, #0]
 801c624:	613b      	str	r3, [r7, #16]
  INPUT_BYTE(cinfo, c2, return FALSE);
 801c626:	69bb      	ldr	r3, [r7, #24]
 801c628:	2b00      	cmp	r3, #0
 801c62a:	d10e      	bne.n	801c64a <first_marker+0x72>
 801c62c:	697b      	ldr	r3, [r7, #20]
 801c62e:	68db      	ldr	r3, [r3, #12]
 801c630:	6878      	ldr	r0, [r7, #4]
 801c632:	4798      	blx	r3
 801c634:	4603      	mov	r3, r0
 801c636:	2b00      	cmp	r3, #0
 801c638:	d101      	bne.n	801c63e <first_marker+0x66>
 801c63a:	2300      	movs	r3, #0
 801c63c:	e02f      	b.n	801c69e <first_marker+0xc6>
 801c63e:	697b      	ldr	r3, [r7, #20]
 801c640:	681b      	ldr	r3, [r3, #0]
 801c642:	61fb      	str	r3, [r7, #28]
 801c644:	697b      	ldr	r3, [r7, #20]
 801c646:	685b      	ldr	r3, [r3, #4]
 801c648:	61bb      	str	r3, [r7, #24]
 801c64a:	69bb      	ldr	r3, [r7, #24]
 801c64c:	3b01      	subs	r3, #1
 801c64e:	61bb      	str	r3, [r7, #24]
 801c650:	69fb      	ldr	r3, [r7, #28]
 801c652:	1c5a      	adds	r2, r3, #1
 801c654:	61fa      	str	r2, [r7, #28]
 801c656:	781b      	ldrb	r3, [r3, #0]
 801c658:	60fb      	str	r3, [r7, #12]
  if (c != 0xFF || c2 != (int) M_SOI)
 801c65a:	693b      	ldr	r3, [r7, #16]
 801c65c:	2bff      	cmp	r3, #255	@ 0xff
 801c65e:	d102      	bne.n	801c666 <first_marker+0x8e>
 801c660:	68fb      	ldr	r3, [r7, #12]
 801c662:	2bd8      	cmp	r3, #216	@ 0xd8
 801c664:	d010      	beq.n	801c688 <first_marker+0xb0>
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);
 801c666:	687b      	ldr	r3, [r7, #4]
 801c668:	681b      	ldr	r3, [r3, #0]
 801c66a:	2237      	movs	r2, #55	@ 0x37
 801c66c:	615a      	str	r2, [r3, #20]
 801c66e:	687b      	ldr	r3, [r7, #4]
 801c670:	681b      	ldr	r3, [r3, #0]
 801c672:	693a      	ldr	r2, [r7, #16]
 801c674:	619a      	str	r2, [r3, #24]
 801c676:	687b      	ldr	r3, [r7, #4]
 801c678:	681b      	ldr	r3, [r3, #0]
 801c67a:	68fa      	ldr	r2, [r7, #12]
 801c67c:	61da      	str	r2, [r3, #28]
 801c67e:	687b      	ldr	r3, [r7, #4]
 801c680:	681b      	ldr	r3, [r3, #0]
 801c682:	681b      	ldr	r3, [r3, #0]
 801c684:	6878      	ldr	r0, [r7, #4]
 801c686:	4798      	blx	r3

  cinfo->unread_marker = c2;
 801c688:	687b      	ldr	r3, [r7, #4]
 801c68a:	68fa      	ldr	r2, [r7, #12]
 801c68c:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4

  INPUT_SYNC(cinfo);
 801c690:	697b      	ldr	r3, [r7, #20]
 801c692:	69fa      	ldr	r2, [r7, #28]
 801c694:	601a      	str	r2, [r3, #0]
 801c696:	697b      	ldr	r3, [r7, #20]
 801c698:	69ba      	ldr	r2, [r7, #24]
 801c69a:	605a      	str	r2, [r3, #4]
  return TRUE;
 801c69c:	2301      	movs	r3, #1
}
 801c69e:	4618      	mov	r0, r3
 801c6a0:	3720      	adds	r7, #32
 801c6a2:	46bd      	mov	sp, r7
 801c6a4:	bd80      	pop	{r7, pc}
	...

0801c6a8 <read_markers>:
 * after processing for the caller.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
 801c6a8:	b580      	push	{r7, lr}
 801c6aa:	b082      	sub	sp, #8
 801c6ac:	af00      	add	r7, sp, #0
 801c6ae:	6078      	str	r0, [r7, #4]
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
 801c6b0:	687b      	ldr	r3, [r7, #4]
 801c6b2:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801c6b6:	2b00      	cmp	r3, #0
 801c6b8:	d115      	bne.n	801c6e6 <read_markers+0x3e>
      if (! cinfo->marker->saw_SOI) {
 801c6ba:	687b      	ldr	r3, [r7, #4]
 801c6bc:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c6c0:	68db      	ldr	r3, [r3, #12]
 801c6c2:	2b00      	cmp	r3, #0
 801c6c4:	d107      	bne.n	801c6d6 <read_markers+0x2e>
	if (! first_marker(cinfo))
 801c6c6:	6878      	ldr	r0, [r7, #4]
 801c6c8:	f7ff ff86 	bl	801c5d8 <first_marker>
 801c6cc:	4603      	mov	r3, r0
 801c6ce:	2b00      	cmp	r3, #0
 801c6d0:	d109      	bne.n	801c6e6 <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801c6d2:	2300      	movs	r3, #0
 801c6d4:	e192      	b.n	801c9fc <read_markers+0x354>
      } else {
	if (! next_marker(cinfo))
 801c6d6:	6878      	ldr	r0, [r7, #4]
 801c6d8:	f7ff fecc 	bl	801c474 <next_marker>
 801c6dc:	4603      	mov	r3, r0
 801c6de:	2b00      	cmp	r3, #0
 801c6e0:	d101      	bne.n	801c6e6 <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801c6e2:	2300      	movs	r3, #0
 801c6e4:	e18a      	b.n	801c9fc <read_markers+0x354>
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
 801c6e6:	687b      	ldr	r3, [r7, #4]
 801c6e8:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801c6ec:	2b01      	cmp	r3, #1
 801c6ee:	f000 813e 	beq.w	801c96e <read_markers+0x2c6>
 801c6f2:	2b00      	cmp	r3, #0
 801c6f4:	f340 8154 	ble.w	801c9a0 <read_markers+0x2f8>
 801c6f8:	2bfe      	cmp	r3, #254	@ 0xfe
 801c6fa:	f300 8151 	bgt.w	801c9a0 <read_markers+0x2f8>
 801c6fe:	2bc0      	cmp	r3, #192	@ 0xc0
 801c700:	f2c0 814e 	blt.w	801c9a0 <read_markers+0x2f8>
 801c704:	3bc0      	subs	r3, #192	@ 0xc0
 801c706:	2b3e      	cmp	r3, #62	@ 0x3e
 801c708:	f200 814a 	bhi.w	801c9a0 <read_markers+0x2f8>
 801c70c:	a201      	add	r2, pc, #4	@ (adr r2, 801c714 <read_markers+0x6c>)
 801c70e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c712:	bf00      	nop
 801c714:	0801c823 	.word	0x0801c823
 801c718:	0801c83b 	.word	0x0801c83b
 801c71c:	0801c853 	.word	0x0801c853
 801c720:	0801c89b 	.word	0x0801c89b
 801c724:	0801c907 	.word	0x0801c907
 801c728:	0801c89b 	.word	0x0801c89b
 801c72c:	0801c89b 	.word	0x0801c89b
 801c730:	0801c89b 	.word	0x0801c89b
 801c734:	0801c89b 	.word	0x0801c89b
 801c738:	0801c86b 	.word	0x0801c86b
 801c73c:	0801c883 	.word	0x0801c883
 801c740:	0801c89b 	.word	0x0801c89b
 801c744:	0801c8f7 	.word	0x0801c8f7
 801c748:	0801c89b 	.word	0x0801c89b
 801c74c:	0801c89b 	.word	0x0801c89b
 801c750:	0801c89b 	.word	0x0801c89b
 801c754:	0801c96f 	.word	0x0801c96f
 801c758:	0801c96f 	.word	0x0801c96f
 801c75c:	0801c96f 	.word	0x0801c96f
 801c760:	0801c96f 	.word	0x0801c96f
 801c764:	0801c96f 	.word	0x0801c96f
 801c768:	0801c96f 	.word	0x0801c96f
 801c76c:	0801c96f 	.word	0x0801c96f
 801c770:	0801c96f 	.word	0x0801c96f
 801c774:	0801c811 	.word	0x0801c811
 801c778:	0801c8d7 	.word	0x0801c8d7
 801c77c:	0801c8bb 	.word	0x0801c8bb
 801c780:	0801c917 	.word	0x0801c917
 801c784:	0801c991 	.word	0x0801c991
 801c788:	0801c927 	.word	0x0801c927
 801c78c:	0801c9a1 	.word	0x0801c9a1
 801c790:	0801c9a1 	.word	0x0801c9a1
 801c794:	0801c937 	.word	0x0801c937
 801c798:	0801c937 	.word	0x0801c937
 801c79c:	0801c937 	.word	0x0801c937
 801c7a0:	0801c937 	.word	0x0801c937
 801c7a4:	0801c937 	.word	0x0801c937
 801c7a8:	0801c937 	.word	0x0801c937
 801c7ac:	0801c937 	.word	0x0801c937
 801c7b0:	0801c937 	.word	0x0801c937
 801c7b4:	0801c937 	.word	0x0801c937
 801c7b8:	0801c937 	.word	0x0801c937
 801c7bc:	0801c937 	.word	0x0801c937
 801c7c0:	0801c937 	.word	0x0801c937
 801c7c4:	0801c937 	.word	0x0801c937
 801c7c8:	0801c937 	.word	0x0801c937
 801c7cc:	0801c937 	.word	0x0801c937
 801c7d0:	0801c937 	.word	0x0801c937
 801c7d4:	0801c9a1 	.word	0x0801c9a1
 801c7d8:	0801c9a1 	.word	0x0801c9a1
 801c7dc:	0801c9a1 	.word	0x0801c9a1
 801c7e0:	0801c9a1 	.word	0x0801c9a1
 801c7e4:	0801c9a1 	.word	0x0801c9a1
 801c7e8:	0801c9a1 	.word	0x0801c9a1
 801c7ec:	0801c9a1 	.word	0x0801c9a1
 801c7f0:	0801c9a1 	.word	0x0801c9a1
 801c7f4:	0801c9a1 	.word	0x0801c9a1
 801c7f8:	0801c9a1 	.word	0x0801c9a1
 801c7fc:	0801c9a1 	.word	0x0801c9a1
 801c800:	0801c9a1 	.word	0x0801c9a1
 801c804:	0801c9a1 	.word	0x0801c9a1
 801c808:	0801c9a1 	.word	0x0801c9a1
 801c80c:	0801c959 	.word	0x0801c959
    case M_SOI:
      if (! get_soi(cinfo))
 801c810:	6878      	ldr	r0, [r7, #4]
 801c812:	f7fe f82b 	bl	801a86c <get_soi>
 801c816:	4603      	mov	r3, r0
 801c818:	2b00      	cmp	r3, #0
 801c81a:	f040 80d1 	bne.w	801c9c0 <read_markers+0x318>
	return JPEG_SUSPENDED;
 801c81e:	2300      	movs	r3, #0
 801c820:	e0ec      	b.n	801c9fc <read_markers+0x354>
      break;

    case M_SOF0:		/* Baseline */
      if (! get_sof(cinfo, TRUE, FALSE, FALSE))
 801c822:	2300      	movs	r3, #0
 801c824:	2200      	movs	r2, #0
 801c826:	2101      	movs	r1, #1
 801c828:	6878      	ldr	r0, [r7, #4]
 801c82a:	f7fe f88e 	bl	801a94a <get_sof>
 801c82e:	4603      	mov	r3, r0
 801c830:	2b00      	cmp	r3, #0
 801c832:	f040 80c7 	bne.w	801c9c4 <read_markers+0x31c>
	return JPEG_SUSPENDED;
 801c836:	2300      	movs	r3, #0
 801c838:	e0e0      	b.n	801c9fc <read_markers+0x354>
      break;

    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE, FALSE))
 801c83a:	2300      	movs	r3, #0
 801c83c:	2200      	movs	r2, #0
 801c83e:	2100      	movs	r1, #0
 801c840:	6878      	ldr	r0, [r7, #4]
 801c842:	f7fe f882 	bl	801a94a <get_sof>
 801c846:	4603      	mov	r3, r0
 801c848:	2b00      	cmp	r3, #0
 801c84a:	f040 80bd 	bne.w	801c9c8 <read_markers+0x320>
	return JPEG_SUSPENDED;
 801c84e:	2300      	movs	r3, #0
 801c850:	e0d4      	b.n	801c9fc <read_markers+0x354>
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, FALSE, TRUE, FALSE))
 801c852:	2300      	movs	r3, #0
 801c854:	2201      	movs	r2, #1
 801c856:	2100      	movs	r1, #0
 801c858:	6878      	ldr	r0, [r7, #4]
 801c85a:	f7fe f876 	bl	801a94a <get_sof>
 801c85e:	4603      	mov	r3, r0
 801c860:	2b00      	cmp	r3, #0
 801c862:	f040 80b3 	bne.w	801c9cc <read_markers+0x324>
	return JPEG_SUSPENDED;
 801c866:	2300      	movs	r3, #0
 801c868:	e0c8      	b.n	801c9fc <read_markers+0x354>
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, FALSE, TRUE))
 801c86a:	2301      	movs	r3, #1
 801c86c:	2200      	movs	r2, #0
 801c86e:	2100      	movs	r1, #0
 801c870:	6878      	ldr	r0, [r7, #4]
 801c872:	f7fe f86a 	bl	801a94a <get_sof>
 801c876:	4603      	mov	r3, r0
 801c878:	2b00      	cmp	r3, #0
 801c87a:	f040 80a9 	bne.w	801c9d0 <read_markers+0x328>
	return JPEG_SUSPENDED;
 801c87e:	2300      	movs	r3, #0
 801c880:	e0bc      	b.n	801c9fc <read_markers+0x354>
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE, TRUE))
 801c882:	2301      	movs	r3, #1
 801c884:	2201      	movs	r2, #1
 801c886:	2100      	movs	r1, #0
 801c888:	6878      	ldr	r0, [r7, #4]
 801c88a:	f7fe f85e 	bl	801a94a <get_sof>
 801c88e:	4603      	mov	r3, r0
 801c890:	2b00      	cmp	r3, #0
 801c892:	f040 809f 	bne.w	801c9d4 <read_markers+0x32c>
	return JPEG_SUSPENDED;
 801c896:	2300      	movs	r3, #0
 801c898:	e0b0      	b.n	801c9fc <read_markers+0x354>
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
 801c89a:	687b      	ldr	r3, [r7, #4]
 801c89c:	681b      	ldr	r3, [r3, #0]
 801c89e:	223e      	movs	r2, #62	@ 0x3e
 801c8a0:	615a      	str	r2, [r3, #20]
 801c8a2:	687b      	ldr	r3, [r7, #4]
 801c8a4:	681b      	ldr	r3, [r3, #0]
 801c8a6:	687a      	ldr	r2, [r7, #4]
 801c8a8:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c8ac:	619a      	str	r2, [r3, #24]
 801c8ae:	687b      	ldr	r3, [r7, #4]
 801c8b0:	681b      	ldr	r3, [r3, #0]
 801c8b2:	681b      	ldr	r3, [r3, #0]
 801c8b4:	6878      	ldr	r0, [r7, #4]
 801c8b6:	4798      	blx	r3
      break;
 801c8b8:	e09b      	b.n	801c9f2 <read_markers+0x34a>

    case M_SOS:
      if (! get_sos(cinfo))
 801c8ba:	6878      	ldr	r0, [r7, #4]
 801c8bc:	f7fe fa59 	bl	801ad72 <get_sos>
 801c8c0:	4603      	mov	r3, r0
 801c8c2:	2b00      	cmp	r3, #0
 801c8c4:	d101      	bne.n	801c8ca <read_markers+0x222>
	return JPEG_SUSPENDED;
 801c8c6:	2300      	movs	r3, #0
 801c8c8:	e098      	b.n	801c9fc <read_markers+0x354>
      cinfo->unread_marker = 0;	/* processed the marker */
 801c8ca:	687b      	ldr	r3, [r7, #4]
 801c8cc:	2200      	movs	r2, #0
 801c8ce:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return JPEG_REACHED_SOS;
 801c8d2:	2301      	movs	r3, #1
 801c8d4:	e092      	b.n	801c9fc <read_markers+0x354>
    
    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
 801c8d6:	687b      	ldr	r3, [r7, #4]
 801c8d8:	681b      	ldr	r3, [r3, #0]
 801c8da:	2257      	movs	r2, #87	@ 0x57
 801c8dc:	615a      	str	r2, [r3, #20]
 801c8de:	687b      	ldr	r3, [r7, #4]
 801c8e0:	681b      	ldr	r3, [r3, #0]
 801c8e2:	685b      	ldr	r3, [r3, #4]
 801c8e4:	2101      	movs	r1, #1
 801c8e6:	6878      	ldr	r0, [r7, #4]
 801c8e8:	4798      	blx	r3
      cinfo->unread_marker = 0;	/* processed the marker */
 801c8ea:	687b      	ldr	r3, [r7, #4]
 801c8ec:	2200      	movs	r2, #0
 801c8ee:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return JPEG_REACHED_EOI;
 801c8f2:	2302      	movs	r3, #2
 801c8f4:	e082      	b.n	801c9fc <read_markers+0x354>
      
    case M_DAC:
      if (! get_dac(cinfo))
 801c8f6:	6878      	ldr	r0, [r7, #4]
 801c8f8:	f7fe fc09 	bl	801b10e <get_dac>
 801c8fc:	4603      	mov	r3, r0
 801c8fe:	2b00      	cmp	r3, #0
 801c900:	d16a      	bne.n	801c9d8 <read_markers+0x330>
	return JPEG_SUSPENDED;
 801c902:	2300      	movs	r3, #0
 801c904:	e07a      	b.n	801c9fc <read_markers+0x354>
      break;
      
    case M_DHT:
      if (! get_dht(cinfo))
 801c906:	6878      	ldr	r0, [r7, #4]
 801c908:	f7fe fcfb 	bl	801b302 <get_dht>
 801c90c:	4603      	mov	r3, r0
 801c90e:	2b00      	cmp	r3, #0
 801c910:	d164      	bne.n	801c9dc <read_markers+0x334>
	return JPEG_SUSPENDED;
 801c912:	2300      	movs	r3, #0
 801c914:	e072      	b.n	801c9fc <read_markers+0x354>
      break;
      
    case M_DQT:
      if (! get_dqt(cinfo))
 801c916:	6878      	ldr	r0, [r7, #4]
 801c918:	f7fe ffb0 	bl	801b87c <get_dqt>
 801c91c:	4603      	mov	r3, r0
 801c91e:	2b00      	cmp	r3, #0
 801c920:	d15e      	bne.n	801c9e0 <read_markers+0x338>
	return JPEG_SUSPENDED;
 801c922:	2300      	movs	r3, #0
 801c924:	e06a      	b.n	801c9fc <read_markers+0x354>
      break;
      
    case M_DRI:
      if (! get_dri(cinfo))
 801c926:	6878      	ldr	r0, [r7, #4]
 801c928:	f7ff f9f2 	bl	801bd10 <get_dri>
 801c92c:	4603      	mov	r3, r0
 801c92e:	2b00      	cmp	r3, #0
 801c930:	d158      	bne.n	801c9e4 <read_markers+0x33c>
	return JPEG_SUSPENDED;
 801c932:	2300      	movs	r3, #0
 801c934:	e062      	b.n	801c9fc <read_markers+0x354>
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 801c936:	687b      	ldr	r3, [r7, #4]
 801c938:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
		cinfo->unread_marker - (int) M_APP0]) (cinfo))
 801c93c:	687a      	ldr	r2, [r7, #4]
 801c93e:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c942:	3ae0      	subs	r2, #224	@ 0xe0
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 801c944:	3208      	adds	r2, #8
 801c946:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801c94a:	6878      	ldr	r0, [r7, #4]
 801c94c:	4798      	blx	r3
 801c94e:	4603      	mov	r3, r0
 801c950:	2b00      	cmp	r3, #0
 801c952:	d149      	bne.n	801c9e8 <read_markers+0x340>
	return JPEG_SUSPENDED;
 801c954:	2300      	movs	r3, #0
 801c956:	e051      	b.n	801c9fc <read_markers+0x354>
      break;
      
    case M_COM:
      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
 801c958:	687b      	ldr	r3, [r7, #4]
 801c95a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801c95e:	69db      	ldr	r3, [r3, #28]
 801c960:	6878      	ldr	r0, [r7, #4]
 801c962:	4798      	blx	r3
 801c964:	4603      	mov	r3, r0
 801c966:	2b00      	cmp	r3, #0
 801c968:	d140      	bne.n	801c9ec <read_markers+0x344>
	return JPEG_SUSPENDED;
 801c96a:	2300      	movs	r3, #0
 801c96c:	e046      	b.n	801c9fc <read_markers+0x354>
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
 801c96e:	687b      	ldr	r3, [r7, #4]
 801c970:	681b      	ldr	r3, [r3, #0]
 801c972:	225e      	movs	r2, #94	@ 0x5e
 801c974:	615a      	str	r2, [r3, #20]
 801c976:	687b      	ldr	r3, [r7, #4]
 801c978:	681b      	ldr	r3, [r3, #0]
 801c97a:	687a      	ldr	r2, [r7, #4]
 801c97c:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c980:	619a      	str	r2, [r3, #24]
 801c982:	687b      	ldr	r3, [r7, #4]
 801c984:	681b      	ldr	r3, [r3, #0]
 801c986:	685b      	ldr	r3, [r3, #4]
 801c988:	2101      	movs	r1, #1
 801c98a:	6878      	ldr	r0, [r7, #4]
 801c98c:	4798      	blx	r3
      break;
 801c98e:	e030      	b.n	801c9f2 <read_markers+0x34a>

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
 801c990:	6878      	ldr	r0, [r7, #4]
 801c992:	f7ff fcff 	bl	801c394 <skip_variable>
 801c996:	4603      	mov	r3, r0
 801c998:	2b00      	cmp	r3, #0
 801c99a:	d129      	bne.n	801c9f0 <read_markers+0x348>
	return JPEG_SUSPENDED;
 801c99c:	2300      	movs	r3, #0
 801c99e:	e02d      	b.n	801c9fc <read_markers+0x354>
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 801c9a0:	687b      	ldr	r3, [r7, #4]
 801c9a2:	681b      	ldr	r3, [r3, #0]
 801c9a4:	2246      	movs	r2, #70	@ 0x46
 801c9a6:	615a      	str	r2, [r3, #20]
 801c9a8:	687b      	ldr	r3, [r7, #4]
 801c9aa:	681b      	ldr	r3, [r3, #0]
 801c9ac:	687a      	ldr	r2, [r7, #4]
 801c9ae:	f8d2 21b4 	ldr.w	r2, [r2, #436]	@ 0x1b4
 801c9b2:	619a      	str	r2, [r3, #24]
 801c9b4:	687b      	ldr	r3, [r7, #4]
 801c9b6:	681b      	ldr	r3, [r3, #0]
 801c9b8:	681b      	ldr	r3, [r3, #0]
 801c9ba:	6878      	ldr	r0, [r7, #4]
 801c9bc:	4798      	blx	r3
      break;
 801c9be:	e018      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9c0:	bf00      	nop
 801c9c2:	e016      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9c4:	bf00      	nop
 801c9c6:	e014      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9c8:	bf00      	nop
 801c9ca:	e012      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9cc:	bf00      	nop
 801c9ce:	e010      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9d0:	bf00      	nop
 801c9d2:	e00e      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9d4:	bf00      	nop
 801c9d6:	e00c      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9d8:	bf00      	nop
 801c9da:	e00a      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9dc:	bf00      	nop
 801c9de:	e008      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9e0:	bf00      	nop
 801c9e2:	e006      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9e4:	bf00      	nop
 801c9e6:	e004      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9e8:	bf00      	nop
 801c9ea:	e002      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9ec:	bf00      	nop
 801c9ee:	e000      	b.n	801c9f2 <read_markers+0x34a>
      break;
 801c9f0:	bf00      	nop
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
 801c9f2:	687b      	ldr	r3, [r7, #4]
 801c9f4:	2200      	movs	r2, #0
 801c9f6:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
    if (cinfo->unread_marker == 0) {
 801c9fa:	e659      	b.n	801c6b0 <read_markers+0x8>
  } /* end loop */
}
 801c9fc:	4618      	mov	r0, r3
 801c9fe:	3708      	adds	r7, #8
 801ca00:	46bd      	mov	sp, r7
 801ca02:	bd80      	pop	{r7, pc}

0801ca04 <read_restart_marker>:
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
 801ca04:	b580      	push	{r7, lr}
 801ca06:	b082      	sub	sp, #8
 801ca08:	af00      	add	r7, sp, #0
 801ca0a:	6078      	str	r0, [r7, #4]
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
 801ca0c:	687b      	ldr	r3, [r7, #4]
 801ca0e:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801ca12:	2b00      	cmp	r3, #0
 801ca14:	d107      	bne.n	801ca26 <read_restart_marker+0x22>
    if (! next_marker(cinfo))
 801ca16:	6878      	ldr	r0, [r7, #4]
 801ca18:	f7ff fd2c 	bl	801c474 <next_marker>
 801ca1c:	4603      	mov	r3, r0
 801ca1e:	2b00      	cmp	r3, #0
 801ca20:	d101      	bne.n	801ca26 <read_restart_marker+0x22>
      return FALSE;
 801ca22:	2300      	movs	r3, #0
 801ca24:	e03a      	b.n	801ca9c <read_restart_marker+0x98>
  }

  if (cinfo->unread_marker ==
 801ca26:	687b      	ldr	r3, [r7, #4]
 801ca28:	f8d3 21b4 	ldr.w	r2, [r3, #436]	@ 0x1b4
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
 801ca2c:	687b      	ldr	r3, [r7, #4]
 801ca2e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ca32:	695b      	ldr	r3, [r3, #20]
 801ca34:	33d0      	adds	r3, #208	@ 0xd0
  if (cinfo->unread_marker ==
 801ca36:	429a      	cmp	r2, r3
 801ca38:	d115      	bne.n	801ca66 <read_restart_marker+0x62>
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
 801ca3a:	687b      	ldr	r3, [r7, #4]
 801ca3c:	681b      	ldr	r3, [r3, #0]
 801ca3e:	2264      	movs	r2, #100	@ 0x64
 801ca40:	615a      	str	r2, [r3, #20]
 801ca42:	687b      	ldr	r3, [r7, #4]
 801ca44:	f8d3 21cc 	ldr.w	r2, [r3, #460]	@ 0x1cc
 801ca48:	687b      	ldr	r3, [r7, #4]
 801ca4a:	681b      	ldr	r3, [r3, #0]
 801ca4c:	6952      	ldr	r2, [r2, #20]
 801ca4e:	619a      	str	r2, [r3, #24]
 801ca50:	687b      	ldr	r3, [r7, #4]
 801ca52:	681b      	ldr	r3, [r3, #0]
 801ca54:	685b      	ldr	r3, [r3, #4]
 801ca56:	2103      	movs	r1, #3
 801ca58:	6878      	ldr	r0, [r7, #4]
 801ca5a:	4798      	blx	r3
    cinfo->unread_marker = 0;
 801ca5c:	687b      	ldr	r3, [r7, #4]
 801ca5e:	2200      	movs	r2, #0
 801ca60:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
 801ca64:	e00e      	b.n	801ca84 <read_restart_marker+0x80>
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 801ca66:	687b      	ldr	r3, [r7, #4]
 801ca68:	699b      	ldr	r3, [r3, #24]
 801ca6a:	695b      	ldr	r3, [r3, #20]
					    cinfo->marker->next_restart_num))
 801ca6c:	687a      	ldr	r2, [r7, #4]
 801ca6e:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 801ca72:	6952      	ldr	r2, [r2, #20]
 801ca74:	4611      	mov	r1, r2
 801ca76:	6878      	ldr	r0, [r7, #4]
 801ca78:	4798      	blx	r3
 801ca7a:	4603      	mov	r3, r0
 801ca7c:	2b00      	cmp	r3, #0
 801ca7e:	d101      	bne.n	801ca84 <read_restart_marker+0x80>
      return FALSE;
 801ca80:	2300      	movs	r3, #0
 801ca82:	e00b      	b.n	801ca9c <read_restart_marker+0x98>
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
 801ca84:	687b      	ldr	r3, [r7, #4]
 801ca86:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ca8a:	695b      	ldr	r3, [r3, #20]
 801ca8c:	1c5a      	adds	r2, r3, #1
 801ca8e:	687b      	ldr	r3, [r7, #4]
 801ca90:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801ca94:	f002 0207 	and.w	r2, r2, #7
 801ca98:	615a      	str	r2, [r3, #20]

  return TRUE;
 801ca9a:	2301      	movs	r3, #1
}
 801ca9c:	4618      	mov	r0, r3
 801ca9e:	3708      	adds	r7, #8
 801caa0:	46bd      	mov	sp, r7
 801caa2:	bd80      	pop	{r7, pc}

0801caa4 <jpeg_resync_to_restart>:
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
 801caa4:	b580      	push	{r7, lr}
 801caa6:	b084      	sub	sp, #16
 801caa8:	af00      	add	r7, sp, #0
 801caaa:	6078      	str	r0, [r7, #4]
 801caac:	6039      	str	r1, [r7, #0]
  int marker = cinfo->unread_marker;
 801caae:	687b      	ldr	r3, [r7, #4]
 801cab0:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801cab4:	60fb      	str	r3, [r7, #12]
  int action = 1;
 801cab6:	2301      	movs	r3, #1
 801cab8:	60bb      	str	r3, [r7, #8]
  
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
 801caba:	687b      	ldr	r3, [r7, #4]
 801cabc:	681b      	ldr	r3, [r3, #0]
 801cabe:	227c      	movs	r2, #124	@ 0x7c
 801cac0:	615a      	str	r2, [r3, #20]
 801cac2:	687b      	ldr	r3, [r7, #4]
 801cac4:	681b      	ldr	r3, [r3, #0]
 801cac6:	68fa      	ldr	r2, [r7, #12]
 801cac8:	619a      	str	r2, [r3, #24]
 801caca:	687b      	ldr	r3, [r7, #4]
 801cacc:	681b      	ldr	r3, [r3, #0]
 801cace:	683a      	ldr	r2, [r7, #0]
 801cad0:	61da      	str	r2, [r3, #28]
 801cad2:	687b      	ldr	r3, [r7, #4]
 801cad4:	681b      	ldr	r3, [r3, #0]
 801cad6:	685b      	ldr	r3, [r3, #4]
 801cad8:	f04f 31ff 	mov.w	r1, #4294967295
 801cadc:	6878      	ldr	r0, [r7, #4]
 801cade:	4798      	blx	r3
  
  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
 801cae0:	68fb      	ldr	r3, [r7, #12]
 801cae2:	2bbf      	cmp	r3, #191	@ 0xbf
 801cae4:	dc02      	bgt.n	801caec <jpeg_resync_to_restart+0x48>
      action = 2;		/* invalid marker */
 801cae6:	2302      	movs	r3, #2
 801cae8:	60bb      	str	r3, [r7, #8]
 801caea:	e030      	b.n	801cb4e <jpeg_resync_to_restart+0xaa>
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
 801caec:	68fb      	ldr	r3, [r7, #12]
 801caee:	2bcf      	cmp	r3, #207	@ 0xcf
 801caf0:	dd02      	ble.n	801caf8 <jpeg_resync_to_restart+0x54>
 801caf2:	68fb      	ldr	r3, [r7, #12]
 801caf4:	2bd7      	cmp	r3, #215	@ 0xd7
 801caf6:	dd02      	ble.n	801cafe <jpeg_resync_to_restart+0x5a>
      action = 3;		/* valid non-restart marker */
 801caf8:	2303      	movs	r3, #3
 801cafa:	60bb      	str	r3, [r7, #8]
 801cafc:	e027      	b.n	801cb4e <jpeg_resync_to_restart+0xaa>
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 801cafe:	683b      	ldr	r3, [r7, #0]
 801cb00:	3301      	adds	r3, #1
 801cb02:	f003 0307 	and.w	r3, r3, #7
 801cb06:	33d0      	adds	r3, #208	@ 0xd0
 801cb08:	68fa      	ldr	r2, [r7, #12]
 801cb0a:	429a      	cmp	r2, r3
 801cb0c:	d007      	beq.n	801cb1e <jpeg_resync_to_restart+0x7a>
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
 801cb0e:	683b      	ldr	r3, [r7, #0]
 801cb10:	3302      	adds	r3, #2
 801cb12:	f003 0307 	and.w	r3, r3, #7
 801cb16:	33d0      	adds	r3, #208	@ 0xd0
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 801cb18:	68fa      	ldr	r2, [r7, #12]
 801cb1a:	429a      	cmp	r2, r3
 801cb1c:	d102      	bne.n	801cb24 <jpeg_resync_to_restart+0x80>
	action = 3;		/* one of the next two expected restarts */
 801cb1e:	2303      	movs	r3, #3
 801cb20:	60bb      	str	r3, [r7, #8]
 801cb22:	e014      	b.n	801cb4e <jpeg_resync_to_restart+0xaa>
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 801cb24:	683b      	ldr	r3, [r7, #0]
 801cb26:	3b01      	subs	r3, #1
 801cb28:	f003 0307 	and.w	r3, r3, #7
 801cb2c:	33d0      	adds	r3, #208	@ 0xd0
 801cb2e:	68fa      	ldr	r2, [r7, #12]
 801cb30:	429a      	cmp	r2, r3
 801cb32:	d007      	beq.n	801cb44 <jpeg_resync_to_restart+0xa0>
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
 801cb34:	683b      	ldr	r3, [r7, #0]
 801cb36:	3b02      	subs	r3, #2
 801cb38:	f003 0307 	and.w	r3, r3, #7
 801cb3c:	33d0      	adds	r3, #208	@ 0xd0
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 801cb3e:	68fa      	ldr	r2, [r7, #12]
 801cb40:	429a      	cmp	r2, r3
 801cb42:	d102      	bne.n	801cb4a <jpeg_resync_to_restart+0xa6>
	action = 2;		/* a prior restart, so advance */
 801cb44:	2302      	movs	r3, #2
 801cb46:	60bb      	str	r3, [r7, #8]
 801cb48:	e001      	b.n	801cb4e <jpeg_resync_to_restart+0xaa>
      else
	action = 1;		/* desired restart or too far away */
 801cb4a:	2301      	movs	r3, #1
 801cb4c:	60bb      	str	r3, [r7, #8]
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
 801cb4e:	687b      	ldr	r3, [r7, #4]
 801cb50:	681b      	ldr	r3, [r3, #0]
 801cb52:	2263      	movs	r2, #99	@ 0x63
 801cb54:	615a      	str	r2, [r3, #20]
 801cb56:	687b      	ldr	r3, [r7, #4]
 801cb58:	681b      	ldr	r3, [r3, #0]
 801cb5a:	68fa      	ldr	r2, [r7, #12]
 801cb5c:	619a      	str	r2, [r3, #24]
 801cb5e:	687b      	ldr	r3, [r7, #4]
 801cb60:	681b      	ldr	r3, [r3, #0]
 801cb62:	68ba      	ldr	r2, [r7, #8]
 801cb64:	61da      	str	r2, [r3, #28]
 801cb66:	687b      	ldr	r3, [r7, #4]
 801cb68:	681b      	ldr	r3, [r3, #0]
 801cb6a:	685b      	ldr	r3, [r3, #4]
 801cb6c:	2104      	movs	r1, #4
 801cb6e:	6878      	ldr	r0, [r7, #4]
 801cb70:	4798      	blx	r3
    switch (action) {
 801cb72:	68bb      	ldr	r3, [r7, #8]
 801cb74:	2b03      	cmp	r3, #3
 801cb76:	d01c      	beq.n	801cbb2 <jpeg_resync_to_restart+0x10e>
 801cb78:	68bb      	ldr	r3, [r7, #8]
 801cb7a:	2b03      	cmp	r3, #3
 801cb7c:	dcb0      	bgt.n	801cae0 <jpeg_resync_to_restart+0x3c>
 801cb7e:	68bb      	ldr	r3, [r7, #8]
 801cb80:	2b01      	cmp	r3, #1
 801cb82:	d003      	beq.n	801cb8c <jpeg_resync_to_restart+0xe8>
 801cb84:	68bb      	ldr	r3, [r7, #8]
 801cb86:	2b02      	cmp	r3, #2
 801cb88:	d006      	beq.n	801cb98 <jpeg_resync_to_restart+0xf4>
 801cb8a:	e014      	b.n	801cbb6 <jpeg_resync_to_restart+0x112>
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
 801cb8c:	687b      	ldr	r3, [r7, #4]
 801cb8e:	2200      	movs	r2, #0
 801cb90:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
      return TRUE;
 801cb94:	2301      	movs	r3, #1
 801cb96:	e00f      	b.n	801cbb8 <jpeg_resync_to_restart+0x114>
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
 801cb98:	6878      	ldr	r0, [r7, #4]
 801cb9a:	f7ff fc6b 	bl	801c474 <next_marker>
 801cb9e:	4603      	mov	r3, r0
 801cba0:	2b00      	cmp	r3, #0
 801cba2:	d101      	bne.n	801cba8 <jpeg_resync_to_restart+0x104>
	return FALSE;
 801cba4:	2300      	movs	r3, #0
 801cba6:	e007      	b.n	801cbb8 <jpeg_resync_to_restart+0x114>
      marker = cinfo->unread_marker;
 801cba8:	687b      	ldr	r3, [r7, #4]
 801cbaa:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 801cbae:	60fb      	str	r3, [r7, #12]
      break;
 801cbb0:	e001      	b.n	801cbb6 <jpeg_resync_to_restart+0x112>
    case 3:
      /* Return without advancing past this marker. */
      /* Entropy decoder will be forced to process an empty segment. */
      return TRUE;
 801cbb2:	2301      	movs	r3, #1
 801cbb4:	e000      	b.n	801cbb8 <jpeg_resync_to_restart+0x114>
    if (marker < (int) M_SOF0)
 801cbb6:	e793      	b.n	801cae0 <jpeg_resync_to_restart+0x3c>
    }
  } /* end loop */
}
 801cbb8:	4618      	mov	r0, r3
 801cbba:	3710      	adds	r7, #16
 801cbbc:	46bd      	mov	sp, r7
 801cbbe:	bd80      	pop	{r7, pc}

0801cbc0 <reset_marker_reader>:
 * Reset marker processing state to begin a fresh datastream.
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
 801cbc0:	b480      	push	{r7}
 801cbc2:	b085      	sub	sp, #20
 801cbc4:	af00      	add	r7, sp, #0
 801cbc6:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
 801cbc8:	687b      	ldr	r3, [r7, #4]
 801cbca:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
 801cbce:	60fb      	str	r3, [r7, #12]

  cinfo->comp_info = NULL;		/* until allocated by get_sof */
 801cbd0:	687b      	ldr	r3, [r7, #4]
 801cbd2:	2200      	movs	r2, #0
 801cbd4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
 801cbd8:	687b      	ldr	r3, [r7, #4]
 801cbda:	2200      	movs	r2, #0
 801cbdc:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  cinfo->unread_marker = 0;		/* no pending marker */
 801cbe0:	687b      	ldr	r3, [r7, #4]
 801cbe2:	2200      	movs	r2, #0
 801cbe4:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
  marker->pub.saw_SOI = FALSE;		/* set internal state too */
 801cbe8:	68fb      	ldr	r3, [r7, #12]
 801cbea:	2200      	movs	r2, #0
 801cbec:	60da      	str	r2, [r3, #12]
  marker->pub.saw_SOF = FALSE;
 801cbee:	68fb      	ldr	r3, [r7, #12]
 801cbf0:	2200      	movs	r2, #0
 801cbf2:	611a      	str	r2, [r3, #16]
  marker->pub.discarded_bytes = 0;
 801cbf4:	68fb      	ldr	r3, [r7, #12]
 801cbf6:	2200      	movs	r2, #0
 801cbf8:	619a      	str	r2, [r3, #24]
  marker->cur_marker = NULL;
 801cbfa:	68fb      	ldr	r3, [r7, #12]
 801cbfc:	2200      	movs	r2, #0
 801cbfe:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
}
 801cc02:	bf00      	nop
 801cc04:	3714      	adds	r7, #20
 801cc06:	46bd      	mov	sp, r7
 801cc08:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc0c:	4770      	bx	lr
	...

0801cc10 <jinit_marker_reader>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
 801cc10:	b580      	push	{r7, lr}
 801cc12:	b084      	sub	sp, #16
 801cc14:	af00      	add	r7, sp, #0
 801cc16:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker;
  int i;

  /* Create subobject in permanent pool */
  marker = (my_marker_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 801cc18:	687b      	ldr	r3, [r7, #4]
 801cc1a:	685b      	ldr	r3, [r3, #4]
 801cc1c:	681b      	ldr	r3, [r3, #0]
 801cc1e:	22ac      	movs	r2, #172	@ 0xac
 801cc20:	2100      	movs	r1, #0
 801cc22:	6878      	ldr	r0, [r7, #4]
 801cc24:	4798      	blx	r3
 801cc26:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_marker_reader));
  cinfo->marker = (struct jpeg_marker_reader *) marker;
 801cc28:	687b      	ldr	r3, [r7, #4]
 801cc2a:	68ba      	ldr	r2, [r7, #8]
 801cc2c:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
  /* Initialize public method pointers */
  marker->pub.reset_marker_reader = reset_marker_reader;
 801cc30:	68bb      	ldr	r3, [r7, #8]
 801cc32:	4a18      	ldr	r2, [pc, #96]	@ (801cc94 <jinit_marker_reader+0x84>)
 801cc34:	601a      	str	r2, [r3, #0]
  marker->pub.read_markers = read_markers;
 801cc36:	68bb      	ldr	r3, [r7, #8]
 801cc38:	4a17      	ldr	r2, [pc, #92]	@ (801cc98 <jinit_marker_reader+0x88>)
 801cc3a:	605a      	str	r2, [r3, #4]
  marker->pub.read_restart_marker = read_restart_marker;
 801cc3c:	68bb      	ldr	r3, [r7, #8]
 801cc3e:	4a17      	ldr	r2, [pc, #92]	@ (801cc9c <jinit_marker_reader+0x8c>)
 801cc40:	609a      	str	r2, [r3, #8]
  /* Initialize COM/APPn processing.
   * By default, we examine and then discard APP0 and APP14,
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
 801cc42:	68bb      	ldr	r3, [r7, #8]
 801cc44:	4a16      	ldr	r2, [pc, #88]	@ (801cca0 <jinit_marker_reader+0x90>)
 801cc46:	61da      	str	r2, [r3, #28]
  marker->length_limit_COM = 0;
 801cc48:	68bb      	ldr	r3, [r7, #8]
 801cc4a:	2200      	movs	r2, #0
 801cc4c:	661a      	str	r2, [r3, #96]	@ 0x60
  for (i = 0; i < 16; i++) {
 801cc4e:	2300      	movs	r3, #0
 801cc50:	60fb      	str	r3, [r7, #12]
 801cc52:	e00f      	b.n	801cc74 <jinit_marker_reader+0x64>
    marker->process_APPn[i] = skip_variable;
 801cc54:	68bb      	ldr	r3, [r7, #8]
 801cc56:	68fa      	ldr	r2, [r7, #12]
 801cc58:	3208      	adds	r2, #8
 801cc5a:	4911      	ldr	r1, [pc, #68]	@ (801cca0 <jinit_marker_reader+0x90>)
 801cc5c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    marker->length_limit_APPn[i] = 0;
 801cc60:	68ba      	ldr	r2, [r7, #8]
 801cc62:	68fb      	ldr	r3, [r7, #12]
 801cc64:	3318      	adds	r3, #24
 801cc66:	009b      	lsls	r3, r3, #2
 801cc68:	4413      	add	r3, r2
 801cc6a:	2200      	movs	r2, #0
 801cc6c:	605a      	str	r2, [r3, #4]
  for (i = 0; i < 16; i++) {
 801cc6e:	68fb      	ldr	r3, [r7, #12]
 801cc70:	3301      	adds	r3, #1
 801cc72:	60fb      	str	r3, [r7, #12]
 801cc74:	68fb      	ldr	r3, [r7, #12]
 801cc76:	2b0f      	cmp	r3, #15
 801cc78:	ddec      	ble.n	801cc54 <jinit_marker_reader+0x44>
  }
  marker->process_APPn[0] = get_interesting_appn;
 801cc7a:	68bb      	ldr	r3, [r7, #8]
 801cc7c:	4a09      	ldr	r2, [pc, #36]	@ (801cca4 <jinit_marker_reader+0x94>)
 801cc7e:	621a      	str	r2, [r3, #32]
  marker->process_APPn[14] = get_interesting_appn;
 801cc80:	68bb      	ldr	r3, [r7, #8]
 801cc82:	4a08      	ldr	r2, [pc, #32]	@ (801cca4 <jinit_marker_reader+0x94>)
 801cc84:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
 801cc86:	6878      	ldr	r0, [r7, #4]
 801cc88:	f7ff ff9a 	bl	801cbc0 <reset_marker_reader>
}
 801cc8c:	bf00      	nop
 801cc8e:	3710      	adds	r7, #16
 801cc90:	46bd      	mov	sp, r7
 801cc92:	bd80      	pop	{r7, pc}
 801cc94:	0801cbc1 	.word	0x0801cbc1
 801cc98:	0801c6a9 	.word	0x0801c6a9
 801cc9c:	0801ca05 	.word	0x0801ca05
 801cca0:	0801c395 	.word	0x0801c395
 801cca4:	0801c217 	.word	0x0801c217

0801cca8 <use_merged_upsample>:
 * CRUCIAL: this must match the actual capabilities of jdmerge.c!
 */

LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
 801cca8:	b480      	push	{r7}
 801ccaa:	b083      	sub	sp, #12
 801ccac:	af00      	add	r7, sp, #0
 801ccae:	6078      	str	r0, [r7, #4]
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
 801ccb0:	687b      	ldr	r3, [r7, #4]
 801ccb2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801ccb4:	2b00      	cmp	r3, #0
 801ccb6:	d104      	bne.n	801ccc2 <use_merged_upsample+0x1a>
 801ccb8:	687b      	ldr	r3, [r7, #4]
 801ccba:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 801ccbe:	2b00      	cmp	r3, #0
 801ccc0:	d001      	beq.n	801ccc6 <use_merged_upsample+0x1e>
    return FALSE;
 801ccc2:	2300      	movs	r3, #0
 801ccc4:	e07a      	b.n	801cdbc <use_merged_upsample+0x114>
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 801ccc6:	687b      	ldr	r3, [r7, #4]
 801ccc8:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801cccc:	2b03      	cmp	r3, #3
 801ccce:	d10c      	bne.n	801ccea <use_merged_upsample+0x42>
 801ccd0:	687b      	ldr	r3, [r7, #4]
 801ccd2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801ccd4:	2b03      	cmp	r3, #3
 801ccd6:	d108      	bne.n	801ccea <use_merged_upsample+0x42>
      cinfo->out_color_space != JCS_RGB ||
 801ccd8:	687b      	ldr	r3, [r7, #4]
 801ccda:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 801ccde:	2b02      	cmp	r3, #2
 801cce0:	d103      	bne.n	801ccea <use_merged_upsample+0x42>
      cinfo->out_color_components != RGB_PIXELSIZE)
 801cce2:	687b      	ldr	r3, [r7, #4]
 801cce4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
      cinfo->out_color_space != JCS_RGB ||
 801cce6:	2b03      	cmp	r3, #3
 801cce8:	d001      	beq.n	801ccee <use_merged_upsample+0x46>
    return FALSE;
 801ccea:	2300      	movs	r3, #0
 801ccec:	e066      	b.n	801cdbc <use_merged_upsample+0x114>
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 801ccee:	687b      	ldr	r3, [r7, #4]
 801ccf0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801ccf4:	689b      	ldr	r3, [r3, #8]
 801ccf6:	2b02      	cmp	r3, #2
 801ccf8:	d121      	bne.n	801cd3e <use_merged_upsample+0x96>
      cinfo->comp_info[1].h_samp_factor != 1 ||
 801ccfa:	687b      	ldr	r3, [r7, #4]
 801ccfc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd00:	3358      	adds	r3, #88	@ 0x58
 801cd02:	689b      	ldr	r3, [r3, #8]
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 801cd04:	2b01      	cmp	r3, #1
 801cd06:	d11a      	bne.n	801cd3e <use_merged_upsample+0x96>
      cinfo->comp_info[2].h_samp_factor != 1 ||
 801cd08:	687b      	ldr	r3, [r7, #4]
 801cd0a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd0e:	33b0      	adds	r3, #176	@ 0xb0
 801cd10:	689b      	ldr	r3, [r3, #8]
      cinfo->comp_info[1].h_samp_factor != 1 ||
 801cd12:	2b01      	cmp	r3, #1
 801cd14:	d113      	bne.n	801cd3e <use_merged_upsample+0x96>
      cinfo->comp_info[0].v_samp_factor >  2 ||
 801cd16:	687b      	ldr	r3, [r7, #4]
 801cd18:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd1c:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[2].h_samp_factor != 1 ||
 801cd1e:	2b02      	cmp	r3, #2
 801cd20:	dc0d      	bgt.n	801cd3e <use_merged_upsample+0x96>
      cinfo->comp_info[1].v_samp_factor != 1 ||
 801cd22:	687b      	ldr	r3, [r7, #4]
 801cd24:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd28:	3358      	adds	r3, #88	@ 0x58
 801cd2a:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[0].v_samp_factor >  2 ||
 801cd2c:	2b01      	cmp	r3, #1
 801cd2e:	d106      	bne.n	801cd3e <use_merged_upsample+0x96>
      cinfo->comp_info[2].v_samp_factor != 1)
 801cd30:	687b      	ldr	r3, [r7, #4]
 801cd32:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd36:	33b0      	adds	r3, #176	@ 0xb0
 801cd38:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[1].v_samp_factor != 1 ||
 801cd3a:	2b01      	cmp	r3, #1
 801cd3c:	d001      	beq.n	801cd42 <use_merged_upsample+0x9a>
    return FALSE;
 801cd3e:	2300      	movs	r3, #0
 801cd40:	e03c      	b.n	801cdbc <use_merged_upsample+0x114>
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd42:	687b      	ldr	r3, [r7, #4]
 801cd44:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd48:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801cd4a:	687b      	ldr	r3, [r7, #4]
 801cd4c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801cd50:	429a      	cmp	r2, r3
 801cd52:	d130      	bne.n	801cdb6 <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd54:	687b      	ldr	r3, [r7, #4]
 801cd56:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd5a:	3358      	adds	r3, #88	@ 0x58
 801cd5c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801cd5e:	687b      	ldr	r3, [r7, #4]
 801cd60:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd64:	429a      	cmp	r2, r3
 801cd66:	d126      	bne.n	801cdb6 <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd68:	687b      	ldr	r3, [r7, #4]
 801cd6a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd6e:	33b0      	adds	r3, #176	@ 0xb0
 801cd70:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801cd72:	687b      	ldr	r3, [r7, #4]
 801cd74:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd78:	429a      	cmp	r2, r3
 801cd7a:	d11c      	bne.n	801cdb6 <use_merged_upsample+0x10e>
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801cd7c:	687b      	ldr	r3, [r7, #4]
 801cd7e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd82:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801cd84:	687b      	ldr	r3, [r7, #4]
 801cd86:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 801cd8a:	429a      	cmp	r2, r3
 801cd8c:	d113      	bne.n	801cdb6 <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801cd8e:	687b      	ldr	r3, [r7, #4]
 801cd90:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cd94:	3358      	adds	r3, #88	@ 0x58
 801cd96:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801cd98:	687b      	ldr	r3, [r7, #4]
 801cd9a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801cd9e:	429a      	cmp	r2, r3
 801cda0:	d109      	bne.n	801cdb6 <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size)
 801cda2:	687b      	ldr	r3, [r7, #4]
 801cda4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cda8:	33b0      	adds	r3, #176	@ 0xb0
 801cdaa:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801cdac:	687b      	ldr	r3, [r7, #4]
 801cdae:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 801cdb2:	429a      	cmp	r2, r3
 801cdb4:	d001      	beq.n	801cdba <use_merged_upsample+0x112>
    return FALSE;
 801cdb6:	2300      	movs	r3, #0
 801cdb8:	e000      	b.n	801cdbc <use_merged_upsample+0x114>
  /* ??? also need to test for upsample-time rescaling, when & if supported */
  return TRUE;			/* by golly, it'll work... */
 801cdba:	2301      	movs	r3, #1
#else
  return FALSE;
#endif
}
 801cdbc:	4618      	mov	r0, r3
 801cdbe:	370c      	adds	r7, #12
 801cdc0:	46bd      	mov	sp, r7
 801cdc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cdc6:	4770      	bx	lr

0801cdc8 <jpeg_calc_output_dimensions>:
GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for full decompression.
 */
{
 801cdc8:	b580      	push	{r7, lr}
 801cdca:	b086      	sub	sp, #24
 801cdcc:	af00      	add	r7, sp, #0
 801cdce:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;
#endif

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
 801cdd0:	687b      	ldr	r3, [r7, #4]
 801cdd2:	695b      	ldr	r3, [r3, #20]
 801cdd4:	2bca      	cmp	r3, #202	@ 0xca
 801cdd6:	d00d      	beq.n	801cdf4 <jpeg_calc_output_dimensions+0x2c>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 801cdd8:	687b      	ldr	r3, [r7, #4]
 801cdda:	681b      	ldr	r3, [r3, #0]
 801cddc:	2215      	movs	r2, #21
 801cdde:	615a      	str	r2, [r3, #20]
 801cde0:	687b      	ldr	r3, [r7, #4]
 801cde2:	681b      	ldr	r3, [r3, #0]
 801cde4:	687a      	ldr	r2, [r7, #4]
 801cde6:	6952      	ldr	r2, [r2, #20]
 801cde8:	619a      	str	r2, [r3, #24]
 801cdea:	687b      	ldr	r3, [r7, #4]
 801cdec:	681b      	ldr	r3, [r3, #0]
 801cdee:	681b      	ldr	r3, [r3, #0]
 801cdf0:	6878      	ldr	r0, [r7, #4]
 801cdf2:	4798      	blx	r3

  /* Compute core output image dimensions and DCT scaling choices. */
  jpeg_core_output_dimensions(cinfo);
 801cdf4:	6878      	ldr	r0, [r7, #4]
 801cdf6:	f7fc f80f 	bl	8018e18 <jpeg_core_output_dimensions>
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code adapts subsampling ratios which are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801cdfa:	2300      	movs	r3, #0
 801cdfc:	617b      	str	r3, [r7, #20]
 801cdfe:	687b      	ldr	r3, [r7, #4]
 801ce00:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801ce04:	613b      	str	r3, [r7, #16]
 801ce06:	e078      	b.n	801cefa <jpeg_calc_output_dimensions+0x132>
       ci++, compptr++) {
    int ssize = 1;
 801ce08:	2301      	movs	r3, #1
 801ce0a:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 801ce0c:	e002      	b.n	801ce14 <jpeg_calc_output_dimensions+0x4c>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 801ce0e:	68fb      	ldr	r3, [r7, #12]
 801ce10:	005b      	lsls	r3, r3, #1
 801ce12:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 801ce14:	687b      	ldr	r3, [r7, #4]
 801ce16:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801ce1a:	68fa      	ldr	r2, [r7, #12]
 801ce1c:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801ce20:	687a      	ldr	r2, [r7, #4]
 801ce22:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 801ce24:	2a00      	cmp	r2, #0
 801ce26:	d001      	beq.n	801ce2c <jpeg_calc_output_dimensions+0x64>
 801ce28:	2208      	movs	r2, #8
 801ce2a:	e000      	b.n	801ce2e <jpeg_calc_output_dimensions+0x66>
 801ce2c:	2204      	movs	r2, #4
 801ce2e:	429a      	cmp	r2, r3
 801ce30:	db0f      	blt.n	801ce52 <jpeg_calc_output_dimensions+0x8a>
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
 801ce32:	687b      	ldr	r3, [r7, #4]
 801ce34:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801ce38:	693a      	ldr	r2, [r7, #16]
 801ce3a:	6892      	ldr	r2, [r2, #8]
 801ce3c:	68f9      	ldr	r1, [r7, #12]
 801ce3e:	fb01 f202 	mul.w	r2, r1, r2
 801ce42:	0052      	lsls	r2, r2, #1
 801ce44:	fb93 f1f2 	sdiv	r1, r3, r2
 801ce48:	fb01 f202 	mul.w	r2, r1, r2
 801ce4c:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801ce4e:	2b00      	cmp	r3, #0
 801ce50:	d0dd      	beq.n	801ce0e <jpeg_calc_output_dimensions+0x46>
    }
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
 801ce52:	687b      	ldr	r3, [r7, #4]
 801ce54:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 801ce58:	68fa      	ldr	r2, [r7, #12]
 801ce5a:	fb03 f202 	mul.w	r2, r3, r2
 801ce5e:	693b      	ldr	r3, [r7, #16]
 801ce60:	625a      	str	r2, [r3, #36]	@ 0x24
    ssize = 1;
 801ce62:	2301      	movs	r3, #1
 801ce64:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 801ce66:	e002      	b.n	801ce6e <jpeg_calc_output_dimensions+0xa6>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 801ce68:	68fb      	ldr	r3, [r7, #12]
 801ce6a:	005b      	lsls	r3, r3, #1
 801ce6c:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 801ce6e:	687b      	ldr	r3, [r7, #4]
 801ce70:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801ce74:	68fa      	ldr	r2, [r7, #12]
 801ce76:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801ce7a:	687a      	ldr	r2, [r7, #4]
 801ce7c:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 801ce7e:	2a00      	cmp	r2, #0
 801ce80:	d001      	beq.n	801ce86 <jpeg_calc_output_dimensions+0xbe>
 801ce82:	2208      	movs	r2, #8
 801ce84:	e000      	b.n	801ce88 <jpeg_calc_output_dimensions+0xc0>
 801ce86:	2204      	movs	r2, #4
 801ce88:	429a      	cmp	r2, r3
 801ce8a:	db0f      	blt.n	801ceac <jpeg_calc_output_dimensions+0xe4>
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
 801ce8c:	687b      	ldr	r3, [r7, #4]
 801ce8e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801ce92:	693a      	ldr	r2, [r7, #16]
 801ce94:	68d2      	ldr	r2, [r2, #12]
 801ce96:	68f9      	ldr	r1, [r7, #12]
 801ce98:	fb01 f202 	mul.w	r2, r1, r2
 801ce9c:	0052      	lsls	r2, r2, #1
 801ce9e:	fb93 f1f2 	sdiv	r1, r3, r2
 801cea2:	fb01 f202 	mul.w	r2, r1, r2
 801cea6:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 801cea8:	2b00      	cmp	r3, #0
 801ceaa:	d0dd      	beq.n	801ce68 <jpeg_calc_output_dimensions+0xa0>
    }
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 801ceac:	687b      	ldr	r3, [r7, #4]
 801ceae:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
 801ceb2:	68fa      	ldr	r2, [r7, #12]
 801ceb4:	fb03 f202 	mul.w	r2, r3, r2
 801ceb8:	693b      	ldr	r3, [r7, #16]
 801ceba:	629a      	str	r2, [r3, #40]	@ 0x28

    /* We don't support IDCT ratios larger than 2. */
    if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
 801cebc:	693b      	ldr	r3, [r7, #16]
 801cebe:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801cec0:	693b      	ldr	r3, [r7, #16]
 801cec2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801cec4:	005b      	lsls	r3, r3, #1
 801cec6:	429a      	cmp	r2, r3
 801cec8:	dd05      	ble.n	801ced6 <jpeg_calc_output_dimensions+0x10e>
	compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size * 2;
 801ceca:	693b      	ldr	r3, [r7, #16]
 801cecc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801cece:	005a      	lsls	r2, r3, #1
 801ced0:	693b      	ldr	r3, [r7, #16]
 801ced2:	625a      	str	r2, [r3, #36]	@ 0x24
 801ced4:	e00b      	b.n	801ceee <jpeg_calc_output_dimensions+0x126>
    else if (compptr->DCT_v_scaled_size > compptr->DCT_h_scaled_size * 2)
 801ced6:	693b      	ldr	r3, [r7, #16]
 801ced8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801ceda:	693b      	ldr	r3, [r7, #16]
 801cedc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801cede:	005b      	lsls	r3, r3, #1
 801cee0:	429a      	cmp	r2, r3
 801cee2:	dd04      	ble.n	801ceee <jpeg_calc_output_dimensions+0x126>
	compptr->DCT_v_scaled_size = compptr->DCT_h_scaled_size * 2;
 801cee4:	693b      	ldr	r3, [r7, #16]
 801cee6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801cee8:	005a      	lsls	r2, r3, #1
 801ceea:	693b      	ldr	r3, [r7, #16]
 801ceec:	629a      	str	r2, [r3, #40]	@ 0x28
       ci++, compptr++) {
 801ceee:	697b      	ldr	r3, [r7, #20]
 801cef0:	3301      	adds	r3, #1
 801cef2:	617b      	str	r3, [r7, #20]
 801cef4:	693b      	ldr	r3, [r7, #16]
 801cef6:	3358      	adds	r3, #88	@ 0x58
 801cef8:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801cefa:	687b      	ldr	r3, [r7, #4]
 801cefc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801cefe:	697a      	ldr	r2, [r7, #20]
 801cf00:	429a      	cmp	r2, r3
 801cf02:	db81      	blt.n	801ce08 <jpeg_calc_output_dimensions+0x40>
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801cf04:	2300      	movs	r3, #0
 801cf06:	617b      	str	r3, [r7, #20]
 801cf08:	687b      	ldr	r3, [r7, #4]
 801cf0a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801cf0e:	613b      	str	r3, [r7, #16]
 801cf10:	e039      	b.n	801cf86 <jpeg_calc_output_dimensions+0x1be>
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width *
 801cf12:	687b      	ldr	r3, [r7, #4]
 801cf14:	69db      	ldr	r3, [r3, #28]
 801cf16:	4619      	mov	r1, r3
		    (long) (compptr->h_samp_factor * compptr->DCT_h_scaled_size),
 801cf18:	693b      	ldr	r3, [r7, #16]
 801cf1a:	689b      	ldr	r3, [r3, #8]
 801cf1c:	693a      	ldr	r2, [r7, #16]
 801cf1e:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801cf20:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 801cf24:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 801cf28:	687b      	ldr	r3, [r7, #4]
 801cf2a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801cf2e:	687a      	ldr	r2, [r7, #4]
 801cf30:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801cf34:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 801cf38:	4619      	mov	r1, r3
 801cf3a:	f012 f8a7 	bl	802f08c <jdiv_round_up>
 801cf3e:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 801cf40:	461a      	mov	r2, r3
 801cf42:	693b      	ldr	r3, [r7, #16]
 801cf44:	62da      	str	r2, [r3, #44]	@ 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height *
 801cf46:	687b      	ldr	r3, [r7, #4]
 801cf48:	6a1b      	ldr	r3, [r3, #32]
 801cf4a:	4619      	mov	r1, r3
		    (long) (compptr->v_samp_factor * compptr->DCT_v_scaled_size),
 801cf4c:	693b      	ldr	r3, [r7, #16]
 801cf4e:	68db      	ldr	r3, [r3, #12]
 801cf50:	693a      	ldr	r2, [r7, #16]
 801cf52:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801cf54:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 801cf58:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 801cf5c:	687b      	ldr	r3, [r7, #4]
 801cf5e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801cf62:	687a      	ldr	r2, [r7, #4]
 801cf64:	f8d2 21a8 	ldr.w	r2, [r2, #424]	@ 0x1a8
 801cf68:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 801cf6c:	4619      	mov	r1, r3
 801cf6e:	f012 f88d 	bl	802f08c <jdiv_round_up>
 801cf72:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 801cf74:	461a      	mov	r2, r3
 801cf76:	693b      	ldr	r3, [r7, #16]
 801cf78:	631a      	str	r2, [r3, #48]	@ 0x30
       ci++, compptr++) {
 801cf7a:	697b      	ldr	r3, [r7, #20]
 801cf7c:	3301      	adds	r3, #1
 801cf7e:	617b      	str	r3, [r7, #20]
 801cf80:	693b      	ldr	r3, [r7, #16]
 801cf82:	3358      	adds	r3, #88	@ 0x58
 801cf84:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801cf86:	687b      	ldr	r3, [r7, #4]
 801cf88:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801cf8a:	697a      	ldr	r2, [r7, #20]
 801cf8c:	429a      	cmp	r2, r3
 801cf8e:	dbc0      	blt.n	801cf12 <jpeg_calc_output_dimensions+0x14a>

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
 801cf90:	687b      	ldr	r3, [r7, #4]
 801cf92:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 801cf96:	3b01      	subs	r3, #1
 801cf98:	2b04      	cmp	r3, #4
 801cf9a:	d81d      	bhi.n	801cfd8 <jpeg_calc_output_dimensions+0x210>
 801cf9c:	a201      	add	r2, pc, #4	@ (adr r2, 801cfa4 <jpeg_calc_output_dimensions+0x1dc>)
 801cf9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801cfa2:	bf00      	nop
 801cfa4:	0801cfb9 	.word	0x0801cfb9
 801cfa8:	0801cfc1 	.word	0x0801cfc1
 801cfac:	0801cfc9 	.word	0x0801cfc9
 801cfb0:	0801cfd1 	.word	0x0801cfd1
 801cfb4:	0801cfd1 	.word	0x0801cfd1
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 801cfb8:	687b      	ldr	r3, [r7, #4]
 801cfba:	2201      	movs	r2, #1
 801cfbc:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801cfbe:	e010      	b.n	801cfe2 <jpeg_calc_output_dimensions+0x21a>
  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 801cfc0:	687b      	ldr	r3, [r7, #4]
 801cfc2:	2203      	movs	r2, #3
 801cfc4:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801cfc6:	e00c      	b.n	801cfe2 <jpeg_calc_output_dimensions+0x21a>
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
 801cfc8:	687b      	ldr	r3, [r7, #4]
 801cfca:	2203      	movs	r2, #3
 801cfcc:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801cfce:	e008      	b.n	801cfe2 <jpeg_calc_output_dimensions+0x21a>
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
 801cfd0:	687b      	ldr	r3, [r7, #4]
 801cfd2:	2204      	movs	r2, #4
 801cfd4:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801cfd6:	e004      	b.n	801cfe2 <jpeg_calc_output_dimensions+0x21a>
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
 801cfd8:	687b      	ldr	r3, [r7, #4]
 801cfda:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801cfdc:	687b      	ldr	r3, [r7, #4]
 801cfde:	679a      	str	r2, [r3, #120]	@ 0x78
    break;
 801cfe0:	bf00      	nop
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
 801cfe2:	687b      	ldr	r3, [r7, #4]
 801cfe4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801cfe6:	2b00      	cmp	r3, #0
 801cfe8:	d102      	bne.n	801cff0 <jpeg_calc_output_dimensions+0x228>
 801cfea:	687b      	ldr	r3, [r7, #4]
 801cfec:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801cfee:	e000      	b.n	801cff2 <jpeg_calc_output_dimensions+0x22a>
 801cff0:	2301      	movs	r3, #1
 801cff2:	687a      	ldr	r2, [r7, #4]
 801cff4:	67d3      	str	r3, [r2, #124]	@ 0x7c
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
 801cff6:	6878      	ldr	r0, [r7, #4]
 801cff8:	f7ff fe56 	bl	801cca8 <use_merged_upsample>
 801cffc:	4603      	mov	r3, r0
 801cffe:	2b00      	cmp	r3, #0
 801d000:	d006      	beq.n	801d010 <jpeg_calc_output_dimensions+0x248>
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
 801d002:	687b      	ldr	r3, [r7, #4]
 801d004:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801d008:	687b      	ldr	r3, [r7, #4]
 801d00a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  else
    cinfo->rec_outbuf_height = 1;
}
 801d00e:	e003      	b.n	801d018 <jpeg_calc_output_dimensions+0x250>
    cinfo->rec_outbuf_height = 1;
 801d010:	687b      	ldr	r3, [r7, #4]
 801d012:	2201      	movs	r2, #1
 801d014:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
}
 801d018:	bf00      	nop
 801d01a:	3718      	adds	r7, #24
 801d01c:	46bd      	mov	sp, r7
 801d01e:	bd80      	pop	{r7, pc}

0801d020 <prepare_range_limit_table>:
 */

LOCAL(void)
prepare_range_limit_table (j_decompress_ptr cinfo)
/* Allocate and fill in the sample_range_limit table */
{
 801d020:	b580      	push	{r7, lr}
 801d022:	b084      	sub	sp, #16
 801d024:	af00      	add	r7, sp, #0
 801d026:	6078      	str	r0, [r7, #4]
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d028:	687b      	ldr	r3, [r7, #4]
 801d02a:	685b      	ldr	r3, [r3, #4]
 801d02c:	681b      	ldr	r3, [r3, #0]
 801d02e:	f44f 62b0 	mov.w	r2, #1408	@ 0x580
 801d032:	2101      	movs	r1, #1
 801d034:	6878      	ldr	r0, [r7, #4]
 801d036:	4798      	blx	r3
 801d038:	60b8      	str	r0, [r7, #8]
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
 801d03a:	68bb      	ldr	r3, [r7, #8]
 801d03c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801d040:	60bb      	str	r3, [r7, #8]
  cinfo->sample_range_limit = table;
 801d042:	687b      	ldr	r3, [r7, #4]
 801d044:	68ba      	ldr	r2, [r7, #8]
 801d046:	f8c3 214c 	str.w	r2, [r3, #332]	@ 0x14c
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
 801d04a:	68bb      	ldr	r3, [r7, #8]
 801d04c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 801d050:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801d054:	2100      	movs	r1, #0
 801d056:	4618      	mov	r0, r3
 801d058:	f012 fca2 	bl	802f9a0 <memset>
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
 801d05c:	2300      	movs	r3, #0
 801d05e:	60fb      	str	r3, [r7, #12]
 801d060:	e008      	b.n	801d074 <prepare_range_limit_table+0x54>
    table[i] = (JSAMPLE) i;
 801d062:	68fb      	ldr	r3, [r7, #12]
 801d064:	68ba      	ldr	r2, [r7, #8]
 801d066:	4413      	add	r3, r2
 801d068:	68fa      	ldr	r2, [r7, #12]
 801d06a:	b2d2      	uxtb	r2, r2
 801d06c:	701a      	strb	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++)
 801d06e:	68fb      	ldr	r3, [r7, #12]
 801d070:	3301      	adds	r3, #1
 801d072:	60fb      	str	r3, [r7, #12]
 801d074:	68fb      	ldr	r3, [r7, #12]
 801d076:	2bff      	cmp	r3, #255	@ 0xff
 801d078:	ddf3      	ble.n	801d062 <prepare_range_limit_table+0x42>
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
 801d07a:	68bb      	ldr	r3, [r7, #8]
 801d07c:	3380      	adds	r3, #128	@ 0x80
 801d07e:	60bb      	str	r3, [r7, #8]
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 801d080:	2380      	movs	r3, #128	@ 0x80
 801d082:	60fb      	str	r3, [r7, #12]
 801d084:	e007      	b.n	801d096 <prepare_range_limit_table+0x76>
    table[i] = MAXJSAMPLE;
 801d086:	68fb      	ldr	r3, [r7, #12]
 801d088:	68ba      	ldr	r2, [r7, #8]
 801d08a:	4413      	add	r3, r2
 801d08c:	22ff      	movs	r2, #255	@ 0xff
 801d08e:	701a      	strb	r2, [r3, #0]
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 801d090:	68fb      	ldr	r3, [r7, #12]
 801d092:	3301      	adds	r3, #1
 801d094:	60fb      	str	r3, [r7, #12]
 801d096:	68fb      	ldr	r3, [r7, #12]
 801d098:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801d09c:	dbf3      	blt.n	801d086 <prepare_range_limit_table+0x66>
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
 801d09e:	68bb      	ldr	r3, [r7, #8]
 801d0a0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801d0a4:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 801d0a8:	2100      	movs	r1, #0
 801d0aa:	4618      	mov	r0, r3
 801d0ac:	f012 fc78 	bl	802f9a0 <memset>
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
 801d0b0:	68bb      	ldr	r3, [r7, #8]
 801d0b2:	f503 7060 	add.w	r0, r3, #896	@ 0x380
 801d0b6:	687b      	ldr	r3, [r7, #4]
 801d0b8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801d0bc:	2280      	movs	r2, #128	@ 0x80
 801d0be:	4619      	mov	r1, r3
 801d0c0:	f012 fcb2 	bl	802fa28 <memcpy>
	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
}
 801d0c4:	bf00      	nop
 801d0c6:	3710      	adds	r7, #16
 801d0c8:	46bd      	mov	sp, r7
 801d0ca:	bd80      	pop	{r7, pc}

0801d0cc <master_selection>:
 * settings.
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
 801d0cc:	b580      	push	{r7, lr}
 801d0ce:	b088      	sub	sp, #32
 801d0d0:	af00      	add	r7, sp, #0
 801d0d2:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801d0d4:	687b      	ldr	r3, [r7, #4]
 801d0d6:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801d0da:	61bb      	str	r3, [r7, #24]
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
 801d0dc:	6878      	ldr	r0, [r7, #4]
 801d0de:	f7ff fe73 	bl	801cdc8 <jpeg_calc_output_dimensions>
  prepare_range_limit_table(cinfo);
 801d0e2:	6878      	ldr	r0, [r7, #4]
 801d0e4:	f7ff ff9c 	bl	801d020 <prepare_range_limit_table>

  /* Width of an output scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
 801d0e8:	687b      	ldr	r3, [r7, #4]
 801d0ea:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801d0ec:	461a      	mov	r2, r3
 801d0ee:	687b      	ldr	r3, [r7, #4]
 801d0f0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801d0f2:	fb02 f303 	mul.w	r3, r2, r3
 801d0f6:	617b      	str	r3, [r7, #20]
  jd_samplesperrow = (JDIMENSION) samplesperrow;
 801d0f8:	697b      	ldr	r3, [r7, #20]
 801d0fa:	613b      	str	r3, [r7, #16]
  if ((long) jd_samplesperrow != samplesperrow)
 801d0fc:	693b      	ldr	r3, [r7, #16]
 801d0fe:	697a      	ldr	r2, [r7, #20]
 801d100:	429a      	cmp	r2, r3
 801d102:	d008      	beq.n	801d116 <master_selection+0x4a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 801d104:	687b      	ldr	r3, [r7, #4]
 801d106:	681b      	ldr	r3, [r3, #0]
 801d108:	2248      	movs	r2, #72	@ 0x48
 801d10a:	615a      	str	r2, [r3, #20]
 801d10c:	687b      	ldr	r3, [r7, #4]
 801d10e:	681b      	ldr	r3, [r3, #0]
 801d110:	681b      	ldr	r3, [r3, #0]
 801d112:	6878      	ldr	r0, [r7, #4]
 801d114:	4798      	blx	r3

  /* Initialize my private state */
  master->pass_number = 0;
 801d116:	69bb      	ldr	r3, [r7, #24]
 801d118:	2200      	movs	r2, #0
 801d11a:	60da      	str	r2, [r3, #12]
  master->using_merged_upsample = use_merged_upsample(cinfo);
 801d11c:	6878      	ldr	r0, [r7, #4]
 801d11e:	f7ff fdc3 	bl	801cca8 <use_merged_upsample>
 801d122:	4602      	mov	r2, r0
 801d124:	69bb      	ldr	r3, [r7, #24]
 801d126:	611a      	str	r2, [r3, #16]

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
 801d128:	69bb      	ldr	r3, [r7, #24]
 801d12a:	2200      	movs	r2, #0
 801d12c:	615a      	str	r2, [r3, #20]
  master->quantizer_2pass = NULL;
 801d12e:	69bb      	ldr	r3, [r7, #24]
 801d130:	2200      	movs	r2, #0
 801d132:	619a      	str	r2, [r3, #24]
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
 801d134:	687b      	ldr	r3, [r7, #4]
 801d136:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d138:	2b00      	cmp	r3, #0
 801d13a:	d003      	beq.n	801d144 <master_selection+0x78>
 801d13c:	687b      	ldr	r3, [r7, #4]
 801d13e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801d140:	2b00      	cmp	r3, #0
 801d142:	d108      	bne.n	801d156 <master_selection+0x8a>
    cinfo->enable_1pass_quant = FALSE;
 801d144:	687b      	ldr	r3, [r7, #4]
 801d146:	2200      	movs	r2, #0
 801d148:	665a      	str	r2, [r3, #100]	@ 0x64
    cinfo->enable_external_quant = FALSE;
 801d14a:	687b      	ldr	r3, [r7, #4]
 801d14c:	2200      	movs	r2, #0
 801d14e:	669a      	str	r2, [r3, #104]	@ 0x68
    cinfo->enable_2pass_quant = FALSE;
 801d150:	687b      	ldr	r3, [r7, #4]
 801d152:	2200      	movs	r2, #0
 801d154:	66da      	str	r2, [r3, #108]	@ 0x6c
  }
  if (cinfo->quantize_colors) {
 801d156:	687b      	ldr	r3, [r7, #4]
 801d158:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d15a:	2b00      	cmp	r3, #0
 801d15c:	d04e      	beq.n	801d1fc <master_selection+0x130>
    if (cinfo->raw_data_out)
 801d15e:	687b      	ldr	r3, [r7, #4]
 801d160:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801d162:	2b00      	cmp	r3, #0
 801d164:	d008      	beq.n	801d178 <master_selection+0xac>
      ERREXIT(cinfo, JERR_NOTIMPL);
 801d166:	687b      	ldr	r3, [r7, #4]
 801d168:	681b      	ldr	r3, [r3, #0]
 801d16a:	2230      	movs	r2, #48	@ 0x30
 801d16c:	615a      	str	r2, [r3, #20]
 801d16e:	687b      	ldr	r3, [r7, #4]
 801d170:	681b      	ldr	r3, [r3, #0]
 801d172:	681b      	ldr	r3, [r3, #0]
 801d174:	6878      	ldr	r0, [r7, #4]
 801d176:	4798      	blx	r3
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
 801d178:	687b      	ldr	r3, [r7, #4]
 801d17a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801d17c:	2b03      	cmp	r3, #3
 801d17e:	d00d      	beq.n	801d19c <master_selection+0xd0>
      cinfo->enable_1pass_quant = TRUE;
 801d180:	687b      	ldr	r3, [r7, #4]
 801d182:	2201      	movs	r2, #1
 801d184:	665a      	str	r2, [r3, #100]	@ 0x64
      cinfo->enable_external_quant = FALSE;
 801d186:	687b      	ldr	r3, [r7, #4]
 801d188:	2200      	movs	r2, #0
 801d18a:	669a      	str	r2, [r3, #104]	@ 0x68
      cinfo->enable_2pass_quant = FALSE;
 801d18c:	687b      	ldr	r3, [r7, #4]
 801d18e:	2200      	movs	r2, #0
 801d190:	66da      	str	r2, [r3, #108]	@ 0x6c
      cinfo->colormap = NULL;
 801d192:	687b      	ldr	r3, [r7, #4]
 801d194:	2200      	movs	r2, #0
 801d196:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 801d19a:	e013      	b.n	801d1c4 <master_selection+0xf8>
    } else if (cinfo->colormap != NULL) {
 801d19c:	687b      	ldr	r3, [r7, #4]
 801d19e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801d1a2:	2b00      	cmp	r3, #0
 801d1a4:	d003      	beq.n	801d1ae <master_selection+0xe2>
      cinfo->enable_external_quant = TRUE;
 801d1a6:	687b      	ldr	r3, [r7, #4]
 801d1a8:	2201      	movs	r2, #1
 801d1aa:	669a      	str	r2, [r3, #104]	@ 0x68
 801d1ac:	e00a      	b.n	801d1c4 <master_selection+0xf8>
    } else if (cinfo->two_pass_quantize) {
 801d1ae:	687b      	ldr	r3, [r7, #4]
 801d1b0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801d1b2:	2b00      	cmp	r3, #0
 801d1b4:	d003      	beq.n	801d1be <master_selection+0xf2>
      cinfo->enable_2pass_quant = TRUE;
 801d1b6:	687b      	ldr	r3, [r7, #4]
 801d1b8:	2201      	movs	r2, #1
 801d1ba:	66da      	str	r2, [r3, #108]	@ 0x6c
 801d1bc:	e002      	b.n	801d1c4 <master_selection+0xf8>
    } else {
      cinfo->enable_1pass_quant = TRUE;
 801d1be:	687b      	ldr	r3, [r7, #4]
 801d1c0:	2201      	movs	r2, #1
 801d1c2:	665a      	str	r2, [r3, #100]	@ 0x64
    }

    if (cinfo->enable_1pass_quant) {
 801d1c4:	687b      	ldr	r3, [r7, #4]
 801d1c6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801d1c8:	2b00      	cmp	r3, #0
 801d1ca:	d007      	beq.n	801d1dc <master_selection+0x110>
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
 801d1cc:	6878      	ldr	r0, [r7, #4]
 801d1ce:	f010 faaf 	bl	802d730 <jinit_1pass_quantizer>
      master->quantizer_1pass = cinfo->cquantize;
 801d1d2:	687b      	ldr	r3, [r7, #4]
 801d1d4:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 801d1d8:	69bb      	ldr	r3, [r7, #24]
 801d1da:	615a      	str	r2, [r3, #20]
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
 801d1dc:	687b      	ldr	r3, [r7, #4]
 801d1de:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d1e0:	2b00      	cmp	r3, #0
 801d1e2:	d103      	bne.n	801d1ec <master_selection+0x120>
 801d1e4:	687b      	ldr	r3, [r7, #4]
 801d1e6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801d1e8:	2b00      	cmp	r3, #0
 801d1ea:	d007      	beq.n	801d1fc <master_selection+0x130>
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
 801d1ec:	6878      	ldr	r0, [r7, #4]
 801d1ee:	f011 fe99 	bl	802ef24 <jinit_2pass_quantizer>
      master->quantizer_2pass = cinfo->cquantize;
 801d1f2:	687b      	ldr	r3, [r7, #4]
 801d1f4:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 801d1f8:	69bb      	ldr	r3, [r7, #24]
 801d1fa:	619a      	str	r2, [r3, #24]
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
 801d1fc:	687b      	ldr	r3, [r7, #4]
 801d1fe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801d200:	2b00      	cmp	r3, #0
 801d202:	d113      	bne.n	801d22c <master_selection+0x160>
    if (master->using_merged_upsample) {
 801d204:	69bb      	ldr	r3, [r7, #24]
 801d206:	691b      	ldr	r3, [r3, #16]
 801d208:	2b00      	cmp	r3, #0
 801d20a:	d003      	beq.n	801d214 <master_selection+0x148>
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
 801d20c:	6878      	ldr	r0, [r7, #4]
 801d20e:	f000 fc9f 	bl	801db50 <jinit_merged_upsampler>
 801d212:	e005      	b.n	801d220 <master_selection+0x154>
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
 801d214:	6878      	ldr	r0, [r7, #4]
 801d216:	f7f9 f8b1 	bl	801637c <jinit_color_deconverter>
      jinit_upsampler(cinfo);
 801d21a:	6878      	ldr	r0, [r7, #4]
 801d21c:	f001 f88c 	bl	801e338 <jinit_upsampler>
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
 801d220:	687b      	ldr	r3, [r7, #4]
 801d222:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d224:	4619      	mov	r1, r3
 801d226:	6878      	ldr	r0, [r7, #4]
 801d228:	f000 fe6c 	bl	801df04 <jinit_d_post_controller>
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
 801d22c:	6878      	ldr	r0, [r7, #4]
 801d22e:	f7f9 fd07 	bl	8016c40 <jinit_inverse_dct>
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code)
 801d232:	687b      	ldr	r3, [r7, #4]
 801d234:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 801d238:	2b00      	cmp	r3, #0
 801d23a:	d003      	beq.n	801d244 <master_selection+0x178>
    jinit_arith_decoder(cinfo);
 801d23c:	6878      	ldr	r0, [r7, #4]
 801d23e:	f7f7 fb05 	bl	801484c <jinit_arith_decoder>
 801d242:	e002      	b.n	801d24a <master_selection+0x17e>
  else {
    jinit_huff_decoder(cinfo);
 801d244:	6878      	ldr	r0, [r7, #4]
 801d246:	f7fb fd73 	bl	8018d30 <jinit_huff_decoder>
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
 801d24a:	687b      	ldr	r3, [r7, #4]
 801d24c:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801d250:	691b      	ldr	r3, [r3, #16]
 801d252:	2b00      	cmp	r3, #0
 801d254:	d103      	bne.n	801d25e <master_selection+0x192>
 801d256:	687b      	ldr	r3, [r7, #4]
 801d258:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801d25a:	2b00      	cmp	r3, #0
 801d25c:	d001      	beq.n	801d262 <master_selection+0x196>
 801d25e:	2301      	movs	r3, #1
 801d260:	e000      	b.n	801d264 <master_selection+0x198>
 801d262:	2300      	movs	r3, #0
 801d264:	60fb      	str	r3, [r7, #12]
  jinit_d_coef_controller(cinfo, use_c_buffer);
 801d266:	68f9      	ldr	r1, [r7, #12]
 801d268:	6878      	ldr	r0, [r7, #4]
 801d26a:	f7f8 fcbd 	bl	8015be8 <jinit_d_coef_controller>

  if (! cinfo->raw_data_out)
 801d26e:	687b      	ldr	r3, [r7, #4]
 801d270:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801d272:	2b00      	cmp	r3, #0
 801d274:	d103      	bne.n	801d27e <master_selection+0x1b2>
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
 801d276:	2100      	movs	r1, #0
 801d278:	6878      	ldr	r0, [r7, #4]
 801d27a:	f7fd fa79 	bl	801a770 <jinit_d_main_controller>

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
 801d27e:	687b      	ldr	r3, [r7, #4]
 801d280:	685b      	ldr	r3, [r3, #4]
 801d282:	699b      	ldr	r3, [r3, #24]
 801d284:	6878      	ldr	r0, [r7, #4]
 801d286:	4798      	blx	r3

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);
 801d288:	687b      	ldr	r3, [r7, #4]
 801d28a:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801d28e:	689b      	ldr	r3, [r3, #8]
 801d290:	6878      	ldr	r0, [r7, #4]
 801d292:	4798      	blx	r3
#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 801d294:	687b      	ldr	r3, [r7, #4]
 801d296:	689b      	ldr	r3, [r3, #8]
 801d298:	2b00      	cmp	r3, #0
 801d29a:	d03a      	beq.n	801d312 <master_selection+0x246>
 801d29c:	687b      	ldr	r3, [r7, #4]
 801d29e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801d2a0:	2b00      	cmp	r3, #0
 801d2a2:	d136      	bne.n	801d312 <master_selection+0x246>
      cinfo->inputctl->has_multiple_scans) {
 801d2a4:	687b      	ldr	r3, [r7, #4]
 801d2a6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801d2aa:	691b      	ldr	r3, [r3, #16]
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 801d2ac:	2b00      	cmp	r3, #0
 801d2ae:	d030      	beq.n	801d312 <master_selection+0x246>
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
 801d2b0:	687b      	ldr	r3, [r7, #4]
 801d2b2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801d2b6:	2b00      	cmp	r3, #0
 801d2b8:	d007      	beq.n	801d2ca <master_selection+0x1fe>
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
 801d2ba:	687b      	ldr	r3, [r7, #4]
 801d2bc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801d2be:	4613      	mov	r3, r2
 801d2c0:	005b      	lsls	r3, r3, #1
 801d2c2:	4413      	add	r3, r2
 801d2c4:	3302      	adds	r3, #2
 801d2c6:	61fb      	str	r3, [r7, #28]
 801d2c8:	e002      	b.n	801d2d0 <master_selection+0x204>
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
 801d2ca:	687b      	ldr	r3, [r7, #4]
 801d2cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801d2ce:	61fb      	str	r3, [r7, #28]
    }
    cinfo->progress->pass_counter = 0L;
 801d2d0:	687b      	ldr	r3, [r7, #4]
 801d2d2:	689b      	ldr	r3, [r3, #8]
 801d2d4:	2200      	movs	r2, #0
 801d2d6:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
 801d2d8:	687b      	ldr	r3, [r7, #4]
 801d2da:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 801d2de:	4619      	mov	r1, r3
 801d2e0:	687b      	ldr	r3, [r7, #4]
 801d2e2:	689b      	ldr	r3, [r3, #8]
 801d2e4:	69fa      	ldr	r2, [r7, #28]
 801d2e6:	fb01 f202 	mul.w	r2, r1, r2
 801d2ea:	609a      	str	r2, [r3, #8]
    cinfo->progress->completed_passes = 0;
 801d2ec:	687b      	ldr	r3, [r7, #4]
 801d2ee:	689b      	ldr	r3, [r3, #8]
 801d2f0:	2200      	movs	r2, #0
 801d2f2:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
 801d2f4:	687b      	ldr	r3, [r7, #4]
 801d2f6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d2f8:	2b00      	cmp	r3, #0
 801d2fa:	d001      	beq.n	801d300 <master_selection+0x234>
 801d2fc:	2203      	movs	r2, #3
 801d2fe:	e000      	b.n	801d302 <master_selection+0x236>
 801d300:	2202      	movs	r2, #2
 801d302:	687b      	ldr	r3, [r7, #4]
 801d304:	689b      	ldr	r3, [r3, #8]
 801d306:	611a      	str	r2, [r3, #16]
    /* Count the input pass as done */
    master->pass_number++;
 801d308:	69bb      	ldr	r3, [r7, #24]
 801d30a:	68db      	ldr	r3, [r3, #12]
 801d30c:	1c5a      	adds	r2, r3, #1
 801d30e:	69bb      	ldr	r3, [r7, #24]
 801d310:	60da      	str	r2, [r3, #12]
  }
#endif /* D_MULTISCAN_FILES_SUPPORTED */
}
 801d312:	bf00      	nop
 801d314:	3720      	adds	r7, #32
 801d316:	46bd      	mov	sp, r7
 801d318:	bd80      	pop	{r7, pc}

0801d31a <prepare_for_output_pass>:
 * (In the latter case, jdapistd.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
 801d31a:	b580      	push	{r7, lr}
 801d31c:	b084      	sub	sp, #16
 801d31e:	af00      	add	r7, sp, #0
 801d320:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801d322:	687b      	ldr	r3, [r7, #4]
 801d324:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801d328:	60fb      	str	r3, [r7, #12]

  if (master->pub.is_dummy_pass) {
 801d32a:	68fb      	ldr	r3, [r7, #12]
 801d32c:	689b      	ldr	r3, [r3, #8]
 801d32e:	2b00      	cmp	r3, #0
 801d330:	d018      	beq.n	801d364 <prepare_for_output_pass+0x4a>
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
 801d332:	68fb      	ldr	r3, [r7, #12]
 801d334:	2200      	movs	r2, #0
 801d336:	609a      	str	r2, [r3, #8]
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
 801d338:	687b      	ldr	r3, [r7, #4]
 801d33a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801d33e:	681b      	ldr	r3, [r3, #0]
 801d340:	2100      	movs	r1, #0
 801d342:	6878      	ldr	r0, [r7, #4]
 801d344:	4798      	blx	r3
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
 801d346:	687b      	ldr	r3, [r7, #4]
 801d348:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801d34c:	681b      	ldr	r3, [r3, #0]
 801d34e:	2102      	movs	r1, #2
 801d350:	6878      	ldr	r0, [r7, #4]
 801d352:	4798      	blx	r3
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
 801d354:	687b      	ldr	r3, [r7, #4]
 801d356:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801d35a:	681b      	ldr	r3, [r3, #0]
 801d35c:	2102      	movs	r1, #2
 801d35e:	6878      	ldr	r0, [r7, #4]
 801d360:	4798      	blx	r3
 801d362:	e06e      	b.n	801d442 <prepare_for_output_pass+0x128>
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
 801d364:	687b      	ldr	r3, [r7, #4]
 801d366:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d368:	2b00      	cmp	r3, #0
 801d36a:	d028      	beq.n	801d3be <prepare_for_output_pass+0xa4>
 801d36c:	687b      	ldr	r3, [r7, #4]
 801d36e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801d372:	2b00      	cmp	r3, #0
 801d374:	d123      	bne.n	801d3be <prepare_for_output_pass+0xa4>
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
 801d376:	687b      	ldr	r3, [r7, #4]
 801d378:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801d37a:	2b00      	cmp	r3, #0
 801d37c:	d00c      	beq.n	801d398 <prepare_for_output_pass+0x7e>
 801d37e:	687b      	ldr	r3, [r7, #4]
 801d380:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d382:	2b00      	cmp	r3, #0
 801d384:	d008      	beq.n	801d398 <prepare_for_output_pass+0x7e>
	cinfo->cquantize = master->quantizer_2pass;
 801d386:	68fb      	ldr	r3, [r7, #12]
 801d388:	699a      	ldr	r2, [r3, #24]
 801d38a:	687b      	ldr	r3, [r7, #4]
 801d38c:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
	master->pub.is_dummy_pass = TRUE;
 801d390:	68fb      	ldr	r3, [r7, #12]
 801d392:	2201      	movs	r2, #1
 801d394:	609a      	str	r2, [r3, #8]
 801d396:	e012      	b.n	801d3be <prepare_for_output_pass+0xa4>
      } else if (cinfo->enable_1pass_quant) {
 801d398:	687b      	ldr	r3, [r7, #4]
 801d39a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801d39c:	2b00      	cmp	r3, #0
 801d39e:	d005      	beq.n	801d3ac <prepare_for_output_pass+0x92>
	cinfo->cquantize = master->quantizer_1pass;
 801d3a0:	68fb      	ldr	r3, [r7, #12]
 801d3a2:	695a      	ldr	r2, [r3, #20]
 801d3a4:	687b      	ldr	r3, [r7, #4]
 801d3a6:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
 801d3aa:	e008      	b.n	801d3be <prepare_for_output_pass+0xa4>
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
 801d3ac:	687b      	ldr	r3, [r7, #4]
 801d3ae:	681b      	ldr	r3, [r3, #0]
 801d3b0:	222f      	movs	r2, #47	@ 0x2f
 801d3b2:	615a      	str	r2, [r3, #20]
 801d3b4:	687b      	ldr	r3, [r7, #4]
 801d3b6:	681b      	ldr	r3, [r3, #0]
 801d3b8:	681b      	ldr	r3, [r3, #0]
 801d3ba:	6878      	ldr	r0, [r7, #4]
 801d3bc:	4798      	blx	r3
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
 801d3be:	687b      	ldr	r3, [r7, #4]
 801d3c0:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
 801d3c4:	681b      	ldr	r3, [r3, #0]
 801d3c6:	6878      	ldr	r0, [r7, #4]
 801d3c8:	4798      	blx	r3
    (*cinfo->coef->start_output_pass) (cinfo);
 801d3ca:	687b      	ldr	r3, [r7, #4]
 801d3cc:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 801d3d0:	689b      	ldr	r3, [r3, #8]
 801d3d2:	6878      	ldr	r0, [r7, #4]
 801d3d4:	4798      	blx	r3
    if (! cinfo->raw_data_out) {
 801d3d6:	687b      	ldr	r3, [r7, #4]
 801d3d8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801d3da:	2b00      	cmp	r3, #0
 801d3dc:	d131      	bne.n	801d442 <prepare_for_output_pass+0x128>
      if (! master->using_merged_upsample)
 801d3de:	68fb      	ldr	r3, [r7, #12]
 801d3e0:	691b      	ldr	r3, [r3, #16]
 801d3e2:	2b00      	cmp	r3, #0
 801d3e4:	d105      	bne.n	801d3f2 <prepare_for_output_pass+0xd8>
	(*cinfo->cconvert->start_pass) (cinfo);
 801d3e6:	687b      	ldr	r3, [r7, #4]
 801d3e8:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 801d3ec:	681b      	ldr	r3, [r3, #0]
 801d3ee:	6878      	ldr	r0, [r7, #4]
 801d3f0:	4798      	blx	r3
      (*cinfo->upsample->start_pass) (cinfo);
 801d3f2:	687b      	ldr	r3, [r7, #4]
 801d3f4:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d3f8:	681b      	ldr	r3, [r3, #0]
 801d3fa:	6878      	ldr	r0, [r7, #4]
 801d3fc:	4798      	blx	r3
      if (cinfo->quantize_colors)
 801d3fe:	687b      	ldr	r3, [r7, #4]
 801d400:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d402:	2b00      	cmp	r3, #0
 801d404:	d008      	beq.n	801d418 <prepare_for_output_pass+0xfe>
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
 801d406:	687b      	ldr	r3, [r7, #4]
 801d408:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801d40c:	681b      	ldr	r3, [r3, #0]
 801d40e:	68fa      	ldr	r2, [r7, #12]
 801d410:	6892      	ldr	r2, [r2, #8]
 801d412:	4611      	mov	r1, r2
 801d414:	6878      	ldr	r0, [r7, #4]
 801d416:	4798      	blx	r3
      (*cinfo->post->start_pass) (cinfo,
 801d418:	687b      	ldr	r3, [r7, #4]
 801d41a:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801d41e:	681b      	ldr	r3, [r3, #0]
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
 801d420:	68fa      	ldr	r2, [r7, #12]
 801d422:	6892      	ldr	r2, [r2, #8]
      (*cinfo->post->start_pass) (cinfo,
 801d424:	2a00      	cmp	r2, #0
 801d426:	d001      	beq.n	801d42c <prepare_for_output_pass+0x112>
 801d428:	2203      	movs	r2, #3
 801d42a:	e000      	b.n	801d42e <prepare_for_output_pass+0x114>
 801d42c:	2200      	movs	r2, #0
 801d42e:	4611      	mov	r1, r2
 801d430:	6878      	ldr	r0, [r7, #4]
 801d432:	4798      	blx	r3
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
 801d434:	687b      	ldr	r3, [r7, #4]
 801d436:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 801d43a:	681b      	ldr	r3, [r3, #0]
 801d43c:	2100      	movs	r1, #0
 801d43e:	6878      	ldr	r0, [r7, #4]
 801d440:	4798      	blx	r3
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
 801d442:	687b      	ldr	r3, [r7, #4]
 801d444:	689b      	ldr	r3, [r3, #8]
 801d446:	2b00      	cmp	r3, #0
 801d448:	d029      	beq.n	801d49e <prepare_for_output_pass+0x184>
    cinfo->progress->completed_passes = master->pass_number;
 801d44a:	687b      	ldr	r3, [r7, #4]
 801d44c:	689b      	ldr	r3, [r3, #8]
 801d44e:	68fa      	ldr	r2, [r7, #12]
 801d450:	68d2      	ldr	r2, [r2, #12]
 801d452:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = master->pass_number +
 801d454:	68fb      	ldr	r3, [r7, #12]
 801d456:	68da      	ldr	r2, [r3, #12]
				    (master->pub.is_dummy_pass ? 2 : 1);
 801d458:	68fb      	ldr	r3, [r7, #12]
 801d45a:	689b      	ldr	r3, [r3, #8]
 801d45c:	2b00      	cmp	r3, #0
 801d45e:	d001      	beq.n	801d464 <prepare_for_output_pass+0x14a>
 801d460:	2102      	movs	r1, #2
 801d462:	e000      	b.n	801d466 <prepare_for_output_pass+0x14c>
 801d464:	2101      	movs	r1, #1
    cinfo->progress->total_passes = master->pass_number +
 801d466:	687b      	ldr	r3, [r7, #4]
 801d468:	689b      	ldr	r3, [r3, #8]
 801d46a:	440a      	add	r2, r1
 801d46c:	611a      	str	r2, [r3, #16]
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
 801d46e:	687b      	ldr	r3, [r7, #4]
 801d470:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801d472:	2b00      	cmp	r3, #0
 801d474:	d013      	beq.n	801d49e <prepare_for_output_pass+0x184>
 801d476:	687b      	ldr	r3, [r7, #4]
 801d478:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 801d47c:	695b      	ldr	r3, [r3, #20]
 801d47e:	2b00      	cmp	r3, #0
 801d480:	d10d      	bne.n	801d49e <prepare_for_output_pass+0x184>
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
 801d482:	687b      	ldr	r3, [r7, #4]
 801d484:	689b      	ldr	r3, [r3, #8]
 801d486:	691a      	ldr	r2, [r3, #16]
 801d488:	687b      	ldr	r3, [r7, #4]
 801d48a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d48c:	2b00      	cmp	r3, #0
 801d48e:	d001      	beq.n	801d494 <prepare_for_output_pass+0x17a>
 801d490:	2102      	movs	r1, #2
 801d492:	e000      	b.n	801d496 <prepare_for_output_pass+0x17c>
 801d494:	2101      	movs	r1, #1
 801d496:	687b      	ldr	r3, [r7, #4]
 801d498:	689b      	ldr	r3, [r3, #8]
 801d49a:	440a      	add	r2, r1
 801d49c:	611a      	str	r2, [r3, #16]
    }
  }
}
 801d49e:	bf00      	nop
 801d4a0:	3710      	adds	r7, #16
 801d4a2:	46bd      	mov	sp, r7
 801d4a4:	bd80      	pop	{r7, pc}

0801d4a6 <finish_output_pass>:
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
 801d4a6:	b580      	push	{r7, lr}
 801d4a8:	b084      	sub	sp, #16
 801d4aa:	af00      	add	r7, sp, #0
 801d4ac:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801d4ae:	687b      	ldr	r3, [r7, #4]
 801d4b0:	f8d3 31b8 	ldr.w	r3, [r3, #440]	@ 0x1b8
 801d4b4:	60fb      	str	r3, [r7, #12]

  if (cinfo->quantize_colors)
 801d4b6:	687b      	ldr	r3, [r7, #4]
 801d4b8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801d4ba:	2b00      	cmp	r3, #0
 801d4bc:	d005      	beq.n	801d4ca <finish_output_pass+0x24>
    (*cinfo->cquantize->finish_pass) (cinfo);
 801d4be:	687b      	ldr	r3, [r7, #4]
 801d4c0:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801d4c4:	689b      	ldr	r3, [r3, #8]
 801d4c6:	6878      	ldr	r0, [r7, #4]
 801d4c8:	4798      	blx	r3
  master->pass_number++;
 801d4ca:	68fb      	ldr	r3, [r7, #12]
 801d4cc:	68db      	ldr	r3, [r3, #12]
 801d4ce:	1c5a      	adds	r2, r3, #1
 801d4d0:	68fb      	ldr	r3, [r7, #12]
 801d4d2:	60da      	str	r2, [r3, #12]
}
 801d4d4:	bf00      	nop
 801d4d6:	3710      	adds	r7, #16
 801d4d8:	46bd      	mov	sp, r7
 801d4da:	bd80      	pop	{r7, pc}

0801d4dc <jinit_master_decompress>:
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
 801d4dc:	b580      	push	{r7, lr}
 801d4de:	b084      	sub	sp, #16
 801d4e0:	af00      	add	r7, sp, #0
 801d4e2:	6078      	str	r0, [r7, #4]
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d4e4:	687b      	ldr	r3, [r7, #4]
 801d4e6:	685b      	ldr	r3, [r3, #4]
 801d4e8:	681b      	ldr	r3, [r3, #0]
 801d4ea:	221c      	movs	r2, #28
 801d4ec:	2101      	movs	r1, #1
 801d4ee:	6878      	ldr	r0, [r7, #4]
 801d4f0:	4798      	blx	r3
 801d4f2:	60f8      	str	r0, [r7, #12]
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
 801d4f4:	687b      	ldr	r3, [r7, #4]
 801d4f6:	68fa      	ldr	r2, [r7, #12]
 801d4f8:	f8c3 21b8 	str.w	r2, [r3, #440]	@ 0x1b8
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
 801d4fc:	68fb      	ldr	r3, [r7, #12]
 801d4fe:	4a07      	ldr	r2, [pc, #28]	@ (801d51c <jinit_master_decompress+0x40>)
 801d500:	601a      	str	r2, [r3, #0]
  master->pub.finish_output_pass = finish_output_pass;
 801d502:	68fb      	ldr	r3, [r7, #12]
 801d504:	4a06      	ldr	r2, [pc, #24]	@ (801d520 <jinit_master_decompress+0x44>)
 801d506:	605a      	str	r2, [r3, #4]

  master->pub.is_dummy_pass = FALSE;
 801d508:	68fb      	ldr	r3, [r7, #12]
 801d50a:	2200      	movs	r2, #0
 801d50c:	609a      	str	r2, [r3, #8]

  master_selection(cinfo);
 801d50e:	6878      	ldr	r0, [r7, #4]
 801d510:	f7ff fddc 	bl	801d0cc <master_selection>
}
 801d514:	bf00      	nop
 801d516:	3710      	adds	r7, #16
 801d518:	46bd      	mov	sp, r7
 801d51a:	bd80      	pop	{r7, pc}
 801d51c:	0801d31b 	.word	0x0801d31b
 801d520:	0801d4a7 	.word	0x0801d4a7

0801d524 <build_ycc_rgb_table>:
 * This is taken directly from jdcolor.c; see that file for more info.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 801d524:	b580      	push	{r7, lr}
 801d526:	b086      	sub	sp, #24
 801d528:	af00      	add	r7, sp, #0
 801d52a:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d52c:	687b      	ldr	r3, [r7, #4]
 801d52e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d532:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d534:	687b      	ldr	r3, [r7, #4]
 801d536:	685b      	ldr	r3, [r3, #4]
 801d538:	681b      	ldr	r3, [r3, #0]
 801d53a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801d53e:	2101      	movs	r1, #1
 801d540:	6878      	ldr	r0, [r7, #4]
 801d542:	4798      	blx	r3
 801d544:	4602      	mov	r2, r0
  upsample->Cr_r_tab = (int *)
 801d546:	68fb      	ldr	r3, [r7, #12]
 801d548:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d54a:	687b      	ldr	r3, [r7, #4]
 801d54c:	685b      	ldr	r3, [r3, #4]
 801d54e:	681b      	ldr	r3, [r3, #0]
 801d550:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801d554:	2101      	movs	r1, #1
 801d556:	6878      	ldr	r0, [r7, #4]
 801d558:	4798      	blx	r3
 801d55a:	4602      	mov	r2, r0
  upsample->Cb_b_tab = (int *)
 801d55c:	68fb      	ldr	r3, [r7, #12]
 801d55e:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d560:	687b      	ldr	r3, [r7, #4]
 801d562:	685b      	ldr	r3, [r3, #4]
 801d564:	681b      	ldr	r3, [r3, #0]
 801d566:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801d56a:	2101      	movs	r1, #1
 801d56c:	6878      	ldr	r0, [r7, #4]
 801d56e:	4798      	blx	r3
 801d570:	4602      	mov	r2, r0
  upsample->Cr_g_tab = (INT32 *)
 801d572:	68fb      	ldr	r3, [r7, #12]
 801d574:	619a      	str	r2, [r3, #24]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801d576:	687b      	ldr	r3, [r7, #4]
 801d578:	685b      	ldr	r3, [r3, #4]
 801d57a:	681b      	ldr	r3, [r3, #0]
 801d57c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801d580:	2101      	movs	r1, #1
 801d582:	6878      	ldr	r0, [r7, #4]
 801d584:	4798      	blx	r3
 801d586:	4602      	mov	r2, r0
  upsample->Cb_g_tab = (INT32 *)
 801d588:	68fb      	ldr	r3, [r7, #12]
 801d58a:	61da      	str	r2, [r3, #28]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 801d58c:	2300      	movs	r3, #0
 801d58e:	617b      	str	r3, [r7, #20]
 801d590:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 801d594:	613b      	str	r3, [r7, #16]
 801d596:	e035      	b.n	801d604 <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 801d598:	693b      	ldr	r3, [r7, #16]
 801d59a:	4a1e      	ldr	r2, [pc, #120]	@ (801d614 <build_ycc_rgb_table+0xf0>)
 801d59c:	fb02 f303 	mul.w	r3, r2, r3
 801d5a0:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    upsample->Cr_r_tab[i] = (int)
 801d5a4:	68fb      	ldr	r3, [r7, #12]
 801d5a6:	6919      	ldr	r1, [r3, #16]
 801d5a8:	697b      	ldr	r3, [r7, #20]
 801d5aa:	009b      	lsls	r3, r3, #2
 801d5ac:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 801d5ae:	1412      	asrs	r2, r2, #16
    upsample->Cr_r_tab[i] = (int)
 801d5b0:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 801d5b2:	693b      	ldr	r3, [r7, #16]
 801d5b4:	4a18      	ldr	r2, [pc, #96]	@ (801d618 <build_ycc_rgb_table+0xf4>)
 801d5b6:	fb02 f303 	mul.w	r3, r2, r3
 801d5ba:	f503 4200 	add.w	r2, r3, #32768	@ 0x8000
    upsample->Cb_b_tab[i] = (int)
 801d5be:	68fb      	ldr	r3, [r7, #12]
 801d5c0:	6959      	ldr	r1, [r3, #20]
 801d5c2:	697b      	ldr	r3, [r7, #20]
 801d5c4:	009b      	lsls	r3, r3, #2
 801d5c6:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 801d5c8:	1412      	asrs	r2, r2, #16
    upsample->Cb_b_tab[i] = (int)
 801d5ca:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 801d5cc:	68fb      	ldr	r3, [r7, #12]
 801d5ce:	699a      	ldr	r2, [r3, #24]
 801d5d0:	697b      	ldr	r3, [r7, #20]
 801d5d2:	009b      	lsls	r3, r3, #2
 801d5d4:	4413      	add	r3, r2
 801d5d6:	693a      	ldr	r2, [r7, #16]
 801d5d8:	4910      	ldr	r1, [pc, #64]	@ (801d61c <build_ycc_rgb_table+0xf8>)
 801d5da:	fb01 f202 	mul.w	r2, r1, r2
 801d5de:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 801d5e0:	693b      	ldr	r3, [r7, #16]
 801d5e2:	4a0f      	ldr	r2, [pc, #60]	@ (801d620 <build_ycc_rgb_table+0xfc>)
 801d5e4:	fb03 f202 	mul.w	r2, r3, r2
 801d5e8:	68fb      	ldr	r3, [r7, #12]
 801d5ea:	69d9      	ldr	r1, [r3, #28]
 801d5ec:	697b      	ldr	r3, [r7, #20]
 801d5ee:	009b      	lsls	r3, r3, #2
 801d5f0:	440b      	add	r3, r1
 801d5f2:	f502 4200 	add.w	r2, r2, #32768	@ 0x8000
 801d5f6:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 801d5f8:	697b      	ldr	r3, [r7, #20]
 801d5fa:	3301      	adds	r3, #1
 801d5fc:	617b      	str	r3, [r7, #20]
 801d5fe:	693b      	ldr	r3, [r7, #16]
 801d600:	3301      	adds	r3, #1
 801d602:	613b      	str	r3, [r7, #16]
 801d604:	697b      	ldr	r3, [r7, #20]
 801d606:	2bff      	cmp	r3, #255	@ 0xff
 801d608:	ddc6      	ble.n	801d598 <build_ycc_rgb_table+0x74>
  }
}
 801d60a:	bf00      	nop
 801d60c:	bf00      	nop
 801d60e:	3718      	adds	r7, #24
 801d610:	46bd      	mov	sp, r7
 801d612:	bd80      	pop	{r7, pc}
 801d614:	000166e9 	.word	0x000166e9
 801d618:	0001c5a2 	.word	0x0001c5a2
 801d61c:	ffff492e 	.word	0xffff492e
 801d620:	ffffa7e6 	.word	0xffffa7e6

0801d624 <start_pass_merged_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
 801d624:	b480      	push	{r7}
 801d626:	b085      	sub	sp, #20
 801d628:	af00      	add	r7, sp, #0
 801d62a:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d62c:	687b      	ldr	r3, [r7, #4]
 801d62e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d632:	60fb      	str	r3, [r7, #12]

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
 801d634:	68fb      	ldr	r3, [r7, #12]
 801d636:	2200      	movs	r2, #0
 801d638:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 801d63a:	687b      	ldr	r3, [r7, #4]
 801d63c:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801d63e:	68fb      	ldr	r3, [r7, #12]
 801d640:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 801d642:	bf00      	nop
 801d644:	3714      	adds	r7, #20
 801d646:	46bd      	mov	sp, r7
 801d648:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d64c:	4770      	bx	lr

0801d64e <merged_2v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
 801d64e:	b590      	push	{r4, r7, lr}
 801d650:	b08b      	sub	sp, #44	@ 0x2c
 801d652:	af02      	add	r7, sp, #8
 801d654:	60f8      	str	r0, [r7, #12]
 801d656:	60b9      	str	r1, [r7, #8]
 801d658:	607a      	str	r2, [r7, #4]
 801d65a:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d65c:	68fb      	ldr	r3, [r7, #12]
 801d65e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d662:	61bb      	str	r3, [r7, #24]
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
 801d664:	69bb      	ldr	r3, [r7, #24]
 801d666:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801d668:	2b00      	cmp	r3, #0
 801d66a:	d016      	beq.n	801d69a <merged_2v_upsample+0x4c>
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
 801d66c:	69bb      	ldr	r3, [r7, #24]
 801d66e:	f103 0020 	add.w	r0, r3, #32
 801d672:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d674:	681b      	ldr	r3, [r3, #0]
 801d676:	009b      	lsls	r3, r3, #2
 801d678:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801d67a:	441a      	add	r2, r3
 801d67c:	69bb      	ldr	r3, [r7, #24]
 801d67e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801d680:	9301      	str	r3, [sp, #4]
 801d682:	2301      	movs	r3, #1
 801d684:	9300      	str	r3, [sp, #0]
 801d686:	2300      	movs	r3, #0
 801d688:	2100      	movs	r1, #0
 801d68a:	f011 fd2b 	bl	802f0e4 <jcopy_sample_rows>
		      1, upsample->out_row_width);
    num_rows = 1;
 801d68e:	2301      	movs	r3, #1
 801d690:	61fb      	str	r3, [r7, #28]
    upsample->spare_full = FALSE;
 801d692:	69bb      	ldr	r3, [r7, #24]
 801d694:	2200      	movs	r2, #0
 801d696:	625a      	str	r2, [r3, #36]	@ 0x24
 801d698:	e036      	b.n	801d708 <merged_2v_upsample+0xba>
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
 801d69a:	2302      	movs	r3, #2
 801d69c:	61fb      	str	r3, [r7, #28]
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
 801d69e:	69bb      	ldr	r3, [r7, #24]
 801d6a0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801d6a2:	69fa      	ldr	r2, [r7, #28]
 801d6a4:	429a      	cmp	r2, r3
 801d6a6:	d902      	bls.n	801d6ae <merged_2v_upsample+0x60>
      num_rows = upsample->rows_to_go;
 801d6a8:	69bb      	ldr	r3, [r7, #24]
 801d6aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801d6ac:	61fb      	str	r3, [r7, #28]
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
 801d6ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d6b0:	681b      	ldr	r3, [r3, #0]
 801d6b2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801d6b4:	1ad3      	subs	r3, r2, r3
 801d6b6:	63bb      	str	r3, [r7, #56]	@ 0x38
    if (num_rows > out_rows_avail)
 801d6b8:	69fa      	ldr	r2, [r7, #28]
 801d6ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6bc:	429a      	cmp	r2, r3
 801d6be:	d901      	bls.n	801d6c4 <merged_2v_upsample+0x76>
      num_rows = out_rows_avail;
 801d6c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6c2:	61fb      	str	r3, [r7, #28]
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
 801d6c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d6c6:	681b      	ldr	r3, [r3, #0]
 801d6c8:	009b      	lsls	r3, r3, #2
 801d6ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801d6cc:	4413      	add	r3, r2
 801d6ce:	681b      	ldr	r3, [r3, #0]
 801d6d0:	613b      	str	r3, [r7, #16]
    if (num_rows > 1) {
 801d6d2:	69fb      	ldr	r3, [r7, #28]
 801d6d4:	2b01      	cmp	r3, #1
 801d6d6:	d908      	bls.n	801d6ea <merged_2v_upsample+0x9c>
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
 801d6d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d6da:	681b      	ldr	r3, [r3, #0]
 801d6dc:	3301      	adds	r3, #1
 801d6de:	009b      	lsls	r3, r3, #2
 801d6e0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801d6e2:	4413      	add	r3, r2
 801d6e4:	681b      	ldr	r3, [r3, #0]
 801d6e6:	617b      	str	r3, [r7, #20]
 801d6e8:	e005      	b.n	801d6f6 <merged_2v_upsample+0xa8>
    } else {
      work_ptrs[1] = upsample->spare_row;
 801d6ea:	69bb      	ldr	r3, [r7, #24]
 801d6ec:	6a1b      	ldr	r3, [r3, #32]
 801d6ee:	617b      	str	r3, [r7, #20]
      upsample->spare_full = TRUE;
 801d6f0:	69bb      	ldr	r3, [r7, #24]
 801d6f2:	2201      	movs	r2, #1
 801d6f4:	625a      	str	r2, [r3, #36]	@ 0x24
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
 801d6f6:	69bb      	ldr	r3, [r7, #24]
 801d6f8:	68dc      	ldr	r4, [r3, #12]
 801d6fa:	687b      	ldr	r3, [r7, #4]
 801d6fc:	681a      	ldr	r2, [r3, #0]
 801d6fe:	f107 0310 	add.w	r3, r7, #16
 801d702:	68b9      	ldr	r1, [r7, #8]
 801d704:	68f8      	ldr	r0, [r7, #12]
 801d706:	47a0      	blx	r4
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
 801d708:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d70a:	681a      	ldr	r2, [r3, #0]
 801d70c:	69fb      	ldr	r3, [r7, #28]
 801d70e:	441a      	add	r2, r3
 801d710:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d712:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 801d714:	69bb      	ldr	r3, [r7, #24]
 801d716:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801d718:	69fb      	ldr	r3, [r7, #28]
 801d71a:	1ad2      	subs	r2, r2, r3
 801d71c:	69bb      	ldr	r3, [r7, #24]
 801d71e:	62da      	str	r2, [r3, #44]	@ 0x2c
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
 801d720:	69bb      	ldr	r3, [r7, #24]
 801d722:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801d724:	2b00      	cmp	r3, #0
 801d726:	d104      	bne.n	801d732 <merged_2v_upsample+0xe4>
    (*in_row_group_ctr)++;
 801d728:	687b      	ldr	r3, [r7, #4]
 801d72a:	681b      	ldr	r3, [r3, #0]
 801d72c:	1c5a      	adds	r2, r3, #1
 801d72e:	687b      	ldr	r3, [r7, #4]
 801d730:	601a      	str	r2, [r3, #0]
}
 801d732:	bf00      	nop
 801d734:	3724      	adds	r7, #36	@ 0x24
 801d736:	46bd      	mov	sp, r7
 801d738:	bd90      	pop	{r4, r7, pc}

0801d73a <merged_1v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
 801d73a:	b590      	push	{r4, r7, lr}
 801d73c:	b087      	sub	sp, #28
 801d73e:	af00      	add	r7, sp, #0
 801d740:	60f8      	str	r0, [r7, #12]
 801d742:	60b9      	str	r1, [r7, #8]
 801d744:	607a      	str	r2, [r7, #4]
 801d746:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d748:	68fb      	ldr	r3, [r7, #12]
 801d74a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d74e:	617b      	str	r3, [r7, #20]

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801d750:	697b      	ldr	r3, [r7, #20]
 801d752:	68dc      	ldr	r4, [r3, #12]
 801d754:	687b      	ldr	r3, [r7, #4]
 801d756:	6819      	ldr	r1, [r3, #0]
			 output_buf + *out_row_ctr);
 801d758:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d75a:	681b      	ldr	r3, [r3, #0]
 801d75c:	009b      	lsls	r3, r3, #2
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801d75e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d760:	4413      	add	r3, r2
 801d762:	460a      	mov	r2, r1
 801d764:	68b9      	ldr	r1, [r7, #8]
 801d766:	68f8      	ldr	r0, [r7, #12]
 801d768:	47a0      	blx	r4
  /* Adjust counts */
  (*out_row_ctr)++;
 801d76a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d76c:	681b      	ldr	r3, [r3, #0]
 801d76e:	1c5a      	adds	r2, r3, #1
 801d770:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d772:	601a      	str	r2, [r3, #0]
  (*in_row_group_ctr)++;
 801d774:	687b      	ldr	r3, [r7, #4]
 801d776:	681b      	ldr	r3, [r3, #0]
 801d778:	1c5a      	adds	r2, r3, #1
 801d77a:	687b      	ldr	r3, [r7, #4]
 801d77c:	601a      	str	r2, [r3, #0]
}
 801d77e:	bf00      	nop
 801d780:	371c      	adds	r7, #28
 801d782:	46bd      	mov	sp, r7
 801d784:	bd90      	pop	{r4, r7, pc}

0801d786 <h2v1_merged_upsample>:

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 801d786:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801d78a:	b093      	sub	sp, #76	@ 0x4c
 801d78c:	af00      	add	r7, sp, #0
 801d78e:	6178      	str	r0, [r7, #20]
 801d790:	6139      	str	r1, [r7, #16]
 801d792:	60fa      	str	r2, [r7, #12]
 801d794:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d796:	697b      	ldr	r3, [r7, #20]
 801d798:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d79c:	637b      	str	r3, [r7, #52]	@ 0x34
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 801d79e:	697b      	ldr	r3, [r7, #20]
 801d7a0:	f8d3 514c 	ldr.w	r5, [r3, #332]	@ 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 801d7a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d7a6:	691b      	ldr	r3, [r3, #16]
 801d7a8:	633b      	str	r3, [r7, #48]	@ 0x30
  int * Cbbtab = upsample->Cb_b_tab;
 801d7aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d7ac:	695b      	ldr	r3, [r3, #20]
 801d7ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
  INT32 * Crgtab = upsample->Cr_g_tab;
 801d7b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d7b2:	699b      	ldr	r3, [r3, #24]
 801d7b4:	62bb      	str	r3, [r7, #40]	@ 0x28
  INT32 * Cbgtab = upsample->Cb_g_tab;
 801d7b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d7b8:	69db      	ldr	r3, [r3, #28]
 801d7ba:	627b      	str	r3, [r7, #36]	@ 0x24
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
 801d7bc:	693b      	ldr	r3, [r7, #16]
 801d7be:	681a      	ldr	r2, [r3, #0]
 801d7c0:	68fb      	ldr	r3, [r7, #12]
 801d7c2:	009b      	lsls	r3, r3, #2
 801d7c4:	4413      	add	r3, r2
 801d7c6:	681b      	ldr	r3, [r3, #0]
 801d7c8:	647b      	str	r3, [r7, #68]	@ 0x44
  inptr1 = input_buf[1][in_row_group_ctr];
 801d7ca:	693b      	ldr	r3, [r7, #16]
 801d7cc:	3304      	adds	r3, #4
 801d7ce:	681a      	ldr	r2, [r3, #0]
 801d7d0:	68fb      	ldr	r3, [r7, #12]
 801d7d2:	009b      	lsls	r3, r3, #2
 801d7d4:	4413      	add	r3, r2
 801d7d6:	681b      	ldr	r3, [r3, #0]
 801d7d8:	643b      	str	r3, [r7, #64]	@ 0x40
  inptr2 = input_buf[2][in_row_group_ctr];
 801d7da:	693b      	ldr	r3, [r7, #16]
 801d7dc:	3308      	adds	r3, #8
 801d7de:	681a      	ldr	r2, [r3, #0]
 801d7e0:	68fb      	ldr	r3, [r7, #12]
 801d7e2:	009b      	lsls	r3, r3, #2
 801d7e4:	4413      	add	r3, r2
 801d7e6:	681b      	ldr	r3, [r3, #0]
 801d7e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
  outptr = output_buf[0];
 801d7ea:	68bb      	ldr	r3, [r7, #8]
 801d7ec:	681c      	ldr	r4, [r3, #0]
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801d7ee:	697b      	ldr	r3, [r7, #20]
 801d7f0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801d7f2:	085b      	lsrs	r3, r3, #1
 801d7f4:	63bb      	str	r3, [r7, #56]	@ 0x38
 801d7f6:	e050      	b.n	801d89a <h2v1_merged_upsample+0x114>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 801d7f8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d7fa:	1c5a      	adds	r2, r3, #1
 801d7fc:	643a      	str	r2, [r7, #64]	@ 0x40
 801d7fe:	781b      	ldrb	r3, [r3, #0]
 801d800:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2++);
 801d802:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d804:	1c5a      	adds	r2, r3, #1
 801d806:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801d808:	781b      	ldrb	r3, [r3, #0]
 801d80a:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 801d80c:	69fb      	ldr	r3, [r7, #28]
 801d80e:	009b      	lsls	r3, r3, #2
 801d810:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801d812:	4413      	add	r3, r2
 801d814:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801d816:	6a3b      	ldr	r3, [r7, #32]
 801d818:	009b      	lsls	r3, r3, #2
 801d81a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801d81c:	4413      	add	r3, r2
 801d81e:	681a      	ldr	r2, [r3, #0]
 801d820:	69fb      	ldr	r3, [r7, #28]
 801d822:	009b      	lsls	r3, r3, #2
 801d824:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d826:	440b      	add	r3, r1
 801d828:	681b      	ldr	r3, [r3, #0]
 801d82a:	4413      	add	r3, r2
 801d82c:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801d830:	6a3b      	ldr	r3, [r7, #32]
 801d832:	009b      	lsls	r3, r3, #2
 801d834:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801d836:	4413      	add	r3, r2
 801d838:	681b      	ldr	r3, [r3, #0]
 801d83a:	607b      	str	r3, [r7, #4]
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
 801d83c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d83e:	1c5a      	adds	r2, r3, #1
 801d840:	647a      	str	r2, [r7, #68]	@ 0x44
 801d842:	781b      	ldrb	r3, [r3, #0]
 801d844:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801d846:	4601      	mov	r1, r0
 801d848:	1873      	adds	r3, r6, r1
 801d84a:	442b      	add	r3, r5
 801d84c:	781b      	ldrb	r3, [r3, #0]
 801d84e:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801d850:	eb06 0308 	add.w	r3, r6, r8
 801d854:	18ea      	adds	r2, r5, r3
 801d856:	1c63      	adds	r3, r4, #1
 801d858:	7812      	ldrb	r2, [r2, #0]
 801d85a:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801d85c:	6878      	ldr	r0, [r7, #4]
 801d85e:	1833      	adds	r3, r6, r0
 801d860:	18ea      	adds	r2, r5, r3
 801d862:	1ca3      	adds	r3, r4, #2
 801d864:	7812      	ldrb	r2, [r2, #0]
 801d866:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 801d868:	3403      	adds	r4, #3
    y  = GETJSAMPLE(*inptr0++);
 801d86a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d86c:	1c5a      	adds	r2, r3, #1
 801d86e:	647a      	str	r2, [r7, #68]	@ 0x44
 801d870:	781b      	ldrb	r3, [r3, #0]
 801d872:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801d874:	1873      	adds	r3, r6, r1
 801d876:	442b      	add	r3, r5
 801d878:	781b      	ldrb	r3, [r3, #0]
 801d87a:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801d87c:	eb06 0308 	add.w	r3, r6, r8
 801d880:	18ea      	adds	r2, r5, r3
 801d882:	1c63      	adds	r3, r4, #1
 801d884:	7812      	ldrb	r2, [r2, #0]
 801d886:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801d888:	1833      	adds	r3, r6, r0
 801d88a:	18ea      	adds	r2, r5, r3
 801d88c:	1ca3      	adds	r3, r4, #2
 801d88e:	7812      	ldrb	r2, [r2, #0]
 801d890:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 801d892:	3403      	adds	r4, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801d894:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d896:	3b01      	subs	r3, #1
 801d898:	63bb      	str	r3, [r7, #56]	@ 0x38
 801d89a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d89c:	2b00      	cmp	r3, #0
 801d89e:	d1ab      	bne.n	801d7f8 <h2v1_merged_upsample+0x72>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801d8a0:	697b      	ldr	r3, [r7, #20]
 801d8a2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801d8a4:	f003 0301 	and.w	r3, r3, #1
 801d8a8:	2b00      	cmp	r3, #0
 801d8aa:	d02e      	beq.n	801d90a <h2v1_merged_upsample+0x184>
    cb = GETJSAMPLE(*inptr1);
 801d8ac:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d8ae:	781b      	ldrb	r3, [r3, #0]
 801d8b0:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2);
 801d8b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d8b4:	781b      	ldrb	r3, [r3, #0]
 801d8b6:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 801d8b8:	69fb      	ldr	r3, [r7, #28]
 801d8ba:	009b      	lsls	r3, r3, #2
 801d8bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801d8be:	4413      	add	r3, r2
 801d8c0:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801d8c2:	6a3b      	ldr	r3, [r7, #32]
 801d8c4:	009b      	lsls	r3, r3, #2
 801d8c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801d8c8:	4413      	add	r3, r2
 801d8ca:	681a      	ldr	r2, [r3, #0]
 801d8cc:	69fb      	ldr	r3, [r7, #28]
 801d8ce:	009b      	lsls	r3, r3, #2
 801d8d0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d8d2:	440b      	add	r3, r1
 801d8d4:	681b      	ldr	r3, [r3, #0]
 801d8d6:	4413      	add	r3, r2
 801d8d8:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801d8dc:	6a3b      	ldr	r3, [r7, #32]
 801d8de:	009b      	lsls	r3, r3, #2
 801d8e0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801d8e2:	4413      	add	r3, r2
 801d8e4:	6819      	ldr	r1, [r3, #0]
    y  = GETJSAMPLE(*inptr0);
 801d8e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d8e8:	781b      	ldrb	r3, [r3, #0]
 801d8ea:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 801d8ec:	1833      	adds	r3, r6, r0
 801d8ee:	442b      	add	r3, r5
 801d8f0:	781b      	ldrb	r3, [r3, #0]
 801d8f2:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801d8f4:	eb06 0308 	add.w	r3, r6, r8
 801d8f8:	18ea      	adds	r2, r5, r3
 801d8fa:	1c63      	adds	r3, r4, #1
 801d8fc:	7812      	ldrb	r2, [r2, #0]
 801d8fe:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 801d900:	1873      	adds	r3, r6, r1
 801d902:	18ea      	adds	r2, r5, r3
 801d904:	1ca3      	adds	r3, r4, #2
 801d906:	7812      	ldrb	r2, [r2, #0]
 801d908:	701a      	strb	r2, [r3, #0]
  }
}
 801d90a:	bf00      	nop
 801d90c:	374c      	adds	r7, #76	@ 0x4c
 801d90e:	46bd      	mov	sp, r7
 801d910:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 801d914:	4770      	bx	lr

0801d916 <h2v2_merged_upsample>:

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 801d916:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 801d91a:	b093      	sub	sp, #76	@ 0x4c
 801d91c:	af00      	add	r7, sp, #0
 801d91e:	6178      	str	r0, [r7, #20]
 801d920:	6139      	str	r1, [r7, #16]
 801d922:	60fa      	str	r2, [r7, #12]
 801d924:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801d926:	697b      	ldr	r3, [r7, #20]
 801d928:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801d92c:	633b      	str	r3, [r7, #48]	@ 0x30
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 801d92e:	697b      	ldr	r3, [r7, #20]
 801d930:	f8d3 414c 	ldr.w	r4, [r3, #332]	@ 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 801d934:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d936:	691b      	ldr	r3, [r3, #16]
 801d938:	62fb      	str	r3, [r7, #44]	@ 0x2c
  int * Cbbtab = upsample->Cb_b_tab;
 801d93a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d93c:	695b      	ldr	r3, [r3, #20]
 801d93e:	62bb      	str	r3, [r7, #40]	@ 0x28
  INT32 * Crgtab = upsample->Cr_g_tab;
 801d940:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d942:	699b      	ldr	r3, [r3, #24]
 801d944:	627b      	str	r3, [r7, #36]	@ 0x24
  INT32 * Cbgtab = upsample->Cb_g_tab;
 801d946:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d948:	69db      	ldr	r3, [r3, #28]
 801d94a:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
 801d94c:	693b      	ldr	r3, [r7, #16]
 801d94e:	681a      	ldr	r2, [r3, #0]
 801d950:	68fb      	ldr	r3, [r7, #12]
 801d952:	00db      	lsls	r3, r3, #3
 801d954:	4413      	add	r3, r2
 801d956:	681b      	ldr	r3, [r3, #0]
 801d958:	647b      	str	r3, [r7, #68]	@ 0x44
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
 801d95a:	693b      	ldr	r3, [r7, #16]
 801d95c:	681a      	ldr	r2, [r3, #0]
 801d95e:	68fb      	ldr	r3, [r7, #12]
 801d960:	00db      	lsls	r3, r3, #3
 801d962:	3304      	adds	r3, #4
 801d964:	4413      	add	r3, r2
 801d966:	681b      	ldr	r3, [r3, #0]
 801d968:	643b      	str	r3, [r7, #64]	@ 0x40
  inptr1 = input_buf[1][in_row_group_ctr];
 801d96a:	693b      	ldr	r3, [r7, #16]
 801d96c:	3304      	adds	r3, #4
 801d96e:	681a      	ldr	r2, [r3, #0]
 801d970:	68fb      	ldr	r3, [r7, #12]
 801d972:	009b      	lsls	r3, r3, #2
 801d974:	4413      	add	r3, r2
 801d976:	681b      	ldr	r3, [r3, #0]
 801d978:	63fb      	str	r3, [r7, #60]	@ 0x3c
  inptr2 = input_buf[2][in_row_group_ctr];
 801d97a:	693b      	ldr	r3, [r7, #16]
 801d97c:	3308      	adds	r3, #8
 801d97e:	681a      	ldr	r2, [r3, #0]
 801d980:	68fb      	ldr	r3, [r7, #12]
 801d982:	009b      	lsls	r3, r3, #2
 801d984:	4413      	add	r3, r2
 801d986:	681b      	ldr	r3, [r3, #0]
 801d988:	63bb      	str	r3, [r7, #56]	@ 0x38
  outptr0 = output_buf[0];
 801d98a:	68bb      	ldr	r3, [r7, #8]
 801d98c:	681b      	ldr	r3, [r3, #0]
 801d98e:	607b      	str	r3, [r7, #4]
  outptr1 = output_buf[1];
 801d990:	68bb      	ldr	r3, [r7, #8]
 801d992:	685e      	ldr	r6, [r3, #4]
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801d994:	697b      	ldr	r3, [r7, #20]
 801d996:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801d998:	085b      	lsrs	r3, r3, #1
 801d99a:	637b      	str	r3, [r7, #52]	@ 0x34
 801d99c:	e083      	b.n	801daa6 <h2v2_merged_upsample+0x190>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 801d99e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d9a0:	1c5a      	adds	r2, r3, #1
 801d9a2:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801d9a4:	781b      	ldrb	r3, [r3, #0]
 801d9a6:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2++);
 801d9a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d9aa:	1c5a      	adds	r2, r3, #1
 801d9ac:	63ba      	str	r2, [r7, #56]	@ 0x38
 801d9ae:	781b      	ldrb	r3, [r3, #0]
 801d9b0:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 801d9b2:	69bb      	ldr	r3, [r7, #24]
 801d9b4:	009b      	lsls	r3, r3, #2
 801d9b6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801d9b8:	4413      	add	r3, r2
 801d9ba:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801d9bc:	69fb      	ldr	r3, [r7, #28]
 801d9be:	009b      	lsls	r3, r3, #2
 801d9c0:	6a3a      	ldr	r2, [r7, #32]
 801d9c2:	4413      	add	r3, r2
 801d9c4:	681a      	ldr	r2, [r3, #0]
 801d9c6:	69bb      	ldr	r3, [r7, #24]
 801d9c8:	009b      	lsls	r3, r3, #2
 801d9ca:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801d9cc:	440b      	add	r3, r1
 801d9ce:	681b      	ldr	r3, [r3, #0]
 801d9d0:	4413      	add	r3, r2
 801d9d2:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801d9d6:	69fb      	ldr	r3, [r7, #28]
 801d9d8:	009b      	lsls	r3, r3, #2
 801d9da:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d9dc:	4413      	add	r3, r2
 801d9de:	681b      	ldr	r3, [r3, #0]
 801d9e0:	603b      	str	r3, [r7, #0]
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
 801d9e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d9e4:	1c5a      	adds	r2, r3, #1
 801d9e6:	647a      	str	r2, [r7, #68]	@ 0x44
 801d9e8:	781b      	ldrb	r3, [r3, #0]
 801d9ea:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801d9ec:	4601      	mov	r1, r0
 801d9ee:	186b      	adds	r3, r5, r1
 801d9f0:	4423      	add	r3, r4
 801d9f2:	781b      	ldrb	r3, [r3, #0]
 801d9f4:	6878      	ldr	r0, [r7, #4]
 801d9f6:	4602      	mov	r2, r0
 801d9f8:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801d9fa:	eb05 0308 	add.w	r3, r5, r8
 801d9fe:	18e2      	adds	r2, r4, r3
 801da00:	6078      	str	r0, [r7, #4]
 801da02:	1c43      	adds	r3, r0, #1
 801da04:	7812      	ldrb	r2, [r2, #0]
 801da06:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801da08:	6838      	ldr	r0, [r7, #0]
 801da0a:	182b      	adds	r3, r5, r0
 801da0c:	18e2      	adds	r2, r4, r3
 801da0e:	687d      	ldr	r5, [r7, #4]
 801da10:	1cab      	adds	r3, r5, #2
 801da12:	7812      	ldrb	r2, [r2, #0]
 801da14:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 801da16:	3503      	adds	r5, #3
 801da18:	607d      	str	r5, [r7, #4]
    y  = GETJSAMPLE(*inptr00++);
 801da1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da1c:	1c5a      	adds	r2, r3, #1
 801da1e:	647a      	str	r2, [r7, #68]	@ 0x44
 801da20:	781b      	ldrb	r3, [r3, #0]
 801da22:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801da24:	186b      	adds	r3, r5, r1
 801da26:	4423      	add	r3, r4
 801da28:	781b      	ldrb	r3, [r3, #0]
 801da2a:	687a      	ldr	r2, [r7, #4]
 801da2c:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801da2e:	eb05 0308 	add.w	r3, r5, r8
 801da32:	18e2      	adds	r2, r4, r3
 801da34:	687b      	ldr	r3, [r7, #4]
 801da36:	3301      	adds	r3, #1
 801da38:	7812      	ldrb	r2, [r2, #0]
 801da3a:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801da3c:	182b      	adds	r3, r5, r0
 801da3e:	18e2      	adds	r2, r4, r3
 801da40:	687d      	ldr	r5, [r7, #4]
 801da42:	1cab      	adds	r3, r5, #2
 801da44:	7812      	ldrb	r2, [r2, #0]
 801da46:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 801da48:	1ceb      	adds	r3, r5, #3
 801da4a:	607b      	str	r3, [r7, #4]
    y  = GETJSAMPLE(*inptr01++);
 801da4c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801da4e:	1c5a      	adds	r2, r3, #1
 801da50:	643a      	str	r2, [r7, #64]	@ 0x40
 801da52:	781b      	ldrb	r3, [r3, #0]
 801da54:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801da56:	186b      	adds	r3, r5, r1
 801da58:	4423      	add	r3, r4
 801da5a:	781b      	ldrb	r3, [r3, #0]
 801da5c:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801da5e:	eb05 0308 	add.w	r3, r5, r8
 801da62:	18e2      	adds	r2, r4, r3
 801da64:	1c73      	adds	r3, r6, #1
 801da66:	7812      	ldrb	r2, [r2, #0]
 801da68:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801da6a:	182b      	adds	r3, r5, r0
 801da6c:	18e2      	adds	r2, r4, r3
 801da6e:	1cb3      	adds	r3, r6, #2
 801da70:	7812      	ldrb	r2, [r2, #0]
 801da72:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 801da74:	3603      	adds	r6, #3
    y  = GETJSAMPLE(*inptr01++);
 801da76:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801da78:	1c5a      	adds	r2, r3, #1
 801da7a:	643a      	str	r2, [r7, #64]	@ 0x40
 801da7c:	781b      	ldrb	r3, [r3, #0]
 801da7e:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801da80:	186b      	adds	r3, r5, r1
 801da82:	4423      	add	r3, r4
 801da84:	781b      	ldrb	r3, [r3, #0]
 801da86:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801da88:	eb05 0308 	add.w	r3, r5, r8
 801da8c:	18e2      	adds	r2, r4, r3
 801da8e:	1c73      	adds	r3, r6, #1
 801da90:	7812      	ldrb	r2, [r2, #0]
 801da92:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801da94:	182b      	adds	r3, r5, r0
 801da96:	18e2      	adds	r2, r4, r3
 801da98:	1cb3      	adds	r3, r6, #2
 801da9a:	7812      	ldrb	r2, [r2, #0]
 801da9c:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 801da9e:	3603      	adds	r6, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801daa0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801daa2:	3b01      	subs	r3, #1
 801daa4:	637b      	str	r3, [r7, #52]	@ 0x34
 801daa6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801daa8:	2b00      	cmp	r3, #0
 801daaa:	f47f af78 	bne.w	801d99e <h2v2_merged_upsample+0x88>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801daae:	697b      	ldr	r3, [r7, #20]
 801dab0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801dab2:	f003 0301 	and.w	r3, r3, #1
 801dab6:	2b00      	cmp	r3, #0
 801dab8:	d044      	beq.n	801db44 <h2v2_merged_upsample+0x22e>
    cb = GETJSAMPLE(*inptr1);
 801daba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801dabc:	781b      	ldrb	r3, [r3, #0]
 801dabe:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2);
 801dac0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801dac2:	781b      	ldrb	r3, [r3, #0]
 801dac4:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 801dac6:	69bb      	ldr	r3, [r7, #24]
 801dac8:	009b      	lsls	r3, r3, #2
 801daca:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801dacc:	4413      	add	r3, r2
 801dace:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801dad0:	69fb      	ldr	r3, [r7, #28]
 801dad2:	009b      	lsls	r3, r3, #2
 801dad4:	6a3a      	ldr	r2, [r7, #32]
 801dad6:	4413      	add	r3, r2
 801dad8:	681a      	ldr	r2, [r3, #0]
 801dada:	69bb      	ldr	r3, [r7, #24]
 801dadc:	009b      	lsls	r3, r3, #2
 801dade:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801dae0:	440b      	add	r3, r1
 801dae2:	681b      	ldr	r3, [r3, #0]
 801dae4:	4413      	add	r3, r2
 801dae6:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 801daea:	69fb      	ldr	r3, [r7, #28]
 801daec:	009b      	lsls	r3, r3, #2
 801daee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801daf0:	4413      	add	r3, r2
 801daf2:	681b      	ldr	r3, [r3, #0]
 801daf4:	603b      	str	r3, [r7, #0]
    y  = GETJSAMPLE(*inptr00);
 801daf6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801daf8:	781b      	ldrb	r3, [r3, #0]
 801dafa:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 801dafc:	182b      	adds	r3, r5, r0
 801dafe:	4423      	add	r3, r4
 801db00:	781b      	ldrb	r3, [r3, #0]
 801db02:	6879      	ldr	r1, [r7, #4]
 801db04:	700b      	strb	r3, [r1, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 801db06:	eb05 0308 	add.w	r3, r5, r8
 801db0a:	18e2      	adds	r2, r4, r3
 801db0c:	1c4b      	adds	r3, r1, #1
 801db0e:	7812      	ldrb	r2, [r2, #0]
 801db10:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 801db12:	683b      	ldr	r3, [r7, #0]
 801db14:	18eb      	adds	r3, r5, r3
 801db16:	18e2      	adds	r2, r4, r3
 801db18:	1c8b      	adds	r3, r1, #2
 801db1a:	7812      	ldrb	r2, [r2, #0]
 801db1c:	701a      	strb	r2, [r3, #0]
    y  = GETJSAMPLE(*inptr01);
 801db1e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801db20:	781b      	ldrb	r3, [r3, #0]
 801db22:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801db24:	182b      	adds	r3, r5, r0
 801db26:	4423      	add	r3, r4
 801db28:	781b      	ldrb	r3, [r3, #0]
 801db2a:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801db2c:	eb05 0308 	add.w	r3, r5, r8
 801db30:	18e2      	adds	r2, r4, r3
 801db32:	1c73      	adds	r3, r6, #1
 801db34:	7812      	ldrb	r2, [r2, #0]
 801db36:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 801db38:	683b      	ldr	r3, [r7, #0]
 801db3a:	18eb      	adds	r3, r5, r3
 801db3c:	18e2      	adds	r2, r4, r3
 801db3e:	1cb3      	adds	r3, r6, #2
 801db40:	7812      	ldrb	r2, [r2, #0]
 801db42:	701a      	strb	r2, [r3, #0]
  }
}
 801db44:	bf00      	nop
 801db46:	374c      	adds	r7, #76	@ 0x4c
 801db48:	46bd      	mov	sp, r7
 801db4a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 801db4e:	4770      	bx	lr

0801db50 <jinit_merged_upsampler>:
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
 801db50:	b580      	push	{r7, lr}
 801db52:	b084      	sub	sp, #16
 801db54:	af00      	add	r7, sp, #0
 801db56:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801db58:	687b      	ldr	r3, [r7, #4]
 801db5a:	685b      	ldr	r3, [r3, #4]
 801db5c:	681b      	ldr	r3, [r3, #0]
 801db5e:	2230      	movs	r2, #48	@ 0x30
 801db60:	2101      	movs	r1, #1
 801db62:	6878      	ldr	r0, [r7, #4]
 801db64:	4798      	blx	r3
 801db66:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 801db68:	687b      	ldr	r3, [r7, #4]
 801db6a:	68fa      	ldr	r2, [r7, #12]
 801db6c:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
  upsample->pub.start_pass = start_pass_merged_upsample;
 801db70:	68fb      	ldr	r3, [r7, #12]
 801db72:	4a1a      	ldr	r2, [pc, #104]	@ (801dbdc <jinit_merged_upsampler+0x8c>)
 801db74:	601a      	str	r2, [r3, #0]
  upsample->pub.need_context_rows = FALSE;
 801db76:	68fb      	ldr	r3, [r7, #12]
 801db78:	2200      	movs	r2, #0
 801db7a:	609a      	str	r2, [r3, #8]

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
 801db7c:	687b      	ldr	r3, [r7, #4]
 801db7e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801db80:	687a      	ldr	r2, [r7, #4]
 801db82:	6f92      	ldr	r2, [r2, #120]	@ 0x78
 801db84:	fb03 f202 	mul.w	r2, r3, r2
 801db88:	68fb      	ldr	r3, [r7, #12]
 801db8a:	629a      	str	r2, [r3, #40]	@ 0x28

  if (cinfo->max_v_samp_factor == 2) {
 801db8c:	687b      	ldr	r3, [r7, #4]
 801db8e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801db92:	2b02      	cmp	r3, #2
 801db94:	d111      	bne.n	801dbba <jinit_merged_upsampler+0x6a>
    upsample->pub.upsample = merged_2v_upsample;
 801db96:	68fb      	ldr	r3, [r7, #12]
 801db98:	4a11      	ldr	r2, [pc, #68]	@ (801dbe0 <jinit_merged_upsampler+0x90>)
 801db9a:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v2_merged_upsample;
 801db9c:	68fb      	ldr	r3, [r7, #12]
 801db9e:	4a11      	ldr	r2, [pc, #68]	@ (801dbe4 <jinit_merged_upsampler+0x94>)
 801dba0:	60da      	str	r2, [r3, #12]
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801dba2:	687b      	ldr	r3, [r7, #4]
 801dba4:	685b      	ldr	r3, [r3, #4]
 801dba6:	685b      	ldr	r3, [r3, #4]
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
 801dba8:	68fa      	ldr	r2, [r7, #12]
 801dbaa:	6a92      	ldr	r2, [r2, #40]	@ 0x28
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801dbac:	2101      	movs	r1, #1
 801dbae:	6878      	ldr	r0, [r7, #4]
 801dbb0:	4798      	blx	r3
 801dbb2:	4602      	mov	r2, r0
    upsample->spare_row = (JSAMPROW)
 801dbb4:	68fb      	ldr	r3, [r7, #12]
 801dbb6:	621a      	str	r2, [r3, #32]
 801dbb8:	e008      	b.n	801dbcc <jinit_merged_upsampler+0x7c>
  } else {
    upsample->pub.upsample = merged_1v_upsample;
 801dbba:	68fb      	ldr	r3, [r7, #12]
 801dbbc:	4a0a      	ldr	r2, [pc, #40]	@ (801dbe8 <jinit_merged_upsampler+0x98>)
 801dbbe:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v1_merged_upsample;
 801dbc0:	68fb      	ldr	r3, [r7, #12]
 801dbc2:	4a0a      	ldr	r2, [pc, #40]	@ (801dbec <jinit_merged_upsampler+0x9c>)
 801dbc4:	60da      	str	r2, [r3, #12]
    /* No spare row needed */
    upsample->spare_row = NULL;
 801dbc6:	68fb      	ldr	r3, [r7, #12]
 801dbc8:	2200      	movs	r2, #0
 801dbca:	621a      	str	r2, [r3, #32]
  }

  build_ycc_rgb_table(cinfo);
 801dbcc:	6878      	ldr	r0, [r7, #4]
 801dbce:	f7ff fca9 	bl	801d524 <build_ycc_rgb_table>
}
 801dbd2:	bf00      	nop
 801dbd4:	3710      	adds	r7, #16
 801dbd6:	46bd      	mov	sp, r7
 801dbd8:	bd80      	pop	{r7, pc}
 801dbda:	bf00      	nop
 801dbdc:	0801d625 	.word	0x0801d625
 801dbe0:	0801d64f 	.word	0x0801d64f
 801dbe4:	0801d917 	.word	0x0801d917
 801dbe8:	0801d73b 	.word	0x0801d73b
 801dbec:	0801d787 	.word	0x0801d787

0801dbf0 <start_pass_dpost>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 801dbf0:	b590      	push	{r4, r7, lr}
 801dbf2:	b087      	sub	sp, #28
 801dbf4:	af02      	add	r7, sp, #8
 801dbf6:	6078      	str	r0, [r7, #4]
 801dbf8:	460b      	mov	r3, r1
 801dbfa:	70fb      	strb	r3, [r7, #3]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801dbfc:	687b      	ldr	r3, [r7, #4]
 801dbfe:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801dc02:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 801dc04:	78fb      	ldrb	r3, [r7, #3]
 801dc06:	2b03      	cmp	r3, #3
 801dc08:	d028      	beq.n	801dc5c <start_pass_dpost+0x6c>
 801dc0a:	2b03      	cmp	r3, #3
 801dc0c:	dc48      	bgt.n	801dca0 <start_pass_dpost+0xb0>
 801dc0e:	2b00      	cmp	r3, #0
 801dc10:	d002      	beq.n	801dc18 <start_pass_dpost+0x28>
 801dc12:	2b02      	cmp	r3, #2
 801dc14:	d033      	beq.n	801dc7e <start_pass_dpost+0x8e>
 801dc16:	e043      	b.n	801dca0 <start_pass_dpost+0xb0>
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
 801dc18:	687b      	ldr	r3, [r7, #4]
 801dc1a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801dc1c:	2b00      	cmp	r3, #0
 801dc1e:	d016      	beq.n	801dc4e <start_pass_dpost+0x5e>
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
 801dc20:	68fb      	ldr	r3, [r7, #12]
 801dc22:	4a2a      	ldr	r2, [pc, #168]	@ (801dccc <start_pass_dpost+0xdc>)
 801dc24:	605a      	str	r2, [r3, #4]
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
 801dc26:	68fb      	ldr	r3, [r7, #12]
 801dc28:	68db      	ldr	r3, [r3, #12]
 801dc2a:	2b00      	cmp	r3, #0
 801dc2c:	d142      	bne.n	801dcb4 <start_pass_dpost+0xc4>
	post->buffer = (*cinfo->mem->access_virt_sarray)
 801dc2e:	687b      	ldr	r3, [r7, #4]
 801dc30:	685b      	ldr	r3, [r3, #4]
 801dc32:	69dc      	ldr	r4, [r3, #28]
 801dc34:	68fb      	ldr	r3, [r7, #12]
 801dc36:	6899      	ldr	r1, [r3, #8]
 801dc38:	68fb      	ldr	r3, [r7, #12]
 801dc3a:	691b      	ldr	r3, [r3, #16]
 801dc3c:	2201      	movs	r2, #1
 801dc3e:	9200      	str	r2, [sp, #0]
 801dc40:	2200      	movs	r2, #0
 801dc42:	6878      	ldr	r0, [r7, #4]
 801dc44:	47a0      	blx	r4
 801dc46:	4602      	mov	r2, r0
 801dc48:	68fb      	ldr	r3, [r7, #12]
 801dc4a:	60da      	str	r2, [r3, #12]
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
    }
    break;
 801dc4c:	e032      	b.n	801dcb4 <start_pass_dpost+0xc4>
      post->pub.post_process_data = cinfo->upsample->upsample;
 801dc4e:	687b      	ldr	r3, [r7, #4]
 801dc50:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801dc54:	685a      	ldr	r2, [r3, #4]
 801dc56:	68fb      	ldr	r3, [r7, #12]
 801dc58:	605a      	str	r2, [r3, #4]
    break;
 801dc5a:	e02b      	b.n	801dcb4 <start_pass_dpost+0xc4>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
 801dc5c:	68fb      	ldr	r3, [r7, #12]
 801dc5e:	689b      	ldr	r3, [r3, #8]
 801dc60:	2b00      	cmp	r3, #0
 801dc62:	d108      	bne.n	801dc76 <start_pass_dpost+0x86>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801dc64:	687b      	ldr	r3, [r7, #4]
 801dc66:	681b      	ldr	r3, [r3, #0]
 801dc68:	2203      	movs	r2, #3
 801dc6a:	615a      	str	r2, [r3, #20]
 801dc6c:	687b      	ldr	r3, [r7, #4]
 801dc6e:	681b      	ldr	r3, [r3, #0]
 801dc70:	681b      	ldr	r3, [r3, #0]
 801dc72:	6878      	ldr	r0, [r7, #4]
 801dc74:	4798      	blx	r3
    post->pub.post_process_data = post_process_prepass;
 801dc76:	68fb      	ldr	r3, [r7, #12]
 801dc78:	4a15      	ldr	r2, [pc, #84]	@ (801dcd0 <start_pass_dpost+0xe0>)
 801dc7a:	605a      	str	r2, [r3, #4]
    break;
 801dc7c:	e01b      	b.n	801dcb6 <start_pass_dpost+0xc6>
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
 801dc7e:	68fb      	ldr	r3, [r7, #12]
 801dc80:	689b      	ldr	r3, [r3, #8]
 801dc82:	2b00      	cmp	r3, #0
 801dc84:	d108      	bne.n	801dc98 <start_pass_dpost+0xa8>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801dc86:	687b      	ldr	r3, [r7, #4]
 801dc88:	681b      	ldr	r3, [r3, #0]
 801dc8a:	2203      	movs	r2, #3
 801dc8c:	615a      	str	r2, [r3, #20]
 801dc8e:	687b      	ldr	r3, [r7, #4]
 801dc90:	681b      	ldr	r3, [r3, #0]
 801dc92:	681b      	ldr	r3, [r3, #0]
 801dc94:	6878      	ldr	r0, [r7, #4]
 801dc96:	4798      	blx	r3
    post->pub.post_process_data = post_process_2pass;
 801dc98:	68fb      	ldr	r3, [r7, #12]
 801dc9a:	4a0e      	ldr	r2, [pc, #56]	@ (801dcd4 <start_pass_dpost+0xe4>)
 801dc9c:	605a      	str	r2, [r3, #4]
    break;
 801dc9e:	e00a      	b.n	801dcb6 <start_pass_dpost+0xc6>
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801dca0:	687b      	ldr	r3, [r7, #4]
 801dca2:	681b      	ldr	r3, [r3, #0]
 801dca4:	2203      	movs	r2, #3
 801dca6:	615a      	str	r2, [r3, #20]
 801dca8:	687b      	ldr	r3, [r7, #4]
 801dcaa:	681b      	ldr	r3, [r3, #0]
 801dcac:	681b      	ldr	r3, [r3, #0]
 801dcae:	6878      	ldr	r0, [r7, #4]
 801dcb0:	4798      	blx	r3
    break;
 801dcb2:	e000      	b.n	801dcb6 <start_pass_dpost+0xc6>
    break;
 801dcb4:	bf00      	nop
  }
  post->starting_row = post->next_row = 0;
 801dcb6:	68fb      	ldr	r3, [r7, #12]
 801dcb8:	2200      	movs	r2, #0
 801dcba:	619a      	str	r2, [r3, #24]
 801dcbc:	68fb      	ldr	r3, [r7, #12]
 801dcbe:	699a      	ldr	r2, [r3, #24]
 801dcc0:	68fb      	ldr	r3, [r7, #12]
 801dcc2:	615a      	str	r2, [r3, #20]
}
 801dcc4:	bf00      	nop
 801dcc6:	3714      	adds	r7, #20
 801dcc8:	46bd      	mov	sp, r7
 801dcca:	bd90      	pop	{r4, r7, pc}
 801dccc:	0801dcd9 	.word	0x0801dcd9
 801dcd0:	0801dd5f 	.word	0x0801dd5f
 801dcd4:	0801de29 	.word	0x0801de29

0801dcd8 <post_process_1pass>:
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 801dcd8:	b590      	push	{r4, r7, lr}
 801dcda:	b08d      	sub	sp, #52	@ 0x34
 801dcdc:	af04      	add	r7, sp, #16
 801dcde:	60f8      	str	r0, [r7, #12]
 801dce0:	60b9      	str	r1, [r7, #8]
 801dce2:	607a      	str	r2, [r7, #4]
 801dce4:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801dce6:	68fb      	ldr	r3, [r7, #12]
 801dce8:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801dcec:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
 801dcee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dcf0:	681b      	ldr	r3, [r3, #0]
 801dcf2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801dcf4:	1ad3      	subs	r3, r2, r3
 801dcf6:	61fb      	str	r3, [r7, #28]
  if (max_rows > post->strip_height)
 801dcf8:	69bb      	ldr	r3, [r7, #24]
 801dcfa:	691b      	ldr	r3, [r3, #16]
 801dcfc:	69fa      	ldr	r2, [r7, #28]
 801dcfe:	429a      	cmp	r2, r3
 801dd00:	d902      	bls.n	801dd08 <post_process_1pass+0x30>
    max_rows = post->strip_height;
 801dd02:	69bb      	ldr	r3, [r7, #24]
 801dd04:	691b      	ldr	r3, [r3, #16]
 801dd06:	61fb      	str	r3, [r7, #28]
  num_rows = 0;
 801dd08:	2300      	movs	r3, #0
 801dd0a:	617b      	str	r3, [r7, #20]
  (*cinfo->upsample->upsample) (cinfo,
 801dd0c:	68fb      	ldr	r3, [r7, #12]
 801dd0e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801dd12:	685c      	ldr	r4, [r3, #4]
 801dd14:	69bb      	ldr	r3, [r7, #24]
 801dd16:	68db      	ldr	r3, [r3, #12]
 801dd18:	69fa      	ldr	r2, [r7, #28]
 801dd1a:	9202      	str	r2, [sp, #8]
 801dd1c:	f107 0214 	add.w	r2, r7, #20
 801dd20:	9201      	str	r2, [sp, #4]
 801dd22:	9300      	str	r3, [sp, #0]
 801dd24:	683b      	ldr	r3, [r7, #0]
 801dd26:	687a      	ldr	r2, [r7, #4]
 801dd28:	68b9      	ldr	r1, [r7, #8]
 801dd2a:	68f8      	ldr	r0, [r7, #12]
 801dd2c:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 801dd2e:	68fb      	ldr	r3, [r7, #12]
 801dd30:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801dd34:	685c      	ldr	r4, [r3, #4]
 801dd36:	69bb      	ldr	r3, [r7, #24]
 801dd38:	68d9      	ldr	r1, [r3, #12]
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
 801dd3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dd3c:	681b      	ldr	r3, [r3, #0]
 801dd3e:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801dd40:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801dd42:	441a      	add	r2, r3
 801dd44:	697b      	ldr	r3, [r7, #20]
 801dd46:	68f8      	ldr	r0, [r7, #12]
 801dd48:	47a0      	blx	r4
  *out_row_ctr += num_rows;
 801dd4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dd4c:	681a      	ldr	r2, [r3, #0]
 801dd4e:	697b      	ldr	r3, [r7, #20]
 801dd50:	441a      	add	r2, r3
 801dd52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dd54:	601a      	str	r2, [r3, #0]
}
 801dd56:	bf00      	nop
 801dd58:	3724      	adds	r7, #36	@ 0x24
 801dd5a:	46bd      	mov	sp, r7
 801dd5c:	bd90      	pop	{r4, r7, pc}

0801dd5e <post_process_prepass>:
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
 801dd5e:	b590      	push	{r4, r7, lr}
 801dd60:	b08d      	sub	sp, #52	@ 0x34
 801dd62:	af04      	add	r7, sp, #16
 801dd64:	60f8      	str	r0, [r7, #12]
 801dd66:	60b9      	str	r1, [r7, #8]
 801dd68:	607a      	str	r2, [r7, #4]
 801dd6a:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801dd6c:	68fb      	ldr	r3, [r7, #12]
 801dd6e:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801dd72:	61fb      	str	r3, [r7, #28]
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 801dd74:	69fb      	ldr	r3, [r7, #28]
 801dd76:	699b      	ldr	r3, [r3, #24]
 801dd78:	2b00      	cmp	r3, #0
 801dd7a:	d10f      	bne.n	801dd9c <post_process_prepass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 801dd7c:	68fb      	ldr	r3, [r7, #12]
 801dd7e:	685b      	ldr	r3, [r3, #4]
 801dd80:	69dc      	ldr	r4, [r3, #28]
 801dd82:	69fb      	ldr	r3, [r7, #28]
 801dd84:	6899      	ldr	r1, [r3, #8]
 801dd86:	69fb      	ldr	r3, [r7, #28]
 801dd88:	695a      	ldr	r2, [r3, #20]
 801dd8a:	69fb      	ldr	r3, [r7, #28]
 801dd8c:	691b      	ldr	r3, [r3, #16]
 801dd8e:	2001      	movs	r0, #1
 801dd90:	9000      	str	r0, [sp, #0]
 801dd92:	68f8      	ldr	r0, [r7, #12]
 801dd94:	47a0      	blx	r4
 801dd96:	4602      	mov	r2, r0
 801dd98:	69fb      	ldr	r3, [r7, #28]
 801dd9a:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
 801dd9c:	69fb      	ldr	r3, [r7, #28]
 801dd9e:	699b      	ldr	r3, [r3, #24]
 801dda0:	61bb      	str	r3, [r7, #24]
  (*cinfo->upsample->upsample) (cinfo,
 801dda2:	68fb      	ldr	r3, [r7, #12]
 801dda4:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801dda8:	685c      	ldr	r4, [r3, #4]
 801ddaa:	69fb      	ldr	r3, [r7, #28]
 801ddac:	68db      	ldr	r3, [r3, #12]
 801ddae:	69fa      	ldr	r2, [r7, #28]
 801ddb0:	3218      	adds	r2, #24
 801ddb2:	69f9      	ldr	r1, [r7, #28]
 801ddb4:	6909      	ldr	r1, [r1, #16]
 801ddb6:	9102      	str	r1, [sp, #8]
 801ddb8:	9201      	str	r2, [sp, #4]
 801ddba:	9300      	str	r3, [sp, #0]
 801ddbc:	683b      	ldr	r3, [r7, #0]
 801ddbe:	687a      	ldr	r2, [r7, #4]
 801ddc0:	68b9      	ldr	r1, [r7, #8]
 801ddc2:	68f8      	ldr	r0, [r7, #12]
 801ddc4:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
 801ddc6:	69fb      	ldr	r3, [r7, #28]
 801ddc8:	699b      	ldr	r3, [r3, #24]
 801ddca:	69ba      	ldr	r2, [r7, #24]
 801ddcc:	429a      	cmp	r2, r3
 801ddce:	d217      	bcs.n	801de00 <post_process_prepass+0xa2>
    num_rows = post->next_row - old_next_row;
 801ddd0:	69fb      	ldr	r3, [r7, #28]
 801ddd2:	699a      	ldr	r2, [r3, #24]
 801ddd4:	69bb      	ldr	r3, [r7, #24]
 801ddd6:	1ad3      	subs	r3, r2, r3
 801ddd8:	617b      	str	r3, [r7, #20]
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
 801ddda:	68fb      	ldr	r3, [r7, #12]
 801dddc:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801dde0:	685c      	ldr	r4, [r3, #4]
 801dde2:	69fb      	ldr	r3, [r7, #28]
 801dde4:	68da      	ldr	r2, [r3, #12]
 801dde6:	69bb      	ldr	r3, [r7, #24]
 801dde8:	009b      	lsls	r3, r3, #2
 801ddea:	18d1      	adds	r1, r2, r3
 801ddec:	697b      	ldr	r3, [r7, #20]
 801ddee:	2200      	movs	r2, #0
 801ddf0:	68f8      	ldr	r0, [r7, #12]
 801ddf2:	47a0      	blx	r4
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
 801ddf4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ddf6:	681a      	ldr	r2, [r3, #0]
 801ddf8:	697b      	ldr	r3, [r7, #20]
 801ddfa:	441a      	add	r2, r3
 801ddfc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ddfe:	601a      	str	r2, [r3, #0]
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
 801de00:	69fb      	ldr	r3, [r7, #28]
 801de02:	699a      	ldr	r2, [r3, #24]
 801de04:	69fb      	ldr	r3, [r7, #28]
 801de06:	691b      	ldr	r3, [r3, #16]
 801de08:	429a      	cmp	r2, r3
 801de0a:	d309      	bcc.n	801de20 <post_process_prepass+0xc2>
    post->starting_row += post->strip_height;
 801de0c:	69fb      	ldr	r3, [r7, #28]
 801de0e:	695a      	ldr	r2, [r3, #20]
 801de10:	69fb      	ldr	r3, [r7, #28]
 801de12:	691b      	ldr	r3, [r3, #16]
 801de14:	441a      	add	r2, r3
 801de16:	69fb      	ldr	r3, [r7, #28]
 801de18:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 801de1a:	69fb      	ldr	r3, [r7, #28]
 801de1c:	2200      	movs	r2, #0
 801de1e:	619a      	str	r2, [r3, #24]
  }
}
 801de20:	bf00      	nop
 801de22:	3724      	adds	r7, #36	@ 0x24
 801de24:	46bd      	mov	sp, r7
 801de26:	bd90      	pop	{r4, r7, pc}

0801de28 <post_process_2pass>:
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 801de28:	b590      	push	{r4, r7, lr}
 801de2a:	b08b      	sub	sp, #44	@ 0x2c
 801de2c:	af02      	add	r7, sp, #8
 801de2e:	60f8      	str	r0, [r7, #12]
 801de30:	60b9      	str	r1, [r7, #8]
 801de32:	607a      	str	r2, [r7, #4]
 801de34:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 801de36:	68fb      	ldr	r3, [r7, #12]
 801de38:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 801de3c:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 801de3e:	69bb      	ldr	r3, [r7, #24]
 801de40:	699b      	ldr	r3, [r3, #24]
 801de42:	2b00      	cmp	r3, #0
 801de44:	d10f      	bne.n	801de66 <post_process_2pass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 801de46:	68fb      	ldr	r3, [r7, #12]
 801de48:	685b      	ldr	r3, [r3, #4]
 801de4a:	69dc      	ldr	r4, [r3, #28]
 801de4c:	69bb      	ldr	r3, [r7, #24]
 801de4e:	6899      	ldr	r1, [r3, #8]
 801de50:	69bb      	ldr	r3, [r7, #24]
 801de52:	695a      	ldr	r2, [r3, #20]
 801de54:	69bb      	ldr	r3, [r7, #24]
 801de56:	691b      	ldr	r3, [r3, #16]
 801de58:	2000      	movs	r0, #0
 801de5a:	9000      	str	r0, [sp, #0]
 801de5c:	68f8      	ldr	r0, [r7, #12]
 801de5e:	47a0      	blx	r4
 801de60:	4602      	mov	r2, r0
 801de62:	69bb      	ldr	r3, [r7, #24]
 801de64:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
 801de66:	69bb      	ldr	r3, [r7, #24]
 801de68:	691a      	ldr	r2, [r3, #16]
 801de6a:	69bb      	ldr	r3, [r7, #24]
 801de6c:	699b      	ldr	r3, [r3, #24]
 801de6e:	1ad3      	subs	r3, r2, r3
 801de70:	61fb      	str	r3, [r7, #28]
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
 801de72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801de74:	681b      	ldr	r3, [r3, #0]
 801de76:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801de78:	1ad3      	subs	r3, r2, r3
 801de7a:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 801de7c:	69fa      	ldr	r2, [r7, #28]
 801de7e:	697b      	ldr	r3, [r7, #20]
 801de80:	429a      	cmp	r2, r3
 801de82:	d901      	bls.n	801de88 <post_process_2pass+0x60>
    num_rows = max_rows;
 801de84:	697b      	ldr	r3, [r7, #20]
 801de86:	61fb      	str	r3, [r7, #28]
  /* We have to check bottom of image here, can't depend on upsampler. */
  max_rows = cinfo->output_height - post->starting_row;
 801de88:	68fb      	ldr	r3, [r7, #12]
 801de8a:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801de8c:	69bb      	ldr	r3, [r7, #24]
 801de8e:	695b      	ldr	r3, [r3, #20]
 801de90:	1ad3      	subs	r3, r2, r3
 801de92:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 801de94:	69fa      	ldr	r2, [r7, #28]
 801de96:	697b      	ldr	r3, [r7, #20]
 801de98:	429a      	cmp	r2, r3
 801de9a:	d901      	bls.n	801dea0 <post_process_2pass+0x78>
    num_rows = max_rows;
 801de9c:	697b      	ldr	r3, [r7, #20]
 801de9e:	61fb      	str	r3, [r7, #28]

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 801dea0:	68fb      	ldr	r3, [r7, #12]
 801dea2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 801dea6:	685c      	ldr	r4, [r3, #4]
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 801dea8:	69bb      	ldr	r3, [r7, #24]
 801deaa:	68da      	ldr	r2, [r3, #12]
 801deac:	69bb      	ldr	r3, [r7, #24]
 801deae:	699b      	ldr	r3, [r3, #24]
 801deb0:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801deb2:	18d1      	adds	r1, r2, r3
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 801deb4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801deb6:	681b      	ldr	r3, [r3, #0]
 801deb8:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 801deba:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801debc:	441a      	add	r2, r3
 801debe:	69fb      	ldr	r3, [r7, #28]
 801dec0:	68f8      	ldr	r0, [r7, #12]
 801dec2:	47a0      	blx	r4
		(int) num_rows);
  *out_row_ctr += num_rows;
 801dec4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dec6:	681a      	ldr	r2, [r3, #0]
 801dec8:	69fb      	ldr	r3, [r7, #28]
 801deca:	441a      	add	r2, r3
 801decc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dece:	601a      	str	r2, [r3, #0]

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
 801ded0:	69bb      	ldr	r3, [r7, #24]
 801ded2:	699a      	ldr	r2, [r3, #24]
 801ded4:	69fb      	ldr	r3, [r7, #28]
 801ded6:	441a      	add	r2, r3
 801ded8:	69bb      	ldr	r3, [r7, #24]
 801deda:	619a      	str	r2, [r3, #24]
  if (post->next_row >= post->strip_height) {
 801dedc:	69bb      	ldr	r3, [r7, #24]
 801dede:	699a      	ldr	r2, [r3, #24]
 801dee0:	69bb      	ldr	r3, [r7, #24]
 801dee2:	691b      	ldr	r3, [r3, #16]
 801dee4:	429a      	cmp	r2, r3
 801dee6:	d309      	bcc.n	801defc <post_process_2pass+0xd4>
    post->starting_row += post->strip_height;
 801dee8:	69bb      	ldr	r3, [r7, #24]
 801deea:	695a      	ldr	r2, [r3, #20]
 801deec:	69bb      	ldr	r3, [r7, #24]
 801deee:	691b      	ldr	r3, [r3, #16]
 801def0:	441a      	add	r2, r3
 801def2:	69bb      	ldr	r3, [r7, #24]
 801def4:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 801def6:	69bb      	ldr	r3, [r7, #24]
 801def8:	2200      	movs	r2, #0
 801defa:	619a      	str	r2, [r3, #24]
  }
}
 801defc:	bf00      	nop
 801defe:	3724      	adds	r7, #36	@ 0x24
 801df00:	46bd      	mov	sp, r7
 801df02:	bd90      	pop	{r4, r7, pc}

0801df04 <jinit_d_post_controller>:
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 801df04:	b5b0      	push	{r4, r5, r7, lr}
 801df06:	b086      	sub	sp, #24
 801df08:	af02      	add	r7, sp, #8
 801df0a:	6078      	str	r0, [r7, #4]
 801df0c:	6039      	str	r1, [r7, #0]
  my_post_ptr post;

  post = (my_post_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801df0e:	687b      	ldr	r3, [r7, #4]
 801df10:	685b      	ldr	r3, [r3, #4]
 801df12:	681b      	ldr	r3, [r3, #0]
 801df14:	221c      	movs	r2, #28
 801df16:	2101      	movs	r1, #1
 801df18:	6878      	ldr	r0, [r7, #4]
 801df1a:	4798      	blx	r3
 801df1c:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
 801df1e:	687b      	ldr	r3, [r7, #4]
 801df20:	68fa      	ldr	r2, [r7, #12]
 801df22:	f8c3 21c4 	str.w	r2, [r3, #452]	@ 0x1c4
  post->pub.start_pass = start_pass_dpost;
 801df26:	68fb      	ldr	r3, [r7, #12]
 801df28:	4a25      	ldr	r2, [pc, #148]	@ (801dfc0 <jinit_d_post_controller+0xbc>)
 801df2a:	601a      	str	r2, [r3, #0]
  post->whole_image = NULL;	/* flag for no virtual arrays */
 801df2c:	68fb      	ldr	r3, [r7, #12]
 801df2e:	2200      	movs	r2, #0
 801df30:	609a      	str	r2, [r3, #8]
  post->buffer = NULL;		/* flag for no strip buffer */
 801df32:	68fb      	ldr	r3, [r7, #12]
 801df34:	2200      	movs	r2, #0
 801df36:	60da      	str	r2, [r3, #12]

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
 801df38:	687b      	ldr	r3, [r7, #4]
 801df3a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801df3c:	2b00      	cmp	r3, #0
 801df3e:	d03a      	beq.n	801dfb6 <jinit_d_post_controller+0xb2>
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
 801df40:	687b      	ldr	r3, [r7, #4]
 801df42:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801df46:	461a      	mov	r2, r3
 801df48:	68fb      	ldr	r3, [r7, #12]
 801df4a:	611a      	str	r2, [r3, #16]
    if (need_full_buffer) {
 801df4c:	683b      	ldr	r3, [r7, #0]
 801df4e:	2b00      	cmp	r3, #0
 801df50:	d020      	beq.n	801df94 <jinit_d_post_controller+0x90>
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801df52:	687b      	ldr	r3, [r7, #4]
 801df54:	685b      	ldr	r3, [r3, #4]
 801df56:	691c      	ldr	r4, [r3, #16]
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 cinfo->output_width * cinfo->out_color_components,
 801df58:	687b      	ldr	r3, [r7, #4]
 801df5a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801df5c:	687a      	ldr	r2, [r7, #4]
 801df5e:	6f92      	ldr	r2, [r2, #120]	@ 0x78
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801df60:	fb02 f503 	mul.w	r5, r2, r3
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 801df64:	687b      	ldr	r3, [r7, #4]
 801df66:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801df68:	461a      	mov	r2, r3
				(long) post->strip_height),
 801df6a:	68fb      	ldr	r3, [r7, #12]
 801df6c:	691b      	ldr	r3, [r3, #16]
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 801df6e:	4619      	mov	r1, r3
 801df70:	4610      	mov	r0, r2
 801df72:	f011 f89d 	bl	802f0b0 <jround_up>
 801df76:	4603      	mov	r3, r0
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 801df78:	461a      	mov	r2, r3
 801df7a:	68fb      	ldr	r3, [r7, #12]
 801df7c:	691b      	ldr	r3, [r3, #16]
 801df7e:	9301      	str	r3, [sp, #4]
 801df80:	9200      	str	r2, [sp, #0]
 801df82:	462b      	mov	r3, r5
 801df84:	2200      	movs	r2, #0
 801df86:	2101      	movs	r1, #1
 801df88:	6878      	ldr	r0, [r7, #4]
 801df8a:	47a0      	blx	r4
 801df8c:	4602      	mov	r2, r0
 801df8e:	68fb      	ldr	r3, [r7, #12]
 801df90:	609a      	str	r2, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 cinfo->output_width * cinfo->out_color_components,
	 post->strip_height);
    }
  }
}
 801df92:	e010      	b.n	801dfb6 <jinit_d_post_controller+0xb2>
      post->buffer = (*cinfo->mem->alloc_sarray)
 801df94:	687b      	ldr	r3, [r7, #4]
 801df96:	685b      	ldr	r3, [r3, #4]
 801df98:	689c      	ldr	r4, [r3, #8]
	 cinfo->output_width * cinfo->out_color_components,
 801df9a:	687b      	ldr	r3, [r7, #4]
 801df9c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801df9e:	687a      	ldr	r2, [r7, #4]
 801dfa0:	6f92      	ldr	r2, [r2, #120]	@ 0x78
      post->buffer = (*cinfo->mem->alloc_sarray)
 801dfa2:	fb03 f202 	mul.w	r2, r3, r2
 801dfa6:	68fb      	ldr	r3, [r7, #12]
 801dfa8:	691b      	ldr	r3, [r3, #16]
 801dfaa:	2101      	movs	r1, #1
 801dfac:	6878      	ldr	r0, [r7, #4]
 801dfae:	47a0      	blx	r4
 801dfb0:	4602      	mov	r2, r0
 801dfb2:	68fb      	ldr	r3, [r7, #12]
 801dfb4:	60da      	str	r2, [r3, #12]
}
 801dfb6:	bf00      	nop
 801dfb8:	3710      	adds	r7, #16
 801dfba:	46bd      	mov	sp, r7
 801dfbc:	bdb0      	pop	{r4, r5, r7, pc}
 801dfbe:	bf00      	nop
 801dfc0:	0801dbf1 	.word	0x0801dbf1

0801dfc4 <start_pass_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
 801dfc4:	b480      	push	{r7}
 801dfc6:	b085      	sub	sp, #20
 801dfc8:	af00      	add	r7, sp, #0
 801dfca:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801dfcc:	687b      	ldr	r3, [r7, #4]
 801dfce:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801dfd2:	60fb      	str	r3, [r7, #12]

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
 801dfd4:	687b      	ldr	r3, [r7, #4]
 801dfd6:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801dfda:	68fb      	ldr	r3, [r7, #12]
 801dfdc:	65da      	str	r2, [r3, #92]	@ 0x5c
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 801dfde:	687b      	ldr	r3, [r7, #4]
 801dfe0:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 801dfe2:	68fb      	ldr	r3, [r7, #12]
 801dfe4:	661a      	str	r2, [r3, #96]	@ 0x60
}
 801dfe6:	bf00      	nop
 801dfe8:	3714      	adds	r7, #20
 801dfea:	46bd      	mov	sp, r7
 801dfec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dff0:	4770      	bx	lr

0801dff2 <sep_upsample>:
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
 801dff2:	b590      	push	{r4, r7, lr}
 801dff4:	b08b      	sub	sp, #44	@ 0x2c
 801dff6:	af02      	add	r7, sp, #8
 801dff8:	60f8      	str	r0, [r7, #12]
 801dffa:	60b9      	str	r1, [r7, #8]
 801dffc:	607a      	str	r2, [r7, #4]
 801dffe:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801e000:	68fb      	ldr	r3, [r7, #12]
 801e002:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801e006:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
 801e008:	693b      	ldr	r3, [r7, #16]
 801e00a:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801e00c:	68fb      	ldr	r3, [r7, #12]
 801e00e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e012:	429a      	cmp	r2, r3
 801e014:	db35      	blt.n	801e082 <sep_upsample+0x90>
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801e016:	2300      	movs	r3, #0
 801e018:	61fb      	str	r3, [r7, #28]
 801e01a:	68fb      	ldr	r3, [r7, #12]
 801e01c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801e020:	61bb      	str	r3, [r7, #24]
 801e022:	e026      	b.n	801e072 <sep_upsample+0x80>
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
 801e024:	693a      	ldr	r2, [r7, #16]
 801e026:	69fb      	ldr	r3, [r7, #28]
 801e028:	330c      	adds	r3, #12
 801e02a:	009b      	lsls	r3, r3, #2
 801e02c:	4413      	add	r3, r2
 801e02e:	685c      	ldr	r4, [r3, #4]
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
 801e030:	69fb      	ldr	r3, [r7, #28]
 801e032:	009b      	lsls	r3, r3, #2
 801e034:	68ba      	ldr	r2, [r7, #8]
 801e036:	4413      	add	r3, r2
 801e038:	681a      	ldr	r2, [r3, #0]
 801e03a:	687b      	ldr	r3, [r7, #4]
 801e03c:	6819      	ldr	r1, [r3, #0]
 801e03e:	6938      	ldr	r0, [r7, #16]
 801e040:	69fb      	ldr	r3, [r7, #28]
 801e042:	3318      	adds	r3, #24
 801e044:	009b      	lsls	r3, r3, #2
 801e046:	4403      	add	r3, r0
 801e048:	685b      	ldr	r3, [r3, #4]
 801e04a:	fb01 f303 	mul.w	r3, r1, r3
 801e04e:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 801e050:	18d1      	adds	r1, r2, r3
	upsample->color_buf + ci);
 801e052:	693b      	ldr	r3, [r7, #16]
 801e054:	f103 020c 	add.w	r2, r3, #12
 801e058:	69fb      	ldr	r3, [r7, #28]
 801e05a:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 801e05c:	4413      	add	r3, r2
 801e05e:	460a      	mov	r2, r1
 801e060:	69b9      	ldr	r1, [r7, #24]
 801e062:	68f8      	ldr	r0, [r7, #12]
 801e064:	47a0      	blx	r4
	 ci++, compptr++) {
 801e066:	69fb      	ldr	r3, [r7, #28]
 801e068:	3301      	adds	r3, #1
 801e06a:	61fb      	str	r3, [r7, #28]
 801e06c:	69bb      	ldr	r3, [r7, #24]
 801e06e:	3358      	adds	r3, #88	@ 0x58
 801e070:	61bb      	str	r3, [r7, #24]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801e072:	68fb      	ldr	r3, [r7, #12]
 801e074:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801e076:	69fa      	ldr	r2, [r7, #28]
 801e078:	429a      	cmp	r2, r3
 801e07a:	dbd3      	blt.n	801e024 <sep_upsample+0x32>
    }
    upsample->next_row_out = 0;
 801e07c:	693b      	ldr	r3, [r7, #16]
 801e07e:	2200      	movs	r2, #0
 801e080:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
 801e082:	68fb      	ldr	r3, [r7, #12]
 801e084:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 801e088:	693b      	ldr	r3, [r7, #16]
 801e08a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801e08c:	1ad3      	subs	r3, r2, r3
 801e08e:	617b      	str	r3, [r7, #20]
  /* Not more than the distance to the end of the image.  Need this test
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go) 
 801e090:	693b      	ldr	r3, [r7, #16]
 801e092:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 801e094:	697a      	ldr	r2, [r7, #20]
 801e096:	429a      	cmp	r2, r3
 801e098:	d902      	bls.n	801e0a0 <sep_upsample+0xae>
    num_rows = upsample->rows_to_go;
 801e09a:	693b      	ldr	r3, [r7, #16]
 801e09c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 801e09e:	617b      	str	r3, [r7, #20]
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
 801e0a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801e0a2:	681b      	ldr	r3, [r3, #0]
 801e0a4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801e0a6:	1ad3      	subs	r3, r2, r3
 801e0a8:	63bb      	str	r3, [r7, #56]	@ 0x38
  if (num_rows > out_rows_avail)
 801e0aa:	697a      	ldr	r2, [r7, #20]
 801e0ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801e0ae:	429a      	cmp	r2, r3
 801e0b0:	d901      	bls.n	801e0b6 <sep_upsample+0xc4>
    num_rows = out_rows_avail;
 801e0b2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801e0b4:	617b      	str	r3, [r7, #20]

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801e0b6:	68fb      	ldr	r3, [r7, #12]
 801e0b8:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 801e0bc:	685c      	ldr	r4, [r3, #4]
 801e0be:	693b      	ldr	r3, [r7, #16]
 801e0c0:	f103 010c 	add.w	r1, r3, #12
				     (JDIMENSION) upsample->next_row_out,
 801e0c4:	693b      	ldr	r3, [r7, #16]
 801e0c6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801e0c8:	4618      	mov	r0, r3
				     output_buf + *out_row_ctr,
 801e0ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801e0cc:	681b      	ldr	r3, [r3, #0]
 801e0ce:	009b      	lsls	r3, r3, #2
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 801e0d0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801e0d2:	441a      	add	r2, r3
 801e0d4:	697b      	ldr	r3, [r7, #20]
 801e0d6:	9300      	str	r3, [sp, #0]
 801e0d8:	4613      	mov	r3, r2
 801e0da:	4602      	mov	r2, r0
 801e0dc:	68f8      	ldr	r0, [r7, #12]
 801e0de:	47a0      	blx	r4
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
 801e0e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801e0e2:	681a      	ldr	r2, [r3, #0]
 801e0e4:	697b      	ldr	r3, [r7, #20]
 801e0e6:	441a      	add	r2, r3
 801e0e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801e0ea:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 801e0ec:	693b      	ldr	r3, [r7, #16]
 801e0ee:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 801e0f0:	697b      	ldr	r3, [r7, #20]
 801e0f2:	1ad2      	subs	r2, r2, r3
 801e0f4:	693b      	ldr	r3, [r7, #16]
 801e0f6:	661a      	str	r2, [r3, #96]	@ 0x60
  upsample->next_row_out += num_rows;
 801e0f8:	693b      	ldr	r3, [r7, #16]
 801e0fa:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801e0fc:	461a      	mov	r2, r3
 801e0fe:	697b      	ldr	r3, [r7, #20]
 801e100:	4413      	add	r3, r2
 801e102:	461a      	mov	r2, r3
 801e104:	693b      	ldr	r3, [r7, #16]
 801e106:	65da      	str	r2, [r3, #92]	@ 0x5c
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
 801e108:	693b      	ldr	r3, [r7, #16]
 801e10a:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801e10c:	68fb      	ldr	r3, [r7, #12]
 801e10e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e112:	429a      	cmp	r2, r3
 801e114:	db04      	blt.n	801e120 <sep_upsample+0x12e>
    (*in_row_group_ctr)++;
 801e116:	687b      	ldr	r3, [r7, #4]
 801e118:	681b      	ldr	r3, [r3, #0]
 801e11a:	1c5a      	adds	r2, r3, #1
 801e11c:	687b      	ldr	r3, [r7, #4]
 801e11e:	601a      	str	r2, [r3, #0]
}
 801e120:	bf00      	nop
 801e122:	3724      	adds	r7, #36	@ 0x24
 801e124:	46bd      	mov	sp, r7
 801e126:	bd90      	pop	{r4, r7, pc}

0801e128 <fullsize_upsample>:
 */

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801e128:	b480      	push	{r7}
 801e12a:	b085      	sub	sp, #20
 801e12c:	af00      	add	r7, sp, #0
 801e12e:	60f8      	str	r0, [r7, #12]
 801e130:	60b9      	str	r1, [r7, #8]
 801e132:	607a      	str	r2, [r7, #4]
 801e134:	603b      	str	r3, [r7, #0]
  *output_data_ptr = input_data;
 801e136:	683b      	ldr	r3, [r7, #0]
 801e138:	687a      	ldr	r2, [r7, #4]
 801e13a:	601a      	str	r2, [r3, #0]
}
 801e13c:	bf00      	nop
 801e13e:	3714      	adds	r7, #20
 801e140:	46bd      	mov	sp, r7
 801e142:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e146:	4770      	bx	lr

0801e148 <noop_upsample>:
 */

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801e148:	b480      	push	{r7}
 801e14a:	b085      	sub	sp, #20
 801e14c:	af00      	add	r7, sp, #0
 801e14e:	60f8      	str	r0, [r7, #12]
 801e150:	60b9      	str	r1, [r7, #8]
 801e152:	607a      	str	r2, [r7, #4]
 801e154:	603b      	str	r3, [r7, #0]
  *output_data_ptr = NULL;	/* safety check */
 801e156:	683b      	ldr	r3, [r7, #0]
 801e158:	2200      	movs	r2, #0
 801e15a:	601a      	str	r2, [r3, #0]
}
 801e15c:	bf00      	nop
 801e15e:	3714      	adds	r7, #20
 801e160:	46bd      	mov	sp, r7
 801e162:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e166:	4770      	bx	lr

0801e168 <int_upsample>:
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801e168:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e16c:	b08e      	sub	sp, #56	@ 0x38
 801e16e:	af02      	add	r7, sp, #8
 801e170:	60f8      	str	r0, [r7, #12]
 801e172:	60b9      	str	r1, [r7, #8]
 801e174:	607a      	str	r2, [r7, #4]
 801e176:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 801e178:	68fb      	ldr	r3, [r7, #12]
 801e17a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
 801e17e:	627b      	str	r3, [r7, #36]	@ 0x24
  JSAMPARRAY output_data = *output_data_ptr;
 801e180:	683b      	ldr	r3, [r7, #0]
 801e182:	681b      	ldr	r3, [r3, #0]
 801e184:	623b      	str	r3, [r7, #32]
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
 801e186:	68bb      	ldr	r3, [r7, #8]
 801e188:	685b      	ldr	r3, [r3, #4]
 801e18a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e18c:	4413      	add	r3, r2
 801e18e:	f893 308c 	ldrb.w	r3, [r3, #140]	@ 0x8c
 801e192:	61fb      	str	r3, [r7, #28]
  v_expand = upsample->v_expand[compptr->component_index];
 801e194:	68bb      	ldr	r3, [r7, #8]
 801e196:	685b      	ldr	r3, [r3, #4]
 801e198:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e19a:	4413      	add	r3, r2
 801e19c:	f893 3096 	ldrb.w	r3, [r3, #150]	@ 0x96
 801e1a0:	61bb      	str	r3, [r7, #24]

  inrow = outrow = 0;
 801e1a2:	2300      	movs	r3, #0
 801e1a4:	62bb      	str	r3, [r7, #40]	@ 0x28
 801e1a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e1a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (outrow < cinfo->max_v_samp_factor) {
 801e1aa:	e036      	b.n	801e21a <int_upsample+0xb2>
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
 801e1ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801e1ae:	009b      	lsls	r3, r3, #2
 801e1b0:	687a      	ldr	r2, [r7, #4]
 801e1b2:	4413      	add	r3, r2
 801e1b4:	681e      	ldr	r6, [r3, #0]
    outptr = output_data[outrow];
 801e1b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e1b8:	009b      	lsls	r3, r3, #2
 801e1ba:	6a3a      	ldr	r2, [r7, #32]
 801e1bc:	4413      	add	r3, r2
 801e1be:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801e1c0:	68fb      	ldr	r3, [r7, #12]
 801e1c2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e1c4:	4423      	add	r3, r4
 801e1c6:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 801e1c8:	e00c      	b.n	801e1e4 <int_upsample+0x7c>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801e1ca:	4633      	mov	r3, r6
 801e1cc:	1c5e      	adds	r6, r3, #1
 801e1ce:	f893 8000 	ldrb.w	r8, [r3]
      for (h = h_expand; h > 0; h--) {
 801e1d2:	69fd      	ldr	r5, [r7, #28]
 801e1d4:	e004      	b.n	801e1e0 <int_upsample+0x78>
	*outptr++ = invalue;
 801e1d6:	4623      	mov	r3, r4
 801e1d8:	1c5c      	adds	r4, r3, #1
 801e1da:	4642      	mov	r2, r8
 801e1dc:	701a      	strb	r2, [r3, #0]
      for (h = h_expand; h > 0; h--) {
 801e1de:	3d01      	subs	r5, #1
 801e1e0:	2d00      	cmp	r5, #0
 801e1e2:	dcf8      	bgt.n	801e1d6 <int_upsample+0x6e>
    while (outptr < outend) {
 801e1e4:	697b      	ldr	r3, [r7, #20]
 801e1e6:	429c      	cmp	r4, r3
 801e1e8:	d3ef      	bcc.n	801e1ca <int_upsample+0x62>
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
 801e1ea:	69bb      	ldr	r3, [r7, #24]
 801e1ec:	2b01      	cmp	r3, #1
 801e1ee:	dd0d      	ble.n	801e20c <int_upsample+0xa4>
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 801e1f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e1f2:	1c59      	adds	r1, r3, #1
 801e1f4:	69bb      	ldr	r3, [r7, #24]
 801e1f6:	3b01      	subs	r3, #1
 801e1f8:	68fa      	ldr	r2, [r7, #12]
 801e1fa:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 801e1fc:	9201      	str	r2, [sp, #4]
 801e1fe:	9300      	str	r3, [sp, #0]
 801e200:	460b      	mov	r3, r1
 801e202:	6a3a      	ldr	r2, [r7, #32]
 801e204:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801e206:	6a38      	ldr	r0, [r7, #32]
 801e208:	f010 ff6c 	bl	802f0e4 <jcopy_sample_rows>
			v_expand-1, cinfo->output_width);
    }
    inrow++;
 801e20c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801e20e:	3301      	adds	r3, #1
 801e210:	62fb      	str	r3, [r7, #44]	@ 0x2c
    outrow += v_expand;
 801e212:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e214:	69bb      	ldr	r3, [r7, #24]
 801e216:	4413      	add	r3, r2
 801e218:	62bb      	str	r3, [r7, #40]	@ 0x28
  while (outrow < cinfo->max_v_samp_factor) {
 801e21a:	68fb      	ldr	r3, [r7, #12]
 801e21c:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e220:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e222:	429a      	cmp	r2, r3
 801e224:	dbc2      	blt.n	801e1ac <int_upsample+0x44>
  }
}
 801e226:	bf00      	nop
 801e228:	bf00      	nop
 801e22a:	3730      	adds	r7, #48	@ 0x30
 801e22c:	46bd      	mov	sp, r7
 801e22e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801e232 <h2v1_upsample>:
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801e232:	b4f0      	push	{r4, r5, r6, r7}
 801e234:	b088      	sub	sp, #32
 801e236:	af00      	add	r7, sp, #0
 801e238:	60f8      	str	r0, [r7, #12]
 801e23a:	60b9      	str	r1, [r7, #8]
 801e23c:	607a      	str	r2, [r7, #4]
 801e23e:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 801e240:	683b      	ldr	r3, [r7, #0]
 801e242:	681b      	ldr	r3, [r3, #0]
 801e244:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int outrow;

  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 801e246:	2300      	movs	r3, #0
 801e248:	61fb      	str	r3, [r7, #28]
 801e24a:	e01f      	b.n	801e28c <h2v1_upsample+0x5a>
    inptr = input_data[outrow];
 801e24c:	69fb      	ldr	r3, [r7, #28]
 801e24e:	009b      	lsls	r3, r3, #2
 801e250:	687a      	ldr	r2, [r7, #4]
 801e252:	4413      	add	r3, r2
 801e254:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 801e256:	69fb      	ldr	r3, [r7, #28]
 801e258:	009b      	lsls	r3, r3, #2
 801e25a:	69ba      	ldr	r2, [r7, #24]
 801e25c:	4413      	add	r3, r2
 801e25e:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801e260:	68fb      	ldr	r3, [r7, #12]
 801e262:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e264:	4423      	add	r3, r4
 801e266:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 801e268:	e00a      	b.n	801e280 <h2v1_upsample+0x4e>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801e26a:	462b      	mov	r3, r5
 801e26c:	1c5d      	adds	r5, r3, #1
 801e26e:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 801e270:	4623      	mov	r3, r4
 801e272:	1c5c      	adds	r4, r3, #1
 801e274:	4632      	mov	r2, r6
 801e276:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 801e278:	4623      	mov	r3, r4
 801e27a:	1c5c      	adds	r4, r3, #1
 801e27c:	4632      	mov	r2, r6
 801e27e:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 801e280:	697b      	ldr	r3, [r7, #20]
 801e282:	429c      	cmp	r4, r3
 801e284:	d3f1      	bcc.n	801e26a <h2v1_upsample+0x38>
  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 801e286:	69fb      	ldr	r3, [r7, #28]
 801e288:	3301      	adds	r3, #1
 801e28a:	61fb      	str	r3, [r7, #28]
 801e28c:	68fb      	ldr	r3, [r7, #12]
 801e28e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e292:	69fa      	ldr	r2, [r7, #28]
 801e294:	429a      	cmp	r2, r3
 801e296:	dbd9      	blt.n	801e24c <h2v1_upsample+0x1a>
    }
  }
}
 801e298:	bf00      	nop
 801e29a:	bf00      	nop
 801e29c:	3720      	adds	r7, #32
 801e29e:	46bd      	mov	sp, r7
 801e2a0:	bcf0      	pop	{r4, r5, r6, r7}
 801e2a2:	4770      	bx	lr

0801e2a4 <h2v2_upsample>:
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 801e2a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e2a6:	b08b      	sub	sp, #44	@ 0x2c
 801e2a8:	af02      	add	r7, sp, #8
 801e2aa:	60f8      	str	r0, [r7, #12]
 801e2ac:	60b9      	str	r1, [r7, #8]
 801e2ae:	607a      	str	r2, [r7, #4]
 801e2b0:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 801e2b2:	683b      	ldr	r3, [r7, #0]
 801e2b4:	681b      	ldr	r3, [r3, #0]
 801e2b6:	617b      	str	r3, [r7, #20]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
 801e2b8:	2300      	movs	r3, #0
 801e2ba:	61bb      	str	r3, [r7, #24]
 801e2bc:	69bb      	ldr	r3, [r7, #24]
 801e2be:	61fb      	str	r3, [r7, #28]
  while (outrow < cinfo->max_v_samp_factor) {
 801e2c0:	e02f      	b.n	801e322 <h2v2_upsample+0x7e>
    inptr = input_data[inrow];
 801e2c2:	69fb      	ldr	r3, [r7, #28]
 801e2c4:	009b      	lsls	r3, r3, #2
 801e2c6:	687a      	ldr	r2, [r7, #4]
 801e2c8:	4413      	add	r3, r2
 801e2ca:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 801e2cc:	69bb      	ldr	r3, [r7, #24]
 801e2ce:	009b      	lsls	r3, r3, #2
 801e2d0:	697a      	ldr	r2, [r7, #20]
 801e2d2:	4413      	add	r3, r2
 801e2d4:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 801e2d6:	68fb      	ldr	r3, [r7, #12]
 801e2d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e2da:	4423      	add	r3, r4
 801e2dc:	613b      	str	r3, [r7, #16]
    while (outptr < outend) {
 801e2de:	e00a      	b.n	801e2f6 <h2v2_upsample+0x52>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801e2e0:	462b      	mov	r3, r5
 801e2e2:	1c5d      	adds	r5, r3, #1
 801e2e4:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 801e2e6:	4623      	mov	r3, r4
 801e2e8:	1c5c      	adds	r4, r3, #1
 801e2ea:	4632      	mov	r2, r6
 801e2ec:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 801e2ee:	4623      	mov	r3, r4
 801e2f0:	1c5c      	adds	r4, r3, #1
 801e2f2:	4632      	mov	r2, r6
 801e2f4:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 801e2f6:	693b      	ldr	r3, [r7, #16]
 801e2f8:	429c      	cmp	r4, r3
 801e2fa:	d3f1      	bcc.n	801e2e0 <h2v2_upsample+0x3c>
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 801e2fc:	69bb      	ldr	r3, [r7, #24]
 801e2fe:	1c5a      	adds	r2, r3, #1
 801e300:	68fb      	ldr	r3, [r7, #12]
 801e302:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e304:	9301      	str	r3, [sp, #4]
 801e306:	2301      	movs	r3, #1
 801e308:	9300      	str	r3, [sp, #0]
 801e30a:	4613      	mov	r3, r2
 801e30c:	697a      	ldr	r2, [r7, #20]
 801e30e:	69b9      	ldr	r1, [r7, #24]
 801e310:	6978      	ldr	r0, [r7, #20]
 801e312:	f010 fee7 	bl	802f0e4 <jcopy_sample_rows>
		      1, cinfo->output_width);
    inrow++;
 801e316:	69fb      	ldr	r3, [r7, #28]
 801e318:	3301      	adds	r3, #1
 801e31a:	61fb      	str	r3, [r7, #28]
    outrow += 2;
 801e31c:	69bb      	ldr	r3, [r7, #24]
 801e31e:	3302      	adds	r3, #2
 801e320:	61bb      	str	r3, [r7, #24]
  while (outrow < cinfo->max_v_samp_factor) {
 801e322:	68fb      	ldr	r3, [r7, #12]
 801e324:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e328:	69ba      	ldr	r2, [r7, #24]
 801e32a:	429a      	cmp	r2, r3
 801e32c:	dbc9      	blt.n	801e2c2 <h2v2_upsample+0x1e>
  }
}
 801e32e:	bf00      	nop
 801e330:	bf00      	nop
 801e332:	3724      	adds	r7, #36	@ 0x24
 801e334:	46bd      	mov	sp, r7
 801e336:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801e338 <jinit_upsampler>:
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
 801e338:	b590      	push	{r4, r7, lr}
 801e33a:	b08b      	sub	sp, #44	@ 0x2c
 801e33c:	af00      	add	r7, sp, #0
 801e33e:	6078      	str	r0, [r7, #4]
  jpeg_component_info * compptr;
  boolean need_buffer;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801e340:	687b      	ldr	r3, [r7, #4]
 801e342:	685b      	ldr	r3, [r3, #4]
 801e344:	681b      	ldr	r3, [r3, #0]
 801e346:	22a0      	movs	r2, #160	@ 0xa0
 801e348:	2101      	movs	r1, #1
 801e34a:	6878      	ldr	r0, [r7, #4]
 801e34c:	4798      	blx	r3
 801e34e:	61b8      	str	r0, [r7, #24]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 801e350:	687b      	ldr	r3, [r7, #4]
 801e352:	69ba      	ldr	r2, [r7, #24]
 801e354:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
  upsample->pub.start_pass = start_pass_upsample;
 801e358:	69bb      	ldr	r3, [r7, #24]
 801e35a:	4a7a      	ldr	r2, [pc, #488]	@ (801e544 <jinit_upsampler+0x20c>)
 801e35c:	601a      	str	r2, [r3, #0]
  upsample->pub.upsample = sep_upsample;
 801e35e:	69bb      	ldr	r3, [r7, #24]
 801e360:	4a79      	ldr	r2, [pc, #484]	@ (801e548 <jinit_upsampler+0x210>)
 801e362:	605a      	str	r2, [r3, #4]
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
 801e364:	69bb      	ldr	r3, [r7, #24]
 801e366:	2200      	movs	r2, #0
 801e368:	609a      	str	r2, [r3, #8]

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
 801e36a:	687b      	ldr	r3, [r7, #4]
 801e36c:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 801e370:	2b00      	cmp	r3, #0
 801e372:	d008      	beq.n	801e386 <jinit_upsampler+0x4e>
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
 801e374:	687b      	ldr	r3, [r7, #4]
 801e376:	681b      	ldr	r3, [r3, #0]
 801e378:	221a      	movs	r2, #26
 801e37a:	615a      	str	r2, [r3, #20]
 801e37c:	687b      	ldr	r3, [r7, #4]
 801e37e:	681b      	ldr	r3, [r3, #0]
 801e380:	681b      	ldr	r3, [r3, #0]
 801e382:	6878      	ldr	r0, [r7, #4]
 801e384:	4798      	blx	r3

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801e386:	2300      	movs	r3, #0
 801e388:	627b      	str	r3, [r7, #36]	@ 0x24
 801e38a:	687b      	ldr	r3, [r7, #4]
 801e38c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 801e390:	623b      	str	r3, [r7, #32]
 801e392:	e0cb      	b.n	801e52c <jinit_upsampler+0x1f4>
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 801e394:	6a3b      	ldr	r3, [r7, #32]
 801e396:	689b      	ldr	r3, [r3, #8]
 801e398:	6a3a      	ldr	r2, [r7, #32]
 801e39a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801e39c:	fb03 f202 	mul.w	r2, r3, r2
		 cinfo->min_DCT_h_scaled_size;
 801e3a0:	687b      	ldr	r3, [r7, #4]
 801e3a2:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 801e3a6:	fb92 f3f3 	sdiv	r3, r2, r3
 801e3aa:	617b      	str	r3, [r7, #20]
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801e3ac:	6a3b      	ldr	r3, [r7, #32]
 801e3ae:	68db      	ldr	r3, [r3, #12]
 801e3b0:	6a3a      	ldr	r2, [r7, #32]
 801e3b2:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 801e3b4:	fb03 f202 	mul.w	r2, r3, r2
		 cinfo->min_DCT_v_scaled_size;
 801e3b8:	687b      	ldr	r3, [r7, #4]
 801e3ba:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801e3be:	fb92 f3f3 	sdiv	r3, r2, r3
 801e3c2:	613b      	str	r3, [r7, #16]
    h_out_group = cinfo->max_h_samp_factor;
 801e3c4:	687b      	ldr	r3, [r7, #4]
 801e3c6:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 801e3ca:	60fb      	str	r3, [r7, #12]
    v_out_group = cinfo->max_v_samp_factor;
 801e3cc:	687b      	ldr	r3, [r7, #4]
 801e3ce:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 801e3d2:	60bb      	str	r3, [r7, #8]
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
 801e3d4:	69ba      	ldr	r2, [r7, #24]
 801e3d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e3d8:	3318      	adds	r3, #24
 801e3da:	009b      	lsls	r3, r3, #2
 801e3dc:	4413      	add	r3, r2
 801e3de:	693a      	ldr	r2, [r7, #16]
 801e3e0:	605a      	str	r2, [r3, #4]
    need_buffer = TRUE;
 801e3e2:	2301      	movs	r3, #1
 801e3e4:	61fb      	str	r3, [r7, #28]
    if (! compptr->component_needed) {
 801e3e6:	6a3b      	ldr	r3, [r7, #32]
 801e3e8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801e3ea:	2b00      	cmp	r3, #0
 801e3ec:	d109      	bne.n	801e402 <jinit_upsampler+0xca>
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
 801e3ee:	69ba      	ldr	r2, [r7, #24]
 801e3f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e3f2:	330c      	adds	r3, #12
 801e3f4:	009b      	lsls	r3, r3, #2
 801e3f6:	4413      	add	r3, r2
 801e3f8:	4a54      	ldr	r2, [pc, #336]	@ (801e54c <jinit_upsampler+0x214>)
 801e3fa:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 801e3fc:	2300      	movs	r3, #0
 801e3fe:	61fb      	str	r3, [r7, #28]
 801e400:	e06f      	b.n	801e4e2 <jinit_upsampler+0x1aa>
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
 801e402:	697a      	ldr	r2, [r7, #20]
 801e404:	68fb      	ldr	r3, [r7, #12]
 801e406:	429a      	cmp	r2, r3
 801e408:	d10d      	bne.n	801e426 <jinit_upsampler+0xee>
 801e40a:	693a      	ldr	r2, [r7, #16]
 801e40c:	68bb      	ldr	r3, [r7, #8]
 801e40e:	429a      	cmp	r2, r3
 801e410:	d109      	bne.n	801e426 <jinit_upsampler+0xee>
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
 801e412:	69ba      	ldr	r2, [r7, #24]
 801e414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e416:	330c      	adds	r3, #12
 801e418:	009b      	lsls	r3, r3, #2
 801e41a:	4413      	add	r3, r2
 801e41c:	4a4c      	ldr	r2, [pc, #304]	@ (801e550 <jinit_upsampler+0x218>)
 801e41e:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 801e420:	2300      	movs	r3, #0
 801e422:	61fb      	str	r3, [r7, #28]
 801e424:	e05d      	b.n	801e4e2 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 801e426:	697b      	ldr	r3, [r7, #20]
 801e428:	005b      	lsls	r3, r3, #1
 801e42a:	68fa      	ldr	r2, [r7, #12]
 801e42c:	429a      	cmp	r2, r3
 801e42e:	d10b      	bne.n	801e448 <jinit_upsampler+0x110>
 801e430:	693a      	ldr	r2, [r7, #16]
 801e432:	68bb      	ldr	r3, [r7, #8]
 801e434:	429a      	cmp	r2, r3
 801e436:	d107      	bne.n	801e448 <jinit_upsampler+0x110>
	       v_in_group == v_out_group) {
      /* Special case for 2h1v upsampling */
      upsample->methods[ci] = h2v1_upsample;
 801e438:	69ba      	ldr	r2, [r7, #24]
 801e43a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e43c:	330c      	adds	r3, #12
 801e43e:	009b      	lsls	r3, r3, #2
 801e440:	4413      	add	r3, r2
 801e442:	4a44      	ldr	r2, [pc, #272]	@ (801e554 <jinit_upsampler+0x21c>)
 801e444:	605a      	str	r2, [r3, #4]
 801e446:	e04c      	b.n	801e4e2 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 801e448:	697b      	ldr	r3, [r7, #20]
 801e44a:	005b      	lsls	r3, r3, #1
 801e44c:	68fa      	ldr	r2, [r7, #12]
 801e44e:	429a      	cmp	r2, r3
 801e450:	d10c      	bne.n	801e46c <jinit_upsampler+0x134>
	       v_in_group * 2 == v_out_group) {
 801e452:	693b      	ldr	r3, [r7, #16]
 801e454:	005b      	lsls	r3, r3, #1
    } else if (h_in_group * 2 == h_out_group &&
 801e456:	68ba      	ldr	r2, [r7, #8]
 801e458:	429a      	cmp	r2, r3
 801e45a:	d107      	bne.n	801e46c <jinit_upsampler+0x134>
      /* Special case for 2h2v upsampling */
      upsample->methods[ci] = h2v2_upsample;
 801e45c:	69ba      	ldr	r2, [r7, #24]
 801e45e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e460:	330c      	adds	r3, #12
 801e462:	009b      	lsls	r3, r3, #2
 801e464:	4413      	add	r3, r2
 801e466:	4a3c      	ldr	r2, [pc, #240]	@ (801e558 <jinit_upsampler+0x220>)
 801e468:	605a      	str	r2, [r3, #4]
 801e46a:	e03a      	b.n	801e4e2 <jinit_upsampler+0x1aa>
    } else if ((h_out_group % h_in_group) == 0 &&
 801e46c:	68fb      	ldr	r3, [r7, #12]
 801e46e:	697a      	ldr	r2, [r7, #20]
 801e470:	fb93 f2f2 	sdiv	r2, r3, r2
 801e474:	6979      	ldr	r1, [r7, #20]
 801e476:	fb01 f202 	mul.w	r2, r1, r2
 801e47a:	1a9b      	subs	r3, r3, r2
 801e47c:	2b00      	cmp	r3, #0
 801e47e:	d127      	bne.n	801e4d0 <jinit_upsampler+0x198>
	       (v_out_group % v_in_group) == 0) {
 801e480:	68bb      	ldr	r3, [r7, #8]
 801e482:	693a      	ldr	r2, [r7, #16]
 801e484:	fb93 f2f2 	sdiv	r2, r3, r2
 801e488:	6939      	ldr	r1, [r7, #16]
 801e48a:	fb01 f202 	mul.w	r2, r1, r2
 801e48e:	1a9b      	subs	r3, r3, r2
    } else if ((h_out_group % h_in_group) == 0 &&
 801e490:	2b00      	cmp	r3, #0
 801e492:	d11d      	bne.n	801e4d0 <jinit_upsampler+0x198>
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
 801e494:	69ba      	ldr	r2, [r7, #24]
 801e496:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e498:	330c      	adds	r3, #12
 801e49a:	009b      	lsls	r3, r3, #2
 801e49c:	4413      	add	r3, r2
 801e49e:	4a2f      	ldr	r2, [pc, #188]	@ (801e55c <jinit_upsampler+0x224>)
 801e4a0:	605a      	str	r2, [r3, #4]
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
 801e4a2:	68fa      	ldr	r2, [r7, #12]
 801e4a4:	697b      	ldr	r3, [r7, #20]
 801e4a6:	fb92 f3f3 	sdiv	r3, r2, r3
 801e4aa:	b2d9      	uxtb	r1, r3
 801e4ac:	69ba      	ldr	r2, [r7, #24]
 801e4ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e4b0:	4413      	add	r3, r2
 801e4b2:	338c      	adds	r3, #140	@ 0x8c
 801e4b4:	460a      	mov	r2, r1
 801e4b6:	701a      	strb	r2, [r3, #0]
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
 801e4b8:	68ba      	ldr	r2, [r7, #8]
 801e4ba:	693b      	ldr	r3, [r7, #16]
 801e4bc:	fb92 f3f3 	sdiv	r3, r2, r3
 801e4c0:	b2d9      	uxtb	r1, r3
 801e4c2:	69ba      	ldr	r2, [r7, #24]
 801e4c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e4c6:	4413      	add	r3, r2
 801e4c8:	3396      	adds	r3, #150	@ 0x96
 801e4ca:	460a      	mov	r2, r1
 801e4cc:	701a      	strb	r2, [r3, #0]
 801e4ce:	e008      	b.n	801e4e2 <jinit_upsampler+0x1aa>
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
 801e4d0:	687b      	ldr	r3, [r7, #4]
 801e4d2:	681b      	ldr	r3, [r3, #0]
 801e4d4:	2227      	movs	r2, #39	@ 0x27
 801e4d6:	615a      	str	r2, [r3, #20]
 801e4d8:	687b      	ldr	r3, [r7, #4]
 801e4da:	681b      	ldr	r3, [r3, #0]
 801e4dc:	681b      	ldr	r3, [r3, #0]
 801e4de:	6878      	ldr	r0, [r7, #4]
 801e4e0:	4798      	blx	r3
    if (need_buffer) {
 801e4e2:	69fb      	ldr	r3, [r7, #28]
 801e4e4:	2b00      	cmp	r3, #0
 801e4e6:	d01b      	beq.n	801e520 <jinit_upsampler+0x1e8>
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801e4e8:	687b      	ldr	r3, [r7, #4]
 801e4ea:	685b      	ldr	r3, [r3, #4]
 801e4ec:	689c      	ldr	r4, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 801e4ee:	687b      	ldr	r3, [r7, #4]
 801e4f0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e4f2:	461a      	mov	r2, r3
				(long) cinfo->max_h_samp_factor),
 801e4f4:	687b      	ldr	r3, [r7, #4]
 801e4f6:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 801e4fa:	4619      	mov	r1, r3
 801e4fc:	4610      	mov	r0, r2
 801e4fe:	f010 fdd7 	bl	802f0b0 <jround_up>
 801e502:	4603      	mov	r3, r0
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801e504:	461a      	mov	r2, r3
	 (JDIMENSION) cinfo->max_v_samp_factor);
 801e506:	687b      	ldr	r3, [r7, #4]
 801e508:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 801e50c:	2101      	movs	r1, #1
 801e50e:	6878      	ldr	r0, [r7, #4]
 801e510:	47a0      	blx	r4
 801e512:	4601      	mov	r1, r0
 801e514:	69ba      	ldr	r2, [r7, #24]
 801e516:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e518:	3302      	adds	r3, #2
 801e51a:	009b      	lsls	r3, r3, #2
 801e51c:	4413      	add	r3, r2
 801e51e:	6059      	str	r1, [r3, #4]
       ci++, compptr++) {
 801e520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e522:	3301      	adds	r3, #1
 801e524:	627b      	str	r3, [r7, #36]	@ 0x24
 801e526:	6a3b      	ldr	r3, [r7, #32]
 801e528:	3358      	adds	r3, #88	@ 0x58
 801e52a:	623b      	str	r3, [r7, #32]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801e52c:	687b      	ldr	r3, [r7, #4]
 801e52e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801e530:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e532:	429a      	cmp	r2, r3
 801e534:	f6ff af2e 	blt.w	801e394 <jinit_upsampler+0x5c>
    }
  }
}
 801e538:	bf00      	nop
 801e53a:	bf00      	nop
 801e53c:	372c      	adds	r7, #44	@ 0x2c
 801e53e:	46bd      	mov	sp, r7
 801e540:	bd90      	pop	{r4, r7, pc}
 801e542:	bf00      	nop
 801e544:	0801dfc5 	.word	0x0801dfc5
 801e548:	0801dff3 	.word	0x0801dff3
 801e54c:	0801e149 	.word	0x0801e149
 801e550:	0801e129 	.word	0x0801e129
 801e554:	0801e233 	.word	0x0801e233
 801e558:	0801e2a5 	.word	0x0801e2a5
 801e55c:	0801e169 	.word	0x0801e169

0801e560 <error_exit>:
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
 801e560:	b580      	push	{r7, lr}
 801e562:	b082      	sub	sp, #8
 801e564:	af00      	add	r7, sp, #0
 801e566:	6078      	str	r0, [r7, #4]
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);
 801e568:	687b      	ldr	r3, [r7, #4]
 801e56a:	681b      	ldr	r3, [r3, #0]
 801e56c:	689b      	ldr	r3, [r3, #8]
 801e56e:	6878      	ldr	r0, [r7, #4]
 801e570:	4798      	blx	r3

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);
 801e572:	6878      	ldr	r0, [r7, #4]
 801e574:	f7f4 fcb1 	bl	8012eda <jpeg_destroy>

  //exit(EXIT_FAILURE);
}
 801e578:	bf00      	nop
 801e57a:	3708      	adds	r7, #8
 801e57c:	46bd      	mov	sp, r7
 801e57e:	bd80      	pop	{r7, pc}

0801e580 <output_message>:
 * not just not use this routine.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
 801e580:	b580      	push	{r7, lr}
 801e582:	b0b4      	sub	sp, #208	@ 0xd0
 801e584:	af00      	add	r7, sp, #0
 801e586:	6078      	str	r0, [r7, #4]
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);
 801e588:	687b      	ldr	r3, [r7, #4]
 801e58a:	681b      	ldr	r3, [r3, #0]
 801e58c:	68db      	ldr	r3, [r3, #12]
 801e58e:	f107 0208 	add.w	r2, r7, #8
 801e592:	4611      	mov	r1, r2
 801e594:	6878      	ldr	r0, [r7, #4]
 801e596:	4798      	blx	r3
#else
  /* Send it to stderr, adding a newline */
//  fprintf(stderr, "%s\n", buffer);
//  printf( "%s\n", buffer);
#endif
}
 801e598:	bf00      	nop
 801e59a:	37d0      	adds	r7, #208	@ 0xd0
 801e59c:	46bd      	mov	sp, r7
 801e59e:	bd80      	pop	{r7, pc}

0801e5a0 <emit_message>:
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
 801e5a0:	b580      	push	{r7, lr}
 801e5a2:	b084      	sub	sp, #16
 801e5a4:	af00      	add	r7, sp, #0
 801e5a6:	6078      	str	r0, [r7, #4]
 801e5a8:	6039      	str	r1, [r7, #0]
  struct jpeg_error_mgr * err = cinfo->err;
 801e5aa:	687b      	ldr	r3, [r7, #4]
 801e5ac:	681b      	ldr	r3, [r3, #0]
 801e5ae:	60fb      	str	r3, [r7, #12]

  if (msg_level < 0) {
 801e5b0:	683b      	ldr	r3, [r7, #0]
 801e5b2:	2b00      	cmp	r3, #0
 801e5b4:	da11      	bge.n	801e5da <emit_message+0x3a>
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
 801e5b6:	68fb      	ldr	r3, [r7, #12]
 801e5b8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801e5ba:	2b00      	cmp	r3, #0
 801e5bc:	d003      	beq.n	801e5c6 <emit_message+0x26>
 801e5be:	68fb      	ldr	r3, [r7, #12]
 801e5c0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801e5c2:	2b02      	cmp	r3, #2
 801e5c4:	dd03      	ble.n	801e5ce <emit_message+0x2e>
      (*err->output_message) (cinfo);
 801e5c6:	68fb      	ldr	r3, [r7, #12]
 801e5c8:	689b      	ldr	r3, [r3, #8]
 801e5ca:	6878      	ldr	r0, [r7, #4]
 801e5cc:	4798      	blx	r3
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
 801e5ce:	68fb      	ldr	r3, [r7, #12]
 801e5d0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801e5d2:	1c5a      	adds	r2, r3, #1
 801e5d4:	68fb      	ldr	r3, [r7, #12]
 801e5d6:	66da      	str	r2, [r3, #108]	@ 0x6c
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}
 801e5d8:	e008      	b.n	801e5ec <emit_message+0x4c>
    if (err->trace_level >= msg_level)
 801e5da:	68fb      	ldr	r3, [r7, #12]
 801e5dc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801e5de:	683a      	ldr	r2, [r7, #0]
 801e5e0:	429a      	cmp	r2, r3
 801e5e2:	dc03      	bgt.n	801e5ec <emit_message+0x4c>
      (*err->output_message) (cinfo);
 801e5e4:	68fb      	ldr	r3, [r7, #12]
 801e5e6:	689b      	ldr	r3, [r3, #8]
 801e5e8:	6878      	ldr	r0, [r7, #4]
 801e5ea:	4798      	blx	r3
}
 801e5ec:	bf00      	nop
 801e5ee:	3710      	adds	r7, #16
 801e5f0:	46bd      	mov	sp, r7
 801e5f2:	bd80      	pop	{r7, pc}

0801e5f4 <format_message>:
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
 801e5f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e5f6:	b091      	sub	sp, #68	@ 0x44
 801e5f8:	af06      	add	r7, sp, #24
 801e5fa:	60f8      	str	r0, [r7, #12]
 801e5fc:	60b9      	str	r1, [r7, #8]
  struct jpeg_error_mgr * err = cinfo->err;
 801e5fe:	68fb      	ldr	r3, [r7, #12]
 801e600:	681b      	ldr	r3, [r3, #0]
 801e602:	61bb      	str	r3, [r7, #24]
  int msg_code = err->msg_code;
 801e604:	69bb      	ldr	r3, [r7, #24]
 801e606:	695b      	ldr	r3, [r3, #20]
 801e608:	617b      	str	r3, [r7, #20]
  const char * msgtext = NULL;
 801e60a:	2300      	movs	r3, #0
 801e60c:	627b      	str	r3, [r7, #36]	@ 0x24
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
 801e60e:	697b      	ldr	r3, [r7, #20]
 801e610:	2b00      	cmp	r3, #0
 801e612:	dd0c      	ble.n	801e62e <format_message+0x3a>
 801e614:	69bb      	ldr	r3, [r7, #24]
 801e616:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801e618:	697a      	ldr	r2, [r7, #20]
 801e61a:	429a      	cmp	r2, r3
 801e61c:	dc07      	bgt.n	801e62e <format_message+0x3a>
    msgtext = err->jpeg_message_table[msg_code];
 801e61e:	69bb      	ldr	r3, [r7, #24]
 801e620:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 801e622:	697b      	ldr	r3, [r7, #20]
 801e624:	009b      	lsls	r3, r3, #2
 801e626:	4413      	add	r3, r2
 801e628:	681b      	ldr	r3, [r3, #0]
 801e62a:	627b      	str	r3, [r7, #36]	@ 0x24
 801e62c:	e018      	b.n	801e660 <format_message+0x6c>
  } else if (err->addon_message_table != NULL &&
 801e62e:	69bb      	ldr	r3, [r7, #24]
 801e630:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801e632:	2b00      	cmp	r3, #0
 801e634:	d014      	beq.n	801e660 <format_message+0x6c>
	     msg_code >= err->first_addon_message &&
 801e636:	69bb      	ldr	r3, [r7, #24]
 801e638:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
  } else if (err->addon_message_table != NULL &&
 801e63a:	697a      	ldr	r2, [r7, #20]
 801e63c:	429a      	cmp	r2, r3
 801e63e:	db0f      	blt.n	801e660 <format_message+0x6c>
	     msg_code <= err->last_addon_message) {
 801e640:	69bb      	ldr	r3, [r7, #24]
 801e642:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
	     msg_code >= err->first_addon_message &&
 801e646:	697a      	ldr	r2, [r7, #20]
 801e648:	429a      	cmp	r2, r3
 801e64a:	dc09      	bgt.n	801e660 <format_message+0x6c>
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
 801e64c:	69bb      	ldr	r3, [r7, #24]
 801e64e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 801e650:	69bb      	ldr	r3, [r7, #24]
 801e652:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 801e654:	6979      	ldr	r1, [r7, #20]
 801e656:	1acb      	subs	r3, r1, r3
 801e658:	009b      	lsls	r3, r3, #2
 801e65a:	4413      	add	r3, r2
 801e65c:	681b      	ldr	r3, [r3, #0]
 801e65e:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
 801e660:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e662:	2b00      	cmp	r3, #0
 801e664:	d106      	bne.n	801e674 <format_message+0x80>
    err->msg_parm.i[0] = msg_code;
 801e666:	69bb      	ldr	r3, [r7, #24]
 801e668:	697a      	ldr	r2, [r7, #20]
 801e66a:	619a      	str	r2, [r3, #24]
    msgtext = err->jpeg_message_table[0];
 801e66c:	69bb      	ldr	r3, [r7, #24]
 801e66e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801e670:	681b      	ldr	r3, [r3, #0]
 801e672:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
 801e674:	2300      	movs	r3, #0
 801e676:	61fb      	str	r3, [r7, #28]
  msgptr = msgtext;
 801e678:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e67a:	623b      	str	r3, [r7, #32]
  while ((ch = *msgptr++) != '\0') {
 801e67c:	e009      	b.n	801e692 <format_message+0x9e>
    if (ch == '%') {
 801e67e:	7cfb      	ldrb	r3, [r7, #19]
 801e680:	2b25      	cmp	r3, #37	@ 0x25
 801e682:	d106      	bne.n	801e692 <format_message+0x9e>
      if (*msgptr == 's') isstring = TRUE;
 801e684:	6a3b      	ldr	r3, [r7, #32]
 801e686:	781b      	ldrb	r3, [r3, #0]
 801e688:	2b73      	cmp	r3, #115	@ 0x73
 801e68a:	d10b      	bne.n	801e6a4 <format_message+0xb0>
 801e68c:	2301      	movs	r3, #1
 801e68e:	61fb      	str	r3, [r7, #28]
      break;
 801e690:	e008      	b.n	801e6a4 <format_message+0xb0>
  while ((ch = *msgptr++) != '\0') {
 801e692:	6a3b      	ldr	r3, [r7, #32]
 801e694:	1c5a      	adds	r2, r3, #1
 801e696:	623a      	str	r2, [r7, #32]
 801e698:	781b      	ldrb	r3, [r3, #0]
 801e69a:	74fb      	strb	r3, [r7, #19]
 801e69c:	7cfb      	ldrb	r3, [r7, #19]
 801e69e:	2b00      	cmp	r3, #0
 801e6a0:	d1ed      	bne.n	801e67e <format_message+0x8a>
 801e6a2:	e000      	b.n	801e6a6 <format_message+0xb2>
      break;
 801e6a4:	bf00      	nop
    }
  }

  /* Format the message into the passed buffer */
  if (isstring)
 801e6a6:	69fb      	ldr	r3, [r7, #28]
 801e6a8:	2b00      	cmp	r3, #0
 801e6aa:	d007      	beq.n	801e6bc <format_message+0xc8>
    sprintf(buffer, msgtext, err->msg_parm.s);
 801e6ac:	69bb      	ldr	r3, [r7, #24]
 801e6ae:	3318      	adds	r3, #24
 801e6b0:	461a      	mov	r2, r3
 801e6b2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801e6b4:	68b8      	ldr	r0, [r7, #8]
 801e6b6:	f011 f953 	bl	802f960 <siprintf>
    sprintf(buffer, msgtext,
	    err->msg_parm.i[0], err->msg_parm.i[1],
	    err->msg_parm.i[2], err->msg_parm.i[3],
	    err->msg_parm.i[4], err->msg_parm.i[5],
	    err->msg_parm.i[6], err->msg_parm.i[7]);
}
 801e6ba:	e01c      	b.n	801e6f6 <format_message+0x102>
    sprintf(buffer, msgtext,
 801e6bc:	69bb      	ldr	r3, [r7, #24]
 801e6be:	699e      	ldr	r6, [r3, #24]
 801e6c0:	69bb      	ldr	r3, [r7, #24]
 801e6c2:	69db      	ldr	r3, [r3, #28]
 801e6c4:	607b      	str	r3, [r7, #4]
 801e6c6:	69bb      	ldr	r3, [r7, #24]
 801e6c8:	6a1b      	ldr	r3, [r3, #32]
 801e6ca:	69ba      	ldr	r2, [r7, #24]
 801e6cc:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 801e6ce:	69b9      	ldr	r1, [r7, #24]
 801e6d0:	6a89      	ldr	r1, [r1, #40]	@ 0x28
 801e6d2:	69b8      	ldr	r0, [r7, #24]
 801e6d4:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 801e6d6:	69bc      	ldr	r4, [r7, #24]
 801e6d8:	6b24      	ldr	r4, [r4, #48]	@ 0x30
 801e6da:	69bd      	ldr	r5, [r7, #24]
 801e6dc:	6b6d      	ldr	r5, [r5, #52]	@ 0x34
 801e6de:	9505      	str	r5, [sp, #20]
 801e6e0:	9404      	str	r4, [sp, #16]
 801e6e2:	9003      	str	r0, [sp, #12]
 801e6e4:	9102      	str	r1, [sp, #8]
 801e6e6:	9201      	str	r2, [sp, #4]
 801e6e8:	9300      	str	r3, [sp, #0]
 801e6ea:	687b      	ldr	r3, [r7, #4]
 801e6ec:	4632      	mov	r2, r6
 801e6ee:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801e6f0:	68b8      	ldr	r0, [r7, #8]
 801e6f2:	f011 f935 	bl	802f960 <siprintf>
}
 801e6f6:	bf00      	nop
 801e6f8:	372c      	adds	r7, #44	@ 0x2c
 801e6fa:	46bd      	mov	sp, r7
 801e6fc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801e6fe <reset_error_mgr>:
 * this method if it has additional error processing state.
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
 801e6fe:	b480      	push	{r7}
 801e700:	b083      	sub	sp, #12
 801e702:	af00      	add	r7, sp, #0
 801e704:	6078      	str	r0, [r7, #4]
  cinfo->err->num_warnings = 0;
 801e706:	687b      	ldr	r3, [r7, #4]
 801e708:	681b      	ldr	r3, [r3, #0]
 801e70a:	2200      	movs	r2, #0
 801e70c:	66da      	str	r2, [r3, #108]	@ 0x6c
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
 801e70e:	687b      	ldr	r3, [r7, #4]
 801e710:	681b      	ldr	r3, [r3, #0]
 801e712:	2200      	movs	r2, #0
 801e714:	615a      	str	r2, [r3, #20]
}
 801e716:	bf00      	nop
 801e718:	370c      	adds	r7, #12
 801e71a:	46bd      	mov	sp, r7
 801e71c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e720:	4770      	bx	lr
	...

0801e724 <jpeg_std_error>:
 * after which the application may override some of the methods.
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{
 801e724:	b480      	push	{r7}
 801e726:	b083      	sub	sp, #12
 801e728:	af00      	add	r7, sp, #0
 801e72a:	6078      	str	r0, [r7, #4]
  err->error_exit = error_exit;
 801e72c:	687b      	ldr	r3, [r7, #4]
 801e72e:	4a17      	ldr	r2, [pc, #92]	@ (801e78c <jpeg_std_error+0x68>)
 801e730:	601a      	str	r2, [r3, #0]
  err->emit_message = emit_message;
 801e732:	687b      	ldr	r3, [r7, #4]
 801e734:	4a16      	ldr	r2, [pc, #88]	@ (801e790 <jpeg_std_error+0x6c>)
 801e736:	605a      	str	r2, [r3, #4]
  err->output_message = output_message;
 801e738:	687b      	ldr	r3, [r7, #4]
 801e73a:	4a16      	ldr	r2, [pc, #88]	@ (801e794 <jpeg_std_error+0x70>)
 801e73c:	609a      	str	r2, [r3, #8]
  err->format_message = format_message;
 801e73e:	687b      	ldr	r3, [r7, #4]
 801e740:	4a15      	ldr	r2, [pc, #84]	@ (801e798 <jpeg_std_error+0x74>)
 801e742:	60da      	str	r2, [r3, #12]
  err->reset_error_mgr = reset_error_mgr;
 801e744:	687b      	ldr	r3, [r7, #4]
 801e746:	4a15      	ldr	r2, [pc, #84]	@ (801e79c <jpeg_std_error+0x78>)
 801e748:	611a      	str	r2, [r3, #16]

  err->trace_level = 0;		/* default = no tracing */
 801e74a:	687b      	ldr	r3, [r7, #4]
 801e74c:	2200      	movs	r2, #0
 801e74e:	669a      	str	r2, [r3, #104]	@ 0x68
  err->num_warnings = 0;	/* no warnings emitted yet */
 801e750:	687b      	ldr	r3, [r7, #4]
 801e752:	2200      	movs	r2, #0
 801e754:	66da      	str	r2, [r3, #108]	@ 0x6c
  err->msg_code = 0;		/* may be useful as a flag for "no error" */
 801e756:	687b      	ldr	r3, [r7, #4]
 801e758:	2200      	movs	r2, #0
 801e75a:	615a      	str	r2, [r3, #20]

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
 801e75c:	687b      	ldr	r3, [r7, #4]
 801e75e:	4a10      	ldr	r2, [pc, #64]	@ (801e7a0 <jpeg_std_error+0x7c>)
 801e760:	671a      	str	r2, [r3, #112]	@ 0x70
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
 801e762:	687b      	ldr	r3, [r7, #4]
 801e764:	227e      	movs	r2, #126	@ 0x7e
 801e766:	675a      	str	r2, [r3, #116]	@ 0x74

  err->addon_message_table = NULL;
 801e768:	687b      	ldr	r3, [r7, #4]
 801e76a:	2200      	movs	r2, #0
 801e76c:	679a      	str	r2, [r3, #120]	@ 0x78
  err->first_addon_message = 0;	/* for safety */
 801e76e:	687b      	ldr	r3, [r7, #4]
 801e770:	2200      	movs	r2, #0
 801e772:	67da      	str	r2, [r3, #124]	@ 0x7c
  err->last_addon_message = 0;
 801e774:	687b      	ldr	r3, [r7, #4]
 801e776:	2200      	movs	r2, #0
 801e778:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return err;
 801e77c:	687b      	ldr	r3, [r7, #4]
}
 801e77e:	4618      	mov	r0, r3
 801e780:	370c      	adds	r7, #12
 801e782:	46bd      	mov	sp, r7
 801e784:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e788:	4770      	bx	lr
 801e78a:	bf00      	nop
 801e78c:	0801e561 	.word	0x0801e561
 801e790:	0801e5a1 	.word	0x0801e5a1
 801e794:	0801e581 	.word	0x0801e581
 801e798:	0801e5f5 	.word	0x0801e5f5
 801e79c:	0801e6ff 	.word	0x0801e6ff
 801e7a0:	08032434 	.word	0x08032434

0801e7a4 <jpeg_idct_float>:

GLOBAL(void)
jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801e7a4:	b490      	push	{r4, r7}
 801e7a6:	b0dc      	sub	sp, #368	@ 0x170
 801e7a8:	af00      	add	r7, sp, #0
 801e7aa:	f507 74b8 	add.w	r4, r7, #368	@ 0x170
 801e7ae:	f5a4 74b2 	sub.w	r4, r4, #356	@ 0x164
 801e7b2:	6020      	str	r0, [r4, #0]
 801e7b4:	f507 70b8 	add.w	r0, r7, #368	@ 0x170
 801e7b8:	f5a0 70b4 	sub.w	r0, r0, #360	@ 0x168
 801e7bc:	6001      	str	r1, [r0, #0]
 801e7be:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
 801e7c2:	f5a1 71b6 	sub.w	r1, r1, #364	@ 0x16c
 801e7c6:	600a      	str	r2, [r1, #0]
 801e7c8:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
 801e7cc:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
 801e7d0:	6013      	str	r3, [r2, #0]
  FAST_FLOAT z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  FLOAT_MULT_TYPE * quantptr;
  FAST_FLOAT * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 801e7d2:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801e7d6:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 801e7da:	681b      	ldr	r3, [r3, #0]
 801e7dc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801e7e0:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
  int ctr;
  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801e7e4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801e7e8:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 801e7ec:	681b      	ldr	r3, [r3, #0]
 801e7ee:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
 801e7f2:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
 801e7f6:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 801e7fa:	681b      	ldr	r3, [r3, #0]
 801e7fc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801e7fe:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
  wsptr = workspace;
 801e802:	f107 0310 	add.w	r3, r7, #16
 801e806:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801e80a:	2308      	movs	r3, #8
 801e80c:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801e810:	e230      	b.n	801ec74 <jpeg_idct_float+0x4d0>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801e812:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e816:	3310      	adds	r3, #16
 801e818:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e81c:	2b00      	cmp	r3, #0
 801e81e:	d178      	bne.n	801e912 <jpeg_idct_float+0x16e>
 801e820:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e824:	3320      	adds	r3, #32
 801e826:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e82a:	2b00      	cmp	r3, #0
 801e82c:	d171      	bne.n	801e912 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801e82e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e832:	3330      	adds	r3, #48	@ 0x30
 801e834:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801e838:	2b00      	cmp	r3, #0
 801e83a:	d16a      	bne.n	801e912 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801e83c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e840:	3340      	adds	r3, #64	@ 0x40
 801e842:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e846:	2b00      	cmp	r3, #0
 801e848:	d163      	bne.n	801e912 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801e84a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e84e:	3350      	adds	r3, #80	@ 0x50
 801e850:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801e854:	2b00      	cmp	r3, #0
 801e856:	d15c      	bne.n	801e912 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801e858:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e85c:	3360      	adds	r3, #96	@ 0x60
 801e85e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e862:	2b00      	cmp	r3, #0
 801e864:	d155      	bne.n	801e912 <jpeg_idct_float+0x16e>
	inptr[DCTSIZE*7] == 0) {
 801e866:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e86a:	3370      	adds	r3, #112	@ 0x70
 801e86c:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801e870:	2b00      	cmp	r3, #0
 801e872:	d14e      	bne.n	801e912 <jpeg_idct_float+0x16e>
      /* AC terms all zero */
      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801e874:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e878:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e87c:	ee07 3a90 	vmov	s15, r3
 801e880:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e884:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e888:	edd3 7a00 	vldr	s15, [r3]
 801e88c:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e890:	edc7 7a44 	vstr	s15, [r7, #272]	@ 0x110
      
      wsptr[DCTSIZE*0] = dcval;
 801e894:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e898:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e89c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801e89e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8a2:	3320      	adds	r3, #32
 801e8a4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8a8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801e8aa:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8ae:	3340      	adds	r3, #64	@ 0x40
 801e8b0:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8b4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801e8b6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8ba:	3360      	adds	r3, #96	@ 0x60
 801e8bc:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8c0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801e8c2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8c6:	3380      	adds	r3, #128	@ 0x80
 801e8c8:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8cc:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801e8ce:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8d2:	33a0      	adds	r3, #160	@ 0xa0
 801e8d4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8d8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801e8da:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8de:	33c0      	adds	r3, #192	@ 0xc0
 801e8e0:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8e4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801e8e6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e8ea:	33e0      	adds	r3, #224	@ 0xe0
 801e8ec:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801e8f0:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 801e8f2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e8f6:	3302      	adds	r3, #2
 801e8f8:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      quantptr++;
 801e8fc:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e900:	3304      	adds	r3, #4
 801e902:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
      wsptr++;
 801e906:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801e90a:	3304      	adds	r3, #4
 801e90c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
      continue;
 801e910:	e1ab      	b.n	801ec6a <jpeg_idct_float+0x4c6>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801e912:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e916:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e91a:	ee07 3a90 	vmov	s15, r3
 801e91e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e922:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e926:	edd3 7a00 	vldr	s15, [r3]
 801e92a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e92e:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801e932:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e936:	3320      	adds	r3, #32
 801e938:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e93c:	ee07 3a90 	vmov	s15, r3
 801e940:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e944:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e948:	3340      	adds	r3, #64	@ 0x40
 801e94a:	edd3 7a00 	vldr	s15, [r3]
 801e94e:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e952:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801e956:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e95a:	3340      	adds	r3, #64	@ 0x40
 801e95c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e960:	ee07 3a90 	vmov	s15, r3
 801e964:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e968:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e96c:	3380      	adds	r3, #128	@ 0x80
 801e96e:	edd3 7a00 	vldr	s15, [r3]
 801e972:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e976:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801e97a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801e97e:	3360      	adds	r3, #96	@ 0x60
 801e980:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e984:	ee07 3a90 	vmov	s15, r3
 801e988:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e98c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801e990:	33c0      	adds	r3, #192	@ 0xc0
 801e992:	edd3 7a00 	vldr	s15, [r3]
 801e996:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e99a:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801e99e:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801e9a2:	edd7 7a4d 	vldr	s15, [r7, #308]	@ 0x134
 801e9a6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e9aa:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp11 = tmp0 - tmp2;
 801e9ae:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801e9b2:	edd7 7a4d 	vldr	s15, [r7, #308]	@ 0x134
 801e9b6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e9ba:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801e9be:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801e9c2:	edd7 7a4f 	vldr	s15, [r7, #316]	@ 0x13c
 801e9c6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e9ca:	edc7 7a52 	vstr	s15, [r7, #328]	@ 0x148
    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */
 801e9ce:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801e9d2:	edd7 7a4f 	vldr	s15, [r7, #316]	@ 0x13c
 801e9d6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e9da:	ed9f 7aae 	vldr	s14, [pc, #696]	@ 801ec94 <jpeg_idct_float+0x4f0>
 801e9de:	ee27 7a87 	vmul.f32	s14, s15, s14
 801e9e2:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801e9e6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e9ea:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 801e9ee:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801e9f2:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801e9f6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e9fa:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp3 = tmp10 - tmp13;
 801e9fe:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801ea02:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801ea06:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ea0a:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c
    tmp1 = tmp11 + tmp12;
 801ea0e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801ea12:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801ea16:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ea1a:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = tmp11 - tmp12;
 801ea1e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801ea22:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801ea26:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ea2a:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ea2e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ea32:	3310      	adds	r3, #16
 801ea34:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ea38:	ee07 3a90 	vmov	s15, r3
 801ea3c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801ea40:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801ea44:	3320      	adds	r3, #32
 801ea46:	edd3 7a00 	vldr	s15, [r3]
 801ea4a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801ea4e:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801ea52:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ea56:	3330      	adds	r3, #48	@ 0x30
 801ea58:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ea5c:	ee07 3a90 	vmov	s15, r3
 801ea60:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801ea64:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801ea68:	3360      	adds	r3, #96	@ 0x60
 801ea6a:	edd3 7a00 	vldr	s15, [r3]
 801ea6e:	ee67 7a27 	vmul.f32	s15, s14, s15
 801ea72:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801ea76:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ea7a:	3350      	adds	r3, #80	@ 0x50
 801ea7c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ea80:	ee07 3a90 	vmov	s15, r3
 801ea84:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801ea88:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801ea8c:	33a0      	adds	r3, #160	@ 0xa0
 801ea8e:	edd3 7a00 	vldr	s15, [r3]
 801ea92:	ee67 7a27 	vmul.f32	s15, s14, s15
 801ea96:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801ea9a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ea9e:	3370      	adds	r3, #112	@ 0x70
 801eaa0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801eaa4:	ee07 3a90 	vmov	s15, r3
 801eaa8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801eaac:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801eab0:	33e0      	adds	r3, #224	@ 0xe0
 801eab2:	edd3 7a00 	vldr	s15, [r3]
 801eab6:	ee67 7a27 	vmul.f32	s15, s14, s15
 801eaba:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120

    z13 = tmp6 + tmp5;		/* phase 6 */
 801eabe:	ed97 7a47 	vldr	s14, [r7, #284]	@ 0x11c
 801eac2:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801eac6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eaca:	edc7 7a4c 	vstr	s15, [r7, #304]	@ 0x130
    z10 = tmp6 - tmp5;
 801eace:	ed97 7a47 	vldr	s14, [r7, #284]	@ 0x11c
 801ead2:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ead6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eada:	edc7 7a4b 	vstr	s15, [r7, #300]	@ 0x12c
    z11 = tmp4 + tmp7;
 801eade:	ed97 7a45 	vldr	s14, [r7, #276]	@ 0x114
 801eae2:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eae6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eaea:	edc7 7a4a 	vstr	s15, [r7, #296]	@ 0x128
    z12 = tmp4 - tmp7;
 801eaee:	ed97 7a45 	vldr	s14, [r7, #276]	@ 0x114
 801eaf2:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eaf6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eafa:	edc7 7a49 	vstr	s15, [r7, #292]	@ 0x124

    tmp7 = z11 + z13;		/* phase 5 */
 801eafe:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801eb02:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801eb06:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eb0a:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */
 801eb0e:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801eb12:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801eb16:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb1a:	ed9f 7a5e 	vldr	s14, [pc, #376]	@ 801ec94 <jpeg_idct_float+0x4f0>
 801eb1e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801eb22:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 801eb26:	ed97 7a4b 	vldr	s14, [r7, #300]	@ 0x12c
 801eb2a:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801eb2e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eb32:	ed9f 7a59 	vldr	s14, [pc, #356]	@ 801ec98 <jpeg_idct_float+0x4f4>
 801eb36:	ee67 7a87 	vmul.f32	s15, s15, s14
 801eb3a:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 801eb3e:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801eb42:	ed9f 7a56 	vldr	s14, [pc, #344]	@ 801ec9c <jpeg_idct_float+0x4f8>
 801eb46:	ee67 7a87 	vmul.f32	s15, s15, s14
 801eb4a:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801eb4e:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb52:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 801eb56:	edd7 7a4b 	vldr	s15, [r7, #300]	@ 0x12c
 801eb5a:	ed9f 7a51 	vldr	s14, [pc, #324]	@ 801eca0 <jpeg_idct_float+0x4fc>
 801eb5e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801eb62:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801eb66:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb6a:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801eb6e:	ed97 7a51 	vldr	s14, [r7, #324]	@ 0x144
 801eb72:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eb76:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb7a:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp5 = tmp11 - tmp6;
 801eb7e:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801eb82:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801eb86:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb8a:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp4 = tmp10 - tmp5;
 801eb8e:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801eb92:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801eb96:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eb9a:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114

    wsptr[DCTSIZE*0] = tmp0 + tmp7;
 801eb9e:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801eba2:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eba6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ebaa:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ebae:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*7] = tmp0 - tmp7;
 801ebb2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ebb6:	33e0      	adds	r3, #224	@ 0xe0
 801ebb8:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801ebbc:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801ebc0:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ebc4:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*1] = tmp1 + tmp6;
 801ebc8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ebcc:	3320      	adds	r3, #32
 801ebce:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801ebd2:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801ebd6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ebda:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*6] = tmp1 - tmp6;
 801ebde:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ebe2:	33c0      	adds	r3, #192	@ 0xc0
 801ebe4:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801ebe8:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801ebec:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ebf0:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*2] = tmp2 + tmp5;
 801ebf4:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ebf8:	3340      	adds	r3, #64	@ 0x40
 801ebfa:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801ebfe:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ec02:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ec06:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*5] = tmp2 - tmp5;
 801ec0a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ec0e:	33a0      	adds	r3, #160	@ 0xa0
 801ec10:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801ec14:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ec18:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ec1c:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*3] = tmp3 + tmp4;
 801ec20:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ec24:	3360      	adds	r3, #96	@ 0x60
 801ec26:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801ec2a:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801ec2e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ec32:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*4] = tmp3 - tmp4;
 801ec36:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ec3a:	3380      	adds	r3, #128	@ 0x80
 801ec3c:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801ec40:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801ec44:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ec48:	edc3 7a00 	vstr	s15, [r3]

    inptr++;			/* advance pointers to next column */
 801ec4c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801ec50:	3302      	adds	r3, #2
 801ec52:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    quantptr++;
 801ec56:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801ec5a:	3304      	adds	r3, #4
 801ec5c:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    wsptr++;
 801ec60:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ec64:	3304      	adds	r3, #4
 801ec66:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801ec6a:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801ec6e:	3b01      	subs	r3, #1
 801ec70:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801ec74:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801ec78:	2b00      	cmp	r3, #0
 801ec7a:	f73f adca 	bgt.w	801e812 <jpeg_idct_float+0x6e>
  }
  
  /* Pass 2: process rows from work array, store into output array. */

  wsptr = workspace;
 801ec7e:	f107 0310 	add.w	r3, r7, #16
 801ec82:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801ec86:	2300      	movs	r3, #0
 801ec88:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801ec8c:	e1ae      	b.n	801efec <jpeg_idct_float+0x848>
 801ec8e:	bf00      	nop
 801ec90:	43008000 	.word	0x43008000
 801ec94:	3fb504f3 	.word	0x3fb504f3
 801ec98:	3fec835e 	.word	0x3fec835e
 801ec9c:	3f8a8bd4 	.word	0x3f8a8bd4
 801eca0:	40273d75 	.word	0x40273d75
    outptr = output_buf[ctr] + output_col;
 801eca4:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801eca8:	009b      	lsls	r3, r3, #2
 801ecaa:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
 801ecae:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
 801ecb2:	6812      	ldr	r2, [r2, #0]
 801ecb4:	4413      	add	r3, r2
 801ecb6:	681a      	ldr	r2, [r3, #0]
 801ecb8:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 801ecbc:	4413      	add	r3, r2
 801ecbe:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
     */
    
    /* Even part */

    /* Apply signed->unsigned and prepare float->int conversion */
    z5 = wsptr[0] + ((FAST_FLOAT) CENTERJSAMPLE + (FAST_FLOAT) 0.5);
 801ecc2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ecc6:	edd3 7a00 	vldr	s15, [r3]
 801ecca:	ed1f 7a0f 	vldr	s14, [pc, #-60]	@ 801ec90 <jpeg_idct_float+0x4ec>
 801ecce:	ee77 7a87 	vadd.f32	s15, s15, s14
 801ecd2:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 + wsptr[4];
 801ecd6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ecda:	3310      	adds	r3, #16
 801ecdc:	edd3 7a00 	vldr	s15, [r3]
 801ece0:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ece4:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ece8:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp11 = z5 - wsptr[4];
 801ecec:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ecf0:	3310      	adds	r3, #16
 801ecf2:	edd3 7a00 	vldr	s15, [r3]
 801ecf6:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ecfa:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ecfe:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    tmp13 = wsptr[2] + wsptr[6];
 801ed02:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed06:	3308      	adds	r3, #8
 801ed08:	ed93 7a00 	vldr	s14, [r3]
 801ed0c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed10:	3318      	adds	r3, #24
 801ed12:	edd3 7a00 	vldr	s15, [r3]
 801ed16:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ed1a:	edc7 7a52 	vstr	s15, [r7, #328]	@ 0x148
    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;
 801ed1e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed22:	3308      	adds	r3, #8
 801ed24:	ed93 7a00 	vldr	s14, [r3]
 801ed28:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed2c:	3318      	adds	r3, #24
 801ed2e:	edd3 7a00 	vldr	s15, [r3]
 801ed32:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ed36:	ed1f 7a29 	vldr	s14, [pc, #-164]	@ 801ec94 <jpeg_idct_float+0x4f0>
 801ed3a:	ee27 7a87 	vmul.f32	s14, s15, s14
 801ed3e:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801ed42:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ed46:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp0 = tmp10 + tmp13;
 801ed4a:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801ed4e:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801ed52:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ed56:	edc7 7a50 	vstr	s15, [r7, #320]	@ 0x140
    tmp3 = tmp10 - tmp13;
 801ed5a:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801ed5e:	edd7 7a52 	vldr	s15, [r7, #328]	@ 0x148
 801ed62:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ed66:	edc7 7a4f 	vstr	s15, [r7, #316]	@ 0x13c
    tmp1 = tmp11 + tmp12;
 801ed6a:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801ed6e:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801ed72:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ed76:	edc7 7a4e 	vstr	s15, [r7, #312]	@ 0x138
    tmp2 = tmp11 - tmp12;
 801ed7a:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801ed7e:	edd7 7a51 	vldr	s15, [r7, #324]	@ 0x144
 801ed82:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ed86:	edc7 7a4d 	vstr	s15, [r7, #308]	@ 0x134

    /* Odd part */

    z13 = wsptr[5] + wsptr[3];
 801ed8a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed8e:	3314      	adds	r3, #20
 801ed90:	ed93 7a00 	vldr	s14, [r3]
 801ed94:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ed98:	330c      	adds	r3, #12
 801ed9a:	edd3 7a00 	vldr	s15, [r3]
 801ed9e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eda2:	edc7 7a4c 	vstr	s15, [r7, #304]	@ 0x130
    z10 = wsptr[5] - wsptr[3];
 801eda6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801edaa:	3314      	adds	r3, #20
 801edac:	ed93 7a00 	vldr	s14, [r3]
 801edb0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801edb4:	330c      	adds	r3, #12
 801edb6:	edd3 7a00 	vldr	s15, [r3]
 801edba:	ee77 7a67 	vsub.f32	s15, s14, s15
 801edbe:	edc7 7a4b 	vstr	s15, [r7, #300]	@ 0x12c
    z11 = wsptr[1] + wsptr[7];
 801edc2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801edc6:	3304      	adds	r3, #4
 801edc8:	ed93 7a00 	vldr	s14, [r3]
 801edcc:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801edd0:	331c      	adds	r3, #28
 801edd2:	edd3 7a00 	vldr	s15, [r3]
 801edd6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801edda:	edc7 7a4a 	vstr	s15, [r7, #296]	@ 0x128
    z12 = wsptr[1] - wsptr[7];
 801edde:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801ede2:	3304      	adds	r3, #4
 801ede4:	ed93 7a00 	vldr	s14, [r3]
 801ede8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801edec:	331c      	adds	r3, #28
 801edee:	edd3 7a00 	vldr	s15, [r3]
 801edf2:	ee77 7a67 	vsub.f32	s15, s14, s15
 801edf6:	edc7 7a49 	vstr	s15, [r7, #292]	@ 0x124

    tmp7 = z11 + z13;
 801edfa:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801edfe:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801ee02:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ee06:	edc7 7a48 	vstr	s15, [r7, #288]	@ 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);
 801ee0a:	ed97 7a4a 	vldr	s14, [r7, #296]	@ 0x128
 801ee0e:	edd7 7a4c 	vldr	s15, [r7, #304]	@ 0x130
 801ee12:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee16:	ed1f 7a61 	vldr	s14, [pc, #-388]	@ 801ec94 <jpeg_idct_float+0x4f0>
 801ee1a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ee1e:	edc7 7a53 	vstr	s15, [r7, #332]	@ 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 801ee22:	ed97 7a4b 	vldr	s14, [r7, #300]	@ 0x12c
 801ee26:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801ee2a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ee2e:	ed1f 7a66 	vldr	s14, [pc, #-408]	@ 801ec98 <jpeg_idct_float+0x4f4>
 801ee32:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ee36:	edc7 7a55 	vstr	s15, [r7, #340]	@ 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 801ee3a:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
 801ee3e:	ed1f 7a69 	vldr	s14, [pc, #-420]	@ 801ec9c <jpeg_idct_float+0x4f8>
 801ee42:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ee46:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ee4a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee4e:	edc7 7a54 	vstr	s15, [r7, #336]	@ 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 801ee52:	edd7 7a4b 	vldr	s15, [r7, #300]	@ 0x12c
 801ee56:	ed1f 7a6e 	vldr	s14, [pc, #-440]	@ 801eca0 <jpeg_idct_float+0x4fc>
 801ee5a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ee5e:	ed97 7a55 	vldr	s14, [r7, #340]	@ 0x154
 801ee62:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee66:	edc7 7a51 	vstr	s15, [r7, #324]	@ 0x144

    tmp6 = tmp12 - tmp7;
 801ee6a:	ed97 7a51 	vldr	s14, [r7, #324]	@ 0x144
 801ee6e:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801ee72:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee76:	edc7 7a47 	vstr	s15, [r7, #284]	@ 0x11c
    tmp5 = tmp11 - tmp6;
 801ee7a:	ed97 7a53 	vldr	s14, [r7, #332]	@ 0x14c
 801ee7e:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801ee82:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee86:	edc7 7a46 	vstr	s15, [r7, #280]	@ 0x118
    tmp4 = tmp10 - tmp5;
 801ee8a:	ed97 7a54 	vldr	s14, [r7, #336]	@ 0x150
 801ee8e:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ee92:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ee96:	edc7 7a45 	vstr	s15, [r7, #276]	@ 0x114

    /* Final output stage: float->int conversion and range-limit */

    outptr[0] = range_limit[((int) (tmp0 + tmp7)) & RANGE_MASK];
 801ee9a:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801ee9e:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eea2:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eea6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801eeaa:	ee17 3a90 	vmov	r3, s15
 801eeae:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801eeb2:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801eeb6:	4413      	add	r3, r2
 801eeb8:	781a      	ldrb	r2, [r3, #0]
 801eeba:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801eebe:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[((int) (tmp0 - tmp7)) & RANGE_MASK];
 801eec0:	ed97 7a50 	vldr	s14, [r7, #320]	@ 0x140
 801eec4:	edd7 7a48 	vldr	s15, [r7, #288]	@ 0x120
 801eec8:	ee77 7a67 	vsub.f32	s15, s14, s15
 801eecc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801eed0:	ee17 3a90 	vmov	r3, s15
 801eed4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801eed8:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801eedc:	441a      	add	r2, r3
 801eede:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801eee2:	3307      	adds	r3, #7
 801eee4:	7812      	ldrb	r2, [r2, #0]
 801eee6:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[((int) (tmp1 + tmp6)) & RANGE_MASK];
 801eee8:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801eeec:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801eef0:	ee77 7a27 	vadd.f32	s15, s14, s15
 801eef4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801eef8:	ee17 3a90 	vmov	r3, s15
 801eefc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801ef00:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801ef04:	441a      	add	r2, r3
 801ef06:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801ef0a:	3301      	adds	r3, #1
 801ef0c:	7812      	ldrb	r2, [r2, #0]
 801ef0e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[((int) (tmp1 - tmp6)) & RANGE_MASK];
 801ef10:	ed97 7a4e 	vldr	s14, [r7, #312]	@ 0x138
 801ef14:	edd7 7a47 	vldr	s15, [r7, #284]	@ 0x11c
 801ef18:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ef1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ef20:	ee17 3a90 	vmov	r3, s15
 801ef24:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801ef28:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801ef2c:	441a      	add	r2, r3
 801ef2e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801ef32:	3306      	adds	r3, #6
 801ef34:	7812      	ldrb	r2, [r2, #0]
 801ef36:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[((int) (tmp2 + tmp5)) & RANGE_MASK];
 801ef38:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801ef3c:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ef40:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ef44:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ef48:	ee17 3a90 	vmov	r3, s15
 801ef4c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801ef50:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801ef54:	441a      	add	r2, r3
 801ef56:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801ef5a:	3302      	adds	r3, #2
 801ef5c:	7812      	ldrb	r2, [r2, #0]
 801ef5e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[((int) (tmp2 - tmp5)) & RANGE_MASK];
 801ef60:	ed97 7a4d 	vldr	s14, [r7, #308]	@ 0x134
 801ef64:	edd7 7a46 	vldr	s15, [r7, #280]	@ 0x118
 801ef68:	ee77 7a67 	vsub.f32	s15, s14, s15
 801ef6c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ef70:	ee17 3a90 	vmov	r3, s15
 801ef74:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801ef78:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801ef7c:	441a      	add	r2, r3
 801ef7e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801ef82:	3305      	adds	r3, #5
 801ef84:	7812      	ldrb	r2, [r2, #0]
 801ef86:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[((int) (tmp3 + tmp4)) & RANGE_MASK];
 801ef88:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801ef8c:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801ef90:	ee77 7a27 	vadd.f32	s15, s14, s15
 801ef94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ef98:	ee17 3a90 	vmov	r3, s15
 801ef9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801efa0:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801efa4:	441a      	add	r2, r3
 801efa6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801efaa:	3303      	adds	r3, #3
 801efac:	7812      	ldrb	r2, [r2, #0]
 801efae:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[((int) (tmp3 - tmp4)) & RANGE_MASK];
 801efb0:	ed97 7a4f 	vldr	s14, [r7, #316]	@ 0x13c
 801efb4:	edd7 7a45 	vldr	s15, [r7, #276]	@ 0x114
 801efb8:	ee77 7a67 	vsub.f32	s15, s14, s15
 801efbc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801efc0:	ee17 3a90 	vmov	r3, s15
 801efc4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801efc8:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801efcc:	441a      	add	r2, r3
 801efce:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801efd2:	3304      	adds	r3, #4
 801efd4:	7812      	ldrb	r2, [r2, #0]
 801efd6:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 801efd8:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 801efdc:	3320      	adds	r3, #32
 801efde:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801efe2:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801efe6:	3301      	adds	r3, #1
 801efe8:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
 801efec:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801eff0:	2b07      	cmp	r3, #7
 801eff2:	f77f ae57 	ble.w	801eca4 <jpeg_idct_float+0x500>
  }
}
 801eff6:	bf00      	nop
 801eff8:	bf00      	nop
 801effa:	f507 77b8 	add.w	r7, r7, #368	@ 0x170
 801effe:	46bd      	mov	sp, r7
 801f000:	bc90      	pop	{r4, r7}
 801f002:	4770      	bx	lr

0801f004 <jpeg_idct_ifast>:

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f004:	b490      	push	{r4, r7}
 801f006:	b0de      	sub	sp, #376	@ 0x178
 801f008:	af00      	add	r7, sp, #0
 801f00a:	f507 74bc 	add.w	r4, r7, #376	@ 0x178
 801f00e:	f5a4 74b6 	sub.w	r4, r4, #364	@ 0x16c
 801f012:	6020      	str	r0, [r4, #0]
 801f014:	f507 70bc 	add.w	r0, r7, #376	@ 0x178
 801f018:	f5a0 70b8 	sub.w	r0, r0, #368	@ 0x170
 801f01c:	6001      	str	r1, [r0, #0]
 801f01e:	f507 71bc 	add.w	r1, r7, #376	@ 0x178
 801f022:	f5a1 71ba 	sub.w	r1, r1, #372	@ 0x174
 801f026:	600a      	str	r2, [r1, #0]
 801f028:	f507 72bc 	add.w	r2, r7, #376	@ 0x178
 801f02c:	f5a2 72bc 	sub.w	r2, r2, #376	@ 0x178
 801f030:	6013      	str	r3, [r2, #0]
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  IFAST_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f032:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801f036:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 801f03a:	681b      	ldr	r3, [r3, #0]
 801f03c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f040:	3380      	adds	r3, #128	@ 0x80
 801f042:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
  SHIFT_TEMPS			/* for DESCALE */
  ISHIFT_TEMPS			/* for IDESCALE */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801f046:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801f04a:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 801f04e:	681b      	ldr	r3, [r3, #0]
 801f050:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
 801f054:	f507 73bc 	add.w	r3, r7, #376	@ 0x178
 801f058:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
 801f05c:	681b      	ldr	r3, [r3, #0]
 801f05e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f060:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
  wsptr = workspace;
 801f064:	f107 0314 	add.w	r3, r7, #20
 801f068:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801f06c:	2308      	movs	r3, #8
 801f06e:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801f072:	e1ec      	b.n	801f44e <jpeg_idct_ifast+0x44a>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f074:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f078:	3310      	adds	r3, #16
 801f07a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f07e:	2b00      	cmp	r3, #0
 801f080:	d174      	bne.n	801f16c <jpeg_idct_ifast+0x168>
 801f082:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f086:	3320      	adds	r3, #32
 801f088:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f08c:	2b00      	cmp	r3, #0
 801f08e:	d16d      	bne.n	801f16c <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f090:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f094:	3330      	adds	r3, #48	@ 0x30
 801f096:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f09a:	2b00      	cmp	r3, #0
 801f09c:	d166      	bne.n	801f16c <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f09e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f0a2:	3340      	adds	r3, #64	@ 0x40
 801f0a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0a8:	2b00      	cmp	r3, #0
 801f0aa:	d15f      	bne.n	801f16c <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f0ac:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f0b0:	3350      	adds	r3, #80	@ 0x50
 801f0b2:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f0b6:	2b00      	cmp	r3, #0
 801f0b8:	d158      	bne.n	801f16c <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f0ba:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f0be:	3360      	adds	r3, #96	@ 0x60
 801f0c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0c4:	2b00      	cmp	r3, #0
 801f0c6:	d151      	bne.n	801f16c <jpeg_idct_ifast+0x168>
	inptr[DCTSIZE*7] == 0) {
 801f0c8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f0cc:	3370      	adds	r3, #112	@ 0x70
 801f0ce:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f0d2:	2b00      	cmp	r3, #0
 801f0d4:	d14a      	bne.n	801f16c <jpeg_idct_ifast+0x168>
      /* AC terms all zero */
      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f0d6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f0da:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0de:	461a      	mov	r2, r3
 801f0e0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f0e4:	681b      	ldr	r3, [r3, #0]
 801f0e6:	fb02 f303 	mul.w	r3, r2, r3
 801f0ea:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

      wsptr[DCTSIZE*0] = dcval;
 801f0ee:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f0f2:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f0f6:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801f0f8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f0fc:	3320      	adds	r3, #32
 801f0fe:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f102:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801f104:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f108:	3340      	adds	r3, #64	@ 0x40
 801f10a:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f10e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801f110:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f114:	3360      	adds	r3, #96	@ 0x60
 801f116:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f11a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801f11c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f120:	3380      	adds	r3, #128	@ 0x80
 801f122:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f126:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801f128:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f12c:	33a0      	adds	r3, #160	@ 0xa0
 801f12e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f132:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801f134:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f138:	33c0      	adds	r3, #192	@ 0xc0
 801f13a:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f13e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801f140:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f144:	33e0      	adds	r3, #224	@ 0xe0
 801f146:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f14a:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 801f14c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f150:	3302      	adds	r3, #2
 801f152:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
      quantptr++;
 801f156:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f15a:	3304      	adds	r3, #4
 801f15c:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
      wsptr++;
 801f160:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f164:	3304      	adds	r3, #4
 801f166:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      continue;
 801f16a:	e16b      	b.n	801f444 <jpeg_idct_ifast+0x440>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f16c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f170:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f174:	461a      	mov	r2, r3
 801f176:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f17a:	681b      	ldr	r3, [r3, #0]
 801f17c:	fb02 f303 	mul.w	r3, r2, r3
 801f180:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801f184:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f188:	3320      	adds	r3, #32
 801f18a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f18e:	461a      	mov	r2, r3
 801f190:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f194:	3340      	adds	r3, #64	@ 0x40
 801f196:	681b      	ldr	r3, [r3, #0]
 801f198:	fb02 f303 	mul.w	r3, r2, r3
 801f19c:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801f1a0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f1a4:	3340      	adds	r3, #64	@ 0x40
 801f1a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f1aa:	461a      	mov	r2, r3
 801f1ac:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f1b0:	3380      	adds	r3, #128	@ 0x80
 801f1b2:	681b      	ldr	r3, [r3, #0]
 801f1b4:	fb02 f303 	mul.w	r3, r2, r3
 801f1b8:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801f1bc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f1c0:	3360      	adds	r3, #96	@ 0x60
 801f1c2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f1c6:	461a      	mov	r2, r3
 801f1c8:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f1cc:	33c0      	adds	r3, #192	@ 0xc0
 801f1ce:	681b      	ldr	r3, [r3, #0]
 801f1d0:	fb02 f303 	mul.w	r3, r2, r3
 801f1d4:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801f1d8:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f1dc:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801f1e0:	4413      	add	r3, r2
 801f1e2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp11 = tmp0 - tmp2;
 801f1e6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f1ea:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801f1ee:	1ad3      	subs	r3, r2, r3
 801f1f0:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801f1f4:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f1f8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801f1fc:	4413      	add	r3, r2
 801f1fe:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
 801f202:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f206:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 801f20a:	1ad3      	subs	r3, r2, r3
 801f20c:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801f210:	fb02 f303 	mul.w	r3, r2, r3
 801f214:	121a      	asrs	r2, r3, #8
 801f216:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f21a:	1ad3      	subs	r3, r2, r3
 801f21c:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 801f220:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f224:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f228:	4413      	add	r3, r2
 801f22a:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp3 = tmp10 - tmp13;
 801f22e:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f232:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f236:	1ad3      	subs	r3, r2, r3
 801f238:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp1 = tmp11 + tmp12;
 801f23c:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f240:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f244:	4413      	add	r3, r2
 801f246:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = tmp11 - tmp12;
 801f24a:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f24e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f252:	1ad3      	subs	r3, r2, r3
 801f254:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801f258:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f25c:	3310      	adds	r3, #16
 801f25e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f262:	461a      	mov	r2, r3
 801f264:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f268:	3320      	adds	r3, #32
 801f26a:	681b      	ldr	r3, [r3, #0]
 801f26c:	fb02 f303 	mul.w	r3, r2, r3
 801f270:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801f274:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f278:	3330      	adds	r3, #48	@ 0x30
 801f27a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f27e:	461a      	mov	r2, r3
 801f280:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f284:	3360      	adds	r3, #96	@ 0x60
 801f286:	681b      	ldr	r3, [r3, #0]
 801f288:	fb02 f303 	mul.w	r3, r2, r3
 801f28c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801f290:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f294:	3350      	adds	r3, #80	@ 0x50
 801f296:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f29a:	461a      	mov	r2, r3
 801f29c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f2a0:	33a0      	adds	r3, #160	@ 0xa0
 801f2a2:	681b      	ldr	r3, [r3, #0]
 801f2a4:	fb02 f303 	mul.w	r3, r2, r3
 801f2a8:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801f2ac:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f2b0:	3370      	adds	r3, #112	@ 0x70
 801f2b2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f2b6:	461a      	mov	r2, r3
 801f2b8:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f2bc:	33e0      	adds	r3, #224	@ 0xe0
 801f2be:	681b      	ldr	r3, [r3, #0]
 801f2c0:	fb02 f303 	mul.w	r3, r2, r3
 801f2c4:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    z13 = tmp6 + tmp5;		/* phase 6 */
 801f2c8:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801f2cc:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f2d0:	4413      	add	r3, r2
 801f2d2:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z10 = tmp6 - tmp5;
 801f2d6:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801f2da:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f2de:	1ad3      	subs	r3, r2, r3
 801f2e0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z11 = tmp4 + tmp7;
 801f2e4:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801f2e8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f2ec:	4413      	add	r3, r2
 801f2ee:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z12 = tmp4 - tmp7;
 801f2f2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801f2f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f2fa:	1ad3      	subs	r3, r2, r3
 801f2fc:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 801f300:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801f304:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801f308:	4413      	add	r3, r2
 801f30a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 801f30e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801f312:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801f316:	1ad3      	subs	r3, r2, r3
 801f318:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801f31c:	fb02 f303 	mul.w	r3, r2, r3
 801f320:	121b      	asrs	r3, r3, #8
 801f322:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 801f326:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801f32a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801f32e:	4413      	add	r3, r2
 801f330:	f240 12d9 	movw	r2, #473	@ 0x1d9
 801f334:	fb02 f303 	mul.w	r3, r2, r3
 801f338:	121b      	asrs	r3, r3, #8
 801f33a:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 801f33e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801f342:	f240 1215 	movw	r2, #277	@ 0x115
 801f346:	fb02 f303 	mul.w	r3, r2, r3
 801f34a:	121a      	asrs	r2, r3, #8
 801f34c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801f350:	1ad3      	subs	r3, r2, r3
 801f352:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 801f356:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f35a:	f46f 7227 	mvn.w	r2, #668	@ 0x29c
 801f35e:	fb02 f303 	mul.w	r3, r2, r3
 801f362:	121b      	asrs	r3, r3, #8
 801f364:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801f368:	4413      	add	r3, r2
 801f36a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801f36e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f372:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f376:	1ad3      	subs	r3, r2, r3
 801f378:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp5 = tmp11 - tmp6;
 801f37c:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f380:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801f384:	1ad3      	subs	r3, r2, r3
 801f386:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp4 = tmp10 + tmp5;
 801f38a:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f38e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f392:	4413      	add	r3, r2
 801f394:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
 801f398:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f39c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f3a0:	441a      	add	r2, r3
 801f3a2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3a6:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
 801f3a8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3ac:	33e0      	adds	r3, #224	@ 0xe0
 801f3ae:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 801f3b2:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801f3b6:	1a8a      	subs	r2, r1, r2
 801f3b8:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
 801f3ba:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3be:	3320      	adds	r3, #32
 801f3c0:	f8d7 1140 	ldr.w	r1, [r7, #320]	@ 0x140
 801f3c4:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801f3c8:	440a      	add	r2, r1
 801f3ca:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
 801f3cc:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3d0:	33c0      	adds	r3, #192	@ 0xc0
 801f3d2:	f8d7 1140 	ldr.w	r1, [r7, #320]	@ 0x140
 801f3d6:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801f3da:	1a8a      	subs	r2, r1, r2
 801f3dc:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
 801f3de:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3e2:	3340      	adds	r3, #64	@ 0x40
 801f3e4:	f8d7 113c 	ldr.w	r1, [r7, #316]	@ 0x13c
 801f3e8:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801f3ec:	440a      	add	r2, r1
 801f3ee:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
 801f3f0:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f3f4:	33a0      	adds	r3, #160	@ 0xa0
 801f3f6:	f8d7 113c 	ldr.w	r1, [r7, #316]	@ 0x13c
 801f3fa:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801f3fe:	1a8a      	subs	r2, r1, r2
 801f400:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
 801f402:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f406:	3380      	adds	r3, #128	@ 0x80
 801f408:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 801f40c:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801f410:	440a      	add	r2, r1
 801f412:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
 801f414:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f418:	3360      	adds	r3, #96	@ 0x60
 801f41a:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 801f41e:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801f422:	1a8a      	subs	r2, r1, r2
 801f424:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 801f426:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 801f42a:	3302      	adds	r3, #2
 801f42c:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    quantptr++;
 801f430:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 801f434:	3304      	adds	r3, #4
 801f436:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    wsptr++;
 801f43a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f43e:	3304      	adds	r3, #4
 801f440:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801f444:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f448:	3b01      	subs	r3, #1
 801f44a:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801f44e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f452:	2b00      	cmp	r3, #0
 801f454:	f73f ae0e 	bgt.w	801f074 <jpeg_idct_ifast+0x70>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 801f458:	f107 0314 	add.w	r3, r7, #20
 801f45c:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801f460:	2300      	movs	r3, #0
 801f462:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801f466:	e1c8      	b.n	801f7fa <jpeg_idct_ifast+0x7f6>
    outptr = output_buf[ctr] + output_col;
 801f468:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f46c:	009b      	lsls	r3, r3, #2
 801f46e:	f507 72bc 	add.w	r2, r7, #376	@ 0x178
 801f472:	f5a2 72bc 	sub.w	r2, r2, #376	@ 0x178
 801f476:	6812      	ldr	r2, [r2, #0]
 801f478:	4413      	add	r3, r2
 801f47a:	681a      	ldr	r2, [r3, #0]
 801f47c:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 801f480:	4413      	add	r3, r2
 801f482:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801f486:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f48a:	3304      	adds	r3, #4
 801f48c:	681b      	ldr	r3, [r3, #0]
 801f48e:	2b00      	cmp	r3, #0
 801f490:	d164      	bne.n	801f55c <jpeg_idct_ifast+0x558>
 801f492:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f496:	3308      	adds	r3, #8
 801f498:	681b      	ldr	r3, [r3, #0]
 801f49a:	2b00      	cmp	r3, #0
 801f49c:	d15e      	bne.n	801f55c <jpeg_idct_ifast+0x558>
 801f49e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4a2:	330c      	adds	r3, #12
 801f4a4:	681b      	ldr	r3, [r3, #0]
 801f4a6:	2b00      	cmp	r3, #0
 801f4a8:	d158      	bne.n	801f55c <jpeg_idct_ifast+0x558>
 801f4aa:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4ae:	3310      	adds	r3, #16
 801f4b0:	681b      	ldr	r3, [r3, #0]
 801f4b2:	2b00      	cmp	r3, #0
 801f4b4:	d152      	bne.n	801f55c <jpeg_idct_ifast+0x558>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801f4b6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4ba:	3314      	adds	r3, #20
 801f4bc:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801f4be:	2b00      	cmp	r3, #0
 801f4c0:	d14c      	bne.n	801f55c <jpeg_idct_ifast+0x558>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801f4c2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4c6:	3318      	adds	r3, #24
 801f4c8:	681b      	ldr	r3, [r3, #0]
 801f4ca:	2b00      	cmp	r3, #0
 801f4cc:	d146      	bne.n	801f55c <jpeg_idct_ifast+0x558>
 801f4ce:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4d2:	331c      	adds	r3, #28
 801f4d4:	681b      	ldr	r3, [r3, #0]
 801f4d6:	2b00      	cmp	r3, #0
 801f4d8:	d140      	bne.n	801f55c <jpeg_idct_ifast+0x558>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 801f4da:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f4de:	681b      	ldr	r3, [r3, #0]
 801f4e0:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 801f4e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 801f4e6:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f4ea:	4413      	add	r3, r2
 801f4ec:	781b      	ldrb	r3, [r3, #0]
 801f4ee:	f887 315f 	strb.w	r3, [r7, #351]	@ 0x15f
      
      outptr[0] = dcval;
 801f4f2:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f4f6:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f4fa:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 801f4fc:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f500:	3301      	adds	r3, #1
 801f502:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f506:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 801f508:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f50c:	3302      	adds	r3, #2
 801f50e:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f512:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 801f514:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f518:	3303      	adds	r3, #3
 801f51a:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f51e:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 801f520:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f524:	3304      	adds	r3, #4
 801f526:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f52a:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 801f52c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f530:	3305      	adds	r3, #5
 801f532:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f536:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 801f538:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f53c:	3306      	adds	r3, #6
 801f53e:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f542:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 801f544:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f548:	3307      	adds	r3, #7
 801f54a:	f897 215f 	ldrb.w	r2, [r7, #351]	@ 0x15f
 801f54e:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 801f550:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f554:	3320      	adds	r3, #32
 801f556:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
      continue;
 801f55a:	e149      	b.n	801f7f0 <jpeg_idct_ifast+0x7ec>
    }
#endif
    
    /* Even part */

    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
 801f55c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f560:	681a      	ldr	r2, [r3, #0]
 801f562:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f566:	3310      	adds	r3, #16
 801f568:	681b      	ldr	r3, [r3, #0]
 801f56a:	4413      	add	r3, r2
 801f56c:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
 801f570:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f574:	681a      	ldr	r2, [r3, #0]
 801f576:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f57a:	3310      	adds	r3, #16
 801f57c:	681b      	ldr	r3, [r3, #0]
 801f57e:	1ad3      	subs	r3, r2, r3
 801f580:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
 801f584:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f588:	3308      	adds	r3, #8
 801f58a:	681a      	ldr	r2, [r3, #0]
 801f58c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f590:	3318      	adds	r3, #24
 801f592:	681b      	ldr	r3, [r3, #0]
 801f594:	4413      	add	r3, r2
 801f596:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
 801f59a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f59e:	3308      	adds	r3, #8
 801f5a0:	681a      	ldr	r2, [r3, #0]
 801f5a2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f5a6:	3318      	adds	r3, #24
 801f5a8:	681b      	ldr	r3, [r3, #0]
 801f5aa:	1ad3      	subs	r3, r2, r3
 801f5ac:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801f5b0:	fb02 f303 	mul.w	r3, r2, r3
 801f5b4:	121a      	asrs	r2, r3, #8
 801f5b6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f5ba:	1ad3      	subs	r3, r2, r3
 801f5bc:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
	    - tmp13;

    tmp0 = tmp10 + tmp13;
 801f5c0:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f5c4:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f5c8:	4413      	add	r3, r2
 801f5ca:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp3 = tmp10 - tmp13;
 801f5ce:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f5d2:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801f5d6:	1ad3      	subs	r3, r2, r3
 801f5d8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp1 = tmp11 + tmp12;
 801f5dc:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f5e0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f5e4:	4413      	add	r3, r2
 801f5e6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp2 = tmp11 - tmp12;
 801f5ea:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f5ee:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801f5f2:	1ad3      	subs	r3, r2, r3
 801f5f4:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    /* Odd part */

    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
 801f5f8:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f5fc:	3314      	adds	r3, #20
 801f5fe:	681a      	ldr	r2, [r3, #0]
 801f600:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f604:	330c      	adds	r3, #12
 801f606:	681b      	ldr	r3, [r3, #0]
 801f608:	4413      	add	r3, r2
 801f60a:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
 801f60e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f612:	3314      	adds	r3, #20
 801f614:	681a      	ldr	r2, [r3, #0]
 801f616:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f61a:	330c      	adds	r3, #12
 801f61c:	681b      	ldr	r3, [r3, #0]
 801f61e:	1ad3      	subs	r3, r2, r3
 801f620:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
 801f624:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f628:	3304      	adds	r3, #4
 801f62a:	681a      	ldr	r2, [r3, #0]
 801f62c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f630:	331c      	adds	r3, #28
 801f632:	681b      	ldr	r3, [r3, #0]
 801f634:	4413      	add	r3, r2
 801f636:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
 801f63a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f63e:	3304      	adds	r3, #4
 801f640:	681a      	ldr	r2, [r3, #0]
 801f642:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f646:	331c      	adds	r3, #28
 801f648:	681b      	ldr	r3, [r3, #0]
 801f64a:	1ad3      	subs	r3, r2, r3
 801f64c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 801f650:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801f654:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801f658:	4413      	add	r3, r2
 801f65a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 801f65e:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801f662:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801f666:	1ad3      	subs	r3, r2, r3
 801f668:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 801f66c:	fb02 f303 	mul.w	r3, r2, r3
 801f670:	121b      	asrs	r3, r3, #8
 801f672:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 801f676:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801f67a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801f67e:	4413      	add	r3, r2
 801f680:	f240 12d9 	movw	r2, #473	@ 0x1d9
 801f684:	fb02 f303 	mul.w	r3, r2, r3
 801f688:	121b      	asrs	r3, r3, #8
 801f68a:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 801f68e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801f692:	f240 1215 	movw	r2, #277	@ 0x115
 801f696:	fb02 f303 	mul.w	r3, r2, r3
 801f69a:	121a      	asrs	r2, r3, #8
 801f69c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801f6a0:	1ad3      	subs	r3, r2, r3
 801f6a2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 801f6a6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801f6aa:	f46f 7227 	mvn.w	r2, #668	@ 0x29c
 801f6ae:	fb02 f303 	mul.w	r3, r2, r3
 801f6b2:	121b      	asrs	r3, r3, #8
 801f6b4:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801f6b8:	4413      	add	r3, r2
 801f6ba:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801f6be:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801f6c2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f6c6:	1ad3      	subs	r3, r2, r3
 801f6c8:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp5 = tmp11 - tmp6;
 801f6cc:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801f6d0:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801f6d4:	1ad3      	subs	r3, r2, r3
 801f6d6:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp4 = tmp10 + tmp5;
 801f6da:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801f6de:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f6e2:	4413      	add	r3, r2
 801f6e4:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 801f6e8:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f6ec:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f6f0:	4413      	add	r3, r2
 801f6f2:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f6f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 801f6f8:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f6fc:	4413      	add	r3, r2
 801f6fe:	781a      	ldrb	r2, [r3, #0]
 801f700:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f704:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 801f706:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801f70a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801f70e:	1ad3      	subs	r3, r2, r3
 801f710:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f712:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 801f716:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f71a:	441a      	add	r2, r3
 801f71c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f720:	3307      	adds	r3, #7
 801f722:	7812      	ldrb	r2, [r2, #0]
 801f724:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 801f726:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f72a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801f72e:	4413      	add	r3, r2
 801f730:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f732:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 801f736:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f73a:	441a      	add	r2, r3
 801f73c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f740:	3301      	adds	r3, #1
 801f742:	7812      	ldrb	r2, [r2, #0]
 801f744:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 801f746:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f74a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801f74e:	1ad3      	subs	r3, r2, r3
 801f750:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f752:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 801f756:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f75a:	441a      	add	r2, r3
 801f75c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f760:	3306      	adds	r3, #6
 801f762:	7812      	ldrb	r2, [r2, #0]
 801f764:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 801f766:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f76a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f76e:	4413      	add	r3, r2
 801f770:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f772:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 801f776:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f77a:	441a      	add	r2, r3
 801f77c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f780:	3302      	adds	r3, #2
 801f782:	7812      	ldrb	r2, [r2, #0]
 801f784:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 801f786:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801f78a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801f78e:	1ad3      	subs	r3, r2, r3
 801f790:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f792:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 801f796:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f79a:	441a      	add	r2, r3
 801f79c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f7a0:	3305      	adds	r3, #5
 801f7a2:	7812      	ldrb	r2, [r2, #0]
 801f7a4:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 801f7a6:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801f7aa:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801f7ae:	4413      	add	r3, r2
 801f7b0:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f7b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 801f7b6:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f7ba:	441a      	add	r2, r3
 801f7bc:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f7c0:	3304      	adds	r3, #4
 801f7c2:	7812      	ldrb	r2, [r2, #0]
 801f7c4:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 801f7c6:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 801f7ca:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801f7ce:	1ad3      	subs	r3, r2, r3
 801f7d0:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 801f7d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 801f7d6:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 801f7da:	441a      	add	r2, r3
 801f7dc:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 801f7e0:	3303      	adds	r3, #3
 801f7e2:	7812      	ldrb	r2, [r2, #0]
 801f7e4:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 801f7e6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 801f7ea:	3320      	adds	r3, #32
 801f7ec:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801f7f0:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f7f4:	3301      	adds	r3, #1
 801f7f6:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 801f7fa:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801f7fe:	2b07      	cmp	r3, #7
 801f800:	f77f ae32 	ble.w	801f468 <jpeg_idct_ifast+0x464>
  }
}
 801f804:	bf00      	nop
 801f806:	bf00      	nop
 801f808:	f507 77bc 	add.w	r7, r7, #376	@ 0x178
 801f80c:	46bd      	mov	sp, r7
 801f80e:	bc90      	pop	{r4, r7}
 801f810:	4770      	bx	lr
	...

0801f814 <jpeg_idct_islow>:

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f814:	b490      	push	{r4, r7}
 801f816:	b0d8      	sub	sp, #352	@ 0x160
 801f818:	af00      	add	r7, sp, #0
 801f81a:	f507 74b0 	add.w	r4, r7, #352	@ 0x160
 801f81e:	f5a4 74aa 	sub.w	r4, r4, #340	@ 0x154
 801f822:	6020      	str	r0, [r4, #0]
 801f824:	f507 70b0 	add.w	r0, r7, #352	@ 0x160
 801f828:	f5a0 70ac 	sub.w	r0, r0, #344	@ 0x158
 801f82c:	6001      	str	r1, [r0, #0]
 801f82e:	f507 71b0 	add.w	r1, r7, #352	@ 0x160
 801f832:	f5a1 71ae 	sub.w	r1, r1, #348	@ 0x15c
 801f836:	600a      	str	r2, [r1, #0]
 801f838:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
 801f83c:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 801f840:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f842:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801f846:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801f84a:	681b      	ldr	r3, [r3, #0]
 801f84c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 801f850:	3380      	adds	r3, #128	@ 0x80
 801f852:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 801f856:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801f85a:	f5a3 73ae 	sub.w	r3, r3, #348	@ 0x15c
 801f85e:	681b      	ldr	r3, [r3, #0]
 801f860:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f864:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801f868:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801f86c:	681b      	ldr	r3, [r3, #0]
 801f86e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 801f870:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
  wsptr = workspace;
 801f874:	f107 0314 	add.w	r3, r7, #20
 801f878:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801f87c:	2308      	movs	r3, #8
 801f87e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801f882:	e238      	b.n	801fcf6 <jpeg_idct_islow+0x4e2>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f884:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f888:	3310      	adds	r3, #16
 801f88a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f88e:	2b00      	cmp	r3, #0
 801f890:	d175      	bne.n	801f97e <jpeg_idct_islow+0x16a>
 801f892:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f896:	3320      	adds	r3, #32
 801f898:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f89c:	2b00      	cmp	r3, #0
 801f89e:	d16e      	bne.n	801f97e <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f8a0:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8a4:	3330      	adds	r3, #48	@ 0x30
 801f8a6:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f8aa:	2b00      	cmp	r3, #0
 801f8ac:	d167      	bne.n	801f97e <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f8ae:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8b2:	3340      	adds	r3, #64	@ 0x40
 801f8b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f8b8:	2b00      	cmp	r3, #0
 801f8ba:	d160      	bne.n	801f97e <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f8bc:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8c0:	3350      	adds	r3, #80	@ 0x50
 801f8c2:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f8c6:	2b00      	cmp	r3, #0
 801f8c8:	d159      	bne.n	801f97e <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f8ca:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8ce:	3360      	adds	r3, #96	@ 0x60
 801f8d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f8d4:	2b00      	cmp	r3, #0
 801f8d6:	d152      	bne.n	801f97e <jpeg_idct_islow+0x16a>
	inptr[DCTSIZE*7] == 0) {
 801f8d8:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8dc:	3370      	adds	r3, #112	@ 0x70
 801f8de:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f8e2:	2b00      	cmp	r3, #0
 801f8e4:	d14b      	bne.n	801f97e <jpeg_idct_islow+0x16a>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 801f8e6:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f8ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f8ee:	461a      	mov	r2, r3
 801f8f0:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f8f4:	681b      	ldr	r3, [r3, #0]
 801f8f6:	fb02 f303 	mul.w	r3, r2, r3
 801f8fa:	009b      	lsls	r3, r3, #2
 801f8fc:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

      wsptr[DCTSIZE*0] = dcval;
 801f900:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f904:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f908:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801f90a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f90e:	3320      	adds	r3, #32
 801f910:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f914:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801f916:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f91a:	3340      	adds	r3, #64	@ 0x40
 801f91c:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f920:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801f922:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f926:	3360      	adds	r3, #96	@ 0x60
 801f928:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f92c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801f92e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f932:	3380      	adds	r3, #128	@ 0x80
 801f934:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f938:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801f93a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f93e:	33a0      	adds	r3, #160	@ 0xa0
 801f940:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f944:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801f946:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f94a:	33c0      	adds	r3, #192	@ 0xc0
 801f94c:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f950:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801f952:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f956:	33e0      	adds	r3, #224	@ 0xe0
 801f958:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801f95c:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 801f95e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f962:	3302      	adds	r3, #2
 801f964:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
      quantptr++;
 801f968:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f96c:	3304      	adds	r3, #4
 801f96e:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
      wsptr++;
 801f972:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801f976:	3304      	adds	r3, #4
 801f978:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
      continue;
 801f97c:	e1b6      	b.n	801fcec <jpeg_idct_islow+0x4d8>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801f97e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f982:	3320      	adds	r3, #32
 801f984:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f988:	461a      	mov	r2, r3
 801f98a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f98e:	3340      	adds	r3, #64	@ 0x40
 801f990:	681b      	ldr	r3, [r3, #0]
 801f992:	fb02 f303 	mul.w	r3, r2, r3
 801f996:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801f99a:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f99e:	3360      	adds	r3, #96	@ 0x60
 801f9a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f9a4:	461a      	mov	r2, r3
 801f9a6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801f9aa:	33c0      	adds	r3, #192	@ 0xc0
 801f9ac:	681b      	ldr	r3, [r3, #0]
 801f9ae:	fb02 f303 	mul.w	r3, r2, r3
 801f9b2:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 801f9b6:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801f9ba:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801f9be:	4413      	add	r3, r2
 801f9c0:	f241 1251 	movw	r2, #4433	@ 0x1151
 801f9c4:	fb02 f303 	mul.w	r3, r2, r3
 801f9c8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801f9cc:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801f9d0:	f641 027e 	movw	r2, #6270	@ 0x187e
 801f9d4:	fb02 f303 	mul.w	r3, r2, r3
 801f9d8:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f9dc:	4413      	add	r3, r2
 801f9de:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 801f9e2:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801f9e6:	4aca      	ldr	r2, [pc, #808]	@ (801fd10 <jpeg_idct_islow+0x4fc>)
 801f9e8:	fb02 f303 	mul.w	r3, r2, r3
 801f9ec:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801f9f0:	4413      	add	r3, r2
 801f9f2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f9f6:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801f9fa:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f9fe:	461a      	mov	r2, r3
 801fa00:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fa04:	681b      	ldr	r3, [r3, #0]
 801fa06:	fb02 f303 	mul.w	r3, r2, r3
 801fa0a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801fa0e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801fa12:	3340      	adds	r3, #64	@ 0x40
 801fa14:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fa18:	461a      	mov	r2, r3
 801fa1a:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fa1e:	3380      	adds	r3, #128	@ 0x80
 801fa20:	681b      	ldr	r3, [r3, #0]
 801fa22:	fb02 f303 	mul.w	r3, r2, r3
 801fa26:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 <<= CONST_BITS;
 801fa2a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fa2e:	035b      	lsls	r3, r3, #13
 801fa30:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 <<= CONST_BITS;
 801fa34:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fa38:	035b      	lsls	r3, r3, #13
 801fa3a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 801fa3e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fa42:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801fa46:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp0 = z2 + z3;
 801fa4a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fa4e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fa52:	4413      	add	r3, r2
 801fa54:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = z2 - z3;
 801fa58:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fa5c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fa60:	1ad3      	subs	r3, r2, r3
 801fa62:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp10 = tmp0 + tmp2;
 801fa66:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801fa6a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fa6e:	4413      	add	r3, r2
 801fa70:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp13 = tmp0 - tmp2;
 801fa74:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801fa78:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fa7c:	1ad3      	subs	r3, r2, r3
 801fa7e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp11 = tmp1 + tmp3;
 801fa82:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fa86:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fa8a:	4413      	add	r3, r2
 801fa8c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp12 = tmp1 - tmp3;
 801fa90:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fa94:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fa98:	1ad3      	subs	r3, r2, r3
 801fa9a:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801fa9e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801faa2:	3370      	adds	r3, #112	@ 0x70
 801faa4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801faa8:	461a      	mov	r2, r3
 801faaa:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801faae:	33e0      	adds	r3, #224	@ 0xe0
 801fab0:	681b      	ldr	r3, [r3, #0]
 801fab2:	fb02 f303 	mul.w	r3, r2, r3
 801fab6:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801faba:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801fabe:	3350      	adds	r3, #80	@ 0x50
 801fac0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fac4:	461a      	mov	r2, r3
 801fac6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801faca:	33a0      	adds	r3, #160	@ 0xa0
 801facc:	681b      	ldr	r3, [r3, #0]
 801face:	fb02 f303 	mul.w	r3, r2, r3
 801fad2:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801fad6:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801fada:	3330      	adds	r3, #48	@ 0x30
 801fadc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fae0:	461a      	mov	r2, r3
 801fae2:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fae6:	3360      	adds	r3, #96	@ 0x60
 801fae8:	681b      	ldr	r3, [r3, #0]
 801faea:	fb02 f303 	mul.w	r3, r2, r3
 801faee:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801faf2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801faf6:	3310      	adds	r3, #16
 801faf8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fafc:	461a      	mov	r2, r3
 801fafe:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fb02:	3320      	adds	r3, #32
 801fb04:	681b      	ldr	r3, [r3, #0]
 801fb06:	fb02 f303 	mul.w	r3, r2, r3
 801fb0a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    
    z2 = tmp0 + tmp2;
 801fb0e:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801fb12:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fb16:	4413      	add	r3, r2
 801fb18:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = tmp1 + tmp3;
 801fb1c:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fb20:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fb24:	4413      	add	r3, r2
 801fb26:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 801fb2a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fb2e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fb32:	4413      	add	r3, r2
 801fb34:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 801fb38:	fb02 f303 	mul.w	r3, r2, r3
 801fb3c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801fb40:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fb44:	4a73      	ldr	r2, [pc, #460]	@ (801fd14 <jpeg_idct_islow+0x500>)
 801fb46:	fb02 f303 	mul.w	r3, r2, r3
 801fb4a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801fb4e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fb52:	4a71      	ldr	r2, [pc, #452]	@ (801fd18 <jpeg_idct_islow+0x504>)
 801fb54:	fb02 f303 	mul.w	r3, r2, r3
 801fb58:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 += z1;
 801fb5c:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fb60:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801fb64:	4413      	add	r3, r2
 801fb66:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 += z1;
 801fb6a:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801fb6e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801fb72:	4413      	add	r3, r2
 801fb74:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 801fb78:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801fb7c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fb80:	4413      	add	r3, r2
 801fb82:	4a66      	ldr	r2, [pc, #408]	@ (801fd1c <jpeg_idct_islow+0x508>)
 801fb84:	fb02 f303 	mul.w	r3, r2, r3
 801fb88:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 801fb8c:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801fb90:	f640 128e 	movw	r2, #2446	@ 0x98e
 801fb94:	fb02 f303 	mul.w	r3, r2, r3
 801fb98:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 801fb9c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fba0:	f243 020b 	movw	r2, #12299	@ 0x300b
 801fba4:	fb02 f303 	mul.w	r3, r2, r3
 801fba8:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp0 += z1 + z2;
 801fbac:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fbb0:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fbb4:	4413      	add	r3, r2
 801fbb6:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801fbba:	4413      	add	r3, r2
 801fbbc:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 += z1 + z3;
 801fbc0:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fbc4:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fbc8:	4413      	add	r3, r2
 801fbca:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801fbce:	4413      	add	r3, r2
 801fbd0:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 801fbd4:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fbd8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fbdc:	4413      	add	r3, r2
 801fbde:	4a50      	ldr	r2, [pc, #320]	@ (801fd20 <jpeg_idct_islow+0x50c>)
 801fbe0:	fb02 f303 	mul.w	r3, r2, r3
 801fbe4:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 801fbe8:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801fbec:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 801fbf0:	fb02 f303 	mul.w	r3, r2, r3
 801fbf4:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 801fbf8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fbfc:	f246 2254 	movw	r2, #25172	@ 0x6254
 801fc00:	fb02 f303 	mul.w	r3, r2, r3
 801fc04:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp1 += z1 + z3;
 801fc08:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fc0c:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fc10:	4413      	add	r3, r2
 801fc12:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fc16:	4413      	add	r3, r2
 801fc18:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 += z1 + z2;
 801fc1c:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fc20:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fc24:	4413      	add	r3, r2
 801fc26:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801fc2a:	4413      	add	r3, r2
 801fc2c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 801fc30:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801fc34:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fc38:	4413      	add	r3, r2
 801fc3a:	12da      	asrs	r2, r3, #11
 801fc3c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fc40:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 801fc42:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 801fc46:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fc4a:	1ad2      	subs	r2, r2, r3
 801fc4c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fc50:	33e0      	adds	r3, #224	@ 0xe0
 801fc52:	12d2      	asrs	r2, r2, #11
 801fc54:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 801fc56:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801fc5a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fc5e:	441a      	add	r2, r3
 801fc60:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fc64:	3320      	adds	r3, #32
 801fc66:	12d2      	asrs	r2, r2, #11
 801fc68:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 801fc6a:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801fc6e:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fc72:	1ad2      	subs	r2, r2, r3
 801fc74:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fc78:	33c0      	adds	r3, #192	@ 0xc0
 801fc7a:	12d2      	asrs	r2, r2, #11
 801fc7c:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 801fc7e:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801fc82:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801fc86:	441a      	add	r2, r3
 801fc88:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fc8c:	3340      	adds	r3, #64	@ 0x40
 801fc8e:	12d2      	asrs	r2, r2, #11
 801fc90:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 801fc92:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801fc96:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801fc9a:	1ad2      	subs	r2, r2, r3
 801fc9c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fca0:	33a0      	adds	r3, #160	@ 0xa0
 801fca2:	12d2      	asrs	r2, r2, #11
 801fca4:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 801fca6:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801fcaa:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801fcae:	441a      	add	r2, r3
 801fcb0:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fcb4:	3360      	adds	r3, #96	@ 0x60
 801fcb6:	12d2      	asrs	r2, r2, #11
 801fcb8:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 801fcba:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801fcbe:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801fcc2:	1ad2      	subs	r2, r2, r3
 801fcc4:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fcc8:	3380      	adds	r3, #128	@ 0x80
 801fcca:	12d2      	asrs	r2, r2, #11
 801fccc:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 801fcce:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801fcd2:	3302      	adds	r3, #2
 801fcd4:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    quantptr++;
 801fcd8:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801fcdc:	3304      	adds	r3, #4
 801fcde:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    wsptr++;
 801fce2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fce6:	3304      	adds	r3, #4
 801fce8:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801fcec:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801fcf0:	3b01      	subs	r3, #1
 801fcf2:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801fcf6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801fcfa:	2b00      	cmp	r3, #0
 801fcfc:	f73f adc2 	bgt.w	801f884 <jpeg_idct_islow+0x70>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 801fd00:	f107 0314 	add.w	r3, r7, #20
 801fd04:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 801fd08:	2300      	movs	r3, #0
 801fd0a:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 801fd0e:	e21a      	b.n	8020146 <jpeg_idct_islow+0x932>
 801fd10:	ffffc4df 	.word	0xffffc4df
 801fd14:	ffffc13b 	.word	0xffffc13b
 801fd18:	fffff384 	.word	0xfffff384
 801fd1c:	ffffe333 	.word	0xffffe333
 801fd20:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 801fd24:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 801fd28:	009b      	lsls	r3, r3, #2
 801fd2a:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
 801fd2e:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 801fd32:	6812      	ldr	r2, [r2, #0]
 801fd34:	4413      	add	r3, r2
 801fd36:	681a      	ldr	r2, [r3, #0]
 801fd38:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 801fd3c:	4413      	add	r3, r2
 801fd3e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801fd42:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd46:	3304      	adds	r3, #4
 801fd48:	681b      	ldr	r3, [r3, #0]
 801fd4a:	2b00      	cmp	r3, #0
 801fd4c:	d165      	bne.n	801fe1a <jpeg_idct_islow+0x606>
 801fd4e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd52:	3308      	adds	r3, #8
 801fd54:	681b      	ldr	r3, [r3, #0]
 801fd56:	2b00      	cmp	r3, #0
 801fd58:	d15f      	bne.n	801fe1a <jpeg_idct_islow+0x606>
 801fd5a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd5e:	330c      	adds	r3, #12
 801fd60:	681b      	ldr	r3, [r3, #0]
 801fd62:	2b00      	cmp	r3, #0
 801fd64:	d159      	bne.n	801fe1a <jpeg_idct_islow+0x606>
 801fd66:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd6a:	3310      	adds	r3, #16
 801fd6c:	681b      	ldr	r3, [r3, #0]
 801fd6e:	2b00      	cmp	r3, #0
 801fd70:	d153      	bne.n	801fe1a <jpeg_idct_islow+0x606>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801fd72:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd76:	3314      	adds	r3, #20
 801fd78:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801fd7a:	2b00      	cmp	r3, #0
 801fd7c:	d14d      	bne.n	801fe1a <jpeg_idct_islow+0x606>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 801fd7e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd82:	3318      	adds	r3, #24
 801fd84:	681b      	ldr	r3, [r3, #0]
 801fd86:	2b00      	cmp	r3, #0
 801fd88:	d147      	bne.n	801fe1a <jpeg_idct_islow+0x606>
 801fd8a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd8e:	331c      	adds	r3, #28
 801fd90:	681b      	ldr	r3, [r3, #0]
 801fd92:	2b00      	cmp	r3, #0
 801fd94:	d141      	bne.n	801fe1a <jpeg_idct_islow+0x606>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 801fd96:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fd9a:	681b      	ldr	r3, [r3, #0]
 801fd9c:	3310      	adds	r3, #16
 801fd9e:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 801fda0:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 801fda4:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 801fda8:	4413      	add	r3, r2
 801fdaa:	781b      	ldrb	r3, [r3, #0]
 801fdac:	f887 3147 	strb.w	r3, [r7, #327]	@ 0x147

      outptr[0] = dcval;
 801fdb0:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdb4:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fdb8:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 801fdba:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdbe:	3301      	adds	r3, #1
 801fdc0:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fdc4:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 801fdc6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdca:	3302      	adds	r3, #2
 801fdcc:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fdd0:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 801fdd2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdd6:	3303      	adds	r3, #3
 801fdd8:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fddc:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 801fdde:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fde2:	3304      	adds	r3, #4
 801fde4:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fde8:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 801fdea:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdee:	3305      	adds	r3, #5
 801fdf0:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fdf4:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 801fdf6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fdfa:	3306      	adds	r3, #6
 801fdfc:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fe00:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 801fe02:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 801fe06:	3307      	adds	r3, #7
 801fe08:	f897 2147 	ldrb.w	r2, [r7, #327]	@ 0x147
 801fe0c:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 801fe0e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fe12:	3320      	adds	r3, #32
 801fe14:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
      continue;
 801fe18:	e190      	b.n	802013c <jpeg_idct_islow+0x928>
#endif

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 801fe1a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fe1e:	3308      	adds	r3, #8
 801fe20:	681b      	ldr	r3, [r3, #0]
 801fe22:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = (INT32) wsptr[6];
 801fe26:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fe2a:	3318      	adds	r3, #24
 801fe2c:	681b      	ldr	r3, [r3, #0]
 801fe2e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 801fe32:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fe36:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fe3a:	4413      	add	r3, r2
 801fe3c:	f241 1251 	movw	r2, #4433	@ 0x1151
 801fe40:	fb02 f303 	mul.w	r3, r2, r3
 801fe44:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801fe48:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801fe4c:	f641 027e 	movw	r2, #6270	@ 0x187e
 801fe50:	fb02 f303 	mul.w	r3, r2, r3
 801fe54:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fe58:	4413      	add	r3, r2
 801fe5a:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 801fe5e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fe62:	4abf      	ldr	r2, [pc, #764]	@ (8020160 <jpeg_idct_islow+0x94c>)
 801fe64:	fb02 f303 	mul.w	r3, r2, r3
 801fe68:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801fe6c:	4413      	add	r3, r2
 801fe6e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801fe72:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fe76:	681b      	ldr	r3, [r3, #0]
 801fe78:	3310      	adds	r3, #16
 801fe7a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = (INT32) wsptr[4];
 801fe7e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fe82:	3310      	adds	r3, #16
 801fe84:	681b      	ldr	r3, [r3, #0]
 801fe86:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    tmp0 = (z2 + z3) << CONST_BITS;
 801fe8a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fe8e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fe92:	4413      	add	r3, r2
 801fe94:	035b      	lsls	r3, r3, #13
 801fe96:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = (z2 - z3) << CONST_BITS;
 801fe9a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801fe9e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801fea2:	1ad3      	subs	r3, r2, r3
 801fea4:	035b      	lsls	r3, r3, #13
 801fea6:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    
    tmp10 = tmp0 + tmp2;
 801feaa:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801feae:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801feb2:	4413      	add	r3, r2
 801feb4:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp13 = tmp0 - tmp2;
 801feb8:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801febc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801fec0:	1ad3      	subs	r3, r2, r3
 801fec2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp11 = tmp1 + tmp3;
 801fec6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801feca:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fece:	4413      	add	r3, r2
 801fed0:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp12 = tmp1 - tmp3;
 801fed4:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801fed8:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801fedc:	1ad3      	subs	r3, r2, r3
 801fede:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 801fee2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fee6:	331c      	adds	r3, #28
 801fee8:	681b      	ldr	r3, [r3, #0]
 801feea:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp1 = (INT32) wsptr[5];
 801feee:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fef2:	3314      	adds	r3, #20
 801fef4:	681b      	ldr	r3, [r3, #0]
 801fef6:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = (INT32) wsptr[3];
 801fefa:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801fefe:	330c      	adds	r3, #12
 801ff00:	681b      	ldr	r3, [r3, #0]
 801ff02:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp3 = (INT32) wsptr[1];
 801ff06:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801ff0a:	3304      	adds	r3, #4
 801ff0c:	681b      	ldr	r3, [r3, #0]
 801ff0e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z2 = tmp0 + tmp2;
 801ff12:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801ff16:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801ff1a:	4413      	add	r3, r2
 801ff1c:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = tmp1 + tmp3;
 801ff20:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801ff24:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801ff28:	4413      	add	r3, r2
 801ff2a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 801ff2e:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801ff32:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801ff36:	4413      	add	r3, r2
 801ff38:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 801ff3c:	fb02 f303 	mul.w	r3, r2, r3
 801ff40:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801ff44:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801ff48:	4a86      	ldr	r2, [pc, #536]	@ (8020164 <jpeg_idct_islow+0x950>)
 801ff4a:	fb02 f303 	mul.w	r3, r2, r3
 801ff4e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801ff52:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801ff56:	4a84      	ldr	r2, [pc, #528]	@ (8020168 <jpeg_idct_islow+0x954>)
 801ff58:	fb02 f303 	mul.w	r3, r2, r3
 801ff5c:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z2 += z1;
 801ff60:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 801ff64:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801ff68:	4413      	add	r3, r2
 801ff6a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z3 += z1;
 801ff6e:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 801ff72:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801ff76:	4413      	add	r3, r2
 801ff78:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 801ff7c:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801ff80:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801ff84:	4413      	add	r3, r2
 801ff86:	4a79      	ldr	r2, [pc, #484]	@ (802016c <jpeg_idct_islow+0x958>)
 801ff88:	fb02 f303 	mul.w	r3, r2, r3
 801ff8c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 801ff90:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801ff94:	f640 128e 	movw	r2, #2446	@ 0x98e
 801ff98:	fb02 f303 	mul.w	r3, r2, r3
 801ff9c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 801ffa0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801ffa4:	f243 020b 	movw	r2, #12299	@ 0x300b
 801ffa8:	fb02 f303 	mul.w	r3, r2, r3
 801ffac:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp0 += z1 + z2;
 801ffb0:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801ffb4:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801ffb8:	4413      	add	r3, r2
 801ffba:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 801ffbe:	4413      	add	r3, r2
 801ffc0:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp3 += z1 + z3;
 801ffc4:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 801ffc8:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 801ffcc:	4413      	add	r3, r2
 801ffce:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 801ffd2:	4413      	add	r3, r2
 801ffd4:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 801ffd8:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801ffdc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801ffe0:	4413      	add	r3, r2
 801ffe2:	4a63      	ldr	r2, [pc, #396]	@ (8020170 <jpeg_idct_islow+0x95c>)
 801ffe4:	fb02 f303 	mul.w	r3, r2, r3
 801ffe8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 801ffec:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 801fff0:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 801fff4:	fb02 f303 	mul.w	r3, r2, r3
 801fff8:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 801fffc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8020000:	f246 2254 	movw	r2, #25172	@ 0x6254
 8020004:	fb02 f303 	mul.w	r3, r2, r3
 8020008:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp1 += z1 + z3;
 802000c:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8020010:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8020014:	4413      	add	r3, r2
 8020016:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 802001a:	4413      	add	r3, r2
 802001c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp2 += z1 + z2;
 8020020:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8020024:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8020028:	4413      	add	r3, r2
 802002a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802002e:	4413      	add	r3, r2
 8020030:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8020034:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8020038:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802003c:	4413      	add	r3, r2
 802003e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020040:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8020044:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8020048:	4413      	add	r3, r2
 802004a:	781a      	ldrb	r2, [r3, #0]
 802004c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8020050:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8020052:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8020056:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802005a:	1ad3      	subs	r3, r2, r3
 802005c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802005e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8020062:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8020066:	441a      	add	r2, r3
 8020068:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802006c:	3307      	adds	r3, #7
 802006e:	7812      	ldrb	r2, [r2, #0]
 8020070:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8020072:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8020076:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 802007a:	4413      	add	r3, r2
 802007c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802007e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8020082:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8020086:	441a      	add	r2, r3
 8020088:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802008c:	3301      	adds	r3, #1
 802008e:	7812      	ldrb	r2, [r2, #0]
 8020090:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8020092:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8020096:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 802009a:	1ad3      	subs	r3, r2, r3
 802009c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802009e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 80200a2:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80200a6:	441a      	add	r2, r3
 80200a8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80200ac:	3306      	adds	r3, #6
 80200ae:	7812      	ldrb	r2, [r2, #0]
 80200b0:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 80200b2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 80200b6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80200ba:	4413      	add	r3, r2
 80200bc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80200be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 80200c2:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80200c6:	441a      	add	r2, r3
 80200c8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80200cc:	3302      	adds	r3, #2
 80200ce:	7812      	ldrb	r2, [r2, #0]
 80200d0:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 80200d2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 80200d6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80200da:	1ad3      	subs	r3, r2, r3
 80200dc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80200de:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 80200e2:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80200e6:	441a      	add	r2, r3
 80200e8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80200ec:	3305      	adds	r3, #5
 80200ee:	7812      	ldrb	r2, [r2, #0]
 80200f0:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 80200f2:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80200f6:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80200fa:	4413      	add	r3, r2
 80200fc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80200fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8020102:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8020106:	441a      	add	r2, r3
 8020108:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802010c:	3303      	adds	r3, #3
 802010e:	7812      	ldrb	r2, [r2, #0]
 8020110:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8020112:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8020116:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802011a:	1ad3      	subs	r3, r2, r3
 802011c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802011e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8020122:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8020126:	441a      	add	r2, r3
 8020128:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802012c:	3304      	adds	r3, #4
 802012e:	7812      	ldrb	r2, [r2, #0]
 8020130:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 8020132:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8020136:	3320      	adds	r3, #32
 8020138:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 802013c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8020140:	3301      	adds	r3, #1
 8020142:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 8020146:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802014a:	2b07      	cmp	r3, #7
 802014c:	f77f adea 	ble.w	801fd24 <jpeg_idct_islow+0x510>
  }
}
 8020150:	bf00      	nop
 8020152:	bf00      	nop
 8020154:	f507 77b0 	add.w	r7, r7, #352	@ 0x160
 8020158:	46bd      	mov	sp, r7
 802015a:	bc90      	pop	{r4, r7}
 802015c:	4770      	bx	lr
 802015e:	bf00      	nop
 8020160:	ffffc4df 	.word	0xffffc4df
 8020164:	ffffc13b 	.word	0xffffc13b
 8020168:	fffff384 	.word	0xfffff384
 802016c:	ffffe333 	.word	0xffffe333
 8020170:	ffffadfd 	.word	0xffffadfd

08020174 <jpeg_idct_7x7>:

GLOBAL(void)
jpeg_idct_7x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8020174:	b490      	push	{r4, r7}
 8020176:	b0c6      	sub	sp, #280	@ 0x118
 8020178:	af00      	add	r7, sp, #0
 802017a:	f507 748c 	add.w	r4, r7, #280	@ 0x118
 802017e:	f5a4 7486 	sub.w	r4, r4, #268	@ 0x10c
 8020182:	6020      	str	r0, [r4, #0]
 8020184:	f507 708c 	add.w	r0, r7, #280	@ 0x118
 8020188:	f5a0 7088 	sub.w	r0, r0, #272	@ 0x110
 802018c:	6001      	str	r1, [r0, #0]
 802018e:	f507 718c 	add.w	r1, r7, #280	@ 0x118
 8020192:	f5a1 718a 	sub.w	r1, r1, #276	@ 0x114
 8020196:	600a      	str	r2, [r1, #0]
 8020198:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 802019c:	f5a2 728c 	sub.w	r2, r2, #280	@ 0x118
 80201a0:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80201a2:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80201a6:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 80201aa:	681b      	ldr	r3, [r3, #0]
 80201ac:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80201b0:	3380      	adds	r3, #128	@ 0x80
 80201b2:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
  int workspace[7*7];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80201b6:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80201ba:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 80201be:	681b      	ldr	r3, [r3, #0]
 80201c0:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80201c4:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 80201c8:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
 80201cc:	681b      	ldr	r3, [r3, #0]
 80201ce:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80201d0:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  wsptr = workspace;
 80201d4:	f107 0314 	add.w	r3, r7, #20
 80201d8:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 80201dc:	2300      	movs	r3, #0
 80201de:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 80201e2:	e17a      	b.n	80204da <jpeg_idct_7x7+0x366>
    /* Even part */

    tmp13 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80201e4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80201e8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80201ec:	461a      	mov	r2, r3
 80201ee:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80201f2:	681b      	ldr	r3, [r3, #0]
 80201f4:	fb02 f303 	mul.w	r3, r2, r3
 80201f8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp13 <<= CONST_BITS;
 80201fc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8020200:	035b      	lsls	r3, r3, #13
 8020202:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    /* Add fudge factor here for final descale. */
    tmp13 += ONE << (CONST_BITS-PASS1_BITS-1);
 8020206:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 802020a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802020e:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8020212:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8020216:	3320      	adds	r3, #32
 8020218:	f9b3 3000 	ldrsh.w	r3, [r3]
 802021c:	461a      	mov	r2, r3
 802021e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8020222:	3340      	adds	r3, #64	@ 0x40
 8020224:	681b      	ldr	r3, [r3, #0]
 8020226:	fb02 f303 	mul.w	r3, r2, r3
 802022a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802022e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8020232:	3340      	adds	r3, #64	@ 0x40
 8020234:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020238:	461a      	mov	r2, r3
 802023a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802023e:	3380      	adds	r3, #128	@ 0x80
 8020240:	681b      	ldr	r3, [r3, #0]
 8020242:	fb02 f303 	mul.w	r3, r2, r3
 8020246:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802024a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802024e:	3360      	adds	r3, #96	@ 0x60
 8020250:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020254:	461a      	mov	r2, r3
 8020256:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802025a:	33c0      	adds	r3, #192	@ 0xc0
 802025c:	681b      	ldr	r3, [r3, #0]
 802025e:	fb02 f303 	mul.w	r3, r2, r3
 8020262:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 8020266:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 802026a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 802026e:	1ad3      	subs	r3, r2, r3
 8020270:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8020274:	fb02 f303 	mul.w	r3, r2, r3
 8020278:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 802027c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8020280:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020284:	1ad3      	subs	r3, r2, r3
 8020286:	f640 2212 	movw	r2, #2578	@ 0xa12
 802028a:	fb02 f303 	mul.w	r3, r2, r3
 802028e:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 8020292:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8020296:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802029a:	441a      	add	r2, r3
 802029c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80202a0:	441a      	add	r2, r3
 80202a2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80202a6:	4993      	ldr	r1, [pc, #588]	@ (80204f4 <jpeg_idct_7x7+0x380>)
 80202a8:	fb01 f303 	mul.w	r3, r1, r3
 80202ac:	4413      	add	r3, r2
 80202ae:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp0 = z1 + z3;
 80202b2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80202b6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80202ba:	4413      	add	r3, r2
 80202bc:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z2 -= tmp0;
 80202c0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80202c4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80202c8:	1ad3      	subs	r3, r2, r3
 80202ca:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 80202ce:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80202d2:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 80202d6:	fb02 f303 	mul.w	r3, r2, r3
 80202da:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80202de:	4413      	add	r3, r2
 80202e0:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 80202e4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80202e8:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 80202ec:	fb03 f202 	mul.w	r2, r3, r2
 80202f0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80202f4:	4413      	add	r3, r2
 80202f6:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80202fa:	4413      	add	r3, r2
 80202fc:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 8020300:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8020304:	4a7c      	ldr	r2, [pc, #496]	@ (80204f8 <jpeg_idct_7x7+0x384>)
 8020306:	fb03 f202 	mul.w	r2, r3, r2
 802030a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 802030e:	4413      	add	r3, r2
 8020310:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020314:	4413      	add	r3, r2
 8020316:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 802031a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802031e:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8020322:	fb02 f303 	mul.w	r3, r2, r3
 8020326:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802032a:	4413      	add	r3, r2
 802032c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8020330:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8020334:	3310      	adds	r3, #16
 8020336:	f9b3 3000 	ldrsh.w	r3, [r3]
 802033a:	461a      	mov	r2, r3
 802033c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8020340:	3320      	adds	r3, #32
 8020342:	681b      	ldr	r3, [r3, #0]
 8020344:	fb02 f303 	mul.w	r3, r2, r3
 8020348:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802034c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8020350:	3330      	adds	r3, #48	@ 0x30
 8020352:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020356:	461a      	mov	r2, r3
 8020358:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802035c:	3360      	adds	r3, #96	@ 0x60
 802035e:	681b      	ldr	r3, [r3, #0]
 8020360:	fb02 f303 	mul.w	r3, r2, r3
 8020364:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8020368:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802036c:	3350      	adds	r3, #80	@ 0x50
 802036e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020372:	461a      	mov	r2, r3
 8020374:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8020378:	33a0      	adds	r3, #160	@ 0xa0
 802037a:	681b      	ldr	r3, [r3, #0]
 802037c:	fb02 f303 	mul.w	r3, r2, r3
 8020380:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 8020384:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8020388:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802038c:	4413      	add	r3, r2
 802038e:	f641 52ef 	movw	r2, #7663	@ 0x1def
 8020392:	fb02 f303 	mul.w	r3, r2, r3
 8020396:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 802039a:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802039e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80203a2:	1ad3      	subs	r3, r2, r3
 80203a4:	f240 5273 	movw	r2, #1395	@ 0x573
 80203a8:	fb02 f303 	mul.w	r3, r2, r3
 80203ac:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp0 = tmp1 - tmp2;
 80203b0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80203b4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80203b8:	1ad3      	subs	r3, r2, r3
 80203ba:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp1 += tmp2;
 80203be:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80203c2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80203c6:	4413      	add	r3, r2
 80203c8:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 80203cc:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80203d0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80203d4:	4413      	add	r3, r2
 80203d6:	4a49      	ldr	r2, [pc, #292]	@ (80204fc <jpeg_idct_7x7+0x388>)
 80203d8:	fb02 f303 	mul.w	r3, r2, r3
 80203dc:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp1 += tmp2;
 80203e0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80203e4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80203e8:	4413      	add	r3, r2
 80203ea:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 80203ee:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80203f2:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80203f6:	4413      	add	r3, r2
 80203f8:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 80203fc:	fb02 f303 	mul.w	r3, r2, r3
 8020400:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 += z2;
 8020404:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8020408:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802040c:	4413      	add	r3, r2
 802040e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 8020412:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8020416:	f643 32de 	movw	r2, #15326	@ 0x3bde
 802041a:	fb03 f202 	mul.w	r2, r3, r2
 802041e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020422:	4413      	add	r3, r2
 8020424:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8020428:	4413      	add	r3, r2
 802042a:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    wsptr[7*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 802042e:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8020432:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8020436:	4413      	add	r3, r2
 8020438:	12da      	asrs	r2, r3, #11
 802043a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802043e:	601a      	str	r2, [r3, #0]
    wsptr[7*6] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8020440:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8020444:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8020448:	1ad2      	subs	r2, r2, r3
 802044a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802044e:	33a8      	adds	r3, #168	@ 0xa8
 8020450:	12d2      	asrs	r2, r2, #11
 8020452:	601a      	str	r2, [r3, #0]
    wsptr[7*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 8020454:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8020458:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802045c:	441a      	add	r2, r3
 802045e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020462:	331c      	adds	r3, #28
 8020464:	12d2      	asrs	r2, r2, #11
 8020466:	601a      	str	r2, [r3, #0]
    wsptr[7*5] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 8020468:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 802046c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8020470:	1ad2      	subs	r2, r2, r3
 8020472:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020476:	338c      	adds	r3, #140	@ 0x8c
 8020478:	12d2      	asrs	r2, r2, #11
 802047a:	601a      	str	r2, [r3, #0]
    wsptr[7*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 802047c:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020480:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020484:	441a      	add	r2, r3
 8020486:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802048a:	3338      	adds	r3, #56	@ 0x38
 802048c:	12d2      	asrs	r2, r2, #11
 802048e:	601a      	str	r2, [r3, #0]
    wsptr[7*4] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 8020490:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020494:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020498:	1ad2      	subs	r2, r2, r3
 802049a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802049e:	3370      	adds	r3, #112	@ 0x70
 80204a0:	12d2      	asrs	r2, r2, #11
 80204a2:	601a      	str	r2, [r3, #0]
    wsptr[7*3] = (int) RIGHT_SHIFT(tmp13, CONST_BITS-PASS1_BITS);
 80204a4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80204a8:	3354      	adds	r3, #84	@ 0x54
 80204aa:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80204ae:	12d2      	asrs	r2, r2, #11
 80204b0:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 80204b2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80204b6:	3301      	adds	r3, #1
 80204b8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 80204bc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80204c0:	3302      	adds	r3, #2
 80204c2:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 80204c6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80204ca:	3304      	adds	r3, #4
 80204cc:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 80204d0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80204d4:	3304      	adds	r3, #4
 80204d6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 80204da:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80204de:	2b06      	cmp	r3, #6
 80204e0:	f77f ae80 	ble.w	80201e4 <jpeg_idct_7x7+0x70>
  }

  /* Pass 2: process 7 rows from work array, store into output array. */

  wsptr = workspace;
 80204e4:	f107 0314 	add.w	r3, r7, #20
 80204e8:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 80204ec:	2300      	movs	r3, #0
 80204ee:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 80204f2:	e173      	b.n	80207dc <jpeg_idct_7x7+0x668>
 80204f4:	ffffc515 	.word	0xffffc515
 80204f8:	ffffb0f1 	.word	0xffffb0f1
 80204fc:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 8020500:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8020504:	009b      	lsls	r3, r3, #2
 8020506:	f507 728c 	add.w	r2, r7, #280	@ 0x118
 802050a:	f5a2 728c 	sub.w	r2, r2, #280	@ 0x118
 802050e:	6812      	ldr	r2, [r2, #0]
 8020510:	4413      	add	r3, r2
 8020512:	681a      	ldr	r2, [r3, #0]
 8020514:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8020518:	4413      	add	r3, r2
 802051a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp13 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802051e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020522:	681b      	ldr	r3, [r3, #0]
 8020524:	3310      	adds	r3, #16
 8020526:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp13 <<= CONST_BITS;
 802052a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 802052e:	035b      	lsls	r3, r3, #13
 8020530:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    z1 = (INT32) wsptr[2];
 8020534:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020538:	3308      	adds	r3, #8
 802053a:	681b      	ldr	r3, [r3, #0]
 802053c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = (INT32) wsptr[4];
 8020540:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020544:	3310      	adds	r3, #16
 8020546:	681b      	ldr	r3, [r3, #0]
 8020548:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = (INT32) wsptr[6];
 802054c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020550:	3318      	adds	r3, #24
 8020552:	681b      	ldr	r3, [r3, #0]
 8020554:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 8020558:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 802055c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8020560:	1ad3      	subs	r3, r2, r3
 8020562:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8020566:	fb02 f303 	mul.w	r3, r2, r3
 802056a:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 802056e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8020572:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020576:	1ad3      	subs	r3, r2, r3
 8020578:	f640 2212 	movw	r2, #2578	@ 0xa12
 802057c:	fb02 f303 	mul.w	r3, r2, r3
 8020580:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 8020584:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8020588:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802058c:	441a      	add	r2, r3
 802058e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8020592:	441a      	add	r2, r3
 8020594:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020598:	4996      	ldr	r1, [pc, #600]	@ (80207f4 <jpeg_idct_7x7+0x680>)
 802059a:	fb01 f303 	mul.w	r3, r1, r3
 802059e:	4413      	add	r3, r2
 80205a0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp0 = z1 + z3;
 80205a4:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80205a8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80205ac:	4413      	add	r3, r2
 80205ae:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z2 -= tmp0;
 80205b2:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80205b6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80205ba:	1ad3      	subs	r3, r2, r3
 80205bc:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 80205c0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80205c4:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 80205c8:	fb02 f303 	mul.w	r3, r2, r3
 80205cc:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80205d0:	4413      	add	r3, r2
 80205d2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 80205d6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80205da:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 80205de:	fb03 f202 	mul.w	r2, r3, r2
 80205e2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80205e6:	4413      	add	r3, r2
 80205e8:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80205ec:	4413      	add	r3, r2
 80205ee:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 80205f2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80205f6:	4a80      	ldr	r2, [pc, #512]	@ (80207f8 <jpeg_idct_7x7+0x684>)
 80205f8:	fb03 f202 	mul.w	r2, r3, r2
 80205fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8020600:	4413      	add	r3, r2
 8020602:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020606:	4413      	add	r3, r2
 8020608:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 802060c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020610:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8020614:	fb02 f303 	mul.w	r3, r2, r3
 8020618:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802061c:	4413      	add	r3, r2
 802061e:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8020622:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020626:	3304      	adds	r3, #4
 8020628:	681b      	ldr	r3, [r3, #0]
 802062a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 = (INT32) wsptr[3];
 802062e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8020632:	330c      	adds	r3, #12
 8020634:	681b      	ldr	r3, [r3, #0]
 8020636:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z3 = (INT32) wsptr[5];
 802063a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802063e:	3314      	adds	r3, #20
 8020640:	681b      	ldr	r3, [r3, #0]
 8020642:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 8020646:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802064a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802064e:	4413      	add	r3, r2
 8020650:	f641 52ef 	movw	r2, #7663	@ 0x1def
 8020654:	fb02 f303 	mul.w	r3, r2, r3
 8020658:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 802065c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8020660:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8020664:	1ad3      	subs	r3, r2, r3
 8020666:	f240 5273 	movw	r2, #1395	@ 0x573
 802066a:	fb02 f303 	mul.w	r3, r2, r3
 802066e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp0 = tmp1 - tmp2;
 8020672:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8020676:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802067a:	1ad3      	subs	r3, r2, r3
 802067c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp1 += tmp2;
 8020680:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8020684:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020688:	4413      	add	r3, r2
 802068a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 802068e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8020692:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8020696:	4413      	add	r3, r2
 8020698:	4a58      	ldr	r2, [pc, #352]	@ (80207fc <jpeg_idct_7x7+0x688>)
 802069a:	fb02 f303 	mul.w	r3, r2, r3
 802069e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp1 += tmp2;
 80206a2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80206a6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80206aa:	4413      	add	r3, r2
 80206ac:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 80206b0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80206b4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80206b8:	4413      	add	r3, r2
 80206ba:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 80206be:	fb02 f303 	mul.w	r3, r2, r3
 80206c2:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp0 += z2;
 80206c6:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80206ca:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80206ce:	4413      	add	r3, r2
 80206d0:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 80206d4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80206d8:	f643 32de 	movw	r2, #15326	@ 0x3bde
 80206dc:	fb03 f202 	mul.w	r2, r3, r2
 80206e0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80206e4:	4413      	add	r3, r2
 80206e6:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 80206ea:	4413      	add	r3, r2
 80206ec:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80206f0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80206f4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80206f8:	4413      	add	r3, r2
 80206fa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80206fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8020700:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8020704:	4413      	add	r3, r2
 8020706:	781a      	ldrb	r2, [r3, #0]
 8020708:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802070c:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802070e:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8020712:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8020716:	1ad3      	subs	r3, r2, r3
 8020718:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802071a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802071e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8020722:	441a      	add	r2, r3
 8020724:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8020728:	3306      	adds	r3, #6
 802072a:	7812      	ldrb	r2, [r2, #0]
 802072c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 802072e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8020732:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8020736:	4413      	add	r3, r2
 8020738:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802073a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 802073e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8020742:	441a      	add	r2, r3
 8020744:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8020748:	3301      	adds	r3, #1
 802074a:	7812      	ldrb	r2, [r2, #0]
 802074c:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 802074e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8020752:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8020756:	1ad3      	subs	r3, r2, r3
 8020758:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802075a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 802075e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8020762:	441a      	add	r2, r3
 8020764:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8020768:	3305      	adds	r3, #5
 802076a:	7812      	ldrb	r2, [r2, #0]
 802076c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 802076e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020772:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020776:	4413      	add	r3, r2
 8020778:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802077a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 802077e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8020782:	441a      	add	r2, r3
 8020784:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8020788:	3302      	adds	r3, #2
 802078a:	7812      	ldrb	r2, [r2, #0]
 802078c:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 802078e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8020792:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020796:	1ad3      	subs	r3, r2, r3
 8020798:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802079a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 802079e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80207a2:	441a      	add	r2, r3
 80207a4:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80207a8:	3304      	adds	r3, #4
 80207aa:	7812      	ldrb	r2, [r2, #0]
 80207ac:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 80207ae:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80207b2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80207b4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 80207b8:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80207bc:	441a      	add	r2, r3
 80207be:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80207c2:	3303      	adds	r3, #3
 80207c4:	7812      	ldrb	r2, [r2, #0]
 80207c6:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 80207c8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80207cc:	331c      	adds	r3, #28
 80207ce:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 80207d2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80207d6:	3301      	adds	r3, #1
 80207d8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 80207dc:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80207e0:	2b06      	cmp	r3, #6
 80207e2:	f77f ae8d 	ble.w	8020500 <jpeg_idct_7x7+0x38c>
  }
}
 80207e6:	bf00      	nop
 80207e8:	bf00      	nop
 80207ea:	f507 778c 	add.w	r7, r7, #280	@ 0x118
 80207ee:	46bd      	mov	sp, r7
 80207f0:	bc90      	pop	{r4, r7}
 80207f2:	4770      	bx	lr
 80207f4:	ffffc515 	.word	0xffffc515
 80207f8:	ffffb0f1 	.word	0xffffb0f1
 80207fc:	ffffd3e1 	.word	0xffffd3e1

08020800 <jpeg_idct_6x6>:

GLOBAL(void)
jpeg_idct_6x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8020800:	b480      	push	{r7}
 8020802:	b0b9      	sub	sp, #228	@ 0xe4
 8020804:	af00      	add	r7, sp, #0
 8020806:	60f8      	str	r0, [r7, #12]
 8020808:	60b9      	str	r1, [r7, #8]
 802080a:	607a      	str	r2, [r7, #4]
 802080c:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802080e:	68fb      	ldr	r3, [r7, #12]
 8020810:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8020814:	3380      	adds	r3, #128	@ 0x80
 8020816:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  int workspace[6*6];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 802081a:	687b      	ldr	r3, [r7, #4]
 802081c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8020820:	68bb      	ldr	r3, [r7, #8]
 8020822:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8020824:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  wsptr = workspace;
 8020828:	f107 0314 	add.w	r3, r7, #20
 802082c:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8020830:	2300      	movs	r3, #0
 8020832:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8020836:	e105      	b.n	8020a44 <jpeg_idct_6x6+0x244>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8020838:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802083c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020840:	461a      	mov	r2, r3
 8020842:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020846:	681b      	ldr	r3, [r3, #0]
 8020848:	fb02 f303 	mul.w	r3, r2, r3
 802084c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp0 <<= CONST_BITS;
 8020850:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020854:	035b      	lsls	r3, r3, #13
 8020856:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 802085a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802085e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8020862:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8020866:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802086a:	3340      	adds	r3, #64	@ 0x40
 802086c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020870:	461a      	mov	r2, r3
 8020872:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020876:	3380      	adds	r3, #128	@ 0x80
 8020878:	681b      	ldr	r3, [r3, #0]
 802087a:	fb02 f303 	mul.w	r3, r2, r3
 802087e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 8020882:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8020886:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 802088a:	fb02 f303 	mul.w	r3, r2, r3
 802088e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = tmp0 + tmp10;
 8020892:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8020896:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802089a:	4413      	add	r3, r2
 802089c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 80208a0:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80208a4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80208a8:	1ad2      	subs	r2, r2, r3
 80208aa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80208ae:	1ad3      	subs	r3, r2, r3
 80208b0:	12db      	asrs	r3, r3, #11
 80208b2:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80208b6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80208ba:	3320      	adds	r3, #32
 80208bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80208c0:	461a      	mov	r2, r3
 80208c2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80208c6:	3340      	adds	r3, #64	@ 0x40
 80208c8:	681b      	ldr	r3, [r3, #0]
 80208ca:	fb02 f303 	mul.w	r3, r2, r3
 80208ce:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 80208d2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80208d6:	f242 7231 	movw	r2, #10033	@ 0x2731
 80208da:	fb02 f303 	mul.w	r3, r2, r3
 80208de:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp10 = tmp1 + tmp0;
 80208e2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80208e6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80208ea:	4413      	add	r3, r2
 80208ec:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp12 = tmp1 - tmp0;
 80208f0:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80208f4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80208f8:	1ad3      	subs	r3, r2, r3
 80208fa:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80208fe:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8020902:	3310      	adds	r3, #16
 8020904:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020908:	461a      	mov	r2, r3
 802090a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802090e:	3320      	adds	r3, #32
 8020910:	681b      	ldr	r3, [r3, #0]
 8020912:	fb02 f303 	mul.w	r3, r2, r3
 8020916:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802091a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802091e:	3330      	adds	r3, #48	@ 0x30
 8020920:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020924:	461a      	mov	r2, r3
 8020926:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802092a:	3360      	adds	r3, #96	@ 0x60
 802092c:	681b      	ldr	r3, [r3, #0]
 802092e:	fb02 f303 	mul.w	r3, r2, r3
 8020932:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8020936:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802093a:	3350      	adds	r3, #80	@ 0x50
 802093c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020940:	461a      	mov	r2, r3
 8020942:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020946:	33a0      	adds	r3, #160	@ 0xa0
 8020948:	681b      	ldr	r3, [r3, #0]
 802094a:	fb02 f303 	mul.w	r3, r2, r3
 802094e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8020952:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8020956:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802095a:	4413      	add	r3, r2
 802095c:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 8020960:	fb02 f303 	mul.w	r3, r2, r3
 8020964:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 8020968:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802096c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020970:	4413      	add	r3, r2
 8020972:	035b      	lsls	r3, r3, #13
 8020974:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8020978:	4413      	add	r3, r2
 802097a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 802097e:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8020982:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020986:	1ad3      	subs	r3, r2, r3
 8020988:	035b      	lsls	r3, r3, #13
 802098a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 802098e:	4413      	add	r3, r2
 8020990:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 8020994:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8020998:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802099c:	1ad2      	subs	r2, r2, r3
 802099e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80209a2:	1ad3      	subs	r3, r2, r3
 80209a4:	009b      	lsls	r3, r3, #2
 80209a6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 80209aa:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80209ae:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80209b2:	4413      	add	r3, r2
 80209b4:	12da      	asrs	r2, r3, #11
 80209b6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80209ba:	601a      	str	r2, [r3, #0]
    wsptr[6*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 80209bc:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80209c0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80209c4:	1ad2      	subs	r2, r2, r3
 80209c6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80209ca:	3378      	adds	r3, #120	@ 0x78
 80209cc:	12d2      	asrs	r2, r2, #11
 80209ce:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) (tmp11 + tmp1);
 80209d0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80209d4:	3318      	adds	r3, #24
 80209d6:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 80209da:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80209de:	440a      	add	r2, r1
 80209e0:	601a      	str	r2, [r3, #0]
    wsptr[6*4] = (int) (tmp11 - tmp1);
 80209e2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80209e6:	3360      	adds	r3, #96	@ 0x60
 80209e8:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 80209ec:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80209f0:	1a8a      	subs	r2, r1, r2
 80209f2:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 80209f4:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80209f8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80209fc:	441a      	add	r2, r3
 80209fe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020a02:	3330      	adds	r3, #48	@ 0x30
 8020a04:	12d2      	asrs	r2, r2, #11
 8020a06:	601a      	str	r2, [r3, #0]
    wsptr[6*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 8020a08:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8020a0c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8020a10:	1ad2      	subs	r2, r2, r3
 8020a12:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020a16:	3348      	adds	r3, #72	@ 0x48
 8020a18:	12d2      	asrs	r2, r2, #11
 8020a1a:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8020a1c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8020a20:	3301      	adds	r3, #1
 8020a22:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8020a26:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8020a2a:	3302      	adds	r3, #2
 8020a2c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 8020a30:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8020a34:	3304      	adds	r3, #4
 8020a36:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8020a3a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020a3e:	3304      	adds	r3, #4
 8020a40:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8020a44:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8020a48:	2b05      	cmp	r3, #5
 8020a4a:	f77f aef5 	ble.w	8020838 <jpeg_idct_6x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array. */

  wsptr = workspace;
 8020a4e:	f107 0314 	add.w	r3, r7, #20
 8020a52:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 8020a56:	2300      	movs	r3, #0
 8020a58:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8020a5c:	e0f7      	b.n	8020c4e <jpeg_idct_6x6+0x44e>
    outptr = output_buf[ctr] + output_col;
 8020a5e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8020a62:	009b      	lsls	r3, r3, #2
 8020a64:	683a      	ldr	r2, [r7, #0]
 8020a66:	4413      	add	r3, r2
 8020a68:	681a      	ldr	r2, [r3, #0]
 8020a6a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8020a6e:	4413      	add	r3, r2
 8020a70:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8020a74:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020a78:	681b      	ldr	r3, [r3, #0]
 8020a7a:	3310      	adds	r3, #16
 8020a7c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp0 <<= CONST_BITS;
 8020a80:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020a84:	035b      	lsls	r3, r3, #13
 8020a86:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = (INT32) wsptr[4];
 8020a8a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020a8e:	3310      	adds	r3, #16
 8020a90:	681b      	ldr	r3, [r3, #0]
 8020a92:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 8020a96:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8020a9a:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8020a9e:	fb02 f303 	mul.w	r3, r2, r3
 8020aa2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = tmp0 + tmp10;
 8020aa6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8020aaa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8020aae:	4413      	add	r3, r2
 8020ab0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp11 = tmp0 - tmp10 - tmp10;
 8020ab4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8020ab8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8020abc:	1ad2      	subs	r2, r2, r3
 8020abe:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8020ac2:	1ad3      	subs	r3, r2, r3
 8020ac4:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp10 = (INT32) wsptr[2];
 8020ac8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020acc:	3308      	adds	r3, #8
 8020ace:	681b      	ldr	r3, [r3, #0]
 8020ad0:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 8020ad4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8020ad8:	f242 7231 	movw	r2, #10033	@ 0x2731
 8020adc:	fb02 f303 	mul.w	r3, r2, r3
 8020ae0:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp10 = tmp1 + tmp0;
 8020ae4:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8020ae8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020aec:	4413      	add	r3, r2
 8020aee:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp12 = tmp1 - tmp0;
 8020af2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8020af6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020afa:	1ad3      	subs	r3, r2, r3
 8020afc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8020b00:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020b04:	3304      	adds	r3, #4
 8020b06:	681b      	ldr	r3, [r3, #0]
 8020b08:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z2 = (INT32) wsptr[3];
 8020b0c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020b10:	330c      	adds	r3, #12
 8020b12:	681b      	ldr	r3, [r3, #0]
 8020b14:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z3 = (INT32) wsptr[5];
 8020b18:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020b1c:	3314      	adds	r3, #20
 8020b1e:	681b      	ldr	r3, [r3, #0]
 8020b20:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8020b24:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8020b28:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020b2c:	4413      	add	r3, r2
 8020b2e:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 8020b32:	fb02 f303 	mul.w	r3, r2, r3
 8020b36:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 8020b3a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8020b3e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020b42:	4413      	add	r3, r2
 8020b44:	035b      	lsls	r3, r3, #13
 8020b46:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8020b4a:	4413      	add	r3, r2
 8020b4c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 8020b50:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8020b54:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020b58:	1ad3      	subs	r3, r2, r3
 8020b5a:	035b      	lsls	r3, r3, #13
 8020b5c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8020b60:	4413      	add	r3, r2
 8020b62:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 8020b66:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8020b6a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020b6e:	1ad2      	subs	r2, r2, r3
 8020b70:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020b74:	1ad3      	subs	r3, r2, r3
 8020b76:	035b      	lsls	r3, r3, #13
 8020b78:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8020b7c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8020b80:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020b84:	4413      	add	r3, r2
 8020b86:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020b88:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8020b8c:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020b90:	4413      	add	r3, r2
 8020b92:	781a      	ldrb	r2, [r3, #0]
 8020b94:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020b98:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8020b9a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8020b9e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8020ba2:	1ad3      	subs	r3, r2, r3
 8020ba4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020ba6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8020baa:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020bae:	441a      	add	r2, r3
 8020bb0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020bb4:	3305      	adds	r3, #5
 8020bb6:	7812      	ldrb	r2, [r2, #0]
 8020bb8:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8020bba:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8020bbe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8020bc2:	4413      	add	r3, r2
 8020bc4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020bc6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8020bca:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020bce:	441a      	add	r2, r3
 8020bd0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020bd4:	3301      	adds	r3, #1
 8020bd6:	7812      	ldrb	r2, [r2, #0]
 8020bd8:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8020bda:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8020bde:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8020be2:	1ad3      	subs	r3, r2, r3
 8020be4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020be6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8020bea:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020bee:	441a      	add	r2, r3
 8020bf0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020bf4:	3304      	adds	r3, #4
 8020bf6:	7812      	ldrb	r2, [r2, #0]
 8020bf8:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8020bfa:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8020bfe:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8020c02:	4413      	add	r3, r2
 8020c04:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020c06:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8020c0a:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020c0e:	441a      	add	r2, r3
 8020c10:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020c14:	3302      	adds	r3, #2
 8020c16:	7812      	ldrb	r2, [r2, #0]
 8020c18:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8020c1a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8020c1e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8020c22:	1ad3      	subs	r3, r2, r3
 8020c24:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020c26:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8020c2a:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8020c2e:	441a      	add	r2, r3
 8020c30:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8020c34:	3303      	adds	r3, #3
 8020c36:	7812      	ldrb	r2, [r2, #0]
 8020c38:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8020c3a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8020c3e:	3318      	adds	r3, #24
 8020c40:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 8020c44:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8020c48:	3301      	adds	r3, #1
 8020c4a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8020c4e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8020c52:	2b05      	cmp	r3, #5
 8020c54:	f77f af03 	ble.w	8020a5e <jpeg_idct_6x6+0x25e>
  }
}
 8020c58:	bf00      	nop
 8020c5a:	bf00      	nop
 8020c5c:	37e4      	adds	r7, #228	@ 0xe4
 8020c5e:	46bd      	mov	sp, r7
 8020c60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020c64:	4770      	bx	lr
	...

08020c68 <jpeg_idct_5x5>:

GLOBAL(void)
jpeg_idct_5x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8020c68:	b480      	push	{r7}
 8020c6a:	b0ad      	sub	sp, #180	@ 0xb4
 8020c6c:	af00      	add	r7, sp, #0
 8020c6e:	60f8      	str	r0, [r7, #12]
 8020c70:	60b9      	str	r1, [r7, #8]
 8020c72:	607a      	str	r2, [r7, #4]
 8020c74:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8020c76:	68fb      	ldr	r3, [r7, #12]
 8020c78:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8020c7c:	3380      	adds	r3, #128	@ 0x80
 8020c7e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  int workspace[5*5];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8020c82:	687b      	ldr	r3, [r7, #4]
 8020c84:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8020c88:	68bb      	ldr	r3, [r7, #8]
 8020c8a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8020c8c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  wsptr = workspace;
 8020c90:	f107 0314 	add.w	r3, r7, #20
 8020c94:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8020c98:	2300      	movs	r3, #0
 8020c9a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8020c9e:	e0dd      	b.n	8020e5c <jpeg_idct_5x5+0x1f4>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8020ca0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020ca4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020ca8:	461a      	mov	r2, r3
 8020caa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020cae:	681b      	ldr	r3, [r3, #0]
 8020cb0:	fb02 f303 	mul.w	r3, r2, r3
 8020cb4:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp12 <<= CONST_BITS;
 8020cb8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8020cbc:	035b      	lsls	r3, r3, #13
 8020cbe:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 8020cc2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8020cc6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8020cca:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8020cce:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020cd2:	3320      	adds	r3, #32
 8020cd4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020cd8:	461a      	mov	r2, r3
 8020cda:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020cde:	3340      	adds	r3, #64	@ 0x40
 8020ce0:	681b      	ldr	r3, [r3, #0]
 8020ce2:	fb02 f303 	mul.w	r3, r2, r3
 8020ce6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8020cea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020cee:	3340      	adds	r3, #64	@ 0x40
 8020cf0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020cf4:	461a      	mov	r2, r3
 8020cf6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020cfa:	3380      	adds	r3, #128	@ 0x80
 8020cfc:	681b      	ldr	r3, [r3, #0]
 8020cfe:	fb02 f303 	mul.w	r3, r2, r3
 8020d02:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 8020d06:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 8020d0a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020d0e:	4413      	add	r3, r2
 8020d10:	f641 124c 	movw	r2, #6476	@ 0x194c
 8020d14:	fb02 f303 	mul.w	r3, r2, r3
 8020d18:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 8020d1c:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 8020d20:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020d24:	1ad3      	subs	r3, r2, r3
 8020d26:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8020d2a:	fb02 f303 	mul.w	r3, r2, r3
 8020d2e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = tmp12 + z2;
 8020d32:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8020d36:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020d3a:	4413      	add	r3, r2
 8020d3c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    tmp10 = z3 + z1;
 8020d40:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8020d44:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8020d48:	4413      	add	r3, r2
 8020d4a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp11 = z3 - z1;
 8020d4c:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8020d50:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8020d54:	1ad3      	subs	r3, r2, r3
 8020d56:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 -= z2 << 2;
 8020d58:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020d5c:	009b      	lsls	r3, r3, #2
 8020d5e:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8020d62:	1ad3      	subs	r3, r2, r3
 8020d64:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8020d68:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020d6c:	3310      	adds	r3, #16
 8020d6e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020d72:	461a      	mov	r2, r3
 8020d74:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020d78:	3320      	adds	r3, #32
 8020d7a:	681b      	ldr	r3, [r3, #0]
 8020d7c:	fb02 f303 	mul.w	r3, r2, r3
 8020d80:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8020d84:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020d88:	3330      	adds	r3, #48	@ 0x30
 8020d8a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020d8e:	461a      	mov	r2, r3
 8020d90:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020d94:	3360      	adds	r3, #96	@ 0x60
 8020d96:	681b      	ldr	r3, [r3, #0]
 8020d98:	fb02 f303 	mul.w	r3, r2, r3
 8020d9c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 8020da0:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8020da4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8020da8:	4413      	add	r3, r2
 8020daa:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8020dae:	fb02 f303 	mul.w	r3, r2, r3
 8020db2:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 8020db6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020dba:	f241 0271 	movw	r2, #4209	@ 0x1071
 8020dbe:	fb02 f303 	mul.w	r3, r2, r3
 8020dc2:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8020dc6:	4413      	add	r3, r2
 8020dc8:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 8020dcc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8020dd0:	4a97      	ldr	r2, [pc, #604]	@ (8021030 <jpeg_idct_5x5+0x3c8>)
 8020dd2:	fb02 f303 	mul.w	r3, r2, r3
 8020dd6:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8020dda:	4413      	add	r3, r2
 8020ddc:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8020de0:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8020de2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8020de6:	4413      	add	r3, r2
 8020de8:	12da      	asrs	r2, r3, #11
 8020dea:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020dee:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8020df0:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8020df2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8020df6:	1ad2      	subs	r2, r2, r3
 8020df8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020dfc:	3350      	adds	r3, #80	@ 0x50
 8020dfe:	12d2      	asrs	r2, r2, #11
 8020e00:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 8020e02:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8020e04:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020e08:	441a      	add	r2, r3
 8020e0a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020e0e:	3314      	adds	r3, #20
 8020e10:	12d2      	asrs	r2, r2, #11
 8020e12:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 8020e14:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8020e16:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020e1a:	1ad2      	subs	r2, r2, r3
 8020e1c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020e20:	333c      	adds	r3, #60	@ 0x3c
 8020e22:	12d2      	asrs	r2, r2, #11
 8020e24:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 8020e26:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020e2a:	3328      	adds	r3, #40	@ 0x28
 8020e2c:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8020e30:	12d2      	asrs	r2, r2, #11
 8020e32:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8020e34:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8020e38:	3301      	adds	r3, #1
 8020e3a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8020e3e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8020e42:	3302      	adds	r3, #2
 8020e44:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 8020e48:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8020e4c:	3304      	adds	r3, #4
 8020e4e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8020e52:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020e56:	3304      	adds	r3, #4
 8020e58:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8020e5c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8020e60:	2b04      	cmp	r3, #4
 8020e62:	f77f af1d 	ble.w	8020ca0 <jpeg_idct_5x5+0x38>
  }

  /* Pass 2: process 5 rows from work array, store into output array. */

  wsptr = workspace;
 8020e66:	f107 0314 	add.w	r3, r7, #20
 8020e6a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 8020e6e:	2300      	movs	r3, #0
 8020e70:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8020e74:	e0d0      	b.n	8021018 <jpeg_idct_5x5+0x3b0>
    outptr = output_buf[ctr] + output_col;
 8020e76:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8020e7a:	009b      	lsls	r3, r3, #2
 8020e7c:	683a      	ldr	r2, [r7, #0]
 8020e7e:	4413      	add	r3, r2
 8020e80:	681a      	ldr	r2, [r3, #0]
 8020e82:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8020e86:	4413      	add	r3, r2
 8020e88:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8020e8c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020e90:	681b      	ldr	r3, [r3, #0]
 8020e92:	3310      	adds	r3, #16
 8020e94:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp12 <<= CONST_BITS;
 8020e98:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8020e9c:	035b      	lsls	r3, r3, #13
 8020e9e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp0 = (INT32) wsptr[2];
 8020ea2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020ea6:	3308      	adds	r3, #8
 8020ea8:	681b      	ldr	r3, [r3, #0]
 8020eaa:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = (INT32) wsptr[4];
 8020eae:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020eb2:	3310      	adds	r3, #16
 8020eb4:	681b      	ldr	r3, [r3, #0]
 8020eb6:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 8020eba:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 8020ebe:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020ec2:	4413      	add	r3, r2
 8020ec4:	f641 124c 	movw	r2, #6476	@ 0x194c
 8020ec8:	fb02 f303 	mul.w	r3, r2, r3
 8020ecc:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 8020ed0:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 8020ed4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020ed8:	1ad3      	subs	r3, r2, r3
 8020eda:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8020ede:	fb02 f303 	mul.w	r3, r2, r3
 8020ee2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = tmp12 + z2;
 8020ee6:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8020eea:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020eee:	4413      	add	r3, r2
 8020ef0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    tmp10 = z3 + z1;
 8020ef4:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8020ef8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8020efc:	4413      	add	r3, r2
 8020efe:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp11 = z3 - z1;
 8020f00:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8020f04:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8020f08:	1ad3      	subs	r3, r2, r3
 8020f0a:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 -= z2 << 2;
 8020f0c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020f10:	009b      	lsls	r3, r3, #2
 8020f12:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8020f16:	1ad3      	subs	r3, r2, r3
 8020f18:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */

    z2 = (INT32) wsptr[1];
 8020f1c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020f20:	3304      	adds	r3, #4
 8020f22:	681b      	ldr	r3, [r3, #0]
 8020f24:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    z3 = (INT32) wsptr[3];
 8020f28:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8020f2c:	330c      	adds	r3, #12
 8020f2e:	681b      	ldr	r3, [r3, #0]
 8020f30:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 8020f34:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8020f38:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8020f3c:	4413      	add	r3, r2
 8020f3e:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8020f42:	fb02 f303 	mul.w	r3, r2, r3
 8020f46:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 8020f4a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8020f4e:	f241 0271 	movw	r2, #4209	@ 0x1071
 8020f52:	fb02 f303 	mul.w	r3, r2, r3
 8020f56:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8020f5a:	4413      	add	r3, r2
 8020f5c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 8020f60:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8020f64:	4a32      	ldr	r2, [pc, #200]	@ (8021030 <jpeg_idct_5x5+0x3c8>)
 8020f66:	fb02 f303 	mul.w	r3, r2, r3
 8020f6a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8020f6e:	4413      	add	r3, r2
 8020f70:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8020f74:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8020f76:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8020f7a:	4413      	add	r3, r2
 8020f7c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020f7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8020f82:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8020f86:	4413      	add	r3, r2
 8020f88:	781a      	ldrb	r2, [r3, #0]
 8020f8a:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8020f8e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8020f90:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8020f92:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8020f96:	1ad3      	subs	r3, r2, r3
 8020f98:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020f9a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8020f9e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8020fa2:	441a      	add	r2, r3
 8020fa4:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8020fa8:	3304      	adds	r3, #4
 8020faa:	7812      	ldrb	r2, [r2, #0]
 8020fac:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8020fae:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8020fb0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020fb4:	4413      	add	r3, r2
 8020fb6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020fb8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8020fbc:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8020fc0:	441a      	add	r2, r3
 8020fc2:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8020fc6:	3301      	adds	r3, #1
 8020fc8:	7812      	ldrb	r2, [r2, #0]
 8020fca:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8020fcc:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8020fce:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8020fd2:	1ad3      	subs	r3, r2, r3
 8020fd4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020fd6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8020fda:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8020fde:	441a      	add	r2, r3
 8020fe0:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8020fe4:	3303      	adds	r3, #3
 8020fe6:	7812      	ldrb	r2, [r2, #0]
 8020fe8:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8020fea:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8020fee:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8020ff0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8020ff4:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8020ff8:	441a      	add	r2, r3
 8020ffa:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8020ffe:	3302      	adds	r3, #2
 8021000:	7812      	ldrb	r2, [r2, #0]
 8021002:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 8021004:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8021008:	3314      	adds	r3, #20
 802100a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 802100e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8021012:	3301      	adds	r3, #1
 8021014:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8021018:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 802101c:	2b04      	cmp	r3, #4
 802101e:	f77f af2a 	ble.w	8020e76 <jpeg_idct_5x5+0x20e>
  }
}
 8021022:	bf00      	nop
 8021024:	bf00      	nop
 8021026:	37b4      	adds	r7, #180	@ 0xb4
 8021028:	46bd      	mov	sp, r7
 802102a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802102e:	4770      	bx	lr
 8021030:	ffffba5c 	.word	0xffffba5c

08021034 <jpeg_idct_4x4>:

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021034:	b480      	push	{r7}
 8021036:	b0a3      	sub	sp, #140	@ 0x8c
 8021038:	af00      	add	r7, sp, #0
 802103a:	60f8      	str	r0, [r7, #12]
 802103c:	60b9      	str	r1, [r7, #8]
 802103e:	607a      	str	r2, [r7, #4]
 8021040:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021042:	68fb      	ldr	r3, [r7, #12]
 8021044:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8021048:	3380      	adds	r3, #128	@ 0x80
 802104a:	677b      	str	r3, [r7, #116]	@ 0x74
  int workspace[4*4];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 802104c:	687b      	ldr	r3, [r7, #4]
 802104e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021052:	68bb      	ldr	r3, [r7, #8]
 8021054:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021056:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  wsptr = workspace;
 802105a:	f107 0314 	add.w	r3, r7, #20
 802105e:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8021060:	2300      	movs	r3, #0
 8021062:	67bb      	str	r3, [r7, #120]	@ 0x78
 8021064:	e07f      	b.n	8021166 <jpeg_idct_4x4+0x132>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021066:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 802106a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802106e:	461a      	mov	r2, r3
 8021070:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8021074:	681b      	ldr	r3, [r3, #0]
 8021076:	fb02 f303 	mul.w	r3, r2, r3
 802107a:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802107c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8021080:	3320      	adds	r3, #32
 8021082:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021086:	461a      	mov	r2, r3
 8021088:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802108c:	3340      	adds	r3, #64	@ 0x40
 802108e:	681b      	ldr	r3, [r3, #0]
 8021090:	fb02 f303 	mul.w	r3, r2, r3
 8021094:	66bb      	str	r3, [r7, #104]	@ 0x68
    
    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 8021096:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8021098:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802109a:	4413      	add	r3, r2
 802109c:	009b      	lsls	r3, r3, #2
 802109e:	667b      	str	r3, [r7, #100]	@ 0x64
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 80210a0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80210a2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80210a4:	1ad3      	subs	r3, r2, r3
 80210a6:	009b      	lsls	r3, r3, #2
 80210a8:	663b      	str	r3, [r7, #96]	@ 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80210aa:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80210ae:	3310      	adds	r3, #16
 80210b0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80210b4:	461a      	mov	r2, r3
 80210b6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80210ba:	3320      	adds	r3, #32
 80210bc:	681b      	ldr	r3, [r3, #0]
 80210be:	fb02 f303 	mul.w	r3, r2, r3
 80210c2:	65fb      	str	r3, [r7, #92]	@ 0x5c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80210c4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80210c8:	3330      	adds	r3, #48	@ 0x30
 80210ca:	f9b3 3000 	ldrsh.w	r3, [r3]
 80210ce:	461a      	mov	r2, r3
 80210d0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80210d4:	3360      	adds	r3, #96	@ 0x60
 80210d6:	681b      	ldr	r3, [r3, #0]
 80210d8:	fb02 f303 	mul.w	r3, r2, r3
 80210dc:	65bb      	str	r3, [r7, #88]	@ 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 80210de:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80210e0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80210e2:	4413      	add	r3, r2
 80210e4:	f241 1251 	movw	r2, #4433	@ 0x1151
 80210e8:	fb02 f303 	mul.w	r3, r2, r3
 80210ec:	657b      	str	r3, [r7, #84]	@ 0x54
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 80210ee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80210f0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80210f4:	657b      	str	r3, [r7, #84]	@ 0x54
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 80210f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80210f8:	f641 027e 	movw	r2, #6270	@ 0x187e
 80210fc:	fb03 f202 	mul.w	r2, r3, r2
 8021100:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021102:	4413      	add	r3, r2
 8021104:	12db      	asrs	r3, r3, #11
 8021106:	66fb      	str	r3, [r7, #108]	@ 0x6c
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 8021108:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802110a:	4a58      	ldr	r2, [pc, #352]	@ (802126c <jpeg_idct_4x4+0x238>)
 802110c:	fb03 f202 	mul.w	r2, r3, r2
 8021110:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021112:	4413      	add	r3, r2
 8021114:	12db      	asrs	r3, r3, #11
 8021116:	66bb      	str	r3, [r7, #104]	@ 0x68
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[4*0] = (int) (tmp10 + tmp0);
 8021118:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 802111a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802111c:	441a      	add	r2, r3
 802111e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8021120:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) (tmp10 - tmp0);
 8021122:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8021124:	3330      	adds	r3, #48	@ 0x30
 8021126:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8021128:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802112a:	1a8a      	subs	r2, r1, r2
 802112c:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) (tmp12 + tmp2);
 802112e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8021130:	3310      	adds	r3, #16
 8021132:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8021134:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8021136:	440a      	add	r2, r1
 8021138:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) (tmp12 - tmp2);
 802113a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802113c:	3320      	adds	r3, #32
 802113e:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8021140:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8021142:	1a8a      	subs	r2, r1, r2
 8021144:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8021146:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8021148:	3301      	adds	r3, #1
 802114a:	67bb      	str	r3, [r7, #120]	@ 0x78
 802114c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8021150:	3302      	adds	r3, #2
 8021152:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8021156:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802115a:	3304      	adds	r3, #4
 802115c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8021160:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8021162:	3304      	adds	r3, #4
 8021164:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8021166:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8021168:	2b03      	cmp	r3, #3
 802116a:	f77f af7c 	ble.w	8021066 <jpeg_idct_4x4+0x32>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 802116e:	f107 0314 	add.w	r3, r7, #20
 8021172:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 8021174:	2300      	movs	r3, #0
 8021176:	67bb      	str	r3, [r7, #120]	@ 0x78
 8021178:	e06e      	b.n	8021258 <jpeg_idct_4x4+0x224>
    outptr = output_buf[ctr] + output_col;
 802117a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802117c:	009b      	lsls	r3, r3, #2
 802117e:	683a      	ldr	r2, [r7, #0]
 8021180:	4413      	add	r3, r2
 8021182:	681a      	ldr	r2, [r3, #0]
 8021184:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8021188:	4413      	add	r3, r2
 802118a:	673b      	str	r3, [r7, #112]	@ 0x70

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802118c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802118e:	681b      	ldr	r3, [r3, #0]
 8021190:	3310      	adds	r3, #16
 8021192:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = (INT32) wsptr[2];
 8021194:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8021196:	3308      	adds	r3, #8
 8021198:	681b      	ldr	r3, [r3, #0]
 802119a:	66bb      	str	r3, [r7, #104]	@ 0x68

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 802119c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802119e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80211a0:	4413      	add	r3, r2
 80211a2:	035b      	lsls	r3, r3, #13
 80211a4:	667b      	str	r3, [r7, #100]	@ 0x64
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 80211a6:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80211a8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80211aa:	1ad3      	subs	r3, r2, r3
 80211ac:	035b      	lsls	r3, r3, #13
 80211ae:	663b      	str	r3, [r7, #96]	@ 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 80211b0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80211b2:	3304      	adds	r3, #4
 80211b4:	681b      	ldr	r3, [r3, #0]
 80211b6:	65fb      	str	r3, [r7, #92]	@ 0x5c
    z3 = (INT32) wsptr[3];
 80211b8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80211ba:	330c      	adds	r3, #12
 80211bc:	681b      	ldr	r3, [r3, #0]
 80211be:	65bb      	str	r3, [r7, #88]	@ 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 80211c0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80211c2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80211c4:	4413      	add	r3, r2
 80211c6:	f241 1251 	movw	r2, #4433	@ 0x1151
 80211ca:	fb02 f303 	mul.w	r3, r2, r3
 80211ce:	657b      	str	r3, [r7, #84]	@ 0x54
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 80211d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80211d2:	f641 027e 	movw	r2, #6270	@ 0x187e
 80211d6:	fb02 f303 	mul.w	r3, r2, r3
 80211da:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80211dc:	4413      	add	r3, r2
 80211de:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 80211e0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80211e2:	4a22      	ldr	r2, [pc, #136]	@ (802126c <jpeg_idct_4x4+0x238>)
 80211e4:	fb02 f303 	mul.w	r3, r2, r3
 80211e8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80211ea:	4413      	add	r3, r2
 80211ec:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80211ee:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80211f0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80211f2:	4413      	add	r3, r2
 80211f4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80211f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80211fa:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80211fc:	4413      	add	r3, r2
 80211fe:	781a      	ldrb	r2, [r3, #0]
 8021200:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8021202:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021204:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8021206:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8021208:	1ad3      	subs	r3, r2, r3
 802120a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802120c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021210:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021212:	441a      	add	r2, r3
 8021214:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8021216:	3303      	adds	r3, #3
 8021218:	7812      	ldrb	r2, [r2, #0]
 802121a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 802121c:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 802121e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8021220:	4413      	add	r3, r2
 8021222:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021224:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021228:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802122a:	441a      	add	r2, r3
 802122c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802122e:	3301      	adds	r3, #1
 8021230:	7812      	ldrb	r2, [r2, #0]
 8021232:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021234:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8021236:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8021238:	1ad3      	subs	r3, r2, r3
 802123a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802123c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021240:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021242:	441a      	add	r2, r3
 8021244:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8021246:	3302      	adds	r3, #2
 8021248:	7812      	ldrb	r2, [r2, #0]
 802124a:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 802124c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802124e:	3310      	adds	r3, #16
 8021250:	67fb      	str	r3, [r7, #124]	@ 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 8021252:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8021254:	3301      	adds	r3, #1
 8021256:	67bb      	str	r3, [r7, #120]	@ 0x78
 8021258:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802125a:	2b03      	cmp	r3, #3
 802125c:	dd8d      	ble.n	802117a <jpeg_idct_4x4+0x146>
  }
}
 802125e:	bf00      	nop
 8021260:	bf00      	nop
 8021262:	378c      	adds	r7, #140	@ 0x8c
 8021264:	46bd      	mov	sp, r7
 8021266:	f85d 7b04 	ldr.w	r7, [sp], #4
 802126a:	4770      	bx	lr
 802126c:	ffffc4df 	.word	0xffffc4df

08021270 <jpeg_idct_3x3>:

GLOBAL(void)
jpeg_idct_3x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021270:	b480      	push	{r7}
 8021272:	b099      	sub	sp, #100	@ 0x64
 8021274:	af00      	add	r7, sp, #0
 8021276:	60f8      	str	r0, [r7, #12]
 8021278:	60b9      	str	r1, [r7, #8]
 802127a:	607a      	str	r2, [r7, #4]
 802127c:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp2, tmp10, tmp12;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802127e:	68fb      	ldr	r3, [r7, #12]
 8021280:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8021284:	3380      	adds	r3, #128	@ 0x80
 8021286:	64fb      	str	r3, [r7, #76]	@ 0x4c
  int workspace[3*3];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8021288:	687b      	ldr	r3, [r7, #4]
 802128a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802128c:	68bb      	ldr	r3, [r7, #8]
 802128e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021290:	65bb      	str	r3, [r7, #88]	@ 0x58
  wsptr = workspace;
 8021292:	f107 0314 	add.w	r3, r7, #20
 8021296:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 8021298:	2300      	movs	r3, #0
 802129a:	653b      	str	r3, [r7, #80]	@ 0x50
 802129c:	e059      	b.n	8021352 <jpeg_idct_3x3+0xe2>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802129e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80212a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80212a4:	461a      	mov	r2, r3
 80212a6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80212a8:	681b      	ldr	r3, [r3, #0]
 80212aa:	fb02 f303 	mul.w	r3, r2, r3
 80212ae:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp0 <<= CONST_BITS;
 80212b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80212b2:	035b      	lsls	r3, r3, #13
 80212b4:	647b      	str	r3, [r7, #68]	@ 0x44
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 80212b6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80212b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80212bc:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80212be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80212c0:	3320      	adds	r3, #32
 80212c2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80212c6:	461a      	mov	r2, r3
 80212c8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80212ca:	3340      	adds	r3, #64	@ 0x40
 80212cc:	681b      	ldr	r3, [r3, #0]
 80212ce:	fb02 f303 	mul.w	r3, r2, r3
 80212d2:	643b      	str	r3, [r7, #64]	@ 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 80212d4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80212d6:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 80212da:	fb02 f303 	mul.w	r3, r2, r3
 80212de:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp10 = tmp0 + tmp12;
 80212e0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80212e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80212e4:	4413      	add	r3, r2
 80212e6:	63bb      	str	r3, [r7, #56]	@ 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 80212e8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80212ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80212ec:	1ad2      	subs	r2, r2, r3
 80212ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80212f0:	1ad3      	subs	r3, r2, r3
 80212f2:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80212f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80212f6:	3310      	adds	r3, #16
 80212f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80212fc:	461a      	mov	r2, r3
 80212fe:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8021300:	3320      	adds	r3, #32
 8021302:	681b      	ldr	r3, [r3, #0]
 8021304:	fb02 f303 	mul.w	r3, r2, r3
 8021308:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 802130a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802130c:	f242 7231 	movw	r2, #10033	@ 0x2731
 8021310:	fb02 f303 	mul.w	r3, r2, r3
 8021314:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8021316:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021318:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802131a:	4413      	add	r3, r2
 802131c:	12da      	asrs	r2, r3, #11
 802131e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021320:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8021322:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021324:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8021326:	1ad2      	subs	r2, r2, r3
 8021328:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802132a:	3318      	adds	r3, #24
 802132c:	12d2      	asrs	r2, r2, #11
 802132e:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 8021330:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021332:	330c      	adds	r3, #12
 8021334:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8021336:	12d2      	asrs	r2, r2, #11
 8021338:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 802133a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802133c:	3301      	adds	r3, #1
 802133e:	653b      	str	r3, [r7, #80]	@ 0x50
 8021340:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8021342:	3302      	adds	r3, #2
 8021344:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8021346:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8021348:	3304      	adds	r3, #4
 802134a:	65bb      	str	r3, [r7, #88]	@ 0x58
 802134c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802134e:	3304      	adds	r3, #4
 8021350:	657b      	str	r3, [r7, #84]	@ 0x54
 8021352:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8021354:	2b02      	cmp	r3, #2
 8021356:	dda2      	ble.n	802129e <jpeg_idct_3x3+0x2e>
  }

  /* Pass 2: process 3 rows from work array, store into output array. */

  wsptr = workspace;
 8021358:	f107 0314 	add.w	r3, r7, #20
 802135c:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 802135e:	2300      	movs	r3, #0
 8021360:	653b      	str	r3, [r7, #80]	@ 0x50
 8021362:	e053      	b.n	802140c <jpeg_idct_3x3+0x19c>
    outptr = output_buf[ctr] + output_col;
 8021364:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8021366:	009b      	lsls	r3, r3, #2
 8021368:	683a      	ldr	r2, [r7, #0]
 802136a:	4413      	add	r3, r2
 802136c:	681a      	ldr	r2, [r3, #0]
 802136e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8021370:	4413      	add	r3, r2
 8021372:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8021374:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021376:	681b      	ldr	r3, [r3, #0]
 8021378:	3310      	adds	r3, #16
 802137a:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp0 <<= CONST_BITS;
 802137c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802137e:	035b      	lsls	r3, r3, #13
 8021380:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp2 = (INT32) wsptr[2];
 8021382:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021384:	3308      	adds	r3, #8
 8021386:	681b      	ldr	r3, [r3, #0]
 8021388:	643b      	str	r3, [r7, #64]	@ 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802138a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802138c:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8021390:	fb02 f303 	mul.w	r3, r2, r3
 8021394:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp10 = tmp0 + tmp12;
 8021396:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8021398:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802139a:	4413      	add	r3, r2
 802139c:	63bb      	str	r3, [r7, #56]	@ 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 802139e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80213a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80213a2:	1ad2      	subs	r2, r2, r3
 80213a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80213a6:	1ad3      	subs	r3, r2, r3
 80213a8:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 80213aa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80213ac:	3304      	adds	r3, #4
 80213ae:	681b      	ldr	r3, [r3, #0]
 80213b0:	63fb      	str	r3, [r7, #60]	@ 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 80213b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80213b4:	f242 7231 	movw	r2, #10033	@ 0x2731
 80213b8:	fb02 f303 	mul.w	r3, r2, r3
 80213bc:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80213be:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80213c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80213c2:	4413      	add	r3, r2
 80213c4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80213c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80213ca:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80213cc:	4413      	add	r3, r2
 80213ce:	781a      	ldrb	r2, [r3, #0]
 80213d0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80213d2:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80213d4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80213d6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80213d8:	1ad3      	subs	r3, r2, r3
 80213da:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80213dc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80213e0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80213e2:	441a      	add	r2, r3
 80213e4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80213e6:	3302      	adds	r3, #2
 80213e8:	7812      	ldrb	r2, [r2, #0]
 80213ea:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 80213ec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80213ee:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80213f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 80213f4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80213f6:	441a      	add	r2, r3
 80213f8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80213fa:	3301      	adds	r3, #1
 80213fc:	7812      	ldrb	r2, [r2, #0]
 80213fe:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 8021400:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021402:	330c      	adds	r3, #12
 8021404:	657b      	str	r3, [r7, #84]	@ 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 8021406:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8021408:	3301      	adds	r3, #1
 802140a:	653b      	str	r3, [r7, #80]	@ 0x50
 802140c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802140e:	2b02      	cmp	r3, #2
 8021410:	dda8      	ble.n	8021364 <jpeg_idct_3x3+0xf4>
  }
}
 8021412:	bf00      	nop
 8021414:	bf00      	nop
 8021416:	3764      	adds	r7, #100	@ 0x64
 8021418:	46bd      	mov	sp, r7
 802141a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802141e:	4770      	bx	lr

08021420 <jpeg_idct_2x2>:

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021420:	b480      	push	{r7}
 8021422:	b08f      	sub	sp, #60	@ 0x3c
 8021424:	af00      	add	r7, sp, #0
 8021426:	60f8      	str	r0, [r7, #12]
 8021428:	60b9      	str	r1, [r7, #8]
 802142a:	607a      	str	r2, [r7, #4]
 802142c:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802142e:	68fb      	ldr	r3, [r7, #12]
 8021430:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8021434:	3380      	adds	r3, #128	@ 0x80
 8021436:	637b      	str	r3, [r7, #52]	@ 0x34
  SHIFT_TEMPS

  /* Pass 1: process columns from input. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021438:	68bb      	ldr	r3, [r7, #8]
 802143a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802143c:	633b      	str	r3, [r7, #48]	@ 0x30

  /* Column 0 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802143e:	687b      	ldr	r3, [r7, #4]
 8021440:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021444:	461a      	mov	r2, r3
 8021446:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021448:	681b      	ldr	r3, [r3, #0]
 802144a:	fb02 f303 	mul.w	r3, r2, r3
 802144e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8021450:	687b      	ldr	r3, [r7, #4]
 8021452:	3310      	adds	r3, #16
 8021454:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021458:	461a      	mov	r2, r3
 802145a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802145c:	3320      	adds	r3, #32
 802145e:	681b      	ldr	r3, [r3, #0]
 8021460:	fb02 f303 	mul.w	r3, r2, r3
 8021464:	62bb      	str	r3, [r7, #40]	@ 0x28
  /* Add fudge factor here for final descale. */
  tmp4 += ONE << 2;
 8021466:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021468:	3304      	adds	r3, #4
 802146a:	62fb      	str	r3, [r7, #44]	@ 0x2c

  tmp0 = tmp4 + tmp5;
 802146c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802146e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021470:	4413      	add	r3, r2
 8021472:	627b      	str	r3, [r7, #36]	@ 0x24
  tmp2 = tmp4 - tmp5;
 8021474:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8021476:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021478:	1ad3      	subs	r3, r2, r3
 802147a:	623b      	str	r3, [r7, #32]

  /* Column 1 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0+1], quantptr[DCTSIZE*0+1]);
 802147c:	687b      	ldr	r3, [r7, #4]
 802147e:	3302      	adds	r3, #2
 8021480:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021484:	461a      	mov	r2, r3
 8021486:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021488:	3304      	adds	r3, #4
 802148a:	681b      	ldr	r3, [r3, #0]
 802148c:	fb02 f303 	mul.w	r3, r2, r3
 8021490:	62fb      	str	r3, [r7, #44]	@ 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1+1], quantptr[DCTSIZE*1+1]);
 8021492:	687b      	ldr	r3, [r7, #4]
 8021494:	3312      	adds	r3, #18
 8021496:	f9b3 3000 	ldrsh.w	r3, [r3]
 802149a:	461a      	mov	r2, r3
 802149c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802149e:	3324      	adds	r3, #36	@ 0x24
 80214a0:	681b      	ldr	r3, [r3, #0]
 80214a2:	fb02 f303 	mul.w	r3, r2, r3
 80214a6:	62bb      	str	r3, [r7, #40]	@ 0x28

  tmp1 = tmp4 + tmp5;
 80214a8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80214aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80214ac:	4413      	add	r3, r2
 80214ae:	61fb      	str	r3, [r7, #28]
  tmp3 = tmp4 - tmp5;
 80214b0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80214b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80214b4:	1ad3      	subs	r3, r2, r3
 80214b6:	61bb      	str	r3, [r7, #24]

  /* Pass 2: process 2 rows, store into output array. */

  /* Row 0 */
  outptr = output_buf[0] + output_col;
 80214b8:	683b      	ldr	r3, [r7, #0]
 80214ba:	681a      	ldr	r2, [r3, #0]
 80214bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80214be:	4413      	add	r3, r2
 80214c0:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3) & RANGE_MASK];
 80214c2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80214c4:	69fb      	ldr	r3, [r7, #28]
 80214c6:	4413      	add	r3, r2
 80214c8:	10db      	asrs	r3, r3, #3
 80214ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80214ce:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80214d0:	4413      	add	r3, r2
 80214d2:	781a      	ldrb	r2, [r3, #0]
 80214d4:	697b      	ldr	r3, [r7, #20]
 80214d6:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3) & RANGE_MASK];
 80214d8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80214da:	69fb      	ldr	r3, [r7, #28]
 80214dc:	1ad3      	subs	r3, r2, r3
 80214de:	10db      	asrs	r3, r3, #3
 80214e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80214e4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80214e6:	441a      	add	r2, r3
 80214e8:	697b      	ldr	r3, [r7, #20]
 80214ea:	3301      	adds	r3, #1
 80214ec:	7812      	ldrb	r2, [r2, #0]
 80214ee:	701a      	strb	r2, [r3, #0]

  /* Row 1 */
  outptr = output_buf[1] + output_col;
 80214f0:	683b      	ldr	r3, [r7, #0]
 80214f2:	3304      	adds	r3, #4
 80214f4:	681a      	ldr	r2, [r3, #0]
 80214f6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80214f8:	4413      	add	r3, r2
 80214fa:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp2 + tmp3, 3) & RANGE_MASK];
 80214fc:	6a3a      	ldr	r2, [r7, #32]
 80214fe:	69bb      	ldr	r3, [r7, #24]
 8021500:	4413      	add	r3, r2
 8021502:	10db      	asrs	r3, r3, #3
 8021504:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021508:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802150a:	4413      	add	r3, r2
 802150c:	781a      	ldrb	r2, [r3, #0]
 802150e:	697b      	ldr	r3, [r7, #20]
 8021510:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2 - tmp3, 3) & RANGE_MASK];
 8021512:	6a3a      	ldr	r2, [r7, #32]
 8021514:	69bb      	ldr	r3, [r7, #24]
 8021516:	1ad3      	subs	r3, r2, r3
 8021518:	10db      	asrs	r3, r3, #3
 802151a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 802151e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8021520:	441a      	add	r2, r3
 8021522:	697b      	ldr	r3, [r7, #20]
 8021524:	3301      	adds	r3, #1
 8021526:	7812      	ldrb	r2, [r2, #0]
 8021528:	701a      	strb	r2, [r3, #0]
}
 802152a:	bf00      	nop
 802152c:	373c      	adds	r7, #60	@ 0x3c
 802152e:	46bd      	mov	sp, r7
 8021530:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021534:	4770      	bx	lr

08021536 <jpeg_idct_1x1>:

GLOBAL(void)
jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021536:	b480      	push	{r7}
 8021538:	b089      	sub	sp, #36	@ 0x24
 802153a:	af00      	add	r7, sp, #0
 802153c:	60f8      	str	r0, [r7, #12]
 802153e:	60b9      	str	r1, [r7, #8]
 8021540:	607a      	str	r2, [r7, #4]
 8021542:	603b      	str	r3, [r7, #0]
  int dcval;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021544:	68fb      	ldr	r3, [r7, #12]
 8021546:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802154a:	3380      	adds	r3, #128	@ 0x80
 802154c:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* 1x1 is trivial: just take the DC coefficient divided by 8. */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802154e:	68bb      	ldr	r3, [r7, #8]
 8021550:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021552:	61bb      	str	r3, [r7, #24]
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
 8021554:	687b      	ldr	r3, [r7, #4]
 8021556:	f9b3 3000 	ldrsh.w	r3, [r3]
 802155a:	461a      	mov	r2, r3
 802155c:	69bb      	ldr	r3, [r7, #24]
 802155e:	681b      	ldr	r3, [r3, #0]
 8021560:	fb02 f303 	mul.w	r3, r2, r3
 8021564:	617b      	str	r3, [r7, #20]
  dcval = (int) DESCALE((INT32) dcval, 3);
 8021566:	697b      	ldr	r3, [r7, #20]
 8021568:	3304      	adds	r3, #4
 802156a:	10db      	asrs	r3, r3, #3
 802156c:	617b      	str	r3, [r7, #20]

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
 802156e:	697b      	ldr	r3, [r7, #20]
 8021570:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021574:	69fa      	ldr	r2, [r7, #28]
 8021576:	441a      	add	r2, r3
 8021578:	683b      	ldr	r3, [r7, #0]
 802157a:	6819      	ldr	r1, [r3, #0]
 802157c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802157e:	440b      	add	r3, r1
 8021580:	7812      	ldrb	r2, [r2, #0]
 8021582:	701a      	strb	r2, [r3, #0]
}
 8021584:	bf00      	nop
 8021586:	3724      	adds	r7, #36	@ 0x24
 8021588:	46bd      	mov	sp, r7
 802158a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802158e:	4770      	bx	lr

08021590 <jpeg_idct_9x9>:

GLOBAL(void)
jpeg_idct_9x9 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021590:	b490      	push	{r4, r7}
 8021592:	b0e0      	sub	sp, #384	@ 0x180
 8021594:	af00      	add	r7, sp, #0
 8021596:	f507 74c0 	add.w	r4, r7, #384	@ 0x180
 802159a:	f5a4 74ba 	sub.w	r4, r4, #372	@ 0x174
 802159e:	6020      	str	r0, [r4, #0]
 80215a0:	f507 70c0 	add.w	r0, r7, #384	@ 0x180
 80215a4:	f5a0 70bc 	sub.w	r0, r0, #376	@ 0x178
 80215a8:	6001      	str	r1, [r0, #0]
 80215aa:	f507 71c0 	add.w	r1, r7, #384	@ 0x180
 80215ae:	f5a1 71be 	sub.w	r1, r1, #380	@ 0x17c
 80215b2:	600a      	str	r2, [r1, #0]
 80215b4:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 80215b8:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 80215bc:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80215be:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80215c2:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 80215c6:	681b      	ldr	r3, [r3, #0]
 80215c8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80215cc:	3380      	adds	r3, #128	@ 0x80
 80215ce:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
  int workspace[8*9];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80215d2:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80215d6:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 80215da:	681b      	ldr	r3, [r3, #0]
 80215dc:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80215e0:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80215e4:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 80215e8:	681b      	ldr	r3, [r3, #0]
 80215ea:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80215ec:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
  wsptr = workspace;
 80215f0:	f107 0314 	add.w	r3, r7, #20
 80215f4:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80215f8:	2300      	movs	r3, #0
 80215fa:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 80215fe:	e1a5      	b.n	802194c <jpeg_idct_9x9+0x3bc>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021600:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8021604:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021608:	461a      	mov	r2, r3
 802160a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802160e:	681b      	ldr	r3, [r3, #0]
 8021610:	fb02 f303 	mul.w	r3, r2, r3
 8021614:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 8021618:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802161c:	035b      	lsls	r3, r3, #13
 802161e:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021622:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021626:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802162a:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802162e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8021632:	3320      	adds	r3, #32
 8021634:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021638:	461a      	mov	r2, r3
 802163a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802163e:	3340      	adds	r3, #64	@ 0x40
 8021640:	681b      	ldr	r3, [r3, #0]
 8021642:	fb02 f303 	mul.w	r3, r2, r3
 8021646:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802164a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802164e:	3340      	adds	r3, #64	@ 0x40
 8021650:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021654:	461a      	mov	r2, r3
 8021656:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802165a:	3380      	adds	r3, #128	@ 0x80
 802165c:	681b      	ldr	r3, [r3, #0]
 802165e:	fb02 f303 	mul.w	r3, r2, r3
 8021662:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8021666:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802166a:	3360      	adds	r3, #96	@ 0x60
 802166c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021670:	461a      	mov	r2, r3
 8021672:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8021676:	33c0      	adds	r3, #192	@ 0xc0
 8021678:	681b      	ldr	r3, [r3, #0]
 802167a:	fb02 f303 	mul.w	r3, r2, r3
 802167e:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 8021682:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8021686:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 802168a:	fb02 f303 	mul.w	r3, r2, r3
 802168e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = tmp0 + tmp3;
 8021692:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8021696:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802169a:	4413      	add	r3, r2
 802169c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 80216a0:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80216a4:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80216a8:	1ad2      	subs	r2, r2, r3
 80216aa:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80216ae:	1ad3      	subs	r3, r2, r3
 80216b0:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 80216b4:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80216b8:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 80216bc:	1ad3      	subs	r3, r2, r3
 80216be:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 80216c2:	fb02 f303 	mul.w	r3, r2, r3
 80216c6:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp2 + tmp0;
 80216ca:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80216ce:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 80216d2:	4413      	add	r3, r2
 80216d4:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 80216d8:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80216dc:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 80216e0:	1ad2      	subs	r2, r2, r3
 80216e2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 80216e6:	1ad3      	subs	r3, r2, r3
 80216e8:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 80216ec:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80216f0:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 80216f4:	4413      	add	r3, r2
 80216f6:	f642 2287 	movw	r2, #10887	@ 0x2a87
 80216fa:	fb02 f303 	mul.w	r3, r2, r3
 80216fe:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 8021702:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8021706:	f242 22ab 	movw	r2, #8875	@ 0x22ab
 802170a:	fb02 f303 	mul.w	r3, r2, r3
 802170e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 8021712:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021716:	f240 72dc 	movw	r2, #2012	@ 0x7dc
 802171a:	fb02 f303 	mul.w	r3, r2, r3
 802171e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 8021722:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8021726:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802172a:	441a      	add	r2, r3
 802172c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021730:	1ad3      	subs	r3, r2, r3
 8021732:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 8021736:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802173a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802173e:	1ad3      	subs	r3, r2, r3
 8021740:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021744:	4413      	add	r3, r2
 8021746:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 802174a:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802174e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8021752:	1ad3      	subs	r3, r2, r3
 8021754:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021758:	4413      	add	r3, r2
 802175a:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802175e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8021762:	3310      	adds	r3, #16
 8021764:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021768:	461a      	mov	r2, r3
 802176a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802176e:	3320      	adds	r3, #32
 8021770:	681b      	ldr	r3, [r3, #0]
 8021772:	fb02 f303 	mul.w	r3, r2, r3
 8021776:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802177a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802177e:	3330      	adds	r3, #48	@ 0x30
 8021780:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021784:	461a      	mov	r2, r3
 8021786:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802178a:	3360      	adds	r3, #96	@ 0x60
 802178c:	681b      	ldr	r3, [r3, #0]
 802178e:	fb02 f303 	mul.w	r3, r2, r3
 8021792:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8021796:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802179a:	3350      	adds	r3, #80	@ 0x50
 802179c:	f9b3 3000 	ldrsh.w	r3, [r3]
 80217a0:	461a      	mov	r2, r3
 80217a2:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80217a6:	33a0      	adds	r3, #160	@ 0xa0
 80217a8:	681b      	ldr	r3, [r3, #0]
 80217aa:	fb02 f303 	mul.w	r3, r2, r3
 80217ae:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 80217b2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80217b6:	3370      	adds	r3, #112	@ 0x70
 80217b8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80217bc:	461a      	mov	r2, r3
 80217be:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80217c2:	33e0      	adds	r3, #224	@ 0xe0
 80217c4:	681b      	ldr	r3, [r3, #0]
 80217c6:	fb02 f303 	mul.w	r3, r2, r3
 80217ca:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 80217ce:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 80217d2:	4a65      	ldr	r2, [pc, #404]	@ (8021968 <jpeg_idct_9x9+0x3d8>)
 80217d4:	fb02 f303 	mul.w	r3, r2, r3
 80217d8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 80217dc:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80217e0:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80217e4:	4413      	add	r3, r2
 80217e6:	f641 5217 	movw	r2, #7447	@ 0x1d17
 80217ea:	fb02 f303 	mul.w	r3, r2, r3
 80217ee:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 80217f2:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80217f6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80217fa:	4413      	add	r3, r2
 80217fc:	f640 727a 	movw	r2, #3962	@ 0xf7a
 8021800:	fb02 f303 	mul.w	r3, r2, r3
 8021804:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp0 = tmp2 + tmp3 - z2;
 8021808:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802180c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021810:	441a      	add	r2, r3
 8021812:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021816:	1ad3      	subs	r3, r2, r3
 8021818:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 802181c:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8021820:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8021824:	1ad3      	subs	r3, r2, r3
 8021826:	f642 4291 	movw	r2, #11409	@ 0x2c91
 802182a:	fb02 f303 	mul.w	r3, r2, r3
 802182e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 += z2 - tmp1;
 8021832:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8021836:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802183a:	1ad3      	subs	r3, r2, r3
 802183c:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021840:	4413      	add	r3, r2
 8021842:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 += z2 + tmp1;
 8021846:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802184a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802184e:	4413      	add	r3, r2
 8021850:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021854:	4413      	add	r3, r2
 8021856:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 802185a:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802185e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8021862:	1ad2      	subs	r2, r2, r3
 8021864:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8021868:	1ad3      	subs	r3, r2, r3
 802186a:	f242 7231 	movw	r2, #10033	@ 0x2731
 802186e:	fb02 f303 	mul.w	r3, r2, r3
 8021872:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8021876:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 802187a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802187e:	4413      	add	r3, r2
 8021880:	12da      	asrs	r2, r3, #11
 8021882:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021886:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8021888:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 802188c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021890:	1ad2      	subs	r2, r2, r3
 8021892:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021896:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 802189a:	12d2      	asrs	r2, r2, #11
 802189c:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 802189e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 80218a2:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80218a6:	441a      	add	r2, r3
 80218a8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80218ac:	3320      	adds	r3, #32
 80218ae:	12d2      	asrs	r2, r2, #11
 80218b0:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 80218b2:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 80218b6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 80218ba:	1ad2      	subs	r2, r2, r3
 80218bc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80218c0:	33e0      	adds	r3, #224	@ 0xe0
 80218c2:	12d2      	asrs	r2, r2, #11
 80218c4:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 80218c6:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80218ca:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80218ce:	441a      	add	r2, r3
 80218d0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80218d4:	3340      	adds	r3, #64	@ 0x40
 80218d6:	12d2      	asrs	r2, r2, #11
 80218d8:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 80218da:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80218de:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80218e2:	1ad2      	subs	r2, r2, r3
 80218e4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80218e8:	33c0      	adds	r3, #192	@ 0xc0
 80218ea:	12d2      	asrs	r2, r2, #11
 80218ec:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS-PASS1_BITS);
 80218ee:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 80218f2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80218f6:	441a      	add	r2, r3
 80218f8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80218fc:	3360      	adds	r3, #96	@ 0x60
 80218fe:	12d2      	asrs	r2, r2, #11
 8021900:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS-PASS1_BITS);
 8021902:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8021906:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802190a:	1ad2      	subs	r2, r2, r3
 802190c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021910:	33a0      	adds	r3, #160	@ 0xa0
 8021912:	12d2      	asrs	r2, r2, #11
 8021914:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp14, CONST_BITS-PASS1_BITS);
 8021916:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802191a:	3380      	adds	r3, #128	@ 0x80
 802191c:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8021920:	12d2      	asrs	r2, r2, #11
 8021922:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021924:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021928:	3301      	adds	r3, #1
 802192a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 802192e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8021932:	3302      	adds	r3, #2
 8021934:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
 8021938:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802193c:	3304      	adds	r3, #4
 802193e:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 8021942:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021946:	3304      	adds	r3, #4
 8021948:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
 802194c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021950:	2b07      	cmp	r3, #7
 8021952:	f77f ae55 	ble.w	8021600 <jpeg_idct_9x9+0x70>
  }

  /* Pass 2: process 9 rows from work array, store into output array. */

  wsptr = workspace;
 8021956:	f107 0314 	add.w	r3, r7, #20
 802195a:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 802195e:	2300      	movs	r3, #0
 8021960:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8021964:	e19e      	b.n	8021ca4 <jpeg_idct_9x9+0x714>
 8021966:	bf00      	nop
 8021968:	ffffd8cf 	.word	0xffffd8cf
    outptr = output_buf[ctr] + output_col;
 802196c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021970:	009b      	lsls	r3, r3, #2
 8021972:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 8021976:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 802197a:	6812      	ldr	r2, [r2, #0]
 802197c:	4413      	add	r3, r2
 802197e:	681a      	ldr	r2, [r3, #0]
 8021980:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021984:	4413      	add	r3, r2
 8021986:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802198a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802198e:	681b      	ldr	r3, [r3, #0]
 8021990:	3310      	adds	r3, #16
 8021992:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 8021996:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802199a:	035b      	lsls	r3, r3, #13
 802199c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = (INT32) wsptr[2];
 80219a0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80219a4:	3308      	adds	r3, #8
 80219a6:	681b      	ldr	r3, [r3, #0]
 80219a8:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[4];
 80219ac:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80219b0:	3310      	adds	r3, #16
 80219b2:	681b      	ldr	r3, [r3, #0]
 80219b4:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = (INT32) wsptr[6];
 80219b8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80219bc:	3318      	adds	r3, #24
 80219be:	681b      	ldr	r3, [r3, #0]
 80219c0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 80219c4:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80219c8:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 80219cc:	fb02 f303 	mul.w	r3, r2, r3
 80219d0:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = tmp0 + tmp3;
 80219d4:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80219d8:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80219dc:	4413      	add	r3, r2
 80219de:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 80219e2:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80219e6:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80219ea:	1ad2      	subs	r2, r2, r3
 80219ec:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 80219f0:	1ad3      	subs	r3, r2, r3
 80219f2:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 80219f6:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80219fa:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 80219fe:	1ad3      	subs	r3, r2, r3
 8021a00:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8021a04:	fb02 f303 	mul.w	r3, r2, r3
 8021a08:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp2 + tmp0;
 8021a0c:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021a10:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021a14:	4413      	add	r3, r2
 8021a16:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 8021a1a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021a1e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021a22:	1ad2      	subs	r2, r2, r3
 8021a24:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021a28:	1ad3      	subs	r3, r2, r3
 8021a2a:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 8021a2e:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8021a32:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021a36:	4413      	add	r3, r2
 8021a38:	f642 2287 	movw	r2, #10887	@ 0x2a87
 8021a3c:	fb02 f303 	mul.w	r3, r2, r3
 8021a40:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 8021a44:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8021a48:	f242 22ab 	movw	r2, #8875	@ 0x22ab
 8021a4c:	fb02 f303 	mul.w	r3, r2, r3
 8021a50:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 8021a54:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021a58:	f240 72dc 	movw	r2, #2012	@ 0x7dc
 8021a5c:	fb02 f303 	mul.w	r3, r2, r3
 8021a60:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 8021a64:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8021a68:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021a6c:	441a      	add	r2, r3
 8021a6e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021a72:	1ad3      	subs	r3, r2, r3
 8021a74:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 8021a78:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8021a7c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021a80:	1ad3      	subs	r3, r2, r3
 8021a82:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021a86:	4413      	add	r3, r2
 8021a88:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 8021a8c:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8021a90:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8021a94:	1ad3      	subs	r3, r2, r3
 8021a96:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021a9a:	4413      	add	r3, r2
 8021a9c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8021aa0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021aa4:	3304      	adds	r3, #4
 8021aa6:	681b      	ldr	r3, [r3, #0]
 8021aa8:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[3];
 8021aac:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021ab0:	330c      	adds	r3, #12
 8021ab2:	681b      	ldr	r3, [r3, #0]
 8021ab4:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    z3 = (INT32) wsptr[5];
 8021ab8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021abc:	3314      	adds	r3, #20
 8021abe:	681b      	ldr	r3, [r3, #0]
 8021ac0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z4 = (INT32) wsptr[7];
 8021ac4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021ac8:	331c      	adds	r3, #28
 8021aca:	681b      	ldr	r3, [r3, #0]
 8021acc:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 8021ad0:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021ad4:	4a79      	ldr	r2, [pc, #484]	@ (8021cbc <jpeg_idct_9x9+0x72c>)
 8021ad6:	fb02 f303 	mul.w	r3, r2, r3
 8021ada:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 8021ade:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8021ae2:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8021ae6:	4413      	add	r3, r2
 8021ae8:	f641 5217 	movw	r2, #7447	@ 0x1d17
 8021aec:	fb02 f303 	mul.w	r3, r2, r3
 8021af0:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 8021af4:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8021af8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8021afc:	4413      	add	r3, r2
 8021afe:	f640 727a 	movw	r2, #3962	@ 0xf7a
 8021b02:	fb02 f303 	mul.w	r3, r2, r3
 8021b06:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp0 = tmp2 + tmp3 - z2;
 8021b0a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021b0e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021b12:	441a      	add	r2, r3
 8021b14:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8021b18:	1ad3      	subs	r3, r2, r3
 8021b1a:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 8021b1e:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8021b22:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8021b26:	1ad3      	subs	r3, r2, r3
 8021b28:	f642 4291 	movw	r2, #11409	@ 0x2c91
 8021b2c:	fb02 f303 	mul.w	r3, r2, r3
 8021b30:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp2 += z2 - tmp1;
 8021b34:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8021b38:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8021b3c:	1ad3      	subs	r3, r2, r3
 8021b3e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8021b42:	4413      	add	r3, r2
 8021b44:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp3 += z2 + tmp1;
 8021b48:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8021b4c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8021b50:	4413      	add	r3, r2
 8021b52:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021b56:	4413      	add	r3, r2
 8021b58:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 8021b5c:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8021b60:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8021b64:	1ad2      	subs	r2, r2, r3
 8021b66:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8021b6a:	1ad3      	subs	r3, r2, r3
 8021b6c:	f242 7231 	movw	r2, #10033	@ 0x2731
 8021b70:	fb02 f303 	mul.w	r3, r2, r3
 8021b74:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021b78:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8021b7c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021b80:	4413      	add	r3, r2
 8021b82:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021b84:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021b88:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021b8c:	4413      	add	r3, r2
 8021b8e:	781a      	ldrb	r2, [r3, #0]
 8021b90:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021b94:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021b96:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8021b9a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8021b9e:	1ad3      	subs	r3, r2, r3
 8021ba0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021ba2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021ba6:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021baa:	441a      	add	r2, r3
 8021bac:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021bb0:	3308      	adds	r3, #8
 8021bb2:	7812      	ldrb	r2, [r2, #0]
 8021bb4:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8021bb6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8021bba:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8021bbe:	4413      	add	r3, r2
 8021bc0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021bc2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8021bc6:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021bca:	441a      	add	r2, r3
 8021bcc:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021bd0:	3301      	adds	r3, #1
 8021bd2:	7812      	ldrb	r2, [r2, #0]
 8021bd4:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8021bd6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8021bda:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8021bde:	1ad3      	subs	r3, r2, r3
 8021be0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021be2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8021be6:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021bea:	441a      	add	r2, r3
 8021bec:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021bf0:	3307      	adds	r3, #7
 8021bf2:	7812      	ldrb	r2, [r2, #0]
 8021bf4:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021bf6:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8021bfa:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8021bfe:	4413      	add	r3, r2
 8021c00:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021c02:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021c06:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021c0a:	441a      	add	r2, r3
 8021c0c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021c10:	3302      	adds	r3, #2
 8021c12:	7812      	ldrb	r2, [r2, #0]
 8021c14:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021c16:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8021c1a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8021c1e:	1ad3      	subs	r3, r2, r3
 8021c20:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021c22:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021c26:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021c2a:	441a      	add	r2, r3
 8021c2c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021c30:	3306      	adds	r3, #6
 8021c32:	7812      	ldrb	r2, [r2, #0]
 8021c34:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 8021c36:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8021c3a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021c3e:	4413      	add	r3, r2
 8021c40:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021c42:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 8021c46:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021c4a:	441a      	add	r2, r3
 8021c4c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021c50:	3303      	adds	r3, #3
 8021c52:	7812      	ldrb	r2, [r2, #0]
 8021c54:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 8021c56:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8021c5a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8021c5e:	1ad3      	subs	r3, r2, r3
 8021c60:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021c62:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 8021c66:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021c6a:	441a      	add	r2, r3
 8021c6c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021c70:	3305      	adds	r3, #5
 8021c72:	7812      	ldrb	r2, [r2, #0]
 8021c74:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 8021c76:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8021c7a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021c7c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 8021c80:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8021c84:	441a      	add	r2, r3
 8021c86:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8021c8a:	3304      	adds	r3, #4
 8021c8c:	7812      	ldrb	r2, [r2, #0]
 8021c8e:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8021c90:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8021c94:	3320      	adds	r3, #32
 8021c96:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 8021c9a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021c9e:	3301      	adds	r3, #1
 8021ca0:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8021ca4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021ca8:	2b08      	cmp	r3, #8
 8021caa:	f77f ae5f 	ble.w	802196c <jpeg_idct_9x9+0x3dc>
  }
}
 8021cae:	bf00      	nop
 8021cb0:	bf00      	nop
 8021cb2:	f507 77c0 	add.w	r7, r7, #384	@ 0x180
 8021cb6:	46bd      	mov	sp, r7
 8021cb8:	bc90      	pop	{r4, r7}
 8021cba:	4770      	bx	lr
 8021cbc:	ffffd8cf 	.word	0xffffd8cf

08021cc0 <jpeg_idct_10x10>:

GLOBAL(void)
jpeg_idct_10x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021cc0:	b490      	push	{r4, r7}
 8021cc2:	b0ea      	sub	sp, #424	@ 0x1a8
 8021cc4:	af00      	add	r7, sp, #0
 8021cc6:	f507 74d4 	add.w	r4, r7, #424	@ 0x1a8
 8021cca:	f5a4 74ce 	sub.w	r4, r4, #412	@ 0x19c
 8021cce:	6020      	str	r0, [r4, #0]
 8021cd0:	f507 70d4 	add.w	r0, r7, #424	@ 0x1a8
 8021cd4:	f5a0 70d0 	sub.w	r0, r0, #416	@ 0x1a0
 8021cd8:	6001      	str	r1, [r0, #0]
 8021cda:	f507 71d4 	add.w	r1, r7, #424	@ 0x1a8
 8021cde:	f5a1 71d2 	sub.w	r1, r1, #420	@ 0x1a4
 8021ce2:	600a      	str	r2, [r1, #0]
 8021ce4:	f507 72d4 	add.w	r2, r7, #424	@ 0x1a8
 8021ce8:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 8021cec:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021cee:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 8021cf2:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
 8021cf6:	681b      	ldr	r3, [r3, #0]
 8021cf8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8021cfc:	3380      	adds	r3, #128	@ 0x80
 8021cfe:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
  int workspace[8*10];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8021d02:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 8021d06:	f5a3 73d2 	sub.w	r3, r3, #420	@ 0x1a4
 8021d0a:	681b      	ldr	r3, [r3, #0]
 8021d0c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021d10:	f507 73d4 	add.w	r3, r7, #424	@ 0x1a8
 8021d14:	f5a3 73d0 	sub.w	r3, r3, #416	@ 0x1a0
 8021d18:	681b      	ldr	r3, [r3, #0]
 8021d1a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8021d1c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  wsptr = workspace;
 8021d20:	f107 0314 	add.w	r3, r7, #20
 8021d24:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021d28:	2300      	movs	r3, #0
 8021d2a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 8021d2e:	e1d5      	b.n	80220dc <jpeg_idct_10x10+0x41c>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021d30:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021d34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021d38:	461a      	mov	r2, r3
 8021d3a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021d3e:	681b      	ldr	r3, [r3, #0]
 8021d40:	fb02 f303 	mul.w	r3, r2, r3
 8021d44:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 8021d48:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021d4c:	035b      	lsls	r3, r3, #13
 8021d4e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021d52:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021d56:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8021d5a:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8021d5e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021d62:	3340      	adds	r3, #64	@ 0x40
 8021d64:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021d68:	461a      	mov	r2, r3
 8021d6a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021d6e:	3380      	adds	r3, #128	@ 0x80
 8021d70:	681b      	ldr	r3, [r3, #0]
 8021d72:	fb02 f303 	mul.w	r3, r2, r3
 8021d76:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 8021d7a:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021d7e:	f242 429d 	movw	r2, #9373	@ 0x249d
 8021d82:	fb02 f303 	mul.w	r3, r2, r3
 8021d86:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 8021d8a:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021d8e:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8021d92:	fb02 f303 	mul.w	r3, r2, r3
 8021d96:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp10 = z3 + z1;
 8021d9a:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8021d9e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8021da2:	4413      	add	r3, r2
 8021da4:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = z3 - z2;
 8021da8:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8021dac:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021db0:	1ad3      	subs	r3, r2, r3
 8021db2:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 8021db6:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8021dba:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021dbe:	1ad3      	subs	r3, r2, r3
 8021dc0:	005b      	lsls	r3, r3, #1
 8021dc2:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8021dc6:	1ad3      	subs	r3, r2, r3
 8021dc8:	12db      	asrs	r3, r3, #11
 8021dca:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8021dce:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021dd2:	3320      	adds	r3, #32
 8021dd4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021dd8:	461a      	mov	r2, r3
 8021dda:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021dde:	3340      	adds	r3, #64	@ 0x40
 8021de0:	681b      	ldr	r3, [r3, #0]
 8021de2:	fb02 f303 	mul.w	r3, r2, r3
 8021de6:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8021dea:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021dee:	3360      	adds	r3, #96	@ 0x60
 8021df0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021df4:	461a      	mov	r2, r3
 8021df6:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021dfa:	33c0      	adds	r3, #192	@ 0xc0
 8021dfc:	681b      	ldr	r3, [r3, #0]
 8021dfe:	fb02 f303 	mul.w	r3, r2, r3
 8021e02:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8021e06:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8021e0a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021e0e:	4413      	add	r3, r2
 8021e10:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8021e14:	fb02 f303 	mul.w	r3, r2, r3
 8021e18:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 8021e1c:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021e20:	f241 0271 	movw	r2, #4209	@ 0x1071
 8021e24:	fb02 f303 	mul.w	r3, r2, r3
 8021e28:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8021e2c:	4413      	add	r3, r2
 8021e2e:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 8021e32:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021e36:	4ab0      	ldr	r2, [pc, #704]	@ (80220f8 <jpeg_idct_10x10+0x438>)
 8021e38:	fb02 f303 	mul.w	r3, r2, r3
 8021e3c:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8021e40:	4413      	add	r3, r2
 8021e42:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp20 = tmp10 + tmp12;
 8021e46:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8021e4a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021e4e:	4413      	add	r3, r2
 8021e50:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp24 = tmp10 - tmp12;
 8021e54:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8021e58:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021e5c:	1ad3      	subs	r3, r2, r3
 8021e5e:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp21 = tmp11 + tmp13;
 8021e62:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8021e66:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8021e6a:	4413      	add	r3, r2
 8021e6c:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp23 = tmp11 - tmp13;
 8021e70:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8021e74:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8021e78:	1ad3      	subs	r3, r2, r3
 8021e7a:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8021e7e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021e82:	3310      	adds	r3, #16
 8021e84:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021e88:	461a      	mov	r2, r3
 8021e8a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021e8e:	3320      	adds	r3, #32
 8021e90:	681b      	ldr	r3, [r3, #0]
 8021e92:	fb02 f303 	mul.w	r3, r2, r3
 8021e96:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8021e9a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021e9e:	3330      	adds	r3, #48	@ 0x30
 8021ea0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021ea4:	461a      	mov	r2, r3
 8021ea6:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021eaa:	3360      	adds	r3, #96	@ 0x60
 8021eac:	681b      	ldr	r3, [r3, #0]
 8021eae:	fb02 f303 	mul.w	r3, r2, r3
 8021eb2:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8021eb6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021eba:	3350      	adds	r3, #80	@ 0x50
 8021ebc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021ec0:	461a      	mov	r2, r3
 8021ec2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021ec6:	33a0      	adds	r3, #160	@ 0xa0
 8021ec8:	681b      	ldr	r3, [r3, #0]
 8021eca:	fb02 f303 	mul.w	r3, r2, r3
 8021ece:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8021ed2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8021ed6:	3370      	adds	r3, #112	@ 0x70
 8021ed8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021edc:	461a      	mov	r2, r3
 8021ede:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8021ee2:	33e0      	adds	r3, #224	@ 0xe0
 8021ee4:	681b      	ldr	r3, [r3, #0]
 8021ee6:	fb02 f303 	mul.w	r3, r2, r3
 8021eea:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp11 = z2 + z4;
 8021eee:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8021ef2:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021ef6:	4413      	add	r3, r2
 8021ef8:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = z2 - z4;
 8021efc:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8021f00:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021f04:	1ad3      	subs	r3, r2, r3
 8021f06:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 8021f0a:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8021f0e:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 8021f12:	fb02 f303 	mul.w	r3, r2, r3
 8021f16:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    z5 = z3 << CONST_BITS;
 8021f1a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021f1e:	035b      	lsls	r3, r3, #13
 8021f20:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 8021f24:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8021f28:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 8021f2c:	fb02 f303 	mul.w	r3, r2, r3
 8021f30:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z5 + tmp12;
 8021f34:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021f38:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021f3c:	4413      	add	r3, r2
 8021f3e:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 8021f42:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8021f46:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 8021f4a:	fb03 f202 	mul.w	r2, r3, r2
 8021f4e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021f52:	4413      	add	r3, r2
 8021f54:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8021f58:	4413      	add	r3, r2
 8021f5a:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 8021f5e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8021f62:	f240 7214 	movw	r2, #1812	@ 0x714
 8021f66:	fb03 f202 	mul.w	r2, r3, r2
 8021f6a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021f6e:	1ad3      	subs	r3, r2, r3
 8021f70:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8021f74:	4413      	add	r3, r2
 8021f76:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 8021f7a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8021f7e:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 8021f82:	fb02 f303 	mul.w	r3, r2, r3
 8021f86:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 8021f8a:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8021f8e:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8021f92:	1ad2      	subs	r2, r2, r3
 8021f94:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8021f98:	031b      	lsls	r3, r3, #12
 8021f9a:	1ad3      	subs	r3, r2, r3
 8021f9c:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 8021fa0:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8021fa4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8021fa8:	1ad2      	subs	r2, r2, r3
 8021faa:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8021fae:	1ad3      	subs	r3, r2, r3
 8021fb0:	009b      	lsls	r3, r3, #2
 8021fb2:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 8021fb6:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8021fba:	f642 0253 	movw	r2, #10323	@ 0x2853
 8021fbe:	fb03 f202 	mul.w	r2, r3, r2
 8021fc2:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021fc6:	1ad2      	subs	r2, r2, r3
 8021fc8:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8021fcc:	1ad3      	subs	r3, r2, r3
 8021fce:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8021fd2:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8021fd6:	f241 428c 	movw	r2, #5260	@ 0x148c
 8021fda:	fb03 f202 	mul.w	r2, r3, r2
 8021fde:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8021fe2:	1ad3      	subs	r3, r2, r3
 8021fe4:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8021fe8:	4413      	add	r3, r2
 8021fea:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8021fee:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 8021ff2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8021ff6:	4413      	add	r3, r2
 8021ff8:	12da      	asrs	r2, r3, #11
 8021ffa:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8021ffe:	601a      	str	r2, [r3, #0]
    wsptr[8*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8022000:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 8022004:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022008:	1ad2      	subs	r2, r2, r3
 802200a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802200e:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8022012:	12d2      	asrs	r2, r2, #11
 8022014:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8022016:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802201a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802201e:	441a      	add	r2, r3
 8022020:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022024:	3320      	adds	r3, #32
 8022026:	12d2      	asrs	r2, r2, #11
 8022028:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802202a:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802202e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022032:	1ad2      	subs	r2, r2, r3
 8022034:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022038:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 802203c:	12d2      	asrs	r2, r2, #11
 802203e:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp22 + tmp12);
 8022040:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022044:	3340      	adds	r3, #64	@ 0x40
 8022046:	f8d7 1174 	ldr.w	r1, [r7, #372]	@ 0x174
 802204a:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
 802204e:	440a      	add	r2, r1
 8022050:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) (tmp22 - tmp12);
 8022052:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022056:	33e0      	adds	r3, #224	@ 0xe0
 8022058:	f8d7 1174 	ldr.w	r1, [r7, #372]	@ 0x174
 802205c:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
 8022060:	1a8a      	subs	r2, r1, r2
 8022062:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8022064:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8022068:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802206c:	441a      	add	r2, r3
 802206e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022072:	3360      	adds	r3, #96	@ 0x60
 8022074:	12d2      	asrs	r2, r2, #11
 8022076:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8022078:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802207c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022080:	1ad2      	subs	r2, r2, r3
 8022082:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022086:	33c0      	adds	r3, #192	@ 0xc0
 8022088:	12d2      	asrs	r2, r2, #11
 802208a:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 802208c:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8022090:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8022094:	441a      	add	r2, r3
 8022096:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802209a:	3380      	adds	r3, #128	@ 0x80
 802209c:	12d2      	asrs	r2, r2, #11
 802209e:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 80220a0:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80220a4:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80220a8:	1ad2      	subs	r2, r2, r3
 80220aa:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 80220ae:	33a0      	adds	r3, #160	@ 0xa0
 80220b0:	12d2      	asrs	r2, r2, #11
 80220b2:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80220b4:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80220b8:	3301      	adds	r3, #1
 80220ba:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 80220be:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80220c2:	3302      	adds	r3, #2
 80220c4:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
 80220c8:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80220cc:	3304      	adds	r3, #4
 80220ce:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
 80220d2:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 80220d6:	3304      	adds	r3, #4
 80220d8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
 80220dc:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80220e0:	2b07      	cmp	r3, #7
 80220e2:	f77f ae25 	ble.w	8021d30 <jpeg_idct_10x10+0x70>
  }

  /* Pass 2: process 10 rows from work array, store into output array. */

  wsptr = workspace;
 80220e6:	f107 0314 	add.w	r3, r7, #20
 80220ea:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 80220ee:	2300      	movs	r3, #0
 80220f0:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 80220f4:	e1d4      	b.n	80224a0 <jpeg_idct_10x10+0x7e0>
 80220f6:	bf00      	nop
 80220f8:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 80220fc:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8022100:	009b      	lsls	r3, r3, #2
 8022102:	f507 72d4 	add.w	r2, r7, #424	@ 0x1a8
 8022106:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 802210a:	6812      	ldr	r2, [r2, #0]
 802210c:	4413      	add	r3, r2
 802210e:	681a      	ldr	r2, [r3, #0]
 8022110:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022114:	4413      	add	r3, r2
 8022116:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802211a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802211e:	681b      	ldr	r3, [r3, #0]
 8022120:	3310      	adds	r3, #16
 8022122:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 8022126:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 802212a:	035b      	lsls	r3, r3, #13
 802212c:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = (INT32) wsptr[4];
 8022130:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022134:	3310      	adds	r3, #16
 8022136:	681b      	ldr	r3, [r3, #0]
 8022138:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 802213c:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8022140:	f242 429d 	movw	r2, #9373	@ 0x249d
 8022144:	fb02 f303 	mul.w	r3, r2, r3
 8022148:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 802214c:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8022150:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8022154:	fb02 f303 	mul.w	r3, r2, r3
 8022158:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp10 = z3 + z1;
 802215c:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8022160:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8022164:	4413      	add	r3, r2
 8022166:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = z3 - z2;
 802216a:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 802216e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022172:	1ad3      	subs	r3, r2, r3
 8022174:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 8022178:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 802217c:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022180:	1ad3      	subs	r3, r2, r3
 8022182:	005b      	lsls	r3, r3, #1
 8022184:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8022188:	1ad3      	subs	r3, r2, r3
 802218a:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174

    z2 = (INT32) wsptr[2];
 802218e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022192:	3308      	adds	r3, #8
 8022194:	681b      	ldr	r3, [r3, #0]
 8022196:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = (INT32) wsptr[6];
 802219a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802219e:	3318      	adds	r3, #24
 80221a0:	681b      	ldr	r3, [r3, #0]
 80221a2:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 80221a6:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 80221aa:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 80221ae:	4413      	add	r3, r2
 80221b0:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 80221b4:	fb02 f303 	mul.w	r3, r2, r3
 80221b8:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 80221bc:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80221c0:	f241 0271 	movw	r2, #4209	@ 0x1071
 80221c4:	fb02 f303 	mul.w	r3, r2, r3
 80221c8:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 80221cc:	4413      	add	r3, r2
 80221ce:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 80221d2:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 80221d6:	4ab8      	ldr	r2, [pc, #736]	@ (80224b8 <jpeg_idct_10x10+0x7f8>)
 80221d8:	fb02 f303 	mul.w	r3, r2, r3
 80221dc:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 80221e0:	4413      	add	r3, r2
 80221e2:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp20 = tmp10 + tmp12;
 80221e6:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80221ea:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80221ee:	4413      	add	r3, r2
 80221f0:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp24 = tmp10 - tmp12;
 80221f4:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80221f8:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80221fc:	1ad3      	subs	r3, r2, r3
 80221fe:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp21 = tmp11 + tmp13;
 8022202:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8022206:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802220a:	4413      	add	r3, r2
 802220c:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp23 = tmp11 - tmp13;
 8022210:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8022214:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022218:	1ad3      	subs	r3, r2, r3
 802221a:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802221e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022222:	3304      	adds	r3, #4
 8022224:	681b      	ldr	r3, [r3, #0]
 8022226:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    z2 = (INT32) wsptr[3];
 802222a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802222e:	330c      	adds	r3, #12
 8022230:	681b      	ldr	r3, [r3, #0]
 8022232:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z3 = (INT32) wsptr[5];
 8022236:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 802223a:	3314      	adds	r3, #20
 802223c:	681b      	ldr	r3, [r3, #0]
 802223e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z3 <<= CONST_BITS;
 8022242:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022246:	035b      	lsls	r3, r3, #13
 8022248:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    z4 = (INT32) wsptr[7];
 802224c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022250:	331c      	adds	r3, #28
 8022252:	681b      	ldr	r3, [r3, #0]
 8022254:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp11 = z2 + z4;
 8022258:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 802225c:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8022260:	4413      	add	r3, r2
 8022262:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = z2 - z4;
 8022266:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 802226a:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 802226e:	1ad3      	subs	r3, r2, r3
 8022270:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 8022274:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022278:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 802227c:	fb02 f303 	mul.w	r3, r2, r3
 8022280:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 8022284:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022288:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 802228c:	fb02 f303 	mul.w	r3, r2, r3
 8022290:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z3 + tmp12;
 8022294:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8022298:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802229c:	4413      	add	r3, r2
 802229e:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 80222a2:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 80222a6:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 80222aa:	fb03 f202 	mul.w	r2, r3, r2
 80222ae:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80222b2:	4413      	add	r3, r2
 80222b4:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80222b8:	4413      	add	r3, r2
 80222ba:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 80222be:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 80222c2:	f240 7214 	movw	r2, #1812	@ 0x714
 80222c6:	fb03 f202 	mul.w	r2, r3, r2
 80222ca:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80222ce:	1ad3      	subs	r3, r2, r3
 80222d0:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80222d4:	4413      	add	r3, r2
 80222d6:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 80222da:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80222de:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 80222e2:	fb02 f303 	mul.w	r3, r2, r3
 80222e6:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 80222ea:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 80222ee:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80222f2:	1ad2      	subs	r2, r2, r3
 80222f4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 80222f8:	031b      	lsls	r3, r3, #12
 80222fa:	1ad3      	subs	r3, r2, r3
 80222fc:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 8022300:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8022304:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022308:	1ad3      	subs	r3, r2, r3
 802230a:	035a      	lsls	r2, r3, #13
 802230c:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022310:	1ad3      	subs	r3, r2, r3
 8022312:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 8022316:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802231a:	f642 0253 	movw	r2, #10323	@ 0x2853
 802231e:	fb03 f202 	mul.w	r2, r3, r2
 8022322:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022326:	1ad2      	subs	r2, r2, r3
 8022328:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 802232c:	1ad3      	subs	r3, r2, r3
 802232e:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8022332:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8022336:	f241 428c 	movw	r2, #5260	@ 0x148c
 802233a:	fb03 f202 	mul.w	r2, r3, r2
 802233e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022342:	1ad3      	subs	r3, r2, r3
 8022344:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8022348:	4413      	add	r3, r2
 802234a:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802234e:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 8022352:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022356:	4413      	add	r3, r2
 8022358:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802235a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802235e:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022362:	4413      	add	r3, r2
 8022364:	781a      	ldrb	r2, [r3, #0]
 8022366:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802236a:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802236c:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 8022370:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022374:	1ad3      	subs	r3, r2, r3
 8022376:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022378:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802237c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022380:	441a      	add	r2, r3
 8022382:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022386:	3309      	adds	r3, #9
 8022388:	7812      	ldrb	r2, [r2, #0]
 802238a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802238c:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8022390:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022394:	4413      	add	r3, r2
 8022396:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022398:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802239c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80223a0:	441a      	add	r2, r3
 80223a2:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80223a6:	3301      	adds	r3, #1
 80223a8:	7812      	ldrb	r2, [r2, #0]
 80223aa:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80223ac:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80223b0:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80223b4:	1ad3      	subs	r3, r2, r3
 80223b6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80223b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80223bc:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80223c0:	441a      	add	r2, r3
 80223c2:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80223c6:	3308      	adds	r3, #8
 80223c8:	7812      	ldrb	r2, [r2, #0]
 80223ca:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80223cc:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80223d0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80223d4:	4413      	add	r3, r2
 80223d6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80223d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80223dc:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80223e0:	441a      	add	r2, r3
 80223e2:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80223e6:	3302      	adds	r3, #2
 80223e8:	7812      	ldrb	r2, [r2, #0]
 80223ea:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80223ec:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 80223f0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80223f4:	1ad3      	subs	r3, r2, r3
 80223f6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80223f8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80223fc:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022400:	441a      	add	r2, r3
 8022402:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022406:	3307      	adds	r3, #7
 8022408:	7812      	ldrb	r2, [r2, #0]
 802240a:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802240c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8022410:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022414:	4413      	add	r3, r2
 8022416:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022418:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802241c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022420:	441a      	add	r2, r3
 8022422:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022426:	3303      	adds	r3, #3
 8022428:	7812      	ldrb	r2, [r2, #0]
 802242a:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802242c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8022430:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8022434:	1ad3      	subs	r3, r2, r3
 8022436:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022438:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802243c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022440:	441a      	add	r2, r3
 8022442:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022446:	3306      	adds	r3, #6
 8022448:	7812      	ldrb	r2, [r2, #0]
 802244a:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802244c:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8022450:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8022454:	4413      	add	r3, r2
 8022456:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022458:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802245c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022460:	441a      	add	r2, r3
 8022462:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022466:	3304      	adds	r3, #4
 8022468:	7812      	ldrb	r2, [r2, #0]
 802246a:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802246c:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8022470:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8022474:	1ad3      	subs	r3, r2, r3
 8022476:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022478:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802247c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022480:	441a      	add	r2, r3
 8022482:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8022486:	3305      	adds	r3, #5
 8022488:	7812      	ldrb	r2, [r2, #0]
 802248a:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 802248c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 8022490:	3320      	adds	r3, #32
 8022492:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 8022496:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802249a:	3301      	adds	r3, #1
 802249c:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
 80224a0:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80224a4:	2b09      	cmp	r3, #9
 80224a6:	f77f ae29 	ble.w	80220fc <jpeg_idct_10x10+0x43c>
  }
}
 80224aa:	bf00      	nop
 80224ac:	bf00      	nop
 80224ae:	f507 77d4 	add.w	r7, r7, #424	@ 0x1a8
 80224b2:	46bd      	mov	sp, r7
 80224b4:	bc90      	pop	{r4, r7}
 80224b6:	4770      	bx	lr
 80224b8:	ffffba5c 	.word	0xffffba5c

080224bc <jpeg_idct_11x11>:

GLOBAL(void)
jpeg_idct_11x11 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80224bc:	b490      	push	{r4, r7}
 80224be:	b0f2      	sub	sp, #456	@ 0x1c8
 80224c0:	af00      	add	r7, sp, #0
 80224c2:	f507 74e4 	add.w	r4, r7, #456	@ 0x1c8
 80224c6:	f5a4 74de 	sub.w	r4, r4, #444	@ 0x1bc
 80224ca:	6020      	str	r0, [r4, #0]
 80224cc:	f507 70e4 	add.w	r0, r7, #456	@ 0x1c8
 80224d0:	f5a0 70e0 	sub.w	r0, r0, #448	@ 0x1c0
 80224d4:	6001      	str	r1, [r0, #0]
 80224d6:	f507 71e4 	add.w	r1, r7, #456	@ 0x1c8
 80224da:	f5a1 71e2 	sub.w	r1, r1, #452	@ 0x1c4
 80224de:	600a      	str	r2, [r1, #0]
 80224e0:	f507 72e4 	add.w	r2, r7, #456	@ 0x1c8
 80224e4:	f5a2 72e4 	sub.w	r2, r2, #456	@ 0x1c8
 80224e8:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80224ea:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 80224ee:	f5a3 73de 	sub.w	r3, r3, #444	@ 0x1bc
 80224f2:	681b      	ldr	r3, [r3, #0]
 80224f4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80224f8:	3380      	adds	r3, #128	@ 0x80
 80224fa:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
  int workspace[8*11];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80224fe:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 8022502:	f5a3 73e2 	sub.w	r3, r3, #452	@ 0x1c4
 8022506:	681b      	ldr	r3, [r3, #0]
 8022508:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802250c:	f507 73e4 	add.w	r3, r7, #456	@ 0x1c8
 8022510:	f5a3 73e0 	sub.w	r3, r3, #448	@ 0x1c0
 8022514:	681b      	ldr	r3, [r3, #0]
 8022516:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8022518:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
  wsptr = workspace;
 802251c:	f107 0314 	add.w	r3, r7, #20
 8022520:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8022524:	2300      	movs	r3, #0
 8022526:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 802252a:	e22b      	b.n	8022984 <jpeg_idct_11x11+0x4c8>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802252c:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8022530:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022534:	461a      	mov	r2, r3
 8022536:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802253a:	681b      	ldr	r3, [r3, #0]
 802253c:	fb02 f303 	mul.w	r3, r2, r3
 8022540:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp10 <<= CONST_BITS;
 8022544:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8022548:	035b      	lsls	r3, r3, #13
 802254a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 802254e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8022552:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8022556:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802255a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802255e:	3320      	adds	r3, #32
 8022560:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022564:	461a      	mov	r2, r3
 8022566:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802256a:	3340      	adds	r3, #64	@ 0x40
 802256c:	681b      	ldr	r3, [r3, #0]
 802256e:	fb02 f303 	mul.w	r3, r2, r3
 8022572:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8022576:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802257a:	3340      	adds	r3, #64	@ 0x40
 802257c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022580:	461a      	mov	r2, r3
 8022582:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8022586:	3380      	adds	r3, #128	@ 0x80
 8022588:	681b      	ldr	r3, [r3, #0]
 802258a:	fb02 f303 	mul.w	r3, r2, r3
 802258e:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8022592:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8022596:	3360      	adds	r3, #96	@ 0x60
 8022598:	f9b3 3000 	ldrsh.w	r3, [r3]
 802259c:	461a      	mov	r2, r3
 802259e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80225a2:	33c0      	adds	r3, #192	@ 0xc0
 80225a4:	681b      	ldr	r3, [r3, #0]
 80225a6:	fb02 f303 	mul.w	r3, r2, r3
 80225aa:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 80225ae:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80225b2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80225b6:	1ad3      	subs	r3, r2, r3
 80225b8:	f245 127e 	movw	r2, #20862	@ 0x517e
 80225bc:	fb02 f303 	mul.w	r3, r2, r3
 80225c0:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 80225c4:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80225c8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80225cc:	1ad3      	subs	r3, r2, r3
 80225ce:	f640 52c9 	movw	r2, #3529	@ 0xdc9
 80225d2:	fb02 f303 	mul.w	r3, r2, r3
 80225d6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z4 = z1 + z3;
 80225da:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80225de:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80225e2:	4413      	add	r3, r2
 80225e4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 80225e8:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80225ec:	4aec      	ldr	r2, [pc, #944]	@ (80229a0 <jpeg_idct_11x11+0x4e4>)
 80225ee:	fb02 f303 	mul.w	r3, r2, r3
 80225f2:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    z4 -= z2;
 80225f6:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80225fa:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80225fe:	1ad3      	subs	r3, r2, r3
 8022600:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 8022604:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022608:	f642 326c 	movw	r2, #11116	@ 0x2b6c
 802260c:	fb02 f303 	mul.w	r3, r2, r3
 8022610:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8022614:	4413      	add	r3, r2
 8022616:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 802261a:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 802261e:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8022622:	441a      	add	r2, r3
 8022624:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022628:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 802262a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 802262e:	49dd      	ldr	r1, [pc, #884]	@ (80229a4 <jpeg_idct_11x11+0x4e8>)
 8022630:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 8022634:	4413      	add	r3, r2
 8022636:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 802263a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 802263e:	f244 32b5 	movw	r2, #17333	@ 0x43b5
 8022642:	fb03 f202 	mul.w	r2, r3, r2
 8022646:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 802264a:	4413      	add	r3, r2
 802264c:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022650:	4413      	add	r3, r2
 8022652:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 8022656:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802265a:	4ad3      	ldr	r2, [pc, #844]	@ (80229a8 <jpeg_idct_11x11+0x4ec>)
 802265c:	fb03 f202 	mul.w	r2, r3, r2
 8022660:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022664:	4413      	add	r3, r2
 8022666:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 802266a:	4413      	add	r3, r2
 802266c:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    tmp24 += tmp25;
 8022670:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022674:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022678:	4413      	add	r3, r2
 802267a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 802267e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022682:	4aca      	ldr	r2, [pc, #808]	@ (80229ac <jpeg_idct_11x11+0x4f0>)
 8022684:	fb02 f303 	mul.w	r3, r2, r3
 8022688:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802268c:	4413      	add	r3, r2
 802268e:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 8022692:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022696:	f643 6239 	movw	r2, #15929	@ 0x3e39
 802269a:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 802269e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80226a2:	49c3      	ldr	r1, [pc, #780]	@ (80229b0 <jpeg_idct_11x11+0x4f4>)
 80226a4:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 80226a8:	4413      	add	r3, r2
 80226aa:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 80226ae:	4413      	add	r3, r2
 80226b0:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 80226b4:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80226b8:	f46f 5235 	mvn.w	r2, #11584	@ 0x2d40
 80226bc:	fb02 f303 	mul.w	r3, r2, r3
 80226c0:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80226c4:	4413      	add	r3, r2
 80226c6:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80226ca:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80226ce:	3310      	adds	r3, #16
 80226d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80226d4:	461a      	mov	r2, r3
 80226d6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80226da:	3320      	adds	r3, #32
 80226dc:	681b      	ldr	r3, [r3, #0]
 80226de:	fb02 f303 	mul.w	r3, r2, r3
 80226e2:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80226e6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80226ea:	3330      	adds	r3, #48	@ 0x30
 80226ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 80226f0:	461a      	mov	r2, r3
 80226f2:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80226f6:	3360      	adds	r3, #96	@ 0x60
 80226f8:	681b      	ldr	r3, [r3, #0]
 80226fa:	fb02 f303 	mul.w	r3, r2, r3
 80226fe:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8022702:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8022706:	3350      	adds	r3, #80	@ 0x50
 8022708:	f9b3 3000 	ldrsh.w	r3, [r3]
 802270c:	461a      	mov	r2, r3
 802270e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8022712:	33a0      	adds	r3, #160	@ 0xa0
 8022714:	681b      	ldr	r3, [r3, #0]
 8022716:	fb02 f303 	mul.w	r3, r2, r3
 802271a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802271e:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8022722:	3370      	adds	r3, #112	@ 0x70
 8022724:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022728:	461a      	mov	r2, r3
 802272a:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802272e:	33e0      	adds	r3, #224	@ 0xe0
 8022730:	681b      	ldr	r3, [r3, #0]
 8022732:	fb02 f303 	mul.w	r3, r2, r3
 8022736:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    tmp11 = z1 + z2;
 802273a:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 802273e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022742:	4413      	add	r3, r2
 8022744:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 8022748:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 802274c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022750:	441a      	add	r2, r3
 8022752:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022756:	4413      	add	r3, r2
 8022758:	f44f 624c 	mov.w	r2, #3264	@ 0xcc0
 802275c:	fb02 f303 	mul.w	r3, r2, r3
 8022760:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 8022764:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022768:	f641 426a 	movw	r2, #7274	@ 0x1c6a
 802276c:	fb02 f303 	mul.w	r3, r2, r3
 8022770:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 8022774:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8022778:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 802277c:	4413      	add	r3, r2
 802277e:	f241 5274 	movw	r2, #5492	@ 0x1574
 8022782:	fb02 f303 	mul.w	r3, r2, r3
 8022786:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 802278a:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 802278e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022792:	4413      	add	r3, r2
 8022794:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 8022798:	fb02 f303 	mul.w	r3, r2, r3
 802279c:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80227a0:	4413      	add	r3, r2
 80227a2:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 80227a6:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 80227aa:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80227ae:	441a      	add	r2, r3
 80227b0:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80227b4:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 80227b6:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80227ba:	497e      	ldr	r1, [pc, #504]	@ (80229b4 <jpeg_idct_11x11+0x4f8>)
 80227bc:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 80227c0:	4413      	add	r3, r2
 80227c2:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 80227c6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80227ca:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 80227ce:	4413      	add	r3, r2
 80227d0:	4a79      	ldr	r2, [pc, #484]	@ (80229b8 <jpeg_idct_11x11+0x4fc>)
 80227d2:	fb02 f303 	mul.w	r3, r2, r3
 80227d6:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 80227da:	4413      	add	r3, r2
 80227dc:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 80227e0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 80227e4:	f244 2258 	movw	r2, #16984	@ 0x4258
 80227e8:	fb03 f202 	mul.w	r2, r3, r2
 80227ec:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 80227f0:	4413      	add	r3, r2
 80227f2:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 80227f6:	4413      	add	r3, r2
 80227f8:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 80227fc:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022800:	4a6e      	ldr	r2, [pc, #440]	@ (80229bc <jpeg_idct_11x11+0x500>)
 8022802:	fb03 f202 	mul.w	r2, r3, r2
 8022806:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802280a:	4413      	add	r3, r2
 802280c:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8022810:	4413      	add	r3, r2
 8022812:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 8022816:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802281a:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802281e:	4413      	add	r3, r2
 8022820:	4a67      	ldr	r2, [pc, #412]	@ (80229c0 <jpeg_idct_11x11+0x504>)
 8022822:	fb02 f303 	mul.w	r3, r2, r3
 8022826:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1;
 802282a:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 802282e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022832:	4413      	add	r3, r2
 8022834:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 8022838:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802283c:	f244 3247 	movw	r2, #17223	@ 0x4347
 8022840:	fb03 f202 	mul.w	r2, r3, r2
 8022844:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022848:	4413      	add	r3, r2
 802284a:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802284e:	4413      	add	r3, r2
 8022850:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8022854:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022858:	4a5a      	ldr	r2, [pc, #360]	@ (80229c4 <jpeg_idct_11x11+0x508>)
 802285a:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 802285e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022862:	f242 010b 	movw	r1, #8203	@ 0x200b
 8022866:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 802286a:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 802286c:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022870:	4955      	ldr	r1, [pc, #340]	@ (80229c8 <jpeg_idct_11x11+0x50c>)
 8022872:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 8022876:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8022878:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 802287c:	4413      	add	r3, r2
 802287e:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8022882:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022886:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802288a:	4413      	add	r3, r2
 802288c:	12da      	asrs	r2, r3, #11
 802288e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022892:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8022894:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022898:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802289c:	1ad2      	subs	r2, r2, r3
 802289e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80228a2:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 80228a6:	12d2      	asrs	r2, r2, #11
 80228a8:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80228aa:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80228ae:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80228b2:	441a      	add	r2, r3
 80228b4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80228b8:	3320      	adds	r3, #32
 80228ba:	12d2      	asrs	r2, r2, #11
 80228bc:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 80228be:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 80228c2:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 80228c6:	1ad2      	subs	r2, r2, r3
 80228c8:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80228cc:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80228d0:	12d2      	asrs	r2, r2, #11
 80228d2:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 80228d4:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 80228d8:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80228dc:	441a      	add	r2, r3
 80228de:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80228e2:	3340      	adds	r3, #64	@ 0x40
 80228e4:	12d2      	asrs	r2, r2, #11
 80228e6:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 80228e8:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 80228ec:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80228f0:	1ad2      	subs	r2, r2, r3
 80228f2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80228f6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80228fa:	12d2      	asrs	r2, r2, #11
 80228fc:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 80228fe:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8022902:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8022906:	441a      	add	r2, r3
 8022908:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802290c:	3360      	adds	r3, #96	@ 0x60
 802290e:	12d2      	asrs	r2, r2, #11
 8022910:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8022912:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8022916:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802291a:	1ad2      	subs	r2, r2, r3
 802291c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022920:	33e0      	adds	r3, #224	@ 0xe0
 8022922:	12d2      	asrs	r2, r2, #11
 8022924:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8022926:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802292a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802292e:	441a      	add	r2, r3
 8022930:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022934:	3380      	adds	r3, #128	@ 0x80
 8022936:	12d2      	asrs	r2, r2, #11
 8022938:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802293a:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802293e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022942:	1ad2      	subs	r2, r2, r3
 8022944:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022948:	33c0      	adds	r3, #192	@ 0xc0
 802294a:	12d2      	asrs	r2, r2, #11
 802294c:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25, CONST_BITS-PASS1_BITS);
 802294e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022952:	33a0      	adds	r3, #160	@ 0xa0
 8022954:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 8022958:	12d2      	asrs	r2, r2, #11
 802295a:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802295c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022960:	3301      	adds	r3, #1
 8022962:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 8022966:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802296a:	3302      	adds	r3, #2
 802296c:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
 8022970:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8022974:	3304      	adds	r3, #4
 8022976:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
 802297a:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802297e:	3304      	adds	r3, #4
 8022980:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
 8022984:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022988:	2b07      	cmp	r3, #7
 802298a:	f77f adcf 	ble.w	802252c <jpeg_idct_11x11+0x70>
  }

  /* Pass 2: process 11 rows from work array, store into output array. */

  wsptr = workspace;
 802298e:	f107 0314 	add.w	r3, r7, #20
 8022992:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 8022996:	2300      	movs	r3, #0
 8022998:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 802299c:	e25a      	b.n	8022e54 <jpeg_idct_11x11+0x998>
 802299e:	bf00      	nop
 80229a0:	ffffdb05 	.word	0xffffdb05
 80229a4:	ffffc5b4 	.word	0xffffc5b4
 80229a8:	ffffcf91 	.word	0xffffcf91
 80229ac:	ffffe6c3 	.word	0xffffe6c3
 80229b0:	ffffd37d 	.word	0xffffd37d
 80229b4:	ffffe276 	.word	0xffffe276
 80229b8:	ffffdac9 	.word	0xffffdac9
 80229bc:	ffffd9da 	.word	0xffffd9da
 80229c0:	ffffc675 	.word	0xffffc675
 80229c4:	ffffd10d 	.word	0xffffd10d
 80229c8:	ffffca16 	.word	0xffffca16
    outptr = output_buf[ctr] + output_col;
 80229cc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80229d0:	009b      	lsls	r3, r3, #2
 80229d2:	f507 72e4 	add.w	r2, r7, #456	@ 0x1c8
 80229d6:	f5a2 72e4 	sub.w	r2, r2, #456	@ 0x1c8
 80229da:	6812      	ldr	r2, [r2, #0]
 80229dc:	4413      	add	r3, r2
 80229de:	681a      	ldr	r2, [r3, #0]
 80229e0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80229e4:	4413      	add	r3, r2
 80229e6:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80229ea:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80229ee:	681b      	ldr	r3, [r3, #0]
 80229f0:	3310      	adds	r3, #16
 80229f2:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp10 <<= CONST_BITS;
 80229f6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 80229fa:	035b      	lsls	r3, r3, #13
 80229fc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    z1 = (INT32) wsptr[2];
 8022a00:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022a04:	3308      	adds	r3, #8
 8022a06:	681b      	ldr	r3, [r3, #0]
 8022a08:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = (INT32) wsptr[4];
 8022a0c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022a10:	3310      	adds	r3, #16
 8022a12:	681b      	ldr	r3, [r3, #0]
 8022a14:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = (INT32) wsptr[6];
 8022a18:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022a1c:	3318      	adds	r3, #24
 8022a1e:	681b      	ldr	r3, [r3, #0]
 8022a20:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 8022a24:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8022a28:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022a2c:	1ad3      	subs	r3, r2, r3
 8022a2e:	f245 127e 	movw	r2, #20862	@ 0x517e
 8022a32:	fb02 f303 	mul.w	r3, r2, r3
 8022a36:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 8022a3a:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8022a3e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022a42:	1ad3      	subs	r3, r2, r3
 8022a44:	f640 52c9 	movw	r2, #3529	@ 0xdc9
 8022a48:	fb02 f303 	mul.w	r3, r2, r3
 8022a4c:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z4 = z1 + z3;
 8022a50:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8022a54:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022a58:	4413      	add	r3, r2
 8022a5a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 8022a5e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022a62:	4af1      	ldr	r2, [pc, #964]	@ (8022e28 <jpeg_idct_11x11+0x96c>)
 8022a64:	fb02 f303 	mul.w	r3, r2, r3
 8022a68:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    z4 -= z2;
 8022a6c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8022a70:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022a74:	1ad3      	subs	r3, r2, r3
 8022a76:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 8022a7a:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022a7e:	f642 326c 	movw	r2, #11116	@ 0x2b6c
 8022a82:	fb02 f303 	mul.w	r3, r2, r3
 8022a86:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8022a8a:	4413      	add	r3, r2
 8022a8c:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 8022a90:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022a94:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8022a98:	441a      	add	r2, r3
 8022a9a:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022a9e:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 8022aa0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022aa4:	49e1      	ldr	r1, [pc, #900]	@ (8022e2c <jpeg_idct_11x11+0x970>)
 8022aa6:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 8022aaa:	4413      	add	r3, r2
 8022aac:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 8022ab0:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022ab4:	f244 32b5 	movw	r2, #17333	@ 0x43b5
 8022ab8:	fb03 f202 	mul.w	r2, r3, r2
 8022abc:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022ac0:	4413      	add	r3, r2
 8022ac2:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022ac6:	4413      	add	r3, r2
 8022ac8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 8022acc:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022ad0:	4ad7      	ldr	r2, [pc, #860]	@ (8022e30 <jpeg_idct_11x11+0x974>)
 8022ad2:	fb03 f202 	mul.w	r2, r3, r2
 8022ad6:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022ada:	4413      	add	r3, r2
 8022adc:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8022ae0:	4413      	add	r3, r2
 8022ae2:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    tmp24 += tmp25;
 8022ae6:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022aea:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022aee:	4413      	add	r3, r2
 8022af0:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 8022af4:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022af8:	4ace      	ldr	r2, [pc, #824]	@ (8022e34 <jpeg_idct_11x11+0x978>)
 8022afa:	fb02 f303 	mul.w	r3, r2, r3
 8022afe:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022b02:	4413      	add	r3, r2
 8022b04:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 8022b08:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022b0c:	f643 6239 	movw	r2, #15929	@ 0x3e39
 8022b10:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 8022b14:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022b18:	49c7      	ldr	r1, [pc, #796]	@ (8022e38 <jpeg_idct_11x11+0x97c>)
 8022b1a:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 8022b1e:	4413      	add	r3, r2
 8022b20:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022b24:	4413      	add	r3, r2
 8022b26:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 8022b2a:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022b2e:	f46f 5235 	mvn.w	r2, #11584	@ 0x2d40
 8022b32:	fb02 f303 	mul.w	r3, r2, r3
 8022b36:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8022b3a:	4413      	add	r3, r2
 8022b3c:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8022b40:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022b44:	3304      	adds	r3, #4
 8022b46:	681b      	ldr	r3, [r3, #0]
 8022b48:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    z2 = (INT32) wsptr[3];
 8022b4c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022b50:	330c      	adds	r3, #12
 8022b52:	681b      	ldr	r3, [r3, #0]
 8022b54:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    z3 = (INT32) wsptr[5];
 8022b58:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022b5c:	3314      	adds	r3, #20
 8022b5e:	681b      	ldr	r3, [r3, #0]
 8022b60:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    z4 = (INT32) wsptr[7];
 8022b64:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022b68:	331c      	adds	r3, #28
 8022b6a:	681b      	ldr	r3, [r3, #0]
 8022b6c:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    tmp11 = z1 + z2;
 8022b70:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8022b74:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022b78:	4413      	add	r3, r2
 8022b7a:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 8022b7e:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8022b82:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022b86:	441a      	add	r2, r3
 8022b88:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022b8c:	4413      	add	r3, r2
 8022b8e:	f44f 624c 	mov.w	r2, #3264	@ 0xcc0
 8022b92:	fb02 f303 	mul.w	r3, r2, r3
 8022b96:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 8022b9a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022b9e:	f641 426a 	movw	r2, #7274	@ 0x1c6a
 8022ba2:	fb02 f303 	mul.w	r3, r2, r3
 8022ba6:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 8022baa:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8022bae:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022bb2:	4413      	add	r3, r2
 8022bb4:	f241 5274 	movw	r2, #5492	@ 0x1574
 8022bb8:	fb02 f303 	mul.w	r3, r2, r3
 8022bbc:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 8022bc0:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8022bc4:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022bc8:	4413      	add	r3, r2
 8022bca:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 8022bce:	fb02 f303 	mul.w	r3, r2, r3
 8022bd2:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8022bd6:	4413      	add	r3, r2
 8022bd8:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 8022bdc:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8022be0:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022be4:	441a      	add	r2, r3
 8022be6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8022bea:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 8022bec:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022bf0:	4992      	ldr	r1, [pc, #584]	@ (8022e3c <jpeg_idct_11x11+0x980>)
 8022bf2:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 8022bf6:	4413      	add	r3, r2
 8022bf8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 8022bfc:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8022c00:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022c04:	4413      	add	r3, r2
 8022c06:	4a8e      	ldr	r2, [pc, #568]	@ (8022e40 <jpeg_idct_11x11+0x984>)
 8022c08:	fb02 f303 	mul.w	r3, r2, r3
 8022c0c:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8022c10:	4413      	add	r3, r2
 8022c12:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 8022c16:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022c1a:	f244 2258 	movw	r2, #16984	@ 0x4258
 8022c1e:	fb03 f202 	mul.w	r2, r3, r2
 8022c22:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022c26:	4413      	add	r3, r2
 8022c28:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8022c2c:	4413      	add	r3, r2
 8022c2e:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 8022c32:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022c36:	4a83      	ldr	r2, [pc, #524]	@ (8022e44 <jpeg_idct_11x11+0x988>)
 8022c38:	fb03 f202 	mul.w	r2, r3, r2
 8022c3c:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022c40:	4413      	add	r3, r2
 8022c42:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 8022c46:	4413      	add	r3, r2
 8022c48:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 8022c4c:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8022c50:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022c54:	4413      	add	r3, r2
 8022c56:	4a7c      	ldr	r2, [pc, #496]	@ (8022e48 <jpeg_idct_11x11+0x98c>)
 8022c58:	fb02 f303 	mul.w	r3, r2, r3
 8022c5c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp11 += z1;
 8022c60:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
 8022c64:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022c68:	4413      	add	r3, r2
 8022c6a:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 8022c6e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022c72:	f244 3247 	movw	r2, #17223	@ 0x4347
 8022c76:	fb03 f202 	mul.w	r2, r3, r2
 8022c7a:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8022c7e:	4413      	add	r3, r2
 8022c80:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 8022c84:	4413      	add	r3, r2
 8022c86:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8022c8a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 8022c8e:	4a6f      	ldr	r2, [pc, #444]	@ (8022e4c <jpeg_idct_11x11+0x990>)
 8022c90:	fb03 f202 	mul.w	r2, r3, r2
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 8022c94:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 8022c98:	f242 010b 	movw	r1, #8203	@ 0x200b
 8022c9c:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8022ca0:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 8022ca2:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8022ca6:	496a      	ldr	r1, [pc, #424]	@ (8022e50 <jpeg_idct_11x11+0x994>)
 8022ca8:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 8022cac:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 8022cae:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 8022cb2:	4413      	add	r3, r2
 8022cb4:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8022cb8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022cbc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8022cc0:	4413      	add	r3, r2
 8022cc2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022cc4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8022cc8:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022ccc:	4413      	add	r3, r2
 8022cce:	781a      	ldrb	r2, [r3, #0]
 8022cd0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022cd4:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8022cd6:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8022cda:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8022cde:	1ad3      	subs	r3, r2, r3
 8022ce0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022ce2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8022ce6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022cea:	441a      	add	r2, r3
 8022cec:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022cf0:	330a      	adds	r3, #10
 8022cf2:	7812      	ldrb	r2, [r2, #0]
 8022cf4:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8022cf6:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8022cfa:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022cfe:	4413      	add	r3, r2
 8022d00:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022d02:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8022d06:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022d0a:	441a      	add	r2, r3
 8022d0c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022d10:	3301      	adds	r3, #1
 8022d12:	7812      	ldrb	r2, [r2, #0]
 8022d14:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8022d16:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 8022d1a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8022d1e:	1ad3      	subs	r3, r2, r3
 8022d20:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022d22:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8022d26:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022d2a:	441a      	add	r2, r3
 8022d2c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022d30:	3309      	adds	r3, #9
 8022d32:	7812      	ldrb	r2, [r2, #0]
 8022d34:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8022d36:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8022d3a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022d3e:	4413      	add	r3, r2
 8022d40:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022d42:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8022d46:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022d4a:	441a      	add	r2, r3
 8022d4c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022d50:	3302      	adds	r3, #2
 8022d52:	7812      	ldrb	r2, [r2, #0]
 8022d54:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8022d56:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8022d5a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8022d5e:	1ad3      	subs	r3, r2, r3
 8022d60:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022d62:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8022d66:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022d6a:	441a      	add	r2, r3
 8022d6c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022d70:	3308      	adds	r3, #8
 8022d72:	7812      	ldrb	r2, [r2, #0]
 8022d74:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8022d76:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8022d7a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8022d7e:	4413      	add	r3, r2
 8022d80:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022d82:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8022d86:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022d8a:	441a      	add	r2, r3
 8022d8c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022d90:	3303      	adds	r3, #3
 8022d92:	7812      	ldrb	r2, [r2, #0]
 8022d94:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8022d96:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8022d9a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8022d9e:	1ad3      	subs	r3, r2, r3
 8022da0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022da2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8022da6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022daa:	441a      	add	r2, r3
 8022dac:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022db0:	3307      	adds	r3, #7
 8022db2:	7812      	ldrb	r2, [r2, #0]
 8022db4:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8022db6:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022dba:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022dbe:	4413      	add	r3, r2
 8022dc0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022dc2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8022dc6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022dca:	441a      	add	r2, r3
 8022dcc:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022dd0:	3304      	adds	r3, #4
 8022dd2:	7812      	ldrb	r2, [r2, #0]
 8022dd4:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8022dd6:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8022dda:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8022dde:	1ad3      	subs	r3, r2, r3
 8022de0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022de2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8022de6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022dea:	441a      	add	r2, r3
 8022dec:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022df0:	3306      	adds	r3, #6
 8022df2:	7812      	ldrb	r2, [r2, #0]
 8022df4:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 8022df6:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8022dfa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8022dfc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 8022e00:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8022e04:	441a      	add	r2, r3
 8022e06:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8022e0a:	3305      	adds	r3, #5
 8022e0c:	7812      	ldrb	r2, [r2, #0]
 8022e0e:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8022e10:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022e14:	3320      	adds	r3, #32
 8022e16:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 8022e1a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022e1e:	3301      	adds	r3, #1
 8022e20:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
 8022e24:	e016      	b.n	8022e54 <jpeg_idct_11x11+0x998>
 8022e26:	bf00      	nop
 8022e28:	ffffdb05 	.word	0xffffdb05
 8022e2c:	ffffc5b4 	.word	0xffffc5b4
 8022e30:	ffffcf91 	.word	0xffffcf91
 8022e34:	ffffe6c3 	.word	0xffffe6c3
 8022e38:	ffffd37d 	.word	0xffffd37d
 8022e3c:	ffffe276 	.word	0xffffe276
 8022e40:	ffffdac9 	.word	0xffffdac9
 8022e44:	ffffd9da 	.word	0xffffd9da
 8022e48:	ffffc675 	.word	0xffffc675
 8022e4c:	ffffd10d 	.word	0xffffd10d
 8022e50:	ffffca16 	.word	0xffffca16
 8022e54:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022e58:	2b0a      	cmp	r3, #10
 8022e5a:	f77f adb7 	ble.w	80229cc <jpeg_idct_11x11+0x510>
  }
}
 8022e5e:	bf00      	nop
 8022e60:	bf00      	nop
 8022e62:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
 8022e66:	46bd      	mov	sp, r7
 8022e68:	bc90      	pop	{r4, r7}
 8022e6a:	4770      	bx	lr

08022e6c <jpeg_idct_12x12>:

GLOBAL(void)
jpeg_idct_12x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8022e6c:	b490      	push	{r4, r7}
 8022e6e:	b0fa      	sub	sp, #488	@ 0x1e8
 8022e70:	af00      	add	r7, sp, #0
 8022e72:	f507 74f4 	add.w	r4, r7, #488	@ 0x1e8
 8022e76:	f5a4 74ee 	sub.w	r4, r4, #476	@ 0x1dc
 8022e7a:	6020      	str	r0, [r4, #0]
 8022e7c:	f507 70f4 	add.w	r0, r7, #488	@ 0x1e8
 8022e80:	f5a0 70f0 	sub.w	r0, r0, #480	@ 0x1e0
 8022e84:	6001      	str	r1, [r0, #0]
 8022e86:	f507 71f4 	add.w	r1, r7, #488	@ 0x1e8
 8022e8a:	f5a1 71f2 	sub.w	r1, r1, #484	@ 0x1e4
 8022e8e:	600a      	str	r2, [r1, #0]
 8022e90:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
 8022e94:	f5a2 72f4 	sub.w	r2, r2, #488	@ 0x1e8
 8022e98:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8022e9a:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8022e9e:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 8022ea2:	681b      	ldr	r3, [r3, #0]
 8022ea4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8022ea8:	3380      	adds	r3, #128	@ 0x80
 8022eaa:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
  int workspace[8*12];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8022eae:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8022eb2:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
 8022eb6:	681b      	ldr	r3, [r3, #0]
 8022eb8:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8022ebc:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
 8022ec0:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
 8022ec4:	681b      	ldr	r3, [r3, #0]
 8022ec6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8022ec8:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
  wsptr = workspace;
 8022ecc:	f107 0310 	add.w	r3, r7, #16
 8022ed0:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8022ed4:	2300      	movs	r3, #0
 8022ed6:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 8022eda:	e218      	b.n	802330e <jpeg_idct_12x12+0x4a2>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8022edc:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8022ee0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022ee4:	461a      	mov	r2, r3
 8022ee6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8022eea:	681b      	ldr	r3, [r3, #0]
 8022eec:	fb02 f303 	mul.w	r3, r2, r3
 8022ef0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z3 <<= CONST_BITS;
 8022ef4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8022ef8:	035b      	lsls	r3, r3, #13
 8022efa:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 8022efe:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8022f02:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8022f06:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8022f0a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8022f0e:	3340      	adds	r3, #64	@ 0x40
 8022f10:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022f14:	461a      	mov	r2, r3
 8022f16:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8022f1a:	3380      	adds	r3, #128	@ 0x80
 8022f1c:	681b      	ldr	r3, [r3, #0]
 8022f1e:	fb02 f303 	mul.w	r3, r2, r3
 8022f22:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8022f26:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8022f2a:	f242 7231 	movw	r2, #10033	@ 0x2731
 8022f2e:	fb02 f303 	mul.w	r3, r2, r3
 8022f32:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp10 = z3 + z4;
 8022f36:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8022f3a:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8022f3e:	4413      	add	r3, r2
 8022f40:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp11 = z3 - z4;
 8022f44:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8022f48:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8022f4c:	1ad3      	subs	r3, r2, r3
 8022f4e:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8022f52:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8022f56:	3320      	adds	r3, #32
 8022f58:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022f5c:	461a      	mov	r2, r3
 8022f5e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8022f62:	3340      	adds	r3, #64	@ 0x40
 8022f64:	681b      	ldr	r3, [r3, #0]
 8022f66:	fb02 f303 	mul.w	r3, r2, r3
 8022f6a:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8022f6e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022f72:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 8022f76:	fb02 f303 	mul.w	r3, r2, r3
 8022f7a:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z1 <<= CONST_BITS;
 8022f7e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8022f82:	035b      	lsls	r3, r3, #13
 8022f84:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8022f88:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8022f8c:	3360      	adds	r3, #96	@ 0x60
 8022f8e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022f92:	461a      	mov	r2, r3
 8022f94:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8022f98:	33c0      	adds	r3, #192	@ 0xc0
 8022f9a:	681b      	ldr	r3, [r3, #0]
 8022f9c:	fb02 f303 	mul.w	r3, r2, r3
 8022fa0:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z2 <<= CONST_BITS;
 8022fa4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022fa8:	035b      	lsls	r3, r3, #13
 8022faa:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp12 = z1 - z2;
 8022fae:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8022fb2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022fb6:	1ad3      	subs	r3, r2, r3
 8022fb8:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp21 = z3 + tmp12;
 8022fbc:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8022fc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8022fc4:	4413      	add	r3, r2
 8022fc6:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp24 = z3 - tmp12;
 8022fca:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8022fce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8022fd2:	1ad3      	subs	r3, r2, r3
 8022fd4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    tmp12 = z4 + z2;
 8022fd8:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8022fdc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8022fe0:	4413      	add	r3, r2
 8022fe2:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp20 = tmp10 + tmp12;
 8022fe6:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8022fea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8022fee:	4413      	add	r3, r2
 8022ff0:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp25 = tmp10 - tmp12;
 8022ff4:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8022ff8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8022ffc:	1ad3      	subs	r3, r2, r3
 8022ffe:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

    tmp12 = z4 - z1 - z2;
 8023002:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8023006:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802300a:	1ad2      	subs	r2, r2, r3
 802300c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023010:	1ad3      	subs	r3, r2, r3
 8023012:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp22 = tmp11 + tmp12;
 8023016:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 802301a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802301e:	4413      	add	r3, r2
 8023020:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp23 = tmp11 - tmp12;
 8023024:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8023028:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802302c:	1ad3      	subs	r3, r2, r3
 802302e:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8023032:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023036:	3310      	adds	r3, #16
 8023038:	f9b3 3000 	ldrsh.w	r3, [r3]
 802303c:	461a      	mov	r2, r3
 802303e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023042:	3320      	adds	r3, #32
 8023044:	681b      	ldr	r3, [r3, #0]
 8023046:	fb02 f303 	mul.w	r3, r2, r3
 802304a:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802304e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023052:	3330      	adds	r3, #48	@ 0x30
 8023054:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023058:	461a      	mov	r2, r3
 802305a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802305e:	3360      	adds	r3, #96	@ 0x60
 8023060:	681b      	ldr	r3, [r3, #0]
 8023062:	fb02 f303 	mul.w	r3, r2, r3
 8023066:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802306a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802306e:	3350      	adds	r3, #80	@ 0x50
 8023070:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023074:	461a      	mov	r2, r3
 8023076:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802307a:	33a0      	adds	r3, #160	@ 0xa0
 802307c:	681b      	ldr	r3, [r3, #0]
 802307e:	fb02 f303 	mul.w	r3, r2, r3
 8023082:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8023086:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802308a:	3370      	adds	r3, #112	@ 0x70
 802308c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023090:	461a      	mov	r2, r3
 8023092:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023096:	33e0      	adds	r3, #224	@ 0xe0
 8023098:	681b      	ldr	r3, [r3, #0]
 802309a:	fb02 f303 	mul.w	r3, r2, r3
 802309e:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 80230a2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80230a6:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 80230aa:	fb02 f303 	mul.w	r3, r2, r3
 80230ae:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 80230b2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80230b6:	4a9c      	ldr	r2, [pc, #624]	@ (8023328 <jpeg_idct_12x12+0x4bc>)
 80230b8:	fb02 f303 	mul.w	r3, r2, r3
 80230bc:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    tmp10 = z1 + z3;
 80230c0:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80230c4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80230c8:	4413      	add	r3, r2
 80230ca:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 80230ce:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80230d2:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80230d6:	4413      	add	r3, r2
 80230d8:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 80230dc:	fb02 f303 	mul.w	r3, r2, r3
 80230e0:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 80230e4:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80230e8:	f640 025b 	movw	r2, #2139	@ 0x85b
 80230ec:	fb02 f303 	mul.w	r3, r2, r3
 80230f0:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80230f4:	4413      	add	r3, r2
 80230f6:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 80230fa:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80230fe:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023102:	18d1      	adds	r1, r2, r3
 8023104:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8023108:	4613      	mov	r3, r2
 802310a:	00db      	lsls	r3, r3, #3
 802310c:	4413      	add	r3, r2
 802310e:	021a      	lsls	r2, r3, #8
 8023110:	1ad3      	subs	r3, r2, r3
 8023112:	440b      	add	r3, r1
 8023114:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8023118:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802311c:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023120:	4413      	add	r3, r2
 8023122:	4a82      	ldr	r2, [pc, #520]	@ (802332c <jpeg_idct_12x12+0x4c0>)
 8023124:	fb02 f303 	mul.w	r3, r2, r3
 8023128:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 802312c:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8023130:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8023134:	441a      	add	r2, r3
 8023136:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 802313a:	497d      	ldr	r1, [pc, #500]	@ (8023330 <jpeg_idct_12x12+0x4c4>)
 802313c:	fb01 f303 	mul.w	r3, r1, r3
 8023140:	4413      	add	r3, r2
 8023142:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8023146:	4413      	add	r3, r2
 8023148:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 802314c:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8023150:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023154:	1ad2      	subs	r2, r2, r3
 8023156:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802315a:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 802315e:	fb01 f303 	mul.w	r3, r1, r3
 8023162:	4413      	add	r3, r2
 8023164:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8023168:	4413      	add	r3, r2
 802316a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802316e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8023172:	4a70      	ldr	r2, [pc, #448]	@ (8023334 <jpeg_idct_12x12+0x4c8>)
 8023174:	fb03 f202 	mul.w	r2, r3, r2
 8023178:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802317c:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 802317e:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023182:	496d      	ldr	r1, [pc, #436]	@ (8023338 <jpeg_idct_12x12+0x4cc>)
 8023184:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8023188:	4413      	add	r3, r2
 802318a:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 802318e:	4413      	add	r3, r2
 8023190:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    z1 -= z4;
 8023194:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8023198:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802319c:	1ad3      	subs	r3, r2, r3
 802319e:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 -= z3;
 80231a2:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80231a6:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80231aa:	1ad3      	subs	r3, r2, r3
 80231ac:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 80231b0:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80231b4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80231b8:	4413      	add	r3, r2
 80231ba:	f241 1251 	movw	r2, #4433	@ 0x1151
 80231be:	fb02 f303 	mul.w	r3, r2, r3
 80231c2:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 80231c6:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80231ca:	f641 027e 	movw	r2, #6270	@ 0x187e
 80231ce:	fb02 f303 	mul.w	r3, r2, r3
 80231d2:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80231d6:	4413      	add	r3, r2
 80231d8:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 80231dc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80231e0:	4a56      	ldr	r2, [pc, #344]	@ (802333c <jpeg_idct_12x12+0x4d0>)
 80231e2:	fb02 f303 	mul.w	r3, r2, r3
 80231e6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80231ea:	4413      	add	r3, r2
 80231ec:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80231f0:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80231f4:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80231f8:	4413      	add	r3, r2
 80231fa:	12da      	asrs	r2, r3, #11
 80231fc:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023200:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8023202:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8023206:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 802320a:	1ad2      	subs	r2, r2, r3
 802320c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023210:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8023214:	12d2      	asrs	r2, r2, #11
 8023216:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8023218:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 802321c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023220:	441a      	add	r2, r3
 8023222:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023226:	3320      	adds	r3, #32
 8023228:	12d2      	asrs	r2, r2, #11
 802322a:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802322c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8023230:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023234:	1ad2      	subs	r2, r2, r3
 8023236:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802323a:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 802323e:	12d2      	asrs	r2, r2, #11
 8023240:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8023242:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8023246:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802324a:	441a      	add	r2, r3
 802324c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023250:	3340      	adds	r3, #64	@ 0x40
 8023252:	12d2      	asrs	r2, r2, #11
 8023254:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8023256:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 802325a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802325e:	1ad2      	subs	r2, r2, r3
 8023260:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023264:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8023268:	12d2      	asrs	r2, r2, #11
 802326a:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802326c:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8023270:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8023274:	441a      	add	r2, r3
 8023276:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802327a:	3360      	adds	r3, #96	@ 0x60
 802327c:	12d2      	asrs	r2, r2, #11
 802327e:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8023280:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8023284:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 8023288:	1ad2      	subs	r2, r2, r3
 802328a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802328e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8023292:	12d2      	asrs	r2, r2, #11
 8023294:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8023296:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 802329a:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802329e:	441a      	add	r2, r3
 80232a0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80232a4:	3380      	adds	r3, #128	@ 0x80
 80232a6:	12d2      	asrs	r2, r2, #11
 80232a8:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 80232aa:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80232ae:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80232b2:	1ad2      	subs	r2, r2, r3
 80232b4:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80232b8:	33e0      	adds	r3, #224	@ 0xe0
 80232ba:	12d2      	asrs	r2, r2, #11
 80232bc:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 80232be:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80232c2:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80232c6:	441a      	add	r2, r3
 80232c8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80232cc:	33a0      	adds	r3, #160	@ 0xa0
 80232ce:	12d2      	asrs	r2, r2, #11
 80232d0:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 80232d2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 80232d6:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 80232da:	1ad2      	subs	r2, r2, r3
 80232dc:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80232e0:	33c0      	adds	r3, #192	@ 0xc0
 80232e2:	12d2      	asrs	r2, r2, #11
 80232e4:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80232e6:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80232ea:	3301      	adds	r3, #1
 80232ec:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 80232f0:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 80232f4:	3302      	adds	r3, #2
 80232f6:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
 80232fa:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 80232fe:	3304      	adds	r3, #4
 8023300:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
 8023304:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023308:	3304      	adds	r3, #4
 802330a:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
 802330e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023312:	2b07      	cmp	r3, #7
 8023314:	f77f ade2 	ble.w	8022edc <jpeg_idct_12x12+0x70>
  }

  /* Pass 2: process 12 rows from work array, store into output array. */

  wsptr = workspace;
 8023318:	f107 0310 	add.w	r3, r7, #16
 802331c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 8023320:	2300      	movs	r3, #0
 8023322:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 8023326:	e229      	b.n	802377c <jpeg_idct_12x12+0x910>
 8023328:	ffffeeaf 	.word	0xffffeeaf
 802332c:	ffffde8b 	.word	0xffffde8b
 8023330:	ffffd0b0 	.word	0xffffd0b0
 8023334:	ffffea5c 	.word	0xffffea5c
 8023338:	ffffc08c 	.word	0xffffc08c
 802333c:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 8023340:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023344:	009b      	lsls	r3, r3, #2
 8023346:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
 802334a:	f5a2 72f4 	sub.w	r2, r2, #488	@ 0x1e8
 802334e:	6812      	ldr	r2, [r2, #0]
 8023350:	4413      	add	r3, r2
 8023352:	681a      	ldr	r2, [r3, #0]
 8023354:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023358:	4413      	add	r3, r2
 802335a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802335e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023362:	681b      	ldr	r3, [r3, #0]
 8023364:	3310      	adds	r3, #16
 8023366:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z3 <<= CONST_BITS;
 802336a:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 802336e:	035b      	lsls	r3, r3, #13
 8023370:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

    z4 = (INT32) wsptr[4];
 8023374:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023378:	3310      	adds	r3, #16
 802337a:	681b      	ldr	r3, [r3, #0]
 802337c:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8023380:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023384:	f242 7231 	movw	r2, #10033	@ 0x2731
 8023388:	fb02 f303 	mul.w	r3, r2, r3
 802338c:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp10 = z3 + z4;
 8023390:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8023394:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023398:	4413      	add	r3, r2
 802339a:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp11 = z3 - z4;
 802339e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80233a2:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80233a6:	1ad3      	subs	r3, r2, r3
 80233a8:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    z1 = (INT32) wsptr[2];
 80233ac:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80233b0:	3308      	adds	r3, #8
 80233b2:	681b      	ldr	r3, [r3, #0]
 80233b4:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 80233b8:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80233bc:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 80233c0:	fb02 f303 	mul.w	r3, r2, r3
 80233c4:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    z1 <<= CONST_BITS;
 80233c8:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80233cc:	035b      	lsls	r3, r3, #13
 80233ce:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = (INT32) wsptr[6];
 80233d2:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80233d6:	3318      	adds	r3, #24
 80233d8:	681b      	ldr	r3, [r3, #0]
 80233da:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z2 <<= CONST_BITS;
 80233de:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80233e2:	035b      	lsls	r3, r3, #13
 80233e4:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp12 = z1 - z2;
 80233e8:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80233ec:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80233f0:	1ad3      	subs	r3, r2, r3
 80233f2:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp21 = z3 + tmp12;
 80233f6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80233fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80233fe:	4413      	add	r3, r2
 8023400:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp24 = z3 - tmp12;
 8023404:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8023408:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802340c:	1ad3      	subs	r3, r2, r3
 802340e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

    tmp12 = z4 + z2;
 8023412:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8023416:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802341a:	4413      	add	r3, r2
 802341c:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp20 = tmp10 + tmp12;
 8023420:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8023424:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023428:	4413      	add	r3, r2
 802342a:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp25 = tmp10 - tmp12;
 802342e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8023432:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023436:	1ad3      	subs	r3, r2, r3
 8023438:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

    tmp12 = z4 - z1 - z2;
 802343c:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8023440:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8023444:	1ad2      	subs	r2, r2, r3
 8023446:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802344a:	1ad3      	subs	r3, r2, r3
 802344c:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp22 = tmp11 + tmp12;
 8023450:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8023454:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023458:	4413      	add	r3, r2
 802345a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp23 = tmp11 - tmp12;
 802345e:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8023462:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023466:	1ad3      	subs	r3, r2, r3
 8023468:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802346c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023470:	3304      	adds	r3, #4
 8023472:	681b      	ldr	r3, [r3, #0]
 8023474:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = (INT32) wsptr[3];
 8023478:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802347c:	330c      	adds	r3, #12
 802347e:	681b      	ldr	r3, [r3, #0]
 8023480:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = (INT32) wsptr[5];
 8023484:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023488:	3314      	adds	r3, #20
 802348a:	681b      	ldr	r3, [r3, #0]
 802348c:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    z4 = (INT32) wsptr[7];
 8023490:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023494:	331c      	adds	r3, #28
 8023496:	681b      	ldr	r3, [r3, #0]
 8023498:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 802349c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80234a0:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 80234a4:	fb02 f303 	mul.w	r3, r2, r3
 80234a8:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 80234ac:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80234b0:	4ab8      	ldr	r2, [pc, #736]	@ (8023794 <jpeg_idct_12x12+0x928>)
 80234b2:	fb02 f303 	mul.w	r3, r2, r3
 80234b6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    tmp10 = z1 + z3;
 80234ba:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80234be:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80234c2:	4413      	add	r3, r2
 80234c4:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 80234c8:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80234cc:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 80234d0:	4413      	add	r3, r2
 80234d2:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 80234d6:	fb02 f303 	mul.w	r3, r2, r3
 80234da:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 80234de:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80234e2:	f640 025b 	movw	r2, #2139	@ 0x85b
 80234e6:	fb02 f303 	mul.w	r3, r2, r3
 80234ea:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 80234ee:	4413      	add	r3, r2
 80234f0:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 80234f4:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80234f8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 80234fc:	18d1      	adds	r1, r2, r3
 80234fe:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8023502:	4613      	mov	r3, r2
 8023504:	00db      	lsls	r3, r3, #3
 8023506:	4413      	add	r3, r2
 8023508:	021a      	lsls	r2, r3, #8
 802350a:	1ad3      	subs	r3, r2, r3
 802350c:	440b      	add	r3, r1
 802350e:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8023512:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8023516:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802351a:	4413      	add	r3, r2
 802351c:	4a9e      	ldr	r2, [pc, #632]	@ (8023798 <jpeg_idct_12x12+0x92c>)
 802351e:	fb02 f303 	mul.w	r3, r2, r3
 8023522:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8023526:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 802352a:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802352e:	441a      	add	r2, r3
 8023530:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 8023534:	4999      	ldr	r1, [pc, #612]	@ (802379c <jpeg_idct_12x12+0x930>)
 8023536:	fb01 f303 	mul.w	r3, r1, r3
 802353a:	4413      	add	r3, r2
 802353c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8023540:	4413      	add	r3, r2
 8023542:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8023546:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 802354a:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802354e:	1ad2      	subs	r2, r2, r3
 8023550:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023554:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 8023558:	fb01 f303 	mul.w	r3, r1, r3
 802355c:	4413      	add	r3, r2
 802355e:	f8d7 2190 	ldr.w	r2, [r7, #400]	@ 0x190
 8023562:	4413      	add	r3, r2
 8023564:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8023568:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802356c:	4a8c      	ldr	r2, [pc, #560]	@ (80237a0 <jpeg_idct_12x12+0x934>)
 802356e:	fb03 f202 	mul.w	r2, r3, r2
 8023572:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8023576:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8023578:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802357c:	4989      	ldr	r1, [pc, #548]	@ (80237a4 <jpeg_idct_12x12+0x938>)
 802357e:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8023582:	4413      	add	r3, r2
 8023584:	f8d7 2194 	ldr.w	r2, [r7, #404]	@ 0x194
 8023588:	4413      	add	r3, r2
 802358a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194

    z1 -= z4;
 802358e:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8023592:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 8023596:	1ad3      	subs	r3, r2, r3
 8023598:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 -= z3;
 802359c:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80235a0:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 80235a4:	1ad3      	subs	r3, r2, r3
 80235a6:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 80235aa:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 80235ae:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80235b2:	4413      	add	r3, r2
 80235b4:	f241 1251 	movw	r2, #4433	@ 0x1151
 80235b8:	fb02 f303 	mul.w	r3, r2, r3
 80235bc:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 80235c0:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 80235c4:	f641 027e 	movw	r2, #6270	@ 0x187e
 80235c8:	fb02 f303 	mul.w	r3, r2, r3
 80235cc:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80235d0:	4413      	add	r3, r2
 80235d2:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 80235d6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 80235da:	4a73      	ldr	r2, [pc, #460]	@ (80237a8 <jpeg_idct_12x12+0x93c>)
 80235dc:	fb02 f303 	mul.w	r3, r2, r3
 80235e0:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 80235e4:	4413      	add	r3, r2
 80235e6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80235ea:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 80235ee:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 80235f2:	4413      	add	r3, r2
 80235f4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80235f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80235fa:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80235fe:	4413      	add	r3, r2
 8023600:	781a      	ldrb	r2, [r3, #0]
 8023602:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023606:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8023608:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 802360c:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 8023610:	1ad3      	subs	r3, r2, r3
 8023612:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023614:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8023618:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802361c:	441a      	add	r2, r3
 802361e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023622:	330b      	adds	r3, #11
 8023624:	7812      	ldrb	r2, [r2, #0]
 8023626:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8023628:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 802362c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023630:	4413      	add	r3, r2
 8023632:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023634:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8023638:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802363c:	441a      	add	r2, r3
 802363e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023642:	3301      	adds	r3, #1
 8023644:	7812      	ldrb	r2, [r2, #0]
 8023646:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8023648:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 802364c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8023650:	1ad3      	subs	r3, r2, r3
 8023652:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023654:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8023658:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802365c:	441a      	add	r2, r3
 802365e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023662:	330a      	adds	r3, #10
 8023664:	7812      	ldrb	r2, [r2, #0]
 8023666:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8023668:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 802366c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023670:	4413      	add	r3, r2
 8023672:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023674:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8023678:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802367c:	441a      	add	r2, r3
 802367e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023682:	3302      	adds	r3, #2
 8023684:	7812      	ldrb	r2, [r2, #0]
 8023686:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8023688:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 802368c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023690:	1ad3      	subs	r3, r2, r3
 8023692:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023694:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8023698:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802369c:	441a      	add	r2, r3
 802369e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80236a2:	3309      	adds	r3, #9
 80236a4:	7812      	ldrb	r2, [r2, #0]
 80236a6:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80236a8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80236ac:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80236b0:	4413      	add	r3, r2
 80236b2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80236b4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80236b8:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80236bc:	441a      	add	r2, r3
 80236be:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80236c2:	3303      	adds	r3, #3
 80236c4:	7812      	ldrb	r2, [r2, #0]
 80236c6:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80236c8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 80236cc:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 80236d0:	1ad3      	subs	r3, r2, r3
 80236d2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80236d4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80236d8:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80236dc:	441a      	add	r2, r3
 80236de:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80236e2:	3308      	adds	r3, #8
 80236e4:	7812      	ldrb	r2, [r2, #0]
 80236e6:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80236e8:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 80236ec:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 80236f0:	4413      	add	r3, r2
 80236f2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80236f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80236f8:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80236fc:	441a      	add	r2, r3
 80236fe:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023702:	3304      	adds	r3, #4
 8023704:	7812      	ldrb	r2, [r2, #0]
 8023706:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8023708:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 802370c:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8023710:	1ad3      	subs	r3, r2, r3
 8023712:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023714:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8023718:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802371c:	441a      	add	r2, r3
 802371e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023722:	3307      	adds	r3, #7
 8023724:	7812      	ldrb	r2, [r2, #0]
 8023726:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8023728:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802372c:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8023730:	4413      	add	r3, r2
 8023732:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023734:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8023738:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802373c:	441a      	add	r2, r3
 802373e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023742:	3305      	adds	r3, #5
 8023744:	7812      	ldrb	r2, [r2, #0]
 8023746:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8023748:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802374c:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 8023750:	1ad3      	subs	r3, r2, r3
 8023752:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8023754:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8023758:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802375c:	441a      	add	r2, r3
 802375e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8023762:	3306      	adds	r3, #6
 8023764:	7812      	ldrb	r2, [r2, #0]
 8023766:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8023768:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802376c:	3320      	adds	r3, #32
 802376e:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 8023772:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023776:	3301      	adds	r3, #1
 8023778:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
 802377c:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023780:	2b0b      	cmp	r3, #11
 8023782:	f77f addd 	ble.w	8023340 <jpeg_idct_12x12+0x4d4>
  }
}
 8023786:	bf00      	nop
 8023788:	bf00      	nop
 802378a:	f507 77f4 	add.w	r7, r7, #488	@ 0x1e8
 802378e:	46bd      	mov	sp, r7
 8023790:	bc90      	pop	{r4, r7}
 8023792:	4770      	bx	lr
 8023794:	ffffeeaf 	.word	0xffffeeaf
 8023798:	ffffde8b 	.word	0xffffde8b
 802379c:	ffffd0b0 	.word	0xffffd0b0
 80237a0:	ffffea5c 	.word	0xffffea5c
 80237a4:	ffffc08c 	.word	0xffffc08c
 80237a8:	ffffc4df 	.word	0xffffc4df

080237ac <jpeg_idct_13x13>:

GLOBAL(void)
jpeg_idct_13x13 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80237ac:	b490      	push	{r4, r7}
 80237ae:	f5ad 7d04 	sub.w	sp, sp, #528	@ 0x210
 80237b2:	af00      	add	r7, sp, #0
 80237b4:	f507 7404 	add.w	r4, r7, #528	@ 0x210
 80237b8:	f5a4 7401 	sub.w	r4, r4, #516	@ 0x204
 80237bc:	6020      	str	r0, [r4, #0]
 80237be:	f507 7004 	add.w	r0, r7, #528	@ 0x210
 80237c2:	f5a0 7002 	sub.w	r0, r0, #520	@ 0x208
 80237c6:	6001      	str	r1, [r0, #0]
 80237c8:	f507 7104 	add.w	r1, r7, #528	@ 0x210
 80237cc:	f5a1 7103 	sub.w	r1, r1, #524	@ 0x20c
 80237d0:	600a      	str	r2, [r1, #0]
 80237d2:	f507 7204 	add.w	r2, r7, #528	@ 0x210
 80237d6:	f5a2 7204 	sub.w	r2, r2, #528	@ 0x210
 80237da:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80237dc:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 80237e0:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 80237e4:	681b      	ldr	r3, [r3, #0]
 80237e6:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80237ea:	3380      	adds	r3, #128	@ 0x80
 80237ec:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
  int workspace[8*13];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80237f0:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 80237f4:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 80237f8:	681b      	ldr	r3, [r3, #0]
 80237fa:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80237fe:	f507 7304 	add.w	r3, r7, #528	@ 0x210
 8023802:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
 8023806:	681b      	ldr	r3, [r3, #0]
 8023808:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802380a:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
  wsptr = workspace;
 802380e:	f107 0314 	add.w	r3, r7, #20
 8023812:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8023816:	2300      	movs	r3, #0
 8023818:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 802381c:	e299      	b.n	8023d52 <jpeg_idct_13x13+0x5a6>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802381e:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023822:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023826:	461a      	mov	r2, r3
 8023828:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802382c:	681b      	ldr	r3, [r3, #0]
 802382e:	fb02 f303 	mul.w	r3, r2, r3
 8023832:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z1 <<= CONST_BITS;
 8023836:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802383a:	035b      	lsls	r3, r3, #13
 802383c:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8023840:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023844:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8023848:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802384c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023850:	3320      	adds	r3, #32
 8023852:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023856:	461a      	mov	r2, r3
 8023858:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802385c:	3340      	adds	r3, #64	@ 0x40
 802385e:	681b      	ldr	r3, [r3, #0]
 8023860:	fb02 f303 	mul.w	r3, r2, r3
 8023864:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8023868:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802386c:	3340      	adds	r3, #64	@ 0x40
 802386e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023872:	461a      	mov	r2, r3
 8023874:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023878:	3380      	adds	r3, #128	@ 0x80
 802387a:	681b      	ldr	r3, [r3, #0]
 802387c:	fb02 f303 	mul.w	r3, r2, r3
 8023880:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8023884:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023888:	3360      	adds	r3, #96	@ 0x60
 802388a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802388e:	461a      	mov	r2, r3
 8023890:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023894:	33c0      	adds	r3, #192	@ 0xc0
 8023896:	681b      	ldr	r3, [r3, #0]
 8023898:	fb02 f303 	mul.w	r3, r2, r3
 802389c:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp10 = z3 + z4;
 80238a0:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80238a4:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80238a8:	4413      	add	r3, r2
 80238aa:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp11 = z3 - z4;
 80238ae:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80238b2:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80238b6:	1ad3      	subs	r3, r2, r3
 80238b8:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 80238bc:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 80238c0:	f242 42f9 	movw	r2, #9465	@ 0x24f9
 80238c4:	fb02 f303 	mul.w	r3, r2, r3
 80238c8:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 80238cc:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 80238d0:	f240 3219 	movw	r2, #793	@ 0x319
 80238d4:	fb02 f303 	mul.w	r3, r2, r3
 80238d8:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 80238dc:	4413      	add	r3, r2
 80238de:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 80238e2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80238e6:	f642 32f1 	movw	r2, #11249	@ 0x2bf1
 80238ea:	fb03 f202 	mul.w	r2, r3, r2
 80238ee:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80238f2:	4413      	add	r3, r2
 80238f4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 80238f8:	4413      	add	r3, r2
 80238fa:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 80238fe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023902:	f241 020c 	movw	r2, #4108	@ 0x100c
 8023906:	fb03 f202 	mul.w	r2, r3, r2
 802390a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802390e:	1ad3      	subs	r3, r2, r3
 8023910:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023914:	4413      	add	r3, r2
 8023916:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 802391a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802391e:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
 8023922:	fb02 f303 	mul.w	r3, r2, r3
 8023926:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 802392a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802392e:	f640 7295 	movw	r2, #3989	@ 0xf95
 8023932:	fb02 f303 	mul.w	r3, r2, r3
 8023936:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802393a:	4413      	add	r3, r2
 802393c:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 8023940:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023944:	f242 12e0 	movw	r2, #8672	@ 0x21e0
 8023948:	fb03 f202 	mul.w	r2, r3, r2
 802394c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023950:	1ad3      	subs	r3, r2, r3
 8023952:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023956:	4413      	add	r3, r2
 8023958:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 802395c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023960:	4af0      	ldr	r2, [pc, #960]	@ (8023d24 <jpeg_idct_13x13+0x578>)
 8023962:	fb03 f202 	mul.w	r2, r3, r2
 8023966:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802396a:	4413      	add	r3, r2
 802396c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023970:	4413      	add	r3, r2
 8023972:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 8023976:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 802397a:	f640 52f2 	movw	r2, #3570	@ 0xdf2
 802397e:	fb02 f303 	mul.w	r3, r2, r3
 8023982:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 8023986:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802398a:	f641 52fe 	movw	r2, #7678	@ 0x1dfe
 802398e:	fb03 f202 	mul.w	r2, r3, r2
 8023992:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023996:	1ad3      	subs	r3, r2, r3
 8023998:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 802399c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80239a0:	4ae1      	ldr	r2, [pc, #900]	@ (8023d28 <jpeg_idct_13x13+0x57c>)
 80239a2:	fb03 f202 	mul.w	r2, r3, r2
 80239a6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80239aa:	1ad2      	subs	r2, r2, r3
 80239ac:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80239b0:	1ad3      	subs	r3, r2, r3
 80239b2:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 80239b6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80239ba:	4adc      	ldr	r2, [pc, #880]	@ (8023d2c <jpeg_idct_13x13+0x580>)
 80239bc:	fb03 f202 	mul.w	r2, r3, r2
 80239c0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 80239c4:	441a      	add	r2, r3
 80239c6:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80239ca:	1ad3      	subs	r3, r2, r3
 80239cc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 80239d0:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80239d4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80239d8:	1ad3      	subs	r3, r2, r3
 80239da:	f642 5241 	movw	r2, #11585	@ 0x2d41
 80239de:	fb02 f303 	mul.w	r3, r2, r3
 80239e2:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 80239e6:	4413      	add	r3, r2
 80239e8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80239ec:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80239f0:	3310      	adds	r3, #16
 80239f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80239f6:	461a      	mov	r2, r3
 80239f8:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80239fc:	3320      	adds	r3, #32
 80239fe:	681b      	ldr	r3, [r3, #0]
 8023a00:	fb02 f303 	mul.w	r3, r2, r3
 8023a04:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8023a08:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023a0c:	3330      	adds	r3, #48	@ 0x30
 8023a0e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023a12:	461a      	mov	r2, r3
 8023a14:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023a18:	3360      	adds	r3, #96	@ 0x60
 8023a1a:	681b      	ldr	r3, [r3, #0]
 8023a1c:	fb02 f303 	mul.w	r3, r2, r3
 8023a20:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8023a24:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023a28:	3350      	adds	r3, #80	@ 0x50
 8023a2a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023a2e:	461a      	mov	r2, r3
 8023a30:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023a34:	33a0      	adds	r3, #160	@ 0xa0
 8023a36:	681b      	ldr	r3, [r3, #0]
 8023a38:	fb02 f303 	mul.w	r3, r2, r3
 8023a3c:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8023a40:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023a44:	3370      	adds	r3, #112	@ 0x70
 8023a46:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023a4a:	461a      	mov	r2, r3
 8023a4c:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023a50:	33e0      	adds	r3, #224	@ 0xe0
 8023a52:	681b      	ldr	r3, [r3, #0]
 8023a54:	fb02 f303 	mul.w	r3, r2, r3
 8023a58:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 8023a5c:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023a60:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023a64:	4413      	add	r3, r2
 8023a66:	f642 2250 	movw	r2, #10832	@ 0x2a50
 8023a6a:	fb02 f303 	mul.w	r3, r2, r3
 8023a6e:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 8023a72:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023a76:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023a7a:	4413      	add	r3, r2
 8023a7c:	f242 523e 	movw	r2, #9534	@ 0x253e
 8023a80:	fb02 f303 	mul.w	r3, r2, r3
 8023a84:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp15 = z1 + z4;
 8023a88:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023a8c:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023a90:	4413      	add	r3, r2
 8023a92:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 8023a96:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023a9a:	f641 6202 	movw	r2, #7682	@ 0x1e02
 8023a9e:	fb02 f303 	mul.w	r3, r2, r3
 8023aa2:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 8023aa6:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023aaa:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023aae:	441a      	add	r2, r3
 8023ab0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023ab4:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 8023ab6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023aba:	499d      	ldr	r1, [pc, #628]	@ (8023d30 <jpeg_idct_13x13+0x584>)
 8023abc:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 8023ac0:	4413      	add	r3, r2
 8023ac2:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 8023ac6:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8023aca:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023ace:	4413      	add	r3, r2
 8023ad0:	4a98      	ldr	r2, [pc, #608]	@ (8023d34 <jpeg_idct_13x13+0x588>)
 8023ad2:	fb02 f303 	mul.w	r3, r2, r3
 8023ad6:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 8023ada:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023ade:	f641 22cb 	movw	r2, #6859	@ 0x1acb
 8023ae2:	fb03 f202 	mul.w	r2, r3, r2
 8023ae6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023aea:	4413      	add	r3, r2
 8023aec:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023af0:	4413      	add	r3, r2
 8023af2:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 8023af6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023afa:	4a8f      	ldr	r2, [pc, #572]	@ (8023d38 <jpeg_idct_13x13+0x58c>)
 8023afc:	fb03 f202 	mul.w	r2, r3, r2
 8023b00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023b04:	4413      	add	r3, r2
 8023b06:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8023b0a:	4413      	add	r3, r2
 8023b0c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 8023b10:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8023b14:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023b18:	4413      	add	r3, r2
 8023b1a:	4a88      	ldr	r2, [pc, #544]	@ (8023d3c <jpeg_idct_13x13+0x590>)
 8023b1c:	fb02 f303 	mul.w	r3, r2, r3
 8023b20:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14;
 8023b24:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023b28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023b2c:	4413      	add	r3, r2
 8023b2e:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 8023b32:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023b36:	f244 6294 	movw	r2, #18068	@ 0x4694
 8023b3a:	fb03 f202 	mul.w	r2, r3, r2
 8023b3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023b42:	4413      	add	r3, r2
 8023b44:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023b48:	4413      	add	r3, r2
 8023b4a:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 8023b4e:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8023b52:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023b56:	4413      	add	r3, r2
 8023b58:	4a79      	ldr	r2, [pc, #484]	@ (8023d40 <jpeg_idct_13x13+0x594>)
 8023b5a:	fb02 f303 	mul.w	r3, r2, r3
 8023b5e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp12 += tmp14;
 8023b62:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8023b66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023b6a:	4413      	add	r3, r2
 8023b6c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 += tmp14;
 8023b70:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023b74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023b78:	4413      	add	r3, r2
 8023b7a:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 8023b7e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023b82:	f640 22d5 	movw	r2, #2773	@ 0xad5
 8023b86:	fb02 f303 	mul.w	r3, r2, r3
 8023b8a:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 8023b8e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023b92:	f640 2233 	movw	r2, #2611	@ 0xa33
 8023b96:	fb03 f202 	mul.w	r2, r3, r2
 8023b9a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023b9e:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 8023ba0:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023ba4:	4967      	ldr	r1, [pc, #412]	@ (8023d44 <jpeg_idct_13x13+0x598>)
 8023ba6:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 8023baa:	4413      	add	r3, r2
 8023bac:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 8023bb0:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8023bb4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023bb8:	1ad3      	subs	r3, r2, r3
 8023bba:	f641 6202 	movw	r2, #7682	@ 0x1e02
 8023bbe:	fb02 f303 	mul.w	r3, r2, r3
 8023bc2:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += z1;
 8023bc6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8023bca:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023bce:	4413      	add	r3, r2
 8023bd0:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 8023bd4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023bd8:	f640 424e 	movw	r2, #3150	@ 0xc4e
 8023bdc:	fb03 f202 	mul.w	r2, r3, r2
 8023be0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023be4:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 8023be6:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023bea:	f46f 515f 	mvn.w	r1, #14272	@ 0x37c0
 8023bee:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 8023bf2:	4413      	add	r3, r2
 8023bf4:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8023bf8:	4413      	add	r3, r2
 8023bfa:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8023bfe:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8023c02:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023c06:	4413      	add	r3, r2
 8023c08:	12da      	asrs	r2, r3, #11
 8023c0a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c0e:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8023c10:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8023c14:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023c18:	1ad2      	subs	r2, r2, r3
 8023c1a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c1e:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8023c22:	12d2      	asrs	r2, r2, #11
 8023c24:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8023c26:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8023c2a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023c2e:	441a      	add	r2, r3
 8023c30:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c34:	3320      	adds	r3, #32
 8023c36:	12d2      	asrs	r2, r2, #11
 8023c38:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8023c3a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8023c3e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023c42:	1ad2      	subs	r2, r2, r3
 8023c44:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c48:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8023c4c:	12d2      	asrs	r2, r2, #11
 8023c4e:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8023c50:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8023c54:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023c58:	441a      	add	r2, r3
 8023c5a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c5e:	3340      	adds	r3, #64	@ 0x40
 8023c60:	12d2      	asrs	r2, r2, #11
 8023c62:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8023c64:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8023c68:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023c6c:	1ad2      	subs	r2, r2, r3
 8023c6e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c72:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8023c76:	12d2      	asrs	r2, r2, #11
 8023c78:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8023c7a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8023c7e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023c82:	441a      	add	r2, r3
 8023c84:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c88:	3360      	adds	r3, #96	@ 0x60
 8023c8a:	12d2      	asrs	r2, r2, #11
 8023c8c:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8023c8e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8023c92:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023c96:	1ad2      	subs	r2, r2, r3
 8023c98:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023c9c:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8023ca0:	12d2      	asrs	r2, r2, #11
 8023ca2:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8023ca4:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8023ca8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023cac:	441a      	add	r2, r3
 8023cae:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023cb2:	3380      	adds	r3, #128	@ 0x80
 8023cb4:	12d2      	asrs	r2, r2, #11
 8023cb6:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8023cb8:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8023cbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023cc0:	1ad2      	subs	r2, r2, r3
 8023cc2:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023cc6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8023cca:	12d2      	asrs	r2, r2, #11
 8023ccc:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8023cce:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8023cd2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023cd6:	441a      	add	r2, r3
 8023cd8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023cdc:	33a0      	adds	r3, #160	@ 0xa0
 8023cde:	12d2      	asrs	r2, r2, #11
 8023ce0:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8023ce2:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8023ce6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023cea:	1ad2      	subs	r2, r2, r3
 8023cec:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023cf0:	33e0      	adds	r3, #224	@ 0xe0
 8023cf2:	12d2      	asrs	r2, r2, #11
 8023cf4:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26, CONST_BITS-PASS1_BITS);
 8023cf6:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023cfa:	33c0      	adds	r3, #192	@ 0xc0
 8023cfc:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8023d00:	12d2      	asrs	r2, r2, #11
 8023d02:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8023d04:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8023d08:	3301      	adds	r3, #1
 8023d0a:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 8023d0e:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8023d12:	3302      	adds	r3, #2
 8023d14:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
 8023d18:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8023d1c:	3304      	adds	r3, #4
 8023d1e:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
 8023d22:	e011      	b.n	8023d48 <jpeg_idct_13x13+0x59c>
 8023d24:	ffffd7ee 	.word	0xffffd7ee
 8023d28:	fffffa8c 	.word	0xfffffa8c
 8023d2c:	ffffe64b 	.word	0xffffe64b
 8023d30:	ffffbf5b 	.word	0xffffbf5b
 8023d34:	fffff52b 	.word	0xfffff52b
 8023d38:	ffffcdb1 	.word	0xffffcdb1
 8023d3c:	ffffdac2 	.word	0xffffdac2
 8023d40:	ffffeaf8 	.word	0xffffeaf8
 8023d44:	fffff116 	.word	0xfffff116
 8023d48:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023d4c:	3304      	adds	r3, #4
 8023d4e:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
 8023d52:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8023d56:	2b07      	cmp	r3, #7
 8023d58:	f77f ad61 	ble.w	802381e <jpeg_idct_13x13+0x72>
  }

  /* Pass 2: process 13 rows from work array, store into output array. */

  wsptr = workspace;
 8023d5c:	f107 0314 	add.w	r3, r7, #20
 8023d60:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 8023d64:	2300      	movs	r3, #0
 8023d66:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 8023d6a:	e2a4      	b.n	80242b6 <jpeg_idct_13x13+0xb0a>
    outptr = output_buf[ctr] + output_col;
 8023d6c:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8023d70:	009b      	lsls	r3, r3, #2
 8023d72:	f507 7204 	add.w	r2, r7, #528	@ 0x210
 8023d76:	f5a2 7204 	sub.w	r2, r2, #528	@ 0x210
 8023d7a:	6812      	ldr	r2, [r2, #0]
 8023d7c:	4413      	add	r3, r2
 8023d7e:	681a      	ldr	r2, [r3, #0]
 8023d80:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8023d84:	4413      	add	r3, r2
 8023d86:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8023d8a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023d8e:	681b      	ldr	r3, [r3, #0]
 8023d90:	3310      	adds	r3, #16
 8023d92:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z1 <<= CONST_BITS;
 8023d96:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023d9a:	035b      	lsls	r3, r3, #13
 8023d9c:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    z2 = (INT32) wsptr[2];
 8023da0:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023da4:	3308      	adds	r3, #8
 8023da6:	681b      	ldr	r3, [r3, #0]
 8023da8:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = (INT32) wsptr[4];
 8023dac:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023db0:	3310      	adds	r3, #16
 8023db2:	681b      	ldr	r3, [r3, #0]
 8023db4:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = (INT32) wsptr[6];
 8023db8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023dbc:	3318      	adds	r3, #24
 8023dbe:	681b      	ldr	r3, [r3, #0]
 8023dc0:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp10 = z3 + z4;
 8023dc4:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8023dc8:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023dcc:	4413      	add	r3, r2
 8023dce:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp11 = z3 - z4;
 8023dd2:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8023dd6:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023dda:	1ad3      	subs	r3, r2, r3
 8023ddc:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 8023de0:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023de4:	f242 42f9 	movw	r2, #9465	@ 0x24f9
 8023de8:	fb02 f303 	mul.w	r3, r2, r3
 8023dec:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 8023df0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023df4:	f240 3219 	movw	r2, #793	@ 0x319
 8023df8:	fb02 f303 	mul.w	r3, r2, r3
 8023dfc:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023e00:	4413      	add	r3, r2
 8023e02:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 8023e06:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023e0a:	f642 32f1 	movw	r2, #11249	@ 0x2bf1
 8023e0e:	fb03 f202 	mul.w	r2, r3, r2
 8023e12:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023e16:	4413      	add	r3, r2
 8023e18:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023e1c:	4413      	add	r3, r2
 8023e1e:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 8023e22:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023e26:	f241 020c 	movw	r2, #4108	@ 0x100c
 8023e2a:	fb03 f202 	mul.w	r2, r3, r2
 8023e2e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023e32:	1ad3      	subs	r3, r2, r3
 8023e34:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023e38:	4413      	add	r3, r2
 8023e3a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 8023e3e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023e42:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
 8023e46:	fb02 f303 	mul.w	r3, r2, r3
 8023e4a:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 8023e4e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023e52:	f640 7295 	movw	r2, #3989	@ 0xf95
 8023e56:	fb02 f303 	mul.w	r3, r2, r3
 8023e5a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023e5e:	4413      	add	r3, r2
 8023e60:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 8023e64:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023e68:	f242 12e0 	movw	r2, #8672	@ 0x21e0
 8023e6c:	fb03 f202 	mul.w	r2, r3, r2
 8023e70:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023e74:	1ad3      	subs	r3, r2, r3
 8023e76:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023e7a:	4413      	add	r3, r2
 8023e7c:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 8023e80:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023e84:	4af2      	ldr	r2, [pc, #968]	@ (8024250 <jpeg_idct_13x13+0xaa4>)
 8023e86:	fb03 f202 	mul.w	r2, r3, r2
 8023e8a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023e8e:	4413      	add	r3, r2
 8023e90:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8023e94:	4413      	add	r3, r2
 8023e96:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 8023e9a:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8023e9e:	f640 52f2 	movw	r2, #3570	@ 0xdf2
 8023ea2:	fb02 f303 	mul.w	r3, r2, r3
 8023ea6:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 8023eaa:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8023eae:	f641 52fe 	movw	r2, #7678	@ 0x1dfe
 8023eb2:	fb03 f202 	mul.w	r2, r3, r2
 8023eb6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023eba:	1ad3      	subs	r3, r2, r3
 8023ebc:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 8023ec0:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023ec4:	4ae3      	ldr	r2, [pc, #908]	@ (8024254 <jpeg_idct_13x13+0xaa8>)
 8023ec6:	fb03 f202 	mul.w	r2, r3, r2
 8023eca:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023ece:	1ad2      	subs	r2, r2, r3
 8023ed0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023ed4:	1ad3      	subs	r3, r2, r3
 8023ed6:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 8023eda:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023ede:	4ade      	ldr	r2, [pc, #888]	@ (8024258 <jpeg_idct_13x13+0xaac>)
 8023ee0:	fb03 f202 	mul.w	r2, r3, r2
 8023ee4:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023ee8:	441a      	add	r2, r3
 8023eea:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023eee:	1ad3      	subs	r3, r2, r3
 8023ef0:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 8023ef4:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023ef8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023efc:	1ad3      	subs	r3, r2, r3
 8023efe:	f642 5241 	movw	r2, #11585	@ 0x2d41
 8023f02:	fb02 f303 	mul.w	r3, r2, r3
 8023f06:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023f0a:	4413      	add	r3, r2
 8023f0c:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8023f10:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023f14:	3304      	adds	r3, #4
 8023f16:	681b      	ldr	r3, [r3, #0]
 8023f18:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    z2 = (INT32) wsptr[3];
 8023f1c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023f20:	330c      	adds	r3, #12
 8023f22:	681b      	ldr	r3, [r3, #0]
 8023f24:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    z3 = (INT32) wsptr[5];
 8023f28:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023f2c:	3314      	adds	r3, #20
 8023f2e:	681b      	ldr	r3, [r3, #0]
 8023f30:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    z4 = (INT32) wsptr[7];
 8023f34:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8023f38:	331c      	adds	r3, #28
 8023f3a:	681b      	ldr	r3, [r3, #0]
 8023f3c:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 8023f40:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023f44:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023f48:	4413      	add	r3, r2
 8023f4a:	f642 2250 	movw	r2, #10832	@ 0x2a50
 8023f4e:	fb02 f303 	mul.w	r3, r2, r3
 8023f52:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 8023f56:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023f5a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023f5e:	4413      	add	r3, r2
 8023f60:	f242 523e 	movw	r2, #9534	@ 0x253e
 8023f64:	fb02 f303 	mul.w	r3, r2, r3
 8023f68:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp15 = z1 + z4;
 8023f6c:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8023f70:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023f74:	4413      	add	r3, r2
 8023f76:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 8023f7a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8023f7e:	f641 6202 	movw	r2, #7682	@ 0x1e02
 8023f82:	fb02 f303 	mul.w	r3, r2, r3
 8023f86:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 8023f8a:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023f8e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8023f92:	441a      	add	r2, r3
 8023f94:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8023f98:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 8023f9a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8023f9e:	49af      	ldr	r1, [pc, #700]	@ (802425c <jpeg_idct_13x13+0xab0>)
 8023fa0:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 8023fa4:	4413      	add	r3, r2
 8023fa6:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 8023faa:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8023fae:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023fb2:	4413      	add	r3, r2
 8023fb4:	4aaa      	ldr	r2, [pc, #680]	@ (8024260 <jpeg_idct_13x13+0xab4>)
 8023fb6:	fb02 f303 	mul.w	r3, r2, r3
 8023fba:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 8023fbe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8023fc2:	f641 22cb 	movw	r2, #6859	@ 0x1acb
 8023fc6:	fb03 f202 	mul.w	r2, r3, r2
 8023fca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023fce:	4413      	add	r3, r2
 8023fd0:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8023fd4:	4413      	add	r3, r2
 8023fd6:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 8023fda:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8023fde:	4aa1      	ldr	r2, [pc, #644]	@ (8024264 <jpeg_idct_13x13+0xab8>)
 8023fe0:	fb03 f202 	mul.w	r2, r3, r2
 8023fe4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8023fe8:	4413      	add	r3, r2
 8023fea:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8023fee:	4413      	add	r3, r2
 8023ff0:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 8023ff4:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8023ff8:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8023ffc:	4413      	add	r3, r2
 8023ffe:	4a9a      	ldr	r2, [pc, #616]	@ (8024268 <jpeg_idct_13x13+0xabc>)
 8024000:	fb02 f303 	mul.w	r3, r2, r3
 8024004:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += tmp14;
 8024008:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 802400c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8024010:	4413      	add	r3, r2
 8024012:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 8024016:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802401a:	f244 6294 	movw	r2, #18068	@ 0x4694
 802401e:	fb03 f202 	mul.w	r2, r3, r2
 8024022:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8024026:	4413      	add	r3, r2
 8024028:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802402c:	4413      	add	r3, r2
 802402e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 8024032:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8024036:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802403a:	4413      	add	r3, r2
 802403c:	4a8b      	ldr	r2, [pc, #556]	@ (802426c <jpeg_idct_13x13+0xac0>)
 802403e:	fb02 f303 	mul.w	r3, r2, r3
 8024042:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp12 += tmp14;
 8024046:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 802404a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802404e:	4413      	add	r3, r2
 8024050:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp13 += tmp14;
 8024054:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8024058:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802405c:	4413      	add	r3, r2
 802405e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 8024062:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8024066:	f640 22d5 	movw	r2, #2773	@ 0xad5
 802406a:	fb02 f303 	mul.w	r3, r2, r3
 802406e:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 8024072:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024076:	f640 2233 	movw	r2, #2611	@ 0xa33
 802407a:	fb03 f202 	mul.w	r2, r3, r2
 802407e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8024082:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 8024084:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8024088:	4979      	ldr	r1, [pc, #484]	@ (8024270 <jpeg_idct_13x13+0xac4>)
 802408a:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 802408e:	4413      	add	r3, r2
 8024090:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 8024094:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8024098:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802409c:	1ad3      	subs	r3, r2, r3
 802409e:	f641 6202 	movw	r2, #7682	@ 0x1e02
 80240a2:	fb02 f303 	mul.w	r3, r2, r3
 80240a6:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += z1;
 80240aa:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 80240ae:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80240b2:	4413      	add	r3, r2
 80240b4:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 80240b8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80240bc:	f640 424e 	movw	r2, #3150	@ 0xc4e
 80240c0:	fb03 f202 	mul.w	r2, r3, r2
 80240c4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80240c8:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 80240ca:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 80240ce:	f46f 515f 	mvn.w	r1, #14272	@ 0x37c0
 80240d2:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 80240d6:	4413      	add	r3, r2
 80240d8:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 80240dc:	4413      	add	r3, r2
 80240de:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80240e2:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 80240e6:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 80240ea:	4413      	add	r3, r2
 80240ec:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80240ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80240f2:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80240f6:	4413      	add	r3, r2
 80240f8:	781a      	ldrb	r2, [r3, #0]
 80240fa:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80240fe:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8024100:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8024104:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 8024108:	1ad3      	subs	r3, r2, r3
 802410a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802410c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8024110:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024114:	441a      	add	r2, r3
 8024116:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802411a:	330c      	adds	r3, #12
 802411c:	7812      	ldrb	r2, [r2, #0]
 802411e:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8024120:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8024124:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8024128:	4413      	add	r3, r2
 802412a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802412c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8024130:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024134:	441a      	add	r2, r3
 8024136:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802413a:	3301      	adds	r3, #1
 802413c:	7812      	ldrb	r2, [r2, #0]
 802413e:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8024140:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8024144:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 8024148:	1ad3      	subs	r3, r2, r3
 802414a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802414c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8024150:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024154:	441a      	add	r2, r3
 8024156:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802415a:	330b      	adds	r3, #11
 802415c:	7812      	ldrb	r2, [r2, #0]
 802415e:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8024160:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8024164:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8024168:	4413      	add	r3, r2
 802416a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802416c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8024170:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024174:	441a      	add	r2, r3
 8024176:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802417a:	3302      	adds	r3, #2
 802417c:	7812      	ldrb	r2, [r2, #0]
 802417e:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8024180:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8024184:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 8024188:	1ad3      	subs	r3, r2, r3
 802418a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802418c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8024190:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024194:	441a      	add	r2, r3
 8024196:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802419a:	330a      	adds	r3, #10
 802419c:	7812      	ldrb	r2, [r2, #0]
 802419e:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80241a0:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80241a4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80241a8:	4413      	add	r3, r2
 80241aa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80241ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80241b0:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80241b4:	441a      	add	r2, r3
 80241b6:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80241ba:	3303      	adds	r3, #3
 80241bc:	7812      	ldrb	r2, [r2, #0]
 80241be:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80241c0:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 80241c4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 80241c8:	1ad3      	subs	r3, r2, r3
 80241ca:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80241cc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80241d0:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80241d4:	441a      	add	r2, r3
 80241d6:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80241da:	3309      	adds	r3, #9
 80241dc:	7812      	ldrb	r2, [r2, #0]
 80241de:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80241e0:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 80241e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 80241e8:	4413      	add	r3, r2
 80241ea:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80241ec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80241f0:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80241f4:	441a      	add	r2, r3
 80241f6:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80241fa:	3304      	adds	r3, #4
 80241fc:	7812      	ldrb	r2, [r2, #0]
 80241fe:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8024200:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8024204:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8024208:	1ad3      	subs	r3, r2, r3
 802420a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802420c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8024210:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024214:	441a      	add	r2, r3
 8024216:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802421a:	3308      	adds	r3, #8
 802421c:	7812      	ldrb	r2, [r2, #0]
 802421e:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8024220:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8024224:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8024228:	4413      	add	r3, r2
 802422a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802422c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8024230:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024234:	441a      	add	r2, r3
 8024236:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802423a:	3305      	adds	r3, #5
 802423c:	7812      	ldrb	r2, [r2, #0]
 802423e:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8024240:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8024244:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8024248:	1ad3      	subs	r3, r2, r3
 802424a:	149b      	asrs	r3, r3, #18
 802424c:	e012      	b.n	8024274 <jpeg_idct_13x13+0xac8>
 802424e:	bf00      	nop
 8024250:	ffffd7ee 	.word	0xffffd7ee
 8024254:	fffffa8c 	.word	0xfffffa8c
 8024258:	ffffe64b 	.word	0xffffe64b
 802425c:	ffffbf5b 	.word	0xffffbf5b
 8024260:	fffff52b 	.word	0xfffff52b
 8024264:	ffffcdb1 	.word	0xffffcdb1
 8024268:	ffffdac2 	.word	0xffffdac2
 802426c:	ffffeaf8 	.word	0xffffeaf8
 8024270:	fffff116 	.word	0xfffff116
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024274:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8024278:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802427c:	441a      	add	r2, r3
 802427e:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8024282:	3307      	adds	r3, #7
 8024284:	7812      	ldrb	r2, [r2, #0]
 8024286:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 8024288:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802428c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802428e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 8024292:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024296:	441a      	add	r2, r3
 8024298:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802429c:	3306      	adds	r3, #6
 802429e:	7812      	ldrb	r2, [r2, #0]
 80242a0:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80242a2:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80242a6:	3320      	adds	r3, #32
 80242a8:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 80242ac:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 80242b0:	3301      	adds	r3, #1
 80242b2:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
 80242b6:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 80242ba:	2b0c      	cmp	r3, #12
 80242bc:	f77f ad56 	ble.w	8023d6c <jpeg_idct_13x13+0x5c0>
  }
}
 80242c0:	bf00      	nop
 80242c2:	bf00      	nop
 80242c4:	f507 7704 	add.w	r7, r7, #528	@ 0x210
 80242c8:	46bd      	mov	sp, r7
 80242ca:	bc90      	pop	{r4, r7}
 80242cc:	4770      	bx	lr
 80242ce:	bf00      	nop

080242d0 <jpeg_idct_14x14>:

GLOBAL(void)
jpeg_idct_14x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80242d0:	b490      	push	{r4, r7}
 80242d2:	f5ad 7d0c 	sub.w	sp, sp, #560	@ 0x230
 80242d6:	af00      	add	r7, sp, #0
 80242d8:	f507 740c 	add.w	r4, r7, #560	@ 0x230
 80242dc:	f5a4 7409 	sub.w	r4, r4, #548	@ 0x224
 80242e0:	6020      	str	r0, [r4, #0]
 80242e2:	f507 700c 	add.w	r0, r7, #560	@ 0x230
 80242e6:	f5a0 700a 	sub.w	r0, r0, #552	@ 0x228
 80242ea:	6001      	str	r1, [r0, #0]
 80242ec:	f507 710c 	add.w	r1, r7, #560	@ 0x230
 80242f0:	f5a1 710b 	sub.w	r1, r1, #556	@ 0x22c
 80242f4:	600a      	str	r2, [r1, #0]
 80242f6:	f507 720c 	add.w	r2, r7, #560	@ 0x230
 80242fa:	f5a2 720c 	sub.w	r2, r2, #560	@ 0x230
 80242fe:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8024300:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8024304:	f5a3 7309 	sub.w	r3, r3, #548	@ 0x224
 8024308:	681b      	ldr	r3, [r3, #0]
 802430a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802430e:	3380      	adds	r3, #128	@ 0x80
 8024310:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
  int workspace[8*14];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8024314:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8024318:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 802431c:	681b      	ldr	r3, [r3, #0]
 802431e:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024322:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8024326:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 802432a:	681b      	ldr	r3, [r3, #0]
 802432c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802432e:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
  wsptr = workspace;
 8024332:	f107 0310 	add.w	r3, r7, #16
 8024336:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802433a:	2300      	movs	r3, #0
 802433c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 8024340:	e278      	b.n	8024834 <jpeg_idct_14x14+0x564>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024342:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024346:	f9b3 3000 	ldrsh.w	r3, [r3]
 802434a:	461a      	mov	r2, r3
 802434c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024350:	681b      	ldr	r3, [r3, #0]
 8024352:	fb02 f303 	mul.w	r3, r2, r3
 8024356:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z1 <<= CONST_BITS;
 802435a:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802435e:	035b      	lsls	r3, r3, #13
 8024360:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8024364:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024368:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802436c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8024370:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024374:	3340      	adds	r3, #64	@ 0x40
 8024376:	f9b3 3000 	ldrsh.w	r3, [r3]
 802437a:	461a      	mov	r2, r3
 802437c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024380:	3380      	adds	r3, #128	@ 0x80
 8024382:	681b      	ldr	r3, [r3, #0]
 8024384:	fb02 f303 	mul.w	r3, r2, r3
 8024388:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 802438c:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024390:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8024394:	fb02 f303 	mul.w	r3, r2, r3
 8024398:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 802439c:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80243a0:	f640 2212 	movw	r2, #2578	@ 0xa12
 80243a4:	fb02 f303 	mul.w	r3, r2, r3
 80243a8:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80243ac:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80243b0:	f641 4237 	movw	r2, #7223	@ 0x1c37
 80243b4:	fb02 f303 	mul.w	r3, r2, r3
 80243b8:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = z1 + z2;
 80243bc:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80243c0:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80243c4:	4413      	add	r3, r2
 80243c6:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp11 = z1 + z3;
 80243ca:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80243ce:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80243d2:	4413      	add	r3, r2
 80243d4:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = z1 - z4;
 80243d8:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80243dc:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80243e0:	1ad3      	subs	r3, r2, r3
 80243e2:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 80243e6:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80243ea:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80243ee:	441a      	add	r2, r3
 80243f0:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80243f4:	1ad3      	subs	r3, r2, r3
 80243f6:	005b      	lsls	r3, r3, #1
 80243f8:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80243fc:	1ad3      	subs	r3, r2, r3
 80243fe:	12db      	asrs	r3, r3, #11
 8024400:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8024404:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024408:	3320      	adds	r3, #32
 802440a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802440e:	461a      	mov	r2, r3
 8024410:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024414:	3340      	adds	r3, #64	@ 0x40
 8024416:	681b      	ldr	r3, [r3, #0]
 8024418:	fb02 f303 	mul.w	r3, r2, r3
 802441c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8024420:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024424:	3360      	adds	r3, #96	@ 0x60
 8024426:	f9b3 3000 	ldrsh.w	r3, [r3]
 802442a:	461a      	mov	r2, r3
 802442c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024430:	33c0      	adds	r3, #192	@ 0xc0
 8024432:	681b      	ldr	r3, [r3, #0]
 8024434:	fb02 f303 	mul.w	r3, r2, r3
 8024438:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 802443c:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024440:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024444:	4413      	add	r3, r2
 8024446:	f242 3262 	movw	r2, #9058	@ 0x2362
 802444a:	fb02 f303 	mul.w	r3, r2, r3
 802444e:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8024452:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024456:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 802445a:	fb02 f303 	mul.w	r3, r2, r3
 802445e:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024462:	4413      	add	r3, r2
 8024464:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8024468:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802446c:	4aea      	ldr	r2, [pc, #936]	@ (8024818 <jpeg_idct_14x14+0x548>)
 802446e:	fb02 f303 	mul.w	r3, r2, r3
 8024472:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024476:	4413      	add	r3, r2
 8024478:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 802447c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024480:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8024484:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 8024488:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802448c:	49e3      	ldr	r1, [pc, #908]	@ (802481c <jpeg_idct_14x14+0x54c>)
 802448e:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8024492:	4413      	add	r3, r2
 8024494:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp20 = tmp10 + tmp13;
 8024498:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802449c:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80244a0:	4413      	add	r3, r2
 80244a2:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
    tmp26 = tmp10 - tmp13;
 80244a6:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80244aa:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80244ae:	1ad3      	subs	r3, r2, r3
 80244b0:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp21 = tmp11 + tmp14;
 80244b4:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80244b8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80244bc:	4413      	add	r3, r2
 80244be:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp25 = tmp11 - tmp14;
 80244c2:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80244c6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80244ca:	1ad3      	subs	r3, r2, r3
 80244cc:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp22 = tmp12 + tmp15;
 80244d0:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80244d4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80244d8:	4413      	add	r3, r2
 80244da:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp24 = tmp12 - tmp15;
 80244de:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80244e2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80244e6:	1ad3      	subs	r3, r2, r3
 80244e8:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80244ec:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80244f0:	3310      	adds	r3, #16
 80244f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80244f6:	461a      	mov	r2, r3
 80244f8:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80244fc:	3320      	adds	r3, #32
 80244fe:	681b      	ldr	r3, [r3, #0]
 8024500:	fb02 f303 	mul.w	r3, r2, r3
 8024504:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8024508:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802450c:	3330      	adds	r3, #48	@ 0x30
 802450e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024512:	461a      	mov	r2, r3
 8024514:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024518:	3360      	adds	r3, #96	@ 0x60
 802451a:	681b      	ldr	r3, [r3, #0]
 802451c:	fb02 f303 	mul.w	r3, r2, r3
 8024520:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8024524:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024528:	3350      	adds	r3, #80	@ 0x50
 802452a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802452e:	461a      	mov	r2, r3
 8024530:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024534:	33a0      	adds	r3, #160	@ 0xa0
 8024536:	681b      	ldr	r3, [r3, #0]
 8024538:	fb02 f303 	mul.w	r3, r2, r3
 802453c:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8024540:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024544:	3370      	adds	r3, #112	@ 0x70
 8024546:	f9b3 3000 	ldrsh.w	r3, [r3]
 802454a:	461a      	mov	r2, r3
 802454c:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024550:	33e0      	adds	r3, #224	@ 0xe0
 8024552:	681b      	ldr	r3, [r3, #0]
 8024554:	fb02 f303 	mul.w	r3, r2, r3
 8024558:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp13 = z4 << CONST_BITS;
 802455c:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024560:	035b      	lsls	r3, r3, #13
 8024562:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    tmp14 = z1 + z3;
 8024566:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802456a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 802456e:	4413      	add	r3, r2
 8024570:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8024574:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024578:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802457c:	4413      	add	r3, r2
 802457e:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8024582:	fb02 f303 	mul.w	r3, r2, r3
 8024586:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 802458a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802458e:	f242 6252 	movw	r2, #9810	@ 0x2652
 8024592:	fb02 f303 	mul.w	r3, r2, r3
 8024596:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 802459a:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 802459e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80245a2:	441a      	add	r2, r3
 80245a4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80245a8:	441a      	add	r2, r3
 80245aa:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80245ae:	499c      	ldr	r1, [pc, #624]	@ (8024820 <jpeg_idct_14x14+0x550>)
 80245b0:	fb01 f303 	mul.w	r3, r1, r3
 80245b4:	4413      	add	r3, r2
 80245b6:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80245ba:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80245be:	f641 0214 	movw	r2, #6164	@ 0x1814
 80245c2:	fb02 f303 	mul.w	r3, r2, r3
 80245c6:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80245ca:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80245ce:	4a95      	ldr	r2, [pc, #596]	@ (8024824 <jpeg_idct_14x14+0x554>)
 80245d0:	fb02 f303 	mul.w	r3, r2, r3
 80245d4:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 80245d8:	4413      	add	r3, r2
 80245da:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    -= z2;
 80245de:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80245e2:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80245e6:	1ad3      	subs	r3, r2, r3
 80245e8:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 80245ec:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 80245f0:	f640 62f2 	movw	r2, #3826	@ 0xef2
 80245f4:	fb03 f202 	mul.w	r2, r3, r2
 80245f8:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80245fc:	1ad3      	subs	r3, r2, r3
 80245fe:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    tmp16 += tmp15;
 8024602:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8024606:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802460a:	4413      	add	r3, r2
 802460c:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    += z4;
 8024610:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024614:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024618:	4413      	add	r3, r2
 802461a:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 802461e:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8024622:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024626:	4413      	add	r3, r2
 8024628:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 802462c:	fb03 f202 	mul.w	r2, r3, r2
 8024630:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024634:	1ad3      	subs	r3, r2, r3
 8024636:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 802463a:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802463e:	4a7a      	ldr	r2, [pc, #488]	@ (8024828 <jpeg_idct_14x14+0x558>)
 8024640:	fb03 f202 	mul.w	r2, r3, r2
 8024644:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024648:	4413      	add	r3, r2
 802464a:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 802464e:	4413      	add	r3, r2
 8024650:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 8024654:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024658:	4a74      	ldr	r2, [pc, #464]	@ (802482c <jpeg_idct_14x14+0x55c>)
 802465a:	fb03 f202 	mul.w	r2, r3, r2
 802465e:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024662:	4413      	add	r3, r2
 8024664:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024668:	4413      	add	r3, r2
 802466a:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 802466e:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024672:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024676:	1ad3      	subs	r3, r2, r3
 8024678:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 802467c:	fb02 f303 	mul.w	r3, r2, r3
 8024680:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8024684:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8024688:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802468c:	441a      	add	r2, r3
 802468e:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024692:	4967      	ldr	r1, [pc, #412]	@ (8024830 <jpeg_idct_14x14+0x560>)
 8024694:	fb01 f303 	mul.w	r3, r1, r3
 8024698:	4413      	add	r3, r2
 802469a:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 802469e:	4413      	add	r3, r2
 80246a0:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 80246a4:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80246a8:	f241 5299 	movw	r2, #5529	@ 0x1599
 80246ac:	fb03 f202 	mul.w	r2, r3, r2
 80246b0:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80246b4:	4413      	add	r3, r2
 80246b6:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 80246ba:	4413      	add	r3, r2
 80246bc:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp13 = (z1 - z3) << PASS1_BITS;
 80246c0:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80246c4:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80246c8:	1ad3      	subs	r3, r2, r3
 80246ca:	009b      	lsls	r3, r3, #2
 80246cc:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80246d0:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 80246d4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80246d8:	4413      	add	r3, r2
 80246da:	12da      	asrs	r2, r3, #11
 80246dc:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80246e0:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80246e2:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 80246e6:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 80246ea:	1ad2      	subs	r2, r2, r3
 80246ec:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80246f0:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 80246f4:	12d2      	asrs	r2, r2, #11
 80246f6:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80246f8:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 80246fc:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8024700:	441a      	add	r2, r3
 8024702:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024706:	3320      	adds	r3, #32
 8024708:	12d2      	asrs	r2, r2, #11
 802470a:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802470c:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8024710:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8024714:	1ad2      	subs	r2, r2, r3
 8024716:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802471a:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 802471e:	12d2      	asrs	r2, r2, #11
 8024720:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8024722:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8024726:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802472a:	441a      	add	r2, r3
 802472c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024730:	3340      	adds	r3, #64	@ 0x40
 8024732:	12d2      	asrs	r2, r2, #11
 8024734:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8024736:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802473a:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802473e:	1ad2      	subs	r2, r2, r3
 8024740:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024744:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8024748:	12d2      	asrs	r2, r2, #11
 802474a:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) (tmp23 + tmp13);
 802474c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024750:	3360      	adds	r3, #96	@ 0x60
 8024752:	f8d7 11f8 	ldr.w	r1, [r7, #504]	@ 0x1f8
 8024756:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802475a:	440a      	add	r2, r1
 802475c:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) (tmp23 - tmp13);
 802475e:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024762:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8024766:	f8d7 11f8 	ldr.w	r1, [r7, #504]	@ 0x1f8
 802476a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 802476e:	1a8a      	subs	r2, r1, r2
 8024770:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8024772:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8024776:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802477a:	441a      	add	r2, r3
 802477c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024780:	3380      	adds	r3, #128	@ 0x80
 8024782:	12d2      	asrs	r2, r2, #11
 8024784:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8024786:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802478a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802478e:	1ad2      	subs	r2, r2, r3
 8024790:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024794:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8024798:	12d2      	asrs	r2, r2, #11
 802479a:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 802479c:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80247a0:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80247a4:	441a      	add	r2, r3
 80247a6:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80247aa:	33a0      	adds	r3, #160	@ 0xa0
 80247ac:	12d2      	asrs	r2, r2, #11
 80247ae:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 80247b0:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 80247b4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80247b8:	1ad2      	subs	r2, r2, r3
 80247ba:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80247be:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80247c2:	12d2      	asrs	r2, r2, #11
 80247c4:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 80247c6:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 80247ca:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80247ce:	441a      	add	r2, r3
 80247d0:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80247d4:	33c0      	adds	r3, #192	@ 0xc0
 80247d6:	12d2      	asrs	r2, r2, #11
 80247d8:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 80247da:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 80247de:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 80247e2:	1ad2      	subs	r2, r2, r3
 80247e4:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80247e8:	33e0      	adds	r3, #224	@ 0xe0
 80247ea:	12d2      	asrs	r2, r2, #11
 80247ec:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80247ee:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 80247f2:	3301      	adds	r3, #1
 80247f4:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 80247f8:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80247fc:	3302      	adds	r3, #2
 80247fe:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 8024802:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024806:	3304      	adds	r3, #4
 8024808:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
 802480c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024810:	3304      	adds	r3, #4
 8024812:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
 8024816:	e00d      	b.n	8024834 <jpeg_idct_14x14+0x564>
 8024818:	ffffc8fc 	.word	0xffffc8fc
 802481c:	ffffd3e1 	.word	0xffffd3e1
 8024820:	ffffdbf0 	.word	0xffffdbf0
 8024824:	ffffde0b 	.word	0xffffde0b
 8024828:	fffff26e 	.word	0xfffff26e
 802482c:	ffffb409 	.word	0xffffb409
 8024830:	ffffc9e6 	.word	0xffffc9e6
 8024834:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8024838:	2b07      	cmp	r3, #7
 802483a:	f77f ad82 	ble.w	8024342 <jpeg_idct_14x14+0x72>
  }

  /* Pass 2: process 14 rows from work array, store into output array. */

  wsptr = workspace;
 802483e:	f107 0310 	add.w	r3, r7, #16
 8024842:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 8024846:	2300      	movs	r3, #0
 8024848:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 802484c:	e284      	b.n	8024d58 <jpeg_idct_14x14+0xa88>
    outptr = output_buf[ctr] + output_col;
 802484e:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8024852:	009b      	lsls	r3, r3, #2
 8024854:	f507 720c 	add.w	r2, r7, #560	@ 0x230
 8024858:	f5a2 720c 	sub.w	r2, r2, #560	@ 0x230
 802485c:	6812      	ldr	r2, [r2, #0]
 802485e:	4413      	add	r3, r2
 8024860:	681a      	ldr	r2, [r3, #0]
 8024862:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8024866:	4413      	add	r3, r2
 8024868:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802486c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024870:	681b      	ldr	r3, [r3, #0]
 8024872:	3310      	adds	r3, #16
 8024874:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z1 <<= CONST_BITS;
 8024878:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802487c:	035b      	lsls	r3, r3, #13
 802487e:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z4 = (INT32) wsptr[4];
 8024882:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024886:	3310      	adds	r3, #16
 8024888:	681b      	ldr	r3, [r3, #0]
 802488a:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 802488e:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024892:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8024896:	fb02 f303 	mul.w	r3, r2, r3
 802489a:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 802489e:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80248a2:	f640 2212 	movw	r2, #2578	@ 0xa12
 80248a6:	fb02 f303 	mul.w	r3, r2, r3
 80248aa:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80248ae:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80248b2:	f641 4237 	movw	r2, #7223	@ 0x1c37
 80248b6:	fb02 f303 	mul.w	r3, r2, r3
 80248ba:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = z1 + z2;
 80248be:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80248c2:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 80248c6:	4413      	add	r3, r2
 80248c8:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp11 = z1 + z3;
 80248cc:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80248d0:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80248d4:	4413      	add	r3, r2
 80248d6:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = z1 - z4;
 80248da:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80248de:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80248e2:	1ad3      	subs	r3, r2, r3
 80248e4:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 80248e8:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80248ec:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 80248f0:	441a      	add	r2, r3
 80248f2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 80248f6:	1ad3      	subs	r3, r2, r3
 80248f8:	005b      	lsls	r3, r3, #1
 80248fa:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80248fe:	1ad3      	subs	r3, r2, r3
 8024900:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    z1 = (INT32) wsptr[2];
 8024904:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024908:	3308      	adds	r3, #8
 802490a:	681b      	ldr	r3, [r3, #0]
 802490c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = (INT32) wsptr[6];
 8024910:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024914:	3318      	adds	r3, #24
 8024916:	681b      	ldr	r3, [r3, #0]
 8024918:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 802491c:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024920:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024924:	4413      	add	r3, r2
 8024926:	f242 3262 	movw	r2, #9058	@ 0x2362
 802492a:	fb02 f303 	mul.w	r3, r2, r3
 802492e:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8024932:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024936:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 802493a:	fb02 f303 	mul.w	r3, r2, r3
 802493e:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024942:	4413      	add	r3, r2
 8024944:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8024948:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802494c:	4af1      	ldr	r2, [pc, #964]	@ (8024d14 <jpeg_idct_14x14+0xa44>)
 802494e:	fb02 f303 	mul.w	r3, r2, r3
 8024952:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024956:	4413      	add	r3, r2
 8024958:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 802495c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024960:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8024964:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 8024968:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 802496c:	49ea      	ldr	r1, [pc, #936]	@ (8024d18 <jpeg_idct_14x14+0xa48>)
 802496e:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8024972:	4413      	add	r3, r2
 8024974:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp20 = tmp10 + tmp13;
 8024978:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802497c:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024980:	4413      	add	r3, r2
 8024982:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
    tmp26 = tmp10 - tmp13;
 8024986:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802498a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802498e:	1ad3      	subs	r3, r2, r3
 8024990:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    tmp21 = tmp11 + tmp14;
 8024994:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8024998:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 802499c:	4413      	add	r3, r2
 802499e:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    tmp25 = tmp11 - tmp14;
 80249a2:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80249a6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 80249aa:	1ad3      	subs	r3, r2, r3
 80249ac:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp22 = tmp12 + tmp15;
 80249b0:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80249b4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80249b8:	4413      	add	r3, r2
 80249ba:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp24 = tmp12 - tmp15;
 80249be:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80249c2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 80249c6:	1ad3      	subs	r3, r2, r3
 80249c8:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80249cc:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80249d0:	3304      	adds	r3, #4
 80249d2:	681b      	ldr	r3, [r3, #0]
 80249d4:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    z2 = (INT32) wsptr[3];
 80249d8:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80249dc:	330c      	adds	r3, #12
 80249de:	681b      	ldr	r3, [r3, #0]
 80249e0:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    z3 = (INT32) wsptr[5];
 80249e4:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80249e8:	3314      	adds	r3, #20
 80249ea:	681b      	ldr	r3, [r3, #0]
 80249ec:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    z4 = (INT32) wsptr[7];
 80249f0:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80249f4:	331c      	adds	r3, #28
 80249f6:	681b      	ldr	r3, [r3, #0]
 80249f8:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
    z4 <<= CONST_BITS;
 80249fc:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024a00:	035b      	lsls	r3, r3, #13
 8024a02:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp14 = z1 + z3;
 8024a06:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024a0a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024a0e:	4413      	add	r3, r2
 8024a10:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8024a14:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024a18:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024a1c:	4413      	add	r3, r2
 8024a1e:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8024a22:	fb02 f303 	mul.w	r3, r2, r3
 8024a26:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 8024a2a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8024a2e:	f242 6252 	movw	r2, #9810	@ 0x2652
 8024a32:	fb02 f303 	mul.w	r3, r2, r3
 8024a36:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 8024a3a:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8024a3e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8024a42:	441a      	add	r2, r3
 8024a44:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024a48:	441a      	add	r2, r3
 8024a4a:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024a4e:	49b3      	ldr	r1, [pc, #716]	@ (8024d1c <jpeg_idct_14x14+0xa4c>)
 8024a50:	fb01 f303 	mul.w	r3, r1, r3
 8024a54:	4413      	add	r3, r2
 8024a56:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 8024a5a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8024a5e:	f641 0214 	movw	r2, #6164	@ 0x1814
 8024a62:	fb02 f303 	mul.w	r3, r2, r3
 8024a66:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 8024a6a:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024a6e:	4aac      	ldr	r2, [pc, #688]	@ (8024d20 <jpeg_idct_14x14+0xa50>)
 8024a70:	fb02 f303 	mul.w	r3, r2, r3
 8024a74:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8024a78:	4413      	add	r3, r2
 8024a7a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z1    -= z2;
 8024a7e:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024a82:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024a86:	1ad3      	subs	r3, r2, r3
 8024a88:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 8024a8c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8024a90:	f640 62f2 	movw	r2, #3826	@ 0xef2
 8024a94:	fb03 f202 	mul.w	r2, r3, r2
 8024a98:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024a9c:	1ad3      	subs	r3, r2, r3
 8024a9e:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
    tmp16 += tmp15;
 8024aa2:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8024aa6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8024aaa:	4413      	add	r3, r2
 8024aac:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 8024ab0:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 8024ab4:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024ab8:	4413      	add	r3, r2
 8024aba:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 8024abe:	fb03 f202 	mul.w	r2, r3, r2
 8024ac2:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024ac6:	1ad3      	subs	r3, r2, r3
 8024ac8:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 8024acc:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024ad0:	4a94      	ldr	r2, [pc, #592]	@ (8024d24 <jpeg_idct_14x14+0xa54>)
 8024ad2:	fb03 f202 	mul.w	r2, r3, r2
 8024ad6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024ada:	4413      	add	r3, r2
 8024adc:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 8024ae0:	4413      	add	r3, r2
 8024ae2:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 8024ae6:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024aea:	4a8f      	ldr	r2, [pc, #572]	@ (8024d28 <jpeg_idct_14x14+0xa58>)
 8024aec:	fb03 f202 	mul.w	r2, r3, r2
 8024af0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024af4:	4413      	add	r3, r2
 8024af6:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8024afa:	4413      	add	r3, r2
 8024afc:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8024b00:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8024b04:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024b08:	1ad3      	subs	r3, r2, r3
 8024b0a:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 8024b0e:	fb02 f303 	mul.w	r3, r2, r3
 8024b12:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8024b16:	f8d7 21f4 	ldr.w	r2, [r7, #500]	@ 0x1f4
 8024b1a:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8024b1e:	441a      	add	r2, r3
 8024b20:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024b24:	4981      	ldr	r1, [pc, #516]	@ (8024d2c <jpeg_idct_14x14+0xa5c>)
 8024b26:	fb01 f303 	mul.w	r3, r1, r3
 8024b2a:	4413      	add	r3, r2
 8024b2c:	f8d7 21f0 	ldr.w	r2, [r7, #496]	@ 0x1f0
 8024b30:	4413      	add	r3, r2
 8024b32:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 8024b36:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
 8024b3a:	f241 5299 	movw	r2, #5529	@ 0x1599
 8024b3e:	fb03 f202 	mul.w	r2, r3, r2
 8024b42:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024b46:	4413      	add	r3, r2
 8024b48:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8024b4c:	4413      	add	r3, r2
 8024b4e:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 8024b52:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8024b56:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
 8024b5a:	1ad3      	subs	r3, r2, r3
 8024b5c:	035b      	lsls	r3, r3, #13
 8024b5e:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8024b62:	4413      	add	r3, r2
 8024b64:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8024b68:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 8024b6c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8024b70:	4413      	add	r3, r2
 8024b72:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b74:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8024b78:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024b7c:	4413      	add	r3, r2
 8024b7e:	781a      	ldrb	r2, [r3, #0]
 8024b80:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024b84:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8024b86:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 8024b8a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
 8024b8e:	1ad3      	subs	r3, r2, r3
 8024b90:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024b92:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8024b96:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024b9a:	441a      	add	r2, r3
 8024b9c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024ba0:	330d      	adds	r3, #13
 8024ba2:	7812      	ldrb	r2, [r2, #0]
 8024ba4:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8024ba6:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8024baa:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8024bae:	4413      	add	r3, r2
 8024bb0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024bb2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8024bb6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024bba:	441a      	add	r2, r3
 8024bbc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024bc0:	3301      	adds	r3, #1
 8024bc2:	7812      	ldrb	r2, [r2, #0]
 8024bc4:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8024bc6:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8024bca:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8024bce:	1ad3      	subs	r3, r2, r3
 8024bd0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024bd2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8024bd6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024bda:	441a      	add	r2, r3
 8024bdc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024be0:	330c      	adds	r3, #12
 8024be2:	7812      	ldrb	r2, [r2, #0]
 8024be4:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8024be6:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8024bea:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8024bee:	4413      	add	r3, r2
 8024bf0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024bf2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8024bf6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024bfa:	441a      	add	r2, r3
 8024bfc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024c00:	3302      	adds	r3, #2
 8024c02:	7812      	ldrb	r2, [r2, #0]
 8024c04:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8024c06:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8024c0a:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8024c0e:	1ad3      	subs	r3, r2, r3
 8024c10:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c12:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8024c16:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024c1a:	441a      	add	r2, r3
 8024c1c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024c20:	330b      	adds	r3, #11
 8024c22:	7812      	ldrb	r2, [r2, #0]
 8024c24:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8024c26:	f8d7 21f8 	ldr.w	r2, [r7, #504]	@ 0x1f8
 8024c2a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024c2e:	4413      	add	r3, r2
 8024c30:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c32:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8024c36:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024c3a:	441a      	add	r2, r3
 8024c3c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024c40:	3303      	adds	r3, #3
 8024c42:	7812      	ldrb	r2, [r2, #0]
 8024c44:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8024c46:	f8d7 21f8 	ldr.w	r2, [r7, #504]	@ 0x1f8
 8024c4a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8024c4e:	1ad3      	subs	r3, r2, r3
 8024c50:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c52:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8024c56:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024c5a:	441a      	add	r2, r3
 8024c5c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024c60:	330a      	adds	r3, #10
 8024c62:	7812      	ldrb	r2, [r2, #0]
 8024c64:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8024c66:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8024c6a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8024c6e:	4413      	add	r3, r2
 8024c70:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c72:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8024c76:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024c7a:	441a      	add	r2, r3
 8024c7c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024c80:	3304      	adds	r3, #4
 8024c82:	7812      	ldrb	r2, [r2, #0]
 8024c84:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8024c86:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8024c8a:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8024c8e:	1ad3      	subs	r3, r2, r3
 8024c90:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024c92:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8024c96:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024c9a:	441a      	add	r2, r3
 8024c9c:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024ca0:	3309      	adds	r3, #9
 8024ca2:	7812      	ldrb	r2, [r2, #0]
 8024ca4:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8024ca6:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8024caa:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8024cae:	4413      	add	r3, r2
 8024cb0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cb2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8024cb6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024cba:	441a      	add	r2, r3
 8024cbc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024cc0:	3305      	adds	r3, #5
 8024cc2:	7812      	ldrb	r2, [r2, #0]
 8024cc4:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8024cc6:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 8024cca:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8024cce:	1ad3      	subs	r3, r2, r3
 8024cd0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cd2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8024cd6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024cda:	441a      	add	r2, r3
 8024cdc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024ce0:	3308      	adds	r3, #8
 8024ce2:	7812      	ldrb	r2, [r2, #0]
 8024ce4:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8024ce6:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8024cea:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8024cee:	4413      	add	r3, r2
 8024cf0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024cf2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8024cf6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024cfa:	441a      	add	r2, r3
 8024cfc:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024d00:	3306      	adds	r3, #6
 8024d02:	7812      	ldrb	r2, [r2, #0]
 8024d04:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8024d06:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8024d0a:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8024d0e:	1ad3      	subs	r3, r2, r3
 8024d10:	149b      	asrs	r3, r3, #18
 8024d12:	e00d      	b.n	8024d30 <jpeg_idct_14x14+0xa60>
 8024d14:	ffffc8fc 	.word	0xffffc8fc
 8024d18:	ffffd3e1 	.word	0xffffd3e1
 8024d1c:	ffffdbf0 	.word	0xffffdbf0
 8024d20:	ffffde0b 	.word	0xffffde0b
 8024d24:	fffff26e 	.word	0xfffff26e
 8024d28:	ffffb409 	.word	0xffffb409
 8024d2c:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8024d30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8024d34:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8024d38:	441a      	add	r2, r3
 8024d3a:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8024d3e:	3307      	adds	r3, #7
 8024d40:	7812      	ldrb	r2, [r2, #0]
 8024d42:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8024d44:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8024d48:	3320      	adds	r3, #32
 8024d4a:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 8024d4e:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8024d52:	3301      	adds	r3, #1
 8024d54:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
 8024d58:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8024d5c:	2b0d      	cmp	r3, #13
 8024d5e:	f77f ad76 	ble.w	802484e <jpeg_idct_14x14+0x57e>
  }
}
 8024d62:	bf00      	nop
 8024d64:	bf00      	nop
 8024d66:	f507 770c 	add.w	r7, r7, #560	@ 0x230
 8024d6a:	46bd      	mov	sp, r7
 8024d6c:	bc90      	pop	{r4, r7}
 8024d6e:	4770      	bx	lr

08024d70 <jpeg_idct_15x15>:

GLOBAL(void)
jpeg_idct_15x15 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8024d70:	b490      	push	{r4, r7}
 8024d72:	f5ad 7d16 	sub.w	sp, sp, #600	@ 0x258
 8024d76:	af00      	add	r7, sp, #0
 8024d78:	f507 7416 	add.w	r4, r7, #600	@ 0x258
 8024d7c:	f5a4 7413 	sub.w	r4, r4, #588	@ 0x24c
 8024d80:	6020      	str	r0, [r4, #0]
 8024d82:	f507 7016 	add.w	r0, r7, #600	@ 0x258
 8024d86:	f5a0 7014 	sub.w	r0, r0, #592	@ 0x250
 8024d8a:	6001      	str	r1, [r0, #0]
 8024d8c:	f507 7116 	add.w	r1, r7, #600	@ 0x258
 8024d90:	f5a1 7115 	sub.w	r1, r1, #596	@ 0x254
 8024d94:	600a      	str	r2, [r1, #0]
 8024d96:	f507 7216 	add.w	r2, r7, #600	@ 0x258
 8024d9a:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 8024d9e:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8024da0:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 8024da4:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 8024da8:	681b      	ldr	r3, [r3, #0]
 8024daa:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8024dae:	3380      	adds	r3, #128	@ 0x80
 8024db0:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  int workspace[8*15];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8024db4:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 8024db8:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 8024dbc:	681b      	ldr	r3, [r3, #0]
 8024dbe:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024dc2:	f507 7316 	add.w	r3, r7, #600	@ 0x258
 8024dc6:	f5a3 7314 	sub.w	r3, r3, #592	@ 0x250
 8024dca:	681b      	ldr	r3, [r3, #0]
 8024dcc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8024dce:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
  wsptr = workspace;
 8024dd2:	f107 0314 	add.w	r3, r7, #20
 8024dd6:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8024dda:	2300      	movs	r3, #0
 8024ddc:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8024de0:	e28d      	b.n	80252fe <jpeg_idct_15x15+0x58e>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024de2:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8024de6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024dea:	461a      	mov	r2, r3
 8024dec:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8024df0:	681b      	ldr	r3, [r3, #0]
 8024df2:	fb02 f303 	mul.w	r3, r2, r3
 8024df6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1 <<= CONST_BITS;
 8024dfa:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8024dfe:	035b      	lsls	r3, r3, #13
 8024e00:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8024e04:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8024e08:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8024e0c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8024e10:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8024e14:	3320      	adds	r3, #32
 8024e16:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024e1a:	461a      	mov	r2, r3
 8024e1c:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8024e20:	3340      	adds	r3, #64	@ 0x40
 8024e22:	681b      	ldr	r3, [r3, #0]
 8024e24:	fb02 f303 	mul.w	r3, r2, r3
 8024e28:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8024e2c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8024e30:	3340      	adds	r3, #64	@ 0x40
 8024e32:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024e36:	461a      	mov	r2, r3
 8024e38:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8024e3c:	3380      	adds	r3, #128	@ 0x80
 8024e3e:	681b      	ldr	r3, [r3, #0]
 8024e40:	fb02 f303 	mul.w	r3, r2, r3
 8024e44:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8024e48:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8024e4c:	3360      	adds	r3, #96	@ 0x60
 8024e4e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024e52:	461a      	mov	r2, r3
 8024e54:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8024e58:	33c0      	adds	r3, #192	@ 0xc0
 8024e5a:	681b      	ldr	r3, [r3, #0]
 8024e5c:	fb02 f303 	mul.w	r3, r2, r3
 8024e60:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 8024e64:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024e68:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8024e6c:	fb02 f303 	mul.w	r3, r2, r3
 8024e70:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 8024e74:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024e78:	f242 429d 	movw	r2, #9373	@ 0x249d
 8024e7c:	fb02 f303 	mul.w	r3, r2, r3
 8024e80:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp12 = z1 - tmp10;
 8024e84:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8024e88:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024e8c:	1ad3      	subs	r3, r2, r3
 8024e8e:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp13 = z1 + tmp11;
 8024e92:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8024e96:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024e9a:	4413      	add	r3, r2
 8024e9c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 8024ea0:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8024ea4:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024ea8:	1ad3      	subs	r3, r2, r3
 8024eaa:	005b      	lsls	r3, r3, #1
 8024eac:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8024eb0:	1ad3      	subs	r3, r2, r3
 8024eb2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z4 = z2 - z3;
 8024eb6:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8024eba:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8024ebe:	1ad3      	subs	r3, r2, r3
 8024ec0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 += z2;
 8024ec4:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8024ec8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8024ecc:	4413      	add	r3, r2
 8024ece:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 8024ed2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8024ed6:	f642 22ce 	movw	r2, #10958	@ 0x2ace
 8024eda:	fb02 f303 	mul.w	r3, r2, r3
 8024ede:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 8024ee2:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024ee6:	f44f 72bb 	mov.w	r2, #374	@ 0x176
 8024eea:	fb02 f303 	mul.w	r3, r2, r3
 8024eee:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 8024ef2:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8024ef6:	f642 6213 	movw	r2, #11795	@ 0x2e13
 8024efa:	fb02 f303 	mul.w	r3, r2, r3
 8024efe:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 8024f02:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8024f06:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024f0a:	4413      	add	r3, r2
 8024f0c:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8024f10:	4413      	add	r3, r2
 8024f12:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 8024f16:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8024f1a:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024f1e:	1ad2      	subs	r2, r2, r3
 8024f20:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024f24:	4413      	add	r3, r2
 8024f26:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8024f2a:	4413      	add	r3, r2
 8024f2c:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 8024f30:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8024f34:	f241 1282 	movw	r2, #4482	@ 0x1182
 8024f38:	fb02 f303 	mul.w	r3, r2, r3
 8024f3c:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 8024f40:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024f44:	f640 42c7 	movw	r2, #3271	@ 0xcc7
 8024f48:	fb02 f303 	mul.w	r3, r2, r3
 8024f4c:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 8024f50:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8024f54:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024f58:	1ad2      	subs	r2, r2, r3
 8024f5a:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024f5e:	1ad3      	subs	r3, r2, r3
 8024f60:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 8024f64:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8024f68:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024f6c:	441a      	add	r2, r3
 8024f6e:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024f72:	1ad2      	subs	r2, r2, r3
 8024f74:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8024f78:	1ad3      	subs	r3, r2, r3
 8024f7a:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 8024f7e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8024f82:	f641 124c 	movw	r2, #6476	@ 0x194c
 8024f86:	fb02 f303 	mul.w	r3, r2, r3
 8024f8a:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 8024f8e:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8024f92:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 8024f96:	fb02 f303 	mul.w	r3, r2, r3
 8024f9a:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 8024f9e:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8024fa2:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024fa6:	4413      	add	r3, r2
 8024fa8:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8024fac:	4413      	add	r3, r2
 8024fae:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 8024fb2:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8024fb6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8024fba:	1ad3      	subs	r3, r2, r3
 8024fbc:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8024fc0:	4413      	add	r3, r2
 8024fc2:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    tmp11 += tmp11;
 8024fc6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024fca:	005b      	lsls	r3, r3, #1
 8024fcc:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 8024fd0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8024fd4:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024fd8:	4413      	add	r3, r2
 8024fda:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 8024fde:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8024fe2:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024fe6:	1ad2      	subs	r2, r2, r3
 8024fe8:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8024fec:	1ad3      	subs	r3, r2, r3
 8024fee:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8024ff2:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8024ff6:	3310      	adds	r3, #16
 8024ff8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024ffc:	461a      	mov	r2, r3
 8024ffe:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025002:	3320      	adds	r3, #32
 8025004:	681b      	ldr	r3, [r3, #0]
 8025006:	fb02 f303 	mul.w	r3, r2, r3
 802500a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802500e:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025012:	3330      	adds	r3, #48	@ 0x30
 8025014:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025018:	461a      	mov	r2, r3
 802501a:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802501e:	3360      	adds	r3, #96	@ 0x60
 8025020:	681b      	ldr	r3, [r3, #0]
 8025022:	fb02 f303 	mul.w	r3, r2, r3
 8025026:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802502a:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802502e:	3350      	adds	r3, #80	@ 0x50
 8025030:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025034:	461a      	mov	r2, r3
 8025036:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802503a:	33a0      	adds	r3, #160	@ 0xa0
 802503c:	681b      	ldr	r3, [r3, #0]
 802503e:	fb02 f303 	mul.w	r3, r2, r3
 8025042:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 8025046:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802504a:	f242 7231 	movw	r2, #10033	@ 0x2731
 802504e:	fb02 f303 	mul.w	r3, r2, r3
 8025052:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8025056:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802505a:	3370      	adds	r3, #112	@ 0x70
 802505c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025060:	461a      	mov	r2, r3
 8025062:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025066:	33e0      	adds	r3, #224	@ 0xe0
 8025068:	681b      	ldr	r3, [r3, #0]
 802506a:	fb02 f303 	mul.w	r3, r2, r3
 802506e:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp13 = z2 - z4;
 8025072:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025076:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802507a:	1ad3      	subs	r3, r2, r3
 802507c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 8025080:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025084:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8025088:	4413      	add	r3, r2
 802508a:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 802508e:	fb02 f303 	mul.w	r3, r2, r3
 8025092:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 8025096:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802509a:	f241 0271 	movw	r2, #4209	@ 0x1071
 802509e:	fb02 f303 	mul.w	r3, r2, r3
 80250a2:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80250a6:	4413      	add	r3, r2
 80250a8:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 80250ac:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 80250b0:	4a99      	ldr	r2, [pc, #612]	@ (8025318 <jpeg_idct_15x15+0x5a8>)
 80250b2:	fb02 f303 	mul.w	r3, r2, r3
 80250b6:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 80250ba:	4413      	add	r3, r2
 80250bc:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 80250c0:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80250c4:	4a95      	ldr	r2, [pc, #596]	@ (802531c <jpeg_idct_15x15+0x5ac>)
 80250c6:	fb02 f303 	mul.w	r3, r2, r3
 80250ca:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 80250ce:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80250d2:	4a93      	ldr	r2, [pc, #588]	@ (8025320 <jpeg_idct_15x15+0x5b0>)
 80250d4:	fb02 f303 	mul.w	r3, r2, r3
 80250d8:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z2 = z1 - z4;
 80250dc:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80250e0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80250e4:	1ad3      	subs	r3, r2, r3
 80250e6:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 80250ea:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80250ee:	f642 5202 	movw	r2, #11522	@ 0x2d02
 80250f2:	fb02 f303 	mul.w	r3, r2, r3
 80250f6:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80250fa:	4413      	add	r3, r2
 80250fc:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 8025100:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025104:	f644 62a3 	movw	r2, #20131	@ 0x4ea3
 8025108:	fb03 f202 	mul.w	r2, r3, r2
 802510c:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8025110:	441a      	add	r2, r3
 8025112:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8025116:	1ad3      	subs	r3, r2, r3
 8025118:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 802511c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025120:	4a80      	ldr	r2, [pc, #512]	@ (8025324 <jpeg_idct_15x15+0x5b4>)
 8025122:	fb03 f202 	mul.w	r2, r3, r2
 8025126:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802512a:	4413      	add	r3, r2
 802512c:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025130:	4413      	add	r3, r2
 8025132:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 8025136:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802513a:	f242 7231 	movw	r2, #10033	@ 0x2731
 802513e:	fb03 f202 	mul.w	r2, r3, r2
 8025142:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025146:	1ad3      	subs	r3, r2, r3
 8025148:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 802514c:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025150:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025154:	4413      	add	r3, r2
 8025156:	f241 2268 	movw	r2, #4712	@ 0x1268
 802515a:	fb02 f303 	mul.w	r3, r2, r3
 802515e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 8025162:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025166:	f640 7239 	movw	r2, #3897	@ 0xf39
 802516a:	fb03 f202 	mul.w	r2, r3, r2
 802516e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025172:	441a      	add	r2, r3
 8025174:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025178:	1ad3      	subs	r3, r2, r3
 802517a:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 802517e:	4413      	add	r3, r2
 8025180:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 8025184:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025188:	4a67      	ldr	r2, [pc, #412]	@ (8025328 <jpeg_idct_15x15+0x5b8>)
 802518a:	fb03 f202 	mul.w	r2, r3, r2
 802518e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025192:	441a      	add	r2, r3
 8025194:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025198:	4413      	add	r3, r2
 802519a:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802519e:	4413      	add	r3, r2
 80251a0:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80251a4:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80251a8:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80251ac:	4413      	add	r3, r2
 80251ae:	12da      	asrs	r2, r3, #11
 80251b0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80251b4:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80251b6:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80251ba:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80251be:	1ad2      	subs	r2, r2, r3
 80251c0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80251c4:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80251c8:	12d2      	asrs	r2, r2, #11
 80251ca:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80251cc:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80251d0:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80251d4:	441a      	add	r2, r3
 80251d6:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80251da:	3320      	adds	r3, #32
 80251dc:	12d2      	asrs	r2, r2, #11
 80251de:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 80251e0:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80251e4:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80251e8:	1ad2      	subs	r2, r2, r3
 80251ea:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80251ee:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 80251f2:	12d2      	asrs	r2, r2, #11
 80251f4:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 80251f6:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 80251fa:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80251fe:	441a      	add	r2, r3
 8025200:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025204:	3340      	adds	r3, #64	@ 0x40
 8025206:	12d2      	asrs	r2, r2, #11
 8025208:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802520a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 802520e:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 8025212:	1ad2      	subs	r2, r2, r3
 8025214:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025218:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 802521c:	12d2      	asrs	r2, r2, #11
 802521e:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 8025220:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025224:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8025228:	441a      	add	r2, r3
 802522a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802522e:	3360      	adds	r3, #96	@ 0x60
 8025230:	12d2      	asrs	r2, r2, #11
 8025232:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8025234:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025238:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802523c:	1ad2      	subs	r2, r2, r3
 802523e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025242:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8025246:	12d2      	asrs	r2, r2, #11
 8025248:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 802524a:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 802524e:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8025252:	441a      	add	r2, r3
 8025254:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025258:	3380      	adds	r3, #128	@ 0x80
 802525a:	12d2      	asrs	r2, r2, #11
 802525c:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802525e:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8025262:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 8025266:	1ad2      	subs	r2, r2, r3
 8025268:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802526c:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8025270:	12d2      	asrs	r2, r2, #11
 8025272:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8025274:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8025278:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 802527c:	441a      	add	r2, r3
 802527e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025282:	33a0      	adds	r3, #160	@ 0xa0
 8025284:	12d2      	asrs	r2, r2, #11
 8025286:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8025288:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 802528c:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 8025290:	1ad2      	subs	r2, r2, r3
 8025292:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025296:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 802529a:	12d2      	asrs	r2, r2, #11
 802529c:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 802529e:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 80252a2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80252a6:	441a      	add	r2, r3
 80252a8:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80252ac:	33c0      	adds	r3, #192	@ 0xc0
 80252ae:	12d2      	asrs	r2, r2, #11
 80252b0:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 80252b2:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 80252b6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 80252ba:	1ad2      	subs	r2, r2, r3
 80252bc:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80252c0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80252c4:	12d2      	asrs	r2, r2, #11
 80252c6:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27, CONST_BITS-PASS1_BITS);
 80252c8:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80252cc:	33e0      	adds	r3, #224	@ 0xe0
 80252ce:	f8d7 2200 	ldr.w	r2, [r7, #512]	@ 0x200
 80252d2:	12d2      	asrs	r2, r2, #11
 80252d4:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80252d6:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80252da:	3301      	adds	r3, #1
 80252dc:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 80252e0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80252e4:	3302      	adds	r3, #2
 80252e6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 80252ea:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80252ee:	3304      	adds	r3, #4
 80252f0:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
 80252f4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80252f8:	3304      	adds	r3, #4
 80252fa:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
 80252fe:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025302:	2b07      	cmp	r3, #7
 8025304:	f77f ad6d 	ble.w	8024de2 <jpeg_idct_15x15+0x72>
  }

  /* Pass 2: process 15 rows from work array, store into output array. */

  wsptr = workspace;
 8025308:	f107 0314 	add.w	r3, r7, #20
 802530c:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 8025310:	2300      	movs	r3, #0
 8025312:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8025316:	e2ab      	b.n	8025870 <jpeg_idct_15x15+0xb00>
 8025318:	ffffba5c 	.word	0xffffba5c
 802531c:	ffffe566 	.word	0xffffe566
 8025320:	ffffd4f6 	.word	0xffffd4f6
 8025324:	ffffdc67 	.word	0xffffdc67
 8025328:	ffffe42f 	.word	0xffffe42f
    outptr = output_buf[ctr] + output_col;
 802532c:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025330:	009b      	lsls	r3, r3, #2
 8025332:	f507 7216 	add.w	r2, r7, #600	@ 0x258
 8025336:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 802533a:	6812      	ldr	r2, [r2, #0]
 802533c:	4413      	add	r3, r2
 802533e:	681a      	ldr	r2, [r3, #0]
 8025340:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8025344:	4413      	add	r3, r2
 8025346:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802534a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802534e:	681b      	ldr	r3, [r3, #0]
 8025350:	3310      	adds	r3, #16
 8025352:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1 <<= CONST_BITS;
 8025356:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802535a:	035b      	lsls	r3, r3, #13
 802535c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z2 = (INT32) wsptr[2];
 8025360:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025364:	3308      	adds	r3, #8
 8025366:	681b      	ldr	r3, [r3, #0]
 8025368:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z3 = (INT32) wsptr[4];
 802536c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025370:	3310      	adds	r3, #16
 8025372:	681b      	ldr	r3, [r3, #0]
 8025374:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = (INT32) wsptr[6];
 8025378:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802537c:	3318      	adds	r3, #24
 802537e:	681b      	ldr	r3, [r3, #0]
 8025380:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 8025384:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025388:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 802538c:	fb02 f303 	mul.w	r3, r2, r3
 8025390:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 8025394:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025398:	f242 429d 	movw	r2, #9373	@ 0x249d
 802539c:	fb02 f303 	mul.w	r3, r2, r3
 80253a0:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp12 = z1 - tmp10;
 80253a4:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80253a8:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80253ac:	1ad3      	subs	r3, r2, r3
 80253ae:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp13 = z1 + tmp11;
 80253b2:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80253b6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80253ba:	4413      	add	r3, r2
 80253bc:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 80253c0:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80253c4:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80253c8:	1ad3      	subs	r3, r2, r3
 80253ca:	005b      	lsls	r3, r3, #1
 80253cc:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80253d0:	1ad3      	subs	r3, r2, r3
 80253d2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z4 = z2 - z3;
 80253d6:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80253da:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80253de:	1ad3      	subs	r3, r2, r3
 80253e0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 += z2;
 80253e4:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80253e8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80253ec:	4413      	add	r3, r2
 80253ee:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 80253f2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80253f6:	f642 22ce 	movw	r2, #10958	@ 0x2ace
 80253fa:	fb02 f303 	mul.w	r3, r2, r3
 80253fe:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 8025402:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025406:	f44f 72bb 	mov.w	r2, #374	@ 0x176
 802540a:	fb02 f303 	mul.w	r3, r2, r3
 802540e:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 8025412:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025416:	f642 6213 	movw	r2, #11795	@ 0x2e13
 802541a:	fb02 f303 	mul.w	r3, r2, r3
 802541e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 8025422:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025426:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802542a:	4413      	add	r3, r2
 802542c:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8025430:	4413      	add	r3, r2
 8025432:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 8025436:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 802543a:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802543e:	1ad2      	subs	r2, r2, r3
 8025440:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8025444:	4413      	add	r3, r2
 8025446:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802544a:	4413      	add	r3, r2
 802544c:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 8025450:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025454:	f241 1282 	movw	r2, #4482	@ 0x1182
 8025458:	fb02 f303 	mul.w	r3, r2, r3
 802545c:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 8025460:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025464:	f640 42c7 	movw	r2, #3271	@ 0xcc7
 8025468:	fb02 f303 	mul.w	r3, r2, r3
 802546c:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 8025470:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025474:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8025478:	1ad2      	subs	r2, r2, r3
 802547a:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802547e:	1ad3      	subs	r3, r2, r3
 8025480:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 8025484:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8025488:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802548c:	441a      	add	r2, r3
 802548e:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8025492:	1ad2      	subs	r2, r2, r3
 8025494:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025498:	1ad3      	subs	r3, r2, r3
 802549a:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 802549e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80254a2:	f641 124c 	movw	r2, #6476	@ 0x194c
 80254a6:	fb02 f303 	mul.w	r3, r2, r3
 80254aa:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 80254ae:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80254b2:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 80254b6:	fb02 f303 	mul.w	r3, r2, r3
 80254ba:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 80254be:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80254c2:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80254c6:	4413      	add	r3, r2
 80254c8:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80254cc:	4413      	add	r3, r2
 80254ce:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 80254d2:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80254d6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80254da:	1ad3      	subs	r3, r2, r3
 80254dc:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80254e0:	4413      	add	r3, r2
 80254e2:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
    tmp11 += tmp11;
 80254e6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80254ea:	005b      	lsls	r3, r3, #1
 80254ec:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 80254f0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80254f4:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80254f8:	4413      	add	r3, r2
 80254fa:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 80254fe:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025502:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 8025506:	1ad2      	subs	r2, r2, r3
 8025508:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802550c:	1ad3      	subs	r3, r2, r3
 802550e:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8025512:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025516:	3304      	adds	r3, #4
 8025518:	681b      	ldr	r3, [r3, #0]
 802551a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z2 = (INT32) wsptr[3];
 802551e:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025522:	330c      	adds	r3, #12
 8025524:	681b      	ldr	r3, [r3, #0]
 8025526:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = (INT32) wsptr[5];
 802552a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802552e:	3314      	adds	r3, #20
 8025530:	681b      	ldr	r3, [r3, #0]
 8025532:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 8025536:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802553a:	f242 7231 	movw	r2, #10033	@ 0x2731
 802553e:	fb02 f303 	mul.w	r3, r2, r3
 8025542:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z4 = (INT32) wsptr[7];
 8025546:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802554a:	331c      	adds	r3, #28
 802554c:	681b      	ldr	r3, [r3, #0]
 802554e:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp13 = z2 - z4;
 8025552:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025556:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802555a:	1ad3      	subs	r3, r2, r3
 802555c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 8025560:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025564:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8025568:	4413      	add	r3, r2
 802556a:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 802556e:	fb02 f303 	mul.w	r3, r2, r3
 8025572:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 8025576:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802557a:	f241 0271 	movw	r2, #4209	@ 0x1071
 802557e:	fb02 f303 	mul.w	r3, r2, r3
 8025582:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 8025586:	4413      	add	r3, r2
 8025588:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 802558c:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8025590:	4abd      	ldr	r2, [pc, #756]	@ (8025888 <jpeg_idct_15x15+0xb18>)
 8025592:	fb02 f303 	mul.w	r3, r2, r3
 8025596:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802559a:	4413      	add	r3, r2
 802559c:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 80255a0:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80255a4:	4ab9      	ldr	r2, [pc, #740]	@ (802588c <jpeg_idct_15x15+0xb1c>)
 80255a6:	fb02 f303 	mul.w	r3, r2, r3
 80255aa:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 80255ae:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80255b2:	4ab7      	ldr	r2, [pc, #732]	@ (8025890 <jpeg_idct_15x15+0xb20>)
 80255b4:	fb02 f303 	mul.w	r3, r2, r3
 80255b8:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
    z2 = z1 - z4;
 80255bc:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80255c0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80255c4:	1ad3      	subs	r3, r2, r3
 80255c6:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 80255ca:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80255ce:	f642 5202 	movw	r2, #11522	@ 0x2d02
 80255d2:	fb02 f303 	mul.w	r3, r2, r3
 80255d6:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80255da:	4413      	add	r3, r2
 80255dc:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 80255e0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80255e4:	f644 62a3 	movw	r2, #20131	@ 0x4ea3
 80255e8:	fb03 f202 	mul.w	r2, r3, r2
 80255ec:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 80255f0:	441a      	add	r2, r3
 80255f2:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80255f6:	1ad3      	subs	r3, r2, r3
 80255f8:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 80255fc:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025600:	4aa4      	ldr	r2, [pc, #656]	@ (8025894 <jpeg_idct_15x15+0xb24>)
 8025602:	fb03 f202 	mul.w	r2, r3, r2
 8025606:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802560a:	4413      	add	r3, r2
 802560c:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025610:	4413      	add	r3, r2
 8025612:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 8025616:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802561a:	f242 7231 	movw	r2, #10033	@ 0x2731
 802561e:	fb03 f202 	mul.w	r2, r3, r2
 8025622:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025626:	1ad3      	subs	r3, r2, r3
 8025628:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 802562c:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025630:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025634:	4413      	add	r3, r2
 8025636:	f241 2268 	movw	r2, #4712	@ 0x1268
 802563a:	fb02 f303 	mul.w	r3, r2, r3
 802563e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 8025642:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025646:	f640 7239 	movw	r2, #3897	@ 0xf39
 802564a:	fb03 f202 	mul.w	r2, r3, r2
 802564e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025652:	441a      	add	r2, r3
 8025654:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025658:	1ad3      	subs	r3, r2, r3
 802565a:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 802565e:	4413      	add	r3, r2
 8025660:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 8025664:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025668:	4a8b      	ldr	r2, [pc, #556]	@ (8025898 <jpeg_idct_15x15+0xb28>)
 802566a:	fb03 f202 	mul.w	r2, r3, r2
 802566e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025672:	441a      	add	r2, r3
 8025674:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025678:	4413      	add	r3, r2
 802567a:	f8d7 21fc 	ldr.w	r2, [r7, #508]	@ 0x1fc
 802567e:	4413      	add	r3, r2
 8025680:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8025684:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8025688:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 802568c:	4413      	add	r3, r2
 802568e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025690:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8025694:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025698:	4413      	add	r3, r2
 802569a:	781a      	ldrb	r2, [r3, #0]
 802569c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80256a0:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80256a2:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80256a6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80256aa:	1ad3      	subs	r3, r2, r3
 80256ac:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80256ae:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80256b2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80256b6:	441a      	add	r2, r3
 80256b8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80256bc:	330e      	adds	r3, #14
 80256be:	7812      	ldrb	r2, [r2, #0]
 80256c0:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80256c2:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80256c6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80256ca:	4413      	add	r3, r2
 80256cc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80256ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80256d2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80256d6:	441a      	add	r2, r3
 80256d8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80256dc:	3301      	adds	r3, #1
 80256de:	7812      	ldrb	r2, [r2, #0]
 80256e0:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80256e2:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
 80256e6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80256ea:	1ad3      	subs	r3, r2, r3
 80256ec:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80256ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80256f2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80256f6:	441a      	add	r2, r3
 80256f8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80256fc:	330d      	adds	r3, #13
 80256fe:	7812      	ldrb	r2, [r2, #0]
 8025700:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025702:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 8025706:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802570a:	4413      	add	r3, r2
 802570c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802570e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8025712:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025716:	441a      	add	r2, r3
 8025718:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802571c:	3302      	adds	r3, #2
 802571e:	7812      	ldrb	r2, [r2, #0]
 8025720:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025722:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
 8025726:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802572a:	1ad3      	subs	r3, r2, r3
 802572c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802572e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8025732:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025736:	441a      	add	r2, r3
 8025738:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802573c:	330c      	adds	r3, #12
 802573e:	7812      	ldrb	r2, [r2, #0]
 8025740:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8025742:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025746:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802574a:	4413      	add	r3, r2
 802574c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802574e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8025752:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025756:	441a      	add	r2, r3
 8025758:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802575c:	3303      	adds	r3, #3
 802575e:	7812      	ldrb	r2, [r2, #0]
 8025760:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8025762:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025766:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802576a:	1ad3      	subs	r3, r2, r3
 802576c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802576e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8025772:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025776:	441a      	add	r2, r3
 8025778:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802577c:	330b      	adds	r3, #11
 802577e:	7812      	ldrb	r2, [r2, #0]
 8025780:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8025782:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 8025786:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 802578a:	4413      	add	r3, r2
 802578c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802578e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8025792:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025796:	441a      	add	r2, r3
 8025798:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802579c:	3304      	adds	r3, #4
 802579e:	7812      	ldrb	r2, [r2, #0]
 80257a0:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80257a2:	f8d7 2208 	ldr.w	r2, [r7, #520]	@ 0x208
 80257a6:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 80257aa:	1ad3      	subs	r3, r2, r3
 80257ac:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80257ae:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80257b2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80257b6:	441a      	add	r2, r3
 80257b8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80257bc:	330a      	adds	r3, #10
 80257be:	7812      	ldrb	r2, [r2, #0]
 80257c0:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80257c2:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80257c6:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80257ca:	4413      	add	r3, r2
 80257cc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80257ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80257d2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80257d6:	441a      	add	r2, r3
 80257d8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80257dc:	3305      	adds	r3, #5
 80257de:	7812      	ldrb	r2, [r2, #0]
 80257e0:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80257e2:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 80257e6:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 80257ea:	1ad3      	subs	r3, r2, r3
 80257ec:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80257ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80257f2:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80257f6:	441a      	add	r2, r3
 80257f8:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80257fc:	3309      	adds	r3, #9
 80257fe:	7812      	ldrb	r2, [r2, #0]
 8025800:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8025802:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8025806:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802580a:	4413      	add	r3, r2
 802580c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802580e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8025812:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025816:	441a      	add	r2, r3
 8025818:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802581c:	3306      	adds	r3, #6
 802581e:	7812      	ldrb	r2, [r2, #0]
 8025820:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8025822:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8025826:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 802582a:	1ad3      	subs	r3, r2, r3
 802582c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802582e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8025832:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025836:	441a      	add	r2, r3
 8025838:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802583c:	3308      	adds	r3, #8
 802583e:	7812      	ldrb	r2, [r2, #0]
 8025840:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 8025842:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 8025846:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8025848:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 802584c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025850:	441a      	add	r2, r3
 8025852:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8025856:	3307      	adds	r3, #7
 8025858:	7812      	ldrb	r2, [r2, #0]
 802585a:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 802585c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025860:	3320      	adds	r3, #32
 8025862:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 8025866:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 802586a:	3301      	adds	r3, #1
 802586c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
 8025870:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025874:	2b0e      	cmp	r3, #14
 8025876:	f77f ad59 	ble.w	802532c <jpeg_idct_15x15+0x5bc>
  }
}
 802587a:	bf00      	nop
 802587c:	bf00      	nop
 802587e:	f507 7716 	add.w	r7, r7, #600	@ 0x258
 8025882:	46bd      	mov	sp, r7
 8025884:	bc90      	pop	{r4, r7}
 8025886:	4770      	bx	lr
 8025888:	ffffba5c 	.word	0xffffba5c
 802588c:	ffffe566 	.word	0xffffe566
 8025890:	ffffd4f6 	.word	0xffffd4f6
 8025894:	ffffdc67 	.word	0xffffdc67
 8025898:	ffffe42f 	.word	0xffffe42f

0802589c <jpeg_idct_16x16>:

GLOBAL(void)
jpeg_idct_16x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802589c:	b490      	push	{r4, r7}
 802589e:	f5ad 7d1e 	sub.w	sp, sp, #632	@ 0x278
 80258a2:	af00      	add	r7, sp, #0
 80258a4:	f507 741e 	add.w	r4, r7, #632	@ 0x278
 80258a8:	f5a4 741b 	sub.w	r4, r4, #620	@ 0x26c
 80258ac:	6020      	str	r0, [r4, #0]
 80258ae:	f507 701e 	add.w	r0, r7, #632	@ 0x278
 80258b2:	f5a0 701c 	sub.w	r0, r0, #624	@ 0x270
 80258b6:	6001      	str	r1, [r0, #0]
 80258b8:	f507 711e 	add.w	r1, r7, #632	@ 0x278
 80258bc:	f5a1 711d 	sub.w	r1, r1, #628	@ 0x274
 80258c0:	600a      	str	r2, [r1, #0]
 80258c2:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 80258c6:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 80258ca:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80258cc:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80258d0:	f5a3 731b 	sub.w	r3, r3, #620	@ 0x26c
 80258d4:	681b      	ldr	r3, [r3, #0]
 80258d6:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80258da:	3380      	adds	r3, #128	@ 0x80
 80258dc:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
  int workspace[8*16];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 80258e0:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80258e4:	f5a3 731d 	sub.w	r3, r3, #628	@ 0x274
 80258e8:	681b      	ldr	r3, [r3, #0]
 80258ea:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80258ee:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80258f2:	f5a3 731c 	sub.w	r3, r3, #624	@ 0x270
 80258f6:	681b      	ldr	r3, [r3, #0]
 80258f8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80258fa:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
  wsptr = workspace;
 80258fe:	f107 0310 	add.w	r3, r7, #16
 8025902:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025906:	2300      	movs	r3, #0
 8025908:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 802590c:	e30a      	b.n	8025f24 <jpeg_idct_16x16+0x688>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802590e:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025912:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025916:	461a      	mov	r2, r3
 8025918:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802591c:	681b      	ldr	r3, [r3, #0]
 802591e:	fb02 f303 	mul.w	r3, r2, r3
 8025922:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp0 <<= CONST_BITS;
 8025926:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802592a:	035b      	lsls	r3, r3, #13
 802592c:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    /* Add fudge factor here for final descale. */
    tmp0 += 1 << (CONST_BITS-PASS1_BITS-1);
 8025930:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025934:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8025938:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802593c:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025940:	3340      	adds	r3, #64	@ 0x40
 8025942:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025946:	461a      	mov	r2, r3
 8025948:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802594c:	3380      	adds	r3, #128	@ 0x80
 802594e:	681b      	ldr	r3, [r3, #0]
 8025950:	fb02 f303 	mul.w	r3, r2, r3
 8025954:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8025958:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802595c:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8025960:	fb02 f303 	mul.w	r3, r2, r3
 8025964:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8025968:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802596c:	f241 1251 	movw	r2, #4433	@ 0x1151
 8025970:	fb02 f303 	mul.w	r3, r2, r3
 8025974:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 8025978:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 802597c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025980:	4413      	add	r3, r2
 8025982:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = tmp0 - tmp1;
 8025986:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 802598a:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802598e:	1ad3      	subs	r3, r2, r3
 8025990:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = tmp0 + tmp2;
 8025994:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8025998:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802599c:	4413      	add	r3, r2
 802599e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp13 = tmp0 - tmp2;
 80259a2:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80259a6:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80259aa:	1ad3      	subs	r3, r2, r3
 80259ac:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80259b0:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80259b4:	3320      	adds	r3, #32
 80259b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80259ba:	461a      	mov	r2, r3
 80259bc:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80259c0:	3340      	adds	r3, #64	@ 0x40
 80259c2:	681b      	ldr	r3, [r3, #0]
 80259c4:	fb02 f303 	mul.w	r3, r2, r3
 80259c8:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80259cc:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80259d0:	3360      	adds	r3, #96	@ 0x60
 80259d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80259d6:	461a      	mov	r2, r3
 80259d8:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80259dc:	33c0      	adds	r3, #192	@ 0xc0
 80259de:	681b      	ldr	r3, [r3, #0]
 80259e0:	fb02 f303 	mul.w	r3, r2, r3
 80259e4:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = z1 - z2;
 80259e8:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80259ec:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80259f0:	1ad3      	subs	r3, r2, r3
 80259f2:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 80259f6:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80259fa:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 80259fe:	fb02 f303 	mul.w	r3, r2, r3
 8025a02:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8025a06:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025a0a:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8025a0e:	fb02 f303 	mul.w	r3, r2, r3
 8025a12:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8025a16:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025a1a:	f245 2203 	movw	r2, #20995	@ 0x5203
 8025a1e:	fb02 f303 	mul.w	r3, r2, r3
 8025a22:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025a26:	4413      	add	r3, r2
 8025a28:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8025a2c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025a30:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8025a34:	fb02 f303 	mul.w	r3, r2, r3
 8025a38:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8025a3c:	4413      	add	r3, r2
 8025a3e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8025a42:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025a46:	4af4      	ldr	r2, [pc, #976]	@ (8025e18 <jpeg_idct_16x16+0x57c>)
 8025a48:	fb02 f303 	mul.w	r3, r2, r3
 8025a4c:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025a50:	4413      	add	r3, r2
 8025a52:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8025a56:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025a5a:	4af0      	ldr	r2, [pc, #960]	@ (8025e1c <jpeg_idct_16x16+0x580>)
 8025a5c:	fb02 f303 	mul.w	r3, r2, r3
 8025a60:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8025a64:	4413      	add	r3, r2
 8025a66:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp20 = tmp10 + tmp0;
 8025a6a:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8025a6e:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025a72:	4413      	add	r3, r2
 8025a74:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 8025a78:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8025a7c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025a80:	1ad3      	subs	r3, r2, r3
 8025a82:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 8025a86:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025a8a:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025a8e:	4413      	add	r3, r2
 8025a90:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 8025a94:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025a98:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025a9c:	1ad3      	subs	r3, r2, r3
 8025a9e:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 8025aa2:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8025aa6:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025aaa:	4413      	add	r3, r2
 8025aac:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 8025ab0:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8025ab4:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025ab8:	1ad3      	subs	r3, r2, r3
 8025aba:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 8025abe:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8025ac2:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025ac6:	4413      	add	r3, r2
 8025ac8:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 8025acc:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8025ad0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025ad4:	1ad3      	subs	r3, r2, r3
 8025ad6:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8025ada:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025ade:	3310      	adds	r3, #16
 8025ae0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025ae4:	461a      	mov	r2, r3
 8025ae6:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8025aea:	3320      	adds	r3, #32
 8025aec:	681b      	ldr	r3, [r3, #0]
 8025aee:	fb02 f303 	mul.w	r3, r2, r3
 8025af2:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8025af6:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025afa:	3330      	adds	r3, #48	@ 0x30
 8025afc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025b00:	461a      	mov	r2, r3
 8025b02:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8025b06:	3360      	adds	r3, #96	@ 0x60
 8025b08:	681b      	ldr	r3, [r3, #0]
 8025b0a:	fb02 f303 	mul.w	r3, r2, r3
 8025b0e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8025b12:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025b16:	3350      	adds	r3, #80	@ 0x50
 8025b18:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025b1c:	461a      	mov	r2, r3
 8025b1e:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8025b22:	33a0      	adds	r3, #160	@ 0xa0
 8025b24:	681b      	ldr	r3, [r3, #0]
 8025b26:	fb02 f303 	mul.w	r3, r2, r3
 8025b2a:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8025b2e:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025b32:	3370      	adds	r3, #112	@ 0x70
 8025b34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8025b38:	461a      	mov	r2, r3
 8025b3a:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8025b3e:	33e0      	adds	r3, #224	@ 0xe0
 8025b40:	681b      	ldr	r3, [r3, #0]
 8025b42:	fb02 f303 	mul.w	r3, r2, r3
 8025b46:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234

    tmp11 = z1 + z3;
 8025b4a:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025b4e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025b52:	4413      	add	r3, r2
 8025b54:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8025b58:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025b5c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025b60:	4413      	add	r3, r2
 8025b62:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 8025b66:	fb02 f303 	mul.w	r3, r2, r3
 8025b6a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8025b6e:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025b72:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 8025b76:	fb02 f303 	mul.w	r3, r2, r3
 8025b7a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8025b7e:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025b82:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025b86:	4413      	add	r3, r2
 8025b88:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 8025b8c:	fb02 f303 	mul.w	r3, r2, r3
 8025b90:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8025b94:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025b98:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025b9c:	1ad3      	subs	r3, r2, r3
 8025b9e:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 8025ba2:	fb02 f303 	mul.w	r3, r2, r3
 8025ba6:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8025baa:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025bae:	f241 5255 	movw	r2, #5461	@ 0x1555
 8025bb2:	fb02 f303 	mul.w	r3, r2, r3
 8025bb6:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8025bba:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025bbe:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025bc2:	1ad3      	subs	r3, r2, r3
 8025bc4:	f640 5223 	movw	r2, #3363	@ 0xd23
 8025bc8:	fb02 f303 	mul.w	r3, r2, r3
 8025bcc:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 8025bd0:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8025bd4:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025bd8:	441a      	add	r2, r3
 8025bda:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025bde:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8025be0:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025be4:	498e      	ldr	r1, [pc, #568]	@ (8025e20 <jpeg_idct_16x16+0x584>)
 8025be6:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 8025bea:	4413      	add	r3, r2
 8025bec:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 8025bf0:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8025bf4:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025bf8:	441a      	add	r2, r3
 8025bfa:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8025bfe:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8025c00:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025c04:	4987      	ldr	r1, [pc, #540]	@ (8025e24 <jpeg_idct_16x16+0x588>)
 8025c06:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 8025c0a:	4413      	add	r3, r2
 8025c0c:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8025c10:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025c14:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025c18:	4413      	add	r3, r2
 8025c1a:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 8025c1e:	fb02 f303 	mul.w	r3, r2, r3
 8025c22:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8025c26:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025c2a:	f240 224d 	movw	r2, #589	@ 0x24d
 8025c2e:	fb03 f202 	mul.w	r2, r3, r2
 8025c32:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025c36:	4413      	add	r3, r2
 8025c38:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8025c3c:	4413      	add	r3, r2
 8025c3e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8025c42:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025c46:	4a78      	ldr	r2, [pc, #480]	@ (8025e28 <jpeg_idct_16x16+0x58c>)
 8025c48:	fb03 f202 	mul.w	r2, r3, r2
 8025c4c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025c50:	4413      	add	r3, r2
 8025c52:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8025c56:	4413      	add	r3, r2
 8025c58:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8025c5c:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025c60:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025c64:	1ad3      	subs	r3, r2, r3
 8025c66:	f642 5209 	movw	r2, #11529	@ 0x2d09
 8025c6a:	fb02 f303 	mul.w	r3, r2, r3
 8025c6e:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8025c72:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025c76:	4a6d      	ldr	r2, [pc, #436]	@ (8025e2c <jpeg_idct_16x16+0x590>)
 8025c78:	fb03 f202 	mul.w	r2, r3, r2
 8025c7c:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025c80:	4413      	add	r3, r2
 8025c82:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8025c86:	4413      	add	r3, r2
 8025c88:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 8025c8c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025c90:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 8025c94:	fb03 f202 	mul.w	r2, r3, r2
 8025c98:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025c9c:	4413      	add	r3, r2
 8025c9e:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025ca2:	4413      	add	r3, r2
 8025ca4:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    += z4;
 8025ca8:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8025cac:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025cb0:	4413      	add	r3, r2
 8025cb2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 8025cb6:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025cba:	4a5d      	ldr	r2, [pc, #372]	@ (8025e30 <jpeg_idct_16x16+0x594>)
 8025cbc:	fb02 f303 	mul.w	r3, r2, r3
 8025cc0:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1;
 8025cc4:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8025cc8:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025ccc:	4413      	add	r3, r2
 8025cce:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8025cd2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025cd6:	f242 2218 	movw	r2, #8728	@ 0x2218
 8025cda:	fb03 f202 	mul.w	r2, r3, r2
 8025cde:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025ce2:	4413      	add	r3, r2
 8025ce4:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8025ce8:	4413      	add	r3, r2
 8025cea:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8025cee:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025cf2:	4a50      	ldr	r2, [pc, #320]	@ (8025e34 <jpeg_idct_16x16+0x598>)
 8025cf4:	fb02 f303 	mul.w	r3, r2, r3
 8025cf8:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8025cfc:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025d00:	f246 4285 	movw	r2, #25733	@ 0x6485
 8025d04:	fb03 f202 	mul.w	r2, r3, r2
 8025d08:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d0c:	4413      	add	r3, r2
 8025d0e:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8025d12:	4413      	add	r3, r2
 8025d14:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp12 += z2;
 8025d18:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8025d1c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d20:	4413      	add	r3, r2
 8025d22:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8025d26:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8025d2a:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8025d2e:	4413      	add	r3, r2
 8025d30:	4a41      	ldr	r2, [pc, #260]	@ (8025e38 <jpeg_idct_16x16+0x59c>)
 8025d32:	fb02 f303 	mul.w	r3, r2, r3
 8025d36:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp2  += z2;
 8025d3a:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8025d3e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d42:	4413      	add	r3, r2
 8025d44:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 8025d48:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8025d4c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d50:	4413      	add	r3, r2
 8025d52:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8025d56:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8025d5a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8025d5e:	1ad3      	subs	r3, r2, r3
 8025d60:	f640 5223 	movw	r2, #3363	@ 0xd23
 8025d64:	fb02 f303 	mul.w	r3, r2, r3
 8025d68:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2;
 8025d6c:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8025d70:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d74:	4413      	add	r3, r2
 8025d76:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 += z2;
 8025d7a:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8025d7e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025d82:	4413      	add	r3, r2
 8025d84:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 8025d88:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8025d8c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025d90:	4413      	add	r3, r2
 8025d92:	12da      	asrs	r2, r3, #11
 8025d94:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025d98:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 8025d9a:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8025d9e:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025da2:	1ad2      	subs	r2, r2, r3
 8025da4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025da8:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
 8025dac:	12d2      	asrs	r2, r2, #11
 8025dae:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 8025db0:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8025db4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025db8:	441a      	add	r2, r3
 8025dba:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025dbe:	3320      	adds	r3, #32
 8025dc0:	12d2      	asrs	r2, r2, #11
 8025dc2:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 8025dc4:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8025dc8:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025dcc:	1ad2      	subs	r2, r2, r3
 8025dce:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025dd2:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 8025dd6:	12d2      	asrs	r2, r2, #11
 8025dd8:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 8025dda:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8025dde:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025de2:	441a      	add	r2, r3
 8025de4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025de8:	3340      	adds	r3, #64	@ 0x40
 8025dea:	12d2      	asrs	r2, r2, #11
 8025dec:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 8025dee:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 8025df2:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025df6:	1ad2      	subs	r2, r2, r3
 8025df8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025dfc:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8025e00:	12d2      	asrs	r2, r2, #11
 8025e02:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 8025e04:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8025e08:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025e0c:	441a      	add	r2, r3
 8025e0e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025e12:	3360      	adds	r3, #96	@ 0x60
 8025e14:	12d2      	asrs	r2, r2, #11
 8025e16:	e011      	b.n	8025e3c <jpeg_idct_16x16+0x5a0>
 8025e18:	ffffecc2 	.word	0xffffecc2
 8025e1c:	ffffefb0 	.word	0xffffefb0
 8025e20:	ffffb6d6 	.word	0xffffb6d6
 8025e24:	ffffc542 	.word	0xffffc542
 8025e28:	ffffdbfa 	.word	0xffffdbfa
 8025e2c:	ffffe77a 	.word	0xffffe77a
 8025e30:	ffffeaab 	.word	0xffffeaab
 8025e34:	ffffd817 	.word	0xffffd817
 8025e38:	ffffd4b2 	.word	0xffffd4b2
 8025e3c:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 8025e3e:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8025e42:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8025e46:	1ad2      	subs	r2, r2, r3
 8025e48:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025e4c:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8025e50:	12d2      	asrs	r2, r2, #11
 8025e52:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 8025e54:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8025e58:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025e5c:	441a      	add	r2, r3
 8025e5e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025e62:	3380      	adds	r3, #128	@ 0x80
 8025e64:	12d2      	asrs	r2, r2, #11
 8025e66:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 8025e68:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8025e6c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8025e70:	1ad2      	subs	r2, r2, r3
 8025e72:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025e76:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 8025e7a:	12d2      	asrs	r2, r2, #11
 8025e7c:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 8025e7e:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025e82:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025e86:	441a      	add	r2, r3
 8025e88:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025e8c:	33a0      	adds	r3, #160	@ 0xa0
 8025e8e:	12d2      	asrs	r2, r2, #11
 8025e90:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 8025e92:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8025e96:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8025e9a:	1ad2      	subs	r2, r2, r3
 8025e9c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025ea0:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 8025ea4:	12d2      	asrs	r2, r2, #11
 8025ea6:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 8025ea8:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025eac:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8025eb0:	441a      	add	r2, r3
 8025eb2:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025eb6:	33c0      	adds	r3, #192	@ 0xc0
 8025eb8:	12d2      	asrs	r2, r2, #11
 8025eba:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 8025ebc:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8025ec0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8025ec4:	1ad2      	subs	r2, r2, r3
 8025ec6:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025eca:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 8025ece:	12d2      	asrs	r2, r2, #11
 8025ed0:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 8025ed2:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8025ed6:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8025eda:	441a      	add	r2, r3
 8025edc:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025ee0:	33e0      	adds	r3, #224	@ 0xe0
 8025ee2:	12d2      	asrs	r2, r2, #11
 8025ee4:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 8025ee6:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8025eea:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8025eee:	1ad2      	subs	r2, r2, r3
 8025ef0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025ef4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8025ef8:	12d2      	asrs	r2, r2, #11
 8025efa:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8025efc:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8025f00:	3301      	adds	r3, #1
 8025f02:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8025f06:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8025f0a:	3302      	adds	r3, #2
 8025f0c:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
 8025f10:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8025f14:	3304      	adds	r3, #4
 8025f16:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
 8025f1a:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025f1e:	3304      	adds	r3, #4
 8025f20:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
 8025f24:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8025f28:	2b07      	cmp	r3, #7
 8025f2a:	f77f acf0 	ble.w	802590e <jpeg_idct_16x16+0x72>
  }

  /* Pass 2: process 16 rows from work array, store into output array. */

  wsptr = workspace;
 8025f2e:	f107 0310 	add.w	r3, r7, #16
 8025f32:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 8025f36:	2300      	movs	r3, #0
 8025f38:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8025f3c:	e324      	b.n	8026588 <jpeg_idct_16x16+0xcec>
    outptr = output_buf[ctr] + output_col;
 8025f3e:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8025f42:	009b      	lsls	r3, r3, #2
 8025f44:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 8025f48:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 8025f4c:	6812      	ldr	r2, [r2, #0]
 8025f4e:	4413      	add	r3, r2
 8025f50:	681a      	ldr	r2, [r3, #0]
 8025f52:	f8d7 3280 	ldr.w	r3, [r7, #640]	@ 0x280
 8025f56:	4413      	add	r3, r2
 8025f58:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8025f5c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025f60:	681b      	ldr	r3, [r3, #0]
 8025f62:	3310      	adds	r3, #16
 8025f64:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp0 <<= CONST_BITS;
 8025f68:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8025f6c:	035b      	lsls	r3, r3, #13
 8025f6e:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c

    z1 = (INT32) wsptr[4];
 8025f72:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025f76:	3310      	adds	r3, #16
 8025f78:	681b      	ldr	r3, [r3, #0]
 8025f7a:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8025f7e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025f82:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8025f86:	fb02 f303 	mul.w	r3, r2, r3
 8025f8a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8025f8e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8025f92:	f241 1251 	movw	r2, #4433	@ 0x1151
 8025f96:	fb02 f303 	mul.w	r3, r2, r3
 8025f9a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 8025f9e:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8025fa2:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025fa6:	4413      	add	r3, r2
 8025fa8:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = tmp0 - tmp1;
 8025fac:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8025fb0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8025fb4:	1ad3      	subs	r3, r2, r3
 8025fb6:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = tmp0 + tmp2;
 8025fba:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8025fbe:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025fc2:	4413      	add	r3, r2
 8025fc4:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp13 = tmp0 - tmp2;
 8025fc8:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8025fcc:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8025fd0:	1ad3      	subs	r3, r2, r3
 8025fd2:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240

    z1 = (INT32) wsptr[2];
 8025fd6:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025fda:	3308      	adds	r3, #8
 8025fdc:	681b      	ldr	r3, [r3, #0]
 8025fde:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = (INT32) wsptr[6];
 8025fe2:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8025fe6:	3318      	adds	r3, #24
 8025fe8:	681b      	ldr	r3, [r3, #0]
 8025fea:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = z1 - z2;
 8025fee:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8025ff2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8025ff6:	1ad3      	subs	r3, r2, r3
 8025ff8:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8025ffc:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026000:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 8026004:	fb02 f303 	mul.w	r3, r2, r3
 8026008:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 802600c:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026010:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8026014:	fb02 f303 	mul.w	r3, r2, r3
 8026018:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 802601c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026020:	f245 2203 	movw	r2, #20995	@ 0x5203
 8026024:	fb02 f303 	mul.w	r3, r2, r3
 8026028:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802602c:	4413      	add	r3, r2
 802602e:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8026032:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026036:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 802603a:	fb02 f303 	mul.w	r3, r2, r3
 802603e:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8026042:	4413      	add	r3, r2
 8026044:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8026048:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802604c:	4af4      	ldr	r2, [pc, #976]	@ (8026420 <jpeg_idct_16x16+0xb84>)
 802604e:	fb02 f303 	mul.w	r3, r2, r3
 8026052:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8026056:	4413      	add	r3, r2
 8026058:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 802605c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026060:	4af0      	ldr	r2, [pc, #960]	@ (8026424 <jpeg_idct_16x16+0xb88>)
 8026062:	fb02 f303 	mul.w	r3, r2, r3
 8026066:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802606a:	4413      	add	r3, r2
 802606c:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp20 = tmp10 + tmp0;
 8026070:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8026074:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026078:	4413      	add	r3, r2
 802607a:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 802607e:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8026082:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026086:	1ad3      	subs	r3, r2, r3
 8026088:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 802608c:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8026090:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026094:	4413      	add	r3, r2
 8026096:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 802609a:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802609e:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80260a2:	1ad3      	subs	r3, r2, r3
 80260a4:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 80260a8:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80260ac:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80260b0:	4413      	add	r3, r2
 80260b2:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 80260b6:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80260ba:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80260be:	1ad3      	subs	r3, r2, r3
 80260c0:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 80260c4:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80260c8:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80260cc:	4413      	add	r3, r2
 80260ce:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 80260d2:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80260d6:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80260da:	1ad3      	subs	r3, r2, r3
 80260dc:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80260e0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80260e4:	3304      	adds	r3, #4
 80260e6:	681b      	ldr	r3, [r3, #0]
 80260e8:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 = (INT32) wsptr[3];
 80260ec:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80260f0:	330c      	adds	r3, #12
 80260f2:	681b      	ldr	r3, [r3, #0]
 80260f4:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z3 = (INT32) wsptr[5];
 80260f8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80260fc:	3314      	adds	r3, #20
 80260fe:	681b      	ldr	r3, [r3, #0]
 8026100:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    z4 = (INT32) wsptr[7];
 8026104:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8026108:	331c      	adds	r3, #28
 802610a:	681b      	ldr	r3, [r3, #0]
 802610c:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234

    tmp11 = z1 + z3;
 8026110:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026114:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026118:	4413      	add	r3, r2
 802611a:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 802611e:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026122:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026126:	4413      	add	r3, r2
 8026128:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 802612c:	fb02 f303 	mul.w	r3, r2, r3
 8026130:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8026134:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026138:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 802613c:	fb02 f303 	mul.w	r3, r2, r3
 8026140:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8026144:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026148:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802614c:	4413      	add	r3, r2
 802614e:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 8026152:	fb02 f303 	mul.w	r3, r2, r3
 8026156:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 802615a:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 802615e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8026162:	1ad3      	subs	r3, r2, r3
 8026164:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 8026168:	fb02 f303 	mul.w	r3, r2, r3
 802616c:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8026170:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8026174:	f241 5255 	movw	r2, #5461	@ 0x1555
 8026178:	fb02 f303 	mul.w	r3, r2, r3
 802617c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8026180:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8026184:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026188:	1ad3      	subs	r3, r2, r3
 802618a:	f640 5223 	movw	r2, #3363	@ 0xd23
 802618e:	fb02 f303 	mul.w	r3, r2, r3
 8026192:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 8026196:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802619a:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802619e:	441a      	add	r2, r3
 80261a0:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80261a4:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 80261a6:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80261aa:	499f      	ldr	r1, [pc, #636]	@ (8026428 <jpeg_idct_16x16+0xb8c>)
 80261ac:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 80261b0:	4413      	add	r3, r2
 80261b2:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 80261b6:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 80261ba:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80261be:	441a      	add	r2, r3
 80261c0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80261c4:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 80261c6:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80261ca:	4998      	ldr	r1, [pc, #608]	@ (802642c <jpeg_idct_16x16+0xb90>)
 80261cc:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 80261d0:	4413      	add	r3, r2
 80261d2:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 80261d6:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80261da:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80261de:	4413      	add	r3, r2
 80261e0:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 80261e4:	fb02 f303 	mul.w	r3, r2, r3
 80261e8:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 80261ec:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80261f0:	f240 224d 	movw	r2, #589	@ 0x24d
 80261f4:	fb03 f202 	mul.w	r2, r3, r2
 80261f8:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80261fc:	4413      	add	r3, r2
 80261fe:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8026202:	4413      	add	r3, r2
 8026204:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8026208:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802620c:	4a88      	ldr	r2, [pc, #544]	@ (8026430 <jpeg_idct_16x16+0xb94>)
 802620e:	fb03 f202 	mul.w	r2, r3, r2
 8026212:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026216:	4413      	add	r3, r2
 8026218:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 802621c:	4413      	add	r3, r2
 802621e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8026222:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8026226:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802622a:	1ad3      	subs	r3, r2, r3
 802622c:	f642 5209 	movw	r2, #11529	@ 0x2d09
 8026230:	fb02 f303 	mul.w	r3, r2, r3
 8026234:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8026238:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802623c:	4a7d      	ldr	r2, [pc, #500]	@ (8026434 <jpeg_idct_16x16+0xb98>)
 802623e:	fb03 f202 	mul.w	r2, r3, r2
 8026242:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026246:	4413      	add	r3, r2
 8026248:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 802624c:	4413      	add	r3, r2
 802624e:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 8026252:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026256:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 802625a:	fb03 f202 	mul.w	r2, r3, r2
 802625e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026262:	4413      	add	r3, r2
 8026264:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8026268:	4413      	add	r3, r2
 802626a:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    += z4;
 802626e:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8026272:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8026276:	4413      	add	r3, r2
 8026278:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 802627c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026280:	4a6d      	ldr	r2, [pc, #436]	@ (8026438 <jpeg_idct_16x16+0xb9c>)
 8026282:	fb02 f303 	mul.w	r3, r2, r3
 8026286:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    tmp1  += z1;
 802628a:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802628e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8026292:	4413      	add	r3, r2
 8026294:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8026298:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802629c:	f242 2218 	movw	r2, #8728	@ 0x2218
 80262a0:	fb03 f202 	mul.w	r2, r3, r2
 80262a4:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80262a8:	4413      	add	r3, r2
 80262aa:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 80262ae:	4413      	add	r3, r2
 80262b0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 80262b4:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80262b8:	4a60      	ldr	r2, [pc, #384]	@ (802643c <jpeg_idct_16x16+0xba0>)
 80262ba:	fb02 f303 	mul.w	r3, r2, r3
 80262be:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 80262c2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80262c6:	f246 4285 	movw	r2, #25733	@ 0x6485
 80262ca:	fb03 f202 	mul.w	r2, r3, r2
 80262ce:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80262d2:	4413      	add	r3, r2
 80262d4:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 80262d8:	4413      	add	r3, r2
 80262da:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp12 += z2;
 80262de:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80262e2:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80262e6:	4413      	add	r3, r2
 80262e8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 80262ec:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80262f0:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80262f4:	4413      	add	r3, r2
 80262f6:	4a52      	ldr	r2, [pc, #328]	@ (8026440 <jpeg_idct_16x16+0xba4>)
 80262f8:	fb02 f303 	mul.w	r3, r2, r3
 80262fc:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp2  += z2;
 8026300:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8026304:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026308:	4413      	add	r3, r2
 802630a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 802630e:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8026312:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026316:	4413      	add	r3, r2
 8026318:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 802631c:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8026320:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8026324:	1ad3      	subs	r3, r2, r3
 8026326:	f640 5223 	movw	r2, #3363	@ 0xd23
 802632a:	fb02 f303 	mul.w	r3, r2, r3
 802632e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp10 += z2;
 8026332:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8026336:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802633a:	4413      	add	r3, r2
 802633c:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp11 += z2;
 8026340:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8026344:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8026348:	4413      	add	r3, r2
 802634a:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 802634e:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8026352:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026356:	4413      	add	r3, r2
 8026358:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802635a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 802635e:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026362:	4413      	add	r3, r2
 8026364:	781a      	ldrb	r2, [r3, #0]
 8026366:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802636a:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 802636c:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8026370:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8026374:	1ad3      	subs	r3, r2, r3
 8026376:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026378:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 802637c:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026380:	441a      	add	r2, r3
 8026382:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8026386:	330f      	adds	r3, #15
 8026388:	7812      	ldrb	r2, [r2, #0]
 802638a:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 802638c:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 8026390:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8026394:	4413      	add	r3, r2
 8026396:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026398:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 802639c:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80263a0:	441a      	add	r2, r3
 80263a2:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80263a6:	3301      	adds	r3, #1
 80263a8:	7812      	ldrb	r2, [r2, #0]
 80263aa:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 80263ac:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80263b0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80263b4:	1ad3      	subs	r3, r2, r3
 80263b6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80263b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 80263bc:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80263c0:	441a      	add	r2, r3
 80263c2:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80263c6:	330e      	adds	r3, #14
 80263c8:	7812      	ldrb	r2, [r2, #0]
 80263ca:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 80263cc:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80263d0:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80263d4:	4413      	add	r3, r2
 80263d6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80263d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 80263dc:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80263e0:	441a      	add	r2, r3
 80263e2:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80263e6:	3302      	adds	r3, #2
 80263e8:	7812      	ldrb	r2, [r2, #0]
 80263ea:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 80263ec:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80263f0:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80263f4:	1ad3      	subs	r3, r2, r3
 80263f6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80263f8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 80263fc:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026400:	441a      	add	r2, r3
 8026402:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8026406:	330d      	adds	r3, #13
 8026408:	7812      	ldrb	r2, [r2, #0]
 802640a:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 802640c:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8026410:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8026414:	4413      	add	r3, r2
 8026416:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026418:	f3c3 0309 	ubfx	r3, r3, #0, #10
 802641c:	e012      	b.n	8026444 <jpeg_idct_16x16+0xba8>
 802641e:	bf00      	nop
 8026420:	ffffecc2 	.word	0xffffecc2
 8026424:	ffffefb0 	.word	0xffffefb0
 8026428:	ffffb6d6 	.word	0xffffb6d6
 802642c:	ffffc542 	.word	0xffffc542
 8026430:	ffffdbfa 	.word	0xffffdbfa
 8026434:	ffffe77a 	.word	0xffffe77a
 8026438:	ffffeaab 	.word	0xffffeaab
 802643c:	ffffd817 	.word	0xffffd817
 8026440:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8026444:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026448:	441a      	add	r2, r3
 802644a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802644e:	3303      	adds	r3, #3
 8026450:	7812      	ldrb	r2, [r2, #0]
 8026452:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8026454:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8026458:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802645c:	1ad3      	subs	r3, r2, r3
 802645e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026460:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8026464:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026468:	441a      	add	r2, r3
 802646a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802646e:	330c      	adds	r3, #12
 8026470:	7812      	ldrb	r2, [r2, #0]
 8026472:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8026474:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8026478:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802647c:	4413      	add	r3, r2
 802647e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026480:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8026484:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026488:	441a      	add	r2, r3
 802648a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802648e:	3304      	adds	r3, #4
 8026490:	7812      	ldrb	r2, [r2, #0]
 8026492:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 8026494:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8026498:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802649c:	1ad3      	subs	r3, r2, r3
 802649e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80264a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 80264a4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80264a8:	441a      	add	r2, r3
 80264aa:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80264ae:	330b      	adds	r3, #11
 80264b0:	7812      	ldrb	r2, [r2, #0]
 80264b2:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 80264b4:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80264b8:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80264bc:	4413      	add	r3, r2
 80264be:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80264c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 80264c4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80264c8:	441a      	add	r2, r3
 80264ca:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80264ce:	3305      	adds	r3, #5
 80264d0:	7812      	ldrb	r2, [r2, #0]
 80264d2:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 80264d4:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 80264d8:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80264dc:	1ad3      	subs	r3, r2, r3
 80264de:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80264e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 80264e4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80264e8:	441a      	add	r2, r3
 80264ea:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80264ee:	330a      	adds	r3, #10
 80264f0:	7812      	ldrb	r2, [r2, #0]
 80264f2:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 80264f4:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80264f8:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80264fc:	4413      	add	r3, r2
 80264fe:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026500:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8026504:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026508:	441a      	add	r2, r3
 802650a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802650e:	3306      	adds	r3, #6
 8026510:	7812      	ldrb	r2, [r2, #0]
 8026512:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8026514:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 8026518:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802651c:	1ad3      	subs	r3, r2, r3
 802651e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026520:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8026524:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026528:	441a      	add	r2, r3
 802652a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802652e:	3309      	adds	r3, #9
 8026530:	7812      	ldrb	r2, [r2, #0]
 8026532:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8026534:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8026538:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802653c:	4413      	add	r3, r2
 802653e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026540:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 8026544:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026548:	441a      	add	r2, r3
 802654a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802654e:	3307      	adds	r3, #7
 8026550:	7812      	ldrb	r2, [r2, #0]
 8026552:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8026554:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 8026558:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802655c:	1ad3      	subs	r3, r2, r3
 802655e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026560:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 8026564:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8026568:	441a      	add	r2, r3
 802656a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802656e:	3308      	adds	r3, #8
 8026570:	7812      	ldrb	r2, [r2, #0]
 8026572:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8026574:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8026578:	3320      	adds	r3, #32
 802657a:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 802657e:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8026582:	3301      	adds	r3, #1
 8026584:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8026588:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 802658c:	2b0f      	cmp	r3, #15
 802658e:	f77f acd6 	ble.w	8025f3e <jpeg_idct_16x16+0x6a2>
  }
}
 8026592:	bf00      	nop
 8026594:	bf00      	nop
 8026596:	f507 771e 	add.w	r7, r7, #632	@ 0x278
 802659a:	46bd      	mov	sp, r7
 802659c:	bc90      	pop	{r4, r7}
 802659e:	4770      	bx	lr

080265a0 <jpeg_idct_16x8>:

GLOBAL(void)
jpeg_idct_16x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80265a0:	b490      	push	{r4, r7}
 80265a2:	b0e0      	sub	sp, #384	@ 0x180
 80265a4:	af00      	add	r7, sp, #0
 80265a6:	f507 74c0 	add.w	r4, r7, #384	@ 0x180
 80265aa:	f5a4 74ba 	sub.w	r4, r4, #372	@ 0x174
 80265ae:	6020      	str	r0, [r4, #0]
 80265b0:	f507 70c0 	add.w	r0, r7, #384	@ 0x180
 80265b4:	f5a0 70bc 	sub.w	r0, r0, #376	@ 0x178
 80265b8:	6001      	str	r1, [r0, #0]
 80265ba:	f507 71c0 	add.w	r1, r7, #384	@ 0x180
 80265be:	f5a1 71be 	sub.w	r1, r1, #380	@ 0x17c
 80265c2:	600a      	str	r2, [r1, #0]
 80265c4:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 80265c8:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 80265cc:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80265ce:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80265d2:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 80265d6:	681b      	ldr	r3, [r3, #0]
 80265d8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80265dc:	3380      	adds	r3, #128	@ 0x80
 80265de:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 80265e2:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80265e6:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 80265ea:	681b      	ldr	r3, [r3, #0]
 80265ec:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80265f0:	f507 73c0 	add.w	r3, r7, #384	@ 0x180
 80265f4:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 80265f8:	681b      	ldr	r3, [r3, #0]
 80265fa:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80265fc:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
  wsptr = workspace;
 8026600:	f107 0314 	add.w	r3, r7, #20
 8026604:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 8026608:	2308      	movs	r3, #8
 802660a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 802660e:	e238      	b.n	8026a82 <jpeg_idct_16x8+0x4e2>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8026610:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026614:	3310      	adds	r3, #16
 8026616:	f9b3 3000 	ldrsh.w	r3, [r3]
 802661a:	2b00      	cmp	r3, #0
 802661c:	d175      	bne.n	802670a <jpeg_idct_16x8+0x16a>
 802661e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026622:	3320      	adds	r3, #32
 8026624:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026628:	2b00      	cmp	r3, #0
 802662a:	d16e      	bne.n	802670a <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802662c:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026630:	3330      	adds	r3, #48	@ 0x30
 8026632:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8026636:	2b00      	cmp	r3, #0
 8026638:	d167      	bne.n	802670a <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802663a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802663e:	3340      	adds	r3, #64	@ 0x40
 8026640:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026644:	2b00      	cmp	r3, #0
 8026646:	d160      	bne.n	802670a <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8026648:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802664c:	3350      	adds	r3, #80	@ 0x50
 802664e:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8026652:	2b00      	cmp	r3, #0
 8026654:	d159      	bne.n	802670a <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8026656:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802665a:	3360      	adds	r3, #96	@ 0x60
 802665c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026660:	2b00      	cmp	r3, #0
 8026662:	d152      	bne.n	802670a <jpeg_idct_16x8+0x16a>
	inptr[DCTSIZE*7] == 0) {
 8026664:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026668:	3370      	adds	r3, #112	@ 0x70
 802666a:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802666e:	2b00      	cmp	r3, #0
 8026670:	d14b      	bne.n	802670a <jpeg_idct_16x8+0x16a>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 8026672:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026676:	f9b3 3000 	ldrsh.w	r3, [r3]
 802667a:	461a      	mov	r2, r3
 802667c:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026680:	681b      	ldr	r3, [r3, #0]
 8026682:	fb02 f303 	mul.w	r3, r2, r3
 8026686:	009b      	lsls	r3, r3, #2
 8026688:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
      
      wsptr[DCTSIZE*0] = dcval;
 802668c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026690:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8026694:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 8026696:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 802669a:	3320      	adds	r3, #32
 802669c:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266a0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 80266a2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266a6:	3340      	adds	r3, #64	@ 0x40
 80266a8:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266ac:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 80266ae:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266b2:	3360      	adds	r3, #96	@ 0x60
 80266b4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266b8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 80266ba:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266be:	3380      	adds	r3, #128	@ 0x80
 80266c0:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266c4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 80266c6:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266ca:	33a0      	adds	r3, #160	@ 0xa0
 80266cc:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266d0:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 80266d2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266d6:	33c0      	adds	r3, #192	@ 0xc0
 80266d8:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266dc:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 80266de:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80266e2:	33e0      	adds	r3, #224	@ 0xe0
 80266e4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 80266e8:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 80266ea:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 80266ee:	3302      	adds	r3, #2
 80266f0:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
      quantptr++;
 80266f4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80266f8:	3304      	adds	r3, #4
 80266fa:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
      wsptr++;
 80266fe:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026702:	3304      	adds	r3, #4
 8026704:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
      continue;
 8026708:	e1b6      	b.n	8026a78 <jpeg_idct_16x8+0x4d8>
    }
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802670a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802670e:	3320      	adds	r3, #32
 8026710:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026714:	461a      	mov	r2, r3
 8026716:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802671a:	3340      	adds	r3, #64	@ 0x40
 802671c:	681b      	ldr	r3, [r3, #0]
 802671e:	fb02 f303 	mul.w	r3, r2, r3
 8026722:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8026726:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802672a:	3360      	adds	r3, #96	@ 0x60
 802672c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026730:	461a      	mov	r2, r3
 8026732:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026736:	33c0      	adds	r3, #192	@ 0xc0
 8026738:	681b      	ldr	r3, [r3, #0]
 802673a:	fb02 f303 	mul.w	r3, r2, r3
 802673e:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8026742:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8026746:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 802674a:	4413      	add	r3, r2
 802674c:	f241 1251 	movw	r2, #4433	@ 0x1151
 8026750:	fb02 f303 	mul.w	r3, r2, r3
 8026754:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 8026758:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802675c:	f641 027e 	movw	r2, #6270	@ 0x187e
 8026760:	fb02 f303 	mul.w	r3, r2, r3
 8026764:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026768:	4413      	add	r3, r2
 802676a:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 802676e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026772:	4aca      	ldr	r2, [pc, #808]	@ (8026a9c <jpeg_idct_16x8+0x4fc>)
 8026774:	fb02 f303 	mul.w	r3, r2, r3
 8026778:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802677c:	4413      	add	r3, r2
 802677e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8026782:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026786:	f9b3 3000 	ldrsh.w	r3, [r3]
 802678a:	461a      	mov	r2, r3
 802678c:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026790:	681b      	ldr	r3, [r3, #0]
 8026792:	fb02 f303 	mul.w	r3, r2, r3
 8026796:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802679a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802679e:	3340      	adds	r3, #64	@ 0x40
 80267a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80267a4:	461a      	mov	r2, r3
 80267a6:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 80267aa:	3380      	adds	r3, #128	@ 0x80
 80267ac:	681b      	ldr	r3, [r3, #0]
 80267ae:	fb02 f303 	mul.w	r3, r2, r3
 80267b2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z2 <<= CONST_BITS;
 80267b6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80267ba:	035b      	lsls	r3, r3, #13
 80267bc:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 <<= CONST_BITS;
 80267c0:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80267c4:	035b      	lsls	r3, r3, #13
 80267c6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 80267ca:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80267ce:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80267d2:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp0 = z2 + z3;
 80267d6:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80267da:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80267de:	4413      	add	r3, r2
 80267e0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = z2 - z3;
 80267e4:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80267e8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80267ec:	1ad3      	subs	r3, r2, r3
 80267ee:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    
    tmp10 = tmp0 + tmp2;
 80267f2:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80267f6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80267fa:	4413      	add	r3, r2
 80267fc:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp13 = tmp0 - tmp2;
 8026800:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026804:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026808:	1ad3      	subs	r3, r2, r3
 802680a:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    tmp11 = tmp1 + tmp3;
 802680e:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026812:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026816:	4413      	add	r3, r2
 8026818:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = tmp1 - tmp3;
 802681c:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026820:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026824:	1ad3      	subs	r3, r2, r3
 8026826:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802682a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802682e:	3370      	adds	r3, #112	@ 0x70
 8026830:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026834:	461a      	mov	r2, r3
 8026836:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802683a:	33e0      	adds	r3, #224	@ 0xe0
 802683c:	681b      	ldr	r3, [r3, #0]
 802683e:	fb02 f303 	mul.w	r3, r2, r3
 8026842:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8026846:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802684a:	3350      	adds	r3, #80	@ 0x50
 802684c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026850:	461a      	mov	r2, r3
 8026852:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026856:	33a0      	adds	r3, #160	@ 0xa0
 8026858:	681b      	ldr	r3, [r3, #0]
 802685a:	fb02 f303 	mul.w	r3, r2, r3
 802685e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8026862:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026866:	3330      	adds	r3, #48	@ 0x30
 8026868:	f9b3 3000 	ldrsh.w	r3, [r3]
 802686c:	461a      	mov	r2, r3
 802686e:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026872:	3360      	adds	r3, #96	@ 0x60
 8026874:	681b      	ldr	r3, [r3, #0]
 8026876:	fb02 f303 	mul.w	r3, r2, r3
 802687a:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802687e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026882:	3310      	adds	r3, #16
 8026884:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026888:	461a      	mov	r2, r3
 802688a:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802688e:	3320      	adds	r3, #32
 8026890:	681b      	ldr	r3, [r3, #0]
 8026892:	fb02 f303 	mul.w	r3, r2, r3
 8026896:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    
    z2 = tmp0 + tmp2;
 802689a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802689e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80268a2:	4413      	add	r3, r2
 80268a4:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = tmp1 + tmp3;
 80268a8:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 80268ac:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80268b0:	4413      	add	r3, r2
 80268b2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 80268b6:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80268ba:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80268be:	4413      	add	r3, r2
 80268c0:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 80268c4:	fb02 f303 	mul.w	r3, r2, r3
 80268c8:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80268cc:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80268d0:	4a73      	ldr	r2, [pc, #460]	@ (8026aa0 <jpeg_idct_16x8+0x500>)
 80268d2:	fb02 f303 	mul.w	r3, r2, r3
 80268d6:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 80268da:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80268de:	4a71      	ldr	r2, [pc, #452]	@ (8026aa4 <jpeg_idct_16x8+0x504>)
 80268e0:	fb02 f303 	mul.w	r3, r2, r3
 80268e4:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z2 += z1;
 80268e8:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 80268ec:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80268f0:	4413      	add	r3, r2
 80268f2:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 += z1;
 80268f6:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 80268fa:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 80268fe:	4413      	add	r3, r2
 8026900:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 8026904:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026908:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802690c:	4413      	add	r3, r2
 802690e:	4a66      	ldr	r2, [pc, #408]	@ (8026aa8 <jpeg_idct_16x8+0x508>)
 8026910:	fb02 f303 	mul.w	r3, r2, r3
 8026914:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8026918:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802691c:	f640 128e 	movw	r2, #2446	@ 0x98e
 8026920:	fb02 f303 	mul.w	r3, r2, r3
 8026924:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8026928:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802692c:	f243 020b 	movw	r2, #12299	@ 0x300b
 8026930:	fb02 f303 	mul.w	r3, r2, r3
 8026934:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp0 += z1 + z2;
 8026938:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802693c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026940:	4413      	add	r3, r2
 8026942:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026946:	4413      	add	r3, r2
 8026948:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp3 += z1 + z3;
 802694c:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026950:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026954:	4413      	add	r3, r2
 8026956:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 802695a:	4413      	add	r3, r2
 802695c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8026960:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026964:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026968:	4413      	add	r3, r2
 802696a:	4a50      	ldr	r2, [pc, #320]	@ (8026aac <jpeg_idct_16x8+0x50c>)
 802696c:	fb02 f303 	mul.w	r3, r2, r3
 8026970:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8026974:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026978:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 802697c:	fb02 f303 	mul.w	r3, r2, r3
 8026980:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8026984:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026988:	f246 2254 	movw	r2, #25172	@ 0x6254
 802698c:	fb02 f303 	mul.w	r3, r2, r3
 8026990:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp1 += z1 + z3;
 8026994:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026998:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 802699c:	4413      	add	r3, r2
 802699e:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 80269a2:	4413      	add	r3, r2
 80269a4:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 += z1 + z2;
 80269a8:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 80269ac:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80269b0:	4413      	add	r3, r2
 80269b2:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 80269b6:	4413      	add	r3, r2
 80269b8:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 80269bc:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80269c0:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80269c4:	4413      	add	r3, r2
 80269c6:	12da      	asrs	r2, r3, #11
 80269c8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80269cc:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 80269ce:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80269d2:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80269d6:	1ad2      	subs	r2, r2, r3
 80269d8:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80269dc:	33e0      	adds	r3, #224	@ 0xe0
 80269de:	12d2      	asrs	r2, r2, #11
 80269e0:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 80269e2:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 80269e6:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80269ea:	441a      	add	r2, r3
 80269ec:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80269f0:	3320      	adds	r3, #32
 80269f2:	12d2      	asrs	r2, r2, #11
 80269f4:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 80269f6:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 80269fa:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80269fe:	1ad2      	subs	r2, r2, r3
 8026a00:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a04:	33c0      	adds	r3, #192	@ 0xc0
 8026a06:	12d2      	asrs	r2, r2, #11
 8026a08:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 8026a0a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026a0e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026a12:	441a      	add	r2, r3
 8026a14:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a18:	3340      	adds	r3, #64	@ 0x40
 8026a1a:	12d2      	asrs	r2, r2, #11
 8026a1c:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 8026a1e:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026a22:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026a26:	1ad2      	subs	r2, r2, r3
 8026a28:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a2c:	33a0      	adds	r3, #160	@ 0xa0
 8026a2e:	12d2      	asrs	r2, r2, #11
 8026a30:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 8026a32:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8026a36:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026a3a:	441a      	add	r2, r3
 8026a3c:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a40:	3360      	adds	r3, #96	@ 0x60
 8026a42:	12d2      	asrs	r2, r2, #11
 8026a44:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 8026a46:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8026a4a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026a4e:	1ad2      	subs	r2, r2, r3
 8026a50:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a54:	3380      	adds	r3, #128	@ 0x80
 8026a56:	12d2      	asrs	r2, r2, #11
 8026a58:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 8026a5a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8026a5e:	3302      	adds	r3, #2
 8026a60:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    quantptr++;
 8026a64:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 8026a68:	3304      	adds	r3, #4
 8026a6a:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
    wsptr++;
 8026a6e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026a72:	3304      	adds	r3, #4
 8026a74:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 8026a78:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8026a7c:	3b01      	subs	r3, #1
 8026a7e:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8026a82:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8026a86:	2b00      	cmp	r3, #0
 8026a88:	f73f adc2 	bgt.w	8026610 <jpeg_idct_16x8+0x70>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  wsptr = workspace;
 8026a8c:	f107 0314 	add.w	r3, r7, #20
 8026a90:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 8026a94:	2300      	movs	r3, #0
 8026a96:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 8026a9a:	e32d      	b.n	80270f8 <jpeg_idct_16x8+0xb58>
 8026a9c:	ffffc4df 	.word	0xffffc4df
 8026aa0:	ffffc13b 	.word	0xffffc13b
 8026aa4:	fffff384 	.word	0xfffff384
 8026aa8:	ffffe333 	.word	0xffffe333
 8026aac:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 8026ab0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8026ab4:	009b      	lsls	r3, r3, #2
 8026ab6:	f507 72c0 	add.w	r2, r7, #384	@ 0x180
 8026aba:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 8026abe:	6812      	ldr	r2, [r2, #0]
 8026ac0:	4413      	add	r3, r2
 8026ac2:	681a      	ldr	r2, [r3, #0]
 8026ac4:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8026ac8:	4413      	add	r3, r2
 8026aca:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8026ace:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026ad2:	681b      	ldr	r3, [r3, #0]
 8026ad4:	3310      	adds	r3, #16
 8026ad6:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp0 <<= CONST_BITS;
 8026ada:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026ade:	035b      	lsls	r3, r3, #13
 8026ae0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164

    z1 = (INT32) wsptr[4];
 8026ae4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026ae8:	3310      	adds	r3, #16
 8026aea:	681b      	ldr	r3, [r3, #0]
 8026aec:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8026af0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026af4:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8026af8:	fb02 f303 	mul.w	r3, r2, r3
 8026afc:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8026b00:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026b04:	f241 1251 	movw	r2, #4433	@ 0x1151
 8026b08:	fb02 f303 	mul.w	r3, r2, r3
 8026b0c:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    tmp10 = tmp0 + tmp1;
 8026b10:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026b14:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026b18:	4413      	add	r3, r2
 8026b1a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 = tmp0 - tmp1;
 8026b1e:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026b22:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026b26:	1ad3      	subs	r3, r2, r3
 8026b28:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = tmp0 + tmp2;
 8026b2c:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026b30:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026b34:	4413      	add	r3, r2
 8026b36:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp13 = tmp0 - tmp2;
 8026b3a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8026b3e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026b42:	1ad3      	subs	r3, r2, r3
 8026b44:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    z1 = (INT32) wsptr[2];
 8026b48:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026b4c:	3308      	adds	r3, #8
 8026b4e:	681b      	ldr	r3, [r3, #0]
 8026b50:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[6];
 8026b54:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026b58:	3318      	adds	r3, #24
 8026b5a:	681b      	ldr	r3, [r3, #0]
 8026b5c:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = z1 - z2;
 8026b60:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026b64:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026b68:	1ad3      	subs	r3, r2, r3
 8026b6a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8026b6e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026b72:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 8026b76:	fb02 f303 	mul.w	r3, r2, r3
 8026b7a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8026b7e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026b82:	f642 4263 	movw	r2, #11363	@ 0x2c63
 8026b86:	fb02 f303 	mul.w	r3, r2, r3
 8026b8a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8026b8e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026b92:	f245 2203 	movw	r2, #20995	@ 0x5203
 8026b96:	fb02 f303 	mul.w	r3, r2, r3
 8026b9a:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8026b9e:	4413      	add	r3, r2
 8026ba0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8026ba4:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026ba8:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8026bac:	fb02 f303 	mul.w	r3, r2, r3
 8026bb0:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8026bb4:	4413      	add	r3, r2
 8026bb6:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8026bba:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026bbe:	4af4      	ldr	r2, [pc, #976]	@ (8026f90 <jpeg_idct_16x8+0x9f0>)
 8026bc0:	fb02 f303 	mul.w	r3, r2, r3
 8026bc4:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8026bc8:	4413      	add	r3, r2
 8026bca:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8026bce:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026bd2:	4af0      	ldr	r2, [pc, #960]	@ (8026f94 <jpeg_idct_16x8+0x9f4>)
 8026bd4:	fb02 f303 	mul.w	r3, r2, r3
 8026bd8:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8026bdc:	4413      	add	r3, r2
 8026bde:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    tmp20 = tmp10 + tmp0;
 8026be2:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8026be6:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026bea:	4413      	add	r3, r2
 8026bec:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp27 = tmp10 - tmp0;
 8026bf0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8026bf4:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026bf8:	1ad3      	subs	r3, r2, r3
 8026bfa:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp21 = tmp12 + tmp1;
 8026bfe:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026c02:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026c06:	4413      	add	r3, r2
 8026c08:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp26 = tmp12 - tmp1;
 8026c0c:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026c10:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026c14:	1ad3      	subs	r3, r2, r3
 8026c16:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    tmp22 = tmp13 + tmp2;
 8026c1a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8026c1e:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026c22:	4413      	add	r3, r2
 8026c24:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp25 = tmp13 - tmp2;
 8026c28:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8026c2c:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026c30:	1ad3      	subs	r3, r2, r3
 8026c32:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp23 = tmp11 + tmp3;
 8026c36:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8026c3a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026c3e:	4413      	add	r3, r2
 8026c40:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp24 = tmp11 - tmp3;
 8026c44:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8026c48:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026c4c:	1ad3      	subs	r3, r2, r3
 8026c4e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8026c52:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026c56:	3304      	adds	r3, #4
 8026c58:	681b      	ldr	r3, [r3, #0]
 8026c5a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    z2 = (INT32) wsptr[3];
 8026c5e:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026c62:	330c      	adds	r3, #12
 8026c64:	681b      	ldr	r3, [r3, #0]
 8026c66:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z3 = (INT32) wsptr[5];
 8026c6a:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026c6e:	3314      	adds	r3, #20
 8026c70:	681b      	ldr	r3, [r3, #0]
 8026c72:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
    z4 = (INT32) wsptr[7];
 8026c76:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8026c7a:	331c      	adds	r3, #28
 8026c7c:	681b      	ldr	r3, [r3, #0]
 8026c7e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    tmp11 = z1 + z3;
 8026c82:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026c86:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026c8a:	4413      	add	r3, r2
 8026c8c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8026c90:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026c94:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026c98:	4413      	add	r3, r2
 8026c9a:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 8026c9e:	fb02 f303 	mul.w	r3, r2, r3
 8026ca2:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8026ca6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8026caa:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 8026cae:	fb02 f303 	mul.w	r3, r2, r3
 8026cb2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8026cb6:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026cba:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026cbe:	4413      	add	r3, r2
 8026cc0:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 8026cc4:	fb02 f303 	mul.w	r3, r2, r3
 8026cc8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8026ccc:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026cd0:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026cd4:	1ad3      	subs	r3, r2, r3
 8026cd6:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 8026cda:	fb02 f303 	mul.w	r3, r2, r3
 8026cde:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8026ce2:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8026ce6:	f241 5255 	movw	r2, #5461	@ 0x1555
 8026cea:	fb02 f303 	mul.w	r3, r2, r3
 8026cee:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8026cf2:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 8026cf6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026cfa:	1ad3      	subs	r3, r2, r3
 8026cfc:	f640 5223 	movw	r2, #3363	@ 0xd23
 8026d00:	fb02 f303 	mul.w	r3, r2, r3
 8026d04:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp0  = tmp1 + tmp2 + tmp3 -
 8026d08:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026d0c:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026d10:	441a      	add	r2, r3
 8026d12:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026d16:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8026d18:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026d1c:	499e      	ldr	r1, [pc, #632]	@ (8026f98 <jpeg_idct_16x8+0x9f8>)
 8026d1e:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 8026d22:	4413      	add	r3, r2
 8026d24:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp13 = tmp10 + tmp11 + tmp12 -
 8026d28:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8026d2c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8026d30:	441a      	add	r2, r3
 8026d32:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8026d36:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8026d38:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026d3c:	4997      	ldr	r1, [pc, #604]	@ (8026f9c <jpeg_idct_16x8+0x9fc>)
 8026d3e:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 8026d42:	4413      	add	r3, r2
 8026d44:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8026d48:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8026d4c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026d50:	4413      	add	r3, r2
 8026d52:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 8026d56:	fb02 f303 	mul.w	r3, r2, r3
 8026d5a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8026d5e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026d62:	f240 224d 	movw	r2, #589	@ 0x24d
 8026d66:	fb03 f202 	mul.w	r2, r3, r2
 8026d6a:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026d6e:	4413      	add	r3, r2
 8026d70:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026d74:	4413      	add	r3, r2
 8026d76:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8026d7a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026d7e:	4a88      	ldr	r2, [pc, #544]	@ (8026fa0 <jpeg_idct_16x8+0xa00>)
 8026d80:	fb03 f202 	mul.w	r2, r3, r2
 8026d84:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026d88:	4413      	add	r3, r2
 8026d8a:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8026d8e:	4413      	add	r3, r2
 8026d90:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 8026d94:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8026d98:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026d9c:	1ad3      	subs	r3, r2, r3
 8026d9e:	f642 5209 	movw	r2, #11529	@ 0x2d09
 8026da2:	fb02 f303 	mul.w	r3, r2, r3
 8026da6:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8026daa:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026dae:	4a7d      	ldr	r2, [pc, #500]	@ (8026fa4 <jpeg_idct_16x8+0xa04>)
 8026db0:	fb03 f202 	mul.w	r2, r3, r2
 8026db4:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026db8:	4413      	add	r3, r2
 8026dba:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8026dbe:	4413      	add	r3, r2
 8026dc0:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 8026dc4:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026dc8:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 8026dcc:	fb03 f202 	mul.w	r2, r3, r2
 8026dd0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026dd4:	4413      	add	r3, r2
 8026dd6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026dda:	4413      	add	r3, r2
 8026ddc:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z2    += z4;
 8026de0:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8026de4:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026de8:	4413      	add	r3, r2
 8026dea:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 8026dee:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026df2:	4a6d      	ldr	r2, [pc, #436]	@ (8026fa8 <jpeg_idct_16x8+0xa08>)
 8026df4:	fb02 f303 	mul.w	r3, r2, r3
 8026df8:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp1  += z1;
 8026dfc:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8026e00:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026e04:	4413      	add	r3, r2
 8026e06:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8026e0a:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026e0e:	f242 2218 	movw	r2, #8728	@ 0x2218
 8026e12:	fb03 f202 	mul.w	r2, r3, r2
 8026e16:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8026e1a:	4413      	add	r3, r2
 8026e1c:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8026e20:	4413      	add	r3, r2
 8026e22:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8026e26:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026e2a:	4a60      	ldr	r2, [pc, #384]	@ (8026fac <jpeg_idct_16x8+0xa0c>)
 8026e2c:	fb02 f303 	mul.w	r3, r2, r3
 8026e30:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 8026e34:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026e38:	f246 4285 	movw	r2, #25733	@ 0x6485
 8026e3c:	fb03 f202 	mul.w	r2, r3, r2
 8026e40:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026e44:	4413      	add	r3, r2
 8026e46:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8026e4a:	4413      	add	r3, r2
 8026e4c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp12 += z2;
 8026e50:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8026e54:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026e58:	4413      	add	r3, r2
 8026e5a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8026e5e:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 8026e62:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8026e66:	4413      	add	r3, r2
 8026e68:	4a51      	ldr	r2, [pc, #324]	@ (8026fb0 <jpeg_idct_16x8+0xa10>)
 8026e6a:	fb02 f303 	mul.w	r3, r2, r3
 8026e6e:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp2  += z2;
 8026e72:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8026e76:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026e7a:	4413      	add	r3, r2
 8026e7c:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp3  += z2;
 8026e80:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8026e84:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026e88:	4413      	add	r3, r2
 8026e8a:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8026e8e:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8026e92:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8026e96:	1ad3      	subs	r3, r2, r3
 8026e98:	f640 5223 	movw	r2, #3363	@ 0xd23
 8026e9c:	fb02 f303 	mul.w	r3, r2, r3
 8026ea0:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
    tmp10 += z2;
 8026ea4:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 8026ea8:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026eac:	4413      	add	r3, r2
 8026eae:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    tmp11 += z2;
 8026eb2:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8026eb6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8026eba:	4413      	add	r3, r2
 8026ebc:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8026ec0:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8026ec4:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026ec8:	4413      	add	r3, r2
 8026eca:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026ecc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 8026ed0:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026ed4:	4413      	add	r3, r2
 8026ed6:	781a      	ldrb	r2, [r3, #0]
 8026ed8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026edc:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8026ede:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8026ee2:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8026ee6:	1ad3      	subs	r3, r2, r3
 8026ee8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026eea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 8026eee:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026ef2:	441a      	add	r2, r3
 8026ef4:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026ef8:	330f      	adds	r3, #15
 8026efa:	7812      	ldrb	r2, [r2, #0]
 8026efc:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8026efe:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8026f02:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026f06:	4413      	add	r3, r2
 8026f08:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026f0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 8026f0e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026f12:	441a      	add	r2, r3
 8026f14:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026f18:	3301      	adds	r3, #1
 8026f1a:	7812      	ldrb	r2, [r2, #0]
 8026f1c:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8026f1e:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8026f22:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 8026f26:	1ad3      	subs	r3, r2, r3
 8026f28:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026f2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 8026f2e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026f32:	441a      	add	r2, r3
 8026f34:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026f38:	330e      	adds	r3, #14
 8026f3a:	7812      	ldrb	r2, [r2, #0]
 8026f3c:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8026f3e:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8026f42:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026f46:	4413      	add	r3, r2
 8026f48:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026f4a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 8026f4e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026f52:	441a      	add	r2, r3
 8026f54:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026f58:	3302      	adds	r3, #2
 8026f5a:	7812      	ldrb	r2, [r2, #0]
 8026f5c:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8026f5e:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8026f62:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 8026f66:	1ad3      	subs	r3, r2, r3
 8026f68:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026f6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 8026f6e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026f72:	441a      	add	r2, r3
 8026f74:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026f78:	330d      	adds	r3, #13
 8026f7a:	7812      	ldrb	r2, [r2, #0]
 8026f7c:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8026f7e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8026f82:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026f86:	4413      	add	r3, r2
 8026f88:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026f8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8026f8e:	e011      	b.n	8026fb4 <jpeg_idct_16x8+0xa14>
 8026f90:	ffffecc2 	.word	0xffffecc2
 8026f94:	ffffefb0 	.word	0xffffefb0
 8026f98:	ffffb6d6 	.word	0xffffb6d6
 8026f9c:	ffffc542 	.word	0xffffc542
 8026fa0:	ffffdbfa 	.word	0xffffdbfa
 8026fa4:	ffffe77a 	.word	0xffffe77a
 8026fa8:	ffffeaab 	.word	0xffffeaab
 8026fac:	ffffd817 	.word	0xffffd817
 8026fb0:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 8026fb4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026fb8:	441a      	add	r2, r3
 8026fba:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026fbe:	3303      	adds	r3, #3
 8026fc0:	7812      	ldrb	r2, [r2, #0]
 8026fc2:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8026fc4:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8026fc8:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8026fcc:	1ad3      	subs	r3, r2, r3
 8026fce:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026fd0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 8026fd4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026fd8:	441a      	add	r2, r3
 8026fda:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026fde:	330c      	adds	r3, #12
 8026fe0:	7812      	ldrb	r2, [r2, #0]
 8026fe2:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8026fe4:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8026fe8:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8026fec:	4413      	add	r3, r2
 8026fee:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8026ff0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 8026ff4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8026ff8:	441a      	add	r2, r3
 8026ffa:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 8026ffe:	3304      	adds	r3, #4
 8027000:	7812      	ldrb	r2, [r2, #0]
 8027002:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 8027004:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8027008:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802700c:	1ad3      	subs	r3, r2, r3
 802700e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027010:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 8027014:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8027018:	441a      	add	r2, r3
 802701a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802701e:	330b      	adds	r3, #11
 8027020:	7812      	ldrb	r2, [r2, #0]
 8027022:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 8027024:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8027028:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802702c:	4413      	add	r3, r2
 802702e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027030:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 8027034:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8027038:	441a      	add	r2, r3
 802703a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802703e:	3305      	adds	r3, #5
 8027040:	7812      	ldrb	r2, [r2, #0]
 8027042:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 8027044:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8027048:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802704c:	1ad3      	subs	r3, r2, r3
 802704e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027050:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 8027054:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8027058:	441a      	add	r2, r3
 802705a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802705e:	330a      	adds	r3, #10
 8027060:	7812      	ldrb	r2, [r2, #0]
 8027062:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8027064:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8027068:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802706c:	4413      	add	r3, r2
 802706e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027070:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 8027074:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8027078:	441a      	add	r2, r3
 802707a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802707e:	3306      	adds	r3, #6
 8027080:	7812      	ldrb	r2, [r2, #0]
 8027082:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8027084:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8027088:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802708c:	1ad3      	subs	r3, r2, r3
 802708e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027090:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 8027094:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 8027098:	441a      	add	r2, r3
 802709a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802709e:	3309      	adds	r3, #9
 80270a0:	7812      	ldrb	r2, [r2, #0]
 80270a2:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 80270a4:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80270a8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80270ac:	4413      	add	r3, r2
 80270ae:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80270b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 80270b4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80270b8:	441a      	add	r2, r3
 80270ba:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80270be:	3307      	adds	r3, #7
 80270c0:	7812      	ldrb	r2, [r2, #0]
 80270c2:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 80270c4:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80270c8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80270cc:	1ad3      	subs	r3, r2, r3
 80270ce:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80270d0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 80270d4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 80270d8:	441a      	add	r2, r3
 80270da:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 80270de:	3308      	adds	r3, #8
 80270e0:	7812      	ldrb	r2, [r2, #0]
 80270e2:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80270e4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 80270e8:	3320      	adds	r3, #32
 80270ea:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 80270ee:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80270f2:	3301      	adds	r3, #1
 80270f4:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
 80270f8:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 80270fc:	2b07      	cmp	r3, #7
 80270fe:	f77f acd7 	ble.w	8026ab0 <jpeg_idct_16x8+0x510>
  }
}
 8027102:	bf00      	nop
 8027104:	bf00      	nop
 8027106:	f507 77c0 	add.w	r7, r7, #384	@ 0x180
 802710a:	46bd      	mov	sp, r7
 802710c:	bc90      	pop	{r4, r7}
 802710e:	4770      	bx	lr

08027110 <jpeg_idct_14x7>:

GLOBAL(void)
jpeg_idct_14x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8027110:	b490      	push	{r4, r7}
 8027112:	b0d4      	sub	sp, #336	@ 0x150
 8027114:	af00      	add	r7, sp, #0
 8027116:	f507 74a8 	add.w	r4, r7, #336	@ 0x150
 802711a:	f5a4 74a2 	sub.w	r4, r4, #324	@ 0x144
 802711e:	6020      	str	r0, [r4, #0]
 8027120:	f507 70a8 	add.w	r0, r7, #336	@ 0x150
 8027124:	f5a0 70a4 	sub.w	r0, r0, #328	@ 0x148
 8027128:	6001      	str	r1, [r0, #0]
 802712a:	f507 71a8 	add.w	r1, r7, #336	@ 0x150
 802712e:	f5a1 71a6 	sub.w	r1, r1, #332	@ 0x14c
 8027132:	600a      	str	r2, [r1, #0]
 8027134:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 8027138:	f5a2 72a8 	sub.w	r2, r2, #336	@ 0x150
 802713c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802713e:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8027142:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8027146:	681b      	ldr	r3, [r3, #0]
 8027148:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802714c:	3380      	adds	r3, #128	@ 0x80
 802714e:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  inptr = coef_block;
 8027152:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8027156:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 802715a:	681b      	ldr	r3, [r3, #0]
 802715c:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8027160:	f507 73a8 	add.w	r3, r7, #336	@ 0x150
 8027164:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 8027168:	681b      	ldr	r3, [r3, #0]
 802716a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802716c:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
  wsptr = workspace;
 8027170:	f107 0310 	add.w	r3, r7, #16
 8027174:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8027178:	2300      	movs	r3, #0
 802717a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 802717e:	e17a      	b.n	8027476 <jpeg_idct_14x7+0x366>
    /* Even part */

    tmp23 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8027180:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8027184:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027188:	461a      	mov	r2, r3
 802718a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802718e:	681b      	ldr	r3, [r3, #0]
 8027190:	fb02 f303 	mul.w	r3, r2, r3
 8027194:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    tmp23 <<= CONST_BITS;
 8027198:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802719c:	035b      	lsls	r3, r3, #13
 802719e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
    /* Add fudge factor here for final descale. */
    tmp23 += ONE << (CONST_BITS-PASS1_BITS-1);
 80271a2:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 80271a6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80271aa:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80271ae:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80271b2:	3320      	adds	r3, #32
 80271b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80271b8:	461a      	mov	r2, r3
 80271ba:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80271be:	3340      	adds	r3, #64	@ 0x40
 80271c0:	681b      	ldr	r3, [r3, #0]
 80271c2:	fb02 f303 	mul.w	r3, r2, r3
 80271c6:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80271ca:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80271ce:	3340      	adds	r3, #64	@ 0x40
 80271d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80271d4:	461a      	mov	r2, r3
 80271d6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80271da:	3380      	adds	r3, #128	@ 0x80
 80271dc:	681b      	ldr	r3, [r3, #0]
 80271de:	fb02 f303 	mul.w	r3, r2, r3
 80271e2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80271e6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80271ea:	3360      	adds	r3, #96	@ 0x60
 80271ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 80271f0:	461a      	mov	r2, r3
 80271f2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80271f6:	33c0      	adds	r3, #192	@ 0xc0
 80271f8:	681b      	ldr	r3, [r3, #0]
 80271fa:	fb02 f303 	mul.w	r3, r2, r3
 80271fe:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 8027202:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8027206:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802720a:	1ad3      	subs	r3, r2, r3
 802720c:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8027210:	fb02 f303 	mul.w	r3, r2, r3
 8027214:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 8027218:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802721c:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027220:	1ad3      	subs	r3, r2, r3
 8027222:	f640 2212 	movw	r2, #2578	@ 0xa12
 8027226:	fb02 f303 	mul.w	r3, r2, r3
 802722a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 802722e:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8027232:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027236:	441a      	add	r2, r3
 8027238:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802723c:	441a      	add	r2, r3
 802723e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027242:	4993      	ldr	r1, [pc, #588]	@ (8027490 <jpeg_idct_14x7+0x380>)
 8027244:	fb01 f303 	mul.w	r3, r1, r3
 8027248:	4413      	add	r3, r2
 802724a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = z1 + z3;
 802724e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8027252:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027256:	4413      	add	r3, r2
 8027258:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    z2 -= tmp10;
 802725c:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8027260:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027264:	1ad3      	subs	r3, r2, r3
 8027266:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 802726a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802726e:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8027272:	fb02 f303 	mul.w	r3, r2, r3
 8027276:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 802727a:	4413      	add	r3, r2
 802727c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 8027280:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027284:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 8027288:	fb03 f202 	mul.w	r2, r3, r2
 802728c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027290:	4413      	add	r3, r2
 8027292:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8027296:	4413      	add	r3, r2
 8027298:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 802729c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80272a0:	4a7c      	ldr	r2, [pc, #496]	@ (8027494 <jpeg_idct_14x7+0x384>)
 80272a2:	fb03 f202 	mul.w	r2, r3, r2
 80272a6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80272aa:	4413      	add	r3, r2
 80272ac:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80272b0:	4413      	add	r3, r2
 80272b2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 80272b6:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80272ba:	f642 5241 	movw	r2, #11585	@ 0x2d41
 80272be:	fb02 f303 	mul.w	r3, r2, r3
 80272c2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 80272c6:	4413      	add	r3, r2
 80272c8:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80272cc:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80272d0:	3310      	adds	r3, #16
 80272d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80272d6:	461a      	mov	r2, r3
 80272d8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80272dc:	3320      	adds	r3, #32
 80272de:	681b      	ldr	r3, [r3, #0]
 80272e0:	fb02 f303 	mul.w	r3, r2, r3
 80272e4:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80272e8:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 80272ec:	3330      	adds	r3, #48	@ 0x30
 80272ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80272f2:	461a      	mov	r2, r3
 80272f4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80272f8:	3360      	adds	r3, #96	@ 0x60
 80272fa:	681b      	ldr	r3, [r3, #0]
 80272fc:	fb02 f303 	mul.w	r3, r2, r3
 8027300:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8027304:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8027308:	3350      	adds	r3, #80	@ 0x50
 802730a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802730e:	461a      	mov	r2, r3
 8027310:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8027314:	33a0      	adds	r3, #160	@ 0xa0
 8027316:	681b      	ldr	r3, [r3, #0]
 8027318:	fb02 f303 	mul.w	r3, r2, r3
 802731c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 8027320:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8027324:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027328:	4413      	add	r3, r2
 802732a:	f641 52ef 	movw	r2, #7663	@ 0x1def
 802732e:	fb02 f303 	mul.w	r3, r2, r3
 8027332:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 8027336:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802733a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802733e:	1ad3      	subs	r3, r2, r3
 8027340:	f240 5273 	movw	r2, #1395	@ 0x573
 8027344:	fb02 f303 	mul.w	r3, r2, r3
 8027348:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp10 = tmp11 - tmp12;
 802734c:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8027350:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027354:	1ad3      	subs	r3, r2, r3
 8027356:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp11 += tmp12;
 802735a:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 802735e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027362:	4413      	add	r3, r2
 8027364:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 8027368:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 802736c:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027370:	4413      	add	r3, r2
 8027372:	4a49      	ldr	r2, [pc, #292]	@ (8027498 <jpeg_idct_14x7+0x388>)
 8027374:	fb02 f303 	mul.w	r3, r2, r3
 8027378:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp11 += tmp12;
 802737c:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8027380:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027384:	4413      	add	r3, r2
 8027386:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 802738a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802738e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027392:	4413      	add	r3, r2
 8027394:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8027398:	fb02 f303 	mul.w	r3, r2, r3
 802739c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    tmp10 += z2;
 80273a0:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80273a4:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80273a8:	4413      	add	r3, r2
 80273aa:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 80273ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80273b2:	f643 32de 	movw	r2, #15326	@ 0x3bde
 80273b6:	fb03 f202 	mul.w	r2, r3, r2
 80273ba:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80273be:	4413      	add	r3, r2
 80273c0:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 80273c4:	4413      	add	r3, r2
 80273c6:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80273ca:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80273ce:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80273d2:	4413      	add	r3, r2
 80273d4:	12da      	asrs	r2, r3, #11
 80273d6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80273da:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80273dc:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80273e0:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80273e4:	1ad2      	subs	r2, r2, r3
 80273e6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80273ea:	33c0      	adds	r3, #192	@ 0xc0
 80273ec:	12d2      	asrs	r2, r2, #11
 80273ee:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80273f0:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 80273f4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80273f8:	441a      	add	r2, r3
 80273fa:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80273fe:	3320      	adds	r3, #32
 8027400:	12d2      	asrs	r2, r2, #11
 8027402:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8027404:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027408:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802740c:	1ad2      	subs	r2, r2, r3
 802740e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027412:	33a0      	adds	r3, #160	@ 0xa0
 8027414:	12d2      	asrs	r2, r2, #11
 8027416:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8027418:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802741c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027420:	441a      	add	r2, r3
 8027422:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027426:	3340      	adds	r3, #64	@ 0x40
 8027428:	12d2      	asrs	r2, r2, #11
 802742a:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802742c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8027430:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027434:	1ad2      	subs	r2, r2, r3
 8027436:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802743a:	3380      	adds	r3, #128	@ 0x80
 802743c:	12d2      	asrs	r2, r2, #11
 802743e:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23, CONST_BITS-PASS1_BITS);
 8027440:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027444:	3360      	adds	r3, #96	@ 0x60
 8027446:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 802744a:	12d2      	asrs	r2, r2, #11
 802744c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802744e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8027452:	3301      	adds	r3, #1
 8027454:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8027458:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802745c:	3302      	adds	r3, #2
 802745e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
 8027462:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8027466:	3304      	adds	r3, #4
 8027468:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
 802746c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027470:	3304      	adds	r3, #4
 8027472:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
 8027476:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 802747a:	2b07      	cmp	r3, #7
 802747c:	f77f ae80 	ble.w	8027180 <jpeg_idct_14x7+0x70>
  }

  /* Pass 2: process 7 rows from work array, store into output array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  wsptr = workspace;
 8027480:	f107 0310 	add.w	r3, r7, #16
 8027484:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 8027488:	2300      	movs	r3, #0
 802748a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 802748e:	e28b      	b.n	80279a8 <jpeg_idct_14x7+0x898>
 8027490:	ffffc515 	.word	0xffffc515
 8027494:	ffffb0f1 	.word	0xffffb0f1
 8027498:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 802749c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80274a0:	009b      	lsls	r3, r3, #2
 80274a2:	f507 72a8 	add.w	r2, r7, #336	@ 0x150
 80274a6:	f5a2 72a8 	sub.w	r2, r2, #336	@ 0x150
 80274aa:	6812      	ldr	r2, [r2, #0]
 80274ac:	4413      	add	r3, r2
 80274ae:	681a      	ldr	r2, [r3, #0]
 80274b0:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 80274b4:	4413      	add	r3, r2
 80274b6:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80274ba:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80274be:	681b      	ldr	r3, [r3, #0]
 80274c0:	3310      	adds	r3, #16
 80274c2:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z1 <<= CONST_BITS;
 80274c6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80274ca:	035b      	lsls	r3, r3, #13
 80274cc:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z4 = (INT32) wsptr[4];
 80274d0:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80274d4:	3310      	adds	r3, #16
 80274d6:	681b      	ldr	r3, [r3, #0]
 80274d8:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 80274dc:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80274e0:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 80274e4:	fb02 f303 	mul.w	r3, r2, r3
 80274e8:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 80274ec:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80274f0:	f640 2212 	movw	r2, #2578	@ 0xa12
 80274f4:	fb02 f303 	mul.w	r3, r2, r3
 80274f8:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80274fc:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027500:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8027504:	fb02 f303 	mul.w	r3, r2, r3
 8027508:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    tmp10 = z1 + z2;
 802750c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8027510:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027514:	4413      	add	r3, r2
 8027516:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp11 = z1 + z3;
 802751a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802751e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027522:	4413      	add	r3, r2
 8027524:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = z1 - z4;
 8027528:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802752c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027530:	1ad3      	subs	r3, r2, r3
 8027532:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 8027536:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 802753a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802753e:	441a      	add	r2, r3
 8027540:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027544:	1ad3      	subs	r3, r2, r3
 8027546:	005b      	lsls	r3, r3, #1
 8027548:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802754c:	1ad3      	subs	r3, r2, r3
 802754e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    z1 = (INT32) wsptr[2];
 8027552:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027556:	3308      	adds	r3, #8
 8027558:	681b      	ldr	r3, [r3, #0]
 802755a:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = (INT32) wsptr[6];
 802755e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027562:	3318      	adds	r3, #24
 8027564:	681b      	ldr	r3, [r3, #0]
 8027566:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 802756a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802756e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027572:	4413      	add	r3, r2
 8027574:	f242 3262 	movw	r2, #9058	@ 0x2362
 8027578:	fb02 f303 	mul.w	r3, r2, r3
 802757c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8027580:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 8027584:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 8027588:	fb02 f303 	mul.w	r3, r2, r3
 802758c:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8027590:	4413      	add	r3, r2
 8027592:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8027596:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802759a:	4af2      	ldr	r2, [pc, #968]	@ (8027964 <jpeg_idct_14x7+0x854>)
 802759c:	fb02 f303 	mul.w	r3, r2, r3
 80275a0:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80275a4:	4413      	add	r3, r2
 80275a6:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80275aa:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80275ae:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 80275b2:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 80275b6:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80275ba:	49eb      	ldr	r1, [pc, #940]	@ (8027968 <jpeg_idct_14x7+0x858>)
 80275bc:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 80275c0:	4413      	add	r3, r2
 80275c2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    tmp20 = tmp10 + tmp13;
 80275c6:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80275ca:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80275ce:	4413      	add	r3, r2
 80275d0:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp26 = tmp10 - tmp13;
 80275d4:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80275d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80275dc:	1ad3      	subs	r3, r2, r3
 80275de:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp21 = tmp11 + tmp14;
 80275e2:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80275e6:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80275ea:	4413      	add	r3, r2
 80275ec:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp25 = tmp11 - tmp14;
 80275f0:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80275f4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80275f8:	1ad3      	subs	r3, r2, r3
 80275fa:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp22 = tmp12 + tmp15;
 80275fe:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8027602:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027606:	4413      	add	r3, r2
 8027608:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp24 = tmp12 - tmp15;
 802760c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8027610:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027614:	1ad3      	subs	r3, r2, r3
 8027616:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802761a:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802761e:	3304      	adds	r3, #4
 8027620:	681b      	ldr	r3, [r3, #0]
 8027622:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    z2 = (INT32) wsptr[3];
 8027626:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 802762a:	330c      	adds	r3, #12
 802762c:	681b      	ldr	r3, [r3, #0]
 802762e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
    z3 = (INT32) wsptr[5];
 8027632:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027636:	3314      	adds	r3, #20
 8027638:	681b      	ldr	r3, [r3, #0]
 802763a:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    z4 = (INT32) wsptr[7];
 802763e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027642:	331c      	adds	r3, #28
 8027644:	681b      	ldr	r3, [r3, #0]
 8027646:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    z4 <<= CONST_BITS;
 802764a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802764e:	035b      	lsls	r3, r3, #13
 8027650:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130

    tmp14 = z1 + z3;
 8027654:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8027658:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802765c:	4413      	add	r3, r2
 802765e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8027662:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8027666:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802766a:	4413      	add	r3, r2
 802766c:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8027670:	fb02 f303 	mul.w	r3, r2, r3
 8027674:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 8027678:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802767c:	f242 6252 	movw	r2, #9810	@ 0x2652
 8027680:	fb02 f303 	mul.w	r3, r2, r3
 8027684:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 8027688:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 802768c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027690:	441a      	add	r2, r3
 8027692:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027696:	441a      	add	r2, r3
 8027698:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 802769c:	49b3      	ldr	r1, [pc, #716]	@ (802796c <jpeg_idct_14x7+0x85c>)
 802769e:	fb01 f303 	mul.w	r3, r1, r3
 80276a2:	4413      	add	r3, r2
 80276a4:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80276a8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80276ac:	f641 0214 	movw	r2, #6164	@ 0x1814
 80276b0:	fb02 f303 	mul.w	r3, r2, r3
 80276b4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80276b8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80276bc:	4aac      	ldr	r2, [pc, #688]	@ (8027970 <jpeg_idct_14x7+0x860>)
 80276be:	fb02 f303 	mul.w	r3, r2, r3
 80276c2:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 80276c6:	4413      	add	r3, r2
 80276c8:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    z1    -= z2;
 80276cc:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80276d0:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 80276d4:	1ad3      	subs	r3, r2, r3
 80276d6:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 80276da:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 80276de:	f640 62f2 	movw	r2, #3826	@ 0xef2
 80276e2:	fb03 f202 	mul.w	r2, r3, r2
 80276e6:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 80276ea:	1ad3      	subs	r3, r2, r3
 80276ec:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp16 += tmp15;
 80276f0:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 80276f4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80276f8:	4413      	add	r3, r2
 80276fa:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 80276fe:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 8027702:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027706:	4413      	add	r3, r2
 8027708:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 802770c:	fb03 f202 	mul.w	r2, r3, r2
 8027710:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027714:	1ad3      	subs	r3, r2, r3
 8027716:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 802771a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802771e:	4a95      	ldr	r2, [pc, #596]	@ (8027974 <jpeg_idct_14x7+0x864>)
 8027720:	fb03 f202 	mul.w	r2, r3, r2
 8027724:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8027728:	4413      	add	r3, r2
 802772a:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 802772e:	4413      	add	r3, r2
 8027730:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 8027734:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027738:	4a8f      	ldr	r2, [pc, #572]	@ (8027978 <jpeg_idct_14x7+0x868>)
 802773a:	fb03 f202 	mul.w	r2, r3, r2
 802773e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8027742:	4413      	add	r3, r2
 8027744:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8027748:	4413      	add	r3, r2
 802774a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 802774e:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8027752:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027756:	1ad3      	subs	r3, r2, r3
 8027758:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 802775c:	fb02 f303 	mul.w	r3, r2, r3
 8027760:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8027764:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027768:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802776c:	441a      	add	r2, r3
 802776e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 8027772:	4982      	ldr	r1, [pc, #520]	@ (802797c <jpeg_idct_14x7+0x86c>)
 8027774:	fb01 f303 	mul.w	r3, r1, r3
 8027778:	4413      	add	r3, r2
 802777a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 802777e:	4413      	add	r3, r2
 8027780:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 8027784:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 8027788:	f241 5299 	movw	r2, #5529	@ 0x1599
 802778c:	fb03 f202 	mul.w	r2, r3, r2
 8027790:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8027794:	4413      	add	r3, r2
 8027796:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 802779a:	4413      	add	r3, r2
 802779c:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 80277a0:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 80277a4:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 80277a8:	1ad3      	subs	r3, r2, r3
 80277aa:	035b      	lsls	r3, r3, #13
 80277ac:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 80277b0:	4413      	add	r3, r2
 80277b2:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80277b6:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80277ba:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80277be:	4413      	add	r3, r2
 80277c0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80277c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80277c6:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80277ca:	4413      	add	r3, r2
 80277cc:	781a      	ldrb	r2, [r3, #0]
 80277ce:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80277d2:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80277d4:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 80277d8:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 80277dc:	1ad3      	subs	r3, r2, r3
 80277de:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80277e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80277e4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80277e8:	441a      	add	r2, r3
 80277ea:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80277ee:	330d      	adds	r3, #13
 80277f0:	7812      	ldrb	r2, [r2, #0]
 80277f2:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80277f4:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 80277f8:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80277fc:	4413      	add	r3, r2
 80277fe:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027800:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8027804:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027808:	441a      	add	r2, r3
 802780a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802780e:	3301      	adds	r3, #1
 8027810:	7812      	ldrb	r2, [r2, #0]
 8027812:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027814:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027818:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802781c:	1ad3      	subs	r3, r2, r3
 802781e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027820:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027824:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027828:	441a      	add	r2, r3
 802782a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802782e:	330c      	adds	r3, #12
 8027830:	7812      	ldrb	r2, [r2, #0]
 8027832:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027834:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8027838:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 802783c:	4413      	add	r3, r2
 802783e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027840:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027844:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027848:	441a      	add	r2, r3
 802784a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802784e:	3302      	adds	r3, #2
 8027850:	7812      	ldrb	r2, [r2, #0]
 8027852:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027854:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8027858:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 802785c:	1ad3      	subs	r3, r2, r3
 802785e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027860:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027864:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027868:	441a      	add	r2, r3
 802786a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802786e:	330b      	adds	r3, #11
 8027870:	7812      	ldrb	r2, [r2, #0]
 8027872:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8027874:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8027878:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802787c:	4413      	add	r3, r2
 802787e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027880:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8027884:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027888:	441a      	add	r2, r3
 802788a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802788e:	3303      	adds	r3, #3
 8027890:	7812      	ldrb	r2, [r2, #0]
 8027892:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8027894:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8027898:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802789c:	1ad3      	subs	r3, r2, r3
 802789e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80278a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 80278a4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80278a8:	441a      	add	r2, r3
 80278aa:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80278ae:	330a      	adds	r3, #10
 80278b0:	7812      	ldrb	r2, [r2, #0]
 80278b2:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80278b4:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80278b8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80278bc:	4413      	add	r3, r2
 80278be:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80278c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80278c4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80278c8:	441a      	add	r2, r3
 80278ca:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80278ce:	3304      	adds	r3, #4
 80278d0:	7812      	ldrb	r2, [r2, #0]
 80278d2:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80278d4:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80278d8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 80278dc:	1ad3      	subs	r3, r2, r3
 80278de:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80278e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80278e4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 80278e8:	441a      	add	r2, r3
 80278ea:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80278ee:	3309      	adds	r3, #9
 80278f0:	7812      	ldrb	r2, [r2, #0]
 80278f2:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80278f4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80278f8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 80278fc:	4413      	add	r3, r2
 80278fe:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027900:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8027904:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027908:	441a      	add	r2, r3
 802790a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802790e:	3305      	adds	r3, #5
 8027910:	7812      	ldrb	r2, [r2, #0]
 8027912:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8027914:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027918:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802791c:	1ad3      	subs	r3, r2, r3
 802791e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027920:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8027924:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027928:	441a      	add	r2, r3
 802792a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802792e:	3308      	adds	r3, #8
 8027930:	7812      	ldrb	r2, [r2, #0]
 8027932:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8027934:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027938:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 802793c:	4413      	add	r3, r2
 802793e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027940:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 8027944:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027948:	441a      	add	r2, r3
 802794a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802794e:	3306      	adds	r3, #6
 8027950:	7812      	ldrb	r2, [r2, #0]
 8027952:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8027954:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027958:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 802795c:	1ad3      	subs	r3, r2, r3
 802795e:	149b      	asrs	r3, r3, #18
 8027960:	e00e      	b.n	8027980 <jpeg_idct_14x7+0x870>
 8027962:	bf00      	nop
 8027964:	ffffc8fc 	.word	0xffffc8fc
 8027968:	ffffd3e1 	.word	0xffffd3e1
 802796c:	ffffdbf0 	.word	0xffffdbf0
 8027970:	ffffde0b 	.word	0xffffde0b
 8027974:	fffff26e 	.word	0xfffff26e
 8027978:	ffffb409 	.word	0xffffb409
 802797c:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027980:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8027984:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 8027988:	441a      	add	r2, r3
 802798a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802798e:	3307      	adds	r3, #7
 8027990:	7812      	ldrb	r2, [r2, #0]
 8027992:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8027994:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 8027998:	3320      	adds	r3, #32
 802799a:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 802799e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80279a2:	3301      	adds	r3, #1
 80279a4:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 80279a8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 80279ac:	2b06      	cmp	r3, #6
 80279ae:	f77f ad75 	ble.w	802749c <jpeg_idct_14x7+0x38c>
  }
}
 80279b2:	bf00      	nop
 80279b4:	bf00      	nop
 80279b6:	f507 77a8 	add.w	r7, r7, #336	@ 0x150
 80279ba:	46bd      	mov	sp, r7
 80279bc:	bc90      	pop	{r4, r7}
 80279be:	4770      	bx	lr

080279c0 <jpeg_idct_12x6>:

GLOBAL(void)
jpeg_idct_12x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80279c0:	b490      	push	{r4, r7}
 80279c2:	b0ca      	sub	sp, #296	@ 0x128
 80279c4:	af00      	add	r7, sp, #0
 80279c6:	f507 7494 	add.w	r4, r7, #296	@ 0x128
 80279ca:	f5a4 748e 	sub.w	r4, r4, #284	@ 0x11c
 80279ce:	6020      	str	r0, [r4, #0]
 80279d0:	f507 7094 	add.w	r0, r7, #296	@ 0x128
 80279d4:	f5a0 7090 	sub.w	r0, r0, #288	@ 0x120
 80279d8:	6001      	str	r1, [r0, #0]
 80279da:	f507 7194 	add.w	r1, r7, #296	@ 0x128
 80279de:	f5a1 7192 	sub.w	r1, r1, #292	@ 0x124
 80279e2:	600a      	str	r2, [r1, #0]
 80279e4:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 80279e8:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 80279ec:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80279ee:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80279f2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80279f6:	681b      	ldr	r3, [r3, #0]
 80279f8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80279fc:	3380      	adds	r3, #128	@ 0x80
 80279fe:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 8027a02:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8027a06:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8027a0a:	681b      	ldr	r3, [r3, #0]
 8027a0c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8027a10:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8027a14:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8027a18:	681b      	ldr	r3, [r3, #0]
 8027a1a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8027a1c:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  wsptr = workspace;
 8027a20:	f107 0310 	add.w	r3, r7, #16
 8027a24:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8027a28:	2300      	movs	r3, #0
 8027a2a:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8027a2e:	e105      	b.n	8027c3c <jpeg_idct_12x6+0x27c>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8027a30:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027a34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027a38:	461a      	mov	r2, r3
 8027a3a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027a3e:	681b      	ldr	r3, [r3, #0]
 8027a40:	fb02 f303 	mul.w	r3, r2, r3
 8027a44:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp10 <<= CONST_BITS;
 8027a48:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027a4c:	035b      	lsls	r3, r3, #13
 8027a4e:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 8027a52:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027a56:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8027a5a:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp12 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8027a5e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027a62:	3340      	adds	r3, #64	@ 0x40
 8027a64:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027a68:	461a      	mov	r2, r3
 8027a6a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027a6e:	3380      	adds	r3, #128	@ 0x80
 8027a70:	681b      	ldr	r3, [r3, #0]
 8027a72:	fb02 f303 	mul.w	r3, r2, r3
 8027a76:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 8027a7a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027a7e:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8027a82:	fb02 f303 	mul.w	r3, r2, r3
 8027a86:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp11 = tmp10 + tmp20;
 8027a8a:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027a8e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8027a92:	4413      	add	r3, r2
 8027a94:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp21 = RIGHT_SHIFT(tmp10 - tmp20 - tmp20, CONST_BITS-PASS1_BITS);
 8027a98:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027a9c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8027aa0:	1ad2      	subs	r2, r2, r3
 8027aa2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8027aa6:	1ad3      	subs	r3, r2, r3
 8027aa8:	12db      	asrs	r3, r3, #11
 8027aaa:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp20 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8027aae:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027ab2:	3320      	adds	r3, #32
 8027ab4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027ab8:	461a      	mov	r2, r3
 8027aba:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027abe:	3340      	adds	r3, #64	@ 0x40
 8027ac0:	681b      	ldr	r3, [r3, #0]
 8027ac2:	fb02 f303 	mul.w	r3, r2, r3
 8027ac6:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 8027aca:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8027ace:	f242 7231 	movw	r2, #10033	@ 0x2731
 8027ad2:	fb02 f303 	mul.w	r3, r2, r3
 8027ad6:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp20 = tmp11 + tmp10;
 8027ada:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027ade:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027ae2:	4413      	add	r3, r2
 8027ae4:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp22 = tmp11 - tmp10;
 8027ae8:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027aec:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027af0:	1ad3      	subs	r3, r2, r3
 8027af2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8027af6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027afa:	3310      	adds	r3, #16
 8027afc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027b00:	461a      	mov	r2, r3
 8027b02:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027b06:	3320      	adds	r3, #32
 8027b08:	681b      	ldr	r3, [r3, #0]
 8027b0a:	fb02 f303 	mul.w	r3, r2, r3
 8027b0e:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8027b12:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027b16:	3330      	adds	r3, #48	@ 0x30
 8027b18:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027b1c:	461a      	mov	r2, r3
 8027b1e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027b22:	3360      	adds	r3, #96	@ 0x60
 8027b24:	681b      	ldr	r3, [r3, #0]
 8027b26:	fb02 f303 	mul.w	r3, r2, r3
 8027b2a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8027b2e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027b32:	3350      	adds	r3, #80	@ 0x50
 8027b34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027b38:	461a      	mov	r2, r3
 8027b3a:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027b3e:	33a0      	adds	r3, #160	@ 0xa0
 8027b40:	681b      	ldr	r3, [r3, #0]
 8027b42:	fb02 f303 	mul.w	r3, r2, r3
 8027b46:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8027b4a:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027b4e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027b52:	4413      	add	r3, r2
 8027b54:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 8027b58:	fb02 f303 	mul.w	r3, r2, r3
 8027b5c:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 8027b60:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027b64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027b68:	4413      	add	r3, r2
 8027b6a:	035b      	lsls	r3, r3, #13
 8027b6c:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027b70:	4413      	add	r3, r2
 8027b72:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 8027b76:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027b7a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027b7e:	1ad3      	subs	r3, r2, r3
 8027b80:	035b      	lsls	r3, r3, #13
 8027b82:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027b86:	4413      	add	r3, r2
 8027b88:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp11 = (z1 - z2 - z3) << PASS1_BITS;
 8027b8c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027b90:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027b94:	1ad2      	subs	r2, r2, r3
 8027b96:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027b9a:	1ad3      	subs	r3, r2, r3
 8027b9c:	009b      	lsls	r3, r3, #2
 8027b9e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8027ba2:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8027ba6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027baa:	4413      	add	r3, r2
 8027bac:	12da      	asrs	r2, r3, #11
 8027bae:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027bb2:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8027bb4:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8027bb8:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027bbc:	1ad2      	subs	r2, r2, r3
 8027bbe:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027bc2:	33a0      	adds	r3, #160	@ 0xa0
 8027bc4:	12d2      	asrs	r2, r2, #11
 8027bc6:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp21 + tmp11);
 8027bc8:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027bcc:	3320      	adds	r3, #32
 8027bce:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 8027bd2:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027bd6:	440a      	add	r2, r1
 8027bd8:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) (tmp21 - tmp11);
 8027bda:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027bde:	3380      	adds	r3, #128	@ 0x80
 8027be0:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 8027be4:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027be8:	1a8a      	subs	r2, r1, r2
 8027bea:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8027bec:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8027bf0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027bf4:	441a      	add	r2, r3
 8027bf6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027bfa:	3340      	adds	r3, #64	@ 0x40
 8027bfc:	12d2      	asrs	r2, r2, #11
 8027bfe:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8027c00:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8027c04:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027c08:	1ad2      	subs	r2, r2, r3
 8027c0a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027c0e:	3360      	adds	r3, #96	@ 0x60
 8027c10:	12d2      	asrs	r2, r2, #11
 8027c12:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8027c14:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8027c18:	3301      	adds	r3, #1
 8027c1a:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8027c1e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8027c22:	3302      	adds	r3, #2
 8027c24:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 8027c28:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8027c2c:	3304      	adds	r3, #4
 8027c2e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 8027c32:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027c36:	3304      	adds	r3, #4
 8027c38:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8027c3c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8027c40:	2b07      	cmp	r3, #7
 8027c42:	f77f aef5 	ble.w	8027a30 <jpeg_idct_12x6+0x70>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  wsptr = workspace;
 8027c46:	f107 0310 	add.w	r3, r7, #16
 8027c4a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 8027c4e:	2300      	movs	r3, #0
 8027c50:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8027c54:	e21d      	b.n	8028092 <jpeg_idct_12x6+0x6d2>
    outptr = output_buf[ctr] + output_col;
 8027c56:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8027c5a:	009b      	lsls	r3, r3, #2
 8027c5c:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8027c60:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 8027c64:	6812      	ldr	r2, [r2, #0]
 8027c66:	4413      	add	r3, r2
 8027c68:	681a      	ldr	r2, [r3, #0]
 8027c6a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 8027c6e:	4413      	add	r3, r2
 8027c70:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8027c74:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027c78:	681b      	ldr	r3, [r3, #0]
 8027c7a:	3310      	adds	r3, #16
 8027c7c:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z3 <<= CONST_BITS;
 8027c80:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027c84:	035b      	lsls	r3, r3, #13
 8027c86:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    z4 = (INT32) wsptr[4];
 8027c8a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027c8e:	3310      	adds	r3, #16
 8027c90:	681b      	ldr	r3, [r3, #0]
 8027c92:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8027c96:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027c9a:	f242 7231 	movw	r2, #10033	@ 0x2731
 8027c9e:	fb02 f303 	mul.w	r3, r2, r3
 8027ca2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108

    tmp10 = z3 + z4;
 8027ca6:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027caa:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027cae:	4413      	add	r3, r2
 8027cb0:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp11 = z3 - z4;
 8027cb4:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027cb8:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027cbc:	1ad3      	subs	r3, r2, r3
 8027cbe:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = (INT32) wsptr[2];
 8027cc2:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027cc6:	3308      	adds	r3, #8
 8027cc8:	681b      	ldr	r3, [r3, #0]
 8027cca:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8027cce:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8027cd2:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 8027cd6:	fb02 f303 	mul.w	r3, r2, r3
 8027cda:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z1 <<= CONST_BITS;
 8027cde:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8027ce2:	035b      	lsls	r3, r3, #13
 8027ce4:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = (INT32) wsptr[6];
 8027ce8:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027cec:	3318      	adds	r3, #24
 8027cee:	681b      	ldr	r3, [r3, #0]
 8027cf0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z2 <<= CONST_BITS;
 8027cf4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027cf8:	035b      	lsls	r3, r3, #13
 8027cfa:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

    tmp12 = z1 - z2;
 8027cfe:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027d02:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027d06:	1ad3      	subs	r3, r2, r3
 8027d08:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp21 = z3 + tmp12;
 8027d0c:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027d10:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d14:	4413      	add	r3, r2
 8027d16:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    tmp24 = z3 - tmp12;
 8027d1a:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027d1e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d22:	1ad3      	subs	r3, r2, r3
 8027d24:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec

    tmp12 = z4 + z2;
 8027d28:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8027d2c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027d30:	4413      	add	r3, r2
 8027d32:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp20 = tmp10 + tmp12;
 8027d36:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027d3a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d3e:	4413      	add	r3, r2
 8027d40:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp25 = tmp10 - tmp12;
 8027d44:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027d48:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d4c:	1ad3      	subs	r3, r2, r3
 8027d4e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    tmp12 = z4 - z1 - z2;
 8027d52:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8027d56:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8027d5a:	1ad2      	subs	r2, r2, r3
 8027d5c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027d60:	1ad3      	subs	r3, r2, r3
 8027d62:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp22 = tmp11 + tmp12;
 8027d66:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027d6a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d6e:	4413      	add	r3, r2
 8027d70:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    tmp23 = tmp11 - tmp12;
 8027d74:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8027d78:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027d7c:	1ad3      	subs	r3, r2, r3
 8027d7e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8027d82:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027d86:	3304      	adds	r3, #4
 8027d88:	681b      	ldr	r3, [r3, #0]
 8027d8a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 = (INT32) wsptr[3];
 8027d8e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027d92:	330c      	adds	r3, #12
 8027d94:	681b      	ldr	r3, [r3, #0]
 8027d96:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = (INT32) wsptr[5];
 8027d9a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027d9e:	3314      	adds	r3, #20
 8027da0:	681b      	ldr	r3, [r3, #0]
 8027da2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z4 = (INT32) wsptr[7];
 8027da6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8027daa:	331c      	adds	r3, #28
 8027dac:	681b      	ldr	r3, [r3, #0]
 8027dae:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 8027db2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027db6:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8027dba:	fb02 f303 	mul.w	r3, r2, r3
 8027dbe:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 8027dc2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027dc6:	4ab9      	ldr	r2, [pc, #740]	@ (80280ac <jpeg_idct_12x6+0x6ec>)
 8027dc8:	fb02 f303 	mul.w	r3, r2, r3
 8027dcc:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    tmp10 = z1 + z3;
 8027dd0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027dd4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027dd8:	4413      	add	r3, r2
 8027dda:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 8027dde:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8027de2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027de6:	4413      	add	r3, r2
 8027de8:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 8027dec:	fb02 f303 	mul.w	r3, r2, r3
 8027df0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 8027df4:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027df8:	f640 025b 	movw	r2, #2139	@ 0x85b
 8027dfc:	fb02 f303 	mul.w	r3, r2, r3
 8027e00:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8027e04:	4413      	add	r3, r2
 8027e06:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 8027e0a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8027e0e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8027e12:	18d1      	adds	r1, r2, r3
 8027e14:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027e18:	4613      	mov	r3, r2
 8027e1a:	00db      	lsls	r3, r3, #3
 8027e1c:	4413      	add	r3, r2
 8027e1e:	021a      	lsls	r2, r3, #8
 8027e20:	1ad3      	subs	r3, r2, r3
 8027e22:	440b      	add	r3, r1
 8027e24:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8027e28:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027e2c:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027e30:	4413      	add	r3, r2
 8027e32:	4a9f      	ldr	r2, [pc, #636]	@ (80280b0 <jpeg_idct_12x6+0x6f0>)
 8027e34:	fb02 f303 	mul.w	r3, r2, r3
 8027e38:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8027e3c:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8027e40:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027e44:	441a      	add	r2, r3
 8027e46:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027e4a:	499a      	ldr	r1, [pc, #616]	@ (80280b4 <jpeg_idct_12x6+0x6f4>)
 8027e4c:	fb01 f303 	mul.w	r3, r1, r3
 8027e50:	4413      	add	r3, r2
 8027e52:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8027e56:	4413      	add	r3, r2
 8027e58:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8027e5c:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8027e60:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8027e64:	1ad2      	subs	r2, r2, r3
 8027e66:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027e6a:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 8027e6e:	fb01 f303 	mul.w	r3, r1, r3
 8027e72:	4413      	add	r3, r2
 8027e74:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8027e78:	4413      	add	r3, r2
 8027e7a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8027e7e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8027e82:	4a8d      	ldr	r2, [pc, #564]	@ (80280b8 <jpeg_idct_12x6+0x6f8>)
 8027e84:	fb03 f202 	mul.w	r2, r3, r2
 8027e88:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027e8c:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8027e8e:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027e92:	498a      	ldr	r1, [pc, #552]	@ (80280bc <jpeg_idct_12x6+0x6fc>)
 8027e94:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8027e98:	4413      	add	r3, r2
 8027e9a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8027e9e:	4413      	add	r3, r2
 8027ea0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

    z1 -= z4;
 8027ea4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027ea8:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8027eac:	1ad3      	subs	r3, r2, r3
 8027eae:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    z2 -= z3;
 8027eb2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8027eb6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8027eba:	1ad3      	subs	r3, r2, r3
 8027ebc:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8027ec0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8027ec4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027ec8:	4413      	add	r3, r2
 8027eca:	f241 1251 	movw	r2, #4433	@ 0x1151
 8027ece:	fb02 f303 	mul.w	r3, r2, r3
 8027ed2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 8027ed6:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8027eda:	f641 027e 	movw	r2, #6270	@ 0x187e
 8027ede:	fb02 f303 	mul.w	r3, r2, r3
 8027ee2:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027ee6:	4413      	add	r3, r2
 8027ee8:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 8027eec:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8027ef0:	4a73      	ldr	r2, [pc, #460]	@ (80280c0 <jpeg_idct_12x6+0x700>)
 8027ef2:	fb02 f303 	mul.w	r3, r2, r3
 8027ef6:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 8027efa:	4413      	add	r3, r2
 8027efc:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8027f00:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8027f04:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027f08:	4413      	add	r3, r2
 8027f0a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027f0c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8027f10:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027f14:	4413      	add	r3, r2
 8027f16:	781a      	ldrb	r2, [r3, #0]
 8027f18:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027f1c:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8027f1e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8027f22:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8027f26:	1ad3      	subs	r3, r2, r3
 8027f28:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027f2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8027f2e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027f32:	441a      	add	r2, r3
 8027f34:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027f38:	330b      	adds	r3, #11
 8027f3a:	7812      	ldrb	r2, [r2, #0]
 8027f3c:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8027f3e:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8027f42:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8027f46:	4413      	add	r3, r2
 8027f48:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027f4a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8027f4e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027f52:	441a      	add	r2, r3
 8027f54:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027f58:	3301      	adds	r3, #1
 8027f5a:	7812      	ldrb	r2, [r2, #0]
 8027f5c:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027f5e:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8027f62:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8027f66:	1ad3      	subs	r3, r2, r3
 8027f68:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027f6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8027f6e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027f72:	441a      	add	r2, r3
 8027f74:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027f78:	330a      	adds	r3, #10
 8027f7a:	7812      	ldrb	r2, [r2, #0]
 8027f7c:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027f7e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8027f82:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027f86:	4413      	add	r3, r2
 8027f88:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027f8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8027f8e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027f92:	441a      	add	r2, r3
 8027f94:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027f98:	3302      	adds	r3, #2
 8027f9a:	7812      	ldrb	r2, [r2, #0]
 8027f9c:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027f9e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8027fa2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027fa6:	1ad3      	subs	r3, r2, r3
 8027fa8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027faa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8027fae:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027fb2:	441a      	add	r2, r3
 8027fb4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027fb8:	3309      	adds	r3, #9
 8027fba:	7812      	ldrb	r2, [r2, #0]
 8027fbc:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8027fbe:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8027fc2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8027fc6:	4413      	add	r3, r2
 8027fc8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027fca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8027fce:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027fd2:	441a      	add	r2, r3
 8027fd4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027fd8:	3303      	adds	r3, #3
 8027fda:	7812      	ldrb	r2, [r2, #0]
 8027fdc:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8027fde:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8027fe2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8027fe6:	1ad3      	subs	r3, r2, r3
 8027fe8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8027fea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8027fee:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8027ff2:	441a      	add	r2, r3
 8027ff4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8027ff8:	3308      	adds	r3, #8
 8027ffa:	7812      	ldrb	r2, [r2, #0]
 8027ffc:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8027ffe:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028002:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028006:	4413      	add	r3, r2
 8028008:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802800a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802800e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028012:	441a      	add	r2, r3
 8028014:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028018:	3304      	adds	r3, #4
 802801a:	7812      	ldrb	r2, [r2, #0]
 802801c:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802801e:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028022:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028026:	1ad3      	subs	r3, r2, r3
 8028028:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802802a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802802e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028032:	441a      	add	r2, r3
 8028034:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028038:	3307      	adds	r3, #7
 802803a:	7812      	ldrb	r2, [r2, #0]
 802803c:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 802803e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028042:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028046:	4413      	add	r3, r2
 8028048:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802804a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 802804e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028052:	441a      	add	r2, r3
 8028054:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028058:	3305      	adds	r3, #5
 802805a:	7812      	ldrb	r2, [r2, #0]
 802805c:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 802805e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028062:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028066:	1ad3      	subs	r3, r2, r3
 8028068:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802806a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 802806e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8028072:	441a      	add	r2, r3
 8028074:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8028078:	3306      	adds	r3, #6
 802807a:	7812      	ldrb	r2, [r2, #0]
 802807c:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 802807e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8028082:	3320      	adds	r3, #32
 8028084:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 8028088:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802808c:	3301      	adds	r3, #1
 802808e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8028092:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8028096:	2b05      	cmp	r3, #5
 8028098:	f77f addd 	ble.w	8027c56 <jpeg_idct_12x6+0x296>
  }
}
 802809c:	bf00      	nop
 802809e:	bf00      	nop
 80280a0:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 80280a4:	46bd      	mov	sp, r7
 80280a6:	bc90      	pop	{r4, r7}
 80280a8:	4770      	bx	lr
 80280aa:	bf00      	nop
 80280ac:	ffffeeaf 	.word	0xffffeeaf
 80280b0:	ffffde8b 	.word	0xffffde8b
 80280b4:	ffffd0b0 	.word	0xffffd0b0
 80280b8:	ffffea5c 	.word	0xffffea5c
 80280bc:	ffffc08c 	.word	0xffffc08c
 80280c0:	ffffc4df 	.word	0xffffc4df

080280c4 <jpeg_idct_10x5>:

GLOBAL(void)
jpeg_idct_10x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80280c4:	b480      	push	{r7}
 80280c6:	b0c1      	sub	sp, #260	@ 0x104
 80280c8:	af00      	add	r7, sp, #0
 80280ca:	60f8      	str	r0, [r7, #12]
 80280cc:	60b9      	str	r1, [r7, #8]
 80280ce:	607a      	str	r2, [r7, #4]
 80280d0:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 80280d4:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 80280d8:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80280da:	68fb      	ldr	r3, [r7, #12]
 80280dc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80280e0:	3380      	adds	r3, #128	@ 0x80
 80280e2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  inptr = coef_block;
 80280e6:	687b      	ldr	r3, [r7, #4]
 80280e8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80280ec:	68bb      	ldr	r3, [r7, #8]
 80280ee:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80280f0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
  wsptr = workspace;
 80280f4:	f107 0310 	add.w	r3, r7, #16
 80280f8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80280fc:	2300      	movs	r3, #0
 80280fe:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8028102:	e0e3      	b.n	80282cc <jpeg_idct_10x5+0x208>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8028104:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8028108:	f9b3 3000 	ldrsh.w	r3, [r3]
 802810c:	461a      	mov	r2, r3
 802810e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8028112:	681b      	ldr	r3, [r3, #0]
 8028114:	fb02 f303 	mul.w	r3, r2, r3
 8028118:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp12 <<= CONST_BITS;
 802811c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8028120:	035b      	lsls	r3, r3, #13
 8028122:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 8028126:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802812a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802812e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp13 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8028132:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8028136:	3320      	adds	r3, #32
 8028138:	f9b3 3000 	ldrsh.w	r3, [r3]
 802813c:	461a      	mov	r2, r3
 802813e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8028142:	3340      	adds	r3, #64	@ 0x40
 8028144:	681b      	ldr	r3, [r3, #0]
 8028146:	fb02 f303 	mul.w	r3, r2, r3
 802814a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp14 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802814e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8028152:	3340      	adds	r3, #64	@ 0x40
 8028154:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028158:	461a      	mov	r2, r3
 802815a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802815e:	3380      	adds	r3, #128	@ 0x80
 8028160:	681b      	ldr	r3, [r3, #0]
 8028162:	fb02 f303 	mul.w	r3, r2, r3
 8028166:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 802816a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802816e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028172:	4413      	add	r3, r2
 8028174:	f641 124c 	movw	r2, #6476	@ 0x194c
 8028178:	fb02 f303 	mul.w	r3, r2, r3
 802817c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 8028180:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028184:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028188:	1ad3      	subs	r3, r2, r3
 802818a:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 802818e:	fb02 f303 	mul.w	r3, r2, r3
 8028192:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = tmp12 + z2;
 8028196:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 802819a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802819e:	4413      	add	r3, r2
 80281a0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp10 = z3 + z1;
 80281a4:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80281a8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80281ac:	4413      	add	r3, r2
 80281ae:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp11 = z3 - z1;
 80281b2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80281b6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80281ba:	1ad3      	subs	r3, r2, r3
 80281bc:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp12 -= z2 << 2;
 80281c0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80281c4:	009b      	lsls	r3, r3, #2
 80281c6:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80281ca:	1ad3      	subs	r3, r2, r3
 80281cc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80281d0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80281d4:	3310      	adds	r3, #16
 80281d6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80281da:	461a      	mov	r2, r3
 80281dc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80281e0:	3320      	adds	r3, #32
 80281e2:	681b      	ldr	r3, [r3, #0]
 80281e4:	fb02 f303 	mul.w	r3, r2, r3
 80281e8:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80281ec:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80281f0:	3330      	adds	r3, #48	@ 0x30
 80281f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80281f6:	461a      	mov	r2, r3
 80281f8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80281fc:	3360      	adds	r3, #96	@ 0x60
 80281fe:	681b      	ldr	r3, [r3, #0]
 8028200:	fb02 f303 	mul.w	r3, r2, r3
 8028204:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 8028208:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802820c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8028210:	4413      	add	r3, r2
 8028212:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 8028216:	fb02 f303 	mul.w	r3, r2, r3
 802821a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 802821e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028222:	f241 0271 	movw	r2, #4209	@ 0x1071
 8028226:	fb02 f303 	mul.w	r3, r2, r3
 802822a:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 802822e:	4413      	add	r3, r2
 8028230:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 8028234:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8028238:	4a2b      	ldr	r2, [pc, #172]	@ (80282e8 <jpeg_idct_10x5+0x224>)
 802823a:	fb02 f303 	mul.w	r3, r2, r3
 802823e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8028242:	4413      	add	r3, r2
 8028244:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp13, CONST_BITS-PASS1_BITS);
 8028248:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 802824c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028250:	4413      	add	r3, r2
 8028252:	12da      	asrs	r2, r3, #11
 8028254:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028258:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp10 - tmp13, CONST_BITS-PASS1_BITS);
 802825a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 802825e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028262:	1ad2      	subs	r2, r2, r3
 8028264:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028268:	3380      	adds	r3, #128	@ 0x80
 802826a:	12d2      	asrs	r2, r2, #11
 802826c:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp14, CONST_BITS-PASS1_BITS);
 802826e:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8028272:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028276:	441a      	add	r2, r3
 8028278:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802827c:	3320      	adds	r3, #32
 802827e:	12d2      	asrs	r2, r2, #11
 8028280:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp11 - tmp14, CONST_BITS-PASS1_BITS);
 8028282:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8028286:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 802828a:	1ad2      	subs	r2, r2, r3
 802828c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028290:	3360      	adds	r3, #96	@ 0x60
 8028292:	12d2      	asrs	r2, r2, #11
 8028294:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 8028296:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802829a:	3340      	adds	r3, #64	@ 0x40
 802829c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 80282a0:	12d2      	asrs	r2, r2, #11
 80282a2:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80282a4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80282a8:	3301      	adds	r3, #1
 80282aa:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 80282ae:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80282b2:	3302      	adds	r3, #2
 80282b4:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 80282b8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80282bc:	3304      	adds	r3, #4
 80282be:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 80282c2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80282c6:	3304      	adds	r3, #4
 80282c8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 80282cc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80282d0:	2b07      	cmp	r3, #7
 80282d2:	f77f af17 	ble.w	8028104 <jpeg_idct_10x5+0x40>
  }

  /* Pass 2: process 5 rows from work array, store into output array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  wsptr = workspace;
 80282d6:	f107 0310 	add.w	r3, r7, #16
 80282da:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 80282de:	2300      	movs	r3, #0
 80282e0:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 80282e4:	e1d4      	b.n	8028690 <jpeg_idct_10x5+0x5cc>
 80282e6:	bf00      	nop
 80282e8:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 80282ec:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80282f0:	009b      	lsls	r3, r3, #2
 80282f2:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 80282f6:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 80282fa:	6812      	ldr	r2, [r2, #0]
 80282fc:	4413      	add	r3, r2
 80282fe:	681a      	ldr	r2, [r3, #0]
 8028300:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8028304:	4413      	add	r3, r2
 8028306:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802830a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802830e:	681b      	ldr	r3, [r3, #0]
 8028310:	3310      	adds	r3, #16
 8028312:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z3 <<= CONST_BITS;
 8028316:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 802831a:	035b      	lsls	r3, r3, #13
 802831c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z4 = (INT32) wsptr[4];
 8028320:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028324:	3310      	adds	r3, #16
 8028326:	681b      	ldr	r3, [r3, #0]
 8028328:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 802832c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8028330:	f242 429d 	movw	r2, #9373	@ 0x249d
 8028334:	fb02 f303 	mul.w	r3, r2, r3
 8028338:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 802833c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8028340:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 8028344:	fb02 f303 	mul.w	r3, r2, r3
 8028348:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    tmp10 = z3 + z1;
 802834c:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028350:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8028354:	4413      	add	r3, r2
 8028356:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp11 = z3 - z2;
 802835a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 802835e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028362:	1ad3      	subs	r3, r2, r3
 8028364:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 8028368:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 802836c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028370:	1ad3      	subs	r3, r2, r3
 8028372:	005b      	lsls	r3, r3, #1
 8028374:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028378:	1ad3      	subs	r3, r2, r3
 802837a:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc

    z2 = (INT32) wsptr[2];
 802837e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028382:	3308      	adds	r3, #8
 8028384:	681b      	ldr	r3, [r3, #0]
 8028386:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = (INT32) wsptr[6];
 802838a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802838e:	3318      	adds	r3, #24
 8028390:	681b      	ldr	r3, [r3, #0]
 8028392:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8028396:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802839a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 802839e:	4413      	add	r3, r2
 80283a0:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 80283a4:	fb02 f303 	mul.w	r3, r2, r3
 80283a8:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 80283ac:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80283b0:	f241 0271 	movw	r2, #4209	@ 0x1071
 80283b4:	fb02 f303 	mul.w	r3, r2, r3
 80283b8:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80283bc:	4413      	add	r3, r2
 80283be:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 80283c2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80283c6:	4ab9      	ldr	r2, [pc, #740]	@ (80286ac <jpeg_idct_10x5+0x5e8>)
 80283c8:	fb02 f303 	mul.w	r3, r2, r3
 80283cc:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80283d0:	4413      	add	r3, r2
 80283d2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    tmp20 = tmp10 + tmp12;
 80283d6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 80283da:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80283de:	4413      	add	r3, r2
 80283e0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    tmp24 = tmp10 - tmp12;
 80283e4:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 80283e8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80283ec:	1ad3      	subs	r3, r2, r3
 80283ee:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp21 = tmp11 + tmp13;
 80283f2:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 80283f6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80283fa:	4413      	add	r3, r2
 80283fc:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp23 = tmp11 - tmp13;
 8028400:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8028404:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028408:	1ad3      	subs	r3, r2, r3
 802840a:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802840e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028412:	3304      	adds	r3, #4
 8028414:	681b      	ldr	r3, [r3, #0]
 8028416:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    z2 = (INT32) wsptr[3];
 802841a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802841e:	330c      	adds	r3, #12
 8028420:	681b      	ldr	r3, [r3, #0]
 8028422:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z3 = (INT32) wsptr[5];
 8028426:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802842a:	3314      	adds	r3, #20
 802842c:	681b      	ldr	r3, [r3, #0]
 802842e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z3 <<= CONST_BITS;
 8028432:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8028436:	035b      	lsls	r3, r3, #13
 8028438:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    z4 = (INT32) wsptr[7];
 802843c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028440:	331c      	adds	r3, #28
 8028442:	681b      	ldr	r3, [r3, #0]
 8028444:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp11 = z2 + z4;
 8028448:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802844c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8028450:	4413      	add	r3, r2
 8028452:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp13 = z2 - z4;
 8028456:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802845a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 802845e:	1ad3      	subs	r3, r2, r3
 8028460:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 8028464:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028468:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 802846c:	fb02 f303 	mul.w	r3, r2, r3
 8028470:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 8028474:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028478:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 802847c:	fb02 f303 	mul.w	r3, r2, r3
 8028480:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z4 = z3 + tmp12;
 8028484:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8028488:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802848c:	4413      	add	r3, r2
 802848e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 8028492:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8028496:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 802849a:	fb03 f202 	mul.w	r2, r3, r2
 802849e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80284a2:	4413      	add	r3, r2
 80284a4:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80284a8:	4413      	add	r3, r2
 80284aa:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 80284ae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80284b2:	f240 7214 	movw	r2, #1812	@ 0x714
 80284b6:	fb03 f202 	mul.w	r2, r3, r2
 80284ba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80284be:	1ad3      	subs	r3, r2, r3
 80284c0:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80284c4:	4413      	add	r3, r2
 80284c6:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 80284ca:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80284ce:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 80284d2:	fb02 f303 	mul.w	r3, r2, r3
 80284d6:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 80284da:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80284de:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80284e2:	1ad2      	subs	r2, r2, r3
 80284e4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80284e8:	031b      	lsls	r3, r3, #12
 80284ea:	1ad3      	subs	r3, r2, r3
 80284ec:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 80284f0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 80284f4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80284f8:	1ad3      	subs	r3, r2, r3
 80284fa:	035a      	lsls	r2, r3, #13
 80284fc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8028500:	1ad3      	subs	r3, r2, r3
 8028502:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 8028506:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 802850a:	f642 0253 	movw	r2, #10323	@ 0x2853
 802850e:	fb03 f202 	mul.w	r2, r3, r2
 8028512:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028516:	1ad2      	subs	r2, r2, r3
 8028518:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 802851c:	1ad3      	subs	r3, r2, r3
 802851e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8028522:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8028526:	f241 428c 	movw	r2, #5260	@ 0x148c
 802852a:	fb03 f202 	mul.w	r2, r3, r2
 802852e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8028532:	1ad3      	subs	r3, r2, r3
 8028534:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8028538:	4413      	add	r3, r2
 802853a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802853e:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8028542:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028546:	4413      	add	r3, r2
 8028548:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802854a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802854e:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028552:	4413      	add	r3, r2
 8028554:	781a      	ldrb	r2, [r3, #0]
 8028556:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 802855a:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802855c:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8028560:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028564:	1ad3      	subs	r3, r2, r3
 8028566:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028568:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802856c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028570:	441a      	add	r2, r3
 8028572:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028576:	3309      	adds	r3, #9
 8028578:	7812      	ldrb	r2, [r2, #0]
 802857a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802857c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8028580:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028584:	4413      	add	r3, r2
 8028586:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028588:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802858c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028590:	441a      	add	r2, r3
 8028592:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028596:	3301      	adds	r3, #1
 8028598:	7812      	ldrb	r2, [r2, #0]
 802859a:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802859c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80285a0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80285a4:	1ad3      	subs	r3, r2, r3
 80285a6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285a8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80285ac:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80285b0:	441a      	add	r2, r3
 80285b2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80285b6:	3308      	adds	r3, #8
 80285b8:	7812      	ldrb	r2, [r2, #0]
 80285ba:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80285bc:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80285c0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80285c4:	4413      	add	r3, r2
 80285c6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80285cc:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80285d0:	441a      	add	r2, r3
 80285d2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80285d6:	3302      	adds	r3, #2
 80285d8:	7812      	ldrb	r2, [r2, #0]
 80285da:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80285dc:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80285e0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80285e4:	1ad3      	subs	r3, r2, r3
 80285e6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80285e8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80285ec:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80285f0:	441a      	add	r2, r3
 80285f2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80285f6:	3307      	adds	r3, #7
 80285f8:	7812      	ldrb	r2, [r2, #0]
 80285fa:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 80285fc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028600:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028604:	4413      	add	r3, r2
 8028606:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028608:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 802860c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028610:	441a      	add	r2, r3
 8028612:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028616:	3303      	adds	r3, #3
 8028618:	7812      	ldrb	r2, [r2, #0]
 802861a:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802861c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028620:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8028624:	1ad3      	subs	r3, r2, r3
 8028626:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028628:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 802862c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028630:	441a      	add	r2, r3
 8028632:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028636:	3306      	adds	r3, #6
 8028638:	7812      	ldrb	r2, [r2, #0]
 802863a:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802863c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028640:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028644:	4413      	add	r3, r2
 8028646:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028648:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 802864c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028650:	441a      	add	r2, r3
 8028652:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028656:	3304      	adds	r3, #4
 8028658:	7812      	ldrb	r2, [r2, #0]
 802865a:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802865c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028660:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028664:	1ad3      	subs	r3, r2, r3
 8028666:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028668:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 802866c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8028670:	441a      	add	r2, r3
 8028672:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8028676:	3305      	adds	r3, #5
 8028678:	7812      	ldrb	r2, [r2, #0]
 802867a:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 802867c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8028680:	3320      	adds	r3, #32
 8028682:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 8028686:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 802868a:	3301      	adds	r3, #1
 802868c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 8028690:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8028694:	2b04      	cmp	r3, #4
 8028696:	f77f ae29 	ble.w	80282ec <jpeg_idct_10x5+0x228>
  }
}
 802869a:	bf00      	nop
 802869c:	bf00      	nop
 802869e:	f507 7782 	add.w	r7, r7, #260	@ 0x104
 80286a2:	46bd      	mov	sp, r7
 80286a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80286a8:	4770      	bx	lr
 80286aa:	bf00      	nop
 80286ac:	ffffba5c 	.word	0xffffba5c

080286b0 <jpeg_idct_8x4>:

GLOBAL(void)
jpeg_idct_8x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80286b0:	b480      	push	{r7}
 80286b2:	b0b7      	sub	sp, #220	@ 0xdc
 80286b4:	af00      	add	r7, sp, #0
 80286b6:	60f8      	str	r0, [r7, #12]
 80286b8:	60b9      	str	r1, [r7, #8]
 80286ba:	607a      	str	r2, [r7, #4]
 80286bc:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80286be:	68fb      	ldr	r3, [r7, #12]
 80286c0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80286c4:	3380      	adds	r3, #128	@ 0x80
 80286c6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  inptr = coef_block;
 80286ca:	687b      	ldr	r3, [r7, #4]
 80286cc:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80286d0:	68bb      	ldr	r3, [r7, #8]
 80286d2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80286d4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  wsptr = workspace;
 80286d8:	f107 0314 	add.w	r3, r7, #20
 80286dc:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80286e0:	2300      	movs	r3, #0
 80286e2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80286e6:	e0a4      	b.n	8028832 <jpeg_idct_8x4+0x182>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80286e8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80286ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 80286f0:	461a      	mov	r2, r3
 80286f2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80286f6:	681b      	ldr	r3, [r3, #0]
 80286f8:	fb02 f303 	mul.w	r3, r2, r3
 80286fc:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8028700:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028704:	3320      	adds	r3, #32
 8028706:	f9b3 3000 	ldrsh.w	r3, [r3]
 802870a:	461a      	mov	r2, r3
 802870c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028710:	3340      	adds	r3, #64	@ 0x40
 8028712:	681b      	ldr	r3, [r3, #0]
 8028714:	fb02 f303 	mul.w	r3, r2, r3
 8028718:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 802871c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028720:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028724:	4413      	add	r3, r2
 8028726:	009b      	lsls	r3, r3, #2
 8028728:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 802872c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028730:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028734:	1ad3      	subs	r3, r2, r3
 8028736:	009b      	lsls	r3, r3, #2
 8028738:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802873c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028740:	3310      	adds	r3, #16
 8028742:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028746:	461a      	mov	r2, r3
 8028748:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802874c:	3320      	adds	r3, #32
 802874e:	681b      	ldr	r3, [r3, #0]
 8028750:	fb02 f303 	mul.w	r3, r2, r3
 8028754:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8028758:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802875c:	3330      	adds	r3, #48	@ 0x30
 802875e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028762:	461a      	mov	r2, r3
 8028764:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028768:	3360      	adds	r3, #96	@ 0x60
 802876a:	681b      	ldr	r3, [r3, #0]
 802876c:	fb02 f303 	mul.w	r3, r2, r3
 8028770:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 8028774:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028778:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802877c:	4413      	add	r3, r2
 802877e:	f241 1251 	movw	r2, #4433	@ 0x1151
 8028782:	fb02 f303 	mul.w	r3, r2, r3
 8028786:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 802878a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 802878e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8028792:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 8028796:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802879a:	f641 027e 	movw	r2, #6270	@ 0x187e
 802879e:	fb03 f202 	mul.w	r2, r3, r2
 80287a2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80287a6:	4413      	add	r3, r2
 80287a8:	12db      	asrs	r3, r3, #11
 80287aa:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 80287ae:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80287b2:	4a26      	ldr	r2, [pc, #152]	@ (802884c <jpeg_idct_8x4+0x19c>)
 80287b4:	fb03 f202 	mul.w	r2, r3, r2
 80287b8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80287bc:	4413      	add	r3, r2
 80287be:	12db      	asrs	r3, r3, #11
 80287c0:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[8*0] = (int) (tmp10 + tmp0);
 80287c4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 80287c8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80287cc:	441a      	add	r2, r3
 80287ce:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80287d2:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) (tmp10 - tmp0);
 80287d4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80287d8:	3360      	adds	r3, #96	@ 0x60
 80287da:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 80287de:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80287e2:	1a8a      	subs	r2, r1, r2
 80287e4:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp12 + tmp2);
 80287e6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80287ea:	3320      	adds	r3, #32
 80287ec:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 80287f0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80287f4:	440a      	add	r2, r1
 80287f6:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp12 - tmp2);
 80287f8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80287fc:	3340      	adds	r3, #64	@ 0x40
 80287fe:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 8028802:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8028806:	1a8a      	subs	r2, r1, r2
 8028808:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802880a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802880e:	3301      	adds	r3, #1
 8028810:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8028814:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8028818:	3302      	adds	r3, #2
 802881a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 802881e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8028822:	3304      	adds	r3, #4
 8028824:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8028828:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802882c:	3304      	adds	r3, #4
 802882e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8028832:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8028836:	2b07      	cmp	r3, #7
 8028838:	f77f af56 	ble.w	80286e8 <jpeg_idct_8x4+0x38>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 802883c:	f107 0314 	add.w	r3, r7, #20
 8028840:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 8028844:	2300      	movs	r3, #0
 8028846:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802884a:	e1a2      	b.n	8028b92 <jpeg_idct_8x4+0x4e2>
 802884c:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 8028850:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8028854:	009b      	lsls	r3, r3, #2
 8028856:	683a      	ldr	r2, [r7, #0]
 8028858:	4413      	add	r3, r2
 802885a:	681a      	ldr	r2, [r3, #0]
 802885c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8028860:	4413      	add	r3, r2
 8028862:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = (INT32) wsptr[2];
 8028866:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802886a:	3308      	adds	r3, #8
 802886c:	681b      	ldr	r3, [r3, #0]
 802886e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = (INT32) wsptr[6];
 8028872:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028876:	3318      	adds	r3, #24
 8028878:	681b      	ldr	r3, [r3, #0]
 802887a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 802887e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8028882:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028886:	4413      	add	r3, r2
 8028888:	f241 1251 	movw	r2, #4433	@ 0x1151
 802888c:	fb02 f303 	mul.w	r3, r2, r3
 8028890:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 8028894:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8028898:	f641 027e 	movw	r2, #6270	@ 0x187e
 802889c:	fb02 f303 	mul.w	r3, r2, r3
 80288a0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80288a4:	4413      	add	r3, r2
 80288a6:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 80288aa:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80288ae:	4abf      	ldr	r2, [pc, #764]	@ (8028bac <jpeg_idct_8x4+0x4fc>)
 80288b0:	fb02 f303 	mul.w	r3, r2, r3
 80288b4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80288b8:	4413      	add	r3, r2
 80288ba:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80288be:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80288c2:	681b      	ldr	r3, [r3, #0]
 80288c4:	3310      	adds	r3, #16
 80288c6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = (INT32) wsptr[4];
 80288ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80288ce:	3310      	adds	r3, #16
 80288d0:	681b      	ldr	r3, [r3, #0]
 80288d2:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    
    tmp0 = (z2 + z3) << CONST_BITS;
 80288d6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80288da:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80288de:	4413      	add	r3, r2
 80288e0:	035b      	lsls	r3, r3, #13
 80288e2:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp1 = (z2 - z3) << CONST_BITS;
 80288e6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80288ea:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80288ee:	1ad3      	subs	r3, r2, r3
 80288f0:	035b      	lsls	r3, r3, #13
 80288f2:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    
    tmp10 = tmp0 + tmp2;
 80288f6:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80288fa:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 80288fe:	4413      	add	r3, r2
 8028900:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    tmp13 = tmp0 - tmp2;
 8028904:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028908:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 802890c:	1ad3      	subs	r3, r2, r3
 802890e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    tmp11 = tmp1 + tmp3;
 8028912:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028916:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802891a:	4413      	add	r3, r2
 802891c:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp12 = tmp1 - tmp3;
 8028920:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028924:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028928:	1ad3      	subs	r3, r2, r3
 802892a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 802892e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028932:	331c      	adds	r3, #28
 8028934:	681b      	ldr	r3, [r3, #0]
 8028936:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp1 = (INT32) wsptr[5];
 802893a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802893e:	3314      	adds	r3, #20
 8028940:	681b      	ldr	r3, [r3, #0]
 8028942:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = (INT32) wsptr[3];
 8028946:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802894a:	330c      	adds	r3, #12
 802894c:	681b      	ldr	r3, [r3, #0]
 802894e:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp3 = (INT32) wsptr[1];
 8028952:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028956:	3304      	adds	r3, #4
 8028958:	681b      	ldr	r3, [r3, #0]
 802895a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    z2 = tmp0 + tmp2;
 802895e:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028962:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028966:	4413      	add	r3, r2
 8028968:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = tmp1 + tmp3;
 802896c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028970:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028974:	4413      	add	r3, r2
 8028976:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 802897a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802897e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028982:	4413      	add	r3, r2
 8028984:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 8028988:	fb02 f303 	mul.w	r3, r2, r3
 802898c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 8028990:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8028994:	4a86      	ldr	r2, [pc, #536]	@ (8028bb0 <jpeg_idct_8x4+0x500>)
 8028996:	fb02 f303 	mul.w	r3, r2, r3
 802899a:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 802899e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80289a2:	4a84      	ldr	r2, [pc, #528]	@ (8028bb4 <jpeg_idct_8x4+0x504>)
 80289a4:	fb02 f303 	mul.w	r3, r2, r3
 80289a8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    z2 += z1;
 80289ac:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80289b0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80289b4:	4413      	add	r3, r2
 80289b6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    z3 += z1;
 80289ba:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80289be:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80289c2:	4413      	add	r3, r2
 80289c4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80289c8:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80289cc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80289d0:	4413      	add	r3, r2
 80289d2:	4a79      	ldr	r2, [pc, #484]	@ (8028bb8 <jpeg_idct_8x4+0x508>)
 80289d4:	fb02 f303 	mul.w	r3, r2, r3
 80289d8:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 80289dc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80289e0:	f640 128e 	movw	r2, #2446	@ 0x98e
 80289e4:	fb02 f303 	mul.w	r3, r2, r3
 80289e8:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 80289ec:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80289f0:	f243 020b 	movw	r2, #12299	@ 0x300b
 80289f4:	fb02 f303 	mul.w	r3, r2, r3
 80289f8:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    tmp0 += z1 + z2;
 80289fc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028a00:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8028a04:	4413      	add	r3, r2
 8028a06:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8028a0a:	4413      	add	r3, r2
 8028a0c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    tmp3 += z1 + z3;
 8028a10:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028a14:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028a18:	4413      	add	r3, r2
 8028a1a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8028a1e:	4413      	add	r3, r2
 8028a20:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8028a24:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028a28:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028a2c:	4413      	add	r3, r2
 8028a2e:	4a63      	ldr	r2, [pc, #396]	@ (8028bbc <jpeg_idct_8x4+0x50c>)
 8028a30:	fb02 f303 	mul.w	r3, r2, r3
 8028a34:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8028a38:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8028a3c:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 8028a40:	fb02 f303 	mul.w	r3, r2, r3
 8028a44:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8028a48:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028a4c:	f246 2254 	movw	r2, #25172	@ 0x6254
 8028a50:	fb02 f303 	mul.w	r3, r2, r3
 8028a54:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    tmp1 += z1 + z3;
 8028a58:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028a5c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8028a60:	4413      	add	r3, r2
 8028a62:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8028a66:	4413      	add	r3, r2
 8028a68:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 += z1 + z2;
 8028a6c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8028a70:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8028a74:	4413      	add	r3, r2
 8028a76:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8028a7a:	4413      	add	r3, r2
 8028a7c:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8028a80:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028a84:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028a88:	4413      	add	r3, r2
 8028a8a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028a8c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8028a90:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028a94:	4413      	add	r3, r2
 8028a96:	781a      	ldrb	r2, [r3, #0]
 8028a98:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028a9c:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8028a9e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8028aa2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8028aa6:	1ad3      	subs	r3, r2, r3
 8028aa8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028aaa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8028aae:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028ab2:	441a      	add	r2, r3
 8028ab4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028ab8:	3307      	adds	r3, #7
 8028aba:	7812      	ldrb	r2, [r2, #0]
 8028abc:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8028abe:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028ac2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028ac6:	4413      	add	r3, r2
 8028ac8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028aca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8028ace:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028ad2:	441a      	add	r2, r3
 8028ad4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028ad8:	3301      	adds	r3, #1
 8028ada:	7812      	ldrb	r2, [r2, #0]
 8028adc:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8028ade:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8028ae2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8028ae6:	1ad3      	subs	r3, r2, r3
 8028ae8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028aea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8028aee:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028af2:	441a      	add	r2, r3
 8028af4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028af8:	3306      	adds	r3, #6
 8028afa:	7812      	ldrb	r2, [r2, #0]
 8028afc:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8028afe:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8028b02:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8028b06:	4413      	add	r3, r2
 8028b08:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8028b0e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028b12:	441a      	add	r2, r3
 8028b14:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028b18:	3302      	adds	r3, #2
 8028b1a:	7812      	ldrb	r2, [r2, #0]
 8028b1c:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8028b1e:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8028b22:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8028b26:	1ad3      	subs	r3, r2, r3
 8028b28:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8028b2e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028b32:	441a      	add	r2, r3
 8028b34:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028b38:	3305      	adds	r3, #5
 8028b3a:	7812      	ldrb	r2, [r2, #0]
 8028b3c:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8028b3e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8028b42:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028b46:	4413      	add	r3, r2
 8028b48:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b4a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8028b4e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028b52:	441a      	add	r2, r3
 8028b54:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028b58:	3303      	adds	r3, #3
 8028b5a:	7812      	ldrb	r2, [r2, #0]
 8028b5c:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8028b5e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8028b62:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8028b66:	1ad3      	subs	r3, r2, r3
 8028b68:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028b6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8028b6e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8028b72:	441a      	add	r2, r3
 8028b74:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8028b78:	3304      	adds	r3, #4
 8028b7a:	7812      	ldrb	r2, [r2, #0]
 8028b7c:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 8028b7e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8028b82:	3320      	adds	r3, #32
 8028b84:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 8028b88:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8028b8c:	3301      	adds	r3, #1
 8028b8e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8028b92:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8028b96:	2b03      	cmp	r3, #3
 8028b98:	f77f ae5a 	ble.w	8028850 <jpeg_idct_8x4+0x1a0>
  }
}
 8028b9c:	bf00      	nop
 8028b9e:	bf00      	nop
 8028ba0:	37dc      	adds	r7, #220	@ 0xdc
 8028ba2:	46bd      	mov	sp, r7
 8028ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028ba8:	4770      	bx	lr
 8028baa:	bf00      	nop
 8028bac:	ffffc4df 	.word	0xffffc4df
 8028bb0:	ffffc13b 	.word	0xffffc13b
 8028bb4:	fffff384 	.word	0xfffff384
 8028bb8:	ffffe333 	.word	0xffffe333
 8028bbc:	ffffadfd 	.word	0xffffadfd

08028bc0 <jpeg_idct_6x3>:

GLOBAL(void)
jpeg_idct_6x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8028bc0:	b480      	push	{r7}
 8028bc2:	b0a7      	sub	sp, #156	@ 0x9c
 8028bc4:	af00      	add	r7, sp, #0
 8028bc6:	60f8      	str	r0, [r7, #12]
 8028bc8:	60b9      	str	r1, [r7, #8]
 8028bca:	607a      	str	r2, [r7, #4]
 8028bcc:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8028bce:	68fb      	ldr	r3, [r7, #12]
 8028bd0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8028bd4:	3380      	adds	r3, #128	@ 0x80
 8028bd6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  inptr = coef_block;
 8028bda:	687b      	ldr	r3, [r7, #4]
 8028bdc:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8028be0:	68bb      	ldr	r3, [r7, #8]
 8028be2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8028be4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  wsptr = workspace;
 8028be8:	f107 0314 	add.w	r3, r7, #20
 8028bec:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8028bf0:	2300      	movs	r3, #0
 8028bf2:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8028bf6:	e06a      	b.n	8028cce <jpeg_idct_6x3+0x10e>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8028bf8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8028bfc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028c00:	461a      	mov	r2, r3
 8028c02:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8028c06:	681b      	ldr	r3, [r3, #0]
 8028c08:	fb02 f303 	mul.w	r3, r2, r3
 8028c0c:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 8028c0e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028c10:	035b      	lsls	r3, r3, #13
 8028c12:	67fb      	str	r3, [r7, #124]	@ 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8028c14:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028c16:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8028c1a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8028c1c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8028c20:	3320      	adds	r3, #32
 8028c22:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028c26:	461a      	mov	r2, r3
 8028c28:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8028c2c:	3340      	adds	r3, #64	@ 0x40
 8028c2e:	681b      	ldr	r3, [r3, #0]
 8028c30:	fb02 f303 	mul.w	r3, r2, r3
 8028c34:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 8028c36:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8028c38:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8028c3c:	fb02 f303 	mul.w	r3, r2, r3
 8028c40:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp10 = tmp0 + tmp12;
 8028c42:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8028c44:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8028c46:	4413      	add	r3, r2
 8028c48:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp2 = tmp0 - tmp12 - tmp12;
 8028c4a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8028c4c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8028c4e:	1ad2      	subs	r2, r2, r3
 8028c50:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8028c52:	1ad3      	subs	r3, r2, r3
 8028c54:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8028c56:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8028c5a:	3310      	adds	r3, #16
 8028c5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028c60:	461a      	mov	r2, r3
 8028c62:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8028c66:	3320      	adds	r3, #32
 8028c68:	681b      	ldr	r3, [r3, #0]
 8028c6a:	fb02 f303 	mul.w	r3, r2, r3
 8028c6e:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 8028c70:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8028c72:	f242 7231 	movw	r2, #10033	@ 0x2731
 8028c76:	fb02 f303 	mul.w	r3, r2, r3
 8028c7a:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8028c7c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8028c7e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028c80:	4413      	add	r3, r2
 8028c82:	12da      	asrs	r2, r3, #11
 8028c84:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028c88:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8028c8a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8028c8c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028c8e:	1ad2      	subs	r2, r2, r3
 8028c90:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028c94:	3330      	adds	r3, #48	@ 0x30
 8028c96:	12d2      	asrs	r2, r2, #11
 8028c98:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 8028c9a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028c9e:	3318      	adds	r3, #24
 8028ca0:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8028ca2:	12d2      	asrs	r2, r2, #11
 8028ca4:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8028ca6:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8028caa:	3301      	adds	r3, #1
 8028cac:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8028cb0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8028cb4:	3302      	adds	r3, #2
 8028cb6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8028cba:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8028cbe:	3304      	adds	r3, #4
 8028cc0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8028cc4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028cc8:	3304      	adds	r3, #4
 8028cca:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8028cce:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8028cd2:	2b05      	cmp	r3, #5
 8028cd4:	dd90      	ble.n	8028bf8 <jpeg_idct_6x3+0x38>
  }
  
  /* Pass 2: process 3 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 8028cd6:	f107 0314 	add.w	r3, r7, #20
 8028cda:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8028cde:	2300      	movs	r3, #0
 8028ce0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8028ce4:	e0c3      	b.n	8028e6e <jpeg_idct_6x3+0x2ae>
    outptr = output_buf[ctr] + output_col;
 8028ce6:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8028cea:	009b      	lsls	r3, r3, #2
 8028cec:	683a      	ldr	r2, [r7, #0]
 8028cee:	4413      	add	r3, r2
 8028cf0:	681a      	ldr	r2, [r3, #0]
 8028cf2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8028cf6:	4413      	add	r3, r2
 8028cf8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8028cfc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d00:	681b      	ldr	r3, [r3, #0]
 8028d02:	3310      	adds	r3, #16
 8028d04:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 8028d06:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028d08:	035b      	lsls	r3, r3, #13
 8028d0a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = (INT32) wsptr[4];
 8028d0c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d10:	3310      	adds	r3, #16
 8028d12:	681b      	ldr	r3, [r3, #0]
 8028d14:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 8028d16:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8028d18:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 8028d1c:	fb02 f303 	mul.w	r3, r2, r3
 8028d20:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp1 = tmp0 + tmp10;
 8028d22:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8028d24:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8028d26:	4413      	add	r3, r2
 8028d28:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp11 = tmp0 - tmp10 - tmp10;
 8028d2a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8028d2c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8028d2e:	1ad2      	subs	r2, r2, r3
 8028d30:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8028d32:	1ad3      	subs	r3, r2, r3
 8028d34:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp10 = (INT32) wsptr[2];
 8028d36:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d3a:	3308      	adds	r3, #8
 8028d3c:	681b      	ldr	r3, [r3, #0]
 8028d3e:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 8028d40:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8028d42:	f242 7231 	movw	r2, #10033	@ 0x2731
 8028d46:	fb02 f303 	mul.w	r3, r2, r3
 8028d4a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp10 = tmp1 + tmp0;
 8028d4c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8028d4e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028d50:	4413      	add	r3, r2
 8028d52:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp12 = tmp1 - tmp0;
 8028d54:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8028d56:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028d58:	1ad3      	subs	r3, r2, r3
 8028d5a:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8028d5c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d60:	3304      	adds	r3, #4
 8028d62:	681b      	ldr	r3, [r3, #0]
 8028d64:	667b      	str	r3, [r7, #100]	@ 0x64
    z2 = (INT32) wsptr[3];
 8028d66:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d6a:	330c      	adds	r3, #12
 8028d6c:	681b      	ldr	r3, [r3, #0]
 8028d6e:	663b      	str	r3, [r7, #96]	@ 0x60
    z3 = (INT32) wsptr[5];
 8028d70:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028d74:	3314      	adds	r3, #20
 8028d76:	681b      	ldr	r3, [r3, #0]
 8028d78:	65fb      	str	r3, [r7, #92]	@ 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8028d7a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8028d7c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028d7e:	4413      	add	r3, r2
 8028d80:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 8028d84:	fb02 f303 	mul.w	r3, r2, r3
 8028d88:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 8028d8a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8028d8c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028d8e:	4413      	add	r3, r2
 8028d90:	035b      	lsls	r3, r3, #13
 8028d92:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8028d94:	4413      	add	r3, r2
 8028d96:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 8028d98:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8028d9a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028d9c:	1ad3      	subs	r3, r2, r3
 8028d9e:	035b      	lsls	r3, r3, #13
 8028da0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8028da2:	4413      	add	r3, r2
 8028da4:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 8028da6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8028da8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028daa:	1ad2      	subs	r2, r2, r3
 8028dac:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028dae:	1ad3      	subs	r3, r2, r3
 8028db0:	035b      	lsls	r3, r3, #13
 8028db2:	673b      	str	r3, [r7, #112]	@ 0x70

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8028db4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8028db6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028db8:	4413      	add	r3, r2
 8028dba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028dbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8028dc0:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028dc4:	4413      	add	r3, r2
 8028dc6:	781a      	ldrb	r2, [r3, #0]
 8028dc8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028dcc:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8028dce:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8028dd0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8028dd2:	1ad3      	subs	r3, r2, r3
 8028dd4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028dd6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8028dda:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028dde:	441a      	add	r2, r3
 8028de0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028de4:	3305      	adds	r3, #5
 8028de6:	7812      	ldrb	r2, [r2, #0]
 8028de8:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8028dea:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8028dec:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8028dee:	4413      	add	r3, r2
 8028df0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028df2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8028df6:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028dfa:	441a      	add	r2, r3
 8028dfc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028e00:	3301      	adds	r3, #1
 8028e02:	7812      	ldrb	r2, [r2, #0]
 8028e04:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8028e06:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8028e08:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8028e0a:	1ad3      	subs	r3, r2, r3
 8028e0c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028e0e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8028e12:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028e16:	441a      	add	r2, r3
 8028e18:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028e1c:	3304      	adds	r3, #4
 8028e1e:	7812      	ldrb	r2, [r2, #0]
 8028e20:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8028e22:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8028e24:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8028e26:	4413      	add	r3, r2
 8028e28:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028e2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8028e2e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028e32:	441a      	add	r2, r3
 8028e34:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028e38:	3302      	adds	r3, #2
 8028e3a:	7812      	ldrb	r2, [r2, #0]
 8028e3c:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8028e3e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8028e40:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8028e42:	1ad3      	subs	r3, r2, r3
 8028e44:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8028e46:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8028e4a:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8028e4e:	441a      	add	r2, r3
 8028e50:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8028e54:	3303      	adds	r3, #3
 8028e56:	7812      	ldrb	r2, [r2, #0]
 8028e58:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8028e5a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8028e5e:	3318      	adds	r3, #24
 8028e60:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8028e64:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8028e68:	3301      	adds	r3, #1
 8028e6a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8028e6e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8028e72:	2b02      	cmp	r3, #2
 8028e74:	f77f af37 	ble.w	8028ce6 <jpeg_idct_6x3+0x126>
  }
}
 8028e78:	bf00      	nop
 8028e7a:	bf00      	nop
 8028e7c:	379c      	adds	r7, #156	@ 0x9c
 8028e7e:	46bd      	mov	sp, r7
 8028e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028e84:	4770      	bx	lr
	...

08028e88 <jpeg_idct_4x2>:

GLOBAL(void)
jpeg_idct_4x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8028e88:	b480      	push	{r7}
 8028e8a:	b09b      	sub	sp, #108	@ 0x6c
 8028e8c:	af00      	add	r7, sp, #0
 8028e8e:	60f8      	str	r0, [r7, #12]
 8028e90:	60b9      	str	r1, [r7, #8]
 8028e92:	607a      	str	r2, [r7, #4]
 8028e94:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8028e96:	68fb      	ldr	r3, [r7, #12]
 8028e98:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8028e9c:	3380      	adds	r3, #128	@ 0x80
 8028e9e:	657b      	str	r3, [r7, #84]	@ 0x54
  INT32 workspace[4*2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8028ea0:	687b      	ldr	r3, [r7, #4]
 8028ea2:	667b      	str	r3, [r7, #100]	@ 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8028ea4:	68bb      	ldr	r3, [r7, #8]
 8028ea6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8028ea8:	663b      	str	r3, [r7, #96]	@ 0x60
  wsptr = workspace;
 8028eaa:	f107 0314 	add.w	r3, r7, #20
 8028eae:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8028eb0:	2300      	movs	r3, #0
 8028eb2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8028eb4:	e02a      	b.n	8028f0c <jpeg_idct_4x2+0x84>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8028eb6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8028eb8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028ebc:	461a      	mov	r2, r3
 8028ebe:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028ec0:	681b      	ldr	r3, [r3, #0]
 8028ec2:	fb02 f303 	mul.w	r3, r2, r3
 8028ec6:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Odd part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8028ec8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8028eca:	3310      	adds	r3, #16
 8028ecc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8028ed0:	461a      	mov	r2, r3
 8028ed2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028ed4:	3320      	adds	r3, #32
 8028ed6:	681b      	ldr	r3, [r3, #0]
 8028ed8:	fb02 f303 	mul.w	r3, r2, r3
 8028edc:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Final output stage */

    wsptr[4*0] = tmp10 + tmp0;
 8028ede:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8028ee0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8028ee2:	441a      	add	r2, r3
 8028ee4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028ee6:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = tmp10 - tmp0;
 8028ee8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028eea:	3310      	adds	r3, #16
 8028eec:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 8028eee:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8028ef0:	1a8a      	subs	r2, r1, r2
 8028ef2:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8028ef4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8028ef6:	3301      	adds	r3, #1
 8028ef8:	65bb      	str	r3, [r7, #88]	@ 0x58
 8028efa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8028efc:	3302      	adds	r3, #2
 8028efe:	667b      	str	r3, [r7, #100]	@ 0x64
 8028f00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8028f02:	3304      	adds	r3, #4
 8028f04:	663b      	str	r3, [r7, #96]	@ 0x60
 8028f06:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028f08:	3304      	adds	r3, #4
 8028f0a:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8028f0c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8028f0e:	2b03      	cmp	r3, #3
 8028f10:	ddd1      	ble.n	8028eb6 <jpeg_idct_4x2+0x2e>

  /* Pass 2: process 2 rows from work array, store into output array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  wsptr = workspace;
 8028f12:	f107 0314 	add.w	r3, r7, #20
 8028f16:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8028f18:	2300      	movs	r3, #0
 8028f1a:	65bb      	str	r3, [r7, #88]	@ 0x58
 8028f1c:	e06a      	b.n	8028ff4 <jpeg_idct_4x2+0x16c>
    outptr = output_buf[ctr] + output_col;
 8028f1e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8028f20:	009b      	lsls	r3, r3, #2
 8028f22:	683a      	ldr	r2, [r7, #0]
 8028f24:	4413      	add	r3, r2
 8028f26:	681a      	ldr	r2, [r3, #0]
 8028f28:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8028f2a:	4413      	add	r3, r2
 8028f2c:	653b      	str	r3, [r7, #80]	@ 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = wsptr[0] + (ONE << 2);
 8028f2e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028f30:	681b      	ldr	r3, [r3, #0]
 8028f32:	3304      	adds	r3, #4
 8028f34:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp2 = wsptr[2];
 8028f36:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028f38:	689b      	ldr	r3, [r3, #8]
 8028f3a:	64bb      	str	r3, [r7, #72]	@ 0x48

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 8028f3c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8028f3e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8028f40:	4413      	add	r3, r2
 8028f42:	035b      	lsls	r3, r3, #13
 8028f44:	647b      	str	r3, [r7, #68]	@ 0x44
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8028f46:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8028f48:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8028f4a:	1ad3      	subs	r3, r2, r3
 8028f4c:	035b      	lsls	r3, r3, #13
 8028f4e:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = wsptr[1];
 8028f50:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028f52:	685b      	ldr	r3, [r3, #4]
 8028f54:	63fb      	str	r3, [r7, #60]	@ 0x3c
    z3 = wsptr[3];
 8028f56:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028f58:	68db      	ldr	r3, [r3, #12]
 8028f5a:	63bb      	str	r3, [r7, #56]	@ 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 8028f5c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8028f5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8028f60:	4413      	add	r3, r2
 8028f62:	f241 1251 	movw	r2, #4433	@ 0x1151
 8028f66:	fb02 f303 	mul.w	r3, r2, r3
 8028f6a:	637b      	str	r3, [r7, #52]	@ 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8028f6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8028f6e:	f641 027e 	movw	r2, #6270	@ 0x187e
 8028f72:	fb02 f303 	mul.w	r3, r2, r3
 8028f76:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8028f78:	4413      	add	r3, r2
 8028f7a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 8028f7c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8028f7e:	4a22      	ldr	r2, [pc, #136]	@ (8029008 <jpeg_idct_4x2+0x180>)
 8028f80:	fb02 f303 	mul.w	r3, r2, r3
 8028f84:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8028f86:	4413      	add	r3, r2
 8028f88:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8028f8a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8028f8c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8028f8e:	4413      	add	r3, r2
 8028f90:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8028f92:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8028f96:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8028f98:	4413      	add	r3, r2
 8028f9a:	781a      	ldrb	r2, [r3, #0]
 8028f9c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8028f9e:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8028fa0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8028fa2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8028fa4:	1ad3      	subs	r3, r2, r3
 8028fa6:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8028fa8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8028fac:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8028fae:	441a      	add	r2, r3
 8028fb0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8028fb2:	3303      	adds	r3, #3
 8028fb4:	7812      	ldrb	r2, [r2, #0]
 8028fb6:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8028fb8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8028fba:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8028fbc:	4413      	add	r3, r2
 8028fbe:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8028fc0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8028fc4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8028fc6:	441a      	add	r2, r3
 8028fc8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8028fca:	3301      	adds	r3, #1
 8028fcc:	7812      	ldrb	r2, [r2, #0]
 8028fce:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8028fd0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8028fd2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8028fd4:	1ad3      	subs	r3, r2, r3
 8028fd6:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8028fd8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8028fdc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8028fde:	441a      	add	r2, r3
 8028fe0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8028fe2:	3302      	adds	r3, #2
 8028fe4:	7812      	ldrb	r2, [r2, #0]
 8028fe6:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 8028fe8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8028fea:	3310      	adds	r3, #16
 8028fec:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8028fee:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8028ff0:	3301      	adds	r3, #1
 8028ff2:	65bb      	str	r3, [r7, #88]	@ 0x58
 8028ff4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8028ff6:	2b01      	cmp	r3, #1
 8028ff8:	dd91      	ble.n	8028f1e <jpeg_idct_4x2+0x96>
  }
}
 8028ffa:	bf00      	nop
 8028ffc:	bf00      	nop
 8028ffe:	376c      	adds	r7, #108	@ 0x6c
 8029000:	46bd      	mov	sp, r7
 8029002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029006:	4770      	bx	lr
 8029008:	ffffc4df 	.word	0xffffc4df

0802900c <jpeg_idct_2x1>:

GLOBAL(void)
jpeg_idct_2x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802900c:	b480      	push	{r7}
 802900e:	b08b      	sub	sp, #44	@ 0x2c
 8029010:	af00      	add	r7, sp, #0
 8029012:	60f8      	str	r0, [r7, #12]
 8029014:	60b9      	str	r1, [r7, #8]
 8029016:	607a      	str	r2, [r7, #4]
 8029018:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802901a:	68fb      	ldr	r3, [r7, #12]
 802901c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8029020:	3380      	adds	r3, #128	@ 0x80
 8029022:	627b      	str	r3, [r7, #36]	@ 0x24

  /* Pass 1: empty. */

  /* Pass 2: process 1 row from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8029024:	68bb      	ldr	r3, [r7, #8]
 8029026:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8029028:	623b      	str	r3, [r7, #32]
  outptr = output_buf[0] + output_col;
 802902a:	683b      	ldr	r3, [r7, #0]
 802902c:	681a      	ldr	r2, [r3, #0]
 802902e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8029030:	4413      	add	r3, r2
 8029032:	61fb      	str	r3, [r7, #28]

  /* Even part */

  tmp10 = DEQUANTIZE(coef_block[0], quantptr[0]);
 8029034:	687b      	ldr	r3, [r7, #4]
 8029036:	f9b3 3000 	ldrsh.w	r3, [r3]
 802903a:	461a      	mov	r2, r3
 802903c:	6a3b      	ldr	r3, [r7, #32]
 802903e:	681b      	ldr	r3, [r3, #0]
 8029040:	fb02 f303 	mul.w	r3, r2, r3
 8029044:	61bb      	str	r3, [r7, #24]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 8029046:	69bb      	ldr	r3, [r7, #24]
 8029048:	3304      	adds	r3, #4
 802904a:	61bb      	str	r3, [r7, #24]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[1], quantptr[1]);
 802904c:	687b      	ldr	r3, [r7, #4]
 802904e:	3302      	adds	r3, #2
 8029050:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029054:	461a      	mov	r2, r3
 8029056:	6a3b      	ldr	r3, [r7, #32]
 8029058:	3304      	adds	r3, #4
 802905a:	681b      	ldr	r3, [r3, #0]
 802905c:	fb02 f303 	mul.w	r3, r2, r3
 8029060:	617b      	str	r3, [r7, #20]

  /* Final output stage */

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3) & RANGE_MASK];
 8029062:	69ba      	ldr	r2, [r7, #24]
 8029064:	697b      	ldr	r3, [r7, #20]
 8029066:	4413      	add	r3, r2
 8029068:	10db      	asrs	r3, r3, #3
 802906a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 802906e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029070:	4413      	add	r3, r2
 8029072:	781a      	ldrb	r2, [r3, #0]
 8029074:	69fb      	ldr	r3, [r7, #28]
 8029076:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3) & RANGE_MASK];
 8029078:	69ba      	ldr	r2, [r7, #24]
 802907a:	697b      	ldr	r3, [r7, #20]
 802907c:	1ad3      	subs	r3, r2, r3
 802907e:	10db      	asrs	r3, r3, #3
 8029080:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8029084:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8029086:	441a      	add	r2, r3
 8029088:	69fb      	ldr	r3, [r7, #28]
 802908a:	3301      	adds	r3, #1
 802908c:	7812      	ldrb	r2, [r2, #0]
 802908e:	701a      	strb	r2, [r3, #0]
}
 8029090:	bf00      	nop
 8029092:	372c      	adds	r7, #44	@ 0x2c
 8029094:	46bd      	mov	sp, r7
 8029096:	f85d 7b04 	ldr.w	r7, [sp], #4
 802909a:	4770      	bx	lr

0802909c <jpeg_idct_8x16>:

GLOBAL(void)
jpeg_idct_8x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802909c:	b490      	push	{r4, r7}
 802909e:	f5ad 7d1e 	sub.w	sp, sp, #632	@ 0x278
 80290a2:	af00      	add	r7, sp, #0
 80290a4:	f507 741e 	add.w	r4, r7, #632	@ 0x278
 80290a8:	f5a4 741b 	sub.w	r4, r4, #620	@ 0x26c
 80290ac:	6020      	str	r0, [r4, #0]
 80290ae:	f507 701e 	add.w	r0, r7, #632	@ 0x278
 80290b2:	f5a0 701c 	sub.w	r0, r0, #624	@ 0x270
 80290b6:	6001      	str	r1, [r0, #0]
 80290b8:	f507 711e 	add.w	r1, r7, #632	@ 0x278
 80290bc:	f5a1 711d 	sub.w	r1, r1, #628	@ 0x274
 80290c0:	600a      	str	r2, [r1, #0]
 80290c2:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 80290c6:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 80290ca:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80290cc:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80290d0:	f5a3 731b 	sub.w	r3, r3, #620	@ 0x26c
 80290d4:	681b      	ldr	r3, [r3, #0]
 80290d6:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 80290da:	3380      	adds	r3, #128	@ 0x80
 80290dc:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  inptr = coef_block;
 80290e0:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80290e4:	f5a3 731d 	sub.w	r3, r3, #628	@ 0x274
 80290e8:	681b      	ldr	r3, [r3, #0]
 80290ea:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80290ee:	f507 731e 	add.w	r3, r7, #632	@ 0x278
 80290f2:	f5a3 731c 	sub.w	r3, r3, #624	@ 0x270
 80290f6:	681b      	ldr	r3, [r3, #0]
 80290f8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80290fa:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
  wsptr = workspace;
 80290fe:	f107 0310 	add.w	r3, r7, #16
 8029102:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8029106:	2300      	movs	r3, #0
 8029108:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 802910c:	e30a      	b.n	8029724 <jpeg_idct_8x16+0x688>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802910e:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8029112:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029116:	461a      	mov	r2, r3
 8029118:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802911c:	681b      	ldr	r3, [r3, #0]
 802911e:	fb02 f303 	mul.w	r3, r2, r3
 8029122:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp0 <<= CONST_BITS;
 8029126:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 802912a:	035b      	lsls	r3, r3, #13
 802912c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8029130:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029134:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8029138:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802913c:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8029140:	3340      	adds	r3, #64	@ 0x40
 8029142:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029146:	461a      	mov	r2, r3
 8029148:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802914c:	3380      	adds	r3, #128	@ 0x80
 802914e:	681b      	ldr	r3, [r3, #0]
 8029150:	fb02 f303 	mul.w	r3, r2, r3
 8029154:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8029158:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802915c:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 8029160:	fb02 f303 	mul.w	r3, r2, r3
 8029164:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8029168:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802916c:	f241 1251 	movw	r2, #4433	@ 0x1151
 8029170:	fb02 f303 	mul.w	r3, r2, r3
 8029174:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250

    tmp10 = tmp0 + tmp1;
 8029178:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 802917c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8029180:	4413      	add	r3, r2
 8029182:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 = tmp0 - tmp1;
 8029186:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 802918a:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802918e:	1ad3      	subs	r3, r2, r3
 8029190:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = tmp0 + tmp2;
 8029194:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8029198:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802919c:	4413      	add	r3, r2
 802919e:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp13 = tmp0 - tmp2;
 80291a2:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80291a6:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80291aa:	1ad3      	subs	r3, r2, r3
 80291ac:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80291b0:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80291b4:	3320      	adds	r3, #32
 80291b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80291ba:	461a      	mov	r2, r3
 80291bc:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80291c0:	3340      	adds	r3, #64	@ 0x40
 80291c2:	681b      	ldr	r3, [r3, #0]
 80291c4:	fb02 f303 	mul.w	r3, r2, r3
 80291c8:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80291cc:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80291d0:	3360      	adds	r3, #96	@ 0x60
 80291d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80291d6:	461a      	mov	r2, r3
 80291d8:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80291dc:	33c0      	adds	r3, #192	@ 0xc0
 80291de:	681b      	ldr	r3, [r3, #0]
 80291e0:	fb02 f303 	mul.w	r3, r2, r3
 80291e4:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = z1 - z2;
 80291e8:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80291ec:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80291f0:	1ad3      	subs	r3, r2, r3
 80291f2:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 80291f6:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80291fa:	f640 02d4 	movw	r2, #2260	@ 0x8d4
 80291fe:	fb02 f303 	mul.w	r3, r2, r3
 8029202:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8029206:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802920a:	f642 4263 	movw	r2, #11363	@ 0x2c63
 802920e:	fb02 f303 	mul.w	r3, r2, r3
 8029212:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8029216:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802921a:	f245 2203 	movw	r2, #20995	@ 0x5203
 802921e:	fb02 f303 	mul.w	r3, r2, r3
 8029222:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8029226:	4413      	add	r3, r2
 8029228:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 802922c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029230:	f641 42cd 	movw	r2, #7373	@ 0x1ccd
 8029234:	fb02 f303 	mul.w	r3, r2, r3
 8029238:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802923c:	4413      	add	r3, r2
 802923e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8029242:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029246:	4af4      	ldr	r2, [pc, #976]	@ (8029618 <jpeg_idct_8x16+0x57c>)
 8029248:	fb02 f303 	mul.w	r3, r2, r3
 802924c:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8029250:	4413      	add	r3, r2
 8029252:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8029256:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802925a:	4af0      	ldr	r2, [pc, #960]	@ (802961c <jpeg_idct_8x16+0x580>)
 802925c:	fb02 f303 	mul.w	r3, r2, r3
 8029260:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 8029264:	4413      	add	r3, r2
 8029266:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c

    tmp20 = tmp10 + tmp0;
 802926a:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 802926e:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029272:	4413      	add	r3, r2
 8029274:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
    tmp27 = tmp10 - tmp0;
 8029278:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 802927c:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029280:	1ad3      	subs	r3, r2, r3
 8029282:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    tmp21 = tmp12 + tmp1;
 8029286:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802928a:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802928e:	4413      	add	r3, r2
 8029290:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
    tmp26 = tmp12 - tmp1;
 8029294:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8029298:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802929c:	1ad3      	subs	r3, r2, r3
 802929e:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    tmp22 = tmp13 + tmp2;
 80292a2:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80292a6:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80292aa:	4413      	add	r3, r2
 80292ac:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    tmp25 = tmp13 - tmp2;
 80292b0:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 80292b4:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80292b8:	1ad3      	subs	r3, r2, r3
 80292ba:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    tmp23 = tmp11 + tmp3;
 80292be:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80292c2:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80292c6:	4413      	add	r3, r2
 80292c8:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    tmp24 = tmp11 - tmp3;
 80292cc:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80292d0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80292d4:	1ad3      	subs	r3, r2, r3
 80292d6:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80292da:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80292de:	3310      	adds	r3, #16
 80292e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80292e4:	461a      	mov	r2, r3
 80292e6:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 80292ea:	3320      	adds	r3, #32
 80292ec:	681b      	ldr	r3, [r3, #0]
 80292ee:	fb02 f303 	mul.w	r3, r2, r3
 80292f2:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80292f6:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 80292fa:	3330      	adds	r3, #48	@ 0x30
 80292fc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029300:	461a      	mov	r2, r3
 8029302:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8029306:	3360      	adds	r3, #96	@ 0x60
 8029308:	681b      	ldr	r3, [r3, #0]
 802930a:	fb02 f303 	mul.w	r3, r2, r3
 802930e:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8029312:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8029316:	3350      	adds	r3, #80	@ 0x50
 8029318:	f9b3 3000 	ldrsh.w	r3, [r3]
 802931c:	461a      	mov	r2, r3
 802931e:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8029322:	33a0      	adds	r3, #160	@ 0xa0
 8029324:	681b      	ldr	r3, [r3, #0]
 8029326:	fb02 f303 	mul.w	r3, r2, r3
 802932a:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802932e:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 8029332:	3370      	adds	r3, #112	@ 0x70
 8029334:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029338:	461a      	mov	r2, r3
 802933a:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 802933e:	33e0      	adds	r3, #224	@ 0xe0
 8029340:	681b      	ldr	r3, [r3, #0]
 8029342:	fb02 f303 	mul.w	r3, r2, r3
 8029346:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230

    tmp11 = z1 + z3;
 802934a:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802934e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029352:	4413      	add	r3, r2
 8029354:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8029358:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802935c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029360:	4413      	add	r3, r2
 8029362:	f642 324e 	movw	r2, #11086	@ 0x2b4e
 8029366:	fb02 f303 	mul.w	r3, r2, r3
 802936a:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 802936e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8029372:	f242 72e9 	movw	r2, #10217	@ 0x27e9
 8029376:	fb02 f303 	mul.w	r3, r2, r3
 802937a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 802937e:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8029382:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8029386:	4413      	add	r3, r2
 8029388:	f242 22fc 	movw	r2, #8956	@ 0x22fc
 802938c:	fb02 f303 	mul.w	r3, r2, r3
 8029390:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8029394:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8029398:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802939c:	1ad3      	subs	r3, r2, r3
 802939e:	f641 42b6 	movw	r2, #7350	@ 0x1cb6
 80293a2:	fb02 f303 	mul.w	r3, r2, r3
 80293a6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 80293aa:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80293ae:	f241 5255 	movw	r2, #5461	@ 0x1555
 80293b2:	fb02 f303 	mul.w	r3, r2, r3
 80293b6:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 80293ba:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80293be:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80293c2:	1ad3      	subs	r3, r2, r3
 80293c4:	f640 5223 	movw	r2, #3363	@ 0xd23
 80293c8:	fb02 f303 	mul.w	r3, r2, r3
 80293cc:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    tmp0  = tmp1 + tmp2 + tmp3 -
 80293d0:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80293d4:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80293d8:	441a      	add	r2, r3
 80293da:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80293de:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 80293e0:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80293e4:	498e      	ldr	r1, [pc, #568]	@ (8029620 <jpeg_idct_8x16+0x584>)
 80293e6:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 80293ea:	4413      	add	r3, r2
 80293ec:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp13 = tmp10 + tmp11 + tmp12 -
 80293f0:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 80293f4:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 80293f8:	441a      	add	r2, r3
 80293fa:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80293fe:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8029400:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029404:	4987      	ldr	r1, [pc, #540]	@ (8029624 <jpeg_idct_8x16+0x588>)
 8029406:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 802940a:	4413      	add	r3, r2
 802940c:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8029410:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8029414:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029418:	4413      	add	r3, r2
 802941a:	f44f 628e 	mov.w	r2, #1136	@ 0x470
 802941e:	fb02 f303 	mul.w	r3, r2, r3
 8029422:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8029426:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802942a:	f240 224d 	movw	r2, #589	@ 0x24d
 802942e:	fb03 f202 	mul.w	r2, r3, r2
 8029432:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029436:	4413      	add	r3, r2
 8029438:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802943c:	4413      	add	r3, r2
 802943e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8029442:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029446:	4a78      	ldr	r2, [pc, #480]	@ (8029628 <jpeg_idct_8x16+0x58c>)
 8029448:	fb03 f202 	mul.w	r2, r3, r2
 802944c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029450:	4413      	add	r3, r2
 8029452:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8029456:	4413      	add	r3, r2
 8029458:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 802945c:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 8029460:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029464:	1ad3      	subs	r3, r2, r3
 8029466:	f642 5209 	movw	r2, #11529	@ 0x2d09
 802946a:	fb02 f303 	mul.w	r3, r2, r3
 802946e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 8029472:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029476:	4a6d      	ldr	r2, [pc, #436]	@ (802962c <jpeg_idct_8x16+0x590>)
 8029478:	fb03 f202 	mul.w	r2, r3, r2
 802947c:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 8029480:	4413      	add	r3, r2
 8029482:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 8029486:	4413      	add	r3, r2
 8029488:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 802948c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029490:	f643 721a 	movw	r2, #16154	@ 0x3f1a
 8029494:	fb03 f202 	mul.w	r2, r3, r2
 8029498:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 802949c:	4413      	add	r3, r2
 802949e:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80294a2:	4413      	add	r3, r2
 80294a4:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z2    += z4;
 80294a8:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80294ac:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80294b0:	4413      	add	r3, r2
 80294b2:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 80294b6:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80294ba:	4a5d      	ldr	r2, [pc, #372]	@ (8029630 <jpeg_idct_8x16+0x594>)
 80294bc:	fb02 f303 	mul.w	r3, r2, r3
 80294c0:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1  += z1;
 80294c4:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 80294c8:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80294cc:	4413      	add	r3, r2
 80294ce:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 80294d2:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 80294d6:	f242 2218 	movw	r2, #8728	@ 0x2218
 80294da:	fb03 f202 	mul.w	r2, r3, r2
 80294de:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80294e2:	4413      	add	r3, r2
 80294e4:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 80294e8:	4413      	add	r3, r2
 80294ea:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 80294ee:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80294f2:	4a50      	ldr	r2, [pc, #320]	@ (8029634 <jpeg_idct_8x16+0x598>)
 80294f4:	fb02 f303 	mul.w	r3, r2, r3
 80294f8:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 80294fc:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 8029500:	f246 4285 	movw	r2, #25733	@ 0x6485
 8029504:	fb03 f202 	mul.w	r2, r3, r2
 8029508:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802950c:	4413      	add	r3, r2
 802950e:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8029512:	4413      	add	r3, r2
 8029514:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp12 += z2;
 8029518:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 802951c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029520:	4413      	add	r3, r2
 8029522:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8029526:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 802952a:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802952e:	4413      	add	r3, r2
 8029530:	4a41      	ldr	r2, [pc, #260]	@ (8029638 <jpeg_idct_8x16+0x59c>)
 8029532:	fb02 f303 	mul.w	r3, r2, r3
 8029536:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp2  += z2;
 802953a:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 802953e:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029542:	4413      	add	r3, r2
 8029544:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3  += z2;
 8029548:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 802954c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029550:	4413      	add	r3, r2
 8029552:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8029556:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802955a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802955e:	1ad3      	subs	r3, r2, r3
 8029560:	f640 5223 	movw	r2, #3363	@ 0xd23
 8029564:	fb02 f303 	mul.w	r3, r2, r3
 8029568:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    tmp10 += z2;
 802956c:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8029570:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029574:	4413      	add	r3, r2
 8029576:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp11 += z2;
 802957a:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802957e:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 8029582:	4413      	add	r3, r2
 8029584:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 8029588:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 802958c:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029590:	4413      	add	r3, r2
 8029592:	12da      	asrs	r2, r3, #11
 8029594:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029598:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 802959a:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 802959e:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80295a2:	1ad2      	subs	r2, r2, r3
 80295a4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80295a8:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
 80295ac:	12d2      	asrs	r2, r2, #11
 80295ae:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 80295b0:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80295b4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80295b8:	441a      	add	r2, r3
 80295ba:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80295be:	3320      	adds	r3, #32
 80295c0:	12d2      	asrs	r2, r2, #11
 80295c2:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 80295c4:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 80295c8:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80295cc:	1ad2      	subs	r2, r2, r3
 80295ce:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80295d2:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80295d6:	12d2      	asrs	r2, r2, #11
 80295d8:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 80295da:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80295de:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80295e2:	441a      	add	r2, r3
 80295e4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80295e8:	3340      	adds	r3, #64	@ 0x40
 80295ea:	12d2      	asrs	r2, r2, #11
 80295ec:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 80295ee:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
 80295f2:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80295f6:	1ad2      	subs	r2, r2, r3
 80295f8:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80295fc:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
 8029600:	12d2      	asrs	r2, r2, #11
 8029602:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 8029604:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8029608:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802960c:	441a      	add	r2, r3
 802960e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029612:	3360      	adds	r3, #96	@ 0x60
 8029614:	12d2      	asrs	r2, r2, #11
 8029616:	e011      	b.n	802963c <jpeg_idct_8x16+0x5a0>
 8029618:	ffffecc2 	.word	0xffffecc2
 802961c:	ffffefb0 	.word	0xffffefb0
 8029620:	ffffb6d6 	.word	0xffffb6d6
 8029624:	ffffc542 	.word	0xffffc542
 8029628:	ffffdbfa 	.word	0xffffdbfa
 802962c:	ffffe77a 	.word	0xffffe77a
 8029630:	ffffeaab 	.word	0xffffeaab
 8029634:	ffffd817 	.word	0xffffd817
 8029638:	ffffd4b2 	.word	0xffffd4b2
 802963c:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 802963e:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 8029642:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8029646:	1ad2      	subs	r2, r2, r3
 8029648:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802964c:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 8029650:	12d2      	asrs	r2, r2, #11
 8029652:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 8029654:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8029658:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802965c:	441a      	add	r2, r3
 802965e:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029662:	3380      	adds	r3, #128	@ 0x80
 8029664:	12d2      	asrs	r2, r2, #11
 8029666:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 8029668:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 802966c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 8029670:	1ad2      	subs	r2, r2, r3
 8029672:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029676:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
 802967a:	12d2      	asrs	r2, r2, #11
 802967c:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 802967e:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8029682:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8029686:	441a      	add	r2, r3
 8029688:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802968c:	33a0      	adds	r3, #160	@ 0xa0
 802968e:	12d2      	asrs	r2, r2, #11
 8029690:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 8029692:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8029696:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802969a:	1ad2      	subs	r2, r2, r3
 802969c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80296a0:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
 80296a4:	12d2      	asrs	r2, r2, #11
 80296a6:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 80296a8:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80296ac:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80296b0:	441a      	add	r2, r3
 80296b2:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80296b6:	33c0      	adds	r3, #192	@ 0xc0
 80296b8:	12d2      	asrs	r2, r2, #11
 80296ba:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 80296bc:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 80296c0:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 80296c4:	1ad2      	subs	r2, r2, r3
 80296c6:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80296ca:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80296ce:	12d2      	asrs	r2, r2, #11
 80296d0:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 80296d2:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80296d6:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80296da:	441a      	add	r2, r3
 80296dc:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80296e0:	33e0      	adds	r3, #224	@ 0xe0
 80296e2:	12d2      	asrs	r2, r2, #11
 80296e4:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 80296e6:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 80296ea:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80296ee:	1ad2      	subs	r2, r2, r3
 80296f0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80296f4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80296f8:	12d2      	asrs	r2, r2, #11
 80296fa:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80296fc:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8029700:	3301      	adds	r3, #1
 8029702:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8029706:	f8d7 3274 	ldr.w	r3, [r7, #628]	@ 0x274
 802970a:	3302      	adds	r3, #2
 802970c:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
 8029710:	f8d7 3270 	ldr.w	r3, [r7, #624]	@ 0x270
 8029714:	3304      	adds	r3, #4
 8029716:	f8c7 3270 	str.w	r3, [r7, #624]	@ 0x270
 802971a:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802971e:	3304      	adds	r3, #4
 8029720:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
 8029724:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8029728:	2b07      	cmp	r3, #7
 802972a:	f77f acf0 	ble.w	802910e <jpeg_idct_8x16+0x72>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 802972e:	f107 0310 	add.w	r3, r7, #16
 8029732:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 8029736:	2300      	movs	r3, #0
 8029738:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 802973c:	e1a4      	b.n	8029a88 <jpeg_idct_8x16+0x9ec>
    outptr = output_buf[ctr] + output_col;
 802973e:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8029742:	009b      	lsls	r3, r3, #2
 8029744:	f507 721e 	add.w	r2, r7, #632	@ 0x278
 8029748:	f5a2 721e 	sub.w	r2, r2, #632	@ 0x278
 802974c:	6812      	ldr	r2, [r2, #0]
 802974e:	4413      	add	r3, r2
 8029750:	681a      	ldr	r2, [r3, #0]
 8029752:	f8d7 3280 	ldr.w	r3, [r7, #640]	@ 0x280
 8029756:	4413      	add	r3, r2
 8029758:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 802975c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029760:	3308      	adds	r3, #8
 8029762:	681b      	ldr	r3, [r3, #0]
 8029764:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = (INT32) wsptr[6];
 8029768:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802976c:	3318      	adds	r3, #24
 802976e:	681b      	ldr	r3, [r3, #0]
 8029770:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8029774:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8029778:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802977c:	4413      	add	r3, r2
 802977e:	f241 1251 	movw	r2, #4433	@ 0x1151
 8029782:	fb02 f303 	mul.w	r3, r2, r3
 8029786:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 802978a:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802978e:	f641 027e 	movw	r2, #6270	@ 0x187e
 8029792:	fb02 f303 	mul.w	r3, r2, r3
 8029796:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802979a:	4413      	add	r3, r2
 802979c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 80297a0:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80297a4:	4abe      	ldr	r2, [pc, #760]	@ (8029aa0 <jpeg_idct_8x16+0xa04>)
 80297a6:	fb02 f303 	mul.w	r3, r2, r3
 80297aa:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80297ae:	4413      	add	r3, r2
 80297b0:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80297b4:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80297b8:	681b      	ldr	r3, [r3, #0]
 80297ba:	3310      	adds	r3, #16
 80297bc:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = (INT32) wsptr[4];
 80297c0:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 80297c4:	3310      	adds	r3, #16
 80297c6:	681b      	ldr	r3, [r3, #0]
 80297c8:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    
    tmp0 = (z2 + z3) << CONST_BITS;
 80297cc:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80297d0:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80297d4:	4413      	add	r3, r2
 80297d6:	035b      	lsls	r3, r3, #13
 80297d8:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = (z2 - z3) << CONST_BITS;
 80297dc:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80297e0:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80297e4:	1ad3      	subs	r3, r2, r3
 80297e6:	035b      	lsls	r3, r3, #13
 80297e8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    
    tmp10 = tmp0 + tmp2;
 80297ec:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80297f0:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80297f4:	4413      	add	r3, r2
 80297f6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
    tmp13 = tmp0 - tmp2;
 80297fa:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80297fe:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8029802:	1ad3      	subs	r3, r2, r3
 8029804:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    tmp11 = tmp1 + tmp3;
 8029808:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802980c:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8029810:	4413      	add	r3, r2
 8029812:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    tmp12 = tmp1 - tmp3;
 8029816:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802981a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802981e:	1ad3      	subs	r3, r2, r3
 8029820:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = (INT32) wsptr[7];
 8029824:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029828:	331c      	adds	r3, #28
 802982a:	681b      	ldr	r3, [r3, #0]
 802982c:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp1 = (INT32) wsptr[5];
 8029830:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029834:	3314      	adds	r3, #20
 8029836:	681b      	ldr	r3, [r3, #0]
 8029838:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = (INT32) wsptr[3];
 802983c:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029840:	330c      	adds	r3, #12
 8029842:	681b      	ldr	r3, [r3, #0]
 8029844:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp3 = (INT32) wsptr[1];
 8029848:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 802984c:	3304      	adds	r3, #4
 802984e:	681b      	ldr	r3, [r3, #0]
 8029850:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    
    z2 = tmp0 + tmp2;
 8029854:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8029858:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 802985c:	4413      	add	r3, r2
 802985e:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = tmp1 + tmp3;
 8029862:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 8029866:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802986a:	4413      	add	r3, r2
 802986c:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8029870:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 8029874:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029878:	4413      	add	r3, r2
 802987a:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 802987e:	fb02 f303 	mul.w	r3, r2, r3
 8029882:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 8029886:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802988a:	4a86      	ldr	r2, [pc, #536]	@ (8029aa4 <jpeg_idct_8x16+0xa08>)
 802988c:	fb02 f303 	mul.w	r3, r2, r3
 8029890:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 8029894:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029898:	4a83      	ldr	r2, [pc, #524]	@ (8029aa8 <jpeg_idct_8x16+0xa0c>)
 802989a:	fb02 f303 	mul.w	r3, r2, r3
 802989e:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
    z2 += z1;
 80298a2:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 80298a6:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80298aa:	4413      	add	r3, r2
 80298ac:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
    z3 += z1;
 80298b0:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 80298b4:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80298b8:	4413      	add	r3, r2
 80298ba:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80298be:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 80298c2:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80298c6:	4413      	add	r3, r2
 80298c8:	4a78      	ldr	r2, [pc, #480]	@ (8029aac <jpeg_idct_8x16+0xa10>)
 80298ca:	fb02 f303 	mul.w	r3, r2, r3
 80298ce:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 80298d2:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 80298d6:	f640 128e 	movw	r2, #2446	@ 0x98e
 80298da:	fb02 f303 	mul.w	r3, r2, r3
 80298de:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 80298e2:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80298e6:	f243 020b 	movw	r2, #12299	@ 0x300b
 80298ea:	fb02 f303 	mul.w	r3, r2, r3
 80298ee:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
    tmp0 += z1 + z2;
 80298f2:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 80298f6:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 80298fa:	4413      	add	r3, r2
 80298fc:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 8029900:	4413      	add	r3, r2
 8029902:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
    tmp3 += z1 + z3;
 8029906:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 802990a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802990e:	4413      	add	r3, r2
 8029910:	f8d7 224c 	ldr.w	r2, [r7, #588]	@ 0x24c
 8029914:	4413      	add	r3, r2
 8029916:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 802991a:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802991e:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8029922:	4413      	add	r3, r2
 8029924:	4a62      	ldr	r2, [pc, #392]	@ (8029ab0 <jpeg_idct_8x16+0xa14>)
 8029926:	fb02 f303 	mul.w	r3, r2, r3
 802992a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 802992e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8029932:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 8029936:	fb02 f303 	mul.w	r3, r2, r3
 802993a:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 802993e:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 8029942:	f246 2254 	movw	r2, #25172	@ 0x6254
 8029946:	fb02 f303 	mul.w	r3, r2, r3
 802994a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    tmp1 += z1 + z3;
 802994e:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8029952:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8029956:	4413      	add	r3, r2
 8029958:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 802995c:	4413      	add	r3, r2
 802995e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
    tmp2 += z1 + z2;
 8029962:	f8d7 2254 	ldr.w	r2, [r7, #596]	@ 0x254
 8029966:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 802996a:	4413      	add	r3, r2
 802996c:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 8029970:	4413      	add	r3, r2
 8029972:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8029976:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 802997a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802997e:	4413      	add	r3, r2
 8029980:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029982:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8029986:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 802998a:	4413      	add	r3, r2
 802998c:	781a      	ldrb	r2, [r3, #0]
 802998e:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8029992:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8029994:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 8029998:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 802999c:	1ad3      	subs	r3, r2, r3
 802999e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80299a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80299a4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80299a8:	441a      	add	r2, r3
 80299aa:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80299ae:	3307      	adds	r3, #7
 80299b0:	7812      	ldrb	r2, [r2, #0]
 80299b2:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80299b4:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80299b8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80299bc:	4413      	add	r3, r2
 80299be:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80299c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80299c4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80299c8:	441a      	add	r2, r3
 80299ca:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80299ce:	3301      	adds	r3, #1
 80299d0:	7812      	ldrb	r2, [r2, #0]
 80299d2:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 80299d4:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 80299d8:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 80299dc:	1ad3      	subs	r3, r2, r3
 80299de:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80299e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 80299e4:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 80299e8:	441a      	add	r2, r3
 80299ea:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80299ee:	3306      	adds	r3, #6
 80299f0:	7812      	ldrb	r2, [r2, #0]
 80299f2:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 80299f4:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 80299f8:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80299fc:	4413      	add	r3, r2
 80299fe:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029a00:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8029a04:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8029a08:	441a      	add	r2, r3
 8029a0a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8029a0e:	3302      	adds	r3, #2
 8029a10:	7812      	ldrb	r2, [r2, #0]
 8029a12:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8029a14:	f8d7 2234 	ldr.w	r2, [r7, #564]	@ 0x234
 8029a18:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8029a1c:	1ad3      	subs	r3, r2, r3
 8029a1e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029a20:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8029a24:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8029a28:	441a      	add	r2, r3
 8029a2a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8029a2e:	3305      	adds	r3, #5
 8029a30:	7812      	ldrb	r2, [r2, #0]
 8029a32:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8029a34:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8029a38:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029a3c:	4413      	add	r3, r2
 8029a3e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029a40:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8029a44:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8029a48:	441a      	add	r2, r3
 8029a4a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8029a4e:	3303      	adds	r3, #3
 8029a50:	7812      	ldrb	r2, [r2, #0]
 8029a52:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8029a54:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8029a58:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 8029a5c:	1ad3      	subs	r3, r2, r3
 8029a5e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8029a60:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8029a64:	f8d7 2264 	ldr.w	r2, [r7, #612]	@ 0x264
 8029a68:	441a      	add	r2, r3
 8029a6a:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8029a6e:	3304      	adds	r3, #4
 8029a70:	7812      	ldrb	r2, [r2, #0]
 8029a72:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 8029a74:	f8d7 326c 	ldr.w	r3, [r7, #620]	@ 0x26c
 8029a78:	3320      	adds	r3, #32
 8029a7a:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 8029a7e:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8029a82:	3301      	adds	r3, #1
 8029a84:	f8c7 3268 	str.w	r3, [r7, #616]	@ 0x268
 8029a88:	f8d7 3268 	ldr.w	r3, [r7, #616]	@ 0x268
 8029a8c:	2b0f      	cmp	r3, #15
 8029a8e:	f77f ae56 	ble.w	802973e <jpeg_idct_8x16+0x6a2>
  }
}
 8029a92:	bf00      	nop
 8029a94:	bf00      	nop
 8029a96:	f507 771e 	add.w	r7, r7, #632	@ 0x278
 8029a9a:	46bd      	mov	sp, r7
 8029a9c:	bc90      	pop	{r4, r7}
 8029a9e:	4770      	bx	lr
 8029aa0:	ffffc4df 	.word	0xffffc4df
 8029aa4:	ffffc13b 	.word	0xffffc13b
 8029aa8:	fffff384 	.word	0xfffff384
 8029aac:	ffffe333 	.word	0xffffe333
 8029ab0:	ffffadfd 	.word	0xffffadfd

08029ab4 <jpeg_idct_7x14>:

GLOBAL(void)
jpeg_idct_7x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8029ab4:	b490      	push	{r4, r7}
 8029ab6:	b0fe      	sub	sp, #504	@ 0x1f8
 8029ab8:	af00      	add	r7, sp, #0
 8029aba:	f507 74fc 	add.w	r4, r7, #504	@ 0x1f8
 8029abe:	f5a4 74f6 	sub.w	r4, r4, #492	@ 0x1ec
 8029ac2:	6020      	str	r0, [r4, #0]
 8029ac4:	f507 70fc 	add.w	r0, r7, #504	@ 0x1f8
 8029ac8:	f5a0 70f8 	sub.w	r0, r0, #496	@ 0x1f0
 8029acc:	6001      	str	r1, [r0, #0]
 8029ace:	f507 71fc 	add.w	r1, r7, #504	@ 0x1f8
 8029ad2:	f5a1 71fa 	sub.w	r1, r1, #500	@ 0x1f4
 8029ad6:	600a      	str	r2, [r1, #0]
 8029ad8:	f507 72fc 	add.w	r2, r7, #504	@ 0x1f8
 8029adc:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 8029ae0:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8029ae2:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 8029ae6:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 8029aea:	681b      	ldr	r3, [r3, #0]
 8029aec:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 8029af0:	3380      	adds	r3, #128	@ 0x80
 8029af2:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  inptr = coef_block;
 8029af6:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 8029afa:	f5a3 73fa 	sub.w	r3, r3, #500	@ 0x1f4
 8029afe:	681b      	ldr	r3, [r3, #0]
 8029b00:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8029b04:	f507 73fc 	add.w	r3, r7, #504	@ 0x1f8
 8029b08:	f5a3 73f8 	sub.w	r3, r3, #496	@ 0x1f0
 8029b0c:	681b      	ldr	r3, [r3, #0]
 8029b0e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8029b10:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
  wsptr = workspace;
 8029b14:	f107 0310 	add.w	r3, r7, #16
 8029b18:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8029b1c:	2300      	movs	r3, #0
 8029b1e:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8029b22:	e267      	b.n	8029ff4 <jpeg_idct_7x14+0x540>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8029b24:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029b28:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029b2c:	461a      	mov	r2, r3
 8029b2e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029b32:	681b      	ldr	r3, [r3, #0]
 8029b34:	fb02 f303 	mul.w	r3, r2, r3
 8029b38:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z1 <<= CONST_BITS;
 8029b3c:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029b40:	035b      	lsls	r3, r3, #13
 8029b42:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8029b46:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029b4a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8029b4e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8029b52:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029b56:	3340      	adds	r3, #64	@ 0x40
 8029b58:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029b5c:	461a      	mov	r2, r3
 8029b5e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029b62:	3380      	adds	r3, #128	@ 0x80
 8029b64:	681b      	ldr	r3, [r3, #0]
 8029b66:	fb02 f303 	mul.w	r3, r2, r3
 8029b6a:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 8029b6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029b72:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 8029b76:	fb02 f303 	mul.w	r3, r2, r3
 8029b7a:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 8029b7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029b82:	f640 2212 	movw	r2, #2578	@ 0xa12
 8029b86:	fb02 f303 	mul.w	r3, r2, r3
 8029b8a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 8029b8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029b92:	f641 4237 	movw	r2, #7223	@ 0x1c37
 8029b96:	fb02 f303 	mul.w	r3, r2, r3
 8029b9a:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

    tmp10 = z1 + z2;
 8029b9e:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029ba2:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029ba6:	4413      	add	r3, r2
 8029ba8:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp11 = z1 + z3;
 8029bac:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029bb0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029bb4:	4413      	add	r3, r2
 8029bb6:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = z1 - z4;
 8029bba:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029bbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029bc2:	1ad3      	subs	r3, r2, r3
 8029bc4:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 8029bc8:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8029bcc:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029bd0:	441a      	add	r2, r3
 8029bd2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029bd6:	1ad3      	subs	r3, r2, r3
 8029bd8:	005b      	lsls	r3, r3, #1
 8029bda:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029bde:	1ad3      	subs	r3, r2, r3
 8029be0:	12db      	asrs	r3, r3, #11
 8029be2:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8029be6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029bea:	3320      	adds	r3, #32
 8029bec:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029bf0:	461a      	mov	r2, r3
 8029bf2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029bf6:	3340      	adds	r3, #64	@ 0x40
 8029bf8:	681b      	ldr	r3, [r3, #0]
 8029bfa:	fb02 f303 	mul.w	r3, r2, r3
 8029bfe:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8029c02:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029c06:	3360      	adds	r3, #96	@ 0x60
 8029c08:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029c0c:	461a      	mov	r2, r3
 8029c0e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029c12:	33c0      	adds	r3, #192	@ 0xc0
 8029c14:	681b      	ldr	r3, [r3, #0]
 8029c16:	fb02 f303 	mul.w	r3, r2, r3
 8029c1a:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 8029c1e:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029c22:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029c26:	4413      	add	r3, r2
 8029c28:	f242 3262 	movw	r2, #9058	@ 0x2362
 8029c2c:	fb02 f303 	mul.w	r3, r2, r3
 8029c30:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8029c34:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029c38:	f640 02bd 	movw	r2, #2237	@ 0x8bd
 8029c3c:	fb02 f303 	mul.w	r3, r2, r3
 8029c40:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8029c44:	4413      	add	r3, r2
 8029c46:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8029c4a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029c4e:	4af0      	ldr	r2, [pc, #960]	@ (802a010 <jpeg_idct_7x14+0x55c>)
 8029c50:	fb02 f303 	mul.w	r3, r2, r3
 8029c54:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8029c58:	4413      	add	r3, r2
 8029c5a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8029c5e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029c62:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 8029c66:	fb03 f202 	mul.w	r2, r3, r2
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 8029c6a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029c6e:	49e9      	ldr	r1, [pc, #932]	@ (802a014 <jpeg_idct_7x14+0x560>)
 8029c70:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8029c74:	4413      	add	r3, r2
 8029c76:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8

    tmp20 = tmp10 + tmp13;
 8029c7a:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8029c7e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029c82:	4413      	add	r3, r2
 8029c84:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp26 = tmp10 - tmp13;
 8029c88:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 8029c8c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029c90:	1ad3      	subs	r3, r2, r3
 8029c92:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    tmp21 = tmp11 + tmp14;
 8029c96:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8029c9a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029c9e:	4413      	add	r3, r2
 8029ca0:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp25 = tmp11 - tmp14;
 8029ca4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8029ca8:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029cac:	1ad3      	subs	r3, r2, r3
 8029cae:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    tmp22 = tmp12 + tmp15;
 8029cb2:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8029cb6:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8029cba:	4413      	add	r3, r2
 8029cbc:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp24 = tmp12 - tmp15;
 8029cc0:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8029cc4:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8029cc8:	1ad3      	subs	r3, r2, r3
 8029cca:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8029cce:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029cd2:	3310      	adds	r3, #16
 8029cd4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029cd8:	461a      	mov	r2, r3
 8029cda:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029cde:	3320      	adds	r3, #32
 8029ce0:	681b      	ldr	r3, [r3, #0]
 8029ce2:	fb02 f303 	mul.w	r3, r2, r3
 8029ce6:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8029cea:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029cee:	3330      	adds	r3, #48	@ 0x30
 8029cf0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029cf4:	461a      	mov	r2, r3
 8029cf6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029cfa:	3360      	adds	r3, #96	@ 0x60
 8029cfc:	681b      	ldr	r3, [r3, #0]
 8029cfe:	fb02 f303 	mul.w	r3, r2, r3
 8029d02:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8029d06:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029d0a:	3350      	adds	r3, #80	@ 0x50
 8029d0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029d10:	461a      	mov	r2, r3
 8029d12:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029d16:	33a0      	adds	r3, #160	@ 0xa0
 8029d18:	681b      	ldr	r3, [r3, #0]
 8029d1a:	fb02 f303 	mul.w	r3, r2, r3
 8029d1e:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8029d22:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029d26:	3370      	adds	r3, #112	@ 0x70
 8029d28:	f9b3 3000 	ldrsh.w	r3, [r3]
 8029d2c:	461a      	mov	r2, r3
 8029d2e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029d32:	33e0      	adds	r3, #224	@ 0xe0
 8029d34:	681b      	ldr	r3, [r3, #0]
 8029d36:	fb02 f303 	mul.w	r3, r2, r3
 8029d3a:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp13 = z4 << CONST_BITS;
 8029d3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029d42:	035b      	lsls	r3, r3, #13
 8029d44:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    tmp14 = z1 + z3;
 8029d48:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029d4c:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029d50:	4413      	add	r3, r2
 8029d52:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8029d56:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029d5a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029d5e:	4413      	add	r3, r2
 8029d60:	f642 22b7 	movw	r2, #10935	@ 0x2ab7
 8029d64:	fb02 f303 	mul.w	r3, r2, r3
 8029d68:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 8029d6c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029d70:	f242 6252 	movw	r2, #9810	@ 0x2652
 8029d74:	fb02 f303 	mul.w	r3, r2, r3
 8029d78:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 8029d7c:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8029d80:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8029d84:	441a      	add	r2, r3
 8029d86:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029d8a:	441a      	add	r2, r3
 8029d8c:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029d90:	49a1      	ldr	r1, [pc, #644]	@ (802a018 <jpeg_idct_7x14+0x564>)
 8029d92:	fb01 f303 	mul.w	r3, r1, r3
 8029d96:	4413      	add	r3, r2
 8029d98:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 8029d9c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029da0:	f641 0214 	movw	r2, #6164	@ 0x1814
 8029da4:	fb02 f303 	mul.w	r3, r2, r3
 8029da8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 8029dac:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029db0:	4a9a      	ldr	r2, [pc, #616]	@ (802a01c <jpeg_idct_7x14+0x568>)
 8029db2:	fb02 f303 	mul.w	r3, r2, r3
 8029db6:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8029dba:	4413      	add	r3, r2
 8029dbc:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z1    -= z2;
 8029dc0:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029dc4:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029dc8:	1ad3      	subs	r3, r2, r3
 8029dca:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 8029dce:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 8029dd2:	f640 62f2 	movw	r2, #3826	@ 0xef2
 8029dd6:	fb03 f202 	mul.w	r2, r3, r2
 8029dda:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029dde:	1ad3      	subs	r3, r2, r3
 8029de0:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    tmp16 += tmp15;
 8029de4:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 8029de8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8029dec:	4413      	add	r3, r2
 8029dee:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
    z1    += z4;
 8029df2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029df6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029dfa:	4413      	add	r3, r2
 8029dfc:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 8029e00:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 8029e04:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029e08:	4413      	add	r3, r2
 8029e0a:	f46f 62a2 	mvn.w	r2, #1296	@ 0x510
 8029e0e:	fb03 f202 	mul.w	r2, r3, r2
 8029e12:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029e16:	1ad3      	subs	r3, r2, r3
 8029e18:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 8029e1c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029e20:	4a7f      	ldr	r2, [pc, #508]	@ (802a020 <jpeg_idct_7x14+0x56c>)
 8029e22:	fb03 f202 	mul.w	r2, r3, r2
 8029e26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029e2a:	4413      	add	r3, r2
 8029e2c:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 8029e30:	4413      	add	r3, r2
 8029e32:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 8029e36:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029e3a:	4a7a      	ldr	r2, [pc, #488]	@ (802a024 <jpeg_idct_7x14+0x570>)
 8029e3c:	fb03 f202 	mul.w	r2, r3, r2
 8029e40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029e44:	4413      	add	r3, r2
 8029e46:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 8029e4a:	4413      	add	r3, r2
 8029e4c:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8029e50:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 8029e54:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029e58:	1ad3      	subs	r3, r2, r3
 8029e5a:	f642 42f8 	movw	r2, #11512	@ 0x2cf8
 8029e5e:	fb02 f303 	mul.w	r3, r2, r3
 8029e62:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8029e66:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
 8029e6a:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 8029e6e:	441a      	add	r2, r3
 8029e70:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029e74:	496c      	ldr	r1, [pc, #432]	@ (802a028 <jpeg_idct_7x14+0x574>)
 8029e76:	fb01 f303 	mul.w	r3, r1, r3
 8029e7a:	4413      	add	r3, r2
 8029e7c:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 8029e80:	4413      	add	r3, r2
 8029e82:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 8029e86:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 8029e8a:	f241 5299 	movw	r2, #5529	@ 0x1599
 8029e8e:	fb03 f202 	mul.w	r2, r3, r2
 8029e92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 8029e96:	4413      	add	r3, r2
 8029e98:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 8029e9c:	4413      	add	r3, r2
 8029e9e:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8

    tmp13 = (z1 - z3) << PASS1_BITS;
 8029ea2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 8029ea6:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 8029eaa:	1ad3      	subs	r3, r2, r3
 8029eac:	009b      	lsls	r3, r3, #2
 8029eae:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0

    /* Final output stage */

    wsptr[7*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8029eb2:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8029eb6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8029eba:	4413      	add	r3, r2
 8029ebc:	12da      	asrs	r2, r3, #11
 8029ebe:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029ec2:	601a      	str	r2, [r3, #0]
    wsptr[7*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8029ec4:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 8029ec8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 8029ecc:	1ad2      	subs	r2, r2, r3
 8029ece:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029ed2:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 8029ed6:	12d2      	asrs	r2, r2, #11
 8029ed8:	601a      	str	r2, [r3, #0]
    wsptr[7*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8029eda:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8029ede:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8029ee2:	441a      	add	r2, r3
 8029ee4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029ee8:	331c      	adds	r3, #28
 8029eea:	12d2      	asrs	r2, r2, #11
 8029eec:	601a      	str	r2, [r3, #0]
    wsptr[7*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8029eee:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 8029ef2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 8029ef6:	1ad2      	subs	r2, r2, r3
 8029ef8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029efc:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8029f00:	12d2      	asrs	r2, r2, #11
 8029f02:	601a      	str	r2, [r3, #0]
    wsptr[7*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8029f04:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8029f08:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8029f0c:	441a      	add	r2, r3
 8029f0e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f12:	3338      	adds	r3, #56	@ 0x38
 8029f14:	12d2      	asrs	r2, r2, #11
 8029f16:	601a      	str	r2, [r3, #0]
    wsptr[7*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8029f18:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 8029f1c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 8029f20:	1ad2      	subs	r2, r2, r3
 8029f22:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f26:	f503 739a 	add.w	r3, r3, #308	@ 0x134
 8029f2a:	12d2      	asrs	r2, r2, #11
 8029f2c:	601a      	str	r2, [r3, #0]
    wsptr[7*3]  = (int) (tmp23 + tmp13);
 8029f2e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f32:	3354      	adds	r3, #84	@ 0x54
 8029f34:	f8d7 11dc 	ldr.w	r1, [r7, #476]	@ 0x1dc
 8029f38:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8029f3c:	440a      	add	r2, r1
 8029f3e:	601a      	str	r2, [r3, #0]
    wsptr[7*10] = (int) (tmp23 - tmp13);
 8029f40:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f44:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8029f48:	f8d7 11dc 	ldr.w	r1, [r7, #476]	@ 0x1dc
 8029f4c:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 8029f50:	1a8a      	subs	r2, r1, r2
 8029f52:	601a      	str	r2, [r3, #0]
    wsptr[7*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8029f54:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8029f58:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029f5c:	441a      	add	r2, r3
 8029f5e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f62:	3370      	adds	r3, #112	@ 0x70
 8029f64:	12d2      	asrs	r2, r2, #11
 8029f66:	601a      	str	r2, [r3, #0]
    wsptr[7*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8029f68:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 8029f6c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 8029f70:	1ad2      	subs	r2, r2, r3
 8029f72:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f76:	33fc      	adds	r3, #252	@ 0xfc
 8029f78:	12d2      	asrs	r2, r2, #11
 8029f7a:	601a      	str	r2, [r3, #0]
    wsptr[7*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8029f7c:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8029f80:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8029f84:	441a      	add	r2, r3
 8029f86:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f8a:	338c      	adds	r3, #140	@ 0x8c
 8029f8c:	12d2      	asrs	r2, r2, #11
 8029f8e:	601a      	str	r2, [r3, #0]
    wsptr[7*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8029f90:	f8d7 21a0 	ldr.w	r2, [r7, #416]	@ 0x1a0
 8029f94:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 8029f98:	1ad2      	subs	r2, r2, r3
 8029f9a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029f9e:	33e0      	adds	r3, #224	@ 0xe0
 8029fa0:	12d2      	asrs	r2, r2, #11
 8029fa2:	601a      	str	r2, [r3, #0]
    wsptr[7*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 8029fa4:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8029fa8:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8029fac:	441a      	add	r2, r3
 8029fae:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029fb2:	33a8      	adds	r3, #168	@ 0xa8
 8029fb4:	12d2      	asrs	r2, r2, #11
 8029fb6:	601a      	str	r2, [r3, #0]
    wsptr[7*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 8029fb8:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 8029fbc:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 8029fc0:	1ad2      	subs	r2, r2, r3
 8029fc2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029fc6:	33c4      	adds	r3, #196	@ 0xc4
 8029fc8:	12d2      	asrs	r2, r2, #11
 8029fca:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8029fcc:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8029fd0:	3301      	adds	r3, #1
 8029fd2:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 8029fd6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 8029fda:	3302      	adds	r3, #2
 8029fdc:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
 8029fe0:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
 8029fe4:	3304      	adds	r3, #4
 8029fe6:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
 8029fea:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 8029fee:	3304      	adds	r3, #4
 8029ff0:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
 8029ff4:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 8029ff8:	2b06      	cmp	r3, #6
 8029ffa:	f77f ad93 	ble.w	8029b24 <jpeg_idct_7x14+0x70>
  }

  /* Pass 2: process 14 rows from work array, store into output array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  wsptr = workspace;
 8029ffe:	f107 0310 	add.w	r3, r7, #16
 802a002:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 802a006:	2300      	movs	r3, #0
 802a008:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 802a00c:	e17c      	b.n	802a308 <jpeg_idct_7x14+0x854>
 802a00e:	bf00      	nop
 802a010:	ffffc8fc 	.word	0xffffc8fc
 802a014:	ffffd3e1 	.word	0xffffd3e1
 802a018:	ffffdbf0 	.word	0xffffdbf0
 802a01c:	ffffde0b 	.word	0xffffde0b
 802a020:	fffff26e 	.word	0xfffff26e
 802a024:	ffffb409 	.word	0xffffb409
 802a028:	ffffc9e6 	.word	0xffffc9e6
    outptr = output_buf[ctr] + output_col;
 802a02c:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802a030:	009b      	lsls	r3, r3, #2
 802a032:	f507 72fc 	add.w	r2, r7, #504	@ 0x1f8
 802a036:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 802a03a:	6812      	ldr	r2, [r2, #0]
 802a03c:	4413      	add	r3, r2
 802a03e:	681a      	ldr	r2, [r3, #0]
 802a040:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 802a044:	4413      	add	r3, r2
 802a046:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp23 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802a04a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a04e:	681b      	ldr	r3, [r3, #0]
 802a050:	3310      	adds	r3, #16
 802a052:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
    tmp23 <<= CONST_BITS;
 802a056:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802a05a:	035b      	lsls	r3, r3, #13
 802a05c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc

    z1 = (INT32) wsptr[2];
 802a060:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a064:	3308      	adds	r3, #8
 802a066:	681b      	ldr	r3, [r3, #0]
 802a068:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = (INT32) wsptr[4];
 802a06c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a070:	3310      	adds	r3, #16
 802a072:	681b      	ldr	r3, [r3, #0]
 802a074:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = (INT32) wsptr[6];
 802a078:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a07c:	3318      	adds	r3, #24
 802a07e:	681b      	ldr	r3, [r3, #0]
 802a080:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 802a084:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802a088:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a08c:	1ad3      	subs	r3, r2, r3
 802a08e:	f641 4237 	movw	r2, #7223	@ 0x1c37
 802a092:	fb02 f303 	mul.w	r3, r2, r3
 802a096:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 802a09a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802a09e:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a0a2:	1ad3      	subs	r3, r2, r3
 802a0a4:	f640 2212 	movw	r2, #2578	@ 0xa12
 802a0a8:	fb02 f303 	mul.w	r3, r2, r3
 802a0ac:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 802a0b0:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802a0b4:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 802a0b8:	441a      	add	r2, r3
 802a0ba:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802a0be:	441a      	add	r2, r3
 802a0c0:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a0c4:	4996      	ldr	r1, [pc, #600]	@ (802a320 <jpeg_idct_7x14+0x86c>)
 802a0c6:	fb01 f303 	mul.w	r3, r1, r3
 802a0ca:	4413      	add	r3, r2
 802a0cc:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
    tmp10 = z1 + z3;
 802a0d0:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802a0d4:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a0d8:	4413      	add	r3, r2
 802a0da:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    z2 -= tmp10;
 802a0de:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802a0e2:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a0e6:	1ad3      	subs	r3, r2, r3
 802a0e8:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 802a0ec:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a0f0:	f642 02c6 	movw	r2, #10438	@ 0x28c6
 802a0f4:	fb02 f303 	mul.w	r3, r2, r3
 802a0f8:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 802a0fc:	4413      	add	r3, r2
 802a0fe:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 802a102:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a106:	f46f 721f 	mvn.w	r2, #636	@ 0x27c
 802a10a:	fb03 f202 	mul.w	r2, r3, r2
 802a10e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a112:	4413      	add	r3, r2
 802a114:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802a118:	4413      	add	r3, r2
 802a11a:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 802a11e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 802a122:	4a80      	ldr	r2, [pc, #512]	@ (802a324 <jpeg_idct_7x14+0x870>)
 802a124:	fb03 f202 	mul.w	r2, r3, r2
 802a128:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a12c:	4413      	add	r3, r2
 802a12e:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 802a132:	4413      	add	r3, r2
 802a134:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 802a138:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a13c:	f642 5241 	movw	r2, #11585	@ 0x2d41
 802a140:	fb02 f303 	mul.w	r3, r2, r3
 802a144:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 802a148:	4413      	add	r3, r2
 802a14a:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802a14e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a152:	3304      	adds	r3, #4
 802a154:	681b      	ldr	r3, [r3, #0]
 802a156:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
    z2 = (INT32) wsptr[3];
 802a15a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a15e:	330c      	adds	r3, #12
 802a160:	681b      	ldr	r3, [r3, #0]
 802a162:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    z3 = (INT32) wsptr[5];
 802a166:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a16a:	3314      	adds	r3, #20
 802a16c:	681b      	ldr	r3, [r3, #0]
 802a16e:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 802a172:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802a176:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a17a:	4413      	add	r3, r2
 802a17c:	f641 52ef 	movw	r2, #7663	@ 0x1def
 802a180:	fb02 f303 	mul.w	r3, r2, r3
 802a184:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 802a188:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802a18c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a190:	1ad3      	subs	r3, r2, r3
 802a192:	f240 5273 	movw	r2, #1395	@ 0x573
 802a196:	fb02 f303 	mul.w	r3, r2, r3
 802a19a:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp10 = tmp11 - tmp12;
 802a19e:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 802a1a2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802a1a6:	1ad3      	subs	r3, r2, r3
 802a1a8:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp11 += tmp12;
 802a1ac:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 802a1b0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802a1b4:	4413      	add	r3, r2
 802a1b6:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 802a1ba:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 802a1be:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a1c2:	4413      	add	r3, r2
 802a1c4:	4a58      	ldr	r2, [pc, #352]	@ (802a328 <jpeg_idct_7x14+0x874>)
 802a1c6:	fb02 f303 	mul.w	r3, r2, r3
 802a1ca:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
    tmp11 += tmp12;
 802a1ce:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 802a1d2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802a1d6:	4413      	add	r3, r2
 802a1d8:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 802a1dc:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 802a1e0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a1e4:	4413      	add	r3, r2
 802a1e6:	f241 32a3 	movw	r2, #5027	@ 0x13a3
 802a1ea:	fb02 f303 	mul.w	r3, r2, r3
 802a1ee:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
    tmp10 += z2;
 802a1f2:	f8d7 21c0 	ldr.w	r2, [r7, #448]	@ 0x1c0
 802a1f6:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a1fa:	4413      	add	r3, r2
 802a1fc:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 802a200:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 802a204:	f643 32de 	movw	r2, #15326	@ 0x3bde
 802a208:	fb03 f202 	mul.w	r2, r3, r2
 802a20c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 802a210:	4413      	add	r3, r2
 802a212:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 802a216:	4413      	add	r3, r2
 802a218:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802a21c:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802a220:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a224:	4413      	add	r3, r2
 802a226:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a228:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802a22c:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a230:	4413      	add	r3, r2
 802a232:	781a      	ldrb	r2, [r3, #0]
 802a234:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a238:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802a23a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	@ 0x1cc
 802a23e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 802a242:	1ad3      	subs	r3, r2, r3
 802a244:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a246:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802a24a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a24e:	441a      	add	r2, r3
 802a250:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a254:	3306      	adds	r3, #6
 802a256:	7812      	ldrb	r2, [r2, #0]
 802a258:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802a25a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 802a25e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802a262:	4413      	add	r3, r2
 802a264:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a266:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802a26a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a26e:	441a      	add	r2, r3
 802a270:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a274:	3301      	adds	r3, #1
 802a276:	7812      	ldrb	r2, [r2, #0]
 802a278:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802a27a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 802a27e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 802a282:	1ad3      	subs	r3, r2, r3
 802a284:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a286:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802a28a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a28e:	441a      	add	r2, r3
 802a290:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a294:	3305      	adds	r3, #5
 802a296:	7812      	ldrb	r2, [r2, #0]
 802a298:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802a29a:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 802a29e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802a2a2:	4413      	add	r3, r2
 802a2a4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a2a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802a2aa:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a2ae:	441a      	add	r2, r3
 802a2b0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a2b4:	3302      	adds	r3, #2
 802a2b6:	7812      	ldrb	r2, [r2, #0]
 802a2b8:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802a2ba:	f8d7 21c8 	ldr.w	r2, [r7, #456]	@ 0x1c8
 802a2be:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 802a2c2:	1ad3      	subs	r3, r2, r3
 802a2c4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a2c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802a2ca:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a2ce:	441a      	add	r2, r3
 802a2d0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a2d4:	3304      	adds	r3, #4
 802a2d6:	7812      	ldrb	r2, [r2, #0]
 802a2d8:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 802a2da:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 802a2de:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a2e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 802a2e4:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 802a2e8:	441a      	add	r2, r3
 802a2ea:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 802a2ee:	3303      	adds	r3, #3
 802a2f0:	7812      	ldrb	r2, [r2, #0]
 802a2f2:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 802a2f4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 802a2f8:	331c      	adds	r3, #28
 802a2fa:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 802a2fe:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802a302:	3301      	adds	r3, #1
 802a304:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 802a308:	f8d7 31e8 	ldr.w	r3, [r7, #488]	@ 0x1e8
 802a30c:	2b0d      	cmp	r3, #13
 802a30e:	f77f ae8d 	ble.w	802a02c <jpeg_idct_7x14+0x578>
  }
}
 802a312:	bf00      	nop
 802a314:	bf00      	nop
 802a316:	f507 77fc 	add.w	r7, r7, #504	@ 0x1f8
 802a31a:	46bd      	mov	sp, r7
 802a31c:	bc90      	pop	{r4, r7}
 802a31e:	4770      	bx	lr
 802a320:	ffffc515 	.word	0xffffc515
 802a324:	ffffb0f1 	.word	0xffffb0f1
 802a328:	ffffd3e1 	.word	0xffffd3e1

0802a32c <jpeg_idct_6x12>:

GLOBAL(void)
jpeg_idct_6x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802a32c:	b490      	push	{r4, r7}
 802a32e:	b0e2      	sub	sp, #392	@ 0x188
 802a330:	af00      	add	r7, sp, #0
 802a332:	f507 74c4 	add.w	r4, r7, #392	@ 0x188
 802a336:	f5a4 74be 	sub.w	r4, r4, #380	@ 0x17c
 802a33a:	6020      	str	r0, [r4, #0]
 802a33c:	f507 70c4 	add.w	r0, r7, #392	@ 0x188
 802a340:	f5a0 70c0 	sub.w	r0, r0, #384	@ 0x180
 802a344:	6001      	str	r1, [r0, #0]
 802a346:	f507 71c4 	add.w	r1, r7, #392	@ 0x188
 802a34a:	f5a1 71c2 	sub.w	r1, r1, #388	@ 0x184
 802a34e:	600a      	str	r2, [r1, #0]
 802a350:	f507 72c4 	add.w	r2, r7, #392	@ 0x188
 802a354:	f5a2 72c4 	sub.w	r2, r2, #392	@ 0x188
 802a358:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802a35a:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 802a35e:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 802a362:	681b      	ldr	r3, [r3, #0]
 802a364:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802a368:	3380      	adds	r3, #128	@ 0x80
 802a36a:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  inptr = coef_block;
 802a36e:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 802a372:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 802a376:	681b      	ldr	r3, [r3, #0]
 802a378:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802a37c:	f507 73c4 	add.w	r3, r7, #392	@ 0x188
 802a380:	f5a3 73c0 	sub.w	r3, r3, #384	@ 0x180
 802a384:	681b      	ldr	r3, [r3, #0]
 802a386:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802a388:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
  wsptr = workspace;
 802a38c:	f107 0310 	add.w	r3, r7, #16
 802a390:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 802a394:	2300      	movs	r3, #0
 802a396:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 802a39a:	e215      	b.n	802a7c8 <jpeg_idct_6x12+0x49c>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802a39c:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a3a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a3a4:	461a      	mov	r2, r3
 802a3a6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a3aa:	681b      	ldr	r3, [r3, #0]
 802a3ac:	fb02 f303 	mul.w	r3, r2, r3
 802a3b0:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z3 <<= CONST_BITS;
 802a3b4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a3b8:	035b      	lsls	r3, r3, #13
 802a3ba:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 802a3be:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a3c2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802a3c6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802a3ca:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a3ce:	3340      	adds	r3, #64	@ 0x40
 802a3d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a3d4:	461a      	mov	r2, r3
 802a3d6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a3da:	3380      	adds	r3, #128	@ 0x80
 802a3dc:	681b      	ldr	r3, [r3, #0]
 802a3de:	fb02 f303 	mul.w	r3, r2, r3
 802a3e2:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 802a3e6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a3ea:	f242 7231 	movw	r2, #10033	@ 0x2731
 802a3ee:	fb02 f303 	mul.w	r3, r2, r3
 802a3f2:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    tmp10 = z3 + z4;
 802a3f6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a3fa:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a3fe:	4413      	add	r3, r2
 802a400:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp11 = z3 - z4;
 802a404:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a408:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a40c:	1ad3      	subs	r3, r2, r3
 802a40e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802a412:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a416:	3320      	adds	r3, #32
 802a418:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a41c:	461a      	mov	r2, r3
 802a41e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a422:	3340      	adds	r3, #64	@ 0x40
 802a424:	681b      	ldr	r3, [r3, #0]
 802a426:	fb02 f303 	mul.w	r3, r2, r3
 802a42a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 802a42e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802a432:	f642 32b6 	movw	r2, #11190	@ 0x2bb6
 802a436:	fb02 f303 	mul.w	r3, r2, r3
 802a43a:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
    z1 <<= CONST_BITS;
 802a43e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802a442:	035b      	lsls	r3, r3, #13
 802a444:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802a448:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a44c:	3360      	adds	r3, #96	@ 0x60
 802a44e:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a452:	461a      	mov	r2, r3
 802a454:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a458:	33c0      	adds	r3, #192	@ 0xc0
 802a45a:	681b      	ldr	r3, [r3, #0]
 802a45c:	fb02 f303 	mul.w	r3, r2, r3
 802a460:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z2 <<= CONST_BITS;
 802a464:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a468:	035b      	lsls	r3, r3, #13
 802a46a:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150

    tmp12 = z1 - z2;
 802a46e:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a472:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a476:	1ad3      	subs	r3, r2, r3
 802a478:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp21 = z3 + tmp12;
 802a47c:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a480:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a484:	4413      	add	r3, r2
 802a486:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp24 = z3 - tmp12;
 802a48a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a48e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a492:	1ad3      	subs	r3, r2, r3
 802a494:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144

    tmp12 = z4 + z2;
 802a498:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 802a49c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a4a0:	4413      	add	r3, r2
 802a4a2:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp20 = tmp10 + tmp12;
 802a4a6:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 802a4aa:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a4ae:	4413      	add	r3, r2
 802a4b0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp25 = tmp10 - tmp12;
 802a4b4:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 802a4b8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a4bc:	1ad3      	subs	r3, r2, r3
 802a4be:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    tmp12 = z4 - z1 - z2;
 802a4c2:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 802a4c6:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802a4ca:	1ad2      	subs	r2, r2, r3
 802a4cc:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a4d0:	1ad3      	subs	r3, r2, r3
 802a4d2:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    tmp22 = tmp11 + tmp12;
 802a4d6:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a4da:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a4de:	4413      	add	r3, r2
 802a4e0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
    tmp23 = tmp11 - tmp12;
 802a4e4:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a4e8:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a4ec:	1ad3      	subs	r3, r2, r3
 802a4ee:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802a4f2:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a4f6:	3310      	adds	r3, #16
 802a4f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a4fc:	461a      	mov	r2, r3
 802a4fe:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a502:	3320      	adds	r3, #32
 802a504:	681b      	ldr	r3, [r3, #0]
 802a506:	fb02 f303 	mul.w	r3, r2, r3
 802a50a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802a50e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a512:	3330      	adds	r3, #48	@ 0x30
 802a514:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a518:	461a      	mov	r2, r3
 802a51a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a51e:	3360      	adds	r3, #96	@ 0x60
 802a520:	681b      	ldr	r3, [r3, #0]
 802a522:	fb02 f303 	mul.w	r3, r2, r3
 802a526:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802a52a:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a52e:	3350      	adds	r3, #80	@ 0x50
 802a530:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a534:	461a      	mov	r2, r3
 802a536:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a53a:	33a0      	adds	r3, #160	@ 0xa0
 802a53c:	681b      	ldr	r3, [r3, #0]
 802a53e:	fb02 f303 	mul.w	r3, r2, r3
 802a542:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802a546:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a54a:	3370      	adds	r3, #112	@ 0x70
 802a54c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802a550:	461a      	mov	r2, r3
 802a552:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a556:	33e0      	adds	r3, #224	@ 0xe0
 802a558:	681b      	ldr	r3, [r3, #0]
 802a55a:	fb02 f303 	mul.w	r3, r2, r3
 802a55e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 802a562:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a566:	f642 12cf 	movw	r2, #10703	@ 0x29cf
 802a56a:	fb02 f303 	mul.w	r3, r2, r3
 802a56e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 802a572:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a576:	4a9b      	ldr	r2, [pc, #620]	@ (802a7e4 <jpeg_idct_6x12+0x4b8>)
 802a578:	fb02 f303 	mul.w	r3, r2, r3
 802a57c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    tmp10 = z1 + z3;
 802a580:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a584:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a588:	4413      	add	r3, r2
 802a58a:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 802a58e:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 802a592:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a596:	4413      	add	r3, r2
 802a598:	f641 328d 	movw	r2, #7053	@ 0x1b8d
 802a59c:	fb02 f303 	mul.w	r3, r2, r3
 802a5a0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 802a5a4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a5a8:	f640 025b 	movw	r2, #2139	@ 0x85b
 802a5ac:	fb02 f303 	mul.w	r3, r2, r3
 802a5b0:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802a5b4:	4413      	add	r3, r2
 802a5b6:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 802a5ba:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 802a5be:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a5c2:	18d1      	adds	r1, r2, r3
 802a5c4:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a5c8:	4613      	mov	r3, r2
 802a5ca:	00db      	lsls	r3, r3, #3
 802a5cc:	4413      	add	r3, r2
 802a5ce:	021a      	lsls	r2, r3, #8
 802a5d0:	1ad3      	subs	r3, r2, r3
 802a5d2:	440b      	add	r3, r1
 802a5d4:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 802a5d8:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a5dc:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a5e0:	4413      	add	r3, r2
 802a5e2:	4a81      	ldr	r2, [pc, #516]	@ (802a7e8 <jpeg_idct_6x12+0x4bc>)
 802a5e4:	fb02 f303 	mul.w	r3, r2, r3
 802a5e8:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 802a5ec:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 802a5f0:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802a5f4:	441a      	add	r2, r3
 802a5f6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a5fa:	497c      	ldr	r1, [pc, #496]	@ (802a7ec <jpeg_idct_6x12+0x4c0>)
 802a5fc:	fb01 f303 	mul.w	r3, r1, r3
 802a600:	4413      	add	r3, r2
 802a602:	f8d7 2168 	ldr.w	r2, [r7, #360]	@ 0x168
 802a606:	4413      	add	r3, r2
 802a608:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 802a60c:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802a610:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a614:	1ad2      	subs	r2, r2, r3
 802a616:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a61a:	f243 21c6 	movw	r1, #12998	@ 0x32c6
 802a61e:	fb01 f303 	mul.w	r3, r1, r3
 802a622:	4413      	add	r3, r2
 802a624:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
 802a628:	4413      	add	r3, r2
 802a62a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802a62e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802a632:	4a6f      	ldr	r2, [pc, #444]	@ (802a7f0 <jpeg_idct_6x12+0x4c4>)
 802a634:	fb03 f202 	mul.w	r2, r3, r2
 802a638:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802a63c:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 802a63e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a642:	496c      	ldr	r1, [pc, #432]	@ (802a7f4 <jpeg_idct_6x12+0x4c8>)
 802a644:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802a648:	4413      	add	r3, r2
 802a64a:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 802a64e:	4413      	add	r3, r2
 802a650:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

    z1 -= z4;
 802a654:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a658:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 802a65c:	1ad3      	subs	r3, r2, r3
 802a65e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 -= z3;
 802a662:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 802a666:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a66a:	1ad3      	subs	r3, r2, r3
 802a66c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 802a670:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a674:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a678:	4413      	add	r3, r2
 802a67a:	f241 1251 	movw	r2, #4433	@ 0x1151
 802a67e:	fb02 f303 	mul.w	r3, r2, r3
 802a682:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 802a686:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 802a68a:	f641 027e 	movw	r2, #6270	@ 0x187e
 802a68e:	fb02 f303 	mul.w	r3, r2, r3
 802a692:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a696:	4413      	add	r3, r2
 802a698:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 802a69c:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a6a0:	4a55      	ldr	r2, [pc, #340]	@ (802a7f8 <jpeg_idct_6x12+0x4cc>)
 802a6a2:	fb02 f303 	mul.w	r3, r2, r3
 802a6a6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a6aa:	4413      	add	r3, r2
 802a6ac:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138

    /* Final output stage */

    wsptr[6*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 802a6b0:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802a6b4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a6b8:	4413      	add	r3, r2
 802a6ba:	12da      	asrs	r2, r3, #11
 802a6bc:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a6c0:	601a      	str	r2, [r3, #0]
    wsptr[6*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 802a6c2:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802a6c6:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a6ca:	1ad2      	subs	r2, r2, r3
 802a6cc:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a6d0:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 802a6d4:	12d2      	asrs	r2, r2, #11
 802a6d6:	601a      	str	r2, [r3, #0]
    wsptr[6*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 802a6d8:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802a6dc:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a6e0:	441a      	add	r2, r3
 802a6e2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a6e6:	3318      	adds	r3, #24
 802a6e8:	12d2      	asrs	r2, r2, #11
 802a6ea:	601a      	str	r2, [r3, #0]
    wsptr[6*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802a6ec:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802a6f0:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a6f4:	1ad2      	subs	r2, r2, r3
 802a6f6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a6fa:	33f0      	adds	r3, #240	@ 0xf0
 802a6fc:	12d2      	asrs	r2, r2, #11
 802a6fe:	601a      	str	r2, [r3, #0]
    wsptr[6*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 802a700:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 802a704:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a708:	441a      	add	r2, r3
 802a70a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a70e:	3330      	adds	r3, #48	@ 0x30
 802a710:	12d2      	asrs	r2, r2, #11
 802a712:	601a      	str	r2, [r3, #0]
    wsptr[6*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802a714:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 802a718:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a71c:	1ad2      	subs	r2, r2, r3
 802a71e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a722:	33d8      	adds	r3, #216	@ 0xd8
 802a724:	12d2      	asrs	r2, r2, #11
 802a726:	601a      	str	r2, [r3, #0]
    wsptr[6*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802a728:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802a72c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802a730:	441a      	add	r2, r3
 802a732:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a736:	3348      	adds	r3, #72	@ 0x48
 802a738:	12d2      	asrs	r2, r2, #11
 802a73a:	601a      	str	r2, [r3, #0]
    wsptr[6*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 802a73c:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 802a740:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 802a744:	1ad2      	subs	r2, r2, r3
 802a746:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a74a:	33c0      	adds	r3, #192	@ 0xc0
 802a74c:	12d2      	asrs	r2, r2, #11
 802a74e:	601a      	str	r2, [r3, #0]
    wsptr[6*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 802a750:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 802a754:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802a758:	441a      	add	r2, r3
 802a75a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a75e:	3360      	adds	r3, #96	@ 0x60
 802a760:	12d2      	asrs	r2, r2, #11
 802a762:	601a      	str	r2, [r3, #0]
    wsptr[6*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802a764:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 802a768:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802a76c:	1ad2      	subs	r2, r2, r3
 802a76e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a772:	33a8      	adds	r3, #168	@ 0xa8
 802a774:	12d2      	asrs	r2, r2, #11
 802a776:	601a      	str	r2, [r3, #0]
    wsptr[6*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 802a778:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 802a77c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 802a780:	441a      	add	r2, r3
 802a782:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a786:	3378      	adds	r3, #120	@ 0x78
 802a788:	12d2      	asrs	r2, r2, #11
 802a78a:	601a      	str	r2, [r3, #0]
    wsptr[6*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 802a78c:	f8d7 2140 	ldr.w	r2, [r7, #320]	@ 0x140
 802a790:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 802a794:	1ad2      	subs	r2, r2, r3
 802a796:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a79a:	3390      	adds	r3, #144	@ 0x90
 802a79c:	12d2      	asrs	r2, r2, #11
 802a79e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 802a7a0:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802a7a4:	3301      	adds	r3, #1
 802a7a6:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 802a7aa:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 802a7ae:	3302      	adds	r3, #2
 802a7b0:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
 802a7b4:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 802a7b8:	3304      	adds	r3, #4
 802a7ba:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
 802a7be:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a7c2:	3304      	adds	r3, #4
 802a7c4:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
 802a7c8:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802a7cc:	2b05      	cmp	r3, #5
 802a7ce:	f77f ade5 	ble.w	802a39c <jpeg_idct_6x12+0x70>
  }

  /* Pass 2: process 12 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 802a7d2:	f107 0310 	add.w	r3, r7, #16
 802a7d6:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 802a7da:	2300      	movs	r3, #0
 802a7dc:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 802a7e0:	e108      	b.n	802a9f4 <jpeg_idct_6x12+0x6c8>
 802a7e2:	bf00      	nop
 802a7e4:	ffffeeaf 	.word	0xffffeeaf
 802a7e8:	ffffde8b 	.word	0xffffde8b
 802a7ec:	ffffd0b0 	.word	0xffffd0b0
 802a7f0:	ffffea5c 	.word	0xffffea5c
 802a7f4:	ffffc08c 	.word	0xffffc08c
 802a7f8:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 802a7fc:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802a800:	009b      	lsls	r3, r3, #2
 802a802:	f507 72c4 	add.w	r2, r7, #392	@ 0x188
 802a806:	f5a2 72c4 	sub.w	r2, r2, #392	@ 0x188
 802a80a:	6812      	ldr	r2, [r2, #0]
 802a80c:	4413      	add	r3, r2
 802a80e:	681a      	ldr	r2, [r3, #0]
 802a810:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 802a814:	4413      	add	r3, r2
 802a816:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802a81a:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a81e:	681b      	ldr	r3, [r3, #0]
 802a820:	3310      	adds	r3, #16
 802a822:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp10 <<= CONST_BITS;
 802a826:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a82a:	035b      	lsls	r3, r3, #13
 802a82c:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp12 = (INT32) wsptr[4];
 802a830:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a834:	3310      	adds	r3, #16
 802a836:	681b      	ldr	r3, [r3, #0]
 802a838:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 802a83c:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a840:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 802a844:	fb02 f303 	mul.w	r3, r2, r3
 802a848:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp11 = tmp10 + tmp20;
 802a84c:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 802a850:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802a854:	4413      	add	r3, r2
 802a856:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp21 = tmp10 - tmp20 - tmp20;
 802a85a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 802a85e:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802a862:	1ad2      	subs	r2, r2, r3
 802a864:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802a868:	1ad3      	subs	r3, r2, r3
 802a86a:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    tmp20 = (INT32) wsptr[2];
 802a86e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a872:	3308      	adds	r3, #8
 802a874:	681b      	ldr	r3, [r3, #0]
 802a876:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 802a87a:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 802a87e:	f242 7231 	movw	r2, #10033	@ 0x2731
 802a882:	fb02 f303 	mul.w	r3, r2, r3
 802a886:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp20 = tmp11 + tmp10;
 802a88a:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a88e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a892:	4413      	add	r3, r2
 802a894:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
    tmp22 = tmp11 - tmp10;
 802a898:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a89c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a8a0:	1ad3      	subs	r3, r2, r3
 802a8a2:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

    /* Odd part */

    z1 = (INT32) wsptr[1];
 802a8a6:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a8aa:	3304      	adds	r3, #4
 802a8ac:	681b      	ldr	r3, [r3, #0]
 802a8ae:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    z2 = (INT32) wsptr[3];
 802a8b2:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a8b6:	330c      	adds	r3, #12
 802a8b8:	681b      	ldr	r3, [r3, #0]
 802a8ba:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    z3 = (INT32) wsptr[5];
 802a8be:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a8c2:	3314      	adds	r3, #20
 802a8c4:	681b      	ldr	r3, [r3, #0]
 802a8c6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 802a8ca:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a8ce:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a8d2:	4413      	add	r3, r2
 802a8d4:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 802a8d8:	fb02 f303 	mul.w	r3, r2, r3
 802a8dc:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 802a8e0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a8e4:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a8e8:	4413      	add	r3, r2
 802a8ea:	035b      	lsls	r3, r3, #13
 802a8ec:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a8f0:	4413      	add	r3, r2
 802a8f2:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 802a8f6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 802a8fa:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a8fe:	1ad3      	subs	r3, r2, r3
 802a900:	035b      	lsls	r3, r3, #13
 802a902:	f8d7 2160 	ldr.w	r2, [r7, #352]	@ 0x160
 802a906:	4413      	add	r3, r2
 802a908:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
    tmp11 = (z1 - z2 - z3) << CONST_BITS;
 802a90c:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 802a910:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 802a914:	1ad2      	subs	r2, r2, r3
 802a916:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 802a91a:	1ad3      	subs	r3, r2, r3
 802a91c:	035b      	lsls	r3, r3, #13
 802a91e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802a922:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802a926:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a92a:	4413      	add	r3, r2
 802a92c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a92e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 802a932:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a936:	4413      	add	r3, r2
 802a938:	781a      	ldrb	r2, [r3, #0]
 802a93a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a93e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802a940:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 802a944:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 802a948:	1ad3      	subs	r3, r2, r3
 802a94a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a94c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802a950:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a954:	441a      	add	r2, r3
 802a956:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a95a:	3305      	adds	r3, #5
 802a95c:	7812      	ldrb	r2, [r2, #0]
 802a95e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802a960:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802a964:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a968:	4413      	add	r3, r2
 802a96a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a96c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802a970:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a974:	441a      	add	r2, r3
 802a976:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a97a:	3301      	adds	r3, #1
 802a97c:	7812      	ldrb	r2, [r2, #0]
 802a97e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802a980:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 802a984:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 802a988:	1ad3      	subs	r3, r2, r3
 802a98a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a98c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802a990:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a994:	441a      	add	r2, r3
 802a996:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a99a:	3304      	adds	r3, #4
 802a99c:	7812      	ldrb	r2, [r2, #0]
 802a99e:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802a9a0:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 802a9a4:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a9a8:	4413      	add	r3, r2
 802a9aa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a9ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802a9b0:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a9b4:	441a      	add	r2, r3
 802a9b6:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a9ba:	3302      	adds	r3, #2
 802a9bc:	7812      	ldrb	r2, [r2, #0]
 802a9be:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802a9c0:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 802a9c4:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 802a9c8:	1ad3      	subs	r3, r2, r3
 802a9ca:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802a9cc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 802a9d0:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 802a9d4:	441a      	add	r2, r3
 802a9d6:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 802a9da:	3303      	adds	r3, #3
 802a9dc:	7812      	ldrb	r2, [r2, #0]
 802a9de:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 802a9e0:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 802a9e4:	3318      	adds	r3, #24
 802a9e6:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 802a9ea:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802a9ee:	3301      	adds	r3, #1
 802a9f0:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
 802a9f4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
 802a9f8:	2b0b      	cmp	r3, #11
 802a9fa:	f77f aeff 	ble.w	802a7fc <jpeg_idct_6x12+0x4d0>
  }
}
 802a9fe:	bf00      	nop
 802aa00:	bf00      	nop
 802aa02:	f507 77c4 	add.w	r7, r7, #392	@ 0x188
 802aa06:	46bd      	mov	sp, r7
 802aa08:	bc90      	pop	{r4, r7}
 802aa0a:	4770      	bx	lr

0802aa0c <jpeg_idct_5x10>:

GLOBAL(void)
jpeg_idct_5x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802aa0c:	b490      	push	{r4, r7}
 802aa0e:	b0cc      	sub	sp, #304	@ 0x130
 802aa10:	af00      	add	r7, sp, #0
 802aa12:	f507 7498 	add.w	r4, r7, #304	@ 0x130
 802aa16:	f5a4 7492 	sub.w	r4, r4, #292	@ 0x124
 802aa1a:	6020      	str	r0, [r4, #0]
 802aa1c:	f507 7098 	add.w	r0, r7, #304	@ 0x130
 802aa20:	f5a0 7094 	sub.w	r0, r0, #296	@ 0x128
 802aa24:	6001      	str	r1, [r0, #0]
 802aa26:	f507 7198 	add.w	r1, r7, #304	@ 0x130
 802aa2a:	f5a1 7196 	sub.w	r1, r1, #300	@ 0x12c
 802aa2e:	600a      	str	r2, [r1, #0]
 802aa30:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 802aa34:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 802aa38:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802aa3a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 802aa3e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 802aa42:	681b      	ldr	r3, [r3, #0]
 802aa44:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802aa48:	3380      	adds	r3, #128	@ 0x80
 802aa4a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  inptr = coef_block;
 802aa4e:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 802aa52:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 802aa56:	681b      	ldr	r3, [r3, #0]
 802aa58:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802aa5c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 802aa60:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 802aa64:	681b      	ldr	r3, [r3, #0]
 802aa66:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802aa68:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
  wsptr = workspace;
 802aa6c:	f107 0314 	add.w	r3, r7, #20
 802aa70:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 802aa74:	2300      	movs	r3, #0
 802aa76:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 802aa7a:	e1d3      	b.n	802ae24 <jpeg_idct_5x10+0x418>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802aa7c:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802aa80:	f9b3 3000 	ldrsh.w	r3, [r3]
 802aa84:	461a      	mov	r2, r3
 802aa86:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802aa8a:	681b      	ldr	r3, [r3, #0]
 802aa8c:	fb02 f303 	mul.w	r3, r2, r3
 802aa90:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z3 <<= CONST_BITS;
 802aa94:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802aa98:	035b      	lsls	r3, r3, #13
 802aa9a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 802aa9e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802aaa2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802aaa6:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802aaaa:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802aaae:	3340      	adds	r3, #64	@ 0x40
 802aab0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802aab4:	461a      	mov	r2, r3
 802aab6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802aaba:	3380      	adds	r3, #128	@ 0x80
 802aabc:	681b      	ldr	r3, [r3, #0]
 802aabe:	fb02 f303 	mul.w	r3, r2, r3
 802aac2:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 802aac6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802aaca:	f242 429d 	movw	r2, #9373	@ 0x249d
 802aace:	fb02 f303 	mul.w	r3, r2, r3
 802aad2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 802aad6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802aada:	f640 52fc 	movw	r2, #3580	@ 0xdfc
 802aade:	fb02 f303 	mul.w	r3, r2, r3
 802aae2:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    tmp10 = z3 + z1;
 802aae6:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802aaea:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802aaee:	4413      	add	r3, r2
 802aaf0:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp11 = z3 - z2;
 802aaf4:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802aaf8:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802aafc:	1ad3      	subs	r3, r2, r3
 802aafe:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 802ab02:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802ab06:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802ab0a:	1ad3      	subs	r3, r2, r3
 802ab0c:	005b      	lsls	r3, r3, #1
 802ab0e:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802ab12:	1ad3      	subs	r3, r2, r3
 802ab14:	12db      	asrs	r3, r3, #11
 802ab16:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802ab1a:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802ab1e:	3320      	adds	r3, #32
 802ab20:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ab24:	461a      	mov	r2, r3
 802ab26:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802ab2a:	3340      	adds	r3, #64	@ 0x40
 802ab2c:	681b      	ldr	r3, [r3, #0]
 802ab2e:	fb02 f303 	mul.w	r3, r2, r3
 802ab32:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802ab36:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802ab3a:	3360      	adds	r3, #96	@ 0x60
 802ab3c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ab40:	461a      	mov	r2, r3
 802ab42:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802ab46:	33c0      	adds	r3, #192	@ 0xc0
 802ab48:	681b      	ldr	r3, [r3, #0]
 802ab4a:	fb02 f303 	mul.w	r3, r2, r3
 802ab4e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 802ab52:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802ab56:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802ab5a:	4413      	add	r3, r2
 802ab5c:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 802ab60:	fb02 f303 	mul.w	r3, r2, r3
 802ab64:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 802ab68:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802ab6c:	f241 0271 	movw	r2, #4209	@ 0x1071
 802ab70:	fb02 f303 	mul.w	r3, r2, r3
 802ab74:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802ab78:	4413      	add	r3, r2
 802ab7a:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 802ab7e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802ab82:	4aaf      	ldr	r2, [pc, #700]	@ (802ae40 <jpeg_idct_5x10+0x434>)
 802ab84:	fb02 f303 	mul.w	r3, r2, r3
 802ab88:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802ab8c:	4413      	add	r3, r2
 802ab8e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    tmp20 = tmp10 + tmp12;
 802ab92:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802ab96:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802ab9a:	4413      	add	r3, r2
 802ab9c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    tmp24 = tmp10 - tmp12;
 802aba0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802aba4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802aba8:	1ad3      	subs	r3, r2, r3
 802abaa:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    tmp21 = tmp11 + tmp13;
 802abae:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802abb2:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802abb6:	4413      	add	r3, r2
 802abb8:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    tmp23 = tmp11 - tmp13;
 802abbc:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802abc0:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802abc4:	1ad3      	subs	r3, r2, r3
 802abc6:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802abca:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802abce:	3310      	adds	r3, #16
 802abd0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802abd4:	461a      	mov	r2, r3
 802abd6:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802abda:	3320      	adds	r3, #32
 802abdc:	681b      	ldr	r3, [r3, #0]
 802abde:	fb02 f303 	mul.w	r3, r2, r3
 802abe2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802abe6:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802abea:	3330      	adds	r3, #48	@ 0x30
 802abec:	f9b3 3000 	ldrsh.w	r3, [r3]
 802abf0:	461a      	mov	r2, r3
 802abf2:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802abf6:	3360      	adds	r3, #96	@ 0x60
 802abf8:	681b      	ldr	r3, [r3, #0]
 802abfa:	fb02 f303 	mul.w	r3, r2, r3
 802abfe:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802ac02:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802ac06:	3350      	adds	r3, #80	@ 0x50
 802ac08:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ac0c:	461a      	mov	r2, r3
 802ac0e:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802ac12:	33a0      	adds	r3, #160	@ 0xa0
 802ac14:	681b      	ldr	r3, [r3, #0]
 802ac16:	fb02 f303 	mul.w	r3, r2, r3
 802ac1a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802ac1e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802ac22:	3370      	adds	r3, #112	@ 0x70
 802ac24:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ac28:	461a      	mov	r2, r3
 802ac2a:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802ac2e:	33e0      	adds	r3, #224	@ 0xe0
 802ac30:	681b      	ldr	r3, [r3, #0]
 802ac32:	fb02 f303 	mul.w	r3, r2, r3
 802ac36:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp11 = z2 + z4;
 802ac3a:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802ac3e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802ac42:	4413      	add	r3, r2
 802ac44:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp13 = z2 - z4;
 802ac48:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802ac4c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802ac50:	1ad3      	subs	r3, r2, r3
 802ac52:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 802ac56:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802ac5a:	f640 12e3 	movw	r2, #2531	@ 0x9e3
 802ac5e:	fb02 f303 	mul.w	r3, r2, r3
 802ac62:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    z5 = z3 << CONST_BITS;
 802ac66:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802ac6a:	035b      	lsls	r3, r3, #13
 802ac6c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 802ac70:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802ac74:	f641 626f 	movw	r2, #7791	@ 0x1e6f
 802ac78:	fb02 f303 	mul.w	r3, r2, r3
 802ac7c:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z4 = z5 + tmp12;
 802ac80:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 802ac84:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802ac88:	4413      	add	r3, r2
 802ac8a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 802ac8e:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802ac92:	f642 42b3 	movw	r2, #11443	@ 0x2cb3
 802ac96:	fb03 f202 	mul.w	r2, r3, r2
 802ac9a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802ac9e:	4413      	add	r3, r2
 802aca0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 802aca4:	4413      	add	r3, r2
 802aca6:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 802acaa:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802acae:	f240 7214 	movw	r2, #1812	@ 0x714
 802acb2:	fb03 f202 	mul.w	r2, r3, r2
 802acb6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802acba:	1ad3      	subs	r3, r2, r3
 802acbc:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 802acc0:	4413      	add	r3, r2
 802acc2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 802acc6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802acca:	f241 22cf 	movw	r2, #4815	@ 0x12cf
 802acce:	fb02 f303 	mul.w	r3, r2, r3
 802acd2:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 802acd6:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 802acda:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802acde:	1ad2      	subs	r2, r2, r3
 802ace0:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802ace4:	031b      	lsls	r3, r3, #12
 802ace6:	1ad3      	subs	r3, r2, r3
 802ace8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 802acec:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802acf0:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802acf4:	1ad2      	subs	r2, r2, r3
 802acf6:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802acfa:	1ad3      	subs	r3, r2, r3
 802acfc:	009b      	lsls	r3, r3, #2
 802acfe:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 802ad02:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802ad06:	f642 0253 	movw	r2, #10323	@ 0x2853
 802ad0a:	fb03 f202 	mul.w	r2, r3, r2
 802ad0e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802ad12:	1ad2      	subs	r2, r2, r3
 802ad14:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 802ad18:	1ad3      	subs	r3, r2, r3
 802ad1a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 802ad1e:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802ad22:	f241 428c 	movw	r2, #5260	@ 0x148c
 802ad26:	fb03 f202 	mul.w	r2, r3, r2
 802ad2a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802ad2e:	1ad3      	subs	r3, r2, r3
 802ad30:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 802ad34:	4413      	add	r3, r2
 802ad36:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 802ad3a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 802ad3e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 802ad42:	4413      	add	r3, r2
 802ad44:	12da      	asrs	r2, r3, #11
 802ad46:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad4a:	601a      	str	r2, [r3, #0]
    wsptr[5*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 802ad4c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 802ad50:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 802ad54:	1ad2      	subs	r2, r2, r3
 802ad56:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad5a:	33b4      	adds	r3, #180	@ 0xb4
 802ad5c:	12d2      	asrs	r2, r2, #11
 802ad5e:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 802ad60:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 802ad64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802ad68:	441a      	add	r2, r3
 802ad6a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad6e:	3314      	adds	r3, #20
 802ad70:	12d2      	asrs	r2, r2, #11
 802ad72:	601a      	str	r2, [r3, #0]
    wsptr[5*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 802ad74:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 802ad78:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 802ad7c:	1ad2      	subs	r2, r2, r3
 802ad7e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad82:	33a0      	adds	r3, #160	@ 0xa0
 802ad84:	12d2      	asrs	r2, r2, #11
 802ad86:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) (tmp22 + tmp12);
 802ad88:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad8c:	3328      	adds	r3, #40	@ 0x28
 802ad8e:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 802ad92:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802ad96:	440a      	add	r2, r1
 802ad98:	601a      	str	r2, [r3, #0]
    wsptr[5*7] = (int) (tmp22 - tmp12);
 802ad9a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ad9e:	338c      	adds	r3, #140	@ 0x8c
 802ada0:	f8d7 10f0 	ldr.w	r1, [r7, #240]	@ 0xf0
 802ada4:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802ada8:	1a8a      	subs	r2, r1, r2
 802adaa:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802adac:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 802adb0:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802adb4:	441a      	add	r2, r3
 802adb6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802adba:	333c      	adds	r3, #60	@ 0x3c
 802adbc:	12d2      	asrs	r2, r2, #11
 802adbe:	601a      	str	r2, [r3, #0]
    wsptr[5*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 802adc0:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 802adc4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802adc8:	1ad2      	subs	r2, r2, r3
 802adca:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802adce:	3378      	adds	r3, #120	@ 0x78
 802add0:	12d2      	asrs	r2, r2, #11
 802add2:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 802add4:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 802add8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802addc:	441a      	add	r2, r3
 802adde:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ade2:	3350      	adds	r3, #80	@ 0x50
 802ade4:	12d2      	asrs	r2, r2, #11
 802ade6:	601a      	str	r2, [r3, #0]
    wsptr[5*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802ade8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 802adec:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802adf0:	1ad2      	subs	r2, r2, r3
 802adf2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802adf6:	3364      	adds	r3, #100	@ 0x64
 802adf8:	12d2      	asrs	r2, r2, #11
 802adfa:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 802adfc:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802ae00:	3301      	adds	r3, #1
 802ae02:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 802ae06:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 802ae0a:	3302      	adds	r3, #2
 802ae0c:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
 802ae10:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
 802ae14:	3304      	adds	r3, #4
 802ae16:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 802ae1a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ae1e:	3304      	adds	r3, #4
 802ae20:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 802ae24:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802ae28:	2b04      	cmp	r3, #4
 802ae2a:	f77f ae27 	ble.w	802aa7c <jpeg_idct_5x10+0x70>
  }

  /* Pass 2: process 10 rows from work array, store into output array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  wsptr = workspace;
 802ae2e:	f107 0314 	add.w	r3, r7, #20
 802ae32:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 802ae36:	2300      	movs	r3, #0
 802ae38:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 802ae3c:	e0dd      	b.n	802affa <jpeg_idct_5x10+0x5ee>
 802ae3e:	bf00      	nop
 802ae40:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 802ae44:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802ae48:	009b      	lsls	r3, r3, #2
 802ae4a:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 802ae4e:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
 802ae52:	6812      	ldr	r2, [r2, #0]
 802ae54:	4413      	add	r3, r2
 802ae56:	681a      	ldr	r2, [r3, #0]
 802ae58:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 802ae5c:	4413      	add	r3, r2
 802ae5e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802ae62:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ae66:	681b      	ldr	r3, [r3, #0]
 802ae68:	3310      	adds	r3, #16
 802ae6a:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp12 <<= CONST_BITS;
 802ae6e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802ae72:	035b      	lsls	r3, r3, #13
 802ae74:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    tmp13 = (INT32) wsptr[2];
 802ae78:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ae7c:	3308      	adds	r3, #8
 802ae7e:	681b      	ldr	r3, [r3, #0]
 802ae80:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp14 = (INT32) wsptr[4];
 802ae84:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802ae88:	3310      	adds	r3, #16
 802ae8a:	681b      	ldr	r3, [r3, #0]
 802ae8c:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 802ae90:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 802ae94:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802ae98:	4413      	add	r3, r2
 802ae9a:	f641 124c 	movw	r2, #6476	@ 0x194c
 802ae9e:	fb02 f303 	mul.w	r3, r2, r3
 802aea2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 802aea6:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 802aeaa:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802aeae:	1ad3      	subs	r3, r2, r3
 802aeb0:	f44f 6235 	mov.w	r2, #2896	@ 0xb50
 802aeb4:	fb02 f303 	mul.w	r3, r2, r3
 802aeb8:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = tmp12 + z2;
 802aebc:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802aec0:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802aec4:	4413      	add	r3, r2
 802aec6:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    tmp10 = z3 + z1;
 802aeca:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802aece:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802aed2:	4413      	add	r3, r2
 802aed4:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    tmp11 = z3 - z1;
 802aed8:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 802aedc:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 802aee0:	1ad3      	subs	r3, r2, r3
 802aee2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    tmp12 -= z2 << 2;
 802aee6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802aeea:	009b      	lsls	r3, r3, #2
 802aeec:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 802aef0:	1ad3      	subs	r3, r2, r3
 802aef2:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114

    /* Odd part */

    z2 = (INT32) wsptr[1];
 802aef6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802aefa:	3304      	adds	r3, #4
 802aefc:	681b      	ldr	r3, [r3, #0]
 802aefe:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    z3 = (INT32) wsptr[3];
 802af02:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802af06:	330c      	adds	r3, #12
 802af08:	681b      	ldr	r3, [r3, #0]
 802af0a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 802af0e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 802af12:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802af16:	4413      	add	r3, r2
 802af18:	f641 229a 	movw	r2, #6810	@ 0x1a9a
 802af1c:	fb02 f303 	mul.w	r3, r2, r3
 802af20:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 802af24:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 802af28:	f241 0271 	movw	r2, #4209	@ 0x1071
 802af2c:	fb02 f303 	mul.w	r3, r2, r3
 802af30:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802af34:	4413      	add	r3, r2
 802af36:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 802af3a:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 802af3e:	4a35      	ldr	r2, [pc, #212]	@ (802b014 <jpeg_idct_5x10+0x608>)
 802af40:	fb02 f303 	mul.w	r3, r2, r3
 802af44:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 802af48:	4413      	add	r3, r2
 802af4a:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 802af4e:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802af52:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802af56:	4413      	add	r3, r2
 802af58:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802af5a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 802af5e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802af62:	4413      	add	r3, r2
 802af64:	781a      	ldrb	r2, [r3, #0]
 802af66:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802af6a:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 802af6c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 802af70:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 802af74:	1ad3      	subs	r3, r2, r3
 802af76:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802af78:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 802af7c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802af80:	441a      	add	r2, r3
 802af82:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802af86:	3304      	adds	r3, #4
 802af88:	7812      	ldrb	r2, [r2, #0]
 802af8a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 802af8c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802af90:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802af94:	4413      	add	r3, r2
 802af96:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802af98:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 802af9c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802afa0:	441a      	add	r2, r3
 802afa2:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802afa6:	3301      	adds	r3, #1
 802afa8:	7812      	ldrb	r2, [r2, #0]
 802afaa:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 802afac:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 802afb0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 802afb4:	1ad3      	subs	r3, r2, r3
 802afb6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802afb8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 802afbc:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802afc0:	441a      	add	r2, r3
 802afc2:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802afc6:	3303      	adds	r3, #3
 802afc8:	7812      	ldrb	r2, [r2, #0]
 802afca:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 802afcc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 802afd0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802afd2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 802afd6:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 802afda:	441a      	add	r2, r3
 802afdc:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 802afe0:	3302      	adds	r3, #2
 802afe2:	7812      	ldrb	r2, [r2, #0]
 802afe4:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 802afe6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 802afea:	3314      	adds	r3, #20
 802afec:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 802aff0:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802aff4:	3301      	adds	r3, #1
 802aff6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 802affa:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 802affe:	2b09      	cmp	r3, #9
 802b000:	f77f af20 	ble.w	802ae44 <jpeg_idct_5x10+0x438>
  }
}
 802b004:	bf00      	nop
 802b006:	bf00      	nop
 802b008:	f507 7798 	add.w	r7, r7, #304	@ 0x130
 802b00c:	46bd      	mov	sp, r7
 802b00e:	bc90      	pop	{r4, r7}
 802b010:	4770      	bx	lr
 802b012:	bf00      	nop
 802b014:	ffffba5c 	.word	0xffffba5c

0802b018 <jpeg_idct_4x8>:

GLOBAL(void)
jpeg_idct_4x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802b018:	b480      	push	{r7}
 802b01a:	b0b7      	sub	sp, #220	@ 0xdc
 802b01c:	af00      	add	r7, sp, #0
 802b01e:	60f8      	str	r0, [r7, #12]
 802b020:	60b9      	str	r1, [r7, #8]
 802b022:	607a      	str	r2, [r7, #4]
 802b024:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802b026:	68fb      	ldr	r3, [r7, #12]
 802b028:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802b02c:	3380      	adds	r3, #128	@ 0x80
 802b02e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 802b032:	687b      	ldr	r3, [r7, #4]
 802b034:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802b038:	68bb      	ldr	r3, [r7, #8]
 802b03a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802b03c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  wsptr = workspace;
 802b040:	f107 0310 	add.w	r3, r7, #16
 802b044:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 802b048:	2304      	movs	r3, #4
 802b04a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802b04e:	e238      	b.n	802b4c2 <jpeg_idct_4x8+0x4aa>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 802b050:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b054:	3310      	adds	r3, #16
 802b056:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b05a:	2b00      	cmp	r3, #0
 802b05c:	d175      	bne.n	802b14a <jpeg_idct_4x8+0x132>
 802b05e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b062:	3320      	adds	r3, #32
 802b064:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b068:	2b00      	cmp	r3, #0
 802b06a:	d16e      	bne.n	802b14a <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802b06c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b070:	3330      	adds	r3, #48	@ 0x30
 802b072:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 802b076:	2b00      	cmp	r3, #0
 802b078:	d167      	bne.n	802b14a <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802b07a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b07e:	3340      	adds	r3, #64	@ 0x40
 802b080:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b084:	2b00      	cmp	r3, #0
 802b086:	d160      	bne.n	802b14a <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802b088:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b08c:	3350      	adds	r3, #80	@ 0x50
 802b08e:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 802b092:	2b00      	cmp	r3, #0
 802b094:	d159      	bne.n	802b14a <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802b096:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b09a:	3360      	adds	r3, #96	@ 0x60
 802b09c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b0a0:	2b00      	cmp	r3, #0
 802b0a2:	d152      	bne.n	802b14a <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*7] == 0) {
 802b0a4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b0a8:	3370      	adds	r3, #112	@ 0x70
 802b0aa:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 802b0ae:	2b00      	cmp	r3, #0
 802b0b0:	d14b      	bne.n	802b14a <jpeg_idct_4x8+0x132>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 802b0b2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b0b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b0ba:	461a      	mov	r2, r3
 802b0bc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b0c0:	681b      	ldr	r3, [r3, #0]
 802b0c2:	fb02 f303 	mul.w	r3, r2, r3
 802b0c6:	009b      	lsls	r3, r3, #2
 802b0c8:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0

      wsptr[4*0] = dcval;
 802b0cc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b0d0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b0d4:	601a      	str	r2, [r3, #0]
      wsptr[4*1] = dcval;
 802b0d6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b0da:	3310      	adds	r3, #16
 802b0dc:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b0e0:	601a      	str	r2, [r3, #0]
      wsptr[4*2] = dcval;
 802b0e2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b0e6:	3320      	adds	r3, #32
 802b0e8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b0ec:	601a      	str	r2, [r3, #0]
      wsptr[4*3] = dcval;
 802b0ee:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b0f2:	3330      	adds	r3, #48	@ 0x30
 802b0f4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b0f8:	601a      	str	r2, [r3, #0]
      wsptr[4*4] = dcval;
 802b0fa:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b0fe:	3340      	adds	r3, #64	@ 0x40
 802b100:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b104:	601a      	str	r2, [r3, #0]
      wsptr[4*5] = dcval;
 802b106:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b10a:	3350      	adds	r3, #80	@ 0x50
 802b10c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b110:	601a      	str	r2, [r3, #0]
      wsptr[4*6] = dcval;
 802b112:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b116:	3360      	adds	r3, #96	@ 0x60
 802b118:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b11c:	601a      	str	r2, [r3, #0]
      wsptr[4*7] = dcval;
 802b11e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b122:	3370      	adds	r3, #112	@ 0x70
 802b124:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 802b128:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 802b12a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b12e:	3302      	adds	r3, #2
 802b130:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      quantptr++;
 802b134:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b138:	3304      	adds	r3, #4
 802b13a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
      wsptr++;
 802b13e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b142:	3304      	adds	r3, #4
 802b144:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
      continue;
 802b148:	e1b6      	b.n	802b4b8 <jpeg_idct_4x8+0x4a0>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802b14a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b14e:	3320      	adds	r3, #32
 802b150:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b154:	461a      	mov	r2, r3
 802b156:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b15a:	3340      	adds	r3, #64	@ 0x40
 802b15c:	681b      	ldr	r3, [r3, #0]
 802b15e:	fb02 f303 	mul.w	r3, r2, r3
 802b162:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802b166:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b16a:	3360      	adds	r3, #96	@ 0x60
 802b16c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b170:	461a      	mov	r2, r3
 802b172:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b176:	33c0      	adds	r3, #192	@ 0xc0
 802b178:	681b      	ldr	r3, [r3, #0]
 802b17a:	fb02 f303 	mul.w	r3, r2, r3
 802b17e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 802b182:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b186:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b18a:	4413      	add	r3, r2
 802b18c:	f241 1251 	movw	r2, #4433	@ 0x1151
 802b190:	fb02 f303 	mul.w	r3, r2, r3
 802b194:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 802b198:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b19c:	f641 027e 	movw	r2, #6270	@ 0x187e
 802b1a0:	fb02 f303 	mul.w	r3, r2, r3
 802b1a4:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b1a8:	4413      	add	r3, r2
 802b1aa:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 802b1ae:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b1b2:	4aca      	ldr	r2, [pc, #808]	@ (802b4dc <jpeg_idct_4x8+0x4c4>)
 802b1b4:	fb02 f303 	mul.w	r3, r2, r3
 802b1b8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b1bc:	4413      	add	r3, r2
 802b1be:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802b1c2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b1c6:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b1ca:	461a      	mov	r2, r3
 802b1cc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b1d0:	681b      	ldr	r3, [r3, #0]
 802b1d2:	fb02 f303 	mul.w	r3, r2, r3
 802b1d6:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802b1da:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b1de:	3340      	adds	r3, #64	@ 0x40
 802b1e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b1e4:	461a      	mov	r2, r3
 802b1e6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b1ea:	3380      	adds	r3, #128	@ 0x80
 802b1ec:	681b      	ldr	r3, [r3, #0]
 802b1ee:	fb02 f303 	mul.w	r3, r2, r3
 802b1f2:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z2 <<= CONST_BITS;
 802b1f6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b1fa:	035b      	lsls	r3, r3, #13
 802b1fc:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 <<= CONST_BITS;
 802b200:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b204:	035b      	lsls	r3, r3, #13
 802b206:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 802b20a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b20e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802b212:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    tmp0 = z2 + z3;
 802b216:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b21a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b21e:	4413      	add	r3, r2
 802b220:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = z2 - z3;
 802b224:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b228:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b22c:	1ad3      	subs	r3, r2, r3
 802b22e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    
    tmp10 = tmp0 + tmp2;
 802b232:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b236:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b23a:	4413      	add	r3, r2
 802b23c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp13 = tmp0 - tmp2;
 802b240:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b244:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b248:	1ad3      	subs	r3, r2, r3
 802b24a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    tmp11 = tmp1 + tmp3;
 802b24e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 802b252:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b256:	4413      	add	r3, r2
 802b258:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    tmp12 = tmp1 - tmp3;
 802b25c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 802b260:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b264:	1ad3      	subs	r3, r2, r3
 802b266:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802b26a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b26e:	3370      	adds	r3, #112	@ 0x70
 802b270:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b274:	461a      	mov	r2, r3
 802b276:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b27a:	33e0      	adds	r3, #224	@ 0xe0
 802b27c:	681b      	ldr	r3, [r3, #0]
 802b27e:	fb02 f303 	mul.w	r3, r2, r3
 802b282:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802b286:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b28a:	3350      	adds	r3, #80	@ 0x50
 802b28c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b290:	461a      	mov	r2, r3
 802b292:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b296:	33a0      	adds	r3, #160	@ 0xa0
 802b298:	681b      	ldr	r3, [r3, #0]
 802b29a:	fb02 f303 	mul.w	r3, r2, r3
 802b29e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802b2a2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b2a6:	3330      	adds	r3, #48	@ 0x30
 802b2a8:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b2ac:	461a      	mov	r2, r3
 802b2ae:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b2b2:	3360      	adds	r3, #96	@ 0x60
 802b2b4:	681b      	ldr	r3, [r3, #0]
 802b2b6:	fb02 f303 	mul.w	r3, r2, r3
 802b2ba:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802b2be:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b2c2:	3310      	adds	r3, #16
 802b2c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b2c8:	461a      	mov	r2, r3
 802b2ca:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b2ce:	3320      	adds	r3, #32
 802b2d0:	681b      	ldr	r3, [r3, #0]
 802b2d2:	fb02 f303 	mul.w	r3, r2, r3
 802b2d6:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

    z2 = tmp0 + tmp2;
 802b2da:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b2de:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b2e2:	4413      	add	r3, r2
 802b2e4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = tmp1 + tmp3;
 802b2e8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 802b2ec:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b2f0:	4413      	add	r3, r2
 802b2f2:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 802b2f6:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b2fa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b2fe:	4413      	add	r3, r2
 802b300:	f242 52a1 	movw	r2, #9633	@ 0x25a1
 802b304:	fb02 f303 	mul.w	r3, r2, r3
 802b308:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 802b30c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b310:	4a73      	ldr	r2, [pc, #460]	@ (802b4e0 <jpeg_idct_4x8+0x4c8>)
 802b312:	fb02 f303 	mul.w	r3, r2, r3
 802b316:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 802b31a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b31e:	4a71      	ldr	r2, [pc, #452]	@ (802b4e4 <jpeg_idct_4x8+0x4cc>)
 802b320:	fb02 f303 	mul.w	r3, r2, r3
 802b324:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    z2 += z1;
 802b328:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b32c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802b330:	4413      	add	r3, r2
 802b332:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 += z1;
 802b336:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 802b33a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 802b33e:	4413      	add	r3, r2
 802b340:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 802b344:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b348:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b34c:	4413      	add	r3, r2
 802b34e:	4a66      	ldr	r2, [pc, #408]	@ (802b4e8 <jpeg_idct_4x8+0x4d0>)
 802b350:	fb02 f303 	mul.w	r3, r2, r3
 802b354:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 802b358:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802b35c:	f640 128e 	movw	r2, #2446	@ 0x98e
 802b360:	fb02 f303 	mul.w	r3, r2, r3
 802b364:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 802b368:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b36c:	f243 020b 	movw	r2, #12299	@ 0x300b
 802b370:	fb02 f303 	mul.w	r3, r2, r3
 802b374:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    tmp0 += z1 + z2;
 802b378:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b37c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b380:	4413      	add	r3, r2
 802b382:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b386:	4413      	add	r3, r2
 802b388:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp3 += z1 + z3;
 802b38c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b390:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b394:	4413      	add	r3, r2
 802b396:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 802b39a:	4413      	add	r3, r2
 802b39c:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 802b3a0:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 802b3a4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b3a8:	4413      	add	r3, r2
 802b3aa:	4a50      	ldr	r2, [pc, #320]	@ (802b4ec <jpeg_idct_4x8+0x4d4>)
 802b3ac:	fb02 f303 	mul.w	r3, r2, r3
 802b3b0:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 802b3b4:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802b3b8:	f244 12b3 	movw	r2, #16819	@ 0x41b3
 802b3bc:	fb02 f303 	mul.w	r3, r2, r3
 802b3c0:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 802b3c4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b3c8:	f246 2254 	movw	r2, #25172	@ 0x6254
 802b3cc:	fb02 f303 	mul.w	r3, r2, r3
 802b3d0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    tmp1 += z1 + z3;
 802b3d4:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b3d8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b3dc:	4413      	add	r3, r2
 802b3de:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 802b3e2:	4413      	add	r3, r2
 802b3e4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    tmp2 += z1 + z2;
 802b3e8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b3ec:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b3f0:	4413      	add	r3, r2
 802b3f2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 802b3f6:	4413      	add	r3, r2
 802b3f8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[4*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 802b3fc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 802b400:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b404:	4413      	add	r3, r2
 802b406:	12da      	asrs	r2, r3, #11
 802b408:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b40c:	601a      	str	r2, [r3, #0]
    wsptr[4*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 802b40e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 802b412:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802b416:	1ad2      	subs	r2, r2, r3
 802b418:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b41c:	3370      	adds	r3, #112	@ 0x70
 802b41e:	12d2      	asrs	r2, r2, #11
 802b420:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 802b422:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 802b426:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b42a:	441a      	add	r2, r3
 802b42c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b430:	3310      	adds	r3, #16
 802b432:	12d2      	asrs	r2, r2, #11
 802b434:	601a      	str	r2, [r3, #0]
    wsptr[4*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 802b436:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 802b43a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b43e:	1ad2      	subs	r2, r2, r3
 802b440:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b444:	3360      	adds	r3, #96	@ 0x60
 802b446:	12d2      	asrs	r2, r2, #11
 802b448:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 802b44a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802b44e:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802b452:	441a      	add	r2, r3
 802b454:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b458:	3320      	adds	r3, #32
 802b45a:	12d2      	asrs	r2, r2, #11
 802b45c:	601a      	str	r2, [r3, #0]
    wsptr[4*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 802b45e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802b462:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802b466:	1ad2      	subs	r2, r2, r3
 802b468:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b46c:	3350      	adds	r3, #80	@ 0x50
 802b46e:	12d2      	asrs	r2, r2, #11
 802b470:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 802b472:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 802b476:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802b47a:	441a      	add	r2, r3
 802b47c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b480:	3330      	adds	r3, #48	@ 0x30
 802b482:	12d2      	asrs	r2, r2, #11
 802b484:	601a      	str	r2, [r3, #0]
    wsptr[4*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 802b486:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 802b48a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802b48e:	1ad2      	subs	r2, r2, r3
 802b490:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b494:	3340      	adds	r3, #64	@ 0x40
 802b496:	12d2      	asrs	r2, r2, #11
 802b498:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 802b49a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802b49e:	3302      	adds	r3, #2
 802b4a0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    quantptr++;
 802b4a4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802b4a8:	3304      	adds	r3, #4
 802b4aa:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    wsptr++;
 802b4ae:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b4b2:	3304      	adds	r3, #4
 802b4b4:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 802b4b8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802b4bc:	3b01      	subs	r3, #1
 802b4be:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802b4c2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802b4c6:	2b00      	cmp	r3, #0
 802b4c8:	f73f adc2 	bgt.w	802b050 <jpeg_idct_4x8+0x38>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  wsptr = workspace;
 802b4cc:	f107 0310 	add.w	r3, r7, #16
 802b4d0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 802b4d4:	2300      	movs	r3, #0
 802b4d6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802b4da:	e0a5      	b.n	802b628 <jpeg_idct_4x8+0x610>
 802b4dc:	ffffc4df 	.word	0xffffc4df
 802b4e0:	ffffc13b 	.word	0xffffc13b
 802b4e4:	fffff384 	.word	0xfffff384
 802b4e8:	ffffe333 	.word	0xffffe333
 802b4ec:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 802b4f0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802b4f4:	009b      	lsls	r3, r3, #2
 802b4f6:	683a      	ldr	r2, [r7, #0]
 802b4f8:	4413      	add	r3, r2
 802b4fa:	681a      	ldr	r2, [r3, #0]
 802b4fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 802b500:	4413      	add	r3, r2
 802b502:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802b506:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b50a:	681b      	ldr	r3, [r3, #0]
 802b50c:	3310      	adds	r3, #16
 802b50e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp2 = (INT32) wsptr[2];
 802b512:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b516:	3308      	adds	r3, #8
 802b518:	681b      	ldr	r3, [r3, #0]
 802b51a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 802b51e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b522:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b526:	4413      	add	r3, r2
 802b528:	035b      	lsls	r3, r3, #13
 802b52a:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 802b52e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 802b532:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b536:	1ad3      	subs	r3, r2, r3
 802b538:	035b      	lsls	r3, r3, #13
 802b53a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 802b53e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b542:	3304      	adds	r3, #4
 802b544:	681b      	ldr	r3, [r3, #0]
 802b546:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    z3 = (INT32) wsptr[3];
 802b54a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b54e:	330c      	adds	r3, #12
 802b550:	681b      	ldr	r3, [r3, #0]
 802b552:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 802b556:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 802b55a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b55e:	4413      	add	r3, r2
 802b560:	f241 1251 	movw	r2, #4433	@ 0x1151
 802b564:	fb02 f303 	mul.w	r3, r2, r3
 802b568:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 802b56c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 802b570:	f641 027e 	movw	r2, #6270	@ 0x187e
 802b574:	fb02 f303 	mul.w	r3, r2, r3
 802b578:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b57c:	4413      	add	r3, r2
 802b57e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 802b582:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802b586:	4a2e      	ldr	r2, [pc, #184]	@ (802b640 <jpeg_idct_4x8+0x628>)
 802b588:	fb02 f303 	mul.w	r3, r2, r3
 802b58c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 802b590:	4413      	add	r3, r2
 802b592:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802b596:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 802b59a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802b59e:	4413      	add	r3, r2
 802b5a0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b5a2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802b5a6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802b5aa:	4413      	add	r3, r2
 802b5ac:	781a      	ldrb	r2, [r3, #0]
 802b5ae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802b5b2:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802b5b4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 802b5b8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 802b5bc:	1ad3      	subs	r3, r2, r3
 802b5be:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b5c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802b5c4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802b5c8:	441a      	add	r2, r3
 802b5ca:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802b5ce:	3303      	adds	r3, #3
 802b5d0:	7812      	ldrb	r2, [r2, #0]
 802b5d2:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 802b5d4:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802b5d8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b5dc:	4413      	add	r3, r2
 802b5de:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b5e0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 802b5e4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802b5e8:	441a      	add	r2, r3
 802b5ea:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802b5ee:	3301      	adds	r3, #1
 802b5f0:	7812      	ldrb	r2, [r2, #0]
 802b5f2:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 802b5f4:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 802b5f8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802b5fc:	1ad3      	subs	r3, r2, r3
 802b5fe:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b600:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 802b604:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 802b608:	441a      	add	r2, r3
 802b60a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802b60e:	3302      	adds	r3, #2
 802b610:	7812      	ldrb	r2, [r2, #0]
 802b612:	701a      	strb	r2, [r3, #0]
    
    wsptr += 4;		/* advance pointer to next row */
 802b614:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 802b618:	3310      	adds	r3, #16
 802b61a:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 802b61e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802b622:	3301      	adds	r3, #1
 802b624:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802b628:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802b62c:	2b07      	cmp	r3, #7
 802b62e:	f77f af5f 	ble.w	802b4f0 <jpeg_idct_4x8+0x4d8>
  }
}
 802b632:	bf00      	nop
 802b634:	bf00      	nop
 802b636:	37dc      	adds	r7, #220	@ 0xdc
 802b638:	46bd      	mov	sp, r7
 802b63a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b63e:	4770      	bx	lr
 802b640:	ffffc4df 	.word	0xffffc4df

0802b644 <jpeg_idct_3x6>:

GLOBAL(void)
jpeg_idct_3x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802b644:	b480      	push	{r7}
 802b646:	b0a7      	sub	sp, #156	@ 0x9c
 802b648:	af00      	add	r7, sp, #0
 802b64a:	60f8      	str	r0, [r7, #12]
 802b64c:	60b9      	str	r1, [r7, #8]
 802b64e:	607a      	str	r2, [r7, #4]
 802b650:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802b652:	68fb      	ldr	r3, [r7, #12]
 802b654:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802b658:	3380      	adds	r3, #128	@ 0x80
 802b65a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 802b65e:	687b      	ldr	r3, [r7, #4]
 802b660:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802b664:	68bb      	ldr	r3, [r7, #8]
 802b666:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802b668:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  wsptr = workspace;
 802b66c:	f107 0314 	add.w	r3, r7, #20
 802b670:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 802b674:	2300      	movs	r3, #0
 802b676:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802b67a:	e0cf      	b.n	802b81c <jpeg_idct_3x6+0x1d8>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802b67c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b680:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b684:	461a      	mov	r2, r3
 802b686:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b68a:	681b      	ldr	r3, [r3, #0]
 802b68c:	fb02 f303 	mul.w	r3, r2, r3
 802b690:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 802b692:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b694:	035b      	lsls	r3, r3, #13
 802b696:	67fb      	str	r3, [r7, #124]	@ 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 802b698:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b69a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802b69e:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 802b6a0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b6a4:	3340      	adds	r3, #64	@ 0x40
 802b6a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b6aa:	461a      	mov	r2, r3
 802b6ac:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b6b0:	3380      	adds	r3, #128	@ 0x80
 802b6b2:	681b      	ldr	r3, [r3, #0]
 802b6b4:	fb02 f303 	mul.w	r3, r2, r3
 802b6b8:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 802b6ba:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802b6bc:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 802b6c0:	fb02 f303 	mul.w	r3, r2, r3
 802b6c4:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp1 = tmp0 + tmp10;
 802b6c6:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802b6c8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802b6ca:	4413      	add	r3, r2
 802b6cc:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 802b6ce:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802b6d0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802b6d2:	1ad2      	subs	r2, r2, r3
 802b6d4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802b6d6:	1ad3      	subs	r3, r2, r3
 802b6d8:	12db      	asrs	r3, r3, #11
 802b6da:	66bb      	str	r3, [r7, #104]	@ 0x68
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802b6dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b6e0:	3320      	adds	r3, #32
 802b6e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b6e6:	461a      	mov	r2, r3
 802b6e8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b6ec:	3340      	adds	r3, #64	@ 0x40
 802b6ee:	681b      	ldr	r3, [r3, #0]
 802b6f0:	fb02 f303 	mul.w	r3, r2, r3
 802b6f4:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 802b6f6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802b6f8:	f242 7231 	movw	r2, #10033	@ 0x2731
 802b6fc:	fb02 f303 	mul.w	r3, r2, r3
 802b700:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp10 = tmp1 + tmp0;
 802b702:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b704:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b706:	4413      	add	r3, r2
 802b708:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp12 = tmp1 - tmp0;
 802b70a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b70c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b70e:	1ad3      	subs	r3, r2, r3
 802b710:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802b712:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b716:	3310      	adds	r3, #16
 802b718:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b71c:	461a      	mov	r2, r3
 802b71e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b722:	3320      	adds	r3, #32
 802b724:	681b      	ldr	r3, [r3, #0]
 802b726:	fb02 f303 	mul.w	r3, r2, r3
 802b72a:	667b      	str	r3, [r7, #100]	@ 0x64
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802b72c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b730:	3330      	adds	r3, #48	@ 0x30
 802b732:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b736:	461a      	mov	r2, r3
 802b738:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b73c:	3360      	adds	r3, #96	@ 0x60
 802b73e:	681b      	ldr	r3, [r3, #0]
 802b740:	fb02 f303 	mul.w	r3, r2, r3
 802b744:	663b      	str	r3, [r7, #96]	@ 0x60
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802b746:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b74a:	3350      	adds	r3, #80	@ 0x50
 802b74c:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b750:	461a      	mov	r2, r3
 802b752:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b756:	33a0      	adds	r3, #160	@ 0xa0
 802b758:	681b      	ldr	r3, [r3, #0]
 802b75a:	fb02 f303 	mul.w	r3, r2, r3
 802b75e:	65fb      	str	r3, [r7, #92]	@ 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 802b760:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 802b762:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b764:	4413      	add	r3, r2
 802b766:	f640 32b6 	movw	r2, #2998	@ 0xbb6
 802b76a:	fb02 f303 	mul.w	r3, r2, r3
 802b76e:	66fb      	str	r3, [r7, #108]	@ 0x6c
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 802b770:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 802b772:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b774:	4413      	add	r3, r2
 802b776:	035b      	lsls	r3, r3, #13
 802b778:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b77a:	4413      	add	r3, r2
 802b77c:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 802b77e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802b780:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b782:	1ad3      	subs	r3, r2, r3
 802b784:	035b      	lsls	r3, r3, #13
 802b786:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b788:	4413      	add	r3, r2
 802b78a:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 802b78c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 802b78e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b790:	1ad2      	subs	r2, r2, r3
 802b792:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b794:	1ad3      	subs	r3, r2, r3
 802b796:	009b      	lsls	r3, r3, #2
 802b798:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 802b79a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 802b79c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b79e:	4413      	add	r3, r2
 802b7a0:	12da      	asrs	r2, r3, #11
 802b7a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7a6:	601a      	str	r2, [r3, #0]
    wsptr[3*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 802b7a8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 802b7aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b7ac:	1ad2      	subs	r2, r2, r3
 802b7ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7b2:	333c      	adds	r3, #60	@ 0x3c
 802b7b4:	12d2      	asrs	r2, r2, #11
 802b7b6:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) (tmp11 + tmp1);
 802b7b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7bc:	330c      	adds	r3, #12
 802b7be:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802b7c0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b7c2:	440a      	add	r2, r1
 802b7c4:	601a      	str	r2, [r3, #0]
    wsptr[3*4] = (int) (tmp11 - tmp1);
 802b7c6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7ca:	3330      	adds	r3, #48	@ 0x30
 802b7cc:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802b7ce:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802b7d0:	1a8a      	subs	r2, r1, r2
 802b7d2:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 802b7d4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802b7d6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802b7d8:	441a      	add	r2, r3
 802b7da:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7de:	3318      	adds	r3, #24
 802b7e0:	12d2      	asrs	r2, r2, #11
 802b7e2:	601a      	str	r2, [r3, #0]
    wsptr[3*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 802b7e4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802b7e6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802b7e8:	1ad2      	subs	r2, r2, r3
 802b7ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b7ee:	3324      	adds	r3, #36	@ 0x24
 802b7f0:	12d2      	asrs	r2, r2, #11
 802b7f2:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 802b7f4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802b7f8:	3301      	adds	r3, #1
 802b7fa:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802b7fe:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802b802:	3302      	adds	r3, #2
 802b804:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 802b808:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 802b80c:	3304      	adds	r3, #4
 802b80e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 802b812:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b816:	3304      	adds	r3, #4
 802b818:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 802b81c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802b820:	2b02      	cmp	r3, #2
 802b822:	f77f af2b 	ble.w	802b67c <jpeg_idct_3x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  wsptr = workspace;
 802b826:	f107 0314 	add.w	r3, r7, #20
 802b82a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 802b82e:	2300      	movs	r3, #0
 802b830:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802b834:	e063      	b.n	802b8fe <jpeg_idct_3x6+0x2ba>
    outptr = output_buf[ctr] + output_col;
 802b836:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802b83a:	009b      	lsls	r3, r3, #2
 802b83c:	683a      	ldr	r2, [r7, #0]
 802b83e:	4413      	add	r3, r2
 802b840:	681a      	ldr	r2, [r3, #0]
 802b842:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 802b846:	4413      	add	r3, r2
 802b848:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 802b84c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b850:	681b      	ldr	r3, [r3, #0]
 802b852:	3310      	adds	r3, #16
 802b854:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp0 <<= CONST_BITS;
 802b856:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b858:	035b      	lsls	r3, r3, #13
 802b85a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    tmp2 = (INT32) wsptr[2];
 802b85c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b860:	3308      	adds	r3, #8
 802b862:	681b      	ldr	r3, [r3, #0]
 802b864:	67bb      	str	r3, [r7, #120]	@ 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802b866:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802b868:	f241 62a1 	movw	r2, #5793	@ 0x16a1
 802b86c:	fb02 f303 	mul.w	r3, r2, r3
 802b870:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp10 = tmp0 + tmp12;
 802b872:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802b874:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802b876:	4413      	add	r3, r2
 802b878:	673b      	str	r3, [r7, #112]	@ 0x70
    tmp2 = tmp0 - tmp12 - tmp12;
 802b87a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802b87c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802b87e:	1ad2      	subs	r2, r2, r3
 802b880:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802b882:	1ad3      	subs	r3, r2, r3
 802b884:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 802b886:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b88a:	3304      	adds	r3, #4
 802b88c:	681b      	ldr	r3, [r3, #0]
 802b88e:	677b      	str	r3, [r7, #116]	@ 0x74
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 802b890:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802b892:	f242 7231 	movw	r2, #10033	@ 0x2731
 802b896:	fb02 f303 	mul.w	r3, r2, r3
 802b89a:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802b89c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 802b89e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b8a0:	4413      	add	r3, r2
 802b8a2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b8a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802b8a8:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 802b8ac:	4413      	add	r3, r2
 802b8ae:	781a      	ldrb	r2, [r3, #0]
 802b8b0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802b8b4:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802b8b6:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 802b8b8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802b8ba:	1ad3      	subs	r3, r2, r3
 802b8bc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b8be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802b8c2:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 802b8c6:	441a      	add	r2, r3
 802b8c8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802b8cc:	3302      	adds	r3, #2
 802b8ce:	7812      	ldrb	r2, [r2, #0]
 802b8d0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 802b8d2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 802b8d4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802b8d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 802b8da:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 802b8de:	441a      	add	r2, r3
 802b8e0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802b8e4:	3301      	adds	r3, #1
 802b8e6:	7812      	ldrb	r2, [r2, #0]
 802b8e8:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 802b8ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 802b8ee:	330c      	adds	r3, #12
 802b8f0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 802b8f4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802b8f8:	3301      	adds	r3, #1
 802b8fa:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 802b8fe:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802b902:	2b05      	cmp	r3, #5
 802b904:	dd97      	ble.n	802b836 <jpeg_idct_3x6+0x1f2>
  }
}
 802b906:	bf00      	nop
 802b908:	bf00      	nop
 802b90a:	379c      	adds	r7, #156	@ 0x9c
 802b90c:	46bd      	mov	sp, r7
 802b90e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b912:	4770      	bx	lr

0802b914 <jpeg_idct_2x4>:

GLOBAL(void)
jpeg_idct_2x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802b914:	b480      	push	{r7}
 802b916:	b09b      	sub	sp, #108	@ 0x6c
 802b918:	af00      	add	r7, sp, #0
 802b91a:	60f8      	str	r0, [r7, #12]
 802b91c:	60b9      	str	r1, [r7, #8]
 802b91e:	607a      	str	r2, [r7, #4]
 802b920:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802b922:	68fb      	ldr	r3, [r7, #12]
 802b924:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802b928:	3380      	adds	r3, #128	@ 0x80
 802b92a:	657b      	str	r3, [r7, #84]	@ 0x54

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  inptr = coef_block;
 802b92c:	687b      	ldr	r3, [r7, #4]
 802b92e:	667b      	str	r3, [r7, #100]	@ 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802b930:	68bb      	ldr	r3, [r7, #8]
 802b932:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802b934:	663b      	str	r3, [r7, #96]	@ 0x60
  wsptr = workspace;
 802b936:	f107 0314 	add.w	r3, r7, #20
 802b93a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 802b93c:	2300      	movs	r3, #0
 802b93e:	65bb      	str	r3, [r7, #88]	@ 0x58
 802b940:	e06d      	b.n	802ba1e <jpeg_idct_2x4+0x10a>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802b942:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802b944:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b948:	461a      	mov	r2, r3
 802b94a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b94c:	681b      	ldr	r3, [r3, #0]
 802b94e:	fb02 f303 	mul.w	r3, r2, r3
 802b952:	64bb      	str	r3, [r7, #72]	@ 0x48
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 802b954:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802b956:	3320      	adds	r3, #32
 802b958:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b95c:	461a      	mov	r2, r3
 802b95e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b960:	3340      	adds	r3, #64	@ 0x40
 802b962:	681b      	ldr	r3, [r3, #0]
 802b964:	fb02 f303 	mul.w	r3, r2, r3
 802b968:	647b      	str	r3, [r7, #68]	@ 0x44

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 802b96a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802b96c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b96e:	4413      	add	r3, r2
 802b970:	035b      	lsls	r3, r3, #13
 802b972:	64fb      	str	r3, [r7, #76]	@ 0x4c
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 802b974:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802b976:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802b978:	1ad3      	subs	r3, r2, r3
 802b97a:	035b      	lsls	r3, r3, #13
 802b97c:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802b97e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802b980:	3310      	adds	r3, #16
 802b982:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b986:	461a      	mov	r2, r3
 802b988:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b98a:	3320      	adds	r3, #32
 802b98c:	681b      	ldr	r3, [r3, #0]
 802b98e:	fb02 f303 	mul.w	r3, r2, r3
 802b992:	63fb      	str	r3, [r7, #60]	@ 0x3c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802b994:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802b996:	3330      	adds	r3, #48	@ 0x30
 802b998:	f9b3 3000 	ldrsh.w	r3, [r3]
 802b99c:	461a      	mov	r2, r3
 802b99e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802b9a0:	3360      	adds	r3, #96	@ 0x60
 802b9a2:	681b      	ldr	r3, [r3, #0]
 802b9a4:	fb02 f303 	mul.w	r3, r2, r3
 802b9a8:	63bb      	str	r3, [r7, #56]	@ 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 802b9aa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802b9ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b9ae:	4413      	add	r3, r2
 802b9b0:	f241 1251 	movw	r2, #4433	@ 0x1151
 802b9b4:	fb02 f303 	mul.w	r3, r2, r3
 802b9b8:	637b      	str	r3, [r7, #52]	@ 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 802b9ba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802b9bc:	f641 027e 	movw	r2, #6270	@ 0x187e
 802b9c0:	fb02 f303 	mul.w	r3, r2, r3
 802b9c4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802b9c6:	4413      	add	r3, r2
 802b9c8:	64bb      	str	r3, [r7, #72]	@ 0x48
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 802b9ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802b9cc:	4a34      	ldr	r2, [pc, #208]	@ (802baa0 <jpeg_idct_2x4+0x18c>)
 802b9ce:	fb02 f303 	mul.w	r3, r2, r3
 802b9d2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802b9d4:	4413      	add	r3, r2
 802b9d6:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Final output stage */

    wsptr[2*0] = tmp10 + tmp0;
 802b9d8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802b9da:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802b9dc:	441a      	add	r2, r3
 802b9de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b9e0:	601a      	str	r2, [r3, #0]
    wsptr[2*3] = tmp10 - tmp0;
 802b9e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b9e4:	3318      	adds	r3, #24
 802b9e6:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 802b9e8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802b9ea:	1a8a      	subs	r2, r1, r2
 802b9ec:	601a      	str	r2, [r3, #0]
    wsptr[2*1] = tmp12 + tmp2;
 802b9ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b9f0:	3308      	adds	r3, #8
 802b9f2:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 802b9f4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802b9f6:	440a      	add	r2, r1
 802b9f8:	601a      	str	r2, [r3, #0]
    wsptr[2*2] = tmp12 - tmp2;
 802b9fa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802b9fc:	3310      	adds	r3, #16
 802b9fe:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 802ba00:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802ba02:	1a8a      	subs	r2, r1, r2
 802ba04:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 802ba06:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ba08:	3301      	adds	r3, #1
 802ba0a:	65bb      	str	r3, [r7, #88]	@ 0x58
 802ba0c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802ba0e:	3302      	adds	r3, #2
 802ba10:	667b      	str	r3, [r7, #100]	@ 0x64
 802ba12:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802ba14:	3304      	adds	r3, #4
 802ba16:	663b      	str	r3, [r7, #96]	@ 0x60
 802ba18:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802ba1a:	3304      	adds	r3, #4
 802ba1c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802ba1e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ba20:	2b01      	cmp	r3, #1
 802ba22:	dd8e      	ble.n	802b942 <jpeg_idct_2x4+0x2e>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 802ba24:	f107 0314 	add.w	r3, r7, #20
 802ba28:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 802ba2a:	2300      	movs	r3, #0
 802ba2c:	65bb      	str	r3, [r7, #88]	@ 0x58
 802ba2e:	e02c      	b.n	802ba8a <jpeg_idct_2x4+0x176>
    outptr = output_buf[ctr] + output_col;
 802ba30:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ba32:	009b      	lsls	r3, r3, #2
 802ba34:	683a      	ldr	r2, [r7, #0]
 802ba36:	4413      	add	r3, r2
 802ba38:	681a      	ldr	r2, [r3, #0]
 802ba3a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802ba3c:	4413      	add	r3, r2
 802ba3e:	653b      	str	r3, [r7, #80]	@ 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = wsptr[0] + (ONE << (CONST_BITS+2));
 802ba40:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802ba42:	681b      	ldr	r3, [r3, #0]
 802ba44:	f503 4300 	add.w	r3, r3, #32768	@ 0x8000
 802ba48:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Odd part */

    tmp0 = wsptr[1];
 802ba4a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802ba4c:	685b      	ldr	r3, [r3, #4]
 802ba4e:	64bb      	str	r3, [r7, #72]	@ 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 802ba50:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802ba52:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802ba54:	4413      	add	r3, r2
 802ba56:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 802ba58:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 802ba5c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802ba5e:	4413      	add	r3, r2
 802ba60:	781a      	ldrb	r2, [r3, #0]
 802ba62:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802ba64:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 802ba66:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802ba68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802ba6a:	1ad3      	subs	r3, r2, r3
 802ba6c:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 802ba6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 802ba72:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802ba74:	441a      	add	r2, r3
 802ba76:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802ba78:	3301      	adds	r3, #1
 802ba7a:	7812      	ldrb	r2, [r2, #0]
 802ba7c:	701a      	strb	r2, [r3, #0]

    wsptr += 2;		/* advance pointer to next row */
 802ba7e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802ba80:	3308      	adds	r3, #8
 802ba82:	65fb      	str	r3, [r7, #92]	@ 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 802ba84:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ba86:	3301      	adds	r3, #1
 802ba88:	65bb      	str	r3, [r7, #88]	@ 0x58
 802ba8a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ba8c:	2b03      	cmp	r3, #3
 802ba8e:	ddcf      	ble.n	802ba30 <jpeg_idct_2x4+0x11c>
  }
}
 802ba90:	bf00      	nop
 802ba92:	bf00      	nop
 802ba94:	376c      	adds	r7, #108	@ 0x6c
 802ba96:	46bd      	mov	sp, r7
 802ba98:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ba9c:	4770      	bx	lr
 802ba9e:	bf00      	nop
 802baa0:	ffffc4df 	.word	0xffffc4df

0802baa4 <jpeg_idct_1x2>:

GLOBAL(void)
jpeg_idct_1x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802baa4:	b480      	push	{r7}
 802baa6:	b089      	sub	sp, #36	@ 0x24
 802baa8:	af00      	add	r7, sp, #0
 802baaa:	60f8      	str	r0, [r7, #12]
 802baac:	60b9      	str	r1, [r7, #8]
 802baae:	607a      	str	r2, [r7, #4]
 802bab0:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802bab2:	68fb      	ldr	r3, [r7, #12]
 802bab4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802bab8:	3380      	adds	r3, #128	@ 0x80
 802baba:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* Process 1 column from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802babc:	68bb      	ldr	r3, [r7, #8]
 802babe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802bac0:	61bb      	str	r3, [r7, #24]

  /* Even part */
    
  tmp10 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802bac2:	687b      	ldr	r3, [r7, #4]
 802bac4:	f9b3 3000 	ldrsh.w	r3, [r3]
 802bac8:	461a      	mov	r2, r3
 802baca:	69bb      	ldr	r3, [r7, #24]
 802bacc:	681b      	ldr	r3, [r3, #0]
 802bace:	fb02 f303 	mul.w	r3, r2, r3
 802bad2:	617b      	str	r3, [r7, #20]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 802bad4:	697b      	ldr	r3, [r7, #20]
 802bad6:	3304      	adds	r3, #4
 802bad8:	617b      	str	r3, [r7, #20]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802bada:	687b      	ldr	r3, [r7, #4]
 802badc:	3310      	adds	r3, #16
 802bade:	f9b3 3000 	ldrsh.w	r3, [r3]
 802bae2:	461a      	mov	r2, r3
 802bae4:	69bb      	ldr	r3, [r7, #24]
 802bae6:	3320      	adds	r3, #32
 802bae8:	681b      	ldr	r3, [r3, #0]
 802baea:	fb02 f303 	mul.w	r3, r2, r3
 802baee:	613b      	str	r3, [r7, #16]

  /* Final output stage */

  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 802baf0:	697a      	ldr	r2, [r7, #20]
 802baf2:	693b      	ldr	r3, [r7, #16]
 802baf4:	4413      	add	r3, r2
 802baf6:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 802baf8:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 802bafc:	69fa      	ldr	r2, [r7, #28]
 802bafe:	441a      	add	r2, r3
 802bb00:	683b      	ldr	r3, [r7, #0]
 802bb02:	6819      	ldr	r1, [r3, #0]
 802bb04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bb06:	440b      	add	r3, r1
 802bb08:	7812      	ldrb	r2, [r2, #0]
 802bb0a:	701a      	strb	r2, [r3, #0]
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 802bb0c:	697a      	ldr	r2, [r7, #20]
 802bb0e:	693b      	ldr	r3, [r7, #16]
 802bb10:	1ad3      	subs	r3, r2, r3
 802bb12:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 802bb14:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 802bb18:	69fa      	ldr	r2, [r7, #28]
 802bb1a:	441a      	add	r2, r3
 802bb1c:	683b      	ldr	r3, [r7, #0]
 802bb1e:	3304      	adds	r3, #4
 802bb20:	6819      	ldr	r1, [r3, #0]
 802bb22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bb24:	440b      	add	r3, r1
 802bb26:	7812      	ldrb	r2, [r2, #0]
 802bb28:	701a      	strb	r2, [r3, #0]
}
 802bb2a:	bf00      	nop
 802bb2c:	3724      	adds	r7, #36	@ 0x24
 802bb2e:	46bd      	mov	sp, r7
 802bb30:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bb34:	4770      	bx	lr

0802bb36 <out_of_memory>:

LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
 802bb36:	b580      	push	{r7, lr}
 802bb38:	b082      	sub	sp, #8
 802bb3a:	af00      	add	r7, sp, #0
 802bb3c:	6078      	str	r0, [r7, #4]
 802bb3e:	6039      	str	r1, [r7, #0]
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 802bb40:	687b      	ldr	r3, [r7, #4]
 802bb42:	681b      	ldr	r3, [r3, #0]
 802bb44:	2238      	movs	r2, #56	@ 0x38
 802bb46:	615a      	str	r2, [r3, #20]
 802bb48:	687b      	ldr	r3, [r7, #4]
 802bb4a:	681b      	ldr	r3, [r3, #0]
 802bb4c:	683a      	ldr	r2, [r7, #0]
 802bb4e:	619a      	str	r2, [r3, #24]
 802bb50:	687b      	ldr	r3, [r7, #4]
 802bb52:	681b      	ldr	r3, [r3, #0]
 802bb54:	681b      	ldr	r3, [r3, #0]
 802bb56:	6878      	ldr	r0, [r7, #4]
 802bb58:	4798      	blx	r3
}
 802bb5a:	bf00      	nop
 802bb5c:	3708      	adds	r7, #8
 802bb5e:	46bd      	mov	sp, r7
 802bb60:	bd80      	pop	{r7, pc}
	...

0802bb64 <alloc_small>:


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
 802bb64:	b580      	push	{r7, lr}
 802bb66:	b08c      	sub	sp, #48	@ 0x30
 802bb68:	af00      	add	r7, sp, #0
 802bb6a:	60f8      	str	r0, [r7, #12]
 802bb6c:	60b9      	str	r1, [r7, #8]
 802bb6e:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802bb70:	68fb      	ldr	r3, [r7, #12]
 802bb72:	685b      	ldr	r3, [r3, #4]
 802bb74:	623b      	str	r3, [r7, #32]
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
 802bb76:	687b      	ldr	r3, [r7, #4]
 802bb78:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 802bb7c:	4293      	cmp	r3, r2
 802bb7e:	d903      	bls.n	802bb88 <alloc_small+0x24>
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 802bb80:	2101      	movs	r1, #1
 802bb82:	68f8      	ldr	r0, [r7, #12]
 802bb84:	f7ff ffd7 	bl	802bb36 <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 802bb88:	687b      	ldr	r3, [r7, #4]
 802bb8a:	f003 0307 	and.w	r3, r3, #7
 802bb8e:	61fb      	str	r3, [r7, #28]
  if (odd_bytes > 0)
 802bb90:	69fb      	ldr	r3, [r7, #28]
 802bb92:	2b00      	cmp	r3, #0
 802bb94:	d004      	beq.n	802bba0 <alloc_small+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 802bb96:	687a      	ldr	r2, [r7, #4]
 802bb98:	69fb      	ldr	r3, [r7, #28]
 802bb9a:	1ad3      	subs	r3, r2, r3
 802bb9c:	3308      	adds	r3, #8
 802bb9e:	607b      	str	r3, [r7, #4]

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 802bba0:	68bb      	ldr	r3, [r7, #8]
 802bba2:	2b00      	cmp	r3, #0
 802bba4:	db02      	blt.n	802bbac <alloc_small+0x48>
 802bba6:	68bb      	ldr	r3, [r7, #8]
 802bba8:	2b01      	cmp	r3, #1
 802bbaa:	dd0c      	ble.n	802bbc6 <alloc_small+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802bbac:	68fb      	ldr	r3, [r7, #12]
 802bbae:	681b      	ldr	r3, [r3, #0]
 802bbb0:	220f      	movs	r2, #15
 802bbb2:	615a      	str	r2, [r3, #20]
 802bbb4:	68fb      	ldr	r3, [r7, #12]
 802bbb6:	681b      	ldr	r3, [r3, #0]
 802bbb8:	68ba      	ldr	r2, [r7, #8]
 802bbba:	619a      	str	r2, [r3, #24]
 802bbbc:	68fb      	ldr	r3, [r7, #12]
 802bbbe:	681b      	ldr	r3, [r3, #0]
 802bbc0:	681b      	ldr	r3, [r3, #0]
 802bbc2:	68f8      	ldr	r0, [r7, #12]
 802bbc4:	4798      	blx	r3
  prev_hdr_ptr = NULL;
 802bbc6:	2300      	movs	r3, #0
 802bbc8:	62bb      	str	r3, [r7, #40]	@ 0x28
  hdr_ptr = mem->small_list[pool_id];
 802bbca:	6a3a      	ldr	r2, [r7, #32]
 802bbcc:	68bb      	ldr	r3, [r7, #8]
 802bbce:	330c      	adds	r3, #12
 802bbd0:	009b      	lsls	r3, r3, #2
 802bbd2:	4413      	add	r3, r2
 802bbd4:	685b      	ldr	r3, [r3, #4]
 802bbd6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (hdr_ptr != NULL) {
 802bbd8:	e009      	b.n	802bbee <alloc_small+0x8a>
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 802bbda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bbdc:	689b      	ldr	r3, [r3, #8]
 802bbde:	687a      	ldr	r2, [r7, #4]
 802bbe0:	429a      	cmp	r2, r3
 802bbe2:	d908      	bls.n	802bbf6 <alloc_small+0x92>
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
 802bbe4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bbe6:	62bb      	str	r3, [r7, #40]	@ 0x28
    hdr_ptr = hdr_ptr->hdr.next;
 802bbe8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bbea:	681b      	ldr	r3, [r3, #0]
 802bbec:	62fb      	str	r3, [r7, #44]	@ 0x2c
  while (hdr_ptr != NULL) {
 802bbee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bbf0:	2b00      	cmp	r3, #0
 802bbf2:	d1f2      	bne.n	802bbda <alloc_small+0x76>
 802bbf4:	e000      	b.n	802bbf8 <alloc_small+0x94>
      break;			/* found pool with enough space */
 802bbf6:	bf00      	nop
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
 802bbf8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bbfa:	2b00      	cmp	r3, #0
 802bbfc:	d154      	bne.n	802bca8 <alloc_small+0x144>
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
 802bbfe:	687b      	ldr	r3, [r7, #4]
 802bc00:	3310      	adds	r3, #16
 802bc02:	61bb      	str	r3, [r7, #24]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 802bc04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bc06:	2b00      	cmp	r3, #0
 802bc08:	d105      	bne.n	802bc16 <alloc_small+0xb2>
      slop = first_pool_slop[pool_id];
 802bc0a:	4a34      	ldr	r2, [pc, #208]	@ (802bcdc <alloc_small+0x178>)
 802bc0c:	68bb      	ldr	r3, [r7, #8]
 802bc0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802bc12:	627b      	str	r3, [r7, #36]	@ 0x24
 802bc14:	e004      	b.n	802bc20 <alloc_small+0xbc>
    else
      slop = extra_pool_slop[pool_id];
 802bc16:	4a32      	ldr	r2, [pc, #200]	@ (802bce0 <alloc_small+0x17c>)
 802bc18:	68bb      	ldr	r3, [r7, #8]
 802bc1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802bc1e:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
 802bc20:	69bb      	ldr	r3, [r7, #24]
 802bc22:	f5c3 3380 	rsb	r3, r3, #65536	@ 0x10000
 802bc26:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802bc28:	429a      	cmp	r2, r3
 802bc2a:	d903      	bls.n	802bc34 <alloc_small+0xd0>
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 802bc2c:	69bb      	ldr	r3, [r7, #24]
 802bc2e:	f5c3 3380 	rsb	r3, r3, #65536	@ 0x10000
 802bc32:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 802bc34:	69ba      	ldr	r2, [r7, #24]
 802bc36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bc38:	4413      	add	r3, r2
 802bc3a:	4619      	mov	r1, r3
 802bc3c:	68f8      	ldr	r0, [r7, #12]
 802bc3e:	f000 feff 	bl	802ca40 <jpeg_get_small>
 802bc42:	62f8      	str	r0, [r7, #44]	@ 0x2c
      if (hdr_ptr != NULL)
 802bc44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bc46:	2b00      	cmp	r3, #0
 802bc48:	d10a      	bne.n	802bc60 <alloc_small+0xfc>
	break;
      slop /= 2;
 802bc4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bc4c:	085b      	lsrs	r3, r3, #1
 802bc4e:	627b      	str	r3, [r7, #36]	@ 0x24
      if (slop < MIN_SLOP)	/* give up when it gets real small */
 802bc50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bc52:	2b31      	cmp	r3, #49	@ 0x31
 802bc54:	d8ee      	bhi.n	802bc34 <alloc_small+0xd0>
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 802bc56:	2102      	movs	r1, #2
 802bc58:	68f8      	ldr	r0, [r7, #12]
 802bc5a:	f7ff ff6c 	bl	802bb36 <out_of_memory>
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 802bc5e:	e7e9      	b.n	802bc34 <alloc_small+0xd0>
	break;
 802bc60:	bf00      	nop
    }
    mem->total_space_allocated += min_request + slop;
 802bc62:	6a3b      	ldr	r3, [r7, #32]
 802bc64:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802bc66:	4619      	mov	r1, r3
 802bc68:	69ba      	ldr	r2, [r7, #24]
 802bc6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bc6c:	4413      	add	r3, r2
 802bc6e:	440b      	add	r3, r1
 802bc70:	461a      	mov	r2, r3
 802bc72:	6a3b      	ldr	r3, [r7, #32]
 802bc74:	64da      	str	r2, [r3, #76]	@ 0x4c
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
 802bc76:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bc78:	2200      	movs	r2, #0
 802bc7a:	601a      	str	r2, [r3, #0]
    hdr_ptr->hdr.bytes_used = 0;
 802bc7c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bc7e:	2200      	movs	r2, #0
 802bc80:	605a      	str	r2, [r3, #4]
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
 802bc82:	687a      	ldr	r2, [r7, #4]
 802bc84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bc86:	441a      	add	r2, r3
 802bc88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bc8a:	609a      	str	r2, [r3, #8]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 802bc8c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bc8e:	2b00      	cmp	r3, #0
 802bc90:	d107      	bne.n	802bca2 <alloc_small+0x13e>
      mem->small_list[pool_id] = hdr_ptr;
 802bc92:	6a3a      	ldr	r2, [r7, #32]
 802bc94:	68bb      	ldr	r3, [r7, #8]
 802bc96:	330c      	adds	r3, #12
 802bc98:	009b      	lsls	r3, r3, #2
 802bc9a:	4413      	add	r3, r2
 802bc9c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802bc9e:	605a      	str	r2, [r3, #4]
 802bca0:	e002      	b.n	802bca8 <alloc_small+0x144>
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
 802bca2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bca4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802bca6:	601a      	str	r2, [r3, #0]
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 802bca8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcaa:	3310      	adds	r3, #16
 802bcac:	617b      	str	r3, [r7, #20]
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
 802bcae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcb0:	685b      	ldr	r3, [r3, #4]
 802bcb2:	697a      	ldr	r2, [r7, #20]
 802bcb4:	4413      	add	r3, r2
 802bcb6:	617b      	str	r3, [r7, #20]
  hdr_ptr->hdr.bytes_used += sizeofobject;
 802bcb8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcba:	685a      	ldr	r2, [r3, #4]
 802bcbc:	687b      	ldr	r3, [r7, #4]
 802bcbe:	441a      	add	r2, r3
 802bcc0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcc2:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left -= sizeofobject;
 802bcc4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcc6:	689a      	ldr	r2, [r3, #8]
 802bcc8:	687b      	ldr	r3, [r7, #4]
 802bcca:	1ad2      	subs	r2, r2, r3
 802bccc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802bcce:	609a      	str	r2, [r3, #8]

  return (void *) data_ptr;
 802bcd0:	697b      	ldr	r3, [r7, #20]
}
 802bcd2:	4618      	mov	r0, r3
 802bcd4:	3730      	adds	r7, #48	@ 0x30
 802bcd6:	46bd      	mov	sp, r7
 802bcd8:	bd80      	pop	{r7, pc}
 802bcda:	bf00      	nop
 802bcdc:	08032634 	.word	0x08032634
 802bce0:	0803263c 	.word	0x0803263c

0802bce4 <alloc_large>:
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
 802bce4:	b580      	push	{r7, lr}
 802bce6:	b088      	sub	sp, #32
 802bce8:	af00      	add	r7, sp, #0
 802bcea:	60f8      	str	r0, [r7, #12]
 802bcec:	60b9      	str	r1, [r7, #8]
 802bcee:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802bcf0:	68fb      	ldr	r3, [r7, #12]
 802bcf2:	685b      	ldr	r3, [r3, #4]
 802bcf4:	61fb      	str	r3, [r7, #28]
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
 802bcf6:	687b      	ldr	r3, [r7, #4]
 802bcf8:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 802bcfc:	4293      	cmp	r3, r2
 802bcfe:	d903      	bls.n	802bd08 <alloc_large+0x24>
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 802bd00:	2103      	movs	r1, #3
 802bd02:	68f8      	ldr	r0, [r7, #12]
 802bd04:	f7ff ff17 	bl	802bb36 <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 802bd08:	687b      	ldr	r3, [r7, #4]
 802bd0a:	f003 0307 	and.w	r3, r3, #7
 802bd0e:	61bb      	str	r3, [r7, #24]
  if (odd_bytes > 0)
 802bd10:	69bb      	ldr	r3, [r7, #24]
 802bd12:	2b00      	cmp	r3, #0
 802bd14:	d004      	beq.n	802bd20 <alloc_large+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 802bd16:	687a      	ldr	r2, [r7, #4]
 802bd18:	69bb      	ldr	r3, [r7, #24]
 802bd1a:	1ad3      	subs	r3, r2, r3
 802bd1c:	3308      	adds	r3, #8
 802bd1e:	607b      	str	r3, [r7, #4]

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 802bd20:	68bb      	ldr	r3, [r7, #8]
 802bd22:	2b00      	cmp	r3, #0
 802bd24:	db02      	blt.n	802bd2c <alloc_large+0x48>
 802bd26:	68bb      	ldr	r3, [r7, #8]
 802bd28:	2b01      	cmp	r3, #1
 802bd2a:	dd0c      	ble.n	802bd46 <alloc_large+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802bd2c:	68fb      	ldr	r3, [r7, #12]
 802bd2e:	681b      	ldr	r3, [r3, #0]
 802bd30:	220f      	movs	r2, #15
 802bd32:	615a      	str	r2, [r3, #20]
 802bd34:	68fb      	ldr	r3, [r7, #12]
 802bd36:	681b      	ldr	r3, [r3, #0]
 802bd38:	68ba      	ldr	r2, [r7, #8]
 802bd3a:	619a      	str	r2, [r3, #24]
 802bd3c:	68fb      	ldr	r3, [r7, #12]
 802bd3e:	681b      	ldr	r3, [r3, #0]
 802bd40:	681b      	ldr	r3, [r3, #0]
 802bd42:	68f8      	ldr	r0, [r7, #12]
 802bd44:	4798      	blx	r3

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 802bd46:	687b      	ldr	r3, [r7, #4]
 802bd48:	3310      	adds	r3, #16
 802bd4a:	4619      	mov	r1, r3
 802bd4c:	68f8      	ldr	r0, [r7, #12]
 802bd4e:	f000 fe91 	bl	802ca74 <jpeg_get_large>
 802bd52:	6178      	str	r0, [r7, #20]
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
 802bd54:	697b      	ldr	r3, [r7, #20]
 802bd56:	2b00      	cmp	r3, #0
 802bd58:	d103      	bne.n	802bd62 <alloc_large+0x7e>
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
 802bd5a:	2104      	movs	r1, #4
 802bd5c:	68f8      	ldr	r0, [r7, #12]
 802bd5e:	f7ff feea 	bl	802bb36 <out_of_memory>
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 802bd62:	69fb      	ldr	r3, [r7, #28]
 802bd64:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802bd66:	461a      	mov	r2, r3
 802bd68:	687b      	ldr	r3, [r7, #4]
 802bd6a:	4413      	add	r3, r2
 802bd6c:	3310      	adds	r3, #16
 802bd6e:	461a      	mov	r2, r3
 802bd70:	69fb      	ldr	r3, [r7, #28]
 802bd72:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
 802bd74:	69fa      	ldr	r2, [r7, #28]
 802bd76:	68bb      	ldr	r3, [r7, #8]
 802bd78:	330e      	adds	r3, #14
 802bd7a:	009b      	lsls	r3, r3, #2
 802bd7c:	4413      	add	r3, r2
 802bd7e:	685a      	ldr	r2, [r3, #4]
 802bd80:	697b      	ldr	r3, [r7, #20]
 802bd82:	601a      	str	r2, [r3, #0]
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
 802bd84:	697b      	ldr	r3, [r7, #20]
 802bd86:	687a      	ldr	r2, [r7, #4]
 802bd88:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left = 0;
 802bd8a:	697b      	ldr	r3, [r7, #20]
 802bd8c:	2200      	movs	r2, #0
 802bd8e:	609a      	str	r2, [r3, #8]
  mem->large_list[pool_id] = hdr_ptr;
 802bd90:	69fa      	ldr	r2, [r7, #28]
 802bd92:	68bb      	ldr	r3, [r7, #8]
 802bd94:	330e      	adds	r3, #14
 802bd96:	009b      	lsls	r3, r3, #2
 802bd98:	4413      	add	r3, r2
 802bd9a:	697a      	ldr	r2, [r7, #20]
 802bd9c:	605a      	str	r2, [r3, #4]

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 802bd9e:	697b      	ldr	r3, [r7, #20]
 802bda0:	3310      	adds	r3, #16
}
 802bda2:	4618      	mov	r0, r3
 802bda4:	3720      	adds	r7, #32
 802bda6:	46bd      	mov	sp, r7
 802bda8:	bd80      	pop	{r7, pc}

0802bdaa <alloc_sarray>:

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
 802bdaa:	b580      	push	{r7, lr}
 802bdac:	b08c      	sub	sp, #48	@ 0x30
 802bdae:	af00      	add	r7, sp, #0
 802bdb0:	60f8      	str	r0, [r7, #12]
 802bdb2:	60b9      	str	r1, [r7, #8]
 802bdb4:	607a      	str	r2, [r7, #4]
 802bdb6:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802bdb8:	68fb      	ldr	r3, [r7, #12]
 802bdba:	685b      	ldr	r3, [r3, #4]
 802bdbc:	61fb      	str	r3, [r7, #28]
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 802bdbe:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 802bdc2:	687b      	ldr	r3, [r7, #4]
 802bdc4:	fbb2 f3f3 	udiv	r3, r2, r3
 802bdc8:	61bb      	str	r3, [r7, #24]
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
 802bdca:	69bb      	ldr	r3, [r7, #24]
 802bdcc:	2b00      	cmp	r3, #0
 802bdce:	dc08      	bgt.n	802bde2 <alloc_sarray+0x38>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 802bdd0:	68fb      	ldr	r3, [r7, #12]
 802bdd2:	681b      	ldr	r3, [r3, #0]
 802bdd4:	2248      	movs	r2, #72	@ 0x48
 802bdd6:	615a      	str	r2, [r3, #20]
 802bdd8:	68fb      	ldr	r3, [r7, #12]
 802bdda:	681b      	ldr	r3, [r3, #0]
 802bddc:	681b      	ldr	r3, [r3, #0]
 802bdde:	68f8      	ldr	r0, [r7, #12]
 802bde0:	4798      	blx	r3
  if (ltemp < (long) numrows)
 802bde2:	683b      	ldr	r3, [r7, #0]
 802bde4:	69ba      	ldr	r2, [r7, #24]
 802bde6:	429a      	cmp	r2, r3
 802bde8:	da02      	bge.n	802bdf0 <alloc_sarray+0x46>
    rowsperchunk = (JDIMENSION) ltemp;
 802bdea:	69bb      	ldr	r3, [r7, #24]
 802bdec:	62bb      	str	r3, [r7, #40]	@ 0x28
 802bdee:	e001      	b.n	802bdf4 <alloc_sarray+0x4a>
  else
    rowsperchunk = numrows;
 802bdf0:	683b      	ldr	r3, [r7, #0]
 802bdf2:	62bb      	str	r3, [r7, #40]	@ 0x28
  mem->last_rowsperchunk = rowsperchunk;
 802bdf4:	69fb      	ldr	r3, [r7, #28]
 802bdf6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802bdf8:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 802bdfa:	683b      	ldr	r3, [r7, #0]
 802bdfc:	009b      	lsls	r3, r3, #2
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
 802bdfe:	461a      	mov	r2, r3
 802be00:	68b9      	ldr	r1, [r7, #8]
 802be02:	68f8      	ldr	r0, [r7, #12]
 802be04:	f7ff feae 	bl	802bb64 <alloc_small>
 802be08:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 802be0a:	2300      	movs	r3, #0
 802be0c:	627b      	str	r3, [r7, #36]	@ 0x24
  while (currow < numrows) {
 802be0e:	e026      	b.n	802be5e <alloc_sarray+0xb4>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 802be10:	683a      	ldr	r2, [r7, #0]
 802be12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802be14:	1ad3      	subs	r3, r2, r3
 802be16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802be18:	4293      	cmp	r3, r2
 802be1a:	bf28      	it	cs
 802be1c:	4613      	movcs	r3, r2
 802be1e:	62bb      	str	r3, [r7, #40]	@ 0x28
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 802be20:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802be22:	687a      	ldr	r2, [r7, #4]
 802be24:	fb02 f303 	mul.w	r3, r2, r3
 802be28:	461a      	mov	r2, r3
 802be2a:	68b9      	ldr	r1, [r7, #8]
 802be2c:	68f8      	ldr	r0, [r7, #12]
 802be2e:	f7ff ff59 	bl	802bce4 <alloc_large>
 802be32:	62f8      	str	r0, [r7, #44]	@ 0x2c
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
 802be34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802be36:	623b      	str	r3, [r7, #32]
 802be38:	e00e      	b.n	802be58 <alloc_sarray+0xae>
      result[currow++] = workspace;
 802be3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802be3c:	1c5a      	adds	r2, r3, #1
 802be3e:	627a      	str	r2, [r7, #36]	@ 0x24
 802be40:	009b      	lsls	r3, r3, #2
 802be42:	697a      	ldr	r2, [r7, #20]
 802be44:	4413      	add	r3, r2
 802be46:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802be48:	601a      	str	r2, [r3, #0]
      workspace += samplesperrow;
 802be4a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802be4c:	687b      	ldr	r3, [r7, #4]
 802be4e:	4413      	add	r3, r2
 802be50:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 802be52:	6a3b      	ldr	r3, [r7, #32]
 802be54:	3b01      	subs	r3, #1
 802be56:	623b      	str	r3, [r7, #32]
 802be58:	6a3b      	ldr	r3, [r7, #32]
 802be5a:	2b00      	cmp	r3, #0
 802be5c:	d1ed      	bne.n	802be3a <alloc_sarray+0x90>
  while (currow < numrows) {
 802be5e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802be60:	683b      	ldr	r3, [r7, #0]
 802be62:	429a      	cmp	r2, r3
 802be64:	d3d4      	bcc.n	802be10 <alloc_sarray+0x66>
    }
  }

  return result;
 802be66:	697b      	ldr	r3, [r7, #20]
}
 802be68:	4618      	mov	r0, r3
 802be6a:	3730      	adds	r7, #48	@ 0x30
 802be6c:	46bd      	mov	sp, r7
 802be6e:	bd80      	pop	{r7, pc}

0802be70 <alloc_barray>:

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
 802be70:	b580      	push	{r7, lr}
 802be72:	b08c      	sub	sp, #48	@ 0x30
 802be74:	af00      	add	r7, sp, #0
 802be76:	60f8      	str	r0, [r7, #12]
 802be78:	60b9      	str	r1, [r7, #8]
 802be7a:	607a      	str	r2, [r7, #4]
 802be7c:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802be7e:	68fb      	ldr	r3, [r7, #12]
 802be80:	685b      	ldr	r3, [r3, #4]
 802be82:	61fb      	str	r3, [r7, #28]
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
 802be84:	687b      	ldr	r3, [r7, #4]
 802be86:	01db      	lsls	r3, r3, #7
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 802be88:	f64f 72f0 	movw	r2, #65520	@ 0xfff0
 802be8c:	fbb2 f3f3 	udiv	r3, r2, r3
 802be90:	61bb      	str	r3, [r7, #24]
  if (ltemp <= 0)
 802be92:	69bb      	ldr	r3, [r7, #24]
 802be94:	2b00      	cmp	r3, #0
 802be96:	dc08      	bgt.n	802beaa <alloc_barray+0x3a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 802be98:	68fb      	ldr	r3, [r7, #12]
 802be9a:	681b      	ldr	r3, [r3, #0]
 802be9c:	2248      	movs	r2, #72	@ 0x48
 802be9e:	615a      	str	r2, [r3, #20]
 802bea0:	68fb      	ldr	r3, [r7, #12]
 802bea2:	681b      	ldr	r3, [r3, #0]
 802bea4:	681b      	ldr	r3, [r3, #0]
 802bea6:	68f8      	ldr	r0, [r7, #12]
 802bea8:	4798      	blx	r3
  if (ltemp < (long) numrows)
 802beaa:	683b      	ldr	r3, [r7, #0]
 802beac:	69ba      	ldr	r2, [r7, #24]
 802beae:	429a      	cmp	r2, r3
 802beb0:	da02      	bge.n	802beb8 <alloc_barray+0x48>
    rowsperchunk = (JDIMENSION) ltemp;
 802beb2:	69bb      	ldr	r3, [r7, #24]
 802beb4:	62bb      	str	r3, [r7, #40]	@ 0x28
 802beb6:	e001      	b.n	802bebc <alloc_barray+0x4c>
  else
    rowsperchunk = numrows;
 802beb8:	683b      	ldr	r3, [r7, #0]
 802beba:	62bb      	str	r3, [r7, #40]	@ 0x28
  mem->last_rowsperchunk = rowsperchunk;
 802bebc:	69fb      	ldr	r3, [r7, #28]
 802bebe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802bec0:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 802bec2:	683b      	ldr	r3, [r7, #0]
 802bec4:	009b      	lsls	r3, r3, #2
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
 802bec6:	461a      	mov	r2, r3
 802bec8:	68b9      	ldr	r1, [r7, #8]
 802beca:	68f8      	ldr	r0, [r7, #12]
 802becc:	f7ff fe4a 	bl	802bb64 <alloc_small>
 802bed0:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 802bed2:	2300      	movs	r3, #0
 802bed4:	627b      	str	r3, [r7, #36]	@ 0x24
  while (currow < numrows) {
 802bed6:	e028      	b.n	802bf2a <alloc_barray+0xba>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 802bed8:	683a      	ldr	r2, [r7, #0]
 802beda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bedc:	1ad3      	subs	r3, r2, r3
 802bede:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802bee0:	4293      	cmp	r3, r2
 802bee2:	bf28      	it	cs
 802bee4:	4613      	movcs	r3, r2
 802bee6:	62bb      	str	r3, [r7, #40]	@ 0x28
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 802bee8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802beea:	687a      	ldr	r2, [r7, #4]
 802beec:	fb02 f303 	mul.w	r3, r2, r3
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 802bef0:	01db      	lsls	r3, r3, #7
 802bef2:	461a      	mov	r2, r3
 802bef4:	68b9      	ldr	r1, [r7, #8]
 802bef6:	68f8      	ldr	r0, [r7, #12]
 802bef8:	f7ff fef4 	bl	802bce4 <alloc_large>
 802befc:	62f8      	str	r0, [r7, #44]	@ 0x2c
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
 802befe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802bf00:	623b      	str	r3, [r7, #32]
 802bf02:	e00f      	b.n	802bf24 <alloc_barray+0xb4>
      result[currow++] = workspace;
 802bf04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802bf06:	1c5a      	adds	r2, r3, #1
 802bf08:	627a      	str	r2, [r7, #36]	@ 0x24
 802bf0a:	009b      	lsls	r3, r3, #2
 802bf0c:	697a      	ldr	r2, [r7, #20]
 802bf0e:	4413      	add	r3, r2
 802bf10:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802bf12:	601a      	str	r2, [r3, #0]
      workspace += blocksperrow;
 802bf14:	687b      	ldr	r3, [r7, #4]
 802bf16:	01db      	lsls	r3, r3, #7
 802bf18:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802bf1a:	4413      	add	r3, r2
 802bf1c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 802bf1e:	6a3b      	ldr	r3, [r7, #32]
 802bf20:	3b01      	subs	r3, #1
 802bf22:	623b      	str	r3, [r7, #32]
 802bf24:	6a3b      	ldr	r3, [r7, #32]
 802bf26:	2b00      	cmp	r3, #0
 802bf28:	d1ec      	bne.n	802bf04 <alloc_barray+0x94>
  while (currow < numrows) {
 802bf2a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802bf2c:	683b      	ldr	r3, [r7, #0]
 802bf2e:	429a      	cmp	r2, r3
 802bf30:	d3d2      	bcc.n	802bed8 <alloc_barray+0x68>
    }
  }

  return result;
 802bf32:	697b      	ldr	r3, [r7, #20]
}
 802bf34:	4618      	mov	r0, r3
 802bf36:	3730      	adds	r7, #48	@ 0x30
 802bf38:	46bd      	mov	sp, r7
 802bf3a:	bd80      	pop	{r7, pc}

0802bf3c <request_virt_sarray>:
METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
 802bf3c:	b580      	push	{r7, lr}
 802bf3e:	b086      	sub	sp, #24
 802bf40:	af00      	add	r7, sp, #0
 802bf42:	60f8      	str	r0, [r7, #12]
 802bf44:	60b9      	str	r1, [r7, #8]
 802bf46:	607a      	str	r2, [r7, #4]
 802bf48:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802bf4a:	68fb      	ldr	r3, [r7, #12]
 802bf4c:	685b      	ldr	r3, [r3, #4]
 802bf4e:	617b      	str	r3, [r7, #20]
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 802bf50:	68bb      	ldr	r3, [r7, #8]
 802bf52:	2b01      	cmp	r3, #1
 802bf54:	d00c      	beq.n	802bf70 <request_virt_sarray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802bf56:	68fb      	ldr	r3, [r7, #12]
 802bf58:	681b      	ldr	r3, [r3, #0]
 802bf5a:	220f      	movs	r2, #15
 802bf5c:	615a      	str	r2, [r3, #20]
 802bf5e:	68fb      	ldr	r3, [r7, #12]
 802bf60:	681b      	ldr	r3, [r3, #0]
 802bf62:	68ba      	ldr	r2, [r7, #8]
 802bf64:	619a      	str	r2, [r3, #24]
 802bf66:	68fb      	ldr	r3, [r7, #12]
 802bf68:	681b      	ldr	r3, [r3, #0]
 802bf6a:	681b      	ldr	r3, [r3, #0]
 802bf6c:	68f8      	ldr	r0, [r7, #12]
 802bf6e:	4798      	blx	r3

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 802bf70:	223c      	movs	r2, #60	@ 0x3c
 802bf72:	68b9      	ldr	r1, [r7, #8]
 802bf74:	68f8      	ldr	r0, [r7, #12]
 802bf76:	f7ff fdf5 	bl	802bb64 <alloc_small>
 802bf7a:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 802bf7c:	693b      	ldr	r3, [r7, #16]
 802bf7e:	2200      	movs	r2, #0
 802bf80:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 802bf82:	693b      	ldr	r3, [r7, #16]
 802bf84:	6a3a      	ldr	r2, [r7, #32]
 802bf86:	605a      	str	r2, [r3, #4]
  result->samplesperrow = samplesperrow;
 802bf88:	693b      	ldr	r3, [r7, #16]
 802bf8a:	683a      	ldr	r2, [r7, #0]
 802bf8c:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 802bf8e:	693b      	ldr	r3, [r7, #16]
 802bf90:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802bf92:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 802bf94:	693b      	ldr	r3, [r7, #16]
 802bf96:	687a      	ldr	r2, [r7, #4]
 802bf98:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 802bf9a:	693b      	ldr	r3, [r7, #16]
 802bf9c:	2200      	movs	r2, #0
 802bf9e:	629a      	str	r2, [r3, #40]	@ 0x28
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
 802bfa0:	697b      	ldr	r3, [r7, #20]
 802bfa2:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 802bfa4:	693b      	ldr	r3, [r7, #16]
 802bfa6:	62da      	str	r2, [r3, #44]	@ 0x2c
  mem->virt_sarray_list = result;
 802bfa8:	697b      	ldr	r3, [r7, #20]
 802bfaa:	693a      	ldr	r2, [r7, #16]
 802bfac:	645a      	str	r2, [r3, #68]	@ 0x44

  return result;
 802bfae:	693b      	ldr	r3, [r7, #16]
}
 802bfb0:	4618      	mov	r0, r3
 802bfb2:	3718      	adds	r7, #24
 802bfb4:	46bd      	mov	sp, r7
 802bfb6:	bd80      	pop	{r7, pc}

0802bfb8 <request_virt_barray>:
METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
 802bfb8:	b580      	push	{r7, lr}
 802bfba:	b086      	sub	sp, #24
 802bfbc:	af00      	add	r7, sp, #0
 802bfbe:	60f8      	str	r0, [r7, #12]
 802bfc0:	60b9      	str	r1, [r7, #8]
 802bfc2:	607a      	str	r2, [r7, #4]
 802bfc4:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802bfc6:	68fb      	ldr	r3, [r7, #12]
 802bfc8:	685b      	ldr	r3, [r3, #4]
 802bfca:	617b      	str	r3, [r7, #20]
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 802bfcc:	68bb      	ldr	r3, [r7, #8]
 802bfce:	2b01      	cmp	r3, #1
 802bfd0:	d00c      	beq.n	802bfec <request_virt_barray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802bfd2:	68fb      	ldr	r3, [r7, #12]
 802bfd4:	681b      	ldr	r3, [r3, #0]
 802bfd6:	220f      	movs	r2, #15
 802bfd8:	615a      	str	r2, [r3, #20]
 802bfda:	68fb      	ldr	r3, [r7, #12]
 802bfdc:	681b      	ldr	r3, [r3, #0]
 802bfde:	68ba      	ldr	r2, [r7, #8]
 802bfe0:	619a      	str	r2, [r3, #24]
 802bfe2:	68fb      	ldr	r3, [r7, #12]
 802bfe4:	681b      	ldr	r3, [r3, #0]
 802bfe6:	681b      	ldr	r3, [r3, #0]
 802bfe8:	68f8      	ldr	r0, [r7, #12]
 802bfea:	4798      	blx	r3

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 802bfec:	223c      	movs	r2, #60	@ 0x3c
 802bfee:	68b9      	ldr	r1, [r7, #8]
 802bff0:	68f8      	ldr	r0, [r7, #12]
 802bff2:	f7ff fdb7 	bl	802bb64 <alloc_small>
 802bff6:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 802bff8:	693b      	ldr	r3, [r7, #16]
 802bffa:	2200      	movs	r2, #0
 802bffc:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 802bffe:	693b      	ldr	r3, [r7, #16]
 802c000:	6a3a      	ldr	r2, [r7, #32]
 802c002:	605a      	str	r2, [r3, #4]
  result->blocksperrow = blocksperrow;
 802c004:	693b      	ldr	r3, [r7, #16]
 802c006:	683a      	ldr	r2, [r7, #0]
 802c008:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 802c00a:	693b      	ldr	r3, [r7, #16]
 802c00c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802c00e:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 802c010:	693b      	ldr	r3, [r7, #16]
 802c012:	687a      	ldr	r2, [r7, #4]
 802c014:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 802c016:	693b      	ldr	r3, [r7, #16]
 802c018:	2200      	movs	r2, #0
 802c01a:	629a      	str	r2, [r3, #40]	@ 0x28
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
 802c01c:	697b      	ldr	r3, [r7, #20]
 802c01e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 802c020:	693b      	ldr	r3, [r7, #16]
 802c022:	62da      	str	r2, [r3, #44]	@ 0x2c
  mem->virt_barray_list = result;
 802c024:	697b      	ldr	r3, [r7, #20]
 802c026:	693a      	ldr	r2, [r7, #16]
 802c028:	649a      	str	r2, [r3, #72]	@ 0x48

  return result;
 802c02a:	693b      	ldr	r3, [r7, #16]
}
 802c02c:	4618      	mov	r0, r3
 802c02e:	3718      	adds	r7, #24
 802c030:	46bd      	mov	sp, r7
 802c032:	bd80      	pop	{r7, pc}

0802c034 <realize_virt_arrays>:


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
 802c034:	b580      	push	{r7, lr}
 802c036:	b08a      	sub	sp, #40	@ 0x28
 802c038:	af00      	add	r7, sp, #0
 802c03a:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802c03c:	687b      	ldr	r3, [r7, #4]
 802c03e:	685b      	ldr	r3, [r3, #4]
 802c040:	613b      	str	r3, [r7, #16]

  /* Compute the minimum space needed (maxaccess rows in each buffer)
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
 802c042:	2300      	movs	r3, #0
 802c044:	627b      	str	r3, [r7, #36]	@ 0x24
  maximum_space = 0;
 802c046:	2300      	movs	r3, #0
 802c048:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c04a:	693b      	ldr	r3, [r7, #16]
 802c04c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802c04e:	61bb      	str	r3, [r7, #24]
 802c050:	e01c      	b.n	802c08c <realize_virt_arrays+0x58>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 802c052:	69bb      	ldr	r3, [r7, #24]
 802c054:	681b      	ldr	r3, [r3, #0]
 802c056:	2b00      	cmp	r3, #0
 802c058:	d115      	bne.n	802c086 <realize_virt_arrays+0x52>
      space_per_minheight += (long) sptr->maxaccess *
 802c05a:	69bb      	ldr	r3, [r7, #24]
 802c05c:	68db      	ldr	r3, [r3, #12]
 802c05e:	461a      	mov	r2, r3
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 802c060:	69bb      	ldr	r3, [r7, #24]
 802c062:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) sptr->maxaccess *
 802c064:	fb02 f303 	mul.w	r3, r2, r3
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 802c068:	461a      	mov	r2, r3
      space_per_minheight += (long) sptr->maxaccess *
 802c06a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c06c:	4413      	add	r3, r2
 802c06e:	627b      	str	r3, [r7, #36]	@ 0x24
      maximum_space += (long) sptr->rows_in_array *
 802c070:	69bb      	ldr	r3, [r7, #24]
 802c072:	685b      	ldr	r3, [r3, #4]
 802c074:	461a      	mov	r2, r3
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 802c076:	69bb      	ldr	r3, [r7, #24]
 802c078:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) sptr->rows_in_array *
 802c07a:	fb02 f303 	mul.w	r3, r2, r3
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 802c07e:	461a      	mov	r2, r3
      maximum_space += (long) sptr->rows_in_array *
 802c080:	6a3b      	ldr	r3, [r7, #32]
 802c082:	4413      	add	r3, r2
 802c084:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c086:	69bb      	ldr	r3, [r7, #24]
 802c088:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c08a:	61bb      	str	r3, [r7, #24]
 802c08c:	69bb      	ldr	r3, [r7, #24]
 802c08e:	2b00      	cmp	r3, #0
 802c090:	d1df      	bne.n	802c052 <realize_virt_arrays+0x1e>
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c092:	693b      	ldr	r3, [r7, #16]
 802c094:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 802c096:	617b      	str	r3, [r7, #20]
 802c098:	e01c      	b.n	802c0d4 <realize_virt_arrays+0xa0>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 802c09a:	697b      	ldr	r3, [r7, #20]
 802c09c:	681b      	ldr	r3, [r3, #0]
 802c09e:	2b00      	cmp	r3, #0
 802c0a0:	d115      	bne.n	802c0ce <realize_virt_arrays+0x9a>
      space_per_minheight += (long) bptr->maxaccess *
 802c0a2:	697b      	ldr	r3, [r7, #20]
 802c0a4:	68db      	ldr	r3, [r3, #12]
 802c0a6:	461a      	mov	r2, r3
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 802c0a8:	697b      	ldr	r3, [r7, #20]
 802c0aa:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) bptr->maxaccess *
 802c0ac:	fb02 f303 	mul.w	r3, r2, r3
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 802c0b0:	01da      	lsls	r2, r3, #7
      space_per_minheight += (long) bptr->maxaccess *
 802c0b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c0b4:	4413      	add	r3, r2
 802c0b6:	627b      	str	r3, [r7, #36]	@ 0x24
      maximum_space += (long) bptr->rows_in_array *
 802c0b8:	697b      	ldr	r3, [r7, #20]
 802c0ba:	685b      	ldr	r3, [r3, #4]
 802c0bc:	461a      	mov	r2, r3
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 802c0be:	697b      	ldr	r3, [r7, #20]
 802c0c0:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) bptr->rows_in_array *
 802c0c2:	fb02 f303 	mul.w	r3, r2, r3
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 802c0c6:	01da      	lsls	r2, r3, #7
      maximum_space += (long) bptr->rows_in_array *
 802c0c8:	6a3b      	ldr	r3, [r7, #32]
 802c0ca:	4413      	add	r3, r2
 802c0cc:	623b      	str	r3, [r7, #32]
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c0ce:	697b      	ldr	r3, [r7, #20]
 802c0d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c0d2:	617b      	str	r3, [r7, #20]
 802c0d4:	697b      	ldr	r3, [r7, #20]
 802c0d6:	2b00      	cmp	r3, #0
 802c0d8:	d1df      	bne.n	802c09a <realize_virt_arrays+0x66>
    }
  }

  if (space_per_minheight <= 0)
 802c0da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c0dc:	2b00      	cmp	r3, #0
 802c0de:	f340 80bd 	ble.w	802c25c <realize_virt_arrays+0x228>
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
 802c0e2:	693b      	ldr	r3, [r7, #16]
 802c0e4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802c0e6:	6a3a      	ldr	r2, [r7, #32]
 802c0e8:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802c0ea:	6878      	ldr	r0, [r7, #4]
 802c0ec:	f000 fcdc 	bl	802caa8 <jpeg_mem_available>
 802c0f0:	60f8      	str	r0, [r7, #12]

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
 802c0f2:	68fa      	ldr	r2, [r7, #12]
 802c0f4:	6a3b      	ldr	r3, [r7, #32]
 802c0f6:	429a      	cmp	r2, r3
 802c0f8:	db02      	blt.n	802c100 <realize_virt_arrays+0xcc>
    max_minheights = 1000000000L;
 802c0fa:	4b5a      	ldr	r3, [pc, #360]	@ (802c264 <realize_virt_arrays+0x230>)
 802c0fc:	61fb      	str	r3, [r7, #28]
 802c0fe:	e009      	b.n	802c114 <realize_virt_arrays+0xe0>
  else {
    max_minheights = avail_mem / space_per_minheight;
 802c100:	68fa      	ldr	r2, [r7, #12]
 802c102:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c104:	fb92 f3f3 	sdiv	r3, r2, r3
 802c108:	61fb      	str	r3, [r7, #28]
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
 802c10a:	69fb      	ldr	r3, [r7, #28]
 802c10c:	2b00      	cmp	r3, #0
 802c10e:	dc01      	bgt.n	802c114 <realize_virt_arrays+0xe0>
      max_minheights = 1;
 802c110:	2301      	movs	r3, #1
 802c112:	61fb      	str	r3, [r7, #28]
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c114:	693b      	ldr	r3, [r7, #16]
 802c116:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802c118:	61bb      	str	r3, [r7, #24]
 802c11a:	e049      	b.n	802c1b0 <realize_virt_arrays+0x17c>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 802c11c:	69bb      	ldr	r3, [r7, #24]
 802c11e:	681b      	ldr	r3, [r3, #0]
 802c120:	2b00      	cmp	r3, #0
 802c122:	d142      	bne.n	802c1aa <realize_virt_arrays+0x176>
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
 802c124:	69bb      	ldr	r3, [r7, #24]
 802c126:	685b      	ldr	r3, [r3, #4]
 802c128:	3b01      	subs	r3, #1
 802c12a:	461a      	mov	r2, r3
 802c12c:	69bb      	ldr	r3, [r7, #24]
 802c12e:	68db      	ldr	r3, [r3, #12]
 802c130:	fbb2 f3f3 	udiv	r3, r2, r3
 802c134:	3301      	adds	r3, #1
 802c136:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 802c138:	68ba      	ldr	r2, [r7, #8]
 802c13a:	69fb      	ldr	r3, [r7, #28]
 802c13c:	429a      	cmp	r2, r3
 802c13e:	dc04      	bgt.n	802c14a <realize_virt_arrays+0x116>
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
 802c140:	69bb      	ldr	r3, [r7, #24]
 802c142:	685a      	ldr	r2, [r3, #4]
 802c144:	69bb      	ldr	r3, [r7, #24]
 802c146:	611a      	str	r2, [r3, #16]
 802c148:	e017      	b.n	802c17a <realize_virt_arrays+0x146>
      } else {
	/* It doesn't fit in memory, create backing store. */
	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
 802c14a:	69bb      	ldr	r3, [r7, #24]
 802c14c:	68db      	ldr	r3, [r3, #12]
 802c14e:	69fa      	ldr	r2, [r7, #28]
 802c150:	fb03 f202 	mul.w	r2, r3, r2
 802c154:	69bb      	ldr	r3, [r7, #24]
 802c156:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 802c158:	69bb      	ldr	r3, [r7, #24]
 802c15a:	f103 0130 	add.w	r1, r3, #48	@ 0x30
				(long) sptr->rows_in_array *
 802c15e:	69bb      	ldr	r3, [r7, #24]
 802c160:	685b      	ldr	r3, [r3, #4]
 802c162:	461a      	mov	r2, r3
				(long) sptr->samplesperrow *
 802c164:	69bb      	ldr	r3, [r7, #24]
 802c166:	689b      	ldr	r3, [r3, #8]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 802c168:	fb02 f303 	mul.w	r3, r2, r3
 802c16c:	461a      	mov	r2, r3
 802c16e:	6878      	ldr	r0, [r7, #4]
 802c170:	f000 fca8 	bl	802cac4 <jpeg_open_backing_store>
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
 802c174:	69bb      	ldr	r3, [r7, #24]
 802c176:	2201      	movs	r2, #1
 802c178:	629a      	str	r2, [r3, #40]	@ 0x28
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 802c17a:	69bb      	ldr	r3, [r7, #24]
 802c17c:	689a      	ldr	r2, [r3, #8]
 802c17e:	69bb      	ldr	r3, [r7, #24]
 802c180:	691b      	ldr	r3, [r3, #16]
 802c182:	2101      	movs	r1, #1
 802c184:	6878      	ldr	r0, [r7, #4]
 802c186:	f7ff fe10 	bl	802bdaa <alloc_sarray>
 802c18a:	4602      	mov	r2, r0
 802c18c:	69bb      	ldr	r3, [r7, #24]
 802c18e:	601a      	str	r2, [r3, #0]
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
 802c190:	693b      	ldr	r3, [r7, #16]
 802c192:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 802c194:	69bb      	ldr	r3, [r7, #24]
 802c196:	615a      	str	r2, [r3, #20]
      sptr->cur_start_row = 0;
 802c198:	69bb      	ldr	r3, [r7, #24]
 802c19a:	2200      	movs	r2, #0
 802c19c:	619a      	str	r2, [r3, #24]
      sptr->first_undef_row = 0;
 802c19e:	69bb      	ldr	r3, [r7, #24]
 802c1a0:	2200      	movs	r2, #0
 802c1a2:	61da      	str	r2, [r3, #28]
      sptr->dirty = FALSE;
 802c1a4:	69bb      	ldr	r3, [r7, #24]
 802c1a6:	2200      	movs	r2, #0
 802c1a8:	625a      	str	r2, [r3, #36]	@ 0x24
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c1aa:	69bb      	ldr	r3, [r7, #24]
 802c1ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c1ae:	61bb      	str	r3, [r7, #24]
 802c1b0:	69bb      	ldr	r3, [r7, #24]
 802c1b2:	2b00      	cmp	r3, #0
 802c1b4:	d1b2      	bne.n	802c11c <realize_virt_arrays+0xe8>
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c1b6:	693b      	ldr	r3, [r7, #16]
 802c1b8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 802c1ba:	617b      	str	r3, [r7, #20]
 802c1bc:	e04a      	b.n	802c254 <realize_virt_arrays+0x220>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 802c1be:	697b      	ldr	r3, [r7, #20]
 802c1c0:	681b      	ldr	r3, [r3, #0]
 802c1c2:	2b00      	cmp	r3, #0
 802c1c4:	d143      	bne.n	802c24e <realize_virt_arrays+0x21a>
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
 802c1c6:	697b      	ldr	r3, [r7, #20]
 802c1c8:	685b      	ldr	r3, [r3, #4]
 802c1ca:	3b01      	subs	r3, #1
 802c1cc:	461a      	mov	r2, r3
 802c1ce:	697b      	ldr	r3, [r7, #20]
 802c1d0:	68db      	ldr	r3, [r3, #12]
 802c1d2:	fbb2 f3f3 	udiv	r3, r2, r3
 802c1d6:	3301      	adds	r3, #1
 802c1d8:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 802c1da:	68ba      	ldr	r2, [r7, #8]
 802c1dc:	69fb      	ldr	r3, [r7, #28]
 802c1de:	429a      	cmp	r2, r3
 802c1e0:	dc04      	bgt.n	802c1ec <realize_virt_arrays+0x1b8>
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
 802c1e2:	697b      	ldr	r3, [r7, #20]
 802c1e4:	685a      	ldr	r2, [r3, #4]
 802c1e6:	697b      	ldr	r3, [r7, #20]
 802c1e8:	611a      	str	r2, [r3, #16]
 802c1ea:	e018      	b.n	802c21e <realize_virt_arrays+0x1ea>
      } else {
	/* It doesn't fit in memory, create backing store. */
	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
 802c1ec:	697b      	ldr	r3, [r7, #20]
 802c1ee:	68db      	ldr	r3, [r3, #12]
 802c1f0:	69fa      	ldr	r2, [r7, #28]
 802c1f2:	fb03 f202 	mul.w	r2, r3, r2
 802c1f6:	697b      	ldr	r3, [r7, #20]
 802c1f8:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 802c1fa:	697b      	ldr	r3, [r7, #20]
 802c1fc:	f103 0130 	add.w	r1, r3, #48	@ 0x30
				(long) bptr->rows_in_array *
 802c200:	697b      	ldr	r3, [r7, #20]
 802c202:	685b      	ldr	r3, [r3, #4]
 802c204:	461a      	mov	r2, r3
				(long) bptr->blocksperrow *
 802c206:	697b      	ldr	r3, [r7, #20]
 802c208:	689b      	ldr	r3, [r3, #8]
				(long) bptr->rows_in_array *
 802c20a:	fb02 f303 	mul.w	r3, r2, r3
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 802c20e:	01db      	lsls	r3, r3, #7
 802c210:	461a      	mov	r2, r3
 802c212:	6878      	ldr	r0, [r7, #4]
 802c214:	f000 fc56 	bl	802cac4 <jpeg_open_backing_store>
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
 802c218:	697b      	ldr	r3, [r7, #20]
 802c21a:	2201      	movs	r2, #1
 802c21c:	629a      	str	r2, [r3, #40]	@ 0x28
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 802c21e:	697b      	ldr	r3, [r7, #20]
 802c220:	689a      	ldr	r2, [r3, #8]
 802c222:	697b      	ldr	r3, [r7, #20]
 802c224:	691b      	ldr	r3, [r3, #16]
 802c226:	2101      	movs	r1, #1
 802c228:	6878      	ldr	r0, [r7, #4]
 802c22a:	f7ff fe21 	bl	802be70 <alloc_barray>
 802c22e:	4602      	mov	r2, r0
 802c230:	697b      	ldr	r3, [r7, #20]
 802c232:	601a      	str	r2, [r3, #0]
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
 802c234:	693b      	ldr	r3, [r7, #16]
 802c236:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 802c238:	697b      	ldr	r3, [r7, #20]
 802c23a:	615a      	str	r2, [r3, #20]
      bptr->cur_start_row = 0;
 802c23c:	697b      	ldr	r3, [r7, #20]
 802c23e:	2200      	movs	r2, #0
 802c240:	619a      	str	r2, [r3, #24]
      bptr->first_undef_row = 0;
 802c242:	697b      	ldr	r3, [r7, #20]
 802c244:	2200      	movs	r2, #0
 802c246:	61da      	str	r2, [r3, #28]
      bptr->dirty = FALSE;
 802c248:	697b      	ldr	r3, [r7, #20]
 802c24a:	2200      	movs	r2, #0
 802c24c:	625a      	str	r2, [r3, #36]	@ 0x24
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c24e:	697b      	ldr	r3, [r7, #20]
 802c250:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c252:	617b      	str	r3, [r7, #20]
 802c254:	697b      	ldr	r3, [r7, #20]
 802c256:	2b00      	cmp	r3, #0
 802c258:	d1b1      	bne.n	802c1be <realize_virt_arrays+0x18a>
 802c25a:	e000      	b.n	802c25e <realize_virt_arrays+0x22a>
    return;			/* no unrealized arrays, no work */
 802c25c:	bf00      	nop
    }
  }
}
 802c25e:	3728      	adds	r7, #40	@ 0x28
 802c260:	46bd      	mov	sp, r7
 802c262:	bd80      	pop	{r7, pc}
 802c264:	3b9aca00 	.word	0x3b9aca00

0802c268 <do_sarray_io>:


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
 802c268:	b590      	push	{r4, r7, lr}
 802c26a:	b08d      	sub	sp, #52	@ 0x34
 802c26c:	af02      	add	r7, sp, #8
 802c26e:	60f8      	str	r0, [r7, #12]
 802c270:	60b9      	str	r1, [r7, #8]
 802c272:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
 802c274:	68bb      	ldr	r3, [r7, #8]
 802c276:	689b      	ldr	r3, [r3, #8]
 802c278:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 802c27a:	68bb      	ldr	r3, [r7, #8]
 802c27c:	699b      	ldr	r3, [r3, #24]
 802c27e:	69fa      	ldr	r2, [r7, #28]
 802c280:	fb02 f303 	mul.w	r3, r2, r3
 802c284:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 802c286:	2300      	movs	r3, #0
 802c288:	623b      	str	r3, [r7, #32]
 802c28a:	e059      	b.n	802c340 <do_sarray_io+0xd8>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 802c28c:	68bb      	ldr	r3, [r7, #8]
 802c28e:	691b      	ldr	r3, [r3, #16]
 802c290:	461a      	mov	r2, r3
 802c292:	6a3b      	ldr	r3, [r7, #32]
 802c294:	1ad3      	subs	r3, r2, r3
 802c296:	68ba      	ldr	r2, [r7, #8]
 802c298:	6952      	ldr	r2, [r2, #20]
 802c29a:	4293      	cmp	r3, r2
 802c29c:	bfa8      	it	ge
 802c29e:	4613      	movge	r3, r2
 802c2a0:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 802c2a2:	68bb      	ldr	r3, [r7, #8]
 802c2a4:	699b      	ldr	r3, [r3, #24]
 802c2a6:	461a      	mov	r2, r3
 802c2a8:	6a3b      	ldr	r3, [r7, #32]
 802c2aa:	4413      	add	r3, r2
 802c2ac:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 802c2ae:	68bb      	ldr	r3, [r7, #8]
 802c2b0:	69db      	ldr	r3, [r3, #28]
 802c2b2:	461a      	mov	r2, r3
 802c2b4:	697b      	ldr	r3, [r7, #20]
 802c2b6:	1ad3      	subs	r3, r2, r3
 802c2b8:	69ba      	ldr	r2, [r7, #24]
 802c2ba:	4293      	cmp	r3, r2
 802c2bc:	bfa8      	it	ge
 802c2be:	4613      	movge	r3, r2
 802c2c0:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 802c2c2:	68bb      	ldr	r3, [r7, #8]
 802c2c4:	685b      	ldr	r3, [r3, #4]
 802c2c6:	461a      	mov	r2, r3
 802c2c8:	697b      	ldr	r3, [r7, #20]
 802c2ca:	1ad3      	subs	r3, r2, r3
 802c2cc:	69ba      	ldr	r2, [r7, #24]
 802c2ce:	4293      	cmp	r3, r2
 802c2d0:	bfa8      	it	ge
 802c2d2:	4613      	movge	r3, r2
 802c2d4:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 802c2d6:	69bb      	ldr	r3, [r7, #24]
 802c2d8:	2b00      	cmp	r3, #0
 802c2da:	dd38      	ble.n	802c34e <do_sarray_io+0xe6>
      break;
    byte_count = rows * bytesperrow;
 802c2dc:	69bb      	ldr	r3, [r7, #24]
 802c2de:	69fa      	ldr	r2, [r7, #28]
 802c2e0:	fb02 f303 	mul.w	r3, r2, r3
 802c2e4:	613b      	str	r3, [r7, #16]
    if (writing)
 802c2e6:	687b      	ldr	r3, [r7, #4]
 802c2e8:	2b00      	cmp	r3, #0
 802c2ea:	d010      	beq.n	802c30e <do_sarray_io+0xa6>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802c2ec:	68bb      	ldr	r3, [r7, #8]
 802c2ee:	6b5c      	ldr	r4, [r3, #52]	@ 0x34
 802c2f0:	68bb      	ldr	r3, [r7, #8]
 802c2f2:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					    (void FAR *) ptr->mem_buffer[i],
 802c2f6:	68bb      	ldr	r3, [r7, #8]
 802c2f8:	681a      	ldr	r2, [r3, #0]
 802c2fa:	6a3b      	ldr	r3, [r7, #32]
 802c2fc:	009b      	lsls	r3, r3, #2
 802c2fe:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802c300:	681a      	ldr	r2, [r3, #0]
 802c302:	693b      	ldr	r3, [r7, #16]
 802c304:	9300      	str	r3, [sp, #0]
 802c306:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c308:	68f8      	ldr	r0, [r7, #12]
 802c30a:	47a0      	blx	r4
 802c30c:	e00f      	b.n	802c32e <do_sarray_io+0xc6>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802c30e:	68bb      	ldr	r3, [r7, #8]
 802c310:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 802c312:	68bb      	ldr	r3, [r7, #8]
 802c314:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					   (void FAR *) ptr->mem_buffer[i],
 802c318:	68bb      	ldr	r3, [r7, #8]
 802c31a:	681a      	ldr	r2, [r3, #0]
 802c31c:	6a3b      	ldr	r3, [r7, #32]
 802c31e:	009b      	lsls	r3, r3, #2
 802c320:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802c322:	681a      	ldr	r2, [r3, #0]
 802c324:	693b      	ldr	r3, [r7, #16]
 802c326:	9300      	str	r3, [sp, #0]
 802c328:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c32a:	68f8      	ldr	r0, [r7, #12]
 802c32c:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 802c32e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802c330:	693b      	ldr	r3, [r7, #16]
 802c332:	4413      	add	r3, r2
 802c334:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 802c336:	68bb      	ldr	r3, [r7, #8]
 802c338:	695a      	ldr	r2, [r3, #20]
 802c33a:	6a3b      	ldr	r3, [r7, #32]
 802c33c:	4413      	add	r3, r2
 802c33e:	623b      	str	r3, [r7, #32]
 802c340:	68bb      	ldr	r3, [r7, #8]
 802c342:	691b      	ldr	r3, [r3, #16]
 802c344:	461a      	mov	r2, r3
 802c346:	6a3b      	ldr	r3, [r7, #32]
 802c348:	4293      	cmp	r3, r2
 802c34a:	db9f      	blt.n	802c28c <do_sarray_io+0x24>
  }
}
 802c34c:	e000      	b.n	802c350 <do_sarray_io+0xe8>
      break;
 802c34e:	bf00      	nop
}
 802c350:	bf00      	nop
 802c352:	372c      	adds	r7, #44	@ 0x2c
 802c354:	46bd      	mov	sp, r7
 802c356:	bd90      	pop	{r4, r7, pc}

0802c358 <do_barray_io>:


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
 802c358:	b590      	push	{r4, r7, lr}
 802c35a:	b08d      	sub	sp, #52	@ 0x34
 802c35c:	af02      	add	r7, sp, #8
 802c35e:	60f8      	str	r0, [r7, #12]
 802c360:	60b9      	str	r1, [r7, #8]
 802c362:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
 802c364:	68bb      	ldr	r3, [r7, #8]
 802c366:	689b      	ldr	r3, [r3, #8]
 802c368:	01db      	lsls	r3, r3, #7
 802c36a:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 802c36c:	68bb      	ldr	r3, [r7, #8]
 802c36e:	699b      	ldr	r3, [r3, #24]
 802c370:	69fa      	ldr	r2, [r7, #28]
 802c372:	fb02 f303 	mul.w	r3, r2, r3
 802c376:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 802c378:	2300      	movs	r3, #0
 802c37a:	623b      	str	r3, [r7, #32]
 802c37c:	e059      	b.n	802c432 <do_barray_io+0xda>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 802c37e:	68bb      	ldr	r3, [r7, #8]
 802c380:	691b      	ldr	r3, [r3, #16]
 802c382:	461a      	mov	r2, r3
 802c384:	6a3b      	ldr	r3, [r7, #32]
 802c386:	1ad3      	subs	r3, r2, r3
 802c388:	68ba      	ldr	r2, [r7, #8]
 802c38a:	6952      	ldr	r2, [r2, #20]
 802c38c:	4293      	cmp	r3, r2
 802c38e:	bfa8      	it	ge
 802c390:	4613      	movge	r3, r2
 802c392:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 802c394:	68bb      	ldr	r3, [r7, #8]
 802c396:	699b      	ldr	r3, [r3, #24]
 802c398:	461a      	mov	r2, r3
 802c39a:	6a3b      	ldr	r3, [r7, #32]
 802c39c:	4413      	add	r3, r2
 802c39e:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 802c3a0:	68bb      	ldr	r3, [r7, #8]
 802c3a2:	69db      	ldr	r3, [r3, #28]
 802c3a4:	461a      	mov	r2, r3
 802c3a6:	697b      	ldr	r3, [r7, #20]
 802c3a8:	1ad3      	subs	r3, r2, r3
 802c3aa:	69ba      	ldr	r2, [r7, #24]
 802c3ac:	4293      	cmp	r3, r2
 802c3ae:	bfa8      	it	ge
 802c3b0:	4613      	movge	r3, r2
 802c3b2:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 802c3b4:	68bb      	ldr	r3, [r7, #8]
 802c3b6:	685b      	ldr	r3, [r3, #4]
 802c3b8:	461a      	mov	r2, r3
 802c3ba:	697b      	ldr	r3, [r7, #20]
 802c3bc:	1ad3      	subs	r3, r2, r3
 802c3be:	69ba      	ldr	r2, [r7, #24]
 802c3c0:	4293      	cmp	r3, r2
 802c3c2:	bfa8      	it	ge
 802c3c4:	4613      	movge	r3, r2
 802c3c6:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 802c3c8:	69bb      	ldr	r3, [r7, #24]
 802c3ca:	2b00      	cmp	r3, #0
 802c3cc:	dd38      	ble.n	802c440 <do_barray_io+0xe8>
      break;
    byte_count = rows * bytesperrow;
 802c3ce:	69bb      	ldr	r3, [r7, #24]
 802c3d0:	69fa      	ldr	r2, [r7, #28]
 802c3d2:	fb02 f303 	mul.w	r3, r2, r3
 802c3d6:	613b      	str	r3, [r7, #16]
    if (writing)
 802c3d8:	687b      	ldr	r3, [r7, #4]
 802c3da:	2b00      	cmp	r3, #0
 802c3dc:	d010      	beq.n	802c400 <do_barray_io+0xa8>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802c3de:	68bb      	ldr	r3, [r7, #8]
 802c3e0:	6b5c      	ldr	r4, [r3, #52]	@ 0x34
 802c3e2:	68bb      	ldr	r3, [r7, #8]
 802c3e4:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					    (void FAR *) ptr->mem_buffer[i],
 802c3e8:	68bb      	ldr	r3, [r7, #8]
 802c3ea:	681a      	ldr	r2, [r3, #0]
 802c3ec:	6a3b      	ldr	r3, [r7, #32]
 802c3ee:	009b      	lsls	r3, r3, #2
 802c3f0:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 802c3f2:	681a      	ldr	r2, [r3, #0]
 802c3f4:	693b      	ldr	r3, [r7, #16]
 802c3f6:	9300      	str	r3, [sp, #0]
 802c3f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c3fa:	68f8      	ldr	r0, [r7, #12]
 802c3fc:	47a0      	blx	r4
 802c3fe:	e00f      	b.n	802c420 <do_barray_io+0xc8>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802c400:	68bb      	ldr	r3, [r7, #8]
 802c402:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 802c404:	68bb      	ldr	r3, [r7, #8]
 802c406:	f103 0130 	add.w	r1, r3, #48	@ 0x30
					   (void FAR *) ptr->mem_buffer[i],
 802c40a:	68bb      	ldr	r3, [r7, #8]
 802c40c:	681a      	ldr	r2, [r3, #0]
 802c40e:	6a3b      	ldr	r3, [r7, #32]
 802c410:	009b      	lsls	r3, r3, #2
 802c412:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 802c414:	681a      	ldr	r2, [r3, #0]
 802c416:	693b      	ldr	r3, [r7, #16]
 802c418:	9300      	str	r3, [sp, #0]
 802c41a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c41c:	68f8      	ldr	r0, [r7, #12]
 802c41e:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 802c420:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802c422:	693b      	ldr	r3, [r7, #16]
 802c424:	4413      	add	r3, r2
 802c426:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 802c428:	68bb      	ldr	r3, [r7, #8]
 802c42a:	695a      	ldr	r2, [r3, #20]
 802c42c:	6a3b      	ldr	r3, [r7, #32]
 802c42e:	4413      	add	r3, r2
 802c430:	623b      	str	r3, [r7, #32]
 802c432:	68bb      	ldr	r3, [r7, #8]
 802c434:	691b      	ldr	r3, [r3, #16]
 802c436:	461a      	mov	r2, r3
 802c438:	6a3b      	ldr	r3, [r7, #32]
 802c43a:	4293      	cmp	r3, r2
 802c43c:	db9f      	blt.n	802c37e <do_barray_io+0x26>
  }
}
 802c43e:	e000      	b.n	802c442 <do_barray_io+0xea>
      break;
 802c440:	bf00      	nop
}
 802c442:	bf00      	nop
 802c444:	372c      	adds	r7, #44	@ 0x2c
 802c446:	46bd      	mov	sp, r7
 802c448:	bd90      	pop	{r4, r7, pc}

0802c44a <access_virt_sarray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802c44a:	b580      	push	{r7, lr}
 802c44c:	b088      	sub	sp, #32
 802c44e:	af00      	add	r7, sp, #0
 802c450:	60f8      	str	r0, [r7, #12]
 802c452:	60b9      	str	r1, [r7, #8]
 802c454:	607a      	str	r2, [r7, #4]
 802c456:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 802c458:	687a      	ldr	r2, [r7, #4]
 802c45a:	683b      	ldr	r3, [r7, #0]
 802c45c:	4413      	add	r3, r2
 802c45e:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802c460:	68bb      	ldr	r3, [r7, #8]
 802c462:	685b      	ldr	r3, [r3, #4]
 802c464:	697a      	ldr	r2, [r7, #20]
 802c466:	429a      	cmp	r2, r3
 802c468:	d808      	bhi.n	802c47c <access_virt_sarray+0x32>
 802c46a:	68bb      	ldr	r3, [r7, #8]
 802c46c:	68db      	ldr	r3, [r3, #12]
 802c46e:	683a      	ldr	r2, [r7, #0]
 802c470:	429a      	cmp	r2, r3
 802c472:	d803      	bhi.n	802c47c <access_virt_sarray+0x32>
      ptr->mem_buffer == NULL)
 802c474:	68bb      	ldr	r3, [r7, #8]
 802c476:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802c478:	2b00      	cmp	r3, #0
 802c47a:	d108      	bne.n	802c48e <access_virt_sarray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c47c:	68fb      	ldr	r3, [r7, #12]
 802c47e:	681b      	ldr	r3, [r3, #0]
 802c480:	2217      	movs	r2, #23
 802c482:	615a      	str	r2, [r3, #20]
 802c484:	68fb      	ldr	r3, [r7, #12]
 802c486:	681b      	ldr	r3, [r3, #0]
 802c488:	681b      	ldr	r3, [r3, #0]
 802c48a:	68f8      	ldr	r0, [r7, #12]
 802c48c:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 802c48e:	68bb      	ldr	r3, [r7, #8]
 802c490:	699b      	ldr	r3, [r3, #24]
 802c492:	687a      	ldr	r2, [r7, #4]
 802c494:	429a      	cmp	r2, r3
 802c496:	d307      	bcc.n	802c4a8 <access_virt_sarray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 802c498:	68bb      	ldr	r3, [r7, #8]
 802c49a:	699a      	ldr	r2, [r3, #24]
 802c49c:	68bb      	ldr	r3, [r7, #8]
 802c49e:	691b      	ldr	r3, [r3, #16]
 802c4a0:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 802c4a2:	697a      	ldr	r2, [r7, #20]
 802c4a4:	429a      	cmp	r2, r3
 802c4a6:	d933      	bls.n	802c510 <access_virt_sarray+0xc6>
    if (! ptr->b_s_open)
 802c4a8:	68bb      	ldr	r3, [r7, #8]
 802c4aa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802c4ac:	2b00      	cmp	r3, #0
 802c4ae:	d108      	bne.n	802c4c2 <access_virt_sarray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 802c4b0:	68fb      	ldr	r3, [r7, #12]
 802c4b2:	681b      	ldr	r3, [r3, #0]
 802c4b4:	2247      	movs	r2, #71	@ 0x47
 802c4b6:	615a      	str	r2, [r3, #20]
 802c4b8:	68fb      	ldr	r3, [r7, #12]
 802c4ba:	681b      	ldr	r3, [r3, #0]
 802c4bc:	681b      	ldr	r3, [r3, #0]
 802c4be:	68f8      	ldr	r0, [r7, #12]
 802c4c0:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 802c4c2:	68bb      	ldr	r3, [r7, #8]
 802c4c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802c4c6:	2b00      	cmp	r3, #0
 802c4c8:	d007      	beq.n	802c4da <access_virt_sarray+0x90>
      do_sarray_io(cinfo, ptr, TRUE);
 802c4ca:	2201      	movs	r2, #1
 802c4cc:	68b9      	ldr	r1, [r7, #8]
 802c4ce:	68f8      	ldr	r0, [r7, #12]
 802c4d0:	f7ff feca 	bl	802c268 <do_sarray_io>
      ptr->dirty = FALSE;
 802c4d4:	68bb      	ldr	r3, [r7, #8]
 802c4d6:	2200      	movs	r2, #0
 802c4d8:	625a      	str	r2, [r3, #36]	@ 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802c4da:	68bb      	ldr	r3, [r7, #8]
 802c4dc:	699b      	ldr	r3, [r3, #24]
 802c4de:	687a      	ldr	r2, [r7, #4]
 802c4e0:	429a      	cmp	r2, r3
 802c4e2:	d903      	bls.n	802c4ec <access_virt_sarray+0xa2>
      ptr->cur_start_row = start_row;
 802c4e4:	68bb      	ldr	r3, [r7, #8]
 802c4e6:	687a      	ldr	r2, [r7, #4]
 802c4e8:	619a      	str	r2, [r3, #24]
 802c4ea:	e00c      	b.n	802c506 <access_virt_sarray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 802c4ec:	697b      	ldr	r3, [r7, #20]
 802c4ee:	68ba      	ldr	r2, [r7, #8]
 802c4f0:	6912      	ldr	r2, [r2, #16]
 802c4f2:	1a9b      	subs	r3, r3, r2
 802c4f4:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 802c4f6:	69bb      	ldr	r3, [r7, #24]
 802c4f8:	2b00      	cmp	r3, #0
 802c4fa:	da01      	bge.n	802c500 <access_virt_sarray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 802c4fc:	2300      	movs	r3, #0
 802c4fe:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 802c500:	69ba      	ldr	r2, [r7, #24]
 802c502:	68bb      	ldr	r3, [r7, #8]
 802c504:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_sarray_io(cinfo, ptr, FALSE);
 802c506:	2200      	movs	r2, #0
 802c508:	68b9      	ldr	r1, [r7, #8]
 802c50a:	68f8      	ldr	r0, [r7, #12]
 802c50c:	f7ff feac 	bl	802c268 <do_sarray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 802c510:	68bb      	ldr	r3, [r7, #8]
 802c512:	69db      	ldr	r3, [r3, #28]
 802c514:	697a      	ldr	r2, [r7, #20]
 802c516:	429a      	cmp	r2, r3
 802c518:	d94d      	bls.n	802c5b6 <access_virt_sarray+0x16c>
    if (ptr->first_undef_row < start_row) {
 802c51a:	68bb      	ldr	r3, [r7, #8]
 802c51c:	69db      	ldr	r3, [r3, #28]
 802c51e:	687a      	ldr	r2, [r7, #4]
 802c520:	429a      	cmp	r2, r3
 802c522:	d90e      	bls.n	802c542 <access_virt_sarray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 802c524:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c526:	2b00      	cmp	r3, #0
 802c528:	d008      	beq.n	802c53c <access_virt_sarray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c52a:	68fb      	ldr	r3, [r7, #12]
 802c52c:	681b      	ldr	r3, [r3, #0]
 802c52e:	2217      	movs	r2, #23
 802c530:	615a      	str	r2, [r3, #20]
 802c532:	68fb      	ldr	r3, [r7, #12]
 802c534:	681b      	ldr	r3, [r3, #0]
 802c536:	681b      	ldr	r3, [r3, #0]
 802c538:	68f8      	ldr	r0, [r7, #12]
 802c53a:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 802c53c:	687b      	ldr	r3, [r7, #4]
 802c53e:	61fb      	str	r3, [r7, #28]
 802c540:	e002      	b.n	802c548 <access_virt_sarray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 802c542:	68bb      	ldr	r3, [r7, #8]
 802c544:	69db      	ldr	r3, [r3, #28]
 802c546:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802c548:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c54a:	2b00      	cmp	r3, #0
 802c54c:	d002      	beq.n	802c554 <access_virt_sarray+0x10a>
      ptr->first_undef_row = end_row;
 802c54e:	68bb      	ldr	r3, [r7, #8]
 802c550:	697a      	ldr	r2, [r7, #20]
 802c552:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 802c554:	68bb      	ldr	r3, [r7, #8]
 802c556:	6a1b      	ldr	r3, [r3, #32]
 802c558:	2b00      	cmp	r3, #0
 802c55a:	d020      	beq.n	802c59e <access_virt_sarray+0x154>
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 802c55c:	68bb      	ldr	r3, [r7, #8]
 802c55e:	689b      	ldr	r3, [r3, #8]
 802c560:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 802c562:	68bb      	ldr	r3, [r7, #8]
 802c564:	699b      	ldr	r3, [r3, #24]
 802c566:	69fa      	ldr	r2, [r7, #28]
 802c568:	1ad3      	subs	r3, r2, r3
 802c56a:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 802c56c:	68bb      	ldr	r3, [r7, #8]
 802c56e:	699b      	ldr	r3, [r3, #24]
 802c570:	697a      	ldr	r2, [r7, #20]
 802c572:	1ad3      	subs	r3, r2, r3
 802c574:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 802c576:	e00d      	b.n	802c594 <access_virt_sarray+0x14a>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 802c578:	68bb      	ldr	r3, [r7, #8]
 802c57a:	681a      	ldr	r2, [r3, #0]
 802c57c:	69fb      	ldr	r3, [r7, #28]
 802c57e:	009b      	lsls	r3, r3, #2
 802c580:	4413      	add	r3, r2
 802c582:	681b      	ldr	r3, [r3, #0]
 802c584:	693a      	ldr	r2, [r7, #16]
 802c586:	2100      	movs	r1, #0
 802c588:	4618      	mov	r0, r3
 802c58a:	f003 fa09 	bl	802f9a0 <memset>
	undef_row++;
 802c58e:	69fb      	ldr	r3, [r7, #28]
 802c590:	3301      	adds	r3, #1
 802c592:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 802c594:	69fa      	ldr	r2, [r7, #28]
 802c596:	697b      	ldr	r3, [r7, #20]
 802c598:	429a      	cmp	r2, r3
 802c59a:	d3ed      	bcc.n	802c578 <access_virt_sarray+0x12e>
 802c59c:	e00b      	b.n	802c5b6 <access_virt_sarray+0x16c>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 802c59e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c5a0:	2b00      	cmp	r3, #0
 802c5a2:	d108      	bne.n	802c5b6 <access_virt_sarray+0x16c>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c5a4:	68fb      	ldr	r3, [r7, #12]
 802c5a6:	681b      	ldr	r3, [r3, #0]
 802c5a8:	2217      	movs	r2, #23
 802c5aa:	615a      	str	r2, [r3, #20]
 802c5ac:	68fb      	ldr	r3, [r7, #12]
 802c5ae:	681b      	ldr	r3, [r3, #0]
 802c5b0:	681b      	ldr	r3, [r3, #0]
 802c5b2:	68f8      	ldr	r0, [r7, #12]
 802c5b4:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802c5b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c5b8:	2b00      	cmp	r3, #0
 802c5ba:	d002      	beq.n	802c5c2 <access_virt_sarray+0x178>
    ptr->dirty = TRUE;
 802c5bc:	68bb      	ldr	r3, [r7, #8]
 802c5be:	2201      	movs	r2, #1
 802c5c0:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 802c5c2:	68bb      	ldr	r3, [r7, #8]
 802c5c4:	681a      	ldr	r2, [r3, #0]
 802c5c6:	68bb      	ldr	r3, [r7, #8]
 802c5c8:	699b      	ldr	r3, [r3, #24]
 802c5ca:	6879      	ldr	r1, [r7, #4]
 802c5cc:	1acb      	subs	r3, r1, r3
 802c5ce:	009b      	lsls	r3, r3, #2
 802c5d0:	4413      	add	r3, r2
}
 802c5d2:	4618      	mov	r0, r3
 802c5d4:	3720      	adds	r7, #32
 802c5d6:	46bd      	mov	sp, r7
 802c5d8:	bd80      	pop	{r7, pc}

0802c5da <access_virt_barray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802c5da:	b580      	push	{r7, lr}
 802c5dc:	b088      	sub	sp, #32
 802c5de:	af00      	add	r7, sp, #0
 802c5e0:	60f8      	str	r0, [r7, #12]
 802c5e2:	60b9      	str	r1, [r7, #8]
 802c5e4:	607a      	str	r2, [r7, #4]
 802c5e6:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 802c5e8:	687a      	ldr	r2, [r7, #4]
 802c5ea:	683b      	ldr	r3, [r7, #0]
 802c5ec:	4413      	add	r3, r2
 802c5ee:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802c5f0:	68bb      	ldr	r3, [r7, #8]
 802c5f2:	685b      	ldr	r3, [r3, #4]
 802c5f4:	697a      	ldr	r2, [r7, #20]
 802c5f6:	429a      	cmp	r2, r3
 802c5f8:	d808      	bhi.n	802c60c <access_virt_barray+0x32>
 802c5fa:	68bb      	ldr	r3, [r7, #8]
 802c5fc:	68db      	ldr	r3, [r3, #12]
 802c5fe:	683a      	ldr	r2, [r7, #0]
 802c600:	429a      	cmp	r2, r3
 802c602:	d803      	bhi.n	802c60c <access_virt_barray+0x32>
      ptr->mem_buffer == NULL)
 802c604:	68bb      	ldr	r3, [r7, #8]
 802c606:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802c608:	2b00      	cmp	r3, #0
 802c60a:	d108      	bne.n	802c61e <access_virt_barray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c60c:	68fb      	ldr	r3, [r7, #12]
 802c60e:	681b      	ldr	r3, [r3, #0]
 802c610:	2217      	movs	r2, #23
 802c612:	615a      	str	r2, [r3, #20]
 802c614:	68fb      	ldr	r3, [r7, #12]
 802c616:	681b      	ldr	r3, [r3, #0]
 802c618:	681b      	ldr	r3, [r3, #0]
 802c61a:	68f8      	ldr	r0, [r7, #12]
 802c61c:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 802c61e:	68bb      	ldr	r3, [r7, #8]
 802c620:	699b      	ldr	r3, [r3, #24]
 802c622:	687a      	ldr	r2, [r7, #4]
 802c624:	429a      	cmp	r2, r3
 802c626:	d307      	bcc.n	802c638 <access_virt_barray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 802c628:	68bb      	ldr	r3, [r7, #8]
 802c62a:	699a      	ldr	r2, [r3, #24]
 802c62c:	68bb      	ldr	r3, [r7, #8]
 802c62e:	691b      	ldr	r3, [r3, #16]
 802c630:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 802c632:	697a      	ldr	r2, [r7, #20]
 802c634:	429a      	cmp	r2, r3
 802c636:	d933      	bls.n	802c6a0 <access_virt_barray+0xc6>
    if (! ptr->b_s_open)
 802c638:	68bb      	ldr	r3, [r7, #8]
 802c63a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802c63c:	2b00      	cmp	r3, #0
 802c63e:	d108      	bne.n	802c652 <access_virt_barray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 802c640:	68fb      	ldr	r3, [r7, #12]
 802c642:	681b      	ldr	r3, [r3, #0]
 802c644:	2247      	movs	r2, #71	@ 0x47
 802c646:	615a      	str	r2, [r3, #20]
 802c648:	68fb      	ldr	r3, [r7, #12]
 802c64a:	681b      	ldr	r3, [r3, #0]
 802c64c:	681b      	ldr	r3, [r3, #0]
 802c64e:	68f8      	ldr	r0, [r7, #12]
 802c650:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 802c652:	68bb      	ldr	r3, [r7, #8]
 802c654:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802c656:	2b00      	cmp	r3, #0
 802c658:	d007      	beq.n	802c66a <access_virt_barray+0x90>
      do_barray_io(cinfo, ptr, TRUE);
 802c65a:	2201      	movs	r2, #1
 802c65c:	68b9      	ldr	r1, [r7, #8]
 802c65e:	68f8      	ldr	r0, [r7, #12]
 802c660:	f7ff fe7a 	bl	802c358 <do_barray_io>
      ptr->dirty = FALSE;
 802c664:	68bb      	ldr	r3, [r7, #8]
 802c666:	2200      	movs	r2, #0
 802c668:	625a      	str	r2, [r3, #36]	@ 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802c66a:	68bb      	ldr	r3, [r7, #8]
 802c66c:	699b      	ldr	r3, [r3, #24]
 802c66e:	687a      	ldr	r2, [r7, #4]
 802c670:	429a      	cmp	r2, r3
 802c672:	d903      	bls.n	802c67c <access_virt_barray+0xa2>
      ptr->cur_start_row = start_row;
 802c674:	68bb      	ldr	r3, [r7, #8]
 802c676:	687a      	ldr	r2, [r7, #4]
 802c678:	619a      	str	r2, [r3, #24]
 802c67a:	e00c      	b.n	802c696 <access_virt_barray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 802c67c:	697b      	ldr	r3, [r7, #20]
 802c67e:	68ba      	ldr	r2, [r7, #8]
 802c680:	6912      	ldr	r2, [r2, #16]
 802c682:	1a9b      	subs	r3, r3, r2
 802c684:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 802c686:	69bb      	ldr	r3, [r7, #24]
 802c688:	2b00      	cmp	r3, #0
 802c68a:	da01      	bge.n	802c690 <access_virt_barray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 802c68c:	2300      	movs	r3, #0
 802c68e:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 802c690:	69ba      	ldr	r2, [r7, #24]
 802c692:	68bb      	ldr	r3, [r7, #8]
 802c694:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_barray_io(cinfo, ptr, FALSE);
 802c696:	2200      	movs	r2, #0
 802c698:	68b9      	ldr	r1, [r7, #8]
 802c69a:	68f8      	ldr	r0, [r7, #12]
 802c69c:	f7ff fe5c 	bl	802c358 <do_barray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 802c6a0:	68bb      	ldr	r3, [r7, #8]
 802c6a2:	69db      	ldr	r3, [r3, #28]
 802c6a4:	697a      	ldr	r2, [r7, #20]
 802c6a6:	429a      	cmp	r2, r3
 802c6a8:	d94e      	bls.n	802c748 <access_virt_barray+0x16e>
    if (ptr->first_undef_row < start_row) {
 802c6aa:	68bb      	ldr	r3, [r7, #8]
 802c6ac:	69db      	ldr	r3, [r3, #28]
 802c6ae:	687a      	ldr	r2, [r7, #4]
 802c6b0:	429a      	cmp	r2, r3
 802c6b2:	d90e      	bls.n	802c6d2 <access_virt_barray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 802c6b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c6b6:	2b00      	cmp	r3, #0
 802c6b8:	d008      	beq.n	802c6cc <access_virt_barray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c6ba:	68fb      	ldr	r3, [r7, #12]
 802c6bc:	681b      	ldr	r3, [r3, #0]
 802c6be:	2217      	movs	r2, #23
 802c6c0:	615a      	str	r2, [r3, #20]
 802c6c2:	68fb      	ldr	r3, [r7, #12]
 802c6c4:	681b      	ldr	r3, [r3, #0]
 802c6c6:	681b      	ldr	r3, [r3, #0]
 802c6c8:	68f8      	ldr	r0, [r7, #12]
 802c6ca:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 802c6cc:	687b      	ldr	r3, [r7, #4]
 802c6ce:	61fb      	str	r3, [r7, #28]
 802c6d0:	e002      	b.n	802c6d8 <access_virt_barray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 802c6d2:	68bb      	ldr	r3, [r7, #8]
 802c6d4:	69db      	ldr	r3, [r3, #28]
 802c6d6:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802c6d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c6da:	2b00      	cmp	r3, #0
 802c6dc:	d002      	beq.n	802c6e4 <access_virt_barray+0x10a>
      ptr->first_undef_row = end_row;
 802c6de:	68bb      	ldr	r3, [r7, #8]
 802c6e0:	697a      	ldr	r2, [r7, #20]
 802c6e2:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 802c6e4:	68bb      	ldr	r3, [r7, #8]
 802c6e6:	6a1b      	ldr	r3, [r3, #32]
 802c6e8:	2b00      	cmp	r3, #0
 802c6ea:	d021      	beq.n	802c730 <access_virt_barray+0x156>
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 802c6ec:	68bb      	ldr	r3, [r7, #8]
 802c6ee:	689b      	ldr	r3, [r3, #8]
 802c6f0:	01db      	lsls	r3, r3, #7
 802c6f2:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 802c6f4:	68bb      	ldr	r3, [r7, #8]
 802c6f6:	699b      	ldr	r3, [r3, #24]
 802c6f8:	69fa      	ldr	r2, [r7, #28]
 802c6fa:	1ad3      	subs	r3, r2, r3
 802c6fc:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 802c6fe:	68bb      	ldr	r3, [r7, #8]
 802c700:	699b      	ldr	r3, [r3, #24]
 802c702:	697a      	ldr	r2, [r7, #20]
 802c704:	1ad3      	subs	r3, r2, r3
 802c706:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 802c708:	e00d      	b.n	802c726 <access_virt_barray+0x14c>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 802c70a:	68bb      	ldr	r3, [r7, #8]
 802c70c:	681a      	ldr	r2, [r3, #0]
 802c70e:	69fb      	ldr	r3, [r7, #28]
 802c710:	009b      	lsls	r3, r3, #2
 802c712:	4413      	add	r3, r2
 802c714:	681b      	ldr	r3, [r3, #0]
 802c716:	693a      	ldr	r2, [r7, #16]
 802c718:	2100      	movs	r1, #0
 802c71a:	4618      	mov	r0, r3
 802c71c:	f003 f940 	bl	802f9a0 <memset>
	undef_row++;
 802c720:	69fb      	ldr	r3, [r7, #28]
 802c722:	3301      	adds	r3, #1
 802c724:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 802c726:	69fa      	ldr	r2, [r7, #28]
 802c728:	697b      	ldr	r3, [r7, #20]
 802c72a:	429a      	cmp	r2, r3
 802c72c:	d3ed      	bcc.n	802c70a <access_virt_barray+0x130>
 802c72e:	e00b      	b.n	802c748 <access_virt_barray+0x16e>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 802c730:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c732:	2b00      	cmp	r3, #0
 802c734:	d108      	bne.n	802c748 <access_virt_barray+0x16e>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802c736:	68fb      	ldr	r3, [r7, #12]
 802c738:	681b      	ldr	r3, [r3, #0]
 802c73a:	2217      	movs	r2, #23
 802c73c:	615a      	str	r2, [r3, #20]
 802c73e:	68fb      	ldr	r3, [r7, #12]
 802c740:	681b      	ldr	r3, [r3, #0]
 802c742:	681b      	ldr	r3, [r3, #0]
 802c744:	68f8      	ldr	r0, [r7, #12]
 802c746:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802c748:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802c74a:	2b00      	cmp	r3, #0
 802c74c:	d002      	beq.n	802c754 <access_virt_barray+0x17a>
    ptr->dirty = TRUE;
 802c74e:	68bb      	ldr	r3, [r7, #8]
 802c750:	2201      	movs	r2, #1
 802c752:	625a      	str	r2, [r3, #36]	@ 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 802c754:	68bb      	ldr	r3, [r7, #8]
 802c756:	681a      	ldr	r2, [r3, #0]
 802c758:	68bb      	ldr	r3, [r7, #8]
 802c75a:	699b      	ldr	r3, [r3, #24]
 802c75c:	6879      	ldr	r1, [r7, #4]
 802c75e:	1acb      	subs	r3, r1, r3
 802c760:	009b      	lsls	r3, r3, #2
 802c762:	4413      	add	r3, r2
}
 802c764:	4618      	mov	r0, r3
 802c766:	3720      	adds	r7, #32
 802c768:	46bd      	mov	sp, r7
 802c76a:	bd80      	pop	{r7, pc}

0802c76c <free_pool>:
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
 802c76c:	b580      	push	{r7, lr}
 802c76e:	b08a      	sub	sp, #40	@ 0x28
 802c770:	af00      	add	r7, sp, #0
 802c772:	6078      	str	r0, [r7, #4]
 802c774:	6039      	str	r1, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802c776:	687b      	ldr	r3, [r7, #4]
 802c778:	685b      	ldr	r3, [r3, #4]
 802c77a:	617b      	str	r3, [r7, #20]
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 802c77c:	683b      	ldr	r3, [r7, #0]
 802c77e:	2b00      	cmp	r3, #0
 802c780:	db02      	blt.n	802c788 <free_pool+0x1c>
 802c782:	683b      	ldr	r3, [r7, #0]
 802c784:	2b01      	cmp	r3, #1
 802c786:	dd0c      	ble.n	802c7a2 <free_pool+0x36>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802c788:	687b      	ldr	r3, [r7, #4]
 802c78a:	681b      	ldr	r3, [r3, #0]
 802c78c:	220f      	movs	r2, #15
 802c78e:	615a      	str	r2, [r3, #20]
 802c790:	687b      	ldr	r3, [r7, #4]
 802c792:	681b      	ldr	r3, [r3, #0]
 802c794:	683a      	ldr	r2, [r7, #0]
 802c796:	619a      	str	r2, [r3, #24]
 802c798:	687b      	ldr	r3, [r7, #4]
 802c79a:	681b      	ldr	r3, [r3, #0]
 802c79c:	681b      	ldr	r3, [r3, #0]
 802c79e:	6878      	ldr	r0, [r7, #4]
 802c7a0:	4798      	blx	r3
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
 802c7a2:	683b      	ldr	r3, [r7, #0]
 802c7a4:	2b01      	cmp	r3, #1
 802c7a6:	d135      	bne.n	802c814 <free_pool+0xa8>
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c7a8:	697b      	ldr	r3, [r7, #20]
 802c7aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802c7ac:	61fb      	str	r3, [r7, #28]
 802c7ae:	e010      	b.n	802c7d2 <free_pool+0x66>
      if (sptr->b_s_open) {	/* there may be no backing store */
 802c7b0:	69fb      	ldr	r3, [r7, #28]
 802c7b2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802c7b4:	2b00      	cmp	r3, #0
 802c7b6:	d009      	beq.n	802c7cc <free_pool+0x60>
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
 802c7b8:	69fb      	ldr	r3, [r7, #28]
 802c7ba:	2200      	movs	r2, #0
 802c7bc:	629a      	str	r2, [r3, #40]	@ 0x28
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
 802c7be:	69fb      	ldr	r3, [r7, #28]
 802c7c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 802c7c2:	69fa      	ldr	r2, [r7, #28]
 802c7c4:	3230      	adds	r2, #48	@ 0x30
 802c7c6:	4611      	mov	r1, r2
 802c7c8:	6878      	ldr	r0, [r7, #4]
 802c7ca:	4798      	blx	r3
    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802c7cc:	69fb      	ldr	r3, [r7, #28]
 802c7ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c7d0:	61fb      	str	r3, [r7, #28]
 802c7d2:	69fb      	ldr	r3, [r7, #28]
 802c7d4:	2b00      	cmp	r3, #0
 802c7d6:	d1eb      	bne.n	802c7b0 <free_pool+0x44>
      }
    }
    mem->virt_sarray_list = NULL;
 802c7d8:	697b      	ldr	r3, [r7, #20]
 802c7da:	2200      	movs	r2, #0
 802c7dc:	645a      	str	r2, [r3, #68]	@ 0x44
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c7de:	697b      	ldr	r3, [r7, #20]
 802c7e0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 802c7e2:	61bb      	str	r3, [r7, #24]
 802c7e4:	e010      	b.n	802c808 <free_pool+0x9c>
      if (bptr->b_s_open) {	/* there may be no backing store */
 802c7e6:	69bb      	ldr	r3, [r7, #24]
 802c7e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802c7ea:	2b00      	cmp	r3, #0
 802c7ec:	d009      	beq.n	802c802 <free_pool+0x96>
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
 802c7ee:	69bb      	ldr	r3, [r7, #24]
 802c7f0:	2200      	movs	r2, #0
 802c7f2:	629a      	str	r2, [r3, #40]	@ 0x28
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
 802c7f4:	69bb      	ldr	r3, [r7, #24]
 802c7f6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 802c7f8:	69ba      	ldr	r2, [r7, #24]
 802c7fa:	3230      	adds	r2, #48	@ 0x30
 802c7fc:	4611      	mov	r1, r2
 802c7fe:	6878      	ldr	r0, [r7, #4]
 802c800:	4798      	blx	r3
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 802c802:	69bb      	ldr	r3, [r7, #24]
 802c804:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802c806:	61bb      	str	r3, [r7, #24]
 802c808:	69bb      	ldr	r3, [r7, #24]
 802c80a:	2b00      	cmp	r3, #0
 802c80c:	d1eb      	bne.n	802c7e6 <free_pool+0x7a>
      }
    }
    mem->virt_barray_list = NULL;
 802c80e:	697b      	ldr	r3, [r7, #20]
 802c810:	2200      	movs	r2, #0
 802c812:	649a      	str	r2, [r3, #72]	@ 0x48
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
 802c814:	697a      	ldr	r2, [r7, #20]
 802c816:	683b      	ldr	r3, [r7, #0]
 802c818:	330e      	adds	r3, #14
 802c81a:	009b      	lsls	r3, r3, #2
 802c81c:	4413      	add	r3, r2
 802c81e:	685b      	ldr	r3, [r3, #4]
 802c820:	623b      	str	r3, [r7, #32]
  mem->large_list[pool_id] = NULL;
 802c822:	697a      	ldr	r2, [r7, #20]
 802c824:	683b      	ldr	r3, [r7, #0]
 802c826:	330e      	adds	r3, #14
 802c828:	009b      	lsls	r3, r3, #2
 802c82a:	4413      	add	r3, r2
 802c82c:	2200      	movs	r2, #0
 802c82e:	605a      	str	r2, [r3, #4]

  while (lhdr_ptr != NULL) {
 802c830:	e018      	b.n	802c864 <free_pool+0xf8>
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 802c832:	6a3b      	ldr	r3, [r7, #32]
 802c834:	681b      	ldr	r3, [r3, #0]
 802c836:	60bb      	str	r3, [r7, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 802c838:	6a3b      	ldr	r3, [r7, #32]
 802c83a:	685a      	ldr	r2, [r3, #4]
		  lhdr_ptr->hdr.bytes_left +
 802c83c:	6a3b      	ldr	r3, [r7, #32]
 802c83e:	689b      	ldr	r3, [r3, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 802c840:	4413      	add	r3, r2
 802c842:	3310      	adds	r3, #16
 802c844:	60fb      	str	r3, [r7, #12]
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 802c846:	68fa      	ldr	r2, [r7, #12]
 802c848:	6a39      	ldr	r1, [r7, #32]
 802c84a:	6878      	ldr	r0, [r7, #4]
 802c84c:	f000 f91f 	bl	802ca8e <jpeg_free_large>
    mem->total_space_allocated -= space_freed;
 802c850:	697b      	ldr	r3, [r7, #20]
 802c852:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802c854:	461a      	mov	r2, r3
 802c856:	68fb      	ldr	r3, [r7, #12]
 802c858:	1ad3      	subs	r3, r2, r3
 802c85a:	461a      	mov	r2, r3
 802c85c:	697b      	ldr	r3, [r7, #20]
 802c85e:	64da      	str	r2, [r3, #76]	@ 0x4c
    lhdr_ptr = next_lhdr_ptr;
 802c860:	68bb      	ldr	r3, [r7, #8]
 802c862:	623b      	str	r3, [r7, #32]
  while (lhdr_ptr != NULL) {
 802c864:	6a3b      	ldr	r3, [r7, #32]
 802c866:	2b00      	cmp	r3, #0
 802c868:	d1e3      	bne.n	802c832 <free_pool+0xc6>
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
 802c86a:	697a      	ldr	r2, [r7, #20]
 802c86c:	683b      	ldr	r3, [r7, #0]
 802c86e:	330c      	adds	r3, #12
 802c870:	009b      	lsls	r3, r3, #2
 802c872:	4413      	add	r3, r2
 802c874:	685b      	ldr	r3, [r3, #4]
 802c876:	627b      	str	r3, [r7, #36]	@ 0x24
  mem->small_list[pool_id] = NULL;
 802c878:	697a      	ldr	r2, [r7, #20]
 802c87a:	683b      	ldr	r3, [r7, #0]
 802c87c:	330c      	adds	r3, #12
 802c87e:	009b      	lsls	r3, r3, #2
 802c880:	4413      	add	r3, r2
 802c882:	2200      	movs	r2, #0
 802c884:	605a      	str	r2, [r3, #4]

  while (shdr_ptr != NULL) {
 802c886:	e018      	b.n	802c8ba <free_pool+0x14e>
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 802c888:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c88a:	681b      	ldr	r3, [r3, #0]
 802c88c:	613b      	str	r3, [r7, #16]
    space_freed = shdr_ptr->hdr.bytes_used +
 802c88e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c890:	685a      	ldr	r2, [r3, #4]
		  shdr_ptr->hdr.bytes_left +
 802c892:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c894:	689b      	ldr	r3, [r3, #8]
    space_freed = shdr_ptr->hdr.bytes_used +
 802c896:	4413      	add	r3, r2
 802c898:	3310      	adds	r3, #16
 802c89a:	60fb      	str	r3, [r7, #12]
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 802c89c:	68fa      	ldr	r2, [r7, #12]
 802c89e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802c8a0:	6878      	ldr	r0, [r7, #4]
 802c8a2:	f000 f8da 	bl	802ca5a <jpeg_free_small>
    mem->total_space_allocated -= space_freed;
 802c8a6:	697b      	ldr	r3, [r7, #20]
 802c8a8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 802c8aa:	461a      	mov	r2, r3
 802c8ac:	68fb      	ldr	r3, [r7, #12]
 802c8ae:	1ad3      	subs	r3, r2, r3
 802c8b0:	461a      	mov	r2, r3
 802c8b2:	697b      	ldr	r3, [r7, #20]
 802c8b4:	64da      	str	r2, [r3, #76]	@ 0x4c
    shdr_ptr = next_shdr_ptr;
 802c8b6:	693b      	ldr	r3, [r7, #16]
 802c8b8:	627b      	str	r3, [r7, #36]	@ 0x24
  while (shdr_ptr != NULL) {
 802c8ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802c8bc:	2b00      	cmp	r3, #0
 802c8be:	d1e3      	bne.n	802c888 <free_pool+0x11c>
  }
}
 802c8c0:	bf00      	nop
 802c8c2:	bf00      	nop
 802c8c4:	3728      	adds	r7, #40	@ 0x28
 802c8c6:	46bd      	mov	sp, r7
 802c8c8:	bd80      	pop	{r7, pc}

0802c8ca <self_destruct>:
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
 802c8ca:	b580      	push	{r7, lr}
 802c8cc:	b084      	sub	sp, #16
 802c8ce:	af00      	add	r7, sp, #0
 802c8d0:	6078      	str	r0, [r7, #4]

  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802c8d2:	2301      	movs	r3, #1
 802c8d4:	60fb      	str	r3, [r7, #12]
 802c8d6:	e006      	b.n	802c8e6 <self_destruct+0x1c>
    free_pool(cinfo, pool);
 802c8d8:	68f9      	ldr	r1, [r7, #12]
 802c8da:	6878      	ldr	r0, [r7, #4]
 802c8dc:	f7ff ff46 	bl	802c76c <free_pool>
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802c8e0:	68fb      	ldr	r3, [r7, #12]
 802c8e2:	3b01      	subs	r3, #1
 802c8e4:	60fb      	str	r3, [r7, #12]
 802c8e6:	68fb      	ldr	r3, [r7, #12]
 802c8e8:	2b00      	cmp	r3, #0
 802c8ea:	daf5      	bge.n	802c8d8 <self_destruct+0xe>
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
 802c8ec:	687b      	ldr	r3, [r7, #4]
 802c8ee:	685b      	ldr	r3, [r3, #4]
 802c8f0:	2254      	movs	r2, #84	@ 0x54
 802c8f2:	4619      	mov	r1, r3
 802c8f4:	6878      	ldr	r0, [r7, #4]
 802c8f6:	f000 f8b0 	bl	802ca5a <jpeg_free_small>
  cinfo->mem = NULL;		/* ensures I will be called only once */
 802c8fa:	687b      	ldr	r3, [r7, #4]
 802c8fc:	2200      	movs	r2, #0
 802c8fe:	605a      	str	r2, [r3, #4]

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
 802c900:	6878      	ldr	r0, [r7, #4]
 802c902:	f000 f8fd 	bl	802cb00 <jpeg_mem_term>
}
 802c906:	bf00      	nop
 802c908:	3710      	adds	r7, #16
 802c90a:	46bd      	mov	sp, r7
 802c90c:	bd80      	pop	{r7, pc}
	...

0802c910 <jinit_memory_mgr>:
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
 802c910:	b580      	push	{r7, lr}
 802c912:	b086      	sub	sp, #24
 802c914:	af00      	add	r7, sp, #0
 802c916:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */
 802c918:	687b      	ldr	r3, [r7, #4]
 802c91a:	2200      	movs	r2, #0
 802c91c:	605a      	str	r2, [r3, #4]
  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   * a multiple of SIZEOF(ALIGN_TYPE).
   * Again, an "unreachable code" warning may be ignored here.
   * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   */
  test_mac = (size_t) MAX_ALLOC_CHUNK;
 802c91e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 802c922:	613b      	str	r3, [r7, #16]
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
 802c924:	693b      	ldr	r3, [r7, #16]
 802c926:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 802c92a:	d008      	beq.n	802c93e <jinit_memory_mgr+0x2e>
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
 802c92c:	687b      	ldr	r3, [r7, #4]
 802c92e:	681b      	ldr	r3, [r3, #0]
 802c930:	2202      	movs	r2, #2
 802c932:	615a      	str	r2, [r3, #20]
 802c934:	687b      	ldr	r3, [r7, #4]
 802c936:	681b      	ldr	r3, [r3, #0]
 802c938:	681b      	ldr	r3, [r3, #0]
 802c93a:	6878      	ldr	r0, [r7, #4]
 802c93c:	4798      	blx	r3

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
 802c93e:	6878      	ldr	r0, [r7, #4]
 802c940:	f000 f8d3 	bl	802caea <jpeg_mem_init>
 802c944:	60f8      	str	r0, [r7, #12]

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
 802c946:	2154      	movs	r1, #84	@ 0x54
 802c948:	6878      	ldr	r0, [r7, #4]
 802c94a:	f000 f879 	bl	802ca40 <jpeg_get_small>
 802c94e:	60b8      	str	r0, [r7, #8]

  if (mem == NULL) {
 802c950:	68bb      	ldr	r3, [r7, #8]
 802c952:	2b00      	cmp	r3, #0
 802c954:	d10f      	bne.n	802c976 <jinit_memory_mgr+0x66>
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
 802c956:	6878      	ldr	r0, [r7, #4]
 802c958:	f000 f8d2 	bl	802cb00 <jpeg_mem_term>
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
 802c95c:	687b      	ldr	r3, [r7, #4]
 802c95e:	681b      	ldr	r3, [r3, #0]
 802c960:	2238      	movs	r2, #56	@ 0x38
 802c962:	615a      	str	r2, [r3, #20]
 802c964:	687b      	ldr	r3, [r7, #4]
 802c966:	681b      	ldr	r3, [r3, #0]
 802c968:	2200      	movs	r2, #0
 802c96a:	619a      	str	r2, [r3, #24]
 802c96c:	687b      	ldr	r3, [r7, #4]
 802c96e:	681b      	ldr	r3, [r3, #0]
 802c970:	681b      	ldr	r3, [r3, #0]
 802c972:	6878      	ldr	r0, [r7, #4]
 802c974:	4798      	blx	r3
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
 802c976:	68bb      	ldr	r3, [r7, #8]
 802c978:	4a26      	ldr	r2, [pc, #152]	@ (802ca14 <jinit_memory_mgr+0x104>)
 802c97a:	601a      	str	r2, [r3, #0]
  mem->pub.alloc_large = alloc_large;
 802c97c:	68bb      	ldr	r3, [r7, #8]
 802c97e:	4a26      	ldr	r2, [pc, #152]	@ (802ca18 <jinit_memory_mgr+0x108>)
 802c980:	605a      	str	r2, [r3, #4]
  mem->pub.alloc_sarray = alloc_sarray;
 802c982:	68bb      	ldr	r3, [r7, #8]
 802c984:	4a25      	ldr	r2, [pc, #148]	@ (802ca1c <jinit_memory_mgr+0x10c>)
 802c986:	609a      	str	r2, [r3, #8]
  mem->pub.alloc_barray = alloc_barray;
 802c988:	68bb      	ldr	r3, [r7, #8]
 802c98a:	4a25      	ldr	r2, [pc, #148]	@ (802ca20 <jinit_memory_mgr+0x110>)
 802c98c:	60da      	str	r2, [r3, #12]
  mem->pub.request_virt_sarray = request_virt_sarray;
 802c98e:	68bb      	ldr	r3, [r7, #8]
 802c990:	4a24      	ldr	r2, [pc, #144]	@ (802ca24 <jinit_memory_mgr+0x114>)
 802c992:	611a      	str	r2, [r3, #16]
  mem->pub.request_virt_barray = request_virt_barray;
 802c994:	68bb      	ldr	r3, [r7, #8]
 802c996:	4a24      	ldr	r2, [pc, #144]	@ (802ca28 <jinit_memory_mgr+0x118>)
 802c998:	615a      	str	r2, [r3, #20]
  mem->pub.realize_virt_arrays = realize_virt_arrays;
 802c99a:	68bb      	ldr	r3, [r7, #8]
 802c99c:	4a23      	ldr	r2, [pc, #140]	@ (802ca2c <jinit_memory_mgr+0x11c>)
 802c99e:	619a      	str	r2, [r3, #24]
  mem->pub.access_virt_sarray = access_virt_sarray;
 802c9a0:	68bb      	ldr	r3, [r7, #8]
 802c9a2:	4a23      	ldr	r2, [pc, #140]	@ (802ca30 <jinit_memory_mgr+0x120>)
 802c9a4:	61da      	str	r2, [r3, #28]
  mem->pub.access_virt_barray = access_virt_barray;
 802c9a6:	68bb      	ldr	r3, [r7, #8]
 802c9a8:	4a22      	ldr	r2, [pc, #136]	@ (802ca34 <jinit_memory_mgr+0x124>)
 802c9aa:	621a      	str	r2, [r3, #32]
  mem->pub.free_pool = free_pool;
 802c9ac:	68bb      	ldr	r3, [r7, #8]
 802c9ae:	4a22      	ldr	r2, [pc, #136]	@ (802ca38 <jinit_memory_mgr+0x128>)
 802c9b0:	625a      	str	r2, [r3, #36]	@ 0x24
  mem->pub.self_destruct = self_destruct;
 802c9b2:	68bb      	ldr	r3, [r7, #8]
 802c9b4:	4a21      	ldr	r2, [pc, #132]	@ (802ca3c <jinit_memory_mgr+0x12c>)
 802c9b6:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Make MAX_ALLOC_CHUNK accessible to other modules */
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
 802c9b8:	68bb      	ldr	r3, [r7, #8]
 802c9ba:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 802c9be:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;
 802c9c0:	68bb      	ldr	r3, [r7, #8]
 802c9c2:	68fa      	ldr	r2, [r7, #12]
 802c9c4:	62da      	str	r2, [r3, #44]	@ 0x2c

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802c9c6:	2301      	movs	r3, #1
 802c9c8:	617b      	str	r3, [r7, #20]
 802c9ca:	e010      	b.n	802c9ee <jinit_memory_mgr+0xde>
    mem->small_list[pool] = NULL;
 802c9cc:	68ba      	ldr	r2, [r7, #8]
 802c9ce:	697b      	ldr	r3, [r7, #20]
 802c9d0:	330c      	adds	r3, #12
 802c9d2:	009b      	lsls	r3, r3, #2
 802c9d4:	4413      	add	r3, r2
 802c9d6:	2200      	movs	r2, #0
 802c9d8:	605a      	str	r2, [r3, #4]
    mem->large_list[pool] = NULL;
 802c9da:	68ba      	ldr	r2, [r7, #8]
 802c9dc:	697b      	ldr	r3, [r7, #20]
 802c9de:	330e      	adds	r3, #14
 802c9e0:	009b      	lsls	r3, r3, #2
 802c9e2:	4413      	add	r3, r2
 802c9e4:	2200      	movs	r2, #0
 802c9e6:	605a      	str	r2, [r3, #4]
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802c9e8:	697b      	ldr	r3, [r7, #20]
 802c9ea:	3b01      	subs	r3, #1
 802c9ec:	617b      	str	r3, [r7, #20]
 802c9ee:	697b      	ldr	r3, [r7, #20]
 802c9f0:	2b00      	cmp	r3, #0
 802c9f2:	daeb      	bge.n	802c9cc <jinit_memory_mgr+0xbc>
  }
  mem->virt_sarray_list = NULL;
 802c9f4:	68bb      	ldr	r3, [r7, #8]
 802c9f6:	2200      	movs	r2, #0
 802c9f8:	645a      	str	r2, [r3, #68]	@ 0x44
  mem->virt_barray_list = NULL;
 802c9fa:	68bb      	ldr	r3, [r7, #8]
 802c9fc:	2200      	movs	r2, #0
 802c9fe:	649a      	str	r2, [r3, #72]	@ 0x48

  mem->total_space_allocated = SIZEOF(my_memory_mgr);
 802ca00:	68bb      	ldr	r3, [r7, #8]
 802ca02:	2254      	movs	r2, #84	@ 0x54
 802ca04:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;
 802ca06:	68ba      	ldr	r2, [r7, #8]
 802ca08:	687b      	ldr	r3, [r7, #4]
 802ca0a:	605a      	str	r2, [r3, #4]
      }
    }
  }
#endif

}
 802ca0c:	bf00      	nop
 802ca0e:	3718      	adds	r7, #24
 802ca10:	46bd      	mov	sp, r7
 802ca12:	bd80      	pop	{r7, pc}
 802ca14:	0802bb65 	.word	0x0802bb65
 802ca18:	0802bce5 	.word	0x0802bce5
 802ca1c:	0802bdab 	.word	0x0802bdab
 802ca20:	0802be71 	.word	0x0802be71
 802ca24:	0802bf3d 	.word	0x0802bf3d
 802ca28:	0802bfb9 	.word	0x0802bfb9
 802ca2c:	0802c035 	.word	0x0802c035
 802ca30:	0802c44b 	.word	0x0802c44b
 802ca34:	0802c5db 	.word	0x0802c5db
 802ca38:	0802c76d 	.word	0x0802c76d
 802ca3c:	0802c8cb 	.word	0x0802c8cb

0802ca40 <jpeg_get_small>:
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
 802ca40:	b580      	push	{r7, lr}
 802ca42:	b082      	sub	sp, #8
 802ca44:	af00      	add	r7, sp, #0
 802ca46:	6078      	str	r0, [r7, #4]
 802ca48:	6039      	str	r1, [r7, #0]
  return (void *) JMALLOC(sizeofobject);
 802ca4a:	6838      	ldr	r0, [r7, #0]
 802ca4c:	f002 feca 	bl	802f7e4 <malloc>
 802ca50:	4603      	mov	r3, r0
}
 802ca52:	4618      	mov	r0, r3
 802ca54:	3708      	adds	r7, #8
 802ca56:	46bd      	mov	sp, r7
 802ca58:	bd80      	pop	{r7, pc}

0802ca5a <jpeg_free_small>:

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
 802ca5a:	b580      	push	{r7, lr}
 802ca5c:	b084      	sub	sp, #16
 802ca5e:	af00      	add	r7, sp, #0
 802ca60:	60f8      	str	r0, [r7, #12]
 802ca62:	60b9      	str	r1, [r7, #8]
 802ca64:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802ca66:	68b8      	ldr	r0, [r7, #8]
 802ca68:	f002 fec4 	bl	802f7f4 <free>
}
 802ca6c:	bf00      	nop
 802ca6e:	3710      	adds	r7, #16
 802ca70:	46bd      	mov	sp, r7
 802ca72:	bd80      	pop	{r7, pc}

0802ca74 <jpeg_get_large>:
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
 802ca74:	b580      	push	{r7, lr}
 802ca76:	b082      	sub	sp, #8
 802ca78:	af00      	add	r7, sp, #0
 802ca7a:	6078      	str	r0, [r7, #4]
 802ca7c:	6039      	str	r1, [r7, #0]
  return (void FAR *) JMALLOC(sizeofobject);
 802ca7e:	6838      	ldr	r0, [r7, #0]
 802ca80:	f002 feb0 	bl	802f7e4 <malloc>
 802ca84:	4603      	mov	r3, r0
}
 802ca86:	4618      	mov	r0, r3
 802ca88:	3708      	adds	r7, #8
 802ca8a:	46bd      	mov	sp, r7
 802ca8c:	bd80      	pop	{r7, pc}

0802ca8e <jpeg_free_large>:

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
 802ca8e:	b580      	push	{r7, lr}
 802ca90:	b084      	sub	sp, #16
 802ca92:	af00      	add	r7, sp, #0
 802ca94:	60f8      	str	r0, [r7, #12]
 802ca96:	60b9      	str	r1, [r7, #8]
 802ca98:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802ca9a:	68b8      	ldr	r0, [r7, #8]
 802ca9c:	f002 feaa 	bl	802f7f4 <free>
}
 802caa0:	bf00      	nop
 802caa2:	3710      	adds	r7, #16
 802caa4:	46bd      	mov	sp, r7
 802caa6:	bd80      	pop	{r7, pc}

0802caa8 <jpeg_mem_available>:
 */

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
 802caa8:	b480      	push	{r7}
 802caaa:	b085      	sub	sp, #20
 802caac:	af00      	add	r7, sp, #0
 802caae:	60f8      	str	r0, [r7, #12]
 802cab0:	60b9      	str	r1, [r7, #8]
 802cab2:	607a      	str	r2, [r7, #4]
 802cab4:	603b      	str	r3, [r7, #0]
  return max_bytes_needed;
 802cab6:	687b      	ldr	r3, [r7, #4]
}
 802cab8:	4618      	mov	r0, r3
 802caba:	3714      	adds	r7, #20
 802cabc:	46bd      	mov	sp, r7
 802cabe:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cac2:	4770      	bx	lr

0802cac4 <jpeg_open_backing_store>:
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
 802cac4:	b580      	push	{r7, lr}
 802cac6:	b084      	sub	sp, #16
 802cac8:	af00      	add	r7, sp, #0
 802caca:	60f8      	str	r0, [r7, #12]
 802cacc:	60b9      	str	r1, [r7, #8]
 802cace:	607a      	str	r2, [r7, #4]
  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
 802cad0:	68fb      	ldr	r3, [r7, #12]
 802cad2:	681b      	ldr	r3, [r3, #0]
 802cad4:	2233      	movs	r2, #51	@ 0x33
 802cad6:	615a      	str	r2, [r3, #20]
 802cad8:	68fb      	ldr	r3, [r7, #12]
 802cada:	681b      	ldr	r3, [r3, #0]
 802cadc:	681b      	ldr	r3, [r3, #0]
 802cade:	68f8      	ldr	r0, [r7, #12]
 802cae0:	4798      	blx	r3
}
 802cae2:	bf00      	nop
 802cae4:	3710      	adds	r7, #16
 802cae6:	46bd      	mov	sp, r7
 802cae8:	bd80      	pop	{r7, pc}

0802caea <jpeg_mem_init>:
 * cleanup required.  Here, there isn't any.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
 802caea:	b480      	push	{r7}
 802caec:	b083      	sub	sp, #12
 802caee:	af00      	add	r7, sp, #0
 802caf0:	6078      	str	r0, [r7, #4]
  return 0;			/* just set max_memory_to_use to 0 */
 802caf2:	2300      	movs	r3, #0
}
 802caf4:	4618      	mov	r0, r3
 802caf6:	370c      	adds	r7, #12
 802caf8:	46bd      	mov	sp, r7
 802cafa:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cafe:	4770      	bx	lr

0802cb00 <jpeg_mem_term>:

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
 802cb00:	b480      	push	{r7}
 802cb02:	b083      	sub	sp, #12
 802cb04:	af00      	add	r7, sp, #0
 802cb06:	6078      	str	r0, [r7, #4]
}
 802cb08:	bf00      	nop
 802cb0a:	370c      	adds	r7, #12
 802cb0c:	46bd      	mov	sp, r7
 802cb0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cb12:	4770      	bx	lr

0802cb14 <select_ncolors>:
LOCAL(int)
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
 802cb14:	b580      	push	{r7, lr}
 802cb16:	b08a      	sub	sp, #40	@ 0x28
 802cb18:	af00      	add	r7, sp, #0
 802cb1a:	6078      	str	r0, [r7, #4]
 802cb1c:	6039      	str	r1, [r7, #0]
  int nc = cinfo->out_color_components; /* number of color components */
 802cb1e:	687b      	ldr	r3, [r7, #4]
 802cb20:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802cb22:	613b      	str	r3, [r7, #16]
  int max_colors = cinfo->desired_number_of_colors;
 802cb24:	687b      	ldr	r3, [r7, #4]
 802cb26:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802cb28:	60fb      	str	r3, [r7, #12]
  long temp;
  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
 802cb2a:	2301      	movs	r3, #1
 802cb2c:	623b      	str	r3, [r7, #32]
  do {
    iroot++;
 802cb2e:	6a3b      	ldr	r3, [r7, #32]
 802cb30:	3301      	adds	r3, #1
 802cb32:	623b      	str	r3, [r7, #32]
    temp = iroot;		/* set temp = iroot ** nc */
 802cb34:	6a3b      	ldr	r3, [r7, #32]
 802cb36:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 802cb38:	2301      	movs	r3, #1
 802cb3a:	61fb      	str	r3, [r7, #28]
 802cb3c:	e007      	b.n	802cb4e <select_ncolors+0x3a>
      temp *= iroot;
 802cb3e:	697b      	ldr	r3, [r7, #20]
 802cb40:	6a3a      	ldr	r2, [r7, #32]
 802cb42:	fb02 f303 	mul.w	r3, r2, r3
 802cb46:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 802cb48:	69fb      	ldr	r3, [r7, #28]
 802cb4a:	3301      	adds	r3, #1
 802cb4c:	61fb      	str	r3, [r7, #28]
 802cb4e:	69fa      	ldr	r2, [r7, #28]
 802cb50:	693b      	ldr	r3, [r7, #16]
 802cb52:	429a      	cmp	r2, r3
 802cb54:	dbf3      	blt.n	802cb3e <select_ncolors+0x2a>
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
 802cb56:	697a      	ldr	r2, [r7, #20]
 802cb58:	68fb      	ldr	r3, [r7, #12]
 802cb5a:	429a      	cmp	r2, r3
 802cb5c:	dde7      	ble.n	802cb2e <select_ncolors+0x1a>
  iroot--;			/* now iroot = floor(root) */
 802cb5e:	6a3b      	ldr	r3, [r7, #32]
 802cb60:	3b01      	subs	r3, #1
 802cb62:	623b      	str	r3, [r7, #32]

  /* Must have at least 2 color values per component */
  if (iroot < 2)
 802cb64:	6a3b      	ldr	r3, [r7, #32]
 802cb66:	2b01      	cmp	r3, #1
 802cb68:	dc0c      	bgt.n	802cb84 <select_ncolors+0x70>
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
 802cb6a:	687b      	ldr	r3, [r7, #4]
 802cb6c:	681b      	ldr	r3, [r3, #0]
 802cb6e:	223a      	movs	r2, #58	@ 0x3a
 802cb70:	615a      	str	r2, [r3, #20]
 802cb72:	687b      	ldr	r3, [r7, #4]
 802cb74:	681b      	ldr	r3, [r3, #0]
 802cb76:	697a      	ldr	r2, [r7, #20]
 802cb78:	619a      	str	r2, [r3, #24]
 802cb7a:	687b      	ldr	r3, [r7, #4]
 802cb7c:	681b      	ldr	r3, [r3, #0]
 802cb7e:	681b      	ldr	r3, [r3, #0]
 802cb80:	6878      	ldr	r0, [r7, #4]
 802cb82:	4798      	blx	r3

  /* Initialize to iroot color values for each component */
  total_colors = 1;
 802cb84:	2301      	movs	r3, #1
 802cb86:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < nc; i++) {
 802cb88:	2300      	movs	r3, #0
 802cb8a:	61fb      	str	r3, [r7, #28]
 802cb8c:	e00d      	b.n	802cbaa <select_ncolors+0x96>
    Ncolors[i] = iroot;
 802cb8e:	69fb      	ldr	r3, [r7, #28]
 802cb90:	009b      	lsls	r3, r3, #2
 802cb92:	683a      	ldr	r2, [r7, #0]
 802cb94:	4413      	add	r3, r2
 802cb96:	6a3a      	ldr	r2, [r7, #32]
 802cb98:	601a      	str	r2, [r3, #0]
    total_colors *= iroot;
 802cb9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802cb9c:	6a3a      	ldr	r2, [r7, #32]
 802cb9e:	fb02 f303 	mul.w	r3, r2, r3
 802cba2:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0; i < nc; i++) {
 802cba4:	69fb      	ldr	r3, [r7, #28]
 802cba6:	3301      	adds	r3, #1
 802cba8:	61fb      	str	r3, [r7, #28]
 802cbaa:	69fa      	ldr	r2, [r7, #28]
 802cbac:	693b      	ldr	r3, [r7, #16]
 802cbae:	429a      	cmp	r2, r3
 802cbb0:	dbed      	blt.n	802cb8e <select_ncolors+0x7a>
   * Sometimes, the first component can be incremented more than once!
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
 802cbb2:	2300      	movs	r3, #0
 802cbb4:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 802cbb6:	2300      	movs	r3, #0
 802cbb8:	61fb      	str	r3, [r7, #28]
 802cbba:	e030      	b.n	802cc1e <select_ncolors+0x10a>
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
 802cbbc:	687b      	ldr	r3, [r7, #4]
 802cbbe:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 802cbc2:	2b02      	cmp	r3, #2
 802cbc4:	d104      	bne.n	802cbd0 <select_ncolors+0xbc>
 802cbc6:	4a1d      	ldr	r2, [pc, #116]	@ (802cc3c <select_ncolors+0x128>)
 802cbc8:	69fb      	ldr	r3, [r7, #28]
 802cbca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802cbce:	e000      	b.n	802cbd2 <select_ncolors+0xbe>
 802cbd0:	69fb      	ldr	r3, [r7, #28]
 802cbd2:	60bb      	str	r3, [r7, #8]
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
 802cbd4:	68bb      	ldr	r3, [r7, #8]
 802cbd6:	009b      	lsls	r3, r3, #2
 802cbd8:	683a      	ldr	r2, [r7, #0]
 802cbda:	4413      	add	r3, r2
 802cbdc:	681b      	ldr	r3, [r3, #0]
 802cbde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802cbe0:	fb92 f3f3 	sdiv	r3, r2, r3
 802cbe4:	617b      	str	r3, [r7, #20]
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
 802cbe6:	68bb      	ldr	r3, [r7, #8]
 802cbe8:	009b      	lsls	r3, r3, #2
 802cbea:	683a      	ldr	r2, [r7, #0]
 802cbec:	4413      	add	r3, r2
 802cbee:	681b      	ldr	r3, [r3, #0]
 802cbf0:	1c5a      	adds	r2, r3, #1
 802cbf2:	697b      	ldr	r3, [r7, #20]
 802cbf4:	fb02 f303 	mul.w	r3, r2, r3
 802cbf8:	617b      	str	r3, [r7, #20]
      if (temp > (long) max_colors)
 802cbfa:	697a      	ldr	r2, [r7, #20]
 802cbfc:	68fb      	ldr	r3, [r7, #12]
 802cbfe:	429a      	cmp	r2, r3
 802cc00:	dc12      	bgt.n	802cc28 <select_ncolors+0x114>
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
 802cc02:	68bb      	ldr	r3, [r7, #8]
 802cc04:	009b      	lsls	r3, r3, #2
 802cc06:	683a      	ldr	r2, [r7, #0]
 802cc08:	4413      	add	r3, r2
 802cc0a:	681a      	ldr	r2, [r3, #0]
 802cc0c:	3201      	adds	r2, #1
 802cc0e:	601a      	str	r2, [r3, #0]
      total_colors = (int) temp;
 802cc10:	697b      	ldr	r3, [r7, #20]
 802cc12:	627b      	str	r3, [r7, #36]	@ 0x24
      changed = TRUE;
 802cc14:	2301      	movs	r3, #1
 802cc16:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 802cc18:	69fb      	ldr	r3, [r7, #28]
 802cc1a:	3301      	adds	r3, #1
 802cc1c:	61fb      	str	r3, [r7, #28]
 802cc1e:	69fa      	ldr	r2, [r7, #28]
 802cc20:	693b      	ldr	r3, [r7, #16]
 802cc22:	429a      	cmp	r2, r3
 802cc24:	dbca      	blt.n	802cbbc <select_ncolors+0xa8>
 802cc26:	e000      	b.n	802cc2a <select_ncolors+0x116>
	break;			/* won't fit, done with this pass */
 802cc28:	bf00      	nop
    }
  } while (changed);
 802cc2a:	69bb      	ldr	r3, [r7, #24]
 802cc2c:	2b00      	cmp	r3, #0
 802cc2e:	d1c0      	bne.n	802cbb2 <select_ncolors+0x9e>

  return total_colors;
 802cc30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 802cc32:	4618      	mov	r0, r3
 802cc34:	3728      	adds	r7, #40	@ 0x28
 802cc36:	46bd      	mov	sp, r7
 802cc38:	bd80      	pop	{r7, pc}
 802cc3a:	bf00      	nop
 802cc3c:	08032744 	.word	0x08032744

0802cc40 <output_value>:

LOCAL(int)
output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
{
 802cc40:	b480      	push	{r7}
 802cc42:	b085      	sub	sp, #20
 802cc44:	af00      	add	r7, sp, #0
 802cc46:	60f8      	str	r0, [r7, #12]
 802cc48:	60b9      	str	r1, [r7, #8]
 802cc4a:	607a      	str	r2, [r7, #4]
 802cc4c:	603b      	str	r3, [r7, #0]
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
 802cc4e:	687a      	ldr	r2, [r7, #4]
 802cc50:	4613      	mov	r3, r2
 802cc52:	021b      	lsls	r3, r3, #8
 802cc54:	1a9a      	subs	r2, r3, r2
 802cc56:	683b      	ldr	r3, [r7, #0]
 802cc58:	0fd9      	lsrs	r1, r3, #31
 802cc5a:	440b      	add	r3, r1
 802cc5c:	105b      	asrs	r3, r3, #1
 802cc5e:	441a      	add	r2, r3
 802cc60:	683b      	ldr	r3, [r7, #0]
 802cc62:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802cc66:	4618      	mov	r0, r3
 802cc68:	3714      	adds	r7, #20
 802cc6a:	46bd      	mov	sp, r7
 802cc6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cc70:	4770      	bx	lr

0802cc72 <largest_input_value>:

LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
 802cc72:	b480      	push	{r7}
 802cc74:	b085      	sub	sp, #20
 802cc76:	af00      	add	r7, sp, #0
 802cc78:	60f8      	str	r0, [r7, #12]
 802cc7a:	60b9      	str	r1, [r7, #8]
 802cc7c:	607a      	str	r2, [r7, #4]
 802cc7e:	603b      	str	r3, [r7, #0]
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
 802cc80:	687b      	ldr	r3, [r7, #4]
 802cc82:	005b      	lsls	r3, r3, #1
 802cc84:	1c5a      	adds	r2, r3, #1
 802cc86:	4613      	mov	r3, r2
 802cc88:	021b      	lsls	r3, r3, #8
 802cc8a:	1a9a      	subs	r2, r3, r2
 802cc8c:	683b      	ldr	r3, [r7, #0]
 802cc8e:	441a      	add	r2, r3
 802cc90:	683b      	ldr	r3, [r7, #0]
 802cc92:	005b      	lsls	r3, r3, #1
 802cc94:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802cc98:	4618      	mov	r0, r3
 802cc9a:	3714      	adds	r7, #20
 802cc9c:	46bd      	mov	sp, r7
 802cc9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cca2:	4770      	bx	lr

0802cca4 <create_colormap>:
 * Create the colormap.
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
 802cca4:	b590      	push	{r4, r7, lr}
 802cca6:	b08f      	sub	sp, #60	@ 0x3c
 802cca8:	af00      	add	r7, sp, #0
 802ccaa:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ccac:	687b      	ldr	r3, [r7, #4]
 802ccae:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ccb2:	623b      	str	r3, [r7, #32]
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
 802ccb4:	6a3b      	ldr	r3, [r7, #32]
 802ccb6:	3320      	adds	r3, #32
 802ccb8:	4619      	mov	r1, r3
 802ccba:	6878      	ldr	r0, [r7, #4]
 802ccbc:	f7ff ff2a 	bl	802cb14 <select_ncolors>
 802ccc0:	61f8      	str	r0, [r7, #28]

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
 802ccc2:	687b      	ldr	r3, [r7, #4]
 802ccc4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802ccc6:	2b03      	cmp	r3, #3
 802ccc8:	d120      	bne.n	802cd0c <create_colormap+0x68>
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
 802ccca:	687b      	ldr	r3, [r7, #4]
 802cccc:	681b      	ldr	r3, [r3, #0]
 802ccce:	3318      	adds	r3, #24
 802ccd0:	61bb      	str	r3, [r7, #24]
 802ccd2:	69bb      	ldr	r3, [r7, #24]
 802ccd4:	69fa      	ldr	r2, [r7, #28]
 802ccd6:	601a      	str	r2, [r3, #0]
 802ccd8:	69bb      	ldr	r3, [r7, #24]
 802ccda:	3304      	adds	r3, #4
 802ccdc:	6a3a      	ldr	r2, [r7, #32]
 802ccde:	6a12      	ldr	r2, [r2, #32]
 802cce0:	601a      	str	r2, [r3, #0]
 802cce2:	69bb      	ldr	r3, [r7, #24]
 802cce4:	3308      	adds	r3, #8
 802cce6:	6a3a      	ldr	r2, [r7, #32]
 802cce8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 802ccea:	601a      	str	r2, [r3, #0]
 802ccec:	69bb      	ldr	r3, [r7, #24]
 802ccee:	330c      	adds	r3, #12
 802ccf0:	6a3a      	ldr	r2, [r7, #32]
 802ccf2:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 802ccf4:	601a      	str	r2, [r3, #0]
 802ccf6:	687b      	ldr	r3, [r7, #4]
 802ccf8:	681b      	ldr	r3, [r3, #0]
 802ccfa:	2260      	movs	r2, #96	@ 0x60
 802ccfc:	615a      	str	r2, [r3, #20]
 802ccfe:	687b      	ldr	r3, [r7, #4]
 802cd00:	681b      	ldr	r3, [r3, #0]
 802cd02:	685b      	ldr	r3, [r3, #4]
 802cd04:	2101      	movs	r1, #1
 802cd06:	6878      	ldr	r0, [r7, #4]
 802cd08:	4798      	blx	r3
 802cd0a:	e00d      	b.n	802cd28 <create_colormap+0x84>
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
 802cd0c:	687b      	ldr	r3, [r7, #4]
 802cd0e:	681b      	ldr	r3, [r3, #0]
 802cd10:	2261      	movs	r2, #97	@ 0x61
 802cd12:	615a      	str	r2, [r3, #20]
 802cd14:	687b      	ldr	r3, [r7, #4]
 802cd16:	681b      	ldr	r3, [r3, #0]
 802cd18:	69fa      	ldr	r2, [r7, #28]
 802cd1a:	619a      	str	r2, [r3, #24]
 802cd1c:	687b      	ldr	r3, [r7, #4]
 802cd1e:	681b      	ldr	r3, [r3, #0]
 802cd20:	685b      	ldr	r3, [r3, #4]
 802cd22:	2101      	movs	r1, #1
 802cd24:	6878      	ldr	r0, [r7, #4]
 802cd26:	4798      	blx	r3

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
 802cd28:	687b      	ldr	r3, [r7, #4]
 802cd2a:	685b      	ldr	r3, [r3, #4]
 802cd2c:	689c      	ldr	r4, [r3, #8]
 802cd2e:	69fa      	ldr	r2, [r7, #28]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
 802cd30:	687b      	ldr	r3, [r7, #4]
 802cd32:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
  colormap = (*cinfo->mem->alloc_sarray)
 802cd34:	2101      	movs	r1, #1
 802cd36:	6878      	ldr	r0, [r7, #4]
 802cd38:	47a0      	blx	r4
 802cd3a:	6178      	str	r0, [r7, #20]

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;
 802cd3c:	69fb      	ldr	r3, [r7, #28]
 802cd3e:	62bb      	str	r3, [r7, #40]	@ 0x28

  for (i = 0; i < cinfo->out_color_components; i++) {
 802cd40:	2300      	movs	r3, #0
 802cd42:	637b      	str	r3, [r7, #52]	@ 0x34
 802cd44:	e045      	b.n	802cdd2 <create_colormap+0x12e>
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802cd46:	6a3b      	ldr	r3, [r7, #32]
 802cd48:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802cd4a:	3208      	adds	r2, #8
 802cd4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cd50:	613b      	str	r3, [r7, #16]
    blksize = blkdist / nci;
 802cd52:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802cd54:	693b      	ldr	r3, [r7, #16]
 802cd56:	fb92 f3f3 	sdiv	r3, r2, r3
 802cd5a:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < nci; j++) {
 802cd5c:	2300      	movs	r3, #0
 802cd5e:	633b      	str	r3, [r7, #48]	@ 0x30
 802cd60:	e02e      	b.n	802cdc0 <create_colormap+0x11c>
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
 802cd62:	693b      	ldr	r3, [r7, #16]
 802cd64:	3b01      	subs	r3, #1
 802cd66:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802cd68:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 802cd6a:	6878      	ldr	r0, [r7, #4]
 802cd6c:	f7ff ff68 	bl	802cc40 <output_value>
 802cd70:	60b8      	str	r0, [r7, #8]
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 802cd72:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802cd74:	68fa      	ldr	r2, [r7, #12]
 802cd76:	fb02 f303 	mul.w	r3, r2, r3
 802cd7a:	627b      	str	r3, [r7, #36]	@ 0x24
 802cd7c:	e019      	b.n	802cdb2 <create_colormap+0x10e>
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
 802cd7e:	2300      	movs	r3, #0
 802cd80:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802cd82:	e00e      	b.n	802cda2 <create_colormap+0xfe>
	  colormap[i][ptr+k] = (JSAMPLE) val;
 802cd84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802cd86:	009b      	lsls	r3, r3, #2
 802cd88:	697a      	ldr	r2, [r7, #20]
 802cd8a:	4413      	add	r3, r2
 802cd8c:	681b      	ldr	r3, [r3, #0]
 802cd8e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802cd90:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802cd92:	440a      	add	r2, r1
 802cd94:	4413      	add	r3, r2
 802cd96:	68ba      	ldr	r2, [r7, #8]
 802cd98:	b2d2      	uxtb	r2, r2
 802cd9a:	701a      	strb	r2, [r3, #0]
	for (k = 0; k < blksize; k++)
 802cd9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802cd9e:	3301      	adds	r3, #1
 802cda0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802cda2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802cda4:	68fb      	ldr	r3, [r7, #12]
 802cda6:	429a      	cmp	r2, r3
 802cda8:	dbec      	blt.n	802cd84 <create_colormap+0xe0>
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 802cdaa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802cdac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cdae:	4413      	add	r3, r2
 802cdb0:	627b      	str	r3, [r7, #36]	@ 0x24
 802cdb2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802cdb4:	69fb      	ldr	r3, [r7, #28]
 802cdb6:	429a      	cmp	r2, r3
 802cdb8:	dbe1      	blt.n	802cd7e <create_colormap+0xda>
    for (j = 0; j < nci; j++) {
 802cdba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802cdbc:	3301      	adds	r3, #1
 802cdbe:	633b      	str	r3, [r7, #48]	@ 0x30
 802cdc0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802cdc2:	693b      	ldr	r3, [r7, #16]
 802cdc4:	429a      	cmp	r2, r3
 802cdc6:	dbcc      	blt.n	802cd62 <create_colormap+0xbe>
      }
    }
    blkdist = blksize;		/* blksize of this color is blkdist of next */
 802cdc8:	68fb      	ldr	r3, [r7, #12]
 802cdca:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = 0; i < cinfo->out_color_components; i++) {
 802cdcc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802cdce:	3301      	adds	r3, #1
 802cdd0:	637b      	str	r3, [r7, #52]	@ 0x34
 802cdd2:	687b      	ldr	r3, [r7, #4]
 802cdd4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802cdd6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802cdd8:	429a      	cmp	r2, r3
 802cdda:	dbb4      	blt.n	802cd46 <create_colormap+0xa2>
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
 802cddc:	6a3b      	ldr	r3, [r7, #32]
 802cdde:	697a      	ldr	r2, [r7, #20]
 802cde0:	611a      	str	r2, [r3, #16]
  cquantize->sv_actual = total_colors;
 802cde2:	6a3b      	ldr	r3, [r7, #32]
 802cde4:	69fa      	ldr	r2, [r7, #28]
 802cde6:	615a      	str	r2, [r3, #20]
}
 802cde8:	bf00      	nop
 802cdea:	373c      	adds	r7, #60	@ 0x3c
 802cdec:	46bd      	mov	sp, r7
 802cdee:	bd90      	pop	{r4, r7, pc}

0802cdf0 <create_colorindex>:
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
 802cdf0:	b590      	push	{r4, r7, lr}
 802cdf2:	b08d      	sub	sp, #52	@ 0x34
 802cdf4:	af00      	add	r7, sp, #0
 802cdf6:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802cdf8:	687b      	ldr	r3, [r7, #4]
 802cdfa:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802cdfe:	617b      	str	r3, [r7, #20]
  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
 802ce00:	687b      	ldr	r3, [r7, #4]
 802ce02:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802ce06:	2b01      	cmp	r3, #1
 802ce08:	d106      	bne.n	802ce18 <create_colorindex+0x28>
    pad = MAXJSAMPLE*2;
 802ce0a:	f44f 73ff 	mov.w	r3, #510	@ 0x1fe
 802ce0e:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = TRUE;
 802ce10:	697b      	ldr	r3, [r7, #20]
 802ce12:	2201      	movs	r2, #1
 802ce14:	61da      	str	r2, [r3, #28]
 802ce16:	e004      	b.n	802ce22 <create_colorindex+0x32>
  } else {
    pad = 0;
 802ce18:	2300      	movs	r3, #0
 802ce1a:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = FALSE;
 802ce1c:	697b      	ldr	r3, [r7, #20]
 802ce1e:	2200      	movs	r2, #0
 802ce20:	61da      	str	r2, [r3, #28]
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802ce22:	687b      	ldr	r3, [r7, #4]
 802ce24:	685b      	ldr	r3, [r3, #4]
 802ce26:	689c      	ldr	r4, [r3, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
 802ce28:	69bb      	ldr	r3, [r7, #24]
 802ce2a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802ce2e:	461a      	mov	r2, r3
     (JDIMENSION) cinfo->out_color_components);
 802ce30:	687b      	ldr	r3, [r7, #4]
 802ce32:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 802ce34:	2101      	movs	r1, #1
 802ce36:	6878      	ldr	r0, [r7, #4]
 802ce38:	47a0      	blx	r4
 802ce3a:	4602      	mov	r2, r0
 802ce3c:	697b      	ldr	r3, [r7, #20]
 802ce3e:	619a      	str	r2, [r3, #24]

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;
 802ce40:	697b      	ldr	r3, [r7, #20]
 802ce42:	695b      	ldr	r3, [r3, #20]
 802ce44:	623b      	str	r3, [r7, #32]

  for (i = 0; i < cinfo->out_color_components; i++) {
 802ce46:	2300      	movs	r3, #0
 802ce48:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802ce4a:	e06e      	b.n	802cf2a <create_colorindex+0x13a>
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802ce4c:	697b      	ldr	r3, [r7, #20]
 802ce4e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802ce50:	3208      	adds	r2, #8
 802ce52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802ce56:	613b      	str	r3, [r7, #16]
    blksize = blksize / nci;
 802ce58:	6a3a      	ldr	r2, [r7, #32]
 802ce5a:	693b      	ldr	r3, [r7, #16]
 802ce5c:	fb92 f3f3 	sdiv	r3, r2, r3
 802ce60:	623b      	str	r3, [r7, #32]

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
 802ce62:	69bb      	ldr	r3, [r7, #24]
 802ce64:	2b00      	cmp	r3, #0
 802ce66:	d00c      	beq.n	802ce82 <create_colorindex+0x92>
      cquantize->colorindex[i] += MAXJSAMPLE;
 802ce68:	697b      	ldr	r3, [r7, #20]
 802ce6a:	699a      	ldr	r2, [r3, #24]
 802ce6c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ce6e:	009b      	lsls	r3, r3, #2
 802ce70:	4413      	add	r3, r2
 802ce72:	681a      	ldr	r2, [r3, #0]
 802ce74:	697b      	ldr	r3, [r7, #20]
 802ce76:	6999      	ldr	r1, [r3, #24]
 802ce78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ce7a:	009b      	lsls	r3, r3, #2
 802ce7c:	440b      	add	r3, r1
 802ce7e:	32ff      	adds	r2, #255	@ 0xff
 802ce80:	601a      	str	r2, [r3, #0]

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
 802ce82:	697b      	ldr	r3, [r7, #20]
 802ce84:	699a      	ldr	r2, [r3, #24]
 802ce86:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802ce88:	009b      	lsls	r3, r3, #2
 802ce8a:	4413      	add	r3, r2
 802ce8c:	681b      	ldr	r3, [r3, #0]
 802ce8e:	60fb      	str	r3, [r7, #12]
    val = 0;
 802ce90:	2300      	movs	r3, #0
 802ce92:	61fb      	str	r3, [r7, #28]
    k = largest_input_value(cinfo, i, 0, nci-1);
 802ce94:	693b      	ldr	r3, [r7, #16]
 802ce96:	3b01      	subs	r3, #1
 802ce98:	2200      	movs	r2, #0
 802ce9a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802ce9c:	6878      	ldr	r0, [r7, #4]
 802ce9e:	f7ff fee8 	bl	802cc72 <largest_input_value>
 802cea2:	6278      	str	r0, [r7, #36]	@ 0x24
    for (j = 0; j <= MAXJSAMPLE; j++) {
 802cea4:	2300      	movs	r3, #0
 802cea6:	62bb      	str	r3, [r7, #40]	@ 0x28
 802cea8:	e01c      	b.n	802cee4 <create_colorindex+0xf4>
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
 802ceaa:	69fb      	ldr	r3, [r7, #28]
 802ceac:	3301      	adds	r3, #1
 802ceae:	61fb      	str	r3, [r7, #28]
 802ceb0:	693b      	ldr	r3, [r7, #16]
 802ceb2:	3b01      	subs	r3, #1
 802ceb4:	69fa      	ldr	r2, [r7, #28]
 802ceb6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802ceb8:	6878      	ldr	r0, [r7, #4]
 802ceba:	f7ff feda 	bl	802cc72 <largest_input_value>
 802cebe:	6278      	str	r0, [r7, #36]	@ 0x24
      while (j > k)		/* advance val if past boundary */
 802cec0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802cec2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802cec4:	429a      	cmp	r2, r3
 802cec6:	dcf0      	bgt.n	802ceaa <create_colorindex+0xba>
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
 802cec8:	69fb      	ldr	r3, [r7, #28]
 802ceca:	b2d9      	uxtb	r1, r3
 802cecc:	6a3b      	ldr	r3, [r7, #32]
 802cece:	b2da      	uxtb	r2, r3
 802ced0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ced2:	68f8      	ldr	r0, [r7, #12]
 802ced4:	4403      	add	r3, r0
 802ced6:	fb11 f202 	smulbb	r2, r1, r2
 802ceda:	b2d2      	uxtb	r2, r2
 802cedc:	701a      	strb	r2, [r3, #0]
    for (j = 0; j <= MAXJSAMPLE; j++) {
 802cede:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cee0:	3301      	adds	r3, #1
 802cee2:	62bb      	str	r3, [r7, #40]	@ 0x28
 802cee4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cee6:	2bff      	cmp	r3, #255	@ 0xff
 802cee8:	ddea      	ble.n	802cec0 <create_colorindex+0xd0>
    }
    /* Pad at both ends if necessary */
    if (pad)
 802ceea:	69bb      	ldr	r3, [r7, #24]
 802ceec:	2b00      	cmp	r3, #0
 802ceee:	d019      	beq.n	802cf24 <create_colorindex+0x134>
      for (j = 1; j <= MAXJSAMPLE; j++) {
 802cef0:	2301      	movs	r3, #1
 802cef2:	62bb      	str	r3, [r7, #40]	@ 0x28
 802cef4:	e013      	b.n	802cf1e <create_colorindex+0x12e>
	indexptr[-j] = indexptr[0];
 802cef6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cef8:	425b      	negs	r3, r3
 802cefa:	461a      	mov	r2, r3
 802cefc:	68fb      	ldr	r3, [r7, #12]
 802cefe:	4413      	add	r3, r2
 802cf00:	68fa      	ldr	r2, [r7, #12]
 802cf02:	7812      	ldrb	r2, [r2, #0]
 802cf04:	701a      	strb	r2, [r3, #0]
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
 802cf06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cf08:	33ff      	adds	r3, #255	@ 0xff
 802cf0a:	461a      	mov	r2, r3
 802cf0c:	68fb      	ldr	r3, [r7, #12]
 802cf0e:	4413      	add	r3, r2
 802cf10:	68fa      	ldr	r2, [r7, #12]
 802cf12:	f892 20ff 	ldrb.w	r2, [r2, #255]	@ 0xff
 802cf16:	701a      	strb	r2, [r3, #0]
      for (j = 1; j <= MAXJSAMPLE; j++) {
 802cf18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cf1a:	3301      	adds	r3, #1
 802cf1c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802cf1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802cf20:	2bff      	cmp	r3, #255	@ 0xff
 802cf22:	dde8      	ble.n	802cef6 <create_colorindex+0x106>
  for (i = 0; i < cinfo->out_color_components; i++) {
 802cf24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802cf26:	3301      	adds	r3, #1
 802cf28:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802cf2a:	687b      	ldr	r3, [r7, #4]
 802cf2c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802cf2e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802cf30:	429a      	cmp	r2, r3
 802cf32:	db8b      	blt.n	802ce4c <create_colorindex+0x5c>
      }
  }
}
 802cf34:	bf00      	nop
 802cf36:	bf00      	nop
 802cf38:	3734      	adds	r7, #52	@ 0x34
 802cf3a:	46bd      	mov	sp, r7
 802cf3c:	bd90      	pop	{r4, r7, pc}
	...

0802cf40 <make_odither_array>:
 * distinct output values.
 */

LOCAL(ODITHER_MATRIX_PTR)
make_odither_array (j_decompress_ptr cinfo, int ncolors)
{
 802cf40:	b580      	push	{r7, lr}
 802cf42:	b088      	sub	sp, #32
 802cf44:	af00      	add	r7, sp, #0
 802cf46:	6078      	str	r0, [r7, #4]
 802cf48:	6039      	str	r1, [r7, #0]
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802cf4a:	687b      	ldr	r3, [r7, #4]
 802cf4c:	685b      	ldr	r3, [r3, #4]
 802cf4e:	681b      	ldr	r3, [r3, #0]
 802cf50:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 802cf54:	2101      	movs	r1, #1
 802cf56:	6878      	ldr	r0, [r7, #4]
 802cf58:	4798      	blx	r3
 802cf5a:	6178      	str	r0, [r7, #20]
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
 802cf5c:	683b      	ldr	r3, [r7, #0]
 802cf5e:	3b01      	subs	r3, #1
 802cf60:	025b      	lsls	r3, r3, #9
 802cf62:	613b      	str	r3, [r7, #16]
  for (j = 0; j < ODITHER_SIZE; j++) {
 802cf64:	2300      	movs	r3, #0
 802cf66:	61fb      	str	r3, [r7, #28]
 802cf68:	e02e      	b.n	802cfc8 <make_odither_array+0x88>
    for (k = 0; k < ODITHER_SIZE; k++) {
 802cf6a:	2300      	movs	r3, #0
 802cf6c:	61bb      	str	r3, [r7, #24]
 802cf6e:	e025      	b.n	802cfbc <make_odither_array+0x7c>
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
 802cf70:	4a19      	ldr	r2, [pc, #100]	@ (802cfd8 <make_odither_array+0x98>)
 802cf72:	69fb      	ldr	r3, [r7, #28]
 802cf74:	011b      	lsls	r3, r3, #4
 802cf76:	441a      	add	r2, r3
 802cf78:	69bb      	ldr	r3, [r7, #24]
 802cf7a:	4413      	add	r3, r2
 802cf7c:	781b      	ldrb	r3, [r3, #0]
 802cf7e:	005b      	lsls	r3, r3, #1
 802cf80:	f1c3 02ff 	rsb	r2, r3, #255	@ 0xff
 802cf84:	4613      	mov	r3, r2
 802cf86:	021b      	lsls	r3, r3, #8
 802cf88:	1a9b      	subs	r3, r3, r2
 802cf8a:	60fb      	str	r3, [r7, #12]
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
 802cf8c:	68fb      	ldr	r3, [r7, #12]
 802cf8e:	2b00      	cmp	r3, #0
 802cf90:	da06      	bge.n	802cfa0 <make_odither_array+0x60>
 802cf92:	68fb      	ldr	r3, [r7, #12]
 802cf94:	425a      	negs	r2, r3
 802cf96:	693b      	ldr	r3, [r7, #16]
 802cf98:	fb92 f3f3 	sdiv	r3, r2, r3
 802cf9c:	425b      	negs	r3, r3
 802cf9e:	e003      	b.n	802cfa8 <make_odither_array+0x68>
 802cfa0:	68fa      	ldr	r2, [r7, #12]
 802cfa2:	693b      	ldr	r3, [r7, #16]
 802cfa4:	fb92 f3f3 	sdiv	r3, r2, r3
 802cfa8:	69fa      	ldr	r2, [r7, #28]
 802cfaa:	0192      	lsls	r2, r2, #6
 802cfac:	6979      	ldr	r1, [r7, #20]
 802cfae:	440a      	add	r2, r1
 802cfb0:	69b9      	ldr	r1, [r7, #24]
 802cfb2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    for (k = 0; k < ODITHER_SIZE; k++) {
 802cfb6:	69bb      	ldr	r3, [r7, #24]
 802cfb8:	3301      	adds	r3, #1
 802cfba:	61bb      	str	r3, [r7, #24]
 802cfbc:	69bb      	ldr	r3, [r7, #24]
 802cfbe:	2b0f      	cmp	r3, #15
 802cfc0:	ddd6      	ble.n	802cf70 <make_odither_array+0x30>
  for (j = 0; j < ODITHER_SIZE; j++) {
 802cfc2:	69fb      	ldr	r3, [r7, #28]
 802cfc4:	3301      	adds	r3, #1
 802cfc6:	61fb      	str	r3, [r7, #28]
 802cfc8:	69fb      	ldr	r3, [r7, #28]
 802cfca:	2b0f      	cmp	r3, #15
 802cfcc:	ddcd      	ble.n	802cf6a <make_odither_array+0x2a>
    }
  }
  return odither;
 802cfce:	697b      	ldr	r3, [r7, #20]
}
 802cfd0:	4618      	mov	r0, r3
 802cfd2:	3720      	adds	r7, #32
 802cfd4:	46bd      	mov	sp, r7
 802cfd6:	bd80      	pop	{r7, pc}
 802cfd8:	08032644 	.word	0x08032644

0802cfdc <create_odither_tables>:
 * share a dither table.
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
 802cfdc:	b580      	push	{r7, lr}
 802cfde:	b088      	sub	sp, #32
 802cfe0:	af00      	add	r7, sp, #0
 802cfe2:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802cfe4:	687b      	ldr	r3, [r7, #4]
 802cfe6:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802cfea:	613b      	str	r3, [r7, #16]
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
 802cfec:	2300      	movs	r3, #0
 802cfee:	61bb      	str	r3, [r7, #24]
 802cff0:	e033      	b.n	802d05a <create_odither_tables+0x7e>
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802cff2:	693b      	ldr	r3, [r7, #16]
 802cff4:	69ba      	ldr	r2, [r7, #24]
 802cff6:	3208      	adds	r2, #8
 802cff8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802cffc:	60fb      	str	r3, [r7, #12]
    odither = NULL;		/* search for matching prior component */
 802cffe:	2300      	movs	r3, #0
 802d000:	61fb      	str	r3, [r7, #28]
    for (j = 0; j < i; j++) {
 802d002:	2300      	movs	r3, #0
 802d004:	617b      	str	r3, [r7, #20]
 802d006:	e012      	b.n	802d02e <create_odither_tables+0x52>
      if (nci == cquantize->Ncolors[j]) {
 802d008:	693b      	ldr	r3, [r7, #16]
 802d00a:	697a      	ldr	r2, [r7, #20]
 802d00c:	3208      	adds	r2, #8
 802d00e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802d012:	68fa      	ldr	r2, [r7, #12]
 802d014:	429a      	cmp	r2, r3
 802d016:	d107      	bne.n	802d028 <create_odither_tables+0x4c>
	odither = cquantize->odither[j];
 802d018:	693a      	ldr	r2, [r7, #16]
 802d01a:	697b      	ldr	r3, [r7, #20]
 802d01c:	330c      	adds	r3, #12
 802d01e:	009b      	lsls	r3, r3, #2
 802d020:	4413      	add	r3, r2
 802d022:	685b      	ldr	r3, [r3, #4]
 802d024:	61fb      	str	r3, [r7, #28]
	break;
 802d026:	e006      	b.n	802d036 <create_odither_tables+0x5a>
    for (j = 0; j < i; j++) {
 802d028:	697b      	ldr	r3, [r7, #20]
 802d02a:	3301      	adds	r3, #1
 802d02c:	617b      	str	r3, [r7, #20]
 802d02e:	697a      	ldr	r2, [r7, #20]
 802d030:	69bb      	ldr	r3, [r7, #24]
 802d032:	429a      	cmp	r2, r3
 802d034:	dbe8      	blt.n	802d008 <create_odither_tables+0x2c>
      }
    }
    if (odither == NULL)	/* need a new table? */
 802d036:	69fb      	ldr	r3, [r7, #28]
 802d038:	2b00      	cmp	r3, #0
 802d03a:	d104      	bne.n	802d046 <create_odither_tables+0x6a>
      odither = make_odither_array(cinfo, nci);
 802d03c:	68f9      	ldr	r1, [r7, #12]
 802d03e:	6878      	ldr	r0, [r7, #4]
 802d040:	f7ff ff7e 	bl	802cf40 <make_odither_array>
 802d044:	61f8      	str	r0, [r7, #28]
    cquantize->odither[i] = odither;
 802d046:	693a      	ldr	r2, [r7, #16]
 802d048:	69bb      	ldr	r3, [r7, #24]
 802d04a:	330c      	adds	r3, #12
 802d04c:	009b      	lsls	r3, r3, #2
 802d04e:	4413      	add	r3, r2
 802d050:	69fa      	ldr	r2, [r7, #28]
 802d052:	605a      	str	r2, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802d054:	69bb      	ldr	r3, [r7, #24]
 802d056:	3301      	adds	r3, #1
 802d058:	61bb      	str	r3, [r7, #24]
 802d05a:	687b      	ldr	r3, [r7, #4]
 802d05c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d05e:	69ba      	ldr	r2, [r7, #24]
 802d060:	429a      	cmp	r2, r3
 802d062:	dbc6      	blt.n	802cff2 <create_odither_tables+0x16>
  }
}
 802d064:	bf00      	nop
 802d066:	bf00      	nop
 802d068:	3720      	adds	r7, #32
 802d06a:	46bd      	mov	sp, r7
 802d06c:	bd80      	pop	{r7, pc}

0802d06e <color_quantize>:

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
 802d06e:	b4f0      	push	{r4, r5, r6, r7}
 802d070:	b08a      	sub	sp, #40	@ 0x28
 802d072:	af00      	add	r7, sp, #0
 802d074:	60f8      	str	r0, [r7, #12]
 802d076:	60b9      	str	r1, [r7, #8]
 802d078:	607a      	str	r2, [r7, #4]
 802d07a:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d07c:	68fb      	ldr	r3, [r7, #12]
 802d07e:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d082:	61fb      	str	r3, [r7, #28]
  JSAMPARRAY colorindex = cquantize->colorindex;
 802d084:	69fb      	ldr	r3, [r7, #28]
 802d086:	699b      	ldr	r3, [r3, #24]
 802d088:	61bb      	str	r3, [r7, #24]
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d08a:	68fb      	ldr	r3, [r7, #12]
 802d08c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d08e:	617b      	str	r3, [r7, #20]
  register int nc = cinfo->out_color_components;
 802d090:	68fb      	ldr	r3, [r7, #12]
 802d092:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d094:	4618      	mov	r0, r3

  for (row = 0; row < num_rows; row++) {
 802d096:	2300      	movs	r3, #0
 802d098:	627b      	str	r3, [r7, #36]	@ 0x24
 802d09a:	e02d      	b.n	802d0f8 <color_quantize+0x8a>
    ptrin = input_buf[row];
 802d09c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d09e:	009b      	lsls	r3, r3, #2
 802d0a0:	68ba      	ldr	r2, [r7, #8]
 802d0a2:	4413      	add	r3, r2
 802d0a4:	681e      	ldr	r6, [r3, #0]
    ptrout = output_buf[row];
 802d0a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d0a8:	009b      	lsls	r3, r3, #2
 802d0aa:	687a      	ldr	r2, [r7, #4]
 802d0ac:	4413      	add	r3, r2
 802d0ae:	681b      	ldr	r3, [r3, #0]
 802d0b0:	4619      	mov	r1, r3
    for (col = width; col > 0; col--) {
 802d0b2:	697b      	ldr	r3, [r7, #20]
 802d0b4:	623b      	str	r3, [r7, #32]
 802d0b6:	e019      	b.n	802d0ec <color_quantize+0x7e>
      pixcode = 0;
 802d0b8:	2500      	movs	r5, #0
      for (ci = 0; ci < nc; ci++) {
 802d0ba:	2400      	movs	r4, #0
 802d0bc:	e00b      	b.n	802d0d6 <color_quantize+0x68>
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
 802d0be:	4623      	mov	r3, r4
 802d0c0:	009b      	lsls	r3, r3, #2
 802d0c2:	69ba      	ldr	r2, [r7, #24]
 802d0c4:	4413      	add	r3, r2
 802d0c6:	681a      	ldr	r2, [r3, #0]
 802d0c8:	4633      	mov	r3, r6
 802d0ca:	1c5e      	adds	r6, r3, #1
 802d0cc:	781b      	ldrb	r3, [r3, #0]
 802d0ce:	4413      	add	r3, r2
 802d0d0:	781b      	ldrb	r3, [r3, #0]
 802d0d2:	441d      	add	r5, r3
      for (ci = 0; ci < nc; ci++) {
 802d0d4:	3401      	adds	r4, #1
 802d0d6:	4603      	mov	r3, r0
 802d0d8:	429c      	cmp	r4, r3
 802d0da:	dbf0      	blt.n	802d0be <color_quantize+0x50>
      }
      *ptrout++ = (JSAMPLE) pixcode;
 802d0dc:	460b      	mov	r3, r1
 802d0de:	1c5a      	adds	r2, r3, #1
 802d0e0:	4611      	mov	r1, r2
 802d0e2:	b2ea      	uxtb	r2, r5
 802d0e4:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802d0e6:	6a3b      	ldr	r3, [r7, #32]
 802d0e8:	3b01      	subs	r3, #1
 802d0ea:	623b      	str	r3, [r7, #32]
 802d0ec:	6a3b      	ldr	r3, [r7, #32]
 802d0ee:	2b00      	cmp	r3, #0
 802d0f0:	d1e2      	bne.n	802d0b8 <color_quantize+0x4a>
  for (row = 0; row < num_rows; row++) {
 802d0f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d0f4:	3301      	adds	r3, #1
 802d0f6:	627b      	str	r3, [r7, #36]	@ 0x24
 802d0f8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802d0fa:	683b      	ldr	r3, [r7, #0]
 802d0fc:	429a      	cmp	r2, r3
 802d0fe:	dbcd      	blt.n	802d09c <color_quantize+0x2e>
    }
  }
}
 802d100:	bf00      	nop
 802d102:	bf00      	nop
 802d104:	3728      	adds	r7, #40	@ 0x28
 802d106:	46bd      	mov	sp, r7
 802d108:	bcf0      	pop	{r4, r5, r6, r7}
 802d10a:	4770      	bx	lr

0802d10c <color_quantize3>:

METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
 802d10c:	b4f0      	push	{r4, r5, r6, r7}
 802d10e:	b08c      	sub	sp, #48	@ 0x30
 802d110:	af00      	add	r7, sp, #0
 802d112:	60f8      	str	r0, [r7, #12]
 802d114:	60b9      	str	r1, [r7, #8]
 802d116:	607a      	str	r2, [r7, #4]
 802d118:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d11a:	68fb      	ldr	r3, [r7, #12]
 802d11c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d120:	627b      	str	r3, [r7, #36]	@ 0x24
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 802d122:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d124:	699b      	ldr	r3, [r3, #24]
 802d126:	681b      	ldr	r3, [r3, #0]
 802d128:	623b      	str	r3, [r7, #32]
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 802d12a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d12c:	699b      	ldr	r3, [r3, #24]
 802d12e:	685b      	ldr	r3, [r3, #4]
 802d130:	61fb      	str	r3, [r7, #28]
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 802d132:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d134:	699b      	ldr	r3, [r3, #24]
 802d136:	689b      	ldr	r3, [r3, #8]
 802d138:	61bb      	str	r3, [r7, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d13a:	68fb      	ldr	r3, [r7, #12]
 802d13c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d13e:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 802d140:	2300      	movs	r3, #0
 802d142:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802d144:	e031      	b.n	802d1aa <color_quantize3+0x9e>
    ptrin = input_buf[row];
 802d146:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d148:	009b      	lsls	r3, r3, #2
 802d14a:	68ba      	ldr	r2, [r7, #8]
 802d14c:	4413      	add	r3, r2
 802d14e:	681c      	ldr	r4, [r3, #0]
    ptrout = output_buf[row];
 802d150:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d152:	009b      	lsls	r3, r3, #2
 802d154:	687a      	ldr	r2, [r7, #4]
 802d156:	4413      	add	r3, r2
 802d158:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 802d15a:	697b      	ldr	r3, [r7, #20]
 802d15c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802d15e:	e01e      	b.n	802d19e <color_quantize3+0x92>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
 802d160:	4623      	mov	r3, r4
 802d162:	1c5c      	adds	r4, r3, #1
 802d164:	781b      	ldrb	r3, [r3, #0]
 802d166:	461a      	mov	r2, r3
 802d168:	6a3b      	ldr	r3, [r7, #32]
 802d16a:	4413      	add	r3, r2
 802d16c:	781b      	ldrb	r3, [r3, #0]
 802d16e:	461d      	mov	r5, r3
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
 802d170:	4623      	mov	r3, r4
 802d172:	1c5c      	adds	r4, r3, #1
 802d174:	781b      	ldrb	r3, [r3, #0]
 802d176:	461a      	mov	r2, r3
 802d178:	69fb      	ldr	r3, [r7, #28]
 802d17a:	4413      	add	r3, r2
 802d17c:	781b      	ldrb	r3, [r3, #0]
 802d17e:	441d      	add	r5, r3
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
 802d180:	4623      	mov	r3, r4
 802d182:	1c5c      	adds	r4, r3, #1
 802d184:	781b      	ldrb	r3, [r3, #0]
 802d186:	461a      	mov	r2, r3
 802d188:	69bb      	ldr	r3, [r7, #24]
 802d18a:	4413      	add	r3, r2
 802d18c:	781b      	ldrb	r3, [r3, #0]
 802d18e:	441d      	add	r5, r3
      *ptrout++ = (JSAMPLE) pixcode;
 802d190:	4633      	mov	r3, r6
 802d192:	1c5e      	adds	r6, r3, #1
 802d194:	b2ea      	uxtb	r2, r5
 802d196:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802d198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d19a:	3b01      	subs	r3, #1
 802d19c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802d19e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d1a0:	2b00      	cmp	r3, #0
 802d1a2:	d1dd      	bne.n	802d160 <color_quantize3+0x54>
  for (row = 0; row < num_rows; row++) {
 802d1a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d1a6:	3301      	adds	r3, #1
 802d1a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802d1aa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802d1ac:	683b      	ldr	r3, [r7, #0]
 802d1ae:	429a      	cmp	r2, r3
 802d1b0:	dbc9      	blt.n	802d146 <color_quantize3+0x3a>
    }
  }
}
 802d1b2:	bf00      	nop
 802d1b4:	bf00      	nop
 802d1b6:	3730      	adds	r7, #48	@ 0x30
 802d1b8:	46bd      	mov	sp, r7
 802d1ba:	bcf0      	pop	{r4, r5, r6, r7}
 802d1bc:	4770      	bx	lr

0802d1be <quantize_ord_dither>:

METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
 802d1be:	b5b0      	push	{r4, r5, r7, lr}
 802d1c0:	b08e      	sub	sp, #56	@ 0x38
 802d1c2:	af00      	add	r7, sp, #0
 802d1c4:	60f8      	str	r0, [r7, #12]
 802d1c6:	60b9      	str	r1, [r7, #8]
 802d1c8:	607a      	str	r2, [r7, #4]
 802d1ca:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d1cc:	68fb      	ldr	r3, [r7, #12]
 802d1ce:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d1d2:	627b      	str	r3, [r7, #36]	@ 0x24
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
 802d1d4:	68fb      	ldr	r3, [r7, #12]
 802d1d6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d1d8:	623b      	str	r3, [r7, #32]
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d1da:	68fb      	ldr	r3, [r7, #12]
 802d1dc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d1de:	61fb      	str	r3, [r7, #28]

  for (row = 0; row < num_rows; row++) {
 802d1e0:	2300      	movs	r3, #0
 802d1e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802d1e4:	e061      	b.n	802d2aa <quantize_ord_dither+0xec>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 802d1e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d1e8:	009b      	lsls	r3, r3, #2
 802d1ea:	687a      	ldr	r2, [r7, #4]
 802d1ec:	4413      	add	r3, r2
 802d1ee:	681b      	ldr	r3, [r3, #0]
 802d1f0:	69fa      	ldr	r2, [r7, #28]
 802d1f2:	2100      	movs	r1, #0
 802d1f4:	4618      	mov	r0, r3
 802d1f6:	f002 fbd3 	bl	802f9a0 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
 802d1fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d1fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802d1fe:	61bb      	str	r3, [r7, #24]
    for (ci = 0; ci < nc; ci++) {
 802d200:	2300      	movs	r3, #0
 802d202:	633b      	str	r3, [r7, #48]	@ 0x30
 802d204:	e042      	b.n	802d28c <quantize_ord_dither+0xce>
      input_ptr = input_buf[row] + ci;
 802d206:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d208:	009b      	lsls	r3, r3, #2
 802d20a:	68ba      	ldr	r2, [r7, #8]
 802d20c:	4413      	add	r3, r2
 802d20e:	681a      	ldr	r2, [r3, #0]
 802d210:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d212:	18d5      	adds	r5, r2, r3
      output_ptr = output_buf[row];
 802d214:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d216:	009b      	lsls	r3, r3, #2
 802d218:	687a      	ldr	r2, [r7, #4]
 802d21a:	4413      	add	r3, r2
 802d21c:	681c      	ldr	r4, [r3, #0]
      colorindex_ci = cquantize->colorindex[ci];
 802d21e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d220:	699a      	ldr	r2, [r3, #24]
 802d222:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d224:	009b      	lsls	r3, r3, #2
 802d226:	4413      	add	r3, r2
 802d228:	681b      	ldr	r3, [r3, #0]
 802d22a:	617b      	str	r3, [r7, #20]
      dither = cquantize->odither[ci][row_index];
 802d22c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802d22e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d230:	330c      	adds	r3, #12
 802d232:	009b      	lsls	r3, r3, #2
 802d234:	4413      	add	r3, r2
 802d236:	685a      	ldr	r2, [r3, #4]
 802d238:	69bb      	ldr	r3, [r7, #24]
 802d23a:	019b      	lsls	r3, r3, #6
 802d23c:	4413      	add	r3, r2
 802d23e:	613b      	str	r3, [r7, #16]
      col_index = 0;
 802d240:	2300      	movs	r3, #0
 802d242:	637b      	str	r3, [r7, #52]	@ 0x34

      for (col = width; col > 0; col--) {
 802d244:	69fb      	ldr	r3, [r7, #28]
 802d246:	62bb      	str	r3, [r7, #40]	@ 0x28
 802d248:	e01a      	b.n	802d280 <quantize_ord_dither+0xc2>
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
 802d24a:	7822      	ldrb	r2, [r4, #0]
 802d24c:	782b      	ldrb	r3, [r5, #0]
 802d24e:	4618      	mov	r0, r3
 802d250:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d252:	009b      	lsls	r3, r3, #2
 802d254:	6939      	ldr	r1, [r7, #16]
 802d256:	440b      	add	r3, r1
 802d258:	681b      	ldr	r3, [r3, #0]
 802d25a:	4403      	add	r3, r0
 802d25c:	4619      	mov	r1, r3
 802d25e:	697b      	ldr	r3, [r7, #20]
 802d260:	440b      	add	r3, r1
 802d262:	781b      	ldrb	r3, [r3, #0]
 802d264:	4413      	add	r3, r2
 802d266:	b2db      	uxtb	r3, r3
 802d268:	7023      	strb	r3, [r4, #0]
	input_ptr += nc;
 802d26a:	6a3b      	ldr	r3, [r7, #32]
 802d26c:	441d      	add	r5, r3
	output_ptr++;
 802d26e:	3401      	adds	r4, #1
	col_index = (col_index + 1) & ODITHER_MASK;
 802d270:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d272:	3301      	adds	r3, #1
 802d274:	f003 030f 	and.w	r3, r3, #15
 802d278:	637b      	str	r3, [r7, #52]	@ 0x34
      for (col = width; col > 0; col--) {
 802d27a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d27c:	3b01      	subs	r3, #1
 802d27e:	62bb      	str	r3, [r7, #40]	@ 0x28
 802d280:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d282:	2b00      	cmp	r3, #0
 802d284:	d1e1      	bne.n	802d24a <quantize_ord_dither+0x8c>
    for (ci = 0; ci < nc; ci++) {
 802d286:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d288:	3301      	adds	r3, #1
 802d28a:	633b      	str	r3, [r7, #48]	@ 0x30
 802d28c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d28e:	6a3b      	ldr	r3, [r7, #32]
 802d290:	429a      	cmp	r2, r3
 802d292:	dbb8      	blt.n	802d206 <quantize_ord_dither+0x48>
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
 802d294:	69bb      	ldr	r3, [r7, #24]
 802d296:	3301      	adds	r3, #1
 802d298:	f003 030f 	and.w	r3, r3, #15
 802d29c:	61bb      	str	r3, [r7, #24]
    cquantize->row_index = row_index;
 802d29e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d2a0:	69ba      	ldr	r2, [r7, #24]
 802d2a2:	631a      	str	r2, [r3, #48]	@ 0x30
  for (row = 0; row < num_rows; row++) {
 802d2a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d2a6:	3301      	adds	r3, #1
 802d2a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802d2aa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802d2ac:	683b      	ldr	r3, [r7, #0]
 802d2ae:	429a      	cmp	r2, r3
 802d2b0:	db99      	blt.n	802d1e6 <quantize_ord_dither+0x28>
  }
}
 802d2b2:	bf00      	nop
 802d2b4:	bf00      	nop
 802d2b6:	3738      	adds	r7, #56	@ 0x38
 802d2b8:	46bd      	mov	sp, r7
 802d2ba:	bdb0      	pop	{r4, r5, r7, pc}

0802d2bc <quantize3_ord_dither>:

METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
 802d2bc:	b4f0      	push	{r4, r5, r6, r7}
 802d2be:	b090      	sub	sp, #64	@ 0x40
 802d2c0:	af00      	add	r7, sp, #0
 802d2c2:	60f8      	str	r0, [r7, #12]
 802d2c4:	60b9      	str	r1, [r7, #8]
 802d2c6:	607a      	str	r2, [r7, #4]
 802d2c8:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d2ca:	68fb      	ldr	r3, [r7, #12]
 802d2cc:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d2d0:	633b      	str	r3, [r7, #48]	@ 0x30
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 802d2d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d2d4:	699b      	ldr	r3, [r3, #24]
 802d2d6:	681b      	ldr	r3, [r3, #0]
 802d2d8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 802d2da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d2dc:	699b      	ldr	r3, [r3, #24]
 802d2de:	685b      	ldr	r3, [r3, #4]
 802d2e0:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 802d2e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d2e4:	699b      	ldr	r3, [r3, #24]
 802d2e6:	689b      	ldr	r3, [r3, #8]
 802d2e8:	627b      	str	r3, [r7, #36]	@ 0x24
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d2ea:	68fb      	ldr	r3, [r7, #12]
 802d2ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d2ee:	623b      	str	r3, [r7, #32]

  for (row = 0; row < num_rows; row++) {
 802d2f0:	2300      	movs	r3, #0
 802d2f2:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d2f4:	e06a      	b.n	802d3cc <quantize3_ord_dither+0x110>
    row_index = cquantize->row_index;
 802d2f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d2f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802d2fa:	61fb      	str	r3, [r7, #28]
    input_ptr = input_buf[row];
 802d2fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d2fe:	009b      	lsls	r3, r3, #2
 802d300:	68ba      	ldr	r2, [r7, #8]
 802d302:	4413      	add	r3, r2
 802d304:	681c      	ldr	r4, [r3, #0]
    output_ptr = output_buf[row];
 802d306:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d308:	009b      	lsls	r3, r3, #2
 802d30a:	687a      	ldr	r2, [r7, #4]
 802d30c:	4413      	add	r3, r2
 802d30e:	681e      	ldr	r6, [r3, #0]
    dither0 = cquantize->odither[0][row_index];
 802d310:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d312:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 802d314:	69fb      	ldr	r3, [r7, #28]
 802d316:	019b      	lsls	r3, r3, #6
 802d318:	4413      	add	r3, r2
 802d31a:	61bb      	str	r3, [r7, #24]
    dither1 = cquantize->odither[1][row_index];
 802d31c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d31e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 802d320:	69fb      	ldr	r3, [r7, #28]
 802d322:	019b      	lsls	r3, r3, #6
 802d324:	4413      	add	r3, r2
 802d326:	617b      	str	r3, [r7, #20]
    dither2 = cquantize->odither[2][row_index];
 802d328:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d32a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 802d32c:	69fb      	ldr	r3, [r7, #28]
 802d32e:	019b      	lsls	r3, r3, #6
 802d330:	4413      	add	r3, r2
 802d332:	613b      	str	r3, [r7, #16]
    col_index = 0;
 802d334:	2300      	movs	r3, #0
 802d336:	63fb      	str	r3, [r7, #60]	@ 0x3c

    for (col = width; col > 0; col--) {
 802d338:	6a3b      	ldr	r3, [r7, #32]
 802d33a:	637b      	str	r3, [r7, #52]	@ 0x34
 802d33c:	e038      	b.n	802d3b0 <quantize3_ord_dither+0xf4>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
 802d33e:	4623      	mov	r3, r4
 802d340:	1c5c      	adds	r4, r3, #1
 802d342:	781b      	ldrb	r3, [r3, #0]
 802d344:	4619      	mov	r1, r3
 802d346:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d348:	009b      	lsls	r3, r3, #2
 802d34a:	69ba      	ldr	r2, [r7, #24]
 802d34c:	4413      	add	r3, r2
 802d34e:	681b      	ldr	r3, [r3, #0]
 802d350:	440b      	add	r3, r1
 802d352:	461a      	mov	r2, r3
 802d354:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d356:	4413      	add	r3, r2
 802d358:	781b      	ldrb	r3, [r3, #0]
 802d35a:	461d      	mov	r5, r3
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
 802d35c:	4623      	mov	r3, r4
 802d35e:	1c5c      	adds	r4, r3, #1
 802d360:	781b      	ldrb	r3, [r3, #0]
 802d362:	4619      	mov	r1, r3
 802d364:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d366:	009b      	lsls	r3, r3, #2
 802d368:	697a      	ldr	r2, [r7, #20]
 802d36a:	4413      	add	r3, r2
 802d36c:	681b      	ldr	r3, [r3, #0]
 802d36e:	440b      	add	r3, r1
 802d370:	461a      	mov	r2, r3
 802d372:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d374:	4413      	add	r3, r2
 802d376:	781b      	ldrb	r3, [r3, #0]
 802d378:	441d      	add	r5, r3
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
 802d37a:	4623      	mov	r3, r4
 802d37c:	1c5c      	adds	r4, r3, #1
 802d37e:	781b      	ldrb	r3, [r3, #0]
 802d380:	4619      	mov	r1, r3
 802d382:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d384:	009b      	lsls	r3, r3, #2
 802d386:	693a      	ldr	r2, [r7, #16]
 802d388:	4413      	add	r3, r2
 802d38a:	681b      	ldr	r3, [r3, #0]
 802d38c:	440b      	add	r3, r1
 802d38e:	461a      	mov	r2, r3
 802d390:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d392:	4413      	add	r3, r2
 802d394:	781b      	ldrb	r3, [r3, #0]
 802d396:	441d      	add	r5, r3
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
 802d398:	4633      	mov	r3, r6
 802d39a:	1c5e      	adds	r6, r3, #1
 802d39c:	b2ea      	uxtb	r2, r5
 802d39e:	701a      	strb	r2, [r3, #0]
      col_index = (col_index + 1) & ODITHER_MASK;
 802d3a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d3a2:	3301      	adds	r3, #1
 802d3a4:	f003 030f 	and.w	r3, r3, #15
 802d3a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    for (col = width; col > 0; col--) {
 802d3aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d3ac:	3b01      	subs	r3, #1
 802d3ae:	637b      	str	r3, [r7, #52]	@ 0x34
 802d3b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d3b2:	2b00      	cmp	r3, #0
 802d3b4:	d1c3      	bne.n	802d33e <quantize3_ord_dither+0x82>
    }
    row_index = (row_index + 1) & ODITHER_MASK;
 802d3b6:	69fb      	ldr	r3, [r7, #28]
 802d3b8:	3301      	adds	r3, #1
 802d3ba:	f003 030f 	and.w	r3, r3, #15
 802d3be:	61fb      	str	r3, [r7, #28]
    cquantize->row_index = row_index;
 802d3c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d3c2:	69fa      	ldr	r2, [r7, #28]
 802d3c4:	631a      	str	r2, [r3, #48]	@ 0x30
  for (row = 0; row < num_rows; row++) {
 802d3c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d3c8:	3301      	adds	r3, #1
 802d3ca:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d3cc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802d3ce:	683b      	ldr	r3, [r7, #0]
 802d3d0:	429a      	cmp	r2, r3
 802d3d2:	db90      	blt.n	802d2f6 <quantize3_ord_dither+0x3a>
  }
}
 802d3d4:	bf00      	nop
 802d3d6:	bf00      	nop
 802d3d8:	3740      	adds	r7, #64	@ 0x40
 802d3da:	46bd      	mov	sp, r7
 802d3dc:	bcf0      	pop	{r4, r5, r6, r7}
 802d3de:	4770      	bx	lr

0802d3e0 <quantize_fs_dither>:

METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
 802d3e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d3e4:	b094      	sub	sp, #80	@ 0x50
 802d3e6:	af00      	add	r7, sp, #0
 802d3e8:	60f8      	str	r0, [r7, #12]
 802d3ea:	60b9      	str	r1, [r7, #8]
 802d3ec:	607a      	str	r2, [r7, #4]
 802d3ee:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d3f0:	68fb      	ldr	r3, [r7, #12]
 802d3f2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d3f6:	633b      	str	r3, [r7, #48]	@ 0x30
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
 802d3f8:	68fb      	ldr	r3, [r7, #12]
 802d3fa:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d3fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d3fe:	68fb      	ldr	r3, [r7, #12]
 802d400:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d402:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 802d404:	68fb      	ldr	r3, [r7, #12]
 802d406:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802d40a:	627b      	str	r3, [r7, #36]	@ 0x24
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 802d40c:	2300      	movs	r3, #0
 802d40e:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d410:	e0b1      	b.n	802d576 <quantize_fs_dither+0x196>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 802d412:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d414:	009b      	lsls	r3, r3, #2
 802d416:	687a      	ldr	r2, [r7, #4]
 802d418:	4413      	add	r3, r2
 802d41a:	681b      	ldr	r3, [r3, #0]
 802d41c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802d41e:	2100      	movs	r1, #0
 802d420:	4618      	mov	r0, r3
 802d422:	f002 fabd 	bl	802f9a0 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
 802d426:	2300      	movs	r3, #0
 802d428:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802d42a:	e092      	b.n	802d552 <quantize_fs_dither+0x172>
      input_ptr = input_buf[row] + ci;
 802d42c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d42e:	009b      	lsls	r3, r3, #2
 802d430:	68ba      	ldr	r2, [r7, #8]
 802d432:	4413      	add	r3, r2
 802d434:	681a      	ldr	r2, [r3, #0]
 802d436:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d438:	eb02 0803 	add.w	r8, r2, r3
      output_ptr = output_buf[row];
 802d43c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d43e:	009b      	lsls	r3, r3, #2
 802d440:	687a      	ldr	r2, [r7, #4]
 802d442:	4413      	add	r3, r2
 802d444:	681e      	ldr	r6, [r3, #0]
      if (cquantize->on_odd_row) {
 802d446:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d448:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802d44a:	2b00      	cmp	r3, #0
 802d44c:	d019      	beq.n	802d482 <quantize_fs_dither+0xa2>
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
 802d44e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d450:	3b01      	subs	r3, #1
 802d452:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802d454:	fb02 f303 	mul.w	r3, r2, r3
 802d458:	4498      	add	r8, r3
	output_ptr += width-1;
 802d45a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d45c:	3b01      	subs	r3, #1
 802d45e:	441e      	add	r6, r3
	dir = -1;
 802d460:	f04f 33ff 	mov.w	r3, #4294967295
 802d464:	647b      	str	r3, [r7, #68]	@ 0x44
	dirnc = -nc;
 802d466:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d468:	425b      	negs	r3, r3
 802d46a:	643b      	str	r3, [r7, #64]	@ 0x40
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
 802d46c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d46e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d470:	3310      	adds	r3, #16
 802d472:	009b      	lsls	r3, r3, #2
 802d474:	4413      	add	r3, r2
 802d476:	685a      	ldr	r2, [r3, #4]
 802d478:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d47a:	3301      	adds	r3, #1
 802d47c:	005b      	lsls	r3, r3, #1
 802d47e:	18d5      	adds	r5, r2, r3
 802d480:	e009      	b.n	802d496 <quantize_fs_dither+0xb6>
      } else {
	/* work left to right in this row */
	dir = 1;
 802d482:	2301      	movs	r3, #1
 802d484:	647b      	str	r3, [r7, #68]	@ 0x44
	dirnc = nc;
 802d486:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d488:	643b      	str	r3, [r7, #64]	@ 0x40
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
 802d48a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d48c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d48e:	3310      	adds	r3, #16
 802d490:	009b      	lsls	r3, r3, #2
 802d492:	4413      	add	r3, r2
 802d494:	685d      	ldr	r5, [r3, #4]
      }
      colorindex_ci = cquantize->colorindex[ci];
 802d496:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d498:	699a      	ldr	r2, [r3, #24]
 802d49a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d49c:	009b      	lsls	r3, r3, #2
 802d49e:	4413      	add	r3, r2
 802d4a0:	681b      	ldr	r3, [r3, #0]
 802d4a2:	623b      	str	r3, [r7, #32]
      colormap_ci = cquantize->sv_colormap[ci];
 802d4a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d4a6:	691a      	ldr	r2, [r3, #16]
 802d4a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d4aa:	009b      	lsls	r3, r3, #2
 802d4ac:	4413      	add	r3, r2
 802d4ae:	681b      	ldr	r3, [r3, #0]
 802d4b0:	61fb      	str	r3, [r7, #28]
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
 802d4b2:	2400      	movs	r4, #0
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;
 802d4b4:	2300      	movs	r3, #0
 802d4b6:	64bb      	str	r3, [r7, #72]	@ 0x48
 802d4b8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802d4ba:	64fb      	str	r3, [r7, #76]	@ 0x4c

      for (col = width; col > 0; col--) {
 802d4bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d4be:	637b      	str	r3, [r7, #52]	@ 0x34
 802d4c0:	e03e      	b.n	802d540 <quantize_fs_dither+0x160>
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
 802d4c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802d4c4:	005b      	lsls	r3, r3, #1
 802d4c6:	442b      	add	r3, r5
 802d4c8:	f9b3 3000 	ldrsh.w	r3, [r3]
 802d4cc:	4423      	add	r3, r4
 802d4ce:	3308      	adds	r3, #8
 802d4d0:	111c      	asrs	r4, r3, #4
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
 802d4d2:	f898 3000 	ldrb.w	r3, [r8]
 802d4d6:	441c      	add	r4, r3
	cur = GETJSAMPLE(range_limit[cur]);
 802d4d8:	4622      	mov	r2, r4
 802d4da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d4dc:	4413      	add	r3, r2
 802d4de:	781b      	ldrb	r3, [r3, #0]
 802d4e0:	461c      	mov	r4, r3
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
 802d4e2:	4622      	mov	r2, r4
 802d4e4:	6a3b      	ldr	r3, [r7, #32]
 802d4e6:	4413      	add	r3, r2
 802d4e8:	781b      	ldrb	r3, [r3, #0]
 802d4ea:	61bb      	str	r3, [r7, #24]
	*output_ptr += (JSAMPLE) pixcode;
 802d4ec:	7832      	ldrb	r2, [r6, #0]
 802d4ee:	69bb      	ldr	r3, [r7, #24]
 802d4f0:	b2db      	uxtb	r3, r3
 802d4f2:	4413      	add	r3, r2
 802d4f4:	b2db      	uxtb	r3, r3
 802d4f6:	7033      	strb	r3, [r6, #0]
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
 802d4f8:	69bb      	ldr	r3, [r7, #24]
 802d4fa:	69fa      	ldr	r2, [r7, #28]
 802d4fc:	4413      	add	r3, r2
 802d4fe:	781b      	ldrb	r3, [r3, #0]
 802d500:	1ae4      	subs	r4, r4, r3
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
 802d502:	617c      	str	r4, [r7, #20]
	delta = cur * 2;
 802d504:	0063      	lsls	r3, r4, #1
 802d506:	613b      	str	r3, [r7, #16]
	cur += delta;		/* form error * 3 */
 802d508:	693b      	ldr	r3, [r7, #16]
 802d50a:	441c      	add	r4, r3
	errorptr[0] = (FSERROR) (bpreverr + cur);
 802d50c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802d50e:	b29a      	uxth	r2, r3
 802d510:	b2a3      	uxth	r3, r4
 802d512:	4413      	add	r3, r2
 802d514:	b29b      	uxth	r3, r3
 802d516:	b21b      	sxth	r3, r3
 802d518:	802b      	strh	r3, [r5, #0]
	cur += delta;		/* form error * 5 */
 802d51a:	693b      	ldr	r3, [r7, #16]
 802d51c:	441c      	add	r4, r3
	bpreverr = belowerr + cur;
 802d51e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802d520:	4423      	add	r3, r4
 802d522:	64bb      	str	r3, [r7, #72]	@ 0x48
	belowerr = bnexterr;
 802d524:	697b      	ldr	r3, [r7, #20]
 802d526:	64fb      	str	r3, [r7, #76]	@ 0x4c
	cur += delta;		/* form error * 7 */
 802d528:	693b      	ldr	r3, [r7, #16]
 802d52a:	441c      	add	r4, r3
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
 802d52c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d52e:	4498      	add	r8, r3
	output_ptr += dir;	/* advance output ptr to next column */
 802d530:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802d532:	441e      	add	r6, r3
	errorptr += dir;	/* advance errorptr to current column */
 802d534:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802d536:	005b      	lsls	r3, r3, #1
 802d538:	441d      	add	r5, r3
      for (col = width; col > 0; col--) {
 802d53a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d53c:	3b01      	subs	r3, #1
 802d53e:	637b      	str	r3, [r7, #52]	@ 0x34
 802d540:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d542:	2b00      	cmp	r3, #0
 802d544:	d1bd      	bne.n	802d4c2 <quantize_fs_dither+0xe2>
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
 802d546:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802d548:	b21b      	sxth	r3, r3
 802d54a:	802b      	strh	r3, [r5, #0]
    for (ci = 0; ci < nc; ci++) {
 802d54c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d54e:	3301      	adds	r3, #1
 802d550:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802d552:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802d554:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d556:	429a      	cmp	r2, r3
 802d558:	f6ff af68 	blt.w	802d42c <quantize_fs_dither+0x4c>
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
 802d55c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d55e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 802d560:	2b00      	cmp	r3, #0
 802d562:	bf0c      	ite	eq
 802d564:	2301      	moveq	r3, #1
 802d566:	2300      	movne	r3, #0
 802d568:	b2db      	uxtb	r3, r3
 802d56a:	461a      	mov	r2, r3
 802d56c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d56e:	655a      	str	r2, [r3, #84]	@ 0x54
  for (row = 0; row < num_rows; row++) {
 802d570:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d572:	3301      	adds	r3, #1
 802d574:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d576:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802d578:	683b      	ldr	r3, [r7, #0]
 802d57a:	429a      	cmp	r2, r3
 802d57c:	f6ff af49 	blt.w	802d412 <quantize_fs_dither+0x32>
  }
}
 802d580:	bf00      	nop
 802d582:	bf00      	nop
 802d584:	3750      	adds	r7, #80	@ 0x50
 802d586:	46bd      	mov	sp, r7
 802d588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802d58c <alloc_fs_workspace>:
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
 802d58c:	b580      	push	{r7, lr}
 802d58e:	b086      	sub	sp, #24
 802d590:	af00      	add	r7, sp, #0
 802d592:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d594:	687b      	ldr	r3, [r7, #4]
 802d596:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d59a:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 802d59c:	687b      	ldr	r3, [r7, #4]
 802d59e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d5a0:	3302      	adds	r3, #2
 802d5a2:	005b      	lsls	r3, r3, #1
 802d5a4:	60fb      	str	r3, [r7, #12]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802d5a6:	2300      	movs	r3, #0
 802d5a8:	617b      	str	r3, [r7, #20]
 802d5aa:	e010      	b.n	802d5ce <alloc_fs_workspace+0x42>
    cquantize->fserrors[i] = (FSERRPTR)
      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
 802d5ac:	687b      	ldr	r3, [r7, #4]
 802d5ae:	685b      	ldr	r3, [r3, #4]
 802d5b0:	685b      	ldr	r3, [r3, #4]
 802d5b2:	68fa      	ldr	r2, [r7, #12]
 802d5b4:	2101      	movs	r1, #1
 802d5b6:	6878      	ldr	r0, [r7, #4]
 802d5b8:	4798      	blx	r3
 802d5ba:	4601      	mov	r1, r0
    cquantize->fserrors[i] = (FSERRPTR)
 802d5bc:	693a      	ldr	r2, [r7, #16]
 802d5be:	697b      	ldr	r3, [r7, #20]
 802d5c0:	3310      	adds	r3, #16
 802d5c2:	009b      	lsls	r3, r3, #2
 802d5c4:	4413      	add	r3, r2
 802d5c6:	6059      	str	r1, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802d5c8:	697b      	ldr	r3, [r7, #20]
 802d5ca:	3301      	adds	r3, #1
 802d5cc:	617b      	str	r3, [r7, #20]
 802d5ce:	687b      	ldr	r3, [r7, #4]
 802d5d0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d5d2:	697a      	ldr	r2, [r7, #20]
 802d5d4:	429a      	cmp	r2, r3
 802d5d6:	dbe9      	blt.n	802d5ac <alloc_fs_workspace+0x20>
  }
}
 802d5d8:	bf00      	nop
 802d5da:	bf00      	nop
 802d5dc:	3718      	adds	r7, #24
 802d5de:	46bd      	mov	sp, r7
 802d5e0:	bd80      	pop	{r7, pc}
	...

0802d5e4 <start_pass_1_quant>:
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 802d5e4:	b580      	push	{r7, lr}
 802d5e6:	b086      	sub	sp, #24
 802d5e8:	af00      	add	r7, sp, #0
 802d5ea:	6078      	str	r0, [r7, #4]
 802d5ec:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d5ee:	687b      	ldr	r3, [r7, #4]
 802d5f0:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d5f4:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
 802d5f6:	693b      	ldr	r3, [r7, #16]
 802d5f8:	691a      	ldr	r2, [r3, #16]
 802d5fa:	687b      	ldr	r3, [r7, #4]
 802d5fc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  cinfo->actual_number_of_colors = cquantize->sv_actual;
 802d600:	693b      	ldr	r3, [r7, #16]
 802d602:	695a      	ldr	r2, [r3, #20]
 802d604:	687b      	ldr	r3, [r7, #4]
 802d606:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
 802d60a:	687b      	ldr	r3, [r7, #4]
 802d60c:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802d610:	2b02      	cmp	r3, #2
 802d612:	d02f      	beq.n	802d674 <start_pass_1_quant+0x90>
 802d614:	2b02      	cmp	r3, #2
 802d616:	dc56      	bgt.n	802d6c6 <start_pass_1_quant+0xe2>
 802d618:	2b00      	cmp	r3, #0
 802d61a:	d002      	beq.n	802d622 <start_pass_1_quant+0x3e>
 802d61c:	2b01      	cmp	r3, #1
 802d61e:	d00c      	beq.n	802d63a <start_pass_1_quant+0x56>
 802d620:	e051      	b.n	802d6c6 <start_pass_1_quant+0xe2>
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
 802d622:	687b      	ldr	r3, [r7, #4]
 802d624:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d626:	2b03      	cmp	r3, #3
 802d628:	d103      	bne.n	802d632 <start_pass_1_quant+0x4e>
      cquantize->pub.color_quantize = color_quantize3;
 802d62a:	693b      	ldr	r3, [r7, #16]
 802d62c:	4a2d      	ldr	r2, [pc, #180]	@ (802d6e4 <start_pass_1_quant+0x100>)
 802d62e:	605a      	str	r2, [r3, #4]
    else
      cquantize->pub.color_quantize = color_quantize;
    break;
 802d630:	e054      	b.n	802d6dc <start_pass_1_quant+0xf8>
      cquantize->pub.color_quantize = color_quantize;
 802d632:	693b      	ldr	r3, [r7, #16]
 802d634:	4a2c      	ldr	r2, [pc, #176]	@ (802d6e8 <start_pass_1_quant+0x104>)
 802d636:	605a      	str	r2, [r3, #4]
    break;
 802d638:	e050      	b.n	802d6dc <start_pass_1_quant+0xf8>
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
 802d63a:	687b      	ldr	r3, [r7, #4]
 802d63c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d63e:	2b03      	cmp	r3, #3
 802d640:	d103      	bne.n	802d64a <start_pass_1_quant+0x66>
      cquantize->pub.color_quantize = quantize3_ord_dither;
 802d642:	693b      	ldr	r3, [r7, #16]
 802d644:	4a29      	ldr	r2, [pc, #164]	@ (802d6ec <start_pass_1_quant+0x108>)
 802d646:	605a      	str	r2, [r3, #4]
 802d648:	e002      	b.n	802d650 <start_pass_1_quant+0x6c>
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
 802d64a:	693b      	ldr	r3, [r7, #16]
 802d64c:	4a28      	ldr	r2, [pc, #160]	@ (802d6f0 <start_pass_1_quant+0x10c>)
 802d64e:	605a      	str	r2, [r3, #4]
    cquantize->row_index = 0;	/* initialize state for ordered dither */
 802d650:	693b      	ldr	r3, [r7, #16]
 802d652:	2200      	movs	r2, #0
 802d654:	631a      	str	r2, [r3, #48]	@ 0x30
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
 802d656:	693b      	ldr	r3, [r7, #16]
 802d658:	69db      	ldr	r3, [r3, #28]
 802d65a:	2b00      	cmp	r3, #0
 802d65c:	d102      	bne.n	802d664 <start_pass_1_quant+0x80>
      create_colorindex(cinfo);
 802d65e:	6878      	ldr	r0, [r7, #4]
 802d660:	f7ff fbc6 	bl	802cdf0 <create_colorindex>
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
 802d664:	693b      	ldr	r3, [r7, #16]
 802d666:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 802d668:	2b00      	cmp	r3, #0
 802d66a:	d136      	bne.n	802d6da <start_pass_1_quant+0xf6>
      create_odither_tables(cinfo);
 802d66c:	6878      	ldr	r0, [r7, #4]
 802d66e:	f7ff fcb5 	bl	802cfdc <create_odither_tables>
    break;
 802d672:	e032      	b.n	802d6da <start_pass_1_quant+0xf6>
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
 802d674:	693b      	ldr	r3, [r7, #16]
 802d676:	4a1f      	ldr	r2, [pc, #124]	@ (802d6f4 <start_pass_1_quant+0x110>)
 802d678:	605a      	str	r2, [r3, #4]
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
 802d67a:	693b      	ldr	r3, [r7, #16]
 802d67c:	2200      	movs	r2, #0
 802d67e:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
 802d680:	693b      	ldr	r3, [r7, #16]
 802d682:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 802d684:	2b00      	cmp	r3, #0
 802d686:	d102      	bne.n	802d68e <start_pass_1_quant+0xaa>
      alloc_fs_workspace(cinfo);
 802d688:	6878      	ldr	r0, [r7, #4]
 802d68a:	f7ff ff7f 	bl	802d58c <alloc_fs_workspace>
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 802d68e:	687b      	ldr	r3, [r7, #4]
 802d690:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d692:	3302      	adds	r3, #2
 802d694:	005b      	lsls	r3, r3, #1
 802d696:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < cinfo->out_color_components; i++)
 802d698:	2300      	movs	r3, #0
 802d69a:	617b      	str	r3, [r7, #20]
 802d69c:	e00d      	b.n	802d6ba <start_pass_1_quant+0xd6>
      FMEMZERO((void FAR *) cquantize->fserrors[i], arraysize);
 802d69e:	693a      	ldr	r2, [r7, #16]
 802d6a0:	697b      	ldr	r3, [r7, #20]
 802d6a2:	3310      	adds	r3, #16
 802d6a4:	009b      	lsls	r3, r3, #2
 802d6a6:	4413      	add	r3, r2
 802d6a8:	685b      	ldr	r3, [r3, #4]
 802d6aa:	68fa      	ldr	r2, [r7, #12]
 802d6ac:	2100      	movs	r1, #0
 802d6ae:	4618      	mov	r0, r3
 802d6b0:	f002 f976 	bl	802f9a0 <memset>
    for (i = 0; i < cinfo->out_color_components; i++)
 802d6b4:	697b      	ldr	r3, [r7, #20]
 802d6b6:	3301      	adds	r3, #1
 802d6b8:	617b      	str	r3, [r7, #20]
 802d6ba:	687b      	ldr	r3, [r7, #4]
 802d6bc:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d6be:	697a      	ldr	r2, [r7, #20]
 802d6c0:	429a      	cmp	r2, r3
 802d6c2:	dbec      	blt.n	802d69e <start_pass_1_quant+0xba>
    break;
 802d6c4:	e00a      	b.n	802d6dc <start_pass_1_quant+0xf8>
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
 802d6c6:	687b      	ldr	r3, [r7, #4]
 802d6c8:	681b      	ldr	r3, [r3, #0]
 802d6ca:	2231      	movs	r2, #49	@ 0x31
 802d6cc:	615a      	str	r2, [r3, #20]
 802d6ce:	687b      	ldr	r3, [r7, #4]
 802d6d0:	681b      	ldr	r3, [r3, #0]
 802d6d2:	681b      	ldr	r3, [r3, #0]
 802d6d4:	6878      	ldr	r0, [r7, #4]
 802d6d6:	4798      	blx	r3
    break;
 802d6d8:	e000      	b.n	802d6dc <start_pass_1_quant+0xf8>
    break;
 802d6da:	bf00      	nop
  }
}
 802d6dc:	bf00      	nop
 802d6de:	3718      	adds	r7, #24
 802d6e0:	46bd      	mov	sp, r7
 802d6e2:	bd80      	pop	{r7, pc}
 802d6e4:	0802d10d 	.word	0x0802d10d
 802d6e8:	0802d06f 	.word	0x0802d06f
 802d6ec:	0802d2bd 	.word	0x0802d2bd
 802d6f0:	0802d1bf 	.word	0x0802d1bf
 802d6f4:	0802d3e1 	.word	0x0802d3e1

0802d6f8 <finish_pass_1_quant>:
 * Finish up at the end of the pass.
 */

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
 802d6f8:	b480      	push	{r7}
 802d6fa:	b083      	sub	sp, #12
 802d6fc:	af00      	add	r7, sp, #0
 802d6fe:	6078      	str	r0, [r7, #4]
  /* no work in 1-pass case */
}
 802d700:	bf00      	nop
 802d702:	370c      	adds	r7, #12
 802d704:	46bd      	mov	sp, r7
 802d706:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d70a:	4770      	bx	lr

0802d70c <new_color_map_1_quant>:
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
 802d70c:	b580      	push	{r7, lr}
 802d70e:	b082      	sub	sp, #8
 802d710:	af00      	add	r7, sp, #0
 802d712:	6078      	str	r0, [r7, #4]
  ERREXIT(cinfo, JERR_MODE_CHANGE);
 802d714:	687b      	ldr	r3, [r7, #4]
 802d716:	681b      	ldr	r3, [r3, #0]
 802d718:	222f      	movs	r2, #47	@ 0x2f
 802d71a:	615a      	str	r2, [r3, #20]
 802d71c:	687b      	ldr	r3, [r7, #4]
 802d71e:	681b      	ldr	r3, [r3, #0]
 802d720:	681b      	ldr	r3, [r3, #0]
 802d722:	6878      	ldr	r0, [r7, #4]
 802d724:	4798      	blx	r3
}
 802d726:	bf00      	nop
 802d728:	3708      	adds	r7, #8
 802d72a:	46bd      	mov	sp, r7
 802d72c:	bd80      	pop	{r7, pc}
	...

0802d730 <jinit_1pass_quantizer>:
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
 802d730:	b580      	push	{r7, lr}
 802d732:	b084      	sub	sp, #16
 802d734:	af00      	add	r7, sp, #0
 802d736:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802d738:	687b      	ldr	r3, [r7, #4]
 802d73a:	685b      	ldr	r3, [r3, #4]
 802d73c:	681b      	ldr	r3, [r3, #0]
 802d73e:	2258      	movs	r2, #88	@ 0x58
 802d740:	2101      	movs	r1, #1
 802d742:	6878      	ldr	r0, [r7, #4]
 802d744:	4798      	blx	r3
 802d746:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 802d748:	687b      	ldr	r3, [r7, #4]
 802d74a:	68fa      	ldr	r2, [r7, #12]
 802d74c:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
  cquantize->pub.start_pass = start_pass_1_quant;
 802d750:	68fb      	ldr	r3, [r7, #12]
 802d752:	4a22      	ldr	r2, [pc, #136]	@ (802d7dc <jinit_1pass_quantizer+0xac>)
 802d754:	601a      	str	r2, [r3, #0]
  cquantize->pub.finish_pass = finish_pass_1_quant;
 802d756:	68fb      	ldr	r3, [r7, #12]
 802d758:	4a21      	ldr	r2, [pc, #132]	@ (802d7e0 <jinit_1pass_quantizer+0xb0>)
 802d75a:	609a      	str	r2, [r3, #8]
  cquantize->pub.new_color_map = new_color_map_1_quant;
 802d75c:	68fb      	ldr	r3, [r7, #12]
 802d75e:	4a21      	ldr	r2, [pc, #132]	@ (802d7e4 <jinit_1pass_quantizer+0xb4>)
 802d760:	60da      	str	r2, [r3, #12]
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
 802d762:	68fb      	ldr	r3, [r7, #12]
 802d764:	2200      	movs	r2, #0
 802d766:	645a      	str	r2, [r3, #68]	@ 0x44
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
 802d768:	68fb      	ldr	r3, [r7, #12]
 802d76a:	2200      	movs	r2, #0
 802d76c:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
 802d76e:	687b      	ldr	r3, [r7, #4]
 802d770:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802d772:	2b04      	cmp	r3, #4
 802d774:	dd0c      	ble.n	802d790 <jinit_1pass_quantizer+0x60>
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
 802d776:	687b      	ldr	r3, [r7, #4]
 802d778:	681b      	ldr	r3, [r3, #0]
 802d77a:	2239      	movs	r2, #57	@ 0x39
 802d77c:	615a      	str	r2, [r3, #20]
 802d77e:	687b      	ldr	r3, [r7, #4]
 802d780:	681b      	ldr	r3, [r3, #0]
 802d782:	2204      	movs	r2, #4
 802d784:	619a      	str	r2, [r3, #24]
 802d786:	687b      	ldr	r3, [r7, #4]
 802d788:	681b      	ldr	r3, [r3, #0]
 802d78a:	681b      	ldr	r3, [r3, #0]
 802d78c:	6878      	ldr	r0, [r7, #4]
 802d78e:	4798      	blx	r3
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
 802d790:	687b      	ldr	r3, [r7, #4]
 802d792:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802d794:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802d798:	dd0d      	ble.n	802d7b6 <jinit_1pass_quantizer+0x86>
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
 802d79a:	687b      	ldr	r3, [r7, #4]
 802d79c:	681b      	ldr	r3, [r3, #0]
 802d79e:	223b      	movs	r2, #59	@ 0x3b
 802d7a0:	615a      	str	r2, [r3, #20]
 802d7a2:	687b      	ldr	r3, [r7, #4]
 802d7a4:	681b      	ldr	r3, [r3, #0]
 802d7a6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802d7aa:	619a      	str	r2, [r3, #24]
 802d7ac:	687b      	ldr	r3, [r7, #4]
 802d7ae:	681b      	ldr	r3, [r3, #0]
 802d7b0:	681b      	ldr	r3, [r3, #0]
 802d7b2:	6878      	ldr	r0, [r7, #4]
 802d7b4:	4798      	blx	r3

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
 802d7b6:	6878      	ldr	r0, [r7, #4]
 802d7b8:	f7ff fa74 	bl	802cca4 <create_colormap>
  create_colorindex(cinfo);
 802d7bc:	6878      	ldr	r0, [r7, #4]
 802d7be:	f7ff fb17 	bl	802cdf0 <create_colorindex>
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
 802d7c2:	687b      	ldr	r3, [r7, #4]
 802d7c4:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802d7c8:	2b02      	cmp	r3, #2
 802d7ca:	d102      	bne.n	802d7d2 <jinit_1pass_quantizer+0xa2>
    alloc_fs_workspace(cinfo);
 802d7cc:	6878      	ldr	r0, [r7, #4]
 802d7ce:	f7ff fedd 	bl	802d58c <alloc_fs_workspace>
}
 802d7d2:	bf00      	nop
 802d7d4:	3710      	adds	r7, #16
 802d7d6:	46bd      	mov	sp, r7
 802d7d8:	bd80      	pop	{r7, pc}
 802d7da:	bf00      	nop
 802d7dc:	0802d5e5 	.word	0x0802d5e5
 802d7e0:	0802d6f9 	.word	0x0802d6f9
 802d7e4:	0802d70d 	.word	0x0802d70d

0802d7e8 <prescan_quantize>:
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
 802d7e8:	b4f0      	push	{r4, r5, r6, r7}
 802d7ea:	b088      	sub	sp, #32
 802d7ec:	af00      	add	r7, sp, #0
 802d7ee:	60f8      	str	r0, [r7, #12]
 802d7f0:	60b9      	str	r1, [r7, #8]
 802d7f2:	607a      	str	r2, [r7, #4]
 802d7f4:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d7f6:	68fb      	ldr	r3, [r7, #12]
 802d7f8:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d7fc:	617b      	str	r3, [r7, #20]
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
 802d7fe:	697b      	ldr	r3, [r7, #20]
 802d800:	699e      	ldr	r6, [r3, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802d802:	68fb      	ldr	r3, [r7, #12]
 802d804:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802d806:	613b      	str	r3, [r7, #16]

  for (row = 0; row < num_rows; row++) {
 802d808:	2300      	movs	r3, #0
 802d80a:	61fb      	str	r3, [r7, #28]
 802d80c:	e02e      	b.n	802d86c <prescan_quantize+0x84>
    ptr = input_buf[row];
 802d80e:	69fb      	ldr	r3, [r7, #28]
 802d810:	009b      	lsls	r3, r3, #2
 802d812:	68ba      	ldr	r2, [r7, #8]
 802d814:	4413      	add	r3, r2
 802d816:	681c      	ldr	r4, [r3, #0]
    for (col = width; col > 0; col--) {
 802d818:	693b      	ldr	r3, [r7, #16]
 802d81a:	61bb      	str	r3, [r7, #24]
 802d81c:	e020      	b.n	802d860 <prescan_quantize+0x78>
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 802d81e:	7823      	ldrb	r3, [r4, #0]
 802d820:	08db      	lsrs	r3, r3, #3
 802d822:	b2db      	uxtb	r3, r3
 802d824:	009b      	lsls	r3, r3, #2
 802d826:	4433      	add	r3, r6
 802d828:	681a      	ldr	r2, [r3, #0]
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
 802d82a:	1c63      	adds	r3, r4, #1
 802d82c:	781b      	ldrb	r3, [r3, #0]
 802d82e:	089b      	lsrs	r3, r3, #2
 802d830:	b2db      	uxtb	r3, r3
 802d832:	019b      	lsls	r3, r3, #6
 802d834:	441a      	add	r2, r3
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
 802d836:	1ca3      	adds	r3, r4, #2
 802d838:	781b      	ldrb	r3, [r3, #0]
 802d83a:	08db      	lsrs	r3, r3, #3
 802d83c:	b2db      	uxtb	r3, r3
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 802d83e:	005b      	lsls	r3, r3, #1
 802d840:	18d5      	adds	r5, r2, r3
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
 802d842:	882b      	ldrh	r3, [r5, #0]
 802d844:	3301      	adds	r3, #1
 802d846:	b29b      	uxth	r3, r3
 802d848:	802b      	strh	r3, [r5, #0]
 802d84a:	882b      	ldrh	r3, [r5, #0]
 802d84c:	2b00      	cmp	r3, #0
 802d84e:	d103      	bne.n	802d858 <prescan_quantize+0x70>
	(*histp)--;
 802d850:	882b      	ldrh	r3, [r5, #0]
 802d852:	3b01      	subs	r3, #1
 802d854:	b29b      	uxth	r3, r3
 802d856:	802b      	strh	r3, [r5, #0]
      ptr += 3;
 802d858:	3403      	adds	r4, #3
    for (col = width; col > 0; col--) {
 802d85a:	69bb      	ldr	r3, [r7, #24]
 802d85c:	3b01      	subs	r3, #1
 802d85e:	61bb      	str	r3, [r7, #24]
 802d860:	69bb      	ldr	r3, [r7, #24]
 802d862:	2b00      	cmp	r3, #0
 802d864:	d1db      	bne.n	802d81e <prescan_quantize+0x36>
  for (row = 0; row < num_rows; row++) {
 802d866:	69fb      	ldr	r3, [r7, #28]
 802d868:	3301      	adds	r3, #1
 802d86a:	61fb      	str	r3, [r7, #28]
 802d86c:	69fa      	ldr	r2, [r7, #28]
 802d86e:	683b      	ldr	r3, [r7, #0]
 802d870:	429a      	cmp	r2, r3
 802d872:	dbcc      	blt.n	802d80e <prescan_quantize+0x26>
    }
  }
}
 802d874:	bf00      	nop
 802d876:	bf00      	nop
 802d878:	3720      	adds	r7, #32
 802d87a:	46bd      	mov	sp, r7
 802d87c:	bcf0      	pop	{r4, r5, r6, r7}
 802d87e:	4770      	bx	lr

0802d880 <find_biggest_color_pop>:

LOCAL(boxptr)
find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
 802d880:	b4f0      	push	{r4, r5, r6, r7}
 802d882:	b084      	sub	sp, #16
 802d884:	af00      	add	r7, sp, #0
 802d886:	6078      	str	r0, [r7, #4]
 802d888:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register long maxc = 0;
 802d88a:	2600      	movs	r6, #0
  boxptr which = NULL;
 802d88c:	2300      	movs	r3, #0
 802d88e:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802d890:	2500      	movs	r5, #0
 802d892:	687c      	ldr	r4, [r7, #4]
 802d894:	e009      	b.n	802d8aa <find_biggest_color_pop+0x2a>
    if (boxp->colorcount > maxc && boxp->volume > 0) {
 802d896:	69e3      	ldr	r3, [r4, #28]
 802d898:	429e      	cmp	r6, r3
 802d89a:	da04      	bge.n	802d8a6 <find_biggest_color_pop+0x26>
 802d89c:	69a3      	ldr	r3, [r4, #24]
 802d89e:	2b00      	cmp	r3, #0
 802d8a0:	dd01      	ble.n	802d8a6 <find_biggest_color_pop+0x26>
      which = boxp;
 802d8a2:	60fc      	str	r4, [r7, #12]
      maxc = boxp->colorcount;
 802d8a4:	69e6      	ldr	r6, [r4, #28]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802d8a6:	3501      	adds	r5, #1
 802d8a8:	3420      	adds	r4, #32
 802d8aa:	683b      	ldr	r3, [r7, #0]
 802d8ac:	429d      	cmp	r5, r3
 802d8ae:	dbf2      	blt.n	802d896 <find_biggest_color_pop+0x16>
    }
  }
  return which;
 802d8b0:	68fb      	ldr	r3, [r7, #12]
}
 802d8b2:	4618      	mov	r0, r3
 802d8b4:	3710      	adds	r7, #16
 802d8b6:	46bd      	mov	sp, r7
 802d8b8:	bcf0      	pop	{r4, r5, r6, r7}
 802d8ba:	4770      	bx	lr

0802d8bc <find_biggest_volume>:

LOCAL(boxptr)
find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
 802d8bc:	b4f0      	push	{r4, r5, r6, r7}
 802d8be:	b084      	sub	sp, #16
 802d8c0:	af00      	add	r7, sp, #0
 802d8c2:	6078      	str	r0, [r7, #4]
 802d8c4:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
 802d8c6:	2600      	movs	r6, #0
  boxptr which = NULL;
 802d8c8:	2300      	movs	r3, #0
 802d8ca:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802d8cc:	2500      	movs	r5, #0
 802d8ce:	687c      	ldr	r4, [r7, #4]
 802d8d0:	e006      	b.n	802d8e0 <find_biggest_volume+0x24>
    if (boxp->volume > maxv) {
 802d8d2:	69a3      	ldr	r3, [r4, #24]
 802d8d4:	429e      	cmp	r6, r3
 802d8d6:	da01      	bge.n	802d8dc <find_biggest_volume+0x20>
      which = boxp;
 802d8d8:	60fc      	str	r4, [r7, #12]
      maxv = boxp->volume;
 802d8da:	69a6      	ldr	r6, [r4, #24]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802d8dc:	3501      	adds	r5, #1
 802d8de:	3420      	adds	r4, #32
 802d8e0:	683b      	ldr	r3, [r7, #0]
 802d8e2:	429d      	cmp	r5, r3
 802d8e4:	dbf5      	blt.n	802d8d2 <find_biggest_volume+0x16>
    }
  }
  return which;
 802d8e6:	68fb      	ldr	r3, [r7, #12]
}
 802d8e8:	4618      	mov	r0, r3
 802d8ea:	3710      	adds	r7, #16
 802d8ec:	46bd      	mov	sp, r7
 802d8ee:	bcf0      	pop	{r4, r5, r6, r7}
 802d8f0:	4770      	bx	lr

0802d8f2 <update_box>:

LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
 802d8f2:	b480      	push	{r7}
 802d8f4:	b093      	sub	sp, #76	@ 0x4c
 802d8f6:	af00      	add	r7, sp, #0
 802d8f8:	6078      	str	r0, [r7, #4]
 802d8fa:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802d8fc:	687b      	ldr	r3, [r7, #4]
 802d8fe:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802d902:	61bb      	str	r3, [r7, #24]
  hist3d histogram = cquantize->histogram;
 802d904:	69bb      	ldr	r3, [r7, #24]
 802d906:	699b      	ldr	r3, [r3, #24]
 802d908:	617b      	str	r3, [r7, #20]
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 802d90a:	683b      	ldr	r3, [r7, #0]
 802d90c:	681b      	ldr	r3, [r3, #0]
 802d90e:	637b      	str	r3, [r7, #52]	@ 0x34
 802d910:	683b      	ldr	r3, [r7, #0]
 802d912:	685b      	ldr	r3, [r3, #4]
 802d914:	633b      	str	r3, [r7, #48]	@ 0x30
  c1min = boxp->c1min;  c1max = boxp->c1max;
 802d916:	683b      	ldr	r3, [r7, #0]
 802d918:	689b      	ldr	r3, [r3, #8]
 802d91a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802d91c:	683b      	ldr	r3, [r7, #0]
 802d91e:	68db      	ldr	r3, [r3, #12]
 802d920:	62bb      	str	r3, [r7, #40]	@ 0x28
  c2min = boxp->c2min;  c2max = boxp->c2max;
 802d922:	683b      	ldr	r3, [r7, #0]
 802d924:	691b      	ldr	r3, [r3, #16]
 802d926:	627b      	str	r3, [r7, #36]	@ 0x24
 802d928:	683b      	ldr	r3, [r7, #0]
 802d92a:	695b      	ldr	r3, [r3, #20]
 802d92c:	623b      	str	r3, [r7, #32]
  
  if (c0max > c0min)
 802d92e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d930:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d932:	429a      	cmp	r2, r3
 802d934:	dd35      	ble.n	802d9a2 <update_box+0xb0>
    for (c0 = c0min; c0 <= c0max; c0++)
 802d936:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d938:	643b      	str	r3, [r7, #64]	@ 0x40
 802d93a:	e02e      	b.n	802d99a <update_box+0xa8>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802d93c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d93e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802d940:	e024      	b.n	802d98c <update_box+0x9a>
	histp = & histogram[c0][c1][c2min];
 802d942:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d944:	009b      	lsls	r3, r3, #2
 802d946:	697a      	ldr	r2, [r7, #20]
 802d948:	4413      	add	r3, r2
 802d94a:	681a      	ldr	r2, [r3, #0]
 802d94c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d94e:	019b      	lsls	r3, r3, #6
 802d950:	441a      	add	r2, r3
 802d952:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d954:	005b      	lsls	r3, r3, #1
 802d956:	4413      	add	r3, r2
 802d958:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802d95a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d95c:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d95e:	e00e      	b.n	802d97e <update_box+0x8c>
	  if (*histp++ != 0) {
 802d960:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802d962:	1c9a      	adds	r2, r3, #2
 802d964:	647a      	str	r2, [r7, #68]	@ 0x44
 802d966:	881b      	ldrh	r3, [r3, #0]
 802d968:	2b00      	cmp	r3, #0
 802d96a:	d005      	beq.n	802d978 <update_box+0x86>
	    boxp->c0min = c0min = c0;
 802d96c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d96e:	637b      	str	r3, [r7, #52]	@ 0x34
 802d970:	683b      	ldr	r3, [r7, #0]
 802d972:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802d974:	601a      	str	r2, [r3, #0]
	    goto have_c0min;
 802d976:	e015      	b.n	802d9a4 <update_box+0xb2>
	for (c2 = c2min; c2 <= c2max; c2++)
 802d978:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d97a:	3301      	adds	r3, #1
 802d97c:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d97e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802d980:	6a3b      	ldr	r3, [r7, #32]
 802d982:	429a      	cmp	r2, r3
 802d984:	ddec      	ble.n	802d960 <update_box+0x6e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802d986:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d988:	3301      	adds	r3, #1
 802d98a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802d98c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802d98e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802d990:	429a      	cmp	r2, r3
 802d992:	ddd6      	ble.n	802d942 <update_box+0x50>
    for (c0 = c0min; c0 <= c0max; c0++)
 802d994:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d996:	3301      	adds	r3, #1
 802d998:	643b      	str	r3, [r7, #64]	@ 0x40
 802d99a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802d99c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d99e:	429a      	cmp	r2, r3
 802d9a0:	ddcc      	ble.n	802d93c <update_box+0x4a>
	  }
      }
 have_c0min:
 802d9a2:	bf00      	nop
  if (c0max > c0min)
 802d9a4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d9a6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802d9a8:	429a      	cmp	r2, r3
 802d9aa:	dd35      	ble.n	802da18 <update_box+0x126>
    for (c0 = c0max; c0 >= c0min; c0--)
 802d9ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802d9ae:	643b      	str	r3, [r7, #64]	@ 0x40
 802d9b0:	e02e      	b.n	802da10 <update_box+0x11e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802d9b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802d9b4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802d9b6:	e024      	b.n	802da02 <update_box+0x110>
	histp = & histogram[c0][c1][c2min];
 802d9b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d9ba:	009b      	lsls	r3, r3, #2
 802d9bc:	697a      	ldr	r2, [r7, #20]
 802d9be:	4413      	add	r3, r2
 802d9c0:	681a      	ldr	r2, [r3, #0]
 802d9c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d9c4:	019b      	lsls	r3, r3, #6
 802d9c6:	441a      	add	r2, r3
 802d9c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d9ca:	005b      	lsls	r3, r3, #1
 802d9cc:	4413      	add	r3, r2
 802d9ce:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802d9d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802d9d2:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d9d4:	e00e      	b.n	802d9f4 <update_box+0x102>
	  if (*histp++ != 0) {
 802d9d6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802d9d8:	1c9a      	adds	r2, r3, #2
 802d9da:	647a      	str	r2, [r7, #68]	@ 0x44
 802d9dc:	881b      	ldrh	r3, [r3, #0]
 802d9de:	2b00      	cmp	r3, #0
 802d9e0:	d005      	beq.n	802d9ee <update_box+0xfc>
	    boxp->c0max = c0max = c0;
 802d9e2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802d9e4:	633b      	str	r3, [r7, #48]	@ 0x30
 802d9e6:	683b      	ldr	r3, [r7, #0]
 802d9e8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802d9ea:	605a      	str	r2, [r3, #4]
	    goto have_c0max;
 802d9ec:	e015      	b.n	802da1a <update_box+0x128>
	for (c2 = c2min; c2 <= c2max; c2++)
 802d9ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802d9f0:	3301      	adds	r3, #1
 802d9f2:	63bb      	str	r3, [r7, #56]	@ 0x38
 802d9f4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802d9f6:	6a3b      	ldr	r3, [r7, #32]
 802d9f8:	429a      	cmp	r2, r3
 802d9fa:	ddec      	ble.n	802d9d6 <update_box+0xe4>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802d9fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802d9fe:	3301      	adds	r3, #1
 802da00:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802da02:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802da04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802da06:	429a      	cmp	r2, r3
 802da08:	ddd6      	ble.n	802d9b8 <update_box+0xc6>
    for (c0 = c0max; c0 >= c0min; c0--)
 802da0a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802da0c:	3b01      	subs	r3, #1
 802da0e:	643b      	str	r3, [r7, #64]	@ 0x40
 802da10:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802da12:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802da14:	429a      	cmp	r2, r3
 802da16:	dacc      	bge.n	802d9b2 <update_box+0xc0>
	  }
      }
 have_c0max:
 802da18:	bf00      	nop
  if (c1max > c1min)
 802da1a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802da1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802da1e:	429a      	cmp	r2, r3
 802da20:	dd35      	ble.n	802da8e <update_box+0x19c>
    for (c1 = c1min; c1 <= c1max; c1++)
 802da22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802da24:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802da26:	e02e      	b.n	802da86 <update_box+0x194>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802da28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802da2a:	643b      	str	r3, [r7, #64]	@ 0x40
 802da2c:	e024      	b.n	802da78 <update_box+0x186>
	histp = & histogram[c0][c1][c2min];
 802da2e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802da30:	009b      	lsls	r3, r3, #2
 802da32:	697a      	ldr	r2, [r7, #20]
 802da34:	4413      	add	r3, r2
 802da36:	681a      	ldr	r2, [r3, #0]
 802da38:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802da3a:	019b      	lsls	r3, r3, #6
 802da3c:	441a      	add	r2, r3
 802da3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802da40:	005b      	lsls	r3, r3, #1
 802da42:	4413      	add	r3, r2
 802da44:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802da46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802da48:	63bb      	str	r3, [r7, #56]	@ 0x38
 802da4a:	e00e      	b.n	802da6a <update_box+0x178>
	  if (*histp++ != 0) {
 802da4c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802da4e:	1c9a      	adds	r2, r3, #2
 802da50:	647a      	str	r2, [r7, #68]	@ 0x44
 802da52:	881b      	ldrh	r3, [r3, #0]
 802da54:	2b00      	cmp	r3, #0
 802da56:	d005      	beq.n	802da64 <update_box+0x172>
	    boxp->c1min = c1min = c1;
 802da58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802da5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802da5c:	683b      	ldr	r3, [r7, #0]
 802da5e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802da60:	609a      	str	r2, [r3, #8]
	    goto have_c1min;
 802da62:	e015      	b.n	802da90 <update_box+0x19e>
	for (c2 = c2min; c2 <= c2max; c2++)
 802da64:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802da66:	3301      	adds	r3, #1
 802da68:	63bb      	str	r3, [r7, #56]	@ 0x38
 802da6a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802da6c:	6a3b      	ldr	r3, [r7, #32]
 802da6e:	429a      	cmp	r2, r3
 802da70:	ddec      	ble.n	802da4c <update_box+0x15a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802da72:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802da74:	3301      	adds	r3, #1
 802da76:	643b      	str	r3, [r7, #64]	@ 0x40
 802da78:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802da7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802da7c:	429a      	cmp	r2, r3
 802da7e:	ddd6      	ble.n	802da2e <update_box+0x13c>
    for (c1 = c1min; c1 <= c1max; c1++)
 802da80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802da82:	3301      	adds	r3, #1
 802da84:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802da86:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802da88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802da8a:	429a      	cmp	r2, r3
 802da8c:	ddcc      	ble.n	802da28 <update_box+0x136>
	  }
      }
 have_c1min:
 802da8e:	bf00      	nop
  if (c1max > c1min)
 802da90:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802da92:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802da94:	429a      	cmp	r2, r3
 802da96:	dd35      	ble.n	802db04 <update_box+0x212>
    for (c1 = c1max; c1 >= c1min; c1--)
 802da98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802da9a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802da9c:	e02e      	b.n	802dafc <update_box+0x20a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802da9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802daa0:	643b      	str	r3, [r7, #64]	@ 0x40
 802daa2:	e024      	b.n	802daee <update_box+0x1fc>
	histp = & histogram[c0][c1][c2min];
 802daa4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802daa6:	009b      	lsls	r3, r3, #2
 802daa8:	697a      	ldr	r2, [r7, #20]
 802daaa:	4413      	add	r3, r2
 802daac:	681a      	ldr	r2, [r3, #0]
 802daae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802dab0:	019b      	lsls	r3, r3, #6
 802dab2:	441a      	add	r2, r3
 802dab4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dab6:	005b      	lsls	r3, r3, #1
 802dab8:	4413      	add	r3, r2
 802daba:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802dabc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dabe:	63bb      	str	r3, [r7, #56]	@ 0x38
 802dac0:	e00e      	b.n	802dae0 <update_box+0x1ee>
	  if (*histp++ != 0) {
 802dac2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dac4:	1c9a      	adds	r2, r3, #2
 802dac6:	647a      	str	r2, [r7, #68]	@ 0x44
 802dac8:	881b      	ldrh	r3, [r3, #0]
 802daca:	2b00      	cmp	r3, #0
 802dacc:	d005      	beq.n	802dada <update_box+0x1e8>
	    boxp->c1max = c1max = c1;
 802dace:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802dad0:	62bb      	str	r3, [r7, #40]	@ 0x28
 802dad2:	683b      	ldr	r3, [r7, #0]
 802dad4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802dad6:	60da      	str	r2, [r3, #12]
	    goto have_c1max;
 802dad8:	e015      	b.n	802db06 <update_box+0x214>
	for (c2 = c2min; c2 <= c2max; c2++)
 802dada:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802dadc:	3301      	adds	r3, #1
 802dade:	63bb      	str	r3, [r7, #56]	@ 0x38
 802dae0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802dae2:	6a3b      	ldr	r3, [r7, #32]
 802dae4:	429a      	cmp	r2, r3
 802dae6:	ddec      	ble.n	802dac2 <update_box+0x1d0>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802dae8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802daea:	3301      	adds	r3, #1
 802daec:	643b      	str	r3, [r7, #64]	@ 0x40
 802daee:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802daf0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802daf2:	429a      	cmp	r2, r3
 802daf4:	ddd6      	ble.n	802daa4 <update_box+0x1b2>
    for (c1 = c1max; c1 >= c1min; c1--)
 802daf6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802daf8:	3b01      	subs	r3, #1
 802dafa:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802dafc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802dafe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802db00:	429a      	cmp	r2, r3
 802db02:	dacc      	bge.n	802da9e <update_box+0x1ac>
	  }
      }
 have_c1max:
 802db04:	bf00      	nop
  if (c2max > c2min)
 802db06:	6a3a      	ldr	r2, [r7, #32]
 802db08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802db0a:	429a      	cmp	r2, r3
 802db0c:	dd36      	ble.n	802db7c <update_box+0x28a>
    for (c2 = c2min; c2 <= c2max; c2++)
 802db0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802db10:	63bb      	str	r3, [r7, #56]	@ 0x38
 802db12:	e02f      	b.n	802db74 <update_box+0x282>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802db14:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802db16:	643b      	str	r3, [r7, #64]	@ 0x40
 802db18:	e025      	b.n	802db66 <update_box+0x274>
	histp = & histogram[c0][c1min][c2];
 802db1a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802db1c:	009b      	lsls	r3, r3, #2
 802db1e:	697a      	ldr	r2, [r7, #20]
 802db20:	4413      	add	r3, r2
 802db22:	681a      	ldr	r2, [r3, #0]
 802db24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802db26:	019b      	lsls	r3, r3, #6
 802db28:	441a      	add	r2, r3
 802db2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802db2c:	005b      	lsls	r3, r3, #1
 802db2e:	4413      	add	r3, r2
 802db30:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802db32:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802db34:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802db36:	e00f      	b.n	802db58 <update_box+0x266>
	  if (*histp != 0) {
 802db38:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802db3a:	881b      	ldrh	r3, [r3, #0]
 802db3c:	2b00      	cmp	r3, #0
 802db3e:	d005      	beq.n	802db4c <update_box+0x25a>
	    boxp->c2min = c2min = c2;
 802db40:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802db42:	627b      	str	r3, [r7, #36]	@ 0x24
 802db44:	683b      	ldr	r3, [r7, #0]
 802db46:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802db48:	611a      	str	r2, [r3, #16]
	    goto have_c2min;
 802db4a:	e018      	b.n	802db7e <update_box+0x28c>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802db4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802db4e:	3301      	adds	r3, #1
 802db50:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802db52:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802db54:	3340      	adds	r3, #64	@ 0x40
 802db56:	647b      	str	r3, [r7, #68]	@ 0x44
 802db58:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802db5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802db5c:	429a      	cmp	r2, r3
 802db5e:	ddeb      	ble.n	802db38 <update_box+0x246>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802db60:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802db62:	3301      	adds	r3, #1
 802db64:	643b      	str	r3, [r7, #64]	@ 0x40
 802db66:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802db68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802db6a:	429a      	cmp	r2, r3
 802db6c:	ddd5      	ble.n	802db1a <update_box+0x228>
    for (c2 = c2min; c2 <= c2max; c2++)
 802db6e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802db70:	3301      	adds	r3, #1
 802db72:	63bb      	str	r3, [r7, #56]	@ 0x38
 802db74:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802db76:	6a3b      	ldr	r3, [r7, #32]
 802db78:	429a      	cmp	r2, r3
 802db7a:	ddcb      	ble.n	802db14 <update_box+0x222>
	  }
      }
 have_c2min:
 802db7c:	bf00      	nop
  if (c2max > c2min)
 802db7e:	6a3a      	ldr	r2, [r7, #32]
 802db80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802db82:	429a      	cmp	r2, r3
 802db84:	dd36      	ble.n	802dbf4 <update_box+0x302>
    for (c2 = c2max; c2 >= c2min; c2--)
 802db86:	6a3b      	ldr	r3, [r7, #32]
 802db88:	63bb      	str	r3, [r7, #56]	@ 0x38
 802db8a:	e02f      	b.n	802dbec <update_box+0x2fa>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802db8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802db8e:	643b      	str	r3, [r7, #64]	@ 0x40
 802db90:	e025      	b.n	802dbde <update_box+0x2ec>
	histp = & histogram[c0][c1min][c2];
 802db92:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802db94:	009b      	lsls	r3, r3, #2
 802db96:	697a      	ldr	r2, [r7, #20]
 802db98:	4413      	add	r3, r2
 802db9a:	681a      	ldr	r2, [r3, #0]
 802db9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802db9e:	019b      	lsls	r3, r3, #6
 802dba0:	441a      	add	r2, r3
 802dba2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802dba4:	005b      	lsls	r3, r3, #1
 802dba6:	4413      	add	r3, r2
 802dba8:	647b      	str	r3, [r7, #68]	@ 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802dbaa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802dbac:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802dbae:	e00f      	b.n	802dbd0 <update_box+0x2de>
	  if (*histp != 0) {
 802dbb0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dbb2:	881b      	ldrh	r3, [r3, #0]
 802dbb4:	2b00      	cmp	r3, #0
 802dbb6:	d005      	beq.n	802dbc4 <update_box+0x2d2>
	    boxp->c2max = c2max = c2;
 802dbb8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802dbba:	623b      	str	r3, [r7, #32]
 802dbbc:	683b      	ldr	r3, [r7, #0]
 802dbbe:	6a3a      	ldr	r2, [r7, #32]
 802dbc0:	615a      	str	r2, [r3, #20]
	    goto have_c2max;
 802dbc2:	e018      	b.n	802dbf6 <update_box+0x304>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802dbc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802dbc6:	3301      	adds	r3, #1
 802dbc8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802dbca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dbcc:	3340      	adds	r3, #64	@ 0x40
 802dbce:	647b      	str	r3, [r7, #68]	@ 0x44
 802dbd0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802dbd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802dbd4:	429a      	cmp	r2, r3
 802dbd6:	ddeb      	ble.n	802dbb0 <update_box+0x2be>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802dbd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802dbda:	3301      	adds	r3, #1
 802dbdc:	643b      	str	r3, [r7, #64]	@ 0x40
 802dbde:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802dbe0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802dbe2:	429a      	cmp	r2, r3
 802dbe4:	ddd5      	ble.n	802db92 <update_box+0x2a0>
    for (c2 = c2max; c2 >= c2min; c2--)
 802dbe6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802dbe8:	3b01      	subs	r3, #1
 802dbea:	63bb      	str	r3, [r7, #56]	@ 0x38
 802dbec:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802dbee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dbf0:	429a      	cmp	r2, r3
 802dbf2:	dacb      	bge.n	802db8c <update_box+0x29a>
	  }
      }
 have_c2max:
 802dbf4:	bf00      	nop
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
 802dbf6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802dbf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802dbfa:	1ad3      	subs	r3, r2, r3
 802dbfc:	00db      	lsls	r3, r3, #3
 802dbfe:	005b      	lsls	r3, r3, #1
 802dc00:	613b      	str	r3, [r7, #16]
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
 802dc02:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802dc04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802dc06:	1ad3      	subs	r3, r2, r3
 802dc08:	009a      	lsls	r2, r3, #2
 802dc0a:	4613      	mov	r3, r2
 802dc0c:	005b      	lsls	r3, r3, #1
 802dc0e:	4413      	add	r3, r2
 802dc10:	60fb      	str	r3, [r7, #12]
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
 802dc12:	6a3a      	ldr	r2, [r7, #32]
 802dc14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dc16:	1ad3      	subs	r3, r2, r3
 802dc18:	00db      	lsls	r3, r3, #3
 802dc1a:	60bb      	str	r3, [r7, #8]
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
 802dc1c:	693b      	ldr	r3, [r7, #16]
 802dc1e:	fb03 f203 	mul.w	r2, r3, r3
 802dc22:	68fb      	ldr	r3, [r7, #12]
 802dc24:	fb03 f303 	mul.w	r3, r3, r3
 802dc28:	441a      	add	r2, r3
 802dc2a:	68bb      	ldr	r3, [r7, #8]
 802dc2c:	fb03 f303 	mul.w	r3, r3, r3
 802dc30:	441a      	add	r2, r3
 802dc32:	683b      	ldr	r3, [r7, #0]
 802dc34:	619a      	str	r2, [r3, #24]
  
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
 802dc36:	2300      	movs	r3, #0
 802dc38:	61fb      	str	r3, [r7, #28]
  for (c0 = c0min; c0 <= c0max; c0++)
 802dc3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802dc3c:	643b      	str	r3, [r7, #64]	@ 0x40
 802dc3e:	e02c      	b.n	802dc9a <update_box+0x3a8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802dc40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802dc42:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802dc44:	e022      	b.n	802dc8c <update_box+0x39a>
      histp = & histogram[c0][c1][c2min];
 802dc46:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802dc48:	009b      	lsls	r3, r3, #2
 802dc4a:	697a      	ldr	r2, [r7, #20]
 802dc4c:	4413      	add	r3, r2
 802dc4e:	681a      	ldr	r2, [r3, #0]
 802dc50:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802dc52:	019b      	lsls	r3, r3, #6
 802dc54:	441a      	add	r2, r3
 802dc56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dc58:	005b      	lsls	r3, r3, #1
 802dc5a:	4413      	add	r3, r2
 802dc5c:	647b      	str	r3, [r7, #68]	@ 0x44
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 802dc5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dc60:	63bb      	str	r3, [r7, #56]	@ 0x38
 802dc62:	e00c      	b.n	802dc7e <update_box+0x38c>
	if (*histp != 0) {
 802dc64:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dc66:	881b      	ldrh	r3, [r3, #0]
 802dc68:	2b00      	cmp	r3, #0
 802dc6a:	d002      	beq.n	802dc72 <update_box+0x380>
	  ccount++;
 802dc6c:	69fb      	ldr	r3, [r7, #28]
 802dc6e:	3301      	adds	r3, #1
 802dc70:	61fb      	str	r3, [r7, #28]
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 802dc72:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802dc74:	3301      	adds	r3, #1
 802dc76:	63bb      	str	r3, [r7, #56]	@ 0x38
 802dc78:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dc7a:	3302      	adds	r3, #2
 802dc7c:	647b      	str	r3, [r7, #68]	@ 0x44
 802dc7e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802dc80:	6a3b      	ldr	r3, [r7, #32]
 802dc82:	429a      	cmp	r2, r3
 802dc84:	ddee      	ble.n	802dc64 <update_box+0x372>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802dc86:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802dc88:	3301      	adds	r3, #1
 802dc8a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802dc8c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802dc8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802dc90:	429a      	cmp	r2, r3
 802dc92:	ddd8      	ble.n	802dc46 <update_box+0x354>
  for (c0 = c0min; c0 <= c0max; c0++)
 802dc94:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802dc96:	3301      	adds	r3, #1
 802dc98:	643b      	str	r3, [r7, #64]	@ 0x40
 802dc9a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802dc9c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802dc9e:	429a      	cmp	r2, r3
 802dca0:	ddce      	ble.n	802dc40 <update_box+0x34e>
	}
    }
  boxp->colorcount = ccount;
 802dca2:	683b      	ldr	r3, [r7, #0]
 802dca4:	69fa      	ldr	r2, [r7, #28]
 802dca6:	61da      	str	r2, [r3, #28]
}
 802dca8:	bf00      	nop
 802dcaa:	374c      	adds	r7, #76	@ 0x4c
 802dcac:	46bd      	mov	sp, r7
 802dcae:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dcb2:	4770      	bx	lr

0802dcb4 <median_cut>:

LOCAL(int)
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
/* Repeatedly select and split the largest box until we have enough boxes */
{
 802dcb4:	b5b0      	push	{r4, r5, r7, lr}
 802dcb6:	b08a      	sub	sp, #40	@ 0x28
 802dcb8:	af00      	add	r7, sp, #0
 802dcba:	60f8      	str	r0, [r7, #12]
 802dcbc:	60b9      	str	r1, [r7, #8]
 802dcbe:	607a      	str	r2, [r7, #4]
 802dcc0:	603b      	str	r3, [r7, #0]
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
 802dcc2:	e085      	b.n	802ddd0 <median_cut+0x11c>
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
 802dcc4:	687b      	ldr	r3, [r7, #4]
 802dcc6:	005b      	lsls	r3, r3, #1
 802dcc8:	683a      	ldr	r2, [r7, #0]
 802dcca:	429a      	cmp	r2, r3
 802dccc:	db05      	blt.n	802dcda <median_cut+0x26>
      b1 = find_biggest_color_pop(boxlist, numboxes);
 802dcce:	6879      	ldr	r1, [r7, #4]
 802dcd0:	68b8      	ldr	r0, [r7, #8]
 802dcd2:	f7ff fdd5 	bl	802d880 <find_biggest_color_pop>
 802dcd6:	4604      	mov	r4, r0
 802dcd8:	e004      	b.n	802dce4 <median_cut+0x30>
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
 802dcda:	6879      	ldr	r1, [r7, #4]
 802dcdc:	68b8      	ldr	r0, [r7, #8]
 802dcde:	f7ff fded 	bl	802d8bc <find_biggest_volume>
 802dce2:	4604      	mov	r4, r0
    }
    if (b1 == NULL)		/* no splittable boxes left! */
 802dce4:	2c00      	cmp	r4, #0
 802dce6:	d079      	beq.n	802dddc <median_cut+0x128>
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
 802dce8:	687b      	ldr	r3, [r7, #4]
 802dcea:	015b      	lsls	r3, r3, #5
 802dcec:	68ba      	ldr	r2, [r7, #8]
 802dcee:	18d5      	adds	r5, r2, r3
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
 802dcf0:	6863      	ldr	r3, [r4, #4]
 802dcf2:	606b      	str	r3, [r5, #4]
 802dcf4:	68e3      	ldr	r3, [r4, #12]
 802dcf6:	60eb      	str	r3, [r5, #12]
 802dcf8:	6963      	ldr	r3, [r4, #20]
 802dcfa:	616b      	str	r3, [r5, #20]
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
 802dcfc:	6823      	ldr	r3, [r4, #0]
 802dcfe:	602b      	str	r3, [r5, #0]
 802dd00:	68a3      	ldr	r3, [r4, #8]
 802dd02:	60ab      	str	r3, [r5, #8]
 802dd04:	6923      	ldr	r3, [r4, #16]
 802dd06:	612b      	str	r3, [r5, #16]
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
 802dd08:	6862      	ldr	r2, [r4, #4]
 802dd0a:	6823      	ldr	r3, [r4, #0]
 802dd0c:	1ad3      	subs	r3, r2, r3
 802dd0e:	00db      	lsls	r3, r3, #3
 802dd10:	005b      	lsls	r3, r3, #1
 802dd12:	61fb      	str	r3, [r7, #28]
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
 802dd14:	68e2      	ldr	r2, [r4, #12]
 802dd16:	68a3      	ldr	r3, [r4, #8]
 802dd18:	1ad3      	subs	r3, r2, r3
 802dd1a:	009a      	lsls	r2, r3, #2
 802dd1c:	4613      	mov	r3, r2
 802dd1e:	005b      	lsls	r3, r3, #1
 802dd20:	4413      	add	r3, r2
 802dd22:	61bb      	str	r3, [r7, #24]
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
 802dd24:	6962      	ldr	r2, [r4, #20]
 802dd26:	6923      	ldr	r3, [r4, #16]
 802dd28:	1ad3      	subs	r3, r2, r3
 802dd2a:	00db      	lsls	r3, r3, #3
 802dd2c:	617b      	str	r3, [r7, #20]
    /* We want to break any ties in favor of green, then red, blue last.
     * This code does the right thing for R,G,B or B,G,R color orders only.
     */
#if RGB_RED == 0
    cmax = c1; n = 1;
 802dd2e:	69bb      	ldr	r3, [r7, #24]
 802dd30:	623b      	str	r3, [r7, #32]
 802dd32:	2301      	movs	r3, #1
 802dd34:	627b      	str	r3, [r7, #36]	@ 0x24
    if (c0 > cmax) { cmax = c0; n = 0; }
 802dd36:	69fa      	ldr	r2, [r7, #28]
 802dd38:	6a3b      	ldr	r3, [r7, #32]
 802dd3a:	429a      	cmp	r2, r3
 802dd3c:	dd03      	ble.n	802dd46 <median_cut+0x92>
 802dd3e:	69fb      	ldr	r3, [r7, #28]
 802dd40:	623b      	str	r3, [r7, #32]
 802dd42:	2300      	movs	r3, #0
 802dd44:	627b      	str	r3, [r7, #36]	@ 0x24
    if (c2 > cmax) { n = 2; }
 802dd46:	697a      	ldr	r2, [r7, #20]
 802dd48:	6a3b      	ldr	r3, [r7, #32]
 802dd4a:	429a      	cmp	r2, r3
 802dd4c:	dd01      	ble.n	802dd52 <median_cut+0x9e>
 802dd4e:	2302      	movs	r3, #2
 802dd50:	627b      	str	r3, [r7, #36]	@ 0x24
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
 802dd52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dd54:	2b02      	cmp	r3, #2
 802dd56:	d023      	beq.n	802dda0 <median_cut+0xec>
 802dd58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dd5a:	2b02      	cmp	r3, #2
 802dd5c:	dc2d      	bgt.n	802ddba <median_cut+0x106>
 802dd5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dd60:	2b00      	cmp	r3, #0
 802dd62:	d003      	beq.n	802dd6c <median_cut+0xb8>
 802dd64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802dd66:	2b01      	cmp	r3, #1
 802dd68:	d00d      	beq.n	802dd86 <median_cut+0xd2>
 802dd6a:	e026      	b.n	802ddba <median_cut+0x106>
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
 802dd6c:	6862      	ldr	r2, [r4, #4]
 802dd6e:	6823      	ldr	r3, [r4, #0]
 802dd70:	4413      	add	r3, r2
 802dd72:	0fda      	lsrs	r2, r3, #31
 802dd74:	4413      	add	r3, r2
 802dd76:	105b      	asrs	r3, r3, #1
 802dd78:	613b      	str	r3, [r7, #16]
      b1->c0max = lb;
 802dd7a:	693b      	ldr	r3, [r7, #16]
 802dd7c:	6063      	str	r3, [r4, #4]
      b2->c0min = lb+1;
 802dd7e:	693b      	ldr	r3, [r7, #16]
 802dd80:	3301      	adds	r3, #1
 802dd82:	602b      	str	r3, [r5, #0]
      break;
 802dd84:	e019      	b.n	802ddba <median_cut+0x106>
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
 802dd86:	68e2      	ldr	r2, [r4, #12]
 802dd88:	68a3      	ldr	r3, [r4, #8]
 802dd8a:	4413      	add	r3, r2
 802dd8c:	0fda      	lsrs	r2, r3, #31
 802dd8e:	4413      	add	r3, r2
 802dd90:	105b      	asrs	r3, r3, #1
 802dd92:	613b      	str	r3, [r7, #16]
      b1->c1max = lb;
 802dd94:	693b      	ldr	r3, [r7, #16]
 802dd96:	60e3      	str	r3, [r4, #12]
      b2->c1min = lb+1;
 802dd98:	693b      	ldr	r3, [r7, #16]
 802dd9a:	3301      	adds	r3, #1
 802dd9c:	60ab      	str	r3, [r5, #8]
      break;
 802dd9e:	e00c      	b.n	802ddba <median_cut+0x106>
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
 802dda0:	6962      	ldr	r2, [r4, #20]
 802dda2:	6923      	ldr	r3, [r4, #16]
 802dda4:	4413      	add	r3, r2
 802dda6:	0fda      	lsrs	r2, r3, #31
 802dda8:	4413      	add	r3, r2
 802ddaa:	105b      	asrs	r3, r3, #1
 802ddac:	613b      	str	r3, [r7, #16]
      b1->c2max = lb;
 802ddae:	693b      	ldr	r3, [r7, #16]
 802ddb0:	6163      	str	r3, [r4, #20]
      b2->c2min = lb+1;
 802ddb2:	693b      	ldr	r3, [r7, #16]
 802ddb4:	3301      	adds	r3, #1
 802ddb6:	612b      	str	r3, [r5, #16]
      break;
 802ddb8:	bf00      	nop
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
 802ddba:	4621      	mov	r1, r4
 802ddbc:	68f8      	ldr	r0, [r7, #12]
 802ddbe:	f7ff fd98 	bl	802d8f2 <update_box>
    update_box(cinfo, b2);
 802ddc2:	4629      	mov	r1, r5
 802ddc4:	68f8      	ldr	r0, [r7, #12]
 802ddc6:	f7ff fd94 	bl	802d8f2 <update_box>
    numboxes++;
 802ddca:	687b      	ldr	r3, [r7, #4]
 802ddcc:	3301      	adds	r3, #1
 802ddce:	607b      	str	r3, [r7, #4]
  while (numboxes < desired_colors) {
 802ddd0:	687a      	ldr	r2, [r7, #4]
 802ddd2:	683b      	ldr	r3, [r7, #0]
 802ddd4:	429a      	cmp	r2, r3
 802ddd6:	f6ff af75 	blt.w	802dcc4 <median_cut+0x10>
 802ddda:	e000      	b.n	802ddde <median_cut+0x12a>
      break;
 802dddc:	bf00      	nop
  }
  return numboxes;
 802ddde:	687b      	ldr	r3, [r7, #4]
}
 802dde0:	4618      	mov	r0, r3
 802dde2:	3728      	adds	r7, #40	@ 0x28
 802dde4:	46bd      	mov	sp, r7
 802dde6:	bdb0      	pop	{r4, r5, r7, pc}

0802dde8 <compute_color>:


LOCAL(void)
compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
 802dde8:	b480      	push	{r7}
 802ddea:	b097      	sub	sp, #92	@ 0x5c
 802ddec:	af00      	add	r7, sp, #0
 802ddee:	60f8      	str	r0, [r7, #12]
 802ddf0:	60b9      	str	r1, [r7, #8]
 802ddf2:	607a      	str	r2, [r7, #4]
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ddf4:	68fb      	ldr	r3, [r7, #12]
 802ddf6:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ddfa:	637b      	str	r3, [r7, #52]	@ 0x34
  hist3d histogram = cquantize->histogram;
 802ddfc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ddfe:	699b      	ldr	r3, [r3, #24]
 802de00:	633b      	str	r3, [r7, #48]	@ 0x30
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  long count;
  long total = 0;
 802de02:	2300      	movs	r3, #0
 802de04:	647b      	str	r3, [r7, #68]	@ 0x44
  long c0total = 0;
 802de06:	2300      	movs	r3, #0
 802de08:	643b      	str	r3, [r7, #64]	@ 0x40
  long c1total = 0;
 802de0a:	2300      	movs	r3, #0
 802de0c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  long c2total = 0;
 802de0e:	2300      	movs	r3, #0
 802de10:	63bb      	str	r3, [r7, #56]	@ 0x38
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 802de12:	68bb      	ldr	r3, [r7, #8]
 802de14:	681b      	ldr	r3, [r3, #0]
 802de16:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802de18:	68bb      	ldr	r3, [r7, #8]
 802de1a:	685b      	ldr	r3, [r3, #4]
 802de1c:	62bb      	str	r3, [r7, #40]	@ 0x28
  c1min = boxp->c1min;  c1max = boxp->c1max;
 802de1e:	68bb      	ldr	r3, [r7, #8]
 802de20:	689b      	ldr	r3, [r3, #8]
 802de22:	627b      	str	r3, [r7, #36]	@ 0x24
 802de24:	68bb      	ldr	r3, [r7, #8]
 802de26:	68db      	ldr	r3, [r3, #12]
 802de28:	623b      	str	r3, [r7, #32]
  c2min = boxp->c2min;  c2max = boxp->c2max;
 802de2a:	68bb      	ldr	r3, [r7, #8]
 802de2c:	691b      	ldr	r3, [r3, #16]
 802de2e:	61fb      	str	r3, [r7, #28]
 802de30:	68bb      	ldr	r3, [r7, #8]
 802de32:	695b      	ldr	r3, [r3, #20]
 802de34:	61bb      	str	r3, [r7, #24]
  
  for (c0 = c0min; c0 <= c0max; c0++)
 802de36:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802de38:	653b      	str	r3, [r7, #80]	@ 0x50
 802de3a:	e049      	b.n	802ded0 <compute_color+0xe8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802de3c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802de3e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802de40:	e03f      	b.n	802dec2 <compute_color+0xda>
      histp = & histogram[c0][c1][c2min];
 802de42:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802de44:	009b      	lsls	r3, r3, #2
 802de46:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802de48:	4413      	add	r3, r2
 802de4a:	681a      	ldr	r2, [r3, #0]
 802de4c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802de4e:	019b      	lsls	r3, r3, #6
 802de50:	441a      	add	r2, r3
 802de52:	69fb      	ldr	r3, [r7, #28]
 802de54:	005b      	lsls	r3, r3, #1
 802de56:	4413      	add	r3, r2
 802de58:	657b      	str	r3, [r7, #84]	@ 0x54
      for (c2 = c2min; c2 <= c2max; c2++) {
 802de5a:	69fb      	ldr	r3, [r7, #28]
 802de5c:	64bb      	str	r3, [r7, #72]	@ 0x48
 802de5e:	e029      	b.n	802deb4 <compute_color+0xcc>
	if ((count = *histp++) != 0) {
 802de60:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802de62:	1c9a      	adds	r2, r3, #2
 802de64:	657a      	str	r2, [r7, #84]	@ 0x54
 802de66:	881b      	ldrh	r3, [r3, #0]
 802de68:	617b      	str	r3, [r7, #20]
 802de6a:	697b      	ldr	r3, [r7, #20]
 802de6c:	2b00      	cmp	r3, #0
 802de6e:	d01e      	beq.n	802deae <compute_color+0xc6>
	  total += count;
 802de70:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802de72:	697b      	ldr	r3, [r7, #20]
 802de74:	4413      	add	r3, r2
 802de76:	647b      	str	r3, [r7, #68]	@ 0x44
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
 802de78:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802de7a:	00db      	lsls	r3, r3, #3
 802de7c:	3304      	adds	r3, #4
 802de7e:	697a      	ldr	r2, [r7, #20]
 802de80:	fb02 f303 	mul.w	r3, r2, r3
 802de84:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 802de86:	4413      	add	r3, r2
 802de88:	643b      	str	r3, [r7, #64]	@ 0x40
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
 802de8a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802de8c:	009b      	lsls	r3, r3, #2
 802de8e:	3302      	adds	r3, #2
 802de90:	697a      	ldr	r2, [r7, #20]
 802de92:	fb02 f303 	mul.w	r3, r2, r3
 802de96:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802de98:	4413      	add	r3, r2
 802de9a:	63fb      	str	r3, [r7, #60]	@ 0x3c
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
 802de9c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802de9e:	00db      	lsls	r3, r3, #3
 802dea0:	3304      	adds	r3, #4
 802dea2:	697a      	ldr	r2, [r7, #20]
 802dea4:	fb02 f303 	mul.w	r3, r2, r3
 802dea8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802deaa:	4413      	add	r3, r2
 802deac:	63bb      	str	r3, [r7, #56]	@ 0x38
      for (c2 = c2min; c2 <= c2max; c2++) {
 802deae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802deb0:	3301      	adds	r3, #1
 802deb2:	64bb      	str	r3, [r7, #72]	@ 0x48
 802deb4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802deb6:	69bb      	ldr	r3, [r7, #24]
 802deb8:	429a      	cmp	r2, r3
 802deba:	ddd1      	ble.n	802de60 <compute_color+0x78>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802debc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802debe:	3301      	adds	r3, #1
 802dec0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802dec2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802dec4:	6a3b      	ldr	r3, [r7, #32]
 802dec6:	429a      	cmp	r2, r3
 802dec8:	ddbb      	ble.n	802de42 <compute_color+0x5a>
  for (c0 = c0min; c0 <= c0max; c0++)
 802deca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802decc:	3301      	adds	r3, #1
 802dece:	653b      	str	r3, [r7, #80]	@ 0x50
 802ded0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802ded2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802ded4:	429a      	cmp	r2, r3
 802ded6:	ddb1      	ble.n	802de3c <compute_color+0x54>
	}
      }
    }
  
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
 802ded8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802deda:	105a      	asrs	r2, r3, #1
 802dedc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802dede:	441a      	add	r2, r3
 802dee0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802dee2:	fb92 f1f3 	sdiv	r1, r2, r3
 802dee6:	68fb      	ldr	r3, [r7, #12]
 802dee8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802deec:	681a      	ldr	r2, [r3, #0]
 802deee:	687b      	ldr	r3, [r7, #4]
 802def0:	4413      	add	r3, r2
 802def2:	b2ca      	uxtb	r2, r1
 802def4:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
 802def6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802def8:	105a      	asrs	r2, r3, #1
 802defa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802defc:	441a      	add	r2, r3
 802defe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802df00:	fb92 f1f3 	sdiv	r1, r2, r3
 802df04:	68fb      	ldr	r3, [r7, #12]
 802df06:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802df0a:	3304      	adds	r3, #4
 802df0c:	681a      	ldr	r2, [r3, #0]
 802df0e:	687b      	ldr	r3, [r7, #4]
 802df10:	4413      	add	r3, r2
 802df12:	b2ca      	uxtb	r2, r1
 802df14:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
 802df16:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802df18:	105a      	asrs	r2, r3, #1
 802df1a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802df1c:	441a      	add	r2, r3
 802df1e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802df20:	fb92 f1f3 	sdiv	r1, r2, r3
 802df24:	68fb      	ldr	r3, [r7, #12]
 802df26:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802df2a:	3308      	adds	r3, #8
 802df2c:	681a      	ldr	r2, [r3, #0]
 802df2e:	687b      	ldr	r3, [r7, #4]
 802df30:	4413      	add	r3, r2
 802df32:	b2ca      	uxtb	r2, r1
 802df34:	701a      	strb	r2, [r3, #0]
}
 802df36:	bf00      	nop
 802df38:	375c      	adds	r7, #92	@ 0x5c
 802df3a:	46bd      	mov	sp, r7
 802df3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802df40:	4770      	bx	lr

0802df42 <select_colors>:


LOCAL(void)
select_colors (j_decompress_ptr cinfo, int desired_colors)
/* Master routine for color selection */
{
 802df42:	b580      	push	{r7, lr}
 802df44:	b086      	sub	sp, #24
 802df46:	af00      	add	r7, sp, #0
 802df48:	6078      	str	r0, [r7, #4]
 802df4a:	6039      	str	r1, [r7, #0]
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
 802df4c:	687b      	ldr	r3, [r7, #4]
 802df4e:	685b      	ldr	r3, [r3, #4]
 802df50:	681b      	ldr	r3, [r3, #0]
 802df52:	683a      	ldr	r2, [r7, #0]
 802df54:	0152      	lsls	r2, r2, #5
 802df56:	2101      	movs	r1, #1
 802df58:	6878      	ldr	r0, [r7, #4]
 802df5a:	4798      	blx	r3
 802df5c:	6138      	str	r0, [r7, #16]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
 802df5e:	2301      	movs	r3, #1
 802df60:	60fb      	str	r3, [r7, #12]
  boxlist[0].c0min = 0;
 802df62:	693b      	ldr	r3, [r7, #16]
 802df64:	2200      	movs	r2, #0
 802df66:	601a      	str	r2, [r3, #0]
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
 802df68:	693b      	ldr	r3, [r7, #16]
 802df6a:	221f      	movs	r2, #31
 802df6c:	605a      	str	r2, [r3, #4]
  boxlist[0].c1min = 0;
 802df6e:	693b      	ldr	r3, [r7, #16]
 802df70:	2200      	movs	r2, #0
 802df72:	609a      	str	r2, [r3, #8]
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
 802df74:	693b      	ldr	r3, [r7, #16]
 802df76:	223f      	movs	r2, #63	@ 0x3f
 802df78:	60da      	str	r2, [r3, #12]
  boxlist[0].c2min = 0;
 802df7a:	693b      	ldr	r3, [r7, #16]
 802df7c:	2200      	movs	r2, #0
 802df7e:	611a      	str	r2, [r3, #16]
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
 802df80:	693b      	ldr	r3, [r7, #16]
 802df82:	221f      	movs	r2, #31
 802df84:	615a      	str	r2, [r3, #20]
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
 802df86:	6939      	ldr	r1, [r7, #16]
 802df88:	6878      	ldr	r0, [r7, #4]
 802df8a:	f7ff fcb2 	bl	802d8f2 <update_box>
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
 802df8e:	683b      	ldr	r3, [r7, #0]
 802df90:	68fa      	ldr	r2, [r7, #12]
 802df92:	6939      	ldr	r1, [r7, #16]
 802df94:	6878      	ldr	r0, [r7, #4]
 802df96:	f7ff fe8d 	bl	802dcb4 <median_cut>
 802df9a:	60f8      	str	r0, [r7, #12]
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
 802df9c:	2300      	movs	r3, #0
 802df9e:	617b      	str	r3, [r7, #20]
 802dfa0:	e00b      	b.n	802dfba <select_colors+0x78>
    compute_color(cinfo, & boxlist[i], i);
 802dfa2:	697b      	ldr	r3, [r7, #20]
 802dfa4:	015b      	lsls	r3, r3, #5
 802dfa6:	693a      	ldr	r2, [r7, #16]
 802dfa8:	4413      	add	r3, r2
 802dfaa:	697a      	ldr	r2, [r7, #20]
 802dfac:	4619      	mov	r1, r3
 802dfae:	6878      	ldr	r0, [r7, #4]
 802dfb0:	f7ff ff1a 	bl	802dde8 <compute_color>
  for (i = 0; i < numboxes; i++)
 802dfb4:	697b      	ldr	r3, [r7, #20]
 802dfb6:	3301      	adds	r3, #1
 802dfb8:	617b      	str	r3, [r7, #20]
 802dfba:	697a      	ldr	r2, [r7, #20]
 802dfbc:	68fb      	ldr	r3, [r7, #12]
 802dfbe:	429a      	cmp	r2, r3
 802dfc0:	dbef      	blt.n	802dfa2 <select_colors+0x60>
  cinfo->actual_number_of_colors = numboxes;
 802dfc2:	687b      	ldr	r3, [r7, #4]
 802dfc4:	68fa      	ldr	r2, [r7, #12]
 802dfc6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
 802dfca:	687b      	ldr	r3, [r7, #4]
 802dfcc:	681b      	ldr	r3, [r3, #0]
 802dfce:	2262      	movs	r2, #98	@ 0x62
 802dfd0:	615a      	str	r2, [r3, #20]
 802dfd2:	687b      	ldr	r3, [r7, #4]
 802dfd4:	681b      	ldr	r3, [r3, #0]
 802dfd6:	68fa      	ldr	r2, [r7, #12]
 802dfd8:	619a      	str	r2, [r3, #24]
 802dfda:	687b      	ldr	r3, [r7, #4]
 802dfdc:	681b      	ldr	r3, [r3, #0]
 802dfde:	685b      	ldr	r3, [r3, #4]
 802dfe0:	2101      	movs	r1, #1
 802dfe2:	6878      	ldr	r0, [r7, #4]
 802dfe4:	4798      	blx	r3
}
 802dfe6:	bf00      	nop
 802dfe8:	3718      	adds	r7, #24
 802dfea:	46bd      	mov	sp, r7
 802dfec:	bd80      	pop	{r7, pc}

0802dfee <find_nearby_colors>:
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
 802dfee:	b490      	push	{r4, r7}
 802dff0:	f5ad 6d89 	sub.w	sp, sp, #1096	@ 0x448
 802dff4:	af00      	add	r7, sp, #0
 802dff6:	f507 6489 	add.w	r4, r7, #1096	@ 0x448
 802dffa:	f2a4 443c 	subw	r4, r4, #1084	@ 0x43c
 802dffe:	6020      	str	r0, [r4, #0]
 802e000:	f507 6089 	add.w	r0, r7, #1096	@ 0x448
 802e004:	f5a0 6088 	sub.w	r0, r0, #1088	@ 0x440
 802e008:	6001      	str	r1, [r0, #0]
 802e00a:	f507 6189 	add.w	r1, r7, #1096	@ 0x448
 802e00e:	f2a1 4144 	subw	r1, r1, #1092	@ 0x444
 802e012:	600a      	str	r2, [r1, #0]
 802e014:	f507 6289 	add.w	r2, r7, #1096	@ 0x448
 802e018:	f5a2 6289 	sub.w	r2, r2, #1096	@ 0x448
 802e01c:	6013      	str	r3, [r2, #0]
  int numcolors = cinfo->actual_number_of_colors;
 802e01e:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e022:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802e026:	681b      	ldr	r3, [r3, #0]
 802e028:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 802e02c:	f8c7 3430 	str.w	r3, [r7, #1072]	@ 0x430
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
 802e030:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e034:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e038:	681b      	ldr	r3, [r3, #0]
 802e03a:	3318      	adds	r3, #24
 802e03c:	f8c7 342c 	str.w	r3, [r7, #1068]	@ 0x42c
  centerc0 = (minc0 + maxc0) >> 1;
 802e040:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e044:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e048:	681a      	ldr	r2, [r3, #0]
 802e04a:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802e04e:	4413      	add	r3, r2
 802e050:	105b      	asrs	r3, r3, #1
 802e052:	f8c7 3428 	str.w	r3, [r7, #1064]	@ 0x428
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
 802e056:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e05a:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e05e:	681b      	ldr	r3, [r3, #0]
 802e060:	331c      	adds	r3, #28
 802e062:	f8c7 3424 	str.w	r3, [r7, #1060]	@ 0x424
  centerc1 = (minc1 + maxc1) >> 1;
 802e066:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e06a:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e06e:	681a      	ldr	r2, [r3, #0]
 802e070:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802e074:	4413      	add	r3, r2
 802e076:	105b      	asrs	r3, r3, #1
 802e078:	f8c7 3420 	str.w	r3, [r7, #1056]	@ 0x420
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
 802e07c:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e080:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e084:	681b      	ldr	r3, [r3, #0]
 802e086:	3318      	adds	r3, #24
 802e088:	f8c7 341c 	str.w	r3, [r7, #1052]	@ 0x41c
  centerc2 = (minc2 + maxc2) >> 1;
 802e08c:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e090:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e094:	681a      	ldr	r2, [r3, #0]
 802e096:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802e09a:	4413      	add	r3, r2
 802e09c:	105b      	asrs	r3, r3, #1
 802e09e:	f8c7 3418 	str.w	r3, [r7, #1048]	@ 0x418
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;
 802e0a2:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 802e0a6:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c

  for (i = 0; i < numcolors; i++) {
 802e0aa:	2300      	movs	r3, #0
 802e0ac:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802e0b0:	e1d0      	b.n	802e454 <find_nearby_colors+0x466>
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
 802e0b2:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e0b6:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802e0ba:	681b      	ldr	r3, [r3, #0]
 802e0bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e0c0:	681a      	ldr	r2, [r3, #0]
 802e0c2:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802e0c6:	4413      	add	r3, r2
 802e0c8:	781b      	ldrb	r3, [r3, #0]
 802e0ca:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc0) {
 802e0ce:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e0d2:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e0d6:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e0da:	681b      	ldr	r3, [r3, #0]
 802e0dc:	429a      	cmp	r2, r3
 802e0de:	da1f      	bge.n	802e120 <find_nearby_colors+0x132>
      tdist = (x - minc0) * C0_SCALE;
 802e0e0:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e0e4:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e0e8:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e0ec:	681b      	ldr	r3, [r3, #0]
 802e0ee:	1ad3      	subs	r3, r2, r3
 802e0f0:	005b      	lsls	r3, r3, #1
 802e0f2:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist = tdist*tdist;
 802e0f6:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e0fa:	fb03 f303 	mul.w	r3, r3, r3
 802e0fe:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc0) * C0_SCALE;
 802e102:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e106:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802e10a:	1ad3      	subs	r3, r2, r3
 802e10c:	005b      	lsls	r3, r3, #1
 802e10e:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist = tdist*tdist;
 802e112:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e116:	fb03 f303 	mul.w	r3, r3, r3
 802e11a:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e11e:	e04e      	b.n	802e1be <find_nearby_colors+0x1d0>
    } else if (x > maxc0) {
 802e120:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e124:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802e128:	429a      	cmp	r2, r3
 802e12a:	dd1f      	ble.n	802e16c <find_nearby_colors+0x17e>
      tdist = (x - maxc0) * C0_SCALE;
 802e12c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e130:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802e134:	1ad3      	subs	r3, r2, r3
 802e136:	005b      	lsls	r3, r3, #1
 802e138:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist = tdist*tdist;
 802e13c:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e140:	fb03 f303 	mul.w	r3, r3, r3
 802e144:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc0) * C0_SCALE;
 802e148:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e14c:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e150:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e154:	681b      	ldr	r3, [r3, #0]
 802e156:	1ad3      	subs	r3, r2, r3
 802e158:	005b      	lsls	r3, r3, #1
 802e15a:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist = tdist*tdist;
 802e15e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e162:	fb03 f303 	mul.w	r3, r3, r3
 802e166:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e16a:	e028      	b.n	802e1be <find_nearby_colors+0x1d0>
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
 802e16c:	2300      	movs	r3, #0
 802e16e:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      if (x <= centerc0) {
 802e172:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e176:	f8d7 3428 	ldr.w	r3, [r7, #1064]	@ 0x428
 802e17a:	429a      	cmp	r2, r3
 802e17c:	dc0e      	bgt.n	802e19c <find_nearby_colors+0x1ae>
	tdist = (x - maxc0) * C0_SCALE;
 802e17e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e182:	f8d7 342c 	ldr.w	r3, [r7, #1068]	@ 0x42c
 802e186:	1ad3      	subs	r3, r2, r3
 802e188:	005b      	lsls	r3, r3, #1
 802e18a:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist = tdist*tdist;
 802e18e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e192:	fb03 f303 	mul.w	r3, r3, r3
 802e196:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e19a:	e010      	b.n	802e1be <find_nearby_colors+0x1d0>
      } else {
	tdist = (x - minc0) * C0_SCALE;
 802e19c:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e1a0:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 802e1a4:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e1a8:	681b      	ldr	r3, [r3, #0]
 802e1aa:	1ad3      	subs	r3, r2, r3
 802e1ac:	005b      	lsls	r3, r3, #1
 802e1ae:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist = tdist*tdist;
 802e1b2:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e1b6:	fb03 f303 	mul.w	r3, r3, r3
 802e1ba:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
 802e1be:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e1c2:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802e1c6:	681b      	ldr	r3, [r3, #0]
 802e1c8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e1cc:	3304      	adds	r3, #4
 802e1ce:	681a      	ldr	r2, [r3, #0]
 802e1d0:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802e1d4:	4413      	add	r3, r2
 802e1d6:	781b      	ldrb	r3, [r3, #0]
 802e1d8:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc1) {
 802e1dc:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e1e0:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e1e4:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e1e8:	681b      	ldr	r3, [r3, #0]
 802e1ea:	429a      	cmp	r2, r3
 802e1ec:	da29      	bge.n	802e242 <find_nearby_colors+0x254>
      tdist = (x - minc1) * C1_SCALE;
 802e1ee:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e1f2:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e1f6:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e1fa:	681b      	ldr	r3, [r3, #0]
 802e1fc:	1ad2      	subs	r2, r2, r3
 802e1fe:	4613      	mov	r3, r2
 802e200:	005b      	lsls	r3, r3, #1
 802e202:	4413      	add	r3, r2
 802e204:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802e208:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e20c:	fb03 f303 	mul.w	r3, r3, r3
 802e210:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802e214:	4413      	add	r3, r2
 802e216:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc1) * C1_SCALE;
 802e21a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e21e:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802e222:	1ad2      	subs	r2, r2, r3
 802e224:	4613      	mov	r3, r2
 802e226:	005b      	lsls	r3, r3, #1
 802e228:	4413      	add	r3, r2
 802e22a:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802e22e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e232:	fb03 f303 	mul.w	r3, r3, r3
 802e236:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e23a:	4413      	add	r3, r2
 802e23c:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e240:	e05f      	b.n	802e302 <find_nearby_colors+0x314>
    } else if (x > maxc1) {
 802e242:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e246:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802e24a:	429a      	cmp	r2, r3
 802e24c:	dd29      	ble.n	802e2a2 <find_nearby_colors+0x2b4>
      tdist = (x - maxc1) * C1_SCALE;
 802e24e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e252:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802e256:	1ad2      	subs	r2, r2, r3
 802e258:	4613      	mov	r3, r2
 802e25a:	005b      	lsls	r3, r3, #1
 802e25c:	4413      	add	r3, r2
 802e25e:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802e262:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e266:	fb03 f303 	mul.w	r3, r3, r3
 802e26a:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802e26e:	4413      	add	r3, r2
 802e270:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc1) * C1_SCALE;
 802e274:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e278:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e27c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e280:	681b      	ldr	r3, [r3, #0]
 802e282:	1ad2      	subs	r2, r2, r3
 802e284:	4613      	mov	r3, r2
 802e286:	005b      	lsls	r3, r3, #1
 802e288:	4413      	add	r3, r2
 802e28a:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802e28e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e292:	fb03 f303 	mul.w	r3, r3, r3
 802e296:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e29a:	4413      	add	r3, r2
 802e29c:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e2a0:	e02f      	b.n	802e302 <find_nearby_colors+0x314>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
 802e2a2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e2a6:	f8d7 3420 	ldr.w	r3, [r7, #1056]	@ 0x420
 802e2aa:	429a      	cmp	r2, r3
 802e2ac:	dc13      	bgt.n	802e2d6 <find_nearby_colors+0x2e8>
	tdist = (x - maxc1) * C1_SCALE;
 802e2ae:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e2b2:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 802e2b6:	1ad2      	subs	r2, r2, r3
 802e2b8:	4613      	mov	r3, r2
 802e2ba:	005b      	lsls	r3, r3, #1
 802e2bc:	4413      	add	r3, r2
 802e2be:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802e2c2:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e2c6:	fb03 f303 	mul.w	r3, r3, r3
 802e2ca:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e2ce:	4413      	add	r3, r2
 802e2d0:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e2d4:	e015      	b.n	802e302 <find_nearby_colors+0x314>
      } else {
	tdist = (x - minc1) * C1_SCALE;
 802e2d6:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e2da:	f2a3 4344 	subw	r3, r3, #1092	@ 0x444
 802e2de:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e2e2:	681b      	ldr	r3, [r3, #0]
 802e2e4:	1ad2      	subs	r2, r2, r3
 802e2e6:	4613      	mov	r3, r2
 802e2e8:	005b      	lsls	r3, r3, #1
 802e2ea:	4413      	add	r3, r2
 802e2ec:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802e2f0:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e2f4:	fb03 f303 	mul.w	r3, r3, r3
 802e2f8:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e2fc:	4413      	add	r3, r2
 802e2fe:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
 802e302:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e306:	f2a3 433c 	subw	r3, r3, #1084	@ 0x43c
 802e30a:	681b      	ldr	r3, [r3, #0]
 802e30c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e310:	3308      	adds	r3, #8
 802e312:	681a      	ldr	r2, [r3, #0]
 802e314:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802e318:	4413      	add	r3, r2
 802e31a:	781b      	ldrb	r3, [r3, #0]
 802e31c:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
    if (x < minc2) {
 802e320:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e324:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e328:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e32c:	681b      	ldr	r3, [r3, #0]
 802e32e:	429a      	cmp	r2, r3
 802e330:	da23      	bge.n	802e37a <find_nearby_colors+0x38c>
      tdist = (x - minc2) * C2_SCALE;
 802e332:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e336:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e33a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e33e:	681b      	ldr	r3, [r3, #0]
 802e340:	1ad3      	subs	r3, r2, r3
 802e342:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802e346:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e34a:	fb03 f303 	mul.w	r3, r3, r3
 802e34e:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802e352:	4413      	add	r3, r2
 802e354:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - maxc2) * C2_SCALE;
 802e358:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e35c:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802e360:	1ad3      	subs	r3, r2, r3
 802e362:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802e366:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e36a:	fb03 f303 	mul.w	r3, r3, r3
 802e36e:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e372:	4413      	add	r3, r2
 802e374:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e378:	e053      	b.n	802e422 <find_nearby_colors+0x434>
    } else if (x > maxc2) {
 802e37a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e37e:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802e382:	429a      	cmp	r2, r3
 802e384:	dd23      	ble.n	802e3ce <find_nearby_colors+0x3e0>
      tdist = (x - maxc2) * C2_SCALE;
 802e386:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e38a:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802e38e:	1ad3      	subs	r3, r2, r3
 802e390:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      min_dist += tdist*tdist;
 802e394:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e398:	fb03 f303 	mul.w	r3, r3, r3
 802e39c:	f8d7 2438 	ldr.w	r2, [r7, #1080]	@ 0x438
 802e3a0:	4413      	add	r3, r2
 802e3a2:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
      tdist = (x - minc2) * C2_SCALE;
 802e3a6:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e3aa:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e3ae:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e3b2:	681b      	ldr	r3, [r3, #0]
 802e3b4:	1ad3      	subs	r3, r2, r3
 802e3b6:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
      max_dist += tdist*tdist;
 802e3ba:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e3be:	fb03 f303 	mul.w	r3, r3, r3
 802e3c2:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e3c6:	4413      	add	r3, r2
 802e3c8:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e3cc:	e029      	b.n	802e422 <find_nearby_colors+0x434>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
 802e3ce:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e3d2:	f8d7 3418 	ldr.w	r3, [r7, #1048]	@ 0x418
 802e3d6:	429a      	cmp	r2, r3
 802e3d8:	dc10      	bgt.n	802e3fc <find_nearby_colors+0x40e>
	tdist = (x - maxc2) * C2_SCALE;
 802e3da:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e3de:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 802e3e2:	1ad3      	subs	r3, r2, r3
 802e3e4:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802e3e8:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e3ec:	fb03 f303 	mul.w	r3, r3, r3
 802e3f0:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e3f4:	4413      	add	r3, r2
 802e3f6:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
 802e3fa:	e012      	b.n	802e422 <find_nearby_colors+0x434>
      } else {
	tdist = (x - minc2) * C2_SCALE;
 802e3fc:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e400:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 802e404:	f8d7 2414 	ldr.w	r2, [r7, #1044]	@ 0x414
 802e408:	681b      	ldr	r3, [r3, #0]
 802e40a:	1ad3      	subs	r3, r2, r3
 802e40c:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	max_dist += tdist*tdist;
 802e410:	f8d7 3410 	ldr.w	r3, [r7, #1040]	@ 0x410
 802e414:	fb03 f303 	mul.w	r3, r3, r3
 802e418:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e41c:	4413      	add	r3, r2
 802e41e:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
      }
    }

    mindist[i] = min_dist;	/* save away the results */
 802e422:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e426:	f5a3 6387 	sub.w	r3, r3, #1080	@ 0x438
 802e42a:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802e42e:	f8d7 1438 	ldr.w	r1, [r7, #1080]	@ 0x438
 802e432:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    if (max_dist < minmaxdist)
 802e436:	f8d7 2434 	ldr.w	r2, [r7, #1076]	@ 0x434
 802e43a:	f8d7 343c 	ldr.w	r3, [r7, #1084]	@ 0x43c
 802e43e:	429a      	cmp	r2, r3
 802e440:	da03      	bge.n	802e44a <find_nearby_colors+0x45c>
      minmaxdist = max_dist;
 802e442:	f8d7 3434 	ldr.w	r3, [r7, #1076]	@ 0x434
 802e446:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c
  for (i = 0; i < numcolors; i++) {
 802e44a:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802e44e:	3301      	adds	r3, #1
 802e450:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802e454:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802e458:	f8d7 3430 	ldr.w	r3, [r7, #1072]	@ 0x430
 802e45c:	429a      	cmp	r2, r3
 802e45e:	f6ff ae28 	blt.w	802e0b2 <find_nearby_colors+0xc4>

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
 802e462:	2300      	movs	r3, #0
 802e464:	f8c7 3440 	str.w	r3, [r7, #1088]	@ 0x440
  for (i = 0; i < numcolors; i++) {
 802e468:	2300      	movs	r3, #0
 802e46a:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802e46e:	e01d      	b.n	802e4ac <find_nearby_colors+0x4be>
    if (mindist[i] <= minmaxdist)
 802e470:	f507 6389 	add.w	r3, r7, #1096	@ 0x448
 802e474:	f5a3 6387 	sub.w	r3, r3, #1080	@ 0x438
 802e478:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802e47c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802e480:	f8d7 243c 	ldr.w	r2, [r7, #1084]	@ 0x43c
 802e484:	429a      	cmp	r2, r3
 802e486:	db0c      	blt.n	802e4a2 <find_nearby_colors+0x4b4>
      colorlist[ncolors++] = (JSAMPLE) i;
 802e488:	f8d7 3440 	ldr.w	r3, [r7, #1088]	@ 0x440
 802e48c:	1c5a      	adds	r2, r3, #1
 802e48e:	f8c7 2440 	str.w	r2, [r7, #1088]	@ 0x440
 802e492:	461a      	mov	r2, r3
 802e494:	f8d7 3450 	ldr.w	r3, [r7, #1104]	@ 0x450
 802e498:	4413      	add	r3, r2
 802e49a:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802e49e:	b2d2      	uxtb	r2, r2
 802e4a0:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numcolors; i++) {
 802e4a2:	f8d7 3444 	ldr.w	r3, [r7, #1092]	@ 0x444
 802e4a6:	3301      	adds	r3, #1
 802e4a8:	f8c7 3444 	str.w	r3, [r7, #1092]	@ 0x444
 802e4ac:	f8d7 2444 	ldr.w	r2, [r7, #1092]	@ 0x444
 802e4b0:	f8d7 3430 	ldr.w	r3, [r7, #1072]	@ 0x430
 802e4b4:	429a      	cmp	r2, r3
 802e4b6:	dbdb      	blt.n	802e470 <find_nearby_colors+0x482>
  }
  return ncolors;
 802e4b8:	f8d7 3440 	ldr.w	r3, [r7, #1088]	@ 0x440
}
 802e4bc:	4618      	mov	r0, r3
 802e4be:	f507 6789 	add.w	r7, r7, #1096	@ 0x448
 802e4c2:	46bd      	mov	sp, r7
 802e4c4:	bc90      	pop	{r4, r7}
 802e4c6:	4770      	bx	lr

0802e4c8 <find_best_colors>:
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
 802e4c8:	b4f0      	push	{r4, r5, r6, r7}
 802e4ca:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 802e4ce:	af00      	add	r7, sp, #0
 802e4d0:	f507 7412 	add.w	r4, r7, #584	@ 0x248
 802e4d4:	f5a4 740f 	sub.w	r4, r4, #572	@ 0x23c
 802e4d8:	6020      	str	r0, [r4, #0]
 802e4da:	f507 7012 	add.w	r0, r7, #584	@ 0x248
 802e4de:	f5a0 7010 	sub.w	r0, r0, #576	@ 0x240
 802e4e2:	6001      	str	r1, [r0, #0]
 802e4e4:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 802e4e8:	f5a1 7111 	sub.w	r1, r1, #580	@ 0x244
 802e4ec:	600a      	str	r2, [r1, #0]
 802e4ee:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 802e4f2:	f5a2 7212 	sub.w	r2, r2, #584	@ 0x248
 802e4f6:	6013      	str	r3, [r2, #0]
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
 802e4f8:	f107 0414 	add.w	r4, r7, #20
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 802e4fc:	237f      	movs	r3, #127	@ 0x7f
 802e4fe:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802e502:	e009      	b.n	802e518 <find_best_colors+0x50>
    *bptr++ = 0x7FFFFFFFL;
 802e504:	4623      	mov	r3, r4
 802e506:	1d1c      	adds	r4, r3, #4
 802e508:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 802e50c:	601a      	str	r2, [r3, #0]
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 802e50e:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802e512:	3b01      	subs	r3, #1
 802e514:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802e518:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802e51c:	2b00      	cmp	r3, #0
 802e51e:	daf1      	bge.n	802e504 <find_best_colors+0x3c>
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
 802e520:	2300      	movs	r3, #0
 802e522:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802e526:	e0e7      	b.n	802e6f8 <find_best_colors+0x230>
    icolor = GETJSAMPLE(colorlist[i]);
 802e528:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802e52c:	f8d7 225c 	ldr.w	r2, [r7, #604]	@ 0x25c
 802e530:	4413      	add	r3, r2
 802e532:	781b      	ldrb	r3, [r3, #0]
 802e534:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
 802e538:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e53c:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802e540:	681b      	ldr	r3, [r3, #0]
 802e542:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e546:	681a      	ldr	r2, [r3, #0]
 802e548:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802e54c:	4413      	add	r3, r2
 802e54e:	781b      	ldrb	r3, [r3, #0]
 802e550:	461a      	mov	r2, r3
 802e552:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e556:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 802e55a:	681b      	ldr	r3, [r3, #0]
 802e55c:	1a9b      	subs	r3, r3, r2
 802e55e:	005b      	lsls	r3, r3, #1
 802e560:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    dist0 = inc0*inc0;
 802e564:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802e568:	fb03 f303 	mul.w	r3, r3, r3
 802e56c:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
 802e570:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e574:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802e578:	681b      	ldr	r3, [r3, #0]
 802e57a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e57e:	3304      	adds	r3, #4
 802e580:	681a      	ldr	r2, [r3, #0]
 802e582:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802e586:	4413      	add	r3, r2
 802e588:	781b      	ldrb	r3, [r3, #0]
 802e58a:	461a      	mov	r2, r3
 802e58c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e590:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 802e594:	681b      	ldr	r3, [r3, #0]
 802e596:	1a9a      	subs	r2, r3, r2
 802e598:	4613      	mov	r3, r2
 802e59a:	005b      	lsls	r3, r3, #1
 802e59c:	4413      	add	r3, r2
 802e59e:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    dist0 += inc1*inc1;
 802e5a2:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 802e5a6:	fb03 f303 	mul.w	r3, r3, r3
 802e5aa:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802e5ae:	4413      	add	r3, r2
 802e5b0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
 802e5b4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e5b8:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 802e5bc:	681b      	ldr	r3, [r3, #0]
 802e5be:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802e5c2:	3308      	adds	r3, #8
 802e5c4:	681a      	ldr	r2, [r3, #0]
 802e5c6:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802e5ca:	4413      	add	r3, r2
 802e5cc:	781b      	ldrb	r3, [r3, #0]
 802e5ce:	461a      	mov	r2, r3
 802e5d0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 802e5d4:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 802e5d8:	681b      	ldr	r3, [r3, #0]
 802e5da:	1a9b      	subs	r3, r3, r2
 802e5dc:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    dist0 += inc2*inc2;
 802e5e0:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802e5e4:	fb03 f303 	mul.w	r3, r3, r3
 802e5e8:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802e5ec:	4413      	add	r3, r2
 802e5ee:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
 802e5f2:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802e5f6:	3308      	adds	r3, #8
 802e5f8:	015b      	lsls	r3, r3, #5
 802e5fa:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
 802e5fe:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 802e602:	4613      	mov	r3, r2
 802e604:	005b      	lsls	r3, r3, #1
 802e606:	4413      	add	r3, r2
 802e608:	00db      	lsls	r3, r3, #3
 802e60a:	3390      	adds	r3, #144	@ 0x90
 802e60c:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
 802e610:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 802e614:	3304      	adds	r3, #4
 802e616:	011b      	lsls	r3, r3, #4
 802e618:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
 802e61c:	f107 0414 	add.w	r4, r7, #20
    cptr = bestcolor;
 802e620:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 802e624:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    xx0 = inc0;
 802e628:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 802e62c:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 802e630:	2303      	movs	r3, #3
 802e632:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
 802e636:	e056      	b.n	802e6e6 <find_best_colors+0x21e>
      dist1 = dist0;
 802e638:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 802e63c:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
      xx1 = inc1;
 802e640:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 802e644:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 802e648:	2307      	movs	r3, #7
 802e64a:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
 802e64e:	e034      	b.n	802e6ba <find_best_colors+0x1f2>
	dist2 = dist1;
 802e650:	f8d7 522c 	ldr.w	r5, [r7, #556]	@ 0x22c
	xx2 = inc2;
 802e654:	f8d7 6214 	ldr.w	r6, [r7, #532]	@ 0x214
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 802e658:	2303      	movs	r3, #3
 802e65a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
 802e65e:	e016      	b.n	802e68e <find_best_colors+0x1c6>
	  if (dist2 < *bptr) {
 802e660:	6823      	ldr	r3, [r4, #0]
 802e662:	429d      	cmp	r5, r3
 802e664:	da06      	bge.n	802e674 <find_best_colors+0x1ac>
	    *bptr = dist2;
 802e666:	6025      	str	r5, [r4, #0]
	    *cptr = (JSAMPLE) icolor;
 802e668:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 802e66c:	b2da      	uxtb	r2, r3
 802e66e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802e672:	701a      	strb	r2, [r3, #0]
	  }
	  dist2 += xx2;
 802e674:	4435      	add	r5, r6
	  xx2 += 2 * STEP_C2 * STEP_C2;
 802e676:	3680      	adds	r6, #128	@ 0x80
	  bptr++;
 802e678:	3404      	adds	r4, #4
	  cptr++;
 802e67a:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 802e67e:	3301      	adds	r3, #1
 802e680:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 802e684:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802e688:	3b01      	subs	r3, #1
 802e68a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
 802e68e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 802e692:	2b00      	cmp	r3, #0
 802e694:	dae4      	bge.n	802e660 <find_best_colors+0x198>
	}
	dist1 += xx1;
 802e696:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 802e69a:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802e69e:	4413      	add	r3, r2
 802e6a0:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
	xx1 += 2 * STEP_C1 * STEP_C1;
 802e6a4:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 802e6a8:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 802e6ac:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 802e6b0:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802e6b4:	3b01      	subs	r3, #1
 802e6b6:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
 802e6ba:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 802e6be:	2b00      	cmp	r3, #0
 802e6c0:	dac6      	bge.n	802e650 <find_best_colors+0x188>
      }
      dist0 += xx0;
 802e6c2:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 802e6c6:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802e6ca:	4413      	add	r3, r2
 802e6cc:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
      xx0 += 2 * STEP_C0 * STEP_C0;
 802e6d0:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 802e6d4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 802e6d8:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 802e6dc:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802e6e0:	3b01      	subs	r3, #1
 802e6e2:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
 802e6e6:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 802e6ea:	2b00      	cmp	r3, #0
 802e6ec:	daa4      	bge.n	802e638 <find_best_colors+0x170>
  for (i = 0; i < numcolors; i++) {
 802e6ee:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 802e6f2:	3301      	adds	r3, #1
 802e6f4:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 802e6f8:	f8d7 2238 	ldr.w	r2, [r7, #568]	@ 0x238
 802e6fc:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 802e700:	429a      	cmp	r2, r3
 802e702:	f6ff af11 	blt.w	802e528 <find_best_colors+0x60>
    }
  }
}
 802e706:	bf00      	nop
 802e708:	bf00      	nop
 802e70a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 802e70e:	46bd      	mov	sp, r7
 802e710:	bcf0      	pop	{r4, r5, r6, r7}
 802e712:	4770      	bx	lr

0802e714 <fill_inverse_cmap>:
LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
 802e714:	b5b0      	push	{r4, r5, r7, lr}
 802e716:	b0f2      	sub	sp, #456	@ 0x1c8
 802e718:	af04      	add	r7, sp, #16
 802e71a:	f507 74dc 	add.w	r4, r7, #440	@ 0x1b8
 802e71e:	f5a4 74d6 	sub.w	r4, r4, #428	@ 0x1ac
 802e722:	6020      	str	r0, [r4, #0]
 802e724:	f507 70dc 	add.w	r0, r7, #440	@ 0x1b8
 802e728:	f5a0 70d8 	sub.w	r0, r0, #432	@ 0x1b0
 802e72c:	6001      	str	r1, [r0, #0]
 802e72e:	f507 71dc 	add.w	r1, r7, #440	@ 0x1b8
 802e732:	f5a1 71da 	sub.w	r1, r1, #436	@ 0x1b4
 802e736:	600a      	str	r2, [r1, #0]
 802e738:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e73c:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802e740:	6013      	str	r3, [r2, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802e742:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e746:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
 802e74a:	681b      	ldr	r3, [r3, #0]
 802e74c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802e750:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
  hist3d histogram = cquantize->histogram;
 802e754:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 802e758:	699b      	ldr	r3, [r3, #24]
 802e75a:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
 802e75e:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e762:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802e766:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e76a:	f5a2 72d8 	sub.w	r2, r2, #432	@ 0x1b0
 802e76e:	6812      	ldr	r2, [r2, #0]
 802e770:	1092      	asrs	r2, r2, #2
 802e772:	601a      	str	r2, [r3, #0]
  c1 >>= BOX_C1_LOG;
 802e774:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e778:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802e77c:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e780:	f5a2 72da 	sub.w	r2, r2, #436	@ 0x1b4
 802e784:	6812      	ldr	r2, [r2, #0]
 802e786:	10d2      	asrs	r2, r2, #3
 802e788:	601a      	str	r2, [r3, #0]
  c2 >>= BOX_C2_LOG;
 802e78a:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e78e:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802e792:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e796:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802e79a:	6812      	ldr	r2, [r2, #0]
 802e79c:	1092      	asrs	r2, r2, #2
 802e79e:	601a      	str	r2, [r3, #0]

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
 802e7a0:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e7a4:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802e7a8:	681b      	ldr	r3, [r3, #0]
 802e7aa:	015b      	lsls	r3, r3, #5
 802e7ac:	3304      	adds	r3, #4
 802e7ae:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
 802e7b2:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e7b6:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802e7ba:	681b      	ldr	r3, [r3, #0]
 802e7bc:	015b      	lsls	r3, r3, #5
 802e7be:	3302      	adds	r3, #2
 802e7c0:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
 802e7c4:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e7c8:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802e7cc:	681b      	ldr	r3, [r3, #0]
 802e7ce:	015b      	lsls	r3, r3, #5
 802e7d0:	3304      	adds	r3, #4
 802e7d2:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
 802e7d6:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e7da:	f5a3 70d6 	sub.w	r0, r3, #428	@ 0x1ac
 802e7de:	f107 0394 	add.w	r3, r7, #148	@ 0x94
 802e7e2:	9300      	str	r3, [sp, #0]
 802e7e4:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802e7e8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 802e7ec:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 802e7f0:	6800      	ldr	r0, [r0, #0]
 802e7f2:	f7ff fbfc 	bl	802dfee <find_nearby_colors>
 802e7f6:	f8c7 0194 	str.w	r0, [r7, #404]	@ 0x194

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
 802e7fa:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e7fe:	f5a3 70d6 	sub.w	r0, r3, #428	@ 0x1ac
 802e802:	f107 0314 	add.w	r3, r7, #20
 802e806:	9302      	str	r3, [sp, #8]
 802e808:	f107 0394 	add.w	r3, r7, #148	@ 0x94
 802e80c:	9301      	str	r3, [sp, #4]
 802e80e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 802e812:	9300      	str	r3, [sp, #0]
 802e814:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 802e818:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 802e81c:	f8d7 11a0 	ldr.w	r1, [r7, #416]	@ 0x1a0
 802e820:	6800      	ldr	r0, [r0, #0]
 802e822:	f7ff fe51 	bl	802e4c8 <find_best_colors>
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
 802e826:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e82a:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802e82e:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e832:	f5a2 72d8 	sub.w	r2, r2, #432	@ 0x1b0
 802e836:	6812      	ldr	r2, [r2, #0]
 802e838:	0092      	lsls	r2, r2, #2
 802e83a:	601a      	str	r2, [r3, #0]
  c1 <<= BOX_C1_LOG;
 802e83c:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e840:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802e844:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e848:	f5a2 72da 	sub.w	r2, r2, #436	@ 0x1b4
 802e84c:	6812      	ldr	r2, [r2, #0]
 802e84e:	00d2      	lsls	r2, r2, #3
 802e850:	601a      	str	r2, [r3, #0]
  c2 <<= BOX_C2_LOG;
 802e852:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e856:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802e85a:	f507 72dc 	add.w	r2, r7, #440	@ 0x1b8
 802e85e:	f5a2 72dc 	sub.w	r2, r2, #440	@ 0x1b8
 802e862:	6812      	ldr	r2, [r2, #0]
 802e864:	0092      	lsls	r2, r2, #2
 802e866:	601a      	str	r2, [r3, #0]
  cptr = bestcolor;
 802e868:	f107 0414 	add.w	r4, r7, #20
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 802e86c:	2300      	movs	r3, #0
 802e86e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 802e872:	e045      	b.n	802e900 <fill_inverse_cmap+0x1ec>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802e874:	2300      	movs	r3, #0
 802e876:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
 802e87a:	e038      	b.n	802e8ee <fill_inverse_cmap+0x1da>
      cachep = & histogram[c0+ic0][c1+ic1][c2];
 802e87c:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e880:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 802e884:	681a      	ldr	r2, [r3, #0]
 802e886:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802e88a:	4413      	add	r3, r2
 802e88c:	009b      	lsls	r3, r3, #2
 802e88e:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 802e892:	4413      	add	r3, r2
 802e894:	681a      	ldr	r2, [r3, #0]
 802e896:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e89a:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 802e89e:	6819      	ldr	r1, [r3, #0]
 802e8a0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802e8a4:	440b      	add	r3, r1
 802e8a6:	019b      	lsls	r3, r3, #6
 802e8a8:	441a      	add	r2, r3
 802e8aa:	f507 73dc 	add.w	r3, r7, #440	@ 0x1b8
 802e8ae:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 802e8b2:	681b      	ldr	r3, [r3, #0]
 802e8b4:	005b      	lsls	r3, r3, #1
 802e8b6:	18d5      	adds	r5, r2, r3
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 802e8b8:	2300      	movs	r3, #0
 802e8ba:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
 802e8be:	e00d      	b.n	802e8dc <fill_inverse_cmap+0x1c8>
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
 802e8c0:	4623      	mov	r3, r4
 802e8c2:	1c5c      	adds	r4, r3, #1
 802e8c4:	781b      	ldrb	r3, [r3, #0]
 802e8c6:	461a      	mov	r2, r3
 802e8c8:	462b      	mov	r3, r5
 802e8ca:	1c9d      	adds	r5, r3, #2
 802e8cc:	3201      	adds	r2, #1
 802e8ce:	b292      	uxth	r2, r2
 802e8d0:	801a      	strh	r2, [r3, #0]
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 802e8d2:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802e8d6:	3301      	adds	r3, #1
 802e8d8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
 802e8dc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 802e8e0:	2b03      	cmp	r3, #3
 802e8e2:	dded      	ble.n	802e8c0 <fill_inverse_cmap+0x1ac>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802e8e4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802e8e8:	3301      	adds	r3, #1
 802e8ea:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
 802e8ee:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 802e8f2:	2b07      	cmp	r3, #7
 802e8f4:	ddc2      	ble.n	802e87c <fill_inverse_cmap+0x168>
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 802e8f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802e8fa:	3301      	adds	r3, #1
 802e8fc:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
 802e900:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 802e904:	2b03      	cmp	r3, #3
 802e906:	ddb5      	ble.n	802e874 <fill_inverse_cmap+0x160>
      }
    }
  }
}
 802e908:	bf00      	nop
 802e90a:	bf00      	nop
 802e90c:	f507 77dc 	add.w	r7, r7, #440	@ 0x1b8
 802e910:	46bd      	mov	sp, r7
 802e912:	bdb0      	pop	{r4, r5, r7, pc}

0802e914 <pass2_no_dither>:

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
 802e914:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802e918:	b08a      	sub	sp, #40	@ 0x28
 802e91a:	af00      	add	r7, sp, #0
 802e91c:	60f8      	str	r0, [r7, #12]
 802e91e:	60b9      	str	r1, [r7, #8]
 802e920:	607a      	str	r2, [r7, #4]
 802e922:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802e924:	68fb      	ldr	r3, [r7, #12]
 802e926:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802e92a:	61fb      	str	r3, [r7, #28]
  hist3d histogram = cquantize->histogram;
 802e92c:	69fb      	ldr	r3, [r7, #28]
 802e92e:	699b      	ldr	r3, [r3, #24]
 802e930:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802e932:	68fb      	ldr	r3, [r7, #12]
 802e934:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802e936:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 802e938:	2300      	movs	r3, #0
 802e93a:	627b      	str	r3, [r7, #36]	@ 0x24
 802e93c:	e042      	b.n	802e9c4 <pass2_no_dither+0xb0>
    inptr = input_buf[row];
 802e93e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802e940:	009b      	lsls	r3, r3, #2
 802e942:	68ba      	ldr	r2, [r7, #8]
 802e944:	4413      	add	r3, r2
 802e946:	681c      	ldr	r4, [r3, #0]
    outptr = output_buf[row];
 802e948:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802e94a:	009b      	lsls	r3, r3, #2
 802e94c:	687a      	ldr	r2, [r7, #4]
 802e94e:	4413      	add	r3, r2
 802e950:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 802e952:	697b      	ldr	r3, [r7, #20]
 802e954:	623b      	str	r3, [r7, #32]
 802e956:	e02f      	b.n	802e9b8 <pass2_no_dither+0xa4>
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
 802e958:	4623      	mov	r3, r4
 802e95a:	1c5c      	adds	r4, r3, #1
 802e95c:	781b      	ldrb	r3, [r3, #0]
 802e95e:	08db      	lsrs	r3, r3, #3
 802e960:	b2db      	uxtb	r3, r3
 802e962:	4699      	mov	r9, r3
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
 802e964:	4623      	mov	r3, r4
 802e966:	1c5c      	adds	r4, r3, #1
 802e968:	781b      	ldrb	r3, [r3, #0]
 802e96a:	089b      	lsrs	r3, r3, #2
 802e96c:	b2db      	uxtb	r3, r3
 802e96e:	469a      	mov	sl, r3
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
 802e970:	4623      	mov	r3, r4
 802e972:	1c5c      	adds	r4, r3, #1
 802e974:	781b      	ldrb	r3, [r3, #0]
 802e976:	08db      	lsrs	r3, r3, #3
 802e978:	b2db      	uxtb	r3, r3
 802e97a:	4698      	mov	r8, r3
      cachep = & histogram[c0][c1][c2];
 802e97c:	464b      	mov	r3, r9
 802e97e:	009b      	lsls	r3, r3, #2
 802e980:	69ba      	ldr	r2, [r7, #24]
 802e982:	4413      	add	r3, r2
 802e984:	681a      	ldr	r2, [r3, #0]
 802e986:	4653      	mov	r3, sl
 802e988:	019b      	lsls	r3, r3, #6
 802e98a:	441a      	add	r2, r3
 802e98c:	ea4f 0348 	mov.w	r3, r8, lsl #1
 802e990:	18d5      	adds	r5, r2, r3
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
 802e992:	882b      	ldrh	r3, [r5, #0]
 802e994:	2b00      	cmp	r3, #0
 802e996:	d105      	bne.n	802e9a4 <pass2_no_dither+0x90>
	fill_inverse_cmap(cinfo, c0,c1,c2);
 802e998:	4643      	mov	r3, r8
 802e99a:	4652      	mov	r2, sl
 802e99c:	4649      	mov	r1, r9
 802e99e:	68f8      	ldr	r0, [r7, #12]
 802e9a0:	f7ff feb8 	bl	802e714 <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
 802e9a4:	882b      	ldrh	r3, [r5, #0]
 802e9a6:	b2da      	uxtb	r2, r3
 802e9a8:	4633      	mov	r3, r6
 802e9aa:	1c5e      	adds	r6, r3, #1
 802e9ac:	3a01      	subs	r2, #1
 802e9ae:	b2d2      	uxtb	r2, r2
 802e9b0:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802e9b2:	6a3b      	ldr	r3, [r7, #32]
 802e9b4:	3b01      	subs	r3, #1
 802e9b6:	623b      	str	r3, [r7, #32]
 802e9b8:	6a3b      	ldr	r3, [r7, #32]
 802e9ba:	2b00      	cmp	r3, #0
 802e9bc:	d1cc      	bne.n	802e958 <pass2_no_dither+0x44>
  for (row = 0; row < num_rows; row++) {
 802e9be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802e9c0:	3301      	adds	r3, #1
 802e9c2:	627b      	str	r3, [r7, #36]	@ 0x24
 802e9c4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802e9c6:	683b      	ldr	r3, [r7, #0]
 802e9c8:	429a      	cmp	r2, r3
 802e9ca:	dbb8      	blt.n	802e93e <pass2_no_dither+0x2a>
    }
  }
}
 802e9cc:	bf00      	nop
 802e9ce:	bf00      	nop
 802e9d0:	3728      	adds	r7, #40	@ 0x28
 802e9d2:	46bd      	mov	sp, r7
 802e9d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802e9d8 <pass2_fs_dither>:

METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
 802e9d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e9dc:	b09c      	sub	sp, #112	@ 0x70
 802e9de:	af00      	add	r7, sp, #0
 802e9e0:	6178      	str	r0, [r7, #20]
 802e9e2:	6139      	str	r1, [r7, #16]
 802e9e4:	60fa      	str	r2, [r7, #12]
 802e9e6:	60bb      	str	r3, [r7, #8]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802e9e8:	697b      	ldr	r3, [r7, #20]
 802e9ea:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802e9ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
  hist3d histogram = cquantize->histogram;
 802e9f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802e9f2:	699b      	ldr	r3, [r3, #24]
 802e9f4:	63bb      	str	r3, [r7, #56]	@ 0x38
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802e9f6:	697b      	ldr	r3, [r7, #20]
 802e9f8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 802e9fa:	637b      	str	r3, [r7, #52]	@ 0x34
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 802e9fc:	697b      	ldr	r3, [r7, #20]
 802e9fe:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
 802ea02:	633b      	str	r3, [r7, #48]	@ 0x30
  int *error_limit = cquantize->error_limiter;
 802ea04:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802ea06:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802ea08:	62fb      	str	r3, [r7, #44]	@ 0x2c
  JSAMPROW colormap0 = cinfo->colormap[0];
 802ea0a:	697b      	ldr	r3, [r7, #20]
 802ea0c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802ea10:	681b      	ldr	r3, [r3, #0]
 802ea12:	62bb      	str	r3, [r7, #40]	@ 0x28
  JSAMPROW colormap1 = cinfo->colormap[1];
 802ea14:	697b      	ldr	r3, [r7, #20]
 802ea16:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802ea1a:	685b      	ldr	r3, [r3, #4]
 802ea1c:	627b      	str	r3, [r7, #36]	@ 0x24
  JSAMPROW colormap2 = cinfo->colormap[2];
 802ea1e:	697b      	ldr	r3, [r7, #20]
 802ea20:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 802ea24:	689b      	ldr	r3, [r3, #8]
 802ea26:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 802ea28:	2300      	movs	r3, #0
 802ea2a:	647b      	str	r3, [r7, #68]	@ 0x44
 802ea2c:	e115      	b.n	802ec5a <pass2_fs_dither+0x282>
    inptr = input_buf[row];
 802ea2e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802ea30:	009b      	lsls	r3, r3, #2
 802ea32:	693a      	ldr	r2, [r7, #16]
 802ea34:	4413      	add	r3, r2
 802ea36:	681b      	ldr	r3, [r3, #0]
 802ea38:	657b      	str	r3, [r7, #84]	@ 0x54
    outptr = output_buf[row];
 802ea3a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802ea3c:	009b      	lsls	r3, r3, #2
 802ea3e:	68fa      	ldr	r2, [r7, #12]
 802ea40:	4413      	add	r3, r2
 802ea42:	681b      	ldr	r3, [r3, #0]
 802ea44:	653b      	str	r3, [r7, #80]	@ 0x50
    if (cquantize->on_odd_row) {
 802ea46:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802ea48:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802ea4a:	2b00      	cmp	r3, #0
 802ea4c:	d020      	beq.n	802ea90 <pass2_fs_dither+0xb8>
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
 802ea4e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802ea50:	4613      	mov	r3, r2
 802ea52:	005b      	lsls	r3, r3, #1
 802ea54:	4413      	add	r3, r2
 802ea56:	3b03      	subs	r3, #3
 802ea58:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802ea5a:	4413      	add	r3, r2
 802ea5c:	657b      	str	r3, [r7, #84]	@ 0x54
      outptr += width-1;
 802ea5e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ea60:	3b01      	subs	r3, #1
 802ea62:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802ea64:	4413      	add	r3, r2
 802ea66:	653b      	str	r3, [r7, #80]	@ 0x50
      dir = -1;
 802ea68:	f04f 33ff 	mov.w	r3, #4294967295
 802ea6c:	64fb      	str	r3, [r7, #76]	@ 0x4c
      dir3 = -3;
 802ea6e:	f06f 0302 	mvn.w	r3, #2
 802ea72:	64bb      	str	r3, [r7, #72]	@ 0x48
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
 802ea74:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802ea76:	6a19      	ldr	r1, [r3, #32]
 802ea78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802ea7a:	1c5a      	adds	r2, r3, #1
 802ea7c:	4613      	mov	r3, r2
 802ea7e:	005b      	lsls	r3, r3, #1
 802ea80:	4413      	add	r3, r2
 802ea82:	005b      	lsls	r3, r3, #1
 802ea84:	18cb      	adds	r3, r1, r3
 802ea86:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = FALSE; /* flip for next time */
 802ea88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802ea8a:	2200      	movs	r2, #0
 802ea8c:	625a      	str	r2, [r3, #36]	@ 0x24
 802ea8e:	e009      	b.n	802eaa4 <pass2_fs_dither+0xcc>
    } else {
      /* work left to right in this row */
      dir = 1;
 802ea90:	2301      	movs	r3, #1
 802ea92:	64fb      	str	r3, [r7, #76]	@ 0x4c
      dir3 = 3;
 802ea94:	2303      	movs	r3, #3
 802ea96:	64bb      	str	r3, [r7, #72]	@ 0x48
      errorptr = cquantize->fserrors; /* => entry before first real column */
 802ea98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802ea9a:	6a1b      	ldr	r3, [r3, #32]
 802ea9c:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = TRUE; /* flip for next time */
 802ea9e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802eaa0:	2201      	movs	r2, #1
 802eaa2:	625a      	str	r2, [r3, #36]	@ 0x24
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
 802eaa4:	2400      	movs	r4, #0
 802eaa6:	4625      	mov	r5, r4
 802eaa8:	462e      	mov	r6, r5
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
 802eaaa:	2300      	movs	r3, #0
 802eaac:	667b      	str	r3, [r7, #100]	@ 0x64
 802eaae:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802eab0:	66bb      	str	r3, [r7, #104]	@ 0x68
 802eab2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802eab4:	66fb      	str	r3, [r7, #108]	@ 0x6c
    bpreverr0 = bpreverr1 = bpreverr2 = 0;
 802eab6:	2300      	movs	r3, #0
 802eab8:	65bb      	str	r3, [r7, #88]	@ 0x58
 802eaba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802eabc:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802eabe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802eac0:	663b      	str	r3, [r7, #96]	@ 0x60

    for (col = width; col > 0; col--) {
 802eac2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802eac4:	643b      	str	r3, [r7, #64]	@ 0x40
 802eac6:	e0b5      	b.n	802ec34 <pass2_fs_dither+0x25c>
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
 802eac8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802eaca:	005b      	lsls	r3, r3, #1
 802eacc:	687a      	ldr	r2, [r7, #4]
 802eace:	4413      	add	r3, r2
 802ead0:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ead4:	4433      	add	r3, r6
 802ead6:	3308      	adds	r3, #8
 802ead8:	111e      	asrs	r6, r3, #4
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
 802eada:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802eadc:	3301      	adds	r3, #1
 802eade:	005b      	lsls	r3, r3, #1
 802eae0:	4413      	add	r3, r2
 802eae2:	f9b3 3000 	ldrsh.w	r3, [r3]
 802eae6:	442b      	add	r3, r5
 802eae8:	3308      	adds	r3, #8
 802eaea:	111d      	asrs	r5, r3, #4
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
 802eaec:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802eaee:	3302      	adds	r3, #2
 802eaf0:	005b      	lsls	r3, r3, #1
 802eaf2:	4413      	add	r3, r2
 802eaf4:	f9b3 3000 	ldrsh.w	r3, [r3]
 802eaf8:	4423      	add	r3, r4
 802eafa:	3308      	adds	r3, #8
 802eafc:	111c      	asrs	r4, r3, #4
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
 802eafe:	4633      	mov	r3, r6
 802eb00:	009b      	lsls	r3, r3, #2
 802eb02:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802eb04:	4413      	add	r3, r2
 802eb06:	681e      	ldr	r6, [r3, #0]
      cur1 = error_limit[cur1];
 802eb08:	462b      	mov	r3, r5
 802eb0a:	009b      	lsls	r3, r3, #2
 802eb0c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802eb0e:	4413      	add	r3, r2
 802eb10:	681d      	ldr	r5, [r3, #0]
      cur2 = error_limit[cur2];
 802eb12:	4623      	mov	r3, r4
 802eb14:	009b      	lsls	r3, r3, #2
 802eb16:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802eb18:	4413      	add	r3, r2
 802eb1a:	681c      	ldr	r4, [r3, #0]
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
 802eb1c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802eb1e:	781b      	ldrb	r3, [r3, #0]
 802eb20:	441e      	add	r6, r3
      cur1 += GETJSAMPLE(inptr[1]);
 802eb22:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802eb24:	3301      	adds	r3, #1
 802eb26:	781b      	ldrb	r3, [r3, #0]
 802eb28:	441d      	add	r5, r3
      cur2 += GETJSAMPLE(inptr[2]);
 802eb2a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802eb2c:	3302      	adds	r3, #2
 802eb2e:	781b      	ldrb	r3, [r3, #0]
 802eb30:	441c      	add	r4, r3
      cur0 = GETJSAMPLE(range_limit[cur0]);
 802eb32:	4632      	mov	r2, r6
 802eb34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802eb36:	4413      	add	r3, r2
 802eb38:	781b      	ldrb	r3, [r3, #0]
 802eb3a:	461e      	mov	r6, r3
      cur1 = GETJSAMPLE(range_limit[cur1]);
 802eb3c:	462a      	mov	r2, r5
 802eb3e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802eb40:	4413      	add	r3, r2
 802eb42:	781b      	ldrb	r3, [r3, #0]
 802eb44:	461d      	mov	r5, r3
      cur2 = GETJSAMPLE(range_limit[cur2]);
 802eb46:	4622      	mov	r2, r4
 802eb48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802eb4a:	4413      	add	r3, r2
 802eb4c:	781b      	ldrb	r3, [r3, #0]
 802eb4e:	461c      	mov	r4, r3
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
 802eb50:	10f3      	asrs	r3, r6, #3
 802eb52:	009b      	lsls	r3, r3, #2
 802eb54:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802eb56:	4413      	add	r3, r2
 802eb58:	681a      	ldr	r2, [r3, #0]
 802eb5a:	10ab      	asrs	r3, r5, #2
 802eb5c:	019b      	lsls	r3, r3, #6
 802eb5e:	441a      	add	r2, r3
 802eb60:	10e3      	asrs	r3, r4, #3
 802eb62:	005b      	lsls	r3, r3, #1
 802eb64:	4413      	add	r3, r2
 802eb66:	61fb      	str	r3, [r7, #28]
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
 802eb68:	69fb      	ldr	r3, [r7, #28]
 802eb6a:	881b      	ldrh	r3, [r3, #0]
 802eb6c:	2b00      	cmp	r3, #0
 802eb6e:	d105      	bne.n	802eb7c <pass2_fs_dither+0x1a4>
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
 802eb70:	10f1      	asrs	r1, r6, #3
 802eb72:	10aa      	asrs	r2, r5, #2
 802eb74:	10e3      	asrs	r3, r4, #3
 802eb76:	6978      	ldr	r0, [r7, #20]
 802eb78:	f7ff fdcc 	bl	802e714 <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
 802eb7c:	69fb      	ldr	r3, [r7, #28]
 802eb7e:	881b      	ldrh	r3, [r3, #0]
 802eb80:	f103 38ff 	add.w	r8, r3, #4294967295
	*outptr = (JSAMPLE) pixcode;
 802eb84:	fa5f f288 	uxtb.w	r2, r8
 802eb88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802eb8a:	701a      	strb	r2, [r3, #0]
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
 802eb8c:	4642      	mov	r2, r8
 802eb8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802eb90:	4413      	add	r3, r2
 802eb92:	781b      	ldrb	r3, [r3, #0]
 802eb94:	1af6      	subs	r6, r6, r3
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
 802eb96:	4642      	mov	r2, r8
 802eb98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802eb9a:	4413      	add	r3, r2
 802eb9c:	781b      	ldrb	r3, [r3, #0]
 802eb9e:	1aed      	subs	r5, r5, r3
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
 802eba0:	4642      	mov	r2, r8
 802eba2:	6a3b      	ldr	r3, [r7, #32]
 802eba4:	4413      	add	r3, r2
 802eba6:	781b      	ldrb	r3, [r3, #0]
 802eba8:	1ae4      	subs	r4, r4, r3
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
 802ebaa:	4630      	mov	r0, r6
	delta = cur0 * 2;
 802ebac:	ea4f 0846 	mov.w	r8, r6, lsl #1
	cur0 += delta;		/* form error * 3 */
 802ebb0:	4446      	add	r6, r8
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
 802ebb2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802ebb4:	b29a      	uxth	r2, r3
 802ebb6:	b2b3      	uxth	r3, r6
 802ebb8:	4413      	add	r3, r2
 802ebba:	b29b      	uxth	r3, r3
 802ebbc:	b21b      	sxth	r3, r3
 802ebbe:	6879      	ldr	r1, [r7, #4]
 802ebc0:	800b      	strh	r3, [r1, #0]
	cur0 += delta;		/* form error * 5 */
 802ebc2:	4446      	add	r6, r8
	bpreverr0 = belowerr0 + cur0;
 802ebc4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802ebc6:	4433      	add	r3, r6
 802ebc8:	663b      	str	r3, [r7, #96]	@ 0x60
	belowerr0 = bnexterr;
 802ebca:	66f8      	str	r0, [r7, #108]	@ 0x6c
	cur0 += delta;		/* form error * 7 */
 802ebcc:	4446      	add	r6, r8
	bnexterr = cur1;	/* Process component 1 */
 802ebce:	4628      	mov	r0, r5
	delta = cur1 * 2;
 802ebd0:	ea4f 0845 	mov.w	r8, r5, lsl #1
	cur1 += delta;		/* form error * 3 */
 802ebd4:	4445      	add	r5, r8
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
 802ebd6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802ebd8:	b29a      	uxth	r2, r3
 802ebda:	b2ab      	uxth	r3, r5
 802ebdc:	4413      	add	r3, r2
 802ebde:	b29a      	uxth	r2, r3
 802ebe0:	1c8b      	adds	r3, r1, #2
 802ebe2:	b212      	sxth	r2, r2
 802ebe4:	801a      	strh	r2, [r3, #0]
	cur1 += delta;		/* form error * 5 */
 802ebe6:	4445      	add	r5, r8
	bpreverr1 = belowerr1 + cur1;
 802ebe8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802ebea:	442b      	add	r3, r5
 802ebec:	65fb      	str	r3, [r7, #92]	@ 0x5c
	belowerr1 = bnexterr;
 802ebee:	66b8      	str	r0, [r7, #104]	@ 0x68
	cur1 += delta;		/* form error * 7 */
 802ebf0:	4445      	add	r5, r8
	bnexterr = cur2;	/* Process component 2 */
 802ebf2:	4620      	mov	r0, r4
	delta = cur2 * 2;
 802ebf4:	ea4f 0844 	mov.w	r8, r4, lsl #1
	cur2 += delta;		/* form error * 3 */
 802ebf8:	4444      	add	r4, r8
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
 802ebfa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802ebfc:	b29a      	uxth	r2, r3
 802ebfe:	b2a3      	uxth	r3, r4
 802ec00:	4413      	add	r3, r2
 802ec02:	b29a      	uxth	r2, r3
 802ec04:	1d0b      	adds	r3, r1, #4
 802ec06:	b212      	sxth	r2, r2
 802ec08:	801a      	strh	r2, [r3, #0]
	cur2 += delta;		/* form error * 5 */
 802ec0a:	4444      	add	r4, r8
	bpreverr2 = belowerr2 + cur2;
 802ec0c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802ec0e:	4423      	add	r3, r4
 802ec10:	65bb      	str	r3, [r7, #88]	@ 0x58
	belowerr2 = bnexterr;
 802ec12:	6678      	str	r0, [r7, #100]	@ 0x64
	cur2 += delta;		/* form error * 7 */
 802ec14:	4444      	add	r4, r8
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
 802ec16:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802ec18:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802ec1a:	4413      	add	r3, r2
 802ec1c:	657b      	str	r3, [r7, #84]	@ 0x54
      outptr += dir;
 802ec1e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802ec20:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802ec22:	4413      	add	r3, r2
 802ec24:	653b      	str	r3, [r7, #80]	@ 0x50
      errorptr += dir3;		/* advance errorptr to current column */
 802ec26:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802ec28:	005b      	lsls	r3, r3, #1
 802ec2a:	18cb      	adds	r3, r1, r3
 802ec2c:	607b      	str	r3, [r7, #4]
    for (col = width; col > 0; col--) {
 802ec2e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802ec30:	3b01      	subs	r3, #1
 802ec32:	643b      	str	r3, [r7, #64]	@ 0x40
 802ec34:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802ec36:	2b00      	cmp	r3, #0
 802ec38:	f47f af46 	bne.w	802eac8 <pass2_fs_dither+0xf0>
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
 802ec3c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802ec3e:	b21b      	sxth	r3, r3
 802ec40:	6879      	ldr	r1, [r7, #4]
 802ec42:	800b      	strh	r3, [r1, #0]
    errorptr[1] = (FSERROR) bpreverr1;
 802ec44:	1c8b      	adds	r3, r1, #2
 802ec46:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802ec48:	b212      	sxth	r2, r2
 802ec4a:	801a      	strh	r2, [r3, #0]
    errorptr[2] = (FSERROR) bpreverr2;
 802ec4c:	1d0b      	adds	r3, r1, #4
 802ec4e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 802ec50:	b212      	sxth	r2, r2
 802ec52:	801a      	strh	r2, [r3, #0]
  for (row = 0; row < num_rows; row++) {
 802ec54:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802ec56:	3301      	adds	r3, #1
 802ec58:	647b      	str	r3, [r7, #68]	@ 0x44
 802ec5a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802ec5c:	68bb      	ldr	r3, [r7, #8]
 802ec5e:	429a      	cmp	r2, r3
 802ec60:	f6ff aee5 	blt.w	802ea2e <pass2_fs_dither+0x56>
  }
}
 802ec64:	bf00      	nop
 802ec66:	bf00      	nop
 802ec68:	3770      	adds	r7, #112	@ 0x70
 802ec6a:	46bd      	mov	sp, r7
 802ec6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802ec70 <init_error_limit>:
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
 802ec70:	b580      	push	{r7, lr}
 802ec72:	b086      	sub	sp, #24
 802ec74:	af00      	add	r7, sp, #0
 802ec76:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ec78:	687b      	ldr	r3, [r7, #4]
 802ec7a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ec7e:	60fb      	str	r3, [r7, #12]
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
 802ec80:	687b      	ldr	r3, [r7, #4]
 802ec82:	685b      	ldr	r3, [r3, #4]
 802ec84:	681b      	ldr	r3, [r3, #0]
 802ec86:	f240 72fc 	movw	r2, #2044	@ 0x7fc
 802ec8a:	2101      	movs	r1, #1
 802ec8c:	6878      	ldr	r0, [r7, #4]
 802ec8e:	4798      	blx	r3
 802ec90:	60b8      	str	r0, [r7, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
 802ec92:	68bb      	ldr	r3, [r7, #8]
 802ec94:	f503 737f 	add.w	r3, r3, #1020	@ 0x3fc
 802ec98:	60bb      	str	r3, [r7, #8]
  cquantize->error_limiter = table;
 802ec9a:	68fb      	ldr	r3, [r7, #12]
 802ec9c:	68ba      	ldr	r2, [r7, #8]
 802ec9e:	629a      	str	r2, [r3, #40]	@ 0x28

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
 802eca0:	2300      	movs	r3, #0
 802eca2:	613b      	str	r3, [r7, #16]
  for (in = 0; in < STEPSIZE; in++, out++) {
 802eca4:	2300      	movs	r3, #0
 802eca6:	617b      	str	r3, [r7, #20]
 802eca8:	e016      	b.n	802ecd8 <init_error_limit+0x68>
    table[in] = out; table[-in] = -out;
 802ecaa:	697b      	ldr	r3, [r7, #20]
 802ecac:	009b      	lsls	r3, r3, #2
 802ecae:	68ba      	ldr	r2, [r7, #8]
 802ecb0:	4413      	add	r3, r2
 802ecb2:	693a      	ldr	r2, [r7, #16]
 802ecb4:	601a      	str	r2, [r3, #0]
 802ecb6:	697a      	ldr	r2, [r7, #20]
 802ecb8:	4613      	mov	r3, r2
 802ecba:	079b      	lsls	r3, r3, #30
 802ecbc:	1a9b      	subs	r3, r3, r2
 802ecbe:	009b      	lsls	r3, r3, #2
 802ecc0:	461a      	mov	r2, r3
 802ecc2:	68bb      	ldr	r3, [r7, #8]
 802ecc4:	4413      	add	r3, r2
 802ecc6:	693a      	ldr	r2, [r7, #16]
 802ecc8:	4252      	negs	r2, r2
 802ecca:	601a      	str	r2, [r3, #0]
  for (in = 0; in < STEPSIZE; in++, out++) {
 802eccc:	697b      	ldr	r3, [r7, #20]
 802ecce:	3301      	adds	r3, #1
 802ecd0:	617b      	str	r3, [r7, #20]
 802ecd2:	693b      	ldr	r3, [r7, #16]
 802ecd4:	3301      	adds	r3, #1
 802ecd6:	613b      	str	r3, [r7, #16]
 802ecd8:	697b      	ldr	r3, [r7, #20]
 802ecda:	2b0f      	cmp	r3, #15
 802ecdc:	dde5      	ble.n	802ecaa <init_error_limit+0x3a>
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 802ecde:	e01f      	b.n	802ed20 <init_error_limit+0xb0>
    table[in] = out; table[-in] = -out;
 802ece0:	697b      	ldr	r3, [r7, #20]
 802ece2:	009b      	lsls	r3, r3, #2
 802ece4:	68ba      	ldr	r2, [r7, #8]
 802ece6:	4413      	add	r3, r2
 802ece8:	693a      	ldr	r2, [r7, #16]
 802ecea:	601a      	str	r2, [r3, #0]
 802ecec:	697a      	ldr	r2, [r7, #20]
 802ecee:	4613      	mov	r3, r2
 802ecf0:	079b      	lsls	r3, r3, #30
 802ecf2:	1a9b      	subs	r3, r3, r2
 802ecf4:	009b      	lsls	r3, r3, #2
 802ecf6:	461a      	mov	r2, r3
 802ecf8:	68bb      	ldr	r3, [r7, #8]
 802ecfa:	4413      	add	r3, r2
 802ecfc:	693a      	ldr	r2, [r7, #16]
 802ecfe:	4252      	negs	r2, r2
 802ed00:	601a      	str	r2, [r3, #0]
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 802ed02:	697b      	ldr	r3, [r7, #20]
 802ed04:	3301      	adds	r3, #1
 802ed06:	617b      	str	r3, [r7, #20]
 802ed08:	697b      	ldr	r3, [r7, #20]
 802ed0a:	f003 0301 	and.w	r3, r3, #1
 802ed0e:	2b00      	cmp	r3, #0
 802ed10:	bf0c      	ite	eq
 802ed12:	2301      	moveq	r3, #1
 802ed14:	2300      	movne	r3, #0
 802ed16:	b2db      	uxtb	r3, r3
 802ed18:	461a      	mov	r2, r3
 802ed1a:	693b      	ldr	r3, [r7, #16]
 802ed1c:	4413      	add	r3, r2
 802ed1e:	613b      	str	r3, [r7, #16]
 802ed20:	697b      	ldr	r3, [r7, #20]
 802ed22:	2b2f      	cmp	r3, #47	@ 0x2f
 802ed24:	dddc      	ble.n	802ece0 <init_error_limit+0x70>
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
 802ed26:	e013      	b.n	802ed50 <init_error_limit+0xe0>
    table[in] = out; table[-in] = -out;
 802ed28:	697b      	ldr	r3, [r7, #20]
 802ed2a:	009b      	lsls	r3, r3, #2
 802ed2c:	68ba      	ldr	r2, [r7, #8]
 802ed2e:	4413      	add	r3, r2
 802ed30:	693a      	ldr	r2, [r7, #16]
 802ed32:	601a      	str	r2, [r3, #0]
 802ed34:	697a      	ldr	r2, [r7, #20]
 802ed36:	4613      	mov	r3, r2
 802ed38:	079b      	lsls	r3, r3, #30
 802ed3a:	1a9b      	subs	r3, r3, r2
 802ed3c:	009b      	lsls	r3, r3, #2
 802ed3e:	461a      	mov	r2, r3
 802ed40:	68bb      	ldr	r3, [r7, #8]
 802ed42:	4413      	add	r3, r2
 802ed44:	693a      	ldr	r2, [r7, #16]
 802ed46:	4252      	negs	r2, r2
 802ed48:	601a      	str	r2, [r3, #0]
  for (; in <= MAXJSAMPLE; in++) {
 802ed4a:	697b      	ldr	r3, [r7, #20]
 802ed4c:	3301      	adds	r3, #1
 802ed4e:	617b      	str	r3, [r7, #20]
 802ed50:	697b      	ldr	r3, [r7, #20]
 802ed52:	2bff      	cmp	r3, #255	@ 0xff
 802ed54:	dde8      	ble.n	802ed28 <init_error_limit+0xb8>
  }
#undef STEPSIZE
}
 802ed56:	bf00      	nop
 802ed58:	bf00      	nop
 802ed5a:	3718      	adds	r7, #24
 802ed5c:	46bd      	mov	sp, r7
 802ed5e:	bd80      	pop	{r7, pc}

0802ed60 <finish_pass1>:
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
 802ed60:	b580      	push	{r7, lr}
 802ed62:	b084      	sub	sp, #16
 802ed64:	af00      	add	r7, sp, #0
 802ed66:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ed68:	687b      	ldr	r3, [r7, #4]
 802ed6a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ed6e:	60fb      	str	r3, [r7, #12]

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
 802ed70:	68fb      	ldr	r3, [r7, #12]
 802ed72:	691a      	ldr	r2, [r3, #16]
 802ed74:	687b      	ldr	r3, [r7, #4]
 802ed76:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  select_colors(cinfo, cquantize->desired);
 802ed7a:	68fb      	ldr	r3, [r7, #12]
 802ed7c:	695b      	ldr	r3, [r3, #20]
 802ed7e:	4619      	mov	r1, r3
 802ed80:	6878      	ldr	r0, [r7, #4]
 802ed82:	f7ff f8de 	bl	802df42 <select_colors>
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
 802ed86:	68fb      	ldr	r3, [r7, #12]
 802ed88:	2201      	movs	r2, #1
 802ed8a:	61da      	str	r2, [r3, #28]
}
 802ed8c:	bf00      	nop
 802ed8e:	3710      	adds	r7, #16
 802ed90:	46bd      	mov	sp, r7
 802ed92:	bd80      	pop	{r7, pc}

0802ed94 <finish_pass2>:


METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
 802ed94:	b480      	push	{r7}
 802ed96:	b083      	sub	sp, #12
 802ed98:	af00      	add	r7, sp, #0
 802ed9a:	6078      	str	r0, [r7, #4]
  /* no work */
}
 802ed9c:	bf00      	nop
 802ed9e:	370c      	adds	r7, #12
 802eda0:	46bd      	mov	sp, r7
 802eda2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802eda6:	4770      	bx	lr

0802eda8 <start_pass_2_quant>:
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 802eda8:	b580      	push	{r7, lr}
 802edaa:	b086      	sub	sp, #24
 802edac:	af00      	add	r7, sp, #0
 802edae:	6078      	str	r0, [r7, #4]
 802edb0:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802edb2:	687b      	ldr	r3, [r7, #4]
 802edb4:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802edb8:	613b      	str	r3, [r7, #16]
  hist3d histogram = cquantize->histogram;
 802edba:	693b      	ldr	r3, [r7, #16]
 802edbc:	699b      	ldr	r3, [r3, #24]
 802edbe:	60fb      	str	r3, [r7, #12]
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 802edc0:	687b      	ldr	r3, [r7, #4]
 802edc2:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802edc6:	2b00      	cmp	r3, #0
 802edc8:	d003      	beq.n	802edd2 <start_pass_2_quant+0x2a>
    cinfo->dither_mode = JDITHER_FS;
 802edca:	687b      	ldr	r3, [r7, #4]
 802edcc:	2202      	movs	r2, #2
 802edce:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58

  if (is_pre_scan) {
 802edd2:	683b      	ldr	r3, [r7, #0]
 802edd4:	2b00      	cmp	r3, #0
 802edd6:	d009      	beq.n	802edec <start_pass_2_quant+0x44>
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
 802edd8:	693b      	ldr	r3, [r7, #16]
 802edda:	4a44      	ldr	r2, [pc, #272]	@ (802eeec <start_pass_2_quant+0x144>)
 802eddc:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass1;
 802edde:	693b      	ldr	r3, [r7, #16]
 802ede0:	4a43      	ldr	r2, [pc, #268]	@ (802eef0 <start_pass_2_quant+0x148>)
 802ede2:	609a      	str	r2, [r3, #8]
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
 802ede4:	693b      	ldr	r3, [r7, #16]
 802ede6:	2201      	movs	r2, #1
 802ede8:	61da      	str	r2, [r3, #28]
 802edea:	e060      	b.n	802eeae <start_pass_2_quant+0x106>
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
 802edec:	687b      	ldr	r3, [r7, #4]
 802edee:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802edf2:	2b02      	cmp	r3, #2
 802edf4:	d103      	bne.n	802edfe <start_pass_2_quant+0x56>
      cquantize->pub.color_quantize = pass2_fs_dither;
 802edf6:	693b      	ldr	r3, [r7, #16]
 802edf8:	4a3e      	ldr	r2, [pc, #248]	@ (802eef4 <start_pass_2_quant+0x14c>)
 802edfa:	605a      	str	r2, [r3, #4]
 802edfc:	e002      	b.n	802ee04 <start_pass_2_quant+0x5c>
    else
      cquantize->pub.color_quantize = pass2_no_dither;
 802edfe:	693b      	ldr	r3, [r7, #16]
 802ee00:	4a3d      	ldr	r2, [pc, #244]	@ (802eef8 <start_pass_2_quant+0x150>)
 802ee02:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass2;
 802ee04:	693b      	ldr	r3, [r7, #16]
 802ee06:	4a3d      	ldr	r2, [pc, #244]	@ (802eefc <start_pass_2_quant+0x154>)
 802ee08:	609a      	str	r2, [r3, #8]

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
 802ee0a:	687b      	ldr	r3, [r7, #4]
 802ee0c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 802ee10:	617b      	str	r3, [r7, #20]
    if (i < 1)
 802ee12:	697b      	ldr	r3, [r7, #20]
 802ee14:	2b00      	cmp	r3, #0
 802ee16:	dc0c      	bgt.n	802ee32 <start_pass_2_quant+0x8a>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
 802ee18:	687b      	ldr	r3, [r7, #4]
 802ee1a:	681b      	ldr	r3, [r3, #0]
 802ee1c:	223a      	movs	r2, #58	@ 0x3a
 802ee1e:	615a      	str	r2, [r3, #20]
 802ee20:	687b      	ldr	r3, [r7, #4]
 802ee22:	681b      	ldr	r3, [r3, #0]
 802ee24:	2201      	movs	r2, #1
 802ee26:	619a      	str	r2, [r3, #24]
 802ee28:	687b      	ldr	r3, [r7, #4]
 802ee2a:	681b      	ldr	r3, [r3, #0]
 802ee2c:	681b      	ldr	r3, [r3, #0]
 802ee2e:	6878      	ldr	r0, [r7, #4]
 802ee30:	4798      	blx	r3
    if (i > MAXNUMCOLORS)
 802ee32:	697b      	ldr	r3, [r7, #20]
 802ee34:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802ee38:	dd0d      	ble.n	802ee56 <start_pass_2_quant+0xae>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 802ee3a:	687b      	ldr	r3, [r7, #4]
 802ee3c:	681b      	ldr	r3, [r3, #0]
 802ee3e:	223b      	movs	r2, #59	@ 0x3b
 802ee40:	615a      	str	r2, [r3, #20]
 802ee42:	687b      	ldr	r3, [r7, #4]
 802ee44:	681b      	ldr	r3, [r3, #0]
 802ee46:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802ee4a:	619a      	str	r2, [r3, #24]
 802ee4c:	687b      	ldr	r3, [r7, #4]
 802ee4e:	681b      	ldr	r3, [r3, #0]
 802ee50:	681b      	ldr	r3, [r3, #0]
 802ee52:	6878      	ldr	r0, [r7, #4]
 802ee54:	4798      	blx	r3

    if (cinfo->dither_mode == JDITHER_FS) {
 802ee56:	687b      	ldr	r3, [r7, #4]
 802ee58:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802ee5c:	2b02      	cmp	r3, #2
 802ee5e:	d126      	bne.n	802eeae <start_pass_2_quant+0x106>
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
 802ee60:	687b      	ldr	r3, [r7, #4]
 802ee62:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 802ee64:	4613      	mov	r3, r2
 802ee66:	005b      	lsls	r3, r3, #1
 802ee68:	4413      	add	r3, r2
 802ee6a:	005b      	lsls	r3, r3, #1
 802ee6c:	330c      	adds	r3, #12
 802ee6e:	60bb      	str	r3, [r7, #8]
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
 802ee70:	693b      	ldr	r3, [r7, #16]
 802ee72:	6a1b      	ldr	r3, [r3, #32]
 802ee74:	2b00      	cmp	r3, #0
 802ee76:	d109      	bne.n	802ee8c <start_pass_2_quant+0xe4>
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802ee78:	687b      	ldr	r3, [r7, #4]
 802ee7a:	685b      	ldr	r3, [r3, #4]
 802ee7c:	685b      	ldr	r3, [r3, #4]
 802ee7e:	68ba      	ldr	r2, [r7, #8]
 802ee80:	2101      	movs	r1, #1
 802ee82:	6878      	ldr	r0, [r7, #4]
 802ee84:	4798      	blx	r3
 802ee86:	4602      	mov	r2, r0
 802ee88:	693b      	ldr	r3, [r7, #16]
 802ee8a:	621a      	str	r2, [r3, #32]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      FMEMZERO((void FAR *) cquantize->fserrors, arraysize);
 802ee8c:	693b      	ldr	r3, [r7, #16]
 802ee8e:	6a1b      	ldr	r3, [r3, #32]
 802ee90:	68ba      	ldr	r2, [r7, #8]
 802ee92:	2100      	movs	r1, #0
 802ee94:	4618      	mov	r0, r3
 802ee96:	f000 fd83 	bl	802f9a0 <memset>
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
 802ee9a:	693b      	ldr	r3, [r7, #16]
 802ee9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 802ee9e:	2b00      	cmp	r3, #0
 802eea0:	d102      	bne.n	802eea8 <start_pass_2_quant+0x100>
	init_error_limit(cinfo);
 802eea2:	6878      	ldr	r0, [r7, #4]
 802eea4:	f7ff fee4 	bl	802ec70 <init_error_limit>
      cquantize->on_odd_row = FALSE;
 802eea8:	693b      	ldr	r3, [r7, #16]
 802eeaa:	2200      	movs	r2, #0
 802eeac:	625a      	str	r2, [r3, #36]	@ 0x24
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
 802eeae:	693b      	ldr	r3, [r7, #16]
 802eeb0:	69db      	ldr	r3, [r3, #28]
 802eeb2:	2b00      	cmp	r3, #0
 802eeb4:	d016      	beq.n	802eee4 <start_pass_2_quant+0x13c>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 802eeb6:	2300      	movs	r3, #0
 802eeb8:	617b      	str	r3, [r7, #20]
 802eeba:	e00d      	b.n	802eed8 <start_pass_2_quant+0x130>
      FMEMZERO((void FAR *) histogram[i],
 802eebc:	697b      	ldr	r3, [r7, #20]
 802eebe:	009b      	lsls	r3, r3, #2
 802eec0:	68fa      	ldr	r2, [r7, #12]
 802eec2:	4413      	add	r3, r2
 802eec4:	681b      	ldr	r3, [r3, #0]
 802eec6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 802eeca:	2100      	movs	r1, #0
 802eecc:	4618      	mov	r0, r3
 802eece:	f000 fd67 	bl	802f9a0 <memset>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 802eed2:	697b      	ldr	r3, [r7, #20]
 802eed4:	3301      	adds	r3, #1
 802eed6:	617b      	str	r3, [r7, #20]
 802eed8:	697b      	ldr	r3, [r7, #20]
 802eeda:	2b1f      	cmp	r3, #31
 802eedc:	ddee      	ble.n	802eebc <start_pass_2_quant+0x114>
	       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
 802eede:	693b      	ldr	r3, [r7, #16]
 802eee0:	2200      	movs	r2, #0
 802eee2:	61da      	str	r2, [r3, #28]
  }
}
 802eee4:	bf00      	nop
 802eee6:	3718      	adds	r7, #24
 802eee8:	46bd      	mov	sp, r7
 802eeea:	bd80      	pop	{r7, pc}
 802eeec:	0802d7e9 	.word	0x0802d7e9
 802eef0:	0802ed61 	.word	0x0802ed61
 802eef4:	0802e9d9 	.word	0x0802e9d9
 802eef8:	0802e915 	.word	0x0802e915
 802eefc:	0802ed95 	.word	0x0802ed95

0802ef00 <new_color_map_2_quant>:
 * Switch to a new external colormap between output passes.
 */

METHODDEF(void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
 802ef00:	b480      	push	{r7}
 802ef02:	b085      	sub	sp, #20
 802ef04:	af00      	add	r7, sp, #0
 802ef06:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 802ef08:	687b      	ldr	r3, [r7, #4]
 802ef0a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	@ 0x1e0
 802ef0e:	60fb      	str	r3, [r7, #12]

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
 802ef10:	68fb      	ldr	r3, [r7, #12]
 802ef12:	2201      	movs	r2, #1
 802ef14:	61da      	str	r2, [r3, #28]
}
 802ef16:	bf00      	nop
 802ef18:	3714      	adds	r7, #20
 802ef1a:	46bd      	mov	sp, r7
 802ef1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ef20:	4770      	bx	lr
	...

0802ef24 <jinit_2pass_quantizer>:
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
 802ef24:	b590      	push	{r4, r7, lr}
 802ef26:	b087      	sub	sp, #28
 802ef28:	af00      	add	r7, sp, #0
 802ef2a:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 802ef2c:	687b      	ldr	r3, [r7, #4]
 802ef2e:	685b      	ldr	r3, [r3, #4]
 802ef30:	681b      	ldr	r3, [r3, #0]
 802ef32:	222c      	movs	r2, #44	@ 0x2c
 802ef34:	2101      	movs	r1, #1
 802ef36:	6878      	ldr	r0, [r7, #4]
 802ef38:	4798      	blx	r3
 802ef3a:	6138      	str	r0, [r7, #16]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 802ef3c:	687b      	ldr	r3, [r7, #4]
 802ef3e:	693a      	ldr	r2, [r7, #16]
 802ef40:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
  cquantize->pub.start_pass = start_pass_2_quant;
 802ef44:	693b      	ldr	r3, [r7, #16]
 802ef46:	4a4f      	ldr	r2, [pc, #316]	@ (802f084 <jinit_2pass_quantizer+0x160>)
 802ef48:	601a      	str	r2, [r3, #0]
  cquantize->pub.new_color_map = new_color_map_2_quant;
 802ef4a:	693b      	ldr	r3, [r7, #16]
 802ef4c:	4a4e      	ldr	r2, [pc, #312]	@ (802f088 <jinit_2pass_quantizer+0x164>)
 802ef4e:	60da      	str	r2, [r3, #12]
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
 802ef50:	693b      	ldr	r3, [r7, #16]
 802ef52:	2200      	movs	r2, #0
 802ef54:	621a      	str	r2, [r3, #32]
  cquantize->error_limiter = NULL;
 802ef56:	693b      	ldr	r3, [r7, #16]
 802ef58:	2200      	movs	r2, #0
 802ef5a:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
 802ef5c:	687b      	ldr	r3, [r7, #4]
 802ef5e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 802ef60:	2b03      	cmp	r3, #3
 802ef62:	d008      	beq.n	802ef76 <jinit_2pass_quantizer+0x52>
    ERREXIT(cinfo, JERR_NOTIMPL);
 802ef64:	687b      	ldr	r3, [r7, #4]
 802ef66:	681b      	ldr	r3, [r3, #0]
 802ef68:	2230      	movs	r2, #48	@ 0x30
 802ef6a:	615a      	str	r2, [r3, #20]
 802ef6c:	687b      	ldr	r3, [r7, #4]
 802ef6e:	681b      	ldr	r3, [r3, #0]
 802ef70:	681b      	ldr	r3, [r3, #0]
 802ef72:	6878      	ldr	r0, [r7, #4]
 802ef74:	4798      	blx	r3

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
 802ef76:	687b      	ldr	r3, [r7, #4]
 802ef78:	685b      	ldr	r3, [r3, #4]
 802ef7a:	681b      	ldr	r3, [r3, #0]
 802ef7c:	2280      	movs	r2, #128	@ 0x80
 802ef7e:	2101      	movs	r1, #1
 802ef80:	6878      	ldr	r0, [r7, #4]
 802ef82:	4798      	blx	r3
 802ef84:	4602      	mov	r2, r0
 802ef86:	693b      	ldr	r3, [r7, #16]
 802ef88:	619a      	str	r2, [r3, #24]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 802ef8a:	2300      	movs	r3, #0
 802ef8c:	617b      	str	r3, [r7, #20]
 802ef8e:	e011      	b.n	802efb4 <jinit_2pass_quantizer+0x90>
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
 802ef90:	687b      	ldr	r3, [r7, #4]
 802ef92:	685b      	ldr	r3, [r3, #4]
 802ef94:	685b      	ldr	r3, [r3, #4]
 802ef96:	693a      	ldr	r2, [r7, #16]
 802ef98:	6991      	ldr	r1, [r2, #24]
 802ef9a:	697a      	ldr	r2, [r7, #20]
 802ef9c:	0092      	lsls	r2, r2, #2
 802ef9e:	188c      	adds	r4, r1, r2
 802efa0:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 802efa4:	2101      	movs	r1, #1
 802efa6:	6878      	ldr	r0, [r7, #4]
 802efa8:	4798      	blx	r3
 802efaa:	4603      	mov	r3, r0
 802efac:	6023      	str	r3, [r4, #0]
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 802efae:	697b      	ldr	r3, [r7, #20]
 802efb0:	3301      	adds	r3, #1
 802efb2:	617b      	str	r3, [r7, #20]
 802efb4:	697b      	ldr	r3, [r7, #20]
 802efb6:	2b1f      	cmp	r3, #31
 802efb8:	ddea      	ble.n	802ef90 <jinit_2pass_quantizer+0x6c>
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
 802efba:	693b      	ldr	r3, [r7, #16]
 802efbc:	2201      	movs	r2, #1
 802efbe:	61da      	str	r2, [r3, #28]

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
 802efc0:	687b      	ldr	r3, [r7, #4]
 802efc2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 802efc4:	2b00      	cmp	r3, #0
 802efc6:	d033      	beq.n	802f030 <jinit_2pass_quantizer+0x10c>
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
 802efc8:	687b      	ldr	r3, [r7, #4]
 802efca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802efcc:	60fb      	str	r3, [r7, #12]
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
 802efce:	68fb      	ldr	r3, [r7, #12]
 802efd0:	2b07      	cmp	r3, #7
 802efd2:	dc0c      	bgt.n	802efee <jinit_2pass_quantizer+0xca>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
 802efd4:	687b      	ldr	r3, [r7, #4]
 802efd6:	681b      	ldr	r3, [r3, #0]
 802efd8:	223a      	movs	r2, #58	@ 0x3a
 802efda:	615a      	str	r2, [r3, #20]
 802efdc:	687b      	ldr	r3, [r7, #4]
 802efde:	681b      	ldr	r3, [r3, #0]
 802efe0:	2208      	movs	r2, #8
 802efe2:	619a      	str	r2, [r3, #24]
 802efe4:	687b      	ldr	r3, [r7, #4]
 802efe6:	681b      	ldr	r3, [r3, #0]
 802efe8:	681b      	ldr	r3, [r3, #0]
 802efea:	6878      	ldr	r0, [r7, #4]
 802efec:	4798      	blx	r3
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
 802efee:	68fb      	ldr	r3, [r7, #12]
 802eff0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 802eff4:	dd0d      	ble.n	802f012 <jinit_2pass_quantizer+0xee>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 802eff6:	687b      	ldr	r3, [r7, #4]
 802eff8:	681b      	ldr	r3, [r3, #0]
 802effa:	223b      	movs	r2, #59	@ 0x3b
 802effc:	615a      	str	r2, [r3, #20]
 802effe:	687b      	ldr	r3, [r7, #4]
 802f000:	681b      	ldr	r3, [r3, #0]
 802f002:	f44f 7280 	mov.w	r2, #256	@ 0x100
 802f006:	619a      	str	r2, [r3, #24]
 802f008:	687b      	ldr	r3, [r7, #4]
 802f00a:	681b      	ldr	r3, [r3, #0]
 802f00c:	681b      	ldr	r3, [r3, #0]
 802f00e:	6878      	ldr	r0, [r7, #4]
 802f010:	4798      	blx	r3
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
 802f012:	687b      	ldr	r3, [r7, #4]
 802f014:	685b      	ldr	r3, [r3, #4]
 802f016:	689c      	ldr	r4, [r3, #8]
 802f018:	68fa      	ldr	r2, [r7, #12]
 802f01a:	2303      	movs	r3, #3
 802f01c:	2101      	movs	r1, #1
 802f01e:	6878      	ldr	r0, [r7, #4]
 802f020:	47a0      	blx	r4
 802f022:	4602      	mov	r2, r0
 802f024:	693b      	ldr	r3, [r7, #16]
 802f026:	611a      	str	r2, [r3, #16]
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
 802f028:	693b      	ldr	r3, [r7, #16]
 802f02a:	68fa      	ldr	r2, [r7, #12]
 802f02c:	615a      	str	r2, [r3, #20]
 802f02e:	e002      	b.n	802f036 <jinit_2pass_quantizer+0x112>
  } else
    cquantize->sv_colormap = NULL;
 802f030:	693b      	ldr	r3, [r7, #16]
 802f032:	2200      	movs	r2, #0
 802f034:	611a      	str	r2, [r3, #16]

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 802f036:	687b      	ldr	r3, [r7, #4]
 802f038:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802f03c:	2b00      	cmp	r3, #0
 802f03e:	d003      	beq.n	802f048 <jinit_2pass_quantizer+0x124>
    cinfo->dither_mode = JDITHER_FS;
 802f040:	687b      	ldr	r3, [r7, #4]
 802f042:	2202      	movs	r2, #2
 802f044:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
 802f048:	687b      	ldr	r3, [r7, #4]
 802f04a:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 802f04e:	2b02      	cmp	r3, #2
 802f050:	d113      	bne.n	802f07a <jinit_2pass_quantizer+0x156>
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802f052:	687b      	ldr	r3, [r7, #4]
 802f054:	685b      	ldr	r3, [r3, #4]
 802f056:	685c      	ldr	r4, [r3, #4]
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 802f058:	687b      	ldr	r3, [r7, #4]
 802f05a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802f05c:	4613      	mov	r3, r2
 802f05e:	005b      	lsls	r3, r3, #1
 802f060:	4413      	add	r3, r2
 802f062:	005b      	lsls	r3, r3, #1
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 802f064:	330c      	adds	r3, #12
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 802f066:	461a      	mov	r2, r3
 802f068:	2101      	movs	r1, #1
 802f06a:	6878      	ldr	r0, [r7, #4]
 802f06c:	47a0      	blx	r4
 802f06e:	4602      	mov	r2, r0
 802f070:	693b      	ldr	r3, [r7, #16]
 802f072:	621a      	str	r2, [r3, #32]
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
 802f074:	6878      	ldr	r0, [r7, #4]
 802f076:	f7ff fdfb 	bl	802ec70 <init_error_limit>
  }
}
 802f07a:	bf00      	nop
 802f07c:	371c      	adds	r7, #28
 802f07e:	46bd      	mov	sp, r7
 802f080:	bd90      	pop	{r4, r7, pc}
 802f082:	bf00      	nop
 802f084:	0802eda9 	.word	0x0802eda9
 802f088:	0802ef01 	.word	0x0802ef01

0802f08c <jdiv_round_up>:

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
 802f08c:	b480      	push	{r7}
 802f08e:	b083      	sub	sp, #12
 802f090:	af00      	add	r7, sp, #0
 802f092:	6078      	str	r0, [r7, #4]
 802f094:	6039      	str	r1, [r7, #0]
  return (a + b - 1L) / b;
 802f096:	687a      	ldr	r2, [r7, #4]
 802f098:	683b      	ldr	r3, [r7, #0]
 802f09a:	4413      	add	r3, r2
 802f09c:	1e5a      	subs	r2, r3, #1
 802f09e:	683b      	ldr	r3, [r7, #0]
 802f0a0:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802f0a4:	4618      	mov	r0, r3
 802f0a6:	370c      	adds	r7, #12
 802f0a8:	46bd      	mov	sp, r7
 802f0aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f0ae:	4770      	bx	lr

0802f0b0 <jround_up>:

GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
 802f0b0:	b480      	push	{r7}
 802f0b2:	b083      	sub	sp, #12
 802f0b4:	af00      	add	r7, sp, #0
 802f0b6:	6078      	str	r0, [r7, #4]
 802f0b8:	6039      	str	r1, [r7, #0]
  a += b - 1L;
 802f0ba:	683b      	ldr	r3, [r7, #0]
 802f0bc:	3b01      	subs	r3, #1
 802f0be:	687a      	ldr	r2, [r7, #4]
 802f0c0:	4413      	add	r3, r2
 802f0c2:	607b      	str	r3, [r7, #4]
  return a - (a % b);
 802f0c4:	687b      	ldr	r3, [r7, #4]
 802f0c6:	683a      	ldr	r2, [r7, #0]
 802f0c8:	fb93 f2f2 	sdiv	r2, r3, r2
 802f0cc:	6839      	ldr	r1, [r7, #0]
 802f0ce:	fb01 f202 	mul.w	r2, r1, r2
 802f0d2:	1a9b      	subs	r3, r3, r2
 802f0d4:	687a      	ldr	r2, [r7, #4]
 802f0d6:	1ad3      	subs	r3, r2, r3
}
 802f0d8:	4618      	mov	r0, r3
 802f0da:	370c      	adds	r7, #12
 802f0dc:	46bd      	mov	sp, r7
 802f0de:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f0e2:	4770      	bx	lr

0802f0e4 <jcopy_sample_rows>:
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
 802f0e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f0e6:	b085      	sub	sp, #20
 802f0e8:	af00      	add	r7, sp, #0
 802f0ea:	60f8      	str	r0, [r7, #12]
 802f0ec:	60b9      	str	r1, [r7, #8]
 802f0ee:	607a      	str	r2, [r7, #4]
 802f0f0:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
 802f0f2:	6afd      	ldr	r5, [r7, #44]	@ 0x2c
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
 802f0f4:	68bb      	ldr	r3, [r7, #8]
 802f0f6:	009b      	lsls	r3, r3, #2
 802f0f8:	68fa      	ldr	r2, [r7, #12]
 802f0fa:	4413      	add	r3, r2
 802f0fc:	60fb      	str	r3, [r7, #12]
  output_array += dest_row;
 802f0fe:	683b      	ldr	r3, [r7, #0]
 802f100:	009b      	lsls	r3, r3, #2
 802f102:	687a      	ldr	r2, [r7, #4]
 802f104:	4413      	add	r3, r2
 802f106:	607b      	str	r3, [r7, #4]

  for (row = num_rows; row > 0; row--) {
 802f108:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 802f10a:	e00c      	b.n	802f126 <jcopy_sample_rows+0x42>
    inptr = *input_array++;
 802f10c:	68fb      	ldr	r3, [r7, #12]
 802f10e:	1d1a      	adds	r2, r3, #4
 802f110:	60fa      	str	r2, [r7, #12]
 802f112:	6819      	ldr	r1, [r3, #0]
    outptr = *output_array++;
 802f114:	687b      	ldr	r3, [r7, #4]
 802f116:	1d1a      	adds	r2, r3, #4
 802f118:	607a      	str	r2, [r7, #4]
 802f11a:	681e      	ldr	r6, [r3, #0]
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
 802f11c:	462a      	mov	r2, r5
 802f11e:	4630      	mov	r0, r6
 802f120:	f000 fc82 	bl	802fa28 <memcpy>
  for (row = num_rows; row > 0; row--) {
 802f124:	3c01      	subs	r4, #1
 802f126:	2c00      	cmp	r4, #0
 802f128:	dcf0      	bgt.n	802f10c <jcopy_sample_rows+0x28>
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
#endif
  }
}
 802f12a:	bf00      	nop
 802f12c:	bf00      	nop
 802f12e:	3714      	adds	r7, #20
 802f130:	46bd      	mov	sp, r7
 802f132:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802f134 <jcopy_block_row>:

GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
 802f134:	b580      	push	{r7, lr}
 802f136:	b084      	sub	sp, #16
 802f138:	af00      	add	r7, sp, #0
 802f13a:	60f8      	str	r0, [r7, #12]
 802f13c:	60b9      	str	r1, [r7, #8]
 802f13e:	607a      	str	r2, [r7, #4]
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
 802f140:	687b      	ldr	r3, [r7, #4]
 802f142:	01db      	lsls	r3, r3, #7
 802f144:	461a      	mov	r2, r3
 802f146:	68f9      	ldr	r1, [r7, #12]
 802f148:	68b8      	ldr	r0, [r7, #8]
 802f14a:	f000 fc6d 	bl	802fa28 <memcpy>
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}
 802f14e:	bf00      	nop
 802f150:	3710      	adds	r7, #16
 802f152:	46bd      	mov	sp, r7
 802f154:	bd80      	pop	{r7, pc}
	...

0802f158 <MX_USB_HOST_Init>:
/**
  * Init USB host library, add supported class and start the library
  * @retval None
  */
void MX_USB_HOST_Init(void)
{
 802f158:	b580      	push	{r7, lr}
 802f15a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_HOST_Init_PreTreatment */

  /* USER CODE END USB_HOST_Init_PreTreatment */

  /* Init host Library, add supported class and start the library. */
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 802f15c:	2201      	movs	r2, #1
 802f15e:	490e      	ldr	r1, [pc, #56]	@ (802f198 <MX_USB_HOST_Init+0x40>)
 802f160:	480e      	ldr	r0, [pc, #56]	@ (802f19c <MX_USB_HOST_Init+0x44>)
 802f162:	f7dc fe72 	bl	800be4a <USBH_Init>
 802f166:	4603      	mov	r3, r0
 802f168:	2b00      	cmp	r3, #0
 802f16a:	d001      	beq.n	802f170 <MX_USB_HOST_Init+0x18>
  {
    Error_Handler();
 802f16c:	f7d2 f9ba 	bl	80014e4 <Error_Handler>
  }
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MSC_CLASS) != USBH_OK)
 802f170:	490b      	ldr	r1, [pc, #44]	@ (802f1a0 <MX_USB_HOST_Init+0x48>)
 802f172:	480a      	ldr	r0, [pc, #40]	@ (802f19c <MX_USB_HOST_Init+0x44>)
 802f174:	f7dc ff16 	bl	800bfa4 <USBH_RegisterClass>
 802f178:	4603      	mov	r3, r0
 802f17a:	2b00      	cmp	r3, #0
 802f17c:	d001      	beq.n	802f182 <MX_USB_HOST_Init+0x2a>
  {
    Error_Handler();
 802f17e:	f7d2 f9b1 	bl	80014e4 <Error_Handler>
  }
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 802f182:	4806      	ldr	r0, [pc, #24]	@ (802f19c <MX_USB_HOST_Init+0x44>)
 802f184:	f7dc ff9a 	bl	800c0bc <USBH_Start>
 802f188:	4603      	mov	r3, r0
 802f18a:	2b00      	cmp	r3, #0
 802f18c:	d001      	beq.n	802f192 <MX_USB_HOST_Init+0x3a>
  {
    Error_Handler();
 802f18e:	f7d2 f9a9 	bl	80014e4 <Error_Handler>
  }
  /* USER CODE BEGIN USB_HOST_Init_PostTreatment */

  /* USER CODE END USB_HOST_Init_PostTreatment */
}
 802f192:	bf00      	nop
 802f194:	bd80      	pop	{r7, pc}
 802f196:	bf00      	nop
 802f198:	0802f1b9 	.word	0x0802f1b9
 802f19c:	20002d90 	.word	0x20002d90
 802f1a0:	2000000c 	.word	0x2000000c

0802f1a4 <MX_USB_HOST_Process>:

/*
 * Background task
 */
void MX_USB_HOST_Process(void)
{
 802f1a4:	b580      	push	{r7, lr}
 802f1a6:	af00      	add	r7, sp, #0
  /* USB Host Background task */
  USBH_Process(&hUsbHostFS);
 802f1a8:	4802      	ldr	r0, [pc, #8]	@ (802f1b4 <MX_USB_HOST_Process+0x10>)
 802f1aa:	f7dc ff97 	bl	800c0dc <USBH_Process>
}
 802f1ae:	bf00      	nop
 802f1b0:	bd80      	pop	{r7, pc}
 802f1b2:	bf00      	nop
 802f1b4:	20002d90 	.word	0x20002d90

0802f1b8 <USBH_UserProcess>:
/*
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
 802f1b8:	b580      	push	{r7, lr}
 802f1ba:	b082      	sub	sp, #8
 802f1bc:	af00      	add	r7, sp, #0
 802f1be:	6078      	str	r0, [r7, #4]
 802f1c0:	460b      	mov	r3, r1
 802f1c2:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
 802f1c4:	78fb      	ldrb	r3, [r7, #3]
 802f1c6:	3b01      	subs	r3, #1
 802f1c8:	2b04      	cmp	r3, #4
 802f1ca:	d829      	bhi.n	802f220 <USBH_UserProcess+0x68>
 802f1cc:	a201      	add	r2, pc, #4	@ (adr r2, 802f1d4 <USBH_UserProcess+0x1c>)
 802f1ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802f1d2:	bf00      	nop
 802f1d4:	0802f221 	.word	0x0802f221
 802f1d8:	0802f1fb 	.word	0x0802f1fb
 802f1dc:	0802f221 	.word	0x0802f221
 802f1e0:	0802f219 	.word	0x0802f219
 802f1e4:	0802f1e9 	.word	0x0802f1e9
  {
  case HOST_USER_SELECT_CONFIGURATION:
  break;

  case HOST_USER_DISCONNECTION:
  Appli_state = APPLICATION_DISCONNECT;
 802f1e8:	4b10      	ldr	r3, [pc, #64]	@ (802f22c <USBH_UserProcess+0x74>)
 802f1ea:	2203      	movs	r2, #3
 802f1ec:	701a      	strb	r2, [r3, #0]
  f_mount(&fs, USBHPath, 0);
 802f1ee:	2200      	movs	r2, #0
 802f1f0:	490f      	ldr	r1, [pc, #60]	@ (802f230 <USBH_UserProcess+0x78>)
 802f1f2:	4810      	ldr	r0, [pc, #64]	@ (802f234 <USBH_UserProcess+0x7c>)
 802f1f4:	f7e1 ff3c 	bl	8011070 <f_mount>
  break;
 802f1f8:	e013      	b.n	802f222 <USBH_UserProcess+0x6a>

  case HOST_USER_CLASS_ACTIVE:
  Appli_state = APPLICATION_READY;
 802f1fa:	4b0c      	ldr	r3, [pc, #48]	@ (802f22c <USBH_UserProcess+0x74>)
 802f1fc:	2202      	movs	r2, #2
 802f1fe:	701a      	strb	r2, [r3, #0]
  f_mount(&fs, USBHPath, 1);
 802f200:	2201      	movs	r2, #1
 802f202:	490b      	ldr	r1, [pc, #44]	@ (802f230 <USBH_UserProcess+0x78>)
 802f204:	480b      	ldr	r0, [pc, #44]	@ (802f234 <USBH_UserProcess+0x7c>)
 802f206:	f7e1 ff33 	bl	8011070 <f_mount>
  f_mkdir("0:/VIDEO");
 802f20a:	480b      	ldr	r0, [pc, #44]	@ (802f238 <USBH_UserProcess+0x80>)
 802f20c:	f7e3 fbc9 	bl	80129a2 <f_mkdir>
  begin_rec = 1;
 802f210:	4b0a      	ldr	r3, [pc, #40]	@ (802f23c <USBH_UserProcess+0x84>)
 802f212:	2201      	movs	r2, #1
 802f214:	701a      	strb	r2, [r3, #0]
  break;
 802f216:	e004      	b.n	802f222 <USBH_UserProcess+0x6a>

  case HOST_USER_CONNECTION:
  Appli_state = APPLICATION_START;
 802f218:	4b04      	ldr	r3, [pc, #16]	@ (802f22c <USBH_UserProcess+0x74>)
 802f21a:	2201      	movs	r2, #1
 802f21c:	701a      	strb	r2, [r3, #0]
  break;
 802f21e:	e000      	b.n	802f222 <USBH_UserProcess+0x6a>

  default:
  break;
 802f220:	bf00      	nop
  }
  /* USER CODE END CALL_BACK_1 */
}
 802f222:	bf00      	nop
 802f224:	3708      	adds	r7, #8
 802f226:	46bd      	mov	sp, r7
 802f228:	bd80      	pop	{r7, pc}
 802f22a:	bf00      	nop
 802f22c:	20003168 	.word	0x20003168
 802f230:	200028f8 	.word	0x200028f8
 802f234:	20000170 	.word	0x20000170
 802f238:	080315b4 	.word	0x080315b4
 802f23c:	20002208 	.word	0x20002208

0802f240 <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
 802f240:	b580      	push	{r7, lr}
 802f242:	b086      	sub	sp, #24
 802f244:	af00      	add	r7, sp, #0
 802f246:	6078      	str	r0, [r7, #4]
  GPIO_Handle_t GPIO_InitStruct = {0};
 802f248:	f107 0308 	add.w	r3, r7, #8
 802f24c:	2200      	movs	r2, #0
 802f24e:	601a      	str	r2, [r3, #0]
 802f250:	605a      	str	r2, [r3, #4]
 802f252:	609a      	str	r2, [r3, #8]
 802f254:	60da      	str	r2, [r3, #12]
  if(hcdHandle->Instance==USB_OTG_FS)
 802f256:	687b      	ldr	r3, [r7, #4]
 802f258:	681b      	ldr	r3, [r3, #0]
 802f25a:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 802f25e:	d13b      	bne.n	802f2d8 <HAL_HCD_MspInit+0x98>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    RCC->AHB1ENR.bit.gpioaen = SET;
 802f260:	4a1f      	ldr	r2, [pc, #124]	@ (802f2e0 <HAL_HCD_MspInit+0xa0>)
 802f262:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 802f264:	f043 0301 	orr.w	r3, r3, #1
 802f268:	6313      	str	r3, [r2, #48]	@ 0x30
    /**USB_OTG_FS GPIO Configuration
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.pGPIOx = GPIOA;
 802f26a:	4b1e      	ldr	r3, [pc, #120]	@ (802f2e4 <HAL_HCD_MspInit+0xa4>)
 802f26c:	60bb      	str	r3, [r7, #8]
    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_9;
 802f26e:	2309      	movs	r3, #9
 802f270:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_INPUT;
 802f272:	2300      	movs	r3, #0
 802f274:	743b      	strb	r3, [r7, #16]
    GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 802f276:	2300      	movs	r3, #0
 802f278:	74bb      	strb	r3, [r7, #18]
    GPIO_Init(&GPIO_InitStruct);
 802f27a:	f107 0308 	add.w	r3, r7, #8
 802f27e:	4618      	mov	r0, r3
 802f280:	f7da f822 	bl	80092c8 <GPIO_Init>

    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_11;
 802f284:	230b      	movs	r3, #11
 802f286:	60fb      	str	r3, [r7, #12]
	GPIO_InitStruct.GPIO_Config.PinMode = GPIO_MODE_AF;
 802f288:	2302      	movs	r3, #2
 802f28a:	743b      	strb	r3, [r7, #16]
	GPIO_InitStruct.GPIO_Config.PinOPType = GPIO_OUTPUT_PP;
 802f28c:	2300      	movs	r3, #0
 802f28e:	74fb      	strb	r3, [r7, #19]
	GPIO_InitStruct.GPIO_Config.PinPuPdControl = GPIO_PIN_NO_PUPD;
 802f290:	2300      	movs	r3, #0
 802f292:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStruct.GPIO_Config.PinSpeed = GPIO_SPEED_HIGH;
 802f294:	2303      	movs	r3, #3
 802f296:	747b      	strb	r3, [r7, #17]
	GPIO_InitStruct.GPIO_Config.PinAltFuncMode = 0xA;
 802f298:	230a      	movs	r3, #10
 802f29a:	753b      	strb	r3, [r7, #20]
    GPIO_Init(&GPIO_InitStruct);
 802f29c:	f107 0308 	add.w	r3, r7, #8
 802f2a0:	4618      	mov	r0, r3
 802f2a2:	f7da f811 	bl	80092c8 <GPIO_Init>

    GPIO_InitStruct.GPIO_Config.PinNumber = GPIO_PIN_12;
 802f2a6:	230c      	movs	r3, #12
 802f2a8:	60fb      	str	r3, [r7, #12]
    GPIO_Init(&GPIO_InitStruct);
 802f2aa:	f107 0308 	add.w	r3, r7, #8
 802f2ae:	4618      	mov	r0, r3
 802f2b0:	f7da f80a 	bl	80092c8 <GPIO_Init>

    /* Peripheral clock enable */
    RCC->AHB2ENR.bit.otgfsen = SET;
 802f2b4:	4a0a      	ldr	r2, [pc, #40]	@ (802f2e0 <HAL_HCD_MspInit+0xa0>)
 802f2b6:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 802f2b8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802f2bc:	6353      	str	r3, [r2, #52]	@ 0x34
    RCC->APB2ENR.bit.syscfgen = SET;
 802f2be:	4a08      	ldr	r2, [pc, #32]	@ (802f2e0 <HAL_HCD_MspInit+0xa0>)
 802f2c0:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 802f2c2:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 802f2c6:	6453      	str	r3, [r2, #68]	@ 0x44

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 802f2c8:	2200      	movs	r2, #0
 802f2ca:	2100      	movs	r1, #0
 802f2cc:	2043      	movs	r0, #67	@ 0x43
 802f2ce:	f7d2 fcaa 	bl	8001c26 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 802f2d2:	2043      	movs	r0, #67	@ 0x43
 802f2d4:	f7d2 fcc3 	bl	8001c5e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 802f2d8:	bf00      	nop
 802f2da:	3718      	adds	r7, #24
 802f2dc:	46bd      	mov	sp, r7
 802f2de:	bd80      	pop	{r7, pc}
 802f2e0:	40023800 	.word	0x40023800
 802f2e4:	40020000 	.word	0x40020000

0802f2e8 <HAL_HCD_SOF_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
 802f2e8:	b580      	push	{r7, lr}
 802f2ea:	b082      	sub	sp, #8
 802f2ec:	af00      	add	r7, sp, #0
 802f2ee:	6078      	str	r0, [r7, #4]
  USBH_LL_IncTimer(hhcd->pData);
 802f2f0:	687b      	ldr	r3, [r7, #4]
 802f2f2:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802f2f6:	4618      	mov	r0, r3
 802f2f8:	f7dd fac7 	bl	800c88a <USBH_LL_IncTimer>
}
 802f2fc:	bf00      	nop
 802f2fe:	3708      	adds	r7, #8
 802f300:	46bd      	mov	sp, r7
 802f302:	bd80      	pop	{r7, pc}

0802f304 <HAL_HCD_Connect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
 802f304:	b580      	push	{r7, lr}
 802f306:	b082      	sub	sp, #8
 802f308:	af00      	add	r7, sp, #0
 802f30a:	6078      	str	r0, [r7, #4]
  USBH_LL_Connect(hhcd->pData);
 802f30c:	687b      	ldr	r3, [r7, #4]
 802f30e:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802f312:	4618      	mov	r0, r3
 802f314:	f7dd faff 	bl	800c916 <USBH_LL_Connect>
}
 802f318:	bf00      	nop
 802f31a:	3708      	adds	r7, #8
 802f31c:	46bd      	mov	sp, r7
 802f31e:	bd80      	pop	{r7, pc}

0802f320 <HAL_HCD_Disconnect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
 802f320:	b580      	push	{r7, lr}
 802f322:	b082      	sub	sp, #8
 802f324:	af00      	add	r7, sp, #0
 802f326:	6078      	str	r0, [r7, #4]
  USBH_LL_Disconnect(hhcd->pData);
 802f328:	687b      	ldr	r3, [r7, #4]
 802f32a:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802f32e:	4618      	mov	r0, r3
 802f330:	f7dd fb08 	bl	800c944 <USBH_LL_Disconnect>
}
 802f334:	bf00      	nop
 802f336:	3708      	adds	r7, #8
 802f338:	46bd      	mov	sp, r7
 802f33a:	bd80      	pop	{r7, pc}

0802f33c <HAL_HCD_HC_NotifyURBChange_Callback>:
  * @param  chnum: channel number
  * @param  urb_state: state
  * @retval None
  */
void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
 802f33c:	b480      	push	{r7}
 802f33e:	b083      	sub	sp, #12
 802f340:	af00      	add	r7, sp, #0
 802f342:	6078      	str	r0, [r7, #4]
 802f344:	460b      	mov	r3, r1
 802f346:	70fb      	strb	r3, [r7, #3]
 802f348:	4613      	mov	r3, r2
 802f34a:	70bb      	strb	r3, [r7, #2]
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 802f34c:	bf00      	nop
 802f34e:	370c      	adds	r7, #12
 802f350:	46bd      	mov	sp, r7
 802f352:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f356:	4770      	bx	lr

0802f358 <HAL_HCD_PortEnabled_Callback>:
* @brief  Port Port Enabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
 802f358:	b580      	push	{r7, lr}
 802f35a:	b082      	sub	sp, #8
 802f35c:	af00      	add	r7, sp, #0
 802f35e:	6078      	str	r0, [r7, #4]
  USBH_LL_PortEnabled(hhcd->pData);
 802f360:	687b      	ldr	r3, [r7, #4]
 802f362:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802f366:	4618      	mov	r0, r3
 802f368:	f7dd fab9 	bl	800c8de <USBH_LL_PortEnabled>
}
 802f36c:	bf00      	nop
 802f36e:	3708      	adds	r7, #8
 802f370:	46bd      	mov	sp, r7
 802f372:	bd80      	pop	{r7, pc}

0802f374 <HAL_HCD_PortDisabled_Callback>:
  * @brief  Port Port Disabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
 802f374:	b580      	push	{r7, lr}
 802f376:	b082      	sub	sp, #8
 802f378:	af00      	add	r7, sp, #0
 802f37a:	6078      	str	r0, [r7, #4]
  USBH_LL_PortDisabled(hhcd->pData);
 802f37c:	687b      	ldr	r3, [r7, #4]
 802f37e:	f8d3 33dc 	ldr.w	r3, [r3, #988]	@ 0x3dc
 802f382:	4618      	mov	r0, r3
 802f384:	f7dd fab9 	bl	800c8fa <USBH_LL_PortDisabled>
}
 802f388:	bf00      	nop
 802f38a:	3708      	adds	r7, #8
 802f38c:	46bd      	mov	sp, r7
 802f38e:	bd80      	pop	{r7, pc}

0802f390 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
 802f390:	b580      	push	{r7, lr}
 802f392:	b082      	sub	sp, #8
 802f394:	af00      	add	r7, sp, #0
 802f396:	6078      	str	r0, [r7, #4]
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
 802f398:	687b      	ldr	r3, [r7, #4]
 802f39a:	f893 33cc 	ldrb.w	r3, [r3, #972]	@ 0x3cc
 802f39e:	2b01      	cmp	r3, #1
 802f3a0:	d12a      	bne.n	802f3f8 <USBH_LL_Init+0x68>
  /* Link the driver to the stack. */
  hhcd_USB_OTG_FS.pData = phost;
 802f3a2:	4a18      	ldr	r2, [pc, #96]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3a4:	687b      	ldr	r3, [r7, #4]
 802f3a6:	f8c2 33dc 	str.w	r3, [r2, #988]	@ 0x3dc
  phost->pData = &hhcd_USB_OTG_FS;
 802f3aa:	687b      	ldr	r3, [r7, #4]
 802f3ac:	4a15      	ldr	r2, [pc, #84]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3ae:	f8c3 23d0 	str.w	r2, [r3, #976]	@ 0x3d0

  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 802f3b2:	4b14      	ldr	r3, [pc, #80]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3b4:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 802f3b8:	601a      	str	r2, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 8;
 802f3ba:	4b12      	ldr	r3, [pc, #72]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3bc:	2208      	movs	r2, #8
 802f3be:	715a      	strb	r2, [r3, #5]
  hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
 802f3c0:	4b10      	ldr	r3, [pc, #64]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3c2:	2201      	movs	r2, #1
 802f3c4:	71da      	strb	r2, [r3, #7]
  hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 802f3c6:	4b0f      	ldr	r3, [pc, #60]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3c8:	2200      	movs	r2, #0
 802f3ca:	719a      	strb	r2, [r3, #6]
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 802f3cc:	4b0d      	ldr	r3, [pc, #52]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3ce:	2202      	movs	r2, #2
 802f3d0:	725a      	strb	r2, [r3, #9]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 802f3d2:	4b0c      	ldr	r3, [pc, #48]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3d4:	2200      	movs	r2, #0
 802f3d6:	729a      	strb	r2, [r3, #10]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 802f3d8:	480a      	ldr	r0, [pc, #40]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3da:	f7d4 fca1 	bl	8003d20 <HAL_HCD_Init>
 802f3de:	4603      	mov	r3, r0
 802f3e0:	2b00      	cmp	r3, #0
 802f3e2:	d001      	beq.n	802f3e8 <USBH_LL_Init+0x58>
  {
    Error_Handler( );
 802f3e4:	f7d2 f87e 	bl	80014e4 <Error_Handler>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
 802f3e8:	4806      	ldr	r0, [pc, #24]	@ (802f404 <USBH_LL_Init+0x74>)
 802f3ea:	f7d5 f901 	bl	80045f0 <HAL_HCD_GetCurrentFrame>
 802f3ee:	4603      	mov	r3, r0
 802f3f0:	4619      	mov	r1, r3
 802f3f2:	6878      	ldr	r0, [r7, #4]
 802f3f4:	f7dd fa3a 	bl	800c86c <USBH_LL_SetTimer>
  }
  return USBH_OK;
 802f3f8:	2300      	movs	r3, #0
}
 802f3fa:	4618      	mov	r0, r3
 802f3fc:	3708      	adds	r7, #8
 802f3fe:	46bd      	mov	sp, r7
 802f400:	bd80      	pop	{r7, pc}
 802f402:	bf00      	nop
 802f404:	2000316c 	.word	0x2000316c

0802f408 <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 802f408:	b580      	push	{r7, lr}
 802f40a:	b084      	sub	sp, #16
 802f40c:	af00      	add	r7, sp, #0
 802f40e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f410:	2300      	movs	r3, #0
 802f412:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f414:	2300      	movs	r3, #0
 802f416:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Start(phost->pData);
 802f418:	687b      	ldr	r3, [r7, #4]
 802f41a:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f41e:	4618      	mov	r0, r3
 802f420:	f7d5 f86e 	bl	8004500 <HAL_HCD_Start>
 802f424:	4603      	mov	r3, r0
 802f426:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802f428:	7bfb      	ldrb	r3, [r7, #15]
 802f42a:	4618      	mov	r0, r3
 802f42c:	f000 f992 	bl	802f754 <USBH_Get_USB_Status>
 802f430:	4603      	mov	r3, r0
 802f432:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f434:	7bbb      	ldrb	r3, [r7, #14]
}
 802f436:	4618      	mov	r0, r3
 802f438:	3710      	adds	r7, #16
 802f43a:	46bd      	mov	sp, r7
 802f43c:	bd80      	pop	{r7, pc}

0802f43e <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 802f43e:	b580      	push	{r7, lr}
 802f440:	b084      	sub	sp, #16
 802f442:	af00      	add	r7, sp, #0
 802f444:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f446:	2300      	movs	r3, #0
 802f448:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f44a:	2300      	movs	r3, #0
 802f44c:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Stop(phost->pData);
 802f44e:	687b      	ldr	r3, [r7, #4]
 802f450:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f454:	4618      	mov	r0, r3
 802f456:	f7d5 f876 	bl	8004546 <HAL_HCD_Stop>
 802f45a:	4603      	mov	r3, r0
 802f45c:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802f45e:	7bfb      	ldrb	r3, [r7, #15]
 802f460:	4618      	mov	r0, r3
 802f462:	f000 f977 	bl	802f754 <USBH_Get_USB_Status>
 802f466:	4603      	mov	r3, r0
 802f468:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f46a:	7bbb      	ldrb	r3, [r7, #14]
}
 802f46c:	4618      	mov	r0, r3
 802f46e:	3710      	adds	r7, #16
 802f470:	46bd      	mov	sp, r7
 802f472:	bd80      	pop	{r7, pc}

0802f474 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 802f474:	b580      	push	{r7, lr}
 802f476:	b084      	sub	sp, #16
 802f478:	af00      	add	r7, sp, #0
 802f47a:	6078      	str	r0, [r7, #4]
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
 802f47c:	2301      	movs	r3, #1
 802f47e:	73fb      	strb	r3, [r7, #15]

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 802f480:	687b      	ldr	r3, [r7, #4]
 802f482:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f486:	4618      	mov	r0, r3
 802f488:	f7d5 f8c0 	bl	800460c <HAL_HCD_GetCurrentSpeed>
 802f48c:	4603      	mov	r3, r0
 802f48e:	2b02      	cmp	r3, #2
 802f490:	d00c      	beq.n	802f4ac <USBH_LL_GetSpeed+0x38>
 802f492:	2b02      	cmp	r3, #2
 802f494:	d80d      	bhi.n	802f4b2 <USBH_LL_GetSpeed+0x3e>
 802f496:	2b00      	cmp	r3, #0
 802f498:	d002      	beq.n	802f4a0 <USBH_LL_GetSpeed+0x2c>
 802f49a:	2b01      	cmp	r3, #1
 802f49c:	d003      	beq.n	802f4a6 <USBH_LL_GetSpeed+0x32>
 802f49e:	e008      	b.n	802f4b2 <USBH_LL_GetSpeed+0x3e>
  {
  case 0 :
    speed = USBH_SPEED_HIGH;
 802f4a0:	2300      	movs	r3, #0
 802f4a2:	73fb      	strb	r3, [r7, #15]
    break;
 802f4a4:	e008      	b.n	802f4b8 <USBH_LL_GetSpeed+0x44>

  case 1 :
    speed = USBH_SPEED_FULL;
 802f4a6:	2301      	movs	r3, #1
 802f4a8:	73fb      	strb	r3, [r7, #15]
    break;
 802f4aa:	e005      	b.n	802f4b8 <USBH_LL_GetSpeed+0x44>

  case 2 :
    speed = USBH_SPEED_LOW;
 802f4ac:	2302      	movs	r3, #2
 802f4ae:	73fb      	strb	r3, [r7, #15]
    break;
 802f4b0:	e002      	b.n	802f4b8 <USBH_LL_GetSpeed+0x44>

  default:
   speed = USBH_SPEED_FULL;
 802f4b2:	2301      	movs	r3, #1
 802f4b4:	73fb      	strb	r3, [r7, #15]
    break;
 802f4b6:	bf00      	nop
  }
  return  speed;
 802f4b8:	7bfb      	ldrb	r3, [r7, #15]
}
 802f4ba:	4618      	mov	r0, r3
 802f4bc:	3710      	adds	r7, #16
 802f4be:	46bd      	mov	sp, r7
 802f4c0:	bd80      	pop	{r7, pc}

0802f4c2 <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
 802f4c2:	b580      	push	{r7, lr}
 802f4c4:	b084      	sub	sp, #16
 802f4c6:	af00      	add	r7, sp, #0
 802f4c8:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f4ca:	2300      	movs	r3, #0
 802f4cc:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f4ce:	2300      	movs	r3, #0
 802f4d0:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_ResetPort(phost->pData);
 802f4d2:	687b      	ldr	r3, [r7, #4]
 802f4d4:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f4d8:	4618      	mov	r0, r3
 802f4da:	f7d5 f851 	bl	8004580 <HAL_HCD_ResetPort>
 802f4de:	4603      	mov	r3, r0
 802f4e0:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802f4e2:	7bfb      	ldrb	r3, [r7, #15]
 802f4e4:	4618      	mov	r0, r3
 802f4e6:	f000 f935 	bl	802f754 <USBH_Get_USB_Status>
 802f4ea:	4603      	mov	r3, r0
 802f4ec:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f4ee:	7bbb      	ldrb	r3, [r7, #14]
}
 802f4f0:	4618      	mov	r0, r3
 802f4f2:	3710      	adds	r7, #16
 802f4f4:	46bd      	mov	sp, r7
 802f4f6:	bd80      	pop	{r7, pc}

0802f4f8 <USBH_LL_GetLastXferSize>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802f4f8:	b580      	push	{r7, lr}
 802f4fa:	b082      	sub	sp, #8
 802f4fc:	af00      	add	r7, sp, #0
 802f4fe:	6078      	str	r0, [r7, #4]
 802f500:	460b      	mov	r3, r1
 802f502:	70fb      	strb	r3, [r7, #3]
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 802f504:	687b      	ldr	r3, [r7, #4]
 802f506:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f50a:	78fa      	ldrb	r2, [r7, #3]
 802f50c:	4611      	mov	r1, r2
 802f50e:	4618      	mov	r0, r3
 802f510:	f7d5 f859 	bl	80045c6 <HAL_HCD_HC_GetXferCount>
 802f514:	4603      	mov	r3, r0
}
 802f516:	4618      	mov	r0, r3
 802f518:	3708      	adds	r7, #8
 802f51a:	46bd      	mov	sp, r7
 802f51c:	bd80      	pop	{r7, pc}

0802f51e <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 802f51e:	b590      	push	{r4, r7, lr}
 802f520:	b089      	sub	sp, #36	@ 0x24
 802f522:	af04      	add	r7, sp, #16
 802f524:	6078      	str	r0, [r7, #4]
 802f526:	4608      	mov	r0, r1
 802f528:	4611      	mov	r1, r2
 802f52a:	461a      	mov	r2, r3
 802f52c:	4603      	mov	r3, r0
 802f52e:	70fb      	strb	r3, [r7, #3]
 802f530:	460b      	mov	r3, r1
 802f532:	70bb      	strb	r3, [r7, #2]
 802f534:	4613      	mov	r3, r2
 802f536:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f538:	2300      	movs	r3, #0
 802f53a:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f53c:	2300      	movs	r3, #0
 802f53e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 802f540:	687b      	ldr	r3, [r7, #4]
 802f542:	f8d3 03d0 	ldr.w	r0, [r3, #976]	@ 0x3d0
 802f546:	787c      	ldrb	r4, [r7, #1]
 802f548:	78ba      	ldrb	r2, [r7, #2]
 802f54a:	78f9      	ldrb	r1, [r7, #3]
 802f54c:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 802f54e:	9302      	str	r3, [sp, #8]
 802f550:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 802f554:	9301      	str	r3, [sp, #4]
 802f556:	f897 3020 	ldrb.w	r3, [r7, #32]
 802f55a:	9300      	str	r3, [sp, #0]
 802f55c:	4623      	mov	r3, r4
 802f55e:	f7d4 fc46 	bl	8003dee <HAL_HCD_HC_Init>
 802f562:	4603      	mov	r3, r0
 802f564:	73fb      	strb	r3, [r7, #15]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
 802f566:	7bfb      	ldrb	r3, [r7, #15]
 802f568:	4618      	mov	r0, r3
 802f56a:	f000 f8f3 	bl	802f754 <USBH_Get_USB_Status>
 802f56e:	4603      	mov	r3, r0
 802f570:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f572:	7bbb      	ldrb	r3, [r7, #14]
}
 802f574:	4618      	mov	r0, r3
 802f576:	3714      	adds	r7, #20
 802f578:	46bd      	mov	sp, r7
 802f57a:	bd90      	pop	{r4, r7, pc}

0802f57c <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802f57c:	b580      	push	{r7, lr}
 802f57e:	b084      	sub	sp, #16
 802f580:	af00      	add	r7, sp, #0
 802f582:	6078      	str	r0, [r7, #4]
 802f584:	460b      	mov	r3, r1
 802f586:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f588:	2300      	movs	r3, #0
 802f58a:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f58c:	2300      	movs	r3, #0
 802f58e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 802f590:	687b      	ldr	r3, [r7, #4]
 802f592:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f596:	78fa      	ldrb	r2, [r7, #3]
 802f598:	4611      	mov	r1, r2
 802f59a:	4618      	mov	r0, r3
 802f59c:	f7d4 fcdf 	bl	8003f5e <HAL_HCD_HC_Halt>
 802f5a0:	4603      	mov	r3, r0
 802f5a2:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 802f5a4:	7bfb      	ldrb	r3, [r7, #15]
 802f5a6:	4618      	mov	r0, r3
 802f5a8:	f000 f8d4 	bl	802f754 <USBH_Get_USB_Status>
 802f5ac:	4603      	mov	r3, r0
 802f5ae:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f5b0:	7bbb      	ldrb	r3, [r7, #14]
}
 802f5b2:	4618      	mov	r0, r3
 802f5b4:	3710      	adds	r7, #16
 802f5b6:	46bd      	mov	sp, r7
 802f5b8:	bd80      	pop	{r7, pc}

0802f5ba <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
 802f5ba:	b590      	push	{r4, r7, lr}
 802f5bc:	b089      	sub	sp, #36	@ 0x24
 802f5be:	af04      	add	r7, sp, #16
 802f5c0:	6078      	str	r0, [r7, #4]
 802f5c2:	4608      	mov	r0, r1
 802f5c4:	4611      	mov	r1, r2
 802f5c6:	461a      	mov	r2, r3
 802f5c8:	4603      	mov	r3, r0
 802f5ca:	70fb      	strb	r3, [r7, #3]
 802f5cc:	460b      	mov	r3, r1
 802f5ce:	70bb      	strb	r3, [r7, #2]
 802f5d0:	4613      	mov	r3, r2
 802f5d2:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802f5d4:	2300      	movs	r3, #0
 802f5d6:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f5d8:	2300      	movs	r3, #0
 802f5da:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 802f5dc:	687b      	ldr	r3, [r7, #4]
 802f5de:	f8d3 03d0 	ldr.w	r0, [r3, #976]	@ 0x3d0
 802f5e2:	787c      	ldrb	r4, [r7, #1]
 802f5e4:	78ba      	ldrb	r2, [r7, #2]
 802f5e6:	78f9      	ldrb	r1, [r7, #3]
 802f5e8:	f897 302c 	ldrb.w	r3, [r7, #44]	@ 0x2c
 802f5ec:	9303      	str	r3, [sp, #12]
 802f5ee:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 802f5f0:	9302      	str	r3, [sp, #8]
 802f5f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802f5f4:	9301      	str	r3, [sp, #4]
 802f5f6:	f897 3020 	ldrb.w	r3, [r7, #32]
 802f5fa:	9300      	str	r3, [sp, #0]
 802f5fc:	4623      	mov	r3, r4
 802f5fe:	f7d4 fcd1 	bl	8003fa4 <HAL_HCD_HC_SubmitRequest>
 802f602:	4603      	mov	r3, r0
 802f604:	73fb      	strb	r3, [r7, #15]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
 802f606:	7bfb      	ldrb	r3, [r7, #15]
 802f608:	4618      	mov	r0, r3
 802f60a:	f000 f8a3 	bl	802f754 <USBH_Get_USB_Status>
 802f60e:	4603      	mov	r3, r0
 802f610:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802f612:	7bbb      	ldrb	r3, [r7, #14]
}
 802f614:	4618      	mov	r0, r3
 802f616:	3714      	adds	r7, #20
 802f618:	46bd      	mov	sp, r7
 802f61a:	bd90      	pop	{r4, r7, pc}

0802f61c <USBH_LL_GetURBState>:
  *            @arg URB_NYET
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802f61c:	b580      	push	{r7, lr}
 802f61e:	b082      	sub	sp, #8
 802f620:	af00      	add	r7, sp, #0
 802f622:	6078      	str	r0, [r7, #4]
 802f624:	460b      	mov	r3, r1
 802f626:	70fb      	strb	r3, [r7, #3]
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 802f628:	687b      	ldr	r3, [r7, #4]
 802f62a:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f62e:	78fa      	ldrb	r2, [r7, #3]
 802f630:	4611      	mov	r1, r2
 802f632:	4618      	mov	r0, r3
 802f634:	f7d4 ffb2 	bl	800459c <HAL_HCD_HC_GetURBState>
 802f638:	4603      	mov	r3, r0
}
 802f63a:	4618      	mov	r0, r3
 802f63c:	3708      	adds	r7, #8
 802f63e:	46bd      	mov	sp, r7
 802f640:	bd80      	pop	{r7, pc}

0802f642 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Inactive
  *           1 : VBUS Active
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 802f642:	b580      	push	{r7, lr}
 802f644:	b082      	sub	sp, #8
 802f646:	af00      	add	r7, sp, #0
 802f648:	6078      	str	r0, [r7, #4]
 802f64a:	460b      	mov	r3, r1
 802f64c:	70fb      	strb	r3, [r7, #3]
  if (phost->id == HOST_FS) {
 802f64e:	687b      	ldr	r3, [r7, #4]
 802f650:	f893 33cc 	ldrb.w	r3, [r3, #972]	@ 0x3cc
 802f654:	2b01      	cmp	r3, #1
 802f656:	d103      	bne.n	802f660 <USBH_LL_DriverVBUS+0x1e>
    MX_DriverVbusFS(state);
 802f658:	78fb      	ldrb	r3, [r7, #3]
 802f65a:	4618      	mov	r0, r3
 802f65c:	f000 f8a6 	bl	802f7ac <MX_DriverVbusFS>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
 802f660:	20c8      	movs	r0, #200	@ 0xc8
 802f662:	f7d2 f9e1 	bl	8001a28 <HAL_Delay>
  return USBH_OK;
 802f666:	2300      	movs	r3, #0
}
 802f668:	4618      	mov	r0, r3
 802f66a:	3708      	adds	r7, #8
 802f66c:	46bd      	mov	sp, r7
 802f66e:	bd80      	pop	{r7, pc}

0802f670 <USBH_LL_SetToggle>:
  * @param  pipe: Pipe index
  * @param  toggle: toggle (0/1)
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
 802f670:	b480      	push	{r7}
 802f672:	b085      	sub	sp, #20
 802f674:	af00      	add	r7, sp, #0
 802f676:	6078      	str	r0, [r7, #4]
 802f678:	460b      	mov	r3, r1
 802f67a:	70fb      	strb	r3, [r7, #3]
 802f67c:	4613      	mov	r3, r2
 802f67e:	70bb      	strb	r3, [r7, #2]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 802f680:	687b      	ldr	r3, [r7, #4]
 802f682:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f686:	60fb      	str	r3, [r7, #12]

  if(pHandle->hc[pipe].ep_is_in)
 802f688:	78fa      	ldrb	r2, [r7, #3]
 802f68a:	68f9      	ldr	r1, [r7, #12]
 802f68c:	4613      	mov	r3, r2
 802f68e:	011b      	lsls	r3, r3, #4
 802f690:	1a9b      	subs	r3, r3, r2
 802f692:	009b      	lsls	r3, r3, #2
 802f694:	440b      	add	r3, r1
 802f696:	3317      	adds	r3, #23
 802f698:	781b      	ldrb	r3, [r3, #0]
 802f69a:	2b00      	cmp	r3, #0
 802f69c:	d00a      	beq.n	802f6b4 <USBH_LL_SetToggle+0x44>
  {
    pHandle->hc[pipe].toggle_in = toggle;
 802f69e:	78fa      	ldrb	r2, [r7, #3]
 802f6a0:	68f9      	ldr	r1, [r7, #12]
 802f6a2:	4613      	mov	r3, r2
 802f6a4:	011b      	lsls	r3, r3, #4
 802f6a6:	1a9b      	subs	r3, r3, r2
 802f6a8:	009b      	lsls	r3, r3, #2
 802f6aa:	440b      	add	r3, r1
 802f6ac:	333c      	adds	r3, #60	@ 0x3c
 802f6ae:	78ba      	ldrb	r2, [r7, #2]
 802f6b0:	701a      	strb	r2, [r3, #0]
 802f6b2:	e009      	b.n	802f6c8 <USBH_LL_SetToggle+0x58>
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
 802f6b4:	78fa      	ldrb	r2, [r7, #3]
 802f6b6:	68f9      	ldr	r1, [r7, #12]
 802f6b8:	4613      	mov	r3, r2
 802f6ba:	011b      	lsls	r3, r3, #4
 802f6bc:	1a9b      	subs	r3, r3, r2
 802f6be:	009b      	lsls	r3, r3, #2
 802f6c0:	440b      	add	r3, r1
 802f6c2:	333d      	adds	r3, #61	@ 0x3d
 802f6c4:	78ba      	ldrb	r2, [r7, #2]
 802f6c6:	701a      	strb	r2, [r3, #0]
  }

  return USBH_OK;
 802f6c8:	2300      	movs	r3, #0
}
 802f6ca:	4618      	mov	r0, r3
 802f6cc:	3714      	adds	r7, #20
 802f6ce:	46bd      	mov	sp, r7
 802f6d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f6d4:	4770      	bx	lr

0802f6d6 <USBH_LL_GetToggle>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval toggle (0/1)
  */
uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 802f6d6:	b480      	push	{r7}
 802f6d8:	b085      	sub	sp, #20
 802f6da:	af00      	add	r7, sp, #0
 802f6dc:	6078      	str	r0, [r7, #4]
 802f6de:	460b      	mov	r3, r1
 802f6e0:	70fb      	strb	r3, [r7, #3]
  uint8_t toggle = 0;
 802f6e2:	2300      	movs	r3, #0
 802f6e4:	73fb      	strb	r3, [r7, #15]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 802f6e6:	687b      	ldr	r3, [r7, #4]
 802f6e8:	f8d3 33d0 	ldr.w	r3, [r3, #976]	@ 0x3d0
 802f6ec:	60bb      	str	r3, [r7, #8]

  if(pHandle->hc[pipe].ep_is_in)
 802f6ee:	78fa      	ldrb	r2, [r7, #3]
 802f6f0:	68b9      	ldr	r1, [r7, #8]
 802f6f2:	4613      	mov	r3, r2
 802f6f4:	011b      	lsls	r3, r3, #4
 802f6f6:	1a9b      	subs	r3, r3, r2
 802f6f8:	009b      	lsls	r3, r3, #2
 802f6fa:	440b      	add	r3, r1
 802f6fc:	3317      	adds	r3, #23
 802f6fe:	781b      	ldrb	r3, [r3, #0]
 802f700:	2b00      	cmp	r3, #0
 802f702:	d00a      	beq.n	802f71a <USBH_LL_GetToggle+0x44>
  {
    toggle = pHandle->hc[pipe].toggle_in;
 802f704:	78fa      	ldrb	r2, [r7, #3]
 802f706:	68b9      	ldr	r1, [r7, #8]
 802f708:	4613      	mov	r3, r2
 802f70a:	011b      	lsls	r3, r3, #4
 802f70c:	1a9b      	subs	r3, r3, r2
 802f70e:	009b      	lsls	r3, r3, #2
 802f710:	440b      	add	r3, r1
 802f712:	333c      	adds	r3, #60	@ 0x3c
 802f714:	781b      	ldrb	r3, [r3, #0]
 802f716:	73fb      	strb	r3, [r7, #15]
 802f718:	e009      	b.n	802f72e <USBH_LL_GetToggle+0x58>
  }
  else
  {
    toggle = pHandle->hc[pipe].toggle_out;
 802f71a:	78fa      	ldrb	r2, [r7, #3]
 802f71c:	68b9      	ldr	r1, [r7, #8]
 802f71e:	4613      	mov	r3, r2
 802f720:	011b      	lsls	r3, r3, #4
 802f722:	1a9b      	subs	r3, r3, r2
 802f724:	009b      	lsls	r3, r3, #2
 802f726:	440b      	add	r3, r1
 802f728:	333d      	adds	r3, #61	@ 0x3d
 802f72a:	781b      	ldrb	r3, [r3, #0]
 802f72c:	73fb      	strb	r3, [r7, #15]
  }
  return toggle;
 802f72e:	7bfb      	ldrb	r3, [r7, #15]
}
 802f730:	4618      	mov	r0, r3
 802f732:	3714      	adds	r7, #20
 802f734:	46bd      	mov	sp, r7
 802f736:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f73a:	4770      	bx	lr

0802f73c <USBH_Delay>:
  * @brief  Delay routine for the USB Host Library
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
 802f73c:	b580      	push	{r7, lr}
 802f73e:	b082      	sub	sp, #8
 802f740:	af00      	add	r7, sp, #0
 802f742:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
 802f744:	6878      	ldr	r0, [r7, #4]
 802f746:	f7d2 f96f 	bl	8001a28 <HAL_Delay>
}
 802f74a:	bf00      	nop
 802f74c:	3708      	adds	r7, #8
 802f74e:	46bd      	mov	sp, r7
 802f750:	bd80      	pop	{r7, pc}
	...

0802f754 <USBH_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBH_StatusTypeDef USBH_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 802f754:	b480      	push	{r7}
 802f756:	b085      	sub	sp, #20
 802f758:	af00      	add	r7, sp, #0
 802f75a:	4603      	mov	r3, r0
 802f75c:	71fb      	strb	r3, [r7, #7]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802f75e:	2300      	movs	r3, #0
 802f760:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 802f762:	79fb      	ldrb	r3, [r7, #7]
 802f764:	2b03      	cmp	r3, #3
 802f766:	d817      	bhi.n	802f798 <USBH_Get_USB_Status+0x44>
 802f768:	a201      	add	r2, pc, #4	@ (adr r2, 802f770 <USBH_Get_USB_Status+0x1c>)
 802f76a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802f76e:	bf00      	nop
 802f770:	0802f781 	.word	0x0802f781
 802f774:	0802f787 	.word	0x0802f787
 802f778:	0802f78d 	.word	0x0802f78d
 802f77c:	0802f793 	.word	0x0802f793
  {
    case HAL_OK :
      usb_status = USBH_OK;
 802f780:	2300      	movs	r3, #0
 802f782:	73fb      	strb	r3, [r7, #15]
    break;
 802f784:	e00b      	b.n	802f79e <USBH_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBH_FAIL;
 802f786:	2302      	movs	r3, #2
 802f788:	73fb      	strb	r3, [r7, #15]
    break;
 802f78a:	e008      	b.n	802f79e <USBH_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBH_BUSY;
 802f78c:	2301      	movs	r3, #1
 802f78e:	73fb      	strb	r3, [r7, #15]
    break;
 802f790:	e005      	b.n	802f79e <USBH_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBH_FAIL;
 802f792:	2302      	movs	r3, #2
 802f794:	73fb      	strb	r3, [r7, #15]
    break;
 802f796:	e002      	b.n	802f79e <USBH_Get_USB_Status+0x4a>
    default :
      usb_status = USBH_FAIL;
 802f798:	2302      	movs	r3, #2
 802f79a:	73fb      	strb	r3, [r7, #15]
    break;
 802f79c:	bf00      	nop
  }
  return usb_status;
 802f79e:	7bfb      	ldrb	r3, [r7, #15]
}
 802f7a0:	4618      	mov	r0, r3
 802f7a2:	3714      	adds	r7, #20
 802f7a4:	46bd      	mov	sp, r7
 802f7a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f7aa:	4770      	bx	lr

0802f7ac <MX_DriverVbusFS>:
  *          This parameter can be one of the these values:
  *           - 1 : VBUS Active
  *           - 0 : VBUS Inactive
  */
void MX_DriverVbusFS(uint8_t state)
{
 802f7ac:	b580      	push	{r7, lr}
 802f7ae:	b084      	sub	sp, #16
 802f7b0:	af00      	add	r7, sp, #0
 802f7b2:	4603      	mov	r3, r0
 802f7b4:	71fb      	strb	r3, [r7, #7]
  uint8_t data = state;
 802f7b6:	79fb      	ldrb	r3, [r7, #7]
 802f7b8:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN PREPARE_GPIO_DATA_VBUS_FS */
  if(state == 0)
 802f7ba:	79fb      	ldrb	r3, [r7, #7]
 802f7bc:	2b00      	cmp	r3, #0
 802f7be:	d102      	bne.n	802f7c6 <MX_DriverVbusFS+0x1a>
  {
    /* Drive high Charge pump */
    data = RESET;
 802f7c0:	2300      	movs	r3, #0
 802f7c2:	73fb      	strb	r3, [r7, #15]
 802f7c4:	e001      	b.n	802f7ca <MX_DriverVbusFS+0x1e>
  }
  else
  {
    /* Drive low Charge pump */
    data = SET;
 802f7c6:	2301      	movs	r3, #1
 802f7c8:	73fb      	strb	r3, [r7, #15]
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  GPIO_WritePin(GPIOC,GPIO_PIN_0,(FlagStatus)data);
 802f7ca:	7bfb      	ldrb	r3, [r7, #15]
 802f7cc:	461a      	mov	r2, r3
 802f7ce:	2100      	movs	r1, #0
 802f7d0:	4803      	ldr	r0, [pc, #12]	@ (802f7e0 <MX_DriverVbusFS+0x34>)
 802f7d2:	f7d9 ffa1 	bl	8009718 <GPIO_WritePin>
}
 802f7d6:	bf00      	nop
 802f7d8:	3710      	adds	r7, #16
 802f7da:	46bd      	mov	sp, r7
 802f7dc:	bd80      	pop	{r7, pc}
 802f7de:	bf00      	nop
 802f7e0:	40020800 	.word	0x40020800

0802f7e4 <malloc>:
 802f7e4:	4b02      	ldr	r3, [pc, #8]	@ (802f7f0 <malloc+0xc>)
 802f7e6:	4601      	mov	r1, r0
 802f7e8:	6818      	ldr	r0, [r3, #0]
 802f7ea:	f000 b82d 	b.w	802f848 <_malloc_r>
 802f7ee:	bf00      	nop
 802f7f0:	2000002c 	.word	0x2000002c

0802f7f4 <free>:
 802f7f4:	4b02      	ldr	r3, [pc, #8]	@ (802f800 <free+0xc>)
 802f7f6:	4601      	mov	r1, r0
 802f7f8:	6818      	ldr	r0, [r3, #0]
 802f7fa:	f000 b923 	b.w	802fa44 <_free_r>
 802f7fe:	bf00      	nop
 802f800:	2000002c 	.word	0x2000002c

0802f804 <sbrk_aligned>:
 802f804:	b570      	push	{r4, r5, r6, lr}
 802f806:	4e0f      	ldr	r6, [pc, #60]	@ (802f844 <sbrk_aligned+0x40>)
 802f808:	460c      	mov	r4, r1
 802f80a:	6831      	ldr	r1, [r6, #0]
 802f80c:	4605      	mov	r5, r0
 802f80e:	b911      	cbnz	r1, 802f816 <sbrk_aligned+0x12>
 802f810:	f000 f8ce 	bl	802f9b0 <_sbrk_r>
 802f814:	6030      	str	r0, [r6, #0]
 802f816:	4621      	mov	r1, r4
 802f818:	4628      	mov	r0, r5
 802f81a:	f000 f8c9 	bl	802f9b0 <_sbrk_r>
 802f81e:	1c43      	adds	r3, r0, #1
 802f820:	d103      	bne.n	802f82a <sbrk_aligned+0x26>
 802f822:	f04f 34ff 	mov.w	r4, #4294967295
 802f826:	4620      	mov	r0, r4
 802f828:	bd70      	pop	{r4, r5, r6, pc}
 802f82a:	1cc4      	adds	r4, r0, #3
 802f82c:	f024 0403 	bic.w	r4, r4, #3
 802f830:	42a0      	cmp	r0, r4
 802f832:	d0f8      	beq.n	802f826 <sbrk_aligned+0x22>
 802f834:	1a21      	subs	r1, r4, r0
 802f836:	4628      	mov	r0, r5
 802f838:	f000 f8ba 	bl	802f9b0 <_sbrk_r>
 802f83c:	3001      	adds	r0, #1
 802f83e:	d1f2      	bne.n	802f826 <sbrk_aligned+0x22>
 802f840:	e7ef      	b.n	802f822 <sbrk_aligned+0x1e>
 802f842:	bf00      	nop
 802f844:	2000354c 	.word	0x2000354c

0802f848 <_malloc_r>:
 802f848:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802f84c:	1ccd      	adds	r5, r1, #3
 802f84e:	f025 0503 	bic.w	r5, r5, #3
 802f852:	3508      	adds	r5, #8
 802f854:	2d0c      	cmp	r5, #12
 802f856:	bf38      	it	cc
 802f858:	250c      	movcc	r5, #12
 802f85a:	2d00      	cmp	r5, #0
 802f85c:	4606      	mov	r6, r0
 802f85e:	db01      	blt.n	802f864 <_malloc_r+0x1c>
 802f860:	42a9      	cmp	r1, r5
 802f862:	d904      	bls.n	802f86e <_malloc_r+0x26>
 802f864:	230c      	movs	r3, #12
 802f866:	6033      	str	r3, [r6, #0]
 802f868:	2000      	movs	r0, #0
 802f86a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802f86e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 802f944 <_malloc_r+0xfc>
 802f872:	f000 f869 	bl	802f948 <__malloc_lock>
 802f876:	f8d8 3000 	ldr.w	r3, [r8]
 802f87a:	461c      	mov	r4, r3
 802f87c:	bb44      	cbnz	r4, 802f8d0 <_malloc_r+0x88>
 802f87e:	4629      	mov	r1, r5
 802f880:	4630      	mov	r0, r6
 802f882:	f7ff ffbf 	bl	802f804 <sbrk_aligned>
 802f886:	1c43      	adds	r3, r0, #1
 802f888:	4604      	mov	r4, r0
 802f88a:	d158      	bne.n	802f93e <_malloc_r+0xf6>
 802f88c:	f8d8 4000 	ldr.w	r4, [r8]
 802f890:	4627      	mov	r7, r4
 802f892:	2f00      	cmp	r7, #0
 802f894:	d143      	bne.n	802f91e <_malloc_r+0xd6>
 802f896:	2c00      	cmp	r4, #0
 802f898:	d04b      	beq.n	802f932 <_malloc_r+0xea>
 802f89a:	6823      	ldr	r3, [r4, #0]
 802f89c:	4639      	mov	r1, r7
 802f89e:	4630      	mov	r0, r6
 802f8a0:	eb04 0903 	add.w	r9, r4, r3
 802f8a4:	f000 f884 	bl	802f9b0 <_sbrk_r>
 802f8a8:	4581      	cmp	r9, r0
 802f8aa:	d142      	bne.n	802f932 <_malloc_r+0xea>
 802f8ac:	6821      	ldr	r1, [r4, #0]
 802f8ae:	1a6d      	subs	r5, r5, r1
 802f8b0:	4629      	mov	r1, r5
 802f8b2:	4630      	mov	r0, r6
 802f8b4:	f7ff ffa6 	bl	802f804 <sbrk_aligned>
 802f8b8:	3001      	adds	r0, #1
 802f8ba:	d03a      	beq.n	802f932 <_malloc_r+0xea>
 802f8bc:	6823      	ldr	r3, [r4, #0]
 802f8be:	442b      	add	r3, r5
 802f8c0:	6023      	str	r3, [r4, #0]
 802f8c2:	f8d8 3000 	ldr.w	r3, [r8]
 802f8c6:	685a      	ldr	r2, [r3, #4]
 802f8c8:	bb62      	cbnz	r2, 802f924 <_malloc_r+0xdc>
 802f8ca:	f8c8 7000 	str.w	r7, [r8]
 802f8ce:	e00f      	b.n	802f8f0 <_malloc_r+0xa8>
 802f8d0:	6822      	ldr	r2, [r4, #0]
 802f8d2:	1b52      	subs	r2, r2, r5
 802f8d4:	d420      	bmi.n	802f918 <_malloc_r+0xd0>
 802f8d6:	2a0b      	cmp	r2, #11
 802f8d8:	d917      	bls.n	802f90a <_malloc_r+0xc2>
 802f8da:	1961      	adds	r1, r4, r5
 802f8dc:	42a3      	cmp	r3, r4
 802f8de:	6025      	str	r5, [r4, #0]
 802f8e0:	bf18      	it	ne
 802f8e2:	6059      	strne	r1, [r3, #4]
 802f8e4:	6863      	ldr	r3, [r4, #4]
 802f8e6:	bf08      	it	eq
 802f8e8:	f8c8 1000 	streq.w	r1, [r8]
 802f8ec:	5162      	str	r2, [r4, r5]
 802f8ee:	604b      	str	r3, [r1, #4]
 802f8f0:	4630      	mov	r0, r6
 802f8f2:	f000 f82f 	bl	802f954 <__malloc_unlock>
 802f8f6:	f104 000b 	add.w	r0, r4, #11
 802f8fa:	1d23      	adds	r3, r4, #4
 802f8fc:	f020 0007 	bic.w	r0, r0, #7
 802f900:	1ac2      	subs	r2, r0, r3
 802f902:	bf1c      	itt	ne
 802f904:	1a1b      	subne	r3, r3, r0
 802f906:	50a3      	strne	r3, [r4, r2]
 802f908:	e7af      	b.n	802f86a <_malloc_r+0x22>
 802f90a:	6862      	ldr	r2, [r4, #4]
 802f90c:	42a3      	cmp	r3, r4
 802f90e:	bf0c      	ite	eq
 802f910:	f8c8 2000 	streq.w	r2, [r8]
 802f914:	605a      	strne	r2, [r3, #4]
 802f916:	e7eb      	b.n	802f8f0 <_malloc_r+0xa8>
 802f918:	4623      	mov	r3, r4
 802f91a:	6864      	ldr	r4, [r4, #4]
 802f91c:	e7ae      	b.n	802f87c <_malloc_r+0x34>
 802f91e:	463c      	mov	r4, r7
 802f920:	687f      	ldr	r7, [r7, #4]
 802f922:	e7b6      	b.n	802f892 <_malloc_r+0x4a>
 802f924:	461a      	mov	r2, r3
 802f926:	685b      	ldr	r3, [r3, #4]
 802f928:	42a3      	cmp	r3, r4
 802f92a:	d1fb      	bne.n	802f924 <_malloc_r+0xdc>
 802f92c:	2300      	movs	r3, #0
 802f92e:	6053      	str	r3, [r2, #4]
 802f930:	e7de      	b.n	802f8f0 <_malloc_r+0xa8>
 802f932:	230c      	movs	r3, #12
 802f934:	6033      	str	r3, [r6, #0]
 802f936:	4630      	mov	r0, r6
 802f938:	f000 f80c 	bl	802f954 <__malloc_unlock>
 802f93c:	e794      	b.n	802f868 <_malloc_r+0x20>
 802f93e:	6005      	str	r5, [r0, #0]
 802f940:	e7d6      	b.n	802f8f0 <_malloc_r+0xa8>
 802f942:	bf00      	nop
 802f944:	20003550 	.word	0x20003550

0802f948 <__malloc_lock>:
 802f948:	4801      	ldr	r0, [pc, #4]	@ (802f950 <__malloc_lock+0x8>)
 802f94a:	f000 b86b 	b.w	802fa24 <__retarget_lock_acquire_recursive>
 802f94e:	bf00      	nop
 802f950:	20003690 	.word	0x20003690

0802f954 <__malloc_unlock>:
 802f954:	4801      	ldr	r0, [pc, #4]	@ (802f95c <__malloc_unlock+0x8>)
 802f956:	f000 b866 	b.w	802fa26 <__retarget_lock_release_recursive>
 802f95a:	bf00      	nop
 802f95c:	20003690 	.word	0x20003690

0802f960 <siprintf>:
 802f960:	b40e      	push	{r1, r2, r3}
 802f962:	b500      	push	{lr}
 802f964:	b09c      	sub	sp, #112	@ 0x70
 802f966:	ab1d      	add	r3, sp, #116	@ 0x74
 802f968:	9002      	str	r0, [sp, #8]
 802f96a:	9006      	str	r0, [sp, #24]
 802f96c:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 802f970:	4809      	ldr	r0, [pc, #36]	@ (802f998 <siprintf+0x38>)
 802f972:	9107      	str	r1, [sp, #28]
 802f974:	9104      	str	r1, [sp, #16]
 802f976:	4909      	ldr	r1, [pc, #36]	@ (802f99c <siprintf+0x3c>)
 802f978:	f853 2b04 	ldr.w	r2, [r3], #4
 802f97c:	9105      	str	r1, [sp, #20]
 802f97e:	6800      	ldr	r0, [r0, #0]
 802f980:	9301      	str	r3, [sp, #4]
 802f982:	a902      	add	r1, sp, #8
 802f984:	f000 f904 	bl	802fb90 <_svfiprintf_r>
 802f988:	9b02      	ldr	r3, [sp, #8]
 802f98a:	2200      	movs	r2, #0
 802f98c:	701a      	strb	r2, [r3, #0]
 802f98e:	b01c      	add	sp, #112	@ 0x70
 802f990:	f85d eb04 	ldr.w	lr, [sp], #4
 802f994:	b003      	add	sp, #12
 802f996:	4770      	bx	lr
 802f998:	2000002c 	.word	0x2000002c
 802f99c:	ffff0208 	.word	0xffff0208

0802f9a0 <memset>:
 802f9a0:	4402      	add	r2, r0
 802f9a2:	4603      	mov	r3, r0
 802f9a4:	4293      	cmp	r3, r2
 802f9a6:	d100      	bne.n	802f9aa <memset+0xa>
 802f9a8:	4770      	bx	lr
 802f9aa:	f803 1b01 	strb.w	r1, [r3], #1
 802f9ae:	e7f9      	b.n	802f9a4 <memset+0x4>

0802f9b0 <_sbrk_r>:
 802f9b0:	b538      	push	{r3, r4, r5, lr}
 802f9b2:	4d06      	ldr	r5, [pc, #24]	@ (802f9cc <_sbrk_r+0x1c>)
 802f9b4:	2300      	movs	r3, #0
 802f9b6:	4604      	mov	r4, r0
 802f9b8:	4608      	mov	r0, r1
 802f9ba:	602b      	str	r3, [r5, #0]
 802f9bc:	f7d1 ff50 	bl	8001860 <_sbrk>
 802f9c0:	1c43      	adds	r3, r0, #1
 802f9c2:	d102      	bne.n	802f9ca <_sbrk_r+0x1a>
 802f9c4:	682b      	ldr	r3, [r5, #0]
 802f9c6:	b103      	cbz	r3, 802f9ca <_sbrk_r+0x1a>
 802f9c8:	6023      	str	r3, [r4, #0]
 802f9ca:	bd38      	pop	{r3, r4, r5, pc}
 802f9cc:	2000368c 	.word	0x2000368c

0802f9d0 <__errno>:
 802f9d0:	4b01      	ldr	r3, [pc, #4]	@ (802f9d8 <__errno+0x8>)
 802f9d2:	6818      	ldr	r0, [r3, #0]
 802f9d4:	4770      	bx	lr
 802f9d6:	bf00      	nop
 802f9d8:	2000002c 	.word	0x2000002c

0802f9dc <__libc_init_array>:
 802f9dc:	b570      	push	{r4, r5, r6, lr}
 802f9de:	4d0d      	ldr	r5, [pc, #52]	@ (802fa14 <__libc_init_array+0x38>)
 802f9e0:	4c0d      	ldr	r4, [pc, #52]	@ (802fa18 <__libc_init_array+0x3c>)
 802f9e2:	1b64      	subs	r4, r4, r5
 802f9e4:	10a4      	asrs	r4, r4, #2
 802f9e6:	2600      	movs	r6, #0
 802f9e8:	42a6      	cmp	r6, r4
 802f9ea:	d109      	bne.n	802fa00 <__libc_init_array+0x24>
 802f9ec:	4d0b      	ldr	r5, [pc, #44]	@ (802fa1c <__libc_init_array+0x40>)
 802f9ee:	4c0c      	ldr	r4, [pc, #48]	@ (802fa20 <__libc_init_array+0x44>)
 802f9f0:	f000 fba8 	bl	8030144 <_init>
 802f9f4:	1b64      	subs	r4, r4, r5
 802f9f6:	10a4      	asrs	r4, r4, #2
 802f9f8:	2600      	movs	r6, #0
 802f9fa:	42a6      	cmp	r6, r4
 802f9fc:	d105      	bne.n	802fa0a <__libc_init_array+0x2e>
 802f9fe:	bd70      	pop	{r4, r5, r6, pc}
 802fa00:	f855 3b04 	ldr.w	r3, [r5], #4
 802fa04:	4798      	blx	r3
 802fa06:	3601      	adds	r6, #1
 802fa08:	e7ee      	b.n	802f9e8 <__libc_init_array+0xc>
 802fa0a:	f855 3b04 	ldr.w	r3, [r5], #4
 802fa0e:	4798      	blx	r3
 802fa10:	3601      	adds	r6, #1
 802fa12:	e7f2      	b.n	802f9fa <__libc_init_array+0x1e>
 802fa14:	08032c78 	.word	0x08032c78
 802fa18:	08032c78 	.word	0x08032c78
 802fa1c:	08032c78 	.word	0x08032c78
 802fa20:	08032c7c 	.word	0x08032c7c

0802fa24 <__retarget_lock_acquire_recursive>:
 802fa24:	4770      	bx	lr

0802fa26 <__retarget_lock_release_recursive>:
 802fa26:	4770      	bx	lr

0802fa28 <memcpy>:
 802fa28:	440a      	add	r2, r1
 802fa2a:	4291      	cmp	r1, r2
 802fa2c:	f100 33ff 	add.w	r3, r0, #4294967295
 802fa30:	d100      	bne.n	802fa34 <memcpy+0xc>
 802fa32:	4770      	bx	lr
 802fa34:	b510      	push	{r4, lr}
 802fa36:	f811 4b01 	ldrb.w	r4, [r1], #1
 802fa3a:	f803 4f01 	strb.w	r4, [r3, #1]!
 802fa3e:	4291      	cmp	r1, r2
 802fa40:	d1f9      	bne.n	802fa36 <memcpy+0xe>
 802fa42:	bd10      	pop	{r4, pc}

0802fa44 <_free_r>:
 802fa44:	b538      	push	{r3, r4, r5, lr}
 802fa46:	4605      	mov	r5, r0
 802fa48:	2900      	cmp	r1, #0
 802fa4a:	d041      	beq.n	802fad0 <_free_r+0x8c>
 802fa4c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802fa50:	1f0c      	subs	r4, r1, #4
 802fa52:	2b00      	cmp	r3, #0
 802fa54:	bfb8      	it	lt
 802fa56:	18e4      	addlt	r4, r4, r3
 802fa58:	f7ff ff76 	bl	802f948 <__malloc_lock>
 802fa5c:	4a1d      	ldr	r2, [pc, #116]	@ (802fad4 <_free_r+0x90>)
 802fa5e:	6813      	ldr	r3, [r2, #0]
 802fa60:	b933      	cbnz	r3, 802fa70 <_free_r+0x2c>
 802fa62:	6063      	str	r3, [r4, #4]
 802fa64:	6014      	str	r4, [r2, #0]
 802fa66:	4628      	mov	r0, r5
 802fa68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802fa6c:	f7ff bf72 	b.w	802f954 <__malloc_unlock>
 802fa70:	42a3      	cmp	r3, r4
 802fa72:	d908      	bls.n	802fa86 <_free_r+0x42>
 802fa74:	6820      	ldr	r0, [r4, #0]
 802fa76:	1821      	adds	r1, r4, r0
 802fa78:	428b      	cmp	r3, r1
 802fa7a:	bf01      	itttt	eq
 802fa7c:	6819      	ldreq	r1, [r3, #0]
 802fa7e:	685b      	ldreq	r3, [r3, #4]
 802fa80:	1809      	addeq	r1, r1, r0
 802fa82:	6021      	streq	r1, [r4, #0]
 802fa84:	e7ed      	b.n	802fa62 <_free_r+0x1e>
 802fa86:	461a      	mov	r2, r3
 802fa88:	685b      	ldr	r3, [r3, #4]
 802fa8a:	b10b      	cbz	r3, 802fa90 <_free_r+0x4c>
 802fa8c:	42a3      	cmp	r3, r4
 802fa8e:	d9fa      	bls.n	802fa86 <_free_r+0x42>
 802fa90:	6811      	ldr	r1, [r2, #0]
 802fa92:	1850      	adds	r0, r2, r1
 802fa94:	42a0      	cmp	r0, r4
 802fa96:	d10b      	bne.n	802fab0 <_free_r+0x6c>
 802fa98:	6820      	ldr	r0, [r4, #0]
 802fa9a:	4401      	add	r1, r0
 802fa9c:	1850      	adds	r0, r2, r1
 802fa9e:	4283      	cmp	r3, r0
 802faa0:	6011      	str	r1, [r2, #0]
 802faa2:	d1e0      	bne.n	802fa66 <_free_r+0x22>
 802faa4:	6818      	ldr	r0, [r3, #0]
 802faa6:	685b      	ldr	r3, [r3, #4]
 802faa8:	6053      	str	r3, [r2, #4]
 802faaa:	4408      	add	r0, r1
 802faac:	6010      	str	r0, [r2, #0]
 802faae:	e7da      	b.n	802fa66 <_free_r+0x22>
 802fab0:	d902      	bls.n	802fab8 <_free_r+0x74>
 802fab2:	230c      	movs	r3, #12
 802fab4:	602b      	str	r3, [r5, #0]
 802fab6:	e7d6      	b.n	802fa66 <_free_r+0x22>
 802fab8:	6820      	ldr	r0, [r4, #0]
 802faba:	1821      	adds	r1, r4, r0
 802fabc:	428b      	cmp	r3, r1
 802fabe:	bf04      	itt	eq
 802fac0:	6819      	ldreq	r1, [r3, #0]
 802fac2:	685b      	ldreq	r3, [r3, #4]
 802fac4:	6063      	str	r3, [r4, #4]
 802fac6:	bf04      	itt	eq
 802fac8:	1809      	addeq	r1, r1, r0
 802faca:	6021      	streq	r1, [r4, #0]
 802facc:	6054      	str	r4, [r2, #4]
 802face:	e7ca      	b.n	802fa66 <_free_r+0x22>
 802fad0:	bd38      	pop	{r3, r4, r5, pc}
 802fad2:	bf00      	nop
 802fad4:	20003550 	.word	0x20003550

0802fad8 <__ssputs_r>:
 802fad8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802fadc:	688e      	ldr	r6, [r1, #8]
 802fade:	461f      	mov	r7, r3
 802fae0:	42be      	cmp	r6, r7
 802fae2:	680b      	ldr	r3, [r1, #0]
 802fae4:	4682      	mov	sl, r0
 802fae6:	460c      	mov	r4, r1
 802fae8:	4690      	mov	r8, r2
 802faea:	d82d      	bhi.n	802fb48 <__ssputs_r+0x70>
 802faec:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802faf0:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 802faf4:	d026      	beq.n	802fb44 <__ssputs_r+0x6c>
 802faf6:	6965      	ldr	r5, [r4, #20]
 802faf8:	6909      	ldr	r1, [r1, #16]
 802fafa:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802fafe:	eba3 0901 	sub.w	r9, r3, r1
 802fb02:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802fb06:	1c7b      	adds	r3, r7, #1
 802fb08:	444b      	add	r3, r9
 802fb0a:	106d      	asrs	r5, r5, #1
 802fb0c:	429d      	cmp	r5, r3
 802fb0e:	bf38      	it	cc
 802fb10:	461d      	movcc	r5, r3
 802fb12:	0553      	lsls	r3, r2, #21
 802fb14:	d527      	bpl.n	802fb66 <__ssputs_r+0x8e>
 802fb16:	4629      	mov	r1, r5
 802fb18:	f7ff fe96 	bl	802f848 <_malloc_r>
 802fb1c:	4606      	mov	r6, r0
 802fb1e:	b360      	cbz	r0, 802fb7a <__ssputs_r+0xa2>
 802fb20:	6921      	ldr	r1, [r4, #16]
 802fb22:	464a      	mov	r2, r9
 802fb24:	f7ff ff80 	bl	802fa28 <memcpy>
 802fb28:	89a3      	ldrh	r3, [r4, #12]
 802fb2a:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 802fb2e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802fb32:	81a3      	strh	r3, [r4, #12]
 802fb34:	6126      	str	r6, [r4, #16]
 802fb36:	6165      	str	r5, [r4, #20]
 802fb38:	444e      	add	r6, r9
 802fb3a:	eba5 0509 	sub.w	r5, r5, r9
 802fb3e:	6026      	str	r6, [r4, #0]
 802fb40:	60a5      	str	r5, [r4, #8]
 802fb42:	463e      	mov	r6, r7
 802fb44:	42be      	cmp	r6, r7
 802fb46:	d900      	bls.n	802fb4a <__ssputs_r+0x72>
 802fb48:	463e      	mov	r6, r7
 802fb4a:	6820      	ldr	r0, [r4, #0]
 802fb4c:	4632      	mov	r2, r6
 802fb4e:	4641      	mov	r1, r8
 802fb50:	f000 faa8 	bl	80300a4 <memmove>
 802fb54:	68a3      	ldr	r3, [r4, #8]
 802fb56:	1b9b      	subs	r3, r3, r6
 802fb58:	60a3      	str	r3, [r4, #8]
 802fb5a:	6823      	ldr	r3, [r4, #0]
 802fb5c:	4433      	add	r3, r6
 802fb5e:	6023      	str	r3, [r4, #0]
 802fb60:	2000      	movs	r0, #0
 802fb62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802fb66:	462a      	mov	r2, r5
 802fb68:	f000 fab6 	bl	80300d8 <_realloc_r>
 802fb6c:	4606      	mov	r6, r0
 802fb6e:	2800      	cmp	r0, #0
 802fb70:	d1e0      	bne.n	802fb34 <__ssputs_r+0x5c>
 802fb72:	6921      	ldr	r1, [r4, #16]
 802fb74:	4650      	mov	r0, sl
 802fb76:	f7ff ff65 	bl	802fa44 <_free_r>
 802fb7a:	230c      	movs	r3, #12
 802fb7c:	f8ca 3000 	str.w	r3, [sl]
 802fb80:	89a3      	ldrh	r3, [r4, #12]
 802fb82:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802fb86:	81a3      	strh	r3, [r4, #12]
 802fb88:	f04f 30ff 	mov.w	r0, #4294967295
 802fb8c:	e7e9      	b.n	802fb62 <__ssputs_r+0x8a>
	...

0802fb90 <_svfiprintf_r>:
 802fb90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802fb94:	4698      	mov	r8, r3
 802fb96:	898b      	ldrh	r3, [r1, #12]
 802fb98:	061b      	lsls	r3, r3, #24
 802fb9a:	b09d      	sub	sp, #116	@ 0x74
 802fb9c:	4607      	mov	r7, r0
 802fb9e:	460d      	mov	r5, r1
 802fba0:	4614      	mov	r4, r2
 802fba2:	d510      	bpl.n	802fbc6 <_svfiprintf_r+0x36>
 802fba4:	690b      	ldr	r3, [r1, #16]
 802fba6:	b973      	cbnz	r3, 802fbc6 <_svfiprintf_r+0x36>
 802fba8:	2140      	movs	r1, #64	@ 0x40
 802fbaa:	f7ff fe4d 	bl	802f848 <_malloc_r>
 802fbae:	6028      	str	r0, [r5, #0]
 802fbb0:	6128      	str	r0, [r5, #16]
 802fbb2:	b930      	cbnz	r0, 802fbc2 <_svfiprintf_r+0x32>
 802fbb4:	230c      	movs	r3, #12
 802fbb6:	603b      	str	r3, [r7, #0]
 802fbb8:	f04f 30ff 	mov.w	r0, #4294967295
 802fbbc:	b01d      	add	sp, #116	@ 0x74
 802fbbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802fbc2:	2340      	movs	r3, #64	@ 0x40
 802fbc4:	616b      	str	r3, [r5, #20]
 802fbc6:	2300      	movs	r3, #0
 802fbc8:	9309      	str	r3, [sp, #36]	@ 0x24
 802fbca:	2320      	movs	r3, #32
 802fbcc:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802fbd0:	f8cd 800c 	str.w	r8, [sp, #12]
 802fbd4:	2330      	movs	r3, #48	@ 0x30
 802fbd6:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 802fd74 <_svfiprintf_r+0x1e4>
 802fbda:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 802fbde:	f04f 0901 	mov.w	r9, #1
 802fbe2:	4623      	mov	r3, r4
 802fbe4:	469a      	mov	sl, r3
 802fbe6:	f813 2b01 	ldrb.w	r2, [r3], #1
 802fbea:	b10a      	cbz	r2, 802fbf0 <_svfiprintf_r+0x60>
 802fbec:	2a25      	cmp	r2, #37	@ 0x25
 802fbee:	d1f9      	bne.n	802fbe4 <_svfiprintf_r+0x54>
 802fbf0:	ebba 0b04 	subs.w	fp, sl, r4
 802fbf4:	d00b      	beq.n	802fc0e <_svfiprintf_r+0x7e>
 802fbf6:	465b      	mov	r3, fp
 802fbf8:	4622      	mov	r2, r4
 802fbfa:	4629      	mov	r1, r5
 802fbfc:	4638      	mov	r0, r7
 802fbfe:	f7ff ff6b 	bl	802fad8 <__ssputs_r>
 802fc02:	3001      	adds	r0, #1
 802fc04:	f000 80a7 	beq.w	802fd56 <_svfiprintf_r+0x1c6>
 802fc08:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802fc0a:	445a      	add	r2, fp
 802fc0c:	9209      	str	r2, [sp, #36]	@ 0x24
 802fc0e:	f89a 3000 	ldrb.w	r3, [sl]
 802fc12:	2b00      	cmp	r3, #0
 802fc14:	f000 809f 	beq.w	802fd56 <_svfiprintf_r+0x1c6>
 802fc18:	2300      	movs	r3, #0
 802fc1a:	f04f 32ff 	mov.w	r2, #4294967295
 802fc1e:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802fc22:	f10a 0a01 	add.w	sl, sl, #1
 802fc26:	9304      	str	r3, [sp, #16]
 802fc28:	9307      	str	r3, [sp, #28]
 802fc2a:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 802fc2e:	931a      	str	r3, [sp, #104]	@ 0x68
 802fc30:	4654      	mov	r4, sl
 802fc32:	2205      	movs	r2, #5
 802fc34:	f814 1b01 	ldrb.w	r1, [r4], #1
 802fc38:	484e      	ldr	r0, [pc, #312]	@ (802fd74 <_svfiprintf_r+0x1e4>)
 802fc3a:	f7d0 fac9 	bl	80001d0 <memchr>
 802fc3e:	9a04      	ldr	r2, [sp, #16]
 802fc40:	b9d8      	cbnz	r0, 802fc7a <_svfiprintf_r+0xea>
 802fc42:	06d0      	lsls	r0, r2, #27
 802fc44:	bf44      	itt	mi
 802fc46:	2320      	movmi	r3, #32
 802fc48:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802fc4c:	0711      	lsls	r1, r2, #28
 802fc4e:	bf44      	itt	mi
 802fc50:	232b      	movmi	r3, #43	@ 0x2b
 802fc52:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802fc56:	f89a 3000 	ldrb.w	r3, [sl]
 802fc5a:	2b2a      	cmp	r3, #42	@ 0x2a
 802fc5c:	d015      	beq.n	802fc8a <_svfiprintf_r+0xfa>
 802fc5e:	9a07      	ldr	r2, [sp, #28]
 802fc60:	4654      	mov	r4, sl
 802fc62:	2000      	movs	r0, #0
 802fc64:	f04f 0c0a 	mov.w	ip, #10
 802fc68:	4621      	mov	r1, r4
 802fc6a:	f811 3b01 	ldrb.w	r3, [r1], #1
 802fc6e:	3b30      	subs	r3, #48	@ 0x30
 802fc70:	2b09      	cmp	r3, #9
 802fc72:	d94b      	bls.n	802fd0c <_svfiprintf_r+0x17c>
 802fc74:	b1b0      	cbz	r0, 802fca4 <_svfiprintf_r+0x114>
 802fc76:	9207      	str	r2, [sp, #28]
 802fc78:	e014      	b.n	802fca4 <_svfiprintf_r+0x114>
 802fc7a:	eba0 0308 	sub.w	r3, r0, r8
 802fc7e:	fa09 f303 	lsl.w	r3, r9, r3
 802fc82:	4313      	orrs	r3, r2
 802fc84:	9304      	str	r3, [sp, #16]
 802fc86:	46a2      	mov	sl, r4
 802fc88:	e7d2      	b.n	802fc30 <_svfiprintf_r+0xa0>
 802fc8a:	9b03      	ldr	r3, [sp, #12]
 802fc8c:	1d19      	adds	r1, r3, #4
 802fc8e:	681b      	ldr	r3, [r3, #0]
 802fc90:	9103      	str	r1, [sp, #12]
 802fc92:	2b00      	cmp	r3, #0
 802fc94:	bfbb      	ittet	lt
 802fc96:	425b      	neglt	r3, r3
 802fc98:	f042 0202 	orrlt.w	r2, r2, #2
 802fc9c:	9307      	strge	r3, [sp, #28]
 802fc9e:	9307      	strlt	r3, [sp, #28]
 802fca0:	bfb8      	it	lt
 802fca2:	9204      	strlt	r2, [sp, #16]
 802fca4:	7823      	ldrb	r3, [r4, #0]
 802fca6:	2b2e      	cmp	r3, #46	@ 0x2e
 802fca8:	d10a      	bne.n	802fcc0 <_svfiprintf_r+0x130>
 802fcaa:	7863      	ldrb	r3, [r4, #1]
 802fcac:	2b2a      	cmp	r3, #42	@ 0x2a
 802fcae:	d132      	bne.n	802fd16 <_svfiprintf_r+0x186>
 802fcb0:	9b03      	ldr	r3, [sp, #12]
 802fcb2:	1d1a      	adds	r2, r3, #4
 802fcb4:	681b      	ldr	r3, [r3, #0]
 802fcb6:	9203      	str	r2, [sp, #12]
 802fcb8:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802fcbc:	3402      	adds	r4, #2
 802fcbe:	9305      	str	r3, [sp, #20]
 802fcc0:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 802fd84 <_svfiprintf_r+0x1f4>
 802fcc4:	7821      	ldrb	r1, [r4, #0]
 802fcc6:	2203      	movs	r2, #3
 802fcc8:	4650      	mov	r0, sl
 802fcca:	f7d0 fa81 	bl	80001d0 <memchr>
 802fcce:	b138      	cbz	r0, 802fce0 <_svfiprintf_r+0x150>
 802fcd0:	9b04      	ldr	r3, [sp, #16]
 802fcd2:	eba0 000a 	sub.w	r0, r0, sl
 802fcd6:	2240      	movs	r2, #64	@ 0x40
 802fcd8:	4082      	lsls	r2, r0
 802fcda:	4313      	orrs	r3, r2
 802fcdc:	3401      	adds	r4, #1
 802fcde:	9304      	str	r3, [sp, #16]
 802fce0:	f814 1b01 	ldrb.w	r1, [r4], #1
 802fce4:	4824      	ldr	r0, [pc, #144]	@ (802fd78 <_svfiprintf_r+0x1e8>)
 802fce6:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802fcea:	2206      	movs	r2, #6
 802fcec:	f7d0 fa70 	bl	80001d0 <memchr>
 802fcf0:	2800      	cmp	r0, #0
 802fcf2:	d036      	beq.n	802fd62 <_svfiprintf_r+0x1d2>
 802fcf4:	4b21      	ldr	r3, [pc, #132]	@ (802fd7c <_svfiprintf_r+0x1ec>)
 802fcf6:	bb1b      	cbnz	r3, 802fd40 <_svfiprintf_r+0x1b0>
 802fcf8:	9b03      	ldr	r3, [sp, #12]
 802fcfa:	3307      	adds	r3, #7
 802fcfc:	f023 0307 	bic.w	r3, r3, #7
 802fd00:	3308      	adds	r3, #8
 802fd02:	9303      	str	r3, [sp, #12]
 802fd04:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802fd06:	4433      	add	r3, r6
 802fd08:	9309      	str	r3, [sp, #36]	@ 0x24
 802fd0a:	e76a      	b.n	802fbe2 <_svfiprintf_r+0x52>
 802fd0c:	fb0c 3202 	mla	r2, ip, r2, r3
 802fd10:	460c      	mov	r4, r1
 802fd12:	2001      	movs	r0, #1
 802fd14:	e7a8      	b.n	802fc68 <_svfiprintf_r+0xd8>
 802fd16:	2300      	movs	r3, #0
 802fd18:	3401      	adds	r4, #1
 802fd1a:	9305      	str	r3, [sp, #20]
 802fd1c:	4619      	mov	r1, r3
 802fd1e:	f04f 0c0a 	mov.w	ip, #10
 802fd22:	4620      	mov	r0, r4
 802fd24:	f810 2b01 	ldrb.w	r2, [r0], #1
 802fd28:	3a30      	subs	r2, #48	@ 0x30
 802fd2a:	2a09      	cmp	r2, #9
 802fd2c:	d903      	bls.n	802fd36 <_svfiprintf_r+0x1a6>
 802fd2e:	2b00      	cmp	r3, #0
 802fd30:	d0c6      	beq.n	802fcc0 <_svfiprintf_r+0x130>
 802fd32:	9105      	str	r1, [sp, #20]
 802fd34:	e7c4      	b.n	802fcc0 <_svfiprintf_r+0x130>
 802fd36:	fb0c 2101 	mla	r1, ip, r1, r2
 802fd3a:	4604      	mov	r4, r0
 802fd3c:	2301      	movs	r3, #1
 802fd3e:	e7f0      	b.n	802fd22 <_svfiprintf_r+0x192>
 802fd40:	ab03      	add	r3, sp, #12
 802fd42:	9300      	str	r3, [sp, #0]
 802fd44:	462a      	mov	r2, r5
 802fd46:	4b0e      	ldr	r3, [pc, #56]	@ (802fd80 <_svfiprintf_r+0x1f0>)
 802fd48:	a904      	add	r1, sp, #16
 802fd4a:	4638      	mov	r0, r7
 802fd4c:	f3af 8000 	nop.w
 802fd50:	1c42      	adds	r2, r0, #1
 802fd52:	4606      	mov	r6, r0
 802fd54:	d1d6      	bne.n	802fd04 <_svfiprintf_r+0x174>
 802fd56:	89ab      	ldrh	r3, [r5, #12]
 802fd58:	065b      	lsls	r3, r3, #25
 802fd5a:	f53f af2d 	bmi.w	802fbb8 <_svfiprintf_r+0x28>
 802fd5e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802fd60:	e72c      	b.n	802fbbc <_svfiprintf_r+0x2c>
 802fd62:	ab03      	add	r3, sp, #12
 802fd64:	9300      	str	r3, [sp, #0]
 802fd66:	462a      	mov	r2, r5
 802fd68:	4b05      	ldr	r3, [pc, #20]	@ (802fd80 <_svfiprintf_r+0x1f0>)
 802fd6a:	a904      	add	r1, sp, #16
 802fd6c:	4638      	mov	r0, r7
 802fd6e:	f000 f879 	bl	802fe64 <_printf_i>
 802fd72:	e7ed      	b.n	802fd50 <_svfiprintf_r+0x1c0>
 802fd74:	08032c3c 	.word	0x08032c3c
 802fd78:	08032c46 	.word	0x08032c46
 802fd7c:	00000000 	.word	0x00000000
 802fd80:	0802fad9 	.word	0x0802fad9
 802fd84:	08032c42 	.word	0x08032c42

0802fd88 <_printf_common>:
 802fd88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802fd8c:	4616      	mov	r6, r2
 802fd8e:	4698      	mov	r8, r3
 802fd90:	688a      	ldr	r2, [r1, #8]
 802fd92:	690b      	ldr	r3, [r1, #16]
 802fd94:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802fd98:	4293      	cmp	r3, r2
 802fd9a:	bfb8      	it	lt
 802fd9c:	4613      	movlt	r3, r2
 802fd9e:	6033      	str	r3, [r6, #0]
 802fda0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 802fda4:	4607      	mov	r7, r0
 802fda6:	460c      	mov	r4, r1
 802fda8:	b10a      	cbz	r2, 802fdae <_printf_common+0x26>
 802fdaa:	3301      	adds	r3, #1
 802fdac:	6033      	str	r3, [r6, #0]
 802fdae:	6823      	ldr	r3, [r4, #0]
 802fdb0:	0699      	lsls	r1, r3, #26
 802fdb2:	bf42      	ittt	mi
 802fdb4:	6833      	ldrmi	r3, [r6, #0]
 802fdb6:	3302      	addmi	r3, #2
 802fdb8:	6033      	strmi	r3, [r6, #0]
 802fdba:	6825      	ldr	r5, [r4, #0]
 802fdbc:	f015 0506 	ands.w	r5, r5, #6
 802fdc0:	d106      	bne.n	802fdd0 <_printf_common+0x48>
 802fdc2:	f104 0a19 	add.w	sl, r4, #25
 802fdc6:	68e3      	ldr	r3, [r4, #12]
 802fdc8:	6832      	ldr	r2, [r6, #0]
 802fdca:	1a9b      	subs	r3, r3, r2
 802fdcc:	42ab      	cmp	r3, r5
 802fdce:	dc26      	bgt.n	802fe1e <_printf_common+0x96>
 802fdd0:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 802fdd4:	6822      	ldr	r2, [r4, #0]
 802fdd6:	3b00      	subs	r3, #0
 802fdd8:	bf18      	it	ne
 802fdda:	2301      	movne	r3, #1
 802fddc:	0692      	lsls	r2, r2, #26
 802fdde:	d42b      	bmi.n	802fe38 <_printf_common+0xb0>
 802fde0:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 802fde4:	4641      	mov	r1, r8
 802fde6:	4638      	mov	r0, r7
 802fde8:	47c8      	blx	r9
 802fdea:	3001      	adds	r0, #1
 802fdec:	d01e      	beq.n	802fe2c <_printf_common+0xa4>
 802fdee:	6823      	ldr	r3, [r4, #0]
 802fdf0:	6922      	ldr	r2, [r4, #16]
 802fdf2:	f003 0306 	and.w	r3, r3, #6
 802fdf6:	2b04      	cmp	r3, #4
 802fdf8:	bf02      	ittt	eq
 802fdfa:	68e5      	ldreq	r5, [r4, #12]
 802fdfc:	6833      	ldreq	r3, [r6, #0]
 802fdfe:	1aed      	subeq	r5, r5, r3
 802fe00:	68a3      	ldr	r3, [r4, #8]
 802fe02:	bf0c      	ite	eq
 802fe04:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802fe08:	2500      	movne	r5, #0
 802fe0a:	4293      	cmp	r3, r2
 802fe0c:	bfc4      	itt	gt
 802fe0e:	1a9b      	subgt	r3, r3, r2
 802fe10:	18ed      	addgt	r5, r5, r3
 802fe12:	2600      	movs	r6, #0
 802fe14:	341a      	adds	r4, #26
 802fe16:	42b5      	cmp	r5, r6
 802fe18:	d11a      	bne.n	802fe50 <_printf_common+0xc8>
 802fe1a:	2000      	movs	r0, #0
 802fe1c:	e008      	b.n	802fe30 <_printf_common+0xa8>
 802fe1e:	2301      	movs	r3, #1
 802fe20:	4652      	mov	r2, sl
 802fe22:	4641      	mov	r1, r8
 802fe24:	4638      	mov	r0, r7
 802fe26:	47c8      	blx	r9
 802fe28:	3001      	adds	r0, #1
 802fe2a:	d103      	bne.n	802fe34 <_printf_common+0xac>
 802fe2c:	f04f 30ff 	mov.w	r0, #4294967295
 802fe30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802fe34:	3501      	adds	r5, #1
 802fe36:	e7c6      	b.n	802fdc6 <_printf_common+0x3e>
 802fe38:	18e1      	adds	r1, r4, r3
 802fe3a:	1c5a      	adds	r2, r3, #1
 802fe3c:	2030      	movs	r0, #48	@ 0x30
 802fe3e:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 802fe42:	4422      	add	r2, r4
 802fe44:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 802fe48:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 802fe4c:	3302      	adds	r3, #2
 802fe4e:	e7c7      	b.n	802fde0 <_printf_common+0x58>
 802fe50:	2301      	movs	r3, #1
 802fe52:	4622      	mov	r2, r4
 802fe54:	4641      	mov	r1, r8
 802fe56:	4638      	mov	r0, r7
 802fe58:	47c8      	blx	r9
 802fe5a:	3001      	adds	r0, #1
 802fe5c:	d0e6      	beq.n	802fe2c <_printf_common+0xa4>
 802fe5e:	3601      	adds	r6, #1
 802fe60:	e7d9      	b.n	802fe16 <_printf_common+0x8e>
	...

0802fe64 <_printf_i>:
 802fe64:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802fe68:	7e0f      	ldrb	r7, [r1, #24]
 802fe6a:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 802fe6c:	2f78      	cmp	r7, #120	@ 0x78
 802fe6e:	4691      	mov	r9, r2
 802fe70:	4680      	mov	r8, r0
 802fe72:	460c      	mov	r4, r1
 802fe74:	469a      	mov	sl, r3
 802fe76:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802fe7a:	d807      	bhi.n	802fe8c <_printf_i+0x28>
 802fe7c:	2f62      	cmp	r7, #98	@ 0x62
 802fe7e:	d80a      	bhi.n	802fe96 <_printf_i+0x32>
 802fe80:	2f00      	cmp	r7, #0
 802fe82:	f000 80d2 	beq.w	803002a <_printf_i+0x1c6>
 802fe86:	2f58      	cmp	r7, #88	@ 0x58
 802fe88:	f000 80b9 	beq.w	802fffe <_printf_i+0x19a>
 802fe8c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802fe90:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 802fe94:	e03a      	b.n	802ff0c <_printf_i+0xa8>
 802fe96:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802fe9a:	2b15      	cmp	r3, #21
 802fe9c:	d8f6      	bhi.n	802fe8c <_printf_i+0x28>
 802fe9e:	a101      	add	r1, pc, #4	@ (adr r1, 802fea4 <_printf_i+0x40>)
 802fea0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 802fea4:	0802fefd 	.word	0x0802fefd
 802fea8:	0802ff11 	.word	0x0802ff11
 802feac:	0802fe8d 	.word	0x0802fe8d
 802feb0:	0802fe8d 	.word	0x0802fe8d
 802feb4:	0802fe8d 	.word	0x0802fe8d
 802feb8:	0802fe8d 	.word	0x0802fe8d
 802febc:	0802ff11 	.word	0x0802ff11
 802fec0:	0802fe8d 	.word	0x0802fe8d
 802fec4:	0802fe8d 	.word	0x0802fe8d
 802fec8:	0802fe8d 	.word	0x0802fe8d
 802fecc:	0802fe8d 	.word	0x0802fe8d
 802fed0:	08030011 	.word	0x08030011
 802fed4:	0802ff3b 	.word	0x0802ff3b
 802fed8:	0802ffcb 	.word	0x0802ffcb
 802fedc:	0802fe8d 	.word	0x0802fe8d
 802fee0:	0802fe8d 	.word	0x0802fe8d
 802fee4:	08030033 	.word	0x08030033
 802fee8:	0802fe8d 	.word	0x0802fe8d
 802feec:	0802ff3b 	.word	0x0802ff3b
 802fef0:	0802fe8d 	.word	0x0802fe8d
 802fef4:	0802fe8d 	.word	0x0802fe8d
 802fef8:	0802ffd3 	.word	0x0802ffd3
 802fefc:	6833      	ldr	r3, [r6, #0]
 802fefe:	1d1a      	adds	r2, r3, #4
 802ff00:	681b      	ldr	r3, [r3, #0]
 802ff02:	6032      	str	r2, [r6, #0]
 802ff04:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802ff08:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 802ff0c:	2301      	movs	r3, #1
 802ff0e:	e09d      	b.n	803004c <_printf_i+0x1e8>
 802ff10:	6833      	ldr	r3, [r6, #0]
 802ff12:	6820      	ldr	r0, [r4, #0]
 802ff14:	1d19      	adds	r1, r3, #4
 802ff16:	6031      	str	r1, [r6, #0]
 802ff18:	0606      	lsls	r6, r0, #24
 802ff1a:	d501      	bpl.n	802ff20 <_printf_i+0xbc>
 802ff1c:	681d      	ldr	r5, [r3, #0]
 802ff1e:	e003      	b.n	802ff28 <_printf_i+0xc4>
 802ff20:	0645      	lsls	r5, r0, #25
 802ff22:	d5fb      	bpl.n	802ff1c <_printf_i+0xb8>
 802ff24:	f9b3 5000 	ldrsh.w	r5, [r3]
 802ff28:	2d00      	cmp	r5, #0
 802ff2a:	da03      	bge.n	802ff34 <_printf_i+0xd0>
 802ff2c:	232d      	movs	r3, #45	@ 0x2d
 802ff2e:	426d      	negs	r5, r5
 802ff30:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 802ff34:	4859      	ldr	r0, [pc, #356]	@ (803009c <_printf_i+0x238>)
 802ff36:	230a      	movs	r3, #10
 802ff38:	e011      	b.n	802ff5e <_printf_i+0xfa>
 802ff3a:	6821      	ldr	r1, [r4, #0]
 802ff3c:	6833      	ldr	r3, [r6, #0]
 802ff3e:	0608      	lsls	r0, r1, #24
 802ff40:	f853 5b04 	ldr.w	r5, [r3], #4
 802ff44:	d402      	bmi.n	802ff4c <_printf_i+0xe8>
 802ff46:	0649      	lsls	r1, r1, #25
 802ff48:	bf48      	it	mi
 802ff4a:	b2ad      	uxthmi	r5, r5
 802ff4c:	2f6f      	cmp	r7, #111	@ 0x6f
 802ff4e:	4853      	ldr	r0, [pc, #332]	@ (803009c <_printf_i+0x238>)
 802ff50:	6033      	str	r3, [r6, #0]
 802ff52:	bf14      	ite	ne
 802ff54:	230a      	movne	r3, #10
 802ff56:	2308      	moveq	r3, #8
 802ff58:	2100      	movs	r1, #0
 802ff5a:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 802ff5e:	6866      	ldr	r6, [r4, #4]
 802ff60:	60a6      	str	r6, [r4, #8]
 802ff62:	2e00      	cmp	r6, #0
 802ff64:	bfa2      	ittt	ge
 802ff66:	6821      	ldrge	r1, [r4, #0]
 802ff68:	f021 0104 	bicge.w	r1, r1, #4
 802ff6c:	6021      	strge	r1, [r4, #0]
 802ff6e:	b90d      	cbnz	r5, 802ff74 <_printf_i+0x110>
 802ff70:	2e00      	cmp	r6, #0
 802ff72:	d04b      	beq.n	803000c <_printf_i+0x1a8>
 802ff74:	4616      	mov	r6, r2
 802ff76:	fbb5 f1f3 	udiv	r1, r5, r3
 802ff7a:	fb03 5711 	mls	r7, r3, r1, r5
 802ff7e:	5dc7      	ldrb	r7, [r0, r7]
 802ff80:	f806 7d01 	strb.w	r7, [r6, #-1]!
 802ff84:	462f      	mov	r7, r5
 802ff86:	42bb      	cmp	r3, r7
 802ff88:	460d      	mov	r5, r1
 802ff8a:	d9f4      	bls.n	802ff76 <_printf_i+0x112>
 802ff8c:	2b08      	cmp	r3, #8
 802ff8e:	d10b      	bne.n	802ffa8 <_printf_i+0x144>
 802ff90:	6823      	ldr	r3, [r4, #0]
 802ff92:	07df      	lsls	r7, r3, #31
 802ff94:	d508      	bpl.n	802ffa8 <_printf_i+0x144>
 802ff96:	6923      	ldr	r3, [r4, #16]
 802ff98:	6861      	ldr	r1, [r4, #4]
 802ff9a:	4299      	cmp	r1, r3
 802ff9c:	bfde      	ittt	le
 802ff9e:	2330      	movle	r3, #48	@ 0x30
 802ffa0:	f806 3c01 	strble.w	r3, [r6, #-1]
 802ffa4:	f106 36ff 	addle.w	r6, r6, #4294967295
 802ffa8:	1b92      	subs	r2, r2, r6
 802ffaa:	6122      	str	r2, [r4, #16]
 802ffac:	f8cd a000 	str.w	sl, [sp]
 802ffb0:	464b      	mov	r3, r9
 802ffb2:	aa03      	add	r2, sp, #12
 802ffb4:	4621      	mov	r1, r4
 802ffb6:	4640      	mov	r0, r8
 802ffb8:	f7ff fee6 	bl	802fd88 <_printf_common>
 802ffbc:	3001      	adds	r0, #1
 802ffbe:	d14a      	bne.n	8030056 <_printf_i+0x1f2>
 802ffc0:	f04f 30ff 	mov.w	r0, #4294967295
 802ffc4:	b004      	add	sp, #16
 802ffc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802ffca:	6823      	ldr	r3, [r4, #0]
 802ffcc:	f043 0320 	orr.w	r3, r3, #32
 802ffd0:	6023      	str	r3, [r4, #0]
 802ffd2:	4833      	ldr	r0, [pc, #204]	@ (80300a0 <_printf_i+0x23c>)
 802ffd4:	2778      	movs	r7, #120	@ 0x78
 802ffd6:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 802ffda:	6823      	ldr	r3, [r4, #0]
 802ffdc:	6831      	ldr	r1, [r6, #0]
 802ffde:	061f      	lsls	r7, r3, #24
 802ffe0:	f851 5b04 	ldr.w	r5, [r1], #4
 802ffe4:	d402      	bmi.n	802ffec <_printf_i+0x188>
 802ffe6:	065f      	lsls	r7, r3, #25
 802ffe8:	bf48      	it	mi
 802ffea:	b2ad      	uxthmi	r5, r5
 802ffec:	6031      	str	r1, [r6, #0]
 802ffee:	07d9      	lsls	r1, r3, #31
 802fff0:	bf44      	itt	mi
 802fff2:	f043 0320 	orrmi.w	r3, r3, #32
 802fff6:	6023      	strmi	r3, [r4, #0]
 802fff8:	b11d      	cbz	r5, 8030002 <_printf_i+0x19e>
 802fffa:	2310      	movs	r3, #16
 802fffc:	e7ac      	b.n	802ff58 <_printf_i+0xf4>
 802fffe:	4827      	ldr	r0, [pc, #156]	@ (803009c <_printf_i+0x238>)
 8030000:	e7e9      	b.n	802ffd6 <_printf_i+0x172>
 8030002:	6823      	ldr	r3, [r4, #0]
 8030004:	f023 0320 	bic.w	r3, r3, #32
 8030008:	6023      	str	r3, [r4, #0]
 803000a:	e7f6      	b.n	802fffa <_printf_i+0x196>
 803000c:	4616      	mov	r6, r2
 803000e:	e7bd      	b.n	802ff8c <_printf_i+0x128>
 8030010:	6833      	ldr	r3, [r6, #0]
 8030012:	6825      	ldr	r5, [r4, #0]
 8030014:	6961      	ldr	r1, [r4, #20]
 8030016:	1d18      	adds	r0, r3, #4
 8030018:	6030      	str	r0, [r6, #0]
 803001a:	062e      	lsls	r6, r5, #24
 803001c:	681b      	ldr	r3, [r3, #0]
 803001e:	d501      	bpl.n	8030024 <_printf_i+0x1c0>
 8030020:	6019      	str	r1, [r3, #0]
 8030022:	e002      	b.n	803002a <_printf_i+0x1c6>
 8030024:	0668      	lsls	r0, r5, #25
 8030026:	d5fb      	bpl.n	8030020 <_printf_i+0x1bc>
 8030028:	8019      	strh	r1, [r3, #0]
 803002a:	2300      	movs	r3, #0
 803002c:	6123      	str	r3, [r4, #16]
 803002e:	4616      	mov	r6, r2
 8030030:	e7bc      	b.n	802ffac <_printf_i+0x148>
 8030032:	6833      	ldr	r3, [r6, #0]
 8030034:	1d1a      	adds	r2, r3, #4
 8030036:	6032      	str	r2, [r6, #0]
 8030038:	681e      	ldr	r6, [r3, #0]
 803003a:	6862      	ldr	r2, [r4, #4]
 803003c:	2100      	movs	r1, #0
 803003e:	4630      	mov	r0, r6
 8030040:	f7d0 f8c6 	bl	80001d0 <memchr>
 8030044:	b108      	cbz	r0, 803004a <_printf_i+0x1e6>
 8030046:	1b80      	subs	r0, r0, r6
 8030048:	6060      	str	r0, [r4, #4]
 803004a:	6863      	ldr	r3, [r4, #4]
 803004c:	6123      	str	r3, [r4, #16]
 803004e:	2300      	movs	r3, #0
 8030050:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8030054:	e7aa      	b.n	802ffac <_printf_i+0x148>
 8030056:	6923      	ldr	r3, [r4, #16]
 8030058:	4632      	mov	r2, r6
 803005a:	4649      	mov	r1, r9
 803005c:	4640      	mov	r0, r8
 803005e:	47d0      	blx	sl
 8030060:	3001      	adds	r0, #1
 8030062:	d0ad      	beq.n	802ffc0 <_printf_i+0x15c>
 8030064:	6823      	ldr	r3, [r4, #0]
 8030066:	079b      	lsls	r3, r3, #30
 8030068:	d413      	bmi.n	8030092 <_printf_i+0x22e>
 803006a:	68e0      	ldr	r0, [r4, #12]
 803006c:	9b03      	ldr	r3, [sp, #12]
 803006e:	4298      	cmp	r0, r3
 8030070:	bfb8      	it	lt
 8030072:	4618      	movlt	r0, r3
 8030074:	e7a6      	b.n	802ffc4 <_printf_i+0x160>
 8030076:	2301      	movs	r3, #1
 8030078:	4632      	mov	r2, r6
 803007a:	4649      	mov	r1, r9
 803007c:	4640      	mov	r0, r8
 803007e:	47d0      	blx	sl
 8030080:	3001      	adds	r0, #1
 8030082:	d09d      	beq.n	802ffc0 <_printf_i+0x15c>
 8030084:	3501      	adds	r5, #1
 8030086:	68e3      	ldr	r3, [r4, #12]
 8030088:	9903      	ldr	r1, [sp, #12]
 803008a:	1a5b      	subs	r3, r3, r1
 803008c:	42ab      	cmp	r3, r5
 803008e:	dcf2      	bgt.n	8030076 <_printf_i+0x212>
 8030090:	e7eb      	b.n	803006a <_printf_i+0x206>
 8030092:	2500      	movs	r5, #0
 8030094:	f104 0619 	add.w	r6, r4, #25
 8030098:	e7f5      	b.n	8030086 <_printf_i+0x222>
 803009a:	bf00      	nop
 803009c:	08032c4d 	.word	0x08032c4d
 80300a0:	08032c5e 	.word	0x08032c5e

080300a4 <memmove>:
 80300a4:	4288      	cmp	r0, r1
 80300a6:	b510      	push	{r4, lr}
 80300a8:	eb01 0402 	add.w	r4, r1, r2
 80300ac:	d902      	bls.n	80300b4 <memmove+0x10>
 80300ae:	4284      	cmp	r4, r0
 80300b0:	4623      	mov	r3, r4
 80300b2:	d807      	bhi.n	80300c4 <memmove+0x20>
 80300b4:	1e43      	subs	r3, r0, #1
 80300b6:	42a1      	cmp	r1, r4
 80300b8:	d008      	beq.n	80300cc <memmove+0x28>
 80300ba:	f811 2b01 	ldrb.w	r2, [r1], #1
 80300be:	f803 2f01 	strb.w	r2, [r3, #1]!
 80300c2:	e7f8      	b.n	80300b6 <memmove+0x12>
 80300c4:	4402      	add	r2, r0
 80300c6:	4601      	mov	r1, r0
 80300c8:	428a      	cmp	r2, r1
 80300ca:	d100      	bne.n	80300ce <memmove+0x2a>
 80300cc:	bd10      	pop	{r4, pc}
 80300ce:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80300d2:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80300d6:	e7f7      	b.n	80300c8 <memmove+0x24>

080300d8 <_realloc_r>:
 80300d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80300dc:	4680      	mov	r8, r0
 80300de:	4615      	mov	r5, r2
 80300e0:	460c      	mov	r4, r1
 80300e2:	b921      	cbnz	r1, 80300ee <_realloc_r+0x16>
 80300e4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80300e8:	4611      	mov	r1, r2
 80300ea:	f7ff bbad 	b.w	802f848 <_malloc_r>
 80300ee:	b92a      	cbnz	r2, 80300fc <_realloc_r+0x24>
 80300f0:	f7ff fca8 	bl	802fa44 <_free_r>
 80300f4:	2400      	movs	r4, #0
 80300f6:	4620      	mov	r0, r4
 80300f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80300fc:	f000 f81a 	bl	8030134 <_malloc_usable_size_r>
 8030100:	4285      	cmp	r5, r0
 8030102:	4606      	mov	r6, r0
 8030104:	d802      	bhi.n	803010c <_realloc_r+0x34>
 8030106:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 803010a:	d8f4      	bhi.n	80300f6 <_realloc_r+0x1e>
 803010c:	4629      	mov	r1, r5
 803010e:	4640      	mov	r0, r8
 8030110:	f7ff fb9a 	bl	802f848 <_malloc_r>
 8030114:	4607      	mov	r7, r0
 8030116:	2800      	cmp	r0, #0
 8030118:	d0ec      	beq.n	80300f4 <_realloc_r+0x1c>
 803011a:	42b5      	cmp	r5, r6
 803011c:	462a      	mov	r2, r5
 803011e:	4621      	mov	r1, r4
 8030120:	bf28      	it	cs
 8030122:	4632      	movcs	r2, r6
 8030124:	f7ff fc80 	bl	802fa28 <memcpy>
 8030128:	4621      	mov	r1, r4
 803012a:	4640      	mov	r0, r8
 803012c:	f7ff fc8a 	bl	802fa44 <_free_r>
 8030130:	463c      	mov	r4, r7
 8030132:	e7e0      	b.n	80300f6 <_realloc_r+0x1e>

08030134 <_malloc_usable_size_r>:
 8030134:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8030138:	1f18      	subs	r0, r3, #4
 803013a:	2b00      	cmp	r3, #0
 803013c:	bfbc      	itt	lt
 803013e:	580b      	ldrlt	r3, [r1, r0]
 8030140:	18c0      	addlt	r0, r0, r3
 8030142:	4770      	bx	lr

08030144 <_init>:
 8030144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030146:	bf00      	nop
 8030148:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803014a:	bc08      	pop	{r3}
 803014c:	469e      	mov	lr, r3
 803014e:	4770      	bx	lr

08030150 <_fini>:
 8030150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030152:	bf00      	nop
 8030154:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8030156:	bc08      	pop	{r3}
 8030158:	469e      	mov	lr, r3
 803015a:	4770      	bx	lr
